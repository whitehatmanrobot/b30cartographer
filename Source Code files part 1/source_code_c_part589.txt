rns texture format bits shifted to the right place
//
static inline DWORD FVFMakeTextureFormat(DWORD dwNumberOfCoordinates, DWORD dwTextureIndex)
{
    return g_dwTextureFormat[dwNumberOfCoordinates] << ((dwTextureIndex << 1) + 16);
}
//---------------------------------------------------------------------
inline DWORD GetOutTexCoordSize(DWORD *pdwStage, DWORD dwInpTexCoordSize)
{
    // Low byte has texture coordinate count
    const DWORD dwTextureTransformFlags = pdwStage[D3DTSS_TEXTURETRANSFORMFLAGS] & 0xFF;
    if (dwTextureTransformFlags == 0)
        return dwInpTexCoordSize;
    else
        return (dwTextureTransformFlags << 2);
}
//----------------------------------------------------------------------
// pDevI->nOutTexCoord should be initialized to the number of input texture coord sets
//
void EvalTextureTransforms(LPD3DHAL pDevI, DWORD dwTexTransform,
                           DWORD *pdwOutTextureSize, DWORD *pdwOutTextureFormat)
{
    D3DFE_PROCESSVERTICES* pv = pDevI->m_pv;
    DWORD dwOutTextureSize = 0;         // Used to compute output vertex size
    DWORD dwOutTextureFormat = 0;       // Used to compute output texture FVF
    // The bits are used to find out how the texture coordinates are used.
    const DWORD __USED_BY_TRANSFORM  = 1;
    const DWORD __USED               = 2;
    const DWORD __USED_TEXTURE_PROJECTION   = 4;
    // The low 16 bits are for _USED bits. The high 16 bits will hold
    // re-mapped texture index for a stage
    DWORD dwTexCoordUsage[D3DDP_MAXTEXCOORD];
    memset(dwTexCoordUsage, 0, sizeof(dwTexCoordUsage));

    // Re-mapping buffer will contain only stages that use texture
    // This variable is used to count them
    pDevI->dwNumTextureStagesToRemap = 0;
    DWORD dwNewIndex = 0;           // Used to generate output index
    // We need offsets for every input texture coordinate, because
    // we could access them in random order.
    // Offsets are not needed for strided input
    DWORD   dwTextureCoordOffset[D3DDP_MAXTEXCOORD];
    if (!(pv->dwDeviceFlags & D3DDEV_STRIDE))
    {
        ComputeInpTexCoordOffsets(pv->nTexCoord, pv->dwVIDIn, dwTextureCoordOffset);
    }
    DWORD dwOutTextureCoordSize[D3DDP_MAXTEXCOORD];
    // TRUE, if we do not do texture projection and transform for a stage, 
    // because the stage does not have corresponding texture coordinates in the
    // input
    BOOL bIgnoreTexCoord = FALSE;
    // Go through all texture stages and find those wich use texture coordinates
    for (DWORD i=0; i < D3DDP_MAXTEXCOORD; i++)
    {
        if (pDevI->tsstates[i][D3DTSS_COLOROP] == D3DTOP_DISABLE)
            break;

        DWORD dwIndex = pDevI->tsstates[i][D3DTSS_TEXCOORDINDEX];
        DWORD dwInpTextureFormat;
        DWORD dwInpTexSize;
        LPD3DFE_TEXTURESTAGE pStage = &pDevI->textureStageToRemap[pDevI->dwNumTextureStagesToRemap];
        DWORD dwTexGenMode = dwIndex & ~0xFFFF;
        pStage->dwInpOffset = 0;
        dwIndex = dwIndex & 0xFFFF; // Remove texture generation mode
        if (dwTexGenMode == D3DTSS_TCI_CAMERASPACENORMAL ||
            dwTexGenMode == D3DTSS_TCI_CAMERASPACEPOSITION ||
            dwTexGenMode == D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR)
        {
            dwInpTextureFormat = D3DFVF_TEXCOORDSIZE3(dwIndex);
            dwInpTexSize = 3*sizeof(D3DVALUE);
            pv->dwDeviceFlags |= D3DDEV_REMAPTEXTUREINDICES;
            if (dwTexGenMode == D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR)
                pv->dwDeviceFlags |= D3DDEV_NORMALINCAMERASPACE | D3DDEV_POSITIONINCAMERASPACE;
            else
            if (dwTexGenMode == D3DTSS_TCI_CAMERASPACENORMAL)
                pv->dwDeviceFlags |= D3DDEV_NORMALINCAMERASPACE;
            else
            if (dwTexGenMode == D3DTSS_TCI_CAMERASPACEPOSITION)
                pv->dwDeviceFlags |= D3DDEV_POSITIONINCAMERASPACE;
        }
        else
        {
            if (dwIndex >= pv->nTexCoord)
            {
                // This could happen when input vertex does not have texture 
                // coordinates, but it is OK, because texture pointer in the 
                // stage could be  NULL, or the stage does not use texture, or 
                // pixel shader is used.
                // It is too complex and error prone to check all cases when 
                // this is an user error, so we just make this case to work.
                dwIndex = 0;
                dwInpTexSize = sizeof(float)*2; 
                dwInpTextureFormat = 0;
                // Ignore special texture coordinate processing for this stage
                bIgnoreTexCoord = TRUE; 
                // Disable texture transform for the stage
                dwTexTransform &= ~1;
                pStage->dwInpOffset = 0;
            }
            else
            {
                dwInpTexSize = pv->dwTextureCoordSize[dwIndex];
                dwInpTextureFormat = FVFGetTextureFormat(pv->dwVIDIn, dwIndex);
                pStage->dwInpOffset = dwTextureCoordOffset[dwIndex];
            }
        }
        pStage->dwInpCoordIndex = dwIndex;
        pStage->dwTexGenMode = dwTexGenMode;
        pStage->dwOrgStage = i;
        pStage->bDoTextureProjection = FALSE;
        DWORD dwOutTexCoordSize;    // Size of the texture coord set in bytes for this stage
        if (dwTexTransform & 1)
        {
            pv->dwDeviceFlags |= D3DDEV_TEXTURETRANSFORM;
            pStage->pmTextureTransform = &pv->mTexture[i];
            dwOutTexCoordSize = GetOutTexCoordSize((DWORD*)&pDevI->tsstates[i], dwInpTexSize);
            // If we have to add or remove some coordinates we go through
            // the re-mapping path
            if (dwOutTexCoordSize != dwInpTexSize)
                pv->dwDeviceFlags |= D3DDEV_REMAPTEXTUREINDICES;
            pStage->dwTexTransformFuncIndex = MakeTexTransformFuncIndex
                                             (dwInpTexSize >> 2, dwOutTexCoordSize >> 2);
        }
        else
        {
            pStage->pmTextureTransform = NULL;
            dwOutTexCoordSize = dwInpTexSize;
            pStage->dwTexTransformFuncIndex = 0;
        }
        if (NeedTextureProjection(pv, i) && !bIgnoreTexCoord)
        {
            // Remove one float from the output
            dwOutTexCoordSize -= 4; 
            // Set re-mapping so we do not complicate simple case
            pv->dwDeviceFlags |= D3DDEV_REMAPTEXTUREINDICES;
            // Texture projection is required for the stage
            pStage->bDoTextureProjection = TRUE;
        }
        if ((dwTexCoordUsage[dwIndex] & 0xFFFF) == 0)
        {
            // Texture coordinate set is used first time
            if (dwTexTransform & 1)
                dwTexCoordUsage[dwIndex] |= __USED_BY_TRANSFORM;
            dwTexCoordUsage[dwIndex] |= __USED;
            if (pStage->bDoTextureProjection)
                dwTexCoordUsage[dwIndex] |= __USED_TEXTURE_PROJECTION;
        }
        else
        {
            // Texture coordinate set is used second or more time
            if (dwTexTransform & 1)
            {
                // This set is used by two texture transforms or a
                // texture transform and without it, so we have to
                // generate an additional output texture coordinate
                dwTexCoordUsage[dwIndex] |= __USED_BY_TRANSFORM;
                pv->dwDeviceFlags |= D3DDEV_REMAPTEXTUREINDICES;
            }
            else
            {
                if (dwTexCoordUsage[dwIndex] & __USED_BY_TRANSFORM)
                {
                    // This set is used by two texture transforms or a
                    // texture transform and without it, so we have to
                    // generate an additional output texture coordinate
                    pv->dwDeviceFlags |= D3DDEV_REMAPTEXTUREINDICES;
                }
                else
                // We can re-use the same input texture coordinate if there is no 
                // texture generation and texture projection flag is the same for both 
                // stages
                if (dwTexGenMode == 0 && 
                    (pStage->bDoTextureProjection == ((dwTexCoordUsage[dwIndex] & __USED_TEXTURE_PROJECTION) != 0)))
                {
                    DWORD dwOutIndex = dwTexCoordUsage[dwIndex] >> 16;
                    pStage->dwOutCoordIndex = dwOutIndex;
                    // Mark the stage as not to be used in the vertex processing loop
                    pStage->dwInpOffset = 0xFFFFFFFF;
                    goto l_NoNewOutTexCoord;
                }
            }
        }
        // If we are here, we have to generate new output texture coordinate set
        pStage->dwOutCoordIndex = dwNewIndex;
        dwTexCoordUsage[dwIndex] |= dwNewIndex << 16;
        dwOutTextureSize += dwOutTexCoordSize;
        dwOutTextureCoordSize[dwNewIndex] = dwOutTexCoordSize;
        dwOutTextureFormat |= FVFMakeTextureFormat(dwOutTexCoordSize >> 2, dwNewIndex);
        dwNewIndex++;
l_NoNewOutTexCoord:
        pDevI->dwNumTextureStagesToRemap++;
        dwTexTransform >>= 1;
    }
    if (pv->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
    {
        // Now, when we have to do re-mapping, we have to set new output texture
        // coordinate set sizes and we need to remove stages, which do not produce
        // output texture coordinates.
        DWORD dwNumTextureStages = 0;
        for (DWORD i=0; i < pDevI->dwNumTextureStagesToRemap; i++)
        {
            if (pDevI->textureStageToRemap[i].dwInpOffset != 0xFFFFFFFF)
            {
                pv->textureStage[dwNumTextureStages] = pDevI->textureStageToRemap[i];
                pv->dwTextureCoordSize[dwNumTextureStages] = dwOutTextureCoordSize[dwNumTextureStages];
                dwNumTextureStages++;
            }
            pv->dwNumTextureStages = dwNumTextureStages;
        }
        pv->nOutTexCoord = dwNewIndex;
    }
    *pdwOutTextureSize = dwOutTextureSize;
    *pdwOutTextureFormat = dwOutTextureFormat;
}
//----------------------------------------------------------------------
// Sets texture transform pointer for every input texture coordinate set
//
void SetupTextureTransforms(LPD3DHAL pDevI)
{
    D3DFE_PROCESSVERTICES* pv = pDevI->m_pv;
    // Set texture transforms to NULL in case when some texture coordinates
    // are not used by texture stages
    memset(pv->pmTexture, 0, sizeof(pv->pmTexture));

    for (DWORD i=0; i < pDevI->dwNumTextureStagesToRemap; i++)
    {
        LPD3DFE_TEXTURESTAGE pStage = &pDevI->textureStageToRemap[i];
        pv->pmTexture[pStage->dwInpCoordIndex] = pStage->pmTextureTransform;
    }
}
//----------------------------------------------------------------------
// Computes the following device data
//  - dwVIDOut, based on input FVF id and device settings
//  - nTexCoord
//  - dwTextureCoordSizeTotal
//  - dwTextureCoordSize[] array, based on the input FVF id
//  - dwOutputSize, based on the output FVF id
//
// The function is called from ProcessVertices and DrawPrimitives code paths
//
// The following variables should be set in the pDevI:
//  - dwVIDIn
//
// Number of texture coordinates is set based on dwVIDIn. ValidateFVF should
// make sure that it is not greater than supported by the driver
// Last settings for dwVIDOut and dwVIDIn are saved to speed up processing
//
#undef  DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetupFVFDataCommon"

void CD3DHal::SetupFVFDataCommon()
{
    HRESULT ret;
    this->dwFEFlags &= ~D3DFE_FVF_DIRTY;
    // We have to restore texture stage indices if previous primitive
    // re-mapped them
    if (m_pv->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
    {
        RestoreTextureStages(this);
    }

    // Compute number of the input texture coordinates
    m_pv->nTexCoord = FVF_TEXCOORD_NUMBER(m_pv->dwVIDIn);

    // Compute size of input texture coordinates

    m_pv->dwTextureCoordSizeTotal = ComputeTextureCoordSize(m_pv->dwVIDIn,
                                        m_pv->dwInpTextureCoordSize);

    // This size is the same for input and output FVFs in case when we do not have to
    // expand number of texture coordinates
    for (DWORD i=0; i < m_pv->nTexCoord; i++)
        m_pv->dwTextureCoordSize[i] = m_pv->dwInpTextureCoordSize[i];

    m_pv->nOutTexCoord = m_pv->nTexCoord;

    // Setup input vertex offsets
    UpdateGeometryLoopData(m_pv);

    if (FVF_TRANSFORMED(m_pv->dwVIDIn))
    {
        // Set up vertex pointers
        m_pv->dwVIDOut = m_pv->dwVIDIn;
        ComputeOutputVertexOffsets(m_pv);
        m_pv->dwOutputSize = ComputeVertexSizeFVF(m_pv->dwVIDOut);
        return;
    }

    // Compute output FVF

    m_pv->dwVIDOut = D3DFVF_XYZRHW;
    if (m_pv->dwDeviceFlags & D3DDEV_DONOTSTRIPELEMENTS &&
        !(m_pv->dwFlags & D3DPV_VBCALL))
    {
        m_pv->dwVIDOut |= D3DFVF_DIFFUSE | D3DFVF_SPECULAR;
    }
    else
    {
        // If normal present we have to compute specular and duffuse
        // Otherwise set these bits the same as input.
        // Not that normal should not be present for XYZRHW position type
        if (m_pv->dwDeviceFlags & D3DDEV_LIGHTING)
            m_pv->dwVIDOut |= D3DFVF_DIFFUSE | D3DFVF_SPECULAR;
        else
            m_pv->dwVIDOut |= m_pv->dwVIDIn &
                              (D3DFVF_DIFFUSE | D3DFVF_SPECULAR);
        // Always set specular flag if vertex fog is enabled
        if (this->rstates[D3DRENDERSTATE_FOGENABLE] &&
            m_pv->lighting.fog_mode != D3DFOG_NONE)
        {
            m_pv->dwVIDOut |= D3DFVF_SPECULAR;
        }
        else
        // Clear specular flag if specular disabled and we do not have
        // specular in the input
        if (!this->rstates[D3DRENDERSTATE_SPECULARENABLE] &&
            !(m_pv->dwVIDIn & D3DFVF_SPECULAR))
        {
            m_pv->dwVIDOut &= ~D3DFVF_SPECULAR;
        }
    }
    if (m_pv->dwVIDIn & D3DFVF_PSIZE ||
        m_pv->primType == D3DPT_POINTLIST &&
        this->rstates[D3DRS_POINTSCALEENABLE])
    {
        m_pv->dwVIDOut |= D3DFVF_PSIZE;
    }

    // Compute number of the output texture coordinates

    // Transform enable bits
    m_pv->dwDeviceFlags &= ~D3DDEV_TEXTURETRANSFORM;

    DWORD dwTexTransform = m_pv->dwFlags2 & __FLAGS2_TEXTRANSFORM;

    // When texture transform is enabled or we need to do projected texture 
    // emulation or texture coordinates are taken from the vertex data (texgen),
    // output texture coordinates could be generated.
    // So we go and evaluate texture stages
    if ((m_pv->dwFlags2 & (__FLAGS2_TEXTRANSFORM | __FLAGS2_TEXPROJ) 
        && (m_pv->nTexCoord > 0)) ||
        m_pv->dwFlags2 & __FLAGS2_TEXGEN)
    {
        DWORD dwOutTextureSize;     // Used to compute output vertex size
        DWORD dwOutTextureFormat;   // Used to compute output texture FVF
        // There are texture transforms.
        // Now we find out if some of the texture coordinates are used two
        // or more times and used by a texture transform. In this case we
        // have expand number of output texture coordinates.
        EvalTextureTransforms(this, dwTexTransform,
                                    &dwOutTextureSize,
                                    &dwOutTextureFormat);
        if (m_pv->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
        {
            // For ProcessVertices calls user should set texture stages and
            // wrap modes himself
            if (!(m_pv->dwFlags & D3DPV_VBCALL))
            {
                // dwVIDIn is used to force re-compute FVF in the
                // SetTextureStageState. so we save and restore it.
                DWORD dwVIDInSaved = m_pv->dwVIDIn;
                // Re-map indices in the texture stages and wrap modes
                DWORD dwOrgWrapModes[D3DDP_MAXTEXCOORD];
                memcpy(dwOrgWrapModes, &this->rstates[D3DRENDERSTATE_WRAP0],
                       sizeof(dwOrgWrapModes));
                for (DWORD i=0; i < this->dwNumTextureStagesToRemap; i++)
                {
                    LPD3DFE_TEXTURESTAGE pStage = &this->textureStageToRemap[i];
                    DWORD dwOutIndex = pStage->dwOutCoordIndex;
                    DWORD dwInpIndex = pStage->dwInpCoordIndex;
                    if (dwOutIndex != dwInpIndex || pStage->dwTexGenMode)
                    {
                        DWORD dwState = D3DRENDERSTATE_WRAP0 + dwOutIndex;
                        pStage->dwOrgWrapMode = dwOrgWrapModes[dwOutIndex];
                        DWORD dwValue = dwOrgWrapModes[dwInpIndex];
                        // We do not call UpdateInternaState because it
                        // will call ForceRecomputeFVF and we do not want this.
                        this->rstates[dwState] = dwValue;

                        m_pDDI->SetRenderState((D3DRENDERSTATETYPE)dwState, dwValue);

                        // We do not call UpdateInternalTextureStageState because it
                        // will call ForceRecomputeFVF and we do not want this.
                        m_pDDI->SetTSS(pStage->dwOrgStage, D3DTSS_TEXCOORDINDEX, dwOutIndex);
                        // We do not call UpdateInternalTextureStageState because it
                        // will call ForceRecomputeFVF and we do not want this.
                        // We set some invalid value to the internal array, because otherwise
                        // a new SetTextureStageState could be filtered as redundant
                        tsstates[pStage->dwOrgStage][D3DTSS_TEXCOORDINDEX] = 0xFFFFFFFF;
                    }
                }
                m_pv->dwVIDIn = dwVIDInSaved;
            }
            else
            {
            }
            m_pv->dwVIDOut |= dwOutTextureFormat;
            m_pv->dwTextureCoordSizeTotal = dwOutTextureSize;
        }
        else
        {   // We do not do re-mapping but we have to make correspondence between
            // texture sets and texture transforms
            SetupTextureTransforms(this);

            //  Copy input texture formats
            m_pv->dwVIDOut |= m_pv->dwVIDIn & 0xFFFF0000;
        }
    }
    else
    {
        //  Copy input texture formats
        m_pv->dwVIDOut |= m_pv->dwVIDIn & 0xFFFF0000;
        // When we have texture coordinate set with number of floats different
        // from 2 and device does not support them, we "fix" the texture format
        if (m_pv->dwVIDOut & 0xFFFF0000)
        {
            if (m_dwRuntimeFlags & D3DRT_ONLY2FLOATSPERTEXTURE)
            {
                m_pv->dwVIDOut &= ~0xFFFF0000;
                for (DWORD i=0; i < m_pv->nOutTexCoord; i++)
                    m_pv->dwTextureCoordSize[i] = 8;
                m_pv->dwTextureCoordSizeTotal = m_pv->nTexCoord * 8;
            }
        }
    }

    if (m_pv->dwDeviceFlags & D3DDEV_DONOTSTRIPELEMENTS)
    {
        if (m_pv->nOutTexCoord == 0 && !(m_pv->dwFlags & D3DPV_VBCALL))
        {
            m_pv->dwTextureCoordSize[0] = 0;
            m_pv->dwVIDOut |= (1 << D3DFVF_TEXCOUNT_SHIFT);
        }
    }
    // Set up number of output texture coordinates
    m_pv->dwVIDOut |= (m_pv->nOutTexCoord << D3DFVF_TEXCOUNT_SHIFT);
    if ((m_pv->dwVIDOut & 0xFFFF0000) &&
        (GetDDIType() < D3DDDITYPE_DX7))
    {
        D3D_THROW_FAIL("Texture format bits in the output FVF for this device should be 0");
    }

    if (!(m_pv->dwFlags & D3DPV_VBCALL))
    {
        m_pv->dwOutputSize = ComputeVertexSizeFVF(m_pv->dwVIDOut);
        ComputeOutputVertexOffsets(m_pv);
    }


    // In case if COLORVERTEX is TRUE, the vertexAlpha could be overriden
    // by vertex alpha
    m_pv->lighting.alpha = (DWORD)m_pv->lighting.materialAlpha;
    m_pv->lighting.alphaSpecular = (DWORD)m_pv->lighting.materialAlphaS;

    this->dwFEFlags |= D3DFE_VERTEXBLEND_DIRTY | D3DFE_FRONTEND_DIRTY;
}
//-----------------------------------------------------------------------------
// Sets input vertex pointers and output offsets for legacy vertex shaders for
// the programmable vertex shaders
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::PrepareToDrawVVM"

void CD3DHal::PrepareToDrawVVM(UINT StartVertex)
{
    if (m_dwRuntimeFlags & D3DRT_SHADERDIRTY)
    {
        SetupFVFDataVVM(this);
        m_dwRuntimeFlags &= ~D3DRT_SHADERDIRTY;
        m_pDDI->SetVertexShader(m_pv->dwVIDOut);
    }
    // Initialize vertex pointers used in the vertex loop
    CVertexDesc* pVD = m_pv->VertexDesc;
    for (DWORD i = m_pv->dwNumUsedVertexDescs; i; i--)
    {
        CVStream* pStream = pVD->pStream;
        DWORD dwStride = pStream->m_dwStride;
        pVD->pMemory = pStream->Data() + pVD->dwVertexOffset +
                       StartVertex * dwStride;
        pVD->dwStride = dwStride;
        pVD++;
    }
}
//-----------------------------------------------------------------------------
// Sets input vertex pointers and output offsets for legacy vertex shaders
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::PrepareToDrawLegacy"

void CD3DHal::PrepareToDrawLegacy(UINT StartVertex)
{
    // For legacy FVFs we draw using Stream[0]
    m_pv->position.lpvData = m_pStream[0].Data() +
                             m_pStream[0].m_dwStride * StartVertex;
    if (m_dwRuntimeFlags & D3DRT_SHADERDIRTY)
    {
        SetupFVFData();
        m_pDDI->SetVertexShader(m_pv->dwVIDOut);
        m_dwRuntimeFlags &= ~D3DRT_SHADERDIRTY;
    }
}
//-----------------------------------------------------------------------------
// Sets input vertex pointers and output offsets for the fixed-function pipeline
// and non-legacy vertex declarations
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::PrepareToDraw"

void CD3DHal::PrepareToDraw(UINT StartVertex)
{
    // Initialize strided data pointers used in the vertex loop
#if DBG
    {
        // Set all NULL pointers to check if they are initialized by the 
        // declaration
        for (DWORD i=0; i < __NUMELEMENTS; i++)
        {
            m_pv->elements[i].lpvData = NULL;
        }
    }
#endif
    CVertexDesc* pVD = m_pv->VertexDesc;
    for (DWORD i = m_pv->dwNumUsedVertexDescs; i; i--)
    {
        CVStream* pStream = pVD->pStream;
        DWORD dwStride = pStream->m_dwStride;
        pVD->pElement->lpvData  = pStream->Data() +
                                  pVD->dwVertexOffset +
                                  StartVertex * dwStride;
        pVD->pElement->dwStride = dwStride;
        pVD++;
    }
    if (m_dwRuntimeFlags & D3DRT_SHADERDIRTY)
    {
        SetupFVFData();
        m_pDDI->SetVertexShader(m_pv->dwVIDOut);
        m_dwRuntimeFlags &= ~D3DRT_SHADERDIRTY;
    }
}
//-----------------------------------------------------------------------------
//
//          Object implementations
//
//---------------------------------------------------------------------
const DWORD CVShader::FIXEDFUNCTION = 1;
const DWORD CVShader::SOFTWARE      = 2;

void CheckForNull(LPVOID p, DWORD line, char* file)
{
    if (p == NULL)
        D3D_THROW_LINE(E_OUTOFMEMORY, "Not enough memory", line, file);
}

//-----------------------------------------------------------------------------
void Copy_FLOAT1(LPVOID pInputStream, UINT stride, UINT count,
                      VVM_WORD * pVertexRegister)
{
    for (UINT i=0; i < count; i++)
    {
        pVertexRegister->x = *(float*)pInputStream;
        pVertexRegister->y = 0;
        pVertexRegister->z = 0;
        pVertexRegister->w = 1;
        pInputStream = (BYTE*)pInputStream + stride;
        pVertexRegister++;
    }
}

void Copy_FLOAT2(LPVOID pInputStream, UINT stride, UINT count,
                      VVM_WORD * pVertexRegister)
{
    for (UINT i=0; i < count; i++)
    {
        pVertexRegister->x = ((float*)pInputStream)[0];
        pVertexRegister->y = ((float*)pInputStream)[1];
        pVertexRegister->z = 0;
        pVertexRegister->w = 1;
        pInputStream = (BYTE*)pInputStream + stride;
        pVertexRegister++;
    }
}

void Copy_FLOAT3(LPVOID pInputStream, UINT stride, UINT count,
                      VVM_WORD * pVertexRegister)
{
    for (UINT i=0; i < count; i++)
    {
        pVertexRegister->x = ((float*)pInputStream)[0];
        pVertexRegister->y = ((float*)pInputStream)[1];
        pVertexRegister->z = ((float*)pInputStream)[2];
        pVertexRegister->w = 1;
        pInputStream = (BYTE*)pInputStream + stride;
        pVertexRegister++;
    }
}

void Copy_FLOAT4(LPVOID pInputStream, UINT stride, UINT count,
                      VVM_WORD * pVertexRegister)
{
    for (UINT i=0; i < count; i++)
    {
        pVertexRegister->x = ((float*)pInputStream)[0];
        pVertexRegister->y = ((float*)pInputStream)[1];
        pVertexRegister->z = ((float*)pInputStream)[2];
        pVertexRegister->w = ((float*)pInputStream)[3];
        pInputStream = (BYTE*)pInputStream + stride;
        pVertexRegister++;
    }
}

void Copy_D3DCOLOR(LPVOID pInputStream, UINT stride, UINT count,
                          VVM_WORD * pVertexRegister)
{
    const float scale = 1.0f/255.f;
    for (UINT i=0; i < count; i++)
    {
        const DWORD v = ((DWORD*)pInputStream)[0];
        pVertexRegister->x = scale * RGBA_GETRED(v);
        pVertexRegister->y = scale * RGBA_GETGREEN(v);
        pVertexRegister->z = scale * RGBA_GETBLUE(v);
        pVertexRegister->w = scale * RGBA_GETALPHA(v);
        pInputStream = (BYTE*)pInputStream + stride;
        pVertexRegister++;
    }
}

void Copy_UBYTE4(LPVOID pInputStream, UINT stride, UINT count,
                 VVM_WORD * pVertexRegister)
{
    for (UINT i=0; i < count; i++)
    {
        const BYTE* v = (BYTE*)pInputStream;
        pVertexRegister->x = v[0];
        pVertexRegister->y = v[1];
        pVertexRegister->z = v[2];
        pVertexRegister->w = v[3];
        pInputStream = (BYTE*)pInputStream + stride;
        pVertexRegister++;
    }
}

void Copy_SHORT2(LPVOID pInputStream, UINT stride, UINT count,
                 VVM_WORD * pVertexRegister)
{
    for (UINT i=0; i < count; i++)
    {
        const short* v = (short*)pInputStream;
        pVertexRegister->x = v[0];
        pVertexRegister->y = v[1];
        pVertexRegister->z = 0;
        pVertexRegister->w = 1;
        pInputStream = (BYTE*)pInputStream + stride;
        pVertexRegister++;
    }
}

void Copy_SHORT4(LPVOID pInputStream, UINT stride, UINT count,
                 VVM_WORD * pVertexRegister)
{
    for (UINT i=0; i < count; i++)
    {
        const short* v = (short*)pInputStream;
        pVertexRegister->x = v[0];
        pVertexRegister->y = v[1];
        pVertexRegister->z = v[2];
        pVertexRegister->w = v[3];
        pInputStream = (BYTE*)pInputStream + stride;
        pVertexRegister++;
    }
}
//-----------------------------------------------------------------------------
// Based on register and data type the function computes FVF dword and presence 
// bits:
// - Bits in the dwFVF2 are used to detect that some field is not entered twice
// - pnFloats is used to compute number of floats with position
//

// Bits for dwFVF2. Order is the same as in the FVF!!!
//
static const DWORD __POSITION_PRESENT       = 1 << 0;
static const DWORD __BLENDWEIGHT_PRESENT    = 1 << 1;
static const DWORD __BLENDINDICES_PRESENT   = 1 << 2;
static const DWORD __NORMAL_PRESENT         = 1 << 3;
static const DWORD __PSIZE_PRESENT          = 1 << 4;
static const DWORD __DIFFUSE_PRESENT        = 1 << 5;
static const DWORD __SPECULAR_PRESENT       = 1 << 6;
// __TEXTURE0_PRESENT must start from 8th bit
static const DWORD __TEXTURE0_PRESENT       = 1 << 8;   
static const DWORD __TEXTURE1_PRESENT       = 1 << 9;
static const DWORD __TEXTURE2_PRESENT       = 1 << 10;
static const DWORD __TEXTURE3_PRESENT       = 1 << 11;
static const DWORD __TEXTURE4_PRESENT       = 1 << 12;
static const DWORD __TEXTURE5_PRESENT       = 1 << 13;
static const DWORD __TEXTURE6_PRESENT       = 1 << 14;
static const DWORD __TEXTURE7_PRESENT       = 1 << 15;
static const DWORD __POSITION2_PRESENT      = 1 << 16;
static const DWORD __NORMAL2_PRESENT        = 1 << 17;

// Check if any bit left from the CurrentBit is set in PresenceBits
// PresenceBits are updated by CurrentBit.
//
inline void CheckOrder(
    DWORD* pPresenceBits,       // Presence bits for the declaration
    DWORD CurrentBit, 
    BOOL* pFlag,                // Out of order flag for the declaration
    char* s)                    // Name of the field
{
    if (*pPresenceBits & CurrentBit)
    {
        char msg[80];
        sprintf(msg, "%s specified twice in the declaration", s);
        D3D_THROW_FAIL(msg);
    }
    if (*pPresenceBits & ~(CurrentBit | (CurrentBit-1)))
    {
        *pFlag = FALSE;
    }
    *pPresenceBits |= CurrentBit;
}

void UpdateFVF(DWORD dwRegister, DWORD dwDataType,
               DWORD* pdwFVF,       // FVF for the current declaration
               DWORD* pdwFVF2,      // Presence bits for the current stream
               DWORD* pnFloats, 
               BOOL* pbLegacyFVF)
{
    switch (dwRegister)
    {
    case D3DVSDE_POSITION:
        if (dwDataType != D3DVSDT_FLOAT3)
            D3D_THROW_FAIL("Position register must be FLOAT3 for fixed-function pipeline");

        CheckOrder(pdwFVF2, __POSITION_PRESENT, pbLegacyFVF, "Position");
        *pdwFVF |= D3DFVF_XYZ;
        break;
    case D3DVSDE_POSITION2:
        if (dwDataType != D3DVSDT_FLOAT3)
            D3D_THROW_FAIL("Position2 register must be FLOAT3 for fixed-function pipeline");
        CheckOrder(pdwFVF2, __POSITION2_PRESENT, pbLegacyFVF, "Position2");
        break;
    case D3DVSDE_BLENDWEIGHT:
        {
            CheckOrder(pdwFVF2, __BLENDWEIGHT_PRESENT, pbLegacyFVF, "Blend weight");
            switch (dwDataType)
            {
            case D3DVSDT_FLOAT1:
                (*pnFloats)++;
                break;
            case D3DVSDT_FLOAT2:
                (*pnFloats) += 2;
                break;
            case D3DVSDT_FLOAT3:
                (*pnFloats) += 3;
                break;
            case D3DVSDT_FLOAT4:
                (*pnFloats) += 4;
                break;
            default:
                D3D_THROW_FAIL("Invalid data type set for vertex blends");
                break;
            }
            break;
        }
    case D3DVSDE_NORMAL:
        CheckOrder(pdwFVF2, __NORMAL_PRESENT, pbLegacyFVF, "Normal");
        if (dwDataType != D3DVSDT_FLOAT3)
            D3D_THROW_FAIL("Normal register must be FLOAT3 for fixed-function pipeline");
        *pdwFVF |= D3DFVF_NORMAL;
        break;
    case D3DVSDE_NORMAL2:
        CheckOrder(pdwFVF2, __NORMAL2_PRESENT, pbLegacyFVF, "Normal2");
        if (dwDataType != D3DVSDT_FLOAT3)
            D3D_THROW_FAIL("Normal2 register must be FLOAT3 for fixed-function pipeline");
        break;
    case D3DVSDE_PSIZE:
        CheckOrder(pdwFVF2, __PSIZE_PRESENT, pbLegacyFVF, "Point size");
        if (dwDataType != D3DVSDT_FLOAT1)
            D3D_THROW_FAIL("Point size register must be FLOAT1 for fixed-function pipeline");
        *pdwFVF |= D3DFVF_PSIZE;
        break;
    case D3DVSDE_DIFFUSE:
        CheckOrder(pdwFVF2, __DIFFUSE_PRESENT, pbLegacyFVF, "Diffuse");
        if (dwDataType != D3DVSDT_D3DCOLOR)
            D3D_THROW_FAIL("Diffuse register must be D3DCOLOR for fixed-function pipeline");
        *pdwFVF |= D3DFVF_DIFFUSE;
        break;
    case D3DVSDE_SPECULAR:
        CheckOrder(pdwFVF2, __SPECULAR_PRESENT, pbLegacyFVF, "Specular");
        if (dwDataType != D3DVSDT_D3DCOLOR)
            D3D_THROW_FAIL("Specular register must be D3DCOLOR for fixed-function pipeline");
        *pdwFVF |= D3DFVF_SPECULAR;
        break;
    case D3DVSDE_BLENDINDICES:
        CheckOrder(pdwFVF2, __BLENDINDICES_PRESENT, pbLegacyFVF, "Blend indices");
        if (dwDataType != D3DVSDT_UBYTE4)
            D3D_THROW_FAIL("Blend indices register must be D3DVSDT_UBYTE4 for fixed-function pipeline");
        // Update number of floats after position
        (*pnFloats)++;
        break;
    case D3DVSDE_TEXCOORD0:
    case D3DVSDE_TEXCOORD1:
    case D3DVSDE_TEXCOORD2:
    case D3DVSDE_TEXCOORD3:
    case D3DVSDE_TEXCOORD4:
    case D3DVSDE_TEXCOORD5:
    case D3DVSDE_TEXCOORD6:
    case D3DVSDE_TEXCOORD7:
        {
            DWORD dwTextureIndex = dwRegister - D3DVSDE_TEXCOORD0;
            DWORD dwBit = __TEXTURE0_PRESENT  << dwTextureIndex;
            CheckOrder(pdwFVF2, dwBit, pbLegacyFVF, "Texture");
            switch (dwDataType)
            {
            case D3DVSDT_FLOAT1:
                *pdwFVF |= D3DFVF_TEXCOORDSIZE1(dwTextureIndex);
                break;
            case D3DVSDT_FLOAT2:
                *pdwFVF |= D3DFVF_TEXCOORDSIZE2(dwTextureIndex);
                break;
            case D3DVSDT_FLOAT3:
                *pdwFVF |= D3DFVF_TEXCOORDSIZE3(dwTextureIndex);
                break;
            case D3DVSDT_FLOAT4:
                *pdwFVF |= D3DFVF_TEXCOORDSIZE4(dwTextureIndex);
                break;
            default:
                D3D_THROW_FAIL("Invalid data type set for texture register");
                break;
            }
            break;
        }
    default:
        D3D_THROW_FAIL("Invalid register set for fixed-function pipeline");
        break;
    }
}
//-----------------------------------------------------------------------------
void CVStreamDecl::Parse(CD3DBase* pDevice,
                         DWORD CONST ** ppToken, BOOL bFixedFunction,
                         DWORD* pdwFVF, DWORD* pdwFVF2, DWORD* pnFloats, 
                         BOOL* pbLegacyFVF, UINT usage, BOOL bTessStream)
{
    CONST DWORD* pToken = *ppToken;
    // Used to compute stream stride and offset in bytes for each stream element
    DWORD dwCurrentOffset = 0;
    // FVF and FVF2 for this stream only. Used to check if data in the stream 
    // form a FVF subset
    DWORD dwFVF2 = 0;
    DWORD dwFVF  = 0;
    DWORD nFloats = 0;
    // Set to TRUE, if data in the stream is an FVF subset
    BOOL  bFVFSubset = TRUE;
    
    while (TRUE)
    {
        DWORD dwToken = *pToken++;
        const DWORD dwTokenType = D3DVSD_GETTOKENTYPE(dwToken);
        switch (dwTokenType)
        {
        case D3DVSD_TOKEN_NOP:  break;
        case D3DVSD_TOKEN_TESSELLATOR:
            {
                *pbLegacyFVF = FALSE;
                bFVFSubset = FALSE;
                const DWORD dwDataType = D3DVSD_GETDATATYPE(dwToken);
                switch (dwDataType)
                {
                case D3DVSDT_FLOAT2:
                case D3DVSDT_FLOAT3:
                    break;
                }
                break;
            }
        case D3DVSD_TOKEN_STREAMDATA:
            {
                switch (D3DVSD_GETDATALOADTYPE(dwToken))
                {
                case D3DVSD_LOADREGISTER:
                    {
#if DBG
                        if (m_dwNumElements >= __NUMELEMENTS)
                        {
                            D3D_ERR("D3DVSD_TOKEN_STREAMDATA:");
                            D3D_ERR("   Number of vertex elements in a stream is greater than max supported");
                            D3D_ERR("   Max supported number of elements is %d", __NUMELEMENTS);
                            D3D_THROW_FAIL("");
                        }
#endif
                        CVElement* pElement = &m_Elements[m_dwNumElements++];
                        const DWORD dwDataType = D3DVSD_GETDATATYPE(dwToken);
                        const DWORD dwRegister = D3DVSD_GETVERTEXREG(dwToken);
                        pElement->m_dwOffset = dwCurrentOffset;
                        pElement->m_dwRegister = dwRegister;
                        pElement->m_dwDataType = dwDataType;
                        switch (dwDataType)
                        {
                        case D3DVSDT_FLOAT1:
                            dwCurrentOffset += sizeof(float);
                            pElement->m_pfnCopy = (LPVOID)Copy_FLOAT1;
                            break;
                        case D3DVSDT_FLOAT2:
                            dwCurrentOffset += sizeof(float) * 2;
                            pElement->m_pfnCopy = (LPVOID)Copy_FLOAT2;
                            break;
                        case D3DVSDT_FLOAT3:
                            dwCurrentOffset += sizeof(float) * 3;
                            pElement->m_pfnCopy = (LPVOID)Copy_FLOAT3;
                            break;
                        case D3DVSDT_FLOAT4:
                            dwCurrentOffset += sizeof(float) * 4;
                            pElement->m_pfnCopy = (LPVOID)Copy_FLOAT4;
                            break;
                        case D3DVSDT_D3DCOLOR:
                            dwCurrentOffset += sizeof(DWORD);
                            pElement->m_pfnCopy = (LPVOID)Copy_D3DCOLOR;
                            break;
                        case D3DVSDT_UBYTE4:
#if DBG
                            // Do not fail when software processing will be used                       
                            if (pDevice->GetD3DCaps()->VertexProcessingCaps & D3DVTXPCAPS_NO_VSDT_UBYTE4 &&
                                !((usage & D3DUSAGE_SOFTWAREPROCESSING &&
                                  pDevice->BehaviorFlags() & D3DCREATE_MIXED_VERTEXPROCESSING)  ||
                                  (pDevice->BehaviorFlags() & D3DCREATE_SOFTWARE_VERTEXPROCESSING)))
                            {
                                D3D_THROW_FAIL("Device does not support UBYTE4 data type");
                            }
#endif // DBG
                            dwCurrentOffset += sizeof(DWORD);
                            pElement->m_pfnCopy = (LPVOID)Copy_UBYTE4;
                            break;
                        case D3DVSDT_SHORT2:
                            dwCurrentOffset += sizeof(short) * 2;
                            pElement->m_pfnCopy = (LPVOID)Copy_SHORT2;
                            break;
                        case D3DVSDT_SHORT4:
                            dwCurrentOffset += sizeof(short) * 4;
                            pElement->m_pfnCopy = (LPVOID)Copy_SHORT4;
                            break;
                        default:
                            D3D_ERR("D3DVSD_TOKEN_STREAMDATA: Invalid element data type: %10x", dwToken);
                            D3D_THROW_FAIL("");
                        }
                        // Compute input FVF for fixed-function pipeline
                        if (bFixedFunction)
                        {
                            // Update FVF for the declaration
                            UpdateFVF(dwRegister, dwDataType, pdwFVF, pdwFVF2,
                                      pnFloats, pbLegacyFVF);
                            // Update FVF for the stream
                            UpdateFVF(dwRegister, dwDataType, &dwFVF, &dwFVF2,
                                      &nFloats, &bFVFSubset);
                        }
                        else
                            if (dwRegister >= D3DVS_INPUTREG_MAX_V1_1)
                                D3D_THROW_FAIL("D3DVSD_TOKEN_STREAMDATA: Invalid register number");
                        break;
                    }
                case D3DVSD_SKIP:
                    {
                        if (bFixedFunction)
                        {
                            D3D_THROW_FAIL("D3DVSD_SKIP is not allowed for fixed-function pipeline");
                        }
                        const DWORD dwCount = D3DVSD_GETSKIPCOUNT(dwToken);
                        dwCurrentOffset += dwCount * sizeof(DWORD);
                        break;
                    }
                default:
                    D3D_ERR("Invalid data load type: %10x", dwToken);
                    D3D_THROW_FAIL("");
                }
                break;
            }
        default:
            {
                *ppToken = pToken - 1;
                m_dwStride = dwCurrentOffset;
                goto l_exit;
            }
        } // switch
    } // while
l_exit:
    if (bFixedFunction && !bTessStream)
    {
#if DBG
        m_dwFVF = dwFVF;
#endif
        if (!bFVFSubset)
        {
            D3D_THROW_FAIL("For fixed-function pipeline each stream has to be an FVF subset");
        }
        if (dwFVF2 & (__POSITION2_PRESENT   | __NORMAL2_PRESENT | 
                      __PSIZE_PRESENT       | __BLENDINDICES_PRESENT))
        {
            *pbLegacyFVF = FALSE;
        }
    }
}
//-----------------------------------------------------------------------------
CVDeclaration::CVDeclaration(DWORD dwNumStreams)
{
    m_pConstants = NULL;
    m_pConstantsTail = NULL;
    m_pActiveStreams = NULL;
    m_pActiveStreamsTail = NULL;
    m_dwInputFVF = 0;
    m_bLegacyFVF = TRUE;
    m_dwNumStreams = dwNumStreams;
    m_bStreamTessPresent = FALSE;
}
//-----------------------------------------------------------------------------
CVDeclaration::~CVDeclaration()
{
    delete m_pActiveStreams;
    delete m_pConstants;
}
//-----------------------------------------------------------------------------
void CVDeclaration::Parse(CD3DBase* pDevice, CONST DWORD* pTok, BOOL bFixedFunction, 
                          DWORD* pDeclSize, UINT usage)
{
    DWORD dwFVF  = 0;   // FVF for fixed-function pipeline
    DWORD dwFVF2 = 0;   // Texture presence bits (8 bits)
    DWORD nFloats = 0;  // Number of floats after position

    DWORD   dwStreamPresent = 0;    // Bit is set if a stream is used
    m_bLegacyFVF = TRUE;

    CONST DWORD* pToken = pTok;
    while (TRUE)
    {
        DWORD dwToken = *pToken++;
        const DWORD dwTokenType = D3DVSD_GETTOKENTYPE(dwToken);
        switch (dwTokenType)
        {
        case D3DVSD_TOKEN_NOP:  break;
        case D3DVSD_TOKEN_STREAM:
            {
                CVStreamDecl StreamTess;

                if( D3DVSD_ISSTREAMTESS(dwToken) )
                {
                    m_bLegacyFVF = FALSE;
                    if( m_bStreamTessPresent )
                    {
                        D3D_THROW(D3DERR_INVALIDCALL, "Tesselator Stream has already been defined in the declaration");
                    }

                    m_bStreamTessPresent = TRUE;
                    // 
                    // For now simply skip over the Tess tokens in the
                    // Runtime.
                    StreamTess.Parse(pDevice, &pToken, bFixedFunction, &dwFVF, &dwFVF2,
                                     &nFloats, &m_bLegacyFVF, usage, TRUE);
                }
                else
                {
                    DWORD dwStream = D3DVSD_GETSTREAMNUMBER(dwToken);
                    if (dwStream >= m_dwNumStreams)
                    {
                        D3D_THROW_FAIL("Stream number is too big");
                    }

                    if (dwStreamPresent & (1 << dwStream))
                    {
                        D3D_THROW(D3DERR_INVALIDCALL, "Stream is already defined"
                                  "in the declaration");
                    }

                    dwStreamPresent |= 1 << dwStream;

                    // There are more than one stream present, so cant be
                    // handled by legacy FVF.
                    if( dwStreamPresent & (dwStreamPresent - 1) )
                        m_bLegacyFVF = FALSE;


                    CVStreamDecl* pStream = new CVStreamDecl;
                    if (pStream == NULL)
                    {
                        D3D_THROW(E_OUTOFMEMORY, "Not enough memory");
                    }
                    try
                    {
                        pStream->Parse(pDevice, &pToken, bFixedFunction, &dwFVF, &dwFVF2,
                                       &nFloats, &m_bLegacyFVF, usage);
                        pStream->m_dwStreamIndex = dwStream;
                        if (m_pActiveStreams == NULL)
                        {
                            m_pActiveStreams = pStream;
                            m_pActiveStreamsTail = pStream;
                        }
                        else
                        {
                            m_pActiveStreamsTail->Append(pStream);
                            m_pActiveStreamsTail = pStream;
                        }
                    }
                    catch (HRESULT e)
                    {
                        delete pStream;
                        throw e;
                    }
                }
                break;
            }
        case D3DVSD_TOKEN_STREAMDATA:
            {
                D3D_THROW_FAIL("D3DVSD_TOKEN_STREAMDATA could only be used after D3DVSD_TOKEN_STREAM");
            }
        case D3DVSD_TOKEN_CONSTMEM:
            {
                CVConstantData * cd = new CVConstantData;
                CheckForNull(cd, __LINE__, __FILE__);

                cd->m_dwCount = D3DVSD_GETCONSTCOUNT(dwToken);
                cd->m_dwAddress = D3DVSD_GETCONSTADDRESS(dwToken);

                UINT ValidationCount;
                if (usage & D3DUSAGE_SOFTWAREPROCESSING)
                    ValidationCount = D3DVS_CONSTREG_MAX_V1_1;
                else
                    ValidationCount = pDevice->GetD3DCaps()->MaxVertexShaderConst;

                if ((cd->m_dwCount + cd->m_dwAddress) > ValidationCount)
                    D3D_THROW_FAIL("D3DVSD_TOKEN_CONSTMEM writes outside constant memory");

                const DWORD dwSize = cd->m_dwCount << 2;    // number of DWORDs
                cd->m_pData = new DWORD[dwSize];
                CheckForNull(cd->m_pData, __LINE__, __FILE__);

                memcpy(cd->m_pData, pToken, dwSize << 2);
                if (m_pConstants == NULL)
                {
                    m_pConstants = cd;
                    m_pConstantsTail = cd;
                }
                else
                {
                    m_pConstantsTail->Append(cd);
                    m_pConstantsTail = cd;
                }
                pToken += dwSize;
                break;
            }
        case D3DVSD_TOKEN_EXT:
            {
                // Skip extension info
                DWORD dwCount = D3DVSD_GETEXTCOUNT(dwToken);
                pToken += dwCount;
                break;
            }
        case D3DVSD_TOKEN_END:
            {
                goto l_End;
            }
        default:
            {
                D3D_ERR("Invalid declaration token: %10x", dwToken);
                D3D_THROW_FAIL("");
            }
        }
    }
l_End:
    // Validate input for the fixed-function pipeline
    if (bFixedFunction && !m_bStreamTessPresent)
    {
        m_dwInputFVF = dwFVF & 0xFFFF0FFF;   // Remove float count
        switch (nFloats)
        {
        case 0: m_dwInputFVF |= D3DFVF_XYZ;     break;
        case 1: m_dwInputFVF |= D3DFVF_XYZB1;   break;
        case 2: m_dwInputFVF |= D3DFVF_XYZB2;   break;
        case 3: m_dwInputFVF |= D3DFVF_XYZB3;   break;
        case 4: m_dwInputFVF |= D3DFVF_XYZB4;   break;
        case 5: m_dwInputFVF |= D3DFVF_XYZB5;   break;
        default:
            D3D_THROW_FAIL("Too many floats after position");
        }
        // Compute number of texture coordinates
        DWORD nTexCoord = 0;
        DWORD dwTexturePresenceBits = (dwFVF2 >> 8) & 0xFF;
        while (dwTexturePresenceBits & 1)
        {
            dwTexturePresenceBits >>= 1;
            nTexCoord++;
        }
        // There should be no gaps in texture coordinates
        if (dwTexturePresenceBits)
            D3D_THROW_FAIL("Texture coordinates should have no gaps");

        m_dwInputFVF |= nTexCoord << D3DFVF_TEXCOUNT_SHIFT;

        // Position must be set
        if ((dwFVF & D3DFVF_POSITION_MASK) != D3DFVF_XYZ)
            D3D_THROW_FAIL("Position register must be set");
    }
    if (pDeclSize != NULL)
    {
        *pDeclSize = (DWORD) (pToken - pTok) << 2;
    }
}
//---------------------------------------------------------------------
CVStream::~CVStream()
{
    if (m_pVB)
        m_pVB->DecrementUseCount();
}
//---------------------------------------------------------------------
CVIndexStream::~CVIndexStream()
{
    if (m_pVBI)
        m_pVBI->DecrementUseCount();
}
//---------------------------------------------------------------------
DWORD g_PrimToVerCount[7][2] =
{
    {0, 0},         // Illegal
    {1, 0},         // D3DPT_POINTLIST     = 1,
    {2, 0},         // D3DPT_LINELIST      = 2,
    {1, 1},         // D3DPT_LINESTRIP     = 3,
    {3, 0},         // D3DPT_TRIANGLELIST  = 4,
    {1, 2},         // D3DPT_TRIANGLESTRIP = 5,
    {1, 2},         // D3DPT_TRIANGLEFAN   = 6,
};
//-----------------------------------------------------------------------------
HRESULT D3DFE_PVFUNCSI::CreateShader(CVElement* pElements, DWORD dwNumElements,
                                     DWORD* pdwShaderCode, DWORD dwOutputFVF,
                                     CPSGPShader** ppPSGPShader)
{
    *ppPSGPShader = NULL;
    try
    {
        *ppPSGPShader = m_VertexVM.CreateShader(pElements, dwNumElements,
                                                pdwShaderCode);
        if (*ppPSGPShader == NULL)
            return D3DERR_INVALIDCALL;
    }
    D3D_CATCH;
    return D3D_OK;
}
//-----------------------------------------------------------------------------
HRESULT D3DFE_PVFUNCSI::SetActiveShader(CPSGPShader* pPSGPShader)
{
    return m_VertexVM.SetActiveShader((CVShaderCode*)pPSGPShader);
}
//-----------------------------------------------------------------------------
// Load vertex shader constants
HRESULT
D3DFE_PVFUNCSI::LoadShaderConstants(DWORD start, DWORD count, LPVOID buffer)
{
    return m_VertexVM.SetData(D3DSPR_CONST, start, count, buffer);
}
//-----------------------------------------------------------------------------
// Get vertex shader constants
HRESULT
D3DFE_PVFUNCSI::GetShaderConstants(DWORD start, DWORD count, LPVOID buffer)
{
    return m_VertexVM.GetData(D3DSPR_CONST, start, count, buffer);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::GetVertexShaderConstant"

HRESULT D3DAPI
CD3DHal::GetVertexShaderConstant(DWORD Register, LPVOID pData, DWORD count)
{
    API_ENTER(this);
#if DBG
    // Validate Parameters
    if (!VALID_WRITEPTR(pData, 4 * sizeof(DWORD) * count))
    {
        D3D_ERR("Invalid constant data pointer. GetVertexShaderConstant failed.");
        return D3DERR_INVALIDCALL;
    }
	if ((GetD3DCaps()->VertexShaderVersion == D3DVS_VERSION(0,0)) && 
		(BehaviorFlags() & (D3DCREATE_HARDWARE_VERTEXPROCESSING | D3DCREATE_PUREDEVICE)))
	{
        D3D_ERR("No programmable vertex shaders are supported by this device. GetVertexShaderConstant failed.");
        return D3DERR_INVALIDCALL;
	}
    UINT ValidationCount;
    if (BehaviorFlags() & D3DCREATE_MIXED_VERTEXPROCESSING)
        ValidationCount = max(m_MaxVertexShaderConst, D3DVS_CONSTREG_MAX_V1_1);
    else
    if (BehaviorFlags() & D3DCREATE_SOFTWARE_VERTEXPROCESSING)
        ValidationCount = D3DVS_CONSTREG_MAX_V1_1;
    else
        ValidationCount = m_MaxVertexShaderConst;
    if((Register + count) > ValidationCount)
    {
        D3D_ERR("Not that many constant registers in the vertex machine. GetVertexShaderConstant failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    HRESULT hr;
    if (m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING ||
        ((count + Register) <= D3DVS_CONSTREG_MAX_V1_1))
    {
        // For software vertex processing we store constant registers in PSGP if
        // possible
        return m_pv->pGeometryFuncs->GetShaderConstants(Register, count, 
                                                        const_cast<VOID*>(pData));
    }
    else
    {
        if (Register >= D3DVS_CONSTREG_MAX_V1_1)
        {
            // When all modified registers are above software limit, we use Microsoft 
            // internal array
            hr = GeometryFuncsGuaranteed->GetShaderConstants(Register, count, 
                                                              const_cast<VOID*>(pData));
        }
        else
        {
            // Part of constant data is taken from PSGP array and part from 
            // Microsoft's array
            UINT FirstCount = D3DVS_CONSTREG_MAX_V1_1 - Register;
            hr = m_pv->pGeometryFuncs->GetShaderConstants(Register, FirstCount, 
                                                           const_cast<VOID*>(pData));
            if (FAILED(hr))
            {
                return hr;
            }
            return GeometryFuncsGuaranteed->GetShaderConstants(D3DVS_CONSTREG_MAX_V1_1, 
                                                               Register + count - D3DVS_CONSTREG_MAX_V1_1,
                                                               &((DWORD*)pData)[FirstCount*4]);
        }
        return hr;
    }
    return m_pv->pGeometryFuncs->GetShaderConstants(Register, count, pData);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::GetVertexShader"

HRESULT D3DAPI
CD3DHal::GetVertexShader(LPDWORD pdwHandle)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    HRESULT        ret = D3D_OK;
#if DBG
    // Validate Parameters
    if (!VALID_WRITEPTR(pdwHandle, sizeof(DWORD)))
    {
        D3D_ERR("Invalid handle pointer. GetVertexShader failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    *pdwHandle = m_dwCurrentShaderHandle;
    return ret;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::GetPixelShader"

HRESULT D3DAPI
CD3DHal::GetPixelShader(LPDWORD pdwHandle)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    HRESULT        ret = D3D_OK;

#if DBG
    // Validate Parameters
    if (!VALID_WRITEPTR(pdwHandle, sizeof(DWORD)))
    {
        D3D_ERR("Invalid handle pointer. GetPixelShader failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    *pdwHandle = m_dwCurrentPixelShaderHandle;
    return ret;
}
#if DBG
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::ValidateRTPatch"

void CD3DHal::ValidateRTPatch()
{
    if (D3DVSD_ISLEGACY(m_dwCurrentShaderHandle))
    {
        if (m_pStream[0].m_pVB == 0)
        {
            D3D_THROW_FAIL("Draw[RT]Patch should have streams set");
        }
        if ((m_pStream[0].m_pVB->GetBufferDesc()->Usage & D3DUSAGE_RTPATCHES) == 0)
        {
            D3D_THROW_FAIL("Vertex buffers used for rendering RT-Patches should have D3DUSAGE_RTPATCHES set");
        }
    }
    else
    {
        CVStreamDecl* pStream;
        pStream = m_pCurrentShader->m_Declaration.m_pActiveStreams;
        while(pStream)
        {
            UINT index = pStream->m_dwStreamIndex;
            CVStream* pDeviceStream = &m_pStream[index];
            if (pDeviceStream->m_pVB == 0)
            {
                D3D_THROW_FAIL("Draw[RT]Patch should have streams set");
            }
            if ((pDeviceStream->m_pVB->GetBufferDesc()->Usage & D3DUSAGE_RTPATCHES) == 0)
            {
                D3D_THROW_FAIL("Vertex buffers used for rendering RT-Patches should have D3DUSAGE_RTPATCHES set");
            }
            pStream = (CVStreamDecl*)pStream->m_pNext;
        }
    }
}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\cubemap.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       cubemap.cpp
 *  Content:    Implementation of the CCubeMap class.
 *
 *
 ***************************************************************************/
#include "ddrawpr.h"
#include "cubemap.hpp"
#include "cubesurf.hpp"
#include "d3di.hpp"
#include "resource.inl"

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::Create"

// Static class function for creating a cube-map object.
// (Because it is static; it doesn't have a this pointer.)
//
// We do all parameter checking here to reduce the overhead
// in the constructor which is called by the internal Clone
// method which is used by resource management as part of the
// performance critical download operation.


HRESULT CCubeMap::Create(CBaseDevice            *pDevice, 
                         DWORD                   cpEdge,
                         DWORD                   cLevels,
                         DWORD                   Usage,
                         D3DFORMAT               UserFormat,
                         D3DPOOL                 Pool,
                         IDirect3DCubeTexture8 **ppCubeMap)
{
    HRESULT hr;

    // Do parameter checking here
    if (!VALID_PTR_PTR(ppCubeMap))
    {
        DPF_ERR("Bad parameter passed for ppSurface for creating a cubemap");
        return D3DERR_INVALIDCALL;
    }

    // Zero-out return parameter
    *ppCubeMap = NULL;

    // Check if format is valid
    hr = Validate(pDevice, 
                  D3DRTYPE_CUBETEXTURE, 
                  Pool, 
                  Usage, 
                  UserFormat);
    if (FAILED(hr))
    {
        // VerifyFormat does it's own DPFing
        return D3DERR_INVALIDCALL;
    }

    // Infer internal usage flags
    Usage = InferUsageFlags(Pool, Usage, UserFormat);

    // Expand cLevels if necessary
    if (cLevels == 0)
    {
        // See if HW can mip
        if ( (Pool != D3DPOOL_SCRATCH) && (!(pDevice->GetD3DCaps()->TextureCaps &
                D3DPTEXTURECAPS_MIPCUBEMAP)))
        {
            // Can't mip so use 1
            cLevels = 1;
        }
        else
        {
            // Determine number of levels
            cLevels = ComputeLevels(cpEdge);
        }
    }

    // Start parameter checking

    if (cLevels > 32)
    {
        DPF_ERR("No more than 32 levels are supported for a cubemap texture");

        // This limitation is based on the number of
        // bits that we have allocated for iLevel in 
        // some of the supporting classes.
        return D3DERR_INVALIDCALL;
    }

    // Check if the device supports mipped cubemaps
    if (cLevels > 1)
    {
        if ((cpEdge >> (cLevels - 1)) == 0)
        {
            DPF_ERR("Too many levels for Cube Texture of this size.");
            return D3DERR_INVALIDCALL;
        }
    }

    D3DFORMAT RealFormat = UserFormat;

    if (Pool != D3DPOOL_SCRATCH)
    {
        // Check size constraints for cubemap
        if (pDevice->GetD3DCaps()->TextureCaps & D3DPTEXTURECAPS_CUBEMAP_POW2)
        {
            if (!IsPowerOfTwo(cpEdge))
            {
                DPF_ERR("Device requires that edge must be power of two for cube-maps");
                return D3DERR_INVALIDCALL;
            }
        }

        // Check texture size restrictions
        if (cpEdge > pDevice->GetD3DCaps()->MaxTextureWidth)
        {
            DPF_ERR("Texture width is larger than what the device supports. Cube Texture creation fails.");
            return D3DERR_INVALIDCALL;
        }

        if (cpEdge > pDevice->GetD3DCaps()->MaxTextureHeight)
        {
            DPF_ERR("Texture height is larger than what the device supports. Cube Texture creation fails.");
            return D3DERR_INVALIDCALL;
        }

        // Check that the device supports cubemaps
        if (!(pDevice->GetD3DCaps()->TextureCaps & D3DPTEXTURECAPS_CUBEMAP))
        {
            DPF_ERR("Device doesn't support Cube Texture; Cube Texture creation failed.");
            return D3DERR_INVALIDCALL;
        }

        // Check if the device supports mipped cubemaps
        if (cLevels > 1)
        {
            if (!(pDevice->GetD3DCaps()->TextureCaps &
                    D3DPTEXTURECAPS_MIPCUBEMAP))
            {
                DPF_ERR("Device doesn't support mipped cube textures; creation failed.");
                return D3DERR_INVALIDCALL;
            }
        }

        // Map Depth/Stencil formats; returns no change if no
        // mapping is needed
        RealFormat = pDevice->MapDepthStencilFormat(UserFormat);
    }

    // Size may need to be 4x4
    if (CPixel::Requires4X4(UserFormat))
    {
        if (cpEdge & 3)
        {
            DPF_ERR("DXT Formats require edge to be a multiples of 4. Cube Texture creation fails.");
            return D3DERR_INVALIDCALL;
        }
    }

    // Validate against zero width/height
    if (cpEdge == 0)
    {
        DPF_ERR("Edge must be non-zero. Cube Texture creation fails."); 
        return D3DERR_INVALIDCALL;
    }

    // Allocate a new CubeMap object and return it
    CCubeMap *pCubeMap = new CCubeMap(pDevice, 
                                      cpEdge, 
                                      cLevels,
                                      Usage,
                                      UserFormat,
                                      RealFormat,
                                      Pool,
                                      REF_EXTERNAL,
                                     &hr);
    if (pCubeMap == NULL)
    {
        DPF_ERR("Out of Memory creating cubemap");
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr))
    {
        DPF_ERR("Error during initialization of cubemap");
        pCubeMap->ReleaseImpl();
        return hr;
    }

    // We're done; just return the object
    *ppCubeMap = pCubeMap;

    return hr;
} // static Create


#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::CCubeMap"

// Constructor the cube map class
CCubeMap::CCubeMap(CBaseDevice *pDevice, 
                   DWORD        cpEdge,
                   DWORD        cLevels,
                   DWORD        Usage,
                   D3DFORMAT    UserFormat,
                   D3DFORMAT    RealFormat,    
                   D3DPOOL      UserPool,
                   REF_TYPE     refType,
                   HRESULT     *phr
                   ) :
    CBaseTexture(pDevice, cLevels, UserPool, UserFormat, refType),
    m_prgCubeSurfaces(NULL),
    m_rgbPixels(NULL),
    m_IsAnyFaceDirty(TRUE)
{
    // Sanity check
    DXGASSERT(phr);
    DXGASSERT(cLevels <= 32);

    // Initialize basic structures
    m_prgCubeSurfaces       = NULL;
    m_rgbPixels             = NULL;
    m_desc.Format           = RealFormat;
    m_desc.Pool             = UserPool;
    m_desc.Usage            = Usage;
    m_desc.Type             = D3DRTYPE_CUBETEXTURE;
    m_desc.MultiSampleType  = D3DMULTISAMPLE_NONE;
    m_desc.Width            = cpEdge;
    m_desc.Height           = cpEdge;

    // Initialize ourselves to all dirty
    for (DWORD iFace = 0; iFace < CUBEMAP_MAXFACES; iFace++)
    {
        m_IsFaceCleanArray   [iFace] = FALSE;
        m_IsFaceAllDirtyArray[iFace] = TRUE;
    }

    // We assume that we start out dirty
    DXGASSERT(IsDirty());

    // We always have 6 faces now
    DWORD cFaces = 6;

    // Allocate Pixel Data
    m_cbSingleFace = CPixel::ComputeMipMapSize(cpEdge, 
                                               cpEdge, 
                                               cLevels, 
                                               RealFormat);

    // Round up to nearest 32 for alignment
    m_cbSingleFace += 31;
    m_cbSingleFace &= ~(31);

    m_desc.Size = m_cbSingleFace * cFaces;

    // Allocate Pixel Data for SysMem or D3DManaged cases
    if (IS_D3D_ALLOCATED_POOL(UserPool) ||
        IsTypeD3DManaged(Device(), D3DRTYPE_CUBETEXTURE, UserPool))
    {
        m_rgbPixels   = new BYTE[m_desc.Size];

        if (m_rgbPixels == NULL)
        {
            *phr = E_OUTOFMEMORY;
            return;
        }
    }

    // Create the DDSURFACEINFO array and CreateSurfaceData object
    DXGASSERT(cLevels <= 32);

    DDSURFACEINFO SurfInfo[6 * 32];
    ZeroMemory(SurfInfo, sizeof(SurfInfo));

    D3D8_CREATESURFACEDATA CreateSurfaceData;
    ZeroMemory(&CreateSurfaceData, sizeof(CreateSurfaceData));

    // Set up the basic information
    CreateSurfaceData.hDD      = pDevice->GetHandle();
    CreateSurfaceData.pSList   = &SurfInfo[0];
    CreateSurfaceData.dwSCnt   = cLevels * cFaces;
    CreateSurfaceData.Type     = D3DRTYPE_CUBETEXTURE;
    CreateSurfaceData.dwUsage  = m_desc.Usage;
    CreateSurfaceData.Format   = RealFormat;
    CreateSurfaceData.MultiSampleType = D3DMULTISAMPLE_NONE;
    CreateSurfaceData.Pool     = DetermineCreationPool(Device(), 
                                                       D3DRTYPE_CUBETEXTURE, 
                                                       Usage, 
                                                       UserPool);

    // Iterate of each face/level to create the individual level
    // data
    for (iFace = 0; iFace < cFaces; iFace++)
    {
        // Start width and height at the full size
        cpEdge = m_desc.Width;
        DXGASSERT(m_desc.Width == m_desc.Height);

        for (DWORD iLevel = 0; iLevel < cLevels; iLevel++)
        {
            int index = (iFace * cLevels) + iLevel;

            // Fill in the relevant information
            DXGASSERT(cpEdge >= 1);
            SurfInfo[index].cpWidth  = cpEdge;
            SurfInfo[index].cpHeight = cpEdge;

            // If we allocated the memory, pass down
            // the sys-mem pointers
            if (m_rgbPixels)
            {
                D3DLOCKED_RECT lock;
                ComputeCubeMapOffset(iFace, 
                                     iLevel,
                                     NULL,       // pRect
                                     &lock);

                SurfInfo[index].pbPixels = (BYTE*)lock.pBits;
                SurfInfo[index].iPitch   = lock.Pitch;

            }

            // Scale width and height down for each level
            cpEdge >>= 1;
        }
    }

    // Allocate array of pointers to CubeSurfaces
    m_prgCubeSurfaces = new CCubeSurface*[cLevels*cFaces];
    if (m_prgCubeSurfaces == NULL)
    {
        *phr = E_OUTOFMEMORY;
        return;
    }

    // Zero the memory for safe cleanup
    ZeroMemory(m_prgCubeSurfaces, 
               sizeof(*m_prgCubeSurfaces) * cLevels * cFaces);

    if (UserPool != D3DPOOL_SCRATCH)
    {
        // Call the HAL to create this surface
        *phr = pDevice->GetHalCallbacks()->CreateSurface(&CreateSurfaceData);
        if (FAILED(*phr))
            return;

        // NOTE: any failures after this point needs to free up some
        // kernel handles

        // Remember what pool we really got
        m_desc.Pool = CreateSurfaceData.Pool;

        // We need to remember the handles from the top most
        // level of the mip-map
        SetKernelHandle(SurfInfo[0].hKernelHandle);
    }

    // Create and Initialize each CubeLevel
    for (iFace = 0; iFace < cFaces; iFace++)
    {
        for (DWORD iLevel = 0; iLevel < cLevels; iLevel++)
        {
            int index = (iFace * cLevels) + iLevel;

            DXGASSERT((BYTE)iFace == iFace);
            DXGASSERT((BYTE)iLevel == iLevel);

            // Create the appropriate cube-level depending on type

            // Is this a sys-mem surface; could be d3d managed
            if (IS_D3D_ALLOCATED_POOL(m_desc.Pool))
            {
                m_prgCubeSurfaces[index] = 
                            new CCubeSurface(this,
                                            (BYTE)iFace,
                                            (BYTE)iLevel,
                                            SurfInfo[index].hKernelHandle);
            }
            else
            {
                // This is driver kind of cube-map; could be driver managed
                m_prgCubeSurfaces[index] = 
                        new CDriverCubeSurface(this,
                                               (BYTE)iFace,
                                               (BYTE)iLevel,
                                               SurfInfo[index].hKernelHandle);
            }

            if (m_prgCubeSurfaces[index] == NULL)
            {
                DPF_ERR("Out of memory creating cube map level");
                *phr = E_OUTOFMEMORY;

                // Need to free handles that we got before we return; we
                // only free the ones that weren't successfully entrusted
                // to a CCubeSurf because those will be cleaned up automatically
                // at their destructor
                if (UserPool != D3DPOOL_SCRATCH)
                {
                    for (UINT i = index; i < ((cFaces * cLevels) - 1); i++)
                    {
                        DXGASSERT(SurfInfo[i].hKernelHandle);

                        D3D8_DESTROYSURFACEDATA DestroySurfData;
                        DestroySurfData.hDD = Device()->GetHandle();
                        DestroySurfData.hSurface = SurfInfo[i].hKernelHandle;
                        Device()->GetHalCallbacks()->DestroySurface(&DestroySurfData);
                    }
                }

                return;
            }
        }
    }

    // If this is a D3D managed surface then we need 
    // to tell the Resource Manager to remember us. This has to happen
    // at the very end of the constructor so that the important data
    // members are built up correctly
    if (CResource::IsTypeD3DManaged(Device(), D3DRTYPE_CUBETEXTURE, UserPool))
    {
        *phr = InitializeRMHandle();
    }

} // CCubeMap::CCubeMap


#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::~CCubeMap"

// Destructor
CCubeMap::~CCubeMap()
{
    // The destructor has to handle partially
    // created objects. 

    if (m_prgCubeSurfaces)
    {
        // How many faces do we have?
        DWORD cFaces = 6;

        // Delete each CubeSurface individually
        for (DWORD iSurf = 0; iSurf < (cFaces * m_cLevels); iSurf++)
        {
            delete m_prgCubeSurfaces[iSurf];
        }
        delete [] m_prgCubeSurfaces;
    }
    delete [] m_rgbPixels;
} // CCubeMap::~CCubeMap

// Methods for the Resource Manager

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::Clone"

// Specifies a creation of a resource that
// looks just like the current one; in a new POOL
// with a new LOD.
HRESULT CCubeMap::Clone(D3DPOOL    Pool, 
                        CResource **ppResource) const

{
    // NULL out parameter
    *ppResource = NULL;

    // Determine the number of levels/width/height
    // of the clone
    DWORD cLevels  = GetLevelCountImpl();
    DWORD Edge = m_desc.Width;
    DXGASSERT(m_desc.Width == m_desc.Height);

    DWORD dwLOD = GetLODI();

    // If LOD is zero, then there are no changes
    if (dwLOD > 0)
    {
        // Clamp LOD to cLevels-1
        if (dwLOD >= cLevels)
        {
            dwLOD = cLevels - 1;
        }

        // scale down the destination texture
        // to correspond the appropiate max lod
        Edge >>= dwLOD;
        if (Edge == 0)
            Edge = 1;

        // Reduce the number based on the our max lod.
        cLevels -= dwLOD;
    }

    // Sanity checking
    DXGASSERT(cLevels  >= 1);
    DXGASSERT(Edge     >  0);

    // Create the new cube-map object now

    // Note: we treat clones as REF_INTERNAL; because
    // they are owned by the resource manager which 
    // is owned by the device. 

    // Also, we adjust the usage to disable lock-flags
    // since we don't need lockability
    DWORD Usage = m_desc.Usage;
    Usage &= ~(D3DUSAGE_LOCK | D3DUSAGE_LOADONCE);

    HRESULT hr;
    CResource *pResource = new CCubeMap(Device(),
                                        Edge,
                                        cLevels,
                                        Usage,
                                        m_desc.Format,  // UserFormat
                                        m_desc.Format,  // RealFormat
                                        Pool,
                                        REF_INTERNAL,
                                        &hr);

    if (pResource == NULL)
    {
        DPF_ERR("Failed to allocate cube-map object when copying");
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr))
    {
        DPF(5, "Failed to create cube-map when doing texture management");
        pResource->DecrementUseCount();
        return hr;
    }

    *ppResource = pResource;

    return hr;
} // CCubeMap::Clone

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::GetBufferDesc"

// Provides a method to access basic structure of the
// pieces of the resource. A resource may be composed
// of one or more buffers.
const D3DBUFFER_DESC* CCubeMap::GetBufferDesc() const
{
    return (const D3DBUFFER_DESC*)&m_desc;
} // CCubeMap::GetBufferDesc


// IUnknown methods
#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::QueryInterface"

STDMETHODIMP CCubeMap::QueryInterface(REFIID riid, 
                                      LPVOID FAR * ppvObj)
{
    API_ENTER(Device());

    if (!VALID_PTR_PTR(ppvObj))
    {
        DPF_ERR("Invalid ppvObj parameter to QueryInterface for Cubemap");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_PTR(&riid, sizeof(GUID)))
    {
        DPF_ERR("Invalid guid memory address to QueryInterface for Cubemap");
        return D3DERR_INVALIDCALL;
    }

    if (riid == IID_IDirect3DCubeTexture8  || 
        riid == IID_IDirect3DBaseTexture8  ||
        riid == IID_IDirect3DResource8     ||
        riid == IID_IUnknown)
    {
        *ppvObj = static_cast<void*>(static_cast<IDirect3DCubeTexture8*>(this));
            
        AddRef();
        return S_OK;
    }

    DPF_ERR("Unsupported Interface identifier passed to QueryInterface for Cubemap");
    
    // Null out param
    *ppvObj = NULL;
    return E_NOINTERFACE;
} // QueryInterface

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::AddRef"

STDMETHODIMP_(ULONG) CCubeMap::AddRef()
{
    API_ENTER_NO_LOCK(Device());
    
    return AddRefImpl();
} // AddRef

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::Release"

STDMETHODIMP_(ULONG) CCubeMap::Release()
{
    API_ENTER_SUBOBJECT_RELEASE(Device());    

    return ReleaseImpl();
} // Release

// IDirect3DResource methods

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::GetDevice"

STDMETHODIMP CCubeMap::GetDevice(IDirect3DDevice8 ** ppvObj)
{
    API_ENTER(Device());
    return GetDeviceImpl(ppvObj);
} // GetDevice

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::SetPrivateData"

STDMETHODIMP CCubeMap::SetPrivateData(REFGUID   riid, 
                                      CONST VOID*    pvData, 
                                      DWORD     cbData, 
                                      DWORD     dwFlags)
{
    API_ENTER(Device());

    // For the private data that 'really' belongs to the
    // CubeMap, we use m_cLevels. (0 through m_cLevels-1 are for
    // each of the children levels.)

    return SetPrivateDataImpl(riid, pvData, cbData, dwFlags, m_cLevels);
} // SetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::GetPrivateData"

STDMETHODIMP CCubeMap::GetPrivateData(REFGUID   riid, 
                                      LPVOID    pvData, 
                                      LPDWORD   pcbData)
{
    API_ENTER(Device());

    // For the private data that 'really' belongs to the
    // CubeMap, we use m_cLevels. (0 through m_cLevels-1 are for
    // each of the children levels.)
    return GetPrivateDataImpl(riid, pvData, pcbData, m_cLevels);
} // GetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::FreePrivateData"

STDMETHODIMP CCubeMap::FreePrivateData(REFGUID riid)
{
    API_ENTER(Device());

    // For the private data that 'really' belongs to the
    // CubeMap, we use m_cLevels. (0 through m_cLevels-1 are for
    // each of the children levels.)
    return FreePrivateDataImpl(riid, m_cLevels);
} // FreePrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::GetPriority"

STDMETHODIMP_(DWORD) CCubeMap::GetPriority()
{
    API_ENTER_RET(Device(), DWORD);

    return GetPriorityImpl();
} // GetPriority

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::SetPriority"

STDMETHODIMP_(DWORD) CCubeMap::SetPriority(DWORD dwPriority)
{
    API_ENTER_RET(Device(), DWORD);

    return SetPriorityImpl(dwPriority);
} // SetPriority

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::PreLoad"

STDMETHODIMP_(void) CCubeMap::PreLoad(void)
{
    API_ENTER_VOID(Device());

    PreLoadImpl();
    return;
} // PreLoad

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::GetType"
STDMETHODIMP_(D3DRESOURCETYPE) CCubeMap::GetType(void)
{
    API_ENTER_RET(Device(), D3DRESOURCETYPE);

    return m_desc.Type;
} // GetType


// IDirect3DMipTexture methods

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::GetLOD"

STDMETHODIMP_(DWORD) CCubeMap::GetLOD()
{
    API_ENTER_RET(Device(), DWORD);

    return GetLODImpl();
} // GetLOD

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::SetLOD"

STDMETHODIMP_(DWORD) CCubeMap::SetLOD(DWORD dwLOD)
{
    API_ENTER_RET(Device(), DWORD);

    return SetLODImpl(dwLOD);
} // SetLOD

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::GetLevelCount"

STDMETHODIMP_(DWORD) CCubeMap::GetLevelCount()
{
    API_ENTER_RET(Device(), DWORD);

    return GetLevelCountImpl();
} // GetLevelCount


// IDirect3DCubeMap methods

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::GetLevelDesc"

STDMETHODIMP CCubeMap::GetLevelDesc(UINT iLevel, D3DSURFACE_DESC *pDesc)
{
    API_ENTER(Device());

    if (iLevel >= m_cLevels)
    {
        DPF_ERR("Invalid level number passed CCubeMap::GetLevelDesc");
        return D3DERR_INVALIDCALL;
    }

    D3DCUBEMAP_FACES FaceType = D3DCUBEMAP_FACE_POSITIVE_X;

    return GetSurface(FaceType, iLevel)->GetDesc(pDesc);

} // GetLevelDesc

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::GetCubeMapSurface"

STDMETHODIMP CCubeMap::GetCubeMapSurface(D3DCUBEMAP_FACES    FaceType, 
                                         UINT                iLevel,
                                         IDirect3DSurface8 **ppSurface)
{
    API_ENTER(Device());

    if (!VALID_PTR_PTR(ppSurface))
    {
        DPF_ERR("Invalid ppSurface parameter passed to CCubeMap::GetCubeMapSurface");
        return D3DERR_INVALIDCALL;
    }

    // Null out parameter
    *ppSurface = NULL;

    // Continue parameter checking
    if (iLevel >= m_cLevels)
    {
        DPF_ERR("Invalid level number passed CCubeMap::OpenCubemapLevel");
        return D3DERR_INVALIDCALL;
    }
    if (!VALID_CUBEMAP_FACETYPE(FaceType))
    {
        DPF_ERR("Invalid face type passed CCubeMap::OpenCubemapLevel");
        return D3DERR_INVALIDCALL;
    }
        
    // Count bits in dwAllFaces less than dwFaceType's bit
    *ppSurface = GetSurface(FaceType, iLevel);
    (*ppSurface)->AddRef();
    return S_OK;
} // GetCubeMapSurface

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::LockRect"
STDMETHODIMP CCubeMap::LockRect(D3DCUBEMAP_FACES FaceType,
                                UINT             iLevel,
                                D3DLOCKED_RECT  *pLockedRectData, 
                                CONST RECT      *pRect, 
                                DWORD            dwFlags)
{
    API_ENTER(Device());

    if (pLockedRectData == NULL)
    {
        DPF_ERR("Invalid parameter passed to CCubeMap::LockRect");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_CUBEMAP_FACETYPE(FaceType))
    {
        DPF_ERR("Invalid face type passed CCubeMap::LockRect");
        return D3DERR_INVALIDCALL;
    }

    if (iLevel >= m_cLevels)
    {
        DPF_ERR("Invalid level number passed CCubeMap::LockRect");
        return D3DERR_INVALIDCALL;
    }

    return GetSurface(FaceType, iLevel)->LockRect(pLockedRectData, pRect, dwFlags);
} // LockRect


#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::UnlockRect"

STDMETHODIMP CCubeMap::UnlockRect(D3DCUBEMAP_FACES FaceType, UINT iLevel)
{
    API_ENTER(Device());

    if (!VALID_CUBEMAP_FACETYPE(FaceType))
    {
        DPF_ERR("Invalid face type passed CCubeMap::UnlockRect");
        return D3DERR_INVALIDCALL;
    }
    if (iLevel >= m_cLevels)
    {
        DPF_ERR("Invalid level number passed CCubeMap::UnlockRect");
        return D3DERR_INVALIDCALL;
    }

    return GetSurface(FaceType, iLevel)->UnlockRect();

} // UnlockRect


#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::UpdateTexture"

// This function does type-specific parameter checking
// before calling UpdateDirtyPortion
HRESULT CCubeMap::UpdateTexture(CBaseTexture *pResourceTarget)
{
    CCubeMap *pTexSource = static_cast<CCubeMap*>(this);
    CCubeMap *pTexDest   = static_cast<CCubeMap*>(pResourceTarget);

    // Figure out how many levels in the source to skip
    DXGASSERT(pTexSource->m_cLevels >= pTexDest->m_cLevels);
    DWORD StartLevel = pTexSource->m_cLevels - pTexDest->m_cLevels;
    DXGASSERT(StartLevel < 32);

    // Compute the size of the top level of the source that is
    // going to be copied.
    UINT SrcWidth  = pTexSource->Desc()->Width;
    UINT SrcHeight = pTexSource->Desc()->Height;
    if (StartLevel > 0)
    {
        SrcWidth  >>= StartLevel;
        SrcHeight >>= StartLevel;
        if (SrcWidth == 0)
            SrcWidth = 1;
        if (SrcHeight == 0)
            SrcHeight = 1;
    }

    // Source and Dest should be the same sizes at this point
    if (SrcWidth != pTexDest->Desc()->Width)
    {
        if (StartLevel)
        {
            DPF_ERR("Source and Destination for UpdateTexture are not"
                    " compatible. Since both have the same number of"
                    " levels; their widths must match. UpdateTexture"
                    " for CubeTexture fails");
        }
        else
        {
            DPF_ERR("Source and Destination for UpdateTexture are not"
                    " compatible. Since they have the different numbers of"
                    " levels; the widths of the bottom-most levels of"
                    " the source must match all the corresponding levels"
                    " of the destination. UpdateTexture"
                    " for CubeTexture fails");
        }
        return D3DERR_INVALIDCALL;
    }

    if (SrcHeight != pTexDest->Desc()->Height)
    {
        if (StartLevel)
        {
            DPF_ERR("Source and Destination for UpdateTexture are not"
                    " compatible. Since both have the same number of"
                    " levels; their heights must match. UpdateTexture"
                    " for CubeTexture fails");
        }
        else
        {
            DPF_ERR("Source and Destination for UpdateTexture are not"
                    " compatible. Since they have the different numbers of"
                    " mip-levels; the heights of the bottom-most levels of"
                    " the source must match all the corresponding levels"
                    " of the destination. UpdateTexture"
                    " for CubeTexture fails");
        }
        return D3DERR_INVALIDCALL;
    }

    return UpdateDirtyPortion(pResourceTarget);
} // UpdateTexture


#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::UpdateDirtyPortion"

// Tells the resource that it should copy itself
// to the target. It is the caller's responsibility
// to make sure that Target is compatible with the
// Source. (The Target may have different number of mip-levels
// and be in a different pool; however, it must have the same size, 
// faces, format, etc.)
//
// This function will clear the dirty state.
HRESULT CCubeMap::UpdateDirtyPortion(CResource *pResourceTarget)
{
    // If we are clean, then do nothing
    if (!m_IsAnyFaceDirty)
    {
        if (IsDirty())
        {
            DPF_ERR("A Cube Texture has been locked with D3DLOCK_NO_DIRTY_UPDATE but "
                    "no call to AddDirtyRect was made before the texture was used. "
                    "Hardware texture was not updated.");
        }
        return S_OK;
    }

    // We are dirty; so we need to get some pointers
    CCubeMap *pTexSource = static_cast<CCubeMap*>(this);
    CCubeMap *pTexDest   = static_cast<CCubeMap*>(pResourceTarget);

    // Call TexBlt for each face
    HRESULT hr = S_OK;
    
    if (CanTexBlt(pTexDest))
    {
        CD3DBase *pDevice = static_cast<CD3DBase*>(Device());

        // Hack: go in reverse order for driver compat.
        for (INT iFace = CUBEMAP_MAXFACES-1; 
                 iFace >= 0; 
                 iFace--)
        {
            // Skip clean faces
            if (m_IsFaceCleanArray[iFace])
                continue;

            // Figure out the right handles to use for this operation
            D3DCUBEMAP_FACES Face = (D3DCUBEMAP_FACES) iFace;
            DWORD dwDest   = pTexDest->GetSurface(Face, 0 /* iLevel */)->DrawPrimHandle();                       
            DWORD dwSource = pTexSource->GetSurface(Face, 0 /* iLevel */)->DrawPrimHandle();
                      
            // Is this face all dirty?   
            if (m_IsFaceAllDirtyArray[iFace])
            {
                POINT p = {0 , 0};
                RECTL r = {0, 0, Desc()->Width, Desc()->Height};

                hr = pDevice->CubeTexBlt(pTexDest,
                                         pTexSource,
                                         dwDest, 
                                         dwSource, 
                                         &p, 
                                         &r);
            }
            else
            {
                // this face must be dirty
                DXGASSERT(!m_IsFaceCleanArray[iFace]);

                // Is this face partially dirty
                hr = pDevice->CubeTexBlt(pTexDest,
                                         pTexSource,
                                         dwDest, 
                                         dwSource, 
                                         (LPPOINT)&m_DirtyRectArray[iFace], 
                                         (LPRECTL)&m_DirtyRectArray[iFace]);
            }

            if (FAILED(hr))
            {
                DPF_ERR("Failed to update texture; not clearing dirty state for Cubemap");

                return hr;
            }
        }
    }
    else
    {
        // We can't use TexBlt, so we have to copy each level individually
        // through InternalCopyRects

        // Determine number of source levels to skip
        DXGASSERT(pTexSource->m_cLevels >= pTexDest->m_cLevels);
        DWORD StartLevel = pTexSource->m_cLevels - pTexDest->m_cLevels;
        DWORD LevelsToCopy = pTexSource->m_cLevels - StartLevel;
        DXGASSERT(StartLevel < this->m_cLevels);
        DXGASSERT(0 < pTexDest->m_cLevels);

        CBaseSurface *pSurfaceSrc;
        CBaseSurface *pSurfaceDest;

        // Iterate over each face
        for (DWORD iFace = 0; iFace < 6; iFace++)
        {
            if (m_IsFaceCleanArray[iFace])
                continue;

            if (m_IsFaceAllDirtyArray[iFace])
            {
                for (DWORD iLevel = 0; iLevel < LevelsToCopy; iLevel++)
                {
                    DWORD IndexSrc = iFace * this->m_cLevels + iLevel + StartLevel;
                    DXGASSERT(IndexSrc < (DWORD)(this->m_cLevels * 6));
                    pSurfaceSrc = this->m_prgCubeSurfaces[IndexSrc];

                    DWORD IndexDest = iFace * pTexDest->m_cLevels + iLevel;
                    DXGASSERT(IndexDest < (DWORD)(pTexDest->m_cLevels * 6));
                    pSurfaceDest = pTexDest->m_prgCubeSurfaces[IndexDest];

                    // Source and Dest should be the same
                    // or our caller made a mistake
                    DXGASSERT(pSurfaceSrc->InternalGetDesc().Width == 
                              pSurfaceDest->InternalGetDesc().Width);
                    DXGASSERT(pSurfaceSrc->InternalGetDesc().Height == 
                              pSurfaceDest->InternalGetDesc().Height);

                    // Copy the entire level
                    hr = Device()->InternalCopyRects(pSurfaceSrc, 
                                                     NULL, 
                                                     0, 
                                                     pSurfaceDest, 
                                                     NULL);
                    if (FAILED(hr))
                    {
                        DPF_ERR("Failed to update texture; not clearing dirty state for Cubemap");
                        return hr;
                    }
                }
            }
            else
            {
                if (StartLevel)
                {
                    ScaleRectDown(&m_DirtyRectArray[iFace], StartLevel);
                }

                // Use the rect for the top level; but just
                // copy the entirety of other levels
                DWORD iLevel = 0;

                DWORD IndexSrc = iFace * this->m_cLevels + iLevel + StartLevel;
                DXGASSERT(IndexSrc < (DWORD)(this->m_cLevels * 6));
                pSurfaceSrc = this->m_prgCubeSurfaces[IndexSrc];

                DWORD IndexDest = iFace * pTexDest->m_cLevels + iLevel;
                DXGASSERT(IndexDest < (DWORD)(pTexDest->m_cLevels * 6));
                pSurfaceDest = pTexDest->m_prgCubeSurfaces[IndexDest];


                DXGASSERT(pSurfaceSrc->InternalGetDesc().Width == 
                          pSurfaceDest->InternalGetDesc().Width);
                DXGASSERT(pSurfaceSrc->InternalGetDesc().Height == 
                          pSurfaceDest->InternalGetDesc().Height);

                // Passing pPoints as NULL means just do a non-translated
                // copy
                hr = Device()->InternalCopyRects(pSurfaceSrc, 
                                                 &m_DirtyRectArray[iFace], 
                                                 1, 
                                                 pSurfaceDest, 
                                                 NULL);       // pPoints

                if (FAILED(hr))
                {
                    DPF_ERR("Failed to update texture; not clearing dirty state for Cubemap");
                    return hr;
                }

                // Copy each of the levels
                for (iLevel = 1; iLevel < LevelsToCopy; iLevel++)
                {
                    // Get the next surfaces
                    DWORD IndexSrc = iFace * this->m_cLevels + iLevel + StartLevel;
                    DXGASSERT(IndexSrc < (DWORD)(this->m_cLevels * 6));
                    pSurfaceSrc = this->m_prgCubeSurfaces[IndexSrc];

                    DWORD IndexDest = iFace * pTexDest->m_cLevels + iLevel;
                    DXGASSERT(IndexDest < (DWORD)(pTexDest->m_cLevels * 6));
                    pSurfaceDest = pTexDest->m_prgCubeSurfaces[IndexDest];

                    // Check that sizes match
                    DXGASSERT(pSurfaceSrc->InternalGetDesc().Width == 
                              pSurfaceDest->InternalGetDesc().Width);
                    DXGASSERT(pSurfaceSrc->InternalGetDesc().Height == 
                              pSurfaceDest->InternalGetDesc().Height);

                    // Copy the entirety of non-top levels
                    hr = Device()->InternalCopyRects(pSurfaceSrc, 
                                                     NULL, 
                                                     0, 
                                                     pSurfaceDest, 
                                                     NULL);
                    if (FAILED(hr))
                    {
                        DPF_ERR("Failed to update texture; not clearing dirty state for Cubemap");
                        return hr;
                    }
                }
            }
        }
    }
    
    // Remember that we did the work
    m_IsAnyFaceDirty = FALSE;
    for (DWORD iFace = 0; iFace < CUBEMAP_MAXFACES; iFace++)
    {
        m_IsFaceCleanArray   [iFace] = TRUE;
        m_IsFaceAllDirtyArray[iFace] = FALSE;
    }

    // Notify Resource base class that we are now clean
    OnResourceClean();
    DXGASSERT(!IsDirty());

    return S_OK;
} // CCubeMap::UpdateDirtyPortion

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::MarkAllDirty"

// Allows the Resource Manager to mark the texture
// as needing to be completely updated on next
// call to UpdateDirtyPortion
void CCubeMap::MarkAllDirty()
{
    // Set palette to __INVALIDPALETTE so that UpdateTextures
    // calls the DDI SetPalette the next time.
    SetPalette(__INVALIDPALETTE);

    // Mark everything dirty
    m_IsAnyFaceDirty = TRUE;
    for (int iFace = 0; iFace < CUBEMAP_MAXFACES; iFace++)
    {
        m_IsFaceCleanArray   [iFace] = FALSE;
        m_IsFaceAllDirtyArray[iFace] = TRUE;
    }

    // Notify Resource base class that we are now dirty
    OnResourceDirty();

} // CCubeMap::MarkAllDirty


#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::AddDirtyRect"
STDMETHODIMP CCubeMap::AddDirtyRect(D3DCUBEMAP_FACES  FaceType, 
                                    CONST RECT       *pRect)
{
    API_ENTER(Device());

    if (pRect != NULL && !VALID_PTR(pRect, sizeof(RECT)))
    {
        DPF_ERR("Invalid Rect parameter to AddDirtyRect for Cubemap");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_CUBEMAP_FACETYPE(FaceType))
    {
        DPF_ERR("Invalid FaceType parameter to AddDirtyRect for Cubemap");
        return D3DERR_INVALIDCALL;
    }

    if (pRect)
    {
        if (!CPixel::IsValidRect(Desc()->Format,
                                 Desc()->Width, 
                                 Desc()->Height, 
                                 pRect))
        {
            DPF_ERR("AddDirtyRect for a Cube Texture failed");
            return D3DERR_INVALIDCALL;
        }
    }

    InternalAddDirtyRect((UINT)FaceType, pRect);
    return S_OK;
} // AddDirtyRect

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::InternalAddDirtyRect"
void CCubeMap::InternalAddDirtyRect(DWORD             iFace, 
                                    CONST RECT       *pRect)
{
    // If driver managed then batch token
    if (Desc()->Pool == D3DPOOL_MANAGED && !IsD3DManaged())
    {
        RECTL Rect;
        DXGASSERT((Device()->GetD3DCaps()->Caps2 & DDCAPS2_CANMANAGERESOURCE) != 0);
        if (pRect == NULL)
        {
            Rect.left = 0;
            Rect.top = 0;
            Rect.right = (LONG)Desc()->Width;
            Rect.bottom = (LONG)Desc()->Height;
        }
        else
        {
            Rect = *((CONST RECTL*)pRect);
        }
        static_cast<CD3DBase*>(Device())->AddCubeDirtyRect(this, 
                                                           GetSurface((D3DCUBEMAP_FACES)iFace, 0)->DrawPrimHandle(),
                                                           &Rect); // This will fail only due to catastrophic
                                                                   // error and we or the app can't do a
                                                                   // a whole lot about it, so return nothing
        return;
    }

    // Need to mark dirty bit in CResource so that the resource manager works correctly.
    OnResourceDirty();

    // If everything is being modified; then we're totally dirty
    if (pRect == NULL)
    {
        m_IsFaceAllDirtyArray[iFace] = TRUE;
        m_IsFaceCleanArray   [iFace] = FALSE;
        m_IsAnyFaceDirty             = TRUE;
        return;
    }

    // If we're all dirty, we can't get dirtier
    if (m_IsFaceAllDirtyArray[iFace])
    {
        return;
    }

    // If the rect is the entire surface then we're all dirty 
    DXGASSERT(pRect != NULL);
    if (pRect->left     == 0 &&
        pRect->top      == 0 &&
        pRect->right    == (LONG)Desc()->Width &&
        pRect->bottom   == (LONG)Desc()->Height)
    {
        m_IsFaceAllDirtyArray[iFace] = TRUE;
        m_IsFaceCleanArray   [iFace] = FALSE;
        m_IsAnyFaceDirty             = TRUE;
        return;
    }

    // If the face is currently clean; then just remember the
    // new rect
    if (m_IsFaceCleanArray[iFace])
    {
        m_DirtyRectArray  [iFace] = *pRect;
        m_IsFaceCleanArray[iFace] = FALSE;
        m_IsAnyFaceDirty          = TRUE;
        return;
    }

    // Union in this Rect

    // If we're unioning in rects, then we must
    // already be marked dirty but not all dirty
    DXGASSERT(!m_IsFaceAllDirtyArray[iFace]);
    DXGASSERT(m_IsAnyFaceDirty);

    if (m_DirtyRectArray[iFace].left   > pRect->left)
    {
        m_DirtyRectArray[iFace].left   = pRect->left;
    }
    if (m_DirtyRectArray[iFace].right  < pRect->right)
    {
        m_DirtyRectArray[iFace].right  = pRect->right;
    }
    if (m_DirtyRectArray[iFace].top    > pRect->top)
    {
        m_DirtyRectArray[iFace].top    = pRect->top;
    }
    if (m_DirtyRectArray[iFace].bottom < pRect->bottom)
    {
        m_DirtyRectArray[iFace].bottom = pRect->bottom;
    }

    return;
} // InternalAddDirtyRect

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::OnSurfaceLock"

// Methods for the CubeSurface to call
// Notification when a cube-surface is locked for writing
void CCubeMap::OnSurfaceLock(DWORD       iFace, 
                             DWORD       iLevel, 
                             CONST RECT *pRect, 
                             DWORD       dwFlags)
{
    // Need to Sync first
    Sync();

    // We only care about the top-most levels of the cube-map
    if (iLevel != 0)
    {
        return;
    }

    // We don't need to mark the surface dirty if this was a
    // read-only lock; (this can happen for RT+Tex where we
    // need to sync even for read-only locks).
    if (dwFlags & D3DLOCK_READONLY)
    {
        return;
    }

    // Notify the resource that we are dirty
    OnResourceDirty();

    // Don't do anything if we are already all dirty or
    // if the app has specified that we shouldn't keep
    // track of this rect
    if (!m_IsFaceAllDirtyArray[iFace] &&
        !(dwFlags & D3DLOCK_NO_DIRTY_UPDATE))
    {
        InternalAddDirtyRect(iFace, pRect);
    }
    // We're done now.
    return;

} // OnSurfaceLock

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::IsTextureLocked"

// Debug only parameter checking do determine if a piece
// of a mip-chain is locked
#ifdef DEBUG
BOOL CCubeMap::IsTextureLocked()
{
    for (DWORD iFace = 0; iFace < 6; iFace++)
    {
        for (UINT iLevel = 0; iLevel < m_cLevels; iLevel++)
        {
            D3DCUBEMAP_FACES Face = (D3DCUBEMAP_FACES) iFace;            
            if (GetSurface(Face, iLevel)->IsLocked())
                return TRUE;
        }
    }
    return FALSE;

} // IsTextureLocked
#endif // !DEBUG


// End of file : cubemap.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fe\stateset.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       stateset.hpp
 *  Content:    State sets handling interfaces
 *
 ***************************************************************************/
#ifndef _STATESET_HPP_
#define _STATESET_HPP_

#include "hmgr.hpp"

extern void InsertStateSetOp(CD3DBase *pDevI, DWORD dwOperation, DWORD dwParam, D3DSTATEBLOCKTYPE sbt);

 //---------------------------------------------------------------------
// This class provides interface to the growing state set buffer
//
class CStateSetBuffer
{
public:
    CStateSetBuffer()
        {
            m_pBuffer = NULL;
            m_dwCurrentSize = 0;
            m_dwBufferSize = 0;
            m_pDP2CurrCommand = 0;
        }
    CStateSetBuffer(CStateSetBuffer& src)
        {
            m_dwCurrentSize = src.m_dwCurrentSize;
            m_dwBufferSize = src.m_dwCurrentSize;
            if(m_dwCurrentSize != 0)
            {
                m_pBuffer = new BYTE[m_dwCurrentSize];
                if(m_pBuffer == 0)
                {
                    m_dwCurrentSize = 0;
                    m_pDP2CurrCommand = 0;
                    throw E_OUTOFMEMORY;
                }
                memcpy(m_pBuffer, src.m_pBuffer, m_dwCurrentSize);
            }
            else
            {
                m_pBuffer = 0;
            }
            m_pDP2CurrCommand = 0;
        }
    ~CStateSetBuffer()
        {
            delete [] m_pBuffer;
        }
    void operator=(CStateSetBuffer& src)
        {
            m_dwCurrentSize = src.m_dwCurrentSize;
            if(m_dwBufferSize != m_dwCurrentSize)
            {
                m_dwBufferSize = m_dwCurrentSize;
                delete [] m_pBuffer;
                if(m_dwCurrentSize != 0)
                {
                    m_pBuffer = new BYTE[m_dwCurrentSize];
                    if(m_pBuffer == 0)
                    {
                        m_dwCurrentSize = 0;
                        m_pDP2CurrCommand = 0;
                        throw E_OUTOFMEMORY;
                    }
                }
                else
                {
                    m_pBuffer = 0;
                    m_pDP2CurrCommand = 0;
                    return;
                }
            }
            memcpy(m_pBuffer, src.m_pBuffer, m_dwCurrentSize);
            m_pDP2CurrCommand = 0;
        }
    // Insert a command to the buffer. Grow buffer if necessary
    void InsertCommand(D3DHAL_DP2OPERATION, LPVOID pData, DWORD dwDataSize);
    // Reset current command
    void ResetCurrentCommand()
        {
            m_pDP2CurrCommand = 0;
        }
    // Set buffer to its initial state. Memory is not freed
    void Reset()
        {
            m_dwCurrentSize = 0;
            m_pDP2CurrCommand = 0;
        }

    DWORD   m_dwCurrentSize;
    DWORD   m_dwBufferSize;
    BYTE    *m_pBuffer;
    //Pointer to the current position the CB1 buffer
    LPD3DHAL_DP2COMMAND m_pDP2CurrCommand;
};
//---------------------------------------------------------------------
// This class provides interface to a state set
//
const DWORD __STATESET_INITIALIZED          = 1;
// Set if we have to check if we need to restore texture stage indices
const DWORD __STATESET_NEEDCHECKREMAPPING   = 2;
// Set if the state set executed had purely pixel state
const DWORD __STATESET_HASONLYVERTEXSTATE   = 4;
class CStateSet
{
public:
    CStateSet()
        {
            m_dwStateSetFlags = 0;
            m_dwDeviceHandle = __INVALIDHANDLE;
        }
    virtual void InsertCommand(D3DHAL_DP2OPERATION, LPVOID pData, DWORD dwDataSize, BOOL bDriverCanHandle);
    // Mark the state set as unused. The object is not destroyed and can be
    // reused
    HRESULT Release();
    // Execute the front-end only or device state subset
    virtual void Execute(CD3DBase *pDevI, BOOL bFrontEndBuffer);
    // Capture the current device state into the state block
    virtual void Capture(CD3DBase *pDevI, BOOL bFrontEndBuffer);
    // Create a predefined state block
    virtual void CreatePredefined(CD3DBase *pDevI, D3DSTATEBLOCKTYPE sbt);
    // Reset the current command in both buffers
    void ResetCurrentCommand()
        {
            m_FEOnlyBuffer.ResetCurrentCommand();
            m_DriverBuffer.ResetCurrentCommand();
        }
protected:
    CStateSetBuffer m_FEOnlyBuffer; // Contains commands that driver can not
                                    // understand
    CStateSetBuffer m_DriverBuffer; // Contains commands that driver can
                                    // understand
    DWORD   m_dwDeviceHandle;       // Some sets could not have corresponding
                                    // device buffers, so device handle is not
                                    // equal to the user visible handle
    DWORD   m_dwStateSetFlags;
    friend class CStateSets;
};

class CPureStateSet : public CStateSet
{
public:
    void InsertCommand(D3DHAL_DP2OPERATION, LPVOID pData, DWORD dwDataSize, BOOL bDriverCanHandle);
    void Execute(CD3DBase *pDevI, BOOL bFrontEndBuffer);
    void Capture(CD3DBase *pDevI, BOOL bFrontEndBuffer);
    void CreatePredefined(CD3DBase *pDevI, D3DSTATEBLOCKTYPE sbt);
};
//---------------------------------------------------------------------
// This class encapsulates handling of array of state sets
//
class CStateSets
{
public:
    CStateSets();
    ~CStateSets();
    HRESULT Init(CD3DBase *pDev);
    HRESULT StartNewSet();
    void EndSet();
    // Returns current handle
    DWORD GetCurrentHandle() {return m_dwCurrentHandle;}
    // Delete state set
    void DeleteStateSet(CD3DBase *pDevI, DWORD dwHandle);
    // Returns information about state set data to be written to the device
    // Allocates a new handle for the device buffer
    void GetDeviceBufferInfo(DWORD* dwStateSetHandle, LPVOID *pBuffer, DWORD* dwBufferSize);
    void CreateNewDeviceHandle(DWORD* dwStateSetHandle);
    // Copy buffer and translate for DX7 DDI
    void TranslateDeviceBufferToDX7DDI( DWORD* p, DWORD dwSize );
    // Insert a render state to the current state set
    // Throws an exception in case of error
    void InsertRenderState(D3DRENDERSTATETYPE state, DWORD dwValue,
                           BOOL bDriverCanHandle);
    void InsertLight(DWORD dwLightIndex, CONST D3DLIGHT8*);
    void InsertLightEnable(DWORD dwLightIndex, BOOL bEnable);
    void InsertMaterial(CONST D3DMATERIAL8*);
    void InsertViewport(CONST D3DVIEWPORT8*);
    void InsertTransform(D3DTRANSFORMSTATETYPE state, CONST D3DMATRIX* lpMat);
    void InsertTextureStageState(DWORD, D3DTEXTURESTAGESTATETYPE, DWORD);
    void InsertTexture(DWORD dwStage, IDirect3DBaseTexture8 *pTex);
    void InsertClipPlane(DWORD dwPlaneIndex, CONST D3DVALUE* pPlaneEquation);
    void InsertVertexShader(DWORD dwShaderHandle, BOOL bHardware);
    void InsertPixelShader(DWORD dwShaderHandle);
    void InsertStreamSource(DWORD dwStream, CVertexBuffer *pBuf, DWORD dwStride);
    void InsertIndices(CIndexBuffer *pBuf, DWORD dwBaseVertex);
    void InsertVertexShaderConstant(DWORD Register, CONST VOID* pConstantData, DWORD ConstantCount);
    void InsertPixelShaderConstant(DWORD Register, CONST VOID* pConstantData, DWORD ConstantCount);
    void InsertCurrentTexturePalette(DWORD PaletteNumber);
    // Execute a state set with the specified handle
    void Execute(CD3DBase *pDevI, DWORD dwHandle);
    // Capture a state set to the the specified handle
    void Capture(CD3DBase *pDevI, DWORD dwHandle);
    // Capture predefined state
    void CreatePredefined(CD3DBase *pDevI, D3DSTATEBLOCKTYPE sbt);
    void Cleanup(DWORD dwHandle);
protected:
    const DWORD m_GrowSize;
    DWORD       m_dwMaxSets;        // Maximum number of state sets
    DWORD       m_dwCurrentHandle;
    CStateSet * m_pStateSets;       // Array of state sets
    CStateSet * m_pCurrentStateSet;
    CHandleFactory m_DeviceHandles; // Used to create device handles
    CHandleFactory m_SetHandles;    // Used to create state sets
    CStateSet * m_pBufferSet;
    DWORD       m_dwFlags;
    BOOL        m_bPure, m_bTLHal, m_bEmulate, m_bDX8Dev, m_bHardwareVP;
};

// This is RESERVED0 in d3dhal.h
#define D3DDP2OP_FRONTENDDATA   4           // Used by the front-end only
#define D3DDP2OP_FESETVB        5
#define D3DDP2OP_FESETIB        6
#define D3DDP2OP_FESETPAL       7

// This structure is used by the front-end only
typedef struct _D3DHAL_DP2FRONTENDDATA
{
    WORD                    wStage;      // texture stage
    IDirect3DBaseTexture8 * pTexture;    // Texture pointer
} D3DHAL_DP2FRONTENDDATA;
typedef D3DHAL_DP2FRONTENDDATA UNALIGNED64 * LPD3DHAL_DP2FRONTENDDATA;

typedef struct _D3DHAL_DP2FESETVB
{
    WORD                    wStream;
    CVertexBuffer * pBuf;
    DWORD                   dwStride;
} D3DHAL_DP2FESETVB;
typedef D3DHAL_DP2FESETVB UNALIGNED64 * LPD3DHAL_DP2FESETVB;

typedef struct _D3DHAL_DP2FESETIB
{
   CIndexBuffer * pBuf;
   DWORD                    dwBase;
} D3DHAL_DP2FESETIB;
typedef D3DHAL_DP2FESETIB UNALIGNED64 * LPD3DHAL_DP2FESETIB;

typedef struct _D3DHAL_DP2FESETPAL
{
    DWORD                   dwPaletteNumber;
} D3DHAL_DP2FESETPAL;
typedef D3DHAL_DP2FESETPAL UNALIGNED64 * LPD3DHAL_DP2FESETPAL;

#endif //_STATESTE_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\cubemap.hpp ===
#ifndef __CUBEMAP_HPP__
#define __CUBEMAP_HPP__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       cubesurface.h
 *  Content:    Class header for the cube-map class. This class acts a
 *              container for the (planar) Surfaces that are used as textures.
 *              The textures are organized into a set of 6 possible faces
 *              each of which is mip-mapped
 *
 *
 ***************************************************************************/

// Includes
#include "texture.hpp"
#include "pixel.hpp"

// Forward decls
class CCubeSurface;

//
// The cube-map class holds a collection of CCubeSurfaces. The CubeMap class
// implements the IDirect3DCubeTexture8 interface; each CubeSurface implements the
// IDirect3DSurface8 interface. To reduce overhead per level, we have
// put most of the "real" guts of each surface into the CubeMap container class;
// i.e. most of the methods of the CubeSurface really just end up calling
// something in the CubeMap object.
//
// The base class implementation assumes a sys-mem allocation.
//

class CCubeMap : public CBaseTexture, public IDirect3DCubeTexture8
{
public:
    static HRESULT Create(CBaseDevice            *pDevice,
                          DWORD                   cpEdge,
                          DWORD                   cLevels,
                          DWORD                   dwUsage,
                          D3DFORMAT               Format,
                          D3DPOOL                 Pool,
                          IDirect3DCubeTexture8 **ppCubeMap);

    // Destructor
    virtual ~CCubeMap();

    // IUnknown methods
    STDMETHOD(QueryInterface) (REFIID       riid,
                               VOID FAR   **ppvObj);
    STDMETHOD_(ULONG,AddRef) ();
    STDMETHOD_(ULONG,Release) ();

    // IDirect3DResource methods
    STDMETHOD(GetDevice)(IDirect3DDevice8 ** ppvObj);

    STDMETHOD(SetPrivateData)(REFGUID  riid,
                              CONST VOID    *pvData,
                              DWORD    cbData,
                              DWORD    dwFlags);

    STDMETHOD(GetPrivateData)(REFGUID  riid,
                              VOID    *pvData,
                              DWORD   *pcbData);

    STDMETHOD(FreePrivateData)(REFGUID riid);

    STDMETHOD_(DWORD, GetPriority)();
    STDMETHOD_(DWORD, SetPriority)(DWORD dwPriority);
    STDMETHOD_(void, PreLoad)();
    STDMETHOD_(D3DRESOURCETYPE, GetType)();

    // IDirect3DMipTexture methods
    STDMETHOD_(DWORD, GetLOD)();
    STDMETHOD_(DWORD, SetLOD)(DWORD dwLOD);
    STDMETHOD_(DWORD, GetLevelCount)();

    // IDirect3DCubeMap methods
    STDMETHOD(GetLevelDesc)(UINT   iLevel, D3DSURFACE_DESC *pDesc);

    STDMETHOD(GetCubeMapSurface)(D3DCUBEMAP_FACES    FaceType,
                                 UINT                iLevel,
                                 IDirect3DSurface8 **ppCubeMapSurface);

    STDMETHOD(LockRect)(D3DCUBEMAP_FACES    FaceType,
                        UINT                iLevel,
                        D3DLOCKED_RECT     *pLockedRectData,
                        CONST RECT         *pRect,
                        DWORD               dwFlags);

    STDMETHOD(UnlockRect)(D3DCUBEMAP_FACES FaceType,
                          UINT             iLevel);

    STDMETHOD(AddDirtyRect)(D3DCUBEMAP_FACES  FaceType,
                            CONST RECT       *pRect);

    // Public helper stuff

    // Direct accessor for surface descriptor
    const D3DSURFACE_DESC *Desc() const
    {
        return &m_desc;
    } // AccessDesc;

    // Helper for Lock
    void ComputeCubeMapOffset(UINT              iFace,
                              UINT              iLevel,
                              CONST RECT       *pRect,
                              D3DLOCKED_RECT   *pLockedRectData)
    {
        BYTE *pbFace = m_rgbPixels + iFace * m_cbSingleFace;
        CPixel::ComputeMipMapOffset(Desc(),
                                    iLevel,
                                    pbFace,
                                    pRect,
                                    pLockedRectData);
    } // ComputeCubeMapOffset

    // Notification when a cube-surface is locked for writing
    void OnSurfaceLock(DWORD    iFace,
                       DWORD    iLevel,
                       CONST RECT    *pRect,
                       DWORD    dwFlags);

    // Methods for CResource

    // Specifies a creation of a resource that
    // looks just like the current one; in a new POOL
    // with a new LOD.
    virtual HRESULT Clone(D3DPOOL     Pool,
                          CResource **ppResource) const;

    // Provides a method to access basic structure of the
    // pieces of the resource. A resource may be composed
    // of one or more buffers.
    virtual const D3DBUFFER_DESC* GetBufferDesc() const;

    // Updates destination with source dirty rects
    virtual HRESULT UpdateDirtyPortion(CResource *pResourceTarget);

    // Allows the Resource Manager to mark the texture
    // as needing to be completely updated on next
    // call to UpdateDirtyPortion
    virtual void MarkAllDirty();

    // Methods for CBaseTexture

    // Method for UpdateTexture to call; does type-specific
    // parameter checking before calling UpdateDirtyPortion
    virtual HRESULT UpdateTexture(CBaseTexture *pTextureTarget);

    // Parameter validation method to make sure that no part of
    // the texture is locked.
#ifdef DEBUG
    virtual BOOL IsTextureLocked();
#endif  // DEBUG

private:
    // Constructor returns an error code
    // if the object could not be fully
    // constructed
    CCubeMap(CBaseDevice *pDevice,
             DWORD        cpEdge,
             DWORD        cLevels,
             DWORD        dwUsage,
             D3DFORMAT    UserFormat,
             D3DFORMAT    RealFormat,
             D3DPOOL      Pool,
             REF_TYPE     refType,
             HRESULT     *phr
             );

    // Internally keep track of current
    // set of dirty rects
    void InternalAddDirtyRect(DWORD iFace, CONST RECT *pRect);

    // Helpful accessor for getting to a particular
    // level of the cube-map
#undef DPF_MODNAME
#define DPF_MODNAME "CCubeMap::GetSurface"

    CCubeSurface *GetSurface(D3DCUBEMAP_FACES FaceType, DWORD iLevel)
    {
        DXGASSERT(FaceType <= CUBEMAP_MAXFACES);
        DXGASSERT(iLevel < m_cLevels);
        DXGASSERT(m_prgCubeSurfaces);
        return m_prgCubeSurfaces[FaceType * m_cLevels + iLevel];
    } // GetSurface

    // Each cubemap has an array of CCubeSurfaces
    CCubeSurface   **m_prgCubeSurfaces;

    // Each cubemap has a memory block that holds
    // all the pixel data in a contiguous chunk
    BYTE            *m_rgbPixels;

    // Keep track of how much memory we needed
    // for an entire face (including alignment padding)
    DWORD            m_cbSingleFace;

    // Keep track of description
    D3DSURFACE_DESC  m_desc;

    // In DX7 we kept track of upto 6 RECTs per mip-chain.
    // These rects indicate which portion of the top-most level of
    // a mip-chain were modified. (We continue to ignore modifications
    // to lower levels of the mip-chain. This is by-design.)
    //
    // NOTE: However, for cube-maps, it isn't clear what the right
    // dirty rect system ought to be. So we keep track of one
    // rect per-face (which is a union of all the locks taken
    // on that face). If we have a real-world app using managed
    // cube-maps, we really should profile it and examine usage
    // patterns.

    enum
    {
        CUBEMAP_MAXFACES = 6,
    };

    RECT    m_DirtyRectArray[CUBEMAP_MAXFACES];

    // To ease processing, we also keep the following data
    BOOL    m_IsFaceCleanArray[CUBEMAP_MAXFACES];
    BOOL    m_IsFaceAllDirtyArray[CUBEMAP_MAXFACES];
    BOOL    m_IsAnyFaceDirty;

}; // class CCubeMap

#endif // __CUBEMAP_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\cubesurf.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       cubesurf.cpp
 *  Content:    Implementation of the CCubeSurface class
 *
 *
 ***************************************************************************/

#include "ddrawpr.h"
#include "cubesurf.hpp"

// IUnknown methods

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeSurface::QueryInterface"

STDMETHODIMP CCubeSurface::QueryInterface(REFIID riid, 
                                          void **ppvObj)
{
    API_ENTER(Device());

    if (!VALID_PTR_PTR(ppvObj))
    {
        DPF_ERR("Invalid ppvObj parameter for Surface of a Cube Texture");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_PTR(&riid, sizeof(GUID)))
    {
        DPF_ERR("Invalid guid memory address to QueryInterface for Surface of a Cube Texture");
        return D3DERR_INVALIDCALL;
    }

    if (riid == IID_IDirect3DSurface8  || 
        riid == IID_IUnknown)
    {
        *ppvObj = static_cast<void*>(static_cast<IDirect3DSurface8 *>(this));
        AddRef();
        return S_OK;
    }

    DPF_ERR("Unsupported Interface identifier passed to QueryInterface for Surface of a Cubemap");

    // Null out param
    *ppvObj = NULL;
    return E_NOINTERFACE;
} // QueryInterface

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeSurface::AddRef"

STDMETHODIMP_(ULONG) CCubeSurface::AddRef()
{
    API_ENTER_NO_LOCK(Device());    
#ifdef DEBUG
    m_cRefDebug++;
#endif // DEBUG

    return m_pParent->AddRefImpl();
} // AddRef

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeSurface::Release"

STDMETHODIMP_(ULONG) CCubeSurface::Release()
{
    API_ENTER_SUBOBJECT_RELEASE(Device());    
#ifdef DEBUG
    m_cRefDebug--;
    if (m_cRefDebug & 0x80000000)
    {
        DPF_ERR("A level of a cube-map has been released more often than it has been add-ref'ed! Danger!!");
    }
#endif // DEBUG

    return m_pParent->ReleaseImpl();
} // Release

// IBuffer methods
#undef DPF_MODNAME
#define DPF_MODNAME "CCubeSurface::SetPrivateData"

STDMETHODIMP CCubeSurface::SetPrivateData(REFGUID   riid, 
                                          CONST void     *pvData, 
                                          DWORD     cbData, 
                                          DWORD     dwFlags)
{
    API_ENTER(Device());

    return m_pParent->SetPrivateDataImpl(riid, 
                                         pvData, 
                                         cbData, 
                                         dwFlags, 
                                         CombinedFaceLevel());
} // SetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeSurface::GetPrivateData"

STDMETHODIMP CCubeSurface::GetPrivateData(REFGUID   riid, 
                                          void     *pvData, 
                                          DWORD    *pcbData)
{
    API_ENTER(Device());

    return m_pParent->GetPrivateDataImpl(riid,
                                         pvData,
                                         pcbData,
                                         CombinedFaceLevel());

} // GetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeSurface::FreePrivateData"

STDMETHODIMP CCubeSurface::FreePrivateData(REFGUID riid)
{
    API_ENTER(Device());

    return m_pParent->FreePrivateDataImpl(riid,
                                          CombinedFaceLevel());
} // FreePrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeSurface::GetContainer"

STDMETHODIMP CCubeSurface::GetContainer(REFIID riid, 
                                        void **ppContainer)
{
    API_ENTER(Device());

    return m_pParent->QueryInterface(riid, ppContainer);
} // OpenContainer

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeSurface::GetDevice"

STDMETHODIMP CCubeSurface::GetDevice(IDirect3DDevice8 ** ppDevice)
{
    API_ENTER(Device());

    return m_pParent->GetDevice(ppDevice);
} // OpenDevice


// IDirect3DSurface methods

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeSurface::GetDesc"

STDMETHODIMP CCubeSurface::GetDesc(D3DSURFACE_DESC *pDesc)
{
    API_ENTER(Device());

    // If parameters are bad, then we should fail some stuff
    if (!VALID_WRITEPTR(pDesc, sizeof(D3DSURFACE_DESC)))
    {
        DPF_ERR("bad pointer for pDesc passed to GetDesc for Surface of a Cubemap");
        return D3DERR_INVALIDCALL;
    }

    // The internal desc indicates the real
    // format and pool. We need to report
    // back the original data
    *pDesc = InternalGetDesc();

    pDesc->Pool   = m_pParent->GetUserPool();
    pDesc->Format = m_pParent->GetUserFormat();
    pDesc->Usage &= D3DUSAGE_EXTERNAL;

    // We're done
    return S_OK;

} // GetDesc

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeSurface::InternalGetDesc"

D3DSURFACE_DESC CCubeSurface::InternalGetDesc() const
{
    D3DSURFACE_DESC desc;

    // Start from the parent's desc
    desc = *m_pParent->Desc();

    // Width and height are the shifted from the parent 
    desc.Width  >>= m_iLevel;
    desc.Height >>= m_iLevel;

    if (desc.Width == 0)
    {
        desc.Width = 1;
    }

    if (desc.Height == 0)
    {
        desc.Height = 1;
    }

    // Modify the type
    desc.Type    = D3DRTYPE_SURFACE;

    // Modify the size field
    desc.Size = CPixel::ComputeSurfaceSize(desc.Width, 
                                           desc.Height, 
                                           desc.Format);

    // We're done
    return desc;
} // InternalGetDesc


#undef DPF_MODNAME
#define DPF_MODNAME "CCubeSurface::LockRect"

STDMETHODIMP CCubeSurface::LockRect(D3DLOCKED_RECT *pLockedRectData, 
                                    CONST RECT     *pRect, 
                                    DWORD           dwFlags)
{   
    API_ENTER(Device());

    // If parameters are bad, then we should fail some stuff
    if (!VALID_WRITEPTR(pLockedRectData, sizeof(D3DLOCKED_RECT)))
    {
        DPF_ERR("bad pointer for pLockedRectData passed to LockRect for Surface of a Cubemap");
        return D3DERR_INVALIDCALL;
    }

    // Zero out returned data
    ZeroMemory(pLockedRectData, sizeof(D3DLOCKED_RECT));

    // Validate Rect
    if (pRect != NULL)
    {
        DWORD Width  = m_pParent->Desc()->Width  >> m_iLevel;
        DWORD Height = m_pParent->Desc()->Height >> m_iLevel;

        if (!CPixel::IsValidRect(m_pParent->Desc()->Format,
                                 Width, 
                                 Height, 
                                 pRect))
        {
            DPF_ERR("LockRect for a level of a Cube Texture failed");
            return D3DERR_INVALIDCALL;
        }
    }

    if (dwFlags & ~D3DLOCK_SURF_VALID)
    {
        if (dwFlags & D3DLOCK_DISCARD)
        {
            if (dwFlags & D3DLOCK_READONLY)
            {
                DPF_ERR("D3DLOCK_READONLY is not allowed with D3DLOCK_DISCARD");
                return D3DERR_INVALIDCALL;
            }
            if (!(m_pParent->Desc()->Usage & D3DUSAGE_DYNAMIC))
            {
                DPF_ERR("D3DLOCK_DISCARD is allowed only with dynamic textures");
                return D3DERR_INVALIDCALL;
            }
            if (CombinedFaceLevel() > 0)
            {
                DPF_ERR("D3DLOCK_DISCARD is allowed only on D3DCUBEMAP_FACE_POSITIVE_X"
                        " and the top mip level. DISCARD in this case will discard"
                        " the entire cubemap.");
                return D3DERR_INVALIDCALL;
            }
            if (pRect != NULL)
            {
                DPF_ERR("Subrects not allowed with D3DLOCK_DISCARD");
                return D3DERR_INVALIDCALL;
            }
        }
        else
        {
            DPF_ERR("Invalid dwFlags parameter passed to LockRect for Surface of a Cubemap");
            DPF_EXPLAIN_BAD_LOCK_FLAGS(0, dwFlags & ~D3DLOCK_SURF_VALID);
            return D3DERR_INVALIDCALL;
        }
    }

    if (!m_isLockable)
    {
        m_pParent->ReportWhyLockFailed();
        return D3DERR_INVALIDCALL;
    }

    return InternalLockRect(pLockedRectData, pRect, dwFlags);
} // LockRect

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeSurface::InternalLockRect"

HRESULT CCubeSurface::InternalLockRect(D3DLOCKED_RECT *pLockedRectData, 
                                       CONST RECT     *pRect, 
                                       DWORD           dwFlags)
{   

    // Only one lock outstanding at a time is supported
    if (m_isLocked)
    {
        DPF_ERR("LockRect failed on a cube map level; surface was already locked.");
        return D3DERR_INVALIDCALL;
    }

    // Notify the parent/device if we are about to be modified
    if ( (m_pParent->GetUserPool() != D3DPOOL_SCRATCH) && (!(dwFlags & D3DLOCK_READONLY)) )
    {
        m_pParent->OnSurfaceLock(m_iFace, m_iLevel, pRect, dwFlags);
    }

    // Fill out the locked rect structure
    m_pParent->ComputeCubeMapOffset(m_iFace,
                                    m_iLevel,
                                    pRect,
                                    pLockedRectData);


    DXGASSERT(pLockedRectData->pBits != NULL);
    
    // Mark ourselves as locked
    m_isLocked = 1;

    // Done
    return S_OK;
} // InternalLockRect

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeSurface::UnlockRect"

STDMETHODIMP CCubeSurface::UnlockRect()
{
    API_ENTER(Device());

    // If we aren't locked; then something is wrong
    if (m_isLocked == 0)
    {
        DPF_ERR("UnlockRect failed on a cube map level; surface wasn't locked.");
        return D3DERR_INVALIDCALL;
    }
    DXGASSERT(m_isLockable);

    return InternalUnlockRect();
} // UnlockRect

#undef DPF_MODNAME
#define DPF_MODNAME "CCubeSurface::InternalUnlockRect"

HRESULT CCubeSurface::InternalUnlockRect()
{
    // Clear our locked state
    m_isLocked = 0;

    // If we are lock-once; then we mark ourselves as not lockable
    if (m_pParent->Desc()->Usage & D3DUSAGE_LOADONCE)
    {
        m_isLockable = FALSE;
    }

    // Done
    return S_OK;
} // InternalUnlockRect


//
// CDriverCubeSurface class modifies the implementation
// of the LockRect and UnlockRect methods of the CCubeSurface class
//

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverCubeSurface::LockRect"

STDMETHODIMP CDriverCubeSurface::LockRect(D3DLOCKED_RECT *pLockedRectData, 
                                          CONST RECT     *pRect, 
                                          DWORD           dwFlags)
{   
    API_ENTER(Device());

    // If parameters are bad, then we should fail some stuff
    if (!VALID_WRITEPTR(pLockedRectData, sizeof(D3DLOCKED_RECT)))
    {
        DPF_ERR("bad pointer for m_pLockedRectData passed to LockRect for Surface of a driver-allocated Cubemap");
        return D3DERR_INVALIDCALL;
    }

    // Zero out returned data
    ZeroMemory(pLockedRectData, sizeof(D3DLOCKED_RECT));

    // Validate Rect
    if (pRect != NULL)
    {
        DWORD Width  = m_pParent->Desc()->Width  >> m_iLevel;
        DWORD Height = m_pParent->Desc()->Height >> m_iLevel;

        if (!CPixel::IsValidRect(m_pParent->Desc()->Format,
                                 Width, 
                                 Height, 
                                 pRect))
        {
            DPF_ERR("LockRect for a level of a Cube Texture failed");
            return D3DERR_INVALIDCALL;
        }
    }

    if (dwFlags & ~D3DLOCK_SURF_VALID)
    {
        if (dwFlags & D3DLOCK_DISCARD)
        {
            if (dwFlags & D3DLOCK_READONLY)
            {
                DPF_ERR("D3DLOCK_READONLY is not allowed with D3DLOCK_DISCARD");
                return D3DERR_INVALIDCALL;
            }
            if (!(m_pParent->Desc()->Usage & D3DUSAGE_DYNAMIC))
            {
                DPF_ERR("D3DLOCK_DISCARD is allowed only with dynamic textures");
                return D3DERR_INVALIDCALL;
            }
            if (CombinedFaceLevel() > 0)
            {
                DPF_ERR("D3DLOCK_DISCARD is allowed only on D3DCUBEMAP_FACE_POSITIVE_X"
                        " and the top mip level. DISCARD in this case will discard"
                        " the entire cubemap.");
                return D3DERR_INVALIDCALL;
            }
            if (pRect != NULL)
            {
                DPF_ERR("Subrects not allowed with D3DLOCK_DISCARD");
                return D3DERR_INVALIDCALL;
            }
        }
        else
        {
            DPF_ERR("Invalid dwFlags parameter passed to LockRect for a Surface of a driver allocated Cubemap");
            DPF_EXPLAIN_BAD_LOCK_FLAGS(0, dwFlags & ~D3DLOCK_SURF_VALID);
            return D3DERR_INVALIDCALL;
        }
    }

    if (!m_isLockable)
    {
        m_pParent->ReportWhyLockFailed();
        return D3DERR_INVALIDCALL;
    }

    return InternalLockRect(pLockedRectData, pRect, dwFlags);
} // CDriverCubeSurface::LockRect


#undef DPF_MODNAME
#define DPF_MODNAME "CDriverCubeSurface::InternalLockRect"

HRESULT CDriverCubeSurface::InternalLockRect(D3DLOCKED_RECT *pLockedRectData, 
                                             CONST RECT     *pRect, 
                                             DWORD           dwFlags)
{   
    // Only one lock outstanding at a time is supported
    if (m_isLocked)
    {
        DPF_ERR("LockRect failed on a Cube level; surface was already locked.");
        return D3DERR_INVALIDCALL;
    }

    // Notify the parent/device if we are about to be accessed.
    // Driver textures may be written to by HW through 
    // SRT/DrawPrim as well as UpdateTexture. So we may need to sync 
    // with the current command batch.
    m_pParent->OnSurfaceLock(m_iFace, m_iLevel, pRect, dwFlags);

    // Prepare a LockData structure for the HAL call
    D3D8_LOCKDATA lockData;
    ZeroMemory(&lockData, sizeof lockData);

    lockData.hDD        = m_pParent->Device()->GetHandle();
    lockData.hSurface   = m_hKernelHandle;
    lockData.dwFlags    = dwFlags;
    if (pRect != NULL)
    {
        lockData.bHasRect = TRUE;
        lockData.rArea = *((RECTL *) pRect);
    }
    
    HRESULT hr = m_pParent->Device()->GetHalCallbacks()->Lock(&lockData);
    if (FAILED(hr))
    {
        DPF_ERR("Failed to lock driver cube-map surface");
        return hr;
    }

    // Fill in the Locked_Rect fields 
    D3DFORMAT Format = m_pParent->Desc()->Format;
    if (CPixel::IsDXT(Format))
    {
        // Pitch is the number of bytes for
        // one row's worth of blocks for linear formats

        // Start with our width
        UINT Width = m_pParent->Desc()->Width >> m_iLevel;

        // Convert to blocks
        Width = Width / 4;

        // At least one block
        if (Width == 0)
            Width = 1;

        if (Format == D3DFMT_DXT1)
        {
            // 8 bytes per block for DXT1
            pLockedRectData->Pitch = Width * 8;
        }
        else
        {
            // 16 bytes per block for DXT2-5
            pLockedRectData->Pitch = Width * 16;
        }
    }
    else
    {
        pLockedRectData->Pitch = lockData.lPitch;
    }

    pLockedRectData->pBits  = lockData.lpSurfData;

#ifdef DEBUG
    if ((dwFlags & D3DLOCK_DISCARD))
    {
        DXGASSERT(m_iLevel == 0 && m_iFace == 0);
        if (!CPixel::IsFourCC(Format) &&
            !CPixel::IsIHVFormat(Format))
        {
            DXGASSERT(pRect == NULL);
            memset(pLockedRectData->pBits, 0xDD, pLockedRectData->Pitch * m_pParent->Desc()->Height);
            for (UINT j = 0; j < 6; ++j)
            {
                for (UINT i = 0; i < m_pParent->GetLevelCount(); ++i)
                {
                    if (i != 0 || j != 0)
                    {
                        DXGASSERT(i != 0 || j != 0);
                        D3DLOCKED_RECT Rect;
                        HRESULT hr = m_pParent->LockRect((D3DCUBEMAP_FACES)j, i, &Rect, NULL, 0);
                        if (FAILED(hr))
                        {
                            DPF(1, "Lock to cube mipsublevel failed. Not good.");
                            break;
                        }
                        D3DSURFACE_DESC LevelDesc;
                        m_pParent->GetLevelDesc(i, &LevelDesc);
                        memset(Rect.pBits, 0xDD, Rect.Pitch * LevelDesc.Height);
                        m_pParent->UnlockRect((D3DCUBEMAP_FACES)j, i);
                    }
                }
            }
        }
    }
#endif // DEBUG

    // Mark ourselves as locked
    m_isLocked = 1;

    // Done
    return S_OK;
} // CDriverCubeSurface::InternalLockRect

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverCubeSurface::UnlockRect"

STDMETHODIMP CDriverCubeSurface::UnlockRect()
{
    API_ENTER(Device());

    // If we aren't locked; then something is wrong
    if (m_isLocked == 0)
    {
        DPF_ERR("UnlockRect failed on a driver-allocated Cube level; surface wasn't locked.");
        return D3DERR_INVALIDCALL;
    }
    DXGASSERT(m_isLockable);
    return InternalUnlockRect();
} // CDriverCubeSurface::UnlockRect

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverCubeSurface::UnlockRect"

HRESULT CDriverCubeSurface::InternalUnlockRect()
{

    // Call the driver to perform the unlock
    D3D8_UNLOCKDATA unlockData = {
        m_pParent->Device()->GetHandle(),
        m_hKernelHandle
    };

    HRESULT hr = Device()->GetHalCallbacks()->Unlock(&unlockData);
    if (FAILED(hr))
    {
        DPF_ERR("Driver cube-map surface failed to unlock");
        return hr;
    }

    // Clear our locked state
    m_isLocked = 0;

    // If we are lock-once; then we mark ourselves as not lockable
    if (m_pParent->Desc()->Usage & D3DUSAGE_LOADONCE)
    {
        m_isLockable = FALSE;
    }

    // Done
    return S_OK;
} // CDriverCubeSurface::InternalUnlockRect


// End of file : cubesurf.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\buffer.hpp ===
#ifndef __BUFFER_HPP__
#define __BUFFER_HPP__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       buffer.hpp
 *  Content:    Class header the buffer base class; this class
 *              contains all the logic that is shared between
 *              the Index/Vertex/Command buffer types.
 *
 ***************************************************************************/

// Includes
#include "resource.hpp"

//
// The CBuffer is a base class for the index and vertex buffers
//

class CBuffer : public CResource
{
public:
    // Methods for Resource management
    virtual HRESULT UpdateDirtyPortion(CResource *pResourceTarget) { return S_OK; }
    virtual void MarkAllDirty();

    virtual BYTE* Data() const = 0;

    BOOL IsLocked() const
    {
        return m_LockCount > 0;
    } // IsLocked

protected:
    // Constructor returns an error code
    // if the object could not be fully
    // constructed
    CBuffer(CBaseDevice     *pDevice,
            DWORD            cbLength,
            DWORD            dwFVF,
            D3DFORMAT        Format,
            D3DRESOURCETYPE  Type,
            DWORD            Usage,
            DWORD            ActualUsage,
            D3DPOOL          Pool,
            D3DPOOL          ActualPool,
            REF_TYPE         refType,
            HRESULT         *phr
            );

    void LockImpl(UINT cbOffsetToLock,
                  UINT cbSizeToLock,
                  BYTE **ppbData,
                  DWORD dwFlags,
                  DWORD cbLength)
    {
        *ppbData = m_pbBuffer + cbOffsetToLock;

        // Do dirty rect stuff
        if (IsD3DManaged() && (dwFlags & D3DLOCK_READONLY) == 0)
        {
            OnBufferChangeImpl(cbOffsetToLock, cbSizeToLock);
        }
    }

    void OnBufferChangeImpl(UINT cbOffsetToLock, UINT cbSizeToLock);

    BYTE* GetPrivateDataPointer() const
    {
        return m_pbBuffer;
    }

#if DBG
    BOOL    m_isLockable;
    DWORD   m_SceneStamp;
    DWORD   m_TimesLocked;
#endif // DBG

    DWORD   m_LockCount;
    DWORD   m_cbDirtyMin;
    DWORD   m_cbDirtyMax;

    // Destructor
    virtual ~CBuffer();

private:

    BYTE   *m_pbBuffer;
}; // class CBuffer

// HACK: Ok; here's a minimal command buffer... This is probably not
// the final implementation; but hey there you go.
class CCommandBuffer : public CBuffer
{
public:
    // Static creation method
    static HRESULT Create(CBaseDevice *pDevice,
                          DWORD cbLength,
                          D3DPOOL Pool,
                          CCommandBuffer **ppIndexBuffer);

    HRESULT Clone(D3DPOOL    Pool,
                  CResource **ppResource) const;

    const D3DBUFFER_DESC * GetBufferDesc() const
    {
        return &m_desc;
    } // GetDesc

    // You must call Release to free this guy. No support for
    // addref
    UINT Release()
    {
        return ReleaseImpl();
    };

    // Lock and Unlock support

    STDMETHOD(Lock)(THIS_
                    UINT cbOffsetToLock,
                    UINT cbSizeToLock,
                    BYTE **ppbData,
                    DWORD dwFlags)
    {
#if DBG
        if (m_LockCount != 0)
        {
            DPF_ERR("Lock failed for command buffer; buffer was already locked.");
            return D3DERR_INVALIDCALL;
        }
#endif // DBG

        m_LockCount = 1;

        LockImpl(cbOffsetToLock,
                 cbSizeToLock,
                 ppbData,
                 dwFlags,
                 m_cbLength);
        return S_OK;
    } // Lock

    STDMETHOD(Unlock)(THIS)
    {
#if DBG
        // If we aren't locked; then something is wrong
        if (m_LockCount != 1)
        {
            DPF_ERR("Unlock failed on a command buffer; buffer wasn't locked.");
            return D3DERR_INVALIDCALL;
        }
#endif // DBG

        // Clear our locked state
        m_LockCount = 0;

        return S_OK;
    } // Unlock

    BYTE* Data() const
    {
        DXGASSERT(FALSE); // Direct access not supported
        return 0;
    }

private:
    CCommandBuffer(CBaseDevice *pDevice,
                   DWORD        cbLength,
                   D3DPOOL     Pool,
                   HRESULT     *phr)
                  :
        CBuffer(pDevice,
                cbLength,
                0,                      // dwFVF
                D3DFMT_UNKNOWN,
                D3DRTYPE_COMMANDBUFFER,
                D3DUSAGE_LOCK,          // Usage
                D3DUSAGE_LOCK,          // ActualUsage
                Pool,                   // Pool
                Pool,                   // ActualPool
                REF_INTERNAL,
                phr),
        m_cbLength(cbLength)
    {
        m_desc.Pool    = Pool;
        m_desc.Usage   = 0;
        m_desc.Format  = D3DFMT_UNKNOWN;
        m_desc.Type    = D3DRTYPE_COMMANDBUFFER;

    }; // CCommandBuffer::CCommandBuffer

    DWORD           m_cbLength;
    D3DBUFFER_DESC m_desc;
}; // class CCommandBuffer


#endif // __BUFFER_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\dbgtopic.h ===
//emp-u-ty
#undef DPF_CONTROL_LINE
#define DPF_CONTROL_LINE "DDrawDebug"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\d3dobj.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3dobj.cpp
 *  Content:    Base class implementation for resources and buffers
 *
 *
 ***************************************************************************/

#include "ddrawpr.h"
#include "d3dobj.hpp"

// Declare static data for CLockD3D
#ifdef DEBUG
DWORD   CLockD3D::m_Count = 0;
#endif // DEBUG

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseObject::AddRefImpl"

// Internal Implementations of AddRef and Release
DWORD CBaseObject::AddRefImpl()
{
    // Internal objects should never be add-ref'ed
    // or released
    DXGASSERT(m_refType != REF_INTERNAL);

    // Only Intrinsic objects should have a ref
    // count of zero. (Internal objects also have
    // a ref count of zero; but AddRef shouldn't
    // be called for those.)
    DXGASSERT(m_cRef > 0 || m_refType == REF_INTRINSIC);

    // The first extra ref for an intrinsic
    // object causes an add-ref to the device
    if (m_cRef == 0)
    {
        DXGASSERT(m_refType == REF_INTRINSIC);

        UINT crefDevice = m_pDevice->AddRef();
        DXGASSERT(crefDevice > 1);
    }

    // InterlockedIncrement requires the memory
    // to be aligned on DWORD boundary
    DXGASSERT(((ULONG_PTR)(&m_cRef) & 3) == 0);
    InterlockedIncrement((LONG *)&m_cRef);

    return m_cRef;
} // AddRefImpl

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseObject::AddRefImpl"

DWORD CBaseObject::ReleaseImpl()
{
    // Internal objects should never be add-ref'ed
    // or released
    DXGASSERT(m_refType != REF_INTERNAL);

    // Assert that we are not being
    // over-released.
    DXGASSERT(m_cRef > 0);

    if (m_cRef == 0)
    {
        // This heinous state can happen if a texture
        // was being held by the device; but not
        // only has the app held onto a pointer to
        // the texture, but they have released
        // their own pointer.

        // For this case, the safest thing to do
        // is return zero instead of crashing.
        return 0;
    }

    // InterlockedDecrement requires the memory
    // to be aligned on DWORD boundary
    DXGASSERT(((ULONG_PTR)(&m_cRef) & 3) == 0);
    InterlockedDecrement((LONG *)&m_cRef);
    if (m_cRef != 0)
    {
        // For a non-zero ref count,
        // just return the value
        return m_cRef;
    }

    // If we are not in use, then we delete ourselves
    // otherwise we wait until we are no longer marked
    // in use
    if (m_cUseCount == 0)
    {
        DXGASSERT(m_cRef == 0);

        // Before deleting a BaseObject,
        // we need to call OnDestroy to make sure that
        // there is nothing pending in the command
        // stream that uses this object
        OnDestroy();

        delete this;
    }
    else
    {
        // To make sure that we don't again release the
        // device at our destructor, we mark the object
        // as being non-external (refcount is zero and usecount is
        // non-zero). At this point, we know the object
        // is not an internal one: hence it was either
        // external or intrinsic. In either case, it could
        // potentially be handed out again (through GetBackBuffer or
        // GetTexture) and so we need to handle the case
        // where AddRef might be called. We mark the object as
        // INTRINSIC to indicate that that even though we don't
        // have a Ref on the device (as soon as we release it below),
        // we may need to acquire one if it gets add-ref'ed.
        DXGASSERT(m_refType != REF_INTERNAL);
        m_refType = REF_INTRINSIC;

        // We are still in use by the device; but we don't
        // have any external references; so we can
        // release our reference on the device. (Note that
        // even though this should be done before
        // changing the reftype, this must be the LAST
        // thing we do in this function.)
        m_pDevice->Release();

        // But this could have been the LAST reference to the
        // device; which means that device will now have
        // freed us; and the current object has now been
        // deleted. So don't access any member data!!
        //
        // How can this happen? Imagine an app that releases
        // everything except an external vb that is the current
        // stream source: in this case, the only device ref is from
        // the external object; but that extrenal object has a use
        // count of 1; when the app calls release on the
        // the vb, we end up here; calling release on the device
        // causes in turn a call to DecrementUseCount on the
        // current object; which causes the object to be freed.
    }

    // DO NOT PUT CODE HERE (see comment above)

    return 0;
} // ReleaseImpl


#undef DPF_MODNAME
#define DPF_MODNAME "CBaseObject::SetPrivateDataImpl"

// Internal function that adds some private data
// information to an object. Supports having private
// data for multiple levels through the optional
// iLevel parameter
HRESULT CBaseObject::SetPrivateDataImpl(REFGUID refguidTag,
                                        CONST VOID*  pvData,
                                        DWORD   cbSize,
                                        DWORD   dwFlags,
                                        BYTE    iLevel)
{
    if (cbSize > 0 &&
        !VALID_PTR(pvData, cbSize))
    {
        DPF_ERR("Invalid pvData pointer to SetPrivateData");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_PTR(&refguidTag, sizeof(GUID)))
    {
        DPF_ERR("Invalid guid to SetPrivateData");
        return D3DERR_INVALIDCALL;
    }

    if (dwFlags & ~D3DSPD_IUNKNOWN)
    {
        DPF_ERR("Invalid flags to SetPrivateData");
        return D3DERR_INVALIDCALL;
    }

    if (dwFlags & D3DSPD_IUNKNOWN)
    {
        if (cbSize != sizeof(LPVOID))
        {
            DPF_ERR("Invalid size for IUnknown to SetPrivateData");
            return D3DERR_INVALIDCALL;
        }
    }

    // Remember if we allocated a new node or
    // not for error handling
    BOOL fNewNode;

    // Find the node in our list (if there)
    CPrivateDataNode *pNode = Find(refguidTag, iLevel);
    if (pNode)
    {
        // Clean up whatever it has already
        pNode->Cleanup();
        fNewNode = FALSE;
    }
    else
    {
        // Allocate a new node
        pNode = new CPrivateDataNode;
        if (pNode == NULL)
        {
            DPF_ERR("SetPrivateData failed a memory allocation");
            return E_OUTOFMEMORY;
        }

        // Initialize a few fields
        fNewNode = TRUE;
        pNode->m_guid = refguidTag;
        pNode->m_iLevel = iLevel;
    }

    // Initialize the other fields
    pNode->m_dwFlags = dwFlags;
    pNode->m_cbSize = cbSize;

    // Copy the data portion over
    if (dwFlags & D3DSPD_IUNKNOWN)
    {
        // We add-ref the object while we
        // keep a pointer to it
        pNode->m_pUnknown = (IUnknown *)pvData;
        pNode->m_pUnknown->AddRef();
    }
    else
    {
        // Allocate a buffer to store our data
        // into
        pNode->m_pvData = new BYTE[cbSize];
        if (pNode->m_pvData == NULL)
        {
            DPF_ERR("SetPrivateData failed a memory allocation");
            // If memory allocation failed,
            // then we may need to free the Node
            if (fNewNode)
            {
                delete pNode;
            }
            return E_OUTOFMEMORY;
        }
        memcpy(pNode->m_pvData, pvData, cbSize);
    }

    // If we allocated a new Node then
    // we need to put it into our list somewhere
    if (fNewNode)
    {
        // Stuff it at the beginning
        pNode->m_pNodeNext = m_pPrivateDataHead;
        m_pPrivateDataHead = pNode;
    }

    return S_OK;
} // CBaseObject::SetPrivateDataImpl

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseObject::GetPrivateDataImpl"

// Internal function that searches the private data list
// for a match. This supports a single list for a container
// and all of its children by using the iLevel parameter.
HRESULT CBaseObject::GetPrivateDataImpl(REFGUID refguidTag,
                                        LPVOID  pvBuffer,
                                        LPDWORD pcbSize,
                                        BYTE    iLevel) const
{
    if (!VALID_WRITEPTR(pcbSize, sizeof(DWORD)))
    {
        DPF_ERR("Invalid pcbSize pointer to GetPrivateData");
        return D3DERR_INVALIDCALL;
    }

    if (pvBuffer)
    {
        if (*pcbSize > 0 &&
            !VALID_WRITEPTR(pvBuffer, *pcbSize))
        {
            DPF_ERR("Invalid pvData pointer to GetPrivateData");
            return D3DERR_INVALIDCALL;
        }
    }

    if (!VALID_PTR(&refguidTag, sizeof(GUID)))
    {
        DPF_ERR("Invalid guid to GetPrivateData");
        return D3DERR_INVALIDCALL;
    }

    // Find the node in our list
    CPrivateDataNode *pNode = Find(refguidTag, iLevel);
    if (pNode == NULL)
    {
        DPF_ERR("GetPrivateData failed to find a match.");
        return D3DERR_NOTFOUND;
    }

    // Is the user just asking for the size?
    if (pvBuffer == NULL)
    {
        // Return the amount of buffer that was used
        *pcbSize = pNode->m_cbSize;

        // Return Ok in this case.
        return S_OK;
    }

    // Check if we were given a large enough buffer
    if (*pcbSize < pNode->m_cbSize)
    {
        DPF(2, "GetPrivateData called with insufficient buffer.");

        // If the buffer is insufficient, return
        // the necessary size in the out parameter
        *pcbSize = pNode->m_cbSize;

        // An error is returned since pvBuffer != NULL and
        // no data was actually returned.
        return D3DERR_MOREDATA;
    }

    // There is enough room; so just overwrite with
    // the right size
    *pcbSize = pNode->m_cbSize;

    // Handle the IUnknown case
    if (pNode->m_dwFlags & D3DSPD_IUNKNOWN)
    {
        *(IUnknown**)pvBuffer = pNode->m_pUnknown;

        // We Add-Ref the returned object
        pNode->m_pUnknown->AddRef();
        return S_OK;
    }

    memcpy(pvBuffer, pNode->m_pvData, pNode->m_cbSize);
    return S_OK;

} // CBaseObject::GetPrivateDataImpl

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseObject::FreePrivateDataImpl"

HRESULT CBaseObject::FreePrivateDataImpl(REFGUID refguidTag,
                                         BYTE    iLevel)
{
    if (!VALID_PTR(&refguidTag, sizeof(GUID)))
    {
        DPF_ERR("Invalid guid to FreePrivateData");
        return D3DERR_INVALIDCALL;
    }

    // Keep track of the address of the pointer
    // that points to our current node
    CPrivateDataNode **ppPrev = &m_pPrivateDataHead;

    // Keep track of our current node
    CPrivateDataNode *pNode = m_pPrivateDataHead;

    // Find the node in our list
    while (pNode)
    {
        // A match means that iLevel AND the guid
        // match up
        if (pNode->m_iLevel == iLevel &&
            pNode->m_guid   == refguidTag)
        {
            // If found, update the pointer
            // the points to the current node to
            // point to our Next
            *ppPrev = pNode->m_pNodeNext;

            // Delete the current node
            delete pNode;

            // We're done
            return S_OK;
        }

        // Update our previous pointer address
        ppPrev = &pNode->m_pNodeNext;

        // Update our current node to point
        // to the next node
        pNode = pNode->m_pNodeNext;
    }

    DPF_ERR("FreePrivateData called but failed to find a match");
    return D3DERR_NOTFOUND;
} // CBaseObject::FreePrivateDataImpl

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseObject::Find"

// Helper function to iterate through the list of
// data members
CBaseObject::CPrivateDataNode * CBaseObject::Find(REFGUID refguidTag,
                                                  BYTE iLevel) const
{
    CPrivateDataNode *pNode = m_pPrivateDataHead;
    while (pNode)
    {
        if (pNode->m_iLevel == iLevel &&
            pNode->m_guid   == refguidTag)
        {
            return pNode;
        }
        pNode = pNode->m_pNodeNext;
    }
    return NULL;
} // CBaseObject::Find

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseObject::CPrivateDataNode::Cleanup"

void CBaseObject::CPrivateDataNode::Cleanup()
{
    if (m_dwFlags & D3DSPD_IUNKNOWN)
    {
        DXGASSERT(m_cbSize == sizeof(IUnknown *));
        m_pUnknown->Release();
    }
    else
    {
        delete [] m_pvData;
    }
    m_pvData = NULL;
    m_cbSize = 0;
    m_dwFlags &= ~D3DSPD_IUNKNOWN;

    return;
} // CBaseObject::CPrivateDataNode::Cleanup



// End of file : d3dobj.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\cubesurf.hpp ===
#ifndef __CUBESURF_HPP__
#define __CUBESURF_HPP__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       cubesurf.hpp
 *  Content:    Class header the cubesurface class. This class acts
 *              as a level for the CubeMap class. The base class
 *              assumes a system-memory allocation; while the
 *              Driver sub-class will call the driver for every
 *              lock and unlock operation.
 *
 *
 ***************************************************************************/

// Includes
#include "cubemap.hpp"
//
// The CCubeSurface class is a special class that
// works solely with the CCubeMap class. Each CubeSurface
// corresponds to a single level and face of the cube-map. They are
// not stand-alone COM objects because they share the
// same life-time as their CCubeMap parent.
//
// The CDriverCubeSurface class handles
// the driver-managed and vid-mem versions of this
// class. 
//

class CCubeSurface : public CBaseSurface
{
public:

    // Constructor
    CCubeSurface(CCubeMap *pParent, 
                 BYTE      iFace, 
                 BYTE      iLevel,
                 HANDLE    hKernelHandle)
                 :
        m_pParent(pParent),
        m_iFace(iFace),
        m_iLevel(iLevel),
        m_hKernelHandle(hKernelHandle)
    {
        DXGASSERT(hKernelHandle || (pParent->GetUserPool() == D3DPOOL_SCRATCH) );
        DXGASSERT(m_pParent);
    #ifdef DEBUG
        m_cRefDebug = 0; 
    #endif // DEBUG

        if (m_pParent->Desc()->Usage & 
                (D3DUSAGE_LOCK | D3DUSAGE_LOADONCE))
        {
            m_isLockable = TRUE;
        }
        else
        {   
            m_isLockable = FALSE;
        }

    } // CCubeSurface

    ~CCubeSurface()
    {
        DXGASSERT(m_pParent);
        DXGASSERT(m_cRefDebug == 0); 
        if (m_hKernelHandle)
        {
            // Tell the thunk layer that we need to
            // be freed.
            D3D8_DESTROYSURFACEDATA DestroySurfData;
            DestroySurfData.hDD = m_pParent->Device()->GetHandle();
            DestroySurfData.hSurface = m_hKernelHandle;
            m_pParent->Device()->GetHalCallbacks()->DestroySurface(&DestroySurfData);
        }
#ifdef DEBUG
        else
        {
            DXGASSERT(m_pParent->GetUserPool() == D3DPOOL_SCRATCH);
        }
#endif //DEBUG
    }; // ~CCubeSurface

public:
    // IUnknown methods
    STDMETHOD(QueryInterface) (REFIID riid, 
                               LPVOID FAR * ppvObj);
    STDMETHOD_(ULONG,AddRef) ();
    STDMETHOD_(ULONG,Release) ();

    // IBuffer methods
    STDMETHOD(SetPrivateData)(REFGUID riid, 
                              CONST VOID* pvData, 
                              DWORD cbData, 
                              DWORD dwFlags);

    STDMETHOD(GetPrivateData)(REFGUID riid, 
                              LPVOID pvData, 
                              LPDWORD pcbData);

    STDMETHOD(FreePrivateData)(REFGUID riid);

    STDMETHOD(GetContainer)(REFIID riid, 
                            void **ppContainer);

    STDMETHOD(GetDevice)(IDirect3DDevice8 ** ppvObj);

    // IDirect3DSurface8 methods
    STDMETHOD(GetDesc)(D3DSURFACE_DESC *pDesc);

    STDMETHOD(LockRect)(D3DLOCKED_RECT *pLockedRectData, 
                        CONST RECT     *pRect, 
                        DWORD           dwFlags);

    STDMETHOD(UnlockRect)();

    // BaseSurface methods
    virtual DWORD DrawPrimHandle() const
    {
        return D3D8GetDrawPrimHandle(m_hKernelHandle);
    } // GetDrawPrimHandle

    virtual HANDLE KernelHandle() const
    {
        return m_hKernelHandle;
    } // GetKernelHandle
    virtual DWORD IncrementUseCount()
    {
        return m_pParent->IncrementUseCount();
    } // IncrementUseCount

    virtual DWORD DecrementUseCount()
    {
        return m_pParent->DecrementUseCount();
    } // DecrementUseCount

    virtual void Batch()
    {
        m_pParent->Batch();
        return;
    } // Batch

    virtual void Sync()
    {
        m_pParent->Sync();
        return;
    } // Sync

    // Internal lock functions bypass
    // parameter checking and also whether the
    // surface marked as Lockable or LockOnce
    // etc. (Methods of CBaseSurface.)
    virtual HRESULT InternalLockRect(D3DLOCKED_RECT *pLockedRectData, 
                                     CONST RECT     *pRect, 
                                     DWORD           dwFlags);

    virtual HRESULT InternalUnlockRect();

    virtual D3DSURFACE_DESC InternalGetDesc() const;

    // Access the device of the surface
    virtual CBaseDevice *InternalGetDevice() const
    {
        return m_pParent->Device();
    } // InternalGetDevice

    // Determines if a LOAD_ONCE surface has already
    // been loaded
    virtual BOOL IsLoaded() const
    {
        DXGASSERT(m_pParent->Desc()->Usage & D3DUSAGE_LOADONCE);
        if (m_isLockable)
        {
            return FALSE;
        }
        else
        {
            return TRUE;
        }
    } // IsLoaded

    // End Of BaseSurface methods

    // Quick accessor for the device
    // Access the device of the surface
    CBaseDevice *Device() const
    {
        return m_pParent->Device();
    } // Device

protected:
    CCubeMap *m_pParent;
    BOOL      m_isLockable;
    BYTE      m_iLevel;
    BYTE      m_iFace;

    // Helper function so that we can put all
    // the private data into the same list. This
    // returns a value that can be used to tag
    // each of the private datas that are held
    // by the master cubemap. Also, the value
    // of (m_cLevel) is used as the tag for
    // the CubeMap's private data itself
    BYTE CombinedFaceLevel()
    {
        DXGASSERT(m_iLevel < (1<<5));
        DXGASSERT(m_iFace < (1<<3));
        return (m_iFace << 5) + m_iLevel;
    } // CombinedFaceLevel

    // We'll need a kernel handle so that
    // we can communicate to the kernel for
    // the Destroy call
    HANDLE   m_hKernelHandle;

    // Debugging trick to help spew better
    // information if someone over-releases a cubesurface
    // (Since our ref's carry over to the parent object; it
    // means that over-releases can be hard to find.)
#ifdef DEBUG
    DWORD   m_cRefDebug;
#endif // DEBUG

}; // CCubeSurface

// The CDriverCubeSurface is a modification of the base Cube-map
// class. It keeps track some additional information and overrides
// some of the methods. It implements Lock/Unlock by calling the
// driver; hence it is used for both driver-managed and vid-mem
// surface

class CDriverCubeSurface : public CCubeSurface
{
public:
    // Constructor
    CDriverCubeSurface(CCubeMap *pParent, 
                      BYTE       iFace,
                      BYTE       iLevel,
                      HANDLE     hKernelHandle)
                      :
        CCubeSurface(pParent, iFace, iLevel, hKernelHandle)
    {
    } // Init

    STDMETHOD(LockRect)(D3DLOCKED_RECT *pLockedRectData, 
                        CONST RECT     *pRect, 
                        DWORD            dwFlags);

    STDMETHOD(UnlockRect)(THIS);

    // Internal lock functions bypass
    // parameter checking and also whether the
    // surface marked as Lockable or LockOnce
    // etc. (Methods of CBaseSurface.)
    virtual HRESULT InternalLockRect(D3DLOCKED_RECT *pLockedRectData, 
                                     CONST RECT     *pRect, 
                                     DWORD           dwFlags);

    virtual HRESULT InternalUnlockRect();

}; // CDriverCubeSurface

#endif // __CUBESURF_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\d3dmem.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3dmem.c
 *  Content:    Direct3D mem allocation
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10/12/95   stevela Initial rev with this header.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

static D3DMALLOCFUNCTION malloc_function = (D3DMALLOCFUNCTION) MemAlloc;
static D3DFREEFUNCTION free_function = MemFree;

#ifdef __USEGLOBALNEWANDDELETE
//----------------------------------------------------------------------------
// 
// Global new and delete
//
//----------------------------------------------------------------------------
void* operator new(size_t s)
{
    void *p;
    MallocAligned(&p,s);
    return p;
};

void operator delete(void* p)
{
    FreeAligned(p);
};
#endif

#undef DPF_MODNAME
#define DPF_MODNAME "D3DMalloc"

HRESULT D3DAPI D3DMalloc(LPVOID* p_return, size_t size)
{
    void* p;

    if (!VALID_OUTPTR(p_return)) 
    {
        DPF_ERR("Bad pointer given. Memory allocation fails");
        return D3DERR_INVALIDCALL;
    }
    if (size > 0) 
    {
        p = malloc_function(size);
        if (p == NULL)
            return (E_OUTOFMEMORY);
    } 
    else 
    {
        p = NULL;
    }
    *p_return = p;

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "D3DFree"

VOID D3DAPI D3DFree(LPVOID p)
{
    if (p == NULL) 
        return;

    if (!VALID_DWORD_PTR(p)) 
    {
        DPF_ERR("invalid pointer. Memory Free ignored");
        return;
    }
    if (p) 
    {
        free_function(p);
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "MallocAligned"

#define CACHE_LINE 32
HRESULT MallocAligned(void** p_return, size_t size)
{
    char* p;
    size_t offset;
    HRESULT error;

    if (!p_return)
        return D3DERR_INVALIDCALL;

    if (size > 0) 
    {
        if ((error = D3DMalloc((void**) &p, size + CACHE_LINE)) != S_OK)
        {
            *p_return = NULL;
            return error;
        }
        offset = (size_t)(CACHE_LINE - ((ULONG_PTR)p & (CACHE_LINE - 1)));
        p += offset;
        ((size_t*)p)[-1] = offset;
    } 
    else
    {
        p = NULL;
    }
    *p_return = p;
    return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FreeAligned"

void FreeAligned(void* p)
{
    if (p) 
    {
        size_t offset = ((size_t*)p)[-1];
        p = (void*) ((unsigned char*)p - offset);
        D3DFree(p);
    }
}
#undef DPF_MODNAME
#define DPF_MODNAME "CAlignedBuffer32::Grow"

//----------------------------------------------------------------------------
// Growing aligned buffer implementation.
//
HRESULT CAlignedBuffer32::Grow(DWORD growSize)
{
    if (allocatedBuf)
        D3DFree(allocatedBuf);
    size = growSize;
    if (D3DMalloc(&allocatedBuf, size + 31) != S_OK)
    {
        allocatedBuf = 0;
        alignedBuf = 0;
        size = 0;
        return E_OUTOFMEMORY;
    }
    alignedBuf = (LPVOID)(((ULONG_PTR)allocatedBuf + 31 ) & ~31);
    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\d3dobj.hpp ===
#ifndef __D3DOBJ_HPP__
#define __D3DOBJ_HPP__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3dobj.hpp
 *  Content:    Base class header for resources and buffers
 *
 *
 ***************************************************************************/

// Helper function for parameter checking
inline BOOL IsPowerOfTwo(DWORD dwNumber)
{
    if (dwNumber == 0 || (dwNumber & (dwNumber-1)) != 0)
        return FALSE;
    else
        return TRUE;
} // IsPowerOfTwo

// forward decls
class CBaseObject;

// Entry-points that are inside/part of a device/enum may need to
// take a critical section. They do this by putting this
// line of code at the beginning of the API. 
//
// Use API_ENTER for APIs that return an HRESULT; 
// Use API_ENTER_RET for APIs that return a struct (as an out param)
// Use API_ENTER_VOID for APIs that return void.
// Use API_ENTER_SUBOBJECT_RELEASE for Release methods on sub-objects. 
// Use API_ENTER_NOLOCK for Release methods on the Device or Enum itself. 
// Use API_ENTER_NOLOCK for AddRef on anything.
//          
//
// (Release is special because the action of release may cause the 
// destruction of the device/enum; which would free the critical section
// before we got a chance to call Unlock on that critical section.)
//
// The class CLockOwner is a common base class for both CBaseDevice
// and CEnum.

#ifdef DEBUG

    #define API_ENTER(pLockOwner)                                           \
            if (IsBadWritePtr((void *)this, sizeof(*this))             ||   \
                IsBadWritePtr((void *)pLockOwner, sizeof(*pLockOwner)) ||   \
                !pLockOwner->IsValid())                                     \
            {                                                               \
                DPF_ERR("Invalid 'this' parameter to D3D8 API.");           \
                return D3DERR_INVALIDCALL;                                  \
            }                                                               \
            CLockD3D _lock(pLockOwner, DPF_MODNAME, __FILE__)

    // Use this for API's that return something other than an HRESULT
    #define API_ENTER_RET(pLockOwner, RetType)                              \
            if (IsBadWritePtr((void *)this, sizeof(*this))             ||   \
                IsBadWritePtr((void *)pLockOwner, sizeof(*pLockOwner)) ||   \
                !pLockOwner->IsValid())                                     \
            {                                                               \
                DPF_ERR("Invalid 'this' parameter to D3D8 API..");          \
                /* We only allow DWORD types of returns for compat */       \
                /* with C users.                                   */       \
                return (RetType)0;                                          \
            }                                                               \
            CLockD3D _lock(pLockOwner, DPF_MODNAME, __FILE__)

    // Use this for API's that return void
    #define API_ENTER_VOID(pLockOwner)                                      \
            if (IsBadWritePtr((void *)this, sizeof(*this))             ||   \
                IsBadWritePtr((void *)pLockOwner, sizeof(*pLockOwner)) ||   \
                !pLockOwner->IsValid())                                     \
            {                                                               \
                DPF_ERR("Invalid 'this' parameter to D3D8 API...");         \
                return;                                                     \
            }                                                               \
            CLockD3D _lock(pLockOwner, DPF_MODNAME, __FILE__)

    // Use this for Release API's of subobjects i.e. not Device or Enum
    #define API_ENTER_SUBOBJECT_RELEASE(pLockOwner)                         \
            if (IsBadWritePtr((void *)this, sizeof(*this))             ||   \
                IsBadWritePtr((void *)pLockOwner, sizeof(*pLockOwner)) ||   \
                !pLockOwner->IsValid())                                     \
            {                                                               \
                DPF_ERR("Invalid 'this' parameter to D3D8 API....");        \
                return 0;                                                   \
            }                                                               \
            CLockD3D _lock(pLockOwner, DPF_MODNAME, __FILE__, TRUE)

    // Use this for API tracing for methods
    // that don't need a crit-sec lock at-all in Retail.
    #define API_ENTER_NO_LOCK_HR(pLockOwner)                                \
            if (IsBadWritePtr((void *)this, sizeof(*this))             ||   \
                IsBadWritePtr((void *)pLockOwner, sizeof(*pLockOwner)) ||   \
                !pLockOwner->IsValid())                                     \
            {                                                               \
                DPF_ERR("Invalid 'this' parameter to D3D8 API.....");       \
                return D3DERR_INVALIDCALL;                                  \
            }                                                               \
            CNoLockD3D _noLock(DPF_MODNAME, __FILE__)

    // Use this for API tracing for Release for the device or enum 
    // (which is special; see note above). Also for AddRef for anything 
    #define API_ENTER_NO_LOCK(pLockOwner)                                   \
            if (IsBadWritePtr((void *)this, sizeof(*this))             ||   \
                IsBadWritePtr((void *)pLockOwner, sizeof(*pLockOwner)) ||   \
                !pLockOwner->IsValid())                                     \
            {                                                               \
                DPF_ERR("Invalid 'this' parameter to D3D8 API......");      \
                return 0;                                                   \
            }                                                               \
            CNoLockD3D _noLock(DPF_MODNAME, __FILE__)



#else  // !DEBUG

    #define API_ENTER(pLockOwner)                          \
            CLockD3D _lock(pLockOwner)

    #define API_ENTER_RET(pLockOwner, RetType)             \
            CLockD3D _lock(pLockOwner)

    #define API_ENTER_VOID(pLockOwner)                     \
            CLockD3D _lock(pLockOwner)

    #define API_ENTER_SUBOBJECT_RELEASE(pLockOwner)        \
            CLockD3D _lock(pLockOwner, TRUE)

    #define API_ENTER_NO_LOCK(pLockOwner)

    #define API_ENTER_NO_LOCK_HR(pLockOwner)

#endif // !DEBUG

// This is a locking object that is supposed to work with
// the device/enum to determine whether and which critical section needs to
// be taken. The use of a destructor means that "Unlock" will happen
// automatically as part of the destructor

class CLockD3D
{
public:

#ifdef DEBUG
    CLockD3D(CLockOwner *pLockOwner, char *moduleName, char *fileName, BOOL bSubObjectRelease = FALSE)
#else // !DEBUG
    CLockD3D(CLockOwner *pLockOwner, BOOL bSubObjectRelease = FALSE)
#endif // !DEBUG
    {
        // Remember the device
        m_pLockOwner = pLockOwner;

        // Add-ref the LockOwner if there is a risk that
        // that we might cause the LockOwner to go away in processing 
        // the current function i.e. SubObject Release
        if (bSubObjectRelease)
        {
            m_pLockOwner->AddRefOwner(); 
            
            // Remember to unlock it
            m_bNeedToReleaseLockOwner = TRUE;
        }
        else
        {
            // No need to AddRef/Release the device
            m_bNeedToReleaseLockOwner = FALSE;
        }

        // Ask the LockOwner to take a lock for us
        m_pLockOwner->Lock();

#ifdef DEBUG
        m_Count++;
        DPF(6, "*** LOCK_D3D: CNT = %ld %s %s", m_Count, moduleName, fileName);
#endif
    } // CD3DLock

    ~CLockD3D()
    {
#ifdef DEBUG
        DPF(6, "*** UNLOCK_D3D: CNT = %ld", m_Count);
        m_Count--;
#endif // DEBUG

        m_pLockOwner->Unlock();

        // Call Release if we need to
        if (m_bNeedToReleaseLockOwner)
            m_pLockOwner->ReleaseOwner();
    } // ~CD3DLock

private:

#ifdef DEBUG
    static DWORD    m_Count;
#endif // DEBUG

    CLockOwner     *m_pLockOwner;
    BOOL            m_bNeedToReleaseLockOwner;
}; // class CLockD3D

#ifdef DEBUG
// Helper debug-only class for API tracing
class CNoLockD3D
{
public:
    CNoLockD3D(char *moduleName, char *fileName)
    {
        DPF(6, "*** LOCK_D3D: Module= %s %s", moduleName, fileName);
    } // CD3DLock

    ~CNoLockD3D()
    {
        DPF(6, "*** UNLOCK_D3D:");
    } // ~CD3DLock
}; // CNoLockD3D
#endif // DEBUG

//
// This header file contains the base class for all resources and buffers      x
// types of objects
//
// The CBaseObject class contains functionality for the following
// services which can be used by the derived classes:
//          AddRefImpl/ReleaseImpl
//          Get/SetPrivateDataImpl data
//          OpenDeviceImpl
//
// Base objects should allocated with "new" which is means that they
// should be 32-byte aligned by our default allocator.
//
// Resources inherit from CBaseObject and add functionality for
// priority
//

// Add-ref semantics for these objects is complex; a constructor
// flag indicates how/when/if the object will add-ref the device.
typedef enum
{
    // External objects add-ref the device; they are
    // freed by calling Release()
    REF_EXTERNAL  = 0,

    // Intrinsic objects don't add-ref the device
    // except for additional add-refs. They are freed
    // when the number of releases equals the number of
    // addrefs AND the device has called DecrUseCount
    // on the object.
    REF_INTRINSIC = 1,

    // Internal is like intrinsic except that we
    // assert that no one should ever call AddRef or Release
    // on this object at all. To free it, you have to
    // call DecrUseCount
    REF_INTERNAL = 2,

} REF_TYPE;

class CBaseObject
{
public:

    // Provides access to the two handles represent
    // this object to the DDI/TokenStream. Specifically,
    // this represents the Real Sys-Mem data in the
    // case of Managed Resources. (To find
    // the vid-mem mapping for a managed resource;
    // see resource.hpp)
    DWORD BaseDrawPrimHandle() const
    {
        return D3D8GetDrawPrimHandle(m_hKernelHandle);
    } // DrawPrimHandle

    HANDLE BaseKernelHandle() const
    {
        return m_hKernelHandle;
    } // KernelHandle

    // NOTE: No internal object should ever add-ref another
    // internal object; otherwise we may end up with ref-count
    // cycles that prevent anything from ever going away.
    // Instead, an internal object may mark another internal
    // object as being "InUse" which will force it to be kept
    // in memory until it is no-longer in use (and the ref-count
    // is zero.)

    // Internal Implementations of AddRef and Release
    DWORD AddRefImpl();
    DWORD ReleaseImpl();

    DWORD IncrementUseCount()
    {
        DXGASSERT(m_refType != REF_INTERNAL || m_cRef == 0);
        m_cUseCount++;
        return m_cUseCount;
    } // IncrUseCount

    DWORD DecrementUseCount()
    {
        DXGASSERT(m_refType != REF_INTERNAL || m_cRef == 0);
        DXGASSERT(m_cUseCount > 0);
        m_cUseCount--;
        if (m_cUseCount == 0 && m_cRef == 0)
        {
            // Before deleting a BaseObject,
            // we need to call OnDestroy to make sure that
            // there is nothing pending in the command
            // stream that uses this object
            OnDestroy();

            // Ok; now safe to delete the object
            delete this;
            return 0;
        }
        return m_cUseCount;
    } // DecrUseCount

    // Internal implementation functions for
    // the PrivateData set of methods
    HRESULT SetPrivateDataImpl(REFGUID refguidTag,
                               CONST VOID* pvData,
                               DWORD cbSize,
                               DWORD dwFlags,
                               BYTE  iLevel);
    HRESULT GetPrivateDataImpl(REFGUID refguidTag,
                               LPVOID pvBuffer,
                               LPDWORD pcbSize,
                               BYTE iLevel) const;
    HRESULT FreePrivateDataImpl(REFGUID refguidTag,
                                BYTE iLevel);

    // Implements the OpenDevice method
    HRESULT GetDeviceImpl(IDirect3DDevice8 ** ppvInterface) const
    {
        if (!VALID_PTR_PTR(ppvInterface))
        {
            DPF_ERR("Invalid ppvInterface parameter passed to GetDevice");
            return D3DERR_INVALIDCALL;
        }

        return m_pDevice->QueryInterface(IID_IDirect3DDevice8, (void**) ppvInterface);
    }; // OpenDeviceImpl

    CBaseDevice * Device() const
    {
        return m_pDevice;
    } // Device

    // Method to for swapping the underlying identity of
    // a surface. Caller must make sure that we're not locked
    // or other such badness.
    void SwapKernelHandles(HANDLE *phKernelHandle)
    {
        DXGASSERT(m_hKernelHandle != NULL);
        DXGASSERT(*phKernelHandle != NULL);

        HANDLE tmp = m_hKernelHandle;
        m_hKernelHandle = *phKernelHandle;
        *phKernelHandle = tmp;
    }

protected:
    // The following are methods that are only
    // accessible by derived classes: they don't make
    // sense for other classes to call explicitly.

    // Constructor
    //

    CBaseObject(CBaseDevice *pDevice, REF_TYPE ref = REF_EXTERNAL) :
        m_pDevice(pDevice),
        m_refType(ref),
        m_hKernelHandle(NULL)
    {
        DXGASSERT(m_pDevice);
        DXGASSERT(m_refType == REF_EXTERNAL  ||
                  m_refType == REF_INTRINSIC ||
                  m_refType == REF_INTERNAL);

        m_pPrivateDataHead = NULL;
        if (ref == REF_EXTERNAL)
        {
            // External objects add-ref the device
            // as well as having their own reference
            // count set to one
            m_pDevice->AddRef();
            m_cRef     = 1;
            m_cUseCount = 0;
        }
        else
        {
            // Internal and intrinsic objects have no
            // initial ref-count; but they are
            // marked as InUse; the device frees them
            // by calling DecrUseCount
            m_cUseCount = 1;
            m_cRef     = 0;
        }
    }; // CBaseObject

    // The destructor is marked virtual so that delete calls to
    // the base interface will be handled properly
    virtual ~CBaseObject()
    {
        DXGASSERT(m_pDevice);
        DXGASSERT(m_cRef == 0);
        DXGASSERT(m_cUseCount == 0);

        CPrivateDataNode *pNode = m_pPrivateDataHead;
        while (pNode)
        {
            CPrivateDataNode *pNodeNext = pNode->m_pNodeNext;
            delete pNode;
            pNode = pNodeNext;
        }

        if (m_refType == REF_EXTERNAL)
        {
            // Release our reference on the
            // device
            m_pDevice->Release();
        }
    }; // ~CBaseObject

    // OnDestroy function is called just
    // before an object is about to get deleted; we
    // use this to provide synching as well as notification
    // to FE when a texture is going away.
    virtual void OnDestroy()
    {
        // Not all classes have to worry about this;
        // so the default is to do nothing.
    }; // OnDestroy

    void SetKernelHandle(HANDLE hKernelHandle)
    {
        // This better be null; or we either leaking something
        // or we had some uninitialized stuff that will hurt later
        DXGASSERT(m_hKernelHandle == NULL);

        // Remember our handles
        m_hKernelHandle    = hKernelHandle;

        DXGASSERT(m_hKernelHandle != NULL);
    } // SetHandle

    BOOL IsInUse()
    {
        return (m_cUseCount > 0);
    } // IsInUse

private:
    //
    // RefCount must be DWORD aligned
    //
    DWORD m_cRef;

    // Keep a "Use Count" which indicates whether
    // the device (or other object tied to the lifetime of
    // the device) is relying on this object from staying around.
    // This is used to prevent ref-count cycles that would
    // occur whenever something like SetTexture add-ref'ed the
    // the texture that was passed in.
    DWORD m_cUseCount;

    // Keep Track of the device that owns this object
    // This is an add-ref'ed value
    CBaseDevice *m_pDevice;

    // We need an internal handle so that
    // we can communicate to the driver/kernel.
    //
    // Note that the base object does not release this
    // and it is the responsibility of the derived
    // class to do so.
    HANDLE   m_hKernelHandle;

    // Keep track of list of private data objects
    class CPrivateDataNode;
    CPrivateDataNode *m_pPrivateDataHead;

    // Need to keep track of an intrinsic flag
    // to decide whether to release the device on
    // free
    // CONSIDER: Try to merge this flag into some
    // other variable.
    REF_TYPE  m_refType;

    // Helper function to find the right node
    CPrivateDataNode* Find(REFGUID refguidTag, BYTE iLevel) const;

    // Each private data is stored in this node
    // object which is only used for this purpose
    // by this class
    class CPrivateDataNode
    {
    public:
        CPrivateDataNode() {};
        ~CPrivateDataNode()
        {
            Cleanup();
        } // ~CPrivateDateNode

        GUID              m_guid;
        CPrivateDataNode *m_pNodeNext;
        DWORD             m_cbSize;
        DWORD             m_dwFlags;
        BYTE              m_iLevel;
        union
        {
            void         *m_pvData;
            IUnknown     *m_pUnknown;
        };

        void Cleanup();
    }; // CPrivateDataNode

}; // class CBaseObject


// Helper class for all surface types
//
class CBaseSurface : public IDirect3DSurface8
{
public:
    CBaseSurface() :
      m_isLocked(FALSE) {}

    // Methods to allow D3D methods to treat all surface
    // variants the same way
    virtual DWORD  DrawPrimHandle() const PURE;
    virtual HANDLE KernelHandle()   const PURE;

    // See CBaseObject::IncrementUseCount and
    // CBaseObject::DecrementUseCount and the
    // description of the REF_TYPEs above.
    virtual DWORD IncrementUseCount() PURE;
    virtual DWORD DecrementUseCount() PURE;

    // Batching logic is necessary to make sure
    // that the command buffer is flushed before
    // any read or write access is made to a
    // a surface. This should be called at
    // SetRenderTarget time; and it should be
    // called for the currently set rendertarget
    // and zbuffer when the batch count is updated
    virtual void Batch() PURE;

    // Sync should be called when a surface is
    // about to be modified; Normally this is taken
    // care of automatically by Lock; but it also
    // needs to be called prior to using the Blt
    // DDI.
    virtual void Sync() PURE;

    // Internal lock functions bypass
    // parameter checking and also whether the
    // surface marked as Lockable or LockOnce
    // etc.
    virtual HRESULT InternalLockRect(D3DLOCKED_RECT *pLockedRectData,
                                     CONST RECT     *pRect,
                                     DWORD           dwFlags) PURE;
    virtual HRESULT InternalUnlockRect() PURE;

    BOOL IsLocked() const
    {
        return m_isLocked;
    }; // IsLocked

    // Determines if a LOAD_ONCE surface has already
    // been loaded
    virtual BOOL IsLoaded() const PURE;

    // Provides a method to access basic structure of the
    // pieces of the resource.
    virtual D3DSURFACE_DESC InternalGetDesc() const PURE;

    // Access the device of the surface
    virtual CBaseDevice *InternalGetDevice() const PURE;

public:
    BOOL m_isLocked;

}; // class CBaseSurface

#endif // __D3DOBJ_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\ddcreate.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddcreate.c
 *  Content:    DirectDraw create object.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   31-dec-94  craige  initial implementation
 *   13-jan-95  craige  re-worked to updated spec + ongoing work
 *   21-jan-95  craige  made 32-bit + ongoing work
 *   13-feb-94  craige  allow 32-bit callbacks
 *   21-feb-95  craige  disconnect anyone who forgot to do it themselves
 *   27-feb-95  craige  new sync. macros
 *   06-mar-95  craige  HEL integration
 *   08-mar-95  craige  new APIs
 *   11-mar-95  craige  palette stuff
 *   15-mar-95  craige  more HEL integration
 *   19-mar-95  craige  use HRESULTs, process termination cleanup fixes
 *   27-mar-95  craige  linear or rectangular vidmem
 *   28-mar-95  craige  removed Get/SetColorKey, added FlipToGDISurface
 *   29-mar-95  craige  reorg to only call driver once per creation, and
 *                      to allow driver to load us first
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  fill in free video memory
 *   09-apr-95  craige  fixed deadlock situation with a process having a lock
 *                      on the primary surface while another process starts
 *   12-apr-95  craige  bug when driver object freed (extra leave csect)
 *   13-apr-95  craige  EricEng's little contribution to our being late
 *   15-apr-95  craige  fail load if no DD components present
 *   06-may-95  craige  use driver-level csects only
 *   09-may-95  craige  escape call to get 32-bit DLL
 *   12-may-95  craige  added DirectDrawEnumerate; use GUIDs in DirectDrawCreate
 *   14-may-95  craige  call DoneExclusiveMode during CurrentProcessCleanup
 *   15-may-95  craige  restore display mode on a per-process basis
 *   19-may-95  craige  memory leak on mode change
 *   23-may-95  craige  added Flush, GetBatchLimit, SetBatchLimit
 *   24-may-95  craige  plugged another memory leak; allow fourcc codes &
 *                      number of vmem heaps to change
 *   26-may-95  craige  somebody freed the vmem heaps and then tried to
 *                      free the surfaces!
 *   28-may-95  craige  unicode support; make sure blt means at least srccopy
 *   05-jun-95  craige  removed GetVersion, FreeAllSurfaces, DefWindowProc;
 *                      change GarbageCollect to Compact
 *   06-jun-95  craige  call RestoreDisplayMode
 *   07-jun-95  craige  removed DCLIST
 *   12-jun-95  craige  new process list stuff
 *   16-jun-95  craige  new surface structure
 *   18-jun-95  craige  specify pitch for rectangular memory; deadlock
 *                      with MemAlloc16 if we don't take the DLL lock
 *   25-jun-95  craige  one ddraw mutex
 *   26-jun-95  craige  reorganized surface structure
 *   27-jun-95  craige  replaced batch limit/flush stuff with BltBatch
 *   28-jun-95  craige  ENTER_DDRAW at very start of fns
 *   02-jul-95  craige  new registry format
 *   03-jul-95  craige  YEEHAW: new driver struct; SEH
 *   06-jul-95  craige  RemoveFromDriverList was screwing up links
 *   07-jul-95  craige  added pdevice stuff
 *   08-jul-95  craige  call InvalidateAllSurfaces
 *   10-jul-95  craige  support SetOverlayPosition
 *   11-jul-95  craige  validate pdevice is from a dibeng mini driver;
 *                      fail aggregation calls; one ddraw object/process
 *   13-jul-95  craige  ENTER_DDRAW is now the win16 lock; need to
 *                      leave Win16 lock while doing ExtEscape calls
 *   14-jul-95  craige  allow driver to specify heap is already allocated
 *   15-jul-95  craige  invalid HDC set in emulation only
 *   18-jul-95  craige  need to initialize dwPreferredMode
 *   20-jul-95  craige  internal reorg to prevent thunking during modeset
 *   20-jul-95  toddla  zero DDHALINFO before thunking in case nobody home.
 *   22-jul-95  craige  emulation only needs to initialize correctly
 *   29-jul-95  toddla  added DEBUG code to clear driver caps
 *   31-jul-95  toddla  added DD_HAL_VERSION
 *   31-jul-95  craige  set DDCAPS_BANKSWITCHED
 *   01-aug-95  toddla  added dwPDevice to DDRAWI_DIRECTDRAW_GBL
 *   10-aug-95  craige  validate alignment fields
 *   13-aug-95  craige  check DD_HAL_VERSION & set DDCAPS2_CERTIFIED
 *   21-aug-95  craige  mode X support
 *   27-aug-95  craige  bug 738: use GUID instead of IID
 *   05-sep-95  craige  bug 814
 *   08-sep-95  craige  bug 845: reset driver callbacks every time
 *   09-sep-95  craige  bug 949: don't allow ddraw to run in 4bpp
 *                      bug 951: NULL out fn tables at reset
 *   10-sep-95  toddla  dont allow DirectDrawCreate to work for < 8bpp mode.
 *   10-sep-95  toddla  added Message box when DirectDrawCreate fails
 *   20-sep-95  craige  made primary display desc. a string resource
 *   21-sep-95  craige  bug 1215: let ddraw16 know about certified for modex
 *   21-nov-95  colinmc made Direct3D a queryable interface off DirectDraw
 *   27-nov-95  colinmc new member to return available vram of a given type
 *                      (defined by DDSCAPS)
 *   05-dec-95  colinmc changed DDSCAPS_TEXTUREMAP => DDSCAPS_TEXTURE for
 *                      consitency with Direct3D
 *   09-dec-95  colinmc execute buffer support
 *   15-dec-95  colinmc fixed bug setting HAL up for execute buffers
 *   25-dec-95  craige  added InternalDirectDrawCreate for ClassFactory work
 *   31-dec-95  craige  more ClassFactory work
 *   04-jan-96  kylej   add driver interface structures
 *   22-jan-96  jeffno  NT driver conversation in createSurface.
 *                      Since vidmem ptrs can legally be 0 for kernel, added
 *                      DDRAWISURFACEGBL_ISGDISURFACE and use that to find gdi
 *   02-feb-96  kylej   Move HAL function pointers to local object
 *   28-feb-96  kylej   Change DDHALINFO structure
 *   02-mar-96  colinmc Repulsive hack to support interim drivers
 *   06-mar-96  kylej   init HEL even with non-display drivers
 *   13-mar-96  craige  Bug 7528: hw that doesn't have modex
 *   13-mar-96  jeffno  Dynamic mode switch support for NT
 *                      Register process IDs with NT kernel stuff
 *   16-mar-96  colinmc Callback tables now initialized in dllmain
 *   18-mar-96  colinmc Bug 13545: Independent clippers cleanup
 *   22-mar-96  colinmc Bug 13316: uninitialized interfaces
 *   23-mar-96  colinmc Bug 12252: Direct3D not cleaned up properly on crash
 *   14-apr-96  colinmc Bug 17736: No driver notification of flip to GDI
 *   16-apr-96  colinmc Bug 17921: Remove interim driver support
 *   19-apr-96  colinmc Bug 18059: New caps bit to indicate that driver
 *                      can't interleave 2D and 3D operations during scene
 *                      rendering
 *   11-may-96  colinmc Bug 22293: Now validate GUID passed to DirectDraw
 *                      Create in retail as well as debug
 *   16-may-96  colinmc Bug 23215: Not checking for a mode index of -1
 *                      on driver initialization
 *   27-may-96  kylej   Bug 24595: Set Certified bit after call to
 *                      FakeDDCreateDriverObject.
 *   26-jun-96  colinmc Bug 2041: DirectDraw needs time bomb
 *   22-jul-96  colinmc Work Item: Minimal stackable driver support
 *   23-aug-96  craige  registry entries for sw only and modex only
 *   31-aug-96  colinmc Removed erroneous time bomb
 *   03-sep-96  craige  App compatibilty stuff
 *   01-oct-96  ketand  added GetAvailVidMem entrypoint for driver callbacks
 *   05-sep-96  colinmc Work Item: Removing the restriction on taking Win16
 *                      lock on VRAM surfaces (not including the primary)
 *   10-oct-96  colinmc Refinements of the Win16 locking stuff
 *   12-oct-96  colinmc Improvements to Win16 locking code to reduce virtual
 *                      memory usage
 *   15-oct-96  toddla  support multimonitor
 *   09-nov-96  colinmc Fixed problem with old and new drivers not working
 *                      with DirectDraw
 *   17-nov-96  colinmc Added ability to use PrintScrn key to snapshot
 *                      DirectDraw applications.
 *   08-dec-96  colinmc Initial AGP support
 *   21-jan-97  ketand  Added a rectMonitor to lpDD_gbl to allow for correct clipping
 *                      on multi-monitor systems.
 *   25-jan-97  nwilt   Instance GUID in GetDriverInfo struct
 *                      Query for D3DCallbacks2 w/no deps on D3D
 *   27-jan-97  colinmc Fixed problem with multi-mon on emulated displays
 *   27-jan-97  ketand  Multi-mon. Remove bad globals; pass them explicitly. Fix ATTENTIONs.
 *   29-jan-97  smac    Removed old ring 0 code
 *   30-jan-97  colinmc Work item 4125: Add time bomb for beta
 *   30-jan-97  jeffno  Allow surfaces wider than the primary
 *   30-jan-97  ketand  Only enumerate secondaries for multi-mon systems.
 *   01-feb-97  colinmc Bug 5457: Fixed Win16 lock problem causing hang
 *                      with mutliple AMovie instances on old cards
 *   07-feb-97  ketand  Zero DisplayDevice struct between calls to EnumDisplayDevices.
 *                      Fix memory leak w.r.t. GetAndValidateNewHalInfo
 *   24-feb-97  ketand  Update Rects whenever a display change occurs.
 *   24-feb-97  ketand  Add a dwContext to GetDriverInfoData
 *   03-mar-97  smac    Added kernel mode interface
 *   03-mar-97  jeffno  Work item: Extended surface memory alignment
 *   08-mar-97  colinmc Added support for DMA style AGP usage
 *   11-mar-97  jeffno  Asynchronous DMA support
 *   11-mar-97  nwilt   Fail driver create if driver exports some DrawPrimitive
 *                      exports without exporting all of them.
 *   13-mar-97  colinmc Bug 6533: Pass uncached flag to VMM correctly
 *   20-mar-97  nwilt   #6625 and D3D extended caps
 *   24-mar-97  jeffno  Optimized Surfaces
 *   13-may-97  colinmc AGP support on OSR 2.1 systems
 *   26-may-97  nwilt   Fail driver create if driver sets D3DDEVCAPS_DRAWPRIMTLVERTEX
 *                      without exporting the callbacks.
 *   31-jul-97 jvanaken Bug 7093:  Ensure unique HDC for each process/driver pair
 *                      in a multimonitor system.
 *   16-sep-97  jeffno  DirectDrawEnumerateEx
 *   30-sep-97  jeffno  IDirectDraw4
 *   31-oct-97 johnstep Persistent-content surfaces for Windows 9x
 *   05-nov-97 jvanaken Support for master sprite list in SetSpriteDisplayList
 *
 ***************************************************************************/
extern "C" {
#include "ddrawpr.h"

#ifdef WINNT
    #include "ddrawgdi.h"
    #define BUILD_DDDDK
    #include "d3dhal.h"
#endif

#ifdef WIN95
#include "d3dhal.h"
#endif

} // extern C

#include "pixel.hpp"

#ifdef DEBUG
    #define static
#endif

#undef DPF_MODNAME
#define DPF_MODNAME     "DirectDrawObjectCreate"

#define DISPLAY_STR     "display"

#define D3DFORMAT_OP_BACKBUFFER                 0x00000020L

char g_szPrimaryDisplay[MAX_DRIVER_NAME] = "";

void getPrimaryDisplayName(void);


#ifndef WIN16_SEPARATE
    #ifdef WIN95
        CRITICAL_SECTION ddcCS = {0};
        #define ENTER_CSDDC() EnterCriticalSection(&ddcCS)
        #define LEAVE_CSDDC() LeaveCriticalSection(&ddcCS)
    #else
        #define ENTER_CSDDC()
        #define LEAVE_CSDDC()
    #endif
#else
    #define ENTER_CSDDC()
    #define LEAVE_CSDDC()
#endif


/*
 * DISPLAY_DEVICEA
 *
 * define a local copy of the structures and constants needed
 * to call EnumDisplayDevices
 *
 */
#ifndef DISPLAY_DEVICE_ATTACHED_TO_DESKTOP
#define DISPLAY_DEVICE_ATTACHED_TO_DESKTOP 0x00000001
#define DISPLAY_DEVICE_MULTI_DRIVER        0x00000002
#define DISPLAY_DEVICE_PRIMARY_DEVICE      0x00000004
#define DISPLAY_DEVICE_MIRRORING_DRIVER    0x00000008
#define DISPLAY_DEVICE_VGA                 0x00000010
typedef struct {
    DWORD  cb;
    CHAR   DeviceName[MAX_DRIVER_NAME];
    CHAR   DeviceString[128];
    DWORD  StateFlags;
} DISPLAY_DEVICEA;
#endif

#undef DPF_MODNAME
#define DPF_MODNAME "MakeDX8Caps"

void 
MakeDX8Caps( D3DCAPS8 *pCaps8, 
             const D3D8_GLOBALDRIVERDATA*   pGblDrvData,
             const D3DHAL_D3DEXTENDEDCAPS*  pExtCaps )
{   
    // we shouldn't memset pCaps8 as members like Caps, Caps2, Caps3 (dwSVCaps) and 
    // CursorCaps are already set by Thunk layer
    
    pCaps8->DevCaps = pGblDrvData->hwCaps.dwDevCaps;

    pCaps8->PrimitiveMiscCaps  = pGblDrvData->hwCaps.dpcTriCaps.dwMiscCaps;
    pCaps8->RasterCaps         = pGblDrvData->hwCaps.dpcTriCaps.dwRasterCaps;
    pCaps8->ZCmpCaps           = pGblDrvData->hwCaps.dpcTriCaps.dwZCmpCaps;
    pCaps8->SrcBlendCaps       = pGblDrvData->hwCaps.dpcTriCaps.dwSrcBlendCaps;
    pCaps8->DestBlendCaps      = pGblDrvData->hwCaps.dpcTriCaps.dwDestBlendCaps;
    pCaps8->AlphaCmpCaps       = pGblDrvData->hwCaps.dpcTriCaps.dwAlphaCmpCaps;
    pCaps8->ShadeCaps          = pGblDrvData->hwCaps.dpcTriCaps.dwShadeCaps;
    pCaps8->TextureCaps        = pGblDrvData->hwCaps.dpcTriCaps.dwTextureCaps;
    pCaps8->TextureFilterCaps  = pGblDrvData->hwCaps.dpcTriCaps.dwTextureFilterCaps;

        // Adjust the texture filter caps for the legacy drivers that 
        // set only the legacy texture filter caps and not the newer ones.
    if ((pCaps8->TextureFilterCaps & (D3DPTFILTERCAPS_MINFPOINT  |
                                      D3DPTFILTERCAPS_MAGFPOINT  |
                                      D3DPTFILTERCAPS_MIPFPOINT  |
                                      D3DPTFILTERCAPS_MINFLINEAR |
                                      D3DPTFILTERCAPS_MAGFLINEAR |
                                      D3DPTFILTERCAPS_MIPFLINEAR)) == 0)
    {
        if (pCaps8->TextureFilterCaps & D3DPTFILTERCAPS_NEAREST)
        {
            pCaps8->TextureFilterCaps |= (D3DPTFILTERCAPS_MINFPOINT | 
                                          D3DPTFILTERCAPS_MAGFPOINT);
        }

        if (pCaps8->TextureFilterCaps & D3DPTFILTERCAPS_LINEAR)
        { 
            pCaps8->TextureFilterCaps |= (D3DPTFILTERCAPS_MINFLINEAR |
                                          D3DPTFILTERCAPS_MAGFLINEAR);
        }

        if (pCaps8->TextureFilterCaps & D3DPTFILTERCAPS_MIPNEAREST)
        { 
            pCaps8->TextureFilterCaps |= (D3DPTFILTERCAPS_MINFPOINT |
                                          D3DPTFILTERCAPS_MAGFPOINT |
                                          D3DPTFILTERCAPS_MIPFPOINT);
        }

        if (pCaps8->TextureFilterCaps & D3DPTFILTERCAPS_MIPLINEAR)
        { 
            pCaps8->TextureFilterCaps |= (D3DPTFILTERCAPS_MINFLINEAR |
                                          D3DPTFILTERCAPS_MAGFLINEAR |
                                          D3DPTFILTERCAPS_MIPFPOINT);
        }

        if (pCaps8->TextureFilterCaps & D3DPTFILTERCAPS_LINEARMIPNEAREST)
        { 
            pCaps8->TextureFilterCaps |= (D3DPTFILTERCAPS_MINFPOINT |
                                          D3DPTFILTERCAPS_MAGFPOINT |
                                          D3DPTFILTERCAPS_MIPFLINEAR);
        }

        if (pCaps8->TextureFilterCaps & D3DPTFILTERCAPS_LINEARMIPLINEAR)
        { 
            pCaps8->TextureFilterCaps |= (D3DPTFILTERCAPS_MINFLINEAR |
                                          D3DPTFILTERCAPS_MAGFLINEAR |
                                          D3DPTFILTERCAPS_MIPFLINEAR);
        }
    }
        
    pCaps8->TextureAddressCaps = pGblDrvData->hwCaps.dpcTriCaps.dwTextureAddressCaps;

        // Set the cube-texture filter caps only if the device supports
        // cubemaps.
    if (pCaps8->TextureCaps & D3DPTEXTURECAPS_CUBEMAP)
    {
        pCaps8->CubeTextureFilterCaps    = pGblDrvData->hwCaps.dpcTriCaps.dwTextureFilterCaps;
    }
        
    const D3DPRIMCAPS* pTC = &pGblDrvData->hwCaps.dpcTriCaps;
    const D3DPRIMCAPS* pLC = &pGblDrvData->hwCaps.dpcLineCaps;
    if (pLC->dwTextureCaps) pCaps8->LineCaps |= D3DLINECAPS_TEXTURE ;
    if (pLC->dwZCmpCaps == pTC->dwZCmpCaps)
        pCaps8->LineCaps |= D3DLINECAPS_ZTEST;
    if ( (pLC->dwSrcBlendCaps == pTC->dwSrcBlendCaps) &&
         (pLC->dwDestBlendCaps == pTC->dwDestBlendCaps) )
        pCaps8->LineCaps |= D3DLINECAPS_BLEND;
    if (pLC->dwAlphaCmpCaps == pTC->dwAlphaCmpCaps)
        pCaps8->LineCaps |= D3DLINECAPS_ALPHACMP;
    if (pLC->dwRasterCaps & (D3DPRASTERCAPS_FOGVERTEX|D3DPRASTERCAPS_FOGTABLE))
        pCaps8->LineCaps |= D3DLINECAPS_FOG;

    if( pExtCaps->dwMaxTextureWidth == 0 )
        pCaps8->MaxTextureWidth = 256;
    else
        pCaps8->MaxTextureWidth  = pExtCaps->dwMaxTextureWidth;
    
    if( pExtCaps->dwMaxTextureHeight == 0 )
        pCaps8->MaxTextureHeight = 256;
    else
        pCaps8->MaxTextureHeight = pExtCaps->dwMaxTextureHeight;

    pCaps8->MaxTextureRepeat = pExtCaps->dwMaxTextureRepeat;
    pCaps8->MaxTextureAspectRatio = pExtCaps->dwMaxTextureAspectRatio;
    pCaps8->MaxAnisotropy = pExtCaps->dwMaxAnisotropy;
    pCaps8->MaxVertexW = pExtCaps->dvMaxVertexW;

    pCaps8->GuardBandLeft    = pExtCaps->dvGuardBandLeft;
    pCaps8->GuardBandTop     = pExtCaps->dvGuardBandTop;
    pCaps8->GuardBandRight   = pExtCaps->dvGuardBandRight;
    pCaps8->GuardBandBottom  = pExtCaps->dvGuardBandBottom;

    pCaps8->ExtentsAdjust = pExtCaps->dvExtentsAdjust;
    pCaps8->StencilCaps = pExtCaps->dwStencilCaps;

    pCaps8->FVFCaps = pExtCaps->dwFVFCaps;
    pCaps8->TextureOpCaps = pExtCaps->dwTextureOpCaps;
    pCaps8->MaxTextureBlendStages = pExtCaps->wMaxTextureBlendStages;
    pCaps8->MaxSimultaneousTextures = pExtCaps->wMaxSimultaneousTextures;

    pCaps8->VertexProcessingCaps = pExtCaps->dwVertexProcessingCaps;
    pCaps8->MaxActiveLights = pExtCaps->dwMaxActiveLights;
    pCaps8->MaxUserClipPlanes = pExtCaps->wMaxUserClipPlanes;
    pCaps8->MaxVertexBlendMatrices = pExtCaps->wMaxVertexBlendMatrices;
    if (pCaps8->MaxVertexBlendMatrices == 1)
        pCaps8->MaxVertexBlendMatrices = 0;

    //
    // Stuff in the DX8 caps that cannot be reported by the pre DX8 drivers
    //
    pCaps8->MaxPointSize = 0;
    pCaps8->MaxPrimitiveCount = 0xffff;
    pCaps8->MaxVertexIndex = 0xffff;
    pCaps8->MaxStreams = 0;
    pCaps8->MaxStreamStride = 255;
    pCaps8->MaxVertexBlendMatrixIndex = 0;
    pCaps8->MaxVolumeExtent  = 0;

    // Format is 8.8 in bottom of DWORD
    pCaps8->VertexShaderVersion = D3DVS_VERSION(0,0);
    pCaps8->MaxVertexShaderConst = 0;
    pCaps8->PixelShaderVersion = D3DPS_VERSION(0,0);
    pCaps8->MaxPixelShaderValue = 1.0f;

} // MakeDX8Caps

/*
 * xxxEnumDisplayDevices
 *
 * wrapper around the new Win32 API EnumDisplayDevices
 * uses GetProcAddress() so we run on Win95.
 *
 * this function exists in NT 4.0 and Win97 (Memphis) but not Win95
 *
 */
BOOL xxxEnumDisplayDevicesA(LPVOID lpUnused, DWORD iDevice, DISPLAY_DEVICEA *pdd, DWORD dwFlags)
{
    HMODULE h = GetModuleHandle("USER32");
    BOOL (WINAPI *pfnEnumDisplayDevices)(LPVOID, DWORD, DISPLAY_DEVICEA *, DWORD);

    *((void **)&pfnEnumDisplayDevices) = GetProcAddress(h,"EnumDisplayDevicesA");

    //
    // NT 4.0 had a EnumDisplayDevicesA but it does not have the same
    // number of params, so ignore it unless a GetMonitorInfoA exists too.
    //
    if (GetProcAddress(h,"GetMonitorInfoA") == NULL)
        pfnEnumDisplayDevices = NULL;

    if (pfnEnumDisplayDevices)
    {
        return (*pfnEnumDisplayDevices)(lpUnused, iDevice, pdd, dwFlags);
    }

    //else we emulate the function for 95, NT4:
    if (iDevice > 0)
        return FALSE;

    pdd->StateFlags = DISPLAY_DEVICE_PRIMARY_DEVICE;
    lstrcpy(pdd->DeviceName, DISPLAY_STR);
    LoadString(g_hModule, IDS_PRIMARYDISPLAY, pdd->DeviceString, sizeof(pdd->DeviceString));

    return TRUE;
}

// Multi-monitor defines; these are wrong in the TRANGO tree;
// so I need to define them here explicitly. When we move to
// something that matches Memphis/NT5 then we can remove these
#undef SM_XVIRTUALSCREEN
#undef SM_YVIRTUALSCREEN
#undef SM_CXVIRTUALSCREEN
#undef SM_CYVIRTUALSCREEN
#undef SM_CMONITORS
#define SM_XVIRTUALSCREEN       76
#define SM_YVIRTUALSCREEN       77
#define SM_CXVIRTUALSCREEN      78
#define SM_CYVIRTUALSCREEN      79
#define SM_CMONITORS            80

#ifndef ENUM_CURRENT_SETTINGS
#define ENUM_CURRENT_SETTINGS       ((DWORD)-1)
#endif


#ifdef WINNT
// This function gets the device rect by calling GetMonitorInfo.
// On Win98, we got this by calling EnumDisplaySettings, but this
// doesn't work on NT5 and reading the documentation, it never
// indicates that it should work, so we'll just do it the documented
// way.
HRESULT GetNTDeviceRect(LPSTR pDriverName, LPRECT lpRect)
{
    MONITORINFO MonInfo;
    HMONITOR hMon;

    MonInfo.cbSize = sizeof(MONITORINFO);
    if (_stricmp(pDriverName, DISPLAY_STR) == 0)
    {
        hMon = GetMonitorFromDeviceName(g_szPrimaryDisplay);
    }
    else
    {
        hMon = GetMonitorFromDeviceName(pDriverName);
    }
    if (hMon != NULL)
    {
        if (GetMonitorInfo(hMon, &MonInfo) != 0)
        {
            CopyMemory(lpRect, &MonInfo.rcMonitor, sizeof(RECT));
            return S_OK;
        }
    }
    return E_FAIL;
}
#endif


/*
 * IsVGADevice()
 *
 * determine if the passed device name is a VGA
 *
 */
BOOL IsVGADevice(LPSTR szDevice)
{
    //
    //  assume "DISPLAY" and "DISPLAY1" are VGA devices
    //
    if ((_stricmp(szDevice, DISPLAY_STR) == 0) ||
        ((szDevice[0] == '\\') &&
          (szDevice[1] == '\\') &&
          (szDevice[2] == '.')))
    {
        return TRUE;
    }

    return FALSE;
}

/*
 * This function is currently only used in NT
 */

#ifdef WINNT

BOOL GetDDStereoMode(LPDDRAWI_DIRECTDRAW_GBL pdrv,
                      DWORD dwWidth,
                      DWORD dwHeight,
                      DWORD dwBpp,
                      DWORD dwRefreshRate)
{
    DDHAL_GETDRIVERINFODATA     gdidata;
    HRESULT                     hres;
    DDSTEREOMODE                ddStereoMode;

    DDASSERT(pdrv != NULL);

    /*
     * If driver does not support GetDriverInfo callback, it also
     * has no extended capabilities to report, so we're done.
     */
    if (!VALIDEX_CODE_PTR (pdrv->pGetDriverInfo))
    {
        return FALSE;
    }

    /*
     * The mode can't be stereo if the driver doesn't support it...
     */
    if (0 == (pdrv->ddCaps.dwCaps2 & DDCAPS2_STEREO))
    {
        return FALSE;
    }

    ZeroMemory(&ddStereoMode, sizeof(DDSTEREOMODE));

    ddStereoMode.dwSize=sizeof(DDSTEREOMODE);
    ddStereoMode.dwWidth=dwWidth;
    ddStereoMode.dwHeight=dwHeight;
    ddStereoMode.dwBpp=dwBpp;
    ddStereoMode.dwRefreshRate=dwRefreshRate;

    ddStereoMode.bSupported = TRUE;

    /*
     * Get the actual driver data
     */
    memset(&gdidata, 0, sizeof(gdidata));
    gdidata.dwSize = sizeof(gdidata);
    gdidata.dwFlags = 0;
    gdidata.guidInfo = GUID_DDStereoMode;
    gdidata.dwExpectedSize = sizeof(DDSTEREOMODE);
    gdidata.lpvData = &ddStereoMode;
    gdidata.ddRVal = E_FAIL;

    // Pass a context variable so that the driver
    // knows which instance of itself to use
    // w.r.t. this function. These are different
    // values on Win95 and NT.
#ifdef WIN95
    gdidata.dwContext = pdrv->dwReserved3;
#else
    gdidata.dwContext = pdrv->hDD;
#endif

    return TRUE;

} /* GetDDStereoMode */

#endif //WINNT


/*
 * doneDC
 */
void DD_DoneDC(HDC hdc_dd)
{
    if (hdc_dd != NULL)
    {
        DPF(5, "DeleteDC 0x%x", hdc_dd);
        DeleteDC(hdc_dd);
        hdc_dd = NULL;
    }

} /* doneDC */

#undef DPF_MODNAME
#define DPF_MODNAME     "DirectDrawCreate"


/*
 * createDC
 *
 * create a new DC given a device name.
 * doneDC() should be called to free DC
 *
 * the following are valid for device names:
 *
 *      DISPLAY      - the main display device via CreateDC("DISPLAY", ...)
 *                     this is the normal case.
 *
 *      foobar       - the foobar.drv via CreateDC("foobar", ...)
 *                     used for secondary displays listed in the registry
 *
 *      \\.\DisplayX - display device X via CreateDC(NULL,"\\.\DisplayX",...)
 *                     used on Memphis and NT5 for secondary displays
 *
 */
HDC DD_CreateDC(LPSTR pdrvname)
{
    HDC         hdc;
    UINT        u;

    DDASSERT(pdrvname != NULL);

#ifdef DEBUG
    if (pdrvname[0] == 0)
    {
        DPF(3, "createDC() empty string!!!");
        DebugBreak();
        return NULL;
    }
#endif

    #if defined(NT_FIX) || defined(WIN95)
        u = SetErrorMode(SEM_NOOPENFILEERRORBOX);
    #endif
    #ifdef WINNT
        /*
         * Note that DirectDraw refers to the driver for the primary monitor
         * in a multimon system as "display", but NT uses "display" to refer
         * to the desktop as a whole.  To handle this mismatch, we store
         * NT's name for the primary monitor's driver in g_szPrimaryDisplay
         * and substitute this name in place of "display" in our calls to NT.
        */
        if (GetSystemMetrics(SM_CMONITORS) > 1)
        {
            if ((_stricmp(pdrvname, DISPLAY_STR) == 0))
            {
                if (g_szPrimaryDisplay[0] == '\0')
                {
                    getPrimaryDisplayName();
                }
                pdrvname = g_szPrimaryDisplay;
            }
        }
    #endif //WINNT

    DPF(5, "createDC(%s)", pdrvname);

    if (pdrvname[0] == '\\' && pdrvname[1] == '\\' && pdrvname[2] == '.')
        hdc = CreateDC(NULL, pdrvname, NULL, NULL);
    else
        hdc = CreateDC(pdrvname, NULL, NULL, NULL);

    #if defined(NT_FIX) || defined(WIN95) //fix this error mode stuff
        SetErrorMode(u);
    #endif

    if (hdc == NULL)
    {
        DPF(3, "createDC(%s) FAILED!", pdrvname);
    }

    return hdc;

} /* createDC */

/*****************************Private*Routine******************************\
* DdConvertFromOldFormat
*
* History:
*  13-Nov-1999 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

#undef DPF_MODNAME
#define DPF_MODNAME "ConvertFromOldFormat"

void ConvertFromOldFormat(LPDDPIXELFORMAT pOldFormat, D3DFORMAT *pNewFormat)
{
    *pNewFormat = D3DFMT_UNKNOWN;
    if (pOldFormat->dwFlags & DDPF_FOURCC)
    {
        *pNewFormat = (D3DFORMAT) pOldFormat->dwFourCC;
    }
    else if (pOldFormat->dwFlags == DDPF_RGB)
    {
        switch (pOldFormat->dwRGBBitCount)
        {
        case 8:
            if ((pOldFormat->dwRBitMask == 0x000000e0) &&
                (pOldFormat->dwGBitMask == 0x0000001c) &&
                (pOldFormat->dwBBitMask == 0x00000003))
            {
                *pNewFormat = D3DFMT_R3G3B2;
            }
            else
            {
                *pNewFormat = D3DFMT_P8;
            }
            break;

        case 16:
            if ((pOldFormat->dwRBitMask == 0x0000f800) &&
                (pOldFormat->dwGBitMask == 0x000007e0) &&
                (pOldFormat->dwBBitMask == 0x0000001f))
            {
                *pNewFormat = D3DFMT_R5G6B5;
            }
            else if ((pOldFormat->dwRBitMask == 0x00007c00) &&
                (pOldFormat->dwGBitMask == 0x000003e0) &&
                (pOldFormat->dwBBitMask == 0x0000001f))
            {
                *pNewFormat = D3DFMT_X1R5G5B5;
            }
            else if ((pOldFormat->dwRBitMask == 0x00000f00) &&
                (pOldFormat->dwGBitMask == 0x000000f0) &&
                (pOldFormat->dwBBitMask == 0x0000000f))
            {
                *pNewFormat = D3DFMT_X4R4G4B4;
            }
            break;

        case 24:
            if ((pOldFormat->dwRBitMask == 0x00ff0000) &&
                (pOldFormat->dwGBitMask == 0x0000ff00) &&
                (pOldFormat->dwBBitMask == 0x000000ff))
            {
                *pNewFormat = D3DFMT_R8G8B8;
            }
            break;

        case 32:
            if ((pOldFormat->dwRBitMask == 0x00ff0000) &&
                (pOldFormat->dwGBitMask == 0x0000ff00) &&
                (pOldFormat->dwBBitMask == 0x000000ff))
            {
                *pNewFormat = D3DFMT_X8R8G8B8;
            }
            break;
        }
    }
    else if (pOldFormat->dwFlags == (DDPF_RGB | DDPF_ALPHAPIXELS))
    {
        switch (pOldFormat->dwRGBBitCount)
        {
        case 16:
            if ((pOldFormat->dwRGBAlphaBitMask == 0x0000FF00) &&
                (pOldFormat->dwRBitMask == 0x000000e0) &&
                (pOldFormat->dwGBitMask == 0x0000001c) &&
                (pOldFormat->dwBBitMask == 0x00000003))
            {
                *pNewFormat = D3DFMT_A8R3G3B2;
            }
            else if ((pOldFormat->dwRGBAlphaBitMask == 0x0000f000) &&
                (pOldFormat->dwRBitMask == 0x00000f00) &&
                (pOldFormat->dwGBitMask == 0x000000f0) &&
                (pOldFormat->dwBBitMask == 0x0000000f))
            {
                *pNewFormat = D3DFMT_A4R4G4B4;
            }
            else if ((pOldFormat->dwRGBAlphaBitMask == 0x0000FF00) &&
                (pOldFormat->dwRBitMask == 0x00000f00) &&
                (pOldFormat->dwGBitMask == 0x000000f0) &&
                (pOldFormat->dwBBitMask == 0x0000000f))
            {
                *pNewFormat = D3DFMT_A4R4G4B4;
            }
            else if ((pOldFormat->dwRGBAlphaBitMask == 0x00008000) &&
                (pOldFormat->dwRBitMask == 0x00007c00) &&
                (pOldFormat->dwGBitMask == 0x000003e0) &&
                (pOldFormat->dwBBitMask == 0x0000001f))
            {
                *pNewFormat = D3DFMT_A1R5G5B5;
            }
            break;

        case 32:
            if ((pOldFormat->dwRGBAlphaBitMask == 0xff000000) &&
                (pOldFormat->dwRBitMask == 0x00ff0000) &&
                (pOldFormat->dwGBitMask == 0x0000ff00) &&
                (pOldFormat->dwBBitMask == 0x000000ff))
            {
                *pNewFormat = D3DFMT_A8R8G8B8;
            }
            break;
        }
    }
#if 0
    // We don't convert the old representation of A8 to
    // the new format because there are some existing DX7 drivers
    // that expose the old format but don't implement it correctly
    // or completely. We've seen Blt failures, and Rendering failures.
    // So this becomes a DX8+ only feature; in which case
    // we will get a new-style format from the driver.
    // MB43799
    else if (pOldFormat->dwFlags == DDPF_ALPHA)
    {
        if (pOldFormat->dwAlphaBitDepth == 8)
        {
            *pNewFormat = D3DFMT_A8;
        }
    }
#endif
    else if (pOldFormat->dwFlags & (DDPF_PALETTEINDEXED8 | DDPF_RGB))
    {
        switch (pOldFormat->dwRGBBitCount)
        {
        case 8:
            if (pOldFormat->dwFlags == (DDPF_PALETTEINDEXED8 | DDPF_RGB))
            {
                *pNewFormat = D3DFMT_P8;
            }
            break;

        case 16:
            if (pOldFormat->dwFlags == (DDPF_PALETTEINDEXED8 |
                                        DDPF_RGB             |
                                        DDPF_ALPHAPIXELS) &&
                pOldFormat->dwRGBAlphaBitMask == 0xFF00)
            {

                *pNewFormat = D3DFMT_A8P8;
            }
            break;
        }
    }
    else if (pOldFormat->dwFlags == DDPF_ZBUFFER)
    {
        switch (pOldFormat->dwZBufferBitDepth)
        {
        case 32:
            if (pOldFormat->dwZBitMask == 0xffffffff)
            {
                *pNewFormat = D3DFMT_D32;
            }
            else if (pOldFormat->dwZBitMask == 0x00FFFFFF)
            {
                *pNewFormat = D3DFMT_X8D24;
            }
            else if (pOldFormat->dwZBitMask == 0xFFFFFF00)
            {
                *pNewFormat = D3DFMT_D24X8;
            }
            break;

        case 16:
            if (pOldFormat->dwZBitMask == 0xffff)
            {
                *pNewFormat = D3DFMT_D16_LOCKABLE;
            }
            break;
        }
    }
    else if (pOldFormat->dwFlags == (DDPF_ZBUFFER | DDPF_STENCILBUFFER))
    {
        switch (pOldFormat->dwZBufferBitDepth)
        {
        case 32:
            if ((pOldFormat->dwZBitMask == 0xffffff00) &&
                (pOldFormat->dwStencilBitMask == 0x000000ff) &&
                (pOldFormat->dwStencilBitDepth == 8))
            {
                *pNewFormat = D3DFMT_D24S8;
            }
            else if ((pOldFormat->dwZBitMask == 0x00ffffff) &&
                (pOldFormat->dwStencilBitMask == 0xff000000) &&
                (pOldFormat->dwStencilBitDepth == 8))
            {
                *pNewFormat = D3DFMT_S8D24;
            }
            else if ((pOldFormat->dwZBitMask == 0xffffff00) &&
                (pOldFormat->dwStencilBitMask == 0x0000000f) &&
                (pOldFormat->dwStencilBitDepth == 4))
            {
                *pNewFormat = D3DFMT_D24X4S4;
            }
            else if ((pOldFormat->dwZBitMask == 0x00ffffff) &&
                (pOldFormat->dwStencilBitMask == 0x0f000000) &&
                (pOldFormat->dwStencilBitDepth == 4))
            {
                *pNewFormat = D3DFMT_X4S4D24;
            }
            break;
        case 16:
            if ((pOldFormat->dwZBitMask == 0xfffe) &&
                (pOldFormat->dwStencilBitMask == 0x0001) &&
                (pOldFormat->dwStencilBitDepth == 1))
            {
                *pNewFormat = D3DFMT_D15S1;
            }
            else if ((pOldFormat->dwZBitMask == 0x7fff) &&
                (pOldFormat->dwStencilBitMask == 0x8000) &&
                (pOldFormat->dwStencilBitDepth == 1))
            {
                *pNewFormat = D3DFMT_S1D15;
            }
            break;
        }
    }
    else if (pOldFormat->dwFlags == DDPF_LUMINANCE)
    {
        switch (pOldFormat->dwLuminanceBitCount)
        {
        case 8:
            if (pOldFormat->dwLuminanceBitMask == 0xFF)
            {
                *pNewFormat = D3DFMT_L8;
            }
            break;
        }
    }
    else if (pOldFormat->dwFlags == (DDPF_LUMINANCE | DDPF_ALPHAPIXELS))
    {
        switch (pOldFormat->dwLuminanceBitCount)
        {
        case 8:
            if (pOldFormat->dwLuminanceBitMask      == 0x0F &&
                pOldFormat->dwLuminanceAlphaBitMask == 0xF0)
            {
                *pNewFormat = D3DFMT_A4L4;
            }
        case 16:
            if (pOldFormat->dwLuminanceBitMask      == 0x00FF &&
                pOldFormat->dwLuminanceAlphaBitMask == 0xFF00)
            {
                *pNewFormat = D3DFMT_A8L8;
            }

            break;
        }
    }
    else if (pOldFormat->dwFlags == DDPF_BUMPDUDV)
    {
        switch (pOldFormat->dwBumpBitCount)
        {
        case 16:
            if (pOldFormat->dwBumpDuBitMask == 0xFF &&
                pOldFormat->dwBumpDvBitMask == 0xFF00)
            {
                *pNewFormat = D3DFMT_V8U8;
            }
            break;
        }
    }
    else if (pOldFormat->dwFlags == (DDPF_BUMPDUDV | DDPF_BUMPLUMINANCE))
    {
        switch (pOldFormat->dwBumpBitCount)
        {
        case 16:
            if (pOldFormat->dwBumpDuBitMask        == 0x001F &&
                pOldFormat->dwBumpDvBitMask        == 0x03E0 &&
                pOldFormat->dwBumpLuminanceBitMask == 0xFC00)
            {
                *pNewFormat = D3DFMT_L6V5U5;
            }
            break;

        case 32:
            if (pOldFormat->dwBumpDuBitMask        == 0x0000FF &&
                pOldFormat->dwBumpDvBitMask        == 0x00FF00 &&
                pOldFormat->dwBumpLuminanceBitMask == 0xFF0000)
            {
                *pNewFormat = D3DFMT_X8L8V8U8;
            }
            break;
        }
    }
}


/*
 * FetchDirectDrawData
 *
 * Go get new HAL info...
 */
void FetchDirectDrawData(
            PD3D8_DEVICEDATA    pBaseData,
            void*               pInitFunction,
            D3DFORMAT           Unknown16,
            DDSURFACEDESC*      pHalOpList,
            DWORD               NumHalOps)
{
    BOOL                bNewMode;
    BOOL                bRetVal;
    UINT                i=0;
    BOOL                bAlreadyAnOpList = FALSE;
    LPDDPIXELFORMAT     pZStencilFormatList=0;
    DDSURFACEDESC      *pTextureList=0;
    D3D8_GLOBALDRIVERDATA D3DGlobalDriverData;
    D3DHAL_D3DEXTENDEDCAPS D3DExtendedCaps;
    BOOL                bBackbuffersExist = FALSE;
    BOOL                bReset = FALSE;
    
    ZeroMemory( &D3DGlobalDriverData, sizeof(D3DGlobalDriverData) );
    ZeroMemory( &D3DExtendedCaps, sizeof(D3DExtendedCaps) );
    
    if (pBaseData->hDD == NULL)
    {
        #ifdef WINNT
            D3D8CreateDirectDrawObject(pBaseData->hDC,
                pBaseData->DriverName,
                &pBaseData->hDD,
                pBaseData->DeviceType,
                &pBaseData->hLibrary,
                pInitFunction);
        #else
            D3D8CreateDirectDrawObject(&pBaseData->Guid,
                pBaseData->DriverName,
                &pBaseData->hDD,
                pBaseData->DeviceType,
                &pBaseData->hLibrary,
                pInitFunction);
        #endif

        if (pBaseData->hDD == NULL)
        {
            #ifdef WINNT
                DPF(1, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:NT Kernel mode would not create driver object... Failing over to emulation");
            #endif
            goto ErrorExit;
        }
    }
    else
    {
        // If we already have 3D caps, then we are resetting 

        if ((pBaseData->DriverData.dwFlags & DDIFLAG_D3DCAPS8) &&
            (pBaseData->DriverData.D3DCaps.DevCaps != 0))
        {
            bReset = TRUE;
        }
    }

    // Now we can get the driver info...
    // The first call returns the amount of space we need to allocate for the
    // texture and z/stencil lists

    UINT cTextureFormats;
    UINT cZStencilFormats;

    if (bReset)
    {
        // If we are ressting, we do not want to rebuild all of the caps, the
        // format list, etc., but we still need to call the thunk layer because
        // on NT this resets the kernel.

        D3D8_DRIVERCAPS     TempData;
        D3D8_CALLBACKS      TempCallbacks;

        if (!D3D8ReenableDirectDrawObject(pBaseData->hDD,&bNewMode) ||
            !D3D8QueryDirectDrawObject(pBaseData->hDD,
                                   &TempData,
                                   &TempCallbacks,
                                   pBaseData->DriverName,
                                   pBaseData->hLibrary,
                                   &D3DGlobalDriverData,
                                   &D3DExtendedCaps,
                                   NULL,
                                   NULL,
                                   &cTextureFormats,
                                   &cZStencilFormats))
        {
            goto ErrorExit;
        }
        pBaseData->DriverData.DisplayWidth              = TempData.DisplayWidth;
        pBaseData->DriverData.DisplayHeight             = TempData.DisplayHeight;
        pBaseData->DriverData.DisplayFormatWithAlpha    = TempData.DisplayFormatWithAlpha;
        pBaseData->DriverData.DisplayFormatWithoutAlpha = TempData.DisplayFormatWithoutAlpha;
        pBaseData->DriverData.DisplayFrequency          = TempData.DisplayFrequency;
    }
    else
    {
        MemFree (pBaseData->DriverData.pGDD8SupportedFormatOps);
        pBaseData->DriverData.pGDD8SupportedFormatOps = NULL;

        if (!D3D8ReenableDirectDrawObject(pBaseData->hDD,&bNewMode) ||
            !D3D8QueryDirectDrawObject(pBaseData->hDD,
                                       &pBaseData->DriverData,
                                       &pBaseData->Callbacks,
                                       pBaseData->DriverName,
                                       pBaseData->hLibrary,
                                       &D3DGlobalDriverData,
                                       &D3DExtendedCaps,
                                       NULL,
                                       NULL,
                                       &cTextureFormats,
                                       &cZStencilFormats))
        {
            DPF(1, "****Direct3D DRIVER DISABLING ERROR****:First call to DdQueryDirectDrawObject failed!");
            D3D8DeleteDirectDrawObject(pBaseData->hDD);
            pBaseData->hDD = NULL;
            goto ErrorExit;
        }

        // First we make space for the formats
        // let's do memalloc for pTextureList just once, 3 extra for possible backbuffers
        // 3 extra for D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET
        pTextureList = (DDSURFACEDESC *) MemAlloc ((cTextureFormats+ cZStencilFormats + 6) * sizeof (*pTextureList));
        if (pTextureList == NULL)
        {
            DPF_ERR("****Direct3D DRIVER DISABLING ERROR****:Unable to allocate memory for texture formats!");
            D3D8DeleteDirectDrawObject(pBaseData->hDD);
            pBaseData->hDD = NULL;
            goto ErrorExit;
        }

        if (cZStencilFormats > 0)
        {
            pZStencilFormatList = (DDPIXELFORMAT *) MemAlloc (cZStencilFormats * sizeof (*pZStencilFormatList));
            if (pZStencilFormatList == NULL)
            {
                DPF_ERR("****Direct3D DRIVER DISABLING ERROR****:Unable to allocate memory for Z/Stencil formats!");
                D3D8DeleteDirectDrawObject(pBaseData->hDD);
                pBaseData->hDD = NULL;
                goto ErrorExit;
            }
        }

        //Now that we've allocated space for the texture and z/stencil lists, we can go get em.
        if (!D3D8QueryDirectDrawObject(pBaseData->hDD,
                                       &pBaseData->DriverData,
                                       &pBaseData->Callbacks,
                                       pBaseData->DriverName,
                                       pBaseData->hLibrary,
                                       &D3DGlobalDriverData,
                                       &D3DExtendedCaps,
                                       pTextureList,
                                       pZStencilFormatList,
                                       &cTextureFormats,
                                       &cZStencilFormats))
        {
            DPF_ERR("****Direct3D DRIVER DISABLING ERROR****:Second call to DdQueryDirectDrawObject failed!");
            D3D8DeleteDirectDrawObject(pBaseData->hDD);
            pBaseData->hDD = NULL;
            goto ErrorExit;
        }

        // If no D3DCAPS8 was reported by the thunk layer, then the driver
        // must be a pre-DX8 driver. We must sew together the 
        // D3DGlobalDriverData and the ExtendedCaps (which have to be reported).
        // Note: The thunk layer already has plugged in the DDraw Caps such
        // as the Caps, Caps2 and Caps3 (dwSVCaps).
        if( (pBaseData->DriverData.dwFlags & DDIFLAG_D3DCAPS8) == 0 )
        {
            MakeDX8Caps( &pBaseData->DriverData.D3DCaps,
                         &D3DGlobalDriverData,
                         &D3DExtendedCaps );
            pBaseData->DriverData.dwFlags |= DDIFLAG_D3DCAPS8;

        }
        else
        {
            // They reported the DX8 caps. 
            // Internally we check MaxPointSize if it is zero or not
            // to determine if PointSprites are supported or not. So if a DX8 driver said 1.0
            // set it to Zero
            if (pBaseData->DriverData.D3DCaps.MaxPointSize == 1.0)
            {
                pBaseData->DriverData.D3DCaps.MaxPointSize = 0;
            }
        }

        // There are some legacy caps that are reported by the drivers that
        // we dont want the applications to see. Should weed them out here.
        pBaseData->DriverData.D3DCaps.PrimitiveMiscCaps &= ~(D3DPMISCCAPS_MASKPLANES | 
            D3DPMISCCAPS_CONFORMANT);
        
        pBaseData->DriverData.D3DCaps.DevCaps &= ~(D3DDEVCAPS_FLOATTLVERTEX |
            D3DDEVCAPS_SORTINCREASINGZ | D3DDEVCAPS_SORTDECREASINGZ |
            D3DDEVCAPS_SORTEXACT);

        pBaseData->DriverData.D3DCaps.TextureCaps &= ~(D3DPTEXTURECAPS_TRANSPARENCY |
            D3DPTEXTURECAPS_BORDER | D3DPTEXTURECAPS_COLORKEYBLEND);
        
        pBaseData->DriverData.D3DCaps.VertexProcessingCaps &= ~(D3DVTXPCAPS_VERTEXFOG);

        pBaseData->DriverData.D3DCaps.RasterCaps &= ~(D3DPRASTERCAPS_SUBPIXEL |
            D3DPRASTERCAPS_SUBPIXELX | D3DPRASTERCAPS_STIPPLE |
            D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT |
            D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT |
            D3DPRASTERCAPS_TRANSLUCENTSORTINDEPENDENT);

        pBaseData->DriverData.D3DCaps.ShadeCaps &= ~(D3DPSHADECAPS_COLORFLATMONO |
            D3DPSHADECAPS_COLORFLATRGB | D3DPSHADECAPS_COLORGOURAUDMONO | 
            D3DPSHADECAPS_COLORPHONGMONO | D3DPSHADECAPS_COLORPHONGRGB |
            D3DPSHADECAPS_SPECULARFLATMONO | D3DPSHADECAPS_SPECULARFLATRGB |
            D3DPSHADECAPS_SPECULARGOURAUDMONO | D3DPSHADECAPS_SPECULARPHONGMONO |
            D3DPSHADECAPS_SPECULARPHONGRGB | D3DPSHADECAPS_ALPHAFLATBLEND |
            D3DPSHADECAPS_ALPHAFLATSTIPPLED | D3DPSHADECAPS_ALPHAGOURAUDSTIPPLED |
            D3DPSHADECAPS_ALPHAPHONGBLEND | D3DPSHADECAPS_ALPHAPHONGSTIPPLED |
            D3DPSHADECAPS_FOGFLAT | D3DPSHADECAPS_FOGPHONG);

        // Now we generate the list of supported ops from the texture format
        // list and z/stencil list.
        //
        // A DX7 or older driver will return to us a simple list of pixel formats.
        // We will take this list and convert it into a list of supported
        // texture formats in the DX8 style. To that we will append any
        // z/stencil formats.
        //
        // First step in generating supported op lists: see if the list is
        // already a DX8 style format list. If it is (i.e. if any
        // entries are DDPF_D3DFORMAT, then all we need to do is
        // yank out the old-style entries (drivers are allowed to
        // keep both so they can run against old runtimes).

        for (i = 0; i < cTextureFormats; i++)
        {

            if (pTextureList[i].ddpfPixelFormat.dwFlags == DDPF_D3DFORMAT)
            {
                bAlreadyAnOpList = TRUE;
                break;
            }
        }

        if (bAlreadyAnOpList)
        {
            // mmmmm.... dx8 driver. We'll ignore its Z/stencil list because
            // such a driver is supposed to put additional op entries in the
            // "texture" list (i.e. the op list) for its z/stencil formats
            // Now all we have to do is ZAP all the old-style entries.
            for (i = 0; i < (INT)cTextureFormats; i++)
            {
                if (pTextureList[i].ddpfPixelFormat.dwFlags != DDPF_D3DFORMAT && i < (INT)cTextureFormats)
                {
                    // ha! zap that evil old-style entry!
                    // (scroll the remainder of the list down
                    // to squish this entry)
                    DDASSERT(cTextureFormats > 0); //after all, we're in a for loop.
                    if (i < (INT)(cTextureFormats - 1))
                    {
                        memcpy(pTextureList + i,
                               pTextureList + i + 1,
                               sizeof(*pTextureList)*(cTextureFormats - i - 1));
                    }
                    cTextureFormats--;
                    i--;
                }
            }

            // TODO:  Remove this as soon as we think that drivers have caught up to
            //        our OP LIST changes.
            for (i = 0; i < cTextureFormats; i++)
            {
                if (pTextureList[i].ddpfPixelFormat.dwOperations & D3DFORMAT_OP_BACKBUFFER)
                {
                    pTextureList[i].ddpfPixelFormat.dwOperations &= ~D3DFORMAT_OP_BACKBUFFER;
                    pTextureList[i].ddpfPixelFormat.dwOperations |= D3DFORMAT_OP_3DACCELERATION;
                    if (pBaseData->DeviceType == D3DDEVTYPE_HAL)
                    {
                        pTextureList[i].ddpfPixelFormat.dwOperations |= D3DFORMAT_OP_DISPLAYMODE;
                    }
                }
            }

            // If it's a SW driver, we've got a lot of extra work to do.

            if ((pBaseData->DeviceType == D3DDEVTYPE_REF) ||
                (pBaseData->DeviceType == D3DDEVTYPE_SW))
            {
                // First, make sure that the SW driver didn't erroneuously report any
                // D3DFORMAT_OP_DISPLAYMODE entries.

                for (i = 0; i < cTextureFormats; i++)
                {
                    if (pTextureList[i].ddpfPixelFormat.dwOperations & D3DFORMAT_OP_DISPLAYMODE)
                    {
                        DPF_ERR("*****The SW driver is disabled because it claims to support D3DFORMAT_OP_DISPLAYMODE*****");
                        D3D8DeleteDirectDrawObject(pBaseData->hDD);
                        pBaseData->hDD = NULL;
                        goto ErrorExit;
                    }
                }
                        
                // Now for the hard part. The HAL reports which display modes
                // it can support, and the SW driver reports which display
                // modes it can accelerate.  We need to prune the SW list so
                // that it matches the HW list.

                for (i = 0; i < cTextureFormats; i++)
                {
                    if (pTextureList[i].ddpfPixelFormat.dwOperations & D3DFORMAT_OP_3DACCELERATION)
                    {
                        // Does the HAL support this mode?
                        if (IsSupportedOp ((D3DFORMAT) pTextureList[i].ddpfPixelFormat.dwFourCC,
                                           pHalOpList,
                                           NumHalOps,
                                           D3DFORMAT_OP_DISPLAYMODE))
                        {
                            pTextureList[i].ddpfPixelFormat.dwOperations |= D3DFORMAT_OP_DISPLAYMODE;
                        }
                        else
                        {
                            pTextureList[i].ddpfPixelFormat.dwOperations &= ~D3DFORMAT_OP_3DACCELERATION;
                        }
                    }
                }
            }

            // since we found one op-style entry, we shouldn't have
            // killed them all
            DDASSERT(cTextureFormats);
        }
        else
        {
            // Hmmm.. yucky non DX8 driver! Better go through its texture list
            // and turn it into an op list
            INT i;
            for(i=0; i< (INT)cTextureFormats; i++)
            {
                // we proved this above:
                DDASSERT(pTextureList[i].ddpfPixelFormat.dwFlags != DDPF_D3DFORMAT);

                D3DFORMAT NewFormat;
                ConvertFromOldFormat(&pTextureList[i].ddpfPixelFormat, &NewFormat );

                if (NewFormat != D3DFMT_UNKNOWN)    // we succeeded the conversion
                {
                    pTextureList[i].ddpfPixelFormat.dwFourCC = (DWORD) NewFormat;
                    pTextureList[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
                    pTextureList[i].ddpfPixelFormat.dwOperations =  D3DFORMAT_OP_TEXTURE;

                    if (pBaseData->DriverData.D3DCaps.TextureCaps & D3DPTEXTURECAPS_CUBEMAP)
                    {
                        // It is assumed that any texture format works for cubes
                        pTextureList[i].ddpfPixelFormat.dwOperations |=
                            D3DFORMAT_OP_CUBETEXTURE;

                        if (NewFormat == D3DFMT_X1R5G5B5    ||
                            NewFormat == D3DFMT_R5G6B5      ||
                            NewFormat == D3DFMT_A8R8G8B8    ||
                            NewFormat == D3DFMT_X8R8G8B8)
                        {
                            // For these three formats, we assume
                            // all cube-map hw supports rendering to them. 
                            //
                            // Testing indicates that these formats don't work 
                            // well if they are in bitdepth other than the primary; 
                            // so we only specify that the RT aspect of these
                            // formats work if they are basically the same
                            // as the primary.
                            pTextureList[i].ddpfPixelFormat.dwOperations |=
                                D3DFORMAT_OP_SAME_FORMAT_UP_TO_ALPHA_RENDERTARGET;
                        }
                    }

                    // If they can support render target textures, add those flags in now
                    DWORD RTBit = D3DFORMAT_OP_SAME_FORMAT_UP_TO_ALPHA_RENDERTARGET;
                    if (pBaseData->DriverData.KnownDriverFlags & KNOWN_CANMISMATCHRT)
                    {
                        RTBit = D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
                    }
                    if ((NewFormat == D3DFMT_X1R5G5B5) &&
                        (pBaseData->DriverData.KnownDriverFlags & KNOWN_RTTEXTURE_X1R5G5B5))
                    {
                        pTextureList[i].ddpfPixelFormat.dwOperations |= RTBit;
                    }
                    else if ((NewFormat == D3DFMT_R5G6B5) &&
                        (pBaseData->DriverData.KnownDriverFlags & KNOWN_RTTEXTURE_R5G6B5))
                    {
                        pTextureList[i].ddpfPixelFormat.dwOperations |= RTBit;
                    }
                    else if ((NewFormat == D3DFMT_X8R8G8B8) &&
                        (pBaseData->DriverData.KnownDriverFlags & KNOWN_RTTEXTURE_X8R8G8B8))
                    {
                        pTextureList[i].ddpfPixelFormat.dwOperations |= RTBit;
                    }
                    else if ((NewFormat == D3DFMT_A8R8G8B8) &&
                        (pBaseData->DriverData.KnownDriverFlags & KNOWN_RTTEXTURE_A8R8G8B8))
                    {
                        pTextureList[i].ddpfPixelFormat.dwOperations |= RTBit;
                    }
                    else if ((NewFormat == D3DFMT_A1R5G5B5) &&
                        (pBaseData->DriverData.KnownDriverFlags & KNOWN_RTTEXTURE_A1R5G5B5))
                    {
                        pTextureList[i].ddpfPixelFormat.dwOperations |= RTBit;
                    }
                    else if ((NewFormat == D3DFMT_A4R4G4B4) &&
                        (pBaseData->DriverData.KnownDriverFlags & KNOWN_RTTEXTURE_A4R4G4B4))
                    {
                        pTextureList[i].ddpfPixelFormat.dwOperations |= RTBit;
                    }

                    pTextureList[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;
                    pTextureList[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
                    pTextureList[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
                }
                else
                {
                    DPF(3,"This driver exposes an unrecognized DX7- style texture format");
                    // and we eat it up:
                    // (scroll the remainder of the list down to
                    // squish this entry)
                    DDASSERT(cTextureFormats>0); //after all, we're in a for loop.
                    if (i < (INT)(cTextureFormats - 1))
                    {
                        memcpy(pTextureList + i,
                               pTextureList + i + 1,
                               sizeof(*pTextureList)*(cTextureFormats - i - 1));
                    }
                    cTextureFormats--;
                    i--;
                }
            }

            //And laboriously tack on the z/stencil formats. Phew.
            for (i = 0; i < (INT)cZStencilFormats; i++)
            {
                DDASSERT(pZStencilFormatList);

                //we proved this above:
                DDASSERT(pZStencilFormatList[i].dwFlags != DDPF_D3DFORMAT);

                D3DFORMAT NewFormat;

                ConvertFromOldFormat(&pZStencilFormatList[i], &NewFormat);
                if (NewFormat != D3DFMT_UNKNOWN)    //we succeeded the conversion
                {
                    // Room for these elements was allocated above...
                    pTextureList[cTextureFormats].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
                    pTextureList[cTextureFormats].ddpfPixelFormat.dwFourCC = (DWORD) NewFormat;
                    pTextureList[cTextureFormats].ddpfPixelFormat.dwOperations =  D3DFORMAT_OP_ZSTENCIL;
                    pTextureList[cTextureFormats].ddpfPixelFormat.dwPrivateFormatBitCount = 0;
                    pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
                    pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;

                    // See if part is "known good" i.e. it can mix-and-match
                    // ZBuffer and RT formats
                    if (pBaseData->DriverData.KnownDriverFlags & KNOWN_ZSTENCILDEPTH)
                    {
                        pTextureList[cTextureFormats].ddpfPixelFormat.dwOperations 
                                |=  D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH;
                    }

                    // If part successfully supports lockable 16-bit zbuffer tests
                    // then we allow D16_LOCKABLE through; else we only expose D3DFMT_D16
                    if (NewFormat == D3DFMT_D16_LOCKABLE)                    
                    {
                        if (!(pBaseData->DriverData.KnownDriverFlags & KNOWN_D16_LOCKABLE))
                        {
                            pTextureList[cTextureFormats].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_D16;
                        }
                    }

                    cTextureFormats++;
                }
                else
                {
                    DPF(3,"This driver exposes an unrecognized DX6 style Z/Stencil format");
                }
            }

            // Now we need to add in off-screen render target formats for this Non-DX8 driver.

            // DX8 doesn't allow back buffers to be used as textures, so we add
            // a whole new entry to the op list for each supported back buffer
            // format (i.e. don't go searching for any existing texturable format
            // entry that matches and OR in the RT op).
            //
            //If the format is a back-buffer format, we assume it can be rendered when in the same
            //display mode. Note the presence of this entry in the format op list doesn't imply
            //necessarily that the device can render in that depth. CheckDeviceFormat could still
            //fail for modes of that format... This gives us license to blindly add the formats
            //here before we really know what set of back buffer formats the device can do.
            //(Note only display devices are given this boost, since voodoos don't run windowed)

            if (pBaseData->dwFlags & DD_DISPLAYDRV)
            {
                pTextureList[cTextureFormats].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwFourCC = (DWORD) Unknown16;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwOperations =  D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwPrivateFormatBitCount = 0;
                pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
                pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
                cTextureFormats ++;

                pTextureList[cTextureFormats].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_X8R8G8B8;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwOperations =  D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwPrivateFormatBitCount = 0;
                pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
                pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
                cTextureFormats ++;
            }
            else
            {
                // Voodood 2 hack - The V2 doesn't really support offscreen
                // render targets, but we need to add a 565 RT anyway or else
                // our op list won't create the device.
                // CONSIDER: Adding an internal OP flag indicating that this format
                // should NOT succeed in a call to CreateRenderTarget.

                pTextureList[cTextureFormats].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwFourCC = (DWORD) Unknown16;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwOperations =  D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwPrivateFormatBitCount = 0;
                pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
                pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
                cTextureFormats ++;
            }

            // Now add in the supported display modes

            if (D3DGlobalDriverData.hwCaps.dwDeviceRenderBitDepth & DDBD_16)
            {
                pTextureList[cTextureFormats].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwFourCC = (DWORD) Unknown16;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwOperations =  D3DFORMAT_OP_DISPLAYMODE|D3DFORMAT_OP_3DACCELERATION;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwPrivateFormatBitCount = 0;
                pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
                pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
                cTextureFormats++;
            }
            if (D3DGlobalDriverData.hwCaps.dwDeviceRenderBitDepth & DDBD_24)
            {
                pTextureList[cTextureFormats].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_R8G8B8;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwOperations =  D3DFORMAT_OP_DISPLAYMODE|D3DFORMAT_OP_3DACCELERATION;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwPrivateFormatBitCount = 0;
                pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
                pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
                cTextureFormats++;
            }
            if (D3DGlobalDriverData.hwCaps.dwDeviceRenderBitDepth & DDBD_32)
            {
                pTextureList[cTextureFormats].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_X8R8G8B8;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwOperations =  D3DFORMAT_OP_DISPLAYMODE|D3DFORMAT_OP_3DACCELERATION;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwPrivateFormatBitCount = 0;
                pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
                pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
                cTextureFormats++;
            }

            // This is a hack for those really, really old drivers that don't
            // support any D3D at all. We will fill in 16 and 32bpp modes, but remove
            // the 32bpp mode later if we can't find it in the mode table.

            if ((D3DGlobalDriverData.hwCaps.dwDeviceRenderBitDepth == 0)
            #ifdef WIN95
                && (pBaseData->DriverData.D3DCaps.Caps & DDCAPS_BLT)
                && !(pBaseData->DriverData.D3DCaps.Caps & DDCAPS_NOHARDWARE)
            #endif
                )
            {
                pTextureList[cTextureFormats].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwFourCC = (DWORD) Unknown16;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwOperations =  D3DFORMAT_OP_DISPLAYMODE;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwPrivateFormatBitCount = 0;
                pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
                pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
                cTextureFormats++;

                pTextureList[cTextureFormats].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_X8R8G8B8;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwOperations =  D3DFORMAT_OP_DISPLAYMODE;
                pTextureList[cTextureFormats].ddpfPixelFormat.dwPrivateFormatBitCount = 0;
                pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
                pTextureList[cTextureFormats].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
                cTextureFormats++;           
            }
        }

        // As a final pass we infer operations as necessary. If we have an
        // general operation that implies other specific operations; then we
        // turn on the bits of those specific operations. This is better
        // than relying on the driver to get everything right; because it lets us
        // add more specific operations in future releases without breaking
        // old releases.
        for (i = 0; i < cTextureFormats; i++)
        {
            DWORD *pdwOperations = &(pTextureList[i].ddpfPixelFormat.dwOperations);

            // Off-screen RT means truly mode-independent
            if ((*pdwOperations) & D3DFORMAT_OP_OFFSCREEN_RENDERTARGET)
            {
                (*pdwOperations) |= D3DFORMAT_OP_SAME_FORMAT_UP_TO_ALPHA_RENDERTARGET;
                (*pdwOperations) |= D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET;
            }

            // Same except for alpha means exact same is good too
            if ((*pdwOperations) & D3DFORMAT_OP_SAME_FORMAT_UP_TO_ALPHA_RENDERTARGET)
            {
                (*pdwOperations) |= D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET;
            }

            // Color Independent Z implies that forced Z matching is ok too.
            if ((*pdwOperations) & D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH)
            {
                (*pdwOperations) |= D3DFORMAT_OP_ZSTENCIL;
            }
        }

        // Now we make a final pass to verify that they driver did gave us an
        // OP list that makes sense.  The OP list rules are:
        //
        // 1. Only One Endian-ness for any DS format is allowed i.e. D15S1 OR
        //    S1D15, not both independent of other bits.
        // 2. A list should only include D3DFORMAT_OP_DISPLAYMODE for exactly 
        //    one 16bpp format (i.e. shouldnt enumerate 5:5:5 and 5:6:5).
        // 3. A list should not any alpha formats with D3DFORMAT_OP_DISPLAYMODE 
        //    or D3DFORMAT_OP_3DACCEL set.
        // 4. Make sure no mode has OP_3DACCEL set that doesnt also have
        //    OP_DISPLAYMODE set.
        //
        // We also register IHV formats with CPixel.
        //

        BOOL    BadOpList = FALSE;
        for (i = 0; i < cTextureFormats; i++)
        {
            if ((pTextureList[i].ddpfPixelFormat.dwOperations & D3DFORMAT_OP_PIXELSIZE) &&
                pTextureList[i].ddpfPixelFormat.dwPrivateFormatBitCount != 0)
            {
                CPixel::Register((D3DFORMAT)pTextureList[i].ddpfPixelFormat.dwFourCC, pTextureList[i].ddpfPixelFormat.dwPrivateFormatBitCount);
            }

            if ((pTextureList[i].ddpfPixelFormat.dwOperations & D3DFORMAT_OP_3DACCELERATION) &&
                !(pTextureList[i].ddpfPixelFormat.dwOperations & D3DFORMAT_OP_DISPLAYMODE))
            {
                DPF_ERR("***Driver disabled because it reported a format with D3DFORMAT_OP_3DACCELERATION without D3DFORMAT_OP_DISPLAYMODE");
                BadOpList = TRUE;
            }
    
            if ((pTextureList[i].ddpfPixelFormat.dwOperations & D3DFORMAT_OP_3DACCELERATION) &&
                ((pTextureList[i].ddpfPixelFormat.dwFourCC == (DWORD) D3DFMT_A8R8G8B8) ||
                 (pTextureList[i].ddpfPixelFormat.dwFourCC == (DWORD) D3DFMT_A1R5G5B5)))
            {
                DPF_ERR("***Driver disabled because it reported an alpha format with D3DFORMAT_OP_3DACCELERATION");
                BadOpList = TRUE;
            }

            if ((pTextureList[i].ddpfPixelFormat.dwOperations & D3DFORMAT_OP_DISPLAYMODE) &&
                (pTextureList[i].ddpfPixelFormat.dwFourCC == (DWORD) D3DFMT_R5G6B5))
            {
                if (IsSupportedOp (D3DFMT_X1R5G5B5, pTextureList, cTextureFormats, D3DFORMAT_OP_DISPLAYMODE))
                {
                    DPF_ERR("***Driver disabled because it reported both D3DFMT_R5G6B5 and D3DFMT_X1R5G5B5 as a display mode");
                    BadOpList = TRUE;
                }
            }

            if (pTextureList[i].ddpfPixelFormat.dwFourCC == (DWORD) D3DFMT_D15S1)
            {
                if (IsSupportedOp (D3DFMT_S1D15, pTextureList, cTextureFormats, 0))
                {
                    DPF_ERR("***Driver disabled because it reported both D3DFMT_D15S1 and D3DFMT_S1D15");
                    BadOpList = TRUE;
                }
            }
            else if (pTextureList[i].ddpfPixelFormat.dwFourCC == (DWORD) D3DFMT_D24S8)
            {
                if (IsSupportedOp (D3DFMT_S8D24, pTextureList, cTextureFormats, 0))
                {
                    DPF_ERR("***Driver disabled because it reported both D3DFMT_D24S8 and D3DFMT_S8D24");
                    BadOpList = TRUE;
                }
            }
            else if (pTextureList[i].ddpfPixelFormat.dwFourCC == (DWORD) D3DFMT_D24X8)
            {
                if (IsSupportedOp (D3DFMT_X8D24, pTextureList, cTextureFormats, 0))
                {
                    DPF_ERR("***Driver disabled because it reported both D3DFMT_D24X8 and D3DFMT_X8D24");
                    BadOpList = TRUE;
                }
            }
            else if (pTextureList[i].ddpfPixelFormat.dwFourCC == (DWORD) D3DFMT_D24X4S4)
            {
                if (IsSupportedOp (D3DFMT_X4S4D24, pTextureList, cTextureFormats, 0))
                {
                    DPF_ERR("***Driver disabled because it reported both D3DFMT_D24X4S4 and D3DFMT_X4S4D24");
                    BadOpList = TRUE;
                }
            }
        }
        if (BadOpList)
        {
            D3D8DeleteDirectDrawObject(pBaseData->hDD);
            pBaseData->hDD = NULL;
            goto ErrorExit;
        }


        // and now we assign the texture list to its place in the driver data
        pBaseData->DriverData.pGDD8SupportedFormatOps  = pTextureList;
        if (pTextureList != NULL)
        {
            pTextureList = NULL;    //so it won't be freed later
            pBaseData->DriverData.GDD8NumSupportedFormatOps = cTextureFormats;
        }
        else
        {
            pBaseData->DriverData.GDD8NumSupportedFormatOps = 0;
        }

        if (!(pBaseData->DriverData.D3DCaps.Caps2 & DDCAPS2_NONLOCALVIDMEM))
        {
            if (pBaseData->DriverData.D3DCaps.DevCaps & D3DDEVCAPS_TEXTURENONLOCALVIDMEM)
            {   //some drivers(Riva128 on PCI) incorrectly sets D3DDEVCAPS_TEXTURENONLOCALVIDMEM
                DPF(1, "driver set D3DDEVCAPS_TEXTURENONLOCALVIDMEM w/o DDCAPS2_NONLOCALVIDMEM:turning off D3DDEVCAPS_TEXTURENONLOCALVIDMEM");
                pBaseData->DriverData.D3DCaps.DevCaps &= ~D3DDEVCAPS_TEXTURENONLOCALVIDMEM;
            }
        }

        // For pre-DX8, we have some munging of caps that is necessary
        if (pBaseData->DriverData.D3DCaps.MaxStreams == 0)
        {
            DWORD *pdwTextureCaps = &pBaseData->DriverData.D3DCaps.TextureCaps;
            if (*pdwTextureCaps & D3DPTEXTURECAPS_CUBEMAP)
            {
                if (pBaseData->DriverData.KnownDriverFlags & KNOWN_MIPPEDCUBEMAPS)
                {
                    *pdwTextureCaps |= D3DPTEXTURECAPS_MIPCUBEMAP;
                }
                else
                {
                    // Turn off Mip filter flags since this is card doesnt support a mipped cubemap.
                    pBaseData->DriverData.D3DCaps.CubeTextureFilterCaps &= ~(D3DPTFILTERCAPS_MIPFPOINT  |
                                                                             D3DPTFILTERCAPS_MIPFLINEAR);
                }
                // Also we need to specify that cube-maps must
                // be power-of-two
                *pdwTextureCaps |= D3DPTEXTURECAPS_CUBEMAP_POW2;
            }

            // We need to determine the part can support mipmaps...
            if (pBaseData->DriverData.D3DCaps.TextureFilterCaps &
                    (D3DPTFILTERCAPS_MIPNEAREST         |
                     D3DPTFILTERCAPS_MIPLINEAR          |
                     D3DPTFILTERCAPS_LINEARMIPNEAREST   |
                     D3DPTFILTERCAPS_LINEARMIPLINEAR    |
                     D3DPTFILTERCAPS_MIPFPOINT          |
                     D3DPTFILTERCAPS_MIPFLINEAR))
            {
                *pdwTextureCaps |= D3DPTEXTURECAPS_MIPMAP;
            }
            else
            {
                DPF(3, "Device doesn't support mip-maps");
            }
        }

        // We disable driver-management for pre-dx8 parts because
        // the semantics for driver-management are now different
        // for dx8; and hence we can't use old driver's logic.
        pBaseData->DriverData.D3DCaps.Caps2 &= ~DDCAPS2_CANMANAGETEXTURE;

        // For HW that needs separate banks of texture memory; we
        // disable multi-texturing. This is done because we don't want to
        // have an API that puts the burden on the application to specifically
        // code for this case.
        if (pBaseData->DriverData.D3DCaps.DevCaps & D3DDEVCAPS_SEPARATETEXTUREMEMORIES)
        {
            pBaseData->DriverData.D3DCaps.MaxSimultaneousTextures = 1;

            // Turn off this flag.
            pBaseData->DriverData.D3DCaps.DevCaps &= ~D3DDEVCAPS_SEPARATETEXTUREMEMORIES;
        }
    }

ErrorExit:

    if (NULL != pTextureList)
        MemFree(pTextureList);

    // It was only temporary, having now been merged into the supported op list.
    if (NULL != pZStencilFormatList)
        MemFree(pZStencilFormatList);

    return;

} /* FetchDirectDrawData */

/*
 * DirectDrawSupported
 */
BOOL DirectDrawSupported(void)
{
    HDC         hdc;
    unsigned    u;

    hdc = GetDC(NULL);
    u = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);
    ReleaseDC(NULL, hdc);

    if (u < 8)
    {
        return FALSE;
    }
    return TRUE;

} /* DirectDrawSupported */

// Utility function that tells us if there is more than
// one display device in the system.  (We count all devices,
// regardless of whether they are attached to the desktop.)
BOOL IsMultiMonitor(void)
{
    int i, n;

    // Each loop below enumerates one display device.
    for (i = 0, n = 0; ; i++)
    {
        DISPLAY_DEVICEA dd;

        // Zero the memory of the DISPLAY_DEVICE struct between calls to
        // EnumDisplayDevices
        ZeroMemory(&dd, sizeof(dd));
        dd.cb = sizeof(dd);
        if (!xxxEnumDisplayDevicesA(NULL, i, &dd, 0))
        {
            break;      // no more devices to enumerate
        }
        if (dd.StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER)
        {
            continue;   // not a real hardware display driver
        }
        // We're just trying to count the number of display devices in the
        // system and see if there is more than one.
        if (++n > 1)
        {
            return TRUE;   // multiple display devices
        }
    }

    return FALSE;  // single display device
}


BOOL fDoesGDI(HDC hdc)
{
    //
    // the 3Dfx driver always return 1 to every thing
    // verify GetNearest()  color works.
    //
    BOOL b = GetNearestColor(hdc, 0x000000) == 0x000000 &&
             GetNearestColor(hdc, 0xFFFFFF) == 0xFFFFFF;
    if (b)
    {
        DPF(3,"Driver is a GDI driver");
    }

    return b;
}

/*
 * Functions to dynamically link against exports we need in user32 on
 * older OSes
 */
//These statics will be per-process, cuz it's outside the shared section
typedef BOOL (WINAPI * LPENUMMONITORS) (HDC, LPRECT, MONITORENUMPROC, LPARAM);
typedef BOOL (WINAPI * LPGETMONINFO) (HMONITOR, MONITORINFO *);
typedef BOOL (WINAPI * LPISDEBUG) (void);
static LPISDEBUG pIsDebuggerPresent = 0;
static LPENUMMONITORS pEnumMonitors = 0;
static LPGETMONINFO pGetMonitorInfo = 0;
static BOOL bTriedToGetProcAlready = FALSE;

BOOL DynamicLinkToOS(void)
{
    if (1) //!pEnumMonitors)
    {
        HMODULE hUser32;
        HMODULE hKernel32;

        if (0) //bTriedToGetProcAlready)
            return FALSE;

        bTriedToGetProcAlready = TRUE;

        hUser32 = GetModuleHandle(TEXT("USER32"));
        pEnumMonitors = (LPENUMMONITORS) GetProcAddress(hUser32,"EnumDisplayMonitors");
        pGetMonitorInfo = (LPGETMONINFO) GetProcAddress(hUser32,"GetMonitorInfoA");

        hKernel32 = GetModuleHandle(TEXT("KERNEL32"));
        pIsDebuggerPresent = (LPISDEBUG) GetProcAddress(hKernel32,"IsDebuggerPresent");

        if (!pEnumMonitors || !pGetMonitorInfo || !pIsDebuggerPresent)
        {
            DPF(3,"Failed to get proc addresses");
            return FALSE;
        }
    }

    DDASSERT(pEnumMonitors);
    DDASSERT(pGetMonitorInfo);
    DDASSERT(pEnumMonitors);

    return TRUE;
}

BOOL InternalGetMonitorInfo(HMONITOR hMon, MONITORINFO *lpInfo)
{
    DynamicLinkToOS();

    if (!pGetMonitorInfo)
        return FALSE;

    return pGetMonitorInfo(hMon, lpInfo);
}

typedef struct
{
    LPSTR       pName;
    HMONITOR    hMon;
} CALLBACKSTRUCT, * LPCALLBACKSTRUCT;


BOOL InternalEnumMonitors(MONITORENUMPROC proc, LPCALLBACKSTRUCT lp)
{
    DynamicLinkToOS();

    if (!pEnumMonitors)
        return FALSE;

    pEnumMonitors(NULL,NULL,proc,(LPARAM)lp);

    return TRUE;
}
/*
 * InternalIsDebuggerPresent
 * A little helper so that this runtime runs against older OSes
 */
BOOL InternalIsDebuggerPresent(void)
{
    DynamicLinkToOS();

    if (!pIsDebuggerPresent)
        return FALSE;

    return pIsDebuggerPresent();
}

//
// getPrimaryDisplayName
//

void getPrimaryDisplayName(void)
{
    DISPLAY_DEVICE dd;
    int i;

    ZeroMemory(&dd, sizeof dd);
    dd.cb = sizeof dd;

    for (i = 0; xxxEnumDisplayDevicesA(NULL, i, &dd, 0); ++i)
    {
        if (dd.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE)
        {
            lstrcpyn(g_szPrimaryDisplay, dd.DeviceName, sizeof g_szPrimaryDisplay);
            return;
        }
    }

    lstrcpy(g_szPrimaryDisplay, DISPLAY_STR);
}

/*
 * InternalDirectDrawCreate
 */

HRESULT InternalDirectDrawCreate(
                PD3D8_DEVICEDATA*   ppBaseData,
                PADAPTERINFO        pDeviceInfo,
                D3DDEVTYPE          DeviceType,
                VOID*               pInitFunction,
                D3DFORMAT           Unknown16,
                DDSURFACEDESC*      pHalOpList,
                DWORD               NumHalOps)
{
    int                         rc;
    HDC                         hdc_dd;
    HKEY                        hkey;
    ULONG_PTR                   hDD;
    PD3D8_DEVICEDATA            pBaseData;

    *ppBaseData = (PD3D8_DEVICEDATA) NULL;

    /*
     * check for < 8 bpp and disallow.
     */
    if (!DirectDrawSupported())
    {
        DPF_ERR("DDraw and Direct3D are not supported in less than 8bpp modes. Creating Device fails.");
        return D3DERR_NOTAVAILABLE;
    }

    ENTER_CSDDC();

    hdc_dd = NULL;
    hDD = 0;

    //
    // Get the primary display name, which will usually be something like
    // \\.\Display1 and in some cases may be \\.\Display1\Unit0. We only
    // do this one time, and store it globally. On Win98, the global name
    // will be shared between all processes, and on NT5, each process will
    // have its own copy. Also, note that the primary device name may change
    // on NT5; we need to look into this.
    //

    if (g_szPrimaryDisplay[0] == '\0')
    {
        getPrimaryDisplayName();
    }

    // Create the object and get all of the data.

    hdc_dd = DD_CreateDC(pDeviceInfo->DeviceName);
    if (hdc_dd == NULL)
    {
        DPF_ERR("Could not create driver, CreateDC failed! Creating Device fails.");
        LEAVE_CSDDC();
        return E_OUTOFMEMORY;
    }

    // Create the driver object

    pBaseData = (PD3D8_DEVICEDATA) MemAlloc (sizeof (D3D8_DEVICEDATA));
    if (pBaseData == NULL)
    {
        DPF_ERR("Insufficient system memory! Creating Device fails. ");
        DD_DoneDC(hdc_dd);
        LEAVE_CSDDC();
        return E_OUTOFMEMORY;
    }
    ZeroMemory( pBaseData, sizeof(D3D8_DEVICEDATA) );
    strcpy(pBaseData->DriverName, pDeviceInfo->DeviceName);
    pBaseData->hDC = hdc_dd;
    pBaseData->Guid = pDeviceInfo->Guid;
    pBaseData->DeviceType = DeviceType;

    // Even if it's not a display driver, it may still be a GDI driver

    if (hdc_dd != NULL)
    {
        if (pDeviceInfo->bIsDisplay)
        {
            pBaseData->dwFlags |= DD_DISPLAYDRV;
        }
        else if (fDoesGDI(hdc_dd))
        {
            pBaseData->dwFlags |= DD_GDIDRV;
        }
    }

    // Get all of the driver caps and callbacks

    FetchDirectDrawData(pBaseData, 
                        pInitFunction, 
                        Unknown16, 
                        pHalOpList,
                        NumHalOps);

    if (pBaseData->hDD == NULL)
    {
        DDASSERT(NULL == pBaseData->DriverData.pGDD8SupportedFormatOps);
        DD_DoneDC(hdc_dd);
        MemFree(pBaseData);
        LEAVE_CSDDC();
        return D3DERR_NOTAVAILABLE;
    }
    *ppBaseData = pBaseData;
    LEAVE_CSDDC();
    return S_OK;

} /* InternalDirectDrawCreate */


/*
 * InternalDirectDrawRelease
 */

HRESULT InternalDirectDrawRelease(PD3D8_DEVICEDATA  pBaseData)
{
    D3D8DeleteDirectDrawObject(pBaseData->hDD);
    DD_DoneDC(pBaseData->hDC);
    MemFree(pBaseData->DriverData.pGDD8SupportedFormatOps);
    MemFree(pBaseData);

    return S_OK;
} /* InternalDirectDrawRelease */


BOOL CALLBACK MonitorEnumProc(HMONITOR hMon, HDC hdc, LPRECT lpr, LPARAM lParam)
{
    MONITORINFOEX       mix;
    MONITORINFO         mi;
    LPCALLBACKSTRUCT    lpcb = (LPCALLBACKSTRUCT) lParam;

    mi.cbSize = sizeof(mi);
    if (!InternalGetMonitorInfo(hMon,&mi))
        return FALSE;

    mix.cbSize = sizeof(mix);
    if (!InternalGetMonitorInfo(hMon,(MONITORINFO*) &mix))
        return FALSE;

    if (!strcmp(lpcb->pName,(LPSTR)mix.szDevice))
    {
        //Found it!!
        lpcb->hMon = hMon;
        return FALSE;
    }
    return TRUE;
}

/*
 * GetMonitorFromDeviceName
 */
HMONITOR GetMonitorFromDeviceName(LPSTR szName)
{
    CALLBACKSTRUCT cbs;
    cbs.pName = szName;
    cbs.hMon = NULL;

    if (!InternalEnumMonitors(MonitorEnumProc, &cbs))
        return NULL;

    return cbs.hMon;
}



/*
 * these are exported... temp. hack for non-Win95
 */
#ifndef WIN95
void DDAPI thk3216_ThunkData32(void)
{
}
void DDAPI thk1632_ThunkData32(void)
{
}

DWORD DDAPI DDGetPID(void)
{
    return 0;
}

int DDAPI DDGetRequest(void)
{
    return 0;
}

BOOL DDAPI DDGetDCInfo(LPSTR fname)
{
    return 0;
}


#ifdef POSTPONED
BOOL DDAPI DD32_HandleExternalModeChange(LPDEVMODE pModeInfo)
{
    return FALSE;
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\ddgdi32.c ===
/******************************Module*Header*******************************\
* Module Name: ddraw.c
*
* Client side stubs for the private DirectDraw system APIs.
*
* Created: 3-Dec-1995
* Author: J. Andrew Goossen [andrewgo]
*
* Copyright (c) 1995-1999 Microsoft Corporation
\**************************************************************************/


#define _D3DTYPES_H_
#define _D3DCAPS_H_
#include "ddrawpr.h"
//#include "ddrawgdi.h"
#include <ddrawint.h>
#include <d3dnthal.h>
#include <winddi.h>
#include <osthunk.h>
#include "ddithunk.h"
#include <d3d8sddi.h>
#include <assert.h>

#define _FACD3D  0x876
#define MAKE_D3DHRESULT( code )  MAKE_HRESULT( 1, _FACD3D, code )
#define D3DERR_DEVICELOST                       MAKE_D3DHRESULT(2152)
#define D3DERR_DRIVERINTERNALERROR              MAKE_D3DHRESULT(2087)
#define D3DERR_NOTAVAILABLE                     MAKE_D3DHRESULT(2154)
#define D3DERR_OUTOFVIDEOMEMORY                 MAKE_D3DHRESULT(380)
#define D3DERR_DEFERRED_DP2ERROR                MAKE_D3DHRESULT(2158)

typedef struct _KNOWNENTRY
{
    DWORD   PCIID;
    DWORD   VersionMajor;       // 0 means all versions
    DWORD   VersionMinor;       // 0 means all versions
    DWORD   Flags;
} KNOWNENTRY;

// The buffer used by GetDriverInfo2 is constrained to the maximum size
// specified below by restrictions in the Win2K kernel. It is vital that
// all data passed to the driver and received from the driver via
// GetDriverInfo2 fit within a buffer of this number of DWORDS.
// This size has to be less than 1K to let the kernel do its own buffer
// overwrite testing.
#define MAX_GDI2_BUFFER_DWORD_SIZE (249)

// Bogus value used to initialize write only fields when communicating
// with the driver in debug builds
#define BOGUS_FIELD_VALUE          0xBAADCAFEul

// Some global variables used to track when surfaces are free for all devices
// in the process.  This is tricky since we don't keep a device list.
DWORD GlobalUniqueness = 0;
DWORD NumDevices = 0;
DWORD NumReadyDevices = 0;

//todo d16 for rage 128 series... need date/time
//todo :G200, G400 new RT+Tex formats... need date/time
//todo: Need driver date/time for Kyro: |KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8
//todo: Trident 8420, 9910: need date/time for D16
//todo: dates for SiS parts D16

const KNOWNENTRY gKnownDeviceList[] =
{
    // NVidia
    {0x12D20018,          0,          0, KNOWN_ZSTENCILDEPTH},                                      // Riva 128         
    {0x10DE0020,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // TNT
    {0x10DE0028,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // TNT2
    {0x10DE0029,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // TNT2 Ultra
    {0x10DE002C,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Vanta
    {0x10DE002D,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // TNT2 Model 64
    {0x10DE00A0,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Aladdin TNT2
    {0x10DE0100,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV10 (GeForce) 
    {0x10DE0101,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV10 (GeForce DDR) 
    {0x10DE0103,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV10 (Quadro) 
    {0x10DE0110,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV11 (GeForce2 MX) 
    {0x10DE0111,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV11 (GeForce2 MX) 
    {0x10DE0113,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV11 (Quadro2 MXR) 
    {0x10DE0150,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV15 (GeForce2)
    {0x10DE0151,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV15 (GeForce2 DDR) 
    {0x10DE0152,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV15 (GeForce2 BR) 
    {0x10DE0153,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV15 (Quadro2) 
    {0x10DE0200,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV20 (GeForce 3)
    // 3DFX
    {0x121A0003,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_R5G6B5},            // Banshee
    {0x121A0005,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_R5G6B5},            // Voodoo3
    {0x121a0009,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A8R8G8B8},       // Voodoo4/5; same PCI-ID
    // ATI                                                                                           
    {0x10024742,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x10024744,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x10024749,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x1002474D,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x1002474E,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x1002474F,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x10024750,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x10024752,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x10024C42,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro (PCI)
    {0x10024C49,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro (PCI)
    {0x10024C4E,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x10024C52,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x10024C53,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x10024C60,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro LT

    {0x10024C4D,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X1R5G5B5},   // Rage Mobility AGP

    {0x10024C46, 0x0005000a, 0x00000404, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // Rage Mobility 128
    {0x10024C46,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // Rage Mobility 128
    {0x10024D46, 0x0005000a, 0x00000404, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // Rage Mobility 128
    {0x10024D46,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // Rage Mobility 128

    {0x10025046, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X TMDS
    {0x10025046,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X TMDS
    {0x10025245, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128
    {0x10025245,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128
    {0x10025246, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128
    {0x10025246,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128
    {0x1002524B, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 VR PCI //DX8.1
    {0x1002524B,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 VR PCI //DX8.1
    {0x1002524C, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128
    {0x1002524C,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128

    //New 128s for DX8.1:
    {0x10025041, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI            DX8.1
    {0x10025041,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI            DX8.1
    {0x10025042, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X         DX8.1
    {0x10025042,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X         DX8.1
    {0x10025043, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X         DX8.1
    {0x10025043,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X         DX8.1
    {0x10025044, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI TMDS       DX8.1
    {0x10025044,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI TMDS       DX8.1
    {0x10025045, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X TMDS    DX8.1
    {0x10025045,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X TMDS    DX8.1
    {0x10025047, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI            DX8.1
    {0x10025047,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI            DX8.1
    {0x10025048, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X         DX8.1
    {0x10025048,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X         DX8.1
    {0x10025049, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X         DX8.1
    {0x10025049,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X         DX8.1
    {0x1002504a, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI TMDS       DX8.1
    {0x1002504a,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI TMDS       DX8.1
    {0x1002504b, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X TMDS    DX8.1
    {0x1002504b,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X TMDS    DX8.1
    {0x1002504c, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X TMDS    DX8.1
    {0x1002504c,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X TMDS    DX8.1
    {0x1002504d, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP            DX8.1
    {0x1002504d,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP            DX8.1
    {0x1002504e, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X         DX8.1
    {0x1002504e,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X         DX8.1
    {0x1002504f, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X         DX8.1
    {0x1002504f,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X         DX8.1
    {0x10025050, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI TMDS       DX8.1
    {0x10025050,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI TMDS       DX8.1
    {0x10025051, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X TMDS    DX8.1
    {0x10025051,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X TMDS    DX8.1
    {0x10025052, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X TMDS    DX8.1
    {0x10025052,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X TMDS    DX8.1
    {0x10025053, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI            DX8.1
    {0x10025053,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI            DX8.1
    {0x10025054, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X         DX8.1
    {0x10025054,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X         DX8.1
    {0x10025055, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X         DX8.1
    {0x10025055,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X         DX8.1
    {0x10025056, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI TMDS       DX8.1
    {0x10025056,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI TMDS       DX8.1
    {0x10025057, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X TMDS    DX8.1
    {0x10025057,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X TMDS    DX8.1
    {0x10025058, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X TMDS    DX8.1
    {0x10025058,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X TMDS    DX8.1
                        
    {0x10025345, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X PCI    DX8.1
    {0x10025345,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X PCI    DX8.1
    {0x10025346, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X AGP 2X    DX8.1
    {0x10025346,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X AGP 2X    DX8.1
    {0x10025347, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X AGP 4X    DX8.1
    {0x10025347,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X AGP 4X    DX8.1
    {0x10025348, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X   DX8.1
    {0x10025348,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X   DX8.1
    {0x1002534b, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X PCI    DX8.1
    {0x1002534b,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X PCI    DX8.1
    {0x1002534c, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X AGP 2X    DX8.1
    {0x1002534c,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X AGP 2X    DX8.1
    {0x1002534d, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X AGP 4X    DX8.1
    {0x1002534d,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X AGP 4X    DX8.1
    {0x1002534e, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X     DX8.1
    {0x1002534e,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X     DX8.1

    {0x10025446, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO ULTRA GL AGP      DX8.1
    {0x10025446,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO ULTRA GL AGP      DX8.1
    {0x1002544c, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO ULTRA VR AGP      DX8.1
    {0x1002544c,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO ULTRA VR AGP      DX8.1
    {0x10025452, 0x00050001, 0x098a0001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO ULTRA4XL VR-R AGP DX8.1
    {0x10025452,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO ULTRA4XL VR-R AGP DX8.1

    {0x10025144,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage6
    {0x10025145,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage6
    {0x10025146,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage6
    {0x10025147,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage6

    // Intel                                                                                         
    {0x80867800,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER},  // Intel i740
    {0x80867123,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5},  // Intel 810
    {0x80867125,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5},                              // Intel 810e
    {0x80861132,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5},                                                 // Intel 815
    {0x80861A12,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER},                                            // Intel Timna

    // Matrox                                                                                        
    {0x102b0520, 0x0005000c, 0x000104b0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},                                      // G200 PCI
    {0x102b0520,          0,          0, KNOWN_ZSTENCILDEPTH},                                      // G200 PCI
    {0x102b0521, 0x0005000c, 0x000104b0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},          // G200 AGP
    {0x102b0521,          0,          0, KNOWN_ZSTENCILDEPTH},          // G200 AGP
    {0x102b0525, 0x0005000c, 0x000104b0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // G400, G450
    {0x102b0525,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // G400, G450
    // 3DLabs                                                                                        
    {0x3d3d0008,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH},                                      // 3DLabs Gamma
    {0x104c3d07,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8}, // Perm2
    {0x3d3d0009,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8},                                      // Perm2
    {0x3d3d000a,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Perm3
    {0x3d3d000a, 0x00050000, 0x08930001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Perm3
    {0x3d3d000c, 0x00050000, 0x08930001, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Perm3
    // Videologic                                                                                    
    {0x104a0010, 0x0004000c, 0x0001080c, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // PowerVR Kyro updated driver
    {0x104a0010,          0,          0, KNOWN_ZSTENCILDEPTH}, // PowerVR Kyro
    // S3                                                                                            
    {0x53338811,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X1R5G5B5},          // Virge
    {0x53335631,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X1R5G5B5},          // Virge
    {0x53338a01,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X1R5G5B5},          // Virge DX/GX DX8.1
    {0x53338c01,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X1R5G5B5},          // Virge MX DX8.1
    {0x53338a10,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X1R5G5B5},          // Virge GX2 DX8.1
    {0x53338a20,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER},          // Savage3D
    {0x53338a22,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},          // Savage4
    {0x53339102,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER},          // Savage2K
    {0x53338c10,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5},          // Savage MX DX8.1
    {0x53338c12,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5},          // Savage IX DX8.1
    {0x53338a25,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},          // Savage Pro DX8.1
    {0x53338a26,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},          // Savage Pro DX8.1
    // Trident
    {0x10239880,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER}, // Trident Blade 3D 9880
    {0x10238500,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Trident Blade 3D/ProMedia DX8.1
    {0x10238400,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Trident Blade 3D/MVP4     DX8.1
    {0x10238420,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Trident CyberBlade i7 
    {0x10239910,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Trident CyberBlade DX8.1
    // SiS
    {0x10390300, 0x0005000c, 0x0001044c, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},               // SiS 300
    {0x10390300,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5},               // SiS 300
    {0x10396326, 0x0005000c, 0x00010514, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5},          // SiS 6326
    {0x10396326,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER },          // SiS 6326
    {0x10395300, 0x0005000c, 0x0001044c, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},               // SiS 300
    {0x10395300,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5},               // SiS 300
    {0x10396300, 0x0005000c, 0x0001044c, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},               // SiS 6300
    {0x10396300,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5},               // SiS 6300
    {0x10390310, 0x0005000d, 0x0001035c, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // SiS 310
    {0x10390315, 0x0005000d, 0x0001035c, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // SiS 315
    {0x10390325, 0x0005000d, 0x000107d0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // SiS 325
    {0x10396325, 0x0005000d, 0x000107d0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // SiS 640/740
    {0x126f0720,          0,          0, KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A1R5G5B5} //Silicon Motion Lynx3DM
};

#define NUM_KNOWN_DEVICES      (sizeof(gKnownDeviceList)/sizeof(KNOWNENTRY))

#define RESPATH_D3D "Software\\Microsoft\\Direct3D"

void InformDriverFreeAGP(HANDLE hDD);
void InformDriverToDeferFrees(HANDLE hDD);
void InformDriverAGPWorkaroundAware(HANDLE hDD);

#ifdef DEBUG
// Debug helper to indicate which surfaces are around
// 
void DebugPrintSurfaceInfo(PDDSURFHANDLE pSurf)
{
    switch (pSurf->Type)
    {
    case D3DRTYPE_SURFACE:
        DPF(0,"  D3DRTYPE_SURFACE");
        break;
    case D3DRTYPE_VOLUME:
        DPF(0,"  D3DRTYPE_VOLUME");
        break;
    case D3DRTYPE_TEXTURE:
        DPF(0,"  D3DRTYPE_TEXTURE");
        break;
    case D3DRTYPE_VOLUMETEXTURE:
        DPF(0,"  D3DRTYPE_VOLUMETEXTURE");
        break;
    case D3DRTYPE_CUBETEXTURE:
        DPF(0,"  D3DRTYPE_CUBETEXTURE");
        break;
    case D3DRTYPE_VERTEXBUFFER:
        DPF(0,"  D3DRTYPE_VERTEXBUFFER");
        break;
    case D3DRTYPE_INDEXBUFFER:
        DPF(0,"  D3DRTYPE_INDEXBUFFER");
        break;
    case D3DRTYPE_COMMANDBUFFER:
        DPF(0,"  D3DRTYPE_COMMANDBUFFER");
        break;
    default:
        DPF(0,"  UNKNOWN SURFACE TYPE");
        break;
    }
} // DebugPrintSurfaceInfo
#endif 



HRESULT MapLegacyResult(HRESULT in)
{
    HRESULT hr;
    switch (in)
    {
    case DD_OK:
        hr = S_OK;
        break;

    case DDERR_OUTOFVIDEOMEMORY:
        hr = D3DERR_OUTOFVIDEOMEMORY;
        break;

    case DDERR_CURRENTLYNOTAVAIL:
    case DDERR_UNSUPPORTED:
        hr = D3DERR_NOTAVAILABLE;
        break;

    case DDERR_OUTOFMEMORY:
        hr = E_OUTOFMEMORY;
        break;

    default:
        hr = D3DERR_DRIVERINTERNALERROR;
    }
    return hr;
}

BOOL CanKnownDriverDoThis(PDDDEVICEHANDLE pDevice, DWORD Flag)
{
    BOOL ret = FALSE;
    int i;

    if (pDevice->ForceFlagsOff & Flag)
    {
        return FALSE;
    }
    else if (pDevice->ForceFlagsOn & Flag)
    {
        return TRUE;
    }

    // Only drivers in our known good list can support lightweight
    // surfaces

    if (pDevice->PCIID == 0)
    {
        D3DADAPTER_IDENTIFIER8  DI;

        GetAdapterInfo(pDevice->szDeviceName, &DI, TRUE, TRUE, FALSE);
        pDevice->PCIID = (DI.VendorId << 16) | DI.DeviceId;
        pDevice->DriverVersionHigh = DI.DriverVersion.HighPart;
        pDevice->DriverVersionLow = DI.DriverVersion.LowPart;
    }
    for (i = 0; i < NUM_KNOWN_DEVICES; i++)
    {
        if ((gKnownDeviceList[i].PCIID == pDevice->PCIID) &&
            (gKnownDeviceList[i].Flags & Flag) &&
            ((pDevice->DriverVersionHigh > gKnownDeviceList[i].VersionMajor) ||
             ((pDevice->DriverVersionHigh == gKnownDeviceList[i].VersionMajor) &&
              (pDevice->DriverVersionLow >= gKnownDeviceList[i].VersionMinor))))
        {
            ret = TRUE;
            break;
        }
    }

    return ret;
}

BOOL FormatCompatibleWithDisplayFormat(
    PDDDEVICEHANDLE pDD,
    D3DFORMAT Format)
{
    // The surface is compatible if formats match
    if (Format == pDD->DisplayFormatWithAlpha)
        return TRUE;
    return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "ReleaseDX7SurfaceHandle"

void ReleaseDX7SurfaceHandle(HANDLE hDD, DWORD handle)
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;

    pDeviceHandle->SurfaceHandleList.dwList[handle].nextentry =
        pDeviceHandle->SurfaceHandleList.dwFreeList;
    pDeviceHandle->SurfaceHandleList.dwFreeList = handle;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FreeSurfaceObject"

void FreeSurfaceObject (PDDSURFHANDLE pSurf)
{
    DWORD dwRet = DDHAL_DRIVER_NOTHANDLED;

    // If the surface was created by a software driver, we need to call the
    // software driver to destroy it.

    if (IS_SOFTWARE_DRIVER_SURFACE(pSurf))
    {
        // In a creation failure case, we may have not actually called the
        // driver/kernel to create this surface yet.

        // Release the kernel's handle first so that it
        // can finish up whatever it wants to before we free
        // the underlying memory
        if (pSurf->hSurface != 0)
        {
            OsThunkDdDeleteSurfaceObject(pSurf->hSurface);
        }

        // Now free the SW driver's object
        if (pSurf->dwFlags & DDSURF_CREATECOMPLETE)
        {
            dwRet = SwDDIDestroySurface (pSurf->pDevice, pSurf);
        }

    }
    else if (pSurf->hSurface != 0)
    {
        if (pSurf->Pool != D3DPOOL_SYSTEMMEM)
        {
            if ((pSurf->Type == D3DRTYPE_COMMANDBUFFER) ||
                (pSurf->Type == D3DRTYPE_VERTEXBUFFER)  || 
                (pSurf->Type == D3DRTYPE_INDEXBUFFER) )
            {
                OsThunkDdDestroyD3DBuffer(pSurf->hSurface);
            }
            else
            {
                OsThunkDdDestroySurface(pSurf->hSurface, TRUE);
            }
        }
        OsThunkDdDeleteSurfaceObject(pSurf->hSurface);
        pSurf->hSurface = NULL;
    }

    if (pSurf->dwCookie)
    {
        // If CreateSurfaceEx was called on a sysmem surface, we need to tell
        // the driver.  On NT, we only need to tell the software driver since
        // the kernel handles this for a real driver.

        if ((IS_SOFTWARE_DRIVER(pSurf->pDevice)) &&
            (pSurf->dwFlags & DDSURF_CREATECOMPLETE) &&
            (pSurf->Pool == D3DPOOL_SYSTEMMEM))
        {
            // DX7 called CreateSurfaceEx fpVidMem = 0 on each mipmap level
            // (even though it only creates it on the topmost level), so we
            // need to do the same to maintain driver compatibility.

            pSurf->pLcl->lpGbl->fpVidMem = 0;
            SwDDICreateSurfaceEx (pSurf->pDevice->pDD, pSurf->pLcl);
        }

        ReleaseDX7SurfaceHandle(pSurf->pDevice, pSurf->dwCookie);
        pSurf->dwCookie = 0;
    }

    if (pSurf->pLcl != NULL)
    {
        MemFree(pSurf->pLcl);
        pSurf->pLcl = NULL;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CheckForDeviceLost"

BOOL CheckForDeviceLost (HANDLE hDD)
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;
    PDDSURFHANDLE pSurf;
    DWORD           Uniqueness = DdQueryDisplaySettingsUniqueness();

    if (!pDeviceHandle->bDeviceLost &&
        (Uniqueness != pDeviceHandle->DisplayUniqueness))
    {
        // If this is the first device to notice it is lost, then set
        // some state.
        if (InterlockedCompareExchange(&GlobalUniqueness, Uniqueness, GlobalUniqueness) != Uniqueness)
        {
            NumReadyDevices = 0;
        }
        pDeviceHandle->dwFlags &= ~DDDEVICE_READY;

        // The device has transitioned to the lost state, so we need
        // walk through the list and free the vidmem surfaces..

        pDeviceHandle->bDeviceLost  = TRUE;
        pSurf = pDeviceHandle->pSurfList;
        while (pSurf != NULL)
        {
            if (IS_SURFACE_LOOSABLE(pSurf))
            {
                if (pSurf->LockRefCnt == 0)
                {
                    FreeSurfaceObject(pSurf);
                }
                pSurf->fpVidMem = (ULONG_PTR) NULL;
            }
            pSurf = pSurf->pNext;
        }
    }

    return pDeviceHandle->bDeviceLost;
}

#undef DPF_MODNAME
#define DPF_MODNAME "GetDX7SurfaceHandle"

DWORD GetDX7SurfaceHandle (HANDLE hDD)
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;
    DWORD           handle = pDeviceHandle->SurfaceHandleList.dwFreeList;

    if (0==handle)
    {
        // need to grow the dwList
        LPDDSURFACELISTENTRY  newList;
        DWORD   newsize;
        DWORD   index;
        if (NULL != pDeviceHandle->SurfaceHandleList.dwList)
        {
            // old size(current dwFreeList) must not be zero
            DDASSERT(0 != pDeviceHandle->SurfaceHandleList.dwList[0].nextentry);
            // new dwFreeList is always gonna be the old dwList[0].nextentry
            newsize = pDeviceHandle->SurfaceHandleList.dwList[0].nextentry + LISTGROWSIZE;
            newList=(LPDDSURFACELISTENTRY)MemAlloc(newsize*sizeof(DDSURFACELISTENTRY));
            if (NULL == newList)
            {
                DPF_ERR("MemAlloc failure in GetSurfaceHandle(). Can't create new texture/surface/buffer.");
                return  0;
            }
            pDeviceHandle->SurfaceHandleList.dwFreeList =
                pDeviceHandle->SurfaceHandleList.dwList[0].nextentry;
            memcpy((LPVOID)newList,(LPVOID)pDeviceHandle->SurfaceHandleList.dwList,
                pDeviceHandle->SurfaceHandleList.dwList[0].nextentry*sizeof(DDSURFACELISTENTRY));
            MemFree(pDeviceHandle->SurfaceHandleList.dwList);
        }
        else
        {
            newsize = LISTGROWSIZE;
            newList=(LPDDSURFACELISTENTRY)MemAlloc(newsize*sizeof(DDSURFACELISTENTRY));
            if (NULL == newList)
            {
                DPF_ERR("MemAlloc failure in GetSurfaceHandle(). Can't create new texture/surface/buffer");
                return  0;
            }
            // start from one as we don't want 0 as a valid handle
            pDeviceHandle->SurfaceHandleList.dwFreeList = 1;
        }
        pDeviceHandle->SurfaceHandleList.dwList=newList;
        pDeviceHandle->SurfaceHandleList.dwList[0].nextentry=newsize;

        for (index = pDeviceHandle->SurfaceHandleList.dwFreeList;
            index < newsize - 1;
            index++)
        {
            newList[index].nextentry=index+1;
        }
        // indicate end of new FreeList
        newList[newsize-1].nextentry=0;
        // now pop up one and assign it to handle
        handle=pDeviceHandle->SurfaceHandleList.dwFreeList;
    }
    // handle slot is avialable so just remove it from freeList
    pDeviceHandle->SurfaceHandleList.dwFreeList =
    pDeviceHandle->SurfaceHandleList.dwList[handle].nextentry;
#if DBG
    pDeviceHandle->SurfaceHandleList.dwList[handle].nextentry=0xDEADBEEF;
#endif
    pDeviceHandle->SurfaceHandleList.dwList[handle].dwFlags=0;  //mark it's new
    pDeviceHandle->SurfaceHandleList.dwList[handle].lpSurface=NULL;
    DDASSERT (handle > 0);
    DDASSERT (handle < pDeviceHandle->SurfaceHandleList.dwList[0].nextentry);
    return handle;
}

/*****************************Private*Routine******************************\
* DdConvertToOldFormat
*
* History:
*  3-Nov-1999 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

#undef DPF_MODNAME
#define DPF_MODNAME "ConvertToOldFormat"

void ConvertToOldFormat(LPDDPIXELFORMAT pOldFormat, D3DFORMAT NewFormat)
{
    // Zero out the format to avoid missing
    // cases where it isn't initialized right
    ZeroMemory(pOldFormat, sizeof(*pOldFormat));

    // Set Size
    pOldFormat->dwSize = sizeof(DDPIXELFORMAT);

    // Convert away
    if (HIWORD((DWORD)NewFormat))
    {
        pOldFormat->dwFlags = DDPF_FOURCC;
        pOldFormat->dwFourCC = (DWORD)NewFormat;
        return;
    }

    switch (NewFormat)
    {
    case D3DFMT_R8G8B8:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x00ff0000;
        pOldFormat->dwGBitMask        = 0x0000ff00;
        pOldFormat->dwBBitMask        = 0x000000ff;
        pOldFormat->dwRGBBitCount     = 24;
        break;

    case D3DFMT_A8R8G8B8:
        pOldFormat->dwFlags           = DDPF_RGB | DDPF_ALPHAPIXELS;
        pOldFormat->dwRGBAlphaBitMask = 0xFF000000;
        pOldFormat->dwRBitMask        = 0x00ff0000;
        pOldFormat->dwGBitMask        = 0x0000ff00;
        pOldFormat->dwBBitMask        = 0x000000ff;
        pOldFormat->dwRGBBitCount     = 32;
        break;

    case D3DFMT_X8R8G8B8:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x00ff0000;
        pOldFormat->dwGBitMask        = 0x0000ff00;
        pOldFormat->dwBBitMask        = 0x000000ff;
        pOldFormat->dwRGBBitCount     = 32;
        break;

    case D3DFMT_R5G6B5:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x0000f800;
        pOldFormat->dwGBitMask        = 0x000007e0;
        pOldFormat->dwBBitMask        = 0x0000001f;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_X1R5G5B5:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x00007c00;
        pOldFormat->dwGBitMask        = 0x000003e0;
        pOldFormat->dwBBitMask        = 0x0000001f;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_A1R5G5B5:
        pOldFormat->dwFlags           = DDPF_RGB | DDPF_ALPHAPIXELS;
        pOldFormat->dwRGBAlphaBitMask = 0x00008000;
        pOldFormat->dwRBitMask        = 0x00007c00;
        pOldFormat->dwGBitMask        = 0x000003e0;
        pOldFormat->dwBBitMask        = 0x0000001f;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_A4R4G4B4:
        pOldFormat->dwFlags           = DDPF_RGB | DDPF_ALPHAPIXELS;
        pOldFormat->dwRGBAlphaBitMask = 0x0000f000;
        pOldFormat->dwRBitMask        = 0x00000f00;
        pOldFormat->dwGBitMask        = 0x000000f0;
        pOldFormat->dwBBitMask        = 0x0000000f;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_X4R4G4B4:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x00000f00;
        pOldFormat->dwGBitMask        = 0x000000f0;
        pOldFormat->dwBBitMask        = 0x0000000f;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_R3G3B2:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x000000e0;
        pOldFormat->dwGBitMask        = 0x0000001c;
        pOldFormat->dwBBitMask        = 0x00000003;
        pOldFormat->dwRGBBitCount     = 8;
        break;

    case D3DFMT_A8R3G3B2:
        pOldFormat->dwFlags           = DDPF_RGB | DDPF_ALPHAPIXELS;
        pOldFormat->dwRGBAlphaBitMask = 0x0000FF00;
        pOldFormat->dwRBitMask        = 0x000000e0;
        pOldFormat->dwGBitMask        = 0x0000001c;
        pOldFormat->dwBBitMask        = 0x00000003;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_A8P8:
        pOldFormat->dwFlags            = DDPF_RGB         |
                                         DDPF_ALPHAPIXELS |
                                         DDPF_PALETTEINDEXED8;

        pOldFormat->dwRGBAlphaBitMask  = 0x0000FF00;
        pOldFormat->dwRGBBitCount      = 16;
        break;

    case D3DFMT_P8:
        pOldFormat->dwFlags            = DDPF_RGB         |
                                         DDPF_PALETTEINDEXED8;
        pOldFormat->dwRGBBitCount      = 8;
        break;

    case D3DFMT_L8:
        pOldFormat->dwFlags             = DDPF_LUMINANCE;
        pOldFormat->dwLuminanceBitMask  = 0x000000FF;
        pOldFormat->dwLuminanceBitCount = 8;
        break;

    case D3DFMT_A8L8:
        pOldFormat->dwFlags                 = DDPF_LUMINANCE |
                                              DDPF_ALPHAPIXELS;
        pOldFormat->dwLuminanceAlphaBitMask = 0x0000FF00;
        pOldFormat->dwLuminanceBitMask      = 0x000000FF;
        pOldFormat->dwLuminanceBitCount     = 16;
        break;

    case D3DFMT_A4L4:
        pOldFormat->dwFlags                 = DDPF_LUMINANCE |
                                              DDPF_ALPHAPIXELS;
        pOldFormat->dwLuminanceAlphaBitMask = 0x000000F0;
        pOldFormat->dwLuminanceBitMask      = 0x0000000F;
        pOldFormat->dwLuminanceBitCount     = 8;
        break;

    case D3DFMT_V8U8:
        pOldFormat->dwFlags                = DDPF_BUMPDUDV;
        pOldFormat->dwBumpDvBitMask        = 0x0000FF00;
        pOldFormat->dwBumpDuBitMask        = 0x000000FF;
        pOldFormat->dwBumpBitCount         = 16;
        break;

    case D3DFMT_L6V5U5:
        pOldFormat->dwFlags                = DDPF_BUMPDUDV |
                                             DDPF_BUMPLUMINANCE;
        pOldFormat->dwBumpLuminanceBitMask = 0x0000FC00;
        pOldFormat->dwBumpDvBitMask        = 0x000003E0;
        pOldFormat->dwBumpDuBitMask        = 0x0000001F;
        pOldFormat->dwBumpBitCount         = 16;
        break;

    case D3DFMT_X8L8V8U8:
        pOldFormat->dwFlags                = DDPF_BUMPDUDV |
                                             DDPF_BUMPLUMINANCE;
        pOldFormat->dwBumpLuminanceBitMask = 0x00FF0000;
        pOldFormat->dwBumpDvBitMask        = 0x0000FF00;
        pOldFormat->dwBumpDuBitMask        = 0x000000FF;
        pOldFormat->dwBumpBitCount         = 32;
        break;

    case D3DFMT_A8:
        pOldFormat->dwFlags                = DDPF_ALPHA;
        pOldFormat->dwAlphaBitDepth        = 8;
        break;

    case D3DFMT_D16:
    case D3DFMT_D16_LOCKABLE:
        pOldFormat->dwFlags                = DDPF_ZBUFFER;
        pOldFormat->dwZBufferBitDepth      = 16;
        pOldFormat->dwZBitMask             = 0xFFFF;
        pOldFormat->dwStencilBitDepth      = 0;
        pOldFormat->dwStencilBitMask       = 0;
        break;

    case D3DFMT_D32:
        pOldFormat->dwFlags                = DDPF_ZBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0xFFFFFFFF;
        pOldFormat->dwStencilBitDepth      = 0;
        pOldFormat->dwStencilBitMask       = 0;
        break;

    case D3DFMT_D15S1:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;
        pOldFormat->dwZBufferBitDepth      = 16;
        pOldFormat->dwZBitMask             = 0xFFFE;
        pOldFormat->dwStencilBitDepth      = 1;
        pOldFormat->dwStencilBitMask       = 0x0001;
        break;
    case D3DFMT_D24S8:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0xFFFFFF00;
        pOldFormat->dwStencilBitDepth      = 8;
        pOldFormat->dwStencilBitMask       = 0xFF;
        break;
    case D3DFMT_S1D15:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;
        pOldFormat->dwZBufferBitDepth      = 16;
        pOldFormat->dwZBitMask             = 0x7FFF;
        pOldFormat->dwStencilBitDepth      = 1;
        pOldFormat->dwStencilBitMask       = 0x8000;
        break;
    case D3DFMT_S8D24:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0x00FFFFFF;
        pOldFormat->dwStencilBitDepth      = 8;
        pOldFormat->dwStencilBitMask       = 0xFF000000;
        break;
    case D3DFMT_X8D24:
        pOldFormat->dwFlags                = DDPF_ZBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0x00FFFFFF;
        pOldFormat->dwStencilBitDepth      = 0;
        pOldFormat->dwStencilBitMask       = 0x00000000;
        break;
    case D3DFMT_D24X8:
        pOldFormat->dwFlags                = DDPF_ZBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0xFFFFFF00;
        pOldFormat->dwStencilBitDepth      = 0;
        pOldFormat->dwStencilBitMask       = 0x00000000;
        break;
    case D3DFMT_D24X4S4:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0xFFFFFF00;
        pOldFormat->dwStencilBitDepth      = 4;
        pOldFormat->dwStencilBitMask       = 0x0000000F;
        break;
    case D3DFMT_X4S4D24:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0x00FFFFFF;
        pOldFormat->dwStencilBitDepth      = 4;
        pOldFormat->dwStencilBitMask       = 0x0F000000;
        break;

    default:
        // All other formats are treated as a
        // FOURCC
        pOldFormat->dwFlags = DDPF_FOURCC;
        pOldFormat->dwFourCC = (DWORD)NewFormat;
        break;
    }

    return;
}


/*****************************Private*Routine******************************\
* InitSurfaceStructures
*
* History:
*  06-Dec-1999 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

#undef DPF_MODNAME
#define DPF_MODNAME "InitSurfaceStructure"

void InitSurfaceStructures(
    PD3D8_CREATESURFACEDATA pCreateSurface,
    DD_SURFACE_LOCAL*       pDDSurfaceLocal,
    DD_SURFACE_GLOBAL*      pDDSurfaceGlobal,
    DD_SURFACE_MORE*        pDDSurfaceMore
   )
{
    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) pCreateSurface->hDD;
    DWORD   i;
    DWORD   j;
    DWORD   dwBit;

    for (i = 0; i < pCreateSurface->dwSCnt; i++)
    {
        // Make sure there's always a valid pixel format for the surface:
        if ((pCreateSurface->Format != D3DFMT_UNKNOWN) &&
            (pCreateSurface->Format != D3DFMT_VERTEXDATA) &&
            (pCreateSurface->Format != D3DFMT_INDEX16) &&
            (pCreateSurface->Format != D3DFMT_INDEX32))
        {
            pDDSurfaceLocal[i].dwFlags |= DDRAWISURF_HASPIXELFORMAT;

            // For non-textures, we want to promote X8R8G8B8 to A8R8G8B8 in some cases;
            // this allows things like RTs and Backbuffers to get created matching the
            // primary which is more consistent with typical DX7 usage.
            if (FormatCompatibleWithDisplayFormat(pDevice, (D3DFORMAT)pCreateSurface->Format) &&
                (pCreateSurface->Type == D3DRTYPE_SURFACE))
            {
                ConvertToOldFormat(&pDDSurfaceGlobal[i].ddpfSurface, pDevice->DisplayFormatWithAlpha);
            }
            else
            {
                ConvertToOldFormat(&pDDSurfaceGlobal[i].ddpfSurface, (D3DFORMAT)pCreateSurface->Format);
            }
        }

        // Setup width/height first
        pDDSurfaceGlobal[i].wWidth       = pCreateSurface->pSList[i].cpWidth;
        pDDSurfaceGlobal[i].wHeight      = pCreateSurface->pSList[i].cpHeight;

        //dwCaps3==1 means 1 sample per pixel.
        pDDSurfaceMore[i].ddsCapsEx.dwCaps3 = DDSCAPS3_MULTISAMPLE_MASK & (DWORD) pCreateSurface->MultiSampleType;

        if (pCreateSurface->dwUsage & D3DUSAGE_ALPHACHANNEL)
        {
            pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_ENABLEALPHACHANNEL;
        }

        switch (pCreateSurface->Type)
        {
        case D3DRTYPE_SURFACE:
            // Surfaces come in three general flavors:
            //  - Primary flip chains
            //  - Z buffers
            //  - OffscreenPlain (RenderTargets or just sys-mem stuff)
            //
            // Textures are a different resource type

            if (pCreateSurface->dwUsage & D3DUSAGE_PRIMARYSURFACE)
            {
                // If we aren't creating a primary flip chain, then we
                // don't have to do much here.
                
                if (pCreateSurface->dwSCnt == 1)
                {
                    pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_PRIMARYSURFACE;
                }
                else
                {
                    if (i == 0)
                    {
                        // This is the front buffer
                        pDDSurfaceLocal[i].ddsCaps.dwCaps |=
                            DDSCAPS_PRIMARYSURFACE |
                            DDSCAPS_VISIBLE |
                            DDSCAPS_FRONTBUFFER;
                    }
                    else
                    {
                        // This is a back buffer
                        pDDSurfaceLocal[i].ddsCaps.dwCaps |=
                            DDSCAPS_BACKBUFFER;
                    }

                    // All surfaces in the primary chain get these caps
                    pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_COMPLEX | DDSCAPS_FLIP | DDSCAPS_3DDEVICE;

                    // We also get a CreateEx handle for all surfaces in the
                    // chain, but not if we're running w/ a software driver.
                    if (((PDDDEVICEHANDLE)pCreateSurface->hDD)->pDD == NULL)
                    {
                        pDDSurfaceMore[i].dwSurfaceHandle = GetDX7SurfaceHandle(pCreateSurface->hDD);
                    }
                }
            }
            else if (pCreateSurface->dwUsage & D3DUSAGE_DEPTHSTENCIL)
            {
                DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );
                pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_ZBUFFER;
                pDDSurfaceMore[i].dwSurfaceHandle = GetDX7SurfaceHandle(pCreateSurface->hDD);
            }
            else
            {
                pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_OFFSCREENPLAIN;
            }
            break;
        case D3DRTYPE_VOLUME:
            // We don't create stand-alone volumes
            DDASSERT(FALSE);
            break;
        case D3DRTYPE_TEXTURE:
            DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_TEXTURE;

            //mipmaps are only DDI-level mipmaps if they're more than one level
            if (pCreateSurface->dwSCnt>1)
                pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_MIPMAP;

            if (i > 0)
            {
                // Mark non-top levels as being a sub-level
                pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_MIPMAPSUBLEVEL;
            }

            if (pCreateSurface->dwUsage & D3DUSAGE_DYNAMIC)
            {
                pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_HINTDYNAMIC;
            }

            pDDSurfaceMore[i].dwSurfaceHandle = GetDX7SurfaceHandle(pCreateSurface->hDD);
            break;
        case D3DRTYPE_VOLUMETEXTURE:
            DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_TEXTURE | DDSCAPS_MIPMAP;
            pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_VOLUME;
            pDDSurfaceMore[i].ddsCapsEx.dwCaps4 =
                MAKELONG((WORD)(pCreateSurface->pSList[i].cpDepth),0);

            if (i > 0)
            {
                // Mark non-top levels as being a sub-level
                pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_MIPMAPSUBLEVEL;
            }

            if (pCreateSurface->dwUsage & D3DUSAGE_DYNAMIC)
            {
                pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_HINTDYNAMIC;
            }

            pDDSurfaceMore[i].dwSurfaceHandle = GetDX7SurfaceHandle(pCreateSurface->hDD);
            break;
        case D3DRTYPE_CUBETEXTURE:
            DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_TEXTURE | DDSCAPS_COMPLEX;
            pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_CUBEMAP;
            pDDSurfaceMore[i].dwSurfaceHandle = GetDX7SurfaceHandle(pCreateSurface->hDD);

            //cubemaps are only DDI-level mipmaps if they're more than one level
            if (pCreateSurface->dwSCnt>6)
                pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_MIPMAP;

            // DX8 only supports creation of all faces
            {
                DWORD dwOrderedFaces[6] = {
                                           DDSCAPS2_CUBEMAP_POSITIVEX,
                                           DDSCAPS2_CUBEMAP_NEGATIVEX,
                                           DDSCAPS2_CUBEMAP_POSITIVEY,
                                           DDSCAPS2_CUBEMAP_NEGATIVEY,
                                           DDSCAPS2_CUBEMAP_POSITIVEZ,
                                           DDSCAPS2_CUBEMAP_NEGATIVEZ
                };

                int MipLevels;

                MipLevels = pCreateSurface->dwSCnt/6; //since all faces are always present in DX8

                DDASSERT(MipLevels>=1);

                //the first n (where n is mip depth) faces are +x, etc.
               pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= dwOrderedFaces[i/MipLevels];

                //every MipLevels'th surface is a top-level face,
                if (i % MipLevels)
                {
                    // Mark non-top levels as being a sub-level
                    pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_MIPMAPSUBLEVEL;
                }

                if (pCreateSurface->dwUsage & D3DUSAGE_DYNAMIC)
                {
                    pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_HINTDYNAMIC;
                }
            }

            break;
        case D3DRTYPE_IMAGESURFACE:
            DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );
            // Image surfaces are marked as textures since they have the
            // greatest flexibility for formats. But they don't get
            // a CreateSurfaceEx handle since they are never passed to
            // a driver.
            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_TEXTURE;
            break;

        case D3DRTYPE_COMMANDBUFFER:
            DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_EXECUTEBUFFER;
            pDDSurfaceMore[i].dwSurfaceHandle = GetDX7SurfaceHandle(pCreateSurface->hDD);
            DDASSERT((pCreateSurface->dwUsage & D3DUSAGE_INTERNALBUFFER) == 0);
            pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_COMMANDBUFFER;
            pDDSurfaceGlobal[i].dwLinearSize  = pDDSurfaceGlobal[i].wWidth;
            break;
        case D3DRTYPE_VERTEXBUFFER:
            DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_EXECUTEBUFFER;
            if (!(pCreateSurface->dwUsage & D3DUSAGE_INTERNALBUFFER))
            {
                pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_VERTEXBUFFER;
            }
            if (pDevice->DriverLevel >= 8)
            {
                if (pCreateSurface->dwUsage & D3DUSAGE_DYNAMIC)
                {
                    pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_HINTDYNAMIC;
                }
                else
                {
                    pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_HINTSTATIC;
                }
            }
            pDDSurfaceMore[i].dwSurfaceHandle = GetDX7SurfaceHandle(pCreateSurface->hDD);
            pDDSurfaceGlobal[i].dwLinearSize  = pDDSurfaceGlobal[i].wWidth;
            break;
        case D3DRTYPE_INDEXBUFFER:
            DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_EXECUTEBUFFER;
            pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_INDEXBUFFER;
            if (pDevice->DriverLevel >= 8)
            {
                if (pCreateSurface->dwUsage & D3DUSAGE_DYNAMIC)
                {
                    pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_HINTDYNAMIC;
                }
                else
                {
                    pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_HINTSTATIC;
                }
            }
            pDDSurfaceMore[i].dwSurfaceHandle = GetDX7SurfaceHandle(pCreateSurface->hDD);
            pDDSurfaceGlobal[i].dwLinearSize  = pDDSurfaceGlobal[i].wWidth;
            break;
        }

        if (pCreateSurface->dwUsage & D3DUSAGE_RENDERTARGET)
        {
            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_3DDEVICE;
            if (pDDSurfaceMore[i].dwSurfaceHandle == 0)
            {
                pDDSurfaceMore[i].dwSurfaceHandle = GetDX7SurfaceHandle(pCreateSurface->hDD);
            }
        }
        if (pCreateSurface->dwUsage & D3DUSAGE_DEPTHSTENCIL)
        {
            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_ZBUFFER;
        }
        if (pDevice->DriverLevel >= 8)
        {
            if (pCreateSurface->dwUsage & D3DUSAGE_LOADONCE)
            {
                pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_OPAQUE;
            }
            if (pCreateSurface->dwUsage & D3DUSAGE_WRITEONLY)
            {
                pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_WRITEONLY;
            }        
            if (!(pCreateSurface->dwUsage & D3DUSAGE_LOCK) &&
                !(pCreateSurface->dwUsage & D3DUSAGE_LOADONCE))
            {
                pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_NOTUSERLOCKABLE;
            }
            if (pCreateSurface->dwUsage & D3DUSAGE_DISCARD)
            {
                DDASSERT(pCreateSurface->Type != D3DRTYPE_TEXTURE);
                DDASSERT(pCreateSurface->Type != D3DRTYPE_CUBETEXTURE);
                DDASSERT(pCreateSurface->Type != D3DRTYPE_VOLUMETEXTURE);
                DDASSERT(pCreateSurface->Type != D3DRTYPE_VOLUME);
                DDASSERT(pCreateSurface->Type != D3DRTYPE_VERTEXBUFFER);
                DDASSERT(pCreateSurface->Type != D3DRTYPE_INDEXBUFFER);

                pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_DISCARDBACKBUFFER;
            }
            if (pCreateSurface->dwUsage & D3DUSAGE_POINTS)
            {
                pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_POINTS;
            }
            if (pCreateSurface->dwUsage & D3DUSAGE_RTPATCHES)
            {
                pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_RTPATCHES;
            }
            if (pCreateSurface->dwUsage & D3DUSAGE_NPATCHES)
            {
                pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_NPATCHES;
            }
        }
        else // Pre-DX8 driver
        {
            // We allow LOADONCE through only for textures
            if (pCreateSurface->Type == D3DRTYPE_TEXTURE || 
                pCreateSurface->Type == D3DRTYPE_CUBETEXTURE || 
                pCreateSurface->Type == D3DRTYPE_VOLUMETEXTURE)
            {
                if (pCreateSurface->dwUsage & D3DUSAGE_LOADONCE)
                {
                    pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_OPAQUE;
                }
            }
            // We allow WRITEONLY through only for VBs
            if (pCreateSurface->Type == D3DRTYPE_VERTEXBUFFER)
            {
                if (pCreateSurface->dwUsage & D3DUSAGE_WRITEONLY)
                {
                    pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_WRITEONLY;
                } 
            }
        }

        switch (pCreateSurface->Pool)
        {
        case D3DPOOL_LOCALVIDMEM:
            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM | DDSCAPS_VIDEOMEMORY;
            break;
        case D3DPOOL_NONLOCALVIDMEM:
            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_NONLOCALVIDMEM | DDSCAPS_VIDEOMEMORY;
            break;
        case D3DPOOL_SYSTEMMEM:
            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
            break;
        case D3DPOOL_MANAGED:
            pDDSurfaceLocal[i].dwFlags |= DDRAWISURF_DRIVERMANAGED;
            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
            pDDSurfaceMore[i].ddsCapsEx.dwCaps2 |= DDSCAPS2_TEXTUREMANAGE;
            break;
        case D3DPOOL_DEFAULT:
            pCreateSurface->Pool = D3DPOOL_LOCALVIDMEM; 
            pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
            break;
        default:
            /* Unknown Pool?? */
            DDASSERT(FALSE);
            break;
        }
    }
}

/*****************************Private*Routine******************************\
* SelectAttachmentSurface
*
* Returns an index into the surface creation list that indicates which
* surface this surface should be attached to. For mipmap sublevels this is
* always the preceding surface. For cubemaps, each face attaches to the
* root face (element 0).
*
* History:
*  21-Mar-2000 -by- Jeff Noyle [jeffno]
* Wrote it.
\**************************************************************************/

#undef DPF_MODNAME
#define DPF_MODNAME "SelectAttachmentSurface"

UINT SelectAttachmentSurface(
    PD3D8_CREATESURFACEDATA pCreateSurface,
    UINT                    iThis)
{

    //We should never be called to find the attachment from the root face.
    DDASSERT( iThis > 0);

    if ((pCreateSurface->Type == D3DRTYPE_CUBETEXTURE) &&
        ((iThis % (pCreateSurface->dwSCnt/6)) == 0) //which means we're looking at a top-level face
        )
    {
        //... so we attach this face to the root
        return 0;
    }
    else
    {
        // nope its just a mip sublevel, so we attach to the previous
        return iThis-1;
    }
}


/*****************************Private*Routine******************************\
* CreateVidMemSurface
*
* History:
*  06-Dec-1999 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "CreateVidMemSurface"


HRESULT
CreateVidMemSurface(
    PD3D8_CREATESURFACEDATA pCreateSurface,
    DD_SURFACE_LOCAL*       pDDSurfaceLocal,
    DD_SURFACE_GLOBAL*      pDDSurfaceGlobal,
    DD_SURFACE_MORE*        pDDSurfaceMore,
    HANDLE*                 phInSurface,
    HANDLE*                 phOutSurface,
    BOOL                    bIsLost
   )
{
    DDSURFACEDESC2          SurfaceDesc;
    DD_CREATESURFACEDATA    CreateData7;
    DWORD                   i;
    DWORD                   j;
    BOOL                    bRet;
    DDSURFHANDLE*           pSurf;
    DD_CANCREATESURFACEDATA CanCreateData;
    DEFERREDCREATE*         pDefCreate;

    if (DDSCAPS_EXECUTEBUFFER & pDDSurfaceLocal[0].ddsCaps.dwCaps)
    {
        if (!(DDDEVICE_SUPPORTD3DBUF & 
            ((PDDDEVICEHANDLE)pCreateSurface->hDD)->dwFlags)
           )
        {
            return  E_FAIL;
        }
    }
    // If the device is lost, we don't want to allocate vidmem or call the
    // kernel at this point (the surface will be released soon anyway).

    if (bIsLost)
    {
DeviceLost:
        DDASSERT(pCreateSurface->bReUse == FALSE);
        for (i = 0; i < pCreateSurface->dwSCnt; i++)
        {
            pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;
            pDDSurfaceMore[i].dwSurfaceHandle = 0;

            // There is a chance that the app may call Lock at some point,
            // in which case we have to allocate a buffer that they can write
            // to.  Allocating the buffer now is a bit wasteful, but if we
            // allocate it at Lock time the allocation may fail and I'm
            // guessing that apps will handle create surface failures better
            // than they will Lock failures, so we will do the allocation now.

            pDDSurfaceGlobal[i].lPitch = pCreateSurface->pSList[i].cpWidth * 8;
            pDDSurfaceGlobal[i].dwLinearSize =
                pDDSurfaceGlobal[i].lPitch;

            if ((pCreateSurface->Type == D3DRTYPE_VOLUME) ||
                (pCreateSurface->Type == D3DRTYPE_VOLUMETEXTURE))
            {
                pSurf->lSlicePitch = pDDSurfaceGlobal[i].lPitch *
                    pCreateSurface->pSList[i].cpHeight;

                pDDSurfaceGlobal[i].fpVidMem = (ULONG_PTR)
                    MemAlloc(pSurf->lSlicePitch *
                    pCreateSurface->pSList[i].cpDepth);
            }
            else
            {
                pDDSurfaceGlobal[i].fpVidMem = (ULONG_PTR)
                    MemAlloc(pDDSurfaceGlobal[i].lPitch *
                    pCreateSurface->pSList[i].cpHeight);
            }

            if (pDDSurfaceGlobal[i].fpVidMem == (ULONG_PTR) NULL)
            {
                for (j = 0; j < i; j++)
                {
                    MemFree((void*)pDDSurfaceGlobal[j].fpVidMem);
                }

                return E_OUTOFMEMORY;
            }
            pSurf->dwFlags |= DDSURF_SYSMEMALLOCATED;
        }

        // If the surface is driver managed, we save the creation info so that 
        // we can retry the creation at reset time
        if (pDDSurfaceLocal[0].dwFlags & DDRAWISURF_DRIVERMANAGED)
        {
            pDefCreate = (PDEFERREDCREATE)MemAlloc(sizeof(DEFERREDCREATE));
            if (pDefCreate == NULL)
            {
                // Cleanup stuff that we allocated above
                for (i = 0; i < pCreateSurface->dwSCnt; ++i)
                {
                    MemFree((void*)pDDSurfaceGlobal[i].fpVidMem);
                    pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;
                    pSurf->dwFlags &= ~DDSURF_SYSMEMALLOCATED;
                }
                return E_OUTOFMEMORY;
            }

            // Copy
            pDefCreate->CreateData = *pCreateSurface;

            pDefCreate->CreateData.pSList = (LPDDSURFACEINFO)MemAlloc(sizeof(DDSURFACEINFO) * pCreateSurface->dwSCnt);
            if (pDefCreate->CreateData.pSList == NULL)
            {
                // Cleanup stuff that we allocated above
                MemFree(pDefCreate);
                for (i = 0; i < pCreateSurface->dwSCnt; ++i)
                {
                    MemFree((void*)pDDSurfaceGlobal[i].fpVidMem);
                    pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;
                    pSurf->dwFlags &= ~DDSURF_SYSMEMALLOCATED;
                }
                return E_OUTOFMEMORY;
            }

            // Copy
            CopyMemory(pDefCreate->CreateData.pSList, pCreateSurface->pSList, sizeof(DDSURFACEINFO) * pCreateSurface->dwSCnt);

            // Linkup
            pDefCreate->pNext = ((PDDDEVICEHANDLE)pCreateSurface->hDD)->pDeferList;
            ((PDDDEVICEHANDLE)pCreateSurface->hDD)->pDeferList = pDefCreate;

            // We need to release the cookies allocated in InitSurfaceStructures
            // because this is not an actual create. When we do the actual create, we
            // will be reallocating the cookies.
            for (i = 0; i < pCreateSurface->dwSCnt; ++i)
            {
                pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;
                DDASSERT(pSurf->dwCookie != 0);
                ReleaseDX7SurfaceHandle(pSurf->pDevice, pSurf->dwCookie);
                pSurf->dwCookie = 0;
            }

            // *************************MEMORY LEAK WARNING*********************** //
            // The DEFERREDCREATE and DDSURFACEINFO allocations above will
            // not be cleaned up immediately if for some reason DdCreateSurface 
            // (ie the caller of this function) fails after this function returns
            // success. As of 3/2001, DdCreateSurface has no code path that can
            // fail after we return ok below.
            // ******************************************************************* //
        }

        return S_OK;
    }

    // First setup the surface desc

    RtlZeroMemory(&SurfaceDesc, sizeof(SurfaceDesc));
    SurfaceDesc.dwSize = sizeof(SurfaceDesc);
    SurfaceDesc.ddsCaps.dwCaps = pDDSurfaceLocal[0].ddsCaps.dwCaps;
    SurfaceDesc.ddsCaps.dwCaps2 = pDDSurfaceMore[0].ddsCapsEx.dwCaps2;
    SurfaceDesc.ddsCaps.dwCaps3 = pDDSurfaceMore[0].ddsCapsEx.dwCaps3;
    SurfaceDesc.ddsCaps.dwCaps4 = pDDSurfaceMore[0].ddsCapsEx.dwCaps4;
    SurfaceDesc.ddpfPixelFormat = pDDSurfaceGlobal[0].ddpfSurface;
    if ((pCreateSurface->Type == D3DRTYPE_TEXTURE) ||
        (pCreateSurface->Type == D3DRTYPE_VOLUMETEXTURE))
    {
        SurfaceDesc.dwMipMapCount = pCreateSurface->dwSCnt;
        if (SurfaceDesc.dwMipMapCount)
        {
            SurfaceDesc.dwFlags |= DDSD_MIPMAPCOUNT;
        }
    }
    else if (pCreateSurface->Type == D3DRTYPE_CUBETEXTURE)
    {
        if (pCreateSurface->dwSCnt > 6)
        {
            SurfaceDesc.dwMipMapCount = pCreateSurface->dwSCnt / 6;
            SurfaceDesc.dwFlags |= DDSD_MIPMAPCOUNT;
        }
    }
    else if (pCreateSurface->dwSCnt > 1)
    {
        SurfaceDesc.dwBackBufferCount = pCreateSurface->dwSCnt - 1;
        SurfaceDesc.dwFlags |= DDSD_BACKBUFFERCOUNT;
    }
    SurfaceDesc.dwHeight = pDDSurfaceGlobal[0].wHeight;
    SurfaceDesc.dwWidth = pDDSurfaceGlobal[0].wWidth;
    SurfaceDesc.dwFlags |= DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH;
    if (pDDSurfaceLocal[0].dwFlags & DDRAWISURF_HASPIXELFORMAT)
    {
        SurfaceDesc.dwFlags |= DDSD_PIXELFORMAT;
    }
    if (pCreateSurface->Type == D3DRTYPE_VERTEXBUFFER)
    {
        SurfaceDesc.dwFVF = pCreateSurface->dwFVF;
        SurfaceDesc.dwFlags |= DDSD_FVF;
    }
    if (SurfaceDesc.ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER)
    {
        SurfaceDesc.dwLinearSize = pCreateSurface->pSList[0].iPitch;
        SurfaceDesc.dwFlags |= DDSD_LINEARSIZE;
    }
    if (SurfaceDesc.ddsCaps.dwCaps2 & DDSCAPS2_VOLUME)
    {
        SurfaceDesc.dwDepth = pCreateSurface->pSList[0].cpDepth;
        SurfaceDesc.dwFlags |= DDSD_DEPTH;
    }

    if (SurfaceDesc.ddsCaps.dwCaps & DDSCAPS_ZBUFFER)
    {
        // ATI Rage3 driver in Win2K still expects dwZbufferBitDepth
        // in the old place in DDSD, so put it there but probably not
        // set the bit in dwFlags as we don't advocate it.
        ((DDSURFACEDESC*)&SurfaceDesc)->dwZBufferBitDepth =
            SurfaceDesc.ddpfPixelFormat.dwZBufferBitDepth;
    }

    // We do not support texture stage in DX8
    DDASSERT((SurfaceDesc.dwFlags & DDSD_TEXTURESTAGE) == 0);
    DDASSERT(SurfaceDesc.dwTextureStage == 0);

    // Now call CanCreateSurface since this is where most drivers do the
    // majority of their caps checking.

    RtlZeroMemory(&CanCreateData, sizeof(CanCreateData));
    CanCreateData.lpDDSurfaceDesc = (DDSURFACEDESC*) &SurfaceDesc;

    if (!FormatCompatibleWithDisplayFormat(((PDDDEVICEHANDLE)pCreateSurface->hDD), pCreateSurface->Format))
    {
        CanCreateData.bIsDifferentPixelFormat = TRUE;
    }
    else
    {
        CanCreateData.bIsDifferentPixelFormat = FALSE;
    }

    if (SurfaceDesc.ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER)
    {
        bRet = OsThunkDdCanCreateD3DBuffer(DDHANDLE(pCreateSurface->hDD),
                                    &CanCreateData);
    }
    else
    {
        bRet = OsThunkDdCanCreateSurface(DDHANDLE(pCreateSurface->hDD),
                                    &CanCreateData);
    }
    if ( bRet )
    {
        if (CanCreateData.ddRVal != S_OK)
        {
            if (CanCreateData.ddRVal == DDERR_SURFACELOST)
            {
                if (!pCreateSurface->bReUse)
                {
                    goto DeviceLost;
                }
            }
            return CanCreateData.ddRVal;
        }
    }
    /*
     * if the driver didn't handle it, then fail any requests to create a
     * surface that differs in format from the primary surface, except for
     * z buffer and alpha
     */

    else
    {
        // On Win2K, due to broken kernel, when the device is lost, the kernel
        // returns DDHAL_DRIVER_NOT_HANDLED and the return code is DDERR_GENERIC.
        // When we detect this, we check for device lost ourselves.
        if (CanCreateData.ddRVal == DDERR_GENERIC && 
            CheckForDeviceLost (pCreateSurface->hDD))
        {
            if (!pCreateSurface->bReUse)
            {
                goto DeviceLost;
            }
            return DDERR_SURFACELOST;
        }
        if (!FormatCompatibleWithDisplayFormat(((PDDDEVICEHANDLE)pCreateSurface->hDD), pCreateSurface->Format)
            && !(SurfaceDesc.ddsCaps.dwCaps & (DDSCAPS_ZBUFFER|DDSCAPS_ALPHA|DDSCAPS_EXECUTEBUFFER)) )
        {
	    return DDERR_INVALIDPIXELFORMAT;
	}
    }


    // Calculate the surface pitch.  The driver may override this, but if we
    // don't initialize it and the driver doesn't explicitly specify it, then
    // the kernel may fail the allocation.

    if (!(SurfaceDesc.ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER))
    {
        for (i = 0; i < pCreateSurface->dwSCnt; i++)
        {
            if (SurfaceDesc.ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
            {
                pDDSurfaceGlobal[i].lPitch = ((PDDDEVICEHANDLE)pCreateSurface->hDD)->DisplayPitch;
            }
            else if ((pDDSurfaceLocal[0].dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
                     (pDDSurfaceGlobal[0].ddpfSurface.dwRGBBitCount > 0))
            {
                pDDSurfaceGlobal[i].lPitch =
                    (pDDSurfaceGlobal[0].ddpfSurface.dwRGBBitCount / 8) *
                    pDDSurfaceGlobal[i].wWidth;

                // Assume that they need to be 8 byte aligned.

                pDDSurfaceGlobal[i].lPitch += 7;
                pDDSurfaceGlobal[i].lPitch &= 0xfffffff8;
            }
        }
    }

    // If the surface requires attachments, we need to set that up before the
    // CreateSurface call.

    if (pCreateSurface->dwSCnt > 1)
    {
        // First, create all of the surface objects

        for (i = 0; i < pCreateSurface->dwSCnt; i++)
        {
            phInSurface[i] = OsThunkDdCreateSurfaceObject(DDHANDLE(pCreateSurface->hDD),
                NULL,
                &pDDSurfaceLocal[i],
                &pDDSurfaceMore[i],
                &pDDSurfaceGlobal[i],
                FALSE);
            if (phInSurface[i] == NULL)
            {
                for (j = 0; j < i; j++)
                {
                    OsThunkDdDeleteSurfaceObject(phInSurface[j]);
                }
                // Looks like we are lost or something. Check it out.
                if (CheckForDeviceLost (pCreateSurface->hDD))
                {
                    if (!pCreateSurface->bReUse)
                    {
                        goto DeviceLost;
                    }
                    return DDERR_SURFACELOST;
                }
                return E_FAIL;
            }
        }

        // Now attach them all

        for (i = 1; i < pCreateSurface->dwSCnt; i++)
        {
            bRet = OsThunkDdAttachSurface(phInSurface[SelectAttachmentSurface(pCreateSurface,i)],
                                        phInSurface[i]);

            // smac:  handle error condition
        }

        // If it's the primary surface chain, I also need to attach the back
        // to the front (to avoid potential compatibility issues).

        if (pDDSurfaceLocal[0].ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
        {
            bRet = OsThunkDdAttachSurface(phInSurface[pCreateSurface->dwSCnt - 1],
                                        phInSurface[0]);
        }
    }

    // Preset an error in case the kernel can't write status
    // back for some reason.

    CreateData7.ddRVal = E_FAIL;
    CreateData7.dwSCnt = pCreateSurface->dwSCnt;

    if (SurfaceDesc.ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER)
    {
        bRet = OsThunkDdCreateD3DBuffer(DDHANDLE(pCreateSurface->hDD),
                           phInSurface,
                          (LPDDSURFACEDESC)&SurfaceDesc,
                          pDDSurfaceGlobal,
                          pDDSurfaceLocal,
                          pDDSurfaceMore,
                          (PDD_CREATESURFACEDATA) &CreateData7,
                          phOutSurface);
    }
    else
    {
        bRet = OsThunkDdCreateSurface(DDHANDLE(pCreateSurface->hDD),
                           phInSurface,
                          (LPDDSURFACEDESC)&SurfaceDesc,
                          pDDSurfaceGlobal,
                          pDDSurfaceLocal,
                          pDDSurfaceMore,
                          (PDD_CREATESURFACEDATA) &CreateData7,
                          phOutSurface);
    }

    if ( bRet && (CreateData7.ddRVal != S_OK))
    {
        if (pCreateSurface->dwSCnt > 1)
        {
            for (i = 0; i < pCreateSurface->dwSCnt; i++)
            {
                OsThunkDdDeleteSurfaceObject(phInSurface[i]);
            }
        }
        if (CreateData7.ddRVal == DDERR_SURFACELOST)
        {
            if (!pCreateSurface->bReUse)
            {
                goto DeviceLost;
            }
        }
        // Broken Win2K kernel fails with DDERR_OUTOFVIDEOMEMORY, so handle this case
        else if ((CreateData7.ddRVal == DDERR_OUTOFVIDEOMEMORY ||
                 CreateData7.ddRVal == DDERR_GENERIC) &&
                 CheckForDeviceLost (pCreateSurface->hDD))
        {
            if (!pCreateSurface->bReUse)
            {
                goto DeviceLost;
            }
            CreateData7.ddRVal = DDERR_SURFACELOST;
        }
        return CreateData7.ddRVal;
    }

    if (pDDSurfaceLocal[0].ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
    {
        pCreateSurface->Pool = D3DPOOL_NONLOCALVIDMEM;
        for (i = 0; i < pCreateSurface->dwSCnt; i++)
        {
            pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;
            pSurf->Pool = D3DPOOL_NONLOCALVIDMEM;
        }
    }

    for (i = 0; i < pCreateSurface->dwSCnt; i++)
    {
        pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;
        pSurf->hSurface = phOutSurface[i];
    }

    return CreateData7.ddRVal;
}

/*****************************Private*Routine******************************\
* CreateSysMemSurface
*
* History:
*  06-Dec-1999 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

#undef DPF_MODNAME
#define DPF_MODNAME "CreateSysMemSurface"

HRESULT
CreateSysMemSurface(
    PD3D8_CREATESURFACEDATA pCreateSurface,
    DD_SURFACE_LOCAL*       pDDSurfaceLocal,
    DD_SURFACE_GLOBAL*      pDDSurfaceGlobal,
    DD_SURFACE_MORE*        pDDSurfaceMore,
    BOOL                    bIsLost
   )
{
    DWORD           i;
    DWORD           j;
    HRESULT         hr;
    BOOL            bRet;
    DDSURFHANDLE*   pSurf;

    hr = S_OK;
    for (i = 0; i < pCreateSurface->dwSCnt; i++)
    {
        pDDSurfaceGlobal[i].fpVidMem = (ULONG_PTR)pCreateSurface->pSList[i].pbPixels;
        pDDSurfaceGlobal[i].lPitch = pCreateSurface->pSList[i].iPitch;
        if ((pCreateSurface->Type == D3DRTYPE_VOLUME) ||
            (pCreateSurface->Type == D3DRTYPE_VOLUMETEXTURE))
        {
            pDDSurfaceGlobal[i].dwBlockSizeY = pCreateSurface->pSList[i].iSlicePitch;
        }

        // Hack for NT; they don't support FourCC codes
        if (pDDSurfaceGlobal[i].ddpfSurface.dwFlags == DDPF_FOURCC)
        {
            if (pCreateSurface->Format == D3DFMT_UYVY ||
                pCreateSurface->Format == D3DFMT_YUY2)
            {
                pDDSurfaceGlobal[i].ddpfSurface.dwRGBBitCount = 16;
                // lie about pitch
                pDDSurfaceGlobal[i].lPitch = 
                    ((pDDSurfaceGlobal[i].wWidth*2 + 7) & ~7);
            }
            else if (pCreateSurface->Format == D3DFMT_DXT1 ||
                     pCreateSurface->Format == D3DFMT_DXT2 ||
                     pCreateSurface->Format == D3DFMT_DXT3 ||
                     pCreateSurface->Format == D3DFMT_DXT4 ||
                     pCreateSurface->Format == D3DFMT_DXT5)
            {
                DWORD blksize;
                DWORD realwidth  = pDDSurfaceGlobal[i].wWidth;
                DWORD realheight = pDDSurfaceGlobal[i].wHeight;
                WORD dx, dy;

                if (pCreateSurface->Format == D3DFMT_DXT1)
                {
                    blksize = 8;
                }
                else
                {
                    blksize = 16;
                }

                // HACK STOLEN FROM DX7 DDHEL
                // <kd> used the same logic as dx7 to avoid compat pain

                // The NT bug won't let us create this surface unless we lie.
                // We have to make up a width, height, pitch, and pixel size
                // that GDI will accept as valid.
                dx = (WORD)((realwidth  + 3) >> 2);   // number of 4x4 blocks in a row
                dy = (WORD)((realheight + 3) >> 2);   // number of 4x4 blocks in a column

                pDDSurfaceGlobal[i].wHeight = dy;                    // lie about height
                pDDSurfaceGlobal[i].lPitch = dx*blksize;             // lie about pitch
                pDDSurfaceGlobal[i].wWidth = (WORD)pDDSurfaceGlobal[i].lPitch;   // lie about width
                pDDSurfaceGlobal[i].ddpfSurface.dwRGBBitCount = 8;   // lie about pixel size
            }
        }

        // The presence of a software driver can make a sysmem surface act
        // like a vidmem surface, so we need to explicitly say that it's in sysmem

        pDDSurfaceLocal[i].ddsCaps.dwCaps &=
            ~(DDSCAPS_LOCALVIDMEM | DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM);
        pDDSurfaceLocal[i].ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;

        pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;
        pSurf->hSurface = OsThunkDdCreateSurfaceObject(DDHANDLE(pCreateSurface->hDD),
                NULL,
                &pDDSurfaceLocal[i],
                &pDDSurfaceMore[i],
                &pDDSurfaceGlobal[i],
                TRUE);

        if (pSurf->hSurface == NULL)
        {
            // Note that the main reason for this error is actually
            // out-of-memory; but it could also point at a bug
            // somewhere between the validation logic in kernel 
            // and the validation logic in our runtime,
            DPF_ERR("Kernel failed registration of sys-mem object; out of system-memory condition");
            hr = E_OUTOFMEMORY;
        }
    }

    // If we successfully created the handles, then we create any attachments
    // that we might require.

    if (SUCCEEDED(hr))
    {
        for (i = 1; i < pCreateSurface->dwSCnt; i++)
        {
            pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;
            bRet = OsThunkDdAttachSurface(
                ((PDDSURFHANDLE)pCreateSurface->pSList[
                        SelectAttachmentSurface(pCreateSurface,i)
                        ].hKernelHandle)->hSurface,
                    pSurf->hSurface);

            // smac:  handle error condition
        }
    }

    // If we're still OK, then we should call CreateSurfaceEx

    if (SUCCEEDED(hr))
    {
        if (pDDSurfaceMore[0].dwSurfaceHandle != 0)
        {
            // If using a software driver, we need to call CreateSurfaceEx
            // in the software driver; otherwsie, we call the kernel

            if (!IS_SOFTWARE_DRIVER(pCreateSurface->hDD))
            {
                if (bIsLost)
                {
                    // We set defer on the top level so CreateSurfaceEx gets called on Reset
                    pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[0].hKernelHandle;
                    pSurf->dwFlags |= DDSURF_DEFERCREATEEX;
                    return hr;
                }            
                hr = OsThunkDdCreateSurfaceEx(
                        DDHANDLE(pCreateSurface->hDD),
                        ((PDDSURFHANDLE)pCreateSurface->pSList[0].hKernelHandle)->hSurface,
                        pDDSurfaceMore[0].dwSurfaceHandle);
                if (FAILED(hr))
                {
                    if (hr == DDERR_SURFACELOST ||
                        CheckForDeviceLost (pCreateSurface->hDD)) // Due to broken Win2K implementation
                    {
                        // We set defer on the top level so CreateSurfaceEx gets called on Reset
                        pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[0].hKernelHandle;
                        pSurf->dwFlags |= DDSURF_DEFERCREATEEX;
                        return S_OK;
                    }
                }
            }
        }
    }

    return hr;
}

BOOL IsWhistler()
{
    OSVERSIONINFOEX osvi;
    DWORDLONG       dwlConditionMask = 0;

    ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osvi.dwMajorVersion = 5;
    osvi.dwMinorVersion = 1;

    VER_SET_CONDITION( dwlConditionMask, VER_MAJORVERSION, 
        VER_GREATER_EQUAL );
    VER_SET_CONDITION( dwlConditionMask, VER_MINORVERSION, 
        VER_GREATER_EQUAL );

    return VerifyVersionInfo(&osvi, 
                             VER_MAJORVERSION|VER_MINORVERSION,
                             dwlConditionMask);
}
// ResetUniqueness will cause runtime to think there is a device lost,
// have to do that only for whistler when fscreen app alt-tab away to
// desktop mode that is the same as the fullscreen, whistler 
void ResetUniqueness( HANDLE hDD )
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;
    if (pDeviceHandle->bIsWhistler)
        pDeviceHandle->DisplayUniqueness = 0;
}
/*****************************Private*Routine******************************\
* DdCreateSurface
*
* History:
*  2-Nov-1999 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

#undef DPF_MODNAME
#define DPF_MODNAME "DdCreateSurface"

HRESULT
APIENTRY
DdCreateSurface(
    PD3D8_CREATESURFACEDATA pCreateSurface
   )
{
    ULONG                       i;
    ULONG                       j;
    DDSURFACEDESC2              SurfaceDesc;
    HANDLE                      hInSurface;
    HANDLE                      hOutSurface;
    DD_SURFACE_LOCAL            SurfaceLocal;
    DD_SURFACE_GLOBAL           SurfaceGlobal;
    DD_SURFACE_MORE             SurfaceMore;
    DD_SURFACE_LOCAL*           pDDSurfaceLocal = NULL;
    DD_SURFACE_GLOBAL*          pDDSurfaceGlobal = NULL;
    DD_SURFACE_MORE*            pDDSurfaceMore = NULL;
    HANDLE*                     phInSurface = NULL;
    HANDLE*                     phOutSurface = NULL;
    HRESULT                     hr;
    BOOL                        bSysMemCreate = FALSE;
    PDDSURFHANDLE               pSurf;
    BOOL                        bIsLost = FALSE;
    DWORD                       dwNumToCreate;
    PDDDEVICEHANDLE             pDevice = (PDDDEVICEHANDLE) pCreateSurface->hDD;

    dwNumToCreate = pCreateSurface->dwSCnt;

    // If the device is lost, we don't want to actually allocate vidmem, but
    // we still need to support sysmem surfaces.  We also have to fake up
    // vidmem allocations since we only want to expose lost devices in a
    // couple of places.

    if (CheckForDeviceLost (pCreateSurface->hDD))
    {
        bIsLost = TRUE;
        if (pCreateSurface->bReUse)
        {
            return DDERR_SURFACELOST;
        }
    }

    // For every surface, convert to the kernel's surface data structure,
    // call the kernel, then convert back:

    hr = S_OK;

    // If we are only creating one, no need to allocate gobs of memory; otherwise, do it
    if (dwNumToCreate == 1)
    {
        RtlZeroMemory(&SurfaceLocal, sizeof(SurfaceLocal));
        RtlZeroMemory(&SurfaceGlobal, sizeof(SurfaceGlobal));
        RtlZeroMemory(&SurfaceMore, sizeof(SurfaceMore));
        hInSurface = NULL;
        hOutSurface = NULL;
        pDDSurfaceLocal  = &SurfaceLocal;
        pDDSurfaceGlobal  = &SurfaceGlobal;
        pDDSurfaceMore  = &SurfaceMore;
        phInSurface = &hInSurface;
        phOutSurface = &hOutSurface;
    }
    else
    {
        pDDSurfaceLocal = (DD_SURFACE_LOCAL*) MemAlloc(
            sizeof(DD_SURFACE_LOCAL) * dwNumToCreate);

        pDDSurfaceGlobal = (DD_SURFACE_GLOBAL*) MemAlloc(
            sizeof(DD_SURFACE_GLOBAL) * dwNumToCreate);

        pDDSurfaceMore = (DD_SURFACE_MORE*) MemAlloc(
            sizeof(DD_SURFACE_MORE) * dwNumToCreate);

        phInSurface = (HANDLE*) MemAlloc(sizeof(HANDLE) * dwNumToCreate);

        phOutSurface = (HANDLE*) MemAlloc(
            sizeof(HANDLE) * dwNumToCreate);

        if ((pDDSurfaceLocal == NULL) ||
            (pDDSurfaceGlobal == NULL) ||
            (pDDSurfaceMore == NULL) ||
            (phInSurface == NULL) ||
            (phOutSurface == NULL))
        {
            hr = E_OUTOFMEMORY;
            goto CleanupCreate;
        }
    }

    InitSurfaceStructures (pCreateSurface,
        pDDSurfaceLocal,
        pDDSurfaceGlobal,
        pDDSurfaceMore);

    // Allocate the internal surface structures for each surface in the chain
    // and initialize it if we are not reusing the surface
    if (!pCreateSurface->bReUse)
    {
        for (i = 0; i < dwNumToCreate; i++)
        {
            pSurf = (PDDSURFHANDLE) MemAlloc(sizeof(DDSURFHANDLE));
            if (pSurf == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto CleanupCreate;
            }
            pSurf->Pool = pCreateSurface->Pool;
            pSurf->Format = pCreateSurface->Format;
            pSurf->Type = pCreateSurface->Type;

            // This is sort of a hack to save space.  For regular surfaces, we need
            // to know the height to handle the lost case, but for volume textures,
            // we really need to know the depth.  To save space, we will re-use the
            // same variable.

            if ((pSurf->Type == D3DRTYPE_VOLUME) ||
                (pSurf->Type == D3DRTYPE_VOLUMETEXTURE))
            {
                pSurf->dwHeight = pCreateSurface->pSList[i].cpDepth;
            }
            else
            {
                pSurf->dwHeight = pCreateSurface->pSList[i].cpHeight;
            }
            pCreateSurface->pSList[i].hKernelHandle = (HANDLE) pSurf;
            pSurf->pDevice = (PDDDEVICEHANDLE) pCreateSurface->hDD;

            // You may find it wasteful that we assign handles to each mipmap level,
            // even though we only call CreateSurfaceEx on the topmost level.  We need
            // to do this, however, since DX7 worked this way and it also call
            // CreateSurfaceEx fpVidMem = 0 at release time on each level of the mipmap.

            pSurf->dwCookie = pDDSurfaceMore[i].dwSurfaceHandle;

            // Now figure out if this is a sysmem surface, a software driver
            // surface, or a HAL surface.

            if (pSurf->Pool != D3DPOOL_SYSTEMMEM)
            {
                // If they are running w/ a software driver (refrast, RGB HEL, etc.),
                // we will not allow any surfaces to be created in video memory except
                // for the primary flipping chain. And also for surfaces marked
                // USAGE_OFFSCREENPLAIN (which are used for the cursors)

                if (IS_SOFTWARE_DRIVER(pCreateSurface->hDD) &&
                    !(pCreateSurface->dwUsage & D3DUSAGE_PRIMARYSURFACE) &&
                    !(pCreateSurface->dwUsage & D3DUSAGE_OFFSCREENPLAIN))
                {
                    pSurf->dwFlags |= DDSURF_SOFTWARE;
                }
                else
                {
                    pSurf->dwFlags |= DDSURF_HAL;
                }
            }

            if (pCreateSurface->bTreatAsVidMem == TRUE)
            {
                // For objects that should be treated as non-persistent
                // i.e. Reset fails unless these are all freed; we
                // set a flag here and check it in DoVidMemSurfacesExist()
                pSurf->dwFlags |= DDSURF_TREATASVIDMEM;
            }

            // If a software driver will see this surface (either because it
            // will create it, or because it's a sysmem surface that will need
            // to handle CreateEx), we need to build a heavyweight surface structure.

            if (IS_SOFTWARE_DRIVER(pCreateSurface->hDD))
            {
                if (!(pSurf->dwFlags & DDSURF_HAL) &&
                    (pSurf->dwCookie != 0))
                {
                    pSurf->pLcl = SwDDIBuildHeavyWeightSurface(
                                    pSurf->pDevice->pDD,
                                    pCreateSurface,
                                    &pDDSurfaceLocal[i],
                                    &pDDSurfaceGlobal[i],
                                    &pDDSurfaceMore[i],
                                    i);
                    if (pSurf->pLcl == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                        goto CleanupCreate;
                    }
                }
            }
        }
    }
    else // fill in the new cookie
    {
        for (i = 0; i < dwNumToCreate; i++)
        {
            pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;
            DDASSERT(pSurf->dwCookie == 0);
            pSurf->dwCookie = pDDSurfaceMore[i].dwSurfaceHandle;
        }
    }

    // Now create the actual surfaces

    pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[0].hKernelHandle;
    if (pSurf->Pool == D3DPOOL_SYSTEMMEM)
    {
        hr = CreateSysMemSurface(
                pCreateSurface,
                pDDSurfaceLocal,
                pDDSurfaceGlobal,
                pDDSurfaceMore,
                bIsLost);
    }
    else if (pSurf->dwFlags & DDSURF_SOFTWARE)
    {
        // Call the software rasterizer if it can handle it.
        // This allows them to allocate the memory, etc., but
        // we still need to call the kernel to create an object

        hr = SwDDICreateSurface(pCreateSurface,
                                pDDSurfaceLocal,
                                pDDSurfaceGlobal,
                                pDDSurfaceMore);

        // We only need to get a kernel-handle
        // for back-buffers
        
        if (SUCCEEDED(hr) && (pCreateSurface->dwUsage & D3DUSAGE_BACKBUFFER))
        {
            hr = CreateSysMemSurface(pCreateSurface,
                                     pDDSurfaceLocal,
                                     pDDSurfaceGlobal,
                                     pDDSurfaceMore,
                                     bIsLost);

            if (FAILED(hr))
            {
                // we need to mark all the surfaces
                // as completely built so that
                // we free them correctly
                for (i = 0; i < dwNumToCreate; i++)
                {
                    pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;

                    pSurf->dwFlags |= DDSURF_CREATECOMPLETE;
                }
            }
        }
    }
    else
    {
        hr = CreateVidMemSurface (pCreateSurface,
                                  pDDSurfaceLocal,
                                  pDDSurfaceGlobal,
                                  pDDSurfaceMore,
                                  phInSurface,
                                  phOutSurface,
                                  bIsLost);
    }
    if (FAILED(hr))
    {
        goto CleanupCreate;
    }

    // Everything worked so far, so now we just need to finish up.

    for(i = 0; i < dwNumToCreate; i++)
    {
        pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;

        pSurf->dwFlags |= DDSURF_CREATECOMPLETE;
        if (!(pSurf->dwFlags & DDSURF_HAL))
        {
            // It's a sysmem surface - either explicit or a software driver
            pSurf->fpVidMem = (ULONG_PTR)pCreateSurface->pSList[i].pbPixels;
            pSurf->dwLinearSize = pCreateSurface->pSList[i].iPitch;
            pSurf->lPitch = pCreateSurface->pSList[i].iPitch;
            pSurf->lSlicePitch = pCreateSurface->pSList[i].iSlicePitch;
        }
        else
        {
            pSurf->fpVidMem = (ULONG_PTR)pDDSurfaceGlobal[i].fpVidMem;
            pSurf->dwLinearSize = pDDSurfaceGlobal[i].dwLinearSize;
            pCreateSurface->pSList[i].iPitch = pSurf->dwLinearSize;
            pSurf->lPitch = pDDSurfaceGlobal[i].lPitch;
            if ((pSurf->Type == D3DRTYPE_VOLUME) ||
                (pSurf->Type == D3DRTYPE_VOLUMETEXTURE))
            {
                pSurf->lSlicePitch = pDDSurfaceGlobal[i].dwBlockSizeY;
            }
            else
            {
                pSurf->lSlicePitch = 0;
            }
        }

        // If it's a software driver, we may need to attach surfaces

        if ((0==(pSurf->dwFlags & DDSURF_HAL)) &&
            (IS_SOFTWARE_DRIVER(pCreateSurface->hDD)) &&
            (i > 0))
        {
            // Cubes are created strangely... Each face is attached to the root,
            // and each mipsublevel is attached to its face

            DDASSERT(pCreateSurface->Type != D3DRTYPE_CUBETEXTURE || pCreateSurface->dwSCnt>=6);

            SwDDIAttachSurfaces (
                    ((PDDSURFHANDLE)pCreateSurface->pSList[
                            SelectAttachmentSurface(pCreateSurface,i)
                        ].hKernelHandle)->pLcl,
                    pSurf->pLcl);
        }
    }

    // If it's a software driver, we need to call CreateSurfaceEx after
    // all of the attachments are made.

    if ((IS_SOFTWARE_DRIVER(pCreateSurface->hDD)) &&
        (pSurf->dwCookie != 0))
    {
        SwDDICreateSurfaceEx (pDevice->pDD,
            ((PDDSURFHANDLE)pCreateSurface->pSList[0].hKernelHandle)->pLcl);
    }

    // Now save the surfaces in a linked list
    // If re-using, then we are already on the list so don't do anything
    if (!pCreateSurface->bReUse)
    {
        for (i = 0; i < dwNumToCreate; i++)
        {
            ((PDDSURFHANDLE)(pCreateSurface->pSList[i].hKernelHandle))->pNext =
                pDevice->pSurfList;
            ((PDDSURFHANDLE)(pCreateSurface->pSList[i].hKernelHandle))->pPrevious =
                NULL;
            if (pDevice->pSurfList != NULL)
            {
                pDevice->pSurfList->pPrevious = (PDDSURFHANDLE)(pCreateSurface->pSList[i].hKernelHandle);
            }
            pDevice->pSurfList = (PDDSURFHANDLE)(pCreateSurface->pSList[i].hKernelHandle);
        }
    }

    CleanupCreate:
    if (1 != dwNumToCreate)
    {
        if (pDDSurfaceLocal != NULL)
        {
            MemFree(pDDSurfaceLocal);
        }
        if (pDDSurfaceGlobal != NULL)
        {
            MemFree(pDDSurfaceGlobal);
        }
        if (pDDSurfaceMore != NULL)
        {
            MemFree(pDDSurfaceMore);
        }
        if (phInSurface != NULL)
        {
            MemFree(phInSurface);
        }
        if (phOutSurface != NULL)
        {
            MemFree(phOutSurface);
        }
    }

    if (FAILED(hr))
    {
        // Clean everything up

        for (i = 0; i < dwNumToCreate; i++)
        {
            pSurf = (PDDSURFHANDLE) pCreateSurface->pSList[i].hKernelHandle;
            if (pSurf != NULL)
            {
                FreeSurfaceObject(pSurf);
                // If we are reusing, then we need to keep the pSurf around
                // for a retry
                if (!pCreateSurface->bReUse)
                {
                    MemFree(pSurf);
                }
            }
            pCreateSurface->pSList[i].hKernelHandle   = NULL;
        }
    }

    return(MapLegacyResult(hr));
}


/******************************Public*Routine******************************\
*
* D3dContextCreate
*
* History:
*  Mon Jun 03 14:18:29 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "D3dContextCreate"

DWORD WINAPI 
D3dContextCreate(PD3D8_CONTEXTCREATEDATA pCreateContext)
{
    PD3DCONTEXTHANDLE   pContext = NULL;
    BOOL                bIsLost = FALSE;
    DWORD               dwRet = DDHAL_DRIVER_HANDLED;

    // Don't call the driver if the device is lost

    pCreateContext->ddrval = S_OK;
    if (!CheckForDeviceLost (pCreateContext->hDD))
    {
        dwRet = OsThunkD3dContextCreate(DDHANDLE(pCreateContext->hDD),
            GetSurfHandle(pCreateContext->hSurface),
            GetSurfHandle(pCreateContext->hDDSZ),
            (D3DNTHAL_CONTEXTCREATEI *)pCreateContext);
        if (pCreateContext->ddrval == DDERR_SURFACELOST)
        {
            bIsLost = TRUE;
            pCreateContext->ddrval = S_OK;
            CheckForDeviceLost (pCreateContext->hDD);
        }
    }
    else
    {
        bIsLost = TRUE;
    }

    // We need to abstract the handle for a couple of reasons:
    // 1.  The context handle can change due to lost devices, and
    //     we'd prefer to abstract this from D3D.
    // 2.  We need to know the device that this handle belongs to
    //     so we can always check for device lost.

    if (pCreateContext->ddrval == S_OK)
    {
        pContext = (PD3DCONTEXTHANDLE) MemAlloc(sizeof(D3DCONTEXTHANDLE));
        if (pContext == NULL)
        {
            // smac: clean up

            pCreateContext->dwhContext = (ULONG_PTR) NULL;
            pCreateContext->ddrval = E_OUTOFMEMORY;
        }
        else
        {
            pContext->pDevice = pCreateContext->hDD;
            if (bIsLost)
            {
                pContext->dwFlags = D3DCONTEXT_DEFERCREATE;
                pContext->dwPID = pCreateContext->dwPID;
                pContext->hDeferHandle = (HANDLE)pCreateContext->dwhContext;
                pContext->pSurface = pCreateContext->hSurface;
                pContext->pDDSZ = pCreateContext->hDDSZ;
            }
            else
            {
                pContext->dwhContext = (HANDLE) pCreateContext->dwhContext;
            }
            pCreateContext->dwhContext = (ULONG_PTR) pContext;
        }
    }

    pCreateContext->ddrval = MapLegacyResult(pCreateContext->ddrval);

    return dwRet;
}

/******************************Public*Routine******************************\
*
* D3dContextDestroy
*
* History:
*  Mon Jun 03 14:18:29 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "D3dContextDestroy"

DWORD WINAPI 
D3dContextDestroy(PD3D8_CONTEXTDESTROYDATA pDestroyContext)
{
    PD3DCONTEXTHANDLE pContext = (PD3DCONTEXTHANDLE) pDestroyContext->dwhContext;

    CheckForDeviceLost (pContext->pDevice);

    pDestroyContext->ddrval = S_OK;
    if (pContext->dwhContext)
    {
        pDestroyContext->dwhContext = (LONG_PTR) pContext->dwhContext;
        OsThunkD3dContextDestroy((LPD3DNTHAL_CONTEXTDESTROYDATA) pDestroyContext);
    }

    pContext->pDevice->pContext = NULL;
    MemFree(pContext);

    pDestroyContext->ddrval = MapLegacyResult(pDestroyContext->ddrval);

    return DDHAL_DRIVER_HANDLED;
}

/******************************Public*Routine******************************\
*
* D3dContextDestroyAll
*
* History:
*  Mon Jun 03 14:18:29 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "D3dContextDestroyAll"

DWORD WINAPI 
D3dContextDestroyAll(PD3D8_CONTEXTDESTROYALLDATA pDestroyAllContext)
{
    OsThunkD3dContextDestroyAll((LPD3DNTHAL_CONTEXTDESTROYALLDATA) pDestroyAllContext);

    // smac:  Need to add code here to free all contexts for each device
    // the PID has?

    return DDHAL_DRIVER_HANDLED;
}

/******************************Public*Routine******************************\
*
* DdGetDriverState
*
* History:
*  Mon Jun 03 14:18:29 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "DdGetDriverState"

DWORD WINAPI DdGetDriverState(PD3D8_GETDRIVERSTATEDATA pGetDriverState)
{
    PD3DCONTEXTHANDLE pContext = (PD3DCONTEXTHANDLE) pGetDriverState->dwhContext;
    DWORD       dwRet = DDHAL_DRIVER_HANDLED;
    ULONG_PTR   pTemp;

    pGetDriverState->ddRVal = E_FAIL;
    if (!CheckForDeviceLost (pContext->pDevice))
    {
        pTemp = pGetDriverState->dwhContext;
        pGetDriverState->dwhContext = (ULONG_PTR) pContext->dwhContext;
        dwRet = OsThunkDdGetDriverState ((DD_GETDRIVERSTATEDATA*)pGetDriverState);
        pGetDriverState->dwhContext = pTemp;
        if (pGetDriverState->ddRVal == DDERR_SURFACELOST)
        {
            pGetDriverState->ddRVal = E_FAIL;
        }
    }

    pGetDriverState->ddRVal = MapLegacyResult(pGetDriverState->ddRVal);

    return dwRet;
}

/******************************Public*Routine******************************\
*
* D3dValidateTextureStageState
*
* History:
*  Mon Jun 03 14:18:29 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "D3dValidateTextureStageState"

DWORD WINAPI D3dValidateTextureStageState(PD3D8_VALIDATETEXTURESTAGESTATEDATA pValidate)
{
    PD3DCONTEXTHANDLE pContext = (PD3DCONTEXTHANDLE) pValidate->dwhContext;
    DWORD       dwRet = DDHAL_DRIVER_HANDLED;
    ULONG_PTR   pTemp;

    pValidate->ddrval = D3DERR_DEVICELOST;
    pValidate->dwNumPasses = 0;
    if (!CheckForDeviceLost (pContext->pDevice))
    {
        pTemp = pValidate->dwhContext;
        pValidate->dwhContext = (ULONG_PTR) pContext->dwhContext;
        dwRet = OsThunkD3dValidateTextureStageState((D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA*)pValidate);
        pValidate->dwhContext = pTemp;
        if (pValidate->ddrval == DDERR_SURFACELOST)
        {
            pValidate->ddrval = D3DERR_DEVICELOST;
        }
    }

    return dwRet;
}

/******************************Public*Routine******************************\
*
* D3dDrawPrimitives2
*
* History:
*  Mon Jun 17 13:27:05 1996     -by-    Anantha Kancherla [anankan]
*   Created
*
\**************************************************************************/

#undef DPF_MODNAME
#define DPF_MODNAME "D3dDrawPrimitives2"

DWORD WINAPI D3dDrawPrimitives2(PD3D8_DRAWPRIMITIVES2DATA pdp2data)
{
    PD3DCONTEXTHANDLE pContext = (PD3DCONTEXTHANDLE) pdp2data->dwhContext;
    DWORD       dwRet = DDHAL_DRIVER_HANDLED;
    ULONG_PTR   pTemp;

    if (CheckForDeviceLost (pContext->pDevice))
    {
        goto DeviceLost;
    }

    pTemp = pdp2data->dwhContext;
    pdp2data->dwhContext = (ULONG_PTR) pContext->dwhContext;

    if (pdp2data->dwFlags & D3DHALDP2_USERMEMVERTICES)
    {
        dwRet = OsThunkD3dDrawPrimitives2 (
            GetSurfHandle(pdp2data->hDDCommands),
            NULL, // No DDraw surface, pass NULL handle
            (LPD3DNTHAL_DRAWPRIMITIVES2DATA)pdp2data,
            &((PDDSURFHANDLE)(pdp2data->hDDCommands))->fpVidMem,
            &((PDDSURFHANDLE)(pdp2data->hDDCommands))->dwLinearSize,
            NULL,
            NULL
           );
        if (dwRet == DDHAL_DRIVER_HANDLED)
        {
            if (pdp2data->ddrval == DDERR_SURFACELOST)
            {
                pdp2data->dwhContext = pTemp;
                goto DeviceLost;
            }
            else if ((pdp2data->ddrval != S_OK) && 
                (DDERR_WASSTILLDRAWING != pdp2data->ddrval) )
            {
                pContext->pDevice->dwFlags |= DDDEVICE_DP2ERROR;
            }
        }
        pdp2data->fpVidMem_CB = ((PDDSURFHANDLE)(pdp2data->hDDCommands))->fpVidMem;
        pdp2data->dwLinearSize_CB = ((PDDSURFHANDLE)(pdp2data->hDDCommands))->dwLinearSize;
        pdp2data->fpVidMem_VB = 0;
        pdp2data->dwLinearSize_VB = 0;
    }
    else
    {
        dwRet = OsThunkD3dDrawPrimitives2 (
            GetSurfHandle(pdp2data->hDDCommands),
            GetSurfHandle(pdp2data->hDDVertex),
            (LPD3DNTHAL_DRAWPRIMITIVES2DATA)pdp2data,
            &((PDDSURFHANDLE)(pdp2data->hDDCommands))->fpVidMem,
            &((PDDSURFHANDLE)(pdp2data->hDDCommands))->dwLinearSize,
            &((PDDSURFHANDLE)(pdp2data->hDDVertex))->fpVidMem,
            &((PDDSURFHANDLE)(pdp2data->hDDVertex))->dwLinearSize
            );
        if (dwRet == DDHAL_DRIVER_HANDLED)
        {
            if (pdp2data->ddrval == DDERR_SURFACELOST)
            {
                pdp2data->dwhContext = pTemp;
                goto DeviceLost;
            }
            else if ((pdp2data->ddrval != S_OK) &&
                (DDERR_WASSTILLDRAWING != pdp2data->ddrval) )
            {
                pContext->pDevice->dwFlags |= DDDEVICE_DP2ERROR;
            }
        }

        pdp2data->fpVidMem_CB = ((PDDSURFHANDLE)(pdp2data->hDDCommands))->fpVidMem;
        pdp2data->dwLinearSize_CB = ((PDDSURFHANDLE)(pdp2data->hDDCommands))->dwLinearSize;
        pdp2data->fpVidMem_VB = ((PDDSURFHANDLE)(pdp2data->hDDVertex))->fpVidMem;
        pdp2data->dwLinearSize_VB = ((PDDSURFHANDLE)(pdp2data->hDDVertex))->dwLinearSize;
    }
    pdp2data->dwhContext = pTemp;

    return dwRet;

DeviceLost:
    pdp2data->ddrval = S_OK;
    pdp2data->dwErrorOffset = 0;

    // Need to set these values to their original
    // state so that the FE doesn't get confused.
    pdp2data->fpVidMem_CB = ((PDDSURFHANDLE)(pdp2data->hDDCommands))->fpVidMem;
    pdp2data->dwLinearSize_CB = ((PDDSURFHANDLE)(pdp2data->hDDCommands))->dwLinearSize;
    if (pdp2data->dwFlags & D3DHALDP2_USERMEMVERTICES)
    {
        pdp2data->fpVidMem_VB       = 0;
        pdp2data->dwLinearSize_VB   = 0;
    }
    else
    {
        pdp2data->fpVidMem_VB = ((PDDSURFHANDLE)(pdp2data->hDDVertex))->fpVidMem;
        pdp2data->dwLinearSize_VB = ((PDDSURFHANDLE)(pdp2data->hDDVertex))->dwLinearSize;
    }

    // Don't map the legacy result because the runtime needs to handle the
    // WASSTILLDRAWING case.  The runtime will do this mapping for us.

    return DDHAL_DRIVER_HANDLED;
}

LPRGNDATA GetClipList(HWND hWnd)
{
    int APIENTRY GetRandomRgn(HDC hdc, HRGN hrgn, int iNum);
    int rc;
    HRESULT         ddrval = S_OK;
    DWORD           dwSize;
    DWORD           cbRealSize;
    HDC             hdc;
    HRGN            hrgn;
    LPRGNDATA       lpClipList;

    hdc = GetDC(hWnd);
    if (hdc == NULL)
    {
        DPF_ERR("GetDC failed. Unable to accelerate Present.");
        return NULL;
    }

    // Create the appropriate Region object
    hrgn = CreateRectRgn(0, 0, 0, 0);
    if (hrgn == NULL)
    {
        DPF_ERR("CreateRectRgn failed. Unable to accelerate Present.");
        ReleaseDC(hWnd, hdc);
        return NULL;
    }

    // Set the Region to the DC
    if (-1 == GetRandomRgn(hdc, hrgn, 4))
    {
        DPF_ERR("GetRandomRgn failed. Unable to accelerate Present.");
        ReleaseDC(hWnd, hdc);
        DeleteObject(hrgn);
        return NULL;
    }

    // Get the size
    dwSize = GetRegionData(hrgn, 0, NULL);

    if (0 == dwSize)
    {
        // Release allocations
        ReleaseDC(hWnd, hdc);
        DeleteObject(hrgn);
        return NULL;
    }
    do
    {
        lpClipList = (LPRGNDATA)MemAlloc(dwSize);
        if (NULL == lpClipList)
        {
            // Release allocations
            ReleaseDC(hWnd, hdc);
            DeleteObject(hrgn);
            return NULL;
        }
        // Get the window's region's REGIONDATA
        cbRealSize = GetRegionData(hrgn, dwSize, lpClipList);
        if (cbRealSize > dwSize)
        {
            MemFree(lpClipList);
            dwSize =  cbRealSize;   // make it bigger and try again
        }
        else
        {
            break;  // succeeded
        }
    }while(TRUE);

    ReleaseDC(hWnd, hdc);
    DeleteObject(hrgn);

    if (cbRealSize == 0)
    {
        DPF_ERR("GetRegionData failed. Unable to accelerate Present.");
        MemFree(lpClipList);
        return NULL;
    }
    return  lpClipList;
}

/*
 * ClipRgnToRect
 */
void ClipRgnToRect(LPRECT prect, LPRGNDATA prd)
{
    RECT        rect;
    int         i;
    int         n;
    LPRECTL     prectlD;
    LPRECTL     prectlS;


    if (prect == NULL || prd == NULL)
    {
        return;
    }

    // If the bounding rect of the region is exactly equal to
    // or inside of the Restricting rect then we know
    // we don't have to do any more work.
    //
    // In the common case, the rcBound will be the client
    // area of a window and so will the restricting rect.
    if (prect->top    <= prd->rdh.rcBound.top &&
        prect->bottom >= prd->rdh.rcBound.bottom &&
        prect->left   <= prd->rdh.rcBound.left &&
        prect->right  >= prd->rdh.rcBound.right)
    {
        return;
    }

    // If the bounding rect doesn't equal the prect then
    // we might have to do some clipping.
    rect = *prect;

    prectlD = (LPRECTL) prd->Buffer;
    prectlS = (LPRECTL) prd->Buffer;
    n = (int)prd->rdh.nCount;

    for (i=0; i<n; i++)
    {
        prectlD->left  = max(prectlS->left, rect.left);
        prectlD->right = min(prectlS->right, rect.right);
        prectlD->top   = max(prectlS->top, rect.top);
        prectlD->bottom= min(prectlS->bottom, rect.bottom);

        prectlS++;

        if ((prectlD->bottom - prectlD->top <= 0) ||
            (prectlD->right - prectlD->left <= 0))
        {
            prd->rdh.nCount--;  // dont count empty rect.
        }
        else
        {
            prectlD++;
        }
    }

    return;

} /* ClipRgnToRect */

/*
 * XformRect
 *
 * Transform a clipped rect in destination space to the corresponding clipped
 * rect in src space. So, if we're stretching from src to dest, this yields
 * the unstretched clipping rect in src space.
 *
 *  PARAMETERS:
 *      prcSrc - unclipped rect in the source space
 *      prcDest - unclipped rect in the destination space
 *      prcClippedDest - the rect we want to transform
 *      prcClippedSrc - the resulting rect in the source space.  return value.
 *      scale_x - 16.16 fixed point src/dest width ratio
 *      scale_y  - 16.16 fixed point src/dest height ratio
 *
 *  DESCRIPTION:
 *      Given an rect in source space and a rect in destination space, and a
 *      clipped rectangle in the destination space (prcClippedDest), return
 *      the rectangle in the source space (prcClippedSrc) that maps to
 *      prcClippedDest.
 *
 *      Use 16.16 fixed point math for more accuracy. (Shift left, do math,
 *      shift back (w/ round))
 *
 *  RETURNS:
 *      S_OK always.  prcClippedSrc is the mapped rectangle.
 *
 */
HRESULT XformRect(RECT * prcSrc, RECT * prcDest, RECT * prcClippedDest,
                  RECT * prcClippedSrc, DWORD scale_x, DWORD scale_y)
{
    /*
     * This first calculation is done with fixed point arithmetic (16.16).
     * The result is converted to (32.0) below. Scale back into source space
     */
    prcClippedSrc->left = (prcClippedDest->left - prcDest->left) * scale_x;
    prcClippedSrc->right = (prcClippedDest->right - prcDest->left) * scale_x;
    prcClippedSrc->top = (prcClippedDest->top - prcDest->top) * scale_y;
    prcClippedSrc->bottom = (prcClippedDest->bottom - prcDest->top) * scale_y;

    /*
     * now round (adding 0x8000 rounds) and translate (offset by the
     * src offset)
     */
    prcClippedSrc->left = (((DWORD)prcClippedSrc->left + 0x8000) >> 16) + prcSrc->left;
    prcClippedSrc->right = (((DWORD)prcClippedSrc->right + 0x8000) >> 16) + prcSrc->left;
    prcClippedSrc->top = (((DWORD)prcClippedSrc->top + 0x8000) >> 16) + prcSrc->top;
    prcClippedSrc->bottom = (((DWORD)prcClippedSrc->bottom + 0x8000) >> 16) + prcSrc->top;

    /*
     * Check for zero-sized source rect dimensions and bump if necessary
     */
    if (prcClippedSrc->left == prcClippedSrc->right)
    {
        if (prcClippedSrc->right == prcSrc->right)
        {
            (prcClippedSrc->left)--;
        }
        else
        {
            (prcClippedSrc->right)++;
        }

    }
    if (prcClippedSrc->top == prcClippedSrc->bottom)
    {
        if (prcClippedSrc->bottom == prcSrc->bottom)
        {
            (prcClippedSrc->top)--;
        }
        else
        {
            (prcClippedSrc->bottom)++;
        }

    }

    return S_OK;

} /* XformRect */

/*****************************Private*Routine******************************\
* DdBlt
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
* 31-Mar-2000 -by- Kan Qiu [kanqiu]
* Made it handle clipping case
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "DdBlt"
#define SIZE_OF_A_CLIPLIST(lpRgn) \
        (sizeof(RGNDATAHEADER)+sizeof(RECTL)*lpRgn->rdh.nCount)

DWORD
WINAPI
DdBlt(
    PD3D8_BLTDATA pBlt
   )
{
    DDHAL_BLTDATA   bd;
    DWORD       ret = DDHAL_DRIVER_NOTHANDLED;
    PDDSURFHANDLE   pDstSurf = (PDDSURFHANDLE) pBlt->hDestSurface;
    PDDSURFHANDLE   pSrcSurf = (PDDSURFHANDLE) pBlt->hSrcSurface;
    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) pBlt->hDD;
    DWORD   bltcaps;
    if (CheckForDeviceLost (pBlt->hDD))
    {
        // Some blts should fail, others should succeed:
        // persistant -> non persitant : OK
        // persistant -> persitant : FAIL
        // non persistant -> persistant : FAIL
        // non persistant -> non persistant : OK

        if (pDstSurf && ((pDstSurf->Pool == D3DPOOL_LOCALVIDMEM) ||
            (pDstSurf->Pool == D3DPOOL_NONLOCALVIDMEM))
           )
        {
            pBlt->ddRVal = S_OK;
        }
        else
        {
            pBlt->ddRVal = D3DERR_DEVICELOST;
        }
        return DDHAL_DRIVER_HANDLED;
    }
    ZeroMemory(&bd, sizeof bd);
    bd.ddRVal      = E_FAIL;  // always assume error

    // Just a colorfill?
#ifdef DEBUG
    if ((pSrcSurf == NULL) && pDstSurf)
    {
        do
        {
            bd.dwFlags     = pBlt->dwFlags & DDBLT_VALID;
            bd.IsClipped   = FALSE; // NT Kernel cannot handle it
            bd.bltFX       = pBlt->bltFX;
            bd.rDest       = pBlt->rDest;

            ret = OsThunkDdBlt(GetSurfHandle(pBlt->hDestSurface),
                       0,
                       (PDD_BLTDATA) &bd);
        
            if (DDHAL_DRIVER_NOTHANDLED == ret)
            {
                DPF_ERR("Driver failed color-fill blt. SWAPEFFECT_DISCARD not being enforced.");
            }
        } while (bd.ddRVal == DDERR_WASSTILLDRAWING);
 
        return S_OK;
    }
#endif 

    // Are we going to send this blt to the driver?
    if (!pDstSurf)
    {
        // NULL destination ? we are running SW driver w/o ddraw support
        // use GDI for blting
        goto gdiblt;                    
    }
    else if (IS_SOFTWARE_DRIVER_SURFACE(pSrcSurf))
    {
        if (!(pDevice->DDCaps & DDCAPS_CANBLTSYSMEM))
            goto gdiblt;            
        bltcaps = pDevice->SVBCaps;
    }
    else
    {
        bltcaps = pDevice->DDCaps;
    }
    if (!(bltcaps & DDCAPS_BLT))
        goto gdiblt;            
    
    //it is assumed that the format for a presented back buffer is OK and has
    //been validated by higher layers of the runtime. (e.g. if the back
    //buffer has alpha, or in the future is very different from front buffer format)
    if ((pDstSurf->Format == pSrcSurf->Format) ||
        (pBlt->dwFlags & DDBLT_WINDOWCLIP) ) //which means this is a presentation blt
    {
        //Yes, we're going to the driver...
        bd.rDest       = pBlt->rDest;
        bd.rSrc        = pBlt->rSrc;
        bd.dwFlags     = pBlt->dwFlags & DDBLT_VALID;
        bd.dwROPFlags  = pBlt->dwROPFlags;
        bd.IsClipped   = FALSE; // NT Kernel cannot handle it
        bd.bltFX       = pBlt->bltFX;

        // This is for Window Redirection support
        // (available on post-Windows 2000)
        // On Windows 2000, bd.Blt is ignored by win32k.sys
        if (pBlt->dwFlags & DDBLT_WINDOWCLIP)
        {
           bd.Blt      = (VOID*)(pBlt->hWnd);
        }

        // Mask DX8 flags from the OS
        if (pBlt->dwFlags & DDBLT_DX8ORHIGHER)
        {
            bd.dwFlags &= ~(DDBLT_WINDOWCLIP | DDBLT_COPYVSYNC | DDBLT_DX8ORHIGHER);
        }

        DPF(10,"pBlt->rDest %08lx %08lx %08lx %08lx",
            pBlt->rDest.top, pBlt->rDest.bottom,
            pBlt->rDest.left, pBlt->rDest.right);
        if ((pBlt->hWnd) && (DDBLT_WINDOWCLIP & pBlt->dwFlags))
        {
            RECTL   rOrigSrc=pBlt->rSrc;   // unclipped src rect
            LONG    SrcWidth = rOrigSrc.right - rOrigSrc.left;
            LONG    SrcHeight = rOrigSrc.bottom - rOrigSrc.top;
            RECT    rOrigDest;
            do
            {
                LPRGNDATA   prd;
                LPRECT      prect;
                DWORD       cnt;
                if (GetClientRect(pBlt->hWnd, &rOrigDest))
                {
                    POINT   pOrigDest;
                    if (rOrigDest.right > pBlt->rDest.right)
                        rOrigDest.right = pBlt->rDest.right;
                    if (rOrigDest.bottom > pBlt->rDest.bottom)
                        rOrigDest.bottom = pBlt->rDest.bottom;
                    if (0 < pBlt->rDest.left)
                        rOrigDest.left = pBlt->rDest.left;
                    if (0 < pBlt->rDest.top)
                        rOrigDest.top = pBlt->rDest.top;
                    if ((rOrigDest.right <= rOrigDest.left) ||
                        (rOrigDest.bottom <= rOrigDest.top)
                       )
                    {
                        pBlt->ddRVal = S_OK;
                        return DDHAL_DRIVER_HANDLED;
                    }
                        
                    pOrigDest.x = - pDevice->rcMonitor.left;
                    pOrigDest.y = - pDevice->rcMonitor.top;
                    if (!ClientToScreen(pBlt->hWnd, &pOrigDest))
                        DPF_ERR("ClientToScreen Failed on pOrigDest?");
                    if (!OffsetRect(&rOrigDest, pOrigDest.x, pOrigDest.y ))
                        DPF_ERR("OffsetRect Failed on rOrigDest?");
                    if (rOrigDest.bottom <= 0 || rOrigDest.right <= 0 ||
                        (rOrigDest.top + pDevice->rcMonitor.top >= pDevice->rcMonitor.bottom) ||
                        (rOrigDest.left + pDevice->rcMonitor.left >= pDevice->rcMonitor.right))
                    {
                        // client is completely outside device space
                        // means cross device blt is needed
                        goto gdiblt;
                    }
                }
                else
                {
                    DPF_ERR("GetClientRect Failed ?");
                    goto gdiblt;
                }
                if (   ( NULL == pDevice->pClipList ) 
                    || ( NULL == pDevice->pOrigClipList )
                    || ( pDevice->hLastWnd != pBlt->hWnd )
                    || (DDERR_VISRGNCHANGED == bd.ddRVal))
                {
                    DWORD   dwClipListSize;
                    if ( NULL != pDevice->pClipList )
                    {
                        MemFree(pDevice->pClipList);
                        pDevice->pClipList = NULL;
                    }    
                    if ( NULL != pDevice->pOrigClipList )
                    {
                        MemFree(pDevice->pOrigClipList);
                        pDevice->pOrigClipList = NULL;
                    }    
                    prd = GetClipList(pBlt->hWnd);
                    if (NULL == prd)
                        goto gdiblt;
                
                    prect=(LPRECT) &prd->Buffer[0];
                    for (cnt=0; cnt<prd->rdh.nCount; cnt++)
                    {
                        if ((prect[cnt].top < pDevice->rcMonitor.top) ||
                            (prect[cnt].left < pDevice->rcMonitor.left) ||
                            (prect[cnt].bottom > pDevice->rcMonitor.bottom) ||
                            (prect[cnt].right > pDevice->rcMonitor.right)
                          )
                        {
                            // do GDI blt if any rect is outside
                            MemFree (prd);
                            goto gdiblt;
                        }
                        if (!OffsetRect( &prect[cnt], - pDevice->rcMonitor.left, 
                            - pDevice->rcMonitor.top ))
                            DPF_ERR("OffsetRect Failed on prect[cnt]?");
                    }
                    dwClipListSize = SIZE_OF_A_CLIPLIST(prd);
                    pDevice->pOrigClipList = (LPRGNDATA)MemAlloc(dwClipListSize);
                    if (NULL != pDevice->pOrigClipList)
                    {
                        memcpy(pDevice->pOrigClipList, prd, dwClipListSize);
                        pDevice->hLastWnd = pBlt->hWnd;
                    }                
                }
                else
                {                    
                    prd = pDevice->pClipList;
                    memcpy(prd, pDevice->pOrigClipList,
                        SIZE_OF_A_CLIPLIST(pDevice->pOrigClipList));
                }
                DDASSERT( (0 == pDevice->pClipList) || ( prd == pDevice->pClipList) );
                DDASSERT( NULL != prd );

                // Clip the region to the rect before we go further
                ClipRgnToRect(&rOrigDest, prd );

                // Process each visible sub-rect separately
                if (prd->rdh.nCount > 0)
                {
                    int         x_offset;
                    int         y_offset;
                    DWORD       scale_x;
                    DWORD       scale_y;
                    BOOL        stretch_blt;
                    pDevice->pClipList = prd;

                    // precalculate a couple of variables
                    if ((rOrigDest.bottom - rOrigDest.top == SrcHeight) &&
                        (rOrigDest.right - rOrigDest.left == SrcWidth))
                    {
                        x_offset = rOrigSrc.left - rOrigDest.left;
                        y_offset = rOrigSrc.top - rOrigDest.top;
                        stretch_blt = FALSE;
                    }
                    else
                    {
                        if (!(bltcaps & DDCAPS_BLTSTRETCH))
                            goto gdiblt;
                        // scale_x and scale_y are fixed point variables scaled
                        // 16.16 (16 integer bits and 16 fractional bits)
                        scale_x = (SrcWidth << 16) /
                            (rOrigDest.right - rOrigDest.left);
                        scale_y = (SrcHeight << 16) /
                            (rOrigDest.bottom - rOrigDest.top);
                        stretch_blt = TRUE;
                    }

                    if (DDBLT_COPYVSYNC & pBlt->dwFlags)
                    {
                        DD_GETSCANLINEDATA   ScanData;
                        DWORD                msStartTime = GetTickCount();
                        DWORD                msCurrentTime;
                        DWORD                threshold=pBlt->threshold;

                        // Compute how many milliseconds there
                        // are per refresh. We round down.
                        msCurrentTime = msStartTime;                

                        // If the previous blt was just a few ms ago
                        // then we can make up the difference by yielding
                        if ((msCurrentTime - pBlt->msLastPresent) < threshold )
                        {
                            Sleep(threshold + pBlt->msLastPresent - msCurrentTime);
                            msCurrentTime = pBlt->msLastPresent + threshold;
                        }

                        threshold = ((PDDSURFHANDLE)pBlt->hDestSurface)->dwHeight/2;
                        while (DDHAL_DRIVER_HANDLED == 
                            OsThunkDdGetScanLine(DDHANDLE(pBlt->hDD),&ScanData))
                        {
                            if (DD_OK != ScanData.ddRVal)
                                break;

                            if ((LONG)ScanData.dwScanLine >= rOrigDest.bottom)
                                break;
                        
                            if ((LONG)(ScanData.dwScanLine + threshold/3) < rOrigDest.top)
                                break;

                            // just yield 1 ms instead of doing lengthy calculation which
                            // does not get me better result
                            if ((LONG)(ScanData.dwScanLine + threshold) < rOrigDest.bottom)
                            {
                                Sleep(1);
                            }
                            // If we've been spinning here for 30ms
                            // then blt anyway; probably something
                            // running in the background taking
                            // up CPU cycles
                            msCurrentTime = GetTickCount();
                            if ((msCurrentTime - msStartTime) > 30)
                            {
                                break;
                            }
                        }

                        // Remember the time of last blt
                        pBlt->msLastPresent = msCurrentTime;
                    }
                    //traverse the visible rect list and send each piece to
                    //the driver to blit
                    prect=(LPRECT) &prd->Buffer[0];

                    for (cnt=0;cnt<prd->rdh.nCount;cnt++)
                    {

                        // find out where on the src rect we need to get
                        // the data from.

                        bd.rDest.left = prect[cnt].left;
                        bd.rDest.right = prect[cnt].right;
                        bd.rDest.top = prect[cnt].top;
                        bd.rDest.bottom = prect[cnt].bottom;
                        if (!stretch_blt)
                        {
                            // no stretch
                            // one-to-one mapping from source to destination
                            bd.rSrc.left = bd.rDest.left + x_offset;
                            bd.rSrc.right = bd.rDest.right + x_offset;
                            bd.rSrc.top = bd.rDest.top + y_offset;
                            bd.rSrc.bottom = bd.rDest.bottom + y_offset;
                        }
                        else
                        {
                            // stretching
                            // linear mapping from source to destination
                            // calculate the source rect which transforms to the
                            // dest rect
                            XformRect((RECT *)&(rOrigSrc), &rOrigDest,
                                (RECT *)&(bd.rDest), (RECT *)&(bd.rSrc),
                                scale_x, scale_y);
                        }

                        // If mirror Blt, we must fix up source rect here!
                        if (bd.dwFlags & DDBLT_DDFX)
                        {
                            int temp;

                            if (bd.bltFX.dwDDFX & DDBLTFX_MIRRORLEFTRIGHT)
                            {
                                temp = bd.rSrc.left;
                                bd.rSrc.left = rOrigSrc.left +
                                    rOrigSrc.right - bd.rSrc.right;
                                bd.rSrc.right = rOrigSrc.left +
                                    rOrigSrc.right - temp;
                            }

                            if (bd.bltFX.dwDDFX & DDBLTFX_MIRRORUPDOWN)
                            {
                                temp = bd.rSrc.top;
                                bd.rSrc.top = rOrigSrc.top +
                                    rOrigSrc.bottom - bd.rSrc.bottom;
                                bd.rSrc.bottom = rOrigSrc.top +
                                    rOrigSrc.bottom - temp;
                            }
                        }

                        do
                        {
                            bd.ddRVal = E_FAIL;  // always assume error

                            if (bd.dwFlags & DDBLT_PRESENTATION)
                            {
                                if (cnt == prd->rdh.nCount-1)
                                {
                                    bd.dwFlags |= DDBLT_LAST_PRESENTATION;
                                }
                            }

                            ret = OsThunkDdBlt(GetSurfHandle(pBlt->hDestSurface),
                                       GetSurfHandle(pBlt->hSrcSurface),
                                       (PDD_BLTDATA) &bd);
                            if (DDHAL_DRIVER_NOTHANDLED == ret)
                            {
                                bd.ddRVal = E_FAIL;  // make it out of loop
                                break;
                            }
                            if (bd.ddRVal == DDERR_SURFACELOST)
                            {
                                bd.ddRVal = S_OK;
                                break;
                            }

                            /*
                             * NOTE: If clipping has introduced more than
                             * one rectangle we behave as if DDBLT_WAIT
                             * was specified on all rectangles after the
                             * first. This is necessary as the first
                             * rectangle will probably cause the accelerator
                             * to be busy. Hence, the attempt to blit the
                             * second rectangle will fail with
                             * DDERR_WASSTILLDRAWING. If we pass this to
                             * the application (rather than busy waiting)
                             * the application is likely to retry the blit
                             * (which will fail on the second rectangle again)
                             * and we have an application sitting in an
                             * infinite loop).
                             */
                        } while(  (DDERR_WASSTILLDRAWING == bd.ddRVal) &&
                                  ( (DDBLT_WAIT & pBlt->dwFlags) ||
                                    (1 < prd->rdh.nCount)
                                  )
                               );
                        if (FAILED(bd.ddRVal))
                            break;
                    }
                }
                else
                {
                    MemFree (prd);
                    pDevice->pClipList = NULL;
                    bd.ddRVal = S_OK;
                    ret = DDHAL_DRIVER_HANDLED;
                    break;  // all clipped, no need to blt!
                }
                if (DDERR_VISRGNCHANGED == bd.ddRVal)
                {
                    OsThunkDdResetVisrgn(GetSurfHandle(pBlt->hDestSurface),(HWND)0);
                    pDevice->hLastWnd = NULL;   // zero cached info for DdBlt
                }
            } while (DDERR_VISRGNCHANGED == bd.ddRVal);
        }
        else
        {
            DDASSERT( 0 == (bd.dwFlags & DDBLT_PRESENTATION));
            if ((bd.rDest.right - bd.rDest.left != bd.rSrc.right - bd.rSrc.left || 
                 bd.rDest.bottom - bd.rDest.top != bd.rSrc.bottom - bd.rSrc.top)
                 && !(bltcaps & DDCAPS_BLTSTRETCH)
               )
                goto gdiblt;

            do
            {
                bd.ddRVal = E_FAIL;  // always assume error
                ret = OsThunkDdBlt(GetSurfHandle(pBlt->hDestSurface),
                           GetSurfHandle(pBlt->hSrcSurface),
                           (PDD_BLTDATA) &bd);
                if (DDHAL_DRIVER_NOTHANDLED == ret)
                {
                    bd.ddRVal = E_FAIL;  // make it out of loop
                    break;
                }
                if (bd.ddRVal == DDERR_SURFACELOST)
                {
                    bd.ddRVal = S_OK;
                }
                if (DDERR_VISRGNCHANGED == bd.ddRVal)
                {
                    OsThunkDdResetVisrgn(GetSurfHandle(pBlt->hDestSurface),(HWND)0);
                    pDevice->hLastWnd = NULL;   // zero cached info for DdBlt
                }
            } while ( (DDERR_VISRGNCHANGED == bd.ddRVal) ||
                      ( (DDERR_WASSTILLDRAWING == bd.ddRVal) &&
                        (DDBLT_WAIT & pBlt->dwFlags)
                      )
                    );
        }
    }

gdiblt:
    if (FAILED(bd.ddRVal))
    {
        // !!! Just use GetDC on the DirectDraw surface for now, though this is
        // probably way too slow on drivers which do not support derived
        // surfaces. DirectDraw Blt support should be added soon.
        HDC hDCTarget;
        BOOL    bGetDCfromWnd = (pBlt->hWnd) && 
                    ((DDBLT_WINDOWCLIP & pBlt->dwFlags) || !pBlt->hDestSurface);
        if (bGetDCfromWnd)
            hDCTarget = GetDC(pBlt->hWnd);
        else
            hDCTarget = D3D8GetDC(pBlt->hDestSurface, NULL);
        if (hDCTarget != NULL)
        {
            HDC hDCSource = D3D8GetDC(pBlt->hSrcSurface, NULL);
            if (hDCSource != NULL)
            {
                LONG DestWidth=pBlt->rDest.right - pBlt->rDest.left;
                LONG DestHeight= pBlt->rDest.bottom - pBlt->rDest.top;
                LONG SrcWidth= pBlt->rSrc.right - pBlt->rSrc.left;
                LONG SrcHeight= pBlt->rSrc.bottom - pBlt->rSrc.top;
                if (DestWidth == SrcWidth && DestHeight == SrcHeight)
                {
                    if (BitBlt(
                        hDCTarget,
                        pBlt->rDest.left,
                        pBlt->rDest.top,
                        DestWidth,
                        DestHeight,
                        hDCSource,
                        pBlt->rSrc.left,
                        pBlt->rSrc.top,
                        SRCCOPY))
                    {
                        bd.ddRVal = S_OK;
                        ret = DDHAL_DRIVER_HANDLED;
                    }
                }
                else
                {
                    // COLORONCOLOR is not the default in NT
                    int saved = SetStretchBltMode(hDCTarget,COLORONCOLOR);
                    if (StretchBlt(
                        hDCTarget,
                        pBlt->rDest.left,
                        pBlt->rDest.top,
                        DestWidth,
                        DestHeight,
                        hDCSource,
                        pBlt->rSrc.left,
                        pBlt->rSrc.top,
                        SrcWidth,
                        SrcHeight,
                        SRCCOPY))
                    {
                        bd.ddRVal = S_OK;
                        ret = DDHAL_DRIVER_HANDLED;
                    }
                    // restore to previous mode
                    if (saved)
                        SetStretchBltMode(hDCTarget,saved);
                }
                D3D8ReleaseDC(pBlt->hSrcSurface, hDCSource);
            }
            if (bGetDCfromWnd)
                ReleaseDC(pBlt->hWnd, hDCTarget);
            else
                D3D8ReleaseDC(pBlt->hDestSurface, hDCTarget);
        }        
    }

    pBlt->ddRVal = MapLegacyResult(bd.ddRVal);

    // We only want to report DP2 errors  during the present call because
    // checking for it everywhere is too hard.
    if ((pBlt->ddRVal == DD_OK) &&
        (pDevice->dwFlags & DDDEVICE_DP2ERROR) &&
        (pBlt->dwFlags & DDBLT_WINDOWCLIP))
    {
        pDevice->dwFlags &= ~DDDEVICE_DP2ERROR;

        // We use a special error here to mean that the blt succeeded
        // but that that some DP2 failed since the last present
        pBlt->ddRVal = D3DERR_DEFERRED_DP2ERROR;
    }

    return ret;
}

/*****************************Private*Routine******************************\
* DdFlip
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "DdFlip"

DWORD
APIENTRY
DdFlip(
    PD3D8_FLIPDATA pFlip
   )
{
    HANDLE          hSurfTargLeft=NULL;
    HANDLE          hSurfCurrLeft=NULL;
    DDHAL_FLIPDATA  FlipData;
    DWORD           dwRet;

    if (CheckForDeviceLost (pFlip->hDD))
    {
        pFlip->ddRVal = S_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    FlipData.dwFlags = (pFlip->dwFlags  & ~DDFLIP_WAIT);
    FlipData.ddRVal = DDERR_GENERIC;
    if (pFlip->dwFlags & DDFLIP_STEREO)
    {
        hSurfTargLeft = GetSurfHandle(pFlip->hSurfTargLeft);
        hSurfCurrLeft = GetSurfHandle(pFlip->hSurfCurrLeft);
    }
    do
    {
        dwRet = OsThunkDdFlip(GetSurfHandle(pFlip->hSurfCurr),
                       GetSurfHandle(pFlip->hSurfTarg),
                       hSurfCurrLeft,
                       hSurfTargLeft,
                       (PDD_FLIPDATA) &FlipData);
        if (FlipData.ddRVal == DDERR_SURFACELOST)
        {
            FlipData.ddRVal = S_OK;
        }
    }while (DDERR_WASSTILLDRAWING == FlipData.ddRVal &&
        (DDFLIP_WAIT & pFlip->dwFlags));
    pFlip->ddRVal = MapLegacyResult(FlipData.ddRVal);

    // We only want to report DP2 errors  during the present call because
    // checking for it everywhere is too hard.
    if ((pFlip->ddRVal == DD_OK) &&
        (((DDDEVICEHANDLE*)pFlip->hDD)->dwFlags & DDDEVICE_DP2ERROR))
    {
        ((DDDEVICEHANDLE*)pFlip->hDD)->dwFlags &= ~DDDEVICE_DP2ERROR;

        // We use a special error here to mean that the flip succeeded
        // but that that some DP2 failed since the last present
        pFlip->ddRVal = D3DERR_DEFERRED_DP2ERROR;
    }

    return dwRet;
}

/*****************************Private*Routine******************************\
* DdLock
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "DdLock"

HRESULT
APIENTRY
DdLock(
    PD3D8_LOCKDATA pLock
   )
{
    DD_LOCKDATA     LockData;
    PDDSURFHANDLE   pSurf;
    BOOL            bAdjustSlice = FALSE;

    pSurf = (PDDSURFHANDLE) pLock->hSurface;

    // If the device is lost, we need to fake up a buffer for
    // the app to write to.  We still allow software drivers
    // handle the Lock call, however. Further, we also allow
    // driver managed surfaces to go through.

    if (CheckForDeviceLost (pLock->hDD) &&
        !IS_SOFTWARE_DRIVER_SURFACE(pSurf) &&
        pSurf->Pool != D3DPOOL_MANAGED)
    {
        goto DeviceLost;
    }

    // We do make an exception for fake deferred creates
    // of driver managed surfaces. The driver doesn't know
    // about these deferred surfaces, so we don't call it.
    // ASSUMPTIONS: even if DDSURF_SYSMEMALLOCATED can be
    // set below, we expect it to be never set below for
    // **driver managed surfaces**. For these surfaces, we
    // assume that it will be set only in 
    // CreateVidMemSurface. This assumption is true as of
    // 3/2001.

    if ((pSurf->dwFlags & DDSURF_SYSMEMALLOCATED) != 0)
    {
        DDASSERT(pSurf->fpVidMem != (ULONG_PTR)NULL);
        goto DeviceLost;
    }

    // Mask off new flags
    LockData.dwFlags  = pLock->dwFlags;
    LockData.dwFlags &= (D3DLOCK_READONLY         |
                         D3DLOCK_DISCARD          |   
                         D3DLOCK_NOOVERWRITE      |
                         D3DLOCK_NOSYSLOCK);       
    // Always set lock_wait
    LockData.dwFlags |= DDLOCK_WAIT;
    // Also set equivalent DDLOCK flag for NO_DIRTY_UPDATE
    // if the driver understands it
    if ((pLock->dwFlags & D3DLOCK_NO_DIRTY_UPDATE) != 0)
    {
        LockData.dwFlags |= DDLOCK_NODIRTYUPDATE;
    }

    if(pLock->bHasRange)
    {
        LockData.bHasRect = TRUE;
        LockData.rArea.left = 0;
        LockData.rArea.right = 0;
        LockData.rArea.top = pLock->range.Offset;
        LockData.rArea.bottom = pLock->range.Offset + pLock->range.Size;
    }
    else
    {
        LockData.bHasRect = pLock->bHasRect;
        LockData.rArea = pLock->rArea;
    }

    if (pLock->bHasBox)
    {
        LockData.bHasRect = TRUE;
        LockData.rArea.left = pLock->box.Left;
        LockData.rArea.right = pLock->box.Right;
        LockData.rArea.top = pLock->box.Top;
        LockData.rArea.bottom = pLock->box.Bottom;

        // We cannot change the kernel for an OS before whistler, so we will
        // not pass the front/back to the driver.  For ref and for newer OSes,
        // we will stick the front/back into the high word of left/right

        if (IS_SOFTWARE_DRIVER_SURFACE(pSurf) ||
            ((((PDDDEVICEHANDLE)pLock->hDD)->bIsWhistler) &&
             (((PDDDEVICEHANDLE)pLock->hDD)->dwFlags & DDDEVICE_SUPPORTSUBVOLUMELOCK)))
        {
            LockData.dwFlags |= DDLOCK_HASVOLUMETEXTUREBOXRECT;
            LockData.rArea.left |= (pLock->box.Front << 16);
            LockData.rArea.right |= (pLock->box.Back << 16);
        }
        else
        {
            bAdjustSlice = TRUE;
        }
    }

    LockData.ddRVal = DDERR_WASSTILLDRAWING;

    if (IS_SOFTWARE_DRIVER_SURFACE(pSurf))
    {
        // This is a software driver, so we need to treat
        // it specially

        SwDDILock (pLock->hDD, pSurf, &LockData);
    }
    else
    {
        while ((LockData.ddRVal == DDERR_VISRGNCHANGED) ||
            (LockData.ddRVal == DDERR_WASSTILLDRAWING))
        {
            if ((pSurf->Type == D3DRTYPE_VERTEXBUFFER) ||
                (pSurf->Type == D3DRTYPE_COMMANDBUFFER)||
                (pSurf->Type == D3DRTYPE_INDEXBUFFER))
            {
                OsThunkDdLockD3D(pSurf->hSurface,
                                 &LockData);
            }
            else
            {
                OsThunkDdLock(pSurf->hSurface,
                                &LockData,
                                NULL);
            }

            if (LockData.ddRVal == DDERR_VISRGNCHANGED)
            {
                if (pLock->dwFlags & DDLOCK_FAILONVISRGNCHANGED)
                {
                    break;
                }
                else
                {
                    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) pLock->hDD;
                    OsThunkDdResetVisrgn(pSurf->hSurface, (HWND)0);
                    pDevice->hLastWnd = NULL;   // zero cached info for DdBlt
                }
            }

            // In the past we would require DDLOCK_WAIT to
            // decide if we would spin or exit now we always wait
        }
        if (LockData.ddRVal == DDERR_SURFACELOST)
        {
            CheckForDeviceLost(pLock->hDD);
            goto DeviceLost;
        }
    }

    if (LockData.ddRVal == S_OK)
    {
        pLock->lpSurfData = LockData.lpSurfData;
        pLock->lPitch = pSurf->lPitch;

        if ((pSurf->Type == D3DRTYPE_VOLUME) ||
            (pSurf->Type == D3DRTYPE_VOLUMETEXTURE))
        {
            pLock->lSlicePitch = pSurf->lSlicePitch;

            if (bAdjustSlice)
            {
                ((BYTE*)pLock->lpSurfData) += (pLock->lSlicePitch * 
                                                pLock->box.Front);
            }
        }
        pSurf->LockRefCnt++;
    }

    return MapLegacyResult(LockData.ddRVal);

DeviceLost:
    // At the time the device is lost, fpVidMem is set to NULL
    // for all vidmem surfaces.  Therefore, if it is non-NULL
    // we are safe to use what we already have; otherwise, we
    // have to allocate our own.

    if (pSurf->fpVidMem == (ULONG_PTR) NULL)
    {
        if ((pSurf->Type == D3DRTYPE_VOLUME) ||
            (pSurf->Type == D3DRTYPE_VOLUMETEXTURE))
        {
            // For volume textures, dwHeight really contains the depth
            pSurf->fpVidMem = (ULONG_PTR) MemAlloc(pSurf->lSlicePitch * pSurf->dwHeight);
        }
        else
        {
            pSurf->fpVidMem = (ULONG_PTR) MemAlloc(pSurf->lPitch * pSurf->dwHeight);
        }
        if (pSurf->fpVidMem == (ULONG_PTR) NULL)
        {
            pLock->lpSurfData = (void*)pSurf->fpVidMem;
            return E_FAIL;
        }
        pSurf->dwFlags |= DDSURF_SYSMEMALLOCATED;
    }
    pLock->lpSurfData = (void*)pSurf->fpVidMem;
    pLock->lPitch = pSurf->lPitch;

    if ((pSurf->Type == D3DRTYPE_VOLUME) ||
        (pSurf->Type == D3DRTYPE_VOLUMETEXTURE))
    {
        pLock->lSlicePitch = pSurf->lSlicePitch;
    }
    pSurf->LockRefCnt++;

    return S_OK;
}

/*****************************Private*Routine******************************\
* DdUnlock
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "DdUnlock"

HRESULT
APIENTRY
DdUnlock(
    PD3D8_UNLOCKDATA pUnlock
   )
{
    DD_UNLOCKDATA   UnlockData;
    PDDSURFHANDLE   pSurf;

    pSurf = (PDDSURFHANDLE) pUnlock->hSurface;

    if (pSurf->LockRefCnt > 0)
    {
        pSurf->LockRefCnt--;
    }
    if (CheckForDeviceLost (pUnlock->hDD) &&
        !IS_SOFTWARE_DRIVER_SURFACE(pSurf) &&
        pSurf->Pool != D3DPOOL_MANAGED)
    {
        return S_OK;
    }
    if ((pSurf->dwFlags & DDSURF_SYSMEMALLOCATED) != 0)
    {
        DDASSERT(pSurf->fpVidMem != (ULONG_PTR)NULL);
        return S_OK;
    }

    if (IS_SOFTWARE_DRIVER_SURFACE(pSurf))
    {
        // This is a software driver, so we need to treat
        // it specially

        SwDDIUnlock (pUnlock->hDD, pSurf, &UnlockData);
    }
    else
    {
        if ((GetSurfType(pUnlock->hSurface) == D3DRTYPE_VERTEXBUFFER) ||
            (GetSurfType(pUnlock->hSurface) == D3DRTYPE_COMMANDBUFFER) ||
            (GetSurfType(pUnlock->hSurface) == D3DRTYPE_INDEXBUFFER))
        {
            OsThunkDdUnlockD3D(GetSurfHandle(pUnlock->hSurface),
                             &UnlockData);
        }
        else
        {
            OsThunkDdUnlock(GetSurfHandle(pUnlock->hSurface),
                          &UnlockData);
        }
        if (UnlockData.ddRVal == DDERR_SURFACELOST)
        {
            UnlockData.ddRVal = S_OK;
        }
    }
    return MapLegacyResult(UnlockData.ddRVal);
}

/*****************************Private*Routine******************************\
* DdGetBltStatus
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "DdGetBltStatus"

DWORD
APIENTRY
DdGetBltStatus(
    PD3D8_GETBLTSTATUSDATA pGetBltStatus
   )
{
    DDHAL_GETBLTSTATUSDATA  StatusData;
    DWORD dwRet;

    if (CheckForDeviceLost (pGetBltStatus->hDD))
    {
        pGetBltStatus->ddRVal = S_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    StatusData.dwFlags = pGetBltStatus->dwFlags;
    dwRet = OsThunkDdGetBltStatus(GetSurfHandle(pGetBltStatus->hSurface),
                               (PDD_GETBLTSTATUSDATA) &StatusData);
    
    if (StatusData.ddRVal == DDERR_SURFACELOST)
    {
        StatusData.ddRVal = S_OK;
    }

    pGetBltStatus->ddRVal = MapLegacyResult(StatusData.ddRVal);

    return dwRet;
}

/*****************************Private*Routine******************************\
* DdGetFlipStatus
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "DdGetFlipStatus"

DWORD
APIENTRY
DdGetFlipStatus(
    PD3D8_GETFLIPSTATUSDATA pGetFlipStatus
   )
{
    DDHAL_GETFLIPSTATUSDATA StatusData;
    DWORD dwRet;

    if (CheckForDeviceLost (pGetFlipStatus->hDD))
    {
        pGetFlipStatus->ddRVal = S_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    StatusData.dwFlags = pGetFlipStatus->dwFlags;

    dwRet = OsThunkDdGetFlipStatus(GetSurfHandle(pGetFlipStatus->hSurface),
                                   (PDD_GETFLIPSTATUSDATA) &StatusData);

    if (StatusData.ddRVal == DDERR_SURFACELOST)
    {
        StatusData.ddRVal = S_OK;
    }

    pGetFlipStatus->ddRVal = MapLegacyResult(StatusData.ddRVal);

    return dwRet;
}

/*****************************Private*Routine******************************\
* DdWaitForVerticalBlank
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "DdWaitForVerticalBlank"

DWORD
APIENTRY
DdWaitForVerticalBlank(
    PD3D8_WAITFORVERTICALBLANKDATA pWaitForVerticalBlank
   )
{
    DDHAL_WAITFORVERTICALBLANKDATA WaitData;
    DWORD dwRet;

    if (CheckForDeviceLost (pWaitForVerticalBlank->hDD))
    {
        goto DeviceLost;
    }

    WaitData.dwFlags    = pWaitForVerticalBlank->dwFlags;
    WaitData.hEvent     = 0;

    dwRet = OsThunkDdWaitForVerticalBlank(DDHANDLE(pWaitForVerticalBlank->hDD),
                (PDD_WAITFORVERTICALBLANKDATA) &WaitData);

    if (WaitData.ddRVal == DDERR_SURFACELOST)
    {
        goto DeviceLost;
    }

    pWaitForVerticalBlank->bIsInVB  = WaitData.bIsInVB;
    pWaitForVerticalBlank->ddRVal   = WaitData.ddRVal;

    if (WaitData.ddRVal == DDERR_VERTICALBLANKINPROGRESS)
    {
        pWaitForVerticalBlank->bIsInVB = TRUE;                   
    }
    else
    {
        pWaitForVerticalBlank->bIsInVB = FALSE;                   
    }
    pWaitForVerticalBlank->ddRVal = DD_OK;

    return dwRet;

DeviceLost:
    {
        static int LostTestVerticalBlank;

        pWaitForVerticalBlank->ddRVal = DD_OK;
        if (pWaitForVerticalBlank->dwFlags == DDWAITVB_I_TESTVB)
        {
            if (LostTestVerticalBlank > 0)
            {
                pWaitForVerticalBlank->bIsInVB = TRUE;
            }
            else
            {
                pWaitForVerticalBlank->bIsInVB = FALSE;
            }
            LostTestVerticalBlank = LostTestVerticalBlank == 0 ? 1 : 0;
        }
        else if (pWaitForVerticalBlank->dwFlags == DDWAITVB_BLOCKEND)
        {
            pWaitForVerticalBlank->bIsInVB = FALSE;
        }
        else
        {
            pWaitForVerticalBlank->bIsInVB = TRUE;
        }
    }
    return DDHAL_DRIVER_HANDLED;
}

/*****************************Private*Routine******************************\
* DdDestroySurface
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "DdDestroySurface"

DWORD
APIENTRY
DdDestroySurface(
    PD3D8_DESTROYSURFACEDATA pDestroySurface
   )
{
    DWORD i;
    PDDSURFHANDLE pSurf = (PDDSURFHANDLE) pDestroySurface->hSurface;
    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) pDestroySurface->hDD;
    PDEFERREDCREATE pDefCreate = pDevice->pDeferList;

    FreeSurfaceObject(pSurf);

    // Remove the surface from the linked list

    if (pDevice->pSurfList == pSurf)
    {
        pDevice->pSurfList = pSurf->pNext;
        if (pSurf->pNext != NULL)
        {
            pSurf->pNext->pPrevious = NULL;
        }
    }
    else
    {
        if (pSurf->pNext != NULL)
        {
            pSurf->pNext->pPrevious = pSurf->pPrevious;
        }
        pSurf->pPrevious->pNext = pSurf->pNext;
    }

    // If we allcoated the memory for this surface (due to a lost state),
    // then we should free it now.

    if (pSurf->dwFlags & DDSURF_SYSMEMALLOCATED)
    {
        MemFree((void*) pSurf->fpVidMem);
    }

    // If this surface pointer is cached in the context structure, we need
    // to remedy that.

    if (pSurf->pDevice->pContext != NULL)
    {
        if (pSurf->pDevice->pContext->pSurface == pSurf)
        {
            pSurf->pDevice->pContext->pSurface = NULL;
        }
        if (pSurf->pDevice->pContext->pDDSZ == pSurf)
        {
            pSurf->pDevice->pContext->pDDSZ = NULL;
        }
    }

    MemFree (pSurf);

    // We look in the defer list to see if any referenced surface
    // is being destroyed. If this is the case, then we need to
    // update the defer list and mark the surfaces as freed so
    // that we don't try and resurrect destroyed surfaces. Although
    // this appears slow, it is not too bad because a deferred list
    // will be present only if a mode switch happened. In this case,
    // it doesn't hurt if things are a little slow.

    while (pDefCreate != NULL)
    {
        for (i = 0; i < pDefCreate->CreateData.dwSCnt; i++)
        {
            if (pSurf == (PDDSURFHANDLE) pDefCreate->CreateData.pSList[i].hKernelHandle)
            {
                pDefCreate->CreateData.pSList[i].hKernelHandle = 0;
                break;
            }
        }
        pDefCreate = pDefCreate->pNext;
    }

    return (DDHAL_DRIVER_HANDLED);
}

#undef DPF_MODNAME
#define DPF_MODNAME "D3D8GetMode"

DWORD
APIENTRY
D3D8GetMode(
    HANDLE          Handle,
    char*           pDeviceName,
    D3DDISPLAYMODE* pMode,
    D3DFORMAT       Unknown16)
{
    DEVMODE     dm;
    HDC         hdc;

    memset (&dm, 0, sizeof(dm));
    dm.dmSize = sizeof(dm);
    if (EnumDisplaySettings(pDeviceName, ENUM_CURRENT_SETTINGS, &dm))
    {
        pMode->Width        = dm.dmPelsWidth;
        pMode->Height       = dm.dmPelsHeight;
        pMode->RefreshRate  = dm.dmDisplayFrequency;

        switch (dm.dmBitsPerPel)
        {
        case 8:
            pMode->Format = D3DFMT_P8;
            break;

        case 24:
            pMode->Format = D3DFMT_R8G8B8;
            break;

        case 32:
            pMode->Format = D3DFMT_X8R8G8B8;
            break;

        case 15:
        case 16:
            pMode->Format = D3DFMT_R5G6B5;
            hdc = DD_CreateDC(pDeviceName);
            if (hdc)
            {
                HBITMAP hbm;
                BITMAPINFO *pbmi;
                DWORD *pdwColors;

                if (pbmi = (BITMAPINFO*) MemAlloc(3 * sizeof (RGBQUAD) + sizeof (BITMAPINFO)))
                {
                    if (hbm = CreateCompatibleBitmap(hdc, 1, 1))
                    {
                        pbmi->bmiHeader.biSize = sizeof (BITMAPINFOHEADER);

                        if (GetDIBits(hdc, hbm, 0, 0, NULL, pbmi, DIB_RGB_COLORS))
                        {
                            if (pbmi->bmiHeader.biCompression == BI_BITFIELDS)
                            {
                                GetDIBits(hdc, hbm, 0, pbmi->bmiHeader.biHeight,
                                    NULL, pbmi, DIB_RGB_COLORS);

                                pdwColors = (DWORD *) &pbmi->bmiColors[0];
                                if (pdwColors[1] == 0x3e0)
                                {
                                    pMode->Format = D3DFMT_X1R5G5B5;
                                }
                            }
                        }
                        DeleteObject(hbm);
                    }
                    MemFree(pbmi);
                }
                DD_DoneDC(hdc);
            }
            break;

        default:
            pMode->Format = D3DFMT_UNKNOWN;
            break;
        }
        return S_OK;
    }

    // I don't know in which cases we would ever hit this
    return D3DERR_DRIVERINTERNALERROR;
}

#undef DPF_MODNAME
#define DPF_MODNAME "D3D8SetMode"

DWORD
APIENTRY
D3D8SetMode(
    HANDLE          Handle,
    char*           pDeviceName,
    UINT            Width,
    UINT            Height,
    UINT            BPP,
    UINT            RefreshRate,
    BOOL            bRestore)
{
    HANDLE h = GetModuleHandle("USER32");
    LONG (WINAPI *pfnChangeDisplaySettingsExA)(LPCSTR,LPDEVMODEA,HWND,DWORD,LPVOID);
    DEVMODE dm, * pdm;
    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) Handle;

    // Init the devmode properly:

    dm.dmSize               = sizeof(DEVMODE);
    EnumDisplaySettings (pDeviceName,0,&dm);

    dm.dmBitsPerPel         = BPP;
    dm.dmPelsWidth          = Width;
    dm.dmPelsHeight         = Height;
    dm.dmDisplayFrequency   = RefreshRate;
    dm.dmDisplayFlags       = 0;
    dm.dmFields             = DM_BITSPERPEL |
                              DM_PELSWIDTH |
                              DM_PELSHEIGHT |
                              DM_DISPLAYFREQUENCY;

    // Now tell the OS to do the mode change

    (FARPROC)pfnChangeDisplaySettingsExA = GetProcAddress(h,"ChangeDisplaySettingsExA");
    if (pfnChangeDisplaySettingsExA)
    {
        InformDriverToDeferFrees(pDevice);
        if (bRestore)
        {
            if ((*pfnChangeDisplaySettingsExA)(pDeviceName,
                NULL, NULL, CDS_FULLSCREEN, 0) == DISP_CHANGE_SUCCESSFUL)
            {
                return S_OK;
            }
        }
        else
        {
            if ((*pfnChangeDisplaySettingsExA)(pDeviceName,
                &dm, NULL, CDS_FULLSCREEN, 0) == DISP_CHANGE_SUCCESSFUL)
            {
                return S_OK;
            }
        }
        if (NumReadyDevices == NumDevices)
        {
            InformDriverFreeAGP(pDevice);
        }
    }

    return D3DERR_DRIVERINTERNALERROR;
}

/*****************************Private*Routine******************************\
* DdSetMode
*
* History:
*  29-Nov-1999 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

#undef DPF_MODNAME
#define DPF_MODNAME "DdSetMode"

DWORD
APIENTRY
DdSetMode(
    PD3D8_SETMODEDATA pSetMode
   )
{
    UINT    BPP;
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) pSetMode->hDD;

    // smac: How should lost devices behave?
    CheckForDeviceLost(pSetMode->hDD);

    pSetMode->ddRVal = D3DERR_DRIVERINTERNALERROR;

    switch (pSetMode->Format)
    {
    case D3DFMT_P8:
        BPP = 8;
        break;

    case D3DFMT_R5G6B5:
    case D3DFMT_X1R5G5B5:
        BPP = 16;
        break;

    case D3DFMT_R8G8B8:
        BPP = 24;
        break;

    case D3DFMT_A8R8G8B8:
    case D3DFMT_X8R8G8B8:
        BPP = 32;
        break;

    default:
        return DDHAL_DRIVER_HANDLED;
    }

    pSetMode->ddRVal = D3D8SetMode(pDeviceHandle,
                                   pDeviceHandle->szDeviceName,
                                   pSetMode->dwWidth,
                                   pSetMode->dwHeight,
                                   BPP,
                                   pSetMode->dwRefreshRate,
                                   pSetMode->bRestore);

    return DDHAL_DRIVER_HANDLED;
}

/*****************************Private*Routine******************************\
* DdGetScanLine
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

#undef DPF_MODNAME
#define DPF_MODNAME "DdGetScanLine"

DWORD
APIENTRY
DdGetScanLine(
    PD3D8_GETSCANLINEDATA pGetScanLine
   )
{
    DDHAL_GETSCANLINEDATA   ScanData;
    DWORD                   dwRet;

    if (CheckForDeviceLost(pGetScanLine->hDD))
    {
        goto DeviceLost;
    }

    dwRet = OsThunkDdGetScanLine(DDHANDLE(pGetScanLine->hDD),
                                 (PDD_GETSCANLINEDATA) &ScanData);

    if (ScanData.ddRVal == DDERR_SURFACELOST)
    {
        goto DeviceLost;
    }

    pGetScanLine->dwScanLine = ScanData.dwScanLine;
    if (ScanData.ddRVal == DDERR_VERTICALBLANKINPROGRESS)
    {
        pGetScanLine->bInVerticalBlank = TRUE;
        ScanData.ddRVal = S_OK;
    }
    else
    {
        pGetScanLine->bInVerticalBlank = FALSE;
    }
    pGetScanLine->ddRVal = MapLegacyResult(ScanData.ddRVal);

    return dwRet;

DeviceLost:
    {
        static int LostScanLine;

        // When lost, we want to mix up the return values in case somebody
        // calling us is waiting for these values to change

        pGetScanLine->ddRVal = DD_OK;
        if (LostScanLine == 0)
        {
            pGetScanLine->dwScanLine = 0;
            pGetScanLine->bInVerticalBlank = TRUE;
        }
        else 
        {
            pGetScanLine->dwScanLine = LostScanLine;
            pGetScanLine->bInVerticalBlank = FALSE;
        }
        if ((LostScanLine += 10) > 100)
        {
            LostScanLine = 0;
        }
    }
    return DDHAL_DRIVER_HANDLED;
}

/*****************************Private*Routine******************************\
* DdSetExclusiveMode
*
* History:
*  22-Apr-1998 -by- John Stephens [johnstep]
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "DdSetExclusiveMode"

DWORD
APIENTRY
DdSetExclusiveMode(
    PD3D8_SETEXCLUSIVEMODEDATA pSetExclusiveMode
   )
{
    DDHAL_SETEXCLUSIVEMODEDATA  ExclusiveData;
    DWORD dwRet;

    // smac: How should lost devices behave?
    CheckForDeviceLost(pSetExclusiveMode->hDD);

    ZeroMemory(&ExclusiveData, sizeof(ExclusiveData));
    ExclusiveData.dwEnterExcl = pSetExclusiveMode->dwEnterExcl;

    dwRet = OsThunkDdSetExclusiveMode(
                DDHANDLE(pSetExclusiveMode->hDD),
                (PDD_SETEXCLUSIVEMODEDATA) &ExclusiveData);

    pSetExclusiveMode->ddRVal = MapLegacyResult(ExclusiveData.ddRVal);

    return dwRet;
}

/*****************************Private*Routine******************************\
* DdFlipToGDISurface
*
* History:
*  22-Apr-1998 -by- John Stephens [johnstep]
* Wrote it.
\**************************************************************************/

#undef DPF_MODNAME
#define DPF_MODNAME "DdFlipToGDISurface"

DWORD
APIENTRY
DdFlipToGDISurface(
    PD3D8_FLIPTOGDISURFACEDATA pFlipToGDISurface
   )
{
    DDHAL_FLIPTOGDISURFACEDATA  FlipData;
    DWORD dwRet;

    // smac: How should lost devices behave?
    CheckForDeviceLost(pFlipToGDISurface->hDD);

    FlipData.dwToGDI = pFlipToGDISurface->dwToGDI;
    FlipData.dwReserved = 0;
    FlipData.ddRVal = E_FAIL;
    dwRet = OsThunkDdFlipToGDISurface(
                DDHANDLE(pFlipToGDISurface->hDD),
                (PDD_FLIPTOGDISURFACEDATA) &FlipData);
    if (DDHAL_DRIVER_HANDLED == dwRet)
        pFlipToGDISurface->ddRVal = FlipData.ddRVal;

    pFlipToGDISurface->ddRVal = MapLegacyResult(pFlipToGDISurface->ddRVal);

    return dwRet;
}

/*****************************Private*Routine******************************\
* DdGetAvailDriverMemory
*
* History:
*  16-Feb-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

#undef DPF_MODNAME
#define DPF_MODNAME "DdGetAvailDriverMemory"

DWORD
APIENTRY
DdGetAvailDriverMemory(
    PD3D8_GETAVAILDRIVERMEMORYDATA pGetAvailDriverMemory
   )
{
    DDHAL_GETAVAILDRIVERMEMORYDATA  MemoryData;
    DWORD dwRet;

    // smac: How should lost devices behave?
    CheckForDeviceLost(pGetAvailDriverMemory->hDD);

    pGetAvailDriverMemory->dwFree = 0;

    // Convert the pool to something that the driver can understand

    memset(&MemoryData, 0, sizeof(MemoryData));
    switch (pGetAvailDriverMemory->Pool)
    {
    case D3DPOOL_LOCALVIDMEM:
        MemoryData.DDSCaps.dwCaps |= DDSCAPS_LOCALVIDMEM | DDSCAPS_VIDEOMEMORY;
        break;
    case D3DPOOL_DEFAULT:
        MemoryData.DDSCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
        break;
    case D3DPOOL_NONLOCALVIDMEM:
        MemoryData.DDSCaps.dwCaps |= DDSCAPS_NONLOCALVIDMEM | DDSCAPS_VIDEOMEMORY;
        break;

    default:
        return DDHAL_DRIVER_HANDLED;
    }

    if (pGetAvailDriverMemory->dwUsage & D3DUSAGE_DEPTHSTENCIL)
    {
        MemoryData.DDSCaps.dwCaps |= DDSCAPS_ZBUFFER;
    }
    if (pGetAvailDriverMemory->dwUsage & D3DUSAGE_RENDERTARGET)
    {
        MemoryData.DDSCaps.dwCaps |= DDSCAPS_TEXTURE | DDSCAPS_3DDEVICE;
    }
    if (pGetAvailDriverMemory->dwUsage & D3DUSAGE_TEXTURE)
    {
        MemoryData.DDSCaps.dwCaps |= DDSCAPS_TEXTURE;
    }

    dwRet = OsThunkDdGetAvailDriverMemory(
                DDHANDLE(pGetAvailDriverMemory->hDD),
                (PDD_GETAVAILDRIVERMEMORYDATA) &MemoryData);

    pGetAvailDriverMemory->dwFree = MemoryData.dwFree;

    return dwRet;
}

/*****************************Private*Routine******************************\
* D3D8QueryDirectDrawObject
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8QueryDirectDrawObject"


BOOL
APIENTRY
D3D8QueryDirectDrawObject(
    HANDLE                      hDD,
    PD3D8_DRIVERCAPS            pDriverCaps,
    PD3D8_CALLBACKS             pCallbacks,
    char*                       pDeviceName,
    HINSTANCE                   hLibrary,
    D3D8_GLOBALDRIVERDATA*      pGblDriverData,
    D3DHAL_D3DEXTENDEDCAPS*     pExtendedCaps,
    LPDDSURFACEDESC             pTextureFormats,
    LPDDPIXELFORMAT             pZStencilFormats,
    UINT*                       pcTextureFormats,
    UINT*                       pcZStencilFormats
   )
{
    PDDDEVICEHANDLE             pDevice = (PDDDEVICEHANDLE) hDD;
    DD_HALINFO                  HalInfo;
    DWORD                       adwCallBackFlags[3];
    DWORD                       dwFlags;
    VIDEOMEMORY*                pVideoMemoryList;
    VIDEOMEMORY*                pVideoMemory;
    DWORD                       dwNumHeaps;
    DWORD                       dwNumFourCC;
    D3DNTHAL_CALLBACKS          D3dCallbacks;
    D3DNTHAL_GLOBALDRIVERDATA   D3dDriverData;
    DD_D3DBUFCALLBACKS          D3dBufferCallbacks;
    DDSCAPSEX                   SurfCapsEx;
    DD_GETDRIVERINFODATA        GetDriverInfoData;
    DWORD                       dwSize;
    DD_MORESURFACECAPS *        pSurfCaps;
    DWORD                       dwRet;
    DWORD                       i;
    DD_MISCELLANEOUSCALLBACKS   MiscCallbacks;
    DD_MISCELLANEOUS2CALLBACKS  Misc2Callbacks;
    D3DNTHAL_CALLBACKS3         D3dCallbacks3;
    D3DDISPLAYMODE              Mode;
    UINT                        MaxZStencilFormats;
    UINT                        MaxTextureFormats;
    
    DDASSERT(pcTextureFormats);
    DDASSERT(pcZStencilFormats);

    MaxTextureFormats = *pcTextureFormats;
    MaxZStencilFormats = *pcZStencilFormats;
    *pcTextureFormats=0;
    *pcZStencilFormats=0;

    // memset the extended caps and global driver data
    ZeroMemory( pExtendedCaps, sizeof( *pExtendedCaps ) );
    ZeroMemory( pGblDriverData, sizeof( *pGblDriverData ) );
    ZeroMemory( &D3dDriverData, sizeof( D3dDriverData ) );

    // smac: How should lost devices behave?
    CheckForDeviceLost(hDD);

    // Get all of the neccesary caps
    // Note: do this memset before the Query, since the caller might (ok will) be
    // using a ptr internal to this struct to hold a reference to the

    memset(pDriverCaps, 0, sizeof(D3D8_DRIVERCAPS));

    // Behavior change: This code used to query for the supported texture format
    // list if the device is not software only and the caller supplied a non-NULL
    // buffer for the supported texture formats. Now, however, we never request
    // texture formats at this point. We only request them if we need to, that
    // is if the driver turns out to be a DirectX 7.0 driver or if it is a
    // DirectX 8.0 driver that doesn't support the new format querying mechanism.
    // This later clause is temporary only. Prior to RTM we will require
    // DirectX 8.0 drivers to support the new format querying mechanism.
    if (!OsThunkDdQueryDirectDrawObject(DDHANDLE(hDD),
                                      &HalInfo,
                                      &adwCallBackFlags[0],
                                      &D3dCallbacks,
                                      &D3dDriverData,
                                      &D3dBufferCallbacks,
                                      NULL,
                                      &dwNumHeaps,
                                      NULL,
                                      &dwNumFourCC,
                                      NULL))
    {
        return(FALSE);
    }
    if ((!(HalInfo.dwFlags & DDHALINFO_GETDRIVERINFO2)) &&
        (!(IS_SOFTWARE_DRIVER(pDevice)))                &&
        (NULL != pTextureFormats))
    {
        // This is not a DirectX 8.0 or higher level driver so query again to get
        // the texture formats (as we know we won't get them through the new DirectX 8.0
        // interfaces).
        if (!OsThunkDdQueryDirectDrawObject(DDHANDLE(hDD),
                                        &HalInfo,
                                        &adwCallBackFlags[0],
                                        &D3dCallbacks,
                                        &D3dDriverData,
                                        &D3dBufferCallbacks,
                                        pTextureFormats,
                                        &dwNumHeaps,
                                        NULL,
                                        &dwNumFourCC,
                                        NULL))
        {
            return(FALSE);
        }
    }

    if (!IS_SOFTWARE_DRIVER(pDevice))
    {
        // Initialize the texture format count from the driver data.
        // However, if this is a DX8 style driver this number will be
        // replaced by a format count reported by the new DX8 mechanism
        // code later in this function.
        *pcTextureFormats = D3dDriverData.dwNumTextureFormats;
    }

    // Display drivers can all render windowed
    if( (HalInfo.dwFlags & DDHALINFO_ISPRIMARYDISPLAY) ||
        IsVGADevice(pDeviceName))
    {
        HalInfo.ddCaps.dwCaps2 |= DDCAPS2_CANRENDERWINDOWED;
    }

    pDriverCaps->D3DCaps.Caps         = HalInfo.ddCaps.dwCaps;
    pDriverCaps->D3DCaps.Caps2        = HalInfo.ddCaps.dwCaps2;
    pDriverCaps->D3DCaps.Caps3        = HalInfo.ddCaps.dwSVCaps;
    pDriverCaps->SVBCaps              = HalInfo.ddCaps.dwSVBCaps;
    pDriverCaps->VSBCaps              = HalInfo.ddCaps.dwVSBCaps;
    pDriverCaps->SVBCaps2             = HalInfo.ddCaps.dwSVBCaps2;

    pDevice->DisplayPitch = HalInfo.vmiData.lDisplayPitch;

    // Get the extended surface caps

    SurfCapsEx.dwCaps2 = 0;
    SurfCapsEx.dwCaps3 = 0;
    SurfCapsEx.dwCaps4 = 0;

    memset(&GetDriverInfoData, 0, sizeof(GetDriverInfoData));
    GetDriverInfoData.dwSize = sizeof(GetDriverInfoData);

    GetDriverInfoData.guidInfo = GUID_DDMoreSurfaceCaps;
    dwSize = sizeof(DD_MORESURFACECAPS) + ((dwNumHeaps ? dwNumHeaps - 1 : 0) * sizeof(DDSCAPSEX) * 2);
    pSurfCaps = (DD_MORESURFACECAPS*) MemAlloc(dwSize);
    GetDriverInfoData.ddRVal = E_FAIL;
    if (pSurfCaps != NULL)
    {
        pSurfCaps->dwSize = dwSize;
        GetDriverInfoData.dwExpectedSize = dwSize;
        GetDriverInfoData.lpvData        = pSurfCaps;

        dwRet = OsThunkDdGetDriverInfo(DDHANDLE(hDD), &GetDriverInfoData);
        if ((dwRet == DDHAL_DRIVER_HANDLED) &&
            (GetDriverInfoData.ddRVal == S_OK))
        {
            SurfCapsEx = pSurfCaps->ddsCapsMore;
        }
        MemFree(pSurfCaps);
    }

    // If the driver supports the "GetDriverInfo2" usage of GetDriverInfo then
    // use that now to get the D3DCAPS8.
    if ((HalInfo.dwFlags & DDHALINFO_GETDRIVERINFO2) &&
        !IS_SOFTWARE_DRIVER(pDevice))
    {
        // This buffer is used to pass information down to the driver and get
        // information back from the driver. The GetDriverInfo2 header and
        // any additional information to pass to the driver is copied into this
        // buffer prior to calling GetDriverInfo2. After the call the information
        // returned by the driver is contained in this buffer. All information
        // passed to and from the driver must fit within a buffer of this size.
        DWORD                  buffer[MAX_GDI2_BUFFER_DWORD_SIZE];
        DD_GETDRIVERINFO2DATA* pgdi2;
        DD_GETFORMATCOUNTDATA* pgfcd;
        DD_GETFORMATDATA*      pgfd;
        DD_DXVERSION*          pDXVersion;
        int                    i;
        
        // Set up the DXVersion call
        memset(&buffer, 0, sizeof(buffer));
        pDXVersion = (DD_DXVERSION *)buffer;

        // Before we do anything else, we notify the
        // driver about the DX version information. We ignore
        // errors here.
        pDXVersion->gdi2.dwReserved     = sizeof(DD_STEREOMODE);
        pDXVersion->gdi2.dwMagic        = D3DGDI2_MAGIC;
        pDXVersion->gdi2.dwType         = D3DGDI2_TYPE_DXVERSION;
        pDXVersion->gdi2.dwExpectedSize = sizeof(DD_DXVERSION);
        pDXVersion->dwDXVersion         = DD_RUNTIME_VERSION;
        
        memset(&GetDriverInfoData, 0, sizeof(GetDriverInfoData));
        GetDriverInfoData.dwSize         = sizeof(GetDriverInfoData);
        GetDriverInfoData.guidInfo       = GUID_GetDriverInfo2;
        GetDriverInfoData.lpvData        = &buffer;
        GetDriverInfoData.dwExpectedSize = sizeof(DD_STEREOMODE);
        dwRet = OsThunkDdGetDriverInfo(DDHANDLE(hDD), &GetDriverInfoData);
        if (dwRet != DDHAL_DRIVER_HANDLED       || 
            GetDriverInfoData.ddRVal != S_OK)
        {
            // Errors are ignored here
            dwRet = DDHAL_DRIVER_HANDLED;
        }

        memset(&buffer, 0, sizeof(buffer));

        pgdi2 = (DD_GETDRIVERINFO2DATA*)&buffer;

        // sizeof(DD_STEREOMODE)? The GUID for GetDriverInfo2 is shared with
        // the stereo mode querying stuff. Therefore we need to pass down
        // the structure size (and the expected data size) as
        // sizeof(DD_STEREOMODE) even though we actually have a buffer (and
        // expect a size of sizeof(D3DCAPS8).
        pgdi2->dwReserved     = sizeof(DD_STEREOMODE);
        pgdi2->dwMagic        = D3DGDI2_MAGIC;
        pgdi2->dwType         = D3DGDI2_TYPE_GETD3DCAPS8;
        pgdi2->dwExpectedSize = sizeof(D3DCAPS8);

        memset(&GetDriverInfoData, 0, sizeof(GetDriverInfoData));
        GetDriverInfoData.dwSize         = sizeof(GetDriverInfoData);
        GetDriverInfoData.guidInfo       = GUID_GetDriverInfo2;
        GetDriverInfoData.lpvData        = &buffer;
        GetDriverInfoData.dwExpectedSize = sizeof(DD_STEREOMODE);
        dwRet = OsThunkDdGetDriverInfo(DDHANDLE(hDD), &GetDriverInfoData);
        if ((dwRet == DDHAL_DRIVER_HANDLED) && (GetDriverInfoData.ddRVal == S_OK))
        {
            // Looks like we got D3DCAPS8 back from the driver. Verify by means
            // of the dwActualSize field in GetDriverInfoData.
            if (sizeof(D3DCAPS8) != GetDriverInfoData.dwActualSize)
            {
                DPF(0, "Driver returned an data structure of incorrect size (!= sizeof(D3DCAPS8))");
                return(FALSE);
            }

            // All went well. Copy the caps data across
            memcpy(&pDriverCaps->D3DCaps, &buffer, sizeof(D3DCAPS8));

            // Drivers may not set the ddraw caps correctly, or they might not update them
            // across mode changes, so use the caps that we already have.
            pDriverCaps->D3DCaps.Caps = HalInfo.ddCaps.dwCaps;

            // Display drivers can all render windowed
            if( (HalInfo.dwFlags & DDHALINFO_ISPRIMARYDISPLAY) ||
                IsVGADevice(pDeviceName))
            {
                pDriverCaps->D3DCaps.Caps2 |= DDCAPS2_CANRENDERWINDOWED;
            }

            // Set the flag indicating that the DDI successfully reported DX8
            // style caps
            pDriverCaps->dwFlags |= DDIFLAG_D3DCAPS8;

            // See device can do sub volume lock for volume texture.
            if (pDriverCaps->D3DCaps.DevCaps & D3DDEVCAPS_SUBVOLUMELOCK)
            {
                pDevice->dwFlags |= DDDEVICE_SUPPORTSUBVOLUMELOCK;
            }
        }

        // If this is a DX8 driver it needs to report it supported texture formats to us
        // using GetDriverInfo2. This is done in two stages, one query to determine the
        // number of supported formats, and one to actually retrieve those formats
        // iteratively.

        // Step 1: Get the number of supported formats
        // Please see the description comments above for a description of why the
        // reserved field is set to sizeof(DD_STEREOMODE)
        memset(&buffer, 0, sizeof(buffer));

        pgfcd = (DD_GETFORMATCOUNTDATA*)&buffer;

        pgfcd->gdi2.dwReserved     = sizeof(DD_STEREOMODE);
        pgfcd->gdi2.dwMagic        = D3DGDI2_MAGIC;
        pgfcd->gdi2.dwType         = D3DGDI2_TYPE_GETFORMATCOUNT;
        pgfcd->gdi2.dwExpectedSize = sizeof(DD_GETFORMATCOUNTDATA);

        #if DBG
            // Ensure the driver actually sets the format count if it succeeds this call
            pgfcd->dwFormatCount    = BOGUS_FIELD_VALUE;
        #endif // DBG

        memset(&GetDriverInfoData, 0, sizeof(GetDriverInfoData));
        GetDriverInfoData.dwSize         = sizeof(GetDriverInfoData);
        GetDriverInfoData.guidInfo       = GUID_GetDriverInfo2;
        GetDriverInfoData.lpvData        = &buffer;
        GetDriverInfoData.dwExpectedSize = sizeof(DD_STEREOMODE);
        dwRet = OsThunkDdGetDriverInfo(DDHANDLE(hDD), &GetDriverInfoData);
        if ((dwRet == DDHAL_DRIVER_HANDLED) && (GetDriverInfoData.ddRVal == S_OK))
        {
            // Looks like we got a DD_GETFORMATCOUNTDATA back from the driver. Verify by means
            // of the dwActualSize field in GetDriverInfoData.
            if (sizeof(DD_GETFORMATCOUNTDATA) != GetDriverInfoData.dwActualSize)
            {
                DPF(0, "Driver returned an data structure of incorrect size (!= sizeof(DD_GETFORMATCOUNTDATA))");
                return(FALSE);
            }

            #ifdef DBG
                if (BOGUS_FIELD_VALUE == ((DD_GETFORMATCOUNTDATA*)&buffer)->dwFormatCount)
                {
                    DPF_ERR( "Driver succeeded GETFORMATCOUNT request but didn't set dwFormatCount. Driver error." );
                    return(FALSE);
                }
            #endif // DBG

            // All went well. Replace the number of supported texture formats the driver
            // reported to us with this new number. We don't use the legacy texture format
            // list if this new mechanism is supported
            
            *pcTextureFormats = ((DD_GETFORMATCOUNTDATA*)&buffer)->dwFormatCount;

            // Step2: Query for each of the surface formats in turn.
            // We only do this if the caller requested that we do by means of a non-NULL
            // texture format buffer
            if (NULL != pTextureFormats)
            {
                DWORD          c;
                DDSURFACEDESC* pOutFormat;

                // For simplicities sake we ask for a single format at a time. Not exactly
                // high-performance but this should not matter at this stage of the code.
                pOutFormat = pTextureFormats;
                *pcTextureFormats = min(MaxTextureFormats, *pcTextureFormats);
                for (c = 0; c < (*pcTextureFormats); ++c)
                {
                    // We reinitialize the entire request each time. We could probably
                    // optimize this but it doesn't seem worth it.
                    memset(&buffer, 0, sizeof(DD_GETFORMATDATA));

                    pgfd = (DD_GETFORMATDATA*)&buffer;

                    pgfd->gdi2.dwReserved     = sizeof(DD_STEREOMODE);
                    pgfd->gdi2.dwMagic        = D3DGDI2_MAGIC;
                    pgfd->gdi2.dwType         = D3DGDI2_TYPE_GETFORMAT;
                    pgfd->gdi2.dwExpectedSize = sizeof(DD_GETFORMATDATA);
                    pgfd->dwFormatIndex        = c;
                    #if DBG
                        // Ensure the driver actually sets the format count if it succeeds this call
                        pgfd->format.dwSize    = BOGUS_FIELD_VALUE;
                    #endif // DBG
 
                    memset(&GetDriverInfoData, 0, sizeof(GetDriverInfoData));
                    GetDriverInfoData.dwSize         = sizeof(GetDriverInfoData);
                    GetDriverInfoData.guidInfo       = GUID_GetDriverInfo2;
                    GetDriverInfoData.lpvData        = &buffer;
                    GetDriverInfoData.dwExpectedSize = sizeof(DD_STEREOMODE);
                    dwRet = OsThunkDdGetDriverInfo(DDHANDLE(hDD), &GetDriverInfoData);
                    if ((dwRet == DDHAL_DRIVER_HANDLED) && (GetDriverInfoData.ddRVal == S_OK))
                    {
                        // Looks like we got a DD_GETFORMATDATA back from the driver. Verify by means
                        // of the dwActualSize field in GetDriverInfoData.
                        if (sizeof(DD_GETFORMATDATA) != GetDriverInfoData.dwActualSize)
                        {
                            DPF(0, "Driver returned an data structure of incorrect size (!= sizeof(DD_GETFORMATDATA))");
                            return(FALSE);
                        }

                        DDASSERT(c == ((DD_GETFORMATDATA*)&buffer)->dwFormatIndex);

                        #ifdef DBG
                            if (BOGUS_FIELD_VALUE == (((DD_GETFORMATDATA*)&buffer)->format).dwSize)
                            {
                                DPF_ERR( "Driver succeeded GETFORMAT request but didn't set format. Driver error." );
                                return(FALSE);
                            }
                        #endif // DBG

                        // Looks like all went well. Initialize the surface description part of the format
                        // list and copy the pixel format we got from the driver across.
                        memset(pOutFormat, 0, sizeof(DDSURFACEDESC));
                        pOutFormat->dwSize  = sizeof(DDSURFACEDESC);
                        pOutFormat->dwFlags = DDSD_PIXELFORMAT;
                        memcpy(&pOutFormat->ddpfPixelFormat, &(((DD_GETFORMATDATA*)&buffer)->format), sizeof(DDPIXELFORMAT));

                        ++pOutFormat;
                    }
                }
            }
        }
        else
        {
            DPF(0, "Driver claims DX8 but fails call to GETFORMATCOUNT"             );
            DPF(0, "DX7 texture format list will be used but this will change soon" );
            DPF(0, "Fix driver to support DX8 style surface format reporting now"   );

            // This is a DirectX 8.0 level driver but it doesn't appear to support the
            // new DirectX 8.0 style format querying mechanism so query the kernel
            // again for the DirectX 7.0 style capabilities and use them instead.
            // Note, this is a temporary measure only, prior to the RTM of DirectX 8.0
            // this fallback will be removed and drivers will be required to support
            // the new DirectX 8.0 style format reporting mechanism
            if ((!IS_SOFTWARE_DRIVER(pDevice)) && (NULL != pTextureFormats))
            {
                if (!OsThunkDdQueryDirectDrawObject(DDHANDLE(hDD),
                        &HalInfo,
                        &adwCallBackFlags[0],
                        &D3dCallbacks,
                        &D3dDriverData,
                        &D3dBufferCallbacks,
                        pTextureFormats,
                        &dwNumHeaps,
                        NULL,
                        &dwNumFourCC,
                        NULL))
                {
                    return(FALSE);
                }
            }
        }
    }
    else if (D3dCallbacks.dwSize != 0 && D3dDriverData.dwSize != 0)
    {
        pGblDriverData->dwSize = D3dDriverData.dwSize;
        
        //watcha gonna do:
        DDASSERT(sizeof(pGblDriverData->hwCaps) == sizeof(D3dDriverData.hwCaps));
        memcpy(&pGblDriverData->hwCaps, &D3dDriverData.hwCaps, sizeof(pGblDriverData->hwCaps));
        
        pGblDriverData->dwNumVertices = D3dDriverData.dwNumVertices;
        pGblDriverData->dwNumClipVertices = D3dDriverData.dwNumClipVertices;
        
        // Get the D3D extended caps
        
        GetDriverInfoData.guidInfo       = GUID_D3DExtendedCaps;
        GetDriverInfoData.ddRVal         = E_FAIL;
        GetDriverInfoData.dwExpectedSize = sizeof(D3DHAL_D3DEXTENDEDCAPS);
        GetDriverInfoData.lpvData        = pExtendedCaps;
        dwRet = OsThunkDdGetDriverInfo(DDHANDLE(hDD), &GetDriverInfoData);
        if ((dwRet != DDHAL_DRIVER_HANDLED) ||
            (GetDriverInfoData.ddRVal != S_OK))
        {
            DPF_ERR( "Get EXTENDEDCAPS from the driver failed" );
            return FALSE;
        }
    }

    // Get the supported Z formats.  We only do this if we are not using a
    // software driver

    if (!IS_SOFTWARE_DRIVER(pDevice))
    {
        DWORD tempbuf[249];  // make this <1K bytes or GetDriverInfo() fails cuz it cant do its "expected size overwrite" test within its own 1K tempbuffer

        GetDriverInfoData.guidInfo       = GUID_ZPixelFormats;
        GetDriverInfoData.ddRVal         = E_FAIL;
        GetDriverInfoData.dwExpectedSize = sizeof(tempbuf);
        GetDriverInfoData.lpvData        = tempbuf;
        dwRet = OsThunkDdGetDriverInfo(DDHANDLE(hDD), &GetDriverInfoData);

        if ((dwRet != DDHAL_DRIVER_HANDLED) ||
            (GetDriverInfoData.ddRVal != S_OK) ||
            ((GetDriverInfoData.dwActualSize-sizeof(DWORD)) % sizeof(DDPIXELFORMAT) != 0) ||
            ((tempbuf[0]*sizeof(DDPIXELFORMAT)+sizeof(DWORD))>sizeof(tempbuf)))

        {
            // It could be that this is an old driver that doesn't support
            // stencil.  We might be able to get some info from the global
            // driver data.

            if (pGblDriverData->hwCaps.dwDeviceZBufferBitDepth & DDBD_16)
            {
                (*pcZStencilFormats)++;
                if (pZStencilFormats && 
                    (*pcZStencilFormats <= MaxZStencilFormats))
                {
                    pZStencilFormats->dwSize = sizeof(DDPIXELFORMAT);
                    pZStencilFormats->dwFlags = DDPF_ZBUFFER;
                    pZStencilFormats->dwZBufferBitDepth = 16;
                    pZStencilFormats->dwStencilBitDepth = 0;
                    pZStencilFormats->dwZBitMask = 0xffff;
                    pZStencilFormats->dwStencilBitMask = 0x0000;
                    pZStencilFormats++;
                }
            }
            if (pGblDriverData->hwCaps.dwDeviceZBufferBitDepth & DDBD_32)
            {
                (*pcZStencilFormats)++;
                if (pZStencilFormats &&
                    (*pcZStencilFormats <= MaxZStencilFormats))
                {
                    pZStencilFormats->dwSize = sizeof(DDPIXELFORMAT);
                    pZStencilFormats->dwFlags = DDPF_ZBUFFER;
                    pZStencilFormats->dwZBufferBitDepth = 32;
                    pZStencilFormats->dwStencilBitDepth = 0;
                    pZStencilFormats->dwZBitMask = 0xffffffff;
                    pZStencilFormats->dwStencilBitMask = 0x00000000;
                    pZStencilFormats++;
                }
            }
        }
        else
        {
            //We have a GetDriverInfo response to our Z format query. These are
            //DDPIXELFORMATs that we can copy back to our caller
            (*pcZStencilFormats) = tempbuf[0];
            if(pZStencilFormats)
            {
                MaxZStencilFormats = min(MaxZStencilFormats, tempbuf[0]);
                memcpy(pZStencilFormats, &tempbuf[1], MaxZStencilFormats * sizeof(DDPIXELFORMAT));
            }
        }
    }

    // Get info about the current mode

    D3D8GetMode (NULL, pDeviceName, &Mode, 0);

    pDevice->DisplayFormatWithAlpha = Mode.Format;
    pDevice->DisplayFormatWithoutAlpha = Mode.Format;
    if (Mode.Format == D3DFMT_X8R8G8B8)
    {
        if (HalInfo.vmiData.ddpfDisplay.dwFlags & DDPF_ALPHAPIXELS)
        {
            pDevice->DisplayFormatWithAlpha = D3DFMT_A8R8G8B8;
        }
    }
    if (Mode.Format == D3DFMT_X1R5G5B5)
    {
        if (HalInfo.vmiData.ddpfDisplay.dwFlags & DDPF_ALPHAPIXELS)
        {
            pDevice->DisplayFormatWithAlpha = D3DFMT_A1R5G5B5;
        }
    }

    pDriverCaps->DisplayWidth               = Mode.Width;
    pDriverCaps->DisplayHeight              = Mode.Height;
    pDriverCaps->DisplayFrequency           = Mode.RefreshRate;
    pDriverCaps->DisplayFormatWithoutAlpha  = Mode.Format;
    pDriverCaps->DisplayFormatWithAlpha     = pDevice->DisplayFormatWithAlpha;


    // Get the Miscellaneous callbacks
    GetDriverInfoData.guidInfo       = GUID_MiscellaneousCallbacks;
    GetDriverInfoData.ddRVal         = E_FAIL;
    GetDriverInfoData.dwExpectedSize = sizeof(DD_MISCELLANEOUSCALLBACKS);
    GetDriverInfoData.lpvData        = &MiscCallbacks;
    dwRet = OsThunkDdGetDriverInfo(DDHANDLE(hDD), &GetDriverInfoData);
    if ((dwRet != DDHAL_DRIVER_HANDLED) ||
        (GetDriverInfoData.ddRVal != S_OK))
    {
        memset (&MiscCallbacks, 0, sizeof(DD_MISCELLANEOUSCALLBACKS));
    }

    // Get the Miscellaneous2 callbacks
    GetDriverInfoData.guidInfo       = GUID_Miscellaneous2Callbacks;
    GetDriverInfoData.ddRVal         = E_FAIL;
    GetDriverInfoData.dwExpectedSize = sizeof(DD_MISCELLANEOUS2CALLBACKS);
    GetDriverInfoData.lpvData        = &Misc2Callbacks;
    dwRet = OsThunkDdGetDriverInfo(DDHANDLE(hDD), &GetDriverInfoData);
    if ((dwRet != DDHAL_DRIVER_HANDLED) ||
        (GetDriverInfoData.ddRVal != S_OK))
    {
        memset (&Misc2Callbacks, 0, sizeof(DD_MISCELLANEOUS2CALLBACKS));
    }

    // Get the D3Dcallbacks3 callbacks
    GetDriverInfoData.guidInfo       = GUID_D3DCallbacks3;
    GetDriverInfoData.ddRVal         = E_FAIL;
    GetDriverInfoData.dwExpectedSize = sizeof(D3DNTHAL_CALLBACKS3);
    GetDriverInfoData.lpvData        = &D3dCallbacks3;
    dwRet = OsThunkDdGetDriverInfo(DDHANDLE(hDD), &GetDriverInfoData);
    if ((dwRet != DDHAL_DRIVER_HANDLED) ||
        (GetDriverInfoData.ddRVal != S_OK))
    {
        memset (&D3dCallbacks3, 0, sizeof(D3DNTHAL_CALLBACKS3));
    }

    // Fill in the D3D8 Callback table
    RtlZeroMemory(pCallbacks, sizeof(*pCallbacks));
    pCallbacks->CreateSurface           = DdCreateSurface;
    pCallbacks->DestroySurface          = DdDestroySurface;
    pCallbacks->Lock                    = DdLock;
    pCallbacks->Unlock                  = DdUnlock;
    pCallbacks->Blt                     = DdBlt;
    pCallbacks->GetScanLine             = DdGetScanLine;
    pCallbacks->Flip                    = DdFlip;
    pCallbacks->WaitForVerticalBlank    = DdWaitForVerticalBlank;
    pCallbacks->GetBltStatus            = DdGetBltStatus;
    pCallbacks->GetFlipStatus           = DdGetFlipStatus;
    pCallbacks->SetMode                 = DdSetMode;
    pCallbacks->FlipToGDISurface        = DdFlipToGDISurface;
    pCallbacks->SetExclusiveMode        = DdSetExclusiveMode;
    pCallbacks->GetAvailDriverMemory    = DdGetAvailDriverMemory;

    if (D3dCallbacks.ContextCreate != NULL)
    {
        pCallbacks->CreateContext   = D3dContextCreate;
    }
    if (D3dCallbacks.ContextDestroy != NULL)
    {
        pCallbacks->ContextDestroy = D3dContextDestroy;
    }
    if (D3dCallbacks.ContextDestroyAll != NULL)
    {
        pCallbacks->ContextDestroyAll = D3dContextDestroyAll;
    }
    if (Misc2Callbacks.GetDriverState)
    {
        pCallbacks->GetDriverState = DdGetDriverState;
    }
    if (D3dCallbacks3.ValidateTextureStageState != NULL)
    {
        pCallbacks->ValidateTextureStageState = D3dValidateTextureStageState;
    }
    if (D3dCallbacks3.DrawPrimitives2 != NULL)
    {
        pCallbacks->DrawPrimitives2 = D3dDrawPrimitives2;
    }
    if (HalInfo.dwFlags & DDHALINFO_GETDRIVERINFO2)
    {
        pDevice->dwFlags |= DDDEVICE_GETDRIVERINFO2;
        if (!(pDevice->dwFlags & DDDEVICE_INITIALIZED))
        {
            // Since this is the first time we have seen this device, we need
            // to tell the driver that the runtime will send the propoer AGP
            // notification.
            InformDriverAGPWorkaroundAware((HANDLE) pDevice);
        }
    }
    pDevice->dwFlags |= DDDEVICE_INITIALIZED;

    if (FAILED(GetNTDeviceRect(pDeviceName,&pDevice->rcMonitor)))
    {
        SetRect(&pDevice->rcMonitor,0,0,
            GetSystemMetrics(SM_CXSCREEN),GetSystemMetrics(SM_CYSCREEN));
    }

    // What about HW cursor support? check Must be done before SoftwareRast
    // Caps Overrides

    if (0 == pDriverCaps->D3DCaps.MaxStreams)
    {
        // The hardware driver is DX7
        if (CanKnownDriverDoThis(pDevice, KNOWN_HWCURSOR))
        {
            pDriverCaps->D3DCaps.CursorCaps = D3DCURSORCAPS_COLOR; 
            pDriverCaps->KnownDriverFlags |= KNOWN_HWCURSOR;
            if (CanKnownDriverDoThis(pDevice, KNOWN_HWCURSORLOWRES))
            {
                pDriverCaps->D3DCaps.CursorCaps |= D3DCURSORCAPS_LOWRES; 
                pDriverCaps->KnownDriverFlags |= KNOWN_HWCURSORLOWRES;
            }
        }
    }
    // need to save a HAL copy in thunklayer, for example DdBlt needs caps
    pDevice->DDCaps = pDriverCaps->D3DCaps.Caps;
    pDevice->SVBCaps = pDriverCaps->SVBCaps;

    // If Refrast or the HEL has a hook, call it to let it change whatever it wants

    if (IS_SOFTWARE_DRIVER(pDevice))
    {
        *pcZStencilFormats = 0;

        SwDDIMungeCaps (
            hLibrary,
            hDD,
            pDriverCaps,
            pCallbacks,
            pTextureFormats,
            pcTextureFormats,
            pDevice->pSwInitFunction
            );
    }

    pDevice->DriverLevel = 0;
    if (pDriverCaps->D3DCaps.MaxStreams != 0)
    {
        pDevice->DriverLevel = 8;
    }
    else if (pCallbacks->DrawPrimitives2 != NULL)
    {
        pDevice->DriverLevel = 7;
    }

    // Determine what version of windows is running so we can know
    // what lock parameters to send.  Whistler is version 5.1.

    pDevice->bIsWhistler = IsWhistler();

    // If it's a pre-dx8 driver and they support cubemaps, we need to
    // specify whether they support mipped cubemaps or not.
    
    if (pDevice->DriverLevel < 8)
    {
        if (CanKnownDriverDoThis(pDevice, KNOWN_MIPPEDCUBEMAPS))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_MIPPEDCUBEMAPS;
        }

        // Does this driver have a Z/Stencil depth restriction?
        if (CanKnownDriverDoThis(pDevice, KNOWN_ZSTENCILDEPTH))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_ZSTENCILDEPTH;
        }

        // Does device have no driver known to over-queue windowed presentation blts?
        if (CanKnownDriverDoThis(pDevice, KNOWN_NOTAWINDOWEDBLTQUEUER))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_NOTAWINDOWEDBLTQUEUER;
        }

        // Does device support D3DFMT_D16_LOCKABLE
        if (CanKnownDriverDoThis(pDevice, KNOWN_D16_LOCKABLE))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_D16_LOCKABLE;
        }

        // Figure out what RT/Texture formats it supports
        if (CanKnownDriverDoThis(pDevice, KNOWN_CANMISMATCHRT))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_CANMISMATCHRT;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_X1R5G5B5))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_X1R5G5B5;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_R5G6B5))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_R5G6B5;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_X8R8G8B8))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_X8R8G8B8;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_A8R8G8B8))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_A8R8G8B8;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_A1R5G5B5))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_A1R5G5B5;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_A4R4G4B4))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_A4R4G4B4;
        }
    }

    if (NULL != HalInfo.lpD3DBufCallbacks )
    {
        pDevice->dwFlags |= DDDEVICE_SUPPORTD3DBUF;
    }
    else
    {
        pDevice->dwFlags &= ~DDDEVICE_SUPPORTD3DBUF;
    }
    return(TRUE);
}

//
// See NT bug 448720...
//
// AGP surfaces will be unlocked by the kernel mode in response to mode switches.
// App may still be writing to surface.
// Driver should therefore defer free of AGP memory until later.
// "Later" is defined as when the usermode determines the app is done writing and can tell
// the driver so.
//
// Drivers need to know that the runtime can do this so they can turn off any other workarounds
// they might have.
//

/*****************************Private*Routine******************************\
* GetDriverInfo2
*
* History:
*  06-Nov-2001  maxmcm      Wrote it
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "GetDriverInfo2"

DWORD
APIENTRY
GetDriverInfo2(
    DWORD* pdwDrvRet,
    HANDLE hDriver,
    DWORD dwType,
    DWORD dwSize,
    void* pBuffer)
{
    DD_GETDRIVERINFO2DATA*          pGDI2Data;
    DD_GETDRIVERINFODATA            GetDriverInfoData;
    DWORD                           dwRet;
    PDDDEVICEHANDLE                 pDevice;

    // In some cases (e.g. ProfileAdapter), it is possible that we can get
    // here with a NULL device, so we should check for that.
    pDevice = (PDDDEVICEHANDLE) hDriver;
    if (pDevice == NULL)
    {
        *pdwDrvRet = E_FAIL;
        return DDHAL_DRIVER_HANDLED;
    }

    // Don't call the driver if they don't support GETDRIVERINFO2
    if (!(pDevice->dwFlags & DDDEVICE_GETDRIVERINFO2))
    {
        *pdwDrvRet = E_FAIL;
        return DDHAL_DRIVER_HANDLED;
    }
       
    // Setup GetDriverInfo2 call
    pGDI2Data = (DD_GETDRIVERINFO2DATA*) pBuffer;

    memset(pGDI2Data, 0, sizeof(*pGDI2Data));
    pGDI2Data->dwReserved       = sizeof(DD_STEREOMODE);
    pGDI2Data->dwMagic          = D3DGDI2_MAGIC;
    pGDI2Data->dwType           = dwType;
    pGDI2Data->dwExpectedSize   = dwSize;

    memset(&GetDriverInfoData, 0, sizeof(GetDriverInfoData));
    GetDriverInfoData.dwSize         = sizeof(GetDriverInfoData);
    GetDriverInfoData.guidInfo       = GUID_GetDriverInfo2;
    GetDriverInfoData.lpvData        = pGDI2Data;
    GetDriverInfoData.dwExpectedSize = sizeof(DD_STEREOMODE);

    // Ask the driver for information
    dwRet = OsThunkDdGetDriverInfo(DDHANDLE(pDevice), &GetDriverInfoData);

    *pdwDrvRet = GetDriverInfoData.ddRVal;
    return dwRet;
}


void InformDriverAGPWorkaroundAware(HANDLE hDD)
{
    DDNT_DEFERRED_AGP_AWARE_DATA  aad;
    DWORD                       dwDrvRet;
    DWORD                       dwGDI2Ret;

    dwGDI2Ret = GetDriverInfo2(&dwDrvRet, hDD,
                                   _NT_D3DGDI2_TYPE_DEFERRED_AGP_AWARE,
                                   sizeof(aad), &aad);

    //drop the return code on the floor.... just a notification
}

void InformDriverFreeAGP(HANDLE hDD)
{
    DDNT_FREE_DEFERRED_AGP_DATA   fad;
    DWORD                       dwDrvRet;
    DWORD                       dwGDI2Ret;

    fad.dwProcessId = GetCurrentProcessId();

    dwGDI2Ret = GetDriverInfo2(&dwDrvRet, hDD,
                                   _NT_D3DGDI2_TYPE_FREE_DEFERRED_AGP,
                                   sizeof(fad), &fad);

    //drop the return code on the floor.... just a notification
}

void InformDriverToDeferFrees(HANDLE hDD)
{
    DDNT_FREE_DEFERRED_AGP_DATA   fad;
    DWORD                       dwDrvRet;
    DWORD                       dwGDI2Ret;

    fad.dwProcessId = GetCurrentProcessId();

    dwGDI2Ret = GetDriverInfo2(&dwDrvRet, hDD,
                                   _NT_D3DGDI2_TYPE_DEFER_AGP_FREES,
                                   sizeof(fad), &fad);

    //drop the return code on the floor.... just a notification
}

/*****************************Private*Routine******************************\
* D3D8CreateDirectDrawObject
*
* Calls GDI32 to get the global DirectDraw handle.
*
* History:
*  16-Nov-1999 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8CreateDirectDrawObject"

VOID
APIENTRY
D3D8CreateDirectDrawObject(
    HDC             hdc,
    char*           szDeviceName,
    HANDLE*         phDD,
    D3DDEVTYPE      Type,
    HINSTANCE*      phLibrary,
    VOID*           pInitFunction
   )
{
    DDRAWI_DIRECTDRAW_GBL   ddg;
    PDDDEVICEHANDLE         pDeviceHandle;
    HKEY                    hKey = (HKEY) NULL;

    *phDD = NULL;
    ddg.hDD = 0;
    pDeviceHandle = NULL;
    DdCreateDirectDrawObject (&ddg, hdc);

    if (ddg.hDD != 0)
    {
        pDeviceHandle = MemAlloc (sizeof(DDDEVICEHANDLE));
        if (pDeviceHandle != NULL)
        {
            pDeviceHandle->hDD = (HANDLE)ddg.hDD;
            *phDD = (HANDLE) pDeviceHandle;
            lstrcpy (pDeviceHandle->szDeviceName, szDeviceName);
            pDeviceHandle->DisplayUniqueness =
                DdQueryDisplaySettingsUniqueness();
            pDeviceHandle->hLastWnd = NULL;
            pDeviceHandle->pClipList = NULL;
            pDeviceHandle->pOrigClipList = NULL;
            *phLibrary = NULL;
            pDeviceHandle->DeviceType = Type;
            if (Type == D3DDEVTYPE_REF)
            {
                *phLibrary = LoadLibrary (D3D8_REFRASTNAME);
                pDeviceHandle->pDD = SwDDICreateDirectDraw();
                if (pDeviceHandle->pDD == NULL)
                {
                    *phDD = NULL;
                }
                else
                {
                    pDeviceHandle->hLibrary = *phLibrary;
                }
            }
            else if (Type == D3DDEVTYPE_SW)
            {
                pDeviceHandle->pDD = SwDDICreateDirectDraw();
                if (pDeviceHandle->pDD == NULL)
                {
                    *phDD = NULL;
                }
                else
                {
                    pDeviceHandle->pSwInitFunction = pInitFunction;
                }
            }
        }
    }

    if (*phDD == NULL)
    {
        if (pDeviceHandle)
        {
            MemFree (pDeviceHandle);
        }

        if (ddg.hDD != 0)
        {
            OsThunkDdDeleteDirectDrawObject((HANDLE) ddg.hDD);
        }
    }
    else
    {
        // See if they want to explicitly enable/disable driver behavior
        if (!RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey))
        {
            DWORD   type;
            DWORD   value;
            DWORD   cb = sizeof(value);

            pDeviceHandle->ForceFlagsOn = 0;
            pDeviceHandle->ForceFlagsOff = 0;
#ifdef DEBUG
            if (!RegQueryValueEx(hKey, "ForceDriverFlagsOn", NULL, &type, (CONST LPBYTE)&value, &cb))
            {
                pDeviceHandle->ForceFlagsOn = value;
            }
            cb = sizeof(value);
#endif
            if (!RegQueryValueEx(hKey, "ForceDriverFlagsOff", NULL, &type, (CONST LPBYTE)&value, &cb))
            {
                pDeviceHandle->ForceFlagsOff = value;
            }
            RegCloseKey(hKey);
        }
        NumDevices++;
    }
}

/*****************************Private*Routine******************************\
* D3D8DeleteDirectDrawObject
*
* Note that all associated surface objects must be deleted before the
* DirectDrawObject can be deleted.
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8DeleteDirectDrawObject"

VOID
APIENTRY
D3D8DeleteDirectDrawObject(
    HANDLE hDD
   )
{
    PDDDEVICEHANDLE pHandle = (PDDDEVICEHANDLE) hDD;
    PDEFERREDCREATE pTemp;

    NumDevices--;
    if (pHandle!= NULL)
    {
        PDEFERREDCREATE pDefCreate = pHandle->pDeferList;

        OsThunkDdDeleteDirectDrawObject(DDHANDLE(hDD));
        if (NULL != pHandle->SurfaceHandleList.dwList)
        {
            MemFree(pHandle->SurfaceHandleList.dwList);
        }
        if (NULL != pHandle->pDD)
        {
            if ( NULL != pHandle->pDD->lpGbl->lpDDCBtmp)
            {
                MemFree(pHandle->pDD->lpGbl->lpDDCBtmp);
            }
            MemFree(pHandle->pDD);
        }
        if (NULL != pHandle->pClipList)
        {
            MemFree(pHandle->pClipList);
        }
        if (NULL != pHandle->pOrigClipList)
        {
            MemFree(pHandle->pOrigClipList);
        }
#ifdef DEBUG
        // In debug print the types of objects
        // that weren't released
        if (pHandle->pSurfList != NULL)
        {
            PDDSURFHANDLE pSurf = pHandle->pSurfList;
            DPF_ERR("Not all objects were freed: the following indicate "
                    "the types of unfreed objects.");
            while (pSurf)
            {
                DebugPrintSurfaceInfo(pSurf);
                pSurf = pSurf->pNext;
            }
        }
#endif
        while (pDefCreate != NULL)
        {
            pTemp = pDefCreate->pNext;
            MemFree(pDefCreate->CreateData.pSList);
            MemFree(pDefCreate);
            pDefCreate = pTemp;
        }
        DDASSERT(pHandle->pSurfList == NULL);
        DDASSERT(pHandle->pContext == NULL);

        MemFree(hDD);
    }
}

/*****************************Private*Routine******************************\
* DdGetDC
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8GetDC"

HDC
APIENTRY
D3D8GetDC(
    HANDLE                    hSurface,
    LPPALETTEENTRY            pPalette
   )
{
    if (CheckForDeviceLost((HANDLE)((PDDSURFHANDLE)hSurface)->pDevice))
    {
        return NULL;
    }
    return(OsThunkDdGetDC(GetSurfHandle(hSurface), pPalette));
}

/*****************************Private*Routine******************************\
* DdReleaseDC
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8ReleaseDC"

BOOL
APIENTRY
D3D8ReleaseDC(
    HANDLE                  hSurface,
    HDC                     hdc
   )
{
    DDASSERT(hdc != NULL);

    return(OsThunkDdReleaseDC(GetSurfHandle(hSurface)));
}

/*****************************Private*Routine******************************\
* DdReenableDirectDrawObject
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8ReenableDirectDrawObject"

BOOL
APIENTRY
D3D8ReenableDirectDrawObject(
    HANDLE                  hDD,
    BOOL*                   pbNewMode
   )
{
    BOOL    bRet;
    PDDDEVICEHANDLE pHandle = (PDDDEVICEHANDLE) hDD;

    bRet = OsThunkDdReenableDirectDrawObject(DDHANDLE(hDD),
                                           pbNewMode);

    if (!bRet && 
        ((pHandle->DeviceType == D3DDEVTYPE_REF) || 
            (pHandle->DeviceType == D3DDEVTYPE_SW)) &&
        !(pHandle->DDCaps & ~DDCAPS_NOHARDWARE))
    {
        bRet = TRUE;
    }

    return bRet;
}

/*****************************Private*Routine******************************\
* DdSetGammaRamp
*
* History:
*  18-Oct-1997 -by- smac
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8SetGammaRamp"

BOOL
APIENTRY
D3D8SetGammaRamp(
    HANDLE      hDD,
    HDC         hdc,
    LPVOID      lpGammaRamp
   )
{
    if (CheckForDeviceLost(hDD))
    {
        return TRUE;
    }

    return(OsThunkDdSetGammaRamp(DDHANDLE(hDD), hdc,
        lpGammaRamp));
}

/*****************************Private*Routine******************************\
* D3D8BuildModeTable
*
* History:
*  15-Dec-1999 -by- smac
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8BuildModeTable"

VOID
APIENTRY
D3D8BuildModeTable(
    char*               pszDevice,
    D3DDISPLAYMODE*     pModeTable,
    DWORD*              pNumEntries,
    D3DFORMAT           Unknown16,
    HANDLE              hProfile,
    BOOL                b16bppSupported,
    BOOL                b32bppSupported
   )
{
    int             i;
    int             j;
    DEVMODE         dm;
    D3DFORMAT       format;
    int             NumTempEntries = 0;
    DWORD           NumActualEntries = 0;

    dm.dmSize = sizeof(dm);
    for (i = 0; EnumDisplaySettings(pszDevice, i, &dm); ++i)
    {
        // Filter out all modes other than 15, 16 and 32bpp
        if ((dm.dmBitsPerPel != 15) &&
            (dm.dmBitsPerPel != 16) &&
            (dm.dmBitsPerPel != 32))
        {
            continue;
        }

        if (((dm.dmBitsPerPel == 15) ||
             (dm.dmBitsPerPel == 16)) &&
            !b16bppSupported)
        {
            continue;
        }
        else if ((dm.dmBitsPerPel == 32) &&
            !b32bppSupported)
        {
            continue;
        }
       
        // Make sure that we understand the format.

        if ((dm.dmBitsPerPel == 16) ||
            (dm.dmBitsPerPel == 15))
        {
            format = Unknown16;
        }
        else
        {
            DDASSERT(dm.dmBitsPerPel == 32);
            format = D3DFMT_X8R8G8B8;
        }

        if (pModeTable != NULL)
        {
            ///The caller must pass us a number
            DDASSERT( (*pNumEntries) );
            if ( NumActualEntries >= (*pNumEntries) )
            {
                //we exceeded the number of entries allocated for us.
                //tell the caller to re-query and try again.
                NumActualEntries = 0;
                break;
            }

            // Add the new mode.
            pModeTable[NumActualEntries].Width       = dm.dmPelsWidth;
            pModeTable[NumActualEntries].Height      = dm.dmPelsHeight;
            pModeTable[NumActualEntries].RefreshRate = dm.dmDisplayFrequency;
            pModeTable[NumActualEntries].Format      = format;
        }
         
        NumActualEntries++;

    }

    //The caller will either pass a NULL modelist pointer, in which case
    //it is expecting us to fill in the number of entries. If the modelist
    // is non-null, the caller expects us to fill the table but not
    // overwrite. If we find the table has grown, ask the caller to 
    // re-allocate by returning 0 modes.
    (*pNumEntries) = NumActualEntries;
}

/*****************************Private*Routine******************************\
* D3D8IsDeviceLost
*
* History:
*  15-Dec-1999 -by- smac
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8IsDeviceLost"

BOOL
APIENTRY
D3D8IsDeviceLost(
    HANDLE  hDD
   )
{
    return CheckForDeviceLost(hDD);
}

/*****************************Private*Routine******************************\
* D3D8CanRestoreNow
* 15-Dec-1999 -by- smac
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8CanRestoreNow"

BOOL
APIENTRY
D3D8CanRestoreNow(
    HANDLE  hDD
   )
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;
    BOOL            bNewMode;
    D3D8_DRIVERCAPS DriverData;
    D3D8_GLOBALDRIVERDATA D3DGlobalDriverData;
    D3DHAL_D3DEXTENDEDCAPS D3DExtendedCaps;
    D3D8_CALLBACKS  Callbacks;
    UINT            uiDummy;

    // If we aren't lost, then it's an easy call

    if (!CheckForDeviceLost(hDD))
    {
        return TRUE;
    }

    // Otherwise, we actually need to call the kernel and look at the caps

    memset(&DriverData, 0, sizeof(DriverData));
    memset(&D3DGlobalDriverData, 0, sizeof(D3DGlobalDriverData));
    memset(&D3DExtendedCaps, 0, sizeof(D3DExtendedCaps));
    memset(&Callbacks, 0, sizeof(Callbacks));
    if (!D3D8ReenableDirectDrawObject (hDD,&bNewMode) ||
        !D3D8QueryDirectDrawObject(hDD,
                                   &DriverData,
                                   &Callbacks,
                                   pDeviceHandle->szDeviceName,
                                   pDeviceHandle->hLibrary,
                                   &D3DGlobalDriverData,
                                   &D3DExtendedCaps,
                                   NULL,NULL,&uiDummy,&uiDummy))
    {
        return FALSE;
    }

    if (IS_SOFTWARE_DRIVER(hDD) ||
        ((DriverData.D3DCaps.Caps & DDCAPS_3D) &&
        (Callbacks.DrawPrimitives2 != NULL)))
    {
        return TRUE;
    }

    return FALSE;
}

/*****************************Private*Routine******************************\
* D3D8RestoreDevice
* 15-Dec-1999 -by- smac
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8RestoreDevice"

void
APIENTRY
D3D8RestoreDevice (
    HANDLE hDD
   )
{
    HRESULT hr;
    DWORD i, j, k;
    DWORD Width, Height, Depth;
    BYTE *SliceSrc, *SliceDst, *RowSrc, *RowDst;
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;
    PDDSURFHANDLE pSurf;
    PD3DCONTEXTHANDLE pContext = pDeviceHandle->pContext;
    PDEFERREDCREATE pDefCreate = pDeviceHandle->pDeferList;
    PDEFERREDCREATE *ppNext = &pDeviceHandle->pDeferList;
    PDEFERREDCREATE pTemp;
    D3D8_LOCKDATA LockData;
    D3D8_UNLOCKDATA UnlockData;
    ULONG_PTR pVidmem[32 * 6];

    // First, say that we aren't lost anymore

    pDeviceHandle->DisplayUniqueness =
        DdQueryDisplaySettingsUniqueness();
    pDeviceHandle->bDeviceLost = FALSE;
    pDeviceHandle->dwFlags &= ~DDDEVICE_DP2ERROR;

    // Now, check for any sysmem surfaces that were created while
    // the device was lost and call CreateSurfaceEx if they need it.

    pSurf = pDeviceHandle->pSurfList;

    while (pSurf != NULL)
    {
        if ((pSurf->dwCookie != 0) &&
            (pSurf->dwFlags & DDSURF_DEFERCREATEEX))
        {
            hr = OsThunkDdCreateSurfaceEx(
                    DDHANDLE(hDD),
                    pSurf->hSurface,
                    pSurf->dwCookie);
            if (SUCCEEDED(hr))
            {
                pSurf->dwFlags &= ~DDSURF_DEFERCREATEEX;
            }
            else
            {
                // TODO: Handle error condition
                DPF(0, "CreateSurfaceEx failed when resurrecting sysmem or D3D managed surfaces");
            }
        }
        pSurf = pSurf->pNext;
    }

    // Now, create the D3D context if we need to.

    if ((pContext != NULL) &&
        (pContext->dwFlags & D3DCONTEXT_DEFERCREATE))
    {
        D3D8_CONTEXTCREATEDATA  ContextData;

        memset(&ContextData, 0, sizeof(ContextData));
        ContextData.hDD = DDHANDLE(hDD);
        ContextData.dwPID = pContext->dwPID;
        ContextData.dwhContext = (ULONG_PTR) pContext->hDeferHandle;

        OsThunkD3dContextCreate(DDHANDLE(hDD),
            GetSurfHandle(pContext->pSurface),
            GetSurfHandle(pContext->pDDSZ),
            (D3DNTHAL_CONTEXTCREATEI *)&ContextData);

        if (SUCCEEDED(ContextData.ddrval))
        {
            pContext->dwhContext = (HANDLE) ContextData.dwhContext;
            pContext->dwFlags &= ~D3DCONTEXT_DEFERCREATE;
        }
        else
        {
            // TODO: Handle error condition
        }
    }

    // Finally resurrect our deferred driver managed surfaces (Gulp!)

    while (pDefCreate != NULL)
    {
        DDASSERT(pDefCreate->CreateData.dwSCnt <= 32 * 6);

        // First check if the deferred surface exists at all. The problem
        // is that DdDestroySurface could have been called. We could have
        // removed the surface from the deferred list in DdDestroySurface
        // but since DdDestroySurface is called piecemeal, it gets
        // very annoying. The removal is best done here.
        // ASSUMPTION: if pSList[0].hKernelHandle is NULL then
        // pSList[1,2,etc].hKernelHandle are also NULL. There is no
        // reason for this to be not the case as of 3/2001.

        if (pDefCreate->CreateData.pSList[0].hKernelHandle == NULL)
        {
            pTemp = pDefCreate->pNext;
            *ppNext = pTemp;
            MemFree(pDefCreate->CreateData.pSList);
            MemFree(pDefCreate);
            pDefCreate = pTemp;
            continue;
        }

        // Save off all the fpVidmems since they will be overwritten

        for (i = 0; i < pDefCreate->CreateData.dwSCnt; i++)
        {
            pSurf = (PDDSURFHANDLE) pDefCreate->CreateData.pSList[i].hKernelHandle;
            pVidmem[i] = pSurf->fpVidMem;
        }

        // Attempt to resurrect

        pDefCreate->CreateData.bReUse = TRUE;
        hr = DdCreateSurface(&pDefCreate->CreateData);
        if (SUCCEEDED(hr))
        {
            for (i = 0; i < pDefCreate->CreateData.dwSCnt; i++)
            {
                pSurf = (PDDSURFHANDLE) pDefCreate->CreateData.pSList[i].hKernelHandle;

                // Reset DDSURF_SYSMEMALLOCATED to keep DdLock below happy

                pSurf->dwFlags &= ~DDSURF_SYSMEMALLOCATED;

                // Lock and copy

                ZeroMemory(&LockData, sizeof(LockData));
                LockData.hDD = hDD;
                LockData.hSurface = pSurf;
                hr = DdLock(&LockData);
                if (SUCCEEDED(hr))
                {
                    SliceSrc = (BYTE*)pVidmem[i];
                    SliceDst = (BYTE*)LockData.lpSurfData;
                    Width = pDefCreate->CreateData.pSList[i].cpWidth;
                    Height = pDefCreate->CreateData.pSList[i].cpHeight;
                    Depth = pDefCreate->CreateData.pSList[i].cpDepth;
                    if (!(pDefCreate->CreateData.Type == D3DRTYPE_VOLUME ||
                        pDefCreate->CreateData.Type == D3DRTYPE_VOLUMETEXTURE))
                    {
                        Depth = 1;
                    }
                    for (j = 0; j < Depth; ++j)
                    {
                        RowSrc = SliceSrc;
                        RowDst = SliceDst;
                        for (k = 0; k < Height; ++k)
                        {
                            CopyMemory(RowDst, RowSrc, min(LockData.lPitch, (LONG)Width * 8));
                            RowSrc += Width * 8;
                            RowDst += LockData.lPitch;
                        }
                        SliceSrc += Width * Height * 8;
                        SliceDst += LockData.lSlicePitch;
                    }

                    ZeroMemory(&UnlockData, sizeof(UnlockData));
                    UnlockData.hDD = hDD;
                    UnlockData.hSurface = pSurf;
                    hr = DdUnlock(&UnlockData);
                    if (FAILED(hr))
                    {
                        // TODO: Handle/(ignore?) failure 
                        DPF(0,"Unlock failed when resurrecting driver managed surface.");
                    }
                }
                else
                {
                    // TODO: Handle/(ignore?) failure 
                    DPF(0,"Lock failed when resurrecting driver managed surface. Texture may go missing.");
                }

                // Free the temporary fpVidmem that we allocated in CreateVidmemSurface
            
                MemFree((VOID*)pVidmem[i]);
            }

            // Remove from list and freeup all memory
     
            pTemp = pDefCreate->pNext;
            *ppNext = pTemp;
            MemFree(pDefCreate->CreateData.pSList);
            MemFree(pDefCreate);
            pDefCreate = pTemp;
        }
        else
        {
            // We set ReUse to FALSE to indicate that we were not able to resurrect
            pDefCreate->CreateData.bReUse = FALSE;

            ppNext = &(pDefCreate->pNext);
            pDefCreate = pDefCreate->pNext;
        }
    }

    if (pDeviceHandle->pDeferList != NULL)
    {
        // TODO:
        // Ummm, we were not able to resurrect. This may be due to out of memory
        // or if a mode switch happened as we were trying to Reset (ACK!). The
        // former probably needs to be reported to the app. The latter is
        // probably harmless, because the app will eventually realize this and
        // try again.
        DPF(0,"Unable to resurrect all driver managed surfaces.");
    }
}
                     

/*****************************Private*Routine******************************\
* D3D8AreVidmemSurfaces
* 15-Dec-1999 -by- smac
* Wrote it.
\**************************************************************************/
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8DoVidmemSurfacesExist "

BOOL
APIENTRY
D3D8DoVidmemSurfacesExist (
    HANDLE hDD
   )
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;
    PDDSURFHANDLE pSurf;

    // Walk the list and return TRUE is we find any surfaces that are either
    // local or nonlocal vidmem.

    pSurf = pDeviceHandle->pSurfList;
    while (pSurf != NULL)
    {
        if ((pSurf->Pool == D3DPOOL_LOCALVIDMEM) ||
            (pSurf->Pool == D3DPOOL_NONLOCALVIDMEM) ||
            (pSurf->dwFlags & DDSURF_TREATASVIDMEM))
        {
#if DBG
            DPF(0,"The following D3DPOOL_DEFAULT surfaces/buffers/textures still exist");
            pSurf = pDeviceHandle->pSurfList;
            while (pSurf != NULL)
            {
                if ((pSurf->Pool == D3DPOOL_LOCALVIDMEM) ||
                    (pSurf->Pool == D3DPOOL_NONLOCALVIDMEM) ||
                    (pSurf->dwFlags & DDSURF_TREATASVIDMEM))
                {
                    DebugPrintSurfaceInfo(pSurf);
                }
                pSurf = pSurf->pNext;
            }
#endif

            return TRUE;
        }
        pSurf = pSurf->pNext;
    }

    // Is this the first time that the device has become ready?
    if (!(pDeviceHandle->dwFlags & DDDEVICE_READY) &&
        (pDeviceHandle->bDeviceLost))
    {
        pDeviceHandle->dwFlags |= DDDEVICE_READY;
        if (++NumReadyDevices == NumDevices)
        {
            InformDriverFreeAGP(pDeviceHandle);
        }
    }

    return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "D3D8BeginProfile"

HANDLE
APIENTRY
D3D8BeginProfile(
    char*           pDeviceName)
{
    return NULL;
}
#undef DPF_MODNAME
#define DPF_MODNAME "D3D8EndProfile"

void
APIENTRY
D3D8EndProfile(
    HANDLE  Handle)
{
}

DWORD APIENTRY D3D8SetCooperativeLevel(
    HANDLE hDD,
    HWND hWnd,
    DWORD dwFlags )
{
    return S_OK;
}

BOOL APIENTRY D3D8IsDummySurface(
    HANDLE hSurface )
{
    return FALSE;
}

VOID APIENTRY D3D8LoseDevice(
    HANDLE hDD )
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;
    PDDSURFHANDLE   pSurf;

    if (!pDeviceHandle->bDeviceLost)
    {
        pDeviceHandle->bDeviceLost  = TRUE;
        pSurf = pDeviceHandle->pSurfList;
        while (pSurf != NULL)
        {
            if (IS_SURFACE_LOOSABLE(pSurf))
            {
                FreeSurfaceObject(pSurf);
                pSurf->fpVidMem = (ULONG_PTR) NULL;
            }
            pSurf = pSurf->pNext;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\ddithunk.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddithunk.h
 *  Content:	header file used by the NT DDI thunk layer
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   03-Dec-99  smac    Created it
 *
 ***************************************************************************/

#ifndef __DDITHUNK_INCLUDED__
#define __DDITHUNK_INCLUDED__

// Entire file should not be used in Win9x builds
#ifndef WIN95

#define MAX_ZSTENCIL_FORMATS    40

typedef struct _DDSURFHANDLE *PDDSURFHANDLE;
typedef struct _DEFERREDCREATE *PDEFERREDCREATE;

typedef struct _D3DCONTEXTHANDLE
{
    HANDLE                      dwhContext;
    DWORD                       dwFlags;
    struct _DDDEVICEHANDLE*     pDevice;
    DWORD                       dwPID;
    HANDLE                      hDeferHandle;
    struct _DDSURFHANDLE*       pSurface;
    struct _DDSURFHANDLE*       pDDSZ;
} D3DCONTEXTHANDLE, * PD3DCONTEXTHANDLE;

#define D3DCONTEXT_DEFERCREATE  0x00000001

typedef struct _DDDEVICEHANDLE
{
    HANDLE                      hDD;
    DWLIST                      SurfaceHandleList;
    char                        szDeviceName[MAX_DRIVER_NAME];
    LPDDRAWI_DIRECTDRAW_LCL     pDD;    // Used by Refrast and RGB HEL
    BOOL                        bDeviceLost;
    UINT                        DisplayUniqueness;
    PDDSURFHANDLE               pSurfList;
    PD3DCONTEXTHANDLE           pContext;
    D3DFORMAT                   DisplayFormatWithoutAlpha;
    D3DFORMAT                   DisplayFormatWithAlpha;
    UINT                        DisplayPitch;
    DWORD                       DriverLevel;
    RECT                        rcMonitor;
    HWND                        hLastWnd;
    LPRGNDATA                   pClipList;      //result from pOrigClipList
    LPRGNDATA                   pOrigClipList;  //ClipList before ClipRgnToRect
    VOID*                       pSwInitFunction;
    BOOL                        bIsWhistler;
    DWORD                       PCIID;
    DWORD                       DriverVersionHigh;
    DWORD                       DriverVersionLow;
    DWORD                       ForceFlagsOff;
    DWORD                       ForceFlagsOn;
    DWORD                       dwFlags;    
    DWORD                       DDCaps;
    DWORD                       SVBCaps;
    HANDLE                      hLibrary;
    PDEFERREDCREATE             pDeferList;
    D3DDEVTYPE                  DeviceType;
} DDDEVICEHANDLE, * PDDDEVICEHANDLE;
#define DDDEVICE_SUPPORTD3DBUF        0x01    //this device has D3DBuf callbacks
#define DDDEVICE_DP2ERROR             0x02    //A DP2 call failed
#define DDDEVICE_SUPPORTSUBVOLUMELOCK 0x04    //this device supports sub-volume texture lock
#define DDDEVICE_READY                0x08    //All vidmem surfs have been destroyed for this device
#define DDDEVICE_GETDRIVERINFO2       0x10    // Driver support the GetDriverInfo2 call
#define DDDEVICE_INITIALIZED          0x20    // The device has been initialized
#define DDHANDLE(x)  \
    (((PDDDEVICEHANDLE)(x))->hDD)

typedef struct _DDSURFHANDLE
{
    // NOTE: dwCookie must be the first element
    // since we need easy access to it from the 
    // client and the thunk layer itself.
    DWORD                       dwCookie;   // CreateSurfaceEx handle

    HANDLE                      hSurface;   // Kernel mode surface handle
    D3DPOOL                     Pool;       // Location of surface
    D3DFORMAT                   Format;   
    D3DRESOURCETYPE             Type;       // What kind of surface it is
    ULONG_PTR                   fpVidMem;
    DWORD                       dwLinearSize;
    LONG                        lPitch;
    LPDDRAWI_DDRAWSURFACE_LCL   pLcl;
    PDDDEVICEHANDLE             pDevice;
    DWORD                       dwFlags;
    DWORD                       dwHeight;
    LONG                        lSlicePitch; // Offset to next slice for volume texture
    struct _DDSURFHANDLE*       pNext;
    struct _DDSURFHANDLE*       pPrevious;
    UINT                        LockRefCnt;
} DDSURFHANDLE, * PDDSURFHANDLE;

typedef struct _DEFERREDCREATE
{
    D3D8_CREATESURFACEDATA      CreateData;
    struct _DEFERREDCREATE     *pNext;
} DEFERREDCREATE, *PDEFERREDCREATE;

#define DDSURF_SYSMEMALLOCATED      0x00000001
#define DDSURF_DEFERCREATEEX        0x00000002
#define DDSURF_HAL                  0x00000004
#define DDSURF_SOFTWARE             0x00000008
#define DDSURF_CREATECOMPLETE       0x00000010
#define DDSURF_TREATASVIDMEM        0x00000020      // Flag to indicate that surf should
                                                    // be treated as vid-mem for the
                                                    // "do vid-mem surfaces exist" case


#define IS_SOFTWARE_DRIVER(x)                                       \
    (((PDDDEVICEHANDLE)(x))->pDD != NULL)

#define IS_SOFTWARE_DRIVER_SURFACE(x)                               \
    (((PDDSURFHANDLE)(x))->dwFlags & DDSURF_SOFTWARE)

#define IS_SURFACE_LOOSABLE(x)                                      \
    (!IS_SOFTWARE_DRIVER_SURFACE(x) &&                              \
    ((((PDDSURFHANDLE)(x))->Pool == D3DPOOL_LOCALVIDMEM) ||        \
    (((PDDSURFHANDLE)(x))->Pool == D3DPOOL_NONLOCALVIDMEM)))

__inline HANDLE GetSurfHandle(HANDLE hSurface)
{
    if(hSurface)                                     
    {                                                   
        return(((PDDSURFHANDLE)hSurface)->hSurface); 
    }                                                   
    return NULL;
}

__inline D3DRESOURCETYPE GetSurfType(HANDLE hSurface)
{
    if(hSurface)                                     
    {                                                   
        return(((PDDSURFHANDLE)hSurface)->Type); 
    }                                                   
    return (D3DRESOURCETYPE) 0;
}


// Function protoptypes

extern LPDDRAWI_DIRECTDRAW_LCL SwDDICreateDirectDraw( void);
extern void ConvertToOldFormat(LPDDPIXELFORMAT pOldFormat, D3DFORMAT NewFormat);
extern void SwDDIMungeCaps (HINSTANCE hLibrary, HANDLE hDD, PD3D8_DRIVERCAPS pDriverCaps, PD3D8_CALLBACKS pCallbacks, LPDDSURFACEDESC, UINT*, VOID* pSwInitFunction);
extern LPDDRAWI_DDRAWSURFACE_LCL SwDDIBuildHeavyWeightSurface (LPDDRAWI_DIRECTDRAW_LCL, PD3D8_CREATESURFACEDATA pCreateSurface, DD_SURFACE_LOCAL* pSurfaceLocal, DD_SURFACE_GLOBAL* pSurfaceGlobal, DD_SURFACE_MORE* pSurfaceMore, DWORD index);
extern void SwDDICreateSurfaceEx(LPDDRAWI_DIRECTDRAW_LCL pDrv, LPDDRAWI_DDRAWSURFACE_LCL pLcl);
extern void SwDDIAttachSurfaces (LPDDRAWI_DDRAWSURFACE_LCL pFrom, LPDDRAWI_DDRAWSURFACE_LCL pTo);
extern HRESULT SwDDICreateSurface( PD3D8_CREATESURFACEDATA pCreateSurface, DD_SURFACE_LOCAL* pDDSurfaceLocal, DD_SURFACE_GLOBAL* pDDSurfaceGlobal, DD_SURFACE_MORE*  pDDSurfaceMore);
extern void AddUnknownZFormats( UINT NumFormats, DDPIXELFORMAT* pFormats, UINT* pNumUnknownFormats, D3DFORMAT* pUnknownFormats);
extern DWORD SwDDILock( HANDLE hDD, PDDSURFHANDLE   pSurf, DD_LOCKDATA* pLockData);
extern DWORD SwDDIUnlock( HANDLE hDD, PDDSURFHANDLE   pSurf, DD_UNLOCKDATA* pUnlockData);
extern DWORD SwDDIDestroySurface( HANDLE hDD, PDDSURFHANDLE pSurf);
extern HRESULT MapLegacyResult(HRESULT hr);

#endif // !WIN95

#endif // __DDITHUNK_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\dxcursor.cpp ===
/*========================================================================== *
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddcursor.c
 *  Content:    DirectDraw cursor support
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   17-Jan-00  kanqiu  initial implementation(Kan Qiu)
 *
 ***************************************************************************/
#include "ddrawpr.h"
#include "dxcursor.hpp"
#include "swapchan.hpp"

#define FORMAT_8888_1555(val)  \
    ( ((val & 0x80000000) >> 16) | ((val & 0xF80000) >> 9) | ((val & 0xF800) >> 6) | ((val & 0xF8) >> 3))
#define FORMAT_8888_555(val)  \
    ( ((val & 0xF80000) >> 9) | ((val & 0xF800) >> 6) | ((val & 0xF8) >> 3))
#define FORMAT_8888_565(val)  \
    ( ((val & 0xF80000) >> 8) | ((val & 0xFC00) >> 5) | ((val & 0xF8) >> 3))
#define ISOPAQUE(val)   \
    ( 0xFF000000 == (val & 0xFF000000))


#undef DPF_MODNAME
#define DPF_MODNAME "CCursor::CCursor"

//=============================================================================
// CCursor::CCursor
//
//=============================================================================

CCursor::CCursor(CBaseDevice *pDevice) 
{
    m_pDevice = pDevice;
    m_dwCursorFlags = 0;
    m_hCursorDdb = NULL;
    m_hFrontSave = NULL;  
    m_hBackSave = NULL;
    m_Width = m_Height = 0;
    m_hOsCursor = NULL;
    m_hHWCursor = NULL;
    m_SavedMouseTrails = 0;
    m_xCursor = pDevice->SwapChain()->Width()/2;
    m_yCursor = pDevice->SwapChain()->Height()/2;
    m_MonitorOrigin.x = m_MonitorOrigin.y = 0;
    if ( (!pDevice->SwapChain()->Windowed())
        && (1 < pDevice->Enum()->GetAdapterCount()))
    {
        HMONITOR hMonitor = pDevice->Enum()->
            GetAdapterMonitor(pDevice->AdapterIndex());
        if (hMonitor)
        {
            MONITORINFO MonInfo;
            MonInfo.rcMonitor.top = MonInfo.rcMonitor.left = 0;
            MonInfo.cbSize = sizeof(MONITORINFO);
            InternalGetMonitorInfo(hMonitor, &MonInfo);
            m_MonitorOrigin.x = MonInfo.rcMonitor.left;
            m_MonitorOrigin.y = MonInfo.rcMonitor.top;
        }
    }

} // CCursor::CCursor

#undef DPF_MODNAME
#define DPF_MODNAME "CCursor::~CCursor"

//=============================================================================
// CCursor::~CCursor
//
//=============================================================================

CCursor::~CCursor()
{
    Destroy();
    if (m_hOsCursor)
    {
        SetCursor(m_hOsCursor);
        m_hOsCursor = NULL;
    }
}

void
CCursor::Destroy()
{
    D3D8_DESTROYSURFACEDATA DestroySurfData;
    DestroySurfData.hDD = m_pDevice->GetHandle();
    if (m_hCursorDdb)
    {
        DestroySurfData.hSurface = m_hCursorDdb;
        m_pDevice->GetHalCallbacks()->DestroySurface(&DestroySurfData);
        m_hCursorDdb = NULL;
    }
    if (m_hFrontSave)
    {
        DestroySurfData.hSurface = m_hFrontSave;
        m_pDevice->GetHalCallbacks()->DestroySurface(&DestroySurfData);
        m_hFrontSave = NULL;
    }
    if (m_hBackSave)
    {
        DestroySurfData.hSurface = m_hBackSave;
        m_pDevice->GetHalCallbacks()->DestroySurface(&DestroySurfData);
        m_hBackSave = NULL;
    }
    if ( NULL != m_hHWCursor )
    {
        if ( GetCursor() == m_hHWCursor )
            SetCursor(NULL); // turn it off before destroy
        if (!DestroyIcon((HICON)m_hHWCursor))
        {
            DPF_ERR("Destroy Failed to Destroy Old hwcursor Icon");
        }
        m_hHWCursor = NULL;
        if (m_SavedMouseTrails > 1)
        {
            SystemParametersInfo(SPI_SETMOUSETRAILS,m_SavedMouseTrails,0,0);        
            m_SavedMouseTrails = 0;
        }
    }
}

void
CCursor::UpdateRects()
{
    if (DDRAWI_CURSORISON & m_dwCursorFlags)
    {
        if (DDRAWI_CURSORSAVERECT & m_dwCursorFlags) 
        {
            // SetPosition didn't update RECTs, but next Flip will
            m_dwCursorFlags &= ~DDRAWI_CURSORSAVERECT;
            m_dwCursorFlags |= DDRAWI_CURSORRECTSAVED;
            m_CursorRectSave = m_CursorRect;
            m_BufferRectSave = m_BufferRect;
        }
        if (m_xCursor < m_xCursorHotSpot)
        {
            m_CursorRect.left = m_xCursorHotSpot - m_xCursor;
            m_CursorRect.right = m_Width;
            m_BufferRect.left = 0;
        }
        else
        {
            m_CursorRect.left = 0;
            m_BufferRect.left = m_xCursor - m_xCursorHotSpot;
            if (m_xCursor + m_Width > 
                m_pDevice->DisplayWidth() + m_xCursorHotSpot )
            {
                m_CursorRect.right = m_pDevice->DisplayWidth() + m_xCursorHotSpot
                    - m_xCursor;
            }
            else
            {
                m_CursorRect.right = m_Width;
            }
        }
        m_BufferRect.right = m_BufferRect.left + m_CursorRect.right - m_CursorRect.left;
        if (m_yCursor < m_yCursorHotSpot)
        {
            m_CursorRect.top = m_yCursorHotSpot - m_yCursor;
            m_CursorRect.bottom = m_Height;
            m_BufferRect.top = 0;
        }
        else
        {
            m_CursorRect.top = 0;
            m_BufferRect.top = m_yCursor - m_yCursorHotSpot;
            if (m_yCursor + m_Height > 
                m_pDevice->DisplayHeight() + m_yCursorHotSpot )
            {
                m_CursorRect.bottom = m_pDevice->DisplayHeight() + m_yCursorHotSpot
                    - m_yCursor;
            }
            else
            {
                m_CursorRect.bottom = m_Height;
            }
        }
        m_BufferRect.bottom = m_BufferRect.top + m_CursorRect.bottom - m_CursorRect.top;
    }
}

/*
 * Hide
 *
 * Hide the cursor. Restore buffer with saved area
 */
#undef DPF_MODNAME
#define DPF_MODNAME     "CCursor::Hide"
HRESULT 
CCursor::Hide(HANDLE hSurf)
{
    if (!(DDRAWI_CURSORISON & m_dwCursorFlags))
    {
        return S_OK;
    }
    D3D8_BLTDATA BltData;
    ZeroMemory(&BltData, sizeof BltData);

    if (DDRAWI_CURSORRECTSAVED & m_dwCursorFlags) 
    {
        // this Hide Must have been caused by flip
        m_dwCursorFlags &= ~DDRAWI_CURSORRECTSAVED;
        BltData.rSrc.left = m_CursorRectSave.left;
        BltData.rSrc.right = m_CursorRectSave.right;
        BltData.rSrc.top = m_CursorRectSave.top;
        BltData.rSrc.bottom = m_CursorRectSave.bottom;
        BltData.rDest.left = m_BufferRectSave.left;
        BltData.rDest.top = m_BufferRectSave.top;
        BltData.rDest.right = m_BufferRectSave.right;
        BltData.rDest.bottom = m_BufferRectSave.bottom;
    }
    else
    {
        BltData.rSrc.left = m_CursorRect.left;
        BltData.rSrc.right = m_CursorRect.right;
        BltData.rSrc.top = m_CursorRect.top;
        BltData.rSrc.bottom = m_CursorRect.bottom;
        BltData.rDest.left = m_BufferRect.left;
        BltData.rDest.top = m_BufferRect.top;
        BltData.rDest.right = m_BufferRect.right;
        BltData.rDest.bottom = m_BufferRect.bottom;
    }
    BltData.hSrcSurface = m_hFrontSave;
    BltData.hDestSurface = hSurf;
    BltData.hDD = m_pDevice->GetHandle();
    BltData.dwFlags = DDBLT_ROP | DDBLT_WAIT;
    BltData.bltFX.dwROP = SRCCOPY;
    BltData.ddRVal = E_FAIL;
    m_pDevice->GetHalCallbacks()->Blt(&BltData);
    return  BltData.ddRVal;
}

/*
 * ShowCursor
 *
 * Show the cursor. save exclusion area and blt cursor to it
 */
#undef DPF_MODNAME
#define DPF_MODNAME     "CCursor::Show"
HRESULT 
CCursor::Show(HANDLE hSurf)
{
    if (!(DDRAWI_CURSORISON & m_dwCursorFlags))
    {
        return S_OK;
    }
    D3D8_BLTDATA BltData;
    ZeroMemory(&BltData, sizeof BltData);
    UpdateRects();    
    BltData.rSrc.left = m_BufferRect.left;
    BltData.rSrc.right = m_BufferRect.right;
    BltData.rSrc.top = m_BufferRect.top;
    BltData.rSrc.bottom = m_BufferRect.bottom;
    BltData.hSrcSurface = hSurf;
    BltData.rDest.left = m_CursorRect.left;
    BltData.rDest.top = m_CursorRect.top;
    BltData.rDest.right = m_CursorRect.right;
    BltData.rDest.bottom = m_CursorRect.bottom;
    BltData.hDestSurface = m_hFrontSave;
    BltData.hDD = m_pDevice->GetHandle();
    BltData.dwFlags = DDBLT_ROP | DDBLT_WAIT;
    BltData.bltFX.dwROP = SRCCOPY;
    BltData.ddRVal = E_FAIL;
    m_pDevice->GetHalCallbacks()->Blt(&BltData);
    if (SUCCEEDED(BltData.ddRVal))
    {
        BltData.rSrc.left = m_CursorRect.left;
        BltData.rSrc.right = m_CursorRect.right;
        BltData.rSrc.top = m_CursorRect.top;
        BltData.rSrc.bottom = m_CursorRect.bottom;
        BltData.hSrcSurface = m_hCursorDdb;
        BltData.rDest.left = m_BufferRect.left;
        BltData.rDest.top = m_BufferRect.top;
        BltData.rDest.right = m_BufferRect.right;
        BltData.rDest.bottom = m_BufferRect.bottom;
        BltData.hDestSurface = hSurf;
        BltData.hDD = m_pDevice->GetHandle();
        BltData.dwFlags = DDBLT_ROP | DDBLT_WAIT | DDBLT_KEYSRCOVERRIDE;
         //always use black as key
        BltData.bltFX.ddckSrcColorkey.dwColorSpaceLowValue =
        BltData.bltFX.ddckSrcColorkey.dwColorSpaceHighValue = 0; 
        BltData.bltFX.dwROP = SRCCOPY;
        BltData.ddRVal = E_FAIL;
        m_pDevice->GetHalCallbacks()->Blt(&BltData);
    }
    return  BltData.ddRVal;
}

void
CCursor::Flip()
{
    if (DDRAWI_CURSORISON & m_dwCursorFlags)
    {
        HANDLE  htemp = m_hFrontSave;
        m_hFrontSave = m_hBackSave;
        m_hBackSave = htemp;
    }
}

HCURSOR   CreateColorCursor(
    UINT xHotSpot,
    UINT yHotSpot,
    UINT BitmapWidth,
    UINT BitmapHeight,
    CBaseSurface *pCursorBitmap)
{
    UINT Width = (UINT)GetSystemMetrics(SM_CXCURSOR);
    UINT Height = (UINT)GetSystemMetrics(SM_CYCURSOR);
    ICONINFO    iconinfo;
    D3DLOCKED_RECT lock;
    DWORD   *pSourceBitmap;
    DWORD   *pColorMask;
    BYTE    *pMonoMask;
    HCURSOR     hCursor = NULL;
    HDC     hdcMem      = NULL;
    HBITMAP hbmANDMask  = NULL;
    HWND    hwndDesktop = NULL;
    HBITMAP hbmXORBitmap;
    HDC     hdcScreen;

    static char  bmi[sizeof(BITMAPINFO) + (sizeof(RGBQUAD) * 255)];
    LPBITMAPINFO pbmi = (LPBITMAPINFO)bmi;
    iconinfo.fIcon = FALSE;
    iconinfo.xHotspot = xHotSpot*Width/BitmapWidth;
    iconinfo.yHotspot = yHotSpot*Height/BitmapHeight;

    pMonoMask = new BYTE [Width * Height / 8];
    if ( NULL == pMonoMask )
    {
        DPF_ERR("Out of Memory. Unable to create Cursor");
        return NULL;
    }
    ZeroMemory(pMonoMask, (Width * Height / 8));
    pColorMask = new DWORD [Width * Height];
    if ( NULL == pColorMask )
    {
        DPF_ERR("Out of Memory. Unable to CreateCursor");
        delete[] pMonoMask;
        return NULL;
    }
    if (FAILED(pCursorBitmap->LockRect(&lock, NULL, 0)))
    {
        DPF_ERR("Failed to lock pCursorBitmap, it must be lockable. CreateCursor failed");
        delete[] pMonoMask;
        delete[] pColorMask;
        return NULL;
    }
    pSourceBitmap = (DWORD*)lock.pBits;
    for (int j = (int)(Height - 1); j >= 0 ; j--)
    {
        for (UINT i = 0; i < Width; ++i)
        {
            DWORD   pixel= pSourceBitmap[i*BitmapWidth/Width];
            if (ISOPAQUE(pixel))
            {
                pColorMask[j*Width+i] = pixel;
            }
            else
            {
                pMonoMask[(j*Width+i)/8] 
                    |= 1 << (7-((j*Width+i) % 8));    
                pColorMask[j*Width+i] = 0;
            }
        }
        pSourceBitmap += lock.Pitch* BitmapHeight/4/Height;
    }
    if (FAILED(pCursorBitmap->UnlockRect()))
    {
        DPF_ERR("Driver surface failed to unlock pCursorBitmap");
    }
    /************************************************************************/
    /* Initialize the bitmap header for the XOR data.                       */
    /************************************************************************/
    pbmi->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    pbmi->bmiHeader.biWidth         = Width;
    pbmi->bmiHeader.biHeight        = Height;
    pbmi->bmiHeader.biPlanes        = 1;
    pbmi->bmiHeader.biBitCount      = 32;
    pbmi->bmiHeader.biCompression   = BI_RGB;
    pbmi->bmiHeader.biSizeImage     = Width*Height*sizeof(DWORD);
    pbmi->bmiHeader.biXPelsPerMeter = 0;
    pbmi->bmiHeader.biYPelsPerMeter = 0;
    pbmi->bmiHeader.biClrUsed       = 0;
    pbmi->bmiHeader.biClrImportant  = 0;

    hwndDesktop = GetDesktopWindow();
    hdcScreen = GetWindowDC(hwndDesktop);

    if (0 == hdcScreen)
    { 
        // Error getting the screen DC.
        DPF_ERR("Failed to create screen DC");
        delete[] pMonoMask;
        delete[] pColorMask;
        return  NULL;
    }

    /********************************************************************/
    /* Create XOR Bitmap                                                */
    /********************************************************************/
    iconinfo.hbmColor = CreateDIBitmap(hdcScreen,
                      (LPBITMAPINFOHEADER)pbmi,
                      CBM_INIT,
                      pColorMask,
                      pbmi,
                      DIB_RGB_COLORS);
    delete[] pColorMask;

    /********************************************************************/
    /* Release the DC.                                                  */
    /********************************************************************/
    ReleaseDC(hwndDesktop, hdcScreen);

    if ( NULL == iconinfo.hbmColor)
    {
        delete[] pMonoMask;
        return NULL;
    }
    /************************************************************************/
    /* For the mono bitmap, use CreateCompatibleDC - this makes no          */
    /* difference on NT, but allows this code to work on Windows 95.        */
    /************************************************************************/
    hdcMem = CreateCompatibleDC(NULL);
    if ( NULL == hdcMem)
    {
        DPF_ERR("Failed to create DC");
        delete[] pMonoMask;
        DeleteObject( iconinfo.hbmColor );
        return NULL;
    }

    /************************************************************************/
    /* Create AND Mask (1bpp) - set the RGB colors to black and white.      */
    /************************************************************************/
    pbmi->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    pbmi->bmiHeader.biWidth         = Width;
    pbmi->bmiHeader.biHeight        = Height;
    pbmi->bmiHeader.biPlanes        = 1;
    pbmi->bmiHeader.biBitCount      = 1;
    pbmi->bmiHeader.biCompression   = BI_RGB;
    pbmi->bmiHeader.biSizeImage     = Width*Height/8;
    pbmi->bmiHeader.biXPelsPerMeter = 0;
    pbmi->bmiHeader.biYPelsPerMeter = 0;
    pbmi->bmiHeader.biClrUsed       = 2;
    pbmi->bmiHeader.biClrImportant  = 0;

    pbmi->bmiColors[0].rgbRed      = 0x00;
    pbmi->bmiColors[0].rgbGreen    = 0x00;
    pbmi->bmiColors[0].rgbBlue     = 0x00;
    pbmi->bmiColors[0].rgbReserved = 0x00;

    pbmi->bmiColors[1].rgbRed      = 0xFF;
    pbmi->bmiColors[1].rgbGreen    = 0xFF;
    pbmi->bmiColors[1].rgbBlue     = 0xFF;
    pbmi->bmiColors[1].rgbReserved = 0x00;

    iconinfo.hbmMask = CreateDIBitmap(hdcMem,
                                (LPBITMAPINFOHEADER)pbmi,
                                CBM_INIT,
                                pMonoMask,
                                pbmi,
                                DIB_RGB_COLORS);
    /************************************************************************/
    /* Free the DC.                                                         */
    /************************************************************************/
    DeleteDC(hdcMem);
    delete[] pMonoMask;
    if ( NULL == iconinfo.hbmMask)
    {
        DPF_ERR("Failed to create AND mask");
        DeleteObject( iconinfo.hbmColor );
        return NULL;
    }
    hCursor = (HCURSOR) CreateIconIndirect(&iconinfo);
    DeleteObject( iconinfo.hbmMask );
    DeleteObject( iconinfo.hbmColor );
    return hCursor;
}
HRESULT
CCursor::CursorInit(
    UINT xHotSpot,
    UINT yHotSpot,
    CBaseSurface *pCursorBitmap)
{
    HRESULT hr=S_OK;
    D3DSURFACE_DESC desc;
    HCURSOR oscursor;
    ICONINFO    cursorinfo;
    BITMAP  bmColor;
    BITMAP  bmMask;
    HDC hdcBitmap;
    HDC hdcCursorDdb;
    ZeroMemory(&cursorinfo, sizeof cursorinfo);
    m_dwCursorFlags &= ~DDRAWI_CURSORINIT;
    if (NULL != pCursorBitmap)
    {
        hr = pCursorBitmap->GetDesc(&desc);
        DXGASSERT(SUCCEEDED(hr));

        if (desc.Format != D3DFMT_A8R8G8B8)
        {
            DPF_ERR("Invalid Format for pCursorBitmap. Must be D3DFMT_A8R8G8B8");
            return D3DERR_INVALIDCALL;
        }

        if ((desc.Width -1) & desc.Width)
        {
            DPF_ERR("Failed to Initialize Cursor: Width must be a 2^n");
            return D3DERR_INVALIDCALL;
        }

        if ((desc.Height -1) & desc.Height)
        {
            DPF_ERR("Failed to Initialize Cursor: Height must be a 2^n");
            return D3DERR_INVALIDCALL;
        }

        if (desc.Width > m_pDevice->DisplayWidth())
        {
            DPF_ERR("Cursor Width must be smaller than DisplayWidth");
            return D3DERR_INVALIDCALL;
        }

        if (desc.Height > m_pDevice->DisplayHeight())
        {
            DPF_ERR("Cursor Height must be smaller than DisplayHeight");
            return D3DERR_INVALIDCALL;
        }
        if (desc.Width <= xHotSpot)
        {
            DPF_ERR("Cursor xHotSpot must be smaller than its Width");
            return D3DERR_INVALIDCALL;
        }
        if (desc.Height <= yHotSpot)
        {
            DPF_ERR("Cursor yHotSpot must be smaller than its Height");
            return D3DERR_INVALIDCALL;
        }
    }
    else if ( NULL == m_hCursorDdb)
    {
        oscursor = SetCursor(NULL);
        if (oscursor)
            m_hOsCursor = oscursor;
        else if (m_hOsCursor)
            oscursor = m_hOsCursor;

        desc.Width = GetSystemMetrics(SM_CXCURSOR);
        desc.Height = GetSystemMetrics(SM_CYCURSOR);    //default
        
        if (oscursor && GetIconInfo(oscursor,&cursorinfo))
        {
            GetObject( cursorinfo.hbmMask, sizeof(BITMAP), &bmMask );
            desc.Width = bmMask.bmWidth;
            if (cursorinfo.hbmColor)
            {
                GetObject( cursorinfo.hbmColor, sizeof(BITMAP), &bmColor );
                desc.Height = bmColor.bmHeight;  //color cursor has only AND mask
            }
            else
            {
                desc.Height = bmMask.bmHeight/2;
            }            
        }
    }
    else
        return  S_OK;
    
    const D3D8_DRIVERCAPS* pDriverCaps=m_pDevice->GetCoreCaps();
    if ((NULL != pCursorBitmap)
        && (
            (
                 // either driver says it can support
                (
                  (D3DCURSORCAPS_COLOR & pDriverCaps->D3DCaps.CursorCaps)
                  &&
                  (
                    (400 <= pDriverCaps->DisplayHeight) 
                    ||
                    (D3DCURSORCAPS_LOWRES & pDriverCaps->D3DCaps.CursorCaps)
                  )
                ) 
                && ((UINT)GetSystemMetrics(SM_CXCURSOR) == desc.Width) 
                && ((UINT)GetSystemMetrics(SM_CYCURSOR) == desc.Height)
            )
            // or windowed case where we have to use OS cursor
            ||
            m_pDevice->SwapChain()->m_PresentationData.Windowed
            // or there is no ddraw support
            ||
            m_pDevice->Enum()->NoDDrawSupport(m_pDevice->AdapterIndex())
           )
       ) 
    {
        HCURSOR hCursor;

        if (!m_pDevice->SwapChain()->m_PresentationData.Windowed 
            && (NULL == m_hHWCursor))
        {
            SystemParametersInfo(SPI_GETMOUSETRAILS,0,&m_SavedMouseTrails,0);
            if (m_SavedMouseTrails > 1)
            {
                // always make sure it's disabled
                SystemParametersInfo(SPI_SETMOUSETRAILS,0,0,0);        
            }
        }
        hCursor = CreateColorCursor(xHotSpot,yHotSpot,
            desc.Width, desc.Height, pCursorBitmap);
        if ( NULL != hCursor)
        {
            if ( NULL != m_hHWCursor)
            {
                if ( GetCursor() == m_hHWCursor )
                    SetCursor(hCursor); // turn it on if it was on
                if (!DestroyIcon((HICON)m_hHWCursor))
                {
                    DPF_ERR("Failed to Destroy Old hwcursor Icon");
                }
            }
            else 
            if ( DDRAWI_CURSORISON & m_dwCursorFlags)
            {
                SetCursor(hCursor); // turn it on if it was on
                // make sure software cursor is off
                m_dwCursorFlags &= ~DDRAWI_CURSORISON;
            }
            m_hHWCursor = hCursor;
            m_dwCursorFlags |= DDRAWI_CURSORINIT;
            return S_OK;
        }
    }
    if (m_SavedMouseTrails > 1)
    {
        SystemParametersInfo(SPI_SETMOUSETRAILS,m_SavedMouseTrails,0,0);        
        m_SavedMouseTrails = 0;
    }
    SetCursor(NULL);
    if ( NULL != m_hHWCursor )
    {
        if (!DestroyIcon((HICON)m_hHWCursor))
        {
            DPF_ERR("Failed to Destroy Old hwcursor Icon");
        }
        m_hHWCursor = NULL;
    }

    if (desc.Width != m_Width || desc.Height != m_Height)
    {
        DDSURFACEINFO SurfInfoArray[3];
        D3D8_CREATESURFACEDATA CreateSurfaceData;
        ZeroMemory(&CreateSurfaceData, sizeof(CreateSurfaceData));

        Destroy();
        ZeroMemory(SurfInfoArray, sizeof(SurfInfoArray));
        for (int i = 0; i < 3; i++)
        {
            SurfInfoArray[i].cpWidth = desc.Width;
            SurfInfoArray[i].cpHeight = desc.Height;
            ZeroMemory(&CreateSurfaceData, sizeof(CreateSurfaceData));
            CreateSurfaceData.hDD      = m_pDevice->GetHandle();
            CreateSurfaceData.pSList   = &SurfInfoArray[i];
            CreateSurfaceData.dwSCnt   = 1;
            CreateSurfaceData.Type     = D3DRTYPE_SURFACE;
            CreateSurfaceData.Pool     = D3DPOOL_LOCALVIDMEM;
            CreateSurfaceData.dwUsage  = D3DUSAGE_OFFSCREENPLAIN;
            CreateSurfaceData.Format   = m_pDevice->DisplayFormat();
            CreateSurfaceData.MultiSampleType = D3DMULTISAMPLE_NONE;
            hr = m_pDevice->GetHalCallbacks()->CreateSurface(&CreateSurfaceData);
            if (NULL == SurfInfoArray[i].hKernelHandle)
            {
                CreateSurfaceData.Pool  = D3DPOOL_SYSTEMMEM;
                hr = m_pDevice->GetHalCallbacks()->CreateSurface(&CreateSurfaceData);
            } 
            DPF(10,"CursorInit CreateSurface returns hr=%08lx handle=%08lx",
                hr, SurfInfoArray[i].hKernelHandle);
        }

        m_hCursorDdb = SurfInfoArray[0].hKernelHandle;

        m_hFrontSave = SurfInfoArray[1].hKernelHandle;

        m_hBackSave = SurfInfoArray[2].hKernelHandle; 
        if (m_hCursorDdb && m_hFrontSave && m_hBackSave)
        {
            m_Width = desc.Width;
            m_Height = desc.Height;
        }
        else
        {
            DPF_ERR("Cursor not available for this device");
            return D3DERR_NOTAVAILABLE;        
        }
    }
    if (NULL != pCursorBitmap)
    {
        D3D8_LOCKDATA lockData;
        D3DLOCKED_RECT lock;
        DWORD   *pSourceBitmap;
        INT     SourcePitch;
        ZeroMemory(&lockData, sizeof lockData);
        hr = pCursorBitmap->LockRect(&lock, NULL, 0);
        if (FAILED(hr))
        {
            DPF_ERR("Failed to lock pCursorBitmap surface; Surface must be lockable.");
            return D3DERR_INVALIDCALL;
        }

        lockData.hDD = m_pDevice->GetHandle();
        lockData.hSurface = m_hCursorDdb;
        hr = m_pDevice->GetHalCallbacks()->Lock(&lockData);
        if (FAILED(hr))
        {
            DPF_ERR("Failed to lock driver cursor surface.");
            pCursorBitmap->UnlockRect();
            return hr;
        }
        SourcePitch = lock.Pitch; 
        pSourceBitmap = (DWORD*)lock.pBits;
        switch (m_pDevice->DisplayFormat())
        {
        case D3DFMT_A1R5G5B5:
            {
                BYTE *pScan = (BYTE *) lockData.lpSurfData;
                for (UINT j = 0; j < m_Height; ++j)
                {
                    WORD *pPixel = (WORD *) pScan;
                    for (UINT i = 0; i < m_Width; ++i)
                    {
                        if (ISOPAQUE(pSourceBitmap[i]))
                        {
                            *pPixel = 
                                (WORD)FORMAT_8888_1555(pSourceBitmap[i]);
                            if (0 == (0x7FFF & *pPixel))
                                *pPixel |= 0x0421;  //off black color
                        }
                        else
                            *pPixel = 0;
                        pPixel ++;
                    }
                    pScan += lockData.lPitch;
                    pSourceBitmap += SourcePitch/4;
                }
            }
            break;

        case D3DFMT_X1R5G5B5:
            {
                BYTE *pScan = (BYTE *) lockData.lpSurfData;
                for (UINT j = 0; j < m_Height; ++j)
                {
                    WORD *pPixel = (WORD *) pScan;
                    for (UINT i = 0; i < m_Width; ++i)
                    {
                        if (ISOPAQUE(pSourceBitmap[i]))
                        {
                            *pPixel = 
                                (WORD)FORMAT_8888_555(pSourceBitmap[i]);
                            if (0 == *pPixel)
                                *pPixel |= 0x0421;  //off black color
                        }
                        else
                            *pPixel = 0;
                        pPixel ++;
                    }
                    pScan += lockData.lPitch;
                    pSourceBitmap += SourcePitch/4;
                }
            }
            break;

        case D3DFMT_R5G6B5:
            {
                BYTE *pScan = (BYTE *) lockData.lpSurfData;
                for (UINT j = 0; j < m_Height; ++j)
                {
                    WORD *pPixel = (WORD *) pScan;
                    for (UINT i = 0; i < m_Width; ++i)
                    {
                        if (ISOPAQUE(pSourceBitmap[i]))
                        {
                            *pPixel = 
                                (WORD)FORMAT_8888_565(pSourceBitmap[i]);
                            if (0 == *pPixel)
                                *pPixel |= 0x0821;  //off black color
                        }
                        else
                            *pPixel = 0;
                        pPixel ++;
                    }
                    pScan += lockData.lPitch;
                    pSourceBitmap += SourcePitch/4;
                }
            }
            break;

        case D3DFMT_X8R8G8B8:
            {
                BYTE *pScan = (BYTE *) lockData.lpSurfData;
                for (UINT j = 0; j < m_Height; ++j)
                {
                    DWORD *pPixel = (DWORD *) pScan;
                    for (UINT i = 0; i < m_Width; ++i)
                    {
                        if (ISOPAQUE(pSourceBitmap[i]))
                        {
                            *pPixel = pSourceBitmap[i] & 0x00FFFFFF;
                            if (0 == *pPixel)
                                *pPixel |= 0x010101;    //off black color
                        }
                        else
                            *pPixel = 0;
                        pPixel ++;
                    }
                    pScan += lockData.lPitch;
                    pSourceBitmap += SourcePitch/4;
                }
            }
            break;

        case D3DFMT_A8R8G8B8:
            {
                BYTE *pScan = (BYTE *) lockData.lpSurfData;
                for (UINT j = 0; j < m_Height; ++j)
                {
                    DWORD *pPixel = (DWORD *) pScan;
                    for (UINT i = 0; i < m_Width; ++i)
                    {
                        if (ISOPAQUE(pSourceBitmap[i]))
                        {
                            *pPixel = pSourceBitmap[i];
                            if (0 == (0x00FFFFFF & *pPixel))
                                *pPixel |= 0x010101;    //off black color
                        }
                        else
                            *pPixel = 0;
                        pPixel ++;
                    }
                    pScan += lockData.lPitch;
                    pSourceBitmap += SourcePitch/4;
                }
            }
            break;
        default:
            // this should never happen
            DDASSERT(FALSE);
        }
        D3D8_UNLOCKDATA unlockData;
        ZeroMemory(&unlockData, sizeof unlockData);

        unlockData.hDD = m_pDevice->GetHandle();
        unlockData.hSurface = m_hCursorDdb;
        hr = m_pDevice->GetHalCallbacks()->Unlock(&unlockData);
        if (FAILED(hr))
        {
            DPF_ERR("Driver surface failed to unlock driver cursor surface");
        }
        hr = pCursorBitmap->UnlockRect();
        if (FAILED(hr))
        {
            DPF_ERR("Driver surface failed to unlock pCursorBitmap");
        }
        m_xCursorHotSpot = xHotSpot;
        m_yCursorHotSpot = yHotSpot;
    }
    if (SUCCEEDED(hr))
        m_dwCursorFlags |= DDRAWI_CURSORINIT;
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME     "SetVisibility"
BOOL   
CCursor::SetVisibility(BOOL bVisible)
{
    BOOL    retval = FALSE;
    if (DDRAWI_CURSORINIT & m_dwCursorFlags)
    {
        if (NULL == m_hHWCursor)
        {
            retval = (BOOL) (DDRAWI_CURSORISON & m_dwCursorFlags);
            SetCursor(NULL);
            if (bVisible)
            {
                if (!retval)
                {
                    m_dwCursorFlags |= DDRAWI_CURSORISON;
                    Show(m_pDevice->SwapChain()->
                        PrimarySurface()->KernelHandle());
                    m_dwCursorFlags &= ~(DDRAWI_CURSORSAVERECT | DDRAWI_CURSORRECTSAVED);
                }
            }
            else
            {
                Hide(m_pDevice->SwapChain()->
                    PrimarySurface()->KernelHandle());
                m_dwCursorFlags &= ~(DDRAWI_CURSORISON | 
                    DDRAWI_CURSORSAVERECT | DDRAWI_CURSORRECTSAVED);
            }
        }
        else
        {
            if (m_hHWCursor == GetCursor())
            {
                if (!bVisible)
                    SetCursor(NULL);
                retval = TRUE;
            }
            else
            {
                if (bVisible)
                    SetCursor(m_hHWCursor);
                else
                    SetCursor(NULL);
            }
        }
    }
    return retval;
}
/*
 * SetCursorProperties
 *
 * Setup a cursor
 * This is the method visible to the outside world.
 */
#undef DPF_MODNAME
#define DPF_MODNAME     "SetProperties"
HRESULT 
CCursor::SetProperties(
    UINT    xHotSpot,
    UINT    yHotSpot,
    CBaseSurface *pCursorBitmap)
{
    HRESULT hr;
    DPF(10,"ENTERAPI: SetCursorProperties "
        "xh=%d yh=%d pCursorBitmap=%08lx",
        xHotSpot,yHotSpot,pCursorBitmap);

    m_dwCursorFlags &= ~(DDRAWI_CURSORSAVERECT | DDRAWI_CURSORRECTSAVED);
    hr = Hide(m_pDevice->SwapChain()
        ->PrimarySurface()->KernelHandle());

    if (FAILED(hr))
    {
        DPF_ERR("Failed to Hide Cursor.");
        return  hr;
    }

    hr = CursorInit(xHotSpot, yHotSpot, pCursorBitmap);
    if (FAILED(hr))
    {
        DPF_ERR("Failed to CursorInit.");
        return  hr;
    }

    hr = Show(m_pDevice->SwapChain()->PrimarySurface()->KernelHandle());

    return  hr;
}

/*
 * Cursor::SetPosition
 *
 * Setup a cursor
 * This is the method visible to the outside world.
 */
#undef DPF_MODNAME
#define DPF_MODNAME     "Cursor::SetPosition"

void 
CCursor::SetPosition(
    UINT xScreenSpace,
    UINT yScreenSpace,
    DWORD Flags)
{
    HRESULT hr = S_OK;
    if (DDRAWI_CURSORINIT & m_dwCursorFlags)
    {
        if ( m_hHWCursor)
        {
            if (xScreenSpace == m_xCursor && yScreenSpace == m_yCursor)
            {
                POINT   current;
                if (GetCursorPos(&current))
                {
                    if ((current.x == (INT)xScreenSpace + m_MonitorOrigin.x) &&
                        (current.y == (INT)yScreenSpace + m_MonitorOrigin.y)
                       )
                        return;
                }
            }
            else
            {
                m_xCursor = xScreenSpace;
                m_yCursor = yScreenSpace;
            }
            SetCursorPos(xScreenSpace+m_MonitorOrigin.x,
                yScreenSpace+m_MonitorOrigin.y);
            return;
        }
        if (xScreenSpace == m_xCursor && yScreenSpace == m_yCursor)
            return;
        // only emulated fullscreen cursor ever gets down here
        if (D3DCURSOR_IMMEDIATE_UPDATE & Flags)
            hr = Hide(m_pDevice->SwapChain()->PrimarySurface()->KernelHandle());
        else if (DDRAWI_CURSORISON & m_dwCursorFlags)
            m_dwCursorFlags |= DDRAWI_CURSORSAVERECT; 
        m_xCursor = xScreenSpace;
        m_yCursor = yScreenSpace;
        if (m_xCursor >= m_pDevice->DisplayWidth())
        {
            m_xCursor = m_pDevice->DisplayWidth()-1;
        }
        if (m_yCursor >= m_pDevice->DisplayHeight())
        {
            m_yCursor = m_pDevice->DisplayHeight()-1;
        }
        if (D3DCURSOR_IMMEDIATE_UPDATE & Flags)
        {
            hr = Show(m_pDevice->SwapChain()->PrimarySurface()->KernelHandle());
        }
    }
    else
    {
        m_xCursor = xScreenSpace;
        m_yCursor = yScreenSpace;
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\drvinfo.c ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	drvinfo.c
 *  Content:	DirectDraw driver info implementation
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   17-jun-98	jeffno  initial implementation, after michael lyons and toddla
 *   14-jun-99  mregen  return WHQL certification level -- postponed
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "ddrawpr.h"

#include <tchar.h>
#include <stdio.h>
#include <wincrypt.h>
#include <wintrust.h>
#include <softpub.h>
#include <mscat.h>



//========================================================================
//
// just some handy forward declarations
//
DWORD GetWHQLLevel(LPTSTR lpszDriver, LPSTR lpszWin9xDriver);
DWORD IsFileDigitallySigned(LPTSTR lpszDriver);
BOOL FileIsSignedOld(LPTSTR lpszFile);

//
//  These functions are defined in mscat.h. They are not available on win95,
//  so we have to use LoadLibrary to load mscat32.dll and wincrypt.dll
//
typedef HCATINFO WINAPI funcCryptCATAdminEnumCatalogFromHash(HCATADMIN hCatAdmin,
                                                             BYTE *pbHash,
                                                             DWORD cbHash,
                                                             DWORD dwFlags,
                                                             HCATINFO *phPrevCatInfo);
typedef BOOL WINAPI funcCryptCATAdminCalcHashFromFileHandle(HANDLE hFile,
                                                            DWORD *pcbHash,
                                                            BYTE *pbHash,
                                                            DWORD dwFlags);
typedef HANDLE WINAPI funcCryptCATOpen(LPWSTR pwszFileName, 
                                        DWORD fdwOpenFlags,
                                        HCRYPTPROV hProv,
                                        DWORD dwPublicVersion,
                                        DWORD dwEncodingType);
typedef BOOL WINAPI funcCryptCATClose(IN HANDLE hCatalog);
typedef CRYPTCATATTRIBUTE * WINAPI funcCryptCATGetCatAttrInfo(HANDLE hCatalog,
                                                           LPWSTR pwszReferenceTag);
typedef BOOL WINAPI      funcCryptCATAdminAcquireContext(HCATADMIN *phCatAdmin, 
                                                        GUID *pgSubsystem, 
                                                        DWORD dwFlags);
typedef BOOL WINAPI      funcCryptCATAdminReleaseContext(HCATADMIN hCatAdmin,
                                                         DWORD dwFlags);
typedef BOOL WINAPI funcCryptCATAdminReleaseCatalogContext(HCATADMIN hCatAdmin,
                                                       HCATINFO hCatInfo,
                                                       DWORD dwFlags);
typedef BOOL WINAPI funcCryptCATCatalogInfoFromContext(HCATINFO hCatInfo,
                                                   CATALOG_INFO *psCatInfo,
                                                   DWORD dwFlags);

typedef CRYPTCATATTRIBUTE * WINAPI funcCryptCATEnumerateCatAttr(HCATINFO hCatalog,
                                                           CRYPTCATATTRIBUTE *lpCat);


//
//  function defined in wincrypt.dll
//
typedef LONG WINAPI funcWinVerifyTrust(HWND hwnd, GUID *pgActionID,
                                  LPVOID pWVTData);

//
//  our storage for the mscat32/wincrypt dll loader
//
typedef struct tagCatApi {
    BOOL bInitialized;
    HINSTANCE hLibMSCat;
    HINSTANCE hLibWinTrust;
    HCATADMIN hCatAdmin;
    funcCryptCATClose *pCryptCATClose;
    funcCryptCATGetCatAttrInfo *pCryptCATGetCatAttrInfo;
    funcCryptCATOpen *pCryptCATOpen;
    funcCryptCATAdminEnumCatalogFromHash *pCryptCATAdminEnumCatalogFromHash;
    funcCryptCATAdminCalcHashFromFileHandle *pCryptCATAdminCalcHashFromFileHandle;
    funcCryptCATAdminAcquireContext *pCryptCATAdminAcquireContext;
    funcCryptCATAdminReleaseContext *pCryptCATAdminReleaseContext;
    funcCryptCATAdminReleaseCatalogContext *pCryptCATAdminReleaseCatalogContext;
    funcCryptCATCatalogInfoFromContext *pCryptCATCatalogInfoFromContext;
    funcCryptCATEnumerateCatAttr *pCryptCATEnumerateCatAttr;
    funcWinVerifyTrust *pWinVerifyTrust;
} CATAPI,* LPCATAPI;

//========================================================================
//
// some helper functions to open/close crypt API
//
#undef DPF_MODNAME
#define DPF_MODNAME "InitCATAPI"


BOOL InitCATAPI(LPCATAPI lpCatApi)
{
    UINT uiOldErrorMode;
    HINSTANCE hLibMSCat;
    HINSTANCE hLibWinTrust;

    DDASSERT(lpCatApi!=NULL);
    ZeroMemory(lpCatApi, sizeof(CATAPI));

    // already initialized by ZeroMemory
    // lpCatApi->bInitialized=FALSE:

    uiOldErrorMode=SetErrorMode(SEM_NOOPENFILEERRORBOX);
    hLibMSCat=LoadLibrary("mscat32.dll");
    hLibWinTrust=LoadLibrary("wintrust.dll");

    if (hLibMSCat!=NULL &&
        hLibWinTrust!=NULL)
    {
        lpCatApi->pCryptCATOpen=(funcCryptCATOpen *)
            GetProcAddress (hLibMSCat, "CryptCATOpen");
        lpCatApi->pCryptCATClose=(funcCryptCATClose *)
            GetProcAddress (hLibMSCat, "CryptCATClose");
        lpCatApi->pCryptCATGetCatAttrInfo=(funcCryptCATGetCatAttrInfo *)
            GetProcAddress (hLibMSCat, "CryptCATGetCatAttrInfo");
        lpCatApi->pCryptCATAdminCalcHashFromFileHandle=(funcCryptCATAdminCalcHashFromFileHandle*)
            GetProcAddress (hLibMSCat, "CryptCATAdminCalcHashFromFileHandle");
        lpCatApi->pCryptCATAdminEnumCatalogFromHash=(funcCryptCATAdminEnumCatalogFromHash*)
            GetProcAddress (hLibMSCat, "CryptCATAdminEnumCatalogFromHash");
        lpCatApi->pCryptCATAdminAcquireContext=(funcCryptCATAdminAcquireContext*)
            GetProcAddress (hLibMSCat, "CryptCATAdminAcquireContext");
        lpCatApi->pCryptCATAdminReleaseContext=(funcCryptCATAdminReleaseContext*)
            GetProcAddress (hLibMSCat, "CryptCATAdminReleaseContext");
        lpCatApi->pCryptCATAdminReleaseCatalogContext=(funcCryptCATAdminReleaseCatalogContext*)
            GetProcAddress (hLibMSCat, "CryptCATAdminReleaseCatalogContext");
        lpCatApi->pCryptCATCatalogInfoFromContext=(funcCryptCATCatalogInfoFromContext*)
            GetProcAddress (hLibMSCat, "CryptCATCatalogInfoFromContext");
        lpCatApi->pCryptCATEnumerateCatAttr=(funcCryptCATEnumerateCatAttr*)
            GetProcAddress (hLibMSCat, "CryptCATEnumerateCatAttr");
        lpCatApi->pWinVerifyTrust=(funcWinVerifyTrust*)
            GetProcAddress (hLibWinTrust,"WinVerifyTrust");

        if (lpCatApi->pCryptCATOpen!=NULL &&
            lpCatApi->pCryptCATClose!=NULL &&
            lpCatApi->pCryptCATGetCatAttrInfo!=NULL &&
            lpCatApi->pCryptCATAdminCalcHashFromFileHandle!=NULL &&
            lpCatApi->pCryptCATAdminEnumCatalogFromHash!=NULL &&
            lpCatApi->pCryptCATAdminAcquireContext!=NULL &&
            lpCatApi->pCryptCATAdminReleaseContext!=NULL &&
            lpCatApi->pCryptCATAdminReleaseCatalogContext!=NULL &&
            lpCatApi->pCryptCATCatalogInfoFromContext!=NULL &&
            lpCatApi->pCryptCATEnumerateCatAttr !=NULL &&
            lpCatApi->pWinVerifyTrust!=NULL
           )
        {
            if ((*lpCatApi->pCryptCATAdminAcquireContext)(&lpCatApi->hCatAdmin,NULL,0))
            {
                lpCatApi->hLibMSCat=hLibMSCat;
                lpCatApi->hLibWinTrust=hLibWinTrust;
                lpCatApi->bInitialized=TRUE;
            }
        } 
    }

    if (!lpCatApi->bInitialized)
    {
       FreeLibrary(hLibMSCat);
       FreeLibrary(hLibWinTrust);
    }

    SetErrorMode(uiOldErrorMode);

    return lpCatApi->bInitialized;
}

BOOL ReleaseCATAPI(LPCATAPI lpCatApi)
{
    DDASSERT(lpCatApi!=NULL);

    if (lpCatApi->bInitialized)
    {
        (*lpCatApi->pCryptCATAdminReleaseContext)(lpCatApi->hCatAdmin, 0);

        FreeLibrary(lpCatApi->hLibMSCat);
        FreeLibrary(lpCatApi->hLibWinTrust);
        ZeroMemory(lpCatApi, sizeof(CATAPI));        

        return TRUE;
    }

    return FALSE;
}

//========================================================================
//
// _strstr
//
// String-in-string function, written to avoid RTL inclusion necessity.
//
//========================================================================
char *_strstr(char *s1, char *s2)
{
	if (s1 && s2)
	{
		while (*s1)
		{
			char *p1=s1;
			char *p2=s2;

			while (*p2 && (*p1==*p2))
			{
				p1++;
				p2++;
			}
			if (*p2==0)
				return s1;

			s1++;
		}
	}

	return NULL;
}
//***&&*%**!!ing c runtime

DWORD _atoi(char * p)
{
    DWORD dw=0;
    while ((*p >= '0' && *p <= '9') || (*p >= 'A' && *p <= 'F') || (*p >= 'A' && *p <= 'F'))
    {
        dw = dw*16;
        if (*p >= 'a')
            dw += *p-'a' + 10;
        else if (*p >= 'A')
            dw += *p-'A' + 10;
        else
            dw += *p-'0';

        p++;
    }
    return dw;
}

char *FindLast(char * s, char c)
{
    char * pFound=0;
    if (s)
    {
        while (*s)
        {
            if (*s == c)
                pFound = s;
            s++;
        }
    }
    return pFound;
}

//========================================================================
// hard-coded vendor IDs
//========================================================================
#define VEN_3DFX			"VEN_121A"
#define VEN_3DFXVOODOO1                 "VEN_121A&DEV_0001"
#define VEN_POWERVR			"VEN_1033"

#ifdef WIN95

void GetFileVersionData (D3DADAPTER_IDENTIFIER8* pDI)
{
    void *				buffer;
    VS_FIXEDFILEINFO *	verinfo;
    DWORD				dwSize;
    DWORD                               dwHi,dwLo;

    //Failure means 0 returned
    pDI->DriverVersion.HighPart = 0;
    pDI->DriverVersion.LowPart = 0;

    dwSize = GetFileVersionInfoSize (pDI->Driver, 0);

    if (!dwSize)
    {
        return;
    }

    buffer=MemAlloc(dwSize);
    if (!buffer)
    {
        return;
    }

    if (!GetFileVersionInfo(pDI->Driver, 0, dwSize, buffer))
    {
        MemFree(buffer);
        return;
    }

    if (!VerQueryValue(buffer, "\\", (void **)&verinfo, (UINT *)&dwSize))
    {
        MemFree(buffer);
        return;
    }

    pDI->DriverVersion.HighPart = verinfo->dwFileVersionMS;
    pDI->DriverVersion.LowPart  = verinfo->dwFileVersionLS;

    MemFree(buffer);
}

extern HRESULT _GetDriverInfoFromRegistry(char *szClass, char *szClassNot, char *szVendor, D3DADAPTER_IDENTIFIER8* pDI, char *szDeviceID);

/*
 * following are all the 9x-specific version functions
 */
void GetHALName(char* pDriverName, D3DADAPTER_IDENTIFIER8* pDI)
{
    pDI->Driver[0] = '\0';
    D3D8GetHALName(pDriverName, pDI->Driver);
}


BOOL CheckPowerVR(D3DADAPTER_IDENTIFIER8* pDI)
{
#if 0
    BOOL    bFound=FALSE;
    HKEY    hKey;
    DWORD   dwSize;
    DWORD   dwType;

    if (pdrv->dwFlags & DDRAWI_SECONDARYDRIVERLOADED)
    {
        /*
         * Any secondary driver information in the registry at all? (assert this is true)
         */
        if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,
                                         REGSTR_PATH_SECONDARY,
                                        &hKey))
        {
            /*
             * Extract the name of the secondary driver's DLL. (assert this works)
             */
            dwSize = sizeof(pDI->di.szDriver) - 1;
            if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                                  REGSTR_VALUE_SECONDARY_DRIVERNAME,
                                                  NULL,
                                                  &dwType,
                                                  pDI->di.szDriver,
                                                  &dwSize))
            {
                if (REG_SZ == dwType)
                {
                    GetFileVersionData(pDI);
                }
            }
            RegCloseKey(hKey);
        }

        if (SUCCEEDED(_GetDriverInfoFromRegistry(NULL, "Display", VEN_POWERVR, pDI)))
        {
            //got PVR data...
            bFound = TRUE;
        }
    }
    return bFound;
#endif
    return TRUE;
}

HRESULT Check3Dfx (D3DADAPTER_IDENTIFIER8* pDI)
{
    HRESULT hr = S_OK;
    char    szDeviceID[MAX_DDDEVICEID_STRING];

    if (FAILED(_GetDriverInfoFromRegistry(NULL, "Display", VEN_3DFX, pDI, szDeviceID)))
    {
        DPF_ERR("Couldn't get registry data for this device");
        hr = E_FAIL;
    }

    return hr;
}

HRESULT GetDriverInfoFromRegistry(char *szClass, char *szClassNot, char *szVendor, D3DADAPTER_IDENTIFIER8* pDI, char *szDeviceID)
{
    return _GetDriverInfoFromRegistry(szClass, szClassNot, szVendor, pDI, szDeviceID);
}


/*
 * Given a DISPLAY_DEVICE, get driver name
 * NOTE::: THIS FUNCTION NUKES THE DISPLAY_DEVICE.DeviceKey STRING!!!!
 */
void GetWin9XDriverName(DISPLAY_DEVICEA * pdd, LPSTR pDrvName)
{
    HKEY hKey;

    lstrcat(pdd->DeviceKey, "\\DEFAULT");
    if (ERROR_SUCCESS == RegOpenKeyEx(
                            HKEY_LOCAL_MACHINE,
                            pdd->DeviceKey,
                            0,
                            KEY_QUERY_VALUE ,
                            &hKey))
    {
        DWORD dwSize = MAX_DDDEVICEID_STRING;
        DWORD dwType = 0;

        RegQueryValueEx(hKey,
                         TEXT("drv"),
                         NULL,
                         &dwType,
                         pDrvName,
                         &dwSize);

        RegCloseKey(hKey);
    }
}

#else //win95


HRESULT Check3Dfx(D3DADAPTER_IDENTIFIER8* pDI)
{
    return E_FAIL;
}

HRESULT GetDriverInfoFromRegistry(char *szClass, char *szClassNot, char *szVendor, D3DADAPTER_IDENTIFIER8* pDI, char *szDeviceID)
{
    return E_FAIL;
}

/*
 * Given a DISPLAY_DEVICE, get driver name, assuming winnt5
 * NOTE::: THIS FUNCTION NUKES THE DISPLAY_DEVICE.DeviceKey STRING!!!!
 */
void GetNTDriverNameAndVersion(DISPLAY_DEVICEA * pdd, D3DADAPTER_IDENTIFIER8* pDI)
{
    HKEY                hKey;
    void*               buffer;
    DWORD               dwSize;
    VS_FIXEDFILEINFO*   verinfo;

    //
    //  old style to determine display driver...returns name of miniport!
    //

    char * pTemp;

    // The device key has the form blah\blah\services\<devicekey>\DeviceN
    // So we back up one node:
    if ((pTemp = FindLast(pdd->DeviceKey,'\\')))
    {
        char * pTempX;
        char cOld=*pTemp;
        *pTemp = 0;

        //If we back up one node, we'll have the registry key under which the driver is stored. Let's use that!
        if ((pTempX = FindLast(pdd->DeviceKey,'\\')))
        {
            lstrcpyn(pDI->Driver, pTemp+1, sizeof(pDI->Driver));
            //ATTENTION No point getting version data without a filname:
            //We need a new service or something to get the used display driver name
            //GetFileVersionData(pDI);
        }

        *pTemp=cOld;
    }

    //
    //  we can find the display driver in a registry key
    //
    //  note: InstalledDisplayDrivers can contain several entries
    //  to display drivers Since there is no way to find out which
    //  one is the active one, we always return the first as being
    //  the display driver!
    //
    if (ERROR_SUCCESS == RegOpenKeyEx(
                         HKEY_LOCAL_MACHINE,
                         pdd->DeviceKey+18,
                         0,
                         KEY_QUERY_VALUE ,
                        &hKey))
        {
        DWORD dwSize = sizeof(pDI->Driver);
        DWORD dwType = 0;
        if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                              TEXT("InstalledDisplayDrivers"),
                                              NULL,
                                              &dwType,
                                              pDI->Driver,
                                              &dwSize))
        {   
            lstrcat(pDI->Driver, TEXT(".dll"));
        }

        RegCloseKey(hKey);
    }

    // We have the name, now get the version

    pDI->DriverVersion.HighPart = 0;
    pDI->DriverVersion.LowPart = 0;

    dwSize=GetFileVersionInfoSize(pDI->Driver, 0);
    if (dwSize == 0)
        return;

    buffer = MemAlloc(dwSize);
    if (buffer == NULL)
        return;

    if (!GetFileVersionInfo(pDI->Driver, 0, dwSize, buffer))
    {
        MemFree(buffer);
        return;
    }

    if (!VerQueryValue(buffer, "\\", (void **)&verinfo, (UINT *)&dwSize))
    {
        MemFree(buffer);
        return;
    }

    pDI->DriverVersion.HighPart = verinfo->dwFileVersionMS;
    pDI->DriverVersion.LowPart  = verinfo->dwFileVersionLS;

    MemFree(buffer);
}
#endif //win95



void GenerateIdentifier(D3DADAPTER_IDENTIFIER8* pDI)
{
    LPDWORD pdw;

    CopyMemory(&pDI->DeviceIdentifier, &CLSID_DirectDraw, sizeof(pDI->DeviceIdentifier));

    //The device IDs get XORed into the whole GUID with the vendor and device ID in the 
    //first two DWORDs so they don't get XORed with anything else. This makes it 
    DDASSERT(sizeof(GUID) >= 4*sizeof(DWORD));
    pdw = (LPDWORD) &pDI->DeviceIdentifier;
    pdw[0] ^= pDI->VendorId;
    pdw[1] ^= pDI->DeviceId;
    pdw[2] ^= pDI->SubSysId;
    pdw[3] ^= pDI->Revision;

    // The driver version gets XORed into the last two DWORDs of the GUID:
    pdw[2] ^= pDI->DriverVersion.LowPart;
    pdw[3] ^= pDI->DriverVersion.HighPart;
}


void ParseDeviceId(D3DADAPTER_IDENTIFIER8* pDI, char *szDeviceID)
{
    char * p;

    DPF(5,"Parsing %s",szDeviceID);

    pDI->VendorId = 0;
    pDI->DeviceId = 0;
    pDI->SubSysId = 0;
    pDI->Revision = 0;

    if (p =_strstr(szDeviceID, "VEN_"))
        pDI->VendorId = _atoi(p + 4);

    if (p = _strstr(szDeviceID, "DEV_"))
        pDI->DeviceId = _atoi(p + 4);

    if (p = _strstr(szDeviceID, "SUBSYS_"))
        pDI->SubSysId = _atoi(p + 7);

    if (p = _strstr(szDeviceID, "REV_"))
        pDI->Revision = _atoi(p + 4);
}



void GetAdapterInfo(char* pDriverName, D3DADAPTER_IDENTIFIER8* pDI, BOOL bDisplayDriver, BOOL bGuidOnly, BOOL bDriverName)
{
    HRESULT                     hr = S_OK;
    int                         n;
    DISPLAY_DEVICEA             dd;
    BOOL                        bFound;
    char                        szDeviceID[MAX_DDDEVICEID_STRING];
#ifndef WINNT
    static char                 szWin9xName[MAX_DDDEVICEID_STRING];
#endif

    memset(pDI, 0, sizeof(*pDI));
    szDeviceID[0] = 0;
    #ifndef WINNT

        // On Win9X, it's pretty expensive to get the driver name, so we
        // only want to get it when we really need it
        
        szWin9xName[0] = '\0';
        if (bDriverName)
        {
            GetHALName(pDriverName, pDI);
            GetFileVersionData(pDI);
        }
    #endif

    // If it's a 3dfx, it's easy
      
    if (!bDisplayDriver)
    {
        hr = Check3Dfx(pDI);
    }
    else
    {
        // Not a 3dfx.  Next step: Figure out which display device we 
        // really are and get description string for it
                         
        ZeroMemory(&dd, sizeof(dd));
        dd.cb = sizeof(dd);

        bFound=FALSE;

        for(n=0; xxxEnumDisplayDevicesA(NULL, n, &dd, 0); n++)
        {
            if (0 == _stricmp(dd.DeviceName, pDriverName))
            {
                // Found the device. Now we can get some data for it.
                                
                lstrcpyn(pDI->Description, dd.DeviceString, sizeof(pDI->Description));
                lstrcpyn(szDeviceID, dd.DeviceID, sizeof(szDeviceID));

                bFound = TRUE;

                #ifdef WINNT
                    GetNTDriverNameAndVersion(&dd,pDI);
                #else
                    GetWin9XDriverName(&dd, szWin9xName);
                    if (pDI->Driver[0] == '\0')
                    {
                        lstrcpyn(pDI->Driver, szWin9xName, sizeof(pDI->Driver));
                    }
                #endif

                break;
            }

            ZeroMemory(&dd, sizeof(dd));
            dd.cb = sizeof(dd);
        }

        if (!bFound)
        {
            // Didn't find it: xxxEnumDisplayDevices failed, i.e. we're on 9x or NT4,
                            
            if (FAILED(GetDriverInfoFromRegistry("Display", NULL, NULL, pDI, szDeviceID)))
            {
                return;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        ParseDeviceId(pDI, szDeviceID);

        // Finally, for the primary only, check if a PowerVR is in and functioning
#if 0                
        if (0 == (dwFlags & DDGDI_GETHOSTIDENTIFIER))
        {
            if (IsVGADevice(pdrv->cDriverName) && CheckPowerVR(pDI))
            {
                ParseDeviceId(pDI, szDeviceID);
            }
        }
#endif

        // Munge driver version and ID into the identifier GUID.
                         
        GenerateIdentifier(pDI);

        // Now get the WHQL level

        if (!bGuidOnly)
        {
            #ifdef WINNT
                pDI->WHQLLevel = GetWHQLLevel((LPTSTR)pDI->Driver, NULL);
            #else
                pDI->WHQLLevel = GetWHQLLevel((LPTSTR)pDI->Driver, szWin9xName);
            #endif
        }
        else
        {
            pDI->WHQLLevel = 0;
        }
    }
}


/*
 * Voodoo1GoodToGo
 *
 * The Voodoo 1 driver will succeed the CreateDC call on Voodoo 2, Voodoo 3,
 * or Banshee hardware, but if we use the driver beyond that it will hang
 * the hardware.  This is a work around to not enumerate a Voodoo 1
 * driver if the hardware isn't there.
 *
 * To our knowledge, only two guids were ever used to enumerate Voodoo1
 * hardware, so we will look for those guids and assume that anything else
 * doesn't need to be checked.
 */
BOOL Voodoo1GoodToGo(GUID * pGuid)
{
    D3DADAPTER_IDENTIFIER8  DI;

    if (IsEqualIID(pGuid, &guidVoodoo1A) || IsEqualIID(pGuid, &guidVoodoo1B))
    {
        #ifdef WIN95
            char    szDeviceID[MAX_DDDEVICEID_STRING];

            /*
             * Now search the hardware enum key to see if Voodoo 1 hardware exists
             */
            if (FAILED(_GetDriverInfoFromRegistry(NULL, "Display", VEN_3DFXVOODOO1, &DI, szDeviceID)))
            {
                return FALSE;
            }
        #else
            return FALSE;
        #endif
    }
    return TRUE;
}

#ifndef WINNT
/****************************************************************************
 *
 *  FileIsSignedOld
 *
 *  find win95 style of signature
 *
 ****************************************************************************/
BOOL FileIsSignedOld(LPTSTR lpszFile)
{
typedef struct tagIMAGE_DOS_HEADER      // DOS .EXE header
{
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
} IMAGE_DOS_HEADER, * PIMAGE_DOS_HEADER, FAR* LPIMAGE_DOS_HEADER;

typedef struct tagIMAGE_OS2_HEADER      // OS/2 .EXE header
{
    WORD   ne_magic;                    // Magic number
    CHAR   ne_ver;                      // Version number
    CHAR   ne_rev;                      // Revision number
    WORD   ne_enttab;                   // Offset of Entry Table
    WORD   ne_cbenttab;                 // Number of bytes in Entry Table
    LONG   ne_crc;                      // Checksum of whole file
    WORD   ne_flags;                    // Flag word
    WORD   ne_autodata;                 // Automatic data segment number
    WORD   ne_heap;                     // Initial heap allocation
    WORD   ne_stack;                    // Initial stack allocation
    LONG   ne_csip;                     // Initial CS:IP setting
    LONG   ne_sssp;                     // Initial SS:SP setting
    WORD   ne_cseg;                     // Count of file segments
    WORD   ne_cmod;                     // Entries in Module Reference Table
    WORD   ne_cbnrestab;                // Size of non-resident name table
    WORD   ne_segtab;                   // Offset of Segment Table
    WORD   ne_rsrctab;                  // Offset of Resource Table
    WORD   ne_restab;                   // Offset of resident name table
    WORD   ne_modtab;                   // Offset of Module Reference Table
    WORD   ne_imptab;                   // Offset of Imported Names Table
    LONG   ne_nrestab;                  // Offset of Non-resident Names Table
    WORD   ne_cmovent;                  // Count of movable entries
    WORD   ne_align;                    // Segment alignment shift count
    WORD   ne_cres;                     // Count of resource segments
    BYTE   ne_exetyp;                   // Target Operating system
    BYTE   ne_flagsothers;              // Other .EXE flags
    WORD   ne_pretthunks;               // offset to return thunks
    WORD   ne_psegrefbytes;             // offset to segment ref. bytes
    WORD   ne_swaparea;                 // Minimum code swap area size
    WORD   ne_expver;                   // Expected Windows version number
} IMAGE_OS2_HEADER, * PIMAGE_OS2_HEADER, FAR* LPIMAGE_OS2_HEADER;

typedef struct tagWINSTUB
{
    IMAGE_DOS_HEADER idh;
    BYTE             rgb[14];
} WINSTUB, * PWINSTUB, FAR* LPWINSTUB;

typedef struct tagFILEINFO
{
    BYTE   cbInfo[0x120];
} FILEINFO, * PFILEINFO, FAR* LPFILEINFO;


    FILEINFO           fi;
    int                nRC;
    LPIMAGE_DOS_HEADER lpmz;
    LPIMAGE_OS2_HEADER lpne;
    BYTE               cbInfo[9+32+2];
    BOOL               IsSigned = FALSE;
    OFSTRUCT           OpenStruct;
    HFILE              hFile;

    static WINSTUB winstub = {
        {
            IMAGE_DOS_SIGNATURE,            /* magic */
            0,                              /* bytes on last page - varies */
            0,                              /* pages in file - varies */
            0,                              /* relocations */
            4,                              /* paragraphs in header */
            1,                              /* min allocation */
            0xFFFF,                         /* max allocation */
            0,                              /* initial SS */
            0xB8,                           /* initial SP */
            0,                              /* checksum (ha!) */
            0,                              /* initial IP */
            0,                              /* initial CS */
            0x40,                           /* lfarlc */
            0,                              /* overlay number */
            { 0, 0, 0, 0},                 /* reserved */
           0,                              /* oem id */
            0,                              /* oem info */
            0,                              /* compiler bug */
            { 0},                          /* reserved */
            0x80,                           /* lfanew */
        },
        {
            0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD,
            0x21, 0xB8, 0x01, 0x4C, 0xCD, 0x21,
        }
    };

    OpenStruct.cBytes = sizeof(OpenStruct);
    lstrcpyn(OpenStruct.szPathName, lpszFile, OFS_MAXPATHNAME);
    hFile = OpenFile(lpszFile, &OpenStruct, OF_READ);
    if (hFile == HFILE_ERROR)
    {
        return FALSE;
    }

    nRC = 0;
    ReadFile((HANDLE) hFile, (LPVOID)&fi, sizeof(FILEINFO), &nRC, NULL);
    if (nRC != sizeof(FILEINFO))
    {
        goto FileIsSigned_exit;
    }

    lpmz = (LPIMAGE_DOS_HEADER)(&fi);
    lpne = (LPIMAGE_OS2_HEADER)((WORD)&fi + 0x80);

    winstub.idh.e_cblp = lpmz->e_cblp;
    winstub.idh.e_cp   = lpmz->e_cp;

    if (memcmp(&fi, &winstub, sizeof(winstub)) == 0)
    {
        goto FileIsSigned_exit;
    }

    memcpy(cbInfo, &((PWINSTUB)(&fi)->cbInfo)->rgb[14], sizeof(cbInfo));

    if ((cbInfo[4]      != ' ') ||    // space
         (cbInfo[8]      != ' ') ||    // space
         (cbInfo[9+32]   != '\n') ||    // return
         (cbInfo[9+32+1] != '$'))     // Dollar Sign
    {
        goto FileIsSigned_exit;
    }

    cbInfo[4] = 0;
    cbInfo[8] = 0;

    if ((strcmp((const char*)&cbInfo[0], "Cert") != 0) ||
         (strcmp((const char*)&cbInfo[5], "DX2")  != 0))
    {
        goto FileIsSigned_exit;
    }

    IsSigned=TRUE;

    FileIsSigned_exit:

    _lclose(hFile);

    return IsSigned;
}
#endif


/*
 * GetWHQLLevel - On Win95, look for old stamp only.  On Win2000, use digital
 *		signature only.  On Win98, look for old stamp first, then digital signature
 *		if no old stamp.
 *
 *      return 0 -- unsigned or uncertified
 *      return 1 -- driver certified
 *      return 1997 -- driver certified, PC97 compliant...
 *      return 1998...
 *
 *
 * arguments:
 *      
 * lpszDriver----Path of driver file
 * 
 */

DWORD GetWHQLLevel(LPTSTR lpszDriver, LPSTR lpszWin9xDriver)
{
    TCHAR szTmp[MAX_PATH];
    DWORD dwWhqlLevel = 0;

    // here we should rather call 
    if (GetSystemDirectory(szTmp, MAX_PATH-lstrlen(lpszDriver)-2)==0)
        return 0;

    lstrcat(szTmp, TEXT("\\"));
    lstrcat(szTmp, lpszDriver); 
    _tcslwr(szTmp);

    //
    // Look for a digital signature
    //
    dwWhqlLevel = IsFileDigitallySigned(szTmp);
    if (dwWhqlLevel != 0)
    {
        return dwWhqlLevel;
    }


#ifndef WINNT 
    
    // It wasn't digitally signed, but it may still have been signed
    // the old way.  On Win9X, however, lpszDriver actually contains the
    // 32 bit HAL name rather than the display driver, but we typically only
    // signed the display driver, so we should use lpszWin9xDriver.

    if (lpszWin9xDriver[0] != '\0')
    {
        GetSystemDirectory(szTmp, MAX_PATH-lstrlen(lpszWin9xDriver)-2);
        lstrcat(szTmp, TEXT("\\"));
        lstrcat(szTmp, lpszWin9xDriver); 
    }
    else
    {
        GetSystemDirectory(szTmp, MAX_PATH-lstrlen(lpszDriver)-2);
        lstrcat(szTmp, TEXT("\\"));
        lstrcat(szTmp, lpszDriver); 
    }

    if (FileIsSignedOld(szTmp))
    {
        return 1;
    }
#endif

    return 0;
}


DWORD IsFileDigitallySigned(LPTSTR lpszDriver)
{
    DWORD  dwWHQLLevel=0;         // default, driver not certified
    CATAPI catapi;
    WCHAR *lpFileName;
    DRIVER_VER_INFO VerInfo;
    TCHAR szBuffer[50];
    LPSTR lpAttr;
#ifndef UNICODE
    WCHAR wszDriver[MAX_PATH];
    MultiByteToWideChar(CP_ACP, 0, lpszDriver, -1, wszDriver, MAX_PATH);
    lpFileName = wcsrchr(wszDriver, TEXT('\\'));
    if (lpFileName==NULL)
    {
        lpFileName = wszDriver;
    }
    else
    {
        lpFileName++;
    }
#else
    lpFileName = _tcsrchr(lpszDriver, TEXT('\\'));
    if (lpFileName==NULL) lpFileName = lpszDriver;
#endif


    //
    //  try to load and initialize the mscat32.dll and wintrust.dll
    //  these dlls are not available on win95
    //
    if (InitCATAPI(&catapi))
    {
        HANDLE hFile;
        DWORD  cbHashSize=0;
        BYTE  *pbHash;
        BOOL   bResult;

        //
        //  create a handle to our driver, because cat api wants handle to file
        //
        hFile = CreateFile(lpszDriver,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            0,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            0
                           );

        if (hFile!=INVALID_HANDLE_VALUE) 
        {
            // first query hash size...
            bResult=(*catapi.pCryptCATAdminCalcHashFromFileHandle)(hFile,
                                &cbHashSize,
                                NULL,
                                0);
            pbHash=NULL;
            if (bResult)
            {
                // allocate hash
                pbHash = MemAlloc(cbHashSize);                                       
            } 

            if (pbHash!=NULL)
            {
                HCATINFO hPrevCat=NULL;
                HANDLE hCatalog=NULL;
                WINTRUST_DATA WinTrustData;
                WINTRUST_CATALOG_INFO WinTrustCatalogInfo;
                GUID  guidSubSystemDriver = DRIVER_ACTION_VERIFY;
                CRYPTCATATTRIBUTE *lpCat = NULL;

                //
                //  Now get the hash for our file
                //

                bResult=(*catapi.pCryptCATAdminCalcHashFromFileHandle)(hFile,
                                    &cbHashSize,
                                    pbHash,
                                    0);

                if (bResult)
                {
                    hCatalog=(*catapi.pCryptCATAdminEnumCatalogFromHash)(
                                    catapi.hCatAdmin,
                                    pbHash,
                                    cbHashSize,
                                    0,
                                    &hPrevCat);
                }

                //
                // Initialize the structures that
                // will be used later on in calls to WinVerifyTrust.
                //
                ZeroMemory(&WinTrustData, sizeof(WINTRUST_DATA));
                WinTrustData.cbStruct = sizeof(WINTRUST_DATA);
                WinTrustData.dwUIChoice = WTD_UI_NONE;
                WinTrustData.fdwRevocationChecks = WTD_REVOKE_NONE;
                WinTrustData.dwUnionChoice = WTD_CHOICE_CATALOG;
                WinTrustData.dwStateAction = WTD_STATEACTION_AUTO_CACHE;
                WinTrustData.pPolicyCallbackData = (LPVOID)&VerInfo;

                ZeroMemory(&VerInfo, sizeof(DRIVER_VER_INFO));
                VerInfo.cbStruct = sizeof(DRIVER_VER_INFO);

                WinTrustData.pCatalog = &WinTrustCatalogInfo;
        
                ZeroMemory(&WinTrustCatalogInfo, sizeof(WINTRUST_CATALOG_INFO));
                WinTrustCatalogInfo.cbStruct = sizeof(WINTRUST_CATALOG_INFO);
                WinTrustCatalogInfo.pbCalculatedFileHash = pbHash;
                WinTrustCatalogInfo.cbCalculatedFileHash = cbHashSize;
                WinTrustCatalogInfo.pcwszMemberTag = lpFileName;

                while (hCatalog)
                {
                    CATALOG_INFO CatInfo;

                    ZeroMemory(&CatInfo, sizeof(CATALOG_INFO));
                    CatInfo.cbStruct = sizeof(CATALOG_INFO);
                    if ((*catapi.pCryptCATCatalogInfoFromContext)(hCatalog, &CatInfo, 0)) 
                    {
                        HRESULT hRes;

                        WinTrustCatalogInfo.pcwszCatalogFilePath = CatInfo.wszCatalogFile;

                        // Now verify that the file is an actual member of the catalog.
                        hRes = (*catapi.pWinVerifyTrust)
                            (NULL, &guidSubSystemDriver, &WinTrustData);

                        if (hRes == ERROR_SUCCESS)
                        {
                            //
                            // Our driver is certified!  Now see if the cat
                            // info contains the WHQL level
                            //
                            CRYPTCATATTRIBUTE *lpCat = NULL;
                            HANDLE hCat;

                            dwWHQLLevel=1;              // return "certified"

                            hCat =  (*catapi.pCryptCATOpen)(CatInfo.wszCatalogFile, (DWORD)CRYPTCAT_OPEN_EXISTING, (HCRYPTPROV)NULL, 0, 0);
                            lpCat = (*catapi.pCryptCATGetCatAttrInfo) (hCat, L"KV_DISPLAY");
                            if (lpCat != NULL)
                            {
                                WideCharToMultiByte(CP_ACP, 0, (PUSHORT)lpCat->pbValue, -1, szBuffer, 50, NULL, NULL);

                                // The value looks like "1:yyyy-mm-dd".
          
                                lpAttr = _strstr(szBuffer, ":");
                                lpAttr++;
                                lpAttr[4] = '\0';
                                dwWHQLLevel = atoi(lpAttr) * 0x10000;
                                lpAttr[7] = '\0';
                                dwWHQLLevel |= atoi(&lpAttr[5]) * 0x100;
                                dwWHQLLevel |= atoi(&lpAttr[8]);
                            }

                            (*catapi.pCryptCATClose)(hCat);
                            break;
                        }
                    }

                    //
                    // iterate through catalogs...
                    //
                    hPrevCat=hCatalog;
                    hCatalog=(*catapi.pCryptCATAdminEnumCatalogFromHash)(
                                catapi.hCatAdmin,
                                pbHash,
                                cbHashSize,
                                0,
                                &hPrevCat);
                }

                //
                // we might have to free a catalog context!
                //
                if (hCatalog)
                {
                    (*catapi.pCryptCATAdminReleaseCatalogContext)
                        (catapi.hCatAdmin, hCatalog, 0);
                }

                //
                //  free hash
                //
                MemFree(pbHash);

            }

            CloseHandle(hFile);
        }
    }

    ReleaseCATAPI(&catapi);

    return dwWHQLLevel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\dllmain.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dllinit.c
 *  Content:    DDRAW.DLL initialization
 *
 ***************************************************************************/

/*
 * unfortunately we have to break our pre-compiled headers to get our
 * GUIDS defined...
 */
#define INITGUID
#include "ddrawpr.h"
#include <initguid.h>
#ifdef WINNT
#undef IUnknown
#include <objbase.h>
#include "aclapi.h"
#endif


HANDLE              hWindowListMutex; //=(HANDLE)0;

#define WINDOWLISTMUTEXNAME "DDrawWindowListMutex"
#define INITCSWINDLIST() \
hWindowListMutex = CreateMutex(NULL,FALSE,WINDOWLISTMUTEXNAME);
#define FINIWINDLIST() CloseHandle(hWindowListMutex);


HINSTANCE           g_hModule=0;

/*
 * Winnt specific global statics
 */

BYTE szDeviceWndClass[] = "DirectDrawDeviceWnd";


/*
 * This mutex is owned by the exclusive mode owner
 */
HANDLE              hExclusiveModeMutex=0;
HANDLE              hCheckExclusiveModeMutex=0;
#define EXCLUSIVE_MODE_MUTEX_NAME "__DDrawExclMode__"
#define CHECK_EXCLUSIVE_MODE_MUTEX_NAME "__DDrawCheckExclMode__"

//#endif


/*
 * Win95 specific global statics
 */

#ifdef WIN95
    LPVOID	        lpWin16Lock;

    static CRITICAL_SECTION csInit = {0};
    CRITICAL_SECTION	csWindowList;
    CRITICAL_SECTION    csDriverObjectList;
#endif


extern BOOL APIENTRY D3DDllMain(HMODULE hModule, 
                                DWORD   dwReason, 
                                LPVOID  lpvReserved);

extern void CPixel__Cleanup();

#undef DPF_MODNAME
#define DPF_MODNAME "DllMain"

/*
 * DllMain
 */
BOOL WINAPI 
DllMain(HINSTANCE hmod, DWORD dwReason, LPVOID lpvReserved)
{
    DWORD pid;
    BOOL  didhelp;

    pid = GetCurrentProcessId();

    switch(dwReason)
    {
    case DLL_PROCESS_ATTACH:

        DisableThreadLibraryCalls(hmod);
        DPFINIT();
        // Create the DirectDraw csect
        DPF(4, "====> ENTER: DLLMAIN(%08lx): Process Attach: %08lx, tid=%08lx", DllMain,
             pid, GetCurrentThreadId());

        /*
         * This must be the first time.
         */
        INITCSWINDLIST();

        g_hModule = hmod;

        //Let's grant the world MUTEX_ALL_ACCESS.... (bugs 210604, 30170, 194290, 194355)
        {
#ifdef WINNT
            SECURITY_ATTRIBUTES sa;
            SID_IDENTIFIER_AUTHORITY sia = SECURITY_WORLD_SID_AUTHORITY;
            PSID adminSid = 0;
            ULONG cbAcl;
            PACL acl=0;
            PSECURITY_DESCRIPTOR pSD;
            BYTE buffer[SECURITY_DESCRIPTOR_MIN_LENGTH];
            BOOL bSecurityGooSucceeded = FALSE;
            //Granny's old fashioned LocalAlloc:
            BYTE Buffer1[256];
            BYTE Buffer2[16];

            // Create the SID for world
            cbAcl = GetSidLengthRequired(1);
            if (cbAcl < sizeof(Buffer2))
            {
                adminSid = (PSID) Buffer2;
                InitializeSid(
                    adminSid,
                    &sia,
                    1
                    );
                *GetSidSubAuthority(adminSid, 0) = SECURITY_WORLD_RID;
          
               // Create an ACL giving World all access.
                cbAcl = sizeof(ACL) +
                             (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
                             GetLengthSid(adminSid);
                if (cbAcl < sizeof(Buffer1))
                {
                    acl = (PACL)&Buffer1;
                    if (InitializeAcl(
                        acl,
                        cbAcl,
                        ACL_REVISION
                        ))
                    {
                        if (AddAccessAllowedAce(
                            acl,
                            ACL_REVISION,
                            SYNCHRONIZE|MUTANT_QUERY_STATE|DELETE|READ_CONTROL, //|WRITE_OWNER|WRITE_DAC,
                            adminSid
                            ))
                        {
                            // Create a security descriptor with the above ACL.
                            pSD = (PSECURITY_DESCRIPTOR)buffer;
                            if (InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
                            {
                                if (SetSecurityDescriptorDacl(pSD, TRUE, acl, FALSE))
                                {
                                    // Fill in the SECURITY_ATTRIBUTES struct.
                                    sa.nLength = sizeof(sa);
                                    sa.lpSecurityDescriptor = pSD;
                                    sa.bInheritHandle = TRUE;

                                    bSecurityGooSucceeded = TRUE;
                                }
                            }
                        }
                    }
                }
            } 
#endif
            DDASSERT(0 == hExclusiveModeMutex);
            hExclusiveModeMutex = CreateMutex( 
#ifdef WINNT
                bSecurityGooSucceeded ? &sa : 
#endif
                    NULL,     //use default access if security goo failed.
                FALSE, 
                EXCLUSIVE_MODE_MUTEX_NAME );
#ifdef WINNT
            if (0 == hExclusiveModeMutex)
            {
                hExclusiveModeMutex = OpenMutex(
                    SYNCHRONIZE|DELETE,  // access flag
                    FALSE,    // inherit flag
                    EXCLUSIVE_MODE_MUTEX_NAME          // pointer to mutex-object name
                    );
            }
#endif

            if (hExclusiveModeMutex == 0)
            {
                DPF_ERR("Could not create exclusive mode mutex. exiting");
                return FALSE;
            }

            DDASSERT(0 == hCheckExclusiveModeMutex);
            hCheckExclusiveModeMutex = CreateMutex( 
#ifdef WINNT
                bSecurityGooSucceeded ? &sa : 
#endif
                    NULL,     //use default access if security goo failed.
                FALSE, 
                CHECK_EXCLUSIVE_MODE_MUTEX_NAME );

#ifdef WINNT
            if (0 == hCheckExclusiveModeMutex)
            {
                hCheckExclusiveModeMutex = OpenMutex(
                    SYNCHRONIZE|DELETE,  // access flag
                    FALSE,    // inherit flag
                    CHECK_EXCLUSIVE_MODE_MUTEX_NAME          // pointer to mutex-object name
                    );
            }
#endif
            if (hCheckExclusiveModeMutex == 0)
            {
                DPF_ERR("Could not create exclusive mode check mutex. exiting");
                CloseHandle(hExclusiveModeMutex);
                return FALSE;
            }
        }

        if (!MemInit())
        {
            DPF(0,"LEAVING, COULD NOT MemInit");
            CloseHandle(hExclusiveModeMutex);
            CloseHandle(hCheckExclusiveModeMutex);
            return FALSE;
        }


        // Do whatever it takes for D3D (mostly PSGP stuff)
        D3DDllMain(g_hModule, dwReason, lpvReserved);


        DPF(4, "====> EXIT: DLLMAIN(%08lx): Process Attach: %08lx", DllMain,
             pid);
        break;

    case DLL_PROCESS_DETACH:
        DPF(4, "====> ENTER: DLLMAIN(%08lx): Process Detach %08lx, tid=%08lx",
             DllMain, pid, GetCurrentThreadId());

        // Cleanup registry in CPixel
        CPixel__Cleanup();

        /*
         * disconnect from thunk, even if other cleanup code commented out...
         */

        MemFini();

        DDASSERT(0 != hExclusiveModeMutex);
        CloseHandle(hCheckExclusiveModeMutex);
        CloseHandle(hExclusiveModeMutex);
        FINIWINDLIST();

        // Do whatever it takes for D3D (mostly PSGP stuff)
        D3DDllMain(g_hModule, dwReason, lpvReserved);

        DPF(4, "====> EXIT: DLLMAIN(%08lx): Process Detach %08lx",
             DllMain, pid);
        break;

        /*
         * we don't ever want to see thread attach/detach
         */
#ifdef DEBUG
    case DLL_THREAD_ATTACH:
        DPF(4, "THREAD_ATTACH");
        break;

    case DLL_THREAD_DETACH:
        DPF(4,"THREAD_DETACH");
        break;
#endif
    default:
        break;
    }

    return TRUE;

} /* DllMain */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\ddrawpr.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddrawpr.h
 *  Content:    DirectDraw private header file
 *  History:    Confidential. If we told you, we'd have to...
 *
 ***************************************************************************/

#ifndef __DDRAWPR_INCLUDED__
#define __DDRAWPR_INCLUDED__

#ifdef WIN95

#ifdef WINNT
#undef WINNT
#endif

#endif

#ifndef WIN95
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#endif

#ifdef WIN95
    #define WIN16_SEPARATE
#endif
#include "verinfo.h"

#ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <mmsystem.h>

#include <string.h>
#include <stddef.h>


#pragma warning( disable: 4704)

#include "dpf.h"

/*
 * registry stuff
 */
#include "ddreg.h"

#include "memalloc.h"

#include <objbase.h>
#include "ddrawi.h"
#include "d3d8ddi.h"
#include "dwininfo.h"


// Information stored on each device in the system
#define MAX_DX8_ADAPTERS     12

typedef struct _ADAPTERINFO
{
    GUID                Guid;
    char                DeviceName[MAX_PATH];
    BOOL                bIsPrimary;
    BOOL                bIsDisplay;
    DWORD               NumModes;
    D3DDISPLAYMODE*     pModeTable;
    D3DFORMAT           Unknown16;
    D3D8_DRIVERCAPS     HALCaps;
    UINT                HALFlags;
    BOOL                bNoDDrawSupport;
} ADAPTERINFO, * PADAPTERINFO;

#ifdef __cplusplus
    #include "d3d8p.h"
    #include "enum.hpp"
    #include "dxgint.h"
#endif



/*
 * Need this to get CDS_ macros under NT build environment for win95.
 * winuserp.h comes from private\windows\inc
 */
#ifdef NT_BUILD_ENVIRONMENT
    #ifdef WIN32
        #include "winuserp.h"
    #endif
#endif
#include "ids8.h"

/*
 * NT kernel mode stub(ish)s
 */
#ifndef WIN95
    #include "ddrawgdi.h"
#endif


/*
 * Direct3D interfacing defines.
 */
#ifdef __cplusplus
extern "C" {
#endif

/*
 * reminder
 */
#define QUOTE(x) #x
#define QQUOTE(y) QUOTE(y)
#define REMIND(str) __FILE__ "(" QQUOTE(__LINE__) "):" str

/*
 * synchronization
 */

#ifdef WINNT
#define NT_USES_CRITICAL_SECTION
#endif

#include "ddheap.h"
#include "ddagp.h"

/* ddraw.dll exports */
#ifdef WIN95
    extern BOOL WINAPI DdCreateDirectDrawObject( LPDDRAWI_DIRECTDRAW_GBL pddd, LPGUID lpGuid, DWORD dwFlags );
    extern BOOL WINAPI DdReenableDirectDrawObject( LPDDRAWI_DIRECTDRAW_GBL pddd, LPBOOL pbNewMode );
    extern BOOL WINAPI DdQueryDirectDrawObject( LPDDRAWI_DIRECTDRAW_GBL pddd, LPDDHALINFO lpDDHALInfo, LPDDHAL_DDCALLBACKS pddHALDD, LPDDHAL_DDSURFACECALLBACKS pddHALDDSurface, LPDDHAL_DDPALETTECALLBACKS pddHALDDPalette, LPD3DHAL_CALLBACKS pd3dHALCallbacks, LPD3DHAL_GLOBALDRIVERDATA pd3dHALDriverData, LPDDHAL_DDEXEBUFCALLBACKS pddNTHALBufferCallbacks, LPVOID pVoid1, LPVOID pVoid2, LPVOID pVoid3 );
    extern ULONG WINAPI DdQueryDisplaySettingsUniqueness( VOID );
#endif


/* enum.cpp */
extern BOOL IsSupportedOp (D3DFORMAT Format, DDSURFACEDESC* pList, UINT NumElements, DWORD dwRequestedOps);

/* ddcreate.c */
extern BOOL IsVGADevice(LPSTR szDevice);
extern BOOL xxxEnumDisplayDevicesA(LPVOID lpUnused, DWORD iDevice, struct _DISPLAY_DEVICEA *pdd, DWORD dwFlags);
extern HMONITOR GetMonitorFromDeviceName(LPSTR szName);
extern void FetchDirectDrawData( PD3D8_DEVICEDATA pBaseData, void* pInitFunction, D3DFORMAT Unknown16, DDSURFACEDESC* pHalOpList, DWORD NumHalOps);
extern DWORD DirectDrawMsg(LPSTR msg);
extern BOOL InternalGetMonitorInfo(HMONITOR hMon, MONITORINFO *lpInfo);


#ifdef WINNT
extern BOOL GetCurrentMode(LPDDRAWI_DIRECTDRAW_GBL, LPDDHALINFO lpHalInfo, char *szDrvName);
extern HRESULT GetNTDeviceRect( LPSTR pDriverName, LPRECT lpRect );
#endif

extern HDC  DD_CreateDC(LPSTR pdrvname);
extern void DD_DoneDC(HDC hdc);

extern LONG xxxChangeDisplaySettingsExA(LPCSTR szDevice, LPDEVMODEA pdm, HWND hwnd, DWORD dwFlags,LPVOID lParam);
extern HRESULT InternalDirectDrawCreate( PD3D8_DEVICEDATA *lplpDD, PADAPTERINFO pDeviceInfo, D3DDEVTYPE DeviceType, VOID* pInitFunction, D3DFORMAT Unknown16, DDSURFACEDESC* pHalOpList, DWORD NumHalOps);
extern HRESULT InternalDirectDrawRelease(PD3D8_DEVICEDATA  pBaseData);

/* dddefwp.c */
extern HRESULT SetAppHWnd( LPDDRAWI_DIRECTDRAW_LCL thisg, HWND hWnd, DWORD dwFlags );
extern VOID CleanupWindowList( DWORD pid );
extern void ClipTheCursor(LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, LPRECT lpRect);

/* drvinfo.c */
extern BOOL Voodoo1GoodToGo( GUID * pGuid );
extern void GetAdapterInfo( char* pDriverName, D3DADAPTER_IDENTIFIER8* pDI, BOOL bDisplayDriver, BOOL bGuidOnly, BOOL bDriverName);

DEFINE_GUID( guidVoodoo1A, 0x3a0cfd01,0x9320,0x11cf,0xac,0xa1,0x00,0xa0,0x24,0x13,0xc2,0xe2 );
DEFINE_GUID( guidVoodoo1B, 0xaba52f41,0xf744,0x11cf,0xb4,0x52,0x00,0x00,0x1d,0x1b,0x41,0x26 );

/*
 * macros for validating pointers
 */

#ifndef DEBUG
#define FAST_CHECKING
#endif

/*
 * VALIDEX_xxx macros are the same for debug and retail
 */
#define VALIDEX_PTR( ptr, size ) \
        (!IsBadReadPtr( ptr, size) )

#define VALIDEX_IID_PTR( ptr ) \
        (!IsBadReadPtr( ptr, sizeof( IID )) )

#define VALIDEX_PTR_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( LPVOID )) )

#define VALIDEX_CODE_PTR( ptr ) \
        (!IsBadCodePtr( (FARPROC) ptr ) )

#define VALIDEX_GUID_PTR( ptr ) \
        (!IsBadReadPtr( ptr, sizeof( GUID ) ) )

#define VALIDEX_DDDEVICEIDENTIFIER_PTR( ptr ) (!IsBadWritePtr( ptr, sizeof( DDDEVICEIDENTIFIER )))
#define VALIDEX_DDDEVICEIDENTIFIER2_PTR( ptr ) (!IsBadWritePtr( ptr, sizeof( DDDEVICEIDENTIFIER2 )))


/*
 * These macros validate the size (in debug and retail) of callback
 * tables.
 *
 * NOTE: It is essential that the comparison against the current
 * callback size expected by this DirectDraw the comparison operator
 * be >= rather than ==. This is to ensure that newer drivers can run
 * against older DirectDraws.
 */
#define VALIDEX_DDCALLBACKSSIZE( ptr )                       \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ( ptr )->dwSize == DDCALLBACKSSIZE_V1   )   || \
            ( ( ptr )->dwSize >= DDCALLBACKSSIZE      ) ) )

#define VALIDEX_DDSURFACECALLBACKSSIZE( ptr )                \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDSURFACECALLBACKSSIZE ) )

#define VALIDEX_DDPALETTECALLBACKSSIZE( ptr )                \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDPALETTECALLBACKSSIZE ) )

#define VALIDEX_DDPALETTECALLBACKSSIZE( ptr )                \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDPALETTECALLBACKSSIZE ) )

#define VALIDEX_DDEXEBUFCALLBACKSSIZE( ptr )                 \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDEXEBUFCALLBACKSSIZE ) )

#define VALIDEX_DDVIDEOPORTCALLBACKSSIZE( ptr )              \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDVIDEOPORTCALLBACKSSIZE ) )

#define VALIDEX_DDMOTIONCOMPCALLBACKSSIZE( ptr )              \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDMOTIONCOMPCALLBACKSSIZE ) )

#define VALIDEX_DDCOLORCONTROLCALLBACKSSIZE( ptr )           \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDCOLORCONTROLCALLBACKSSIZE ) )

#define VALIDEX_DDMISCELLANEOUSCALLBACKSSIZE( ptr )           \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDMISCELLANEOUSCALLBACKSSIZE ) )

#define VALIDEX_DDMISCELLANEOUS2CALLBACKSSIZE( ptr )           \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDMISCELLANEOUS2CALLBACKSSIZE ) )

#define VALIDEX_D3DCALLBACKS2SIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( (( ptr )->dwSize >= D3DHAL_CALLBACKS2SIZE ) ))

#define VALIDEX_D3DCOMMANDBUFFERCALLBACKSSIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= D3DHAL_COMMANDBUFFERCALLBACKSSIZE ) )

#define VALIDEX_D3DCALLBACKS3SIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= D3DHAL_CALLBACKS3SIZE ) )

#define VALIDEX_DDKERNELCALLBACKSSIZE( ptr )           \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDKERNELCALLBACKSSIZE ) )

#define VALIDEX_DDUMODEDRVINFOSIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDHAL_DDUMODEDRVINFOSIZE ) )
#define VALIDEX_DDOPTSURFKMODEINFOSIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDOPTSURFACEKMODEINFOSIZE ) )

#define VALIDEX_DDOPTSURFUMODEINFOSIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDOPTSURFACEUMODEINFOSIZE ) )

#define VALIDEX_DDNTCALLBACKSSIZE( ptr )           \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDNTCALLBACKSSIZE ) )

#ifndef FAST_CHECKING
#define VALID_DDKERNELCAPS_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDKERNELCAPS ) ) && \
        (ptr->dwSize == sizeof( DDKERNELCAPS )) )
#define VALID_DWORD_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DWORD ) ))
#define VALID_BOOL_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( BOOL ) ))
#define VALID_HDC_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( HDC ) ))
#define VALID_RGNDATA_PTR( ptr, size ) \
        (!IsBadWritePtr( ptr, size ) )
#define VALID_PTR_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( LPVOID )) )
#define VALID_IID_PTR( ptr ) \
        (!IsBadReadPtr( ptr, sizeof( IID )) )
#define VALID_HWND_PTR( ptr ) \
        (!IsBadWritePtr( (LPVOID) ptr, sizeof( HWND )) )
#define VALID_VMEM_PTR( ptr ) \
        (!IsBadWritePtr( (LPVOID) ptr, sizeof( VMEM )) )
#define VALID_POINTER_ARRAY( ptr, cnt ) \
        (!IsBadWritePtr( ptr, sizeof( LPVOID ) * cnt ) )
#define VALID_HANDLE_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( HANDLE )) )
#define VALID_DDCORECAPS_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDCORECAPS ) ) && \
         (ptr->dwSize == sizeof( DDCORECAPS ) ) )
#define VALID_DWORD_ARRAY( ptr, cnt ) \
        (!IsBadWritePtr( ptr, sizeof( DWORD ) * cnt ) )
#define VALID_GUID_PTR( ptr ) \
        (!IsBadReadPtr( ptr, sizeof( GUID ) ) )
#define VALID_BYTE_ARRAY( ptr, cnt ) \
        (!IsBadWritePtr( ptr, sizeof( BYTE ) * cnt ) )
#define VALID_PTR( ptr, size ) \
        (!IsBadReadPtr( ptr, size) )
#define VALID_WRITEPTR( ptr, size ) \
        (!IsBadWritePtr( ptr, size) )

#else
#define VALID_PTR( ptr, size )          1
#define VALID_WRITEPTR( ptr, size )     1
#define VALID_DDKERNELCAPS_PTR( ptr) (ptr->dwSize == sizeof( DDKERNELCAPS ))
#define VALID_DWORD_PTR( ptr )  1
#define VALID_BOOL_PTR( ptr )   1
#define VALID_HDC_PTR( ptr )    1
#define VALID_RGNDATA_PTR( ptr )        1
#define VALID_PTR_PTR( ptr )    1
#define VALID_IID_PTR( ptr )    1
#define VALID_HWND_PTR( ptr )   1
#define VALID_VMEM_PTR( ptr )   1
#define VALID_POINTER_ARRAY( ptr, cnt ) 1
#define VALID_PALETTEENTRY_ARRAY( ptr, cnt )    1
#define VALID_HANDLE_PTR( ptr ) 1
#define VALID_DDCORECAPS_PTR( ptr ) (ptr->dwSize == sizeof( DDCORECAPS )
#define VALID_DWORD_ARRAY( ptr, cnt )   1
#define VALID_GUID_PTR( ptr )   1
#define VALID_BYTE_ARRAY( ptr, cnt ) 1

#endif

/*
 * All global data is should be just here.
 */

#define GLOBAL_STORAGE_CLASS extern

/*
 * This member should stay at the top in order to guarantee that it be intialized to zero
 * -see dllmain.c 's instance of this structure
 */
GLOBAL_STORAGE_CLASS    HINSTANCE           g_hModule;

/*
 * Winnt specific global statics
 */

GLOBAL_STORAGE_CLASS    HANDLE              hExclusiveModeMutex;
GLOBAL_STORAGE_CLASS    HANDLE              hCheckExclusiveModeMutex;


/*
 * IMPORTANT NOTE: This function validates the HAL information passed to us from the driver.
 * It is vital that we code this check so that we will pass HAL information structures
 * larger than the ones we know about so that new drivers can work with old DirectDraws.
 */
#define VALIDEX_DDHALINFO_PTR( ptr )                         \
        ( ( ( ( ptr )->dwSize == sizeof( DDHALINFO_V1 ) ) || \
            ( ( ptr )->dwSize == DDHALINFOSIZE_V2 )       || \
            ( ( ptr )->dwSize >= sizeof( DDHALINFO ) ) ) &&  \
          !IsBadWritePtr( ( ptr ), ( UINT ) ( ( ptr )->dwSize ) ) )


/* Turn on D3D stats collection for Debug builds HERE */
#define COLLECTSTATS    DBG

#ifdef __cplusplus
}       // extern "C"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\dwinproc.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dwinproc.cpp
 *  Content:    DirectDraw processing of Window messages
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   27-Jan-00  kanqiu  initial implementation
 ***************************************************************************/
#include "ddrawpr.h"

#include "swapchan.hpp"

#include "resource.inl"

#ifdef WINNT

#define USESHOWWINDOW

// WindowInfo structure
typedef struct _D3DWINDOWINFO
{
    DWORD                       dwMagic;
    HWND			hWnd;
    WNDPROC			lpWndProc;
    DWORD			dwFlags;
    CEnum                      *pEnum;
    DWORD			dwDDFlags;
} D3DWINDOWINFO;

// WindowInfo for our single hooked winproc
// This global variable should never never be accessed outside
// of this file.
D3DWINDOWINFO g_WindowInfo = {0, 0, 0, 0, 0, 0};

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::HIDESHOW_IME"

// IME hide/show function
void CSwapChain::HIDESHOW_IME()
{
    if (m_lSetIME)
    {                                          
        SystemParametersInfo(
            SPI_SETSHOWIMEUI, m_lSetIME - 1, NULL, 0);
        InterlockedExchange(&m_lSetIME, 0);
    }
} // HIDESHOW_IME

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::IsWinProcDeactivated"

BOOL CSwapChain::IsWinProcDeactivated() const
{
    // Do we even have our own win-proc?
    if (g_WindowInfo.hWnd != Device()->FocusWindow())
    {
        return FALSE;
    }

    // Check to see if our win-proc is deactivated then
    if (DDRAWILCL_ACTIVENO & g_WindowInfo.dwDDFlags)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
} // IsWinProcActive


#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::MakeFullscreen"
//
// make the passed window fullscreen and topmost and set a timer
// to make the window topmost again, what a hack.
//
void CSwapChain::MakeFullscreen()
{
    // We need to make sure that we don't send this
    // size message to the app
    g_WindowInfo.dwFlags |= WININFO_SELFSIZE;

    // Do the processing
    MONITORINFO MonInfo;
    MonInfo.rcMonitor.top = MonInfo.rcMonitor.left = 0;
    if (1 < Device()->Enum()->GetAdapterCount())
    {
        HMONITOR hMonitor = Device()->Enum()->
            GetAdapterMonitor(Device()->AdapterIndex());
        MonInfo.cbSize = sizeof(MONITORINFO);
        if (hMonitor)
            InternalGetMonitorInfo(hMonitor, &MonInfo);
    }
    SetWindowPos(m_PresentationData.hDeviceWindow, NULL,
        MonInfo.rcMonitor.left,
        MonInfo.rcMonitor.top,
        Width(),
        Height(),
        SWP_NOZORDER | SWP_NOACTIVATE);

    if (GetForegroundWindow() == Device()->FocusWindow())
    {
	// If the exclusive mode window is not visible, make it so.
	if (!IsWindowVisible(m_PresentationData.hDeviceWindow))
	{
	    ShowWindow(m_PresentationData.hDeviceWindow, SW_SHOW);
	}

        SetWindowPos(m_PresentationData.hDeviceWindow, HWND_TOPMOST, 0, 0, 0, 0,
            SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

        // If the exclusive mode window is maximized, restore it.
        if (IsZoomed(m_PresentationData.hDeviceWindow))
        {
            ShowWindow(m_PresentationData.hDeviceWindow, SW_RESTORE);
        }
    }

    // We're done; so undo the self-size flag
    g_WindowInfo.dwFlags &= ~WININFO_SELFSIZE;

} // CSwapChain::MakeFullscreen


#undef DPF_MODNAME
#define DPF_MODNAME "handleActivateApp"

HRESULT handleActivateApp(BOOL is_active)
{
    // We are going to start touching some internal
    // data structures of the device and/or enum objects
    // so we have to take the critical section for the device
#ifdef DEBUG
    CLockD3D _lock(g_WindowInfo.pEnum, DPF_MODNAME, __FILE__);
#else
    CLockD3D _lock(g_WindowInfo.pEnum);
#endif 
    
    HRESULT                     ddrval;
    BOOL                        has_excl;
    CEnum                       *pEnum = g_WindowInfo.pEnum;

#ifdef  WINNT
    if (pEnum->CheckExclusiveMode(NULL, &has_excl, is_active) 
        && !has_excl && is_active)
    {
        // If we didn't get exclusive mode, for example, a different thread came in
        DPF_ERR("Could not get exclusive mode when we thought we could");
        return  E_FAIL;
    }
#endif  //WINNT

    /*
     * stuff to do before the mode set if deactivating
     */
    if (is_active)
    {
        /*
         * restore exclusive mode. Here we don't release the ref we took on the exclusive mode mutex,
         * since we want to keep the exclusive mode mutex.
         */
        pEnum->StartExclusiveMode();
    }
    else
    {
        /*
         * restore the mode
         */
        pEnum->DoneExclusiveMode();
    }
    return S_OK;
} /* handleActivateApp */

#undef DPF_MODNAME
#define DPF_MODNAME "WindowProc"

/*
 * WindowProc
 */
LRESULT WINAPI WindowProc(
                HWND hWnd,
                UINT uMsg,
                WPARAM wParam,
                LPARAM lParam)
{
    BOOL                        is_active;
    WNDPROC                     proc;
    BOOL                        get_away;
    LRESULT                     rc;

    /*
     * Check the window proc
     */
    if (g_WindowInfo.hWnd != hWnd || g_WindowInfo.dwMagic != WININFO_MAGIC)
    {
        DPF(4, "FATAL ERROR! Window Proc Called for hWnd %08lx, but not in list!", hWnd);
        DEBUG_BREAK();
        return DefWindowProc(hWnd, uMsg, wParam, lParam);
    }
    
    if (g_WindowInfo.dwFlags & WININFO_SELFSIZE)
    {
        return 0L;   // don't send to app, it's caused by MakeFullscreen
    }

    /*
     * unhook at destroy (or if the WININFO_UNHOOK bit is set)
     */
    proc = g_WindowInfo.lpWndProc;

    if (uMsg == WM_NCDESTROY)
    {
        DPF (4, "*** WM_NCDESTROY unhooking window ***");
        g_WindowInfo.dwFlags |= WININFO_UNHOOK;
    }

    if (g_WindowInfo.dwFlags & WININFO_UNHOOK)
    {
        DPF (4, "*** Unhooking window proc");

        if (g_WindowInfo.dwFlags & WININFO_ZOMBIE)
        {
            DPF (4, "*** Freeing ZOMBIE WININFO ***");
            ZeroMemory(&g_WindowInfo, sizeof(g_WindowInfo));
        }

        SetWindowLongPtr(hWnd, GWLP_WNDPROC, (INT_PTR) proc);

        rc = CallWindowProc(proc, hWnd, uMsg, wParam, lParam);
        return rc;
    }

    /*
     * Code to defer app activation of minimized app until it is restored.
     */
    switch(uMsg)
    {
    #ifdef WIN95
    case WM_POWERBROADCAST:
        if ((wParam == PBT_APMSUSPEND) || (wParam == PBT_APMSTANDBY))
    #else
    //winnt doesn't know about standby vs suspend
    case WM_POWER:
        if (wParam == PWR_SUSPENDREQUEST)
    #endif
        {
            DPF(4, "WM_POWERBROADCAST: deactivating application");
            SendMessage(hWnd, WM_ACTIVATEAPP, 0, GetCurrentThreadId());
        }
        break;
    case WM_SIZE:
        DPF(4, "WM_SIZE hWnd=%X wp=%04X, lp=%08X dwFlags=%08lx", hWnd, wParam, 
            lParam, g_WindowInfo.dwFlags);

        if (!(g_WindowInfo.dwFlags & WININFO_INACTIVATEAPP)
            && ((wParam == SIZE_RESTORED) || (wParam == SIZE_MAXIMIZED))
            && (GetForegroundWindow() == hWnd))
        {
#ifdef WINNT
            //
            // Wouldncha know it, but NT's messaging order is HUGELY different when alt-tabbing
            // between two exclusive mode apps. The first WM_SIZE sent to the activating app is
            // sent BEFORE the deactivating app loses FSE. This WM_SIZE is totally necessary to
            // reactivate the activating app, but it has to wait until the app loses FSE.
            // So, we simply wait on the exclusive mode mutex. This seems to work!
            //
            {
                DWORD dwWaitResult;
                dwWaitResult = WaitForSingleObject(hExclusiveModeMutex, INFINITE);
                switch (dwWaitResult)
                {
                case WAIT_OBJECT_0:
                case WAIT_ABANDONED:
                    ReleaseMutex(hExclusiveModeMutex);
                    break;
                case WAIT_TIMEOUT:
                default:
                    DDASSERT(!"Unexpected return value from WaitForSingleObject");
                }

            }
#endif
            DPF(4, "WM_SIZE: Window restored, sending WM_ACTIVATEAPP");
            PostMessage(hWnd, WM_ACTIVATEAPP, 1, GetCurrentThreadId());
        }
        else
        {
            DPF(4, "WM_SIZE: Window restored, NOT sending WM_ACTIVATEAPP");
        }
        break;

    case WM_ACTIVATEAPP:
        if (IsIconic(hWnd) && wParam)
        {
            DPF(4, "WM_ACTIVATEAPP: Ignoring while minimized");
            return 0;
        }
        else
        {
            g_WindowInfo.dwFlags |= WININFO_INACTIVATEAPP;
        }
        break;
    }

    /*
     * is directdraw involved here?
     */
    if (!(g_WindowInfo.dwFlags & WININFO_DDRAWHOOKED))
    {
        rc = CallWindowProc(proc, hWnd, uMsg, wParam, lParam);

        // clear the WININFO_INACTIVATEAPP bit, but make sure to make sure
        // we are still hooked!
        if (uMsg == WM_ACTIVATEAPP && (g_WindowInfo.hWnd == hWnd))
        {
            g_WindowInfo.dwFlags &= ~WININFO_INACTIVATEAPP;
        }
        return rc;
    }

#ifdef DEBUG
    if (!IsIconic(hWnd))
    {
        if (GetForegroundWindow() == hWnd)
        {
            HWND hwndT;
            RECT rc,rcT;

            GetWindowRect(hWnd, &rc);

            for (hwndT = GetWindow(hWnd, GW_HWNDFIRST);
                hwndT && hwndT != hWnd;
                hwndT = GetWindow(hwndT, GW_HWNDNEXT))
            {
                if (IsWindowVisible(hwndT))
                {
                    GetWindowRect(hwndT, &rcT);
                    if (IntersectRect(&rcT, &rcT, &rc))
                    {
                        DPF(4, "Window %08x is on top of us!!", hwndT);
                    }
                }
            }
        }
    }
#endif

    /*
     * NOTE: we don't take the DLL csect here.   By not doing this, we can
     * up the performance here.   However, this means that the application
     * could have a separate thread kill exclusive mode while window
     * messages were being processed.   This could cause our death.
     * Is this OK?
     */

    switch(uMsg)
    {
    /*
     * WM_SYSKEYUP
     *
     * watch for system keys of app trying to switch away from us...
     *
     * we only need to do this on Win95 because we have disabled all
     * the task-switching hot keys.  on NT we will get switched
     * away from normaly by the system.
     */
    case WM_SYSKEYUP:
        DPF(4, "WM_SYSKEYUP: wParam=%08lx lParam=%08lx", wParam, lParam);
        get_away = FALSE;
        if (wParam == VK_TAB)
        {
            if (lParam & 0x20000000l)
            {
                if (g_WindowInfo.dwFlags & WININFO_IGNORENEXTALTTAB)
                {
                    DPF(4, "AHHHHHHHHHHHH Ignoring AltTab");
                }
                else
                {
                    get_away = TRUE;
                }
            }
        }
        else if (wParam == VK_ESCAPE)
        {
            get_away = TRUE;
        }

        g_WindowInfo.dwFlags &= ~WININFO_IGNORENEXTALTTAB;

        if (get_away)
        {
            DPF(4, "Hot key pressed, switching away from app");
            PostMessage(hWnd, WM_ACTIVATEAPP, 0, GetCurrentThreadId());
        }
        break;

    /*
     * WM_SYSCOMMAND
     *
     * watch for screen savers, and don't allow them!
     *
     */
    case WM_SYSCOMMAND:

        switch(wParam)
        {
        case SC_SCREENSAVE:
            DPF(4, "Ignoring screen saver!");
            return 1;
        // allow window to be restored even if it has popup(s)
        case SC_RESTORE:
            ShowWindow(hWnd, SW_RESTORE);
            break;
        }
        break;

#ifdef USESHOWWINDOW
    case WM_DISPLAYCHANGE:
        DPF(4, "WM_DISPLAYCHANGE: %dx%dx%d", LOWORD(lParam), HIWORD(lParam), wParam);

        //
        //  WM_DISPLAYCHANGE is *sent* to the thread that called
        //  change display settings, we will most likely have the
        //  direct draw lock, make sure we set the WININFO_SELFSIZE
        //  bit while calling down the chain to prevent deadlock
        //
        g_WindowInfo.dwFlags |= WININFO_SELFSIZE;

        rc = CallWindowProc(proc, hWnd, uMsg, wParam, lParam);

        g_WindowInfo.dwFlags &= ~WININFO_SELFSIZE;

        return rc;
#endif

    /*
     * WM_ACTIVATEAPP
     *
     * the application has been reactivated.   In this case, we need to
     * reset the mode
     *
     */
    case WM_ACTIVATEAPP:

        is_active = (BOOL)wParam && GetForegroundWindow() == hWnd && !IsIconic(hWnd);

        if (!is_active && wParam != 0)
        {
            DPF(4, "WM_ACTIVATEAPP: setting wParam to 0, not realy active");
            wParam = 0;
        }

        if (is_active)
        {
            DPF(4, "WM_ACTIVATEAPP: BEGIN Activating app pid=%08lx, tid=%08lx",
                                    GetCurrentProcessId(), GetCurrentThreadId());
        }
        else
        {
            DPF(4, "WM_ACTIVATEAPP: BEGIN Deactivating app pid=%08lx, tid=%08lx",
                                    GetCurrentProcessId(), GetCurrentThreadId());
        }
        if (is_active && (g_WindowInfo.dwDDFlags & DDRAWILCL_ACTIVEYES))
        {
            DPF(4, "*** Already activated");
        }
        else
        if (!is_active && (g_WindowInfo.dwDDFlags & DDRAWILCL_ACTIVENO))
        {
            DPF(4, "*** Already deactivated");
        }
        else
        {
            if (FAILED(handleActivateApp(is_active)))
                break;
            DPF(4, "*** Active state changing");
            if (is_active)
            {
#ifdef DEBUG
                if (GetAsyncKeyState(VK_MENU) < 0)
                    DPF(4, "ALT key is DOWN");

                if (GetKeyState(VK_MENU) < 0)
                    DPF(4, "we think the ALT key is DOWN");
#endif DEBUG

                if (GetAsyncKeyState(VK_MENU) < 0)
                {
                    g_WindowInfo.dwFlags |= WININFO_IGNORENEXTALTTAB;
                    DPF(4, "AHHHHHHH Setting to ignore next alt tab");
                }
                else
                {
                    g_WindowInfo.dwFlags &= ~WININFO_IGNORENEXTALTTAB;
                }
            }

	    /*
	     * In the multi-mon scenario, it's possible that multiple
	     * devices are using this same window, so we need to do
	     * the following for each device.
	     */
            g_WindowInfo.dwDDFlags &= ~(DDRAWILCL_ACTIVEYES|DDRAWILCL_ACTIVENO);
            if (is_active)
            {
                g_WindowInfo.dwDDFlags |= DDRAWILCL_ACTIVEYES;
            }
            else
            {
                g_WindowInfo.dwDDFlags |= DDRAWILCL_ACTIVENO;
            }
        }
        #ifdef DEBUG
            if (is_active)
            {
                DPF(4, "WM_ACTIVATEAPP: DONE Activating app pid=%08lx, tid=%08lx",
                                        GetCurrentProcessId(), GetCurrentThreadId());
            }
            else
            {
                DPF(4, "WM_ACTIVATEAPP: DONE Deactivating app pid=%08lx, tid=%08lx",
                                        GetCurrentProcessId(), GetCurrentThreadId());
            }
        #endif

        rc = CallWindowProc(proc, hWnd, uMsg, wParam, lParam);

        // clear the WININFO_INACTIVATEAPP bit, but make sure to make sure
        // we are still hooked!
        if (g_WindowInfo.hWnd == hWnd)
        {
            g_WindowInfo.dwFlags &= ~WININFO_INACTIVATEAPP;
        }
        return rc;

        break;
    }
    rc = CallWindowProc(proc, hWnd, uMsg, wParam, lParam);
    return rc;

} /* WindowProc */

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::SetAppHWnd"

/*
 * SetAppHWnd
 *
 * Set the WindowList struct up with the app's hwnd info
 * Must be called with Device crit-sec taken and with the
 * Global Exclusive Mode Mutex
 */
HRESULT 
CSwapChain::SetAppHWnd()
{

    HWND    hWnd, hEnumWnd;

    if (m_PresentationData.Windowed)
        hWnd = NULL;
    else
        hWnd = Device()->FocusWindow();

    hEnumWnd = Device()->Enum()->ExclusiveOwnerWindow();
    if (hEnumWnd)
    {
        if (hEnumWnd == Device()->FocusWindow())
        {
            if (m_PresentationData.Windowed)
            {
                Device()->Enum()->SetFullScreenDevice(
                    Device()->AdapterIndex(), NULL);

                // If our enum still has a focus-
                // window then that means another
                // device has gone FS with the same
                // focus-window; so do nothing
                if (Device()->Enum()->ExclusiveOwnerWindow())
                    return DD_OK;             
                
                // Else, fall through so that
                // we tear down the winproc.
            }
            else
            {
                Device()->Enum()->SetFullScreenDevice(
                    Device()->AdapterIndex(), Device());
	        // Already hooked - no need to do more
                return DD_OK;
            }
        }
    } 

    /*
     * check if this isn't doing anything
     */
    if (hWnd == NULL && g_WindowInfo.hWnd == NULL)
    {
        return S_OK;
    }

    // Check if we have a case of different HWND trying to be hooked
    if (hWnd && g_WindowInfo.hWnd && g_WindowInfo.hWnd != hWnd)
    {
        DPF(1, "Hwnd %08lx no good: Different Hwnd (%08lx) already set for Device",
                            hWnd, g_WindowInfo.hWnd);
        return D3DERR_INVALIDCALL;
    }

    /*
     * are we shutting an HWND down?
     */
    if (hWnd == NULL)
    {
        if (IsWindow(g_WindowInfo.hWnd))
        {
            WNDPROC proc;

            proc = (WNDPROC) GetWindowLongPtr(g_WindowInfo.hWnd, GWLP_WNDPROC);

            if (proc != (WNDPROC) WindowProc &&
                proc != (WNDPROC) g_WindowInfo.lpWndProc)
            {
                DPF(3, "Window has been subclassed; cannot restore!");
                g_WindowInfo.dwFlags |= WININFO_ZOMBIE;
            }
            else if (GetWindowThreadProcessId(g_WindowInfo.hWnd, NULL) !=
                     GetCurrentThreadId())
            {
                DPF(3, "intra-thread window unhook, letting window proc do it");
                g_WindowInfo.dwFlags |= WININFO_UNHOOK;
                g_WindowInfo.dwFlags |= WININFO_ZOMBIE;
                PostMessage(g_WindowInfo.hWnd, WM_NULL, 0, 0);
            }
            else
            {
                DPF(4, "Unsubclassing window %08lx", g_WindowInfo.hWnd);
                SetWindowLongPtr(g_WindowInfo.hWnd, GWLP_WNDPROC, 
                    (INT_PTR) g_WindowInfo.lpWndProc);

                ZeroMemory(&g_WindowInfo, sizeof(g_WindowInfo));
            }
        }
        else
        {
            ZeroMemory(&g_WindowInfo, sizeof(g_WindowInfo));
        }

        Device()->Enum()->SetFullScreenDevice(
            Device()->AdapterIndex(), NULL);
    }
    /*
     * changing or adding an hwnd then...
     */
    else
    {
        /*
         * brand new object...
         */
        if (g_WindowInfo.dwMagic == 0)
        {
            g_WindowInfo.dwMagic = WININFO_MAGIC;
            g_WindowInfo.hWnd = hWnd;
            g_WindowInfo.lpWndProc = (WNDPROC) GetWindowLongPtr(hWnd, GWLP_WNDPROC);

            SetWindowLongPtr(hWnd, GWLP_WNDPROC, (INT_PTR) WindowProc);
        }

        g_WindowInfo.pEnum = Device()->Enum();
        g_WindowInfo.dwFlags |= WININFO_DDRAWHOOKED;

        // Sanity check
        DXGASSERT(Device()->Enum()->ExclusiveOwnerWindow() == NULL);

        Device()->Enum()->SetFullScreenDevice(
            Device()->AdapterIndex(), Device());
        DPF(4, "Subclassing window %08lx", g_WindowInfo.hWnd);
    }
    return S_OK;

} /* SetAppHWnd */
extern "C" void ResetUniqueness( HANDLE hDD );

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::DoneExclusiveMode"  
/*
 * DoneExclusiveMode
 */
void
CSwapChain::DoneExclusiveMode(BOOL bChangeWindow)
{
    HRESULT hr = S_OK;
    BOOL    bMinimize = TRUE;
    DPF(4, "DoneExclusiveMode");
    if (m_bExclusiveMode)
    {
        D3D8_SETMODEDATA SetModeData;
        m_bExclusiveMode = FALSE;
        DPF(4, "INACTIVE: %08lx: Restoring original mode (%dx%dx%dx%d)", 
            GetCurrentProcessId(), Device()->DesktopMode().Width,
            Device()->DesktopMode().Height,Device()->DesktopMode().Format,
            Device()->DesktopMode().RefreshRate);
        SetModeData.hDD = Device()->GetHandle();
        SetModeData.dwWidth = Device()->DesktopMode().Width;
        SetModeData.dwHeight = Device()->DesktopMode().Height;
        SetModeData.Format = Device()->DesktopMode().Format;
        SetModeData.dwRefreshRate = Device()->DesktopMode().RefreshRate;
        SetModeData.bRestore = TRUE;

        Device()->GetHalCallbacks()->SetMode(&SetModeData);
        if (SetModeData.ddRVal != S_OK)
        {
            DPF_ERR("Unable to restore to original desktop mode");
           // return SetModeData.ddRVal;
        }
        // some part of the runtime count on that SetMode cause device
        // lost, that's not true for whistler anymore if this fullscreen
        // mode happens to be the same as the original desktop mode.
        // so we ResetUniqueness to force the device to get lost.
        if (Device()->DesktopMode().Width == Width() && 
            Device()->DesktopMode().Height == Height() &&
            Device()->DesktopMode().Format == BackBufferFormat())
            ResetUniqueness(Device()->GetHandle());

        DPF(4, "Enabling error mode, hotkeys");
        SetErrorMode(m_uiErrorMode);

#ifdef WINNT
        // Restore cursor shadow coming out of fullscreen
        SystemParametersInfo(SPI_SETCURSORSHADOW, 0, (LPVOID)m_pCursorShadow, 0);
#endif

        // Restore reactive menus coming out of fullscreen:
        SystemParametersInfo(SPI_SETHOTTRACKING, 0, (LPVOID)m_pHotTracking, 0);
        InterlockedExchange(&m_lSetIME, m_lIMEState + 1);

#ifdef WINNT
        // Notify the display driver that we are chaning cooperative level

        D3D8_SETEXCLUSIVEMODEDATA   ExclusiveData;

        ExclusiveData.hDD  = Device()->GetHandle();
        ExclusiveData.dwEnterExcl = FALSE;
        Device()->GetHalCallbacks()->SetExclusiveMode(&ExclusiveData);
        /*
         * If RestoreDisplayMode failed, we are probably on a different desktop.  In this case,
         * we should not minimize the window or else things won't work right when we switch
         * back to the original desktop.
         */
        if (SetModeData.ddRVal != S_OK)
        {
            HDESK hDesktop;
            static BYTE szName1[256];
            static BYTE szName2[256];
            DWORD dwTemp;

            // Get the name of the current desktop
            hDesktop = OpenInputDesktop( 0, FALSE, DESKTOP_READOBJECTS );
            GetUserObjectInformation( hDesktop, UOI_NAME, szName1, sizeof( szName1 ), &dwTemp );
            CloseDesktop( hDesktop );

            // Get the name of the apps' desktop
            hDesktop = GetThreadDesktop( GetCurrentThreadId() );
            GetUserObjectInformation( hDesktop, UOI_NAME, szName2, sizeof( szName2 ), &dwTemp );
            if( lstrcmp( (const LPCSTR)szName1, (const LPCSTR)szName2 ) )
            {
                bMinimize = FALSE;
            }
        }
#endif
        if (bChangeWindow)
        {
            HIDESHOW_IME();
            /*
             * minimize window if deactivating
             */
            if (IsWindowVisible(m_PresentationData.hDeviceWindow) && bMinimize)
            {
                g_WindowInfo.dwFlags |= WININFO_SELFSIZE;
                #ifdef USESHOWWINDOW
                    ShowWindow(m_PresentationData.hDeviceWindow, SW_SHOWMINNOACTIVE);
                #else
                    SetWindowPos(m_PresentationData.hDeviceWindow, NULL, 0, 0, 0, 0,
                        SWP_NOZORDER | SWP_NOACTIVATE);
                #endif
                g_WindowInfo.dwFlags &= ~WININFO_SELFSIZE;
            }
        }
    }
} /* DoneExclusiveMode */

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::StartExclusiveMode"  
/*
 * StartExclusiveMode
 */
void 
CSwapChain::StartExclusiveMode(BOOL bChangeWindow)
{
    DWORD   dwWaitResult;
    DPF(4, "StartExclusiveMode");

    /*
     * Preceeding code should have taken this mutex already.
     */
    if (!m_bExclusiveMode)
    {
        m_bExclusiveMode = TRUE;
#if defined(WINNT) && defined(DEBUG)
        dwWaitResult = WaitForSingleObject(hExclusiveModeMutex, 0);
        DDASSERT(dwWaitResult == WAIT_OBJECT_0);
        ReleaseMutex(hExclusiveModeMutex);
#endif
        m_uiErrorMode = SetErrorMode(SEM_NOGPFAULTERRORBOX | 
            SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

#ifdef WINNT
        // Save current cursor shadow setting
        SystemParametersInfo(SPI_GETCURSORSHADOW, 0, (LPVOID) &(m_pCursorShadow), 0);
        SystemParametersInfo(SPI_SETCURSORSHADOW, 0, 0, 0);
#endif

        // Save current hot-tracking setting
        SystemParametersInfo(SPI_GETHOTTRACKING, 0, (LPVOID) &(m_pHotTracking), 0);
        SystemParametersInfo(SPI_GETSHOWIMEUI, 0, (LPVOID) &(m_lIMEState), 0);
    
        //And turn it off as we go into exclusive mode
        SystemParametersInfo(SPI_SETHOTTRACKING, 0, 0, 0);
        InterlockedExchange(&m_lSetIME, FALSE + 1);

#ifdef WINNT
        // Notify the display driver that we are chaning cooperative level

        D3D8_SETEXCLUSIVEMODEDATA   ExclusiveData;

        ExclusiveData.hDD  = Device()->GetHandle();
        ExclusiveData.dwEnterExcl = TRUE;
        Device()->GetHalCallbacks()->SetExclusiveMode(&ExclusiveData);
#endif
        if (bChangeWindow)
        {
            MakeFullscreen();
            HIDESHOW_IME();
            if (IsWindowVisible(m_PresentationData.hDeviceWindow))
            {
                g_WindowInfo.dwFlags |= WININFO_SELFSIZE;
                #ifdef USESHOWWINDOW
                    ShowWindow(m_PresentationData.hDeviceWindow, SW_SHOWNOACTIVATE);
                #else
                {
                    RECT rc;
                    SetRect(&rc,0,0,GetSystemMetrics(SM_CXSCREEN),GetSystemMetrics(SM_CYSCREEN));
                    SetWindowPos(g_WindowInfo.hWnd, NULL,rc.left, rc.top,
                        rc.right  - rc.left,rc.bottom - rc.top,
                        SWP_NOZORDER | SWP_NOACTIVATE);
                }
                #endif
                g_WindowInfo.dwFlags &= ~WININFO_SELFSIZE;
            }
        }
    }
} /* StartExclusiveMode */

#endif  //WINNT
// End of file : dwinproc.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\dxcursor.hpp ===
//=============================================================================
// Copyright (c) 2000 Microsoft Corporation
//
// dxcursor.hpp
//
// DX Cursor implementation. 
//
// Created 01/17/2000 kanqiu (Kan Qiu)
//=============================================================================

#ifndef __DXCURSOR_HPP__
#define __DXCURSOR_HPP__

#include "surface.hpp"

//-----------------------------------------------------------------------------
// CCursor
//-----------------------------------------------------------------------------

class CCursor 
{
public:
    CCursor(CBaseDevice *pDevice);

    ~CCursor();
    void    Destroy();

    HRESULT SetProperties(
        UINT    xHotSpot,
        UINT    yHotSpot,
        CBaseSurface *pCursorBitmap);

    void    SetPosition(UINT xScreenSpace,UINT yScreenSpace,DWORD Flags);
    BOOL    SetVisibility(BOOL bVisible);
    HRESULT Hide(HANDLE);
    HRESULT Show(HANDLE);
    void    Flip();
private:
    void    UpdateRects();
    HRESULT CursorInit(
        UINT xHotSpot,
        UINT yHotSpot,
        CBaseSurface *pCursorBitmap);

    DWORD                   m_dwCursorFlags;//cursor flags
    HANDLE                  m_hCursorDdb;   //device dependent Cursor image
    HANDLE                  m_hFrontSave;   //excluded front buffer
    HANDLE                  m_hBackSave;    //excluded back buffer
    UINT                    m_xCursorHotSpot;
    UINT                    m_yCursorHotSpot;
    UINT                    m_xCursor;
    UINT                    m_yCursor;
    UINT                    m_Width;
    UINT                    m_Height;
    RECT                    m_CursorRect;
    RECT                    m_BufferRect;
    RECT                    m_CursorRectSave;
    RECT                    m_BufferRectSave;
    CBaseDevice*            m_pDevice;
    HCURSOR                 m_hOsCursor;
    HCURSOR                 m_hHWCursor;
    POINT                   m_MonitorOrigin;    //(x,y) Monitor Top left
    UINT                    m_SavedMouseTrails;
}; // class CCursor
#define DDRAWI_CURSORISON   0x01
#define DDRAWI_CURSORINIT   0x02
#define DDRAWI_CURSORSAVERECT   0x04
#define DDRAWI_CURSORRECTSAVED  0x08
#endif // __DXCURSOR_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\dxgint.h ===
#ifndef __DXGINT_H__
#define __DXGINT_H__

// COM interface stuff to allow functions such as CoCreateInstance and the like

#include <unknwn.h>

#include "d3d8p.h"
#include "d3d8ddi.h"
#include "enum.hpp"

// Forward decls
class CResource;
class CResourceManager;
class CBaseTexture;
class CBaseSurface;
class CSwapChain;
class CEnum;


#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice"

class CBaseDevice : public CLockOwner, public IDirect3DDevice8
{
public:
    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID, LPVOID FAR*); // 0
    STDMETHODIMP_(ULONG) AddRef(void); // 1
    STDMETHODIMP_(ULONG) Release(void); // 2

    // IDirectGraphicsDevice methods
    STDMETHODIMP TestCooperativeLevel(); // 3
    STDMETHODIMP_(UINT) GetAvailableTextureMem(void); // 4

    // ResourceManagerDiscardBytes is declared in d3di.hpp = 5

    STDMETHODIMP GetDirect3D(LPDIRECT3D8 *pD3D8); // 6
    STDMETHODIMP GetDeviceCaps(D3DCAPS8 *pCaps); // 7
    STDMETHODIMP GetDisplayMode(D3DDISPLAYMODE *pMode); // 8
    STDMETHODIMP GetCreationParameters(D3DDEVICE_CREATION_PARAMETERS *pParameters); // 9

    STDMETHODIMP SetCursorProperties(
        UINT xHotSpot,UINT yHotSpot,
        IDirect3DSurface8 *pCursorBitmap); // 10
    STDMETHODIMP_(void) SetCursorPosition(UINT xScreenSpace,UINT yScreenSpace,DWORD Flags); // 11
    STDMETHODIMP_(INT) ShowCursor(BOOL bShow);    // 12

    // Swap Chain stuff
    STDMETHODIMP CreateAdditionalSwapChain(
        D3DPRESENT_PARAMETERS *pPresentationParameters,
        IDirect3DSwapChain8 **pSwapChain); // 13

    STDMETHODIMP Reset( D3DPRESENT_PARAMETERS *pPresentationParameters); // 14

    STDMETHODIMP Present(   CONST RECT *pSourceRect,
                            CONST RECT *pDestRect,
                            HWND hTargetWindow,
                            CONST RGNDATA *pDestinationRegion); // 15
    STDMETHODIMP GetBackBuffer(UINT iBackBuffer, D3DBACKBUFFER_TYPE Type, IDirect3DSurface8 **ppBackBuffer); // 16
    STDMETHODIMP GetRasterStatus(D3DRASTER_STATUS *pRasterStatus); // 17

    STDMETHODIMP_(void) SetGammaRamp(DWORD dwFlags, CONST D3DGAMMARAMP *pRamp); // 18
    STDMETHODIMP_(void) GetGammaRamp(D3DGAMMARAMP *pRamp); // 19

    STDMETHODIMP CreateTexture(UINT cpWidth,UINT cpHeight,UINT cLevels,DWORD dwUsage,D3DFORMAT Format,D3DPOOL Pool,IDirect3DTexture8 **ppTexture); // 20
    STDMETHODIMP CreateVolumeTexture(UINT cpWidth,UINT cpHeight,UINT cpDepth,UINT cLevels,DWORD dwUsage,D3DFORMAT Format,D3DPOOL Pool,IDirect3DVolumeTexture8 **ppVolumeTexture); // 21
    STDMETHODIMP CreateCubeTexture(UINT cpEdge,UINT cLevels,DWORD dwUsage,D3DFORMAT Format,D3DPOOL Pool,IDirect3DCubeTexture8 **ppCubeTexture); // 22
    STDMETHODIMP CreateVertexBuffer(UINT cbLength,DWORD Usage,DWORD dwFVF,D3DPOOL Pool,IDirect3DVertexBuffer8 **ppVertexBuffer); // 23
    STDMETHODIMP CreateIndexBuffer(UINT cbLength,DWORD dwUsage,D3DFORMAT Format,D3DPOOL Pool,IDirect3DIndexBuffer8 **ppIndexBuffer); // 24

    STDMETHODIMP CreateRenderTarget(UINT cpWidth,UINT cpHeight,D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, BOOL Lockable, IDirect3DSurface8 **ppSurface); // 25
    STDMETHODIMP CreateDepthStencilSurface(UINT cpWidth,UINT cpHeight,D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, IDirect3DSurface8 **ppSurface); // 26
    STDMETHODIMP CreateImageSurface(UINT cpWidth,UINT cpHeight,D3DFORMAT Format, IDirect3DSurface8 **ppSurface); // 27

    STDMETHODIMP CopyRects(IDirect3DSurface8 *pSourceSurface, CONST RECT *pSourceRectsArray,UINT cRects,IDirect3DSurface8 *pDestinationSurface, CONST POINT *pDestPointsArray); // 28
    STDMETHODIMP UpdateTexture(IDirect3DBaseTexture8 *pSourceTexture,IDirect3DBaseTexture8 *pDestinationTexture); // 29
    STDMETHODIMP GetFrontBuffer(IDirect3DSurface8 *pDestSurface); // 30

    // Constructor/deconstructor
    CBaseDevice();
    virtual ~CBaseDevice();
    HRESULT Init(
        PD3D8_DEVICEDATA        pDeviceData,
        D3DDEVTYPE              DeviceType,
        HWND                    hwndFocusWindow,
        DWORD                   dwBehaviorFlags,
        D3DPRESENT_PARAMETERS  *pPresentationParameters,
        UINT                    AdapterIndex,
        CEnum*                  Parent);

    PD3D8_CALLBACKS GetHalCallbacks(void)
    {
        return &m_DeviceData.Callbacks;
    } // GetHalCallbacks

    // Get a handle for the device; used for kernel calls
    HANDLE GetHandle(void) const
    {
        return m_DeviceData.hDD;
    } // GetHandle

    BOOL CanTexBlt(void) const
    {
        if (GetDeviceType() == D3DDEVTYPE_SW ||
            GetDeviceType() == D3DDEVTYPE_REF)
        {
            // TexBlt is not supported for software
            // devices
            return FALSE;
        }
        // DX7 and above
        return (m_ddiType >= D3DDDITYPE_DX7);
    } // CanTexBlt

    BOOL CanBufBlt(void) const
    {
        if (GetDeviceType() == D3DDEVTYPE_SW ||
            GetDeviceType() == D3DDEVTYPE_REF)
        {
            // BufBlt is not supported for software
            // devices
            return FALSE;
        }
        // DX8 and above
        return (m_ddiType >= D3DDDITYPE_DX8);
    } // CanBufBlt

    BOOL CanDriverManageResource(void) const
    {
        if (m_dwBehaviorFlags & D3DCREATE_DISABLE_DRIVER_MANAGEMENT)
        {
            return FALSE;
        }
        else if (GetD3DCaps()->Caps2 & DDCAPS2_CANMANAGERESOURCE)
        {
            DDASSERT(m_ddiType >= D3DDDITYPE_DX8);
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    } // CanDriverManage

    D3DDDITYPE GetDDIType(void) const
    {
        return m_ddiType;
    } // GetDDIType

    const D3D8_DRIVERCAPS* GetCoreCaps() const
    {
        return &m_DeviceData.DriverData;
    } // GetCoreCaps

    const D3DCAPS8* GetD3DCaps() const
    {
        return &m_DeviceData.DriverData.D3DCaps;
    } // GetD3DCaps

    D3DDISPLAYMODE* GetModeTable() const
    {
        return m_pD3DClass->GetModeTable(m_AdapterIndex);
    } // GetModeTable

    VOID* GetInitFunction() const
    {
        if (m_DeviceType == D3DDEVTYPE_SW)
        {
            return m_pD3DClass->GetInitFunction();
        }
        return NULL;
    } // GetModeTable

    const DWORD GetNumModes() const
    {
        return m_pD3DClass->GetNumModes(m_AdapterIndex);
    } // GetNumModes

    D3D8_DEVICEDATA* GetDeviceData()
    {
        return &m_DeviceData;
    } // GetDeviceData

    CBaseSurface *ZBuffer() const
    {
        return m_pZBuffer;
    } // ZBuffer

    CBaseSurface *RenderTarget() const
    {
        return m_pRenderTarget;
    } // RenderTarget

    void UpdateRenderTarget(CBaseSurface *pRenderTarget, CBaseSurface *pZStencil);

    CResourceManager* ResourceManager() const
    {
        // return the ResourceManager
        return m_pResourceManager;
    } // ResourceManager

    CEnum * Enum() const
    {
        // return the enumerator that created us
        return m_pD3DClass;
    } // Enum

    // Internal version of CopyRects (no parameter validation)
    HRESULT InternalCopyRects(CBaseSurface *pSourceSurface,
                              CONST RECT   *pSourceRectsArray,
                              UINT          cRects,
                              CBaseSurface *pDestinationSurface,
                              CONST POINT  *pDestPointsArray); 

    // Internal function for format validation
    HRESULT CheckDeviceFormat(DWORD             Usage,
                              D3DRESOURCETYPE   RType,
                              D3DFORMAT         CheckFormat)
    {
        return Enum()->CheckDeviceFormat(AdapterIndex(),
                                         GetDeviceType(),
                                         DisplayFormat(),
                                         Usage,
                                         RType,
                                         CheckFormat);
    } // CheckDeviceFormats


    HRESULT CheckDepthStencilMatch(D3DFORMAT RTFormat, D3DFORMAT DSFormat)
    {
        return Enum()->CheckDepthStencilMatch(AdapterIndex(),
                                              GetDeviceType(),
                                              DisplayFormat(),
                                              RTFormat,
                                              DSFormat);
    } // CheckDepthStencilMatch

    // Internal function for multi-sample validation
    HRESULT CheckDeviceMultiSampleType(D3DFORMAT           RenderTargetFormat,
                                       BOOL                Windowed,
                                       D3DMULTISAMPLE_TYPE MultiSampleType)
    {
        return Enum()->CheckDeviceMultiSampleType(
            AdapterIndex(),
            GetDeviceType(),
            RenderTargetFormat,
            Windowed,
            MultiSampleType);
    } // CheckDeviceMultiSampleType

    D3DFORMAT MapDepthStencilFormat(D3DFORMAT Format) const
    {
        return Enum()->MapDepthStencilFormat(
                AdapterIndex(),
                GetDeviceType(),
                Format);
    } // MapDepthStencilFormat

    UINT DisplayWidth() const { return m_DeviceData.DriverData.DisplayWidth; }
    UINT DisplayHeight() const { return m_DeviceData.DriverData.DisplayHeight; }
    D3DFORMAT DisplayFormat() const { return m_DeviceData.DriverData.DisplayFormatWithoutAlpha; }
    UINT DisplayRate() const { return m_DeviceData.DriverData.DisplayFrequency; }
    D3DDEVTYPE GetDeviceType() const
    {
        // Check this value is correct; pure types shouldn't happen
        // and other values are wrong. Users of this method
        // assume that these three are the only possible values.
        DDASSERT(m_DeviceType == D3DDEVTYPE_REF ||
                 m_DeviceType == D3DDEVTYPE_SW ||
                 m_DeviceType == D3DDEVTYPE_HAL);

        return m_DeviceType;
    }
    HWND FocusWindow()
    {
        return m_hwndFocusWindow;
    } // FocusWindow

    CSwapChain* SwapChain() const
    {
        DDASSERT(m_pSwapChain);
        return m_pSwapChain;
    }
    D3DDISPLAYMODE    DesktopMode() const
    {
        return  m_DesktopMode;
    }
    UINT AdapterIndex() const
    {
        return  m_AdapterIndex;
    }
    DWORD BehaviorFlags() const
    {
        return m_dwBehaviorFlags;
    }
    void ResetZStencil()
    {
        m_pAutoZStencil = NULL;
    }
    CBaseSurface* GetZStencil() const
    {
        return m_pAutoZStencil;
    }

    void EnableVidmemVBs()
    {
        m_DeviceData.DriverData.D3DCaps.DevCaps |= (D3DDEVCAPS_HWVERTEXBUFFER);
    }

    void DisableVidmemVBs()
    {
        m_DeviceData.DriverData.D3DCaps.DevCaps &= ~(D3DDEVCAPS_HWVERTEXBUFFER);
    }

    BOOL DriverSupportsVidmemVBs() const
    {
        return (GetD3DCaps()->DevCaps & D3DDEVCAPS_HWVERTEXBUFFER);
    }

    BOOL DriverSupportsVidmemIBs() const
    {
        return (GetD3DCaps()->DevCaps & D3DDEVCAPS_HWINDEXBUFFER);
    }

    BOOL VBFailOversDisabled() const
    {
        return m_bVBFailOversDisabled;
    }

    CResource* GetResourceList() const
    {
        return m_pResourceList;
    }

    void SetResourceList(CResource *pRes)
    {
        m_pResourceList = pRes;
    }

#ifdef DEBUG
    // debugging helper
    UINT RefCount() const
    {
        return m_cRef;
    } // RefCount
#endif // DEBUG


protected:
    // This is the section for access to things that
    // the derived versions of the base device need.

    D3DDDITYPE                  m_ddiType;


private:
    // We mark "main" as a friend so that gensym can
    // access everything it wants to
    friend int main(void);

    DWORD                        m_cRef;
    BOOL                         m_fullscreen; // should be a flag?
    BOOL                         m_bVBFailOversDisabled;

    CResource                   *m_pResourceList;
    CResourceManager            *m_pResourceManager;

    D3D8_DEVICEDATA              m_DeviceData;
    HWND                         m_hwndFocusWindow;
    DWORD                        m_dwBehaviorFlags;
    DWORD                        m_dwOriginalBehaviorFlags;


    CBaseSurface                *m_pZBuffer;
    CSwapChain                  *m_pSwapChain;
    CBaseSurface                *m_pRenderTarget;
    CBaseSurface                *m_pAutoZStencil;

    D3DDEVTYPE                  m_DeviceType;
    UINT                        m_AdapterIndex;
    CEnum                       *m_pD3DClass;

    D3DDISPLAYMODE              m_DesktopMode;
};


#endif // define __DXGINT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\dxgcreat.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dxgcreat.cpp
 *  Content     Creates the dxg object
 *
 ***************************************************************************/
#include "ddrawpr.h"

// Includes for creation stuff
#include "mipmap.hpp"
#include "mipvol.hpp"
#include "cubemap.hpp"
#include "surface.hpp"
#include "vbuffer.hpp"
#include "ibuffer.hpp"
#include "swapchan.hpp"
#include "resource.hpp"
#include "d3di.hpp"
#include "resource.inl"

#ifdef WINNT
extern "C" BOOL IsWhistler();
#endif

//---------------------------------------------------------------------------
// CBaseDevice methods
//---------------------------------------------------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::AddRef"

STDMETHODIMP_(ULONG) CBaseDevice::AddRef(void)
{
    API_ENTER_NO_LOCK(this);

    // InterlockedIncrement requires the memory
    // to be aligned on DWORD boundary
    DXGASSERT(((ULONG_PTR)(&m_cRef) & 3) == 0);
    InterlockedIncrement((LONG *)&m_cRef);
    return m_cRef;
} // AddRef

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::Release"

STDMETHODIMP_(ULONG) CBaseDevice::Release(void)
{
    API_ENTER_NO_LOCK(this);

    // InterlockedDecrement requires the memory
    // to be aligned on DWORD boundary
    DXGASSERT(((ULONG_PTR)(&m_cRef) & 3) == 0);
    InterlockedDecrement((LONG *)&m_cRef);
    if (m_cRef != 0)
        return m_cRef;

    // If we are about to release; we
    // DPF a warning if the release is on a different
    // thread than the create
    if (!CheckThread())
    {
        DPF_ERR("Final Release for a device can only be called "
                "from the thread that the "
                "device was created from.");

        // No failure can be returned; but this is
        // dangerous situation for the app since
        // windows messages may still be processed
    }

    delete this;
    return 0;
} // Release

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::QueryInterface"

STDMETHODIMP CBaseDevice::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    API_ENTER(this);

    if (!VALID_PTR_PTR(ppv))
    {
        DPF_ERR("Invalid pointer passed to QueryInterface for IDirect3DDevice8" );
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_PTR(&riid, sizeof(GUID)))
    {
        DPF_ERR("Invalid guid memory address to QueryInterface for IDirect3DDevice8");
        return D3DERR_INVALIDCALL;
    }

    if (riid == IID_IUnknown || riid == IID_IDirect3DDevice8)
    {
        *ppv = static_cast<void*>(static_cast<IDirect3DDevice8*>(this));
        AddRef();
    }
    else
    {
        DPF_ERR("Unsupported Interface identifier passed to QueryInterface for IDirect3DDevice8");
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    return S_OK;
} // QueryInterface


#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::CreateAdditionalSwapChain"

// Swap Chain stuff
STDMETHODIMP
CBaseDevice::CreateAdditionalSwapChain(
    D3DPRESENT_PARAMETERS *pPresentationParams,
    IDirect3DSwapChain8 **pSwapChain)
{
    API_ENTER(this);
    if (!VALID_WRITEPTR(pPresentationParams, sizeof(D3DPRESENT_PARAMETERS)))
    {
        DPF_ERR("Invalid D3DPRESENT_PARAMETERS pointer to CreateAdditionalSwapChain");
        return D3DERR_INVALIDCALL;
    }
    if (!VALID_PTR_PTR(pSwapChain))
    {
        DPF_ERR("Invalid IDirect3DSwapChain8* pointer to CreateAdditionalSwapChain");
        return D3DERR_INVALIDCALL;
    }

    // Zero out return param
    *pSwapChain = NULL;

    if (NULL == m_pSwapChain)
    {
        DPF_ERR("No Swap Chain present; CreateAdditionalSwapChain fails");
        return D3DERR_INVALIDCALL;
    }

    if (pPresentationParams->BackBufferFormat == D3DFMT_UNKNOWN)
    {
        DPF_ERR("Invalid backbuffer format specified. CreateAdditionalSwapChain fails");
        return D3DERR_INVALIDCALL;
    }

    if (m_pSwapChain->m_PresentationData.Windowed
        && pPresentationParams->Windowed)
    {
        // both device and swapchain have to be windowed
        HRESULT hr;

        if ((NULL == pPresentationParams->hDeviceWindow)
            && (NULL == FocusWindow()))
        {
            DPF_ERR("Neither hDeviceWindow nor Focus window specified. CreateAdditionalSwapChain fails");
            return D3DERR_INVALIDCALL;
        }

        *pSwapChain = new CSwapChain(
            this,
            REF_EXTERNAL);

        if (*pSwapChain == NULL)
        {
            DPF_ERR("Out of memory creating swap chain. CreateAdditionalSwapChain fails");
            return E_OUTOFMEMORY;
        }

        static_cast<CSwapChain *> (*pSwapChain) ->Init(
            pPresentationParams,
            &hr);

        if (FAILED(hr))
        {
            DPF_ERR("Failure initializing swap chain. CreateAdditionalSwapChain fails");
            (*pSwapChain)->Release();
            *pSwapChain = NULL;
            return hr;
        }
        return hr;
    }
    else
    {
        DPF_ERR("Can't Create Additional SwapChain for FullScreen");
        return D3DERR_INVALIDCALL;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::SetCursorProperties"
STDMETHODIMP
CBaseDevice::SetCursorProperties(
    UINT    xHotSpot,
    UINT    yHotSpot,
    IDirect3DSurface8 *pCursorBitmap)
{
    API_ENTER(this);

    if (pCursorBitmap == NULL)
    {
        DPF_ERR("Invalid parameter for pCursorBitmap");
        return D3DERR_INVALIDCALL;
    }
    CBaseSurface *pCursorSrc = static_cast<CBaseSurface*>(pCursorBitmap);
    if (pCursorSrc->InternalGetDevice() != this)
    {
        DPF_ERR("Cursor Surface wasn't allocated with this Device. SetCursorProperties fails");
        return D3DERR_INVALIDCALL;
    }

    if (SwapChain()->m_pCursor)
    {
        return SwapChain()->m_pCursor->SetProperties(
            xHotSpot,
            yHotSpot,
            pCursorSrc);
    }
    else
    {
        DPF_ERR("Device is lost. SetCursorProperties does nothing.");
        return S_OK;
    }
} // SetCursorProperties

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::SetCursorPosition"
STDMETHODIMP_(void)
CBaseDevice::SetCursorPosition(
    UINT xScreenSpace,
    UINT yScreenSpace,
    DWORD Flags)
{
    API_ENTER_VOID(this);

    if (SwapChain()->m_pCursor)
        SwapChain()->m_pCursor->SetPosition(xScreenSpace,yScreenSpace,Flags);
    else
        DPF_ERR("Device is lost. SetCursorPosition does nothing.");

    return;
} // SetCursorPosition

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::ShowCursor"
STDMETHODIMP_(BOOL)
CBaseDevice::ShowCursor(
    BOOL bShow  // cursor visibility flag
  )
{
    API_ENTER_RET(this, BOOL);

    if (SwapChain()->m_pCursor)
        return  m_pSwapChain->m_pCursor->SetVisibility(bShow);
    DPF_ERR("Device is lost. ShowCursor does nothing.");
    return FALSE;
} // ShowCursor


#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::Reset"

STDMETHODIMP
CBaseDevice::Reset(
    D3DPRESENT_PARAMETERS *pPresentationParams
   )
{
    API_ENTER(this);
    HRESULT hr;

    if (!CheckThread())
    {
        DPF_ERR("Reset can only be called from the thread that the "
                "device was created from.");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_WRITEPTR(pPresentationParams, sizeof(D3DPRESENT_PARAMETERS)))
    {
        DPF_ERR("Invalid D3DPRESENT_PARAMETERS pointer, Reset fails");
        hr = D3DERR_INVALIDCALL;
        goto LoseDevice;
    }

    if (NULL == FocusWindow())
    {
        if (!pPresentationParams->Windowed)
        {
            DPF_ERR("Can't Reset a Device w/o Focus window to Fullscreen");
            hr = D3DERR_INVALIDCALL;
            goto LoseDevice;
        }
        else
        if (NULL == pPresentationParams->hDeviceWindow)
        {
            DPF_ERR("Neither hDeviceWindow nor Focus window specified. Reset fails.");
            hr = D3DERR_INVALIDCALL;
            goto LoseDevice;
        }
    }
    if (pPresentationParams->BackBufferFormat == D3DFMT_UNKNOWN)
    {
        DPF_ERR("Invalid backbuffer format specified. Reset fails");
        hr = D3DERR_INVALIDCALL;
        goto LoseDevice;
    }

    if (NULL == m_pSwapChain)
    {
        DPF_ERR("No Swap Chain present, Reset fails");
        hr = D3DERR_INVALIDCALL;
        goto LoseDevice;
    }

    hr = TestCooperativeLevel();
    if (D3DERR_DEVICELOST == hr)
    {
        DPF_ERR("Reset fails. D3DERR_DEVICELOST returned.");
        goto LoseDevice;
    }
    else if (D3DERR_DEVICENOTRESET == hr)
    {
        // There might be a external mode switch or ALT-TAB from fullscreen
        FetchDirectDrawData(GetDeviceData(), GetInitFunction(),
            Enum()->GetUnknown16(AdapterIndex()),
            Enum()->GetHalOpList(AdapterIndex()),
            Enum()->GetNumHalOps(AdapterIndex()));

        // only update the DesktopMode
        // if lost device was windowed or Fullscreen(but ALT-TABed away)
        // in Multimon case, even Fullscreen with exclusive mode Device could
        // be lost due to a mode change in other adapters and DesktopMode
        // should NOT be updated as it's the current fullscreen mode
        if (!SwapChain()->m_bExclusiveMode)
        {
            m_DesktopMode.Height = DisplayHeight();
            m_DesktopMode.Width = DisplayWidth();
            m_DesktopMode.Format = DisplayFormat();
            m_DesktopMode.RefreshRate = DisplayRate();
        }
    }
    else if (m_fullscreen)
    {
        SwapChain()->FlipToGDISurface();
    }

    if ( S_OK == hr && RenderTarget())
    {
        RenderTarget()->Sync();
    }

    static_cast<CD3DBase*>(this)->CleanupTextures();

    hr = m_pSwapChain->Reset(
        pPresentationParams);

    if (FAILED(hr))
    {
        goto LoseDevice;
    }

    if (pPresentationParams->EnableAutoDepthStencil)
    {
        // Need to validate that this Z-buffer matches
        // the HW
        hr = CheckDepthStencilMatch(pPresentationParams->BackBufferFormat,
                                    pPresentationParams->AutoDepthStencilFormat);
        if (FAILED(hr))
        {
            DPF_ERR("AutoDepthStencilFormat does not match BackBufferFormat "
                    "because the current Device requires the bitdepth of the "
                    "zbuffer to match the render-target. Reset Failed");
            goto LoseDevice;
        }

        IDirect3DSurface8 *pSurf;
        hr = CSurface::CreateZStencil(this,
                                      m_pSwapChain->Width(),
                                      m_pSwapChain->Height(),
                                      pPresentationParams->AutoDepthStencilFormat,
                                      pPresentationParams->MultiSampleType,
                                      REF_INTRINSIC,
                                      &pSurf);
        if (FAILED(hr))
        {
            DPF_ERR("Failure trying to create automatic zstencil surface. Reset Fails");
            goto LoseDevice;
        }
        DXGASSERT(m_pAutoZStencil == NULL);
        m_pAutoZStencil      = static_cast<CBaseSurface *>(pSurf);
    }

    // Disconnect Buffers from our device's state if there is any
    // I tried to not Destroy() upon window->window Reset
    // however, there are many other cares which require it,
    // such as device lost or m_pDDI=NULL due to earlier failure
    // also SetRenderTarget() is tough when m_pDDI is bad
    // some driver(like ATI Rage3) could not Reset view correctly
    // even after SetRenderTarget()
    // therefore always Destroy and do a Init, as a result, driver
    // will always get a DestroyContext and CreateContext clean
//    static_cast<CD3DBase*>(this)->Destroy();
    UpdateRenderTarget(m_pSwapChain->m_ppBackBuffers[0], m_pAutoZStencil);
    hr = static_cast<CD3DBase*>(this)->Init();
LoseDevice:
    if (FAILED(hr))
    {
        DPF_ERR("Reset failed and Reset/TestCooperativeLevel/Release "
            "are the only legal APIs to be called subsequently");
        if ((SwapChain()) && (!SwapChain()->m_PresentationData.Windowed))
        {
            // release the exclusive upon failure
            SwapChain()->m_PresentationData.Windowed = TRUE;
            SwapChain()->SetCooperativeLevel();
        }
        D3D8LoseDevice(GetHandle());
    }
    else
    {
        hr = CResource::RestoreDriverManagementState(this);
        if (FAILED(hr))
        {
            goto LoseDevice;
        }
        hr = static_cast<CD3DBase*>(this)->ResetShaders();
        if (FAILED(hr))
        {
            goto LoseDevice;
        }
    }
    m_fullscreen = !SwapChain()->m_PresentationData.Windowed;
    return hr;
} // Reset

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::SetGammaRamp"

STDMETHODIMP_(void)
CBaseDevice::SetGammaRamp(DWORD dwFlags, CONST D3DGAMMARAMP *pRamp)
{
    API_ENTER_VOID(this);

    if (NULL == pRamp)
    {
        DPF_ERR("Invalid D3DGAMMARAMP pointer. SetGammaRamp ignored.");
        return;
    }
    if (m_pSwapChain == NULL)
    {
        DPF_ERR("No Swap Chain present; SetGammaRamp fails");
        return;
    }

    m_pSwapChain->SetGammaRamp(dwFlags, pRamp);
} // SetGammaRamp

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::GetGammaRamp"

STDMETHODIMP_(void)
CBaseDevice::GetGammaRamp(D3DGAMMARAMP *pRamp)
{
    API_ENTER_VOID(this);

    if (NULL == pRamp)
    {
        DPF_ERR("Invalid D3DGAMMARAMP pointer. GetGammaRamp ignored");
        return;
    }
    if (m_pSwapChain == NULL)
    {
        DPF_ERR("No Swap Chain present; GetGammaRamp fails");
        return;
    }

    m_pSwapChain->GetGammaRamp(pRamp);
} // GetGammaRamp

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::GetBackBuffer"

HRESULT
CBaseDevice::GetBackBuffer(UINT                iBackBuffer,
                           D3DBACKBUFFER_TYPE  Type,
                           IDirect3DSurface8 **ppBackBuffer)
{
    API_ENTER(this);

    if (!VALID_PTR_PTR(ppBackBuffer))
    {
        DPF_ERR("Invalid IDirect3DSurface8* pointer to GetBackBuffer");
        return D3DERR_INVALIDCALL;
    }

    // Zero out return param
    *ppBackBuffer = NULL;

    if (m_pSwapChain == NULL)
    {
        DPF_ERR("No Swap Chain present; GetBackBuffer fails");
        return D3DERR_INVALIDCALL;
    }

    return m_pSwapChain->GetBackBuffer(iBackBuffer, Type, ppBackBuffer);
} // GetBackBuffer

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::Present"

STDMETHODIMP
CBaseDevice::Present(
    CONST RECT    *pSrcRect,
    CONST RECT    *pDestRect,
    HWND    hWndDestOverride,
    CONST RGNDATA *pDstRegion
   )
{
    API_ENTER(this);

    if (m_pSwapChain == NULL)
    {
        DPF_ERR("No Swap Chain present; Present fails");
        return D3DERR_INVALIDCALL;
    }
    return m_pSwapChain->Present(pSrcRect, pDestRect, hWndDestOverride, pDstRegion);
} // Present

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::TestCooperativeLevel"
STDMETHODIMP CBaseDevice::TestCooperativeLevel(void)
{
    API_ENTER(this);

    if (D3D8IsDeviceLost(GetHandle()))
    {
#ifdef WINNT
        if (m_pSwapChain)
        {
            BOOL bDeactivated = m_pSwapChain->IsWinProcDeactivated();
            if (bDeactivated)
                return D3DERR_DEVICELOST;
        }

        HWND EnumFocusWindow = Enum()->ExclusiveOwnerWindow();
        if (EnumFocusWindow &&
            EnumFocusWindow != FocusWindow())
        {
            DPF(0, "Another device in the same process has gone full-screen."
                   " If you wanted both to go full-screen at the same time,"
                   " you need to pass the same HWND for the Focus Window.");

            return D3DERR_DEVICELOST;
        }
        BOOL    bThisDeviceOwnsExclusive;
        BOOL    bExclusiveExists = Enum()->CheckExclusiveMode(this,
                &bThisDeviceOwnsExclusive, FALSE);
        if (bExclusiveExists && !bThisDeviceOwnsExclusive)
        {
            return D3DERR_DEVICELOST;
        }

#endif  //WINNT
        if (D3D8CanRestoreNow(GetHandle()))
        {
            return D3DERR_DEVICENOTRESET;
        }
        return D3DERR_DEVICELOST;
    }

    return S_OK;
} // TestCooperativeLevel

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::GetRasterStatus"
STDMETHODIMP CBaseDevice::GetRasterStatus(D3DRASTER_STATUS *pStatus)
{
    API_ENTER(this);

    if (!VALID_WRITEPTR(pStatus, sizeof(*pStatus)))
    {
        DPF_ERR("Invalid Raster Status parameter to GetRasterStatus");
        return D3DERR_INVALIDCALL;
    }

    if (!(GetD3DCaps()->Caps & D3DCAPS_READ_SCANLINE))
    {
        pStatus->ScanLine = 0;
        pStatus->InVBlank = FALSE;
        DPF_ERR("Current device doesn't support D3DCAPS_READ_SCANLINE functionality. GetRasterStatus fails.");
        return D3DERR_INVALIDCALL;
    }

    D3D8_GETSCANLINEDATA getScanLineData;
    getScanLineData.hDD = GetHandle();

    DWORD dwRet = GetHalCallbacks()->GetScanLine(&getScanLineData);
    if (dwRet == DDHAL_DRIVER_HANDLED)
    {
        if (getScanLineData.ddRVal == S_OK)
        {
            pStatus->InVBlank = getScanLineData.bInVerticalBlank;
            if (getScanLineData.bInVerticalBlank)
            {
                pStatus->ScanLine = 0;
            }
            else
            {
                pStatus->ScanLine = getScanLineData.dwScanLine;
            }
        }
        else
        {
            DPF_ERR("Device failed GetScanline. GetRasterStatus fails");
            pStatus->ScanLine = 0;
            pStatus->InVBlank = FALSE;
            return D3DERR_NOTAVAILABLE;
        }
    }
    else
    {
        DPF_ERR("Device failed GetScanline. GetRasterStatus fails.");
        pStatus->ScanLine = 0;
        pStatus->InVBlank = FALSE;
        return D3DERR_NOTAVAILABLE;
    }

    return S_OK;
} // GetRasterStatus

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::GetDirect3D"

STDMETHODIMP CBaseDevice::GetDirect3D(LPDIRECT3D8 *pD3D8)
{
    API_ENTER(this);

    if (pD3D8 == NULL)
    {
        DPF_ERR("Invalid pointer specified. GetDirect3D fails.");
        return D3DERR_INVALIDCALL;
    }

    DXGASSERT(m_pD3DClass);

    m_pD3DClass->AddRef();
    *pD3D8 = m_pD3DClass;

    return D3D_OK;
} // GetDirect3D

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::GetCreationParameters"

STDMETHODIMP CBaseDevice::GetCreationParameters(D3DDEVICE_CREATION_PARAMETERS *pParameters)
{
    API_ENTER(this);

    if (!VALID_WRITEPTR(pParameters, sizeof(D3DDEVICE_CREATION_PARAMETERS)))
    {
        DPF_ERR("bad pointer for pParameters passed to GetCreationParameters");
        return D3DERR_INVALIDCALL;
    }

    pParameters->AdapterOrdinal = m_AdapterIndex;
    pParameters->DeviceType     = m_DeviceType;
    pParameters->BehaviorFlags  = m_dwOriginalBehaviorFlags;
    pParameters->hFocusWindow   = m_hwndFocusWindow;

    return S_OK;
} // GetCreationParameters


#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::GetDisplayMode"

STDMETHODIMP CBaseDevice::GetDisplayMode(D3DDISPLAYMODE *pMode)
{
    API_ENTER(this);

    if (!VALID_WRITEPTR(pMode, sizeof(*pMode)))
    {
        DPF_ERR("Invalid pointer specified to GetDisplayMode");
        return D3DERR_INVALIDCALL;
    }

    pMode->Width = DisplayWidth();
    pMode->Height = DisplayHeight();
    pMode->Format = DisplayFormat();
    pMode->RefreshRate = DisplayRate();

    return D3D_OK;
} // GetDisplayMode

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::GetAvailableTextureMem"

STDMETHODIMP_(UINT) CBaseDevice::GetAvailableTextureMem(void)
{
    API_ENTER_RET(this, UINT);


    D3D8_GETAVAILDRIVERMEMORYDATA GetAvailDriverMemory;

    GetAvailDriverMemory.hDD = GetHandle();
    GetAvailDriverMemory.Pool = D3DPOOL_DEFAULT;
    GetAvailDriverMemory.dwUsage = D3DUSAGE_TEXTURE;
    GetAvailDriverMemory.dwFree = 0;

    GetHalCallbacks()->GetAvailDriverMemory(&GetAvailDriverMemory);

    #define ONE_MEG_O_VRAM  0x100000

    //Round to nearest meg:
    return (GetAvailDriverMemory.dwFree + ONE_MEG_O_VRAM/2) & (~(ONE_MEG_O_VRAM-1));
} // GetAvailableTextureMem

#undef DPF_MODNAME
#define DPF_MODNAME "CanHardwareBlt"

BOOL CanHardwareBlt (const D3D8_DRIVERCAPS* pDriverCaps,
                           D3DPOOL SrcPool,
                           D3DFORMAT SrcFormat,
                           D3DPOOL DstPool,
                           D3DFORMAT DstFormat,
                           D3DDEVTYPE DeviceType)
{
    // Pools are supposed to be real pools as opposed to
    // what the app specified
    DXGASSERT(SrcPool != D3DPOOL_DEFAULT);
    DXGASSERT(DstPool != D3DPOOL_DEFAULT);
    DXGASSERT(VALID_INTERNAL_POOL(SrcPool));
    DXGASSERT(VALID_INTERNAL_POOL(DstPool));

    //Driver should never be allowed to see scratch:
    if (SrcPool == D3DPOOL_SCRATCH ||
        DstPool == D3DPOOL_SCRATCH)
    {
        return FALSE;
    }

    // For this case, we want to just lock and memcpy.  Why?
    // It's a software driver, so it's going to be a memcpy anyway,
    // and we special case blt since we want to use a real hardware
    // blt for Present even when running a software driver.  So either
    // we lock and memcpy, or we have to keep track of two different
    // Blt entry points (one for the real driver and one for the software
    // driver) just so the software driver can do the memcpy itself.

    if (DeviceType != D3DDEVTYPE_HAL)
    {
        return FALSE;
    }

    // Check that source and dest formats match
    DXGASSERT(SrcFormat == DstFormat);

    // FourCC may not be copy-able
    if (CPixel::IsFourCC(SrcFormat))
    {
        if (!(pDriverCaps->D3DCaps.Caps2 & DDCAPS2_COPYFOURCC))
        {
            return FALSE;
        }
    }

    // We can't do HW blts if either source or
    // dest is in system memory and the driver
    // needs PageLocks
    if (SrcPool == D3DPOOL_SYSTEMMEM ||
        DstPool == D3DPOOL_SYSTEMMEM)
    {
        if (!(pDriverCaps->D3DCaps.Caps2 & DDCAPS2_NOPAGELOCKREQUIRED))
        {
            return FALSE;
        }

        // Now this is tricky; but in DX7 we checked this cap when
        // deciding whether to do BLTs involving system-memory but not
        // when we decided whether to do real Blts. We need to check this.
        if (!(pDriverCaps->D3DCaps.Caps & DDCAPS_CANBLTSYSMEM))
        {
            return FALSE;
        }
    }

    // Check AGP caps first
    if (pDriverCaps->D3DCaps.Caps2 & DDCAPS2_NONLOCALVIDMEMCAPS)
    {
        if (SrcPool == D3DPOOL_SYSTEMMEM)
        {
            if ((DstPool == D3DPOOL_NONLOCALVIDMEM) &&
                (pDriverCaps->D3DCaps.Caps2 & DDCAPS2_SYSTONONLOCAL_AS_SYSTOLOCAL) &&
                (pDriverCaps->SVBCaps & DDCAPS_BLT))
            {
                return TRUE;
            }
            else if (((DstPool == D3DPOOL_LOCALVIDMEM) ||
                      (DstPool == D3DPOOL_MANAGED)) &&
                      (pDriverCaps->SVBCaps & DDCAPS_BLT))
            {
                return TRUE;
            }
        }
        else if (SrcPool == D3DPOOL_NONLOCALVIDMEM)
        {
            if (((DstPool == D3DPOOL_LOCALVIDMEM) ||
                 (DstPool == D3DPOOL_MANAGED)) &&
                 (pDriverCaps->NLVCaps & DDCAPS_BLT))
            {
                return TRUE;
            }
        }
        else if ((SrcPool == D3DPOOL_LOCALVIDMEM) ||
                 (SrcPool == D3DPOOL_MANAGED))
        {
            if (((DstPool == D3DPOOL_LOCALVIDMEM) ||
                 (DstPool == D3DPOOL_MANAGED)) &&
                 (pDriverCaps->D3DCaps.Caps & DDCAPS_BLT))
            {
                return TRUE;
            }
            else if ((DstPool == D3DPOOL_SYSTEMMEM) &&
                     (pDriverCaps->VSBCaps & DDCAPS_BLT))
            {
                return TRUE;
            }
        }
    }
    else
    {
        if (SrcPool == D3DPOOL_SYSTEMMEM)
        {
            if (((DstPool == D3DPOOL_LOCALVIDMEM) ||
                 (DstPool == D3DPOOL_MANAGED)) &&
                 (pDriverCaps->SVBCaps & DDCAPS_BLT))
            {
                return TRUE;
            }
        }
        else if ((SrcPool == D3DPOOL_LOCALVIDMEM) ||
                 (SrcPool == D3DPOOL_MANAGED))
        {
            if (((DstPool == D3DPOOL_LOCALVIDMEM) ||
                 (DstPool == D3DPOOL_MANAGED)) &&
                 (pDriverCaps->D3DCaps.Caps & DDCAPS_BLT))
            {
                return TRUE;
            }
            else if ((DstPool == D3DPOOL_SYSTEMMEM) &&
                     (pDriverCaps->VSBCaps & DDCAPS_BLT))
            {
                return TRUE;
            }
        }
    }

    return FALSE;
} // CanHardwareBlt

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::CopyRects"

STDMETHODIMP CBaseDevice::CopyRects(IDirect3DSurface8 *pSrcSurface,
                                    CONST RECT        *pSrcRectsArray,
                                    UINT               cRects,
                                    IDirect3DSurface8 *pDstSurface,
                                    CONST POINT       *pDstPointsArray)
{
    API_ENTER(this);

    D3DSURFACE_DESC     SrcDesc;
    D3DSURFACE_DESC     DstDesc;
    HRESULT             hr;
    UINT                i;

    // Do some basic paramater checking
    if (!VALID_PTR(pSrcSurface, sizeof(void*)) ||
        !VALID_PTR(pDstSurface, sizeof(void*)))
    {
        DPF_ERR("NULL surface interface specified. CopyRect fails");
        return D3DERR_INVALIDCALL;
    }

    CBaseSurface *pSrc = static_cast<CBaseSurface*>(pSrcSurface);
    if (pSrc->InternalGetDevice() != this)
    {
        DPF_ERR("SrcSurface was not allocated with this Device. CopyRect fails.");
        return D3DERR_INVALIDCALL;
    }

    CBaseSurface *pDst = static_cast<CBaseSurface*>(pDstSurface);
    if (pDst->InternalGetDevice() != this)
    {
        DPF_ERR("DstSurface was not allocated with this Device. CopyRect fails.");
        return D3DERR_INVALIDCALL;
    }

    hr = pSrc->GetDesc(&SrcDesc);
    DXGASSERT(SUCCEEDED(hr));
    hr = pDst->GetDesc(&DstDesc);
    DXGASSERT(SUCCEEDED(hr));

    // Source can not be a load-once surface
    if (SrcDesc.Usage & D3DUSAGE_LOADONCE)
    {
        DPF_ERR("CopyRects can not be used from a Load_Once surface");
        return D3DERR_INVALIDCALL;
    }

    // Destination can not be a load-once surface
    // if it isn't currently lockable.
    if (DstDesc.Usage & D3DUSAGE_LOADONCE)
    {
        if (pDst->IsLoaded())
        {
            DPF_ERR("Destination for CopyRects a Load_Once surface that has"
                    " already been loaded. CopyRects failed.");
            return D3DERR_INVALIDCALL;
        }
    }

    // Source can not be already locked
    if (pSrc->IsLocked())
    {
        DPF_ERR("Source for CopyRects is already Locked. CopyRect failed.");
        return D3DERR_INVALIDCALL;
    }
    if (pDst->IsLocked())
    {
        DPF_ERR("Destination for CopyRects is already Locked. CopyRect failed.");
        return D3DERR_INVALIDCALL;
    }

    if (SrcDesc.Format != DstDesc.Format)
    {
        DPF_ERR("Source and dest surfaces are different formats. CopyRects fails");
        return D3DERR_INVALIDCALL;
    }

    if (CPixel::IsEnumeratableZ(SrcDesc.Format) &&
        !CPixel::IsIHVFormat(SrcDesc.Format))
    {
        DPF_ERR("CopyRects is not supported for Z formats.");
        return D3DERR_INVALIDCALL;
    }

    // Make sure that the rects are entirely within the surface
    if ((cRects > 0) && (pSrcRectsArray == NULL))
    {
        DPF_ERR("Number of rects > 0, but rect array is NULL. CopyRects fails.");
        return D3DERR_INVALIDCALL;
    }

    D3DFORMAT InternalFormat = pSrc->InternalGetDesc().Format;
    BOOL bDXT = CPixel::IsDXT(InternalFormat);

    for (i = 0; i < cRects; i++)
    {
        if (!CPixel::IsValidRect(InternalFormat,
                                 SrcDesc.Width,
                                 SrcDesc.Height,
                                &pSrcRectsArray[i]))
        {
            DPF_ERR("CopyRects failed");
            return D3DERR_INVALIDCALL;
        }

        // Validate the point parameter;
        // if it is NULL, then it means that we're
        // to use the left/top that was in the corresponding rect.
        CONST POINT *pPoint;
        if (pDstPointsArray != NULL)
        {
            pPoint = &pDstPointsArray[i];
        }
        else
        {
            pPoint = (CONST POINT *)&pSrcRectsArray[i];
        }

        if (bDXT)
        {
            if ((pPoint->x & 3) ||
                (pPoint->y & 3))
            {
                DPF_ERR("Destination points array coordinates must each be 4 pixel aligned for DXT surfaces. CopyRects fails");
                return D3DERR_INVALIDCALL;
            }
        }

        // Check that the dest rect (where left/top is the x/y of the point
        // and the right/bottom is x+width, y+height) fits inside
        // the DstDesc.
        if (((pPoint->x +
             (pSrcRectsArray[i].right - pSrcRectsArray[i].left)) > (int)DstDesc.Width) ||
            ((pPoint->y +
             (pSrcRectsArray[i].bottom - pSrcRectsArray[i].top)) > (int)DstDesc.Height) ||
            (pPoint->x < 0) ||
            (pPoint->y < 0))
        {
            DPF_ERR("Destination rect is outside of the surface. CopyRects fails.");
            return D3DERR_INVALIDCALL;
        }
    }

    return InternalCopyRects(pSrc,
                             pSrcRectsArray,
                             cRects,
                             pDst,
                             pDstPointsArray);
} // CopyRects


#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::InternalCopyRects"

HRESULT CBaseDevice::InternalCopyRects(CBaseSurface *pSrcSurface,
                                       CONST RECT   *pSrcRectsArray,
                                       UINT          cRects,
                                       CBaseSurface *pDstSurface,
                                       CONST POINT  *pDstPointsArray)
{
    D3DSURFACE_DESC     SrcDesc = pSrcSurface->InternalGetDesc();
    D3DSURFACE_DESC     DstDesc = pDstSurface->InternalGetDesc();

    HRESULT             hr;

    RECT                Rect;
    POINT               Point;
    CONST RECT*         pRect;
    CONST POINT*        pPoint;
    int                 BPP;
    UINT                i;

    // If either one of these surfaces is a deep mipmap level that the
    // driver can't handle, then we didn't really create it so we don't
    // want to try to copy it.

    if (D3D8IsDummySurface(pDstSurface->KernelHandle()) ||
        D3D8IsDummySurface(pSrcSurface->KernelHandle()))
    {
        return D3D_OK;
    }

    if (pSrcRectsArray == NULL)
    {
        cRects = 1;
        pSrcRectsArray = &Rect;
        Rect.left = Rect.top = 0;
        Rect.right = SrcDesc.Width;
        Rect.bottom = SrcDesc.Height;

        pDstPointsArray = &Point;
        Point.x = Point.y = 0;
    }

    // Now figure out what is the best way to copy the data.

    if (CanHardwareBlt(GetCoreCaps(),
                       SrcDesc.Pool,
                       SrcDesc.Format,
                       DstDesc.Pool,
                       DstDesc.Format,
                       GetDeviceType()))
    {
        // If we are setting up a blt outside of the
        // the DP2 stream; then we must call Sync on the
        // source and destination surfaces to make sure
        // that any pending TexBlt to or from the surfaces
        // or any pending triangles using these textures
        // has been sent down to the driver
        pSrcSurface->Sync();
        pDstSurface->Sync();

        if (DstDesc.Pool == D3DPOOL_SYSTEMMEM)
        {
            // If the destination is system-memory,
            // then we need to mark it dirty. Easiest way
            // is lock/unlock
            D3DLOCKED_RECT LockTemp;
            hr = pDstSurface->InternalLockRect(&LockTemp, NULL, 0);
            if (FAILED(hr))
            {
                DPF_ERR("Could not lock sys-mem destination for CopyRects?");
            }
            else
            {
                hr = pDstSurface->InternalUnlockRect();
                DXGASSERT(SUCCEEDED(hr));
            }
        }


        D3D8_BLTDATA    BltData;
        ZeroMemory(&BltData, sizeof BltData);
        BltData.hDD = GetHandle();
        BltData.hDestSurface = pDstSurface->KernelHandle();
        BltData.hSrcSurface = pSrcSurface->KernelHandle();
        BltData.dwFlags = DDBLT_ROP | DDBLT_WAIT;

        for (i = 0; i < cRects; i++)
        {
            if (pDstPointsArray == NULL)
            {
                BltData.rDest.left = pSrcRectsArray[i].left;
                BltData.rDest.top = pSrcRectsArray[i].top;
            }
            else
            {
                BltData.rDest.left = pDstPointsArray[i].x;
                BltData.rDest.top = pDstPointsArray[i].y;
            }
            BltData.rDest.right = BltData.rDest.left +
                pSrcRectsArray[i].right -
                pSrcRectsArray[i].left;
            BltData.rDest.bottom = BltData.rDest.top +
                pSrcRectsArray[i].bottom -
                pSrcRectsArray[i].top;
            BltData.rSrc.left   = pSrcRectsArray[i].left;
            BltData.rSrc.right  = pSrcRectsArray[i].right;
            BltData.rSrc.top    = pSrcRectsArray[i].top;
            BltData.rSrc.bottom = pSrcRectsArray[i].bottom;

            GetHalCallbacks()->Blt(&BltData);
            if (FAILED(BltData.ddRVal))
            {
                // We should mask errors if we are lost
                // and the copy is to vidmem. Also, if
                // the copy is persistent-to-persistent,
                // then fail-over to our lock&copy code
                // later in this function.

                if (BltData.ddRVal == D3DERR_DEVICELOST)
                {
                    if (DstDesc.Pool == D3DPOOL_MANAGED ||
                        DstDesc.Pool == D3DPOOL_SYSTEMMEM)
                    {
                        if (SrcDesc.Pool == D3DPOOL_MANAGED ||
                            SrcDesc.Pool == D3DPOOL_SYSTEMMEM)
                        {
                            // if we got here
                            // then it must be persistent to persistent
                            // so we break out of our loop
                            break;
                        }

                        DPF_ERR("Failing copy from video-memory surface to "
                                "system-memory or managed surface because "
                                "device is lost. CopyRect returns D3DERR_DEVICELOST");
                        return D3DERR_DEVICELOST;
                    }
                    else
                    {
                        // copying to vid-mem when we are lost
                        // can just be ignored; since the lock
                        // is faked anyhow
                        return S_OK;
                    }
                }
            }
        }

        // We can handle persistent-to-persistent even
        // in case of loss. Other errors are fatal.
        if (BltData.ddRVal != D3DERR_DEVICELOST)
        {
            if (FAILED(BltData.ddRVal))
            {
                DPF_ERR("Hardware Blt failed. CopyRects failed");
            }
            return BltData.ddRVal;
        }
    }

    // We are here either because the device doesn't support Blt, or because
    // the hardware blt failed due to device lost and we think that we can
    // emulate it.

    D3DLOCKED_RECT SrcLock;
    D3DLOCKED_RECT DstLock;
    BOOL           bDXT = FALSE;

    // We need to lock both surfaces and basically do a memcpy

    BPP = CPixel::ComputePixelStride(SrcDesc.Format);

    if (CPixel::IsDXT(BPP))
    {
        bDXT = TRUE;
        BPP *= -1;
    }

    if (BPP == 0)
    {
        DPF_ERR("Format not understood - cannot perform the copy. CopyRects fails.");
        return D3DERR_INVALIDCALL;
    }

    // CONSIDER: We should be passing D3DLOCK_NO_DIRTY_RECT
    // and then call AddDirtyRect if this is part of a
    // texture; probably need to add some method to CBaseSurface
    // for this purpose

    hr = pSrcSurface->InternalLockRect(&SrcLock, NULL, D3DLOCK_READONLY | D3DLOCK_NOSYSLOCK);
    if (FAILED(hr))
    {
        return hr;
    }

    hr = pDstSurface->InternalLockRect(&DstLock, NULL, D3DLOCK_NOSYSLOCK);
    if (FAILED(hr))
    {
        pSrcSurface->InternalUnlockRect();
        return hr;
    }

    // We check for DeviceLost here when copying from vidmem to sysmem since
    // device lost can happen asynchronously.

    if (((DstDesc.Pool == D3DPOOL_MANAGED) ||
         (DstDesc.Pool == D3DPOOL_SYSTEMMEM)) &&
        ((SrcDesc.Pool != D3DPOOL_MANAGED) &&
         (SrcDesc.Pool != D3DPOOL_SYSTEMMEM)))
    {
        if (D3D8IsDeviceLost(GetHandle()))
        {
            pSrcSurface->InternalUnlockRect();
            pDstSurface->InternalUnlockRect();
            return D3DERR_DEVICELOST;
        }
    }

    pRect = pSrcRectsArray;
    pPoint = pDstPointsArray;
    for (i = 0; i < cRects; i++)
    {
        BYTE*   pSrc;
        BYTE*   pDst;
        DWORD   BytesToCopy;
        DWORD   NumRows;

        // If did not specify a dest point, then we
        // will use the src (left, top) as the dest point.

        if (pDstPointsArray == NULL)
        {
            pPoint = (POINT*) pRect;
        }

        // Handle DXT case inside the loop
        // so that we don't have to touch the user's array
        if (bDXT)
        {
            // Figure out our pointers by converting rect/point
            // offsets to blocks
            pSrc  = (BYTE*)SrcLock.pBits;
            pSrc += (pRect->top  / 4) * SrcLock.Pitch;
            pSrc += (pRect->left / 4) * BPP;

            pDst  = (BYTE*)DstLock.pBits;
            pDst += (pPoint->y   / 4) * DstLock.Pitch;
            pDst += (pPoint->x   / 4) * BPP;

            // Convert top/bottom to blocks
            DWORD top    = (pRect->top) / 4;

            // Handle nasty 1xN, 2xN, Nx1, Nx2 DXT cases
            // by rounding.
            DWORD bottom = (pRect->bottom + 3) / 4;

            // For DXT formats, we know that pitch equals
            // width; so we only need to check if we
            // are copying an entire row to an entire
            // row to go the fast path.
            if ((pRect->left == 0) &&
                (pRect->right == (INT)SrcDesc.Width) &&
                (SrcLock.Pitch == DstLock.Pitch))
            {
                BytesToCopy = SrcLock.Pitch * (bottom - top);
                NumRows     = 1;
            }
            else
            {
                // Convert left/right to blocks
                DWORD left  = (pRect->left  / 4);

                // Round for the right -> block conversion
                DWORD right = (pRect->right + 3) / 4;

                BytesToCopy = (right - left) * BPP;
                NumRows     = bottom - top;
            }
        }
        else
        {
            pSrc = (BYTE*)SrcLock.pBits +
                        (pRect->top * SrcLock.Pitch) +
                        (pRect->left * BPP);
            pDst = (BYTE*)DstLock.pBits +
                        (pPoint->y * DstLock.Pitch) +
                        (pPoint->x * BPP);

            // If the src and dest are linear, we can do it all in a single
            // memcpy
            if ((pRect->left == 0) &&
                ((pRect->right * BPP) == SrcLock.Pitch) &&
                (SrcDesc.Width == DstDesc.Width) &&
                (SrcLock.Pitch == DstLock.Pitch))
            {
                BytesToCopy = SrcLock.Pitch * (pRect->bottom - pRect->top);
                NumRows     = 1;
            }
            else
            {
                BytesToCopy = (pRect->right - pRect->left) * BPP;
                NumRows     = pRect->bottom - pRect->top;
            }
        }

        // Copy the rows
        DXGASSERT(NumRows > 0);
        DXGASSERT(BytesToCopy > 0);
        DXGASSERT(SrcLock.Pitch > 0);
        DXGASSERT(DstLock.Pitch > 0);
        for (UINT j = 0; j < NumRows; j++)
        {
            memcpy(pDst,
                   pSrc,
                   BytesToCopy);
            pSrc += SrcLock.Pitch;
            pDst += DstLock.Pitch;
        }

        // Move onward to the next rect/point pair
        pRect++;
        pPoint++;
    }

    // We check for DeviceLost yet again since it coulkd have occurred while 
    // copying the data.

    hr = D3D_OK;
    if (((DstDesc.Pool == D3DPOOL_MANAGED) ||
         (DstDesc.Pool == D3DPOOL_SYSTEMMEM)) &&
        ((SrcDesc.Pool != D3DPOOL_MANAGED) &&
         (SrcDesc.Pool != D3DPOOL_SYSTEMMEM)))
    {
        if (D3D8IsDeviceLost(GetHandle()))
        {
            hr = D3DERR_DEVICELOST;
        }
    }

    pSrcSurface->InternalUnlockRect();
    pDstSurface->InternalUnlockRect();

    return hr;
} // InternalCopyRects

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::UpdateTexture"

STDMETHODIMP CBaseDevice::UpdateTexture(IDirect3DBaseTexture8 *pSrcTexture,
                                        IDirect3DBaseTexture8 *pDstTexture)
{
    API_ENTER(this);

    HRESULT hr;


#ifdef DEBUG
    // Some parameter validation is in Debug only for performance reasons

    if (pSrcTexture == NULL || pDstTexture == NULL)
    {
        DPF_ERR("Invalid parameter to UpdateTexture");
        return D3DERR_INVALIDCALL;
    }

#endif // DEBUG

    CBaseTexture *pSrcTex = CBaseTexture::SafeCast(pSrcTexture);
    if (pSrcTex->Device() != this)
    {
        DPF_ERR("SrcTexture was not created with this Device. UpdateTexture fails");
        return D3DERR_INVALIDCALL;
    }

    CBaseTexture *pDstTex = CBaseTexture::SafeCast(pDstTexture);
    if (pDstTex->Device() != this)
    {
        DPF_ERR("DstTexture  was not created with this Device. UpdateTexture fails");
        return D3DERR_INVALIDCALL;
    }

#ifdef DEBUG
    // Ensure matching formats
    if (pSrcTex->GetUserFormat() != pDstTex->GetUserFormat())
    {
        DPF_ERR("Formats of source and dest don't match. UpdateTexture fails");
        return D3DERR_INVALIDCALL;
    }

    // Ensure matching types
    if (pSrcTex->GetBufferDesc()->Type !=
        pDstTex->GetBufferDesc()->Type)
    {
        DPF_ERR("Types of source and dest don't match. UpdateTexture fails");
        return D3DERR_INVALIDCALL;
    }

    // Check that Source has at least as many levels as dest
    if (pSrcTex->GetLevelCount() < pDstTex->GetLevelCount())
    {
        DPF_ERR("Source for UpdateTexture must have at least as many levels"
                " as the Destination.");
        return D3DERR_INVALIDCALL;
    }

    // Check that the source texture is not already locked
    if (pSrcTex->IsTextureLocked())
    {
        DPF_ERR("Source for UpdateTexture is currently locked. Unlock must be called "
                "before calling UpdateTexture.");
        return D3DERR_INVALIDCALL;
    }

    // Check that the dest texture is not already locked
    if (pDstTex->IsTextureLocked())
    {
        DPF_ERR("Destination for UpdateTexture is currently locked. Unlock must be called "
                "before calling UpdateTexture.");
        return D3DERR_INVALIDCALL;
    }

#endif // DEBUG

    // Ensure that src was specified in Pool systemmem
    if (pSrcTex->GetUserPool() != D3DPOOL_SYSTEMMEM)
    {
        DPF_ERR("Source Texture for UpdateTexture must be in POOL_SYSTEMMEM.");
        return D3DERR_INVALIDCALL;
    }
    // Ensure that destination was specified in Pool default
    if (pDstTex->GetUserPool() != D3DPOOL_DEFAULT)
    {
        DPF_ERR("Destination Texture for UpdateTexture must be in POOL_DEFAULT.");
        return D3DERR_INVALIDCALL;
    }

#ifdef DEBUG
    // Call UpdateTexture on the source which will use the
    // dirty rects to move just what is needed. This
    // function will also do type-specific parameter checking.
    hr = pSrcTex->UpdateTexture(pDstTex);
#else // !DEBUG
    // In Retail we want to call UpdateDirtyPortion directly;
    // which will bypass the parameter checking
    hr = pSrcTex->UpdateDirtyPortion(pDstTex);
#endif // !DEBUG

    if (FAILED(hr))
    {
        DPF_ERR("UpdateTexture failed to copy");
        return hr;
    }

    return hr;
} // UpdateTexture


#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::CreateTexture"

STDMETHODIMP CBaseDevice::CreateTexture(UINT                 Width,
                                        UINT                 Height,
                                        UINT                 cLevels,
                                        DWORD                dwUsage,
                                        D3DFORMAT            Format,
                                        D3DPOOL              Pool,
                                        IDirect3DTexture8  **ppTexture)
{
    API_ENTER(this);

    if (Format == D3DFMT_UNKNOWN)
    {
        DPF_ERR("D3DFMT_UNKNOWN is not a valid format. CreateTexture fails.");
        return D3DERR_INVALIDCALL;
    }

    HRESULT hr = CMipMap::Create(this,
                                 Width,
                                 Height,
                                 cLevels,
                                 dwUsage,
                                 Format,
                                 Pool,
                                 ppTexture);
    if (FAILED(hr))
    {
        DPF_ERR("Failure trying to create a texture");
        return hr;
    }

    return hr;
} // CreateTexture

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::CreateVolumeTexture"

STDMETHODIMP CBaseDevice::CreateVolumeTexture(
    UINT                        Width,
    UINT                        Height,
    UINT                        cpDepth,
    UINT                        cLevels,
    DWORD                       dwUsage,
    D3DFORMAT                   Format,
    D3DPOOL                     Pool,
    IDirect3DVolumeTexture8   **ppVolumeTexture)
{
    API_ENTER(this);

    if (Format == D3DFMT_UNKNOWN)
    {
        DPF_ERR("D3DFMT_UNKNOWN is not a valid format. CreateVolumeTexture fails.");
        return D3DERR_INVALIDCALL;
    }

    HRESULT hr = CMipVolume::Create(this,
                                    Width,
                                    Height,
                                    cpDepth,
                                    cLevels,
                                    dwUsage,
                                    Format,
                                    Pool,
                                    ppVolumeTexture);
    if (FAILED(hr))
    {
        DPF_ERR("Failure trying to create a volume texture");
        return hr;
    }

    return hr;
} // CreateVolumeTexture


#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::CreateCubeTexture"

STDMETHODIMP CBaseDevice::CreateCubeTexture(UINT                    cpEdge,
                                            UINT                    cLevels,
                                            DWORD                   dwUsage,
                                            D3DFORMAT               Format,
                                            D3DPOOL                 Pool,
                                            IDirect3DCubeTexture8 **ppCubeMap)
{
    API_ENTER(this);

    if (Format == D3DFMT_UNKNOWN)
    {
        DPF_ERR("D3DFMT_UNKNOWN is not a valid format. CreateCubeTexture fails.");
        return D3DERR_INVALIDCALL;
    }

    HRESULT hr = CCubeMap::Create(this,
                                  cpEdge,
                                  cLevels,
                                  dwUsage,
                                  Format,
                                  Pool,
                                  ppCubeMap);
    if (FAILED(hr))
    {
        DPF_ERR("Failure trying to create cubemap");
        return hr;
    }

    return hr;

} // CreateCubeTexture

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::CreateRenderTarget"

STDMETHODIMP CBaseDevice::CreateRenderTarget(UINT                 Width,
                                             UINT                 Height,
                                             D3DFORMAT            Format,
                                             D3DMULTISAMPLE_TYPE  MultiSample,
                                             BOOL                 bLockable,
                                             IDirect3DSurface8  **ppSurface)
{
    API_ENTER(this);

    if (Format == D3DFMT_UNKNOWN)
    {
        DPF_ERR("D3DFMT_UNKNOWN is not a valid format. CreateRenderTarget fails.");
        return D3DERR_INVALIDCALL;
    }

    HRESULT hr = CSurface::CreateRenderTarget(this,
                                              Width,
                                              Height,
                                              Format,
                                              MultiSample,
                                              bLockable,
                                              REF_EXTERNAL,
                                              ppSurface);
    if (FAILED(hr))
    {
        DPF_ERR("Failure trying to create render-target");
        return hr;
    }
    return hr;
} // CreateRenderTarget

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::CreateDepthStencilSurface"

STDMETHODIMP CBaseDevice::CreateDepthStencilSurface
    (UINT                 Width,
     UINT                 Height,
     D3DFORMAT            Format,
     D3DMULTISAMPLE_TYPE  MultiSample,
     IDirect3DSurface8  **ppSurface)
{
    API_ENTER(this);

    if (Format == D3DFMT_UNKNOWN)
    {
        DPF_ERR("D3DFMT_UNKNOWN is not a valid format. CreateDepthStencilSurface fails.");
        return D3DERR_INVALIDCALL;
    }

    HRESULT hr = CSurface::CreateZStencil(this,
                                          Width,
                                          Height,
                                          Format,
                                          MultiSample,
                                          REF_EXTERNAL,
                                          ppSurface);
    if (FAILED(hr))
    {
        DPF_ERR("Failure trying to create zstencil surface");
        return hr;
    }
    return hr;
} // CreateDepthStencilSurface


#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::CreateImageSurface"

STDMETHODIMP CBaseDevice::CreateImageSurface(UINT                 Width,
                                             UINT                 Height,
                                             D3DFORMAT            Format,
                                             IDirect3DSurface8  **ppSurface)
{
    API_ENTER(this);

    HRESULT hr = CSurface::CreateImageSurface(this,
                                              Width,
                                              Height,
                                              Format,
                                              REF_EXTERNAL,
                                              ppSurface);
    if (FAILED(hr))
    {
        DPF_ERR("Failure trying to create image surface");
        return hr;
    }
    return hr;
} // CreateImageSurface


#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::CreateVertexBuffer"

STDMETHODIMP CBaseDevice::CreateVertexBuffer(UINT                     cbLength,
                                             DWORD                    dwUsage,
                                             DWORD                    dwFVF,
                                             D3DPOOL                  Pool,
                                             IDirect3DVertexBuffer8 **ppVertexBuffer)
{
    API_ENTER(this);

    if ((dwUsage & ~D3DUSAGE_VB_VALID) != 0)
    {
        DPF_ERR("Invalid usage flags. CreateVertexBuffer fails.");
        return D3DERR_INVALIDCALL;
    }

    // Warn if POOL_DEFAULT and not WRITEONLY. We do this here, because fe creates
    // a VB with WRITEONLY not set and we don't want to warn in that case.
    if (Pool == D3DPOOL_DEFAULT && (dwUsage & D3DUSAGE_WRITEONLY) == 0)
    {
        DPF(1, "Vertexbuffer created with POOL_DEFAULT but WRITEONLY not set. Performance penalty could be severe.");
    }

    HRESULT hr = CVertexBuffer::Create(this,
                                       cbLength,
                                       dwUsage,
                                       dwFVF,
                                       Pool,
                                       REF_EXTERNAL,
                                       ppVertexBuffer);
    if (FAILED(hr))
    {
        DPF_ERR("Failure trying to create Vertex Buffer");
        return hr;
    }
    return hr;

} // CBaseDevice::CreateVertexBuffer

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::CreateIndexBuffer"

STDMETHODIMP CBaseDevice::CreateIndexBuffer(UINT                    cbLength,
                                            DWORD                   dwUsage,
                                            D3DFORMAT               Format,
                                            D3DPOOL                 Pool,
                                            IDirect3DIndexBuffer8 **ppIndexBuffer)
{
    API_ENTER(this);

    if ((dwUsage & ~D3DUSAGE_IB_VALID) != 0)
    {
        DPF_ERR("Invalid usage flags. CreateIndexBuffer fails");
        return D3DERR_INVALIDCALL;
    }

    // Warn if POOL_DEFAULT and not WRITEONLY. We do this here, because fe creates
    // a IB with WRITEONLY not set and we don't want to warn in that case.
    if (Pool == D3DPOOL_DEFAULT && (dwUsage & D3DUSAGE_WRITEONLY) == 0)
    {
        DPF(1, "Indexbuffer created with POOL_DEFAULT but WRITEONLY not set. Performance penalty could be severe.");
    }

    HRESULT hr = CIndexBuffer::Create(this,
                                      cbLength,
                                      dwUsage,
                                      Format,
                                      Pool,
                                      REF_EXTERNAL,
                                      ppIndexBuffer);
    if (FAILED(hr))
    {
        DPF_ERR("Failure trying to create indexbuffer");
        return hr;
    }
    return hr;
} // CBaseDevice::CreateIndexBuffer


#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::UpdateRenderTarget"

void CBaseDevice::UpdateRenderTarget(CBaseSurface *pRenderTarget,
                                     CBaseSurface *pZStencil)
{
    // We only change things if the old and new are different;
    // this is to allow the device to update itself to the
    // same object without needing an extra-ref-count

    // Has the RenderTarget changed?
    if (pRenderTarget != m_pRenderTarget)
    {
        // Release old RT
        if (m_pRenderTarget)
            m_pRenderTarget->DecrementUseCount();

        m_pRenderTarget = pRenderTarget;

        if (m_pRenderTarget)
        {
            // IncrementUseCount the new RT
            m_pRenderTarget->IncrementUseCount();

            // Update the batch count for the new rendertarget
            m_pRenderTarget->Batch();
        }
    }


    // Has the Z changed?
    if (m_pZBuffer != pZStencil)
    {
        // Release the old Z
        if (m_pZBuffer)
            m_pZBuffer->DecrementUseCount();

        m_pZBuffer = pZStencil;

        // IncrementUseCount the new Z
        if (m_pZBuffer)
        {
            m_pZBuffer->IncrementUseCount();

            // Update the batch count for the new zbuffer
            m_pZBuffer->Batch();
        }
    }

    return;
} // UpdateRenderTarget

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::CBaseDevice"

CBaseDevice::CBaseDevice()
{
    // Give our base class a pointer to ourselves
    SetOwner(this);

    m_hwndFocusWindow           = 0;
    m_cRef                      = 1;

    m_pResourceList             = 0;
    m_pResourceManager          = new CResourceManager();
    m_dwBehaviorFlags           = 0;
    m_dwOriginalBehaviorFlags   = 0;

    m_fullscreen                = FALSE;
    m_bVBFailOversDisabled      = FALSE;

    m_pZBuffer                  = NULL;
    m_pSwapChain                = NULL;
    m_pRenderTarget             = NULL;
    m_pAutoZStencil             = NULL;
    m_ddiType                   = D3DDDITYPE_NULL;

} // CBaseDevice

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::~CBaseDevice"

CBaseDevice::~CBaseDevice()
{
    DWORD cUseCount;

    // Release our objects
    if (m_pAutoZStencil)
    {
        cUseCount = m_pAutoZStencil->DecrementUseCount();
        DXGASSERT(cUseCount == 0 || m_pAutoZStencil == m_pZBuffer);
    }

    // Mark Z buffer as no longer in use
    if (m_pZBuffer)
    {
        cUseCount = m_pZBuffer->DecrementUseCount();
        DXGASSERT(cUseCount == 0);
        m_pZBuffer = NULL;
    }

    // Mark render target as no longer in use
    if (m_pRenderTarget)
    {
        cUseCount = m_pRenderTarget->DecrementUseCount();
        m_pRenderTarget = NULL; //so that FlipToGDISurface won't have to reset it
    }

    if (m_pSwapChain)
    {
        if  (m_fullscreen)
            m_pSwapChain->FlipToGDISurface();
        cUseCount = m_pSwapChain->DecrementUseCount();
        DXGASSERT(cUseCount == 0);
    }

    DD_DoneDC(m_DeviceData.hDC);

    //  Free allocations we made when the device was created

    if (m_DeviceData.DriverData.pGDD8SupportedFormatOps != NULL)
    {
        MemFree(m_DeviceData.DriverData.pGDD8SupportedFormatOps);
    }

    // If a software driver is loaded, unload it now

    if (m_DeviceData.hLibrary != NULL)
    {
        FreeLibrary(m_DeviceData.hLibrary);
    }

    // Shut down the thunk layer

    D3D8DeleteDirectDrawObject(m_DeviceData.hDD);

    delete m_pResourceManager;


    // We release the Enum last because various destructors expect to
    // be around i.e. the swapchain stuff. Also, because it is a
    // stand-alone object; it should not have any dependencies on the
    // the device.
    if (NULL != Enum())
    {
        Enum()->Release();
    }

} // ~CBaseDevice

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::Init"

HRESULT CBaseDevice::Init(
    PD3D8_DEVICEDATA       pDevice,
    D3DDEVTYPE             DeviceType,
    HWND                   hwndFocusWindow,
    DWORD                  dwBehaviorFlags,
    D3DPRESENT_PARAMETERS *pPresentationParams,
    UINT                   AdapterIndex,
    CEnum                 *ParentClass)
{
    HRESULT hr;
    DWORD value = 0;

    m_DeviceData        = *pDevice;
    m_hwndFocusWindow   =  hwndFocusWindow;
    m_DeviceType        =  DeviceType;
    m_AdapterIndex      =  AdapterIndex;
    m_pD3DClass         =  ParentClass;
    GetD3DRegValue(REG_DWORD, "DisableDM", &value, sizeof(DWORD));
#ifdef WINNT
    m_dwBehaviorFlags   =  dwBehaviorFlags | (!IsWhistler() || value != 0 ? D3DCREATE_DISABLE_DRIVER_MANAGEMENT : 0);
#else
    m_dwBehaviorFlags   =  dwBehaviorFlags | (value != 0 ? D3DCREATE_DISABLE_DRIVER_MANAGEMENT : 0);
#endif
    value = 0;
    GetD3DRegValue(REG_DWORD, "DisableST", &value, sizeof(DWORD));
    m_dwOriginalBehaviorFlags = m_dwBehaviorFlags;
    if (value != 0)
    {
        m_dwBehaviorFlags |= D3DCREATE_MULTITHREADED;
    }
    
    MemFree(pDevice);   // Now that we've stored the contents, we can free the old memory

    ParentClass->AddRef();
#ifndef  WINNT
    if (FocusWindow())
    {
        hr = D3D8SetCooperativeLevel(GetHandle(), FocusWindow(), DDSCL_SETFOCUSWINDOW);
        if (FAILED(hr))
        {
            return hr;
        }
    }
#endif  //!WINNT

    //Figure out if we're a screen-saver or not.
    char	        name[_MAX_PATH];
    HMODULE hfile =  GetModuleHandle( NULL );

    name[0]=0;
    GetModuleFileName( hfile, name, sizeof( name ) -1 );
    int len = strlen(name);
    if( ( strlen(name) > 4 ) && 
        name[len - 4 ] == '.' &&
        (name[ len - 3 ] == 's' || name[ len - 3 ] == 'S' )&&
        (name[ len - 2 ] == 'c' || name[ len - 2 ] == 'C' )&&
        (name[ len - 1 ] == 'r' || name[ len - 1 ] == 'R' ))
    {
        m_dwBehaviorFlags |= 0x10000000;
    }

    // Initialize our critical section (if needed)
    if (m_dwBehaviorFlags & D3DCREATE_MULTITHREADED)
    {
        EnableCriticalSection();
    }


    // Initialize the resource manager
    hr = ResourceManager()->Init(this);
    if (hr != S_OK)
    {
        return hr;
    }

    m_DesktopMode.Height = DisplayHeight();
    m_DesktopMode.Width = DisplayWidth();
    m_DesktopMode.Format = DisplayFormat();
    m_DesktopMode.RefreshRate = DisplayRate();
    // Now call Reset to do any mode changes required and to create
    // the primary surface, etc.

    m_pSwapChain = new CSwapChain(
            this,
            REF_INTRINSIC);

    if (m_pSwapChain)
    {
        m_pSwapChain->Init(
            pPresentationParams,
            &hr);

        if (FAILED(hr))
            return hr;
    }
    else
    {
        hr = E_OUTOFMEMORY;
        return hr;
    }

    // If we were created with a specification for a default
    // z buffer; then we need to create one here.
    if (pPresentationParams->EnableAutoDepthStencil)
    {
        // Need to validate that this Z-buffer matches
        // the HW
        hr = CheckDepthStencilMatch(pPresentationParams->BackBufferFormat,
                                    pPresentationParams->AutoDepthStencilFormat);
        if (FAILED(hr))
        {
            DPF_ERR("AutoDepthStencilFormat does not match BackBufferFormat because "
                    "the current Device requires the bitdepth of the zbuffer to "
                    "match the render-target. See CheckDepthStencilMatch documentation. CreateDevice fails.");
            return hr;
        }


        IDirect3DSurface8 *pSurf;
        hr = CSurface::CreateZStencil(
            this,
            m_pSwapChain->Width(),
            m_pSwapChain->Height(),
            pPresentationParams->AutoDepthStencilFormat,
            pPresentationParams->MultiSampleType,
            REF_INTRINSIC,
            &pSurf);
        if (FAILED(hr))
        {
            DPF_ERR("Failure trying to create automatic zstencil surface. CreateDevice Failed.");
            return hr;
        }

        m_pAutoZStencil      = static_cast<CBaseSurface *>(pSurf);
    }

    UpdateRenderTarget(m_pSwapChain->m_ppBackBuffers[0], m_pAutoZStencil);
    m_fullscreen = !SwapChain()->m_PresentationData.Windowed;

    HKEY hKey;
    if(ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey))
    {
        DWORD dwType;
        DWORD dwValue;
        DWORD dwSize = 4;
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, "DisableVBFailovers", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) &&
            dwType == REG_DWORD &&
            dwValue != 0)
        {
            m_bVBFailOversDisabled = TRUE;
        }
        RegCloseKey(hKey);
    }

    return hr;
} // Init

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::GetDeviceCaps"

STDMETHODIMP CBaseDevice::GetDeviceCaps(D3DCAPS8 *pCaps)
{
    API_ENTER(this);

    if (pCaps == NULL)
    {
        DPF_ERR("Invalid pointer to D3DCAPS8 specified. GetDeviceCaps fails");
        return D3DERR_INVALIDCALL;
    }

    Enum()->FillInCaps (
                pCaps,
                GetCoreCaps(),
                m_DeviceType,
                m_AdapterIndex);

    // Emulation of NPatches is done in software when they are not supported
    // for non-Pure devices.
    if ((pCaps->DevCaps & D3DDEVCAPS_RTPATCHES) && (BehaviorFlags() & D3DCREATE_PUREDEVICE) == 0)
        pCaps->DevCaps |= D3DDEVCAPS_NPATCHES;

    // Now the Caps struct has all the hardware caps.
    // In case the device is running in a software vertex-processing mode
    // fix up the caps to reflect that.
    if( ((BehaviorFlags() & D3DCREATE_PUREDEVICE) == 0)
        &&
        (static_cast<CD3DHal *>(this))->m_dwRuntimeFlags &
        D3DRT_RSSOFTWAREPROCESSING )
    {
        // We always do TL Vertex clipping for software vertex processing.
        pCaps->PrimitiveMiscCaps |= D3DPMISCCAPS_CLIPTLVERTS;
        
        pCaps->RasterCaps |= (D3DPRASTERCAPS_FOGVERTEX |
                              D3DPRASTERCAPS_FOGRANGE);

        // We do emulation when FVF has point size but the device does not
        // support it
        pCaps->FVFCaps |= D3DFVFCAPS_PSIZE;

        // All DX8 drivers have to support this cap.
        // Emulation is provided by the software vertex pipeline for all
        // pre-DX8 drivers.
        if( pCaps->MaxPointSize == 0 )
        {
            pCaps->MaxPointSize = 64; // __MAX_POINT_SIZE in d3ditype.h
        }

        pCaps->MaxActiveLights = 0xffffffff;
        pCaps->MaxVertexBlendMatrices = 4;
        pCaps->MaxUserClipPlanes = 6; // __MAXUSERCLIPPLANES in d3dfe.hpp
        pCaps->VertexProcessingCaps = (D3DVTXPCAPS_TEXGEN             |
                                       D3DVTXPCAPS_MATERIALSOURCE7    |
                                       D3DVTXPCAPS_DIRECTIONALLIGHTS  |
                                       D3DVTXPCAPS_POSITIONALLIGHTS   |
                                       D3DVTXPCAPS_LOCALVIEWER        |
                                       D3DVTXPCAPS_TWEENING);

        pCaps->MaxVertexBlendMatrixIndex = 255; // __MAXWORLDMATRICES - 1 in
                                                //  d3dfe.hpp
        pCaps->MaxStreams = 16; // __NUMSTREAMS in d3dfe.hpp
        pCaps->VertexShaderVersion = D3DVS_VERSION(1, 1); // Version 1.1
        pCaps->MaxVertexShaderConst = D3DVS_CONSTREG_MAX_V1_1;

        // Nuke NPATCHES and RT Patches caps, because software emulation 
        // cannot do that.
        pCaps->DevCaps &= ~(D3DDEVCAPS_NPATCHES | D3DDEVCAPS_RTPATCHES);
    }

    // MaxPointSize should never be reported as Zero. Internally though
    // we depend on Zero to be what decides to take the point-sprite emulation
    // path or not. 
    // If it is still zero at this point, fudge it up here.
    if( pCaps->MaxPointSize == 0 )
    {
        pCaps->MaxPointSize = 1.0f; 
    }

    return D3D_OK;

} // GetDeviceCaps

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseDevice::GetDeviceCaps"

STDMETHODIMP CBaseDevice::GetFrontBuffer(IDirect3DSurface8 *pDSurface)
{
    API_ENTER(this);

    RECT            Rect;
    D3DSURFACE_DESC SurfDesc;
    CDriverSurface* pPrimary;
    D3DLOCKED_RECT  PrimaryRect;
    D3DLOCKED_RECT  DestRect;
    HRESULT         hr;
    D3DFORMAT       Format;
    UINT            Width;
    UINT            Height;
    BYTE*           pSrc;
    BYTE*           pDest;
    DWORD*          pDstTemp;
    BYTE*           pSrc8;
    WORD*           pSrc16;
    DWORD*          pSrc32;
    UINT            i;
    UINT            j;
    PALETTEENTRY    Palette[256];

    if (pDSurface == NULL)
    {
        DPF_ERR("Invalid pointer to destination surface specified. GetFrontBuffer fails.");
        return D3DERR_INVALIDCALL;
    }
    CBaseSurface *pDestSurface = static_cast<CBaseSurface*>(pDSurface);
    if (pDestSurface->InternalGetDevice() != this)
    {
        DPF_ERR("Destination Surface was not allocated with this Device. GetFrontBuffer fails. ");
        return D3DERR_INVALIDCALL;
    }

    hr = pDestSurface->GetDesc(&SurfDesc);
    DXGASSERT(SUCCEEDED(hr));

    if (SurfDesc.Format != D3DFMT_A8R8G8B8)
    {
        DPF_ERR("Destination surface must have format D3DFMT_A8R8G8B8. GetFrontBuffer fails.");
        return D3DERR_INVALIDCALL;
    }
    if (SurfDesc.Type != D3DRTYPE_SURFACE)
    {
        DPF_ERR("Destination surface is an invalid type. GetFrontBuffer fails.");
        return D3DERR_INVALIDCALL;
    }
    if ( (SurfDesc.Pool != D3DPOOL_SYSTEMMEM) && (SurfDesc.Pool != D3DPOOL_SCRATCH))
    {
        DPF_ERR("Destination surface must be in system or scratch memory. GetFrontBuffer fails.");
        return D3DERR_INVALIDCALL;
    }

    Rect.left = Rect.top = 0;
    Rect.right = DisplayWidth();
    Rect.bottom = DisplayHeight();

    if ((SurfDesc.Width < (UINT)(Rect.right - Rect.left)) ||
        (SurfDesc.Height < (UINT)(Rect.bottom - Rect.top)))
    {
        DPF_ERR("Destination surface not big enough to hold the size of the screen. GetFrontBuffer fails.");
        return D3DERR_INVALIDCALL;
    }

    if (NULL == m_pSwapChain)
    {
        DPF_ERR("No Swap Chain present, GetFrontBuffer fails.");
        return D3DERR_INVALIDCALL;
    }

    // Lock the primary surface

    pPrimary = m_pSwapChain->PrimarySurface();
    if (NULL == pPrimary)
    {
        DPF_ERR("No Primary present, GetFrontBuffer fails");
        return D3DERR_DEVICELOST;
    }

    hr = pPrimary->LockRect(&PrimaryRect,
                            NULL,
                            0);
    if (SUCCEEDED(hr))
    {
        hr = pDestSurface->LockRect(&DestRect,
                                    NULL,
                                    0);

        if (FAILED(hr))
        {
            DPF_ERR("Unable to lock destination surface. GetFrontBuffer fails.");
            pPrimary->UnlockRect();
            return hr;
        }

        Format = DisplayFormat();

        Width = Rect.right;
        Height = Rect.bottom;

        pSrc = (BYTE*) PrimaryRect.pBits;
        pDest = (BYTE*) DestRect.pBits;

        if (Format == D3DFMT_P8)
        {
            HDC hdc;

            hdc = GetDC (NULL);
            GetSystemPaletteEntries(hdc, 0, 256, Palette);
            ReleaseDC (NULL, hdc);
        }

        for (i = 0; i < Height; i++)
        {
            pDstTemp = (DWORD*) pDest;
            switch (Format)
            {
            case D3DFMT_P8:
                pSrc8 = pSrc;
                for (j = 0; j < Width; j++)
                {
                    *pDstTemp = (Palette[*pSrc8].peRed << 16) |
                                (Palette[*pSrc8].peGreen << 8) |
                                (Palette[*pSrc8].peBlue);
                    pSrc8++;
                    pDstTemp++;
                }
                break;

            case D3DFMT_R5G6B5:
                pSrc16 = (WORD*) pSrc;
                for (j = 0; j < Width; j++)
                {
                    DWORD dwTemp = ((*pSrc16 & 0xf800) << 8) |
                                   ((*pSrc16 & 0x07e0) << 5) |
                                   ((*pSrc16 & 0x001f) << 3);

                    // Need to tweak ranges so that
                    // we map entirely to the 0x00 to 0xff
                    // for each channel. Basically, we
                    // map the high two/three bits of each
                    // channel to fill the gap at the bottom.
                    dwTemp |= (dwTemp & 0x00e000e0) >> 5;
                    dwTemp |= (dwTemp & 0x0000c000) >> 6;

                    // Write out our value
                    *pDstTemp = dwTemp;

                    pDstTemp++;
                    pSrc16++;
                }
                break;

            case D3DFMT_X1R5G5B5:
                pSrc16 = (WORD*) pSrc;
                for (j = 0; j < Width; j++)
                {
                    DWORD dwTemp= ((*pSrc16 & 0x7c00) << 9) |
                                  ((*pSrc16 & 0x03e0) << 6) |
                                  ((*pSrc16 & 0x001f) << 3);

                    // Need to tweak ranges so that
                    // we map entirely to the 0x00 to 0xff
                    // for each channel. Basically, we
                    // map the high three bits of each
                    // channel to fill the gap at the bottom.
                    dwTemp |= (dwTemp & 0x00e0e0e0) >> 5;

                    // Write out our value
                    *pDstTemp = dwTemp;

                    pDstTemp++;
                    pSrc16++;
                }
                break;

            case D3DFMT_R8G8B8:
                pSrc8 = pSrc;
                for (j = 0; j < Width; j++)
                {
                    *pDstTemp = (pSrc8[0] << 16) |
                                (pSrc8[1] << 8) |
                                (pSrc8[2]);
                    pDstTemp++;
                    pSrc8 += 3;
                }
                break;

            case D3DFMT_X8R8G8B8:
                pSrc32 = (DWORD*) pSrc;
                for (j = 0; j < Width; j++)
                {
                    *pDstTemp = *pSrc32 & 0xffffff;
                    pDstTemp++;
                    pSrc32++;
                }
                break;

            default:
                DXGASSERT(0);
                pDestSurface->UnlockRect();
                pPrimary->UnlockRect();
                return D3DERR_INVALIDCALL;
            }
            pSrc += PrimaryRect.Pitch;
            pDest += DestRect.Pitch;
        }

        pDestSurface->UnlockRect();
        pPrimary->UnlockRect();
    }

    return hr;
}

// End of file : dxgcreate.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\fcache.hpp ===
#ifndef __FCACHE_HPP__
#define __FCACHE_HPP__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fcache.hpp
 *  Content:    File cache for device caps.
 *
 ***************************************************************************/


void ReadFromCache(D3DADAPTER_IDENTIFIER8* pDI, UINT* pCapsSize, BYTE** ppCaps);
void WriteToCache(D3DADAPTER_IDENTIFIER8* pDI, UINT CapsSize, BYTE* pCaps);
void RemoveFromCache(D3DADAPTER_IDENTIFIER8* pDI);


#endif // __FCACHE_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\getri.c ===
//========================================================================
//
// GetRegistryInfo.CPP
//
// DirectDraw/Direct3D driver information grabber
// (c) Copyright 1998 Microsoft Corp.
// Written by Michael Lyons (mlyons@microsoft.com)
//
// Registry access functions, for querying device stuff from the
// registry
//
// Function names that begin with an underscore are internal only!
//
//========================================================================


#include "ddrawpr.h"

//#include "GetDriverInfo.h"
//#include "GetDriverInfoInt.h"

//========================================================================
// local functions
//========================================================================
BOOL _FindDevice(int    iDevice, LPCSTR szDeviceClass, LPCSTR szDeviceClassNot, LPSTR szHardwareKey, BOOL bIgnoreProblems);
static BOOL _GetDeviceValue(LPCSTR szHardwareKey, LPCSTR szKey,	LPCSTR szValue,	BYTE* buf, DWORD cbbuf);
extern char *_strstr(char *s1, char *s2);

//========================================================================
//
// GetDeviceValue
//
// read	a value	from the HW	or SW of a PnP device
//
// in:
//	szHardwareKey	the hardware key
//	szKey			the sub-key
//	szValue			the value to query
//	cbbuf			the size of the output buffer
//
// out:
//	buf				the destination buffer
//	
// returns:
//	success status
//
//========================================================================
static BOOL _GetDeviceValue(LPCSTR szHardwareKey, LPCSTR szKey,	LPCSTR szValue,	BYTE* buf, DWORD cbbuf)
{
	HKEY	hkeyHW;
	HKEY	hkeySW;
	BOOL	f =	FALSE;
	DWORD	cb;
	char	szSoftwareKey[MAX_DDDEVICEID_STRING];

	//
	// open	the	HW key
	//
	if (RegOpenKey(HKEY_LOCAL_MACHINE, szHardwareKey, &hkeyHW) == ERROR_SUCCESS)
	{
		//
		// try to read the value from the HW key
		//
		*buf = 0;
		cb = cbbuf;
		if (RegQueryValueEx(hkeyHW,	szValue, NULL, NULL, buf, &cb) == ERROR_SUCCESS)
		{
			f =	TRUE;
		}
		else
		{
			//
			// now try the SW key
			//
			static char	szSW[] = "System\\CurrentControlSet\\Services\\Class\\";

			lstrcpy(szSoftwareKey, szSW);
			cb = sizeof(szSoftwareKey) - sizeof(szSW);
			RegQueryValueEx(hkeyHW,	"Driver", NULL,	NULL, (BYTE	*)&szSoftwareKey[sizeof(szSW) -	1],	&cb);

			if (szKey)
			{
				lstrcat(szSoftwareKey, "\\");
				lstrcat(szSoftwareKey, szKey);
			}

			if (RegOpenKey(HKEY_LOCAL_MACHINE, szSoftwareKey, &hkeySW) == ERROR_SUCCESS)
			{
				*buf = 0;
				cb = cbbuf;
				if (RegQueryValueEx(hkeySW,	szValue, NULL, NULL, buf, &cb) == ERROR_SUCCESS)
				{
					f =	TRUE;
				}

				RegCloseKey(hkeySW);
			}
		}

		RegCloseKey(hkeyHW);
	}

	return f;
}



//========================================================================
//
// FindDevice
//
// enum	the	started	PnP	devices	looking	for	a device of	a particular class
//
//	iDevice			what device	to return (0= first	device,	1=second et)
//	szDeviceClass	what class device (ie "Display") NULL will match all
//	szDeviceID		buffer to return the hardware ID (MAX_DDDEVICEID_STRING bytes)
//
// return TRUE if a	device was found.
//
// example:
//
//		for	(int i=0; FindDevice(i,	"Display", DeviceID); i++)
//		{
//		}
//
//========================================================================
BOOL _FindDevice(int iDevice, LPCSTR szDeviceClass, LPCSTR szDeviceClassNot, LPSTR szHardwareKey, BOOL bIgnoreProblems)
{
	HKEY	hkeyPnP;
	HKEY	hkey;
	DWORD	n;
	DWORD	cb;
	DWORD	dw;
	char	ach[MAX_DDDEVICEID_STRING];

	if (RegOpenKey(HKEY_DYN_DATA, "Config Manager\\Enum", &hkeyPnP)	!= ERROR_SUCCESS)
		return FALSE;

	for	(n=0; RegEnumKey(hkeyPnP, n, ach, sizeof(ach)) == 0; n++)
	{
		static char	szHW[] = "Enum\\";

		if (RegOpenKey(hkeyPnP,	ach, &hkey)	!= ERROR_SUCCESS)
			continue;

		lstrcpy(szHardwareKey, szHW);
		cb = MAX_DDDEVICEID_STRING -	sizeof(szHW);
		RegQueryValueEx(hkey, "HardwareKey", NULL, NULL, (BYTE*)szHardwareKey +	sizeof(szHW) - 1, &cb);

		dw = 0;
		cb = sizeof(dw);
		RegQueryValueEx(hkey, "Problem", NULL, NULL, (BYTE*)&dw, &cb);
		RegCloseKey(hkey);

		if ((!bIgnoreProblems) && (dw != 0))		// if this device has a	problem	skip it
			continue;

		if (szDeviceClass || szDeviceClassNot)
		{
			_GetDeviceValue(szHardwareKey, NULL,	"Class", (BYTE *)ach, sizeof(ach));

			if (szDeviceClass && lstrcmpi(szDeviceClass, ach) != 0)
				continue;

			if (szDeviceClassNot && lstrcmpi(szDeviceClassNot, ach) == 0)
				continue;
		}

		//
		// we found	a device, make sure	it is the one the caller wants
		//
		if (iDevice-- == 0)
		{
			RegCloseKey(hkeyPnP);
			return TRUE;
		}
	}

	RegCloseKey(hkeyPnP);
	return FALSE;
}


//========================================================================
//
// _GetDriverInfoFromRegistry
//
// This function goes through the registry and tries to fill in
// information about a driver given a class and maybe a vendor ID
//
// in:
//	szClass		the class name (i.e., "Display")
//	szVendor	the vendor name (i.e., "VEN_121A" for 3Dfx" or NULL
//				if any vendor of the class will do
//
// out:
//	pDI			pointer to a DDDRIVERINFOEX structure to be filled in
//
// returns:
//	success status
//
//========================================================================
HRESULT _GetDriverInfoFromRegistry(char *szClass, 
                                   char *szClassNot, 
                                   char *szVendor, 
                                   D3DADAPTER_IDENTIFIER8* pDI,
                                   char *szDeviceID)
{
	char szDevice[MAX_DDDEVICEID_STRING];
        int i;

        szDeviceID[0]=0;
	pDI->Description[0]=0;


    for (i=0 ; ; i++)
    {
        if (!_FindDevice(i, szClass, szClassNot, szDevice, FALSE))
            break;

        if ((szVendor == NULL) || (_strstr(szDevice, szVendor)))
        {
            //
            // skip the first 5 characters "Enum\"
            //
            strcpy(szDeviceID, &szDevice[5]);
            _GetDeviceValue((LPCSTR)szDevice, NULL, "DeviceDesc", (BYTE *)pDI->Description, sizeof(pDI->Description));
            //_GetDeviceValue((LPCSTR)szDevice, NULL,		"Mfg",			(BYTE *)pDI->szManufacturer, sizeof(pDI->szManufacturer));
            //_GetDeviceValue((LPCSTR)szDevice, "DEFAULT","drv",			(BYTE *)pDI->szGDIDriver, sizeof(pDI->szGDIDriver));

            return S_OK;
        }
    }

    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\enum.hpp ===
#ifndef __ENUM_HPP__
#define __ENUM_HPP__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       enum.hpp
 *  Content:    Class for the enumerator object.
 *
 ***************************************************************************/

// HACK: this belongs elsewhere
#define DXGASSERT(x) DDASSERT(x)

#define HALFLAG_8BITHAL             0x00000001
#define HALFLAG_16BITHAL            0x00000004
#define HALFLAG_24BITHAL            0x00000010
#define HALFLAG_32BITHAL            0x00000040
class CBaseDevice;

// Base class for objects that own their own critical section
class CLockOwner
{
public:
    CLockOwner() :         
        m_bTakeCriticalSection(FALSE),
        m_punkSelf(NULL)
    {
        m_dwOwnerThread = ::GetCurrentThreadId();

#ifdef DEBUG
        // Prepare IsValid debug helper
        for (int i = 0; i < 8; i++)
        {
            // Set some magic numbers to check
            // object validity in debug
            m_dwDebugArray[i] = D3D8MagicNumber + i;
        }
        DXGASSERT(IsValid());
#endif // DEBUG 
    } // CLockOwner

    ~CLockOwner()
    {
        DXGASSERT(IsValid());
        DXGASSERT(m_bTakeCriticalSection == TRUE || 
                  m_bTakeCriticalSection == FALSE);
        if (m_bTakeCriticalSection)
        {
            ::DeleteCriticalSection(&m_CriticalSection);
        }
    } // ~CLockOwner

    void EnableCriticalSection()
    {
        DXGASSERT(m_bTakeCriticalSection == FALSE);
        m_bTakeCriticalSection = TRUE;
        ::InitializeCriticalSection(&m_CriticalSection);
    } // EnableCriticalSection()

#ifdef DEBUG
    BOOL IsValid() const
    {
        for (int i = 0; i < 8; i++)
        {
            if ((INT)m_dwDebugArray[i] != D3D8MagicNumber + i)
                return FALSE;
        }

        // If we are not locking then warn if we are 
        // not being called on the same thread
        if (!m_bTakeCriticalSection)
        {
            if (!CheckThread())
            {
                D3D_WARN(0, "Device that was created without D3DCREATE_MULTITHREADED "
                            "is being used by a thread other than the creation thread.");
            }
        }

        return TRUE;
    } // IsValid

#endif // DEBUG
    BOOL CheckThread() const
    {
        if (::GetCurrentThreadId() == m_dwOwnerThread)
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    } // CheckThread


    // Critical Section Locking
    void Lock() 
    {
        if (m_bTakeCriticalSection)
        {
            DXGASSERT(m_bTakeCriticalSection == TRUE);
            ::EnterCriticalSection(&m_CriticalSection);
        }
        else
        {
            DXGASSERT(m_bTakeCriticalSection == FALSE);
        }
        DXGASSERT(IsValid());
    }; // Lock

    void Unlock() 
    {
        DXGASSERT(IsValid());
        if (m_bTakeCriticalSection)
        {
            DXGASSERT(m_bTakeCriticalSection == TRUE);
            ::LeaveCriticalSection(&m_CriticalSection);
        }
        else
        {
            DXGASSERT(m_bTakeCriticalSection == FALSE);
        }
    }; // Unlock

    // Methods to help the API_ENTER_SUBOBJECT_RELEASE case
    ULONG AddRefOwner() 
    { 
        DXGASSERT(m_punkSelf);
        return m_punkSelf->AddRef(); 
    } // AddRefOwner
    ULONG ReleaseOwner()
    { 
        DXGASSERT(m_punkSelf);
        return m_punkSelf->Release(); 
    } // ReleaseOwner

    void SetOwner(IUnknown *punkSelf)
    {
        DXGASSERT(punkSelf);
        m_punkSelf = punkSelf;
    } // SetOwner

private:
    CRITICAL_SECTION m_CriticalSection;
    BOOL             m_bTakeCriticalSection;
    DWORD            m_dwOwnerThread;
    IUnknown        *m_punkSelf;

#ifdef DEBUG
    // Set some magic numbers to check 
    // object validity in debug
    enum
    {
        D3D8MagicNumber  = 0xD3D8D3D8
    };
    DWORD            m_dwDebugArray[8];
#endif

}; // class CLockOwner


// Device Caps/Modes Enumeration Object
class CEnum : public CLockOwner, public IDirect3D8
{
public:
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    STDMETHODIMP RegisterSoftwareDevice(void * pInitFunction);
    STDMETHODIMP_(UINT) GetAdapterCount();
    STDMETHODIMP GetAdapterIdentifier(UINT Adapter,DWORD Flags,D3DADAPTER_IDENTIFIER8 *pIdentifier);
    STDMETHODIMP_(UINT) GetAdapterModeCount(UINT Adapter);
    STDMETHODIMP EnumAdapterModes(UINT iAdapter,UINT iMode,D3DDISPLAYMODE *pMode);
    STDMETHODIMP CheckDeviceType(UINT Adapter,D3DDEVTYPE CheckType, D3DFORMAT AdapterFormat, D3DFORMAT BackBufferFormat, BOOL Windowed);
    STDMETHODIMP CheckDeviceFormat(UINT Adapter,D3DDEVTYPE DeviceType,D3DFORMAT DisplayFormat,DWORD Usage,D3DRESOURCETYPE RType, D3DFORMAT CheckFormat); 
    STDMETHODIMP GetAdapterDisplayMode(UINT Adapter, D3DDISPLAYMODE* pMode);
    STDMETHODIMP CheckDeviceMultiSampleType(UINT Adapter,D3DDEVTYPE DeviceType,D3DFORMAT RenderTargetFormat,BOOL Windowed,D3DMULTISAMPLE_TYPE MultiSampleType);
    STDMETHODIMP CheckDepthStencilMatch(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, D3DFORMAT RenderTargetFormat, D3DFORMAT DepthStencilFormat);
    STDMETHODIMP GetDeviceCaps(UINT iAdapter, D3DDEVTYPE DeviceType, D3DCAPS8 *pCaps);
    STDMETHODIMP_(HMONITOR) GetAdapterMonitor(UINT iAdapter);

    STDMETHOD(CreateDevice)(
        UINT                    iAdapter,
        D3DDEVTYPE              DeviceType,
        HWND                    hwndFocusWindow,
        DWORD                   dwBehaviorFlags,
        D3DPRESENT_PARAMETERS  *pPresentationParams,
        IDirect3DDevice8      **ppDevice);

    // Public constructor for Direct3DCreate8 to call
    CEnum(UINT AppSdkVersion);

    D3DDISPLAYMODE* GetModeTable(UINT iAdapter) const
    {
        return m_AdapterInfo[iAdapter].pModeTable;
    }

    const DWORD GetNumModes(UINT iAdapter) const
    {
        return m_AdapterInfo[iAdapter].NumModes;
    }

    const BOOL NoDDrawSupport(UINT iAdapter) const
    {
        return m_AdapterInfo[iAdapter].bNoDDrawSupport;
    }
    void FillInCaps(D3DCAPS8              *pCaps, 
                    const D3D8_DRIVERCAPS *pDriverCaps,
                    D3DDEVTYPE             Type, 
                    UINT                   AdapterOrdinal) const;

    D3DFORMAT MapDepthStencilFormat(UINT        iAdapter,
                                    D3DDEVTYPE  Type, 
                                    D3DFORMAT   Format) const;

    D3DFORMAT GetUnknown16(UINT             iAdapter)
    {
        return m_AdapterInfo[iAdapter].Unknown16;
    }

    DDSURFACEDESC* GetHalOpList(UINT    iAdapter)
    {
        return m_AdapterInfo[iAdapter].HALCaps.pGDD8SupportedFormatOps;
    }

    DWORD GetNumHalOps(UINT iAdapter)
    {
        return m_AdapterInfo[iAdapter].HALCaps.GDD8NumSupportedFormatOps;
    }

#ifdef WINNT
    void    SetFullScreenDevice(UINT         iAdapter, 
                                CBaseDevice *pDevice);

    HWND ExclusiveOwnerWindow();
    BOOL CheckExclusiveMode(
            CBaseDevice* pDevice,
            LPBOOL pbThisDeviceOwnsExclusive, 
            BOOL bKeepMutex);
    void DoneExclusiveMode();
    void StartExclusiveMode();
#endif // WINNT

    // Gamma calibrator is owned by the enumerator
    void LoadAndCallGammaCalibrator(
        D3DGAMMARAMP *pRamp, 
        UCHAR * pDeviceName);

    void GetRefCaps(UINT    iAdapter);
    void GetSwCaps(UINT     iAdapter);

    void * GetInitFunction() const
    {
        return m_pSwInitFunction;
    }
    UINT GetAppSdkVersion() {return m_AppSdkVersion;}

private:

    HRESULT GetAdapterCaps(UINT                 iAdapter,
                           D3DDEVTYPE           Type,
                           D3D8_DRIVERCAPS**    ppCaps);

    DWORD                   m_cRef;
    UINT                    m_cAdapter;
    ADAPTERINFO             m_AdapterInfo[MAX_DX8_ADAPTERS];
    CBaseDevice             *m_pFullScreenDevice[MAX_DX8_ADAPTERS];
    D3D8_DRIVERCAPS         m_REFCaps[MAX_DX8_ADAPTERS];
    D3D8_DRIVERCAPS         m_SwCaps[MAX_DX8_ADAPTERS];
    VOID*                   m_pSwInitFunction;
    BOOL                    m_bDisableHAL;
    BOOL                    m_bHasExclusive;
    HINSTANCE               m_hGammaCalibrator;
    LPDDGAMMACALIBRATORPROC m_pGammaCalibratorProc;
    BOOL                    m_bAttemptedGammaCalibrator;
    BOOL                    m_bGammaCalibratorExists;
    UCHAR                   m_szGammaCalibrator[MAX_PATH];
    UINT                    m_AppSdkVersion;

}; // class CEnum

#endif // __ENUM_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\ibuffer.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ibuffer.cpp
 *  Content:    Implementation of the CIndexBuffer class.
 *
 *
 ***************************************************************************/
#include "ddrawpr.h"

#include "ibuffer.hpp"
#include "d3di.hpp"
#include "ddi.h"
#include "resource.inl"

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::Create"

// Static class function for creating a Index Buffer object.
// (Because it is static; it doesn't have a this pointer.)
//
// We do all parameter checking here to reduce the overhead
// in the constructor which is called by the internal Clone
// method which is used by resource management as part of the
// performance critical download operation.

// Creation function for Index Buffers
HRESULT CIndexBuffer::Create(CBaseDevice        *pDevice,
                             DWORD               cbLength,
                             DWORD               Usage,
                             D3DFORMAT           Format,
                             D3DPOOL             Pool,
                             REF_TYPE            refType,
                             IDirect3DIndexBuffer8  **ppIndexBuffer)
{
    HRESULT hr;

    // Do parameter checking here
    if (!VALID_PTR_PTR(ppIndexBuffer))
    {
        DPF_ERR("Bad parameter passed for ppIndexBuffer for creating a Index buffer");
        return D3DERR_INVALIDCALL;
    }

    // Zero-out return parameter
    *ppIndexBuffer = NULL;

    if (Format != D3DFMT_INDEX16 &&
        Format != D3DFMT_INDEX32)
    {
        DPF_ERR("IndexBuffer must be in D3DFMT_INDEX16 or INDEX32 formats. CreateIndexBuffer fails.");
        return D3DERR_INVALIDCALL;
    }

    if ((Format == D3DFMT_INDEX16 && cbLength < 2) ||
        (Format == D3DFMT_INDEX32 && cbLength < 4))
    {
        DPF_ERR("Index buffer should be large enough to hold at least one index");
        return D3DERR_INVALIDCALL;
    }

    if (Pool != D3DPOOL_DEFAULT && Pool != D3DPOOL_MANAGED && Pool != D3DPOOL_SYSTEMMEM)
    {
        DPF_ERR("Index buffer pool should be default or managed or sysmem");
        return D3DERR_INVALIDCALL;
    }

    // Usage flag allowed for only mixed mode or software device
    if ((Usage & D3DUSAGE_SOFTWAREPROCESSING) != 0 && 
        (pDevice->BehaviorFlags() & D3DCREATE_MIXED_VERTEXPROCESSING) == 0 &&
        (pDevice->BehaviorFlags() & D3DCREATE_SOFTWARE_VERTEXPROCESSING) == 0)
    {
        DPF_ERR("D3DUSAGE_SOFTWAREPROCESSING can be set only when device is mixed mode. CreateIndexBuffer fails.");
        return D3DERR_INVALIDCALL;
    }

    // USAGE_DYNAMIC not allowed with management
    if ((Usage & D3DUSAGE_DYNAMIC) != 0 && Pool == D3DPOOL_MANAGED)
    {
        DPF_ERR("D3DUSAGE_DYNAMIC cannot be used with managed index buffers");
        return D3DERR_INVALIDCALL;
    }

    D3DPOOL ActualPool = Pool;
    DWORD ActualUsage = Usage;

    // Infer Lock from absence of LoadOnce
    if (!(Usage & D3DUSAGE_LOADONCE))
    {
        ActualUsage |= D3DUSAGE_LOCK;
    }

    // On a mixed device, POOL_SYSTEMMEM means the same as D3DUSAGE_SOFTWAREPROCESSING
    if ((pDevice->BehaviorFlags() & D3DCREATE_MIXED_VERTEXPROCESSING) != 0 &&
        Pool == D3DPOOL_SYSTEMMEM)
    {
        ActualUsage |= D3DUSAGE_SOFTWAREPROCESSING;
    }

    /*
     * Put a IB in system memory if the following conditions are TRUE
     * 1. USAGE_SOFTWAREPROCESSING is set or it is a software device and they want to clip
     * 2. HAL is pre-DX8 which means that the driver cannot support hardware IBs (but it might still create them because it doesn't know)
     * 3. Usage NPathes and driver does not support NPatches
    */
    if(!pDevice->DriverSupportsVidmemIBs() || !IS_DX8HAL_DEVICE(static_cast<LPD3DBASE>(pDevice)))
    {
        ActualPool = D3DPOOL_SYSTEMMEM;
        if(!IS_DX8HAL_DEVICE(static_cast<LPD3DBASE>(pDevice)))
        {
            ActualUsage |= D3DUSAGE_SOFTWAREPROCESSING; // fe code will read from the IB
        }
    }
    if (((ActualUsage & D3DUSAGE_SOFTWAREPROCESSING) != 0 || (pDevice->BehaviorFlags() & D3DCREATE_SOFTWARE_VERTEXPROCESSING) != 0) &&
        (ActualUsage & D3DUSAGE_DONOTCLIP) == 0)
    {
        if((ActualUsage & D3DUSAGE_INTERNALBUFFER) == 0)
        {
            if ((pDevice->BehaviorFlags() & D3DCREATE_SOFTWARE_VERTEXPROCESSING) != 0 ||
                ActualPool == D3DPOOL_DEFAULT)
            {
                ActualPool = D3DPOOL_SYSTEMMEM; // For software processing, pool can be only sysmem (POOLMANAGED is overwritten)
            }
            ActualUsage |= D3DUSAGE_SOFTWAREPROCESSING;
        }
    }
    if (ActualUsage & D3DUSAGE_NPATCHES &&
        (pDevice->GetD3DCaps()->DevCaps & D3DDEVCAPS_NPATCHES) == 0)
    {
        ActualPool = D3DPOOL_SYSTEMMEM;
        ActualUsage |= D3DUSAGE_SOFTWAREPROCESSING;
    }

    CIndexBuffer *pIndexBuffer;

    if (ActualPool == D3DPOOL_SYSTEMMEM ||
        IsTypeD3DManaged(pDevice, D3DRTYPE_INDEXBUFFER, ActualPool))
    {
        hr = CreateSysmemIndexBuffer(pDevice,
                                     cbLength,
                                     Usage,
                                     ActualUsage,
                                     Format,
                                     Pool,
                                     ActualPool,
                                     refType,
                                     &pIndexBuffer);
    }
    else
    {
        if (IsTypeDriverManaged(pDevice, D3DRTYPE_INDEXBUFFER, ActualPool))
        {
            // If the index buffer is driver managed, but the usage is softwareprocessing, then
            // we turn off writeonly since the fe pipe WILL read from the sysmem backup (which
            // actually lives in the driver). It follows that when a driver manages a VB/IB without
            // writeonly, it MUST have a sysmem backup. (snene - 12/00)
            if ((ActualUsage & D3DUSAGE_SOFTWAREPROCESSING) != 0)
            {
                ActualUsage &= ~D3DUSAGE_WRITEONLY;
            }
            hr = CreateDriverManagedIndexBuffer(pDevice,
                                                cbLength,
                                                Usage,
                                                ActualUsage,
                                                Format,
                                                Pool,
                                                ActualPool,
                                                refType,
                                                &pIndexBuffer);
            // Driver managed index buffer creates can NEVER fail, except for catastrophic reasons so
            // we don't fallback to sysmem. Even if we do fallback to sysmem here, there is no way
            // deferred creates are going to fallback, so no point.
            if (FAILED(hr))
            {
                return hr;
            }
        }
        else
        {
            hr = CreateDriverIndexBuffer(pDevice,
                                         cbLength,
                                         Usage,
                                         ActualUsage,
                                         Format,
                                         Pool,
                                         ActualPool,
                                         refType,
                                         &pIndexBuffer);
        }
        if (FAILED(hr) && hr != D3DERR_OUTOFVIDEOMEMORY)
        {
            if (pDevice->VBFailOversDisabled())
            {
                DPF_ERR("Cannot create Vidmem or Driver managed index buffer. Will ***NOT*** failover to Sysmem.");
                return hr;
            }
            ActualPool = D3DPOOL_SYSTEMMEM;
            hr = CreateSysmemIndexBuffer(pDevice,
                                         cbLength,
                                         Usage,
                                         ActualUsage,
                                         Format,
                                         Pool,
                                         ActualPool,
                                         refType,
                                         &pIndexBuffer);
        }
    }

    if (FAILED(hr))
    {
        return hr;
    }

    // We're done; just return the object
    *ppIndexBuffer = pIndexBuffer;

    return hr;
} // static Create

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::CreateDriverIndexBuffer"

HRESULT CIndexBuffer::CreateDriverIndexBuffer(CBaseDevice *pDevice,
                                              DWORD        cbLength,
                                              DWORD        Usage,
                                              DWORD        ActualUsage,
                                              D3DFORMAT    Format,
                                              D3DPOOL      Pool,
                                              D3DPOOL      ActualPool,
                                              REF_TYPE     refType,
                                              CIndexBuffer **pIB)
{
    HRESULT hr;
    CDriverIndexBuffer *pIndexBuffer;

    // Zero out return
    *pIB = 0;

    if((pDevice->BehaviorFlags() & D3DCREATE_MULTITHREADED) != 0)
    {
        pIndexBuffer = new CDriverIndexBufferMT(pDevice,
                                                cbLength,
                                                Usage,
                                                ActualUsage,
                                                Format,
                                                Pool,
                                                ActualPool,
                                                refType,
                                                &hr);
    }
    else
    {
        pIndexBuffer = new CDriverIndexBuffer(pDevice,
                                              cbLength,
                                              Usage,
                                              ActualUsage,
                                              Format,
                                              Pool,
                                              ActualPool,
                                              refType,
                                              &hr);
    }
    if (pIndexBuffer == 0)
    {
        DPF_ERR("Out of Memory creating index buffer");
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr))
    {
        if (refType == REF_EXTERNAL)
        {
            // External objects get released
            pIndexBuffer->Release();
        }
        else
        {
            // Internal and intrinsic objects get decremented
            DXGASSERT(refType == REF_INTERNAL || refType == REF_INTRINSIC);
            pIndexBuffer->DecrementUseCount();
        }
        return hr;
    }

    *pIB = static_cast<CIndexBuffer*>(pIndexBuffer);

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::CreateSysmemIndexBuffer"

HRESULT CIndexBuffer::CreateSysmemIndexBuffer(CBaseDevice *pDevice,
                                              DWORD        cbLength,
                                              DWORD        Usage,
                                              DWORD        ActualUsage,
                                              D3DFORMAT    Format,
                                              D3DPOOL      Pool,
                                              D3DPOOL      ActualPool,
                                              REF_TYPE     refType,
                                              CIndexBuffer **pIB)
{
    HRESULT hr;
    CIndexBuffer *pIndexBuffer;

    // Zero out return
    *pIB = 0;

    if((pDevice->BehaviorFlags() & D3DCREATE_MULTITHREADED) != 0)
    {
        pIndexBuffer = new CIndexBufferMT(pDevice,
                                          cbLength,
                                          Usage,
                                          ActualUsage,
                                          Format,
                                          Pool,
                                          ActualPool,
                                          refType,
                                          &hr);
    }
    else
    {
        pIndexBuffer = new CIndexBuffer(pDevice,
                                        cbLength,
                                        Usage,
                                        ActualUsage,
                                        Format,
                                        Pool,
                                        ActualPool,
                                        refType,
                                        &hr);
    }
    if (pIndexBuffer == 0)
    {
        DPF_ERR("Out of Memory creating index buffer");
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr))
    {
        if (refType == REF_EXTERNAL)
        {
            // External objects get released
            pIndexBuffer->Release();
        }
        else
        {
            // Internal and intrinsic objects get decremented
            DXGASSERT(refType == REF_INTERNAL || refType == REF_INTRINSIC);
            pIndexBuffer->DecrementUseCount();
        }
        return hr;
    }

    *pIB = pIndexBuffer;

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::CreateDriverManagedIndexBuffer"

HRESULT CIndexBuffer::CreateDriverManagedIndexBuffer(CBaseDevice *pDevice,
                                                     DWORD        cbLength,
                                                     DWORD        Usage,
                                                     DWORD        ActualUsage,
                                                     D3DFORMAT    Format,
                                                     D3DPOOL      Pool,
                                                     D3DPOOL      ActualPool,
                                                     REF_TYPE     refType,
                                                     CIndexBuffer **pIB)
{
    HRESULT hr;
    CDriverManagedIndexBuffer *pIndexBuffer;

    // Zero out return
    *pIB = 0;

    if((pDevice->BehaviorFlags() & D3DCREATE_MULTITHREADED) != 0)
    {
        pIndexBuffer = new CDriverManagedIndexBufferMT(pDevice,
                                                       cbLength,
                                                       Usage,
                                                       ActualUsage,
                                                       Format,
                                                       Pool,
                                                       ActualPool,
                                                       refType,
                                                       &hr);
    }
    else
    {
        pIndexBuffer = new CDriverManagedIndexBuffer(pDevice,
                                                     cbLength,
                                                     Usage,
                                                     ActualUsage,
                                                     Format,
                                                     Pool,
                                                     ActualPool,
                                                     refType,
                                                     &hr);
    }
    if (pIndexBuffer == 0)
    {
        DPF_ERR("Out of Memory creating index buffer");
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr))
    {
        if (refType == REF_EXTERNAL)
        {
            // External objects get released
            pIndexBuffer->Release();
        }
        else
        {
            // Internal and intrinsic objects get decremented
            DXGASSERT(refType == REF_INTERNAL || refType == REF_INTRINSIC);
            pIndexBuffer->DecrementUseCount();
        }
        return hr;
    }

    *pIB = static_cast<CIndexBuffer*>(pIndexBuffer);

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::CIndexBuffer"

// Constructor the Index Buffer class
CIndexBuffer::CIndexBuffer(CBaseDevice *pDevice,
                           DWORD        cbLength,
                           DWORD        Usage,
                           DWORD        ActualUsage,
                           D3DFORMAT    Format,
                           D3DPOOL      Pool,
                           D3DPOOL      ActualPool,
                           REF_TYPE     refType,
                           HRESULT     *phr
                           ):
    CBuffer(pDevice,
            cbLength,
            0,                      // dwFVF
            Format,
            D3DRTYPE_INDEXBUFFER,
            Usage,                  // UserUsage
            ActualUsage,
            Pool,                   // UserPool
            ActualPool,
            refType,
            phr)
{
    if (FAILED(*phr))
        return;

    m_desc.Size          = cbLength;
    m_desc.Format        = Format;
    m_desc.Pool          = ActualPool;
    m_desc.Usage         = ActualUsage;
    m_desc.Type          = D3DRTYPE_INDEXBUFFER;
    m_usageUser          = Usage;

    // If this is a D3D managed buffer then we need
    // to tell the Resource Manager to remember us. This has to happen
    // at the very end of the constructor so that the important data
    // members are built up correctly
    if (CResource::IsTypeD3DManaged(Device(), D3DRTYPE_INDEXBUFFER, ActualPool))
    {
        *phr = InitializeRMHandle();
    }
} // CIndexBuffer::CIndexBuffer

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::Clone"
HRESULT CIndexBuffer::Clone(D3DPOOL     Pool,
                            CResource **ppResource) const
{
    HRESULT hr;
    CIndexBuffer *pIndexBuffer;
    // Note: we treat clones the same as internal; because
    // they are owned by the resource manager which
    // is owned by the device.
    hr = CreateDriverIndexBuffer(Device(),
                                 m_desc.Size,
                                 m_desc.Usage,
                                 (m_desc.Usage | D3DUSAGE_WRITEONLY) & ~D3DUSAGE_SOFTWAREPROCESSING, // never seen by API!
                                 m_desc.Format,                                 
                                 Pool,
                                 Pool, // never seen by API!
                                 REF_INTERNAL,
                                 &pIndexBuffer);
    *ppResource = static_cast<CResource*>(pIndexBuffer);
    return hr;
} // CIndexBuffer::Clone

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::UpdateDirtyPortion"

HRESULT CIndexBuffer::UpdateDirtyPortion(CResource *pResourceTarget)
{
    if (IsDirty())
    {
        if (Device()->CanBufBlt())
        {
            D3DRANGE range;
            if(m_cbDirtyMin == 0 && m_cbDirtyMax == 0)
            {
                range.Offset = 0;
                range.Size = m_desc.Size;
            }
            else
            {
                range.Offset = m_cbDirtyMin;
                range.Size = m_cbDirtyMax - m_cbDirtyMin;
            }
            HRESULT hr = static_cast<LPD3DBASE>(Device())->BufBlt(static_cast<CBuffer*>(pResourceTarget), this, m_cbDirtyMin, &range);
            if (FAILED(hr))
            {
                DPF_ERR("Failed to copy index buffer");
                return hr;
            }
        }
        else
        {
            DXGASSERT(pResourceTarget->GetBufferDesc()->Pool == D3DPOOL_DEFAULT); // make sure that it is safe to assume that this is a driver VB
            CDriverIndexBuffer *pBufferTarget = static_cast<CDriverIndexBuffer *>(pResourceTarget);

            // Lock the dest (driver) index buffer. It can never be dynamic, so it does
            // not need any unlocking.
            DXGASSERT((pBufferTarget->m_desc.Usage & D3DUSAGE_DYNAMIC) == 0);

            HRESULT hr = pBufferTarget->LockI(D3DLOCK_NOSYSLOCK);
            if (FAILED(hr))
            {
                DPF_ERR("Failed to lock driver index buffer");
                return hr;
            }
            DXGASSERT(pBufferTarget->m_pbData != 0);

            if(m_cbDirtyMin == 0 && m_cbDirtyMax == 0)
            {
                memcpy(pBufferTarget->m_pbData, GetPrivateDataPointer(), m_desc.Size);
            }
            else
            {
                memcpy(pBufferTarget->m_pbData + m_cbDirtyMin, GetPrivateDataPointer() + m_cbDirtyMin, m_cbDirtyMax - m_cbDirtyMin);
            }

            hr = pBufferTarget->UnlockI();
            if (FAILED(hr))
            {
                DPF_ERR("Failed to unlock driver index buffer");
                return hr;
            }
        }

        // Mark ourselves as all clean now.
        OnResourceClean();
    }

    return S_OK;
} // CIndexBuffer::UpdateDirtyPortion

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::GetBufferDesc"
const D3DBUFFER_DESC* CIndexBuffer::GetBufferDesc() const
{
    return (const D3DBUFFER_DESC*)&m_desc;
} // CIndexBuffer::GetBufferDesc

// IUnknown methods
#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::QueryInterface"

STDMETHODIMP CIndexBuffer::QueryInterface(REFIID riid,
                                          LPVOID FAR * ppvObj)
{
    API_ENTER(Device());

    if (!VALID_PTR_PTR(ppvObj))
    {
        DPF_ERR("Invalid ppvObj parameter passed to CIndexBuffer::QueryInterface");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_PTR(&riid, sizeof(GUID)))
    {
        DPF_ERR("Invalid guid memory address to QueryInterface for an IndexBuffer");
        return D3DERR_INVALIDCALL;
    }

    if (riid == IID_IDirect3DIndexBuffer8 ||
        riid == IID_IDirect3DResource8    ||
        riid == IID_IUnknown)
    {
        *ppvObj = static_cast<void*>(static_cast<IDirect3DIndexBuffer8 *>(this));
        AddRef();
        return S_OK;
    }


    DPF_ERR("Unsupported Interface identifier passed to QueryInterface for an IndexBuffer");

    // Null out param
    *ppvObj = NULL;
    return E_NOINTERFACE;
} // QueryInterface

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::AddRef"

STDMETHODIMP_(ULONG) CIndexBuffer::AddRef()
{
    API_ENTER_NO_LOCK(Device());

    return AddRefImpl();
} // AddRef

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::Release"

STDMETHODIMP_(ULONG) CIndexBuffer::Release()
{
    API_ENTER_SUBOBJECT_RELEASE(Device());    

    return ReleaseImpl();
} // Release

// IDirect3DBuffer methods

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::GetDesc"

STDMETHODIMP CIndexBuffer::GetDesc(D3DINDEXBUFFER_DESC *pDesc)
{
    API_ENTER(Device());

    if (!VALID_WRITEPTR(pDesc, sizeof(D3DINDEXBUFFER_DESC)))
    {
        DPF_ERR("bad pointer for pDesc passed to GetDesc for an IndexBuffer");
        return D3DERR_INVALIDCALL;
    }

    *pDesc = m_desc;

    // Need to return pool/usage that the user specified
    pDesc->Pool    = GetUserPool();
    pDesc->Usage   = m_usageUser;

    return S_OK;
} // GetDesc

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::GetDevice"

STDMETHODIMP CIndexBuffer::GetDevice(IDirect3DDevice8 ** ppObj)
{
    API_ENTER(Device());

    return GetDeviceImpl(ppObj);
} // GetDevice

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::SetPrivateData"

STDMETHODIMP CIndexBuffer::SetPrivateData(REFGUID   riid,
                                          CONST VOID     *pvData,
                                          DWORD     cbData,
                                          DWORD     dwFlags)
{
    API_ENTER(Device());

    // We use level zero for our data
    return SetPrivateDataImpl(riid, pvData, cbData, dwFlags, 0);
} // SetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::GetPrivateData"

STDMETHODIMP CIndexBuffer::GetPrivateData(REFGUID   riid,
                                          LPVOID    pvData,
                                          LPDWORD   pcbData)
{
    API_ENTER(Device());

    // We use level zero for our data
    return GetPrivateDataImpl(riid, pvData, pcbData, 0);
} // GetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::FreePrivateData"

STDMETHODIMP CIndexBuffer::FreePrivateData(REFGUID riid)
{
    API_ENTER(Device());

    // We use level zero for our data
    return FreePrivateDataImpl(riid, 0);
} // FreePrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::GetPriority"

STDMETHODIMP_(DWORD) CIndexBuffer::GetPriority()
{
    API_ENTER_RET(Device(), DWORD);

    return GetPriorityImpl();
} // GetPriority

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::SetPriority"

STDMETHODIMP_(DWORD) CIndexBuffer::SetPriority(DWORD dwPriority)
{
    API_ENTER_RET(Device(), DWORD);

    return SetPriorityImpl(dwPriority);
} // SetPriority

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::PreLoad"

STDMETHODIMP_(void) CIndexBuffer::PreLoad(void)
{
    API_ENTER_VOID(Device());

    PreLoadImpl();
    return;
} // PreLoad

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::GetType"
STDMETHODIMP_(D3DRESOURCETYPE) CIndexBuffer::GetType(void)
{
    API_ENTER_RET(Device(), D3DRESOURCETYPE);

    return m_desc.Type;
} // GetType

// IDirect3DIndexBuffer8 methods

#if DBG
#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::ValidateLockParams"
HRESULT CIndexBuffer::ValidateLockParams(UINT cbOffsetToLock,
                                         UINT SizeToLock,
                                         BYTE **ppbData,
                                         DWORD dwFlags) const
{
    if (!VALID_PTR_PTR(ppbData))
    {
        DPF_ERR("Bad parameter passed for ppbData for creating a index buffer");
        return D3DERR_INVALIDCALL;
    }

    // Zero out return params
    *ppbData = NULL;

    if ((cbOffsetToLock != 0) && (SizeToLock == 0))
    {
        DPF_ERR("Cannot lock zero bytes. Lock IndexBuffer fails.");
        return D3DERR_INVALIDCALL;
    }

    if (dwFlags & ~(D3DLOCK_VALID & ~D3DLOCK_NO_DIRTY_UPDATE)) // D3DLOCK_NO_DIRTY_UPDATE not valid for IBs
    {
        DPF_ERR("Invalid flags specified. Lock IndexBuffer fails.");
        return D3DERR_INVALIDCALL;
    }

    // If a load-once is already loaded then
    // we're not lockable
    if (!m_isLockable)
    {
        DPF_ERR("Index buffer with D3DUSAGE_LOADONCE can only be locked once");
        return D3DERR_INVALIDCALL;
    }
    if ((dwFlags & (D3DLOCK_DISCARD | D3DLOCK_NOOVERWRITE)) != 0 && (m_usageUser & D3DUSAGE_DYNAMIC) == 0)
    {
        DPF_ERR("Can specify D3DLOCK_DISCARD or D3DLOCK_NOOVERWRITE for only Index Buffers created with D3DUSAGE_DYNAMIC");
        return D3DERR_INVALIDCALL;
    }
    if ((dwFlags & (D3DLOCK_READONLY | D3DLOCK_DISCARD)) == (D3DLOCK_READONLY | D3DLOCK_DISCARD))
    {
        DPF_ERR("Should not specify D3DLOCK_DISCARD along with D3DLOCK_READONLY. Index Buffer Lock fails.");
        return D3DERR_INVALIDCALL;
    }
    if ((dwFlags & D3DLOCK_READONLY) != 0 && (m_usageUser & D3DUSAGE_WRITEONLY) != 0)
    {
        DPF_ERR("Cannot do READ_ONLY lock on a WRITE_ONLY buffer. Index Buffer Lock fails");
        return D3DERR_INVALIDCALL;
    }

    if (ULONGLONG(cbOffsetToLock) + ULONGLONG(SizeToLock) > ULONGLONG(m_desc.Size))
    {
        DPF_ERR("Lock failed: Locked area exceeds size of buffer. Index Buffer Lock fails.");
        return D3DERR_INVALIDCALL;
    }

    if (m_LockCount == 0)
    {
        if ((m_usageUser & D3DUSAGE_DYNAMIC) == 0)
        {
            if (static_cast<CD3DBase*>(Device())->m_SceneStamp == m_SceneStamp &&
                (m_usageUser & D3DUSAGE_WRITEONLY) != 0 &&
                GetUserPool() != D3DPOOL_SYSTEMMEM)
            {
                DPF(1, "Static index buffer locked more than once per frame. Could have severe performance penalty.");
            }
            ((CIndexBuffer*)this)->m_SceneStamp = static_cast<CD3DBase*>(Device())->m_SceneStamp;
        }
        else
        {
            if ((dwFlags & (D3DLOCK_DISCARD | D3DLOCK_NOOVERWRITE)) == 0)
            {
                if (m_TimesLocked > 0 &&
                    (m_usageUser & D3DUSAGE_WRITEONLY) != 0 &&
                    GetUserPool() != D3DPOOL_SYSTEMMEM)
                {
                    DPF(3, "Dynamic index buffer locked twice or more in a row without D3DLOCK_NOOVERWRITE or D3DLOCK_DISCARD. Could have severe performance penalty.");
                }
                ++(((CIndexBuffer*)this)->m_TimesLocked);
            }
            else
            {
                ((CIndexBuffer*)this)->m_TimesLocked = 0;
            }
        }
    }

    DXGASSERT(m_LockCount < 0x80000000);

    return S_OK;
} // ValidateLockParams
#endif // DBG

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::Lock"

STDMETHODIMP CIndexBuffer::Lock(UINT    cbOffsetToLock,
                                UINT    SizeToLock,
                                BYTE  **ppbData,
                                DWORD   dwFlags)
{
    // We do not take the API lock here since the MT class will take it for
    // a multithreaded device. For a non-multithreaded device, there is no
    // MT class nor do we bother to take the API lock. We still need to 
    // call API_ENTER_NO_LOCK however for validation of the THIS pointer in
    // Debug builds
    API_ENTER_NO_LOCK_HR(Device()); 

#if DBG
    HRESULT hr = ValidateLockParams(cbOffsetToLock, SizeToLock, ppbData, dwFlags);
    if (FAILED(hr))
    {
        return hr;
    }
#endif // DBG

// Sanity check
#if DBG
    if (m_LockCount != 0)
    {
        DXGASSERT(GetPrivateDataPointer() != 0);
    }
#endif // DBG

    // Increment our lock count
    ++m_LockCount;

    if ((dwFlags & (D3DLOCK_READONLY | D3DLOCK_NOOVERWRITE)) == 0 && m_LockCount == 1) // for repeat locks, no syncing
    {
        Sync(); // Sync with device command queue
    }

    LockImpl(cbOffsetToLock,
             SizeToLock,
             ppbData,
             dwFlags,
             m_desc.Size);
    
    return S_OK;
} // Lock

#undef DPF_MODNAME
#define DPF_MODNAME "CIndexBuffer::Unlock"

STDMETHODIMP CIndexBuffer::Unlock()
{
    // We do not take the API lock here since the MT class will take it for
    // a multithreaded device. For a non-multithreaded device, there is no
    // MT class nor do we bother to take the API lock. We still need to 
    // call API_ENTER_NO_LOCK however for validation of the THIS pointer in
    // Debug builds
    API_ENTER_NO_LOCK_HR(Device()); 

#if DBG
    // If we aren't locked; then something is wrong
    if (m_LockCount == 0)
    {
        DPF_ERR("Unlock failed on an index buffer; index buffer wasn't locked.");
        return D3DERR_INVALIDCALL;
    }
#endif // DBG

    // Decrement our lock count
    --m_LockCount;

#if DBG
    if ((m_usageUser & D3DUSAGE_LOADONCE) != 0 && m_LockCount == 0)
    {
        m_isLockable = FALSE;
    }
#endif // DBG

    return S_OK;
} // Unlock

//=============================================
// Methods for the CDriverIndexBuffer class
//=============================================
#undef DPF_MODNAME
#define DPF_MODNAME "CDriverIndexBuffer::CDriverIndexBuffer"
CDriverIndexBuffer::CDriverIndexBuffer(CBaseDevice *pDevice,
                                       DWORD        cbLength,
                                       DWORD        Usage,
                                       DWORD        ActualUsage,
                                       D3DFORMAT    Format,
                                       D3DPOOL      Pool,
                                       D3DPOOL      ActualPool,
                                       REF_TYPE     refType,
                                       HRESULT     *phr
                                       ) :
    CIndexBuffer(pDevice,
                 cbLength,
                 Usage,
                 ActualUsage,
                 Format,
                 Pool,
                 ActualPool,
                 refType,
                 phr),
    m_pbData(0)
{
    if (FAILED(*phr))
    {
        DPF(2, "Failed to create driver indexbuffer");
        return;
    }
} // CDriverIndexBuffer::CDriverIndexBuffer

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverIndexBuffer::~CDriverIndexBuffer"
CDriverIndexBuffer::~CDriverIndexBuffer()
{
    if (m_pbData != 0)
    {
        HRESULT hr = UnlockI();
        if (FAILED(hr))
        {
            DPF_ERR("Failed to unlock driver index buffer");
        }
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverIndexBuffer::Lock"

STDMETHODIMP CDriverIndexBuffer::Lock(UINT cbOffsetToLock,
                                      UINT SizeToLock,
                                      BYTE **ppbData,
                                      DWORD dwFlags)
{
    // We do not take the API lock here since the MT class will take it for
    // a multithreaded device. For a non-multithreaded device, there is no
    // MT class nor do we bother to take the API lock. We still need to 
    // call API_ENTER_NO_LOCK however for validation of the THIS pointer in
    // Debug builds
    API_ENTER_NO_LOCK_HR(Device()); 

#if DBG
    HRESULT hr = ValidateLockParams(cbOffsetToLock, SizeToLock, ppbData, dwFlags);
    if (FAILED(hr))
    {
        return hr;
    }
#endif // DBG

// Sanity check
#if DBG
    if (m_LockCount != 0)
    {
        DXGASSERT(m_pbData != 0);
    }
#endif // DBG

    // Increment our lock count
    ++m_LockCount;

    if (((dwFlags & (D3DLOCK_READONLY | D3DLOCK_NOOVERWRITE)) == 0 || m_pbData == 0) && m_LockCount == 1) // no work for repeat locks
    {
        HRESULT hr;

        if (m_pbData != 0) // If lock was cached
        {
            DXGASSERT((m_desc.Usage & D3DUSAGE_DYNAMIC) != 0);
            hr = UnlockI();
            if (FAILED(hr))
            {
                DPF_ERR("Driver failed to unlock index buffer");
                *ppbData = 0;
                --m_LockCount;
                return hr;
            }
        }

        hr = LockI(dwFlags | D3DLOCK_NOSYSLOCK);
        if (FAILED(hr))
        {
            DPF_ERR("Failed to lock driver indexbuffer");
            *ppbData = 0;
            --m_LockCount;
            return hr;
        }
    }

    // Return value
    *ppbData = m_pbData + cbOffsetToLock;

    // Done
    return S_OK;
} // Lock

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverIndexBuffer::LockI"
HRESULT CDriverIndexBuffer::LockI(DWORD dwFlags)
{
    // We sync first to make sure that the
    // driver has already processed any data that
    // it needs. LockI only gets called if for
    // cases where we need the interlock i.e.
    // not readonly and not nooverwrite.
    Sync();

    // Prepare a LockData structure for the HAL call
    D3D8_LOCKDATA lockData;
    ZeroMemory(&lockData, sizeof lockData);

    lockData.hDD = Device()->GetHandle();
    lockData.hSurface = BaseKernelHandle();
    lockData.bHasRange = FALSE;
    lockData.dwFlags = dwFlags;

    HRESULT hr = Device()->GetHalCallbacks()->Lock(&lockData);
    if (FAILED(hr))
    {
        DPF_ERR("Failed to lock driver index buffer");
    }

    // Return value
    m_pbData = (BYTE*)lockData.lpSurfData;

    return hr;
} // LockI

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverIndexBuffer::Unlock"

STDMETHODIMP CDriverIndexBuffer::Unlock()
{
    // We do not take the API lock here since the MT class will take it for
    // a multithreaded device. For a non-multithreaded device, there is no
    // MT class nor do we bother to take the API lock. We still need to 
    // call API_ENTER_NO_LOCK however for validation of the THIS pointer in
    // Debug builds
    API_ENTER_NO_LOCK_HR(Device()); 

#if DBG
    // If we aren't locked; then something is wrong
    if (m_LockCount == 0)
    {
        DPF_ERR("Unlock failed on a Index buffer; buffer wasn't locked.");
        return D3DERR_INVALIDCALL;
    }
#endif // DBG

    if ((m_desc.Usage & D3DUSAGE_DYNAMIC) == 0 && m_LockCount == 1) // Do work only for the last unlock
    {
        HRESULT hr = UnlockI();
        if (FAILED(hr))
        {
            DPF_ERR("Driver failed to unlock index buffer");
            return hr;
        }
    }

    // Decrement our lock count
    --m_LockCount;

#if DBG
    if ((m_usageUser & D3DUSAGE_LOADONCE) != 0 && m_LockCount == 0)
    {
        m_isLockable = FALSE;
    }
#endif // DBG

    // Done
    return S_OK;
} // Unlock

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverIndexBuffer::UnlockI"

HRESULT CDriverIndexBuffer::UnlockI()
{
    DXGASSERT(m_pbData != 0);

    // Call the driver to perform the unlock
    D3D8_UNLOCKDATA unlockData = {
        Device()->GetHandle(),
        BaseKernelHandle()
    };

    HRESULT hr = Device()->GetHalCallbacks()->Unlock(&unlockData);
    if (FAILED(hr))
    {
        DPF_ERR("Driver index buffer failed to unlock");
        return hr;
    }

    m_pbData = 0;

    return hr;
}

//================================================
// Methods for the CDriverManagedIndexBuffer class
//================================================
#undef DPF_MODNAME
#define DPF_MODNAME "CDriverManagedIndexBuffer::CDriverManagedIndexBuffer"
CDriverManagedIndexBuffer::CDriverManagedIndexBuffer(CBaseDevice *pDevice,
                                                     DWORD        cbLength,
                                                     DWORD        Usage,
                                                     DWORD        ActualUsage,
                                                     D3DFORMAT    Format,
                                                     D3DPOOL      Pool,
                                                     D3DPOOL      ActualPool,
                                                     REF_TYPE     refType,
                                                     HRESULT     *phr
                                                     ) :
    CIndexBuffer(pDevice,
                 cbLength,
                 Usage,
                 ActualUsage,
                 Format,
                 Pool,
                 ActualPool,
                 refType,
                 phr),
    m_pbData(0),
    m_bDriverCalled(FALSE)
{
    if (FAILED(*phr))
        return;
    // If writeonly is not set, we assume that the vertex/index buffer is going
    // to be read from from time to time. Hence, for optimizing the readonly
    // locks, we lock and cache the pointer. (snene - 12/00)
    if ((ActualUsage & D3DUSAGE_WRITEONLY) == 0)
    {
        *phr = UpdateCachedPointer(pDevice);
        if (FAILED(*phr))
            return;
    }
} // CDriverManagedIndexBuffer::CDriverManagedIndexBuffer

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverManagedIndexBuffer::UpdateCachedPointer"

HRESULT CDriverManagedIndexBuffer::UpdateCachedPointer(CBaseDevice *pDevice)
{
    HRESULT hr;

    // Prepare a LockData structure for the HAL call
    D3D8_LOCKDATA lockData;
    ZeroMemory(&lockData, sizeof lockData);
    
    lockData.hDD = pDevice->GetHandle();
    lockData.hSurface = BaseKernelHandle();
    lockData.bHasRange = FALSE;
    lockData.range.Offset = 0;
    lockData.range.Size = 0;
    lockData.dwFlags = D3DLOCK_READONLY;
    
    hr = pDevice->GetHalCallbacks()->Lock(&lockData);
    if (FAILED(hr))
        return hr;
    
    // Call the driver to perform the unlock
    D3D8_UNLOCKDATA unlockData = {
        pDevice->GetHandle(),
            BaseKernelHandle()
    };
    
    hr = pDevice->GetHalCallbacks()->Unlock(&unlockData);
    if (FAILED(hr))
        return hr;
    
    m_pbData = (BYTE*)lockData.lpSurfData;

    return S_OK;
} // CDriverManagedIndexBuffer::UpdateCachedPointer

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverManagedIndexBuffer::Lock"

STDMETHODIMP CDriverManagedIndexBuffer::Lock(UINT cbOffsetToLock,
                                             UINT SizeToLock,
                                             BYTE **ppbData,
                                             DWORD dwFlags)
{
    // We do not take the API lock here since the MT class will take it for
    // a multithreaded device. For a non-multithreaded device, there is no
    // MT class nor do we bother to take the API lock. We still need to 
    // call API_ENTER_NO_LOCK however for validation of the THIS pointer in
    // Debug builds
    API_ENTER_NO_LOCK_HR(Device()); 

    HRESULT hr = S_OK;

#if DBG
    hr = ValidateLockParams(cbOffsetToLock, SizeToLock, ppbData, dwFlags);
    if (FAILED(hr))
    {
        return hr;
    }
#endif // DBG

    // Increment our lock count
    ++m_LockCount;

    if((dwFlags & D3DLOCK_READONLY) == 0)
    {
        // Sync with device command queue
        Sync();

        // Prepare a LockData structure for the HAL call
        D3D8_LOCKDATA lockData;
        ZeroMemory(&lockData, sizeof lockData);

        lockData.hDD = Device()->GetHandle();
        lockData.hSurface = BaseKernelHandle();
        lockData.bHasRange = (SizeToLock != 0);
        lockData.range.Offset = cbOffsetToLock;
        lockData.range.Size = SizeToLock;
        lockData.dwFlags = dwFlags;

        hr = Device()->GetHalCallbacks()->Lock(&lockData);
        if (FAILED(hr))
        {
            *ppbData = 0;
            DPF_ERR("Failed to lock driver managed index buffer");
            return hr;
        }
        else
        {
            // Update cached pointer
            m_pbData = (BYTE*)lockData.lpSurfData - cbOffsetToLock;
            m_bDriverCalled = TRUE;
        }
    }

    *ppbData = m_pbData + cbOffsetToLock;

    // Done
    return hr;
} // Lock

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverManagedIndexBuffer::Unlock"

STDMETHODIMP CDriverManagedIndexBuffer::Unlock()
{
    // We do not take the API lock here since the MT class will take it for
    // a multithreaded device. For a non-multithreaded device, there is no
    // MT class nor do we bother to take the API lock. We still need to 
    // call API_ENTER_NO_LOCK however for validation of the THIS pointer in
    // Debug builds
    API_ENTER_NO_LOCK_HR(Device()); 

#if DBG
    // If we aren't locked; then something is wrong
    if (m_LockCount == 0)
    {
        DPF_ERR("Unlock failed on a index buffer; buffer wasn't locked.");
        return D3DERR_INVALIDCALL;
    }
#endif

    if (m_bDriverCalled)
    {
        // Call the driver to perform the unlock
        D3D8_UNLOCKDATA unlockData = {
            Device()->GetHandle(),
            BaseKernelHandle()
        };

        HRESULT hr = Device()->GetHalCallbacks()->Unlock(&unlockData);
        if (FAILED(hr))
        {
            DPF_ERR("Driver index buffer failed to unlock");
            return hr;
        }

        m_bDriverCalled = FALSE;
    }

    // Decrement our lock count
    --m_LockCount;

#if DBG
    if ((m_usageUser & D3DUSAGE_LOADONCE) != 0 && m_LockCount == 0)
    {
        m_isLockable = FALSE;
    }
#endif // DBG

    return S_OK;
} // Unlock

// End of file : ibuffer.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\init.cpp ===
#define INITGUID

#define this _this
#include "ddrawpr.h"
#undef this
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\enum.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       enum.cpp
 *  Content     Handles all of the enum functions for determing what device
 *              you want before you go there.
 *
 *
 ***************************************************************************/
#include "ddrawpr.h"
#include <stdio.h>

#include "d3dobj.hpp"
#include "pixel.hpp"
#include "enum.hpp"
#include "d3di.hpp"
#include "fcache.hpp"
#include "swapchan.hpp"


#define D3DPMISCCAPS_DX7VALID      \
    (D3DPMISCCAPS_MASKZ          | \
     D3DPMISCCAPS_LINEPATTERNREP | \
     D3DPMISCCAPS_CULLNONE       | \
     D3DPMISCCAPS_CULLCW         | \
     D3DPMISCCAPS_CULLCCW)

// Maps D3DMULTISAMPLE_TYPE into the bit to use for the flags.
// Maps each of the multisampling values (2 to 16) to the bits[1] to bits[15]
// of wBltMSTypes and wFlipMSTypes
#define DDI_MULTISAMPLE_TYPE(x) (1 << ((x)-1))

#ifdef WINNT
extern "C" BOOL IsWhistler();
#endif

void DXReleaseExclusiveModeMutex(void)
{
    if (hExclusiveModeMutex) 
    {
        BOOL bSucceed = ReleaseMutex(hExclusiveModeMutex);
        if (!bSucceed)
        {
            DWORD dwErr = GetLastError();
            DPF_ERR("Release Exclusive Mode Mutex Failed.");
            DPF_ERR("Application attempts to leave exclusive mode on different thread than the device was created on. Dangerous!!");
            DPF(0, "Mutex 0x%p could not be released. Extended Error = %d", 
                    hExclusiveModeMutex, dwErr);
            DXGASSERT(FALSE);
        }
    }
} // DXReleaseExclusiveModeMutex


// DLL exposed Creation function
IDirect3D8 * WINAPI Direct3DCreate8(UINT SDKVersion)
{
    // Turn off D3D8 interfaces on WOW64.
#ifndef _IA64_
#if _WIN32_WINNT >= 0x0501
    typedef BOOL (WINAPI *PFN_ISWOW64PROC)( HANDLE hProcess,
                                            PBOOL Wow64Process );
    HINSTANCE hInst = NULL;
    hInst = LoadLibrary( "kernel32.dll" );
    if( hInst )
    {
        PFN_ISWOW64PROC pfnIsWow64 = NULL;
        pfnIsWow64 = (PFN_ISWOW64PROC)GetProcAddress( (HMODULE)hInst, "IsWow64Process" );
        // We assume that if this function is not available, then it is some OS where
        // WOW64 does not exist (this means that pre-Release versions of XP are busted)
        if( pfnIsWow64 )
        {
            BOOL wow64Process;
            if (pfnIsWow64(GetCurrentProcess(), &wow64Process) && wow64Process)
            {
                DPF_ERR("DX8 D3D interfaces are not supported on WOW64");
                return NULL;
            }
        }
        FreeLibrary( hInst );
    }
    else
    {
        DPF_ERR("LoadLibrary failed. Quitting.");
        return NULL;
    }
#endif // _WIN32_WINNT >= 0x0501
#endif  // _IA64_

#ifndef DEBUG
    // Check for debug-please registry key. If debug is required, then
    // we delegate this call to the debug version, if it exists,,

    HKEY hKey;

    if (!RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey))
    {
        DWORD   type;
        DWORD   value;
        DWORD   cb = sizeof(value);

        if (!RegQueryValueEx(hKey, "LoadDebugRuntime", NULL, &type, (CONST LPBYTE)&value, &cb))
        {

            if (value)
            {
                HINSTANCE hDebugDLL = LoadLibrary("d3d8d.dll");
                if (hDebugDLL)
                {
                    typedef IDirect3D8* (WINAPI * PDIRECT3DCREATE8)(UINT);

                    PDIRECT3DCREATE8 pDirect3DCreate8 =
                        (PDIRECT3DCREATE8) GetProcAddress(hDebugDLL, "Direct3DCreate8");

                    if (pDirect3DCreate8)
                    {
                        return pDirect3DCreate8(SDKVersion);
                    }
                }
            }
        }
        RegCloseKey(hKey);
    }
#else
    //If we are debug, then spew a string at level 2
    DPF(2,"Direct3D8 Debug Runtime selected.");
#endif

#ifndef DX_FINAL_RELEASE
    // Time-bomb check.
    {
        #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
        SYSTEMTIME st;
        GetSystemTime(&st);

        if (st.wYear > DX_EXPIRE_YEAR ||
             ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH)))
           )
        {
            MessageBox(0, DX_EXPIRE_TEXT,
                          TEXT("Microsoft Direct3D"), MB_OK | MB_TASKMODAL);
        }
    }
#endif //DX_FINAL_RELEASE

#ifdef DEBUG
    HKEY hKey;
    if (!RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey))
    {
        DWORD   type;
        DWORD   value;
        DWORD   cb = sizeof(value);

        if (!RegQueryValueEx(hKey, "SDKVersion", NULL, &type, (CONST LPBYTE)&value, &cb))
        {
            if (value)
            {
                SDKVersion = value;
            }
        }
        RegCloseKey(hKey);
    }
#endif

    if ((SDKVersion != D3D_SDK_VERSION_DX8) && 
        ((SDKVersion < (D3D_SDK_VERSION)) || (SDKVersion >= (D3D_SDK_VERSION+100))) )
    {
#ifdef DEBUG
        char pbuf[256];
        _snprintf(pbuf, 256,
            "\n"
            "D3D ERROR: This application compiled against improper D3D headers.\n"
            "The application is compiled with SDK version (%d) but the currently installed\n"
            "runtime supports versions from (%d).\n"
            "Please recompile with an up-to-date SDK.\n\n",
            SDKVersion, D3D_SDK_VERSION);
        OutputDebugString(pbuf);
#endif
        return NULL;
    }

    IDirect3D8 *pEnum = new CEnum(SDKVersion);
    if (pEnum == NULL)
    {
        DPF_ERR("Creating D3D enumeration object failed; out of memory. Direct3DCreate fails and returns NULL.");
    }
    return pEnum;
} // Direct3DCreate

//---------------------------------------------------------------------------
// CEnum methods
//---------------------------------------------------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::AddRef"

STDMETHODIMP_(ULONG) CEnum::AddRef(void)
{
    API_ENTER_NO_LOCK(this);

    // InterlockedIncrement requires the memory
    // to be aligned on DWORD boundary
    DXGASSERT(((ULONG_PTR)(&m_cRef) & 3) == 0);
    InterlockedIncrement((LONG *)&m_cRef);
    return m_cRef;
} // AddRef

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::Release"

STDMETHODIMP_(ULONG) CEnum::Release(void)
{
    API_ENTER_NO_LOCK(this);

    // InterlockedDecrement requires the memory
    // to be aligned on DWORD boundary
    DXGASSERT(((ULONG_PTR)(&m_cRef) & 3) == 0);
    InterlockedDecrement((LONG *)&m_cRef);
    if (m_cRef != 0)
        return m_cRef;

    for (UINT i = 0; i < m_cAdapter; i++)
    {
        if (m_REFCaps[i].pGDD8SupportedFormatOps)
            MemFree(m_REFCaps[i].pGDD8SupportedFormatOps);

        if (m_SwCaps[i].pGDD8SupportedFormatOps)
            MemFree(m_SwCaps[i].pGDD8SupportedFormatOps);
        
        if (m_AdapterInfo[i].HALCaps.pGDD8SupportedFormatOps)
            MemFree(m_AdapterInfo[i].HALCaps.pGDD8SupportedFormatOps);
        if (m_AdapterInfo[i].pModeTable)
            MemFree(m_AdapterInfo[i].pModeTable);
    }
    if (m_hGammaCalibrator)
    {
        FreeLibrary((HMODULE) m_hGammaCalibrator);
    }

    delete this;
    return 0;
} // Release

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::QueryInterface"

STDMETHODIMP CEnum::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    API_ENTER(this);

    if (!VALID_PTR_PTR(ppv))
    {
        DPF_ERR("Invalid pointer passed to QueryInterface for IDirect3D8 interface");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_PTR(&riid, sizeof(GUID)))
    {
        DPF_ERR("Invalid guid memory address to QueryInterface for IDirect3D8 interface");
        return D3DERR_INVALIDCALL;
    }

    if (riid == IID_IUnknown || riid == IID_IDirect3D8)
    {
        *ppv = static_cast<void*>(static_cast<IDirect3D8*>(this));
        AddRef();
    }
    else
    {
        DPF_ERR("Unsupported Interface identifier passed to QueryInterface for IDirect3D8 interface");
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    return S_OK;
} // QueryInterface


// DisplayGUID - GUID used to enumerate secondary displays.
//
// {67685559-3106-11d0-B971-00AA00342F9F}
//
// we use this GUID and the next 32 for enumerating devices
// returned via EnumDisplayDevices
//
GUID DisplayGUID =
    {0x67685559,0x3106,0x11d0,{0xb9,0x71,0x0,0xaa,0x0,0x34,0x2f,0x9f}};


#undef DPF_MODNAME
#define DPF_MODNAME "::strToGUID"

/*
 * strToGUID
 *
 * converts a string in the form xxxxxxxx-xxxx-xxxx-xx-xx-xx-xx-xx-xx-xx-xx
 * into a guid
 */
static BOOL strToGUID(LPSTR str, GUID * pguid)
{
    int         idx;
    LPSTR       ptr;
    LPSTR       next;
    DWORD       data;
    DWORD       mul;
    BYTE        ch;
    BOOL        done;

    idx = 0;
    done = FALSE;
    while (!done)
    {
        /*
         * find the end of the current run of digits
         */
        ptr = str;
        while ((*str) != '-' && (*str) != 0)
        {
            str++;
        }
        if (*str == 0)
        {
            done = TRUE;
        }
        else
        {
            next = str+1;
        }

        /*
         * scan backwards from the end of the string to the beginning,
         * converting characters from hex chars to numbers as we go
         */
        str--;
        mul = 1;
        data = 0;
        while (str >= ptr)
        {
            ch = *str;
            if (ch >= 'A' && ch <= 'F')
            {
                data += mul * (DWORD) (ch-'A'+10);
            }
            else if (ch >= 'a' && ch <= 'f')
            {
                data += mul * (DWORD) (ch-'a'+10);
            }
            else if (ch >= '0' && ch <= '9')
            {
                data += mul * (DWORD) (ch-'0');
            }
            else
            {
                return FALSE;
            }
            mul *= 16;
            str--;
        }

        /*
         * stuff the current number into the guid
         */
        switch(idx)
        {
        case 0:
            pguid->Data1 = data;
            break;
        case 1:
            pguid->Data2 = (WORD) data;
            break;
        case 2:
            pguid->Data3 = (WORD) data;
            break;
        default:
            pguid->Data4[ idx-3 ] = (BYTE) data;
            break;
        }

        /*
         * did we find all 11 numbers?
         */
        idx++;
        if (idx == 11)
        {
            if (done)
            {
                return TRUE;
            }
            else
            {
                return FALSE;
            }
        }
        str = next;
    }
    return FALSE;

} /* strToGUID */

// REF, HAL


typedef struct _DEVICEREGISTRYDATA
{
    UINT                Size;
    UINT                Cookie;
    FILETIME            FileDate;
    GUID                DriverGuid;
    D3D8_DRIVERCAPS     DeviceCaps;
    UINT                OffsetFormatOps;
    D3DFORMAT           Unknown16;
    DWORD               HALFlags;
} DEVICEREGISTRYDATA;

inline UINT EXPECTED_CACHE_SIZE(UINT nFormatOps)
{
    return sizeof(DEVICEREGISTRYDATA) + sizeof(DDSURFACEDESC) * nFormatOps;
}

#define DDRAW_REGCAPS_KEY   "Software\\Microsoft\\DirectDraw\\MostRecentDrivers"
#define VERSION_COOKIE  0x0083

#undef DPF_MODNAME
#define DPF_MODNAME "ReadCapsFromCache"

BOOL GetFileDate (char* Driver, FILETIME* pFileDate)
{
    WIN32_FILE_ATTRIBUTE_DATA   FA;
    char                    Name[MAX_PATH];
    HMODULE                 h = GetModuleHandle("KERNEL32");
    BOOL (WINAPI *pfnGetFileAttributesEx)(LPCSTR, GET_FILEEX_INFO_LEVELS, LPVOID);

    pFileDate->dwLowDateTime = 0;
    pFileDate->dwHighDateTime = 0;

    *((void **)&pfnGetFileAttributesEx) = GetProcAddress(h,"GetFileAttributesExA");
    if (pfnGetFileAttributesEx != NULL)
    {
        GetSystemDirectory(Name, sizeof(Name) - (strlen(Driver) + 3));
        lstrcat(Name,"\\");
        lstrcat(Name, Driver);

        if ((*pfnGetFileAttributesEx)(Name, GetFileExInfoStandard, &FA) != 0)
        {
            *pFileDate = FA.ftCreationTime;
            return TRUE;
        }
    }
    return FALSE;
}

//If pCaps is NULL, then those data will not be returned.
BOOL ReadCapsFromCache(UINT iAdapter,
                       D3D8_DRIVERCAPS *pCaps,
                       UINT* pHALFlags,
                       D3DFORMAT* pUnknown16,
                       char* pDeviceName,
                       BOOL bDisplayDriver)
{
    D3DADAPTER_IDENTIFIER8  DI;
    DEVICEREGISTRYDATA*     pData = NULL;
    UINT                    Size;
    FILETIME                FileDate;

    // Read the data from the registry

    // Don't need WHQL level or driver name
    GetAdapterInfo(pDeviceName, &DI, bDisplayDriver, TRUE, FALSE);

    ReadFromCache(&DI, &Size, (BYTE**)&pData);
    if (pData == NULL)
    {
        return FALSE;
    }

    // We have the data, now do a sanity check to make sure that it
    // it makes sense

    if (pData->Size != Size)
    {
        MemFree(pData);
        return FALSE;
    }
    if (Size != EXPECTED_CACHE_SIZE(pData->DeviceCaps.GDD8NumSupportedFormatOps))
    {
        MemFree(pData);
        return FALSE;
    }
    if (pData->DriverGuid != DI.DeviceIdentifier)
    {
        MemFree(pData);
        return FALSE;
    }
    if (pData->Cookie != VERSION_COOKIE)
    {
        MemFree(pData);
        return FALSE;
    }

    // Check the driver date to see if it changed

    if (GetFileDate(DI.Driver, &FileDate))
    {
        if ((FileDate.dwLowDateTime != pData->FileDate.dwLowDateTime) ||
            (FileDate.dwHighDateTime != pData->FileDate.dwHighDateTime))
        {
            MemFree(pData);
            return FALSE;
        }
    }

    *pUnknown16 = pData->Unknown16;
    *pHALFlags = pData->HALFlags;

    //Sometime we may not be asked to get the whole caps
    if (!pCaps)
    {
        MemFree(pData);
        return TRUE;
    }

    // Now that we have the data, we need to load it into a form that we
    // can use.

    memcpy(pCaps, &pData->DeviceCaps, sizeof(*pCaps));

    //reuse size to calculate size of support format ops
    Size = pData->DeviceCaps.GDD8NumSupportedFormatOps
        * sizeof(*(pData->DeviceCaps.pGDD8SupportedFormatOps));

    pCaps->pGDD8SupportedFormatOps = (DDSURFACEDESC*) MemAlloc(Size);

    if (pCaps->pGDD8SupportedFormatOps != NULL)
    {
        memcpy(pCaps->pGDD8SupportedFormatOps,
              ((BYTE*)pData) + pData->OffsetFormatOps,
              Size);
    }
    else
    {
        pCaps->GDD8NumSupportedFormatOps = 0;
    }

    MemFree(pData);

    return TRUE;
}
#undef DPF_MODNAME
#define DPF_MODNAME "WriteCapsToCache"

void WriteCapsToCache(UINT iAdapter,
                      D3D8_DRIVERCAPS *pCaps,
                      UINT HALFlags,
                      D3DFORMAT Unknown16,
                      char* pDeviceName,
                      BOOL  bDisplayDriver)
{
    DEVICEREGISTRYDATA*     pData;
    D3DADAPTER_IDENTIFIER8  DI;
    UINT                    Size;
    UINT                    Offset;
    FILETIME                FileDate;

    // Allocate the buffer and fill in all of the memory

    Size = EXPECTED_CACHE_SIZE(pCaps->GDD8NumSupportedFormatOps);

    pData = (DEVICEREGISTRYDATA*) MemAlloc(Size);
    if (pData == NULL)
    {
        return;
    }

    // Don't need WHQL level or driver name
    GetAdapterInfo(pDeviceName, &DI, bDisplayDriver, TRUE, FALSE);
    pData->DriverGuid = DI.DeviceIdentifier;

    pData->Size = Size;
    pData->Cookie = VERSION_COOKIE;
    memcpy(&pData->DeviceCaps, pCaps, sizeof(*pCaps));
    pData->Unknown16 = Unknown16;
    pData->HALFlags = HALFlags;

    if (GetFileDate(DI.Driver, &FileDate))
    {
        pData->FileDate = FileDate;
    }

    Offset = sizeof(DEVICEREGISTRYDATA);
    pData->OffsetFormatOps = Offset;
    memcpy(((BYTE*)pData) + Offset,
        pCaps->pGDD8SupportedFormatOps,
        pCaps->GDD8NumSupportedFormatOps *
            sizeof(*(pCaps->pGDD8SupportedFormatOps)));

    // Now save it

    WriteToCache(&DI, Size, (BYTE*) pData);

    MemFree(pData);
}

HRESULT CopyDriverCaps(D3D8_DRIVERCAPS* pDriverCaps, D3D8_DEVICEDATA* pDeviceData, BOOL bForce)
{
    HRESULT hr = D3DERR_INVALIDCALL;

    // Do they report any D3D caps in this mode?

    DWORD   Size;

    // If it's not at least a DX6 driver, we don't want to fill
    // in any caps at all. Also, if it can't texture, then
    // we don't to support it either.
    BOOL bCanTexture = TRUE;
    BOOL bCanHandleFVF = TRUE;
    BOOL bHasGoodCaps = TRUE;
    if (!bForce)
    {
        if (pDeviceData->DriverData.D3DCaps.TextureCaps)
        {
            bCanTexture = TRUE;
        }
        else
        {
            DPF(0, "HAL Disabled: Device doesn't support texturing");
            bCanTexture = FALSE;
        }

        // Some DX6 drivers are not FVF aware; and we need to
        // disable HAL for them.
        if (pDeviceData->DriverData.D3DCaps.FVFCaps != 0)
        {
            bCanHandleFVF = TRUE;
        }
        else
        {
            DPF(0, "HAL Disabled: Device doesn't support FVF");
            bCanHandleFVF = FALSE;
        }

        if (pDeviceData->Callbacks.DrawPrimitives2 == NULL)
        {
            DPF(0, "HAL Disabled: Device doesn't support DX6 or higher");
        }

        // We dont want drivers that report bogus caps:
        // pre-DX8 drivers that can do DX8 features.
        if (pDeviceData->DriverData.D3DCaps.MaxStreams == 0)
        {
            D3DCAPS8& Caps = pDeviceData->DriverData.D3DCaps;

            // Should have none of the following:
            //  1) PointSprites.
            //  2) VertexShaders.
            //  3) PixelShaders.
            //  4) Volume textures.
            //  5) Indexed Vertex Blending.
            //  6) Higher order primitives.
            //  7) PureDevice
            //  8) Perspective Color.
            //  9) Color Write.
            // 10) Newer texture caps.
            if ((Caps.MaxPointSize != 0)              ||
                (Caps.VertexShaderVersion != D3DVS_VERSION(0,0))  ||
                (Caps.PixelShaderVersion != D3DPS_VERSION(0,0))   ||
                (Caps.MaxVolumeExtent != 0)           ||
                (Caps.MaxVertexBlendMatrixIndex != 0) ||
                (Caps.MaxVertexIndex != 0xffff)       ||
                ((Caps.DevCaps & ~(D3DDEVCAPS_DX7VALID | D3DDEVCAPS_HWVERTEXBUFFER)) != 0)        ||
                ((Caps.RasterCaps & ~(D3DPRASTERCAPS_DX7VALID)) != 0) ||
                ((Caps.PrimitiveMiscCaps & ~(D3DPMISCCAPS_DX7VALID)) != 0)  ||
                ((Caps.TextureCaps & ~(D3DPTEXTURECAPS_DX7VALID)) != 0)
                )
            {
                DPF(0, "HAL Disabled: DX7 Device should not support DX8 features");
                bHasGoodCaps = FALSE;
            }
        }
        else
        // We dont want drivers that report bogus caps:
        // DX8 drivers should do DX8 features.
        {
            D3DCAPS8& Caps = pDeviceData->DriverData.D3DCaps;
        }
    }

    // We require drivers to support DP2 (i.e. DX6+),
    // texturing and proper FVF support in order to use a HAL

    if ((pDeviceData->Callbacks.DrawPrimitives2 != NULL &&
        bCanTexture   &&
        bCanHandleFVF &&
        bHasGoodCaps) ||
        bForce)
    {
        MemFree(pDriverCaps->pGDD8SupportedFormatOps);
        memcpy(pDriverCaps,
               &pDeviceData->DriverData, sizeof(pDeviceData->DriverData));

        Size = sizeof(DDSURFACEDESC) *
            pDriverCaps->GDD8NumSupportedFormatOps;
        pDriverCaps->pGDD8SupportedFormatOps =
            (DDSURFACEDESC*) MemAlloc(Size);

        if (pDriverCaps->pGDD8SupportedFormatOps != NULL)
        {
            memcpy(pDriverCaps->pGDD8SupportedFormatOps,
                   pDeviceData->DriverData.pGDD8SupportedFormatOps,
                   Size);
        }
        else
        {
            pDriverCaps->GDD8NumSupportedFormatOps = 0;
        }

        hr = D3D_OK;
    }
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "AddSoftwareDevice"

HRESULT AddSoftwareDevice(D3DDEVTYPE        DeviceType,
                          D3D8_DRIVERCAPS*  pSoftCaps,
                          ADAPTERINFO*      pAdapterInfo,
                          VOID*             pInitFunction)
{
    HRESULT             hr;
    PD3D8_DEVICEDATA    pDeviceData;

    hr = InternalDirectDrawCreate(&pDeviceData,
                                  pAdapterInfo,
                                  DeviceType,
                                  pInitFunction,
                                  pAdapterInfo->Unknown16,
                                  pAdapterInfo->HALCaps.pGDD8SupportedFormatOps,
                                  pAdapterInfo->HALCaps.GDD8NumSupportedFormatOps);
    if (SUCCEEDED(hr))
    {
        hr = CopyDriverCaps(pSoftCaps, pDeviceData, FALSE);

        InternalDirectDrawRelease(pDeviceData);
    }
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CreateCoverWindow"

HWND CreateCoverWindow()
{
#define COVERWINDOWNAME "DxCoverWindow"

    WNDCLASS windowClass =
    {
        0,
        DefWindowProc,
        0,
        0,
        g_hModule,
        LoadIcon(NULL, IDI_APPLICATION),
        LoadCursor(NULL, IDC_ARROW),
        (HBRUSH)(BLACK_BRUSH),
        NULL,
        COVERWINDOWNAME
    };

    RegisterClass(&windowClass);

    HWND hWindow = CreateWindowEx(
            WS_EX_TOPMOST,
            COVERWINDOWNAME,
            COVERWINDOWNAME,
            WS_POPUP,
            0,
            0,
            100,
            100,
            NULL,
            NULL,
            g_hModule,
            NULL);

    return hWindow;
}


HRESULT GetHALCapsInCurrentMode (PD3D8_DEVICEDATA pHalData, PADAPTERINFO pAdapterInfo, BOOL bForce, BOOL bFetchNewCaps)
{
    HRESULT             hr;
    DWORD               i;

    // Free the old stuff if we no longer care

    if (bFetchNewCaps)
    {
        MemFree(pHalData->DriverData.pGDD8SupportedFormatOps);
        pHalData->DriverData.pGDD8SupportedFormatOps = NULL;
        pHalData->DriverData.GDD8NumSupportedFormatOps = 0;

        MemFree(pAdapterInfo->HALCaps.pGDD8SupportedFormatOps);
        pAdapterInfo->HALCaps.pGDD8SupportedFormatOps = NULL;
        pAdapterInfo->HALCaps.GDD8NumSupportedFormatOps = 0;

        // Set this to ensure that we actually get the caps

        pHalData->DriverData.D3DCaps.DevCaps = 0;
        pHalData->DriverData.dwFlags &= ~DDIFLAG_D3DCAPS8;

        FetchDirectDrawData(pHalData, 
                            NULL, 
                            pAdapterInfo->Unknown16, 
                            NULL,
                            0);
    }

    // Do they report any D3D caps in this mode?

    hr = CopyDriverCaps(&pAdapterInfo->HALCaps, pHalData, bForce);

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "ProfileAdapter"

void ProfileAdapter(
    PADAPTERINFO        pAdapterInfo,
    PD3D8_DEVICEDATA    pHalData)
{
    UINT                    i;
    IDirect3DDevice8*       pDevice;
    D3DDISPLAYMODE          OrigMode;
    UINT                    OrigBpp;
    HRESULT                 hr;

    // We will be changing display modes, so first we want to save the current
    // mode so we can return to it later.

    D3D8GetMode (pHalData->hDD, pAdapterInfo->DeviceName, &OrigMode, D3DFMT_UNKNOWN);

    MemFree(pAdapterInfo->HALCaps.pGDD8SupportedFormatOps);
    memset(&pAdapterInfo->HALCaps, 0, sizeof(D3D8_DRIVERCAPS));

    OrigBpp = CPixel::ComputePixelStride(OrigMode.Format)*8;

    //First gather what we need from 16bpp: Unknown16 format
    if (16 != OrigBpp)
    {
            D3D8SetMode (pHalData->hDD,
                        pAdapterInfo->DeviceName,
                        640,
                        480,
                        16,
                        0,
                        FALSE);
    }

    D3DDISPLAYMODE              Mode;
    D3D8GetMode (pHalData->hDD, pAdapterInfo->DeviceName, &Mode, D3DFMT_UNKNOWN);
    pAdapterInfo->Unknown16 = Mode.Format;

    // We need to change to 32bpp, because the above code guarenteed we are now in 16bpp
    hr = D3D8SetMode (pHalData->hDD,
                        pAdapterInfo->DeviceName,
                        640,
                        480,
                        32,
                        0,
                        FALSE);
    if (SUCCEEDED(hr))
    {
        hr = GetHALCapsInCurrentMode(pHalData, pAdapterInfo, FALSE, TRUE);
    }

    if (FAILED(hr))
    {
        // If they don't report caps in 32bpp mode (ala Voodoo 3), then go
        // back to 16bpp mode and get the caps.  If the device supports
        // caps in any mode, we want to exit this function with the caps.

        D3D8SetMode (pHalData->hDD,
                     pAdapterInfo->DeviceName,
                     640,
                     480,
                     16,
                     0,
                     FALSE);

        hr = GetHALCapsInCurrentMode(pHalData, pAdapterInfo, FALSE, TRUE);

        // If they don't report good D3D caps in any mode at all, we still need
        // to return some caps, if only so we can support a SW driver.
     
        if (FAILED(hr))
        {
            GetHALCapsInCurrentMode(pHalData, pAdapterInfo, TRUE, TRUE);
            for (i = 0; i < pAdapterInfo->HALCaps.GDD8NumSupportedFormatOps; i++)
            {
                pAdapterInfo->HALCaps.pGDD8SupportedFormatOps[i].ddpfPixelFormat.dwOperations &= D3DFORMAT_OP_DISPLAYMODE;
            }
        }
    }

    //And now set back to original mode...
    D3D8SetMode (pHalData->hDD,
                     pAdapterInfo->DeviceName,
                     OrigMode.Width,
                     OrigMode.Height,
                     OrigBpp,
                     0,
                     TRUE);
}

#undef DPF_MODNAME
#define DPF_MODNAME "GetRefCaps"


void CEnum::GetRefCaps(UINT iAdapter)
{
    // If we've already got the caps once, there's ne need to get
    // them again

    if (m_REFCaps[iAdapter].GDD8NumSupportedFormatOps == 0)
    {
        AddSoftwareDevice(D3DDEVTYPE_REF,
                          &m_REFCaps[iAdapter],
                          &m_AdapterInfo[iAdapter],
                          NULL);
    }
}

void CEnum::GetSwCaps(UINT iAdapter)
{
    // If we've already got the caps once, there's ne need to get
    // them again

    if (m_SwCaps[iAdapter].GDD8NumSupportedFormatOps == 0)
    {
        AddSoftwareDevice(D3DDEVTYPE_SW,
                          &m_SwCaps[iAdapter],
                          &m_AdapterInfo[iAdapter],
                          m_pSwInitFunction);
    }
}

// IsSupportedOp
// Runs the pixel format operation list looking to see if the
// selected format can support at least the requested operations.

#undef DPF_MODNAME
#define DPF_MODNAME "IsSupportedOp"

BOOL IsSupportedOp (D3DFORMAT   Format,
               DDSURFACEDESC*   pList,
               UINT             NumElements,
               DWORD            dwRequestedOps)
{
    UINT i;

    for (i = 0; i < NumElements; i++)
    {
        DDASSERT(pList[i].ddpfPixelFormat.dwFlags == DDPF_D3DFORMAT);

        if (pList[i].ddpfPixelFormat.dwFourCC == (DWORD) Format &&
            (pList[i].ddpfPixelFormat.dwOperations & dwRequestedOps) == dwRequestedOps)
        {
            return TRUE;
        }
    }

    return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "IsInList"

BOOL IsInList (D3DFORMAT    Format,
               D3DFORMAT*   pList,
               UINT         NumElements)
{
    UINT i;

    for (i = 0; i < NumElements; i++)
    {
        if (pList[i] == Format)
        {
            return TRUE;
        }
    }

    return FALSE;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::MapDepthStencilFormat"

D3DFORMAT CEnum::MapDepthStencilFormat(UINT         iAdapter,
                                       D3DDEVTYPE   Type, 
                                       D3DFORMAT    Format) const
{
    DXGASSERT(CPixel::IsMappedDepthFormat(D3DFMT_D24X8));
    DXGASSERT(CPixel::IsMappedDepthFormat(D3DFMT_D15S1));
    DXGASSERT(CPixel::IsMappedDepthFormat(D3DFMT_D24S8));
    DXGASSERT(CPixel::IsMappedDepthFormat(D3DFMT_D16));
    DXGASSERT(CPixel::IsMappedDepthFormat(D3DFMT_D24X4S4));

    if (CPixel::IsMappedDepthFormat(Format))
    {
        DDSURFACEDESC *pTextureList;
        UINT           NumTextures;

        switch (Type)
        {
        case D3DDEVTYPE_SW:
            pTextureList = m_SwCaps[iAdapter].pGDD8SupportedFormatOps;
            NumTextures = m_SwCaps[iAdapter].GDD8NumSupportedFormatOps;
            break;

        case D3DDEVTYPE_HAL:
            NumTextures = m_AdapterInfo[iAdapter].HALCaps.GDD8NumSupportedFormatOps;
            pTextureList = m_AdapterInfo[iAdapter].HALCaps.pGDD8SupportedFormatOps;
            break;

        case D3DDEVTYPE_REF:
            NumTextures = m_REFCaps[iAdapter].GDD8NumSupportedFormatOps;
            pTextureList = m_REFCaps[iAdapter].pGDD8SupportedFormatOps;
            break;
        }

        // No operations are required; we just want to know
        // if this format is listed in the table for any purpose
        // at all
        DWORD dwRequiredOperations = 0;

        switch (Format)
        {
        case D3DFMT_D24X4S4:
            if (IsSupportedOp(D3DFMT_X4S4D24, pTextureList, NumTextures, dwRequiredOperations))
            {
                return D3DFMT_X4S4D24;
            }
            break;

        case D3DFMT_D24X8:
            if (IsSupportedOp(D3DFMT_X8D24, pTextureList, NumTextures, dwRequiredOperations))
            {
                return D3DFMT_X8D24;
            }
            break;

        case D3DFMT_D24S8:
            if (IsSupportedOp(D3DFMT_S8D24, pTextureList, NumTextures, dwRequiredOperations))
            {
                return D3DFMT_S8D24;
            }
            break;

        case D3DFMT_D16:
            if (IsSupportedOp(D3DFMT_D16, pTextureList, NumTextures, dwRequiredOperations))
            {
                return D3DFMT_D16;
            }
            return D3DFMT_D16_LOCKABLE;

        case D3DFMT_D15S1:
            if (IsSupportedOp(D3DFMT_S1D15, pTextureList, NumTextures, dwRequiredOperations))
            {
                return D3DFMT_S1D15;
            }
            break;

        default:
            // Unexpected format?
            DXGASSERT(FALSE);
            break;
        }
    }

    return Format;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::GetAdapterCaps"

HRESULT CEnum::GetAdapterCaps(UINT              iAdapter,
                              D3DDEVTYPE        Type,
                              D3D8_DRIVERCAPS** ppCaps)
{
    *ppCaps = NULL;
    if (Type == D3DDEVTYPE_REF)
    {
        GetRefCaps (iAdapter);
        *ppCaps = &m_REFCaps[iAdapter];
        if (m_REFCaps[iAdapter].GDD8NumSupportedFormatOps == 0)
        {
            DPF_ERR("The reference driver cannot be found. GetAdapterCaps fails.");
            return D3DERR_NOTAVAILABLE;
        }
        return D3D_OK;
    }
    else if (Type == D3DDEVTYPE_SW)
    {
        if (m_pSwInitFunction == NULL)
        {
            DPF_ERR("No SW device has been registered.. GetAdapterCaps fails.");
            return D3DERR_INVALIDCALL;
        }
        else
        {
            GetSwCaps(iAdapter);
            *ppCaps = &m_SwCaps[iAdapter];
            if (m_SwCaps[iAdapter].GDD8NumSupportedFormatOps == 0)
            {
                DPF_ERR("The software driver cannot be loaded.  GetAdapterCaps fails.");
                return D3DERR_NOTAVAILABLE;
            }
            return D3D_OK;
        }
    }
    else if (Type == D3DDEVTYPE_HAL)
    {
        DWORD   i;

        if (m_bDisableHAL)
        {
            DPF_ERR("HW device not available.  GetAdapterCaps fails.");
            return D3DERR_NOTAVAILABLE;
        }

        *ppCaps = &m_AdapterInfo[iAdapter].HALCaps;
        return D3D_OK;
    }

    return D3DERR_INVALIDDEVICE;
}

void GetDX8HALCaps(UINT iAdapter, PD3D8_DEVICEDATA pHalData, ADAPTERINFO * pAdapterInfo)
{
    //DX7 or older drivers may need to be profiled to determine
    //their 555/565 format and whether they support an alpha
    //channel in 32bpp

    D3DFORMAT       CachedUnknown16 = D3DFMT_UNKNOWN;
    UINT            CachedHALFlags = 0;
    D3DDISPLAYMODE  Mode;
    BOOL            bProfiled = FALSE;
    UINT            i;
    HRESULT         hr;

    // If it's a DX8 driver, we hopefully don't need to profile at all.

    pAdapterInfo->Unknown16 = D3DFMT_UNKNOWN;
    hr = GetHALCapsInCurrentMode(pHalData, pAdapterInfo, FALSE, FALSE);
    if (SUCCEEDED(hr))
    {
        for (i = 0; i < pAdapterInfo->HALCaps.GDD8NumSupportedFormatOps; i++)
        {
            if (pAdapterInfo->HALCaps.pGDD8SupportedFormatOps[i].ddpfPixelFormat.dwOperations & D3DFORMAT_OP_DISPLAYMODE)
            {
                switch (pAdapterInfo->HALCaps.pGDD8SupportedFormatOps[i].ddpfPixelFormat.dwFourCC)
                {
                case D3DFMT_X1R5G5B5:
                case D3DFMT_R5G6B5:
                    pAdapterInfo->Unknown16 = (D3DFORMAT) pAdapterInfo->HALCaps.pGDD8SupportedFormatOps[i].ddpfPixelFormat.dwFourCC;
                    break;
                }
            }
        }

        if (pAdapterInfo->Unknown16 != D3DFMT_UNKNOWN)
        {
            // That wasn't hard
            return;
        }
    }

    // We are definately need to read stuff from the caps at some point,
    // so why not now?

    if (!ReadCapsFromCache(iAdapter,
           NULL,
           &CachedHALFlags,
           &CachedUnknown16,
           pAdapterInfo->DeviceName,
           pAdapterInfo->bIsDisplay))
    {
        // There's nothing to read, so we need to re-profile
        ProfileAdapter(
                pAdapterInfo,
                pHalData);
        bProfiled = TRUE;
    }

    // If we profiled, then we already have everything that we need;
    // otherwise, we have to go get it.

    if (!bProfiled)
    {
        D3D8GetMode (pHalData->hDD, pAdapterInfo->DeviceName, &Mode, D3DFMT_UNKNOWN);
        if ((Mode.Format == D3DFMT_X1R5G5B5) ||
            (Mode.Format == D3DFMT_R5G6B5))
        {
            pAdapterInfo->Unknown16 = Mode.Format;
        }
        else
        {
            pAdapterInfo->Unknown16 = CachedUnknown16;
        }

        HRESULT hCurrentModeIsSupported = GetHALCapsInCurrentMode(pHalData, pAdapterInfo, FALSE, TRUE);

        if (FAILED(hCurrentModeIsSupported))
        {
            // We assume that this will succeed because the call above already has
            ReadCapsFromCache(iAdapter,
                      &pAdapterInfo->HALCaps,
                      &CachedHALFlags,
                      &CachedUnknown16,
                      pAdapterInfo->DeviceName,
                      pAdapterInfo->bIsDisplay);
            DPF(0,"D3D not supported in current mode - reading caps from file");
        }
    }

    //We now have good caps. Write them out to the cache.
    WriteCapsToCache(iAdapter,
                 &pAdapterInfo->HALCaps,
                 pAdapterInfo->HALFlags,
                 pAdapterInfo->Unknown16,
                 pAdapterInfo->DeviceName,
                 pAdapterInfo->bIsDisplay);
}

#ifdef WINNT
void FakeDirectDrawCreate (ADAPTERINFO * pAdapterInfo, int iAdapter)
{
    HDC             hdc;
    DDSURFACEDESC*  pTextureList = NULL;
    BOOL            bProfiled = FALSE;
    BOOL            b32Supported;
    BOOL            b16Supported;
    int             NumOps;
    DWORD           j;
    
    pTextureList = (DDSURFACEDESC *) MemAlloc (2 * sizeof (*pTextureList));
    if (pTextureList != NULL)
    {
        hdc = DD_CreateDC(pAdapterInfo->DeviceName);
        if (hdc != NULL)
        {
            HANDLE      hDD;
            HINSTANCE   hLib;

            D3D8CreateDirectDrawObject(hdc,
                                       pAdapterInfo->DeviceName,
                                       &hDD,
                                       D3DDEVTYPE_HAL,
                                       &hLib,
                                       NULL);
            if (hDD != NULL)
            {
                pAdapterInfo->bNoDDrawSupport = TRUE;

                // Figure out the unknown 16 value

                if (!ReadCapsFromCache(iAdapter,
                    NULL,
                    &(pAdapterInfo->HALFlags),
                    &(pAdapterInfo->Unknown16),
                    pAdapterInfo->DeviceName,
                    pAdapterInfo->bIsDisplay))
                {
                    D3DDISPLAYMODE  OrigMode;
                    D3DDISPLAYMODE  NewMode;

                    D3D8GetMode (hDD, 
                        pAdapterInfo->DeviceName, 
                        &OrigMode, 
                        D3DFMT_UNKNOWN);

                    if ((OrigMode.Format == D3DFMT_R5G6B5) ||
                        (OrigMode.Format == D3DFMT_X1R5G5B5))
                    {
                        pAdapterInfo->Unknown16 = OrigMode.Format;
                    }
                    else
                    {
                        D3D8SetMode (hDD,
                            pAdapterInfo->DeviceName,
                            640,
                            480,
                            16,
                            0,
                            FALSE);

                        D3D8GetMode (hDD, 
                            pAdapterInfo->DeviceName, 
                            &NewMode, 
                            D3DFMT_UNKNOWN);

                        D3D8SetMode (hDD,
                            pAdapterInfo->DeviceName, 
                            OrigMode.Width,
                            OrigMode.Height,
                            0,
                            0,
                            TRUE);
                        pAdapterInfo->Unknown16 = NewMode.Format;
                    }
                    bProfiled = TRUE;
                }

                // Build the mode table

                while (1)
                {
                    D3D8BuildModeTable(
                        pAdapterInfo->DeviceName,
                        NULL,
                        &(pAdapterInfo->NumModes),
                        pAdapterInfo->Unknown16,
                        hDD,
                        TRUE,
                        TRUE);
                    if (pAdapterInfo->NumModes)
                    {
                        pAdapterInfo->pModeTable = (D3DDISPLAYMODE*)
                            MemAlloc (sizeof(D3DDISPLAYMODE) * pAdapterInfo->NumModes);
                        if (pAdapterInfo->pModeTable != NULL)
                        {
                            D3D8BuildModeTable(
                                pAdapterInfo->DeviceName,
                                pAdapterInfo->pModeTable,
                                &(pAdapterInfo->NumModes),
                                pAdapterInfo->Unknown16,
                                hDD,
                                TRUE,
                                TRUE);

                            //If D3D8BuildModeTable finds it needs more space for its table,
                            //it will return 0 to indicate we should try again.
                            if (0 == pAdapterInfo->NumModes)
                            {
                                MemFree(pAdapterInfo->pModeTable);
                                pAdapterInfo->pModeTable = NULL;
                                continue;
                            }
                        }
                        else
                        {
                            pAdapterInfo->NumModes = 0;
                        }
                    }
                    break;
                }//while(1)

                // Now build a rudimentary op list based on what modes we support

                b32Supported = b16Supported = FALSE;
                for (j = 0; j < pAdapterInfo->NumModes; j++)
                {
                    if (pAdapterInfo->pModeTable[j].Format == D3DFMT_X8R8G8B8)
                    {
                        b32Supported = TRUE;
                    }
                    if (pAdapterInfo->pModeTable[j].Format == pAdapterInfo->Unknown16)
                    {
                        b16Supported = TRUE;
                    }
                }

                NumOps = 0;
                if (b16Supported)
                {
                    pTextureList[NumOps].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
                    pTextureList[NumOps].ddpfPixelFormat.dwFourCC = (DWORD) pAdapterInfo->Unknown16;
                    pTextureList[NumOps].ddpfPixelFormat.dwOperations =  D3DFORMAT_OP_DISPLAYMODE;
                    pTextureList[NumOps].ddpfPixelFormat.dwPrivateFormatBitCount = 0;
                    pTextureList[NumOps].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
                    pTextureList[NumOps].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
                    NumOps++;
                }

                if (b32Supported)
                {
                    pTextureList[NumOps].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
                    pTextureList[NumOps].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_X8R8G8B8;
                    pTextureList[NumOps].ddpfPixelFormat.dwOperations =  D3DFORMAT_OP_DISPLAYMODE;
                    pTextureList[NumOps].ddpfPixelFormat.dwPrivateFormatBitCount = 0;
                    pTextureList[NumOps].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
                    pTextureList[NumOps].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
                    NumOps++;
                }

                pAdapterInfo->HALCaps.pGDD8SupportedFormatOps = pTextureList;
                pAdapterInfo->HALCaps.GDD8NumSupportedFormatOps = NumOps;

                if (bProfiled)
                {
                    WriteCapsToCache(iAdapter,
                        &(pAdapterInfo->HALCaps),
                        pAdapterInfo->HALFlags,
                        pAdapterInfo->Unknown16,
                        pAdapterInfo->DeviceName,
                        pAdapterInfo->bIsDisplay);
                }

                D3D8DeleteDirectDrawObject(hDD);
            }
            DD_DoneDC(hdc);
        }
        if (pAdapterInfo->HALCaps.pGDD8SupportedFormatOps == NULL)
        {
            MemFree(pTextureList);
        }
    }
}
#endif


#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::CEnum"


CEnum::CEnum(UINT AppSdkVersion)
    :
    m_cRef(1),
    m_cAdapter(0),
    m_bHasExclusive(FALSE),
    m_AppSdkVersion(AppSdkVersion)
{
    DWORD           rc;
    DWORD           keyidx;
    HKEY            hkey;
    HKEY            hsubkey;
    char            keyname[256];
    char            desc[256];
    char            drvname[MAX_PATH];
    DWORD           cb;
    DWORD           i;
    DWORD           type;
    GUID            guid;
    HDC             hdc;
    DISPLAY_DEVICEA dd;

    // Give our base class a pointer to ourselves
    SetOwner(this);

    // Initialize our critical section
    EnableCriticalSection();

    // Disable DPFs that occur during this phase
    DPF_MUTE();

    // WARNING: Must call DPF_UNMUTE before returning from
    // this function.
    for (i = 0; i < MAX_DX8_ADAPTERS; i++)
        m_pFullScreenDevice[i] = NULL;

    ZeroMemory(m_AdapterInfo, sizeof(m_AdapterInfo));

    // Always make the first entry reflect the primary device
    ZeroMemory(&dd, sizeof(dd));
    dd.cb = sizeof(dd);
    for (i = 0; xxxEnumDisplayDevicesA(NULL, i, &dd, 0); i++)
    {
        //
        // skip drivers that are not hardware devices
        //
        if (dd.StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER)
            continue;
           
        //
        // don't enumerate devices that are not attached
        //
        if (!(dd.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP))
            continue;

        if (dd.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE)
        {
            m_AdapterInfo[m_cAdapter].Guid = DisplayGUID;
            m_AdapterInfo[m_cAdapter].Guid.Data1 += i;
            lstrcpyn(m_AdapterInfo[m_cAdapter].DeviceName, dd.DeviceName, MAX_PATH);
            m_AdapterInfo[m_cAdapter].bIsPrimary = TRUE;
            m_AdapterInfo[m_cAdapter++].bIsDisplay = TRUE;
        }
    }

    // Now get the info for the attached secondary devices

    for (i = 0; xxxEnumDisplayDevicesA(NULL, i, &dd, 0); i++)
    {
        //
        // skip drivers that are not hardware devices
        //
        if (dd.StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER)
            continue;

        //
        // don't enumerate devices that are not attached
        //
        if (!(dd.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP))
            continue;

        if (!(dd.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE) &&
            (m_cAdapter < MAX_DX8_ADAPTERS))
        {
            m_AdapterInfo[m_cAdapter].Guid = DisplayGUID;
            m_AdapterInfo[m_cAdapter].Guid.Data1 += i;
            lstrcpyn(m_AdapterInfo[m_cAdapter].DeviceName, dd.DeviceName, MAX_PATH);
            m_AdapterInfo[m_cAdapter].bIsPrimary = FALSE;
            m_AdapterInfo[m_cAdapter++].bIsDisplay = TRUE;
        }
    }

    // Now get info for the passthrough devices listed under
    // HKEY_LOCALMACHINE\Hardware\DirectDrawDrivers

    if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_DDHW, &hkey) == 0)
    {
        keyidx = 0;
        while (!RegEnumKey(hkey, keyidx, keyname, sizeof(keyname)))
        {
            if (strToGUID(keyname, &guid))
            {
                if (!RegOpenKey(hkey, keyname, &hsubkey))
                {
                    cb = sizeof(desc) - 1;
                    if (!RegQueryValueEx(hsubkey, REGSTR_KEY_DDHW_DESCRIPTION, NULL, &type,
                        (CONST LPBYTE)desc, &cb))
                    {
                        if (type == REG_SZ)
                        {
                            desc[cb] = 0;
                            cb = sizeof(drvname) - 1;
                            if (!RegQueryValueEx(hsubkey, REGSTR_KEY_DDHW_DRIVERNAME, NULL, &type,
                                (CONST LPBYTE)drvname, &cb))
                            {
                                // It is possible that the registry is out
                                // of date, so we will try to create a DC.
                                // The problem is that the Voodoo 1 driver
                                // will suceed on a Voodoo 2, Banshee, or
                                // Voodoo 3 (and hang later), so we need to
                                //  hack around it.

                                drvname[cb] = 0;
                                if (Voodoo1GoodToGo(&guid))
                                {
                                    hdc = DD_CreateDC(drvname);
                                }
                                else
                                {
                                    hdc = NULL;
                                }
                                if ((type == REG_SZ) &&
                                    (hdc != NULL))
                                {
                                    if (m_cAdapter < MAX_DX8_ADAPTERS)
                                    {
                                        drvname[cb] = 0;
                                        m_AdapterInfo[m_cAdapter].Guid = guid;
                                        lstrcpyn(m_AdapterInfo[m_cAdapter].DeviceName, drvname, MAX_PATH);
                                        m_AdapterInfo[m_cAdapter].bIsPrimary = FALSE;
                                        m_AdapterInfo[m_cAdapter++].bIsDisplay = FALSE;
                                    }
                                }
                                if (hdc != NULL)
                                {
                                    DD_DoneDC(hdc);
                                }
                            }
                        }
                    }
                    RegCloseKey(hsubkey);
                }
            }
            keyidx++;
        }
        RegCloseKey(hkey);
    }
    DPF_UNMUTE();

    //  Now that we know about all of the devices, we need to build a mode
    //  table for each one

    for (i = 0; i < m_cAdapter; i++)
    {
        HRESULT             hr;
        D3DDISPLAYMODE      Mode;
        DWORD               j;
        BOOL                b16bppSupported;
        BOOL                b32bppSupported;
        PD3D8_DEVICEDATA    pHalData;

        hr = InternalDirectDrawCreate(&pHalData,
                                      &m_AdapterInfo[i],
                                      D3DDEVTYPE_HAL,
                                      NULL,
                                      D3DFMT_UNKNOWN,
                                      NULL,
                                      0);

        if (FAILED(hr))
        {
            memset(&m_AdapterInfo[i].HALCaps, 0, sizeof(m_AdapterInfo[i].HALCaps));

            // On Win2K, we want to enable sufficient functionality so that this
            // adapter can at least run a sw driver.  If it truly failed due to 
            // no ddraw support, we need to special case this and then build a
            // rudimentary op list indicting that it works in the current mode.

            #ifdef WINNT
                FakeDirectDrawCreate(&m_AdapterInfo[i], i);
            #endif
        }
        else
        {
            GetDX8HALCaps(i, pHalData, &m_AdapterInfo[i]);

            b16bppSupported = b32bppSupported = FALSE;
            for (j = 0; j < m_AdapterInfo[i].HALCaps.GDD8NumSupportedFormatOps; j++)
            {
                if (m_AdapterInfo[i].HALCaps.pGDD8SupportedFormatOps[j].ddpfPixelFormat.dwOperations & D3DFORMAT_OP_DISPLAYMODE)
                {
                    switch(m_AdapterInfo[i].HALCaps.pGDD8SupportedFormatOps[j].ddpfPixelFormat.dwFourCC)
                    {
                    case D3DFMT_X1R5G5B5:
                    case D3DFMT_R5G6B5:
                        b16bppSupported = TRUE;
                        break;

                    case D3DFMT_X8R8G8B8:
                        b32bppSupported = TRUE;
                        break;
                    }
                }
            }

            while (1)
            {
                D3D8BuildModeTable(
                    m_AdapterInfo[i].DeviceName,
                    NULL,
                    &m_AdapterInfo[i].NumModes,
                    m_AdapterInfo[i].Unknown16,
                    pHalData->hDD,
                    b16bppSupported,
                    b32bppSupported);
                if (m_AdapterInfo[i].NumModes)
                {
                    m_AdapterInfo[i].pModeTable = (D3DDISPLAYMODE*)
                        MemAlloc (sizeof(D3DDISPLAYMODE) * m_AdapterInfo[i].NumModes);
                    if (m_AdapterInfo[i].pModeTable != NULL)
                    {
                        D3D8BuildModeTable(
                            m_AdapterInfo[i].DeviceName,
                            m_AdapterInfo[i].pModeTable,
                            &m_AdapterInfo[i].NumModes,
                            m_AdapterInfo[i].Unknown16,
                            pHalData->hDD,
                            b16bppSupported,
                            b32bppSupported);

                        //If D3D8BuildModeTable finds it needs more space for its table,
                        //it will return 0 to indicate we should try again.
                        if (0 == m_AdapterInfo[i].NumModes)
                        {
                            MemFree(m_AdapterInfo[i].pModeTable);
                            m_AdapterInfo[i].pModeTable = NULL;
                            continue;
                        }
                    }
                    else
                    {
                        m_AdapterInfo[i].NumModes = 0;
                    }
                }
                break;
            }//while(1)

            // If this doesn't have a ddraw HAL, but guessed that it might
            // support a 32bpp mode, go see if we were right.

            if (b32bppSupported && 
                (m_AdapterInfo[i].HALCaps.D3DCaps.DevCaps == 0) &&
                (m_AdapterInfo[i].HALCaps.DisplayFormatWithoutAlpha != D3DFMT_X8R8G8B8))               
            {
                for (j = 0; j < m_AdapterInfo[i].NumModes; j++)
                {
                    if (m_AdapterInfo[i].pModeTable[j].Format == D3DFMT_X8R8G8B8)
                    {
                        break;
                    }
                }
                if (j >= m_AdapterInfo[i].NumModes)
                {
                    // This card apparently does NOT support 32bpp so remove it

                    for (j = 0; j < m_AdapterInfo[i].HALCaps.GDD8NumSupportedFormatOps; j++)
                    {
                        if ((m_AdapterInfo[i].HALCaps.pGDD8SupportedFormatOps[j].ddpfPixelFormat.dwOperations & D3DFORMAT_OP_DISPLAYMODE) &&
                            (m_AdapterInfo[i].HALCaps.pGDD8SupportedFormatOps[j].ddpfPixelFormat.dwFourCC == D3DFMT_X8R8G8B8))
                        {
                            m_AdapterInfo[i].HALCaps.pGDD8SupportedFormatOps[j].ddpfPixelFormat.dwOperations &= ~D3DFORMAT_OP_DISPLAYMODE;
                        }
                    }
                }
            }

            InternalDirectDrawRelease(pHalData);
        }
    }

    m_hGammaCalibrator         = NULL;
    m_pGammaCalibratorProc     = NULL;
    m_bAttemptedGammaCalibrator= FALSE;
    m_bGammaCalibratorExists    = FALSE;

    // The first time through, we will also check to see if a gamma
    // calibrator is registered.  All we'll do here is read the registry
    // key and if it's non-NULL, we'll assume that one exists.
    {
        HKEY hkey;
        if (!RegOpenKey(HKEY_LOCAL_MACHINE,
                         REGSTR_PATH_DDRAW "\\" REGSTR_KEY_GAMMA_CALIBRATOR, &hkey))
        {
            DWORD       type;
            DWORD       cb;

            cb = sizeof(m_szGammaCalibrator);
            if (!RegQueryValueEx(hkey, REGSTR_VAL_GAMMA_CALIBRATOR,
                        NULL, &type, m_szGammaCalibrator, &cb))
            {
                if ((type == REG_SZ) &&
                    (m_szGammaCalibrator[0] != '\0'))
                {
                    m_bGammaCalibratorExists = TRUE;
                }
            }
            RegCloseKey(hkey);
        }
    }

    // Check to see if they disabled the D3DHAL in the registry
    {
        HKEY hKey;
        if (!RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D "\\Drivers", &hKey))
        {
            DWORD   type;
            DWORD   value;
            DWORD   cb = sizeof(value);

            if (!RegQueryValueEx(hKey, "SoftwareOnly", NULL, &type, (CONST LPBYTE)&value, &cb))
            {
                if (value)
                {
                    m_bDisableHAL = TRUE;
                }
                else
                {
                    m_bDisableHAL = FALSE;
                }
            }
            RegCloseKey(hKey);
        }
    }

    DXGASSERT(IsValid());

} // CEnum::CEnum

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::GetAdapterCount"


STDMETHODIMP_(UINT) CEnum::GetAdapterCount()
{
    API_ENTER_RET(this, UINT);

    return m_cAdapter;
} // GetAdapterCount

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::GetAdapterIdentifier"


STDMETHODIMP CEnum::GetAdapterIdentifier(
    UINT                        iAdapter,
    DWORD                       dwFlags,
    D3DADAPTER_IDENTIFIER8     *pIdentifier)
{
    API_ENTER(this);

    if (!VALID_WRITEPTR(pIdentifier, sizeof(D3DADAPTER_IDENTIFIER8)))
    {
        DPF_ERR("Invalid pIdentifier parameter specified for GetAdapterIdentifier");
        return D3DERR_INVALIDCALL;
    }

    memset(pIdentifier, 0, sizeof(*pIdentifier));

    if (dwFlags & ~VALID_D3DENUM_FLAGS)
    {
        DPF_ERR("Invalid flags specified. GetAdapterIdentifier fails.");
        return D3DERR_INVALIDCALL;
    }

    if (iAdapter >= m_cAdapter)
    {
        DPF_ERR("Invalid Adapter number specified. GetAdapterIdentifier fails.");
        return D3DERR_INVALIDCALL;
    }

    // Need driver name

    GetAdapterInfo (m_AdapterInfo[iAdapter].DeviceName,
        pIdentifier,
        m_AdapterInfo[iAdapter].bIsDisplay,
        (dwFlags & D3DENUM_NO_WHQL_LEVEL) ? TRUE : FALSE,
        TRUE);

    return D3D_OK;
} // GetAdapterIdentifier

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::GetAdapterModeCount"

STDMETHODIMP_(UINT) CEnum::GetAdapterModeCount(
    UINT                iAdapter)
{
    API_ENTER_RET(this, UINT);

    if (iAdapter >= m_cAdapter)
    {
        DPF_ERR("Invalid adapter specified. GetAdapterModeCount returns zero.");
        return 0;
    }
    return m_AdapterInfo[iAdapter].NumModes;
} // GetAdapterModeCount


#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::EnumAdapterModes"

STDMETHODIMP CEnum::EnumAdapterModes(
    UINT            iAdapter,
    UINT            iMode,
    D3DDISPLAYMODE* pMode)
{
    API_ENTER(this);

    if (iAdapter >= m_cAdapter)
    {
        DPF_ERR("Invalid adapter specified. EnumAdapterModes fails.");
        return D3DERR_INVALIDCALL;
    }

    if (iMode >= m_AdapterInfo[iAdapter].NumModes)
    {
        DPF_ERR("Invalid mode number specified. EnumAdapterModes fails.");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_WRITEPTR(pMode, sizeof(D3DDISPLAYMODE)))
    {
        DPF_ERR("Invalid pMode parameter specified for EnumAdapterModes");
        return D3DERR_INVALIDCALL;
    }

    *pMode = m_AdapterInfo[iAdapter].pModeTable[iMode];

    return D3D_OK;
} // EnumAdapterModes

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::GetAdapterMonitor"

HMONITOR CEnum::GetAdapterMonitor(UINT iAdapter)
{
    API_ENTER_RET(this, HMONITOR);

    if (iAdapter >= m_cAdapter)
    {
        DPF_ERR("Invalid adapter specified. GetAdapterMonitor returns NULL");
        return NULL;
    }

    return GetMonitorFromDeviceName((LPSTR)m_AdapterInfo[iAdapter].DeviceName);
} // GetAdapterMonitor

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::CheckDeviceFormat"

STDMETHODIMP CEnum::CheckDeviceFormat(
    UINT            iAdapter,
    D3DDEVTYPE      DevType,
    D3DFORMAT       DisplayFormat,
    DWORD           Usage,
    D3DRESOURCETYPE RType,
    D3DFORMAT       CheckFormat)
{
    API_ENTER(this);

    D3D8_DRIVERCAPS*    pAdapterCaps;
    HRESULT             hr;

    // Check parameters
    if (iAdapter >= m_cAdapter)
    {
        DPF_ERR("Invalid adapter specified. CheckDeviceFormat fails");
        return D3DERR_INVALIDCALL;
    }

    // Check Device Type
    if (DevType != D3DDEVTYPE_REF &&
        DevType != D3DDEVTYPE_HAL &&
        DevType != D3DDEVTYPE_SW)
    {
        DPF_ERR("Invalid device specified to CheckDeviceFormat");
        return D3DERR_INVALIDCALL;
    }

    if ((DisplayFormat == D3DFMT_UNKNOWN) ||
        (CheckFormat == D3DFMT_UNKNOWN))
    {
        DPF(0, "D3DFMT_UNKNOWN is not a valid format.");
        return D3DERR_INVALIDCALL;
    }

    // Sanity check the input format
    if ((DisplayFormat != D3DFMT_X8R8G8B8) &&
        (DisplayFormat != D3DFMT_R5G6B5) &&
        (DisplayFormat != D3DFMT_X1R5G5B5) &&
        (DisplayFormat != D3DFMT_R8G8B8))
    {
        DPF(1, "D3D Unsupported for the adapter format passed to CheckDeviceFormat");
        return D3DERR_NOTAVAILABLE;
    }

    //We infer the texture usage from type...
    if (RType == D3DRTYPE_TEXTURE ||
        RType == D3DRTYPE_CUBETEXTURE ||
        RType == D3DRTYPE_VOLUMETEXTURE)
    {
        Usage |= D3DUSAGE_TEXTURE;
    }

    // Surface should be either render targets or Z/Stencil
    else if (RType == D3DRTYPE_SURFACE)
    {
        if (!(Usage & D3DUSAGE_DEPTHSTENCIL) &&
            !(Usage & D3DUSAGE_RENDERTARGET))
        {
            DPF_ERR("Must specify either D3DUSAGE_DEPTHSTENCIL or D3DUSAGE_RENDERTARGET for D3DRTYPE_SURFACE. CheckDeviceFormat fails.");
            return D3DERR_INVALIDCALL;
        }
    }

    // Any attempt to query anything but an unknown Z/stencil
    // or D16 value must fail (because we explicitly don't allow apps to
    // know what the z/stencil format really is, except for D16).

    if (Usage & D3DUSAGE_DEPTHSTENCIL)
    {
        if (!CPixel::IsEnumeratableZ(CheckFormat))
        {
            DPF_ERR("Format is not in approved list for Z buffer formats. CheckDeviceFormats fails.");
            return D3DERR_INVALIDCALL;
        }
    }

    // Parameter check for invalid usages and resource types

    if ((RType != D3DRTYPE_SURFACE) &&
        (RType != D3DRTYPE_VOLUME) &&
        (RType != D3DRTYPE_TEXTURE) &&
        (RType != D3DRTYPE_VOLUMETEXTURE) &&
        (RType != D3DRTYPE_CUBETEXTURE))
    {
        DPF_ERR("Invalid resource type specified. CheckDeviceFormat fails.");
        return D3DERR_INVALIDCALL;
    }

    if (Usage & ~(D3DUSAGE_EXTERNAL |
                  D3DUSAGE_LOCK |
                  D3DUSAGE_TEXTURE |
                  D3DUSAGE_BACKBUFFER |
                  D3DUSAGE_INTERNALBUFFER |
                  D3DUSAGE_OFFSCREENPLAIN |
                  D3DUSAGE_PRIMARYSURFACE))
    {
        DPF_ERR("Invalid usage flag specified. CheckDeviceFormat fails.");
        return D3DERR_INVALIDCALL;
    }

    hr = GetAdapterCaps(iAdapter,
                        DevType,
                        &pAdapterCaps);
    if (FAILED(hr))
    {
        return hr;
    }

    // Check if USAGE_DYNAMIC is allowed
    if ((Usage & D3DUSAGE_DYNAMIC) && (Usage & D3DUSAGE_TEXTURE))
    {
        if (!(pAdapterCaps->D3DCaps.Caps2 & D3DCAPS2_DYNAMICTEXTURES))
        {
            DPF_ERR("Driver does not support dynamic textures.");
            return D3DERR_INVALIDCALL;
        }
        if (Usage & (D3DUSAGE_RENDERTARGET | D3DUSAGE_DEPTHSTENCIL))
        {
            DPF_ERR("Dynamic textures cannot be rendertargets or depth/stencils.");
            return D3DERR_INVALIDCALL;
        }
    }

    // Make sure that the specified display format is supported
    
    if (!IsSupportedOp (DisplayFormat, 
                        pAdapterCaps->pGDD8SupportedFormatOps, 
                        pAdapterCaps->GDD8NumSupportedFormatOps, 
                        D3DFORMAT_OP_DISPLAYMODE |D3DFORMAT_OP_3DACCELERATION))
    {
        return D3DERR_NOTAVAILABLE;
    }

    //We now need to map the API desires to the set of capabilities that we
    //allow drivers to express in their DX8 pixel format operation list.
    DWORD dwRequiredOperations=0;

    //We have three different texturing methodologies that the driver may
    //support independently
    switch(RType)
    {
    case D3DRTYPE_TEXTURE:
        dwRequiredOperations |= D3DFORMAT_OP_TEXTURE;
        break;
    case D3DRTYPE_VOLUMETEXTURE:
        dwRequiredOperations |= D3DFORMAT_OP_VOLUMETEXTURE;
        break;
    case D3DRTYPE_CUBETEXTURE:
        dwRequiredOperations |= D3DFORMAT_OP_CUBETEXTURE;
        break;
    }

    // If it's a depth/stencil, make sure it's a format that the driver understands
    CheckFormat = MapDepthStencilFormat(iAdapter,
                                        DevType, 
                                        CheckFormat);

    //Render targets may be the same format as the display, or they may
    //be different

    if (Usage & D3DUSAGE_RENDERTARGET)
    {
        if (DisplayFormat == CheckFormat)
        {
            // We have a special cap for the case when the offscreen is the
            // same format as the display
            dwRequiredOperations |= D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET;
        }
        else if ((CPixel::SuppressAlphaChannel(CheckFormat) != CheckFormat) &&  //offscreen has alpha
                 (CPixel::SuppressAlphaChannel(CheckFormat) == DisplayFormat))  //offscreen is same as display mod alpha
        {
            //We have a special cap for the case when the offscreen is the same
            //format as the display modulo the alpha channel
            //(such as X8R8G8B8 for the primary and A8R8G8B8 for the offscreen).
            dwRequiredOperations |= D3DFORMAT_OP_SAME_FORMAT_UP_TO_ALPHA_RENDERTARGET;
        }
        else
        {
            dwRequiredOperations |= D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
        }
    }

    //Some hardware doesn't support Z and color buffers of differing pixel depths.
    //We only do this check on known z/stencil formats, since drivers are free
    //to spoof unknown formats (they can't be locked).

    // Now we know what we're being asked to do on this format...
    // let's run through the driver's list and see if it can do it.
    for(UINT i=0;i< pAdapterCaps->GDD8NumSupportedFormatOps; i++)
    {
        // We need a match for format, plus all the requested operation flags
        if ((CheckFormat ==
                (D3DFORMAT) pAdapterCaps->pGDD8SupportedFormatOps[i].ddpfPixelFormat.dwFourCC) &&
            (dwRequiredOperations == (dwRequiredOperations &
                        pAdapterCaps->pGDD8SupportedFormatOps[i].ddpfPixelFormat.dwOperations)))
        {
            return D3D_OK;
        }
    }

    // We don't spew info here; because NotAvailable is a reasonable
    // usage of the API; this doesn't reflect an app bug or an
    // anomalous circumstance where a message would be useful
    return D3DERR_NOTAVAILABLE;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::CheckDeviceType"

STDMETHODIMP CEnum::CheckDeviceType(
    UINT                iAdapter,
    D3DDEVTYPE          DevType,
    D3DFORMAT           DisplayFormat,
    D3DFORMAT           BackBufferFormat,
    BOOL                bWindowed)
{
    API_ENTER(this);

    D3D8_DRIVERCAPS*    pAdapterCaps;
    HRESULT             hr;

    if (iAdapter >= m_cAdapter)
    {
        DPF_ERR("Invalid adapter specified. CheckDeviceType fails.");
        return D3DERR_INVALIDCALL;
    }

    if (DevType != D3DDEVTYPE_REF &&
        DevType != D3DDEVTYPE_HAL &&
        DevType != D3DDEVTYPE_SW)
    {
        DPF_ERR("Invalid device specified to CheckDeviceType");
        return D3DERR_INVALIDCALL;
    }

    if ((DisplayFormat == D3DFMT_UNKNOWN) ||
        (BackBufferFormat == D3DFMT_UNKNOWN))
    {
        DPF(0, "D3DFMT_UNKNOWN is not a valid format.");
        return D3DERR_INVALIDCALL;
    }

    // Force the backbuffer format to be one of the 16 or 32bpp formats (not
    // 24bpp). We do this because DX8 shipped with a similar check in Reset, 
    // and we want to be consistent.

    if ((BackBufferFormat != D3DFMT_X1R5G5B5) &&
        (BackBufferFormat != D3DFMT_A1R5G5B5) &&
        (BackBufferFormat != D3DFMT_R5G6B5) &&
        (BackBufferFormat != D3DFMT_X8R8G8B8) &&
        (BackBufferFormat != D3DFMT_A8R8G8B8))
    {
        // We should return D3DDERR_INVALIDCALL, but we didn't ship that way for
        // DX8 and we don't want to cause regressions, so NOTAVAILABLE is safer.
        DPF(1, "Invalid backbuffer format specified");
        return D3DERR_NOTAVAILABLE;
    }

    // Sanity check the input format
    if ((DisplayFormat != D3DFMT_X8R8G8B8) &&
        (DisplayFormat != D3DFMT_R5G6B5) &&
        (DisplayFormat != D3DFMT_X1R5G5B5) &&
        (DisplayFormat != D3DFMT_R8G8B8))
    {
        DPF(1, "D3D Unsupported for the adapter format passed to CheckDeviceType");
        return D3DERR_NOTAVAILABLE;
    }

    hr = GetAdapterCaps(iAdapter,
                        DevType,
                        &pAdapterCaps);
    if (FAILED(hr))
    {
        return hr;
    }

    // Is the display mode supported?

    if (!IsSupportedOp (DisplayFormat, 
                        pAdapterCaps->pGDD8SupportedFormatOps, 
                        pAdapterCaps->GDD8NumSupportedFormatOps, 
                        D3DFORMAT_OP_DISPLAYMODE |D3DFORMAT_OP_3DACCELERATION))
    {
        return D3DERR_NOTAVAILABLE;
    }


    if (DisplayFormat != BackBufferFormat)
    {
        D3DFORMAT   AlphaFormat = D3DFMT_UNKNOWN;
        UINT        i;

        // This is allowed only if the only difference is alpha.

        switch (DisplayFormat)
        {
        case D3DFMT_X1R5G5B5:
            AlphaFormat = D3DFMT_A1R5G5B5;
            break;

        case D3DFMT_X8R8G8B8:
            AlphaFormat = D3DFMT_A8R8G8B8;
            break;
        }

        hr = D3DERR_NOTAVAILABLE;
        if (AlphaFormat == BackBufferFormat)
        {
            if (IsSupportedOp (AlphaFormat, 
                               pAdapterCaps->pGDD8SupportedFormatOps, 
                               pAdapterCaps->GDD8NumSupportedFormatOps, 
                               D3DFORMAT_OP_SAME_FORMAT_UP_TO_ALPHA_RENDERTARGET))
            {
                hr = D3D_OK;
            }
        }
    }
    else
    {
        // For DX8, we force the backbuffer and display formats to match
        // (minus alpha).  This means that they should support a render target
        // of the same format.

        if (!IsSupportedOp (DisplayFormat, 
                            pAdapterCaps->pGDD8SupportedFormatOps, 
                            pAdapterCaps->GDD8NumSupportedFormatOps, 
                            D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET))
        {
            return D3DERR_NOTAVAILABLE;
        }
    }

    if (SUCCEEDED(hr))
    {
        if (bWindowed &&
            !(pAdapterCaps->D3DCaps.Caps2 & DDCAPS2_CANRENDERWINDOWED))
        {
            hr = D3DERR_NOTAVAILABLE;
        }
    }

    return hr;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::GetAdapterDisplayMode"


STDMETHODIMP CEnum::GetAdapterDisplayMode(UINT iAdapter, D3DDISPLAYMODE* pMode)
{
    API_ENTER(this);

    HANDLE      h;
    HRESULT     hr = D3D_OK;

    if (iAdapter >= m_cAdapter)
    {
        DPF_ERR("Invalid adapter specified. GetAdapterDisplayMode fails");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_WRITEPTR(pMode, sizeof(D3DDISPLAYMODE)))
    {
        DPF_ERR("Invalid pMode parameter specified for GetAdapterDisplayMode");
        return D3DERR_INVALIDCALL;
    }

    if (m_AdapterInfo[iAdapter].bIsDisplay)
    {
        D3D8GetMode (NULL, m_AdapterInfo[iAdapter].DeviceName, pMode, m_AdapterInfo[iAdapter].Unknown16);
    }
    else
    {
        PD3D8_DEVICEDATA    pDeviceData;

        hr = InternalDirectDrawCreate(&pDeviceData,
                                      &m_AdapterInfo[iAdapter],
                                      D3DDEVTYPE_HAL,
                                      NULL,
                                      m_AdapterInfo[iAdapter].Unknown16,
                                      m_AdapterInfo[iAdapter].HALCaps.pGDD8SupportedFormatOps,
                                      m_AdapterInfo[iAdapter].HALCaps.GDD8NumSupportedFormatOps);
        if (SUCCEEDED(hr))
        {
            D3D8GetMode (pDeviceData->hDD, m_AdapterInfo[iAdapter].DeviceName, pMode, D3DFMT_UNKNOWN);
            InternalDirectDrawRelease(pDeviceData);
        }
    }

    return hr;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::EnumDeviceMultiSampleType"


STDMETHODIMP CEnum::CheckDeviceMultiSampleType(
    UINT                iAdapter,
    D3DDEVTYPE          DevType,
    D3DFORMAT           RTFormat,
    BOOL                Windowed,
    D3DMULTISAMPLE_TYPE SampleType)
{
    API_ENTER(this);

    // Check parameters
    if (iAdapter >= m_cAdapter)
    {
        DPF_ERR("Invalid adapter specified. CheckDeviceMultiSampleType fails.");
        return D3DERR_INVALIDCALL;
    }

    // Check Device Type
    if (DevType != D3DDEVTYPE_REF &&
        DevType != D3DDEVTYPE_HAL &&
        DevType != D3DDEVTYPE_SW)
    {
        DPF_ERR("Invalid device specified to CheckDeviceMultiSampleType");
        return D3DERR_INVALIDCALL;
    }

    if (RTFormat == D3DFMT_UNKNOWN)
    {
        DPF_ERR("D3DFMT_UNKNOWN is not a valid format. CheckDeviceMultiSampleType fails.");
        return D3DERR_INVALIDCALL;
    }

    D3D8_DRIVERCAPS*    pAdapterCaps;
    HRESULT             hr;

    hr = GetAdapterCaps(iAdapter,
                        DevType,
                        &pAdapterCaps);
    if (FAILED(hr))
    {
        return hr;
    }

    if (SampleType == D3DMULTISAMPLE_NONE)
    {
        return D3D_OK;
    }
    else if (SampleType == 1)
    {
        DPF_ERR("Invalid sample type specified. Only enumerated values are supported. CheckDeviceMultiSampleType fails.");
        return D3DERR_INVALIDCALL;
    }
    else if (SampleType > D3DMULTISAMPLE_16_SAMPLES)
    {
        DPF_ERR("Invalid sample type specified. CheckDeviceMultiSampleType fails.");
        return D3DERR_INVALIDCALL;
    }

    // Treat Ref/SW Fullscreen the same as Windowed.
    if (DevType == D3DDEVTYPE_REF ||
        DevType == D3DDEVTYPE_SW)
    {
        Windowed = TRUE;
    }

    // If it's a depth/stencil, make sure it's a format that the driver understands
    RTFormat = MapDepthStencilFormat(iAdapter,
                                     DevType, 
                                     RTFormat);

    DDSURFACEDESC * pDX8SupportedFormatOperations =
        pAdapterCaps->pGDD8SupportedFormatOps;

    // let's run through the driver's list and see if it can do it.
    for (UINT i = 0; i < pAdapterCaps->GDD8NumSupportedFormatOps; i++)
    {
        //We need a match for format, plus all either blt or flip caps
        if (RTFormat == (D3DFORMAT) pDX8SupportedFormatOperations[i].ddpfPixelFormat.dwFourCC)
        {
            // Found the format in question... do we have the MS caps?
            WORD wMSOps = Windowed ?
                pDX8SupportedFormatOperations[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes :
                pDX8SupportedFormatOperations[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes;

            // To determine the bit to use, we map the set of sample-types [2-16] to
            // a particular (bit 1 to bit 15) of the WORD.
            DXGASSERT(SampleType > 1);
            DXGASSERT(SampleType <= 16);
            if (wMSOps & DDI_MULTISAMPLE_TYPE(SampleType))
            {
                return D3D_OK;
            }
        }
    }

    return D3DERR_NOTAVAILABLE;

} // CheckDeviceMultiSampleType


#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::CheckDepthStencilMatch"

STDMETHODIMP CEnum::CheckDepthStencilMatch(UINT        iAdapter, 
                                           D3DDEVTYPE  DevType, 
                                           D3DFORMAT   AdapterFormat, 
                                           D3DFORMAT   RTFormat, 
                                           D3DFORMAT   DSFormat)
{
    API_ENTER(this);

    HRESULT hr;

    // Check parameters
    if (iAdapter >= m_cAdapter)
    {
        DPF_ERR("Invalid adapter specified. CheckDepthStencilMatch fails.");
        return D3DERR_INVALIDCALL;
    }

    // Check Device Type
    if (DevType != D3DDEVTYPE_REF &&
        DevType != D3DDEVTYPE_HAL &&
        DevType != D3DDEVTYPE_SW)
    {
        DPF_ERR("Invalid device specified to CheckDepthStencilMatch");
        return D3DERR_INVALIDCALL;
    }

    if ((AdapterFormat == D3DFMT_UNKNOWN) ||
        (RTFormat == D3DFMT_UNKNOWN) ||
        (DSFormat == D3DFMT_UNKNOWN))
    {
        DPF_ERR("D3DFMT_UNKNOWN is not a valid format. CheckDepthStencilMatch fails.");
        return D3DERR_INVALIDCALL;
    }

    D3D8_DRIVERCAPS *pAdapterCaps = NULL;
    hr = GetAdapterCaps(iAdapter,
                        DevType,
                        &pAdapterCaps);
    if (FAILED(hr))
    {
        return hr;
    }

    // Is the display mode supported?

    if (!IsSupportedOp (AdapterFormat, 
                        pAdapterCaps->pGDD8SupportedFormatOps, 
                        pAdapterCaps->GDD8NumSupportedFormatOps, 
                        D3DFORMAT_OP_DISPLAYMODE |D3DFORMAT_OP_3DACCELERATION))
    {
        return D3DERR_NOTAVAILABLE;
    }

    DDSURFACEDESC * pDX8SupportedFormatOperations =
        pAdapterCaps->pGDD8SupportedFormatOps;

    // Decide what we need to check
    BOOL bCanDoRT = FALSE;
    BOOL bCanDoDS = FALSE;
    BOOL bMatchNeededForDS = FALSE;

    // We only need to check for matching if the user is trying
    // to use D3DFMT_D16 or has Stencil
    if (DSFormat == D3DFMT_D16_LOCKABLE ||
        CPixel::HasStencilBits(DSFormat))
    {
        bMatchNeededForDS = TRUE;
    }

    //In DX8.1 and beyond, we also make this function check D24X8 and D32, since all known parts that have restrictions
    //also have this restriction
    if (GetAppSdkVersion() > D3D_SDK_VERSION_DX8)
    {
        switch (DSFormat)
        {
        case D3DFMT_D24X8:
        case D3DFMT_D32:
            bMatchNeededForDS = TRUE;
        }
    }

    DWORD dwRequiredZOps = D3DFORMAT_OP_ZSTENCIL;

    // If it's a depth/stencil, make sure it's a format that the driver understands
    DSFormat = MapDepthStencilFormat(iAdapter,
                                     DevType, 
                                     DSFormat);

    // let's run through the driver's list and see if this all
    // works
    for (UINT i = 0; i < pAdapterCaps->GDD8NumSupportedFormatOps; i++)
    {
        // See if it matches the RT format
        if (RTFormat == (D3DFORMAT) pDX8SupportedFormatOperations[i].ddpfPixelFormat.dwFourCC)
        {
            // Found the RT Format, can we use as a render-target?
            // we check the format that has the least constraints so that
            // we are truly checking "For all possible RTs that I can make
            // with this device, does the Z match it?" We'd like to say
            // "No." if you couldn't make the RT at all in any circumstance.
            if (D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET &
                pAdapterCaps->pGDD8SupportedFormatOps[i].ddpfPixelFormat.dwOperations)
            {
                bCanDoRT = TRUE;
            }

        }

        // See if it matches the DS Format
        if (DSFormat == (D3DFORMAT) pDX8SupportedFormatOperations[i].ddpfPixelFormat.dwFourCC)
        {
            // Found the DS format, can we use it as DS (and potentially lockable)?
            // i.e. if ALL required bits are on in this FOL entry.
            // Again, we check the formats that have the least constraints.
            if (dwRequiredZOps == 
                (dwRequiredZOps & pAdapterCaps->pGDD8SupportedFormatOps[i].ddpfPixelFormat.dwOperations) )
            {
                bCanDoDS = TRUE;

                if (D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH &
                    pAdapterCaps->pGDD8SupportedFormatOps[i].ddpfPixelFormat.dwOperations)
                {
                    bMatchNeededForDS = FALSE;
                }
            }
        }
    }

    if (!bCanDoRT)
    {
        DPF_ERR("RenderTarget Format is not supported for this "
                "Adapter/DevType/AdapterFormat. This error can happen if the "
                "application has not successfully called CheckDeviceFormats on the "
                "specified Format prior to calling CheckDepthStencilMatch. The application "
                "is advised to call CheckDeviceFormats on this format first, because a "
                "success return from CheckDepthStencilMatch does not guarantee "
                "that the format is valid as a RenderTarget for all possible cases "
                "i.e. D3DRTYPE_TEXTURE or D3DRTYPE_SURFACE or D3DRTYPE_CUBETEXTURE.");
        return D3DERR_INVALIDCALL;
    }
    if (!bCanDoDS)
    {
        DPF_ERR("DepthStencil Format is not supported for this "
                "Adapter/DevType/AdapterFormat. This error can happen if the "
                "application has not successfully called CheckDeviceFormats on the "
                "specified Format prior to calling CheckDepthStencilMatch. The application "
                "is advised to call CheckDeviceFormats on this format first, because a "
                "success return from CheckDepthStencilMatch does not guarantee "
                "that the format is valid as a DepthStencil buffer for all possible cases "
                "i.e. D3DRTYPE_TEXTURE or D3DRTYPE_SURFACE or D3DRTYPE_CUBETEXTURE.");
        return D3DERR_INVALIDCALL;
    }
    if (bMatchNeededForDS)
    {
        // Check if the DS depth matches the RT depth
        if (CPixel::ComputePixelStride(RTFormat) !=
            CPixel::ComputePixelStride(DSFormat))
        {
            DPF(1, "Specified DepthStencil Format can not be used with RenderTarget Format");
            return D3DERR_NOTAVAILABLE;
        }
    }

    // Otherwise, we now know that the both the RT and DS formats
    // are valid and that they match if they need to.
    DXGASSERT(bCanDoRT && bCanDoDS);

    return S_OK;
} // CheckDepthStencilMatch


#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::FillInCaps"

void CEnum::FillInCaps (D3DCAPS8              *pCaps,
                        const D3D8_DRIVERCAPS *pDriverCaps,
                        D3DDEVTYPE             Type,
                        UINT                   AdapterOrdinal) const
{
    memset(pCaps, 0, sizeof(D3DCAPS8));

    //
    // do 3D caps first so we can copy the struct and clear the (few) non-3D fields
    //
    if (pDriverCaps->dwFlags & DDIFLAG_D3DCAPS8)
    {
        // set 3D fields from caps8 struct from driver
        *pCaps = pDriverCaps->D3DCaps;

        if (Type == D3DDEVTYPE_HAL)
        {
            pCaps->DevCaps |= D3DDEVCAPS_HWRASTERIZATION;
        }

    }
    else
    {
        // ASSERT here
        DDASSERT(FALSE);
    }

    //
    // non-3D caps
    //

    pCaps->DeviceType = Type;
    pCaps->AdapterOrdinal = AdapterOrdinal;

    pCaps->Caps = pDriverCaps->D3DCaps.Caps &
        (DDCAPS_READSCANLINE |
         DDCAPS_NOHARDWARE);
    pCaps->Caps2 = pDriverCaps->D3DCaps.Caps2 &
        (DDCAPS2_NO2DDURING3DSCENE |
         DDCAPS2_PRIMARYGAMMA |
         DDCAPS2_CANRENDERWINDOWED |
         DDCAPS2_STEREO |
         DDCAPS2_DYNAMICTEXTURES |
#ifdef WINNT
         (IsWhistler() ? DDCAPS2_CANMANAGERESOURCE : 0));
#else
         DDCAPS2_CANMANAGERESOURCE);
#endif

    // Special case: gamma calibrator is loaded by the enumerator...
    if (m_bGammaCalibratorExists)
        pCaps->Caps2 |= DDCAPS2_CANCALIBRATEGAMMA;

    pCaps->Caps3 = pDriverCaps->D3DCaps.Caps3 & ~D3DCAPS3_RESERVED; //mask off the old stereo flags.

    pCaps->PresentationIntervals = D3DPRESENT_INTERVAL_ONE;
    if (pDriverCaps->D3DCaps.Caps2 & DDCAPS2_FLIPINTERVAL)
    {
        pCaps->PresentationIntervals |=
            (D3DPRESENT_INTERVAL_TWO |
             D3DPRESENT_INTERVAL_THREE |
             D3DPRESENT_INTERVAL_FOUR);
    }
    if (pDriverCaps->D3DCaps.Caps2 & DDCAPS2_FLIPNOVSYNC)
    {
        pCaps->PresentationIntervals |=
            (D3DPRESENT_INTERVAL_IMMEDIATE);
    }

    // Mask out the HW VB and IB caps
    pCaps->DevCaps &= ~(D3DDEVCAPS_HWVERTEXBUFFER | D3DDEVCAPS_HWINDEXBUFFER);

    // Clear internal caps
    pCaps->PrimitiveMiscCaps &= ~D3DPMISCCAPS_FOGINFVF;

    // Fix up the vertex fog cap.
    if (pCaps->VertexProcessingCaps & D3DVTXPCAPS_RESERVED)
    {
        pCaps->RasterCaps |= D3DPRASTERCAPS_FOGVERTEX;
        pCaps->VertexProcessingCaps &= ~D3DVTXPCAPS_RESERVED;
    }

} // FillInCaps

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::GetDeviceCaps"

STDMETHODIMP CEnum::GetDeviceCaps(
    UINT            iAdapter,
    D3DDEVTYPE      Type,
    D3DCAPS8       *pCaps)
{
    API_ENTER(this);

    BOOL                bValidRTFormat;
    D3DFORMAT           Format;
    D3D8_DRIVERCAPS*    pAdapterCaps;
    HRESULT             hr;
    DWORD               i;

    if (iAdapter >= m_cAdapter)
    {
        DPF_ERR("Invalid adapter specified. GetDeviceCaps fails.");
        return D3DERR_INVALIDCALL;
    }
    if (!VALID_WRITEPTR(pCaps, sizeof(D3DCAPS8)))
    {
        DPF_ERR("Invalid pointer to D3DCAPS8 specified. GetDeviceCaps fails.");
        return D3DERR_INVALIDCALL;
    }

    hr = GetAdapterCaps(iAdapter,
                        Type,
                        &pAdapterCaps);
    if (FAILED(hr))
    {
        // No caps for this type of device
        memset(pCaps, 0, sizeof(D3DCAPS8));
        return hr;
    }

    // Fail this call if the driver dosn't support any accelerated modes

    for (i = 0; i < pAdapterCaps->GDD8NumSupportedFormatOps; i++)
    {
        if (pAdapterCaps->pGDD8SupportedFormatOps[i].ddpfPixelFormat.dwOperations & D3DFORMAT_OP_3DACCELERATION)
        {
            break;
        }
    }
    if (i == pAdapterCaps->GDD8NumSupportedFormatOps)
    {
        // No caps for this type of device
        memset(pCaps, 0, sizeof(D3DCAPS8));
        return D3DERR_NOTAVAILABLE;
    }

    FillInCaps (pCaps,
                pAdapterCaps,
                Type,
                iAdapter);

    if (pCaps->MaxPointSize == 0)
    {
        pCaps->MaxPointSize = 1.0f; 
    }

    return D3D_OK;
} // GetDeviceCaps

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::LoadAndCallGammaCalibrator"

void CEnum::LoadAndCallGammaCalibrator(
        D3DGAMMARAMP *pRamp,
        UCHAR * pDeviceName)
{
    API_ENTER_VOID(this);

    if (!m_bAttemptedGammaCalibrator)
    {
        m_bAttemptedGammaCalibrator = TRUE;

        m_hGammaCalibrator = LoadLibrary((char*) m_szGammaCalibrator);
        if (m_hGammaCalibrator)
        {
            m_pGammaCalibratorProc = (LPDDGAMMACALIBRATORPROC)
                GetProcAddress(m_hGammaCalibrator, "CalibrateGammaRamp");

            if (m_pGammaCalibratorProc == NULL)
            {
                FreeLibrary((HMODULE) m_hGammaCalibrator);
                m_hGammaCalibrator = NULL;
            }
        }
    }

    if (m_pGammaCalibratorProc)
    {
        m_pGammaCalibratorProc((LPDDGAMMARAMP) pRamp, pDeviceName);
    }
} // LoadAndCallGammaCalibrator

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::RegisterSoftwareDevice"

STDMETHODIMP CEnum::RegisterSoftwareDevice(
        void*       pInitFunction)
{
    HRESULT         hr;

    API_ENTER(this);

    if (pInitFunction == NULL)
    {
        DPF_ERR("Invalid initialization function specified. RegisterSoftwareDevice fails.");
        return D3DERR_INVALIDCALL;
    }
    if (m_pSwInitFunction != NULL)
    {
        DPF_ERR("A software device is already registered.");
        return D3DERR_INVALIDCALL;
    }
    if (m_cAdapter == 0)
    {
        DPF_ERR("No display devices are available.");
        return D3DERR_NOTAVAILABLE;
    }

    hr = AddSoftwareDevice(D3DDEVTYPE_SW, &m_SwCaps[0], &m_AdapterInfo[0], pInitFunction);
    if (SUCCEEDED(hr))
    {
        m_pSwInitFunction = pInitFunction;
    }

    if (FAILED(hr))
    {
        DPF_ERR("RegisterSoftwareDevice fails");
    }

    return hr;

} // RegisterSoftwareDevice

#ifdef WINNT
#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::FocusWindow"

HWND CEnum::ExclusiveOwnerWindow()
{
    API_ENTER_RET(this, HWND);
    for (UINT iAdapter = 0; iAdapter < m_cAdapter; iAdapter++)
    {
        CBaseDevice *pDevice = m_pFullScreenDevice[iAdapter];
        if (pDevice)
        {
            return pDevice->FocusWindow();
        }
    }
    return NULL;
} // FocusWindow

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::SetFullScreenDevice"
void CEnum::SetFullScreenDevice(UINT         iAdapter,
                                CBaseDevice *pDevice)
{
    API_ENTER_VOID(this);

    if (m_pFullScreenDevice[iAdapter] != pDevice)
    { 
        DDASSERT(NULL == m_pFullScreenDevice[iAdapter] || NULL == pDevice);
        m_pFullScreenDevice[iAdapter] = pDevice;
        if (NULL == pDevice && NULL == ExclusiveOwnerWindow() && m_bHasExclusive)
        {
            m_bHasExclusive = FALSE;
            DXReleaseExclusiveModeMutex();
        }
    }
} // SetFullScreenDevice

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::CheckExclusiveMode"
BOOL CEnum::CheckExclusiveMode(
    CBaseDevice* pDevice,
    LPBOOL pbThisDeviceOwnsExclusive, 
    BOOL bKeepMutex)
{
    DWORD   dwWaitResult;
    BOOL    bExclusiveExists=FALSE; 

    WaitForSingleObject(hCheckExclusiveModeMutex, INFINITE);

    dwWaitResult = WaitForSingleObject(hExclusiveModeMutex, 0);

    if (dwWaitResult == WAIT_OBJECT_0)
    {
        /*
         * OK, so this process now owns the exclusive mode object,
         * Have we taken the Mutex already ?
         */
        if (m_bHasExclusive)
        {
            bExclusiveExists = TRUE;
            bKeepMutex = FALSE;    
        }
        else
        {
            bExclusiveExists = FALSE;
        }
        if (pbThisDeviceOwnsExclusive && pDevice)
        {
            if (bExclusiveExists &&
                (pDevice == m_pFullScreenDevice[pDevice->AdapterIndex()]
                || NULL == m_pFullScreenDevice[pDevice->AdapterIndex()]) &&
                pDevice->FocusWindow() == ExclusiveOwnerWindow()
                )
            {
                *pbThisDeviceOwnsExclusive = TRUE;
            }
            else
            {
                *pbThisDeviceOwnsExclusive = FALSE;
            }
        }
        /*
         * Undo the temporary ref we just took on the mutex to check its state, if we're not actually
         * taking ownership. We are not taking ownership if we already have ownership. This means this routine
         * doesn't allow more than one ref on the exclusive mode mutex.
         */
        if (!bKeepMutex)
        {
            ReleaseMutex(hExclusiveModeMutex);
        }
        else
        {
            m_bHasExclusive = TRUE;
        }
    }
    else if (dwWaitResult == WAIT_TIMEOUT)
    {
        bExclusiveExists = TRUE;
        if (pbThisDeviceOwnsExclusive)
            *pbThisDeviceOwnsExclusive = FALSE;
    }
    else if (dwWaitResult == WAIT_ABANDONED)
    {
        /*
         * Some other thread lost exclusive mode. We have now picked it up.
         */
        bExclusiveExists = FALSE;
        if (pbThisDeviceOwnsExclusive)
            *pbThisDeviceOwnsExclusive = FALSE;
        /*
         * Undo the temporary ref we just took on the mutex to check its state, if we're not actually
         * taking ownership.
         */
        if (!bKeepMutex)
        {
            ReleaseMutex(hExclusiveModeMutex);
        }
        else
        {
            m_bHasExclusive = TRUE;
        }
    }

    ReleaseMutex(hCheckExclusiveModeMutex);

    return bExclusiveExists;
} // CheckExclusiveMode

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::DoneExclusiveMode"  
/*
 * DoneExclusiveMode
 */
void
CEnum::DoneExclusiveMode()
{
    UINT    iAdapter;
    for (iAdapter=0;iAdapter < m_cAdapter;iAdapter++)
    {
        CBaseDevice* pDevice = m_pFullScreenDevice[iAdapter];
        if (pDevice)
        {
            pDevice->SwapChain()->DoneExclusiveMode(TRUE);
        }
    }
    m_bHasExclusive = FALSE;

    DXReleaseExclusiveModeMutex();

} /* DoneExclusiveMode */

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::StartExclusiveMode"  
/*
 * StartExclusiveMode
 */
void 
CEnum::StartExclusiveMode()
{
    UINT    iAdapter;
    for (iAdapter=0;iAdapter<m_cAdapter;iAdapter++)
    {
        CBaseDevice* pDevice = m_pFullScreenDevice[iAdapter];
        if (pDevice)
        {
            pDevice->SwapChain()->StartExclusiveMode(TRUE);
        }
    }
} /* StartExclusiveMode */

#endif // WINNT

// End of file : enum.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\fcache.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       enum.cpp
 *  Content     Handles all of the file caching of device caps.
 *
 *
 ***************************************************************************/
#include "ddrawpr.h"
#include <stdio.h>

#include "d3dobj.hpp"
#include "enum.hpp"
#include "d3di.hpp"
#include "shlobj.h"

#define DXCACHEFILENAME     "\\d3d8caps.dat"
#define DXTEMPFILENAME      "\\d3d8caps.tmp"

typedef struct _FDEVICEHEADER
{
    DWORD   VendorId;
    DWORD   DeviceId;
    DWORD   SubSysId;
    DWORD   Revision;
    DWORD   FileOffset;
    DWORD   Size;
} FDEVICEHEADER;

HANDLE OpenCacheFile(DWORD dwDesiredAccess, DWORD dwCreationDisposition, char * pName, char * pPath)
{
    char                    FName[MAX_PATH + 16];

    GetSystemDirectory(FName, MAX_PATH);

    lstrcat(FName, pName);

    HANDLE h = CreateFile( FName, 
                       dwDesiredAccess, 
                       FILE_SHARE_READ, 
                       NULL, 
                       dwCreationDisposition, 
                       FILE_ATTRIBUTE_NORMAL, 
                       NULL);
#ifdef WINNT
    if (INVALID_HANDLE_VALUE == h)
    {
        HMODULE hShlwapi=0;
        typedef HRESULT (WINAPI * PSHGETSPECIALFOLDERPATH) (HWND, LPTSTR, int, BOOL);
        PSHGETSPECIALFOLDERPATH pSHGetSpecialFolderPath=0;

        hShlwapi = LoadLibrary("SHELL32.DLL");
        if (hShlwapi)
        {
            pSHGetSpecialFolderPath = (PSHGETSPECIALFOLDERPATH) GetProcAddress(hShlwapi,"SHGetSpecialFolderPathA");

            if(pSHGetSpecialFolderPath)
            {
                HRESULT hr = pSHGetSpecialFolderPath(
                    NULL,
                    FName,
                    CSIDL_LOCAL_APPDATA,          // <user name>\Local Settings\Applicaiton Data (non roaming)
                    TRUE);

                if (SUCCEEDED(hr))
                {
                    lstrcat(FName, pName);

                    h = CreateFile( FName, 
		       dwDesiredAccess, 
		       FILE_SHARE_READ, 
		       NULL, 
		       dwCreationDisposition, 
		       FILE_ATTRIBUTE_NORMAL, 
		       NULL);
                }
            }
            FreeLibrary(hShlwapi);
        }
    }
#endif

    if (pPath)
    {
        lstrcpy(pPath, FName);
    }
    return h;
}

void ReadFromCache(D3DADAPTER_IDENTIFIER8*  pDI,
                   UINT*                    pCapsSize,
                   BYTE**                   ppCaps)
{
    HANDLE                  h;
    DWORD                   HeaderSize;
    DWORD                   NumRead;
    FDEVICEHEADER*          pHeaderInfo = NULL;
    DWORD                   i;

    // Get the data for the device that we're looking for

    *pCapsSize = 0;
    *ppCaps = NULL;

    // Open the file and look for the device entry

    h = OpenCacheFile (GENERIC_READ, OPEN_EXISTING, DXCACHEFILENAME, NULL);
    if (h == INVALID_HANDLE_VALUE)
    {
        return;
    }

    ReadFile( h, &HeaderSize, sizeof(DWORD), &NumRead, NULL);
    if (NumRead < sizeof(DWORD))
    {
        goto FileError;
    }
    pHeaderInfo = (FDEVICEHEADER*) MemAlloc(HeaderSize);
    if (pHeaderInfo == NULL)
    {
        goto FileError;
    }
    ReadFile( h, pHeaderInfo, HeaderSize, &NumRead, NULL);
    if (NumRead < HeaderSize)
    {
        goto FileError;
    }

    for (i = 0; i < HeaderSize / sizeof(FDEVICEHEADER); i++)
    {
        if ((pHeaderInfo[i].VendorId == pDI->VendorId) &&
            (pHeaderInfo[i].DeviceId == pDI->DeviceId) &&
            (pHeaderInfo[i].SubSysId == pDI->SubSysId) &&
            (pHeaderInfo[i].Revision == pDI->Revision))
        {
            break;
        }
    }
    if (i < HeaderSize / sizeof(FDEVICEHEADER))
    {
        // We have info for the device - now we read it

        if (SetFilePointer (h, pHeaderInfo[i].FileOffset, NULL, FILE_BEGIN) !=
            pHeaderInfo[i].FileOffset)
        {
            goto FileError;
        }
        *ppCaps = (BYTE*) MemAlloc(pHeaderInfo[i].Size);
        if (*ppCaps == NULL)
        {
            goto FileError;
        }
        ReadFile( h, *ppCaps, pHeaderInfo[i].Size, &NumRead, NULL);
        if (NumRead < pHeaderInfo[i].Size)
        {
            MemFree(*ppCaps);
            *ppCaps = NULL;
            goto FileError;
        }

        // If we got this far, then everything worked

        *pCapsSize = pHeaderInfo[i].Size;
    }

FileError:
    if (pHeaderInfo != NULL)
    {
        MemFree(pHeaderInfo);
    }
    CloseHandle(h);
}


void WriteToCache(D3DADAPTER_IDENTIFIER8*   pDI,
                  UINT                      CapsSize,
                  BYTE*                     pCaps)
{
    char                    FName[MAX_PATH + 16];
    char                    NewFName[MAX_PATH + 16];
    BOOL                    bNewFile = FALSE;
    HANDLE                  hOld;
    HANDLE                  hNew;
    DWORD                   NewHeaderSize;
    DWORD                   OldHeaderSize;
    DWORD                   NumWritten;
    DWORD                   NumRead;
    FDEVICEHEADER*          pOldHeaderInfo = NULL;
    FDEVICEHEADER*          pNewHeaderInfo = NULL;
    DWORD                   dwOffset;
    DWORD                   i;
    DWORD                   NewEntries;
    DWORD                   NextEntry;
    DWORD                   Biggest;
    BYTE*                   pBuffer = NULL;

    // Does the file already exist, or do we need to create a new one?
    hOld = OpenCacheFile (GENERIC_READ, OPEN_EXISTING, DXCACHEFILENAME, FName);
    
    if (hOld == INVALID_HANDLE_VALUE)
    {
        bNewFile = TRUE;
    }
    else
    {
        // We don't want this file to get over 65K.  If writing this entry 
        // will cause the file size to exceed that, then we will delete all
        // of the existing data and start from scratch. 

        DWORD dwLow;
        DWORD dwHigh;

        dwLow = GetFileSize (hOld, &dwHigh);
        if ((dwHigh != 0) || ((sizeof(DWORD) - dwLow) < CapsSize))
        {
            CloseHandle(hOld);
            bNewFile = TRUE;
        }
    }

    if (bNewFile)
    {
        // We are creating a new file, which is pretty easy

        hNew = OpenCacheFile (GENERIC_WRITE, CREATE_ALWAYS, DXCACHEFILENAME, NewFName);

        if (hNew != INVALID_HANDLE_VALUE)
        {
            NewHeaderSize = sizeof (FDEVICEHEADER);
            WriteFile (hNew, &NewHeaderSize, sizeof(NewHeaderSize), &NumWritten, NULL);
            if (NumWritten == sizeof(NewHeaderSize))
            {
                FDEVICEHEADER DevHeader;

                DevHeader.VendorId = pDI->VendorId;
                DevHeader.DeviceId = pDI->DeviceId;
                DevHeader.SubSysId = pDI->SubSysId;
                DevHeader.Revision = pDI->Revision;
                DevHeader.FileOffset = sizeof(FDEVICEHEADER) + sizeof(DWORD);
                DevHeader.Size = CapsSize;

                WriteFile (hNew, &DevHeader, sizeof(DevHeader), &NumWritten, NULL);
                if (NumWritten == sizeof(DevHeader))
                {
                    WriteFile (hNew, pCaps, CapsSize, &NumWritten, NULL);
                }
            }
            CloseHandle(hNew);
        }
    }
    else
    {
        // The file already exists, so we will create a new file and copy all of the contents
        // from the existing file over.

        hNew = OpenCacheFile (GENERIC_WRITE, CREATE_ALWAYS, DXTEMPFILENAME, NewFName);

        if (hNew == INVALID_HANDLE_VALUE)
        {
            goto FileError;
        }

        ReadFile (hOld, &OldHeaderSize, sizeof(DWORD), &NumRead, NULL);
        if (NumRead < sizeof(DWORD))
        {
            goto FileError;
        }
        pOldHeaderInfo = (FDEVICEHEADER*) MemAlloc(OldHeaderSize);
        if (pOldHeaderInfo == NULL)
        {
            goto FileError;
        }
        ReadFile (hOld, pOldHeaderInfo, OldHeaderSize, &NumRead, NULL);
        if (NumRead < OldHeaderSize)
        {
            goto FileError;
        }

        // How many entries will exist in the new header?

        NewEntries = 1;
        for (i = 0; i < OldHeaderSize / sizeof (FDEVICEHEADER); i++)
        {
            if ((pOldHeaderInfo[i].VendorId != pDI->VendorId) ||
                (pOldHeaderInfo[i].DeviceId != pDI->DeviceId) ||
                (pOldHeaderInfo[i].SubSysId != pDI->SubSysId) ||
                (pOldHeaderInfo[i].Revision != pDI->Revision))
            {
                NewEntries++;
            }
        }
        pNewHeaderInfo = (FDEVICEHEADER*) MemAlloc(sizeof(FDEVICEHEADER) * NewEntries);
        if (pNewHeaderInfo == NULL)
        {
            goto FileError;
        }

        // Fill in the header info for each device and save it to the new file

        dwOffset = (sizeof(FDEVICEHEADER) * NewEntries) + sizeof(DWORD);
        pNewHeaderInfo[0].VendorId = pDI->VendorId;
        pNewHeaderInfo[0].DeviceId = pDI->DeviceId;
        pNewHeaderInfo[0].SubSysId = pDI->SubSysId;
        pNewHeaderInfo[0].Revision = pDI->Revision;
        pNewHeaderInfo[0].FileOffset = dwOffset;
        pNewHeaderInfo[0].Size = CapsSize;
        dwOffset += CapsSize;

        NextEntry = 1;
        for (i = 0; i < OldHeaderSize / sizeof (FDEVICEHEADER); i++)
        {
            if ((pOldHeaderInfo[i].VendorId != pDI->VendorId) ||
                (pOldHeaderInfo[i].DeviceId != pDI->DeviceId) ||
                (pOldHeaderInfo[i].SubSysId != pDI->SubSysId) ||
                (pOldHeaderInfo[i].Revision != pDI->Revision))
            {
                pNewHeaderInfo[NextEntry].VendorId = pOldHeaderInfo[i].VendorId;
                pNewHeaderInfo[NextEntry].DeviceId = pOldHeaderInfo[i].DeviceId;
                pNewHeaderInfo[NextEntry].SubSysId = pOldHeaderInfo[i].SubSysId;
                pNewHeaderInfo[NextEntry].Revision = pOldHeaderInfo[i].Revision;
                pNewHeaderInfo[NextEntry].FileOffset = dwOffset;
                pNewHeaderInfo[NextEntry].Size = pOldHeaderInfo[i].Size;
                dwOffset += pOldHeaderInfo[i].Size;
                NextEntry++;
            }
        }

        NewHeaderSize = sizeof(FDEVICEHEADER) * NewEntries;
        WriteFile (hNew, &NewHeaderSize, sizeof(NewHeaderSize), &NumWritten, NULL);
        if (NumWritten != sizeof(NewHeaderSize))
        {
            goto FileError;
        }
        WriteFile (hNew, pNewHeaderInfo, NewHeaderSize, &NumWritten, NULL);
        if (NumWritten != NewHeaderSize)
        {
            goto FileError;
        }

        // Write the new device data to the file

        WriteFile (hNew, pCaps, CapsSize, &NumWritten, NULL);
        if (NumWritten != CapsSize)
        {
            goto FileError;
        }

        if (NewEntries > 1)
        {
            // Figure out how big the biggest device size is and allocate a buffer
            // to hold it

            Biggest = 0;
            for (i = 1; i < NewEntries; i++)
            {
                if (pNewHeaderInfo[i].Size > Biggest)
                {
                    Biggest = pNewHeaderInfo[i].Size;
                }
            }

            pBuffer = (BYTE*) MemAlloc(Biggest);
            if (pBuffer == NULL)
            {
                goto FileError;
            }

            // Now read the device data from the old file and write it to
            // the new on.

            NextEntry = 0;
            for (i = 0; i < OldHeaderSize / sizeof (FDEVICEHEADER); i++)
            {
                if ((pOldHeaderInfo[i].VendorId != pDI->VendorId) ||
                    (pOldHeaderInfo[i].DeviceId != pDI->DeviceId) ||
                    (pOldHeaderInfo[i].SubSysId != pDI->SubSysId) ||
                    (pOldHeaderInfo[i].Revision != pDI->Revision))
                {
                    if (SetFilePointer (hOld, pOldHeaderInfo[i].FileOffset, NULL, FILE_BEGIN) !=
                        pOldHeaderInfo[i].FileOffset)
                    {
                        goto FileError;
                    }
                    ReadFile (hOld, pBuffer, pOldHeaderInfo[i].Size, &NumRead, NULL);
                    if (NumRead < pOldHeaderInfo[i].Size)
                    {
                        goto FileError;
                    }
                    WriteFile (hNew, pBuffer, pOldHeaderInfo[i].Size, &NumWritten, NULL);
                    if (NumWritten != pOldHeaderInfo[i].Size)
                    {
                        goto FileError;
                    }
                }
            }
        }

        // If we made it this far, then everything worked

        CloseHandle(hNew);
        CloseHandle(hOld);
        DeleteFile(FName);
        MoveFile(NewFName, FName);
        if (pNewHeaderInfo != NULL)
        {
            MemFree(pNewHeaderInfo);
        }
        if (pOldHeaderInfo != NULL)
        {
            MemFree(pOldHeaderInfo);
        }
        if (pBuffer != NULL)
        {   
            MemFree(pBuffer);
        }
        return;

FileError:
        CloseHandle(hNew);
        CloseHandle(hOld);
        DeleteFile(FName);
        DeleteFile(NewFName);

        if (pNewHeaderInfo != NULL)
        {
            MemFree(pNewHeaderInfo);
        }
        if (pOldHeaderInfo != NULL)
        {
            MemFree(pOldHeaderInfo);
        }
        if (pBuffer != NULL)
        {
            MemFree(pBuffer);
        }
    }
}
            

void RemoveFromCache(D3DADAPTER_IDENTIFIER8* pDI)
{
    char                    FName[MAX_PATH + 16];
    char                    NewFName[MAX_PATH + 16];
    BOOL                    bNewFile = FALSE;
    HANDLE                  hOld;
    HANDLE                  hNew;
    DWORD                   NewHeaderSize;
    DWORD                   OldHeaderSize;
    DWORD                   NumWritten;
    DWORD                   NumRead;
    FDEVICEHEADER*          pOldHeaderInfo = NULL;
    FDEVICEHEADER*          pNewHeaderInfo = NULL;
    DWORD                   dwOffset;
    DWORD                   i;
    DWORD                   NewEntries;
    DWORD                   NextEntry;
    DWORD                   Biggest;
    BYTE*                   pBuffer = NULL;

    // Does the file already exist, or do we need to create a new one?

    hOld = OpenCacheFile (GENERIC_READ, OPEN_EXISTING, DXCACHEFILENAME, FName);

    if (hOld == INVALID_HANDLE_VALUE)
    {
        return;
    }

    ReadFile (hOld, &OldHeaderSize, sizeof(DWORD), &NumRead, NULL);
    if (NumRead < sizeof(DWORD))
    {
        goto FileError;
    }
    if (OldHeaderSize <= sizeof(FDEVICEHEADER))
    {
        // Theres only one entry in the file, so all we need to do
        // is delete it.

        DeleteFile(FName);
        return;
    }

    pOldHeaderInfo = (FDEVICEHEADER*) MemAlloc(OldHeaderSize);
    if (pOldHeaderInfo == NULL)
    {
        goto FileError;
    }
    ReadFile (hOld, pOldHeaderInfo, OldHeaderSize, &NumRead, NULL);
    if (NumRead < OldHeaderSize)
    {
        goto FileError;
    }

    // Create a new file and copy all of the contents from the existing file over.

    hNew = OpenCacheFile (GENERIC_WRITE, CREATE_ALWAYS, DXTEMPFILENAME, NewFName);

    if (hNew == INVALID_HANDLE_VALUE)
    {
        goto FileError;
    }

    // How many entries will exist in the new header?

    NewEntries = 0;
    for (i = 0; i < OldHeaderSize / sizeof (FDEVICEHEADER); i++)
    {
        if ((pOldHeaderInfo[i].VendorId != pDI->VendorId) ||
            (pOldHeaderInfo[i].DeviceId != pDI->DeviceId) ||
            (pOldHeaderInfo[i].SubSysId != pDI->SubSysId) ||
            (pOldHeaderInfo[i].Revision != pDI->Revision))
        {
            NewEntries++;
        }
    }
    pNewHeaderInfo = (FDEVICEHEADER*) MemAlloc(sizeof(FDEVICEHEADER) * NewEntries);
    if (pNewHeaderInfo == NULL)
    {
        goto FileError;
    }

    // Fill in the header info for each device and save it to the new file

    dwOffset = (sizeof(FDEVICEHEADER) * NewEntries) + sizeof(DWORD);

    NextEntry = 0;
    for (i = 0; i < OldHeaderSize / sizeof (FDEVICEHEADER); i++)
    {
        if ((pOldHeaderInfo[i].VendorId != pDI->VendorId) ||
            (pOldHeaderInfo[i].DeviceId != pDI->DeviceId) ||
            (pOldHeaderInfo[i].SubSysId != pDI->SubSysId) ||
            (pOldHeaderInfo[i].Revision != pDI->Revision))
        {
            pNewHeaderInfo[NextEntry].VendorId = pOldHeaderInfo[i].VendorId;
            pNewHeaderInfo[NextEntry].DeviceId = pOldHeaderInfo[i].DeviceId;
            pNewHeaderInfo[NextEntry].SubSysId = pOldHeaderInfo[i].SubSysId;
            pNewHeaderInfo[NextEntry].Revision = pOldHeaderInfo[i].Revision;
            pNewHeaderInfo[NextEntry].FileOffset = dwOffset;
            pNewHeaderInfo[NextEntry].Size = pOldHeaderInfo[i].Size;
            dwOffset += pOldHeaderInfo[i].Size;
            NextEntry++;
        }
    }

    NewHeaderSize = sizeof(FDEVICEHEADER) * NewEntries;
    WriteFile (hNew, &NewHeaderSize, sizeof(NewHeaderSize), &NumWritten, NULL);
    if (NumWritten != sizeof(NewHeaderSize))
    {
        goto FileError;
    }
    WriteFile (hNew, pNewHeaderInfo, NewHeaderSize, &NumWritten, NULL);
    if (NumWritten != NewHeaderSize)
    {
        goto FileError;
    }

    // Figure out how big the biggest device size is and allocate a buffer
    // to hold it

    Biggest = 0;
    for (i = 0; i < NewEntries; i++)
    {
        if (pNewHeaderInfo[i].Size > Biggest)
        {
            Biggest = pNewHeaderInfo[i].Size;
        }
    }

    pBuffer = (BYTE*) MemAlloc(Biggest);
    if (pBuffer == NULL)
    {
        goto FileError;
    }

    // Now read the device data from the old file and write it to
    // the new on.

    NextEntry = 0;
    for (i = 0; i < OldHeaderSize / sizeof (FDEVICEHEADER); i++)
    {
        if ((pOldHeaderInfo[i].VendorId != pDI->VendorId) ||
            (pOldHeaderInfo[i].DeviceId != pDI->DeviceId) ||
            (pOldHeaderInfo[i].SubSysId != pDI->SubSysId) ||
            (pOldHeaderInfo[i].Revision != pDI->Revision))
        {
            if (SetFilePointer (hOld, pOldHeaderInfo[i].FileOffset, NULL, FILE_BEGIN) !=
                pOldHeaderInfo[i].FileOffset)
            {
                goto FileError;
            }
            ReadFile (hOld, pBuffer, pOldHeaderInfo[i].Size, &NumRead, NULL);
            if (NumRead < pOldHeaderInfo[i].Size)
            {
                goto FileError;
            }
            WriteFile (hNew, pBuffer, pOldHeaderInfo[i].Size, &NumWritten, NULL);
            if (NumWritten != pOldHeaderInfo[i].Size)
            {
                goto FileError;
            }
        }
    }

    // If we made it this far, then everything worked

    CloseHandle(hNew);
    CloseHandle(hOld);
    DeleteFile(FName);
    MoveFile(NewFName, FName);
    if (pNewHeaderInfo != NULL)
    {
        MemFree(pNewHeaderInfo);
    }
    if (pOldHeaderInfo != NULL)
    {
        MemFree(pOldHeaderInfo);
    }
    if (pBuffer != NULL)
    {
        MemFree(pBuffer);
    }
    return;

FileError:
    CloseHandle(hNew);
    CloseHandle(hOld);

    if (pNewHeaderInfo != NULL)
    {
        MemFree(pNewHeaderInfo);
    }
    if (pOldHeaderInfo != NULL)
    {
        MemFree(pOldHeaderInfo);
    }
    if (pBuffer != NULL)
    {
        MemFree(pBuffer);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\ibuffer.hpp ===
#ifndef __IBUFFER_HPP__
#define __IBUFFER_HPP__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ibuffer.hpp
 *  Content:    Class header the Index buffer class
 *
 ***************************************************************************/

// Includes
#include "buffer.hpp"

// The base-class implementation of the Index buffer assumes
// that it is resides system-memory. It may be managed.
class CIndexBuffer : public IDirect3DIndexBuffer8, public CBuffer
{
public:
    // Creation function for Index Buffers
    static HRESULT Create(CBaseDevice            *pDevice, 
                          DWORD                   cbLength,
                          DWORD                   dwUsage,
                          D3DFORMAT               Format,
                          D3DPOOL                 Pool,
                          REF_TYPE                refType,
                          IDirect3DIndexBuffer8 **ppIndexBuffer);

    static HRESULT CreateSysmemIndexBuffer(CBaseDevice *pDevice,
                                           DWORD        cbLength,
                                           DWORD        dwUsage,
                                           DWORD        dwActualUsage,
                                           D3DFORMAT    Format,
                                           D3DPOOL      Pool,
                                           D3DPOOL      ActualPool,
                                           REF_TYPE     refType,
                                           CIndexBuffer **pIB);

    static HRESULT CreateDriverIndexBuffer(CBaseDevice *pDevice,
                                           DWORD        cbLength,
                                           DWORD        dwUsage,
                                           DWORD        dwActualUsage,
                                           D3DFORMAT    Format,
                                           D3DPOOL      Pool,
                                           D3DPOOL      ActualPool,
                                           REF_TYPE     refType,
                                           CIndexBuffer **pVB);

    static HRESULT CreateDriverManagedIndexBuffer(CBaseDevice *pDevice,
                                                  DWORD        cbLength,
                                                  DWORD        dwUsage,
                                                  DWORD        dwActualUsage,
                                                  D3DFORMAT    Format,
                                                  D3DPOOL      Pool,
                                                  D3DPOOL      ActualPool,
                                                  REF_TYPE     refType,
                                                  CIndexBuffer **pVB);

    // Methods for Resource Management

    // Create duplicate of current object in new pool;
    // LOD is ignored for our type
    virtual HRESULT Clone(D3DPOOL     Pool, 
                          CResource **ppResource) const;

    virtual const D3DBUFFER_DESC* GetBufferDesc() const;

    HRESULT UpdateDirtyPortion(CResource *pResourceTarget);

    // IUnknown methods
    STDMETHOD(QueryInterface) (REFIID riid, 
                               LPVOID FAR * ppvObj);
    STDMETHOD_(ULONG,AddRef) ();
    STDMETHOD_(ULONG,Release) ();

    // Some Methods for IDirect3DBuffer
    STDMETHOD(SetPrivateData)(REFGUID riid, 
                              CONST VOID* pvData, 
                              DWORD cbData, 
                              DWORD dwFlags);

    STDMETHOD(GetPrivateData)(REFGUID riid, 
                              LPVOID pvData, 
                              LPDWORD pcbData);

    STDMETHOD(FreePrivateData)(REFGUID riid);

    STDMETHOD(GetDevice)(IDirect3DDevice8 **ppDevice);
    STDMETHOD_(DWORD, GetPriority)();
    STDMETHOD_(DWORD, SetPriority)(DWORD dwPriority);
    STDMETHOD_(void, PreLoad)();
    STDMETHOD_(D3DRESOURCETYPE, GetType)();

    // Methods for IDirect3DIndexBuffer8
    STDMETHOD(Lock)(UINT cbOffsetToLock,
                    UINT cbSizeToLock,
                    BYTE **ppbData,
                    DWORD dwFlags);

    STDMETHOD(Unlock)();
    STDMETHOD(GetDesc)(D3DINDEXBUFFER_DESC *pDesc);

    BYTE* Data() const
    {
        DXGASSERT(m_desc.Usage & D3DUSAGE_SOFTWAREPROCESSING);
        DXGASSERT(m_desc.Pool == D3DPOOL_SYSTEMMEM || m_desc.Pool == D3DPOOL_MANAGED);
        DXGASSERT(m_LockCount == 0);
        return GetPrivateDataPointer();
    }

protected:

    CIndexBuffer(CBaseDevice *pDevice,
                 DWORD        cbLength,
                 DWORD        dwUsage,
                 DWORD        dwActualUsage,
                 D3DFORMAT    Format,
                 D3DPOOL      Pool,
                 D3DPOOL      ActualPool,
                 REF_TYPE     refType,
                 HRESULT     *phr);

#if DBG
    HRESULT ValidateLockParams(UINT cbOffsetToLock, 
                               UINT SizeToLock,
                               BYTE **ppbData,
                               DWORD dwFlags) const;
#endif // DBG

    // Member data
    D3DINDEXBUFFER_DESC   m_desc;
    DWORD                 m_usageUser;

}; // class CIndexBuffer

class CIndexBufferMT : public CIndexBuffer
{
public:
    STDMETHOD(Lock)(UINT cbOffsetToLock,
                    UINT cbSizeToLock,
                    BYTE **ppbData,
                    DWORD dwFlags)
    {
        API_ENTER(Device());
        return CIndexBuffer::Lock(cbOffsetToLock, cbSizeToLock, ppbData, dwFlags);
    }

    STDMETHOD(Unlock)()
    {
        API_ENTER(Device());
        return CIndexBuffer::Unlock();
    }

    friend CIndexBuffer;

protected:

    CIndexBufferMT(CBaseDevice *pDevice,
                   DWORD        cbLength,
                   DWORD        Usage,
                   DWORD        ActualUsage,
                   D3DFORMAT    Format,
                   D3DPOOL      Pool,
                   D3DPOOL      ActualPool,
                   REF_TYPE     refType,
                   HRESULT     *phr) :
        CIndexBuffer(pDevice,
                     cbLength,
                     Usage,
                     ActualUsage,
                     Format,
                     Pool,
                     ActualPool,
                     refType,
                     phr)
    {
    }

}; // class CIndexBufferMT

// This derived version of the Index buffer class
// overrides lock/unlock to call the driver instead
class CDriverIndexBuffer : public CIndexBuffer
{
public:
    STDMETHOD(Lock)(UINT cbOffsetToLock,
                    UINT cbSizeToLock,
                    BYTE **ppbData,
                    DWORD dwFlags);
    STDMETHOD(Unlock)();

    HRESULT LockI(DWORD dwFlags);
    HRESULT UnlockI();

    BYTE* Data() const
    {
        DXGASSERT(FALSE); // Direct pointer access not supported
        return 0;
    }

    // Alloc CIndexBuffer to construct this object
    friend CIndexBuffer;

protected:
    CDriverIndexBuffer(CBaseDevice *pDevice,
                       DWORD        cbLength,
                       DWORD        Usage,
                       DWORD        ActualUsage,
                       D3DFORMAT    Format,
                       D3DPOOL      Pool,
                       D3DPOOL      ActualPool,
                       REF_TYPE     refType,
                       HRESULT     *phr);
    ~CDriverIndexBuffer();

    BYTE*   m_pbData; // stores cached pointer
    
}; // class CDriverIndexBuffer 

class CDriverIndexBufferMT : public CDriverIndexBuffer
{
public:
    STDMETHOD(Lock)(UINT cbOffsetToLock,
                    UINT cbSizeToLock,
                    BYTE **ppbData,
                    DWORD dwFlags)
    {
        API_ENTER(Device());
        return CDriverIndexBuffer::Lock(cbOffsetToLock, cbSizeToLock, ppbData, dwFlags);
    }

    STDMETHOD(Unlock)()
    {
        API_ENTER(Device());
        return CDriverIndexBuffer::Unlock();
    }

    friend CIndexBuffer;

protected:
    CDriverIndexBufferMT(CBaseDevice *pDevice,
                         DWORD        cbLength,
                         DWORD        Usage,
                         DWORD        ActualUsage,
                         D3DFORMAT    Format,
                         D3DPOOL      Pool,
                         D3DPOOL      ActualPool,
                         REF_TYPE     refType,
                         HRESULT     *phr) :
        CDriverIndexBuffer(pDevice,
                           cbLength,
                           Usage,
                           ActualUsage,
                           Format,
                           Pool,
                           ActualPool,
                           refType,
                           phr)
    {
    }

}; // class CIndexBufferMT

// This derived version of the Index buffer class
// overrides lock/unlock to call the driver instead
class CDriverManagedIndexBuffer : public CIndexBuffer
{
public:
    STDMETHOD(Lock)(UINT cbOffsetToLock,
                    UINT cbSizeToLock,
                    BYTE **ppbData,
                    DWORD dwFlags);
    STDMETHOD(Unlock)();

    BYTE* Data() const
    {
        DXGASSERT(m_desc.Usage & D3DUSAGE_SOFTWAREPROCESSING);
        DXGASSERT((m_desc.Usage & D3DUSAGE_WRITEONLY) == 0);
        DXGASSERT(m_LockCount == 0);
        DXGASSERT(m_pbData != 0);
        return m_pbData;
    }

    // Alloc CIndexBuffer to construct this object
    friend CIndexBuffer;

protected:
    CDriverManagedIndexBuffer(CBaseDevice *pDevice,
                       DWORD        cbLength,
                       DWORD        Usage,
                       DWORD        ActualUsage,
                       D3DFORMAT    Format,
                       D3DPOOL      Pool,
                       D3DPOOL      ActualPool,
                       REF_TYPE     refType,
                       HRESULT     *phr);

    HRESULT UpdateCachedPointer(CBaseDevice*);

    friend HRESULT CResource::RestoreDriverManagementState(CBaseDevice*);

    BYTE*   m_pbData; // stores cached pointer
    BOOL    m_bDriverCalled;
    
}; // class CDriverManagedIndexBuffer 

class CDriverManagedIndexBufferMT : public CDriverManagedIndexBuffer
{
public:
    STDMETHOD(Lock)(UINT cbOffsetToLock,
                    UINT cbSizeToLock,
                    BYTE **ppbData,
                    DWORD dwFlags)
    {
        API_ENTER(Device());
        return CDriverManagedIndexBuffer::Lock(cbOffsetToLock, cbSizeToLock, ppbData, dwFlags);
    }

    STDMETHOD(Unlock)()
    {
        API_ENTER(Device());
        return CDriverManagedIndexBuffer::Unlock();
    }

    // Alloc CIndexBuffer to construct this object
    friend CIndexBuffer;

protected:
    CDriverManagedIndexBufferMT(CBaseDevice *pDevice,
                                 DWORD        cbLength,
                                 DWORD        Usage,
                                 DWORD        ActualUsage,
                                 D3DFORMAT    Format,
                                 D3DPOOL      Pool,
                                 D3DPOOL      ActualPool,
                                 REF_TYPE     refType,
                                 HRESULT     *phr) :
        CDriverManagedIndexBuffer(pDevice,
                                   cbLength,
                                   Usage,
                                   ActualUsage,
                                   Format,
                                   Pool,
                                   ActualPool,
                                   refType,
                                   phr)
    {
    }

}; // class CDriverIndexBufferMT

#endif // __IBUFFER_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\mipmap.hpp ===
#ifndef __MIPMAP_HPP__
#define __MIPMAP_HPP__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mipmap.hpp
 *  Content:    Class header the mip-map class. This class acts a 
 *              container for the (planar) Surfaces that are used as textures.
 *
 *
 ***************************************************************************/

// Includes
#include "texture.hpp"
#include "pixel.hpp"

// Forward decls
class CMipSurface;

//
// The mip-map class holds a collection of CMipSurfaces. The MipTexture class
// implements the IDirect3DTexture8 interface; each MipSurface implements the
// IDirect3DSurface8 interface. To reduce overhead per level, we have
// put most of the "real" guts of each surface into the MipMap container 
// class; i.e. most of the methods of the MipSurface really just end up 
// calling something in the MipMap object. 
//
// The base class implementation assumes a sys-mem allocation.
//

class CMipMap : public CBaseTexture, public IDirect3DTexture8
{
public:
    // Creation method to allow creation of MipMaps no matter
    // their actual underlying type.
    static HRESULT Create(CBaseDevice        *pDevice, 
                          DWORD               cpWidth,
                          DWORD               cpHeight,
                          DWORD               cLevels,
                          DWORD               dwUsage,
                          D3DFORMAT           Format,
                          D3DPOOL             Pool,
                          IDirect3DTexture8 **ppMipMap);

    // Destructor
    virtual ~CMipMap();


    // IUnknown methods
    STDMETHOD(QueryInterface) (REFIID       riid, 
                               LPVOID FAR * ppvObj);
    STDMETHOD_(ULONG,AddRef)  ();
    STDMETHOD_(ULONG,Release) ();

    // IDirect3DResource methods
    STDMETHOD(GetDevice) (IDirect3DDevice8 ** ppvObj);

    STDMETHOD(SetPrivateData)(REFGUID riid, 
                              CONST VOID*  pvData, 
                              DWORD   cbData, 
                              DWORD   dwFlags);

    STDMETHOD(GetPrivateData)(REFGUID riid, 
                              LPVOID  pvData, 
                              LPDWORD pcbData);

    STDMETHOD(FreePrivateData)(REFGUID riid);

    STDMETHOD_(DWORD, GetPriority)();
    STDMETHOD_(DWORD, SetPriority)(DWORD dwPriority);
    STDMETHOD_(void, PreLoad)();
    STDMETHOD_(D3DRESOURCETYPE, GetType)();

    // IDirect3DMipTexture methods
    STDMETHOD_(DWORD, GetLOD)();
    STDMETHOD_(DWORD, SetLOD)(DWORD dwLOD);
    STDMETHOD_(DWORD, GetLevelCount)();

    // IDirect3DMipMap methods
    STDMETHOD(GetLevelDesc)(UINT iLevel, D3DSURFACE_DESC *pDesc);
    STDMETHOD(GetSurfaceLevel)(UINT                 iLevel,
                               IDirect3DSurface8  **ppSurfaceLevel);


    STDMETHOD(LockRect)(UINT             iLevel,
                        D3DLOCKED_RECT  *pLockedRectData, 
                        CONST RECT      *pRect, 
                        DWORD            dwFlags);
    STDMETHOD(UnlockRect)(UINT           iLevel);


    STDMETHOD(AddDirtyRect)(CONST RECT  *pRect);

    // Direct accessor for surface descriptor
    const D3DSURFACE_DESC *Desc() const
    {
        return &m_desc;
    } // Desc;

    // Helper for Lock
    void ComputeMipMapOffset(UINT iLevel, 
                             CONST RECT *pRect, 
                             D3DLOCKED_RECT *pLockedRectData) const
    {
        CPixel::ComputeMipMapOffset(Desc(),
                                    iLevel,
                                    m_rgbPixels,
                                    pRect,
                                    pLockedRectData);
    } // ComputeMipMapOffset

    // Notification when a mip-level is locked for writing
    void OnSurfaceLock(DWORD iLevel, CONST RECT *pRect, DWORD Flags);

    // Methods for CResource

    // Specifies a creation of a resource that
    // looks just like the current one; in a new POOL
    // with a new LOD.
    virtual HRESULT Clone(D3DPOOL     Pool, 
                          CResource **ppResource) const;

    // Provides a method to access basic structure of the
    // pieces of the resource. 
    virtual const D3DBUFFER_DESC* GetBufferDesc() const;

    // Updates destination with source dirty rects
    virtual HRESULT UpdateDirtyPortion(CResource *pResourceTarget);

    // Allows the Resource Manager to mark the texture
    // as needing to be completely updated on next
    // call to UpdateDirtyPortion
    virtual void MarkAllDirty();
        
    // Methods for CBaseTexture

    // Method for UpdateTexture to call; does type-specific
    // parameter checking before calling UpdateDirtyPortion
    virtual HRESULT UpdateTexture(CBaseTexture *pTextureTarget);

    // Parameter validation method to make sure that no part of
    // the texture is locked.
#ifdef DEBUG
    virtual BOOL IsTextureLocked();
#endif  // DEBUG

private:
    // Constructor returns an error code
    // if the object could not be fully
    // constructed
    CMipMap(CBaseDevice *pDevice, 
            DWORD        cpWidth,
            DWORD        cpHeight,
            DWORD        cLevels,
            DWORD        dwUsage,
            D3DFORMAT    UserFormat,
            D3DFORMAT    RealFormat,
            D3DPOOL      Pool,
            REF_TYPE     refType,
            HRESULT     *phr
            );

    // Internally keep track of current
    // set of dirty rects
    void InternalAddDirtyRect(CONST RECT *pRect);

    // Each mipmap has an array of CMipSurfaces
    CMipSurface     **m_prgMipSurfaces;
    
    // Each mipmap has a memory block that holds
    // all the pixel data in a contiguous chunk
    BYTE             *m_rgbPixels;

    // Keep track of description
    D3DSURFACE_DESC   m_desc;

    // In DX7 we kept track of upto 6 RECTs per mip-chain.
    // These rects indicate which portion of the top-most level of
    // a mip-chain were modified. (We continue to ignore modifications 
    // to lower levels of the mip-chain. This is by-design.)
    enum 
    {
        MIPMAP_MAXDIRTYRECT = 6,
        MIPMAP_ALLDIRTY     = 7
    };

    RECT    m_DirtyRectArray[MIPMAP_MAXDIRTYRECT];

    // If m_cRectUsed is greater than MIPMAP_MAXDIRTYRECT
    // then it means that everything is dirty
    UINT    m_cRectUsed;

}; // class CMipMap

#endif // __MIPMAP_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\mipmap.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mipmap.cpp
 *  Content:    Implementation of the CMipMap class. 
 *
 *
 ***************************************************************************/
#include "ddrawpr.h"

#include "mipmap.hpp"
#include "mipsurf.hpp"
#include "d3di.hpp"
#include "resource.inl"

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::Create"

// Static class function for creating a mip-map object.
//
// We do all parameter checking here to reduce the overhead
// in the constructor which is called by the internal Clone
// method which is used by resource management as part of the
// performance critical download operation.

HRESULT CMipMap::Create(CBaseDevice         *pDevice, 
                        DWORD                Width,
                        DWORD                Height,
                        DWORD                cLevels,
                        DWORD                Usage,
                        D3DFORMAT            UserFormat,
                        D3DPOOL              Pool,
                        IDirect3DTexture8  **ppMipMap)
{
    HRESULT hr;

    // Do parameter checking here
    if (!VALID_PTR_PTR(ppMipMap))
    {
        DPF_ERR("Bad parameter passed pTexture. CreateTexture failed");
        return D3DERR_INVALIDCALL;
    }

    // Zero-out return parameter
    *ppMipMap = NULL;

    // Check if format is valid
    hr = Validate(pDevice, 
                  D3DRTYPE_TEXTURE, 
                  Pool, 
                  Usage, 
                  UserFormat);
    if (FAILED(hr))
    {
        // Validate does it's own DPFing
        return D3DERR_INVALIDCALL;
    }


    // Infer internal usage flags
    Usage = InferUsageFlags(Pool, Usage, UserFormat);

    // Expand cLevels if necessary
    if (cLevels == 0)
    {
        // See if HW can mip
        if ( (Pool != D3DPOOL_SCRATCH) && !(pDevice->GetD3DCaps()->TextureCaps & D3DPTEXTURECAPS_MIPMAP))
        {
            // Can't mip so use 1
            cLevels = 1;
        }
        else
        {
            // Determine number of levels
            cLevels = ComputeLevels(Width, Height);
        }
    }

    // Extra checks for multi-level case
    if (cLevels > 1)
    {
        if ((Width  >> (cLevels - 1)) == 0 &&
            (Height >> (cLevels - 1)) == 0)
        {
            DPF_ERR("Too many levels for mip-map of this size. CreateTexture failed.");
            return D3DERR_INVALIDCALL;
        }
    }

    if (cLevels > 32)
    {
        DPF_ERR("No more than 32 levels are supported. CreateTexture failed");

        // This limitation is based on the number of
        // bits that we have allocated for iLevel in 
        // some of the supporting classes.
        return D3DERR_INVALIDCALL;
    }

    D3DFORMAT RealFormat = UserFormat;

    // Start parameter checking
    if(Pool != D3DPOOL_SCRATCH)
    {
        //device-specific checking:

        // Check if device can do mipmaps
        if (cLevels > 1)
        {
            if (!(pDevice->GetD3DCaps()->TextureCaps & D3DPTEXTURECAPS_MIPMAP))
            {
                DPF_ERR("Device doesn't support mip-map textures; CreateTexture failed.");
                return D3DERR_INVALIDCALL;
            }
        }

        // Check power-of-two constraints
        if (!IsPowerOfTwo(Width))
        {
            if (pDevice->GetD3DCaps()->TextureCaps & D3DPTEXTURECAPS_POW2)
            {
                if (!(pDevice->GetD3DCaps()->TextureCaps &
                      D3DPTEXTURECAPS_NONPOW2CONDITIONAL))
                {
                    DPF_ERR("Device does not support non-pow2 width for texture");
                    return D3DERR_INVALIDCALL;
                }
                else if (cLevels > 1)
                {  
                    DPF_ERR("Device doesn't support non-pow2 width for multi-level texture");
                    return D3DERR_INVALIDCALL;
                }
            }
        }

        if (!IsPowerOfTwo(Height))
        {
            if (pDevice->GetD3DCaps()->TextureCaps & D3DPTEXTURECAPS_POW2)
            {
                if (!(pDevice->GetD3DCaps()->TextureCaps &
                      D3DPTEXTURECAPS_NONPOW2CONDITIONAL))
                {
                    DPF_ERR("Device does not support non-pow2 height for texture. CreateTexture failed.");
                    return D3DERR_INVALIDCALL;
                }
                else if (cLevels > 1)
                {  
                    DPF_ERR("Device doesn't support non-pow2 height for multi-level texture. CreateTexture failed.");
                    return D3DERR_INVALIDCALL;
                }
            }
        }

        // See if the device requires square textures
        if (Width != Height)
        {
            if (pDevice->GetD3DCaps()->TextureCaps & D3DPTEXTURECAPS_SQUAREONLY)
            {
                DPF_ERR("Device requires square textures only. CreateTexture failed.");
                return D3DERR_INVALIDCALL;
            }
        }

        // Check texture size restrictions
        if (Width > pDevice->GetD3DCaps()->MaxTextureWidth)
        {
            DPF_ERR("Texture width is larger than what the device supports. CreateTexture failed.");
            return D3DERR_INVALIDCALL;
        }

        if (Height > pDevice->GetD3DCaps()->MaxTextureHeight)
        {
            DPF_ERR("Texture height is larger than what the device supports. CreateTexture failed.");
            return D3DERR_INVALIDCALL;
        }

        // Extra checks for multi-level case
        if (cLevels > 1)
        {
            // Check if the device can do multi-level mipmaps.
            if (!(pDevice->GetD3DCaps()->TextureCaps & D3DPTEXTURECAPS_MIPMAP))
            {
                DPF_ERR("Device doesn't support multi-level mipmaps. CreateTexture failed.");
                return D3DERR_INVALIDCALL;
            }
        }

        // Map Depth/Stencil formats; returns no change if no
        // mapping is needed
        RealFormat = pDevice->MapDepthStencilFormat(UserFormat);
    }

    // Size may need to be 4x4
    if (CPixel::Requires4X4(UserFormat))
    {
        if ((Width & 3) ||
            (Height & 3))
        {
            DPF_ERR("DXT Formats require width/height to be a multiple of 4. CreateTexture failed.");
            return D3DERR_INVALIDCALL;
        }
    }

    // Validate against zero width/height
    if (Width   == 0 ||
        Height  == 0)
    {
        DPF_ERR("Width and Height must be non-zero. CreateTexture failed."); 
        return D3DERR_INVALIDCALL;
    }


    // We don't need to check if the HW can do textures since we
    // fail create if we find no texturing support

    // Allocate a new MipMap object and return it
    CMipMap *pMipMap = new CMipMap(pDevice, 
                                   Width, 
                                   Height, 
                                   cLevels,
                                   Usage,
                                   UserFormat,
                                   RealFormat,
                                   Pool,
                                   REF_EXTERNAL,
                                  &hr);
    if (pMipMap == NULL)
    {
        DPF_ERR("Out of Memory creating texture. CreateTexture failed.");
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr))
    {
        DPF_ERR("Error during initialization of texture. CreateTexture failed.");
        pMipMap->ReleaseImpl();
        return hr;
    }

    // We're done; just return the object
    *ppMipMap = pMipMap;

    return hr;
} // static Create


#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::CMipMap"

// Constructor for the mip map class
CMipMap::CMipMap(CBaseDevice *pDevice, 
                 DWORD        Width,
                 DWORD        Height,
                 DWORD        cLevels,
                 DWORD        Usage,
                 D3DFORMAT    UserFormat,
                 D3DFORMAT    RealFormat,
                 D3DPOOL      UserPool,
                 REF_TYPE     refType,
                 HRESULT     *phr
                 ) :
    CBaseTexture(pDevice, cLevels, UserPool, UserFormat, refType),
    m_prgMipSurfaces(NULL),
    m_rgbPixels(NULL),
    m_cRectUsed(MIPMAP_ALLDIRTY)
{
    // Initialize basic structures
    m_desc.Format           = RealFormat;
    m_desc.Pool             = UserPool;
    m_desc.Usage            = Usage;
    m_desc.Type             = D3DRTYPE_TEXTURE;
    m_desc.MultiSampleType  = D3DMULTISAMPLE_NONE;
    m_desc.Width            = Width;
    m_desc.Height           = Height;

    // Estimate size of memory allocation
    m_desc.Size   = CPixel::ComputeMipMapSize(Width, 
                                              Height, 
                                              cLevels, 
                                              RealFormat);

    // Allocate Pixel Data for SysMem or D3DManaged cases
    if (IS_D3D_ALLOCATED_POOL(UserPool) ||
        IsTypeD3DManaged(Device(), D3DRTYPE_TEXTURE, UserPool))
    {
        m_rgbPixels     = new BYTE[m_desc.Size];
        if (m_rgbPixels == NULL)
        {
            DPF_ERR("Out of memory allocating memory for mip-map levels.");
            *phr = E_OUTOFMEMORY;
            return;
        }

        // Mark our real pool as sys-mem
        m_desc.Pool = D3DPOOL_SYSTEMMEM;
    }

    // Create the DDSURFACEINFO array and CreateSurfaceData object
    DXGASSERT(cLevels <= 32);

    DDSURFACEINFO SurfInfo[32];
    ZeroMemory(SurfInfo, sizeof(SurfInfo));

    D3D8_CREATESURFACEDATA CreateSurfaceData;
    ZeroMemory(&CreateSurfaceData, sizeof(CreateSurfaceData));

    // Set up the basic information
    CreateSurfaceData.hDD      = pDevice->GetHandle();
    CreateSurfaceData.pSList   = &SurfInfo[0];
    CreateSurfaceData.dwSCnt   = cLevels;
    CreateSurfaceData.Type     = D3DRTYPE_TEXTURE;
    CreateSurfaceData.dwUsage  = m_desc.Usage;
    CreateSurfaceData.Format   = RealFormat;
    CreateSurfaceData.MultiSampleType = D3DMULTISAMPLE_NONE;
    CreateSurfaceData.Pool     = DetermineCreationPool(Device(), 
                                                       D3DRTYPE_TEXTURE,
                                                       Usage, 
                                                       UserPool);

    // Iterate of each level to create the individual level
    // data
    for (DWORD iLevel = 0; iLevel < cLevels; iLevel++)
    {
        // Fill in the relevant information
        DXGASSERT(Width >= 1);
        DXGASSERT(Height >= 1);
        SurfInfo[iLevel].cpWidth  = Width;
        SurfInfo[iLevel].cpHeight = Height;

        // If we allocated the memory, pass down
        // the sys-mem pointers
        if (m_rgbPixels)
        {
            D3DLOCKED_RECT lock;
            ComputeMipMapOffset(iLevel, 
                                NULL,       // pRect
                                &lock);

            SurfInfo[iLevel].pbPixels = (BYTE*)lock.pBits;
            SurfInfo[iLevel].iPitch   = lock.Pitch;
            
        }

        // Scale width and height down
        if (Width > 1)
        {
            Width >>= 1;
        }
        if (Height > 1)
        {
            Height >>= 1;
        }
    }

    // Allocate array of pointers to MipSurfaces
    m_prgMipSurfaces = new CMipSurface*[cLevels];
    if (m_prgMipSurfaces == NULL)
    {
        DPF_ERR("Out of memory creating mipmap");
        *phr = E_OUTOFMEMORY;
        return;
    }

    // Zero the memory for safe cleanup
    ZeroMemory(m_prgMipSurfaces, sizeof(*m_prgMipSurfaces) * cLevels);

    if (UserPool != D3DPOOL_SCRATCH)
    {
        // Call the HAL to create this surface
        *phr = pDevice->GetHalCallbacks()->CreateSurface(&CreateSurfaceData);
        if (FAILED(*phr))
            return;

        // NOTE: any failures after this point needs to free up some
        // kernel handles

        // Remember what pool we really got
        m_desc.Pool = CreateSurfaceData.Pool;

        // We need to remember the handles from the top most
        // level of the mip-map
        SetKernelHandle(SurfInfo[0].hKernelHandle);
    }

    // Create and Initialize each MipLevel
    for (iLevel = 0; iLevel < cLevels; iLevel++)
    {
        // Is this a sys-mem or scratch surface; could be d3d managed
        if (IS_D3D_ALLOCATED_POOL(m_desc.Pool))
        {
            m_prgMipSurfaces[iLevel] = 
                    new CMipSurface(this, 
                                    (BYTE)iLevel,
                                    SurfInfo[iLevel].hKernelHandle);
        }
        else
        {
            // Must be a driver kind of surface; could be driver managed
            m_prgMipSurfaces[iLevel] = 
                    new CDriverMipSurface(this, 
                                          (BYTE)iLevel,
                                          SurfInfo[iLevel].hKernelHandle);
        }

        if (m_prgMipSurfaces[iLevel] == NULL)
        {
            DPF_ERR("Out of memory creating miplevel");
            *phr = E_OUTOFMEMORY;

            if (UserPool != D3DPOOL_SCRATCH)
            {
                // Need to free handles that we got before we return; we
                // only free the ones that weren't successfully entrusted
                // to a CMipSurf because those will be cleaned up automatically
                // at their destructor
                for (UINT i = iLevel; i < cLevels; i++)
                {
                    DXGASSERT(SurfInfo[i].hKernelHandle);

                    D3D8_DESTROYSURFACEDATA DestroySurfData;
                    DestroySurfData.hDD = Device()->GetHandle();
                    DestroySurfData.hSurface = SurfInfo[i].hKernelHandle;
                    Device()->GetHalCallbacks()->DestroySurface(&DestroySurfData);
                }
            }

            return;
        }
    }

    // If this is a D3D managed mipmap then we need 
    // to tell the Resource Manager to remember us. This has to happen
    // at the very end of the constructor so that the important data
    // members are built up correctly
    if (CResource::IsTypeD3DManaged(Device(), D3DRTYPE_TEXTURE, UserPool))
    {
        *phr = InitializeRMHandle();
    }

    return;
} // CMipMap::CMipMap


#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::~CMipMap"

// Destructor
CMipMap::~CMipMap()
{
    // The destructor has to handle partially
    // created objects. Delete automatically
    // handles NULL; and members are nulled
    // as part of core constructors

    if (m_prgMipSurfaces)
    {
        for (DWORD i = 0; i < m_cLevels; i++)
        {
            delete m_prgMipSurfaces[i];
        }
        delete [] m_prgMipSurfaces;
    }
    delete [] m_rgbPixels;
} // CMipMap::~CMipMap

// Methods for the Resource Manager

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::Clone"

// Specifies a creation of a resource that
// looks just like the current one; in a new POOL
// with a new LOD.
HRESULT CMipMap::Clone(D3DPOOL     Pool, 
                       CResource **ppResource) const

{
    // NULL out parameter
    *ppResource = NULL;

    // Determine the number of levels/width/height
    // of the clone
    DWORD cLevels  = GetLevelCountImpl();
    DWORD Width  = m_desc.Width;
    DWORD Height = m_desc.Height;

    DWORD dwLOD = GetLODI();

    // If LOD is zero, then there are no changes
    if (dwLOD > 0)
    {
        // Clamp LOD to cLevels-1
        if (dwLOD >= cLevels)
        {
            dwLOD = cLevels - 1;
        }

        // scale down the destination texture
        // to correspond the appropiate max lod
        Width  >>= dwLOD;
        if (Width == 0)
            Width = 1;

        Height >>= dwLOD;
        if (Height == 0)
            Height = 1;

        // Reduce the number based on the our max lod.
        cLevels -= dwLOD;
    }

    // Sanity checking
    DXGASSERT(cLevels  >= 1);
    DXGASSERT(Width  >  0);
    DXGASSERT(Height >  0);

    // Create the new mip-map object now

    // Note: we treat clones as REF_INTERNAL; because
    // they are owned by the resource manager which 
    // is owned by the device. 

    // Also, we adjust the usage to disable lock-flags
    // since we don't need lockability
    DWORD Usage = m_desc.Usage;
    Usage &= ~(D3DUSAGE_LOCK | D3DUSAGE_LOADONCE);

    HRESULT hr;
    CResource *pResource = new CMipMap(Device(),
                                       Width,
                                       Height,
                                       cLevels,
                                       Usage,
                                       m_desc.Format,   // UserFormat
                                       m_desc.Format,   // RealFormat
                                       Pool,
                                       REF_INTERNAL,
                                       &hr);
    
    if (pResource == NULL)
    {
        DPF_ERR("Failed to allocate mip-map object when copying");
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr))
    {
        DPF(5, "Failed to create mip-map when doing texture management");
        pResource->DecrementUseCount();
        return hr;
    }

    *ppResource = pResource;

    return hr;
} // CMipMap::Clone

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::GetBufferDesc"

// Provides a method to access basic structure of the
// pieces of the resource. A resource may be composed
// of one or more buffers.
const D3DBUFFER_DESC* CMipMap::GetBufferDesc() const
{
    return (const D3DBUFFER_DESC*)&m_desc;
} // CMipMap::GetBufferDesc



// IUnknown methods
#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::QueryInterface"

STDMETHODIMP CMipMap::QueryInterface(REFIID       riid, 
                                     LPVOID FAR * ppvObj)
{
    API_ENTER(Device());

    if (!VALID_PTR_PTR(ppvObj))
    {
        DPF_ERR("Invalid ppvObj parameter for a IDirect3DTexture8::QueryInterface");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_PTR(&riid, sizeof(GUID)))
    {
        DPF_ERR("Invalid guid memory address to IDirect3DTexture8::QueryInterface");
        return D3DERR_INVALIDCALL;
    }

    if (riid == IID_IDirect3DTexture8       || 
        riid == IID_IDirect3DBaseTexture8   ||
        riid == IID_IDirect3DResource8      ||
        riid == IID_IUnknown)
    {
        *ppvObj = static_cast<void*>(static_cast<IDirect3DTexture8 *>(this));
        AddRef();
        return S_OK;
    }

    DPF_ERR("Unsupported Interface identifier passed to IDirect3DTexture8::QueryInterface");

    // Null out param
    *ppvObj = NULL;
    return E_NOINTERFACE;
} // QueryInterface

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::AddRef"

STDMETHODIMP_(ULONG) CMipMap::AddRef()
{
    API_ENTER_NO_LOCK(Device());    
    
    return AddRefImpl();
} // AddRef

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::Release"

STDMETHODIMP_(ULONG) CMipMap::Release()
{
    API_ENTER_SUBOBJECT_RELEASE(Device());    
    
    return ReleaseImpl();
} // Release

// IDirect3DResource methods

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::GetDevice"

STDMETHODIMP CMipMap::GetDevice(IDirect3DDevice8 **ppObj)
{
    API_ENTER(Device());
    return GetDeviceImpl(ppObj);
} // GetDevice

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::SetPrivateData"

STDMETHODIMP CMipMap::SetPrivateData(REFGUID riid, 
                                     CONST VOID   *pvData, 
                                     DWORD   cbData, 
                                     DWORD   dwFlags)
{
    API_ENTER(Device());

    // For the private data that 'really' belongs to the
    // MipMap, we use m_cLevels. (0 through m_cLevels-1 are for
    // each of the children levels.)

    return SetPrivateDataImpl(riid, pvData, cbData, dwFlags, m_cLevels);
} // SetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::GetPrivateData"

STDMETHODIMP CMipMap::GetPrivateData(REFGUID riid, 
                                     VOID   *pvData, 
                                     DWORD  *pcbData)
{
    API_ENTER(Device());

    // For the private data that 'really' belongs to the
    // MipMap, we use m_cLevels. (0 through m_cLevels-1 are for
    // each of the children levels.)
    return GetPrivateDataImpl(riid, pvData, pcbData, m_cLevels);
} // GetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::FreePrivateData"

STDMETHODIMP CMipMap::FreePrivateData(REFGUID riid)
{
    API_ENTER(Device());

    // For the private data that 'really' belongs to the
    // MipMap, we use m_cLevels. (0 through m_cLevels-1 are for
    // each of the children levels.)
    return FreePrivateDataImpl(riid, m_cLevels);
} // FreePrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::GetPriority"

STDMETHODIMP_(DWORD) CMipMap::GetPriority()
{
    API_ENTER_RET(Device(), DWORD);

    return GetPriorityImpl();
} // GetPriority

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::SetPriority"

STDMETHODIMP_(DWORD) CMipMap::SetPriority(DWORD dwPriority)
{
    API_ENTER_RET(Device(), DWORD);

    return SetPriorityImpl(dwPriority);
} // SetPriority

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::PreLoad"

STDMETHODIMP_(void) CMipMap::PreLoad(void)
{
    API_ENTER_VOID(Device());

    PreLoadImpl();
    return;
} // PreLoad

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::GetType"
STDMETHODIMP_(D3DRESOURCETYPE) CMipMap::GetType(void)
{
    API_ENTER_RET(Device(), D3DRESOURCETYPE);

    return m_desc.Type;
} // GetType

// IDirect3DMipTexture methods

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::GetLOD"

STDMETHODIMP_(DWORD) CMipMap::GetLOD()
{
    API_ENTER_RET(Device(), DWORD);

    return GetLODImpl();
} // GetLOD

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::SetLOD"

STDMETHODIMP_(DWORD) CMipMap::SetLOD(DWORD dwLOD)
{
    API_ENTER_RET(Device(), DWORD);

    return SetLODImpl(dwLOD);
} // SetLOD

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::GetLevelCount"

STDMETHODIMP_(DWORD) CMipMap::GetLevelCount()
{
    API_ENTER_RET(Device(), DWORD);

    return GetLevelCountImpl();
} // GetLevelCount

// IDirect3DMipMap methods

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::GetLevelDesc"

STDMETHODIMP CMipMap::GetLevelDesc(UINT iLevel, D3DSURFACE_DESC *pDesc)
{
    API_ENTER(Device());

    if (iLevel >= m_cLevels)
    {
        DPF_ERR("Invalid level number passed GetLevelDesc of IDirect3DTexture8");

        return D3DERR_INVALIDCALL;
    }

    return m_prgMipSurfaces[iLevel]->GetDesc(pDesc);
} // GetLevelDesc;

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::GetSurfaceLevel"

STDMETHODIMP CMipMap::GetSurfaceLevel(UINT                iLevel, 
                                      IDirect3DSurface8 **ppSurface)
{
    API_ENTER(Device());

    if (!VALID_PTR_PTR(ppSurface))
    {
        DPF_ERR("Invalid parameter passed to GetSurfaceLevel of IDirect3DTexture8");
        return D3DERR_INVALIDCALL;
    }

    if (iLevel >= m_cLevels)
    {
        DPF_ERR("Invalid level number passed GetSurfaceLevel of IDirect3DTexture8");
        *ppSurface = NULL;
        return D3DERR_INVALIDCALL;
    }

    *ppSurface = m_prgMipSurfaces[iLevel];
    (*ppSurface)->AddRef();
    return S_OK;
} // GetSurfaceLevel

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::LockRect"
STDMETHODIMP CMipMap::LockRect(UINT             iLevel,
                               D3DLOCKED_RECT  *pLockedRectData, 
                               CONST RECT      *pRect, 
                               DWORD            dwFlags)
{
    API_ENTER(Device());

    // This is a high-frequency API, so we put parameter
    // checking into debug only
#ifdef DEBUG
    
    if (iLevel >= m_cLevels)
    {
        DPF_ERR("Invalid level number passed LockRect of IDirect3DTexture8");
        return D3DERR_INVALIDCALL;
    }

#endif // DEBUG
    
    return m_prgMipSurfaces[iLevel]->LockRect(pLockedRectData, pRect, dwFlags);
} // LockRect


#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::UnlockRect"

STDMETHODIMP CMipMap::UnlockRect(UINT iLevel)
{
    API_ENTER(Device());

    // This is a high-frequency API; so we only do
    // parameter checking in debug
#ifdef DEBUG   
    if (iLevel >= m_cLevels)
    {
        DPF_ERR("Invalid level number passed UnlockRect of IDirect3DTexture8");
        return D3DERR_INVALIDCALL;
    }

    return m_prgMipSurfaces[iLevel]->UnlockRect();

#else // !DEBUG

    // We can go to the internal function to avoid
    // the unnecessary call and also to avoid the
    // crit-sec taken twice
    return m_prgMipSurfaces[iLevel]->InternalUnlockRect();

#endif // !DEBUG

} // UnlockRect

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::UpdateTexture"

// This function does type-specific parameter checking
// before calling UpdateDirtyPortion
HRESULT CMipMap::UpdateTexture(CBaseTexture *pResourceTarget)
{
    CMipMap *pTexSource = static_cast<CMipMap*>(this);
    CMipMap *pTexDest   = static_cast<CMipMap*>(pResourceTarget);

    // Figure out how many levels in the source to skip
    DXGASSERT(pTexSource->m_cLevels >= pTexDest->m_cLevels);
    DWORD StartLevel = pTexSource->m_cLevels - pTexDest->m_cLevels;
    DXGASSERT(StartLevel < 32);

    // Compute the size of the top level of the source that is
    // going to be copied.
    UINT SrcWidth  = pTexSource->Desc()->Width;
    UINT SrcHeight = pTexSource->Desc()->Height;
    if (StartLevel > 0)
    {
        SrcWidth  >>= StartLevel;
        SrcHeight >>= StartLevel;
        if (SrcWidth == 0)
            SrcWidth = 1;
        if (SrcHeight == 0)
            SrcHeight = 1;
    }

    // Source and Dest should be the same sizes at this point
    if (SrcWidth != pTexDest->Desc()->Width)
    {
        if (StartLevel)
        {
            DPF_ERR("Source and Destination for UpdateTexture are not"
                    " compatible. Since both have the same number of"
                    " mip-levels; their widths must match.");
        }
        else
        {
            DPF_ERR("Source and Destination for UpdateTexture are not"
                    " compatible. Since they have the different numbers of"
                    " mip-levels; the widths of the bottom-most levels of"
                    " the source must match all the corresponding levels"
                    " of the destination.");
        }
        return D3DERR_INVALIDCALL;
    }

    if (SrcHeight != pTexDest->Desc()->Height)
    {
        if (StartLevel)
        {
            DPF_ERR("Source and Destination for UpdateTexture are not"
                    " compatible. Since both have the same number of"
                    " mip-levels; their heights must match.");
        }
        else
        {
            DPF_ERR("Source and Destination for UpdateTexture are not"
                    " compatible. Since they have the different numbers of"
                    " mip-levels; the heights of the bottom-most levels of"
                    " the source must match all the corresponding levels"
                    " of the destination.");
        }
        return D3DERR_INVALIDCALL;
    }

    return UpdateDirtyPortion(pResourceTarget);
} // UpdateTexture


#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::UpdateDirtyPortion"

// Tells the resource that it should copy itself
// to the target. It is the caller's responsibility
// to make sure that Target is compatible with the
// Source. (The Target may have different number of mip-levels
// and be in a different pool; however, it must have the same size, 
// faces, format, etc.)
//
// This function will clear the dirty state.
HRESULT CMipMap::UpdateDirtyPortion(CResource *pResourceTarget)
{
    HRESULT hr;

    // If we are clean, then do nothing
    if (m_cRectUsed == 0)
    {
        if (IsDirty())
        {
            DPF_ERR("A Texture has been locked with D3DLOCK_NO_DIRTY_UPDATE but "
                    "no call to AddDirtyRect was made before the texture was used. "
                    "Hardware texture was not updated.");
        }
        return S_OK;
    }

    // We are dirty; so we need to get some pointers
    CMipMap *pTexSource = static_cast<CMipMap*>(this);
    CMipMap *pTexDest   = static_cast<CMipMap*>(pResourceTarget);

    if (CanTexBlt(pTexDest))
    {
        if (m_cRectUsed == MIPMAP_ALLDIRTY)
        {   
            POINT p = {0, 0};
            RECTL r = {0, 0, Desc()->Width, Desc()->Height};
            hr = static_cast<CD3DBase*>(Device())->TexBlt(pTexDest, pTexSource, &p, &r);
            if (FAILED(hr))
            {
                DPF_ERR("Failed to update texture; not clearing dirty state");
                return hr;
            }
        }
        else
        {
            DXGASSERT(m_cRectUsed < MIPMAP_ALLDIRTY);
            for (DWORD i = 0; i < m_cRectUsed; i++)
            {
                hr = static_cast<CD3DBase*>(Device())->TexBlt(pTexDest, 
                                                              pTexSource, 
                                                              (LPPOINT)&m_DirtyRectArray[i], 
                                                              (LPRECTL)&m_DirtyRectArray[i]);
                if (FAILED(hr))
                {
                    DPF_ERR("Failed to update texture; not clearing dirty state");
                    return hr;
                }
            }
        }
    }
    else
    {
        // We can't use TexBlt, so we have to copy each level individually
        // through InternalCopyRects

        // Determine number of source levels to skip
        DXGASSERT(pTexSource->m_cLevels >= pTexDest->m_cLevels);
        DWORD StartLevel = pTexSource->m_cLevels - pTexDest->m_cLevels;
        DWORD LevelsToCopy = pTexSource->m_cLevels - StartLevel;

        CBaseSurface *pSurfaceSrc;
        CBaseSurface *pSurfaceDest;

        if (m_cRectUsed == MIPMAP_ALLDIRTY)
        {
            for (DWORD iLevel = 0; iLevel < LevelsToCopy; iLevel++)
            {
                DXGASSERT(iLevel + StartLevel < this->m_cLevels);
                DXGASSERT(iLevel < pTexDest->m_cLevels);
                pSurfaceSrc = this->m_prgMipSurfaces[iLevel + StartLevel];
                pSurfaceDest = pTexDest->m_prgMipSurfaces[iLevel];

                // Source and Dest should be the same
                // or our caller made a mistake
                DXGASSERT(pSurfaceSrc->InternalGetDesc().Width == 
                          pSurfaceDest->InternalGetDesc().Width);
                DXGASSERT(pSurfaceSrc->InternalGetDesc().Height == 
                          pSurfaceDest->InternalGetDesc().Height);

                // Copy the entire level
                hr = Device()->InternalCopyRects(pSurfaceSrc, 
                                                 NULL, 
                                                 0, 
                                                 pSurfaceDest, 
                                                 NULL);
                if (FAILED(hr))
                {
                    DPF_ERR("Failed to update texture; not clearing dirty state");
                    return hr;
                }
            }
        }
        else
        {
            DXGASSERT(m_cRectUsed > 0);
            DXGASSERT(m_cRectUsed <= MIPMAP_MAXDIRTYRECT);

            if (StartLevel)
            {
                // Figure out the right set of target rects
                for (DWORD i = 0; i < m_cRectUsed; i++)
                {
                    ScaleRectDown(&m_DirtyRectArray[i], StartLevel);
                }
            }

            // Use the rects for the top level; but just
            // copy the entirety of other levels
            DXGASSERT(StartLevel < this->m_cLevels);
            DXGASSERT(0 < pTexDest->m_cLevels);
            pSurfaceSrc =  this->m_prgMipSurfaces[StartLevel];
            pSurfaceDest = pTexDest->m_prgMipSurfaces[0];

            DXGASSERT(pSurfaceSrc->InternalGetDesc().Width == 
                      pSurfaceDest->InternalGetDesc().Width);
            DXGASSERT(pSurfaceSrc->InternalGetDesc().Height == 
                      pSurfaceDest->InternalGetDesc().Height);

            // Passing points as NULL means just do a non-translated
            // copy

            // CONSIDER: Maybe we should use the rects for copying the top
            // two levels..
            hr = Device()->InternalCopyRects(pSurfaceSrc, 
                                             m_DirtyRectArray, 
                                             m_cRectUsed, 
                                             pSurfaceDest, 
                                             NULL);       // pPoints

            if (FAILED(hr))
            {
                DPF_ERR("Failed to update texture; not clearing dirty state");
                return hr;
            }

            // Copy each of the levels
            for (DWORD iLevel = 1; iLevel < LevelsToCopy; iLevel++)
            {
                DXGASSERT(iLevel + StartLevel < this->m_cLevels);
                DXGASSERT(iLevel < pTexDest->m_cLevels);

                // Get the next surfaces
                pSurfaceSrc = this->m_prgMipSurfaces[iLevel + StartLevel];
                pSurfaceDest = pTexDest->m_prgMipSurfaces[iLevel];

                // Check that sizes match
                DXGASSERT(pSurfaceSrc->InternalGetDesc().Width == 
                          pSurfaceDest->InternalGetDesc().Width);
                DXGASSERT(pSurfaceSrc->InternalGetDesc().Height == 
                          pSurfaceDest->InternalGetDesc().Height);

                // Copy the entirety of non-top levels
                hr = Device()->InternalCopyRects(pSurfaceSrc, 
                                                 NULL, 
                                                 0, 
                                                 pSurfaceDest, 
                                                 NULL);
                if (FAILED(hr))
                {
                    DPF_ERR("Failed to update texture; not clearing dirty state");
                    return hr;
                }
            }
        }
    }

    if (FAILED(hr))
    {
        DPF_ERR("Failed to update texture; not clearing dirty state");

        return hr;
    }

    // Remember that we did the work
    m_cRectUsed = 0;

    // Notify Resource base class that we are now clean
    OnResourceClean();
    DXGASSERT(!IsDirty());

    return S_OK;
} // CMipMap::UpdateDirtyPortion

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::MarkAllDirty"

// Allows the Resource Manager to mark the texture
// as needing to be completely updated on next
// call to UpdateDirtyPortion
void CMipMap::MarkAllDirty()
{
    // Set palette to __INVALIDPALETTE so that UpdateTextures
    // calls the DDI SetPalette the next time.
    SetPalette(__INVALIDPALETTE);

    m_cRectUsed = MIPMAP_ALLDIRTY;

    // Notify Resource base class that we are now dirty
    OnResourceDirty();

    return;
} // CMipMap::MarkAllDirty

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::OnSurfaceLock"

// Methods for the MipSurface to call
// Notification when a mip-level is locked for writing
void CMipMap::OnSurfaceLock(DWORD iLevel, CONST RECT *pRect, DWORD Flags)
{
    // Sync first
    Sync();

    // We only care about the top-most level of the mip-map
    // for dirty rect information
    if (iLevel != 0)
    {
        return;
    }

    // We don't need to mark the surface dirty if this was a
    // read-only lock; (this can happen for RT+Tex where we
    // need to sync even for read-only locks).
    if (Flags & D3DLOCK_READONLY)
    {
        return;
    }
    
    // Send dirty notification
    OnResourceDirty();

    // Remember this dirty rect
    if (m_cRectUsed != MIPMAP_ALLDIRTY &&
        !(Flags & D3DLOCK_NO_DIRTY_UPDATE))
    {
        InternalAddDirtyRect(pRect);
    }

    // We're done now.
    return;

} // CMipMap::OnSurfaceLock

// AddDirtyRect Method
#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::AddDirtyRect"
STDMETHODIMP CMipMap::AddDirtyRect(CONST RECT *pRect)
{
    API_ENTER(Device());

    if (pRect != NULL && !VALID_PTR(pRect, sizeof(RECT)))
    {
        DPF_ERR("Invalid parameter to of IDirect3DTexture8::AddDirtyRect");
        return D3DERR_INVALIDCALL;
    }

    if (pRect)
    {
        if (!CPixel::IsValidRect(Desc()->Format,
                                 Desc()->Width, 
                                 Desc()->Height, 
                                 pRect))
        {
            DPF_ERR("AddDirtyRect for a Texture failed");
            return D3DERR_INVALIDCALL;
        }
    }

    InternalAddDirtyRect(pRect);
    return S_OK;
} // AddDirtyRect

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::InternalAddDirtyRect"

// Internal version of AddDirtyRect: no crit-sec
// or parameter checking
void CMipMap::InternalAddDirtyRect(CONST RECT *pRect)
{
    // If driver managed then batch token
    if (Desc()->Pool == D3DPOOL_MANAGED && !IsD3DManaged())
    {
        RECTL Rect;
        DXGASSERT((Device()->GetD3DCaps()->Caps2 & DDCAPS2_CANMANAGERESOURCE) != 0);
        if (pRect == NULL)
        {
            Rect.left = 0;
            Rect.top = 0;
            Rect.right = (LONG)Desc()->Width;
            Rect.bottom = (LONG)Desc()->Height;
        }
        else
        {
            Rect = *((CONST RECTL*)pRect);
        }
        static_cast<CD3DBase*>(Device())->AddDirtyRect(this, &Rect); // This will fail only due to catastrophic
                                                                     // error and we or the app can't do a
                                                                     // a whole lot about it, so return nothing
        return;
    }

    // Need to mark dirty bit in CResource so that the resource manager works correctly.
    OnResourceDirty();

    // If everything is being modified; then we're totally dirty
    if (pRect == NULL)
    {
        m_cRectUsed = MIPMAP_ALLDIRTY;
        return;
    }

    // If we're all dirty, we can't get dirtier
    if (m_cRectUsed == MIPMAP_ALLDIRTY)
    {
        return;
    }

    // If the rect is the entire surface then we're all dirty 
    DXGASSERT(pRect != NULL);
    if (pRect->left     == 0                        &&
        pRect->top      == 0                        &&
        pRect->right    == (LONG)Desc()->Width      &&
        pRect->bottom   == (LONG)Desc()->Height)
    {
        m_cRectUsed = MIPMAP_ALLDIRTY;
        return;
    }

    // If we have filled up our rects; then we're also all dirty now
    if (m_cRectUsed == MIPMAP_MAXDIRTYRECT)
    {
        m_cRectUsed = MIPMAP_ALLDIRTY;
        return;
    }

    // Remember this rect
    DXGASSERT(m_cRectUsed < MIPMAP_MAXDIRTYRECT);
    DXGASSERT(pRect != NULL);
    m_DirtyRectArray[m_cRectUsed] = *pRect;
    m_cRectUsed++;

    return;
} // InternalAddDirtyRect


#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::IsTextureLocked"

// Debug only parameter checking do determine if a piece
// of a mip-chain is locked
#ifdef DEBUG
BOOL CMipMap::IsTextureLocked()
{
    for (UINT iLevel = 0; iLevel < m_cLevels; iLevel++)
    {
        if (m_prgMipSurfaces[iLevel]->IsLocked())
            return TRUE;
    }
    return FALSE;

} // IsTextureLocked
#endif // !DEBUG


// End of file : mipmap.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\mipsurf.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mipsurf.cpp
 *  Content:    Implementation of the CMipSurface and CDriverMipSurface 
 *              classes.
 *
 *
 ***************************************************************************/

#include "ddrawpr.h"
#include "mipsurf.hpp"

// IUnknown methods

#undef DPF_MODNAME
#define DPF_MODNAME "CMipSurface::QueryInterface"

STDMETHODIMP CMipSurface::QueryInterface (REFIID  riid, 
                                          void  **ppvObj)
{
    API_ENTER(Device());

    if (!VALID_PTR_PTR(ppvObj))
    {
        DPF_ERR("Invalid ppvObj parameter for QueryInterface for a Surface of a Texture");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_PTR(&riid, sizeof(GUID)))
    {
        DPF_ERR("Invalid guid memory address to QueryInterface for a Surface of a Texture");
        return D3DERR_INVALIDCALL;
    }

    if (riid == IID_IDirect3DSurface8  || 
        riid == IID_IUnknown)
    {
        *ppvObj = static_cast<void*>(static_cast<IDirect3DSurface8 *>(this));
        AddRef();
        return S_OK;
    }

    DPF_ERR("Unsupported Interface identifier passed to QueryInterface for a Surface of a Texture");

    // Null out param
    *ppvObj = NULL;
    return E_NOINTERFACE;
} // QueryInterface

#undef DPF_MODNAME
#define DPF_MODNAME "CMipSurface::AddRef"

STDMETHODIMP_(ULONG) CMipSurface::AddRef()
{
    API_ENTER_NO_LOCK(Device());    

#ifdef DEBUG
    m_cRefDebug++;
#endif // DEBUG

    return m_pParent->AddRefImpl();
} // AddRef

#undef DPF_MODNAME
#define DPF_MODNAME "CMipSurface::Release"

STDMETHODIMP_(ULONG) CMipSurface::Release()
{
    API_ENTER_SUBOBJECT_RELEASE(Device());    

#ifdef DEBUG
    m_cRefDebug--;
    if (m_cRefDebug & 0x80000000)
    {
        DPF_ERR("A level of a mip-map has been released more often than it has been add-ref'ed! Danger!!");
    }
#endif // DEBUG

    return m_pParent->ReleaseImpl();
} // Release

// IBuffer methods

#undef DPF_MODNAME
#define DPF_MODNAME "CMipSurface::SetPrivateData"

STDMETHODIMP CMipSurface::SetPrivateData(REFGUID riid, 
                                         CONST void   *pvData, 
                                         DWORD   cbData, 
                                         DWORD   dwFlags)
{
    API_ENTER(Device());

    return m_pParent->SetPrivateDataImpl(riid, 
                                         pvData, 
                                         cbData, 
                                         dwFlags, 
                                         m_iLevel);
} // SetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CMipSurface::GetPrivateData"

STDMETHODIMP CMipSurface::GetPrivateData(REFGUID riid, 
                                         void   *pvData, 
                                         DWORD  *pcbData)
{
    API_ENTER(Device());

    return m_pParent->GetPrivateDataImpl(riid,
                                         pvData,
                                         pcbData,
                                         m_iLevel);

} // GetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CMipSurface::FreePrivateData"

STDMETHODIMP CMipSurface::FreePrivateData(REFGUID riid)
{
    API_ENTER(Device());

    return m_pParent->FreePrivateDataImpl(riid,
                                          m_iLevel);
} // FreePrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CMipSurface::GetContainer"

STDMETHODIMP CMipSurface::GetContainer(REFIID riid, 
                                       void **ppContainer)
{
    API_ENTER(Device());

    return m_pParent->QueryInterface(riid, ppContainer);
} // OpenContainer

#undef DPF_MODNAME
#define DPF_MODNAME "CMipSurface::GetDevice"

STDMETHODIMP CMipSurface::GetDevice(IDirect3DDevice8 **ppDevice)
{
    API_ENTER(Device());

    return m_pParent->GetDevice(ppDevice);
} // OpenDevice

// IDirect3DSurface8 methods

#undef DPF_MODNAME
#define DPF_MODNAME "CMipSurface::GetDesc"

STDMETHODIMP CMipSurface::GetDesc(D3DSURFACE_DESC *pDesc)
{
    API_ENTER(Device());

    // If parameters are bad, then we should fail some stuff
    if (!VALID_WRITEPTR(pDesc, sizeof(D3DSURFACE_DESC)))
    {
        DPF_ERR("bad pointer for pDesc passed to GetDesc for a Level of a Texture");
        return D3DERR_INVALIDCALL;
    }

    // The internal desc indicates the real
    // format and pool. We need to report
    // back the original data
    *pDesc = InternalGetDesc();

    pDesc->Pool   = m_pParent->GetUserPool();
    pDesc->Format = m_pParent->GetUserFormat();
    pDesc->Usage &= D3DUSAGE_EXTERNAL;

    // We're done
    return S_OK;
} // GetDesc

#undef DPF_MODNAME
#define DPF_MODNAME "CMipSurface::InternalGetDesc"

D3DSURFACE_DESC CMipSurface::InternalGetDesc() const
{
    // We basically get our surface desc from our parent
    // and then modify the width and height fields.
    D3DSURFACE_DESC desc;
    desc          = *m_pParent->Desc();
    desc.Width  >>= m_iLevel;
    desc.Height >>= m_iLevel;

    if (desc.Width == 0)
    {
        desc.Width = 1;
    }
    if (desc.Height == 0)
    {
        desc.Height = 1;
    }

    // Also need to modify the type field
    desc.Type = D3DRTYPE_SURFACE;

    // Also modify the size field
    desc.Size = CPixel::ComputeSurfaceSize(desc.Width, 
                                           desc.Height, 
                                           desc.Format);

    // We're done
    return desc;
} // InternalGetDesc


#undef DPF_MODNAME
#define DPF_MODNAME "CMipSurface::LockRect"

STDMETHODIMP CMipSurface::LockRect(D3DLOCKED_RECT *pLockedRectData, 
                                   CONST RECT     *pRect, 
                                   DWORD           dwFlags)
{   
    API_ENTER(Device());

    // This is a high-frequency API, so we put parameter
    // checking into debug only
#ifdef DEBUG

    // If parameters are bad, then we should fail some stuff
    if (!VALID_WRITEPTR(pLockedRectData, sizeof(D3DLOCKED_RECT)))
    {
        DPF_ERR("bad pointer for pLockedRectData passed to LockRect for a Level of a Texture");
        return D3DERR_INVALIDCALL;
    }

    // Zero out returned data (in debug at least)
    ZeroMemory(pLockedRectData, sizeof(D3DLOCKED_RECT));

    // Validate Rect
    if (pRect != NULL)
    {
        DWORD Width  = m_pParent->Desc()->Width  >> m_iLevel;
        DWORD Height = m_pParent->Desc()->Height >> m_iLevel;

        if (!CPixel::IsValidRect(m_pParent->Desc()->Format,
                                 Width, 
                                 Height, 
                                 pRect))
        {
            DPF_ERR("LockRect for a level of a Texture failed");
            return D3DERR_INVALIDCALL;
        }
    }

    if (dwFlags & ~D3DLOCK_SURF_VALID)
    {
        if (dwFlags & D3DLOCK_DISCARD)
        {
            if (dwFlags & D3DLOCK_READONLY)
            {
                DPF_ERR("D3DLOCK_READONLY is not allowed with D3DLOCK_DISCARD");
                return D3DERR_INVALIDCALL;
            }
            if (!(m_pParent->Desc()->Usage & D3DUSAGE_DYNAMIC))
            {
                DPF_ERR("D3DLOCK_DISCARD is allowed only with dynamic textures");
                return D3DERR_INVALIDCALL;
            }
            if (m_iLevel > 0)
            {
                DPF_ERR("D3DLOCK_DISCARD is allowed only on level 0"
                        " (the top mip level). DISCARD in this case will discard"
                        " the entire mipmap.");
                return D3DERR_INVALIDCALL;
            }
            if (pRect != NULL)
            {
                DPF_ERR("Subrects not allowed with D3DLOCK_DISCARD");
                return D3DERR_INVALIDCALL;
            }
        }
        else
        {
            DPF_ERR("Invalid dwFlags parameter passed to LockRect for a Level of a Texture");
            DPF_EXPLAIN_BAD_LOCK_FLAGS(0, dwFlags & ~D3DLOCK_SURF_VALID);
            return D3DERR_INVALIDCALL;
        }
    }
#endif // DEBUG

    // We do this checking in retail too. Must stay in.
    if (!m_isLockable)
    {
        m_pParent->ReportWhyLockFailed();
        return D3DERR_INVALIDCALL;
    }

    // WARNING: For performance reasons, this code is 
    // duplicated in CMipSurface::InternalLockRect

    // Only one lock outstanding at a time is supported
    if (m_isLocked)
    {
        DPF_ERR("LockRect failed on a mip level; surface was already locked.");
        return D3DERR_INVALIDCALL;
    }

    // Notify the parent/device if we are about to be modified
    if ( (m_pParent->GetUserPool() != D3DPOOL_SCRATCH) && (!(dwFlags & D3DLOCK_READONLY)) )
    {
        m_pParent->OnSurfaceLock(m_iLevel, pRect, dwFlags);
    }

    // Figure out our stride/pointer to bits

    // CONSIDER: maybe we should cache our pitch/starting
    // pointer to make this call much cheaper.
    m_pParent->ComputeMipMapOffset(m_iLevel, 
                                   pRect,
                                   pLockedRectData);

    // Mark ourselves as locked
    m_isLocked = 1;

    // Done
    return S_OK;

} // CMipSurface::LockRect

HRESULT CMipSurface::InternalLockRect(D3DLOCKED_RECT *pLockedRectData, 
                                      CONST RECT     *pRect, 
                                      DWORD           dwFlags)
{   
    // WARNING: For performance reasons, this code is 
    // duplicated in CMipSurface::LockRect

    // Only one lock outstanding at a time is supported
    if (m_isLocked)
    {
        DPF_ERR("LockRect failed on a mip level; surface was already locked.");
        return D3DERR_INVALIDCALL;
    }

    // Notify the parent/device if we are about to be modified
    if ( (m_pParent->GetUserPool() != D3DPOOL_SCRATCH) && (!(dwFlags & D3DLOCK_READONLY)) )
    {
        m_pParent->OnSurfaceLock(m_iLevel, pRect, dwFlags);
    }

    // Figure out our stride/pointer to bits

    // CONSIDER: maybe we should cache our pitch/starting
    // pointer to make this call much cheaper.
    m_pParent->ComputeMipMapOffset(m_iLevel, 
                                   pRect,
                                   pLockedRectData);

    // Mark ourselves as locked
    m_isLocked = 1;

    // Done
    return S_OK;
} // InternalLockRect

#undef DPF_MODNAME
#define DPF_MODNAME "CMipSurface::UnlockRect"

STDMETHODIMP CMipSurface::UnlockRect()
{
    API_ENTER(Device());

#ifdef DEBUG
    // If we aren't locked; then something is wrong
    if (m_isLocked == 0)
    {
        DPF_ERR("UnlockRect failed on a mip level; surface wasn't locked.");
        return D3DERR_INVALIDCALL;
    }
#endif // DEBUG

    // Clear our locked state
    m_isLocked = 0;

    // If we are lock-once; then we mark ourselves as not lockable
    if (m_pParent->Desc()->Usage & D3DUSAGE_LOADONCE)
    {
        m_isLockable = FALSE;
    }

    // Done
    return S_OK;
} // UnlockRect

#undef DPF_MODNAME
#define DPF_MODNAME "CMipSurface::InternalUnlockRect"

HRESULT CMipSurface::InternalUnlockRect()
{
    // All this is copied into UnlockRect for speed;
    // maintain both paths !!!

    // Clear our locked state
    m_isLocked = 0;

    // If we are lock-once; then we mark ourselves as not lockable
    if (m_pParent->Desc()->Usage & D3DUSAGE_LOADONCE)
    {
        m_isLockable = FALSE;
    }

    // Done
    return S_OK;
} // InternalUnlockRect

//
// CDriverMipSurface class modifies the implementation
// of the LockRect and UnlockRect methods of the CMipSurface class
//

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverMipSurface::LockRect"

STDMETHODIMP CDriverMipSurface::LockRect(D3DLOCKED_RECT *pLockedRectData, 
                                         CONST RECT     *pRect, 
                                         DWORD           dwFlags)
{   
    API_ENTER(Device());

    // If parameters are bad, then we should fail some stuff
    if (!VALID_WRITEPTR(pLockedRectData, sizeof(D3DLOCKED_RECT)))
    {
        DPF_ERR("bad pointer for m_pLockedRectData passed to LockRect for a Level of a Texture");
        return D3DERR_INVALIDCALL;
    }

    // Zero out returned data
    ZeroMemory(pLockedRectData, sizeof(D3DLOCKED_RECT));

    // Validate Rect
    if (pRect != NULL)
    {
        DWORD Width  = m_pParent->Desc()->Width  >> m_iLevel;
        DWORD Height = m_pParent->Desc()->Height >> m_iLevel;

        if (!CPixel::IsValidRect(m_pParent->Desc()->Format,
                                 Width, 
                                 Height, 
                                 pRect))
        {
            DPF_ERR("LockRect for a level of a Texture failed");
            return D3DERR_INVALIDCALL;
        }
    }

    if (dwFlags & ~D3DLOCK_SURF_VALID)
    {
        if (dwFlags & D3DLOCK_DISCARD)
        {
            if (dwFlags & D3DLOCK_READONLY)
            {
                DPF_ERR("D3DLOCK_READONLY is not allowed with D3DLOCK_DISCARD");
                return D3DERR_INVALIDCALL;
            }
            if (!(m_pParent->Desc()->Usage & D3DUSAGE_DYNAMIC))
            {
                DPF_ERR("D3DLOCK_DISCARD is allowed only with dynamic textures");
                return D3DERR_INVALIDCALL;
            }
            if (m_iLevel > 0)
            {
                DPF_ERR("D3DLOCK_DISCARD is allowed only on level 0"
                        " (the top mip level). DISCARD in this case will discard"
                        " the entire mipmap.");
                return D3DERR_INVALIDCALL;
            }
            if (pRect != NULL)
            {
                DPF_ERR("Subrects not allowed with D3DLOCK_DISCARD");
                return D3DERR_INVALIDCALL;
            }
        }
        else
        {
            DPF_ERR("Invalid dwFlags parameter passed to LockRect for a Level of a Texture");
            DPF_EXPLAIN_BAD_LOCK_FLAGS(0, dwFlags & ~D3DLOCK_SURF_VALID);
            return D3DERR_INVALIDCALL;
        }
    }

    if (!m_isLockable)
    {
        m_pParent->ReportWhyLockFailed();
        return D3DERR_INVALIDCALL;
    }

    return InternalLockRect(pLockedRectData, pRect, dwFlags);
} // LockRect

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverMipSurface::InternalLockRect"

HRESULT CDriverMipSurface::InternalLockRect(D3DLOCKED_RECT *pLockedRectData, 
                                            CONST RECT     *pRect, 
                                            DWORD           dwFlags)
{   

    // Only one lock outstanding at a time is supported
    if (m_isLocked)
    {
        DPF_ERR("LockRect failed on a mip level; surface was already locked for a Level of a Texture");
        return D3DERR_INVALIDCALL;
    }

    // Notify the parent/device if we are about to be accessed.
    // Driver textures may be written to by HW through 
    // SRT/DrawPrim as well as UpdateTexture. So we may need to sync 
    // with the current command batch.
    m_pParent->OnSurfaceLock(m_iLevel, pRect, dwFlags);
    
    // Prepare a LockData structure for the HAL call
    D3D8_LOCKDATA lockData = {
        Device()->GetHandle(),
        m_hKernelHandle
    };

    if (pRect != NULL)
    {
        lockData.bHasRect = TRUE;
        lockData.rArea = *((RECTL *) pRect);
    }
    else
    {
        lockData.bHasRect = FALSE;
    }

    lockData.dwFlags = dwFlags;
    
    HRESULT hr = Device()->GetHalCallbacks()->Lock(&lockData);
    if (FAILED(hr))
    {
        DPF_ERR("Failed to lock driver mip-map surface");
        return hr;
    }

    // Fill in the Locked_Rect fields 
    D3DFORMAT Format = m_pParent->Desc()->Format;
    if (CPixel::IsDXT(Format))
    {
        // Pitch is the number of bytes for
        // one row's worth of blocks for linear formats

        // Convert to blocks
        UINT Width = (m_pParent->Desc()->Width + 3)/4;
        for (UINT i = 0; i < m_iLevel; i++)
        {
            // Shrink width by half round up to 1 block
            if (Width > 1)
            {
                Width ++;
                Width >>= 1;
            }
        }
        // At least one block
        if (Width == 0)
            Width = 1;

        if (Format == D3DFMT_DXT1)
        {
            // 8 bytes per block for DXT1
            pLockedRectData->Pitch = Width * 8;
        }
        else
        {
            // 16 bytes per block for DXT2-5
            pLockedRectData->Pitch = Width * 16;
        }
    }
    else
    {
        pLockedRectData->Pitch = lockData.lPitch;
    }

    pLockedRectData->pBits  = lockData.lpSurfData;

#ifdef DEBUG
    if ((dwFlags & D3DLOCK_DISCARD))
    {
        DXGASSERT(m_iLevel == 0);
        if (!CPixel::IsFourCC(Format) &&
            !CPixel::IsIHVFormat(Format))
        {
            DXGASSERT(pRect == NULL);
            memset(pLockedRectData->pBits, 0xDD, pLockedRectData->Pitch * m_pParent->Desc()->Height);
            for (UINT i = 1; i < m_pParent->GetLevelCount(); ++i)
            {
                D3DLOCKED_RECT Rect;
                HRESULT hr = m_pParent->LockRect(i, &Rect, NULL, 0);
                if (FAILED(hr))
                {
                    DPF(1, "Lock to mipsublevel failed. Not good.");
                    break;
                }
                D3DSURFACE_DESC LevelDesc;
                m_pParent->GetLevelDesc(i, &LevelDesc);
                memset(Rect.pBits, 0xDD, Rect.Pitch * LevelDesc.Height);
                m_pParent->UnlockRect(i);
            }
        }
    }
#endif // DEBUG

    // Mark ourselves as locked
    m_isLocked = 1;

    // Done
    return S_OK;
} // CDriverMipSurface::InternalLockRect

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverMipSurface::UnlockRect"

STDMETHODIMP CDriverMipSurface::UnlockRect()
{
    API_ENTER(Device());

    // If we aren't locked; then something is wrong
    if (m_isLocked == 0)
    {
        DPF_ERR("UnlockRect failed on a mip level; surface wasn't locked.");
        return D3DERR_INVALIDCALL;
    }

    DXGASSERT(m_isLockable);

    return InternalUnlockRect();
} // CDriverMipSurface::UnlockRect

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverMipSurface::InternalUnlockRect"

HRESULT CDriverMipSurface::InternalUnlockRect()
{
    // Call the driver to perform the unlock
    D3D8_UNLOCKDATA unlockData = {
        m_pParent->Device()->GetHandle(),
        m_hKernelHandle
    };

    HRESULT hr = Device()->GetHalCallbacks()->Unlock(&unlockData);
    if (FAILED(hr))
    {
        DPF_ERR("Driver surface failed to unlock for a Level of a Texture");
        return hr;
    }

    // Clear our locked state
    m_isLocked = 0;

    // If we are lock-once; then we mark ourselves as not lockable
    if (m_pParent->Desc()->Usage & D3DUSAGE_LOADONCE)
    {
        m_isLockable = FALSE;
    }

    // Done
    return S_OK;
} // CDriverMipSurface::UnlockRect


// End of file : mipsurf.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\mipvol.hpp ===
#ifndef __MIPVOL_HPP__
#define __MIPVOL_HPP__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mipvol.hpp
 *  Content:    Class header the mip-volume class. This class acts a 
 *              container for Volumes that are used as textures.
 *
 *
 ***************************************************************************/

// Includes
#include "texture.hpp"
#include "pixel.hpp"

// Forward decls
class CVolume;

//
// The mip-map class holds a collection of CVolumes. The MipVolume class
// implements the IDirect3DVolumeTexture8 interface; each Volume implements 
// the IDirect3DVolume8 interface. To reduce overhead per level, we have
// put most of the "real" guts of each volume into the container class;
// i.e. most of the methods of the Volume really just end up calling
// something in the MipVolume object.
//
// The base class implementation assumes a sys-mem allocation.
//

class CMipVolume : public CBaseTexture, public IDirect3DVolumeTexture8
{
public:
    // Creation method to allow creation of MipVolumes no matter
    // their actual underlying type.
    static HRESULT Create(CBaseDevice              *pDevice, 
                          DWORD                     cpWidth,
                          DWORD                     cpHeight,
                          DWORD                     cpDepth,
                          DWORD                     cLevels,
                          DWORD                     dwUsage,
                          D3DFORMAT                 Format,
                          D3DPOOL                   Pool,
                          IDirect3DVolumeTexture8 **ppMipVolume);

    // Destructor
    virtual ~CMipVolume();

    // IUnknown methods
    STDMETHOD(QueryInterface) (REFIID  riid, 
                               VOID  **ppvObj);
    STDMETHOD_(ULONG,AddRef)  ();
    STDMETHOD_(ULONG,Release) ();

    // IDirect3DResource methods
    STDMETHOD(GetDevice) (IDirect3DDevice8 **ppvObj);

    STDMETHOD(SetPrivateData)(REFGUID  riid, 
                              CONST VOID    *pvData, 
                              DWORD    cbData, 
                              DWORD    dwFlags);

    STDMETHOD(GetPrivateData)(REFGUID  riid, 
                              VOID    *pvData, 
                              DWORD   *pcbData);

    STDMETHOD(FreePrivateData)(REFGUID riid);

    STDMETHOD_(DWORD, GetPriority)();
    STDMETHOD_(DWORD, SetPriority)(DWORD dwPriority);
    STDMETHOD_(void, PreLoad)();
    STDMETHOD_(D3DRESOURCETYPE, GetType)();

    // IDirect3DMipTexture methods
    STDMETHOD_(DWORD, GetLOD)();
    STDMETHOD_(DWORD, SetLOD)(DWORD dwLOD);
    STDMETHOD_(DWORD, GetLevelCount)();

    // IDirect3DMipVolume methods
    STDMETHOD(GetLevelDesc)(UINT iLevel, D3DVOLUME_DESC *pDesc);
    STDMETHOD(GetVolumeLevel)(UINT                iLevel,
                              IDirect3DVolume8  **ppVolumeLevel);

    STDMETHOD(LockBox)(UINT             iLevel,
                       D3DLOCKED_BOX   *pLockedBox, 
                       CONST D3DBOX    *pBox, 
                       DWORD            dwFlags);
    STDMETHOD(UnlockBox)(UINT           iLevel);


    STDMETHOD(AddDirtyBox)(CONST D3DBOX *pBox);

    // Direct accessor for surface descriptor
    const D3DVOLUME_DESC *Desc() const
    {
        return &m_desc;
    } // AccessDesc;

    // Helper for Lock
    void ComputeMipVolumeOffset(UINT            iLevel, 
                                CONST D3DBOX   *pBox, 
                                D3DLOCKED_BOX  *pLockedBoxData)
    {
        CPixel::ComputeMipVolumeOffset(Desc(),
                                       iLevel,
                                       m_rgbPixels,
                                       pBox,
                                       pLockedBoxData);
    } // ComputeMipVolumeOffset

    // Notification when a mip-level is locked for writing
    void OnVolumeLock(DWORD iLevel, CONST D3DBOX *pBox, DWORD dwFlags);


    // Methods for the CResource

    // Specifies a creation of a resource that
    // looks just like the current one; in a new POOL
    // with a new LOD.
    virtual HRESULT Clone(D3DPOOL     Pool, 
                          CResource **ppResource) const;

    // Provides a method to access basic structure of the
    // pieces of the resource. 
    virtual const D3DBUFFER_DESC* GetBufferDesc() const;

    // Updates destination with source dirty rects
    virtual HRESULT UpdateDirtyPortion(CResource *pResourceTarget);

    // Allows the Resource Manager to mark the texture
    // as needing to be completely updated on next
    // call to UpdateDirtyPortion
    virtual void MarkAllDirty();

    // Methods for CBaseTexture

    // Method for UpdateTexture to call; does type-specific
    // parameter checking before calling UpdateDirtyPortion
    virtual HRESULT UpdateTexture(CBaseTexture *pTextureTarget);

    // Parameter validation method to make sure that no part of
    // the texture is locked.
#ifdef DEBUG
    virtual BOOL IsTextureLocked();
#endif  // DEBUG


private:
    // Constructor returns an error code
    // if the object could not be fully
    // constructed
    CMipVolume(CBaseDevice *pDevice, 
               DWORD        cpWidth,
               DWORD        cpHeight,
               DWORD        cpDepth,
               DWORD        cLevels,
               DWORD        dwUsage,
               D3DFORMAT    Format,
               D3DPOOL      Pool,
               REF_TYPE     refType,
               HRESULT     *phr
               );

    // Internal implementation of AddDirtyBox
    void InternalAddDirtyBox(CONST D3DBOX *pBox);

    // Each MipVolume has an array of CMipSurfaces
    CVolume        **m_VolumeArray;
    
    // Each MipVolume has a memory block that holds
    // all the pixel data in a contiguous chunk
    BYTE            *m_rgbPixels;

    // Keep track of description
    D3DVOLUME_DESC m_desc;

    // In DX7 we kept track of upto 6 RECTs per mip-chain.
    // These rects indicate which portion of the top-most level of
    // a mip-chain were modified. (We continue to ignore modifications 
    // to lower levels of the mip-chain. This is by-design.)
    //
    // For MipVolumes, we follow the same guidelines.. but it is less
    // clear that this is the right number to choose.
     
    enum 
    {
        MIPVOLUME_MAXDIRTYBOX  = 6,
        MIPVOLUME_ALLDIRTY     = 7
    };

    D3DBOX     m_DirtyBoxArray[MIPVOLUME_MAXDIRTYBOX];

    // If m_cBoxUsed is greater than MIPVOLUME_MAXDIRTYBOX
    // then it means that everything is dirty
    UINT        m_cBoxUsed;

}; // class CMipVolume

#endif // __MIPVOL_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\pixel.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3dobj.cpp
 *  Content:    Base class implementation for resources and buffers
 *
 *
 ***************************************************************************/

#include "ddrawpr.h"
#include "pixel.hpp"

IHVFormatInfo *CPixel::m_pFormatList = 0;

extern "C" void CPixel__Cleanup()
{
    CPixel::Cleanup();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::Cleanup"
void CPixel::Cleanup()
{
    while(m_pFormatList != 0)
    {
        IHVFormatInfo *t = m_pFormatList->m_pNext;
        delete m_pFormatList;
        m_pFormatList = t;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::BytesPerPixel"

UINT CPixel::BytesPerPixel(D3DFORMAT Format)
{
    switch (Format)
    {
    case D3DFMT_DXT1:
        // Size is negative to indicate DXT; and indicates
        // the size of the block
        return (UINT)(-8);
    case D3DFMT_DXT2:
    case D3DFMT_DXT3:
    case D3DFMT_DXT4:
    case D3DFMT_DXT5:
        // Size is negative to indicate DXT; and indicates
        // the size of the block
        return (UINT)(-16);

#ifdef VOLUME_DXT
    case D3DFMT_DXV1:
        // Size is negative to indicate DXT; and indicates
        // the size of the block
        return (UINT)(-32);

    case D3DFMT_DXV2:
    case D3DFMT_DXV3:
    case D3DFMT_DXV4:
    case D3DFMT_DXV5:
        return (UINT)(-64);
#endif //VOLUME_DXT

    case D3DFMT_A8R8G8B8:
    case D3DFMT_X8R8G8B8:
    case D3DFMT_D32:
    case D3DFMT_D24S8:
    case D3DFMT_S8D24:
    case D3DFMT_X8L8V8U8:
    case D3DFMT_X4S4D24:
    case D3DFMT_D24X4S4:
    case D3DFMT_Q8W8V8U8:
    case D3DFMT_V16U16:
    case D3DFMT_W11V11U10:
    case D3DFMT_W10V11U11:
    case D3DFMT_A2W10V10U10:
    case D3DFMT_A8X8V8U8:
    case D3DFMT_L8X8V8U8:
    case D3DFMT_A2B10G10R10:
    case D3DFMT_A8B8G8R8:
    case D3DFMT_X8B8G8R8:
    case D3DFMT_G16R16:
    case D3DFMT_D24X8:  
        return 4;

    case D3DFMT_R8G8B8:
        return 3;

    case D3DFMT_R5G6B5:
    case D3DFMT_X1R5G5B5:
    case D3DFMT_A1R5G5B5:
    case D3DFMT_A4R4G4B4:
    case D3DFMT_A8L8:
    case D3DFMT_V8U8:
    case D3DFMT_L6V5U5:
    case D3DFMT_D16:
    case D3DFMT_D16_LOCKABLE:
    case D3DFMT_D15S1:
    case D3DFMT_S1D15:
    case D3DFMT_A8P8:
    case D3DFMT_A8R3G3B2:
    case D3DFMT_UYVY:
    case D3DFMT_YUY2:
    case D3DFMT_X4R4G4B4:
        return 2;

    case D3DFMT_P8:
    case D3DFMT_L8:
    case D3DFMT_R3G3B2:
    case D3DFMT_A4L4:
    case D3DFMT_A8:
        return 1;

    default:
        return 0;
    };
}; // BytesPerPixel

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::ComputePixelStride"

UINT CPixel::ComputePixelStride(D3DFORMAT Format)
{
    UINT BPP = BytesPerPixel(Format);
    if (BPP == 0)
    {
        for(IHVFormatInfo *p = m_pFormatList; p != 0; p = p->m_pNext)
        {
            if (p->m_Format == Format)
            {
                return p->m_BPP >> 3;
            }
        }
    }
    return BPP;
}; // ComputePixelStride

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::ComputeSurfaceStride"

// Figure out a stride for a particular surface based on format and width
inline UINT CPixel::ComputeSurfaceStride(UINT cpWidth, UINT cbPixel)
{
    // Figure out basic (linear) stride;
    UINT dwStride = cpWidth * cbPixel;

    // Round up to multiple of 4 (for NT; but makes sense to maximize
    // cache hits and reduce unaligned accesses)
    dwStride = (dwStride + 3) & ~3;

    return dwStride;
}; // ComputeSurfaceStride


#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::ComputeSurfaceSize"

UINT CPixel::ComputeSurfaceSize(UINT            cpWidth,
                                UINT            cpHeight,
                                UINT            cbPixel)
{
    return cpHeight * ComputeSurfaceStride(cpWidth, cbPixel);
} // ComputeSurfaceSize

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::ComputeMipMapSize"

UINT CPixel::ComputeMipMapSize(UINT             cpWidth,
                               UINT             cpHeight,
                               UINT             cLevels,
                               D3DFORMAT       Format)
{
    UINT cbPixel = ComputePixelStride(Format);

    // Adjust pixel->block if necessary
    BOOL isDXT = IsDXT(cbPixel);
    DDASSERT((UINT)isDXT <= 1);
    if (isDXT)
    {
        AdjustForDXT(&cpWidth, &cpHeight, &cbPixel);
    }

    UINT cbSize = 0;
    for (UINT i = 0; i < cLevels; i++)
    {
        // Figure out the size for
        // each level of the mip-map
        cbSize += ComputeSurfaceSize(cpWidth, cpHeight, cbPixel);

        // Shrink width and height by half; clamp to 1 pixel
        if (cpWidth > 1)
        {
            cpWidth += (UINT)isDXT;
            cpWidth >>= 1;
        }
        if (cpHeight > 1)
        {
            cpHeight += (UINT)isDXT;
            cpHeight >>= 1;
        }
    }
    return cbSize;

} // ComputeMipMapSize

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::ComputeMipVolumeSize"

UINT CPixel::ComputeMipVolumeSize(UINT          cpWidth,
                                  UINT          cpHeight,
                                  UINT          cpDepth,
                                  UINT          cLevels,
                                  D3DFORMAT    Format)
{
    UINT cbPixel = ComputePixelStride(Format);

    // Adjust pixel->block if necessary
    BOOL isDXT       = IsDXT(cbPixel);
    BOOL isVolumeDXT = IsVolumeDXT(Format);
    DDASSERT((UINT)isDXT <= 1);

    if (isVolumeDXT)
    {
        DXGASSERT(isDXT);
        AdjustForVolumeDXT(&cpWidth, &cpHeight, &cpDepth, &cbPixel);
    }
    else if (isDXT)
    {
        AdjustForDXT(&cpWidth, &cpHeight, &cbPixel);
    }

    UINT cbSize = 0;

    for (UINT i = 0; i < cLevels; i++)
    {
        // Figure out the size for
        // each level of the mip-volume
        cbSize += cpDepth * ComputeSurfaceSize(cpWidth, cpHeight, cbPixel);

        // Shrink width and height by half; clamp to 1 pixel
        if (cpWidth > 1)
        {
            cpWidth += (UINT)isDXT;
            cpWidth >>= 1;
        }
        if (cpHeight > 1)
        {
            cpHeight += (UINT)isDXT;
            cpHeight >>= 1;
        }
        if (cpDepth > 1)
        {
            cpDepth >>= 1;
        }
    }
    return cbSize;

} // ComputeMipVolumeSize

// Given a surface desc, a level, and pointer to
// bits (pBits in the LockedRectData) and a sub-rect,
// this will fill in the pLockedRectData structure
void CPixel::ComputeMipMapOffset(const D3DSURFACE_DESC *pDescTopLevel,
                                 UINT                   iLevel,
                                 BYTE                  *pBits,
                                 CONST RECT            *pRect,
                                 D3DLOCKED_RECT        *pLockedRectData)
{
    DXGASSERT(pBits != NULL);
    DXGASSERT(pLockedRectData != NULL);
    DXGASSERT(iLevel < 32);
    DXGASSERT(pDescTopLevel != NULL);
    DXGASSERT(0 != ComputePixelStride(pDescTopLevel->Format));
    DXGASSERT(pDescTopLevel->Width > 0);
    DXGASSERT(pDescTopLevel->Height > 0);

    // CONSIDER: This is slow; and we can do a much better
    // job for the non-compressed/wacky cases.
    UINT       cbOffset = 0;
    UINT       cbPixel  = ComputePixelStride(pDescTopLevel->Format);
    UINT       cpWidth  = pDescTopLevel->Width;
    UINT       cpHeight = pDescTopLevel->Height;

    // Adjust pixel->block if necessary
    BOOL isDXT = IsDXT(cbPixel);
    DDASSERT((UINT)isDXT <= 1);
    if (isDXT)
    {
        AdjustForDXT(&cpWidth, &cpHeight, &cbPixel);
    }

    for (UINT i = 0; i < iLevel; i++)
    {
        cbOffset += ComputeSurfaceSize(cpWidth,
                                       cpHeight,
                                       cbPixel);

        // Shrink width and height by half; clamp to 1 pixel
        if (cpWidth > 1)
        {
            cpWidth += (UINT)isDXT;
            cpWidth >>= 1;
        }
        if (cpHeight > 1)
        {
            cpHeight += (UINT)isDXT;
            cpHeight >>= 1;
        }
    }

    // For DXTs, the pitch is the number of bytes
    // for a single row of blocks; which is the same
    // thing as the normal routine
    pLockedRectData->Pitch = ComputeSurfaceStride(cpWidth,
                                                  cbPixel);
    DXGASSERT(pLockedRectData->Pitch != 0);

    // Don't adjust for Rect for DXT formats
    if (pRect)
    {
        if (isDXT)
        {
            DXGASSERT((pRect->top  & 3) == 0);
            DXGASSERT((pRect->left & 3) == 0);
            cbOffset += (pRect->top  / 4) * pLockedRectData->Pitch +
                        (pRect->left / 4) * cbPixel;
        }
        else
        {
            cbOffset += pRect->top  * pLockedRectData->Pitch +
                        pRect->left * cbPixel;
        }
    }

    pLockedRectData->pBits = pBits + cbOffset;

} // ComputeMipMapOffset

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::ComputeMipVolumeOffset"

// MipVolume version of ComputeMipMapOffset
void CPixel::ComputeMipVolumeOffset(const D3DVOLUME_DESC  *pDescTopLevel,
                                    UINT                    iLevel,
                                    BYTE                    *pBits,
                                    CONST D3DBOX            *pBox,
                                    D3DLOCKED_BOX          *pLockedBoxData)
{
    DXGASSERT(pBits != NULL);
    DXGASSERT(pLockedBoxData != NULL);
    DXGASSERT(iLevel < 32);
    DXGASSERT(pDescTopLevel != NULL);
    DXGASSERT(0 != ComputePixelStride(pDescTopLevel->Format));
    DXGASSERT(pDescTopLevel->Width > 0);
    DXGASSERT(pDescTopLevel->Height > 0);
    DXGASSERT(pDescTopLevel->Depth > 0);

    UINT       cbOffset = 0;
    UINT       cbPixel  = ComputePixelStride(pDescTopLevel->Format);
    UINT       cpWidth  = pDescTopLevel->Width;
    UINT       cpHeight = pDescTopLevel->Height;
    UINT       cpDepth  = pDescTopLevel->Depth;

    // Adjust pixel->block if necessary
    BOOL isDXT       = IsDXT(cbPixel);
    BOOL isVolumeDXT = IsVolumeDXT(pDescTopLevel->Format);
    DDASSERT((UINT)isDXT <= 1);

    if (isVolumeDXT)
    {
        DXGASSERT(isDXT);
        AdjustForVolumeDXT(&cpWidth, &cpHeight, &cpDepth, &cbPixel);
    }
    else if (isDXT)
    {
        AdjustForDXT(&cpWidth, &cpHeight, &cbPixel);
    }

    for (UINT i = 0; i < iLevel; i++)
    {
        cbOffset += cpDepth * ComputeSurfaceSize(cpWidth,
                                                 cpHeight,
                                                 cbPixel);

        // Shrink width and height by half; clamp to 1 pixel
        if (cpWidth > 1)
        {
            cpWidth += (UINT)isDXT;
            cpWidth >>= 1;
        }
        if (cpHeight > 1)
        {
            cpHeight += (UINT)isDXT;
            cpHeight >>= 1;
        }
        if (cpDepth > 1)
        {
            cpDepth >>= 1;
        }
    }


    // For DXTs, the row pitch is the number of bytes
    // for a single row of blocks; which is the same
    // thing as the normal routine
    pLockedBoxData->RowPitch = ComputeSurfaceStride(cpWidth,
                                                    cbPixel);
    DXGASSERT(pLockedBoxData->RowPitch != 0);

    // For DXVs the slice pitch is the number of bytes
    // for a single plane of blocks; which is the same thing
    // as the normal routine
    pLockedBoxData->SlicePitch = ComputeSurfaceSize(cpWidth,
                                                    cpHeight,
                                                    cbPixel);
    DXGASSERT(pLockedBoxData->SlicePitch != 0);

    // Adjust for Box
    if (pBox)
    {
        UINT iStride = pLockedBoxData->RowPitch;
        UINT iSlice  = pLockedBoxData->SlicePitch;
        if (isDXT)
        {
            if (isVolumeDXT)
            {
                DXGASSERT((pBox->Front & 3) == 0);
                cbOffset += (pBox->Front / 4) * iSlice;
            }
            else
            {
                cbOffset += (pBox->Front) * iSlice;
            }

            DXGASSERT((pBox->Top  & 3) == 0);
            DXGASSERT((pBox->Left & 3) == 0);
            cbOffset += (pBox->Top  / 4) * iStride +
                        (pBox->Left / 4) * cbPixel;
        }
        else
        {
            cbOffset += pBox->Front * iSlice  +
                        pBox->Top   * iStride +
                        pBox->Left  * cbPixel;
        }
    }

    pLockedBoxData->pBits = pBits + cbOffset;

} // ComputeMipVolumeOffset


#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::IsValidRect"

BOOL CPixel::IsValidRect(D3DFORMAT   Format,
                         UINT        Width,
                         UINT        Height,
                         const RECT *pRect)
{
    if (!VALID_PTR(pRect, sizeof(RECT)))
    {
        DPF_ERR("bad pointer for pRect");
        return FALSE;
    }

    // Treat width/height of zero as 1
    if (Width == 0)
        Width = 1;
    if (Height == 0)
        Height = 1;

    // Check that Rect is reasonable
    if ((pRect->left >= pRect->right) ||
        (pRect->top >= pRect->bottom))
    {
        DPF_ERR("Invalid Rect: zero-area.");
        return FALSE;
    }

    // Check that Rect fits the surface
    if (pRect->left   < 0             ||
        pRect->top    < 0             ||
        pRect->right  > (INT)Width    ||
        pRect->bottom > (INT)Height)
    {
        DPF_ERR("pRect doesn't fit inside the surface");
        return FALSE;
    }

    // Check if 4X4 rules are needed
    if (CPixel::Requires4X4(Format))
    {
        if ((pRect->left & 3) ||
            (pRect->top  & 3))
        {
            DPF_ERR("Rects for DXT surfaces must be on 4x4 boundaries");
            return FALSE;
        }
        if ((pRect->right & 3) && ((INT)Width != pRect->right))
        {
            DPF_ERR("Rects for DXT surfaces must be on 4x4 boundaries");
            return FALSE;
        }
        if ((pRect->bottom & 3) && ((INT)Height != pRect->bottom))
        {
            DPF_ERR("Rects for DXT surfaces must be on 4x4 boundaries");
            return FALSE;
        }
    }

    // Everything checks out
    return TRUE;
} // IsValidRect

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::IsValidBox"

BOOL CPixel::IsValidBox(D3DFORMAT       Format,
                        UINT            Width,
                        UINT            Height,
                        UINT            Depth,
                        const D3DBOX   *pBox)
{
    if (!VALID_PTR(pBox, sizeof(D3DBOX)))
    {
        DPF_ERR("bad pointer for pBox");
        return FALSE;
    }

    // Treat width/height/depth of zero as 1
    if (Width == 0)
        Width = 1;
    if (Height == 0)
        Height = 1;
    if (Depth == 0)
        Depth = 1;

    // Check that Box is reasonable
    if ((pBox->Left  >= pBox->Right) ||
        (pBox->Top   >= pBox->Bottom) ||
        (pBox->Front >= pBox->Back))
    {
        DPF_ERR("Invalid Box passed: non-positive volume.");
        return FALSE;
    }

    // Check that box fits the surface
    if (pBox->Right  > Width         ||
        pBox->Bottom > Height        ||
        pBox->Back   > Depth)
    {
        DPF_ERR("Box doesn't fit inside the volume");
        return FALSE;
    }

    // Check if 4X4 rules are needed
    if (CPixel::Requires4X4(Format))
    {
        if ((pBox->Left & 3) ||
            (pBox->Top  & 3))
        {
            if (CPixel::IsVolumeDXT(Format))
                DPF_ERR("Boxes for DXV volumes must be on 4x4x4 boundaries");
            else
                DPF_ERR("Boxes for DXT volumes must be on 4x4 boundaries");

            return FALSE;
        }
        if ((pBox->Right & 3) && (Width != pBox->Right))
        {
            if (CPixel::IsVolumeDXT(Format))
                DPF_ERR("Boxes for DXV volumes must be on 4x4x4 boundaries");
            else
                DPF_ERR("Boxes for DXT volumes must be on 4x4 boundaries");
            return FALSE;
        }
        if ((pBox->Bottom & 3) && (Height != pBox->Bottom))
        {
            if (CPixel::IsVolumeDXT(Format))
                DPF_ERR("Boxes for DXV volumes must be on 4x4x4 boundaries");
            else
                DPF_ERR("Boxes for DXT volumes must be on 4x4 boundaries");
            return FALSE;
        }

        if (CPixel::IsVolumeDXT(Format))
        {
            // For Volume DXT; we need to check front/back too
            if (pBox->Front & 3)
            {
                DPF_ERR("Boxes for DXV volumes must be on 4x4x4 boundaries");
                return FALSE;
            }
            if ((pBox->Back & 3) && (Depth != pBox->Back))
            {
                DPF_ERR("Boxes for DXV volumes must be on 4x4x4 boundaries");
                return FALSE;
            }
        }
    }

    // Everything checks out
    return TRUE;
} // IsValidBox

D3DFORMAT CPixel::SuppressAlphaChannel(D3DFORMAT Format)
{
    switch(Format)
    {
    case D3DFMT_A8R8G8B8:
        return D3DFMT_X8R8G8B8;
    case D3DFMT_A1R5G5B5:
        return D3DFMT_X1R5G5B5;
    case D3DFMT_A4R4G4B4:
        return D3DFMT_X4R4G4B4;
    }

    return Format;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::Register"

HRESULT CPixel::Register(D3DFORMAT Format, DWORD BPP)
{
    DXGASSERT(BPP != 0);

    // Do not register duplicates
    for(IHVFormatInfo *p = m_pFormatList; p != 0; p = p->m_pNext)
    {
        if (p->m_Format == Format)
        {
            return S_OK;
        }
    }

    // Not found, add to registry.
    // This allocation will be leaked, but since
    // we don't expect to have a large number of
    // IHV formats, the leak is not a big deal.
    // Also, the leak will be immediately recovered
    // upon process exit.
    p = new IHVFormatInfo;
    if (p == 0)
    {
        return E_OUTOFMEMORY;
    }
    p->m_Format = Format;
    p->m_BPP = BPP;
    p->m_pNext = m_pFormatList;
    m_pFormatList = p;

    return S_OK;
}

// End of file : pixel.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\mipsurf.hpp ===
#ifndef __MIPSURF_HPP__
#define __MIPSURF_HPP__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mipsurf.hpp
 *  Content:    Class header the mipsurface class. This class acts
 *              as a level for the MipMap class. The base class
 *              assumes a system-memory allocation; while the
 *              Driver sub-class will call the driver for every
 *              lock and unlock operation.
 *
 *
 ***************************************************************************/

// Includes
#include "mipmap.hpp"

//
// Each MipSurface implements the IDirect3DSurface8 interface. 
// To reduce overhead per level, we have
// put most of the "real" guts of each surface into the MipMap container 
// class; i.e. most of the methods of the MipSurface really just end 
// up calling something in the MipMap object.
//
// The base class implementation assumes a sys-mem allocation.
//


//
// The CMipSurface class is a special class that
// works solely with the CMipMap class. Each MipSurface
// corresponds to a single level of the mip-map. They are
// not stand-alone COM objects because they share the
// same life-time as their CMipMap parent.
//
// The CDriverMipSurface class is declared later in this file
//

class CMipSurface : public CBaseSurface
{
public:
    // Constructor
    CMipSurface(CMipMap *pParent, 
                BYTE     iLevel,
                HANDLE   hKernelHandle
                ) :
        m_pParent(pParent),
        m_iLevel(iLevel),
        m_hKernelHandle(hKernelHandle)
    {
        DXGASSERT(pParent);
        DXGASSERT(hKernelHandle || (pParent->GetUserPool() == D3DPOOL_SCRATCH) );
    #ifdef DEBUG
        m_cRefDebug = 0; 
    #endif // DEBUG

        if (m_pParent->Desc()->Usage & 
                (D3DUSAGE_LOCK | D3DUSAGE_LOADONCE))
        {
            m_isLockable = TRUE;
        }
        else
        {   
            m_isLockable = FALSE;
        }

        return;
    } // CMipSurface

    ~CMipSurface()
    {
        DXGASSERT(m_cRefDebug == 0); 
        //m_hKernelHandle will be 0 if this is a scratch pool.
        if (m_hKernelHandle)
        {
            // Tell the thunk layer that we need to
            // be freed.

            D3D8_DESTROYSURFACEDATA DestroySurfData;
            DestroySurfData.hDD = m_pParent->Device()->GetHandle();
            DestroySurfData.hSurface = m_hKernelHandle;
            m_pParent->Device()->GetHalCallbacks()->DestroySurface(&DestroySurfData);
        }
#ifdef DEBUG
        else
        {
            DXGASSERT(m_pParent->GetUserPool() == D3DPOOL_SCRATCH);
        }
#endif //DEBUG
    }; // ~CMipSurface

public:
    // IUnknown methods
    STDMETHOD(QueryInterface) (REFIID riid, 
                               LPVOID FAR * ppvObj);
    STDMETHOD_(ULONG,AddRef) ();
    STDMETHOD_(ULONG,Release) ();

    // IBuffer methods
    STDMETHOD(SetPrivateData)(REFGUID riid, 
                              CONST VOID* pvData, 
                              DWORD cbData, 
                              DWORD dwFlags);

    STDMETHOD(GetPrivateData)(REFGUID riid, 
                              LPVOID pvData, 
                              LPDWORD pcbData);

    STDMETHOD(FreePrivateData)(REFGUID riid);

    STDMETHOD(GetContainer)(REFIID riid, 
                            void **ppContainer);

    STDMETHOD(GetDevice)(IDirect3DDevice8 **ppDevice);


    // IDirect3DSurface8 methods
    STDMETHOD(GetDesc)(D3DSURFACE_DESC *pDesc);

    STDMETHOD(LockRect)(D3DLOCKED_RECT *pLockedRectData, 
                        CONST RECT     *pRect, 
                        DWORD           dwFlags);

    STDMETHOD(UnlockRect)();

    // BaseSurface methods

    virtual DWORD DrawPrimHandle() const
    {
        return D3D8GetDrawPrimHandle(m_hKernelHandle);
    } // DrawPrimHandle

    virtual HANDLE KernelHandle() const
    {
        return m_hKernelHandle;
    } // KernelHandle

    virtual DWORD IncrementUseCount()
    {
        return m_pParent->IncrementUseCount();
    } // IncrementUseCount

    virtual DWORD DecrementUseCount()
    {
        return m_pParent->DecrementUseCount();
    } // DecrementUseCount

    virtual void Batch()
    {
        m_pParent->Batch();
        return;
    } // Batch

    virtual void Sync()
    {
        m_pParent->Sync();
        return;
    } // Sync

    // Internal lock functions bypass
    // parameter checking and also whether the
    // surface marked as Lockable or LockOnce
    // etc. (Methods of CBaseSurface.)
    virtual HRESULT InternalLockRect(D3DLOCKED_RECT *pLockedRectData, 
                                     CONST RECT     *pRect, 
                                     DWORD           dwFlags);

    virtual HRESULT InternalUnlockRect();

    virtual D3DSURFACE_DESC InternalGetDesc() const;

    virtual CBaseDevice * InternalGetDevice() const
    {
        return m_pParent->Device();
    } // InternalGetDevice

    // Determines if a LOAD_ONCE surface has already
    // been loaded
    virtual BOOL IsLoaded() const
    {
        DXGASSERT(m_pParent->Desc()->Usage & D3DUSAGE_LOADONCE);
        if (m_isLockable)
        {
            return FALSE;
        }
        else
        {
            return TRUE;
        }
    } // IsLoaded

    // End Of BaseSurface methods

    // Quick method to avoid the virtual function call
    CBaseDevice * Device() const
    {
        return m_pParent->Device();
    } // Device

protected:
    CMipMap *m_pParent;
    BOOL     m_isLockable;
    BYTE     m_iLevel;

    // We'll need internal handles so that
    // we can communicate call Destroy 
    // and so that CDriverMipMap can call
    // Lock/Unlock etc.
    HANDLE   m_hKernelHandle;

    // Debugging trick to help spew better
    // information if someone over-releases a mipsurface
    // (Since our ref's carry over to the parent object; it
    // means that over-releases can be hard to find.)
#ifdef DEBUG
    DWORD   m_cRefDebug;
#endif // DEBUG

}; // CMipSurface

// The CDriverMipSurface is a modification of the base mipsurf
// class. It overrides lock and unlock and routes the call to the
// driver
class CDriverMipSurface : public CMipSurface
{
public:
    // Constructor
    CDriverMipSurface(CMipMap *pParent, 
                      BYTE     iLevel,
                      HANDLE   hKernelHandle
                      ) :
        CMipSurface(pParent, iLevel, hKernelHandle)
    {
    } // CDriverMipSurface

public:

    STDMETHOD(LockRect)(D3DLOCKED_RECT *pLockedRectData, 
                        CONST RECT     *pRect, 
                        DWORD           dwFlags);

    STDMETHOD(UnlockRect)();

    // Internal lock functions bypass
    // parameter checking and also whether the
    // surface marked as Lockable or LockOnce
    // etc. (Methods of CBaseSurface.)
    virtual HRESULT InternalLockRect(D3DLOCKED_RECT *pLockedRectData, 
                                     CONST RECT     *pRect, 
                                     DWORD           dwFlags);

    virtual HRESULT InternalUnlockRect();


}; // CDriverMipSurface


#endif // __MIPSURF_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\pixel.hpp ===
#ifndef __PIXEL_HPP__
#define __PIXEL_HPP__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       pixel.hpp
 *  Content:    Utility class for working with pixel formats
 *
 *
 ***************************************************************************/

// includes
#include "d3dobj.hpp"

struct IHVFormatInfo
{
    D3DFORMAT       m_Format;
    DWORD           m_BPP;
    IHVFormatInfo  *m_pNext;
};

// This is a utility class that implements useful helpers for
// allocating and accessing various pixel formats. All methods
// are static and hence should be accessed as follows:
//  e.g. CPixel::LockOffset(...)
//

class CPixel
{
public:
    // Allocate helpers

    // Determine the amount of memory that is needed to
    // allocate various things..
    static UINT ComputeSurfaceSize(UINT            cpWidth,
                                   UINT            cpHeight,
                                   D3DFORMAT       Format);

    static UINT ComputeVolumeSize(UINT             cpWidth,
                                  UINT             cpHeight,
                                  UINT             cpDepth,
                                  D3DFORMAT        Format);


    static UINT ComputeMipMapSize(UINT             cpWidth,
                                  UINT             cpHeight,
                                  UINT             cLevels,
                                  D3DFORMAT        Format);

    static UINT ComputeMipVolumeSize(UINT          cpWidth,
                                     UINT          cpHeight,
                                     UINT          cpDepth,
                                     UINT          cLevels,
                                     D3DFORMAT     Format);

    // Lock helpers

    // Given a surface desc, a level, and pointer to
    // bits (pBits in the LockedRectData) and a sub-rect,
    // this will fill in the pLockedRectData structure
    static void ComputeMipMapOffset(const D3DSURFACE_DESC  *pDescTopLevel,
                                    UINT                    iLevel,
                                    BYTE                   *pBits,
                                    CONST RECT             *pRect,
                                    D3DLOCKED_RECT         *pLockedRectData);

    // MipVolume version of ComputeMipMapOffset
    static void ComputeMipVolumeOffset(const D3DVOLUME_DESC  *pDescTopLevel,
                                       UINT                   iLevel,
                                       BYTE                  *pBits,
                                       CONST D3DBOX          *pBox,
                                       D3DLOCKED_BOX         *pLockedBoxData);

    // Surface version of ComputeMipMapOffset
    static void ComputeSurfaceOffset(const D3DSURFACE_DESC  *pDesc,
                                     BYTE                   *pBits,
                                     CONST RECT             *pRect,
                                     D3DLOCKED_RECT         *pLockedRectData);

    // Is this a supported format?
    static BOOL IsSupported(D3DRESOURCETYPE Type, D3DFORMAT Format);

    // Is this a IHV non-standard format? i.e. do
    // we know the number of bytes per pixel?
    static BOOL IsIHVFormat(D3DFORMAT Format);

    // Is this a Z format that the user can create?
    static BOOL IsEnumeratableZ (D3DFORMAT Format);

    // Is this a Z format that needs mapping b4 sending
    // to the driver?
    static BOOL IsMappedDepthFormat(D3DFORMAT Format);

    // All depth formats other than D16 are currently
    // defined to be non-lockable. This function will
    // return FALSE for:
    //      non-Z formats 
    //      D16_LOCKABLE
    //      IHV formats
    static BOOL IsNonLockableZ(D3DFORMAT Format);

    // Pixel Stride will return negative for DXT formats
    // Call AdjustForDXT to work with things at the block level
    static UINT ComputePixelStride(D3DFORMAT Format);

    // This will adjust cbPixel
    // to pixels per block; and width and height will
    // be adjusted to pixels. Assumes the IsDXT(cbPixel).
    static void AdjustForDXT(UINT *pcpWidth,
                             UINT *pcpHeight,
                             UINT *pcbPixel);

    // Adjust parameters for VolumeDXT
    static void AdjustForVolumeDXT(UINT *pcpWidth,
                                   UINT *pcpHeight,
                                   UINT *pcpDepth,
                                   UINT *pcbPixel);

    // returns TRUE if cbPixel is "negative" i.e. DXT/V group
    static BOOL IsDXT(UINT cbPixel);

    // returns TRUE if format is one of the DXT/V group
    static BOOL IsDXT(D3DFORMAT Format);

    // returns TRUE if format is one of the DXV family
    static BOOL IsVolumeDXT(D3DFORMAT Format);

    // returns TRUE if format has stencil bits
    static BOOL HasStencilBits(D3DFORMAT Format);

    // returns TRUE if format is paletted
    static BOOL IsPaletted(D3DFORMAT Format);

    // Helpers for validation for DXTs.
    static BOOL IsValidRect(D3DFORMAT    Format,
                            UINT         Width,
                            UINT         Height,
                            const RECT  *pRect);

    static BOOL IsValidBox(D3DFORMAT     Format,
                           UINT          Width,
                           UINT          Height,
                           UINT          Depth,
                           const D3DBOX *pBox);

    // Needs 4x4 Rules (DXT/DXVs)
    static BOOL Requires4X4(D3DFORMAT Format);

    // Detection for "real" FourCC formats
    static BOOL IsFourCC(D3DFORMAT Format);

    static D3DFORMAT SuppressAlphaChannel(D3DFORMAT Format);

    static UINT BytesPerPixel(D3DFORMAT Format);

    // Register format for later lookup
    static HRESULT Register(D3DFORMAT Format, DWORD BPP);

    // Cleanup registry
    static void Cleanup();

private:
    // Internal functions

    static UINT ComputeSurfaceStride(UINT cpWidth, UINT cbPixel);

    static UINT ComputeSurfaceSize(UINT            cpWidth,
                                   UINT            cpHeight,
                                   UINT            cbPixel);

    static IHVFormatInfo *m_pFormatList;


}; // CPixel



#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::IsIHVFormat"

inline BOOL CPixel::IsIHVFormat(D3DFORMAT Format)
{
    // If we know the number of bytes per
    // pixel; it's a non-IHV format
    if (BytesPerPixel(Format) != 0)
        return FALSE;

    // Must be an IHV format
    return TRUE;

} // IsIHVFormat


#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::ComputeSurfaceOffset"

inline void CPixel::ComputeSurfaceOffset(const D3DSURFACE_DESC  *pDesc,
                                         BYTE                   *pBits,
                                         CONST RECT             *pRect,
                                         D3DLOCKED_RECT         *pLockedRectData)
{
    ComputeMipMapOffset(pDesc, 0, pBits, pRect, pLockedRectData);
} // ComputeSurfaceOffset


#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::ComputeSurfaceSize"

inline UINT CPixel::ComputeSurfaceSize(UINT            cpWidth,
                                       UINT            cpHeight,
                                       D3DFORMAT       Format)
{
    UINT cbPixel = ComputePixelStride(Format);

    // Adjust pixel->block if necessary
    BOOL isDXT = IsDXT(cbPixel);
    if (isDXT)
    {
        AdjustForDXT(&cpWidth, &cpHeight, &cbPixel);
    }

    return ComputeSurfaceSize(cpWidth,
                              cpHeight,
                              cbPixel);
} // ComputeSurfaceSize

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::AdjustForDXT"
inline void CPixel::AdjustForDXT(UINT *pcpWidth,
                                 UINT *pcpHeight,
                                 UINT *pcbPixel)
{
    DXGASSERT(pcbPixel);
    DXGASSERT(pcpWidth);
    DXGASSERT(pcpHeight);
    DXGASSERT(IsDXT(*pcbPixel));

    // Adjust width and height for DXT formats to be in blocks
    // instead of pixels. Blocks are 4x4 pixels.
    *pcpWidth  = (*pcpWidth  + 3) / 4;
    *pcpHeight = (*pcpHeight + 3) / 4;

    // Negate the pcbPixel to determine bytes per block
    *pcbPixel *= -1;

    // We only know of two DXT formats right now...
    DXGASSERT(*pcbPixel == 8 || *pcbPixel == 16);

} // CPixel::AdjustForDXT

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::AdjustForVolumeDXT"
inline void CPixel::AdjustForVolumeDXT(UINT *pcpWidth,
                                       UINT *pcpHeight,
                                       UINT *pcpDepth,
                                       UINT *pcbPixel)
{
    DXGASSERT(pcbPixel);
    DXGASSERT(pcpWidth);
    DXGASSERT(pcpHeight);
    DXGASSERT(IsDXT(*pcbPixel));

    // Adjust width, height, depth for DXT formats to be in blocks
    // instead of pixels. Blocks are 4x4x4 pixels.
    *pcpWidth  = (*pcpWidth  + 3) / 4;
    *pcpHeight = (*pcpHeight + 3) / 4;
    *pcpDepth  = (*pcpDepth  + 3) / 4;

    // Negate the pcbPixel to determine bytes per block
    *pcbPixel *= -1;

    // We only know of two DXV formats right now...
    DXGASSERT(*pcbPixel == 32 || *pcbPixel == 64);
} // CPixel::AdjustForVolumeDXT


#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::ComputeVolumeSize"

inline UINT CPixel::ComputeVolumeSize(UINT             cpWidth,
                                      UINT             cpHeight,
                                      UINT             cpDepth,
                                      D3DFORMAT        Format)
{
    UINT cbPixel = ComputePixelStride(Format);

    if (IsDXT(cbPixel))
    {
        if (IsVolumeDXT(Format))
        {
            AdjustForVolumeDXT(&cpWidth, &cpHeight, &cpDepth, &cbPixel);
        }
        else
        {
            AdjustForDXT(&cpWidth, &cpHeight, &cbPixel);
        }
    }

    return cpDepth * ComputeSurfaceSize(cpWidth, cpHeight, cbPixel);
} // ComputeVolumeSize

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::IsSupported"
inline BOOL CPixel::IsSupported(D3DRESOURCETYPE Type, D3DFORMAT Format)
{
    UINT cbPixel = ComputePixelStride(Format);

    if (cbPixel == 0)
    {
        return FALSE;
    }
    else if (IsVolumeDXT(Format))
    {
        if (Type == D3DRTYPE_VOLUMETEXTURE)
            return TRUE;
        else
            return FALSE;
    }
    else
    {
        return TRUE;
    }
} // IsSupported

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::IsDXT(cbPixel)"

// returns TRUE if cbPixel is "negative"
inline BOOL CPixel::IsDXT(UINT cbPixel)
{
    if (((INT)cbPixel) < 0)
        return TRUE;
    else
        return FALSE;
} // IsDXT

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::IsDXT(format)"

// returns TRUE if this is a linear format
// i.e. DXT or DXV
inline BOOL CPixel::IsDXT(D3DFORMAT Format)
{
    // CONSIDER: This is a duplication of Requires4x4 function
    switch (Format)
    {
        // normal DXTs
    case D3DFMT_DXT1:
    case D3DFMT_DXT2:
    case D3DFMT_DXT3:
    case D3DFMT_DXT4:
    case D3DFMT_DXT5:

#ifdef VOLUME_DXT
        // Volume dxts
    case D3DFMT_DXV1:
    case D3DFMT_DXV2:
    case D3DFMT_DXV3:
    case D3DFMT_DXV4:
    case D3DFMT_DXV5:
#endif //VOLUME_DXT

        return TRUE;
    }

    return FALSE;
} // IsDXT

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::Requires4X4"

// returns TRUE for formats that have 4x4 rules
inline BOOL CPixel::Requires4X4(D3DFORMAT Format)
{

    switch (Format)
    {
        // normal DXTs
    case D3DFMT_DXT1:
    case D3DFMT_DXT2:
    case D3DFMT_DXT3:
    case D3DFMT_DXT4:
    case D3DFMT_DXT5:

#ifdef VOLUME_DXT
        // Volume dxts
    case D3DFMT_DXV1:
    case D3DFMT_DXV2:
    case D3DFMT_DXV3:
    case D3DFMT_DXV4:
    case D3DFMT_DXV5:
#endif //VOLUME_DXT

        return TRUE;
    }

    return FALSE;
} // Requires4X4


#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::HasStencilBits"

// returns TRUE if format has stencil bits
inline BOOL CPixel::HasStencilBits(D3DFORMAT Format)
{
    switch (Format)
    {
    case D3DFMT_S1D15:
    case D3DFMT_D15S1:
    case D3DFMT_S8D24:
    case D3DFMT_D24S8:
    case D3DFMT_X4S4D24:
    case D3DFMT_D24X4S4:
        return TRUE;
    }

    return FALSE;
} // HasStencilBits

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::IsVolumeDXT"

// returns TRUE if format is one of the DXTV family
inline BOOL CPixel::IsVolumeDXT(D3DFORMAT Format)
{
#ifdef VOLUME_DXT
    if (Format >= D3DFMT_DXV1 && Format <= D3DFMT_DXV5)
        return TRUE;
    else
#endif //VOLUME_DXT
        return FALSE;
} // IsVolumeDXT

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::IsPaletted"

// returns TRUE if Format is paletted
inline BOOL CPixel::IsPaletted(D3DFORMAT Format)
{
    return (Format == D3DFMT_P8) || (Format == D3DFMT_A8P8);
} // IsPaletted

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::IsFourCC"

// returns TRUE if Format is a FourCC
inline BOOL CPixel::IsFourCC(D3DFORMAT Format)
{
    DWORD dwFormat = (DWORD)Format;
    if (HIBYTE(LOWORD(dwFormat)) != 0)
    {
        // FourCC formats are non-zero for in their
        // third byte.
        return TRUE;
    }
    else
    {
        return FALSE;
    }
} // IsFourCC


#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::IsEnumeratableZ"

// IsEnumeratableZ
//
// We only want to enumerate D16 and the Z formats.  We have to know
// about the others so we have to keep them in our list, but we added this
// function so we'd never enumerate them to the app.

inline BOOL CPixel::IsEnumeratableZ (D3DFORMAT Format)
{
    if ((Format == D3DFMT_D16)          ||
        (Format == D3DFMT_D16_LOCKABLE) ||
        (Format == D3DFMT_D15S1)        ||
        (Format == D3DFMT_D24X8)        ||
        (Format == D3DFMT_D24X4S4)      ||
        (Format == D3DFMT_D24S8)        ||
        (Format == D3DFMT_D32))
    {
        return TRUE;
    }

    // IHV formats are creatable; so we let them pass
    if (IsIHVFormat(Format))
    {
        return TRUE;
    }

    return FALSE;
} // IsEnumeratableZ

#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::IsMappedDepthFormat"

// Is this a Z format that needs mapping b4 sending
// to the driver?
inline BOOL CPixel::IsMappedDepthFormat(D3DFORMAT Format)
{
    // D16_LOCKABLE and D32 do not need
    // mapping
    if ((Format == D3DFMT_D16)      ||
        (Format == D3DFMT_D15S1)    ||
        (Format == D3DFMT_D24X4S4)  ||
        (Format == D3DFMT_D24X8)    ||
        (Format == D3DFMT_D24S8))
    {
        return TRUE;
    }
    return FALSE;
} // IsMappedDepthFormat


#undef DPF_MODNAME
#define DPF_MODNAME "CPixel::IsNonLockableZ"

// All depth formats other than D16 are currently
// defined to be non-lockable. This function will
// return FALSE for:
//      non-Z formats 
//      D16_LOCKABLE
//      IHV formats

inline BOOL CPixel::IsNonLockableZ(D3DFORMAT Format)
{
    if ((Format == D3DFMT_D16)      ||
        (Format == D3DFMT_D15S1)    ||
        (Format == D3DFMT_D24X8)    ||
        (Format == D3DFMT_D24S8)    ||
        (Format == D3DFMT_D24X4S4)  ||
        (Format == D3DFMT_D32))
    {
        return TRUE;
    }

    // D16_LOCKABLE is lockable; and other
    // formats are either lockable i.e. IHV or
    // are not a Z format.

    return FALSE;
} // IsNonLockableZ

#endif // __PIXEL_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\mipvol.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mipvol.cpp
 *  Content:    Implementation of the CMipVolume and CManagedMipVolume
 *              classes.
 *
 *
 ***************************************************************************/
#include "ddrawpr.h"

#include "mipvol.hpp"
#include "volume.hpp"
#include "d3di.hpp"
#include "resource.inl"

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::Create"

// Static class function for creating a mip-map object.
// (Because it is static; it doesn't have a this pointer.)
//
// We do all parameter checking here to reduce the overhead
// in the constructor which is called by the internal Clone
// method which is used by resource management as part of the
// performance critical download operation.

HRESULT CMipVolume::Create(CBaseDevice              *pDevice,
                           DWORD                     Width,
                           DWORD                     Height,
                           DWORD                     Depth,
                           DWORD                     cLevels,
                           DWORD                     Usage,
                           D3DFORMAT                 Format,
                           D3DPOOL                   Pool,
                           IDirect3DVolumeTexture8 **ppMipVolume)
{
    HRESULT hr;

    // Do parameter checking here
    if (!VALID_PTR_PTR(ppMipVolume))
    {
        DPF_ERR("Bad parameter passed for ppMipVolume for creating a MipVolume");
        return D3DERR_INVALIDCALL;
    }

    // Zero-out return parameter
    *ppMipVolume = NULL;

    // Check if format, pool is valid
    hr = Validate(pDevice, 
                  D3DRTYPE_VOLUMETEXTURE,
                  Pool,
                  Usage,
                  Format);

    if (FAILED(hr))
    {
        // Validate does it's own DPFing
        return D3DERR_INVALIDCALL;
    }

    // Check usage flags
    if (Usage & ~D3DUSAGE_VOLUMETEXTURE_VALID)
    {
        DPF_ERR("Invalid flag specified for volume texture creation.");
        return D3DERR_INVALIDCALL;
    }

    // Infer internal usage flags
    Usage = InferUsageFlags(Pool, Usage, Format);

    // Expand cLevels if necessary
    if (cLevels == 0)
    {
        // See if HW can mip
        if ( (Pool != D3DPOOL_SCRATCH) && !(pDevice->GetD3DCaps()->TextureCaps & 
              D3DPTEXTURECAPS_MIPVOLUMEMAP))
        {
            // Can't mip so use 1
            cLevels = 1;
        }
        else
        {
            // Determine number of levels
            cLevels = ComputeLevels(Width, Height, Depth);
        }
    }

    if (cLevels > 32)
    {
        DPF_ERR("No more than 32 levels are supported. CreateVolumeTexture failed");

        // This limitation is based on the number of
        // bits that we have allocated for iLevel in
        // some of the supporting classes.
        return D3DERR_INVALIDCALL;
    }

    if (cLevels > 1)
    {
        if ((Width  >> (cLevels - 1)) == 0 &&
            (Height >> (cLevels - 1)) == 0 &&
            (Depth  >> (cLevels - 1)) == 0)
        {
            DPF_ERR("Too many levels for volume texture of this size.");
            return D3DERR_INVALIDCALL;
        }
    }

    if (Pool != D3DPOOL_SCRATCH)
    {
        //Device specific constraints:

        // Check size constraints for volumes
        if (pDevice->GetD3DCaps()->TextureCaps & D3DPTEXTURECAPS_VOLUMEMAP_POW2)
        {
            if (!IsPowerOfTwo(Width))
            {
                DPF_ERR("Width must be power of two for mip-volumes");
                return D3DERR_INVALIDCALL;
            }

            if (!IsPowerOfTwo(Height))
            {
                DPF_ERR("Height must be power of two for mip-volumes");
                return D3DERR_INVALIDCALL;
            }

            if (!IsPowerOfTwo(Depth))
            {
                DPF_ERR("Depth must be power of two for mip-volumes");
                return D3DERR_INVALIDCALL;
            }
        }

        // Check texture size restrictions
        if (Width > pDevice->GetD3DCaps()->MaxVolumeExtent)
        {
            DPF_ERR("Texture width is larger than what the device supports. CreateVolumeTexture fails");
            return D3DERR_INVALIDCALL;
        }

        if (Height > pDevice->GetD3DCaps()->MaxVolumeExtent)
        {
            DPF_ERR("Texture height is larger than what the device supports. CreateVolumeTexture fails");
            return D3DERR_INVALIDCALL;
        }

        if (Depth > pDevice->GetD3DCaps()->MaxVolumeExtent)
        {
            DPF_ERR("Texture depth is larger than what the device supports. CreateVolumeTexture fails");
            return D3DERR_INVALIDCALL;
        }

        // Check that the device supports volume texture
        if (!(pDevice->GetD3DCaps()->TextureCaps & D3DPTEXTURECAPS_VOLUMEMAP))
        {
            DPF_ERR("Device doesn't support volume textures; creation failed.");
            return D3DERR_INVALIDCALL;
        }

        // Check if the device supports mipped volumes
        if (cLevels > 1)
        {
            if (!(pDevice->GetD3DCaps()->TextureCaps & 
                    D3DPTEXTURECAPS_MIPVOLUMEMAP))
            {
                DPF_ERR("Device doesn't support mipped volume textures; creation failed.");
                return D3DERR_INVALIDCALL;
            }
        }
    }

    // Size is required to be 4x4
    if (CPixel::Requires4X4(Format))
    {
        if ((Width & 3) ||
            (Height & 3))
        {
            DPF_ERR("DXT Formats require width/height to multiples of 4. CreateVolumeTexture fails");
            return D3DERR_INVALIDCALL;
        }
        if (CPixel::IsVolumeDXT(Format))
        {
            if (Depth & 3)
            {
                DPF_ERR("DXT Formats require width/height to multiples of 4. CreateVolumeTexture fails");
                return D3DERR_INVALIDCALL;
            }
        }
    }

    // Validate against zero width/height/depth
    if (Width   == 0 ||
        Height  == 0 ||
        Depth   == 0)
    {
        DPF_ERR("Width/Height/Depth must be non-zero.  CreateVolumeTexture fails");
        return D3DERR_INVALIDCALL;
    }

    // DX9: May need to support mapping for volumes that 
    // contain depth data someday.

    // Allocate a new MipVolume object and return it
    CMipVolume *pMipVolume = new CMipVolume(pDevice,
                                            Width,
                                            Height,
                                            Depth,
                                            cLevels,
                                            Usage,
                                            Format,
                                            Pool,
                                            REF_EXTERNAL,
                                           &hr);
    if (pMipVolume == NULL)
    {
        DPF_ERR("Out of Memory creating mip-volume");
        return E_OUTOFMEMORY;
    }

    if (FAILED(hr))
    {
        DPF_ERR("Error during initialization of mip-volume");
        pMipVolume->ReleaseImpl();
        return hr;
    }

    // We're done; just return the object
    *ppMipVolume = pMipVolume;

    return hr;
} // static Create


#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::CMipVolume"

// Constructor for the mip map class
CMipVolume::CMipVolume(CBaseDevice *pDevice,
                       DWORD        Width,
                       DWORD        Height,
                       DWORD        Depth,
                       DWORD        cLevels,
                       DWORD        Usage,
                       D3DFORMAT    UserFormat,
                       D3DPOOL      UserPool,
                       REF_TYPE     refType,
                       HRESULT     *phr
                       ) :
    CBaseTexture(pDevice, cLevels, UserPool, UserFormat, refType),
    m_VolumeArray(NULL),
    m_rgbPixels(NULL),
    m_cBoxUsed(MIPVOLUME_ALLDIRTY)
{
    // We assume that we start out dirty
    DXGASSERT(IsDirty());

    // Initialize basic structures
    m_desc.Format       = UserFormat;
    m_desc.Pool         = UserPool;
    m_desc.Usage        = Usage;
    m_desc.Type         = D3DRTYPE_VOLUMETEXTURE;
    m_desc.Width        = Width;
    m_desc.Height       = Height;
    m_desc.Depth        = Depth;

    // Estimate size of memory allocation
    m_desc.Size         = CPixel::ComputeMipVolumeSize(Width,
                                                       Height,
                                                       Depth,
                                                       cLevels,
                                                       UserFormat);

    // Allocate Pixel Data for SysMem or D3DManaged cases
    if (IS_D3D_ALLOCATED_POOL(UserPool) ||
        IsTypeD3DManaged(Device(), D3DRTYPE_VOLUMETEXTURE, UserPool))
    {
        m_rgbPixels = new BYTE[m_desc.Size];

        if (m_rgbPixels == NULL)
        {
            DPF_ERR("Out of memory allocating memory for mip-volume levels");
            *phr = E_OUTOFMEMORY;
            return;
        }
    }

    // Create the DDSURFACEINFO array and CreateSurfaceData object
    DXGASSERT(cLevels <= 32);

    DDSURFACEINFO SurfInfo[32];
    ZeroMemory(SurfInfo, sizeof(SurfInfo));

    D3D8_CREATESURFACEDATA CreateSurfaceData;
    ZeroMemory(&CreateSurfaceData, sizeof(CreateSurfaceData));

    // Set up the basic information
    CreateSurfaceData.hDD      = pDevice->GetHandle();
    CreateSurfaceData.pSList   = &SurfInfo[0];
    CreateSurfaceData.dwSCnt   = cLevels;
    CreateSurfaceData.Type     = D3DRTYPE_VOLUMETEXTURE;
    CreateSurfaceData.dwUsage  = m_desc.Usage;
    CreateSurfaceData.Format   = UserFormat;
    CreateSurfaceData.MultiSampleType = D3DMULTISAMPLE_NONE;
    CreateSurfaceData.Pool     = DetermineCreationPool(Device(),
                                                       D3DRTYPE_VOLUMETEXTURE,
                                                       Usage,
                                                       UserPool);

    // Iterate of each level to create the individual level
    // data
    for (DWORD iLevel = 0; iLevel < cLevels; iLevel++)
    {
        // Fill in the relevant information
        DXGASSERT(Width >= 1);
        DXGASSERT(Height >= 1);
        DXGASSERT(Depth >= 1);
        SurfInfo[iLevel].cpWidth  = Width;
        SurfInfo[iLevel].cpHeight = Height;
        SurfInfo[iLevel].cpDepth  = Depth;

        // If we allocated the memory, pass down
        // the sys-mem pointers
        if (m_rgbPixels)
        {
            D3DLOCKED_BOX lock;
            CPixel::ComputeMipVolumeOffset(&m_desc,
                                           iLevel,
                                           m_rgbPixels,
                                           NULL,       // pBox
                                           &lock);

            SurfInfo[iLevel].pbPixels    = (BYTE*)lock.pBits;
            SurfInfo[iLevel].iPitch      = lock.RowPitch;
            SurfInfo[iLevel].iSlicePitch = lock.SlicePitch;
        }

        // Scale width and height down
        if (Width > 1)
        {
            Width  >>= 1;
        }
        if (Height > 1)
        {
            Height >>= 1;
        }
        if (Depth > 1)
        {
            Depth >>= 1;
        }
    }

    // Allocate array of pointers to MipSurfaces
    m_VolumeArray = new CVolume*[cLevels];
    if (m_VolumeArray == NULL)
    {
        DPF_ERR("Out of memory creating VolumeTexture");
        *phr = E_OUTOFMEMORY;
        return;
    }

    // Zero the memory for safe cleanup
    ZeroMemory(m_VolumeArray, sizeof(*m_VolumeArray) * cLevels);

    // NOTE: any failures after this point needs to free up some
    // kernel handles, unless it's scratch

    if (UserPool != D3DPOOL_SCRATCH)
    {
        // Call the HAL to create this surface
        *phr = pDevice->GetHalCallbacks()->CreateSurface(&CreateSurfaceData);
        if (FAILED(*phr))
            return;

        // Remember what pool we really got
        m_desc.Pool = CreateSurfaceData.Pool;

        // We need to remember the handles from the top most
        // level of the mip-map
        SetKernelHandle(SurfInfo[0].hKernelHandle);
    }

    // Create and Initialize each MipLevel
    for (iLevel = 0; iLevel < cLevels; iLevel++)
    {
        // Is this a sys-mem surface; could be d3d managed
        if (IS_D3D_ALLOCATED_POOL(m_desc.Pool))
        {
            m_VolumeArray[iLevel] =
                    new CVolume(this,
                                (BYTE)iLevel,
                                SurfInfo[iLevel].hKernelHandle);
        }
        else
        {
            // Must be a driver kind of surface; could be driver managed
            m_VolumeArray[iLevel] =
                    new CDriverVolume(this,
                                      (BYTE)iLevel,
                                      SurfInfo[iLevel].hKernelHandle);
        }

        if (m_VolumeArray[iLevel] == NULL)
        {
            DPF_ERR("Out of memory creating volume level");
            *phr = E_OUTOFMEMORY;

            // Need to free handles that we got before we return; we
            // only free the ones that weren't successfully entrusted
            // to a CVolume because those will be cleaned up automatically
            // at their destructor
            if (UserPool != D3DPOOL_SCRATCH)
            {
                for (UINT i = iLevel; i < cLevels; i++)
                {
                    DXGASSERT(SurfInfo[i].hKernelHandle);

                    D3D8_DESTROYSURFACEDATA DestroySurfData;
                    DestroySurfData.hDD = Device()->GetHandle();
                    DestroySurfData.hSurface = SurfInfo[i].hKernelHandle;
                    Device()->GetHalCallbacks()->DestroySurface(&DestroySurfData);
                }
            }

            return;
        }

    }

    // If this is a D3D managed volume then we need
    // to tell the Resource Manager to remember us. This has to happen
    // at the very end of the constructor so that the important data
    // members are built up correctly
    if (CResource::IsTypeD3DManaged(Device(), D3DRTYPE_VOLUMETEXTURE, UserPool))
    {
        *phr = InitializeRMHandle();
    }

    return;
} // CMipVolume::CMipVolume


#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::~CMipVolume"

// Destructor
CMipVolume::~CMipVolume()
{
    // The destructor has to handle partially
    // created objects. Delete automatically
    // handles NULL; and members are nulled
    // as part of core constructors

    if (m_VolumeArray)
    {
        for (DWORD i = 0; i < m_cLevels; i++)
        {
            delete m_VolumeArray[i];
        }
        delete [] m_VolumeArray;
    }
    delete [] m_rgbPixels;
} // CMipVolume::~CMipVolume

// Methods for the Resource Manager

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::Clone"

// Specifies a creation of a resource that
// looks just like the current one; in a new POOL
// with a new LOD.
HRESULT CMipVolume::Clone(D3DPOOL     Pool,
                          CResource **ppResource) const

{
    // NULL out parameter
    *ppResource = NULL;

    // Determine the number of levels/width/height/depth
    // of the clone
    DWORD cLevels   = GetLevelCountImpl();
    DWORD Width     = m_desc.Width;
    DWORD Height    = m_desc.Height;
    DWORD Depth     = m_desc.Depth;

    DWORD dwLOD     = GetLODI();

    // If LOD is zero, then there are no changes
    if (dwLOD > 0)
    {
        // Clamp LOD to cLevels-1
        if (dwLOD >= cLevels)
        {
            dwLOD = cLevels - 1;
        }

        // scale down the destination texture
        // to correspond the appropiate max lod
        Width  >>= dwLOD;
        if (Width == 0)
            Width = 1;

        Height >>= dwLOD;
        if (Height == 0)
            Height = 1;

        Depth >>= dwLOD;
        if (Depth == 0)
            Depth = 1;

        // Reduce the number based on the our max lod.
        cLevels -= dwLOD;
    }

    // Sanity checking
    DXGASSERT(cLevels  >= 1);
    DXGASSERT(Width    >  0);
    DXGASSERT(Height   >  0);
    DXGASSERT(Depth    >  0);

    // Create the new mip-map object now

    // Note: we treat clones as REF_INTERNAL; because
    // they are owned by the resource manager which
    // is owned by the device.

    // Also, we adjust the usage to disable lock-flags
    // since we don't need lockability
    DWORD Usage = m_desc.Usage;
    Usage &= ~(D3DUSAGE_LOCK | D3DUSAGE_LOADONCE);

    HRESULT hr;
    CResource *pResource = new CMipVolume(Device(),
                                          Width,
                                          Height,
                                          Depth,
                                          cLevels,
                                          Usage,
                                          m_desc.Format,
                                          Pool,
                                          REF_INTERNAL,
                                          &hr);

    if (pResource == NULL)
    {
        DPF_ERR("Failed to allocate mip-volume object when copying");
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr))
    {
        DPF(5, "Failed to create mip-map when doing texture management");
        pResource->DecrementUseCount();
        return hr;
    }

    *ppResource = pResource;

    return hr;
} // CMipVolume::Clone

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::GetBufferDesc"

// Provides a method to access basic structure of the
// pieces of the resource. A resource may be composed
// of one or more buffers.
const D3DBUFFER_DESC* CMipVolume::GetBufferDesc() const
{
    return (const D3DBUFFER_DESC*)&m_desc;
} // CMipVolume::GetBufferDesc



// IUnknown methods
#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::QueryInterface"

STDMETHODIMP CMipVolume::QueryInterface(REFIID       riid,
                                        VOID       **ppvObj)
{
    API_ENTER(Device());

    if (!VALID_PTR_PTR(ppvObj))
    {
        DPF_ERR("Invalid ppvObj parameter for QueryInterface of a VolumeTexture");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_PTR(&riid, sizeof(GUID)))
    {
        DPF_ERR("Invalid guid memory address to QueryInterface of a VolumeTexture");
        return D3DERR_INVALIDCALL;
    }

    if (riid == IID_IDirect3DVolumeTexture8 ||
        riid == IID_IDirect3DBaseTexture8   ||
        riid == IID_IDirect3DResource8      ||
        riid == IID_IUnknown)
    {
        *ppvObj = static_cast<void*>(static_cast<IDirect3DVolumeTexture8 *>(this));
        AddRef();
        return S_OK;
    }

    DPF_ERR("Unsupported Interface identifier passed to QueryInterface of a VolumeTexture");

    // Null out param
    *ppvObj = NULL;
    return E_NOINTERFACE;
} // QueryInterface

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::AddRef"

STDMETHODIMP_(ULONG) CMipVolume::AddRef()
{
    API_ENTER_NO_LOCK(Device());   

    return AddRefImpl();
} // AddRef

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::Release"

STDMETHODIMP_(ULONG) CMipVolume::Release()
{
    API_ENTER_SUBOBJECT_RELEASE(Device());   

    return ReleaseImpl();
} // Release

// IDirect3DResource methods

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::GetDevice"

STDMETHODIMP CMipVolume::GetDevice(IDirect3DDevice8 **ppObj)
{
    API_ENTER(Device());
    return GetDeviceImpl(ppObj);
} // GetDevice

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::SetPrivateData"

STDMETHODIMP CMipVolume::SetPrivateData(REFGUID  riid,
                                        CONST VOID    *pvData,
                                        DWORD    cbData,
                                        DWORD    dwFlags)
{
    API_ENTER(Device());

    // For the private data that 'really' belongs to the
    // MipVolume, we use m_cLevels. (0 through m_cLevels-1 are for
    // each of the children levels.)

    return SetPrivateDataImpl(riid, pvData, cbData, dwFlags, m_cLevels);
} // SetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::GetPrivateData"

STDMETHODIMP CMipVolume::GetPrivateData(REFGUID  riid,
                                        VOID    *pvData,
                                        DWORD   *pcbData)
{
    API_ENTER(Device());

    // For the private data that 'really' belongs to the
    // MipVolume, we use m_cLevels. (0 through m_cLevels-1 are for
    // each of the children levels.)
    return GetPrivateDataImpl(riid, pvData, pcbData, m_cLevels);
} // GetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::FreePrivateData"

STDMETHODIMP CMipVolume::FreePrivateData(REFGUID riid)
{
    API_ENTER(Device());

    // For the private data that 'really' belongs to the
    // MipVolume, we use m_cLevels. (0 through m_cLevels-1 are for
    // each of the children levels.)
    return FreePrivateDataImpl(riid, m_cLevels);
} // FreePrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::GetPriority"

STDMETHODIMP_(DWORD) CMipVolume::GetPriority()
{
    API_ENTER_RET(Device(), DWORD);

    return GetPriorityImpl();
} // GetPriority

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::SetPriority"

STDMETHODIMP_(DWORD) CMipVolume::SetPriority(DWORD dwPriority)
{
    API_ENTER_RET(Device(), DWORD);

    return SetPriorityImpl(dwPriority);
} // SetPriority

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::PreLoad"

STDMETHODIMP_(void) CMipVolume::PreLoad(void)
{
    API_ENTER_VOID(Device());

    PreLoadImpl();
    return;
} // PreLoad

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::GetType"
STDMETHODIMP_(D3DRESOURCETYPE) CMipVolume::GetType(void)
{
    API_ENTER_RET(Device(), D3DRESOURCETYPE);

    return m_desc.Type;
} // GetType

// IDirect3DMipTexture methods

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::GetLOD"

STDMETHODIMP_(DWORD) CMipVolume::GetLOD()
{
    API_ENTER_RET(Device(), DWORD);

    return GetLODImpl();
} // GetLOD

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::SetLOD"

STDMETHODIMP_(DWORD) CMipVolume::SetLOD(DWORD dwLOD)
{
    API_ENTER_RET(Device(), DWORD);

    return SetLODImpl(dwLOD);
} // SetLOD

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::GetLevelCount"

STDMETHODIMP_(DWORD) CMipVolume::GetLevelCount()
{
    API_ENTER_RET(Device(), DWORD);

    return GetLevelCountImpl();
} // GetLevelCount

// IDirect3DMipVolume methods

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::GetDesc"

STDMETHODIMP CMipVolume::GetLevelDesc(UINT iLevel, D3DVOLUME_DESC *pDesc)
{
    API_ENTER(Device());

    if (iLevel >= m_cLevels)
    {
        DPF_ERR("Invalid level number passed GetLevelDesc for a VolumeTexture");

        return D3DERR_INVALIDCALL;
    }

    return m_VolumeArray[iLevel]->GetDesc(pDesc);
} // GetDesc

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::GetVolumeLevel"

STDMETHODIMP CMipVolume::GetVolumeLevel(UINT               iLevel,
                                        IDirect3DVolume8 **ppVolume)
{
    API_ENTER(Device());

    if (!VALID_PTR_PTR(ppVolume))
    {
        DPF_ERR("Invalid parameter passed to GetVolumeLevel");
        return D3DERR_INVALIDCALL;
    }

    if (iLevel >= m_cLevels)
    {
        DPF_ERR("Invalid level number passed GetVolumeLevel");
        *ppVolume = NULL;
        return D3DERR_INVALIDCALL;
    }
    *ppVolume = m_VolumeArray[iLevel];
    (*ppVolume)->AddRef();
    return S_OK;
} // GetSurfaceLevel

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::LockBox"
STDMETHODIMP CMipVolume::LockBox(UINT             iLevel,
                                 D3DLOCKED_BOX   *pLockedBox,
                                 CONST D3DBOX    *pBox,
                                 DWORD            dwFlags)
{
    API_ENTER(Device());

    if (iLevel >= m_cLevels)
    {
        DPF_ERR("Invalid level number passed LockBox");
        return D3DERR_INVALIDCALL;
    }

    return m_VolumeArray[iLevel]->LockBox(pLockedBox, pBox, dwFlags);
} // LockRect


#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::UnlockRect"

STDMETHODIMP CMipVolume::UnlockBox(UINT iLevel)
{
    API_ENTER(Device());

    if (iLevel >= m_cLevels)
    {
        DPF_ERR("Invalid level number passed UnlockBox");
        return D3DERR_INVALIDCALL;
    }

    return m_VolumeArray[iLevel]->UnlockBox();
} // UnlockRect

#undef DPF_MODNAME
#define DPF_MODNAME "CMipMap::UpdateTexture"

// This function does type-specific parameter checking
// before calling UpdateDirtyPortion
HRESULT CMipVolume::UpdateTexture(CBaseTexture *pResourceTarget)
{
    CMipVolume *pTexSource = static_cast<CMipVolume*>(this);
    CMipVolume *pTexDest   = static_cast<CMipVolume*>(pResourceTarget);

    // Figure out how many levels in the source to skip
    DXGASSERT(pTexSource->m_cLevels >= pTexDest->m_cLevels);
    DWORD StartLevel = pTexSource->m_cLevels - pTexDest->m_cLevels;
    DXGASSERT(StartLevel < 32);

    // Compute the size of the top level of the source that is
    // going to be copied.
    UINT SrcWidth  = pTexSource->Desc()->Width;
    UINT SrcHeight = pTexSource->Desc()->Height;
    UINT SrcDepth  = pTexSource->Desc()->Depth;
    if (StartLevel > 0)
    {
        SrcWidth  >>= StartLevel;
        SrcHeight >>= StartLevel;
        SrcDepth  >>= StartLevel;
        if (SrcWidth == 0)
            SrcWidth = 1;
        if (SrcHeight == 0)
            SrcHeight = 1;
        if (SrcDepth == 0)
            SrcDepth = 1;
    }

    // Source and Dest should be the same sizes at this point
    if (SrcWidth != pTexDest->Desc()->Width)
    {
        if (StartLevel)
        {
            DPF_ERR("Source and Destination for UpdateTexture are not"
                    " compatible. Since both have the same number of"
                    " levels; their widths must match.");
        }
        else
        {
            DPF_ERR("Source and Destination for UpdateTexture are not"
                    " compatible. Since they have the different numbers of"
                    " levels; the widths of the bottom-most levels of"
                    " the source must match all the corresponding levels"
                    " of the destination.");
        }
        return D3DERR_INVALIDCALL;
    }

    if (SrcHeight != pTexDest->Desc()->Height)
    {
        if (StartLevel)
        {
            DPF_ERR("Source and Destination for UpdateTexture are not"
                    " compatible. Since both have the same number of"
                    " levels; their heights must match.");
        }
        else
        {
            DPF_ERR("Source and Destination for UpdateTexture are not"
                    " compatible. Since they have the different numbers of"
                    " levels; the heights of the bottom-most levels of"
                    " the source must match all the corresponding levels"
                    " of the destination.");
        }
        return D3DERR_INVALIDCALL;
    }

    if (SrcDepth != pTexDest->Desc()->Depth)
    {
        if (StartLevel)
        {
            DPF_ERR("Source and Destination for UpdateTexture are not"
                    " compatible. Since both have the same number of"
                    " levels; their depths must match.");
        }
        else
        {
            DPF_ERR("Source and Destination for UpdateTexture are not"
                    " compatible. Since they have the different numbers of"
                    " levels; the depths of the bottom-most levels of"
                    " the source must match all the corresponding levels"
                    " of the destination.");
        }
        return D3DERR_INVALIDCALL;
    }


    return UpdateDirtyPortion(pResourceTarget);
} // UpdateTexture

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::UpdateDirtyPortion"


// Tells the resource that it should copy itself
// to the target. It is the caller's responsibility
// to make sure that Target is compatible with the
// Source. (The Target may have different number of mip-levels
// and be in a different pool; however, it must have the same size,
// faces, format, etc.)
//
// This function will clear the dirty state.
HRESULT CMipVolume::UpdateDirtyPortion(CResource *pResourceTarget)
{
    HRESULT hr;

    // If we are clean, then do nothing
    if (m_cBoxUsed == 0)
    {
        if (IsDirty())
        {
            DPF_ERR("A volume texture has been locked with D3DLOCK_NO_DIRTY_UPDATE but "
                    "no call to AddDirtyBox was made before the texture was used. "
                    "Hardware texture was not updated.");
        }
        return S_OK;
    }

    // We are dirty; so we need to get some pointers
    CMipVolume *pTexSource = static_cast<CMipVolume*>(this);
    CMipVolume *pTexDest   = static_cast<CMipVolume*>(pResourceTarget);

    if (CanTexBlt(pTexDest))
    {
        CD3DBase *pDevice = static_cast<CD3DBase*>(Device());

        if (m_cBoxUsed == MIPVOLUME_ALLDIRTY)
        {   
            D3DBOX box;

            box.Left    = 0;
            box.Right   = Desc()->Width;
            box.Top     = 0;
            box.Bottom  = Desc()->Height;
            box.Front   = 0;
            box.Back    = Desc()->Depth;

            hr = pDevice->VolBlt(pTexDest, 
                                 pTexSource, 
                                 0, 0, 0,   // XYZ offset
                                 &box);
            if (FAILED(hr))
            {
                DPF_ERR("Failed to update volume texture; not clearing dirty state");
                return hr;
            }
        }
        else
        {
            DXGASSERT(m_cBoxUsed < MIPVOLUME_ALLDIRTY);

            for (DWORD i = 0; i < m_cBoxUsed; i++)
            {
                hr = pDevice->VolBlt(pTexDest, 
                                     pTexSource, 
                                     m_DirtyBoxArray[i].Left,
                                     m_DirtyBoxArray[i].Top,
                                     m_DirtyBoxArray[i].Front,
                                     &m_DirtyBoxArray[i]);
                if (FAILED(hr))
                {
                    DPF_ERR("Failed to update volume texture; not clearing dirty state");
                    return hr;
                }
            }
        }

        // Remember that we did the work
        m_cBoxUsed = 0;

        return S_OK;
    }

    // We can't use TexBlt, so we have to copy each level individually
    // with Lock and Copy
    
    // Determine number of source levels to skip
    DXGASSERT(pTexSource->m_cLevels >= pTexDest->m_cLevels);
    DWORD StartLevel = pTexSource->m_cLevels - pTexDest->m_cLevels;
    DWORD LevelsToCopy = pTexSource->m_cLevels - StartLevel;

    // Sanity check
    DXGASSERT(LevelsToCopy > 0);

    // Get the volume desc of the top level to copy
    D3DVOLUME_DESC desc;
    hr = pTexDest->GetLevelDesc(0, &desc);
    DXGASSERT(SUCCEEDED(hr));

    BOOL IsAllDirty = FALSE;
    if (m_cBoxUsed == MIPVOLUME_ALLDIRTY)
    {
        m_cBoxUsed = 1;
        m_DirtyBoxArray[0].Left     = 0;
        m_DirtyBoxArray[0].Right    = m_desc.Width >> StartLevel;

        m_DirtyBoxArray[0].Top      = 0;
        m_DirtyBoxArray[0].Bottom   = m_desc.Height >> StartLevel;

        m_DirtyBoxArray[0].Front    = 0;
        m_DirtyBoxArray[0].Back     = m_desc.Depth >> StartLevel;

        IsAllDirty = TRUE;
    }


    // Determine pixel/block size and make some
    // adjustments if necessary

    // cbPixel is size of pixel or (if negative)
    // a special value for use with AdjustForDXT
    UINT cbPixel = CPixel::ComputePixelStride(desc.Format);

    if (CPixel::IsDXT(cbPixel))
    {
        BOOL IsVolumeDXT = CPixel::IsVolumeDXT(desc.Format);

        // Adjust dirty rect coords from pixels into blocks
        for (DWORD iBox = 0; iBox < m_cBoxUsed; iBox++)
        {
            // Basically we just need to round the value
            // down by 2 powers-of-two. (left/top get rounded
            // down, right/bottom get rounded up)

            if (IsVolumeDXT)
            {
                ScaleBoxDown(&m_DirtyBoxArray[iBox], 2);
            }
            else
            {
                ScaleRectDown((RECT *)&m_DirtyBoxArray[iBox], 2);
            }
        }

        // Adjust width/height from pixels into blocks
        if (IsVolumeDXT)
        {
            CPixel::AdjustForVolumeDXT(&desc.Width,
                                       &desc.Height,
                                       &desc.Depth,
                                       &cbPixel);
        }
        else
        {
            CPixel::AdjustForDXT(&desc.Width, &desc.Height, &cbPixel);
        }
    }

    // cbPixel is now the size of a pixel (or of a block if we've
    // converted into DXT block space)


    // We need to copy each volume piece by piece
    for (DWORD Level = 0; Level < LevelsToCopy; Level++)
    {
        CVolume *pVolumeSrc;
        CVolume *pVolumeDst;

        DXGASSERT(Level + StartLevel < pTexSource->m_cLevels);
        pVolumeSrc = pTexSource->m_VolumeArray[Level + StartLevel];

        DXGASSERT(Level < pTexDest->m_cLevels);
        pVolumeDst = pTexDest->m_VolumeArray[Level];

        D3DLOCKED_BOX SrcBox;
        D3DLOCKED_BOX DstBox;

        // Lock the whole source
        hr = pVolumeSrc->InternalLockBox(&SrcBox,
                                         NULL,
                                         D3DLOCK_READONLY);
        if (FAILED(hr))
        {
            DPF_ERR("Failed to update volume texture; not clearing dirty state");
            return hr;
        }

        // Lock the whole dest
        hr = pVolumeDst->InternalLockBox(&DstBox,
                                         NULL,
                                         0);
        if (FAILED(hr))
        {
            pVolumeSrc->InternalUnlockBox();

            DPF_ERR("Failed to update volume texture; not clearing dirty state");
            return hr;
        }

        // Can we do this with one big memcpy, or do we need
        // to break it up?
        if (IsAllDirty &&
            (SrcBox.RowPitch == DstBox.RowPitch) &&
            (SrcBox.SlicePitch == DstBox.SlicePitch) &&
            (SrcBox.RowPitch == (int)(desc.Width * cbPixel)) &&
            (SrcBox.SlicePitch == (int)(SrcBox.RowPitch * desc.Height)))
        {
            BYTE *pSrc = (BYTE*) SrcBox.pBits;
            BYTE *pDst = (BYTE*) DstBox.pBits;
            memcpy(pDst, pSrc, SrcBox.SlicePitch * desc.Depth);
        }
        else
        {
            // Copy each dirty box one by one
            for (DWORD iBox = 0; iBox < m_cBoxUsed; iBox++)
            {
                D3DBOX *pBox = &m_DirtyBoxArray[iBox];

                BYTE *pSrc = (BYTE*)  SrcBox.pBits;
                pSrc += pBox->Front * SrcBox.SlicePitch;
                pSrc += pBox->Top   * SrcBox.RowPitch;
                pSrc += pBox->Left  * cbPixel;

                BYTE *pDst = (BYTE*)  DstBox.pBits;
                pDst += pBox->Front * DstBox.SlicePitch;
                pDst += pBox->Top   * DstBox.RowPitch;
                pDst += pBox->Left  * cbPixel;

                for (DWORD i = pBox->Front; i < pBox->Back; i++)
                {
                    BYTE *pDepthDst = pDst;
                    BYTE *pDepthSrc = pSrc;
                    DWORD cbSpan = cbPixel * (pBox->Right - pBox->Left);

                    for (DWORD j = pBox->Top; j < pBox->Bottom; j++)
                    {
                        memcpy(pDst, pSrc, cbSpan);
                        pDst += DstBox.RowPitch;
                        pSrc += SrcBox.RowPitch;
                    }
                    pDst = pDepthDst + DstBox.SlicePitch;
                    pSrc = pDepthSrc + SrcBox.SlicePitch;
                }
            }
        }

        // Release our locks
        hr = pVolumeDst->InternalUnlockBox();
        DXGASSERT(SUCCEEDED(hr));

        hr = pVolumeSrc->InternalUnlockBox();
        DXGASSERT(SUCCEEDED(hr));

        // Is the last one?
        if (Level+1 < LevelsToCopy)
        {
            // Shrink the desc
            desc.Width  >>= 1;
            if (desc.Width == 0)
                desc.Width = 1;
            desc.Height >>= 1;
            if (desc.Height == 0)
                desc.Height = 1;
            desc.Depth  >>= 1;
            if (desc.Depth == 0)
                desc.Depth = 1;

            // Shrink the boxes
            for (DWORD iBox = 0; iBox < m_cBoxUsed; iBox++)
            {
                ScaleBoxDown(&m_DirtyBoxArray[iBox]);
            }
        }
    }


    if (FAILED(hr))
    {
        DPF_ERR("Failed to update volume texture; not clearing dirty state");

        return hr;
    }

    // Remember that we did the work
    m_cBoxUsed = 0;

    // Notify Resource base class that we are now clean
    OnResourceClean();
    DXGASSERT(!IsDirty());

    return S_OK;
} // CMipVolume::UpdateDirtyPortion

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::MarkAllDirty"

// Allows the Resource Manager to mark the texture
// as needing to be completely updated on next
// call to UpdateDirtyPortion
void CMipVolume::MarkAllDirty()
{
    // Set palette to __INVALIDPALETTE so that UpdateTextures
    // calls the DDI SetPalette the next time.
    SetPalette(__INVALIDPALETTE);

    // Send dirty notification
    m_cBoxUsed = MIPVOLUME_ALLDIRTY;

    // Notify Resource base class that we are now dirty
    OnResourceDirty();

    return;
} // CMipVolume::MarkAllDirty

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::OnVolumeLock"

// Methods for the Volumes to call
// Notification when a mip-level is locked for writing
void CMipVolume::OnVolumeLock(DWORD iLevel, CONST D3DBOX *pBox, DWORD dwFlags)
{
    // Need to Sync first
    Sync();

    // We only care about the top-most level of the mip-map
    if (iLevel != 0)
    {
        return;
    }

    // Send dirty notification
    OnResourceDirty();

    // If we're not all dirty or if the lock specifies
    // that we don't keep track of the lock then
    // remember the box
    if (m_cBoxUsed != MIPVOLUME_ALLDIRTY &&
        !(dwFlags & D3DLOCK_NO_DIRTY_UPDATE))
    {
        InternalAddDirtyBox(pBox);
    }

    return;
} // CMipVolume::OnVolumeLock

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::AddDirtyBox"

STDMETHODIMP CMipVolume::AddDirtyBox(CONST D3DBOX *pBox)
{
    API_ENTER(Device());

    if (pBox != NULL && !VALID_PTR(pBox, sizeof(D3DBOX)))
    {
        DPF_ERR("Invalid parameter to AddDirtyBox");
        return D3DERR_INVALIDCALL;
    }

    if (pBox)
    {
        if (!CPixel::IsValidBox(Desc()->Format,
                                Desc()->Width, 
                                Desc()->Height, 
                                Desc()->Depth,
                                pBox))
        {
            DPF_ERR("AddDirtyBox for a Volume Texture failed");
            return D3DERR_INVALIDCALL;
        }
    }

    InternalAddDirtyBox(pBox);
    return S_OK;
} // AddDirtyBox

#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::InternalAddDirtyBox"

void CMipVolume::InternalAddDirtyBox(CONST D3DBOX *pBox)
{
    // If driver managed then batch token
    if (Desc()->Pool == D3DPOOL_MANAGED && !IsD3DManaged())
    {
        D3DBOX Box;
        DXGASSERT((Device()->GetD3DCaps()->Caps2 & DDCAPS2_CANMANAGERESOURCE) != 0);
        if (pBox == NULL)
        {
            Box.Left   = 0;
            Box.Top    = 0;             
            Box.Front  = 0;
            Box.Right  = Desc()->Width; 
            Box.Bottom = Desc()->Height;
            Box.Back   = Desc()->Depth;
        }
        else
        {
            Box = *pBox;
        }
        static_cast<CD3DBase*>(Device())->AddDirtyBox(this, &Box); // This will fail only due to catastrophic
                                                                   // error and we or the app can't do a
                                                                   // a whole lot about it, so return nothing
        return;
    }

    // Need to mark dirty bit in CResource so that the resource manager works correctly.
    OnResourceDirty();

    // If everything is being modified; then we're totally dirty
    if (pBox == NULL)
    {
        m_cBoxUsed = MIPVOLUME_ALLDIRTY;
        return;
    }

    // If we're all dirty, we can't get dirtier
    if (m_cBoxUsed == MIPVOLUME_ALLDIRTY)
    {
        return;
    }

    // If the rect is the entire surface then we're all dirty
    DXGASSERT(pBox != NULL);
    if (pBox->Left     == 0                 &&
        pBox->Top      == 0                 &&
        pBox->Front    == 0                 &&
        pBox->Right    == Desc()->Width   &&
        pBox->Bottom   == Desc()->Height  &&
        pBox->Back     == Desc()->Depth)
    {
        m_cBoxUsed = MIPVOLUME_ALLDIRTY;
        return;
    }

    // If we have filled up our boxes; then we're also all dirty now
    if (m_cBoxUsed == MIPVOLUME_MAXDIRTYBOX)
    {
        m_cBoxUsed = MIPVOLUME_ALLDIRTY;
        return;
    }

    // Remember this rect
    DXGASSERT(m_cBoxUsed < MIPVOLUME_MAXDIRTYBOX);
    DXGASSERT(pBox != NULL);
    m_DirtyBoxArray[m_cBoxUsed] = *pBox;
    m_cBoxUsed++;

    // We're done now.
    return;

} // InternalAddDirtyBox


#undef DPF_MODNAME
#define DPF_MODNAME "CMipVolume::IsTextureLocked"

// Debug only parameter checking do determine if a piece
// of a mip-chain is locked
#ifdef DEBUG
BOOL CMipVolume::IsTextureLocked()
{
    for (UINT iLevel = 0; iLevel < m_cLevels; iLevel++)
    {
        if (m_VolumeArray[iLevel]->IsLocked())
            return TRUE;
    }
    return FALSE;

} // IsTextureLocked
#endif // !DEBUG

// End of file : mipvol.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\resource.inl ===
#ifndef __RESOURCE_INL__
#define __RESOURCE_INL__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       resource.inl
 *  Content:    Contains inlines from CResource that need to be separated
 *              to prevent a reference cycle with CD3DBase
 *
 ***************************************************************************/

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::Sync"

inline void CResource::Sync()
{
    static_cast<CD3DBase*>(Device())->Sync(m_qwBatchCount);
} // CResource::Sync

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::Batch"

inline void CResource::Batch()
{
    if (IsD3DManaged())
    {
        Device()->ResourceManager()->Batch(RMHandle(), static_cast<CD3DBase*>(Device())->CurrentBatch());
    }
    else
    {
        SetBatchNumber(static_cast<CD3DBase*>(Device())->CurrentBatch());
    }
} // CResource::Batch

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::BatchBase"

inline void CResource::BatchBase()
{
    SetBatchNumber(static_cast<CD3DBase*>(Device())->CurrentBatch());
} // CResource::BatchBase

#endif //__RESOURCE_INL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\sources.inc ===
TARGETPATH=obj
TARGETNAME = d3dfw

TARGETTYPE = LIBRARY

INCLUDES = \
    ..\;         \
    $(DDK_INC_PATH);\
    $(INCLUDES);

USE_ATL=1
!UNDEF USE_NATIVE_EH

C_DEFINES = $(C_DEFINES) /DNEW_DPF

SOURCES = \
    ..\d3dmem.cpp    \
    ..\pixel.cpp     \
    ..\d3dobj.cpp    \
    ..\resource.cpp  \
    ..\texture.cpp   \
    ..\mipmap.cpp    \
    ..\mipsurf.cpp   \
    ..\mipvol.cpp    \
    ..\volume.cpp    \
    ..\cubemap.cpp   \
    ..\cubesurf.cpp  \
    ..\surface.cpp   \
    ..\buffer.cpp    \
    ..\vbuffer.cpp   \
    ..\ibuffer.cpp   \
    ..\enum.cpp      \
    ..\dxgcreat.cpp  \
    ..\swapchan.cpp  \
    ..\dxcursor.cpp  \
    ..\dwinproc.cpp  \
    ..\_dpf.c        \
    ..\_memallo.c    \
    ..\ddcreate.cpp  \
    ..\dllmain.c     \
    ..\drvinfo.c     \
    ..\fcache.cpp    \
    ..\init.cpp

PRECOMPILED_INCLUDE = ..\ddrawpr.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\surface.hpp ===
#ifndef __SURFACE_HPP__
#define __SURFACE_HPP__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       surface.hpp
 *  Content:    Class header the stand-alone surface class. This class
 *              is intended to be returned by the CreateRenderTarget
 *              creation method. It is also used by the CreateZStencil
 *              device method.
 *
 ***************************************************************************/

// Includes
#include "d3dobj.hpp"
#include "d3di.hpp"

//
// The CSurface class is a standalone surface class; "standalone" indicates
// that it doesn't rely on another class for storing state. 
//
// The base class implementation assumes a sys-mem allocation.
//

class CSurface : public CBaseObject, public CBaseSurface
{
public:
    // Creation method to allow creation of render targets
    static HRESULT CreateRenderTarget(CBaseDevice        *pDevice, 
                                      DWORD               cpWidth,
                                      DWORD               cpHeight,
                                      D3DFORMAT           Format,
                                      D3DMULTISAMPLE_TYPE MultiSampleType,
                                      BOOL                bLockable,
                                      REF_TYPE            refType,
                                      IDirect3DSurface8 **ppSurface)
    {
        DWORD Usage = D3DUSAGE_RENDERTARGET;
        if (bLockable)
            Usage = D3DUSAGE_LOCK | D3DUSAGE_RENDERTARGET;

        return Create(pDevice, 
                      cpWidth,
                      cpHeight,
                      Usage,
                      Format,
                      MultiSampleType,
                      refType,
                      ppSurface);
    }

    // Creation method to allow creation of Z/Stencil buffers 
    static HRESULT CreateZStencil(CBaseDevice        *pDevice, 
                                  DWORD               cpWidth,
                                  DWORD               cpHeight,
                                  D3DFORMAT           Format,
                                  D3DMULTISAMPLE_TYPE MultiSampleType,
                                  REF_TYPE            refType,
                                  IDirect3DSurface8 **ppSurface)
    {
        return Create(pDevice, 
                      cpWidth,
                      cpHeight,
                      D3DUSAGE_DEPTHSTENCIL,
                      Format,
                      MultiSampleType,
                      refType,
                      ppSurface);
    }

    // Creation method for stand-along ImageSurface 
    static HRESULT CreateImageSurface(CBaseDevice        *pDevice,
                                      DWORD               cpWidth,
                                      DWORD               cpHeight,
                                      D3DFORMAT           Format,
                                      REF_TYPE            refType,
                                      IDirect3DSurface8 **ppSurface);

    // Destructor
    virtual ~CSurface();

    // IUnknown methods
    STDMETHOD(QueryInterface) (REFIID  riid, 
                               VOID  **ppvObj);
    STDMETHOD_(ULONG,AddRef) ();
    STDMETHOD_(ULONG,Release) ();

    // IBuffer methods
    STDMETHOD(SetPrivateData)(REFGUID riid, 
                              CONST VOID   *pvData, 
                              DWORD   cbData, 
                              DWORD   dwFlags);

    STDMETHOD(GetPrivateData)(REFGUID riid, 
                              VOID   *pvData, 
                              DWORD  *pcbData);

    STDMETHOD(FreePrivateData)(REFGUID riid);

    STDMETHOD(GetContainer)(REFIID riid, 
                            void **ppContainer);

    STDMETHOD(GetDevice)(IDirect3DDevice8 **ppDevice);

    // IDirect3DSurface8 methods
    STDMETHOD(GetDesc)(D3DSURFACE_DESC *pDesc);

    STDMETHOD(LockRect)(D3DLOCKED_RECT  *pLockedRectData, 
                        CONST RECT      *pRect, 
                        DWORD            dwFlags) PURE;

    STDMETHOD(UnlockRect)() PURE;

    BOOL IsLockable() const
    {
        if (m_desc.Usage & D3DUSAGE_LOCK)
            return TRUE;
        else
            return FALSE;
    } // IsLockable

#ifdef DEBUG
    // DPF helper for explaining why lock failed
    void ReportWhyLockFailed(void) const;
#else  // !DEBUG
    void ReportWhyLockFailed(void) const
    {
        // Do Nothing In Retail
    } // ReportWhyLockFailed
#endif // !DEBUG

    D3DFORMAT GetUserFormat() const
    {
        return m_formatUser;
    } // GetUserFormat

    // BaseSurface methods
    virtual DWORD DrawPrimHandle() const
    {
        return BaseDrawPrimHandle();
    } // GetDrawPrimHandle
    virtual HANDLE KernelHandle() const
    {
        return BaseKernelHandle();
    } // GetKernelHandle

    virtual DWORD IncrementUseCount()
    {
        return CBaseObject::IncrementUseCount();
    } // IncrementUseCount

    virtual DWORD DecrementUseCount()
    {
        return CBaseObject::DecrementUseCount();
    } // DecrementUseCount

    virtual void Batch()
    {
        ULONGLONG qwBatch = static_cast<CD3DBase*>(Device())->CurrentBatch();        
        DXGASSERT(qwBatch >= m_qwBatchCount);
        m_qwBatchCount = qwBatch;
    } // Batch

    // Sync should be called before
    // any read or write access to the surface
    virtual void Sync()
    {
        static_cast<CD3DBase*>(Device())->Sync(m_qwBatchCount);
    } // Sync

    // OnDestroy function is called just
    // before an object is about to get deleted; we
    // use this to provide synching prior to deletion
    virtual void OnDestroy()
    {
        Sync();
    }; // OnDestroy

    virtual D3DSURFACE_DESC InternalGetDesc() const;

    virtual CBaseDevice * InternalGetDevice() const
    {
        return CBaseObject::Device();
    } // Device

    // Determines if a LOAD_ONCE surface has already
    // been loaded
    virtual BOOL IsLoaded() const
    {
        // These kinds of surfaces (RT/DS/Image) are never
        // load-once; so this should never be called.
        DXGASSERT(!(m_desc.Usage & D3DUSAGE_LOADONCE));
        DXGASSERT(FALSE);
        return FALSE;
    } // IsLoaded

    // End Of BaseSurface methods

protected:

    // Creation method to allow creation of render targets/zbuffers
    static HRESULT Create(CBaseDevice        *pDevice, 
                          DWORD               cpWidth,
                          DWORD               cpHeight,
                          DWORD               dwUsage,
                          D3DFORMAT           Format,
                          D3DMULTISAMPLE_TYPE MultiSampleType,
                          REF_TYPE            refType,
                          IDirect3DSurface8 **ppSurface);

    // Surface description
    D3DSURFACE_DESC m_desc;

    // Pool that User specified
    D3DPOOL         m_poolUser;

    // Format that User specified
    D3DFORMAT       m_formatUser;

    // Constructor returns an error code
    // if the object could not be fully
    // constructed
    CSurface(CBaseDevice *pDevice, 
             DWORD        cpWidth,
             DWORD        cpHeight,
             DWORD        dwUsage,
             D3DFORMAT    Format,
             REF_TYPE     refType,
             HRESULT     *phr
             );

private:
    // Batch count to make sure that the current
    // command buffer has been flushed
    // before read or write access to the
    // bits
    ULONGLONG m_qwBatchCount;

}; // class CSurface

// Derived class for system-memory version
class CSysMemSurface : public CSurface
{
    // CSurface is the master class and can access
    // whatever it wants
    friend CSurface;

public:
    // Constructor
    CSysMemSurface(CBaseDevice         *pDevice, 
                   DWORD                cpWidth,
                   DWORD                cpHeight,
                   DWORD                dwUsage,
                   D3DFORMAT            Format,
                   REF_TYPE             refType,
                   HRESULT             *phr
                   );

    //  destructor
    virtual ~CSysMemSurface();

    // Override Lock and Unlock
    STDMETHOD(LockRect)(D3DLOCKED_RECT *pLockedRectData, 
                        CONST RECT     *pRect, 
                        DWORD           dwFlags);

    STDMETHOD(UnlockRect)();

    // Internal lock functions bypass
    // parameter checking and also whether the
    // surface marked as Lockable or LockOnce
    // etc. (Methods of CBaseSurface)
    virtual HRESULT InternalLockRect(D3DLOCKED_RECT *pLockedRectData, 
                                     CONST RECT     *pRect, 
                                     DWORD           dwFlags);

    virtual HRESULT InternalUnlockRect();

private:
    BYTE  *m_rgbPixels;
}; // class CSysMemSurface

// Derived class for the driver allocated version
class CDriverSurface : public CSurface
{
    // CSurface is the master class and can access
    // whatever it wants
    friend CSurface;

public:
    // Constructor
    CDriverSurface(CBaseDevice          *pDevice, 
                   DWORD                 cpWidth,
                   DWORD                 cpHeight,
                   DWORD                 dwUsage,
                   D3DFORMAT             UserFormat,
                   D3DFORMAT             RealFormat,
                   D3DMULTISAMPLE_TYPE   MultiSampleType,
                   HANDLE                hKernelHandle,
                   REF_TYPE              refType,
                   HRESULT              *phr
                   );

    //  destructor
    virtual ~CDriverSurface();

    // Override Lock and Unlock
    STDMETHOD(LockRect)(D3DLOCKED_RECT *pLockedRectData, 
                        CONST RECT     *pRect, 
                        DWORD           dwFlags);

    STDMETHOD(UnlockRect)();

    // Internal lock functions bypass
    // parameter checking and also whether the
    // surface marked as Lockable or LockOnce
    // etc. (Methods of CBaseSurface)
    virtual HRESULT InternalLockRect(D3DLOCKED_RECT *pLockedRectData, 
                                     CONST RECT     *pRect, 
                                     DWORD           dwFlags);

    virtual HRESULT InternalUnlockRect();

}; // CDriverSurface


#endif // __SURFACE_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\resource.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       rman.cpp
 *  Content:    Resource management
 *
 ***************************************************************************/

#include "ddrawpr.h"
#include "dxgint.h"
#include "resource.hpp"
#include "texture.hpp"
#include "d3di.hpp"
#include "ddi.h"

// Always use heap 0
DWORD CMgmtInfo::m_rmHeap = 0;

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::UpdateDirtyPortion"

// These stub functions are only supported for managed resources;
// they should never get called; the asserts are there to help
// determine where the bug is if they do get called.
HRESULT CResource::UpdateDirtyPortion(CResource *pResourceTarget)
{
    // This should not be called except for D3D_MANAGED
    // objects because we don't keep dirty portion records
    // for other kinds of objects.

    // If we were D3D_MANAGED: the real class should have
    // overriden this method
    DXGASSERT(!IsTypeD3DManaged(Device(), 
                                GetBufferDesc()->Type,
                                GetBufferDesc()->Pool));

    // If this isn't D3DManaged, we shouldn't have
    // been called.
    DXGASSERT(FALSE);

    // return something benign for retail build
    return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::MarkAllDirty"

void CResource::MarkAllDirty()
{
    // This should not be called except for D3D_MANAGED
    // objects because we don't keep dirty portion records
    // for other kinds of objects.

    // If we were D3D_MANAGED: the real class should have
    // overriden this method
    DXGASSERT(!IsTypeD3DManaged(Device(), 
                                GetBufferDesc()->Type,
                                GetBufferDesc()->Pool));

    // If this isn't D3DManaged, we shouldn't have
    // been called.
    DXGASSERT(FALSE);
} // CResource::MarkAllDirty

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::SetPriorityImpl"

DWORD CResource::SetPriorityImpl(DWORD newPri)
{
    DWORD oldPriority = 0;
    if (IsD3DManaged())
    {
        oldPriority = Device()->ResourceManager()->SetPriority(m_RMHandle, newPri);        
    }
    // If IsD3DManaged() is FALSE and if the actual pool
    // is found to be D3DPOOL_MANAGED then the resource
    // MUST be driver managed.
    else if (GetBufferDesc()->Pool == D3DPOOL_MANAGED)
    {
        CD3DBase *pDev = static_cast<CD3DBase*>(Device());
        DXGASSERT(IS_DX8HAL_DEVICE(pDev));
        oldPriority = SetPriorityI(newPri);
        pDev->SetPriority(this, newPri);
    }
    // If above two conditions are false, then we must
    // check if we have fallen back to sysmem for some
    // reason even if the app requested managed. We
    // can know whether the app requested D3DPOOL_MANAGED
    // by calling GetUserPool().
    else if (GetUserPool() == D3DPOOL_MANAGED)
    {
        // We assert because sysmem fallback is currently
        // possible for only vertex or index buffers.
        DXGASSERT(GetBufferDesc()->Type == D3DRTYPE_VERTEXBUFFER ||
                  GetBufferDesc()->Type == D3DRTYPE_INDEXBUFFER);
        // No need to do any real work since the
        // resource is in sysmem in any case.
        oldPriority = SetPriorityI(newPri);
    }
    else
    {
        DPF_ERR("Priority set on non-managed object. SetPriority returns zero.");
    }
    return oldPriority;
} // SetPriorityImpl

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::GetPriorityImpl"

DWORD CResource::GetPriorityImpl()
{
    if (!IsD3DManaged() && GetBufferDesc()->Pool != D3DPOOL_MANAGED && GetUserPool() != D3DPOOL_MANAGED)
    {
        DPF_ERR("Priority accessed on non-managed object. GetPriority returns zero.");
        return 0;
    }
    return GetPriorityI();    
} // GetPriorityImpl

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::PreLoadImpl"
void CResource::PreLoadImpl()
{
    if (IsD3DManaged())
    {
        Device()->ResourceManager()->PreLoad(m_RMHandle);
    }
    // If IsD3DManaged() is FALSE and if the actual pool
    // is found to be D3DPOOL_MANAGED then the resource
    // MUST be driver managed.
    else if (GetBufferDesc()->Pool == D3DPOOL_MANAGED)
    {
        CD3DBase *pDev = static_cast<CD3DBase*>(Device());
        DXGASSERT(IS_DX8HAL_DEVICE(pDev));
        if(GetBufferDesc()->Type == D3DRTYPE_TEXTURE ||
           GetBufferDesc()->Type == D3DRTYPE_VOLUMETEXTURE ||
           GetBufferDesc()->Type == D3DRTYPE_CUBETEXTURE)
        {
            POINT p = {0, 0};
            RECTL r = {0, 0, 0, 0};
            pDev->TexBlt(0, 
                         static_cast<CBaseTexture*>(this), 
                         &p, 
                         &r);
        }
        else
        {
            DXGASSERT(GetBufferDesc()->Type == D3DRTYPE_VERTEXBUFFER ||
                      GetBufferDesc()->Type == D3DRTYPE_INDEXBUFFER);
            D3DRANGE range = {0, 0};
            pDev->BufBlt(0,
                         static_cast<CBuffer*>(this), 
                         0,
                         &range);
        }
    }
    // If above two conditions are false, then we must
    // check if we have fallen back to sysmem for some
    // reason even if the app requested managed. We
    // can know whether the app requested D3DPOOL_MANAGED
    // by calling GetUserPool().
    else if (GetUserPool() == D3DPOOL_MANAGED)
    {
        // We assert because sysmem fallback is currently
        // possible for only vertex or index buffers.
        DXGASSERT(GetBufferDesc()->Type == D3DRTYPE_VERTEXBUFFER ||
                  GetBufferDesc()->Type == D3DRTYPE_INDEXBUFFER);

        // Do nothing since vertex/index buffer are in sysmem
        // and preload has no meaning
    }
    else
    {
        DPF_ERR("PreLoad called on non-managed object");
    }
} // PreLoadImpl

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::RestoreDriverManagementState"

HRESULT CResource::RestoreDriverManagementState(CBaseDevice *pDevice)
{
    for(CResource *pRes = pDevice->GetResourceList(); pRes != 0; pRes = pRes->m_pNext)
    {
        if (pRes->GetBufferDesc()->Pool == D3DPOOL_MANAGED && !pRes->IsD3DManaged()) // Must be driver managed
        {
            static_cast<CD3DBase*>(pDevice)->SetPriority(pRes, pRes->GetPriorityI());
            if (pRes->GetBufferDesc()->Type == D3DRTYPE_TEXTURE ||
                pRes->GetBufferDesc()->Type == D3DRTYPE_VOLUMETEXTURE ||
                pRes->GetBufferDesc()->Type == D3DRTYPE_CUBETEXTURE)
            {
                static_cast<CD3DBase*>(pDevice)->SetTexLOD(static_cast<CBaseTexture*>(pRes), 
                                                           static_cast<CBaseTexture*>(pRes)->GetLODI());
            }
            // We need to update cached pointers for read/write vertex and index buffers
            else if (pRes->GetBufferDesc()->Type == D3DRTYPE_VERTEXBUFFER &&
                     (pRes->GetBufferDesc()->Usage & D3DUSAGE_WRITEONLY) == 0)
            {
                HRESULT hr = static_cast<CDriverManagedVertexBuffer*>(pRes)->UpdateCachedPointer(pDevice);
                if (FAILED(hr))
                {
                    return hr;
                }
            }
            else if (pRes->GetBufferDesc()->Type == D3DRTYPE_INDEXBUFFER &&
                     (pRes->GetBufferDesc()->Usage & D3DUSAGE_WRITEONLY) == 0)
            {
                HRESULT hr = static_cast<CDriverManagedIndexBuffer*>(pRes)->UpdateCachedPointer(pDevice);
                if (FAILED(hr))
                {
                    return hr;
                }
            }
        }
    }
    return S_OK;
} // RestoreDriverManagementState

#undef DPF_MODNAME
#define DPF_MODNAME "CRMHeap::Initialize"

BOOL CRMHeap::Initialize()
{
    m_data_p = new CMgmtInfo*[m_size];
    if (m_data_p == 0)
    {
        DPF_ERR("Failed to allocate texture heap.");
        return FALSE;
    }
    memset(m_data_p, 0, sizeof(CMgmtInfo*) * m_size);
    return TRUE;
} // CRMHeap::Initialize

#undef DPF_MODNAME
#define DPF_MODNAME "CRMHeap::heapify"

void CRMHeap::heapify(DWORD k)
{
    while(TRUE)
    {
        DWORD smallest;
        DWORD l = lchild(k);
        DWORD r = rchild(k);
        if (l < m_next)
            if (m_data_p[l]->Cost() < m_data_p[k]->Cost())
                smallest = l;
            else
                smallest = k;
        else
            smallest = k;
        if (r < m_next)
            if (m_data_p[r]->Cost() < m_data_p[smallest]->Cost())
                smallest = r;
        if (smallest != k)
        {
            CMgmtInfo *t = m_data_p[k];
            m_data_p[k] = m_data_p[smallest];
            m_data_p[k]->m_rmHeapIndex = k;
            m_data_p[smallest] = t;
            m_data_p[smallest]->m_rmHeapIndex = smallest;
            k = smallest;
        }
        else
            break;
    }
} // CRMHeap::heapify

#undef DPF_MODNAME
#define DPF_MODNAME "CRMHeap::add"

BOOL CRMHeap::add(CMgmtInfo *pMgmtInfo)
{
    DXGASSERT(pMgmtInfo->m_rmHeapIndex == 0);
    if (m_next == m_size)
    {
        m_size = m_size * 2 - 1;
        CMgmtInfo **p = new CMgmtInfo*[m_size];
        if (p == 0)
        {
            DPF_ERR("Failed to allocate memory to grow heap.");
            m_size = (m_size + 1) / 2; // restore size
            return FALSE;
        }
        memcpy(p + 1, m_data_p + 1, sizeof(CMgmtInfo*) * (m_next - 1));
        delete[] m_data_p;
        m_data_p = p;
    }
    ULONGLONG Cost = pMgmtInfo->Cost();
    for (DWORD k = m_next; k > 1; k = parent(k))
        if (Cost < m_data_p[parent(k)]->Cost())
        {
            m_data_p[k] = m_data_p[parent(k)];
            m_data_p[k]->m_rmHeapIndex = k;
        }
        else
            break;
    m_data_p[k] = pMgmtInfo;
    m_data_p[k]->m_rmHeapIndex = k;
    ++m_next;
    return TRUE;
} // CRMHeap::add

#undef DPF_MODNAME
#define DPF_MODNAME "CRMHeap::extractMin"

CMgmtInfo* CRMHeap::extractMin()
{
    CMgmtInfo *pMgmtInfo = m_data_p[1];
    --m_next;
    m_data_p[1] = m_data_p[m_next];
    m_data_p[1]->m_rmHeapIndex = 1;
    heapify(1);
    pMgmtInfo->m_rmHeapIndex = 0;
    return pMgmtInfo;
} // CRMHeap::extractMin

#undef DPF_MODNAME
#define DPF_MODNAME "CRMHeap::extractMax"

CMgmtInfo* CRMHeap::extractMax()
{
    // When extracting the max element from the heap, we don't need to
    // search the entire heap, but just the leafnodes. This is because
    // it is guaranteed that parent nodes are cheaper than the leaf nodes
    // so once you have looked through the leaves, you won't find anything
    // cheaper.
    // NOTE: (lchild(i) >= m_next) is TRUE only for leaf nodes.
    // ALSO NOTE: You cannot have a rchild without a lchild, so simply
    //            checking for lchild is sufficient.
    // 
    // CONSIDER(40358): Should have asserts to verify above assumptions; but
    //                  it would require writing a heap-consistency
    //                  checker. Maybe someday.
    //
    unsigned max = m_next - 1;
    ULONGLONG maxcost = 0;
    for (unsigned i = max; lchild(i) >= m_next; --i)
    {
        ULONGLONG Cost = m_data_p[i]->Cost();
        if (maxcost < Cost)
        {
            maxcost = Cost;
            max = i;
        }
    }
    CMgmtInfo* pMgmtInfo = m_data_p[max];
    if (pMgmtInfo->m_bInUse)
    {
        max = 0;
        maxcost = 0;
        for (i = m_next - 1; i > 0; --i)
        {
            ULONGLONG Cost = m_data_p[i]->Cost();
            if (maxcost < Cost && !m_data_p[i]->m_bInUse)
            {
                maxcost = Cost;
                max = i;
            }
        }
        if (max == 0) // All textures in use
            return 0;
        pMgmtInfo = m_data_p[max];
    }
    del(m_data_p[max]);
    return pMgmtInfo;
} // CRMHeap::extractMax

#undef DPF_MODNAME
#define DPF_MODNAME "CRMHeap::extractNotInScene"

CMgmtInfo* CRMHeap::extractNotInScene(DWORD dwScene)
{
    for (unsigned i = 1; i < m_next; ++i)
    {
        if (m_data_p[i]->m_scene != dwScene)
        {
            CMgmtInfo* pMgmtInfo = m_data_p[i];
            del(m_data_p[i]);
            return pMgmtInfo;
        }
    }
    return 0;
} // CRMHeap::extractNotInScene

#undef DPF_MODNAME
#define DPF_MODNAME "CRMHeap::del"

void CRMHeap::del(CMgmtInfo* pMgmtInfo)
{
    DWORD k = pMgmtInfo->m_rmHeapIndex;
    --m_next;
    ULONGLONG Cost = m_data_p[m_next]->Cost();
    if (Cost < pMgmtInfo->Cost())
    {
        while(k > 1)
        {
            if (Cost < m_data_p[parent(k)]->Cost())
            {
                m_data_p[k] = m_data_p[parent(k)];
                m_data_p[k]->m_rmHeapIndex = k;
            }
            else
                break;
            k = parent(k);
        }
        m_data_p[k] = m_data_p[m_next];
        m_data_p[k]->m_rmHeapIndex = k;
    }
    else
    {
        m_data_p[k] = m_data_p[m_next];
        m_data_p[k]->m_rmHeapIndex = k;
        heapify(k);
    }
    pMgmtInfo->m_rmHeapIndex = 0;
} // CRMHeap::del

#undef DPF_MODNAME
#define DPF_MODNAME "CRMHeap::update"

void CRMHeap::update(CMgmtInfo* pMgmtInfo, BOOL inuse, DWORD priority, DWORD ticks)
{
    DWORD k = pMgmtInfo->m_rmHeapIndex;
    ULONGLONG Cost;
#ifdef _X86_
    _asm
    {
        mov     edx, inuse;
        shl     edx, 31;
        mov     eax, priority;
        mov     ecx, eax;
        shr     eax, 1;
        or      edx, eax;
        mov     DWORD PTR Cost + 4, edx;
        shl     ecx, 31;
        mov     eax, ticks;
        shr     eax, 1;
        or      eax, ecx;
        mov     DWORD PTR Cost, eax;
    }
#else
    Cost = ((ULONGLONG)inuse << 63) + ((ULONGLONG)priority << 31) + ((ULONGLONG)(ticks >> 1));
#endif
    if (Cost < pMgmtInfo->Cost())
    {
        while(k > 1)
        {
            if (Cost < m_data_p[parent(k)]->Cost())
            {
                m_data_p[k] = m_data_p[parent(k)];
                m_data_p[k]->m_rmHeapIndex = k;
            }
            else
                break;
            k = parent(k);
        }
        pMgmtInfo->m_bInUse = inuse;
        pMgmtInfo->m_priority = priority;
        pMgmtInfo->m_ticks = ticks;
        pMgmtInfo->m_rmHeapIndex = k;
        m_data_p[k] = pMgmtInfo;
    }
    else
    {
        pMgmtInfo->m_bInUse = inuse;
        pMgmtInfo->m_priority = priority;
        pMgmtInfo->m_ticks = ticks;
        heapify(k);
    }
} // CRMHeap::update

#undef DPF_MODNAME
#define DPF_MODNAME "CRMHeap::resetAllTimeStamps"

void CRMHeap::resetAllTimeStamps(DWORD ticks)
{
    for (unsigned i = 1; i < m_next; ++i)
    {
        update(m_data_p[i], m_data_p[i]->m_bInUse, m_data_p[i]->m_priority, ticks);
    }
} // CRMHeap::resetAllTimeStamps

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::Init"

HRESULT CResourceManager::Init(CBaseDevice *pD3D8)
{
    const D3DCAPS8* pCaps = pD3D8->GetD3DCaps();
    if (pCaps != 0)
        if (pCaps->DevCaps & D3DDEVCAPS_SEPARATETEXTUREMEMORIES)
        {
            m_dwNumHeaps = pD3D8->GetD3DCaps()->MaxSimultaneousTextures;
            if (m_dwNumHeaps < 1)
            {
                DPF_ERR("Max simultaneous textures not set. Forced to 1.");
                m_dwNumHeaps = 1;
            }
            DPF(2, "Number of heaps set to %u.", m_dwNumHeaps);
        }
        else
            m_dwNumHeaps = 1;
    else
        m_dwNumHeaps = 1;
    m_heap_p = new CRMHeap[m_dwNumHeaps];
    if (m_heap_p == 0)
    {
        DPF_ERR("Out of memory allocating texture heap.");
        return E_OUTOFMEMORY;
    }
    for (DWORD i = 0; i < m_dwNumHeaps; ++i)
    {
        if (m_heap_p[i].Initialize() == FALSE)
        {
            delete[] m_heap_p;
            m_heap_p = 0;
            return E_OUTOFMEMORY;
        }
    }
    m_pD3D8 = pD3D8;
    return S_OK;
} // CResourceManager::Init

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::IsDriverManaged"

BOOL CResourceManager::IsDriverManaged(D3DRESOURCETYPE Type) const
{
#if DBG
    switch (Type)
    {
    case D3DRTYPE_TEXTURE:
    case D3DRTYPE_VOLUMETEXTURE:
    case D3DRTYPE_CUBETEXTURE:
    case D3DRTYPE_VERTEXBUFFER:
    case D3DRTYPE_INDEXBUFFER:
        break;

    default:
        DXGASSERT(FALSE && "Management not supported for this type");
        return FALSE;
    };
#endif // DBG

    return m_pD3D8->CanDriverManageResource();

}; // IsDriverManaged(D3DRESOURCETYPE)

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::Manage"

HRESULT CResourceManager::Manage(CResource *pResource, RMHANDLE *pHandle)
{
    *pHandle = 0;
    DXGASSERT(!pResource->IsD3DManaged());

    CMgmtInfo *pRMInfo = new CMgmtInfo(pResource);        
    if (pRMInfo == 0)
    {
        return E_OUTOFMEMORY;
    }
    *pHandle = pRMInfo;
    return S_OK;
} // CResourceManager::Manage

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::UnManage"

void CResourceManager::UnManage(RMHANDLE hRMHandle)
{
    CMgmtInfo* &pMgmtInfo = hRMHandle;
    if (pMgmtInfo == 0)
        return;
    if (InVidmem(hRMHandle))
    {
        m_heap_p[pMgmtInfo->m_rmHeap].del(pMgmtInfo);
    }
    delete pMgmtInfo;
} // CResourceManager::UnManage

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::SetPriority"

DWORD CResourceManager::SetPriority(RMHANDLE hRMHandle, DWORD newPriority)
{
    CMgmtInfo* &pMgmtInfo = hRMHandle;
    DXGASSERT(pMgmtInfo != 0);
    DWORD oldPriority = pMgmtInfo->m_pBackup->SetPriorityI(newPriority);
    if (InVidmem(hRMHandle))
    {
        m_heap_p[pMgmtInfo->m_rmHeap].update(pMgmtInfo, pMgmtInfo->m_bInUse, newPriority, pMgmtInfo->m_ticks); 
    }
    return oldPriority;
} // CResourceManager::SetPriority

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::SetLOD"

DWORD CResourceManager::SetLOD(RMHANDLE hRMHandle, DWORD dwLodNew)
{
    DWORD oldLOD;
    CMgmtInfo* &pMgmtInfo = hRMHandle;
    DXGASSERT(pMgmtInfo != 0);
    DXGASSERT(pMgmtInfo->m_pBackup->GetBufferDesc()->Type == D3DRTYPE_TEXTURE ||
              pMgmtInfo->m_pBackup->GetBufferDesc()->Type == D3DRTYPE_VOLUMETEXTURE ||
              pMgmtInfo->m_pBackup->GetBufferDesc()->Type == D3DRTYPE_CUBETEXTURE);
    CBaseTexture *pTex = static_cast<CBaseTexture*>(pMgmtInfo->m_pBackup);
    if (dwLodNew < pTex->GetLevelCount())
    {
        oldLOD = pTex->SetLODI(dwLodNew);
    }
    else
    {
        DPF_ERR("Texture does not have sufficient miplevels for current LOD. LOD set to GetLevelCount()-1.");
        oldLOD = pTex->SetLODI(pTex->GetLevelCount() - 1);
    }
    if (InVidmem(hRMHandle))
    {
        m_heap_p[pMgmtInfo->m_rmHeap].del(pMgmtInfo); 
        pMgmtInfo->m_pRes->DecrementUseCount();
        pMgmtInfo->m_pRes = 0;
        static_cast<LPD3DBASE>(this->m_pD3D8)->NeedResourceStateUpdate(); // Need to call this so that DrawPrimitive will do the necessary work
    }
    return oldLOD;
} // CResourceManager::SetLOD

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::PreLoad"
void CResourceManager::PreLoad(RMHANDLE hRMHandle)
{
    CMgmtInfo* &pMgmtInfo = hRMHandle;
    DXGASSERT(pMgmtInfo != 0);
    BOOL  bDirty = FALSE;
    m_PreLoading = TRUE;
    UpdateVideo(hRMHandle, &bDirty);
    m_PreLoading = FALSE;
} // CResourceManaged::PreLoad

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::Lock"

void CResourceManager::Lock(RMHANDLE hRMHandle)
{
    if (hRMHandle != 0)
    {
        CMgmtInfo* &pMgmtInfo = hRMHandle;
        if (InVidmem(hRMHandle))
        {
            m_heap_p[pMgmtInfo->m_rmHeap].update(pMgmtInfo, TRUE, pMgmtInfo->m_pBackup->GetPriorityI(), pMgmtInfo->m_ticks); 
        }
    }
} // CResourceManager::Lock

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::Unlock"

void CResourceManager::Unlock(RMHANDLE hRMHandle)
{
    if (hRMHandle != 0)
    {
        CMgmtInfo* &pMgmtInfo = hRMHandle;
        if (InVidmem(hRMHandle))
        {
            m_heap_p[pMgmtInfo->m_rmHeap].update(pMgmtInfo, FALSE, pMgmtInfo->m_pBackup->GetPriorityI(), pMgmtInfo->m_ticks); 
        }
    }
} // CResourceManager::Unlock

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::FreeResources"

BOOL CResourceManager::FreeResources(DWORD dwHeap, DWORD dwBytes)
{
    if (m_heap_p[dwHeap].length() == 0)
        return FALSE;
    unsigned sz;
    CMgmtInfo *rc;
    for (unsigned i = 0; m_heap_p[dwHeap].length() != 0 && i < dwBytes; i += sz)
    {
        // Find the LRU texture and remove it.
        rc = m_heap_p[dwHeap].minCost();
        if (rc->m_bInUse)
            return FALSE;
        sz = rc->m_pRes->GetBufferDesc()->Size; // save size
        if (rc->m_scene == m_dwScene)
        {
            if(m_PreLoading)
            {
                return TRUE;
            }
            if (m_pD3D8->GetD3DCaps()->RasterCaps & D3DPRASTERCAPS_ZBUFFERLESSHSR)
            {                
                DPF(0, "Trying to locate texture not used in current scene...");
                rc = m_heap_p[dwHeap].extractNotInScene(m_dwScene);
                if (rc == 0)
                {
                    DPF_ERR("No such texture found. Cannot evict textures used in current scene.");
                    return FALSE;
                }
                DPF(0, "Texture found!");
                rc->m_pRes->DecrementUseCount();
                rc->m_pRes = 0;
            }
            else
            {
                DPF(1, "Texture cache thrashing. Removing MRU texture.");
                rc = m_heap_p[dwHeap].extractMax();
                if (rc == 0)
                {
                    DPF_ERR("All textures in use, cannot evict texture.");
                    return FALSE;
                }
                rc->m_pRes->DecrementUseCount();
                rc->m_pRes = 0;
            }
        }
        else
        {
            rc = m_heap_p[dwHeap].extractMin();
            rc->m_pRes->DecrementUseCount();
            rc->m_pRes = 0;
        }
        DPF(2, "Removed texture with timestamp %u,%u (current = %u).", rc->m_priority, rc->m_ticks, tcm_ticks);
    }
    return TRUE;
} // CResourceManager::FreeResources

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::DiscardBytes"

void CResourceManager::DiscardBytes(DWORD cbBytes)
{
    for (DWORD i = 0; i < m_dwNumHeaps; ++i)
    {
        if (cbBytes == 0)
        {
            while(m_heap_p[i].length())
            {
                CMgmtInfo *pMgmtInfo = m_heap_p[i].extractMin();
                pMgmtInfo->m_pRes->DecrementUseCount();
                pMgmtInfo->m_pRes = 0;
            }
        }
        else
        {
            FreeResources(i, cbBytes / m_dwNumHeaps);
        }
    }
    static_cast<LPD3DBASE>(m_pD3D8)->NeedResourceStateUpdate();
    tcm_ticks = 0;
    m_dwScene = 0;
} // CResourceManager::DiscardBytes

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::TimeStamp"

void CResourceManager::TimeStamp(CMgmtInfo *pMgmtInfo)
{
    pMgmtInfo->m_scene = m_dwScene;
    m_heap_p[pMgmtInfo->m_rmHeap].update(pMgmtInfo, pMgmtInfo->m_bInUse, pMgmtInfo->m_pBackup->GetPriorityI(), tcm_ticks);
    unsigned tickp2 = tcm_ticks + 2;
    if (tickp2 > tcm_ticks)
    {
        tcm_ticks = tickp2;
    }
    else // counter has overflowed. Let's reset all timestamps to zero
    {
        DPF(2, "Timestamp counter overflowed. Reseting timestamps for all textures.");
        tcm_ticks = 0;
        for (DWORD i = 0; i < m_dwNumHeaps; ++i)
            m_heap_p[i].resetAllTimeStamps(0);
    }
} // CResourceManager::TimeStamp

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::UpdateVideoInternal"

HRESULT CResourceManager::UpdateVideoInternal(CMgmtInfo *pMgmtInfo)
{
    HRESULT ddrval;
    DWORD trycount = 0, bytecount = pMgmtInfo->m_pBackup->GetBufferDesc()->Size;
    LPD3DBASE lpDevI = static_cast<LPD3DBASE>(m_pD3D8);
    // We need to make sure that we don't evict any mapped textures
    for (DWORD dwStage = 0; dwStage < lpDevI->m_dwMaxTextureBlendStages; ++dwStage)
    {
        if (lpDevI->m_lpD3DMappedTexI[dwStage] != 0)
        {
            Lock(lpDevI->m_lpD3DMappedTexI[dwStage]->RMHandle());
        }
    }
    for (DWORD dwStream = 0; dwStream < lpDevI->m_dwNumStreams; ++dwStream)
    {
        if (lpDevI->m_pStream[dwStream].m_pVB != 0)
        {
            Lock(lpDevI->m_pStream[dwStream].m_pVB->RMHandle());
        }
    }
    if (lpDevI->m_pIndexStream->m_pVBI != 0)
    {
        Lock(lpDevI->m_pIndexStream->m_pVBI->RMHandle());
    }
    // Attempt to allocate a texture.
    do
    {
        ++trycount;
        ddrval = pMgmtInfo->m_pBackup->Clone(D3DPOOL_DEFAULT, &pMgmtInfo->m_pRes);
        if (SUCCEEDED(ddrval)) // No problem, there is enough memory.
        {
            pMgmtInfo->m_scene = m_dwScene;
            pMgmtInfo->m_ticks = tcm_ticks;
            DXGASSERT(pMgmtInfo->m_rmHeapIndex == 0);
            if (!m_heap_p[pMgmtInfo->m_rmHeap].add(pMgmtInfo))
            {
                ddrval = E_OUTOFMEMORY;
                goto exit2;
            }
        }
        else if (ddrval == D3DERR_OUTOFVIDEOMEMORY) // If out of video memory
        {
            if (!FreeResources(pMgmtInfo->m_rmHeap, bytecount))
            {
                DPF_ERR("all Freed no further video memory available");
                ddrval = D3DERR_OUTOFVIDEOMEMORY;        //nothing left
                goto exit1;
            }
            bytecount <<= 1;
        }
        else
        {
            D3DRESOURCETYPE Type = pMgmtInfo->m_pBackup->GetBufferDesc()->Type;
            if (Type == D3DRTYPE_VERTEXBUFFER ||
                Type == D3DRTYPE_INDEXBUFFER)
            {
                if (lpDevI->VBFailOversDisabled())
                {
                    DPF_ERR("Cannot create Vidmem or Driver managed VB/IB. Will ***NOT*** failover to Sysmem.");
                    goto exit1;
                }
                // Fallback to sysmem
                DPF(5, "Driver does not support vidmem VB, falling back to sysmem");
                CResource *pRes = pMgmtInfo->m_pBackup;
                pRes->DeleteRMHandle();
                // HACK HACK HACK
                ((D3DBUFFER_DESC*)pRes->GetBufferDesc())->Pool = D3DPOOL_SYSTEMMEM;
                ddrval = S_OK;
            }
            else
            {
                DPF(0, "Unexpected error in Clone %08x", ddrval);
            }
            goto exit1;
        }
    }
    while (ddrval == D3DERR_OUTOFVIDEOMEMORY);

    if (trycount > 1)
    {
        lpDevI->NeedResourceStateUpdate();
        DPF(1, "Allocated texture after %u tries.", trycount);
    }
    pMgmtInfo->m_pBackup->MarkAllDirty();
    ddrval = pMgmtInfo->m_pBackup->UpdateDirtyPortion(pMgmtInfo->m_pRes);
    if (FAILED(ddrval))
    {
        DPF(0, "Unexpected error in UpdateDirtyPortion %08x", ddrval);
        goto exit3;
    }
    ddrval = S_OK;
    goto exit1;
exit3:
    m_heap_p[pMgmtInfo->m_rmHeap].del(pMgmtInfo);
exit2:
    pMgmtInfo->m_pRes->DecrementUseCount();
    pMgmtInfo->m_pRes = 0;
exit1:
    for (dwStage = 0; dwStage < lpDevI->m_dwMaxTextureBlendStages; ++dwStage)
    {
        if (lpDevI->m_lpD3DMappedTexI[dwStage])
        {
            Unlock(lpDevI->m_lpD3DMappedTexI[dwStage]->RMHandle());
        }
    }
    for (dwStream = 0; dwStream < lpDevI->m_dwNumStreams; ++dwStream)
    {
        if (lpDevI->m_pStream[dwStream].m_pVB != 0)
        {
            Unlock(lpDevI->m_pStream[dwStream].m_pVB->RMHandle());
        }
    }
    if (lpDevI->m_pIndexStream->m_pVBI != 0)
    {
        Unlock(lpDevI->m_pIndexStream->m_pVBI->RMHandle());
    }
    return ddrval;
} // CResourceManager::UpdateVideo

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::OnResourceDirty"

void CResourceManager::OnResourceDirty(RMHANDLE hRMHandle) const
{
    static_cast<LPD3DBASE>(m_pD3D8)->NeedResourceStateUpdate();
} // CResourceManager::OnResourceDirty

// End of file : resource.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\swapchan.cpp ===
//=============================================================================
// Copyright (c) 1999 Microsoft Corporation
//
// swapchan.cpp
//
// Direct3D swap chain implementation.
//
// Created 11/16/1999 johnstep (John Stephens)
//=============================================================================

#include "ddrawpr.h"
#include "swapchan.hpp"
#include "pixel.hpp"

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::QueryInterface"

//=============================================================================
// IUnknown::QueryInterface (public)
//
// Created 11/16/1999 johnstep
//=============================================================================

STDMETHODIMP
CSwapChain::QueryInterface(
    REFIID riid,
    void **ppInterface
  )
{
    API_ENTER(Device());

    if (!VALID_PTR_PTR(ppInterface))
    {
        DPF_ERR("Invalid ppvObj parameter passed to QueryInterface for a SwapChain");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_PTR(&riid, sizeof(GUID)))
    {
        DPF_ERR("Invalid guid memory address to QueryInterface for a SwapChain");
        return D3DERR_INVALIDCALL;
    }

    if ((riid == IID_IDirect3DSwapChain8) || (riid == IID_IUnknown))
    {
        AddRef();
        *ppInterface =
            static_cast<void *>(
                static_cast<IDirect3DSwapChain8 *>(this));
        return S_OK;
    }

    DPF_ERR("Unsupported Interface identifier passed to QueryInterface for a SwapChain");

    // Null out param
    *ppInterface = NULL;
    return E_NOINTERFACE;
} // QueryInterface

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::AddRef"

//=============================================================================
// IUnknown::AddRef (public)
//
// Created 11/16/1999 johnstep
//=============================================================================

STDMETHODIMP_(ULONG)
CSwapChain::AddRef()
{
    API_ENTER_NO_LOCK(Device());   
    
    return AddRefImpl();
} // AddRef

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::Release"

//=============================================================================
// IUnknown::Release (public)
//
// Created 11/16/1999 johnstep
//=============================================================================

STDMETHODIMP_(ULONG)
CSwapChain::Release()
{
    API_ENTER_SUBOBJECT_RELEASE(Device());   
    
    return ReleaseImpl();
} // Release

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::CSwapChain"

//=============================================================================
// CSwapChain::CSwapChain
//
// Created 11/16/1999 johnstep
//=============================================================================

CSwapChain::CSwapChain(
    CBaseDevice         *pDevice,
    REF_TYPE            refType) :
        CBaseObject(pDevice, refType),
        m_pCursor(NULL),
        m_hGDISurface(NULL),
        m_pMirrorSurface(NULL),
        m_pPrimarySurface(NULL),
        m_ppBackBuffers(NULL),
        m_presentnext(0),
        m_cBackBuffers(0),
        m_bExclusiveMode(FALSE),
        m_pCursorShadow(NULL),
        m_pHotTracking(NULL),
        m_lIMEState(0),
        m_lSetIME(0),
        m_dwFlags(0),
        m_dwFlipCnt(0),
        m_dwFlipTime(0xffffffff),
        m_uiErrorMode(0)
{
    HKEY hKey;
    ZeroMemory(&m_BltData, sizeof m_BltData);
    m_BltData.hDD = Device()->GetHandle();
    m_BltData.bltFX.dwROP = SRCCOPY;
    m_BltData.ddRVal = E_FAIL;

    if (!RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey))
    {
        DWORD   type;
        DWORD   value;
        DWORD   cb = sizeof(value);

        if (!RegQueryValueEx(hKey, REGSTR_VAL_DDRAW_SHOWFRAMERATE, NULL, &type, (CONST LPBYTE)&value, &cb))
        {
	    DPF( 2, REGSTR_VAL_DDRAW_SHOWFRAMERATE" : %d", value );
            if (value)
            {
                m_dwFlags |= D3D_REGFLAGS_SHOWFRAMERATE;
            }
        }
#ifdef  WINNT
        cb = sizeof(value);
        if (!RegQueryValueEx(hKey, REGSTR_VAL_D3D_FLIPNOVSYNC, NULL, &type, (CONST LPBYTE)&value, &cb))
        {
	    DPF( 2, REGSTR_VAL_D3D_FLIPNOVSYNC" : %d", value );
            if (value)
            {
                m_dwFlags |= D3D_REGFLAGS_FLIPNOVSYNC;
            }
        }
        RegCloseKey(hKey);
    }
    m_dwForceRefreshRate = 0;
    if( !RegOpenKey( HKEY_LOCAL_MACHINE, REGSTR_PATH_DDRAW, &hKey ) )
    {
        DWORD   type;
        DWORD   value;
        DWORD   cb = sizeof(value);

	if( !RegQueryValueEx( hKey, REGSTR_VAL_DDRAW_FORCEREFRESHRATE, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	{
            m_dwForceRefreshRate = value;
	}
#endif
        RegCloseKey(hKey);
    }
}

void CSwapChain::Init(
    D3DPRESENT_PARAMETERS* pPresentationParams,
    HRESULT             *pHr
  )
{
    DXGASSERT(pHr != NULL);

    //the gamma ramp is initialized to 1:1
    for (int i=0;i<256;i++)
    {
        m_DesiredGammaRamp.red[i] =
        m_DesiredGammaRamp.green[i] =
        m_DesiredGammaRamp.blue[i] = static_cast<WORD>(i);
    }

    *pHr = Reset(
        pPresentationParams);

    return;
} // CSwapChain::CSwapChain

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::~CSwapChain"

//=============================================================================
// CSwapChain::~CSwapChain
//
// Created 11/16/1999 johnstep
//=============================================================================

CSwapChain::~CSwapChain()
{
    if (!m_PresentationData.Windowed)
    {
        m_PresentationData.Windowed = TRUE;
        // make sure we restore after a fullscreen
        SetCooperativeLevel();
    }
    Destroy();
} // CSwapChain::~CSwapChain

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::CreateWindowed"

//=============================================================================
// CSwapChain::CreateWindowed
//
// Created 11/16/1999 johnstep
//=============================================================================

HRESULT
CSwapChain::CreateWindowed(
    UINT width,
    UINT height,
    D3DFORMAT backBufferFormat,
    UINT cBackBuffers,
    D3DMULTISAMPLE_TYPE MultiSampleType,
    BOOL bDiscard,
    BOOL bLockable
  )
{
    // For the windowed case, we will currently create exactly 3 surfaces
    // in this order:
    //
    //   1. Primary Surface
    //   2. Back Buffer
    //   3. Z Buffer (by notifying the device)
    //
    // For now, all 3 surfaces must reside in local video memory. Later,
    // we may allow multiple back buffers, if there is interest, to allow
    // simulated fullscreen-style double buffering (alternate back buffer
    // surfaces after presenting).
    //
    // !!! The primary surface is actually optional because we can just use
    // DdGetDC and then GDI BitBlt. But, presumably, there are performance
    // advantages to using DirectDraw Blt. Of course, the problem with using
    // DirectDraw Blts is keeping in sync with the window manager (so we
    // don't write outside of the window, etc.). GDI BitBlt will also handle
    // format conversion for us, though slowly.

    DXGASSERT(m_pPrimarySurface == NULL);
    DXGASSERT(m_ppBackBuffers == NULL);
    DXGASSERT(m_cBackBuffers == 0);

    HRESULT hr;
    if (D3DSWAPEFFECT_FLIP == m_PresentationData.SwapEffect)
    {
        cBackBuffers = m_PresentationData.BackBufferCount + 1;
    }

    // 1. Create a simple primary surface. If we already have a primary
    //    surface, then don't bother to create a new one.
    if (this == Device()->SwapChain())
    {
        DWORD   dwUsage = D3DUSAGE_PRIMARYSURFACE | D3DUSAGE_LOCK;
        DWORD   Width = Device()->DisplayWidth();
        DWORD   Height = Device()->DisplayHeight();

        // D3DSWAPEFFECT_NO_PRESENT is a hack to allow our D3D test framework
        // to create a windowed REF device after they have created a fullscreen
        // HAL device.  We cannot create a second primary surface for the windowed
        // device, but we cannot leave m_pPrimarySurface equal to NULL (becaue then
        // we cannot cleanup the swap chain and Reset will fail), so instead we
        // create a dummy surface and call it the primary, with the understanding
        // that this device will never call Present or use the primary surface in
        // any way.  We also don't have to do much checking since this is not an
        // external feature.
        if (D3DSWAPEFFECT_NO_PRESENT == m_PresentationData.SwapEffect)
        {
            dwUsage = D3DUSAGE_OFFSCREENPLAIN | D3DUSAGE_LOCK;
            Width = 256;
            Height = 256;
        }

        m_pPrimarySurface = new CDriverSurface(
                Device(),
                Width,
                Height,
                dwUsage,
                Device()->DisplayFormat(),      // UserFormat
                Device()->DisplayFormat(),      // RealFormat
                D3DMULTISAMPLE_NONE,//of course, when windowed
                0,                          // hKernelHandle
                REF_INTERNAL,
                &hr);
    }
    else
    {
        // Additional SwapChain, it's already there
        m_pPrimarySurface = Device()->SwapChain()->PrimarySurface();
        hr = DD_OK;
    }

    // 2. Create the back buffer.

    if (m_pPrimarySurface == NULL)
    {
        return E_OUTOFMEMORY;
    }

    m_PresentUseBlt = TRUE;
    if (SUCCEEDED(hr))
    {
        if (m_ppBackBuffers = new CDriverSurface *[cBackBuffers])
        {
            DWORD Usage = D3DUSAGE_BACKBUFFER | D3DUSAGE_RENDERTARGET;
            if ((D3DMULTISAMPLE_NONE == m_PresentationData.MultiSampleType) &&
                bLockable)
            {
                Usage |= D3DUSAGE_LOCK;
            }
            if (bDiscard)
            {
                Usage |= D3DUSAGE_DISCARD;
            }

            for (; m_cBackBuffers < cBackBuffers; ++m_cBackBuffers)
            {
                m_ppBackBuffers[m_cBackBuffers] = new CDriverSurface(
                    Device(),
                    width,
                    height,
                    Usage,
                    backBufferFormat,             // UserFormat
                    backBufferFormat,           // RealFormat
                    MultiSampleType,
                    0,                          // hKernelHandle
                    REF_INTRINSIC,
                    &hr);
                if (m_ppBackBuffers[m_cBackBuffers] == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }

                if (FAILED(hr))
                {
                    m_ppBackBuffers[m_cBackBuffers]->DecrementUseCount();
                    m_ppBackBuffers[m_cBackBuffers] = NULL;
                    break;
                }
            }

            if (m_cBackBuffers == cBackBuffers)
            {
                m_BltData.hDestSurface = m_pPrimarySurface->KernelHandle();
                m_BltData.dwFlags = DDBLT_WINDOWCLIP | DDBLT_ROP | DDBLT_WAIT | DDBLT_DX8ORHIGHER;

                if (Device()->GetD3DCaps()->MaxStreams != 0)
                {
                    m_BltData.dwFlags |= DDBLT_PRESENTATION;
                }

                if (D3DSWAPEFFECT_COPY_VSYNC == m_PresentationData.SwapEffect)
                {
                    m_BltData.dwFlags |= DDBLT_COPYVSYNC;                    

                    // Need to let thunk layer know current refresh rate
                    if (Device()->DisplayRate() < 60)
                    {
                        // 60Hz = 16.666ms per frame
                        // 75Hz = 13.333ms
                        // 85Hz = 11.765ms
                        m_BltData.threshold = 13;
                    }
                    else
                    {
                        m_BltData.threshold = (DWORD)(1000.0f / (float)Device()->DisplayRate()); 
                    }

                }
                m_ClientWidth = 0;  // windowed client is updated in present
                m_ClientHeight = 0;
                return hr;
            }

            // Something went wrong, so clean up now.

            // 2. Destroy Back Buffers, if any.

            while (m_cBackBuffers > 0)
            {
                m_ppBackBuffers[--m_cBackBuffers]->DecrementUseCount();
            }
            delete [] m_ppBackBuffers;
            m_ppBackBuffers = NULL;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // 1. Destroy Primary Surface.

    if (this == Device()->SwapChain())
        m_pPrimarySurface->DecrementUseCount();
    m_pPrimarySurface = NULL;
    return hr;
} // CreateWindowed

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::CreateFullScreen"

//=============================================================================
// CSwapChain::CreateFullscreen
//
// Created 11/16/1999 johnstep
//=============================================================================

HRESULT
CSwapChain::CreateFullscreen(
    UINT width,
    UINT height,
    D3DFORMAT backBufferFormat,
    UINT cBackBuffers,
    UINT PresentationRate,
    D3DMULTISAMPLE_TYPE MultiSampleType,
    BOOL bDiscard,
    BOOL bLockable
  )
{
    HRESULT hr = E_FAIL;
    DWORD i;
    BOOL    bMirrorBufferCreated, bNoDDrawSupport;
    UINT    Usage = 0;

    if (bLockable)
    {
        Usage |= D3DUSAGE_LOCK;
    }
    if (bDiscard)
    {
        Usage |= D3DUSAGE_DISCARD;
    }

    // If it's a hardware device, we want to create a primary surface and a
    // number of backbuffers.  We need to make this a single driver call,
    // however, in order for everything to get attached correctly.  Therefore,
    // what we do is call the DDI to create the primary chain, and it will
    // return the handles for each surface in the chain.  After that, we
    // will individually create each swap chain buffer, but we will supply
    // it with the required handles rather than having it call the DDI itself.

    // First, call the DDI to allocate the memory and the kernel handles
    DDSURFACEINFO SurfInfoArray[D3DPRESENT_BACK_BUFFERS_MAX + 2];
    ZeroMemory(SurfInfoArray, sizeof(SurfInfoArray));
    
    D3D8_CREATESURFACEDATA CreateSurfaceData;
    ZeroMemory(&CreateSurfaceData, sizeof(CreateSurfaceData));

    DXGASSERT(cBackBuffers  <= D3DPRESENT_BACK_BUFFERS_MAX);
    for (i = 0; i < cBackBuffers + 1; i++)
    {
        SurfInfoArray[i].cpWidth = width;
        SurfInfoArray[i].cpHeight = height;
    }

    CreateSurfaceData.hDD      = Device()->GetHandle();
    CreateSurfaceData.pSList   = &SurfInfoArray[0];
    bNoDDrawSupport = Device()->Enum()->NoDDrawSupport(Device()->AdapterIndex());

    if (D3DDEVTYPE_HAL == Device()->GetDeviceType() &&
        m_PresentationData.SwapEffect == D3DSWAPEFFECT_FLIP)
    {
        m_PresentUseBlt = FALSE;
        bMirrorBufferCreated = FALSE;
        CreateSurfaceData.dwSCnt   = cBackBuffers + 1;
        CreateSurfaceData.MultiSampleType = MultiSampleType;
    }
    else if ((m_PresentationData.SwapEffect == D3DSWAPEFFECT_COPY &&
             m_PresentationData.FullScreen_PresentationInterval == 
                D3DPRESENT_INTERVAL_IMMEDIATE) || bNoDDrawSupport 
            )
    {
        // If we're doing a copy-swap-effect and the app
        // specifies interval-immediate, then we can blt directly
        // to the primary without a mirror.
        DXGASSERT(MultiSampleType == D3DMULTISAMPLE_NONE);
        m_PresentUseBlt = TRUE;
        bMirrorBufferCreated = FALSE;
        CreateSurfaceData.dwSCnt   = 1;
        CreateSurfaceData.MultiSampleType = D3DMULTISAMPLE_NONE;
    }
    else
    {
        //one for m_pPrimarySurface and one for m_pMirrorSurface
        m_PresentUseBlt = TRUE;
        bMirrorBufferCreated = TRUE;
        CreateSurfaceData.dwSCnt   = 2;
        CreateSurfaceData.MultiSampleType = D3DMULTISAMPLE_NONE;
    }
    CreateSurfaceData.Type     = D3DRTYPE_SURFACE;
    CreateSurfaceData.Pool     = D3DPOOL_LOCALVIDMEM;
    CreateSurfaceData.dwUsage  = D3DUSAGE_PRIMARYSURFACE | Usage;
    CreateSurfaceData.Format   = Device()->DisplayFormat();

    if(Device()->DisplayFormat() != backBufferFormat)
    {
        CreateSurfaceData.dwUsage  |= D3DUSAGE_ALPHACHANNEL;
    }
        
    if (!bNoDDrawSupport)
    {
        hr = Device()->GetHalCallbacks()->CreateSurface(&CreateSurfaceData);
        if (FAILED(hr))
        {
            if (D3DDEVTYPE_HAL == Device()->GetDeviceType())
            {
                DPF_ERR("Failed to create driver primary surface chain");
                return hr;
            }
            else
            {
                // assume CreateSurfaceData is still intact
                bMirrorBufferCreated = FALSE;
                CreateSurfaceData.dwSCnt = 1;
                hr = Device()->GetHalCallbacks()->CreateSurface(&CreateSurfaceData);
                if (FAILED(hr))
                {
                    DPF_ERR("Failed to create driver primary surface");
                    return hr;
                }
            }
        }
    }
    // Now that we have the handles, create the surface interfaces
    // one by one

    // When creating passing in kernel handles to a driver
    // surface, the surface will assume that it was created in
    // LocalVidMem. We assert this here..
    DXGASSERT(CreateSurfaceData.Pool == D3DPOOL_LOCALVIDMEM);

    m_pPrimarySurface = new CDriverSurface(
        Device(),
        width,
        height,
        CreateSurfaceData.dwUsage | D3DUSAGE_LOCK,
        // there is a problem with thunklayer when NoDDrawSupport
        // DriverData.DisplayWidth and DriverData.DisplayHeight
        // DriverData.DisplayFormat are not getting updated
        // so we use backBufferFormat until Device()->DisplayFormat() 
        bNoDDrawSupport ? backBufferFormat : Device()->DisplayFormat(), // UserFormat
        bNoDDrawSupport ? backBufferFormat : Device()->DisplayFormat(), // RealFormat
        CreateSurfaceData.MultiSampleType,
        SurfInfoArray[0].hKernelHandle,
        REF_INTERNAL,
        &hr);

    if (m_pPrimarySurface == NULL)
    {
        // We'll clean up the kernel handle(s) at the
        // end of the function
        hr = E_OUTOFMEMORY;
    }
    else
    {
        // Zero out the kernel-handle so that
        // we don't clean it at exit. If the CDriverSurface
        // function fails; it will still release the kernel
        // handle in its destructor.
        SurfInfoArray[0].hKernelHandle = 0;
    }

    if (SUCCEEDED(hr))
    {

        m_hGDISurface = m_pPrimarySurface->KernelHandle();
        if (bMirrorBufferCreated)
        {
            // Mirror surfaces are only useful if we're going
            // to do a Blt as part of the Present. (We might
            // also do a flip in addition.)
            DXGASSERT(m_PresentUseBlt);

            // When creating passing in kernel handles to a driver
            // surface, the surface will assume that it was created in
            // LocalVidMem. We assert this here..
            DXGASSERT(CreateSurfaceData.Pool == D3DPOOL_LOCALVIDMEM);

            m_pMirrorSurface = new CDriverSurface(
                Device(),
                width,
                height,
                D3DUSAGE_BACKBUFFER,
                Device()->DisplayFormat(),  // UserFormat
                Device()->DisplayFormat(),  // RealFormat
                D3DMULTISAMPLE_NONE,
                SurfInfoArray[1].hKernelHandle,
                REF_INTERNAL,
                &hr);

            if (NULL == m_pMirrorSurface)
            {
                //if out of memory, then destroy the driver object as well
                D3D8_DESTROYSURFACEDATA DestroySurfData;
                DestroySurfData.hDD = Device()->GetHandle();
                DestroySurfData.hSurface = SurfInfoArray[1].hKernelHandle;
                Device()->GetHalCallbacks()->DestroySurface(&DestroySurfData);
                bMirrorBufferCreated = FALSE;
                hr = S_OK;  //but don't fail as m_pMirrorSurface is optional
            }
            else if (FAILED(hr))
            {   
                // Release the surface
                m_pMirrorSurface->DecrementUseCount();
                m_pMirrorSurface = NULL;

                bMirrorBufferCreated = FALSE;
                hr = S_OK;  //but don't fail as m_pMirrorSurface is optional
            }
            else
            {
                //blt from m_ppBackBuffers[m_presentnext] to m_pMirrorSurface
                //then flip from m_pPrimarySurface to m_pMirrorSurface
                m_BltData.hDestSurface =
                    m_pMirrorSurface->KernelHandle();
            }
            
            // In all cases, zero out the kernel handle
            // since it has either been owned by something or freed by now
            SurfInfoArray[1].hKernelHandle = 0;
        }
        if (m_PresentUseBlt)
        {
            if (!bMirrorBufferCreated)
            {
                // If we're blitting and there is no
                // mirror surface; then the primary must be
                // the destination
                DXGASSERT(m_BltData.hDestSurface == NULL);
                m_BltData.hDestSurface = m_pPrimarySurface->KernelHandle();
            }
            if (D3DSWAPEFFECT_FLIP == m_PresentationData.SwapEffect)
            {
                // To emualte flip for SW drivers, create an extra backbuffer
                cBackBuffers = m_PresentationData.BackBufferCount + 1;
            }

            ZeroMemory(SurfInfoArray, sizeof(SurfInfoArray));
            for (i = 1; i < cBackBuffers + 1; i++)
            {
                SurfInfoArray[i].cpWidth = width;
                SurfInfoArray[i].cpHeight = height;
            }

            ZeroMemory(&CreateSurfaceData, sizeof(CreateSurfaceData));
            CreateSurfaceData.hDD      = Device()->GetHandle();
            CreateSurfaceData.pSList   = &SurfInfoArray[1];
            CreateSurfaceData.dwSCnt   = cBackBuffers;
            CreateSurfaceData.Type     = D3DRTYPE_SURFACE;
            CreateSurfaceData.Pool     = D3DPOOL_DEFAULT;
            CreateSurfaceData.dwUsage  = D3DUSAGE_BACKBUFFER | D3DUSAGE_RENDERTARGET;
            CreateSurfaceData.Format   = backBufferFormat;
            CreateSurfaceData.MultiSampleType = MultiSampleType;
            hr = Device()->GetHalCallbacks()->CreateSurface(&CreateSurfaceData);
        }
    }
    if (SUCCEEDED(hr))
    {
        if (m_ppBackBuffers = new CDriverSurface *[cBackBuffers])
        {
            DWORD Usage = D3DUSAGE_BACKBUFFER | D3DUSAGE_RENDERTARGET;
            if ((D3DMULTISAMPLE_NONE == m_PresentationData.MultiSampleType) &&
                bLockable)
            {
                Usage |= D3DUSAGE_LOCK;
            }

            for (; m_cBackBuffers < cBackBuffers; ++m_cBackBuffers)
            {

                m_ppBackBuffers[m_cBackBuffers] = new CDriverSurface(
                    Device(),
                    width,
                    height,
                    Usage,
                    backBufferFormat,
                    backBufferFormat,
                    MultiSampleType,
                    SurfInfoArray[m_cBackBuffers + 1].hKernelHandle,
                    REF_INTRINSIC,
                    &hr);

                if (m_ppBackBuffers[m_cBackBuffers] == NULL)
                {
                    // We'll clean up the kernel handle at the ned
                    // of the function
                    hr = E_OUTOFMEMORY;
                    break;
                }
                else
                {
                    // Zero out the kernel-handle so that
                    // we don't clean it at exit. (Even in failure,
                    // the m_ppBackBuffers[m_cBackBuffers] object
                    // will free the kernel handle now
                    SurfInfoArray[m_cBackBuffers + 1].hKernelHandle = 0;
                }


                if (FAILED(hr))
                {
                    m_ppBackBuffers[m_cBackBuffers]->DecrementUseCount();
                    m_ppBackBuffers[m_cBackBuffers] = NULL;
                    break;
                }
            }

            if (m_cBackBuffers != cBackBuffers)
            {
                // Something went wrong, so clean up now.

                // 2. Destroy Back Buffers, if any.

                while (m_cBackBuffers > 0)
                {
                    m_ppBackBuffers[--m_cBackBuffers]->DecrementUseCount();
                }
                delete [] m_ppBackBuffers;
                m_ppBackBuffers = NULL;
            }
            else
            {
                const D3D8_DRIVERCAPS* pDriverCaps = Device()->GetCoreCaps();
                m_dwFlipFlags = DDFLIP_WAIT;
                if ((D3DPRESENT_INTERVAL_IMMEDIATE == m_PresentationData.FullScreen_PresentationInterval)
#ifdef  WINNT
                    || (D3D_REGFLAGS_FLIPNOVSYNC & m_dwFlags)
#endif
                    )
                {
                    if (DDCAPS2_FLIPNOVSYNC & pDriverCaps->D3DCaps.Caps2)
                    {
                        m_dwFlipFlags   |= DDFLIP_NOVSYNC;
                    }
                }
                else if (DDCAPS2_FLIPINTERVAL & pDriverCaps->D3DCaps.Caps2)
                {
                    switch(m_PresentationData.FullScreen_PresentationInterval)
                    {
                    case D3DPRESENT_INTERVAL_DEFAULT:
                    case D3DPRESENT_INTERVAL_ONE:
                        m_dwFlipFlags   |= DDFLIP_INTERVAL1;
                        break;
                    case D3DPRESENT_INTERVAL_TWO:
                        m_dwFlipFlags   |= DDFLIP_INTERVAL2;
                        break;
                    case D3DPRESENT_INTERVAL_THREE:
                        m_dwFlipFlags   |= DDFLIP_INTERVAL3;
                        break;
                    case D3DPRESENT_INTERVAL_FOUR:
                        m_dwFlipFlags   |= DDFLIP_INTERVAL4;
                        break;
                    }
                }
                m_BltData.hWnd = m_PresentationData.hDeviceWindow;
                m_BltData.dwFlags = DDBLT_ROP | DDBLT_WAIT;
                m_ClientWidth = width;
                m_ClientHeight = height;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // Error handling cleanup
    if (FAILED(hr))
    {
        // We may need to free surface handles that
        // were not owned by any CDriverSurface that
        // we failed to properly create

        D3D8_DESTROYSURFACEDATA DestroyData;
        ZeroMemory(&DestroyData, sizeof DestroyData);
        DestroyData.hDD = Device()->GetHandle();

        for (UINT i = 0; i < CreateSurfaceData.dwSCnt; i++)
        {
            if (CreateSurfaceData.pSList[i].hKernelHandle)
            {
                DestroyData.hSurface = CreateSurfaceData.pSList[i].hKernelHandle;
                Device()->GetHalCallbacks()->DestroySurface(&DestroyData);        
            }
        }
    }

    return hr;
} // CreateFullScreen

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::Destroy"

//=============================================================================
// CSwapChain::Destroy
//
// Created 11/16/1999 johnstep
//=============================================================================

VOID
CSwapChain::Destroy()
{
    // Destroy surfaces in reverse create order.
    if (m_pCursor)
    {
        delete m_pCursor;
        m_pCursor = NULL;
    }
    // 2. Destroy Back Buffers
    //
    // If the previous mode was windowed, we should have exactly 1
    // back buffer to destroy. Otherwise, there could be more than
    // one, and plus we may need some sort of atomic destruction.
    if (m_ppBackBuffers)
    {
        while (m_cBackBuffers > 0)
        {
            m_ppBackBuffers[--m_cBackBuffers]->DecrementUseCount();
        }
        delete [] m_ppBackBuffers;
        m_ppBackBuffers = NULL;
    }

    // 1. Destroy Mirror Surface
    if (m_pMirrorSurface)
    {
        m_pMirrorSurface->DecrementUseCount();
        m_pMirrorSurface = NULL;
    }
    // 1. Destroy Primary Surface
    if (m_pPrimarySurface)
    {
        if (this == Device()->SwapChain())
            m_pPrimarySurface->DecrementUseCount();
        m_pPrimarySurface = NULL;
        m_hGDISurface = NULL;
    }
    m_presentnext = 0;
} // Destroy

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::GetBackBuffer"

//=============================================================================
// IDirect3DSwapChain8::GetBackBuffer (public)
//
// Created 11/16/1999 johnstep
//=============================================================================

STDMETHODIMP
CSwapChain::GetBackBuffer(
    UINT                iBackBuffer,
    D3DBACKBUFFER_TYPE  Type,
    IDirect3DSurface8 **ppBackBuffer
  )
{
    API_ENTER(Device());

    if (ppBackBuffer == NULL)
    {
        DPF_ERR("Invalid ppBackbuffer parameter passed to GetBackBuffer");
        return D3DERR_INVALIDCALL;
    }

    // We can't just assert we have a valid back buffer array because a
    // Reset may have failed, which puts the device in a disabled state
    // until Reset is called again. Once we have a `disabled' flag, we
    // can check that instead of m_ppBackBuffers.

    if (m_ppBackBuffers == NULL)
    {
        DPF_ERR("GetBackBuffer failed due to Device being lost");
        return D3DERR_INVALIDCALL;
    }

    // in case of windowed D3DSWAPEFFECT_FLIP, m_cBackBuffers
    // == m_PresentationData.BackBufferCount + 1 as we allocate
    // that extra buffer for user without its knowledge
    if (iBackBuffer >= m_PresentationData.BackBufferCount)
    {
        DPF_ERR("Invalid iBackBuffer parameter passed to GetBackBuffer");
        return D3DERR_INVALIDCALL;
    }

    *ppBackBuffer = BackBuffer(iBackBuffer);

    DXGASSERT(*ppBackBuffer != NULL);
    if (*ppBackBuffer)
    {
        (*ppBackBuffer)->AddRef();
        return S_OK;
    }
    else
    {
        DPF(2, "Swapchain doesn't have a BackBuffer[%d]",iBackBuffer);
        return D3DERR_NOTFOUND;
    }
} // GetBackBuffer

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::Reset"

//=============================================================================
// IDirect3DSwapChain8::Reset (public)
//
// Resizes the device. If this results in a display mode change, then all
// existing surfaces will be lost.
//
// Arguments:
//   width
//   height
//   pcBackBuffers (in/out) !!! Currently an (in) but will be fixed later.
//   backBufferFormat
//   fullscreen
//   pOptionalParams
// Created 11/16/1999 johnstep
//=============================================================================

HRESULT 
CSwapChain::Reset(
    D3DPRESENT_PARAMETERS *pPresentationParameters
  )
{

    BOOL bDeviceLost = FALSE;
    HRESULT hr;

    // Validate First before changing state
    switch (pPresentationParameters->SwapEffect)
    {
    case D3DSWAPEFFECT_DISCARD:
    case D3DSWAPEFFECT_COPY:
    case D3DSWAPEFFECT_COPY_VSYNC:
    case D3DSWAPEFFECT_FLIP:
    case D3DSWAPEFFECT_NO_PRESENT:
        break;
    default:
        DPF_ERR("Invalid parameter for SwapEffect for D3DPRESENT_PARAMETERS. "
                "Must be one of D3DSWAPEFFECTS_COPY, D3DSWAPEFFECTS_COPY_VSYNC, "
                "D3DSWAPEFFECTS_DISCARD, or D3DSWAPEFFECTS_FLIP. CreateDevice/Reset Fails.");
        return D3DERR_INVALIDCALL;
    }

    if (pPresentationParameters->BackBufferCount)
    {
        if ((D3DSWAPEFFECT_COPY == pPresentationParameters->SwapEffect ||
            D3DSWAPEFFECT_COPY_VSYNC == pPresentationParameters->SwapEffect)
            && (pPresentationParameters->BackBufferCount > 1))
        {
            DPF_ERR("BackBufferCount must be 1 if SwapEffect is COPY/VSYNC. CreateDevice/Reset Fails.");
            pPresentationParameters->BackBufferCount = 1;
            return D3DERR_INVALIDCALL;
        }
        if (pPresentationParameters->BackBufferCount >
            D3DPRESENT_BACK_BUFFERS_MAX)
        {
            DPF_ERR("BackBufferCount must be less "
                "than D3DPRESENT_BACK_BUFFERS_MAX. CreateDevice/Reset Fails.");
            pPresentationParameters->BackBufferCount =
                D3DPRESENT_BACK_BUFFERS_MAX;

            return D3DERR_INVALIDCALL;
        }
    }
    else
    {
        pPresentationParameters->BackBufferCount = 1;
        DPF(4, "BackBufferCount not specified, considered default 1 ");
    }

    if (D3DSWAPEFFECT_DISCARD != pPresentationParameters->SwapEffect)
    {
        if (pPresentationParameters->MultiSampleType != D3DMULTISAMPLE_NONE)
        {
            DPF_ERR("Multisampling requires D3DSWAPEFFECT_DISCARD. CreateDevice/Reset Fails.");
            return D3DERR_INVALIDCALL;
        }
    }

    // D3DSWAPEFFECT_NO_PRESENT is a hack that only works for windowed mode
    if (D3DSWAPEFFECT_NO_PRESENT == pPresentationParameters->SwapEffect)
    {
        if (!pPresentationParameters->Windowed)
        {
            DPF_ERR("D3DSWAPEFFECT_NO_PRESENT only works when the device is windowed. CreateDevice/Reset Fails.");
            return D3DERR_INVALIDCALL;
        }
    }

    memcpy(&m_PresentationData,
        pPresentationParameters,sizeof m_PresentationData);

    // Remember the original swapeffect
    m_UserSwapEffect = pPresentationParameters->SwapEffect;

    // Convert discard to flip or copy based on stuff
    if (D3DSWAPEFFECT_DISCARD == pPresentationParameters->SwapEffect)
    {
        if (pPresentationParameters->Windowed &&
            pPresentationParameters->BackBufferCount == 1)
        {
            m_PresentationData.SwapEffect = D3DSWAPEFFECT_COPY;
        }
        else
        {
            m_PresentationData.SwapEffect = D3DSWAPEFFECT_FLIP;
        }
    }

    if (NULL == m_PresentationData.hDeviceWindow)
    {
        m_PresentationData.hDeviceWindow= Device()->FocusWindow();
    }

    DXGASSERT( NULL != m_PresentationData.hDeviceWindow);

#ifdef WINNT
    // On NT, SetCooperativeLevel will fail if another device has exclusive
    // mode, so we cannot call it.  On Win9X, it will not fail, but CreateSurface
    // WILL fail if we don't first call it, so we need to special case this call.
    if (m_UserSwapEffect != D3DSWAPEFFECT_NO_PRESENT)
    {
#endif
        hr = SetCooperativeLevel();
        if (FAILED(hr))
        {
            DPF_ERR("SetCooperativeLevel returned failure. CreateDevice/Reset Failed");
            return hr;
        }
#ifdef WINNT
    }
#endif
    // See if the device is lost

    if (D3D8IsDeviceLost(Device()->GetHandle()))
    {
        bDeviceLost = TRUE;
        FetchDirectDrawData(Device()->GetDeviceData(),  
            Device()->GetInitFunction(),
            Device()->Enum()->GetUnknown16(Device()->AdapterIndex()),
            Device()->Enum()->GetHalOpList(Device()->AdapterIndex()),
            Device()->Enum()->GetNumHalOps(Device()->AdapterIndex()));
    }

    // Map the unknown format to a real one. If they will take any format
    // (i.e. the specified UNKNOWN), then we will try to give them the one
    // that matches the display format.

    if (m_PresentationData.Windowed)
    {
        // If we are windowed, we need to use the current display mode.  We may be
        // able to relax this for new drivers.

        if (D3DFMT_UNKNOWN == m_PresentationData.BackBufferFormat)
        {
            m_PresentationData.BackBufferFormat = Device()->DisplayFormat();
        }
        
        if (CPixel::SuppressAlphaChannel(m_PresentationData.BackBufferFormat)
            != Device()->DisplayFormat())
        {
            DPF_ERR("Windowed BackBuffer Format must be compatible with Desktop Format. CreateDevice/Reset fails.");
            return D3DERR_INVALIDCALL;            
        }
    }

    if (m_PresentationData.Windowed)
    {
        if ((m_PresentationData.BackBufferWidth < 1) ||
            (m_PresentationData.BackBufferHeight < 1))
        {
            RECT rc;
            if (GetClientRect(m_PresentationData.hDeviceWindow, &rc))
            {
                if (m_PresentationData.BackBufferWidth < 1)
                    m_PresentationData.BackBufferWidth = rc.right;
                if (m_PresentationData.BackBufferHeight < 1)
                    m_PresentationData.BackBufferHeight = rc.bottom;
            }
            else
            {
                DPF_ERR("zero width and/or height and unable to get client. CreateDevice/Reset fails.");
                return D3DERR_INVALIDCALL;
            }
        }

        // We can handle color conversion from the back buffer if we use
        // GDI BitBlt instead of DirectDraw Blt for presentation.

        switch (m_PresentationData.BackBufferFormat)
        {
        case D3DFMT_X1R5G5B5:
        case D3DFMT_A1R5G5B5:
        case D3DFMT_R5G6B5:
        case D3DFMT_X8R8G8B8:
        case D3DFMT_A8R8G8B8:
            break;

        default:
            DPF_ERR("Unsupported back buffer format specified.");
            return D3DERR_INVALIDCALL;
        }

        // Does the device support offscreen RTs of this format in the current
        // display mode?

        if (FAILED(Device()->Enum()->CheckDeviceFormat(
                Device()->AdapterIndex(), 
                Device()->GetDeviceType(), 
                Device()->DisplayFormat(),
                D3DUSAGE_RENDERTARGET,
                D3DRTYPE_SURFACE,
                m_PresentationData.BackBufferFormat)))
        {
            DPF_ERR("This back buffer format is not supported for a windowed device. CreateDevice/Reset Fails");
            DPF_ERR("   Use CheckDeviceType(Adapter, DeviceType, <Current Display Format>, <Desired BackBufferFormat>,  TRUE /* Windowed */)");
            return D3DERR_INVALIDCALL;
        }



        // For now, always destroy existing surfaces and recreate. Later, we
        // may reuse the surfaces. We should also add an `initialized' flag,
        // but for now will just arbitrarily use m_pPrimarySurface for this
        // purpose.

        if (this == Device()->SwapChain())
        {
            Device()->UpdateRenderTarget(NULL, NULL);
            if (m_pPrimarySurface != NULL)
            {
                Device()->ResourceManager()->DiscardBytes(0);
                static_cast<CD3DBase*>(Device())->Destroy();
                Destroy();
            }
            if (Device()->GetZStencil() != NULL)
            {
                Device()->GetZStencil()->DecrementUseCount();
                Device()->ResetZStencil();
            }
            if (D3D8DoVidmemSurfacesExist(Device()->GetHandle()))
            {
                // user must free any video memory surfaces before doing
                // fullscreen Reset, otherwise we fail.
                DPF_ERR("All user created D3DPOOL_DEFAULT surfaces must be freed"
                    " before Reset can succeed. Reset Fails.");
                return  D3DERR_DEVICELOST;
            }
        }

        // If the device is lost, we should now restore it before creating
        // the new swap chain.

        if (bDeviceLost)
        {
            D3D8RestoreDevice(Device()->GetHandle());
        }

        hr = CreateWindowed(
            Width(),
            Height(),
            BackBufferFormat(),
            m_PresentationData.BackBufferCount,
            m_PresentationData.MultiSampleType,
            (D3DSWAPEFFECT_DISCARD == m_UserSwapEffect),
            (pPresentationParameters->Flags & D3DPRESENTFLAG_LOCKABLE_BACKBUFFER)
           );
    }
    else
    {
        D3DFORMAT   FormatWithoutAlpha;

        #ifdef WINNT
            // Pick the best refresh rate
            m_PresentationData.FullScreen_RefreshRateInHz = PickRefreshRate(
                Width(),
                Height(),
                m_PresentationData.FullScreen_RefreshRateInHz,
                m_PresentationData.BackBufferFormat);
        #endif

        // If they specified a mode, does the mode exist?
        if (Width() != Device()->DisplayWidth()
            || Height() != Device()->DisplayHeight()
            || BackBufferFormat() != Device()->DisplayFormat()
            || ((m_PresentationData.FullScreen_RefreshRateInHz != 0) &&
                (m_PresentationData.FullScreen_RefreshRateInHz !=
                    Device()->DisplayRate()))
           )
        {
            D3DDISPLAYMODE* pModeTable = Device()->GetModeTable();
            DWORD dwNumModes = Device()->GetNumModes();
            DWORD i;
    #if DBG
            for (i = 0; i < dwNumModes; i++)
            {
                DPF(10,"Mode[%d] is %d x %d format=%08lx",
                    i,
                    pModeTable[i].Width,
                    pModeTable[i].Height,
                    pModeTable[i].Format);
            }
    #endif  //DBG

            FormatWithoutAlpha = CPixel::SuppressAlphaChannel(m_PresentationData.BackBufferFormat);
            for (i = 0; i < dwNumModes; i++)
            {
                if ((pModeTable[i].Width  == Width()) &&
                    (pModeTable[i].Height == Height()) &&
                    (pModeTable[i].Format == FormatWithoutAlpha))
                {
                    // So far so good.  Check refresh rate if they specified one
                    if ((m_PresentationData.FullScreen_RefreshRateInHz == 0) ||
                        (m_PresentationData.FullScreen_RefreshRateInHz ==
                        pModeTable[i].RefreshRate))
                    {
                        break;
                    }
                }
            }
            if (i == dwNumModes)
            {
                // The specified mode is invalid
                DPF_ERR("The specified mode is unsupported. CreateDevice/Reset Fails");
                return D3DERR_INVALIDCALL;
            }

            // If the mode exists, does the device have caps in it?
            if (FAILED(Device()->Enum()->CheckDeviceType(
                    Device()->AdapterIndex(), 
                    Device()->GetDeviceType(), 
                    FormatWithoutAlpha,
                    m_PresentationData.BackBufferFormat,
                    FALSE)))
            {
                DPF_ERR("Display Mode not supported by this device type. Use CheckDeviceType(X, X, <Desired fullscreen format>). CreateDevice/Reset Fails");
                return D3DERR_INVALIDCALL;
            }

            // The mode is supported, so next we set the cooperative level to fullscreen

            // Now do the mode change and update the driver caps

            D3D8_SETMODEDATA SetModeData;

            SetModeData.hDD = Device()->GetHandle();
            SetModeData.dwWidth = Width();
            SetModeData.dwHeight = Height();
            SetModeData.Format = BackBufferFormat();
            SetModeData.dwRefreshRate =
                m_PresentationData.FullScreen_RefreshRateInHz;
            SetModeData.bRestore = FALSE;

            Device()->GetHalCallbacks()->SetMode(&SetModeData);
            if (SetModeData.ddRVal != DD_OK)
            {
                DPF_ERR("Unable to set the new mode. CreateDevice/Reset Fails");
                return SetModeData.ddRVal;
            }

            FetchDirectDrawData(Device()->GetDeviceData(), Device()->GetInitFunction(), 
                Device()->Enum()->GetUnknown16(Device()->AdapterIndex()),
                Device()->Enum()->GetHalOpList(Device()->AdapterIndex()),
                Device()->Enum()->GetNumHalOps(Device()->AdapterIndex()));

            // We have to restore the device now, since out mode change above would
            // have forced it to become lost.

            bDeviceLost = TRUE; // need to restore right away
        }

        // For now, always destroy existing surfaces and recreate. Later, we
        // may reuse the surfaces. We should also add an `initialized' flag,
        // but for now will just arbitrarily use m_pPrimarySurface for this
        // purpose.

        Device()->UpdateRenderTarget(NULL, NULL);
        if (m_pPrimarySurface != NULL)
        {
            Device()->ResourceManager()->DiscardBytes(0);
            static_cast<CD3DBase*>(Device())->Destroy();
            Destroy();
        }
        if (Device()->GetZStencil() != NULL)
        {
            Device()->GetZStencil()->DecrementUseCount();
            Device()->ResetZStencil();
        }

        if (D3D8DoVidmemSurfacesExist(Device()->GetHandle()))
        {
            // user must free any video memory surfaces before doing
            // fullscreen Reset, otherwise we fail.
            DPF_ERR("All user created D3DPOOL_DEFAULT surfaces must be freed"
                " before Reset can succeed. Reset Fails");
            return  D3DERR_DEVICELOST;
        }
        if (bDeviceLost)
        {
            D3D8RestoreDevice(Device()->GetHandle());
        }

        hr = CreateFullscreen(
            m_PresentationData.BackBufferWidth,
            m_PresentationData.BackBufferHeight,
            m_PresentationData.BackBufferFormat,
            m_PresentationData.BackBufferCount,
            m_PresentationData.FullScreen_PresentationInterval,
            m_PresentationData.MultiSampleType,
            (D3DSWAPEFFECT_DISCARD == m_UserSwapEffect),
            (pPresentationParameters->Flags & D3DPRESENTFLAG_LOCKABLE_BACKBUFFER)
            );
#ifdef  WINNT
        if (SUCCEEDED(hr))
        {
            MakeFullscreen();
        }
#endif  //WINNT

        // Restore the gamma ramp if it was previously set

        if (m_GammaSet && SUCCEEDED(hr))
        {
            SetGammaRamp(0, &m_DesiredGammaRamp);
        }
    }
    if (SUCCEEDED(hr))
    {
        m_pCursor = new CCursor(Device());
        m_bClientChanged = TRUE;
        m_pSrcRect = m_pDstRect = NULL;
    }
    return hr;
} // Reset

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::ClipIntervals"

//=============================================================================
// ClipIntervals
//
// calculate [low1 high1] and [low2 high2] after considering [low high] 
// 
// - [low1 high1] will be the interval corresponding to the width/height of 
//   target's size
//
// - [low2 high2] will be the interval corresponding to the width/height of
//   the source's size
//
// - [low high] will be the interval corresponding of the width/height of
//   the target clip
//
// The intention of this function is to clip the source for certain
// stretch scenarios where the target is clipped.
//
// Created 05/17/2000 kanqiu
//=============================================================================
void ClipIntervals(long & low1, long & high1, 
                   long & low2, long & high2,
                   const long low, const long high)
{
    DXGASSERT(low1 < high1);
    DXGASSERT(low2 < high2);
    DXGASSERT(low < high);    

    // shrink the target interval to lie within our Destination Clip [low high]
    if (low > low1)
    {
        low1 = low;
    }
    if (high < high1)
    {
        high1 = high;
    }

    // if the destination interval is the same size as the destination
    // clip, then we don't need to do anything
    long    length1 = high1 - low1;
    long    length = high - low;

    // see if clamp is needed for low2 and high2 proportionally
    if (length1 != length)
    {
        // find the length of our source interval
        long    length2 = high2 - low2;

        // if the destination clip's low is outside our
        // target's low
        if (low < low1)
        {
            // Adjust the source low proportionally
            low2 += (low1 - low) * length2 / length;
        }

        // if the destination clip's high is outside our
        // target's high
        if (high > high1)
        {
            // Adjust the source high proportionally
            high2 -= (high - high1) * length2 / length;            
        }
        /*
         * Check for zero-sized dimensions and bump if necessary
         */
        DXGASSERT(high2 >= low2);
        if (low2 == high2)
        {
            if (low1 - low >= high - high1)
            {
                low2--;
            }
            else
            {
                high2++;
            }
        }
    }
} // ClipIntervals

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::ClipRects"

//=============================================================================
// ClipRects
//
// calculate pSrc and pDst after considering pSrcRect and pDstRect
//
// Created 05/17/2000 kanqiu
//=============================================================================
inline HRESULT ClipRects(RECT * pSrc,  RECT * pDst, 
    RECT * pSrcRect, const RECT * pDstRect)
{
    RECT    SrcRect;
    if (pDstRect)
    {
        if (pDstRect->top >= pDst->bottom ||
            pDstRect->bottom <= pDst->top ||
            pDstRect->left >= pDst->right ||
            pDstRect->right <= pDst->left ||
            pDstRect->top >= pDstRect->bottom ||
            pDstRect->left >= pDstRect->right
           )
        {
            // in case of insane RECT, fail it
            DPF_ERR("Unable to present with invalid destionation RECT");
            return D3DERR_INVALIDCALL;
        }
        if (pSrcRect)
        {
            SrcRect = *pSrcRect;
            pSrcRect = &SrcRect;    //make a local copy and then update
            ClipIntervals(pDst->top,pDst->bottom,pSrcRect->top,pSrcRect->bottom,
                pDstRect->top,pDstRect->bottom);
            ClipIntervals(pDst->left,pDst->right,pSrcRect->left,pSrcRect->right,
                pDstRect->left,pDstRect->right);        
        }
        else
        {
            ClipIntervals(pDst->top,pDst->bottom,pSrc->top,pSrc->bottom,
                pDstRect->top,pDstRect->bottom);
            ClipIntervals(pDst->left,pDst->right,pSrc->left,pSrc->right,
                pDstRect->left,pDstRect->right);        
        }
    }

    // this pSrcRect is either what the user passed in (if there is no pDstRect)
    // or it now points to "SrcRect" temp which contains the clipped version
    // of what the user passed it.
    if (pSrcRect)
    {
        if (pSrcRect->top >= pSrc->bottom ||
            pSrcRect->bottom <= pSrc->top ||
            pSrcRect->left >= pSrc->right ||
            pSrcRect->right <= pSrc->left ||
            pSrcRect->top >= pSrcRect->bottom ||
            pSrcRect->left >= pSrcRect->right
          )
        {
            // in case of insane RECT, fail it
            DPF_ERR("Unable to present with invalid source RECT");
            return D3DERR_INVALIDCALL;
        }
        ClipIntervals(pSrc->top,pSrc->bottom,pDst->top,pDst->bottom,
            pSrcRect->top,pSrcRect->bottom);
        ClipIntervals(pSrc->left,pSrc->right,pDst->left,pDst->right,
            pSrcRect->left,pSrcRect->right);
    }
    return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::UpdateFrameRate"

/*
 * updateFrameRate
 */
void 
CSwapChain::UpdateFrameRate( void )
{

    /*
     * work out the frame rate if required...
     */

    if( 0xffffffff == m_dwFlipTime )
    {
	m_dwFlipTime = GetTickCount();
    }

    m_dwFlipCnt++;
    if( m_dwFlipCnt >= 120 )
    {
	DWORD	time2;
	DWORD	fps;
	char	buff[256];
	time2 = GetTickCount() - m_dwFlipTime;

        // Only do this at most every two seconds 
        if (time2 >= 2000)
        {
	    fps = (m_dwFlipCnt*10000)/time2;
            wsprintf(buff, "Adapter %d FPS = %ld.%01ld\r\n",
                Device()->AdapterIndex(), fps/10, fps % 10 );
            OutputDebugString(buff);
	    m_dwFlipTime = GetTickCount();
	    m_dwFlipCnt = 0;
        }
    }
} /* updateFrameRate */

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::DebugDiscardBackBuffer"

#ifdef DEBUG
void CSwapChain::DebugDiscardBackBuffer(HANDLE SurfaceToClear) const
{
    // Disregard SW or Ref
    if (Device()->GetDeviceType() == D3DDEVTYPE_REF ||
        Device()->GetDeviceType() == D3DDEVTYPE_SW)
    {
        return;
    }

    if (m_UserSwapEffect != D3DSWAPEFFECT_DISCARD)
    {
        return;
    }

    D3D8_BLTDATA ColorFill;
    ZeroMemory(&ColorFill, (sizeof ColorFill));
    ColorFill.hDD = Device()->GetHandle();
    ColorFill.hDestSurface = SurfaceToClear;
    ColorFill.dwFlags = DDBLT_COLORFILL | DDBLT_WAIT;
    ColorFill.rDest.right = Width();
    ColorFill.rDest.bottom = Height();

    // Switch between magenta and the inverse
    static BOOL bMagenta = FALSE;

    DWORD Color;
    switch(Device()->DisplayFormat())
    {
    case D3DFMT_X8R8G8B8:
    case D3DFMT_R8G8B8:
        if (bMagenta)
            Color = 0x00FF007F;
        else
            Color = 0x0000FF00;
        break;
    case D3DFMT_X1R5G5B5:
        if (bMagenta)
            Color = 0x7C0F;
        else    
            Color = 0x03E0;
        break;
    case D3DFMT_R5G6B5:
        if (bMagenta)
            Color = 0xF80F;
        else    
            Color = 0x07E0;
        break;
    }
    if (bMagenta)
        bMagenta = FALSE;
    else
        bMagenta = TRUE;

    ColorFill.bltFX.dwFillColor = Color;

    // In debug we want to clear the back-buffer
    // if we're in discard mode
    Device()->GetHalCallbacks()->Blt(&ColorFill);

    return;
} // DebugDiscardBackBuffer

#endif // DEBUG

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::Present"

//=============================================================================
// IDirect3DSwapChain8::Present (public)
//
// Moves data from back-buffer to the primary
//
// Created 11/16/1999 johnstep
//=============================================================================
STDMETHODIMP
CSwapChain::Present(
    CONST RECT    *pSrcRect,
    CONST RECT    *pDestRect,
    HWND    hWndDestOverride,
    CONST RGNDATA *pDirtyRegion
  )
{
    API_ENTER(Device());

    HRESULT hr = E_FAIL;

    // First, fail if the device is lost
    if (D3D8IsDeviceLost(Device()->GetHandle()))
    {
        return D3DERR_DEVICELOST;
    }

    if (!m_ppBackBuffers)
    {
        return D3DERR_DEVICELOST;
    }

    if (D3DSWAPEFFECT_FLIP == m_PresentationData.SwapEffect)
    {
        if (NULL != pSrcRect || NULL != pDestRect || NULL != pDirtyRegion)
        {
            DPF_ERR("pSrcRect pDestRect pDirtyRegion must be NULL with "
                "D3DSWAPEFFECT_FLIP. Present Fails.");
            return D3DERR_INVALIDCALL;
        }
    }

    if (NULL != pDirtyRegion)
    {
        DPF_ERR("Present with non-null pDirtyRegion is not supported");
        return D3DERR_INVALIDCALL;         
    }

    for (UINT i = 0; i < m_cBackBuffers; i++)
    {
        if (m_ppBackBuffers[i]->IsLocked())
        {
            DPF_ERR("A BackBuffer in this swap chain is Locked. Present failed.");
            return D3DERR_INVALIDCALL;
        }
    }

    // Check if we need to act against HW that queues too much
    if (PresentUseBlt())
    {
        if (Device()->GetDeviceData()->DriverData.D3DCaps.MaxStreams == 0)
        {
            // Only pre-DX8 level drivers are suspected...

            if (0 == (Device()->GetDeviceData()->DriverData.KnownDriverFlags & KNOWN_NOTAWINDOWEDBLTQUEUER))
            {
                // We don't want to treat a vis-region change as a failure to
                // prevent the thunk layer from calling Reset. Reset
                // confuses the clip-list caching that is done for Present.
                // 
                // Also we want don't want to spew any errors here.
                DPF_MUTE();

                D3DLOCKED_RECT LockRect;
                // all we need is a Lock sent down to driver so it would flush the queue
                // therefore 1x1 rect is enough, larger area of lock would cause sprites to flick 
                // and therefore also slow down the system.
                RECT    DummyRect={0,0,1,1}; 
                hr = m_pPrimarySurface->InternalLockRect(&LockRect, &DummyRect, DDLOCK_FAILONVISRGNCHANGED);
                if (SUCCEEDED(hr))
                {
                    m_pPrimarySurface->InternalUnlockRect();
                }
                else
                {
                    hr = S_OK;
                }

                DPF_UNMUTE();
            }
        }
    }

#ifdef WINNT
    // If ~ 50 seconds have passed (assuming a 10Hz flip rate)
    // and this is a primary surface, then make a magic call to 
    // disable screen savers.
    // This isn't needed on 9x since we make a SPI call on that OS
    // to disable screen savers.
     
    if (0 == (Device()->BehaviorFlags() & 0x10000000))      //SCREENSAVER magic number
    {
        if (!m_PresentationData.Windowed)
        {
            static DWORD dwMagicTime = 0;
            dwMagicTime++;
            if (dwMagicTime > (50*10) )
            {
                DWORD dw=60*15;
                dwMagicTime = 0;
                SystemParametersInfo(SPI_GETSCREENSAVETIMEOUT,0,&dw,0);
                SystemParametersInfo(SPI_SETSCREENSAVETIMEOUT,dw,0,0);
            }
        }
    }
#endif


    // Flush any pending commands before we send the Flip/Blt
    static_cast<CD3DBase*>(Device())->FlushStatesNoThrow();
    
    if ( FALSE == PresentUseBlt())
    {
        // We are fullscreen, so turn this into a flip
        DXGASSERT(0==m_presentnext);
        hr = FlipToSurface(BackBuffer(0)->KernelHandle());
    }
    else
    {
        if (m_PresentationData.Windowed)
        {
            RECT    DestRect;
            //
            // Choose the presentation window. Override, or device window?
            //
            if (hWndDestOverride)
                m_BltData.hWnd = hWndDestOverride;
            else
                m_BltData.hWnd = m_PresentationData.hDeviceWindow;
            //The left and top members are zero. The right and bottom 
            //members contain the width and height of the window. 
            if (!GetClientRect(m_BltData.hWnd, &DestRect))
            {
                // in case of this unlikely event, fail it
                DPF_ERR("Unable to get client during presentation");
                return D3DERR_INVALIDCALL;
            }
            if (((UINT)DestRect.bottom != m_ClientHeight)
                || ((UINT)DestRect.right != m_ClientWidth)
               )
            {
                m_bClientChanged = TRUE;
                m_ClientHeight = (UINT)DestRect.bottom;
                m_ClientWidth = (UINT)DestRect.right;
            }
        }
        if (D3DSWAPEFFECT_FLIP != m_PresentationData.SwapEffect)
        {
            if (pSrcRect)
            {
                if (m_pSrcRect)
                {
                    if (memcmp(pSrcRect,m_pSrcRect,sizeof RECT))      
                    {
                        m_bClientChanged = TRUE;
                        m_SrcRect = *pSrcRect;
                    }
                }
                else
                {
                    m_bClientChanged = TRUE;
                    m_pSrcRect = &m_SrcRect;
                    m_SrcRect = *pSrcRect;
                }
            }
            else if (m_pSrcRect)
            {
                m_bClientChanged = TRUE;
                m_pSrcRect = NULL;
            }
            if (pDestRect)
            {
                if (m_pDstRect)
                {
                    if (memcmp(pDestRect,m_pDstRect,sizeof RECT))      
                    {
                        m_bClientChanged = TRUE;
                        m_DstRect = *pDestRect;
                    }
                }
                else
                {
                    m_bClientChanged = TRUE;
                    m_pDstRect = &m_DstRect;
                    m_DstRect = *pDestRect;
                }
            }
            else if (m_pDstRect)
            {
                m_bClientChanged = TRUE;
                m_pDstRect = NULL;
            }
        }
        if (m_bClientChanged)
        {
            m_bClientChanged = FALSE;
            m_BltData.rSrc.left = m_BltData.rSrc.top = 0;
            m_BltData.rSrc.right = Width();
            m_BltData.rSrc.bottom = Height();
            m_BltData.rDest.left = m_BltData.rDest.top = 0;
            m_BltData.rDest.right = m_ClientWidth;
            m_BltData.rDest.bottom = m_ClientHeight;
            hr = ClipRects((RECT*)&m_BltData.rSrc, (RECT*)&m_BltData.rDest,
                m_pSrcRect, m_pDstRect);
            if (FAILED(hr))
            {
                return hr;
            }
        }
        m_BltData.hSrcSurface =
            m_ppBackBuffers[m_presentnext]->KernelHandle();

        // Lock the software driver created buffer
        // and unlock it immediately
        if ((D3DDEVTYPE_HAL != Device()->GetDeviceType()) &&
            (D3DMULTISAMPLE_NONE != m_PresentationData.MultiSampleType)
           )
        {
            D3D8_LOCKDATA lockData;
            ZeroMemory(&lockData, sizeof lockData);
            lockData.hDD = Device()->GetHandle();
            lockData.hSurface = m_BltData.hSrcSurface;
            lockData.dwFlags = DDLOCK_READONLY;
            hr = Device()->GetHalCallbacks()->Lock(&lockData);
            if (SUCCEEDED(hr))
            {
                D3D8_UNLOCKDATA unlockData;
                ZeroMemory(&unlockData, sizeof unlockData);

                unlockData.hDD = Device()->GetHandle();
                unlockData.hSurface = m_BltData.hSrcSurface;
                hr = Device()->GetHalCallbacks()->Unlock(&unlockData);
                if (FAILED(hr))
                {
                    DPF_ERR("Driver failed to unlock MultiSample backbuffer. Present fails.");
                    return  hr;
                }
            }
            else
            {
                DPF_ERR("Driver failed to lock MultiSample backbuffer. Present Fails.");
                return  hr;
            }
        }

        if (DDHAL_DRIVER_NOTHANDLED
            == Device()->GetHalCallbacks()->Blt(&m_BltData))
        {
            hr = E_FAIL;
        }
        else
        {
            hr = m_BltData.ddRVal;

            // Handle deferred DP2 errors specially
            if (hr == D3DERR_DEFERRED_DP2ERROR)
            {
                // We only want to make this "error" visible
                // if we have been created with the right flag
                if (Device()->BehaviorFlags() & D3DCREATE_SHOW_DP2ERROR)
                {
                    DPF_ERR("A prior call to DrawPrim2 has failed; returning error from Present.");
                }
                else
                {
                    // Quietly just mask this error; this is ok; because
                    // we known that the Blt succeeded
                    hr = S_OK;
                }
            }
        }

        if (FAILED(hr))
        {
            DPF_ERR("BitBlt or StretchBlt failed in Present");
            return hr;
        }

        // Clear the backbuffer if the user has specified
        // discard semantics
        DebugDiscardBackBuffer(m_BltData.hSrcSurface);

        if (m_pMirrorSurface)
        {
            hr = FlipToSurface(m_pMirrorSurface->KernelHandle());
            // need to reset it
            m_BltData.hDestSurface = m_pMirrorSurface->KernelHandle();
            if (FAILED(hr))
            {
                DPF_ERR("Driver failed Flip. Present Fails.");
                return  hr;
            }
        }

        if (m_cBackBuffers > 1)
        {
            if (m_PresentationData.SwapEffect == D3DSWAPEFFECT_FLIP)
            {
                HANDLE hRenderTargetHandle = 
                            Device()->RenderTarget()->KernelHandle();
                BOOL    bNeedSetRendertarget = FALSE;

                HANDLE  hSurfTarg   = BackBuffer(0)->KernelHandle();

                DXGASSERT(0 == m_presentnext);
                for (int i = m_cBackBuffers - 1; i >= 0; i--)
                {
                    if (hSurfTarg == hRenderTargetHandle)
                        bNeedSetRendertarget = TRUE;

                    // This swap handles function will
                    // return the value that were currently
                    // in the surface; which we use to
                    // pass to the next surface.
                    m_ppBackBuffers[i]->SwapKernelHandles(&hSurfTarg);
                }
                if (bNeedSetRendertarget)
                    (static_cast<CD3DBase*>(Device()))->SetRenderTargetI(
                        Device()->RenderTarget(),
                        Device()->ZBuffer());
            }
            else
            if (++m_presentnext >= m_cBackBuffers)
            {
                m_presentnext = 0;
            }
        }
    }
    if ( D3D_REGFLAGS_SHOWFRAMERATE & m_dwFlags)
    {
        UpdateFrameRate();
    }
    return hr;
} // Present

HRESULT 
CSwapChain::FlipToSurface(HANDLE hTargetSurface)
{
    HRESULT hr;
    D3D8_FLIPDATA   FlipData;
    HANDLE  hSurfTarg;
    FlipData.hDD            = Device()->GetHandle();
    FlipData.hSurfCurr      = PrimarySurface()->KernelHandle();
    FlipData.hSurfTarg      = hTargetSurface;
    FlipData.hSurfCurrLeft  = NULL;
    FlipData.hSurfTargLeft  = NULL;
    FlipData.dwFlags        = m_dwFlipFlags;
    m_pCursor->Flip();
    hr = m_pCursor->Show(FlipData.hSurfTarg);
    Device()->GetHalCallbacks()->Flip(&FlipData);
    m_pCursor->Flip();
    hr = m_pCursor->Hide(FlipData.hSurfCurr);
    m_pCursor->Flip();
    hr = FlipData.ddRVal;

    // Handle deferred DP2 errors specially
    if (hr == D3DERR_DEFERRED_DP2ERROR)
    {
        // We only want to make this "error" visible
        // if we have been created with the right flag
        if (Device()->BehaviorFlags() & D3DCREATE_SHOW_DP2ERROR)
        {
            DPF_ERR("A prior call to DrawPrim2 has failed; returning error from Present.");
        }
        else
        {
            // Quietly just mask this error; this is ok; because
            // we known that the Flip succeeded
            hr = S_OK;
        }
    }


    // In debug, we may need to clear the data from
    // our new back-buffer if the user specified
    // SWAPEFFECT_DISCARD
    DebugDiscardBackBuffer(FlipData.hSurfCurr);   

    if (m_pMirrorSurface)
    {
        hSurfTarg = PrimarySurface()->KernelHandle();
        m_pMirrorSurface->SwapKernelHandles(&hSurfTarg);
        PrimarySurface()->SwapKernelHandles(&hSurfTarg);
    }
    else
    {
        HANDLE hRenderTargetHandle;
        CBaseSurface*   pRenderTarget = Device()->RenderTarget();
        if (pRenderTarget)
            hRenderTargetHandle = pRenderTarget->KernelHandle();
        else
            hRenderTargetHandle = 0;

        while (hTargetSurface != PrimarySurface()->KernelHandle())
        {
            hSurfTarg = PrimarySurface()->KernelHandle();
            for (int i = m_cBackBuffers-1; i>=0; i--)
            {
                BackBuffer(i)->SwapKernelHandles(&hSurfTarg);
            }
            PrimarySurface()->SwapKernelHandles(&hSurfTarg);
        }
        if (hRenderTargetHandle)
        {
            BOOL bNeedSetRendertarget;
            if (PrimarySurface()->KernelHandle() == hRenderTargetHandle)
            {
                bNeedSetRendertarget = TRUE;
            }
            else
            {
                bNeedSetRendertarget = FALSE;
                for (int i = m_cBackBuffers-1; i>=0; i--)
                {
                    if (BackBuffer(i)->KernelHandle() == hRenderTargetHandle)
                    {
                        bNeedSetRendertarget = TRUE;
                        break;
                    }
                }
            }
            if (bNeedSetRendertarget)
            {
                (static_cast<CD3DBase*>(Device()))->SetRenderTargetI(
                    Device()->RenderTarget(),
                    Device()->ZBuffer());
            }
        }
    }
    return hr;
}

HRESULT 
CSwapChain::FlipToGDISurface(void)
{
    D3D8_FLIPTOGDISURFACEDATA FlipToGDISurfaceData;
    FlipToGDISurfaceData.ddRVal = DD_OK;
    FlipToGDISurfaceData.dwToGDI = TRUE;
    FlipToGDISurfaceData.hDD = Device()->GetHandle();
    Device()->GetHalCallbacks()->FlipToGDISurface(&FlipToGDISurfaceData);
    if (NULL != m_hGDISurface && PrimarySurface() &&
        PrimarySurface()->KernelHandle() != m_hGDISurface)
    {
        return  FlipToSurface(m_hGDISurface); 
    }
    return FlipToGDISurfaceData.ddRVal;
} // FlipToGDISurface

void
CSwapChain::SetGammaRamp(
    DWORD dwFlags,          // Calibrated or not.
    CONST D3DGAMMARAMP *pRamp)
{
    D3DGAMMARAMP TempRamp;
    D3DGAMMARAMP * pRampToPassToHardware;

    m_DesiredGammaRamp = *pRamp;

    // Assume this for now. Calibration may use a temporary.
    pRampToPassToHardware = &m_DesiredGammaRamp;


    // If they want to calibrate the gamma, we will do that now.  We will
    // copy this to a different buffer so that we don't mess up the one
    // passed in to us.
    if (dwFlags & D3DSGR_CALIBRATE)
    {

        TempRamp = *pRamp;

        Device()->Enum()->LoadAndCallGammaCalibrator(
            &TempRamp,
            (UCHAR*) Device()->GetDeviceData()->DriverName);

        pRampToPassToHardware = &TempRamp;
    }


    DXGASSERT(pRampToPassToHardware);
    DXGASSERT(Device()->GetDeviceData()->hDD);
    DXGASSERT(Device()->GetDeviceData()->hDC);
    D3D8SetGammaRamp(
        Device()->GetDeviceData()->hDD,
        Device()->GetDeviceData()->hDC,
        pRampToPassToHardware);
    if (pRamp != NULL)
    {
        m_GammaSet = TRUE;
    }
    else
    {
        m_GammaSet = FALSE;
    }
}

void
CSwapChain::GetGammaRamp(
    D3DGAMMARAMP *pRamp)
{
    *pRamp = m_DesiredGammaRamp;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSwapChain::SetCooperativeLevel"  

/*
 * DD_SetCooperativeLevel
 */
HRESULT 
CSwapChain::SetCooperativeLevel()
{
#if _WIN32_WINNT >= 0x0501
    {
        //Turn off ghosting for any exclusive-mode app
        //(Whistler onwards only)
        typedef void (WINAPI *PFN_NOGHOST)( void );
        HINSTANCE hInst = NULL;
        hInst = LoadLibrary( "user32.dll" );
        if( hInst )
        {
            PFN_NOGHOST pfnNoGhost = NULL;
            pfnNoGhost = (PFN_NOGHOST)GetProcAddress( (HMODULE)hInst, "DisableProcessWindowsGhosting" );
            if( pfnNoGhost )
            {
                pfnNoGhost();
            }
            FreeLibrary( hInst );
        }
    }
#endif // _WIN32_WINNT >= 0x0501

    HRESULT ddrval;
#ifndef  WINNT
    ddrval = D3D8SetCooperativeLevel(Device()->GetHandle(),
        m_PresentationData.hDeviceWindow,
        m_PresentationData.Windowed ? DDSCL_NORMAL : 
            (DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN | DDSCL_SETDEVICEWINDOW));
    if (FAILED(ddrval))
        return ddrval;
#else
    BOOL    bThisDeviceOwnsExclusive;
    BOOL    bExclusiveExists;

    bExclusiveExists = 
        Device()->Enum()->CheckExclusiveMode(Device(), 
            &bThisDeviceOwnsExclusive,
            !m_PresentationData.Windowed);
    /*
     * exclusive mode?
     */
    if (m_PresentationData.Windowed)
    /*
     * no, must be regular
     */
    {
        DoneExclusiveMode(FALSE);
        ddrval = SetAppHWnd();
    }
    if (bExclusiveExists && !bThisDeviceOwnsExclusive)
    {
        DPF_ERR("Exclusive Mode has been taken by other app or "
            "other device on the same adapter. "
            "SetCooperativeLevel returns D3DERR_DEVICELOST.");
        return D3DERR_DEVICELOST;            
    }
    if (!m_PresentationData.Windowed)
    {
        if (GetWindowLong(Device()->FocusWindow(), GWL_STYLE) & WS_CHILD)
        {
            DPF_ERR( "Focus Window must be a top level window. CreateDevice fails." );
            return D3DERR_INVALIDCALL;
        }

        ddrval = SetAppHWnd();
        if (S_OK == ddrval)
        {
            StartExclusiveMode(FALSE);
            SetForegroundWindow(m_PresentationData.hDeviceWindow);
        }
    }
#endif
    return ddrval;

} /* SetCooperativeLevel */

#ifdef WINNT
/*
 * PickRefreshRate
 *
 * On NT, we want to pick a high reffresh rate, but we don't want to pick one 
 * too high.  In theory, mode pruning would be 100% safe and we can always pick
 * a high one, but we don't trust it 100%.  
 */
DWORD 
CSwapChain::PickRefreshRate(
    DWORD           Width,
    DWORD           Height,
    DWORD           RefreshRate,
    D3DFORMAT       Format)
{
    D3DFORMAT   FormatWithoutAlpha;
    D3DDISPLAYMODE* pModeTable = Device()->GetModeTable();
    DWORD dwNumModes = Device()->GetNumModes();
    DWORD i;

    FormatWithoutAlpha = CPixel::SuppressAlphaChannel(Format);

    // We will always use the refresh rate from the registry if it's specified.

    if (m_dwForceRefreshRate > 0)
    {
        for (i = 0; i < dwNumModes; i++)
        {
            if ((pModeTable[i].Width  == Width) &&
                (pModeTable[i].Height == Height) &&
                (pModeTable[i].Format == FormatWithoutAlpha) &&
                (m_dwForceRefreshRate == pModeTable[i].RefreshRate))
            {
                return m_dwForceRefreshRate;
            }
        }
    }

    // If the app specified the refresh rate, then we'll use it; otherwise, we
    // will pick one ourselves.

    if (RefreshRate == 0)
    {
        // If the mode requires no more bandwidth than the desktop mode from which
        // the app was launched, we will go ahead and try that mode.

        DEVMODE dm;
        ZeroMemory(&dm, sizeof dm);
        dm.dmSize = sizeof dm;

        EnumDisplaySettings(Device()->GetDeviceData()->DriverName, 
            ENUM_REGISTRY_SETTINGS, &dm);

        if ((Width <= dm.dmPelsWidth) &&
            (Height <= dm.dmPelsHeight))
        {
            // Now check to see if it's supported
            for (i = 0; i < dwNumModes; i++)
            {
                if ((pModeTable[i].Width  == Width) &&
                    (pModeTable[i].Height == Height) &&
                    (pModeTable[i].Format == FormatWithoutAlpha) &&
                    (dm.dmDisplayFrequency == pModeTable[i].RefreshRate))
                {
                    RefreshRate = dm.dmDisplayFrequency;
                    break;
                }
            }
        }

        // If we still don't have a refresh rate, try 75hz
        if (RefreshRate == 0)
        {
            for (i = 0; i < dwNumModes; i++)
            {
                if ((pModeTable[i].Width  == Width) &&
                    (pModeTable[i].Height == Height) &&
                    (pModeTable[i].Format == FormatWithoutAlpha) &&
                    (75 == pModeTable[i].RefreshRate))
                {
                    RefreshRate = 75;
                    break;
                }
            }
        }

        // If we still don't have a refresh rate, use 60hz
        if (RefreshRate == 0)
        {
            for (i = 0; i < dwNumModes; i++)
            {
                if ((pModeTable[i].Width  == Width) &&
                    (pModeTable[i].Height == Height) &&
                    (pModeTable[i].Format == FormatWithoutAlpha) &&
                    (pModeTable[i].RefreshRate == 60))
                {
                    RefreshRate = pModeTable[i].RefreshRate;
                    break;
                }
            }
        }
    }

    return RefreshRate;
}
#endif

// End of file : swapchain.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\resource.hpp ===
#ifndef __RESOURCE_HPP__
#define __RESOURCE_HPP__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       resource.hpp
 *  Content:    Base class header for resources. A resource is an non-trivial
 *              object that is directly used by the graphics pipeline. It 
 *              be composed of a set of buffers; for example a mip-map is 
 *              a resource that is composed of Surfaces (which are buffers).
 *
 *              Since resources are non-trivial (i.e. more than few bytes), 
 *              they may need management. The resource cooperates with the
 *              Resource Manager component to get management functionality.
 *
 ***************************************************************************/

#include "d3dobj.hpp"

// Forward Decl
struct CMgmtInfo;
class CResourceManager;

// Handle for Resource Manager; internally implemented as a pointer
typedef CMgmtInfo *RMHANDLE;

// A Resource is a Base Object that additionally
// has a Priority field
class CResource : public CBaseObject
{
public:

    static HRESULT RestoreDriverManagementState(CBaseDevice *pDevice);

    // These methods are for the
    // use of the Resource Manager
    RMHANDLE RMHandle() const
    {
        return m_RMHandle;
    }; // RMHandle

    // Determine if a resource is managed or driver-managed
    BOOL IsD3DManaged() const
    {
        // Zero is not a valid RM handle 
        return (m_RMHandle != 0);
    }; // IsD3DManaged

    // Set the device batch number that
    // this resource was last used in. In this
    // context; the batch refers to whether
    // this resource was used in the current
    // command buffer (i.e. containing unflushed commands).
    void Batch();

    // Same as Batch() except it batches the
    // backing (or sysmem) texture rather than the 
    // promoted (or vidmem) one.
    void BatchBase();

    // Notifies the device that this resource
    // is about to be modified in a way that
    // may require a flush. (i.e. Whenever the bits
    // could change or a surface is going away.)
    void Sync();

    // Sets batch number
    void SetBatchNumber(ULONGLONG batch)
    {
        // Batch numbers should only be increasing since we
        // start at zero.
        DXGASSERT(batch >= m_qwBatchCount);

        m_qwBatchCount = batch;
    } // SetBatchNumber

    // returns the batch number that this resource
    // was last referred in
    ULONGLONG GetBatchNumber() const
    {
        return m_qwBatchCount;
    }

    // returns the DrawPrim handle associated with
    // the Driver-Accessible clone if it is Managed; 
    // otherwise returns the handle of itself.
    DWORD DriverAccessibleDrawPrimHandle() const;

    // returns the Kernel handle associated with
    // the Driver-Accessible clone if it is Managed; 
    // otherwise returns the handle of itself.
    HANDLE DriverAccessibleKernelHandle() const;

    // Specifies a creation of a resource that
    // looks just like the current one. The LOD parameter
    // may not be relevant for all Resource types.
    virtual HRESULT Clone(D3DPOOL    Pool,
                          CResource **ppResource) const PURE;

    // Provides a method to access basic structure of the
    // pieces of the resource. 
    virtual const D3DBUFFER_DESC* GetBufferDesc() const PURE;

    // Tells the resource that it should copy itself
    // to the target. It is the caller's responsibility
    // to make sure that Target is compatible with the
    // Source. (The Target may have different number of mip-levels
    // and be in a different pool; however, it must have the same size, 
    // faces, format, etc.)
    //
    // This function will clear the dirty state.
    virtual HRESULT UpdateDirtyPortion(CResource *pResourceTarget) PURE;

    // Allows the Resource Manager to mark the texture
    // as needing to be completely updated on next
    // call to UpdateDirtyPortion
    virtual void MarkAllDirty() PURE;
        
    // Indicates whether the Resource has been modified since
    // the last time that UpdateDirtyPortion has been called.
    // All managed resources start out in the Dirty state.
    BOOL IsDirty() const
    {
        return m_bIsDirty;
    } // IsDirty

    void PreLoadImpl();

    // Returns the pool which the user passed in
    D3DPOOL GetUserPool() const
    {
        return m_poolUser;
    } // GetUserPool
    
protected:
    // The following are methods that only make sense
    // to be called by derived classes

    // Helper to check if a type is managed
    static BOOL IsTypeD3DManaged(CBaseDevice        *pDevice, 
                                 D3DRESOURCETYPE     Type, 
                                 D3DPOOL             Pool);

    static BOOL IsTypeDriverManaged(CBaseDevice        *pDevice, 
                                    D3DRESOURCETYPE     Type, 
                                    D3DPOOL             Pool);

    // Helper to determine what the 'real' pool is
    // for a managed resource.
    static D3DPOOL DetermineCreationPool(CBaseDevice        *pDevice, 
                                          D3DRESOURCETYPE    Type, 
                                          DWORD              dwUsage,
                                          D3DPOOL            Pool);

    // Constructor for Resources; all resources start out dirty
    CResource(CBaseDevice *pDevice, D3DPOOL Pool, REF_TYPE refType = REF_EXTERNAL) : 
        CBaseObject(pDevice, refType),
        m_RMHandle(0),
        m_qwBatchCount(0),
        m_Priority(0),
        m_bIsDirty(TRUE),
        m_poolUser(Pool),
        m_pPrev(0)
    {
        m_pNext = pDevice->GetResourceList();
        pDevice->SetResourceList(this);
        if (m_pNext != 0)
        {
            m_pNext->m_pPrev = this;
        }
    }; // CResource

    virtual ~CResource();

    // Priority Inlines
    DWORD SetPriorityImpl(DWORD newPri);

    DWORD GetPriorityImpl();

    // Allows initialization of the RMHandle after
    // construction is basically complete
    HRESULT InitializeRMHandle();

    // Allows RMHandle to be set to zero
    void DeleteRMHandle();

    // Helper to notify the RM that
    // we are now dirty. 
    void OnResourceDirty();

    // Helper to notify resource when it
    // is all clean
    void OnResourceClean();

    // Resources need to implement OnDestroy by 
    // calling Sync; (Textures overload this
    // to call OnTextureDestroy on the device before
    // calling their base class.)
    virtual void OnDestroy(void)
    {
        Sync();
        return;
    } // OnDestroy

    // Returns the current priority 
    DWORD GetPriorityI() const
    {
        return m_Priority;
    }

    // Sets the current priority (but does not do any work)
    DWORD SetPriorityI(DWORD Priority)
    {
        DWORD oldPriority = m_Priority;
        m_Priority = Priority;
        return oldPriority;
    }

private:

    RMHANDLE    m_RMHandle;
    ULONGLONG   m_qwBatchCount;
    DWORD       m_Priority;
    BOOL        m_bIsDirty;

    // Remember the pool that the user passed in
    D3DPOOL     m_poolUser;

    // Linked list of resources
    CResource  *m_pPrev;
    CResource  *m_pNext;

    friend CResourceManager;
}; // CResource

struct CMgmtInfo
{
    // This is static because we assume all resources
    // to be in heap zero. WHEN the resource manager
    // supports multiple heaps, m_rmHeap should be
    // made per object again.
    static DWORD m_rmHeap;

    DWORD      m_priority;
    DWORD      m_LOD;
    BOOL       m_bInUse;
   
    DWORD      m_rmHeapIndex;
    DWORD      m_scene;
    DWORD      m_ticks;
    CResource *m_pRes;
    CResource *m_pBackup;

    CMgmtInfo(CResource*);
    ~CMgmtInfo();

    ULONGLONG Cost() const
    {
#ifdef _X86_
        ULONGLONG retval;
        _asm
        {
            mov     ebx, this;
            mov     edx, [ebx]CMgmtInfo.m_bInUse;
            shl     edx, 31;
            mov     eax, [ebx]CMgmtInfo.m_priority;
            mov     ecx, eax;
            shr     eax, 1;
            or      edx, eax;
            mov     DWORD PTR retval + 4, edx;
            shl     ecx, 31;
            mov     eax, [ebx]CMgmtInfo.m_ticks;
            shr     eax, 1;
            or      eax, ecx;
            mov     DWORD PTR retval, eax;
        }
        return retval;
#else
        return ((ULONGLONG)m_bInUse << 63) + ((ULONGLONG)m_priority << 31) + ((ULONGLONG)(m_ticks >> 1));
#endif
    }
}; // CMgmtInfo 

inline CMgmtInfo::CMgmtInfo(CResource *pBackup)
{
    m_priority = 0;
    m_LOD = 0;
    m_bInUse = FALSE;
    m_rmHeap = 0;
    m_rmHeapIndex = 0;
    m_scene = 0;
    m_ticks = 0;
    m_pRes = 0;
    m_pBackup = pBackup;
} // CMgmtInfo::CMgmtInfo

inline CMgmtInfo::~CMgmtInfo()
{
    if (m_pRes != 0)
    {
        m_pRes->DecrementUseCount();
    }
} // CMgmtInfo::~CMgmtInfo

class CRMHeap 
{

private:

    enum { InitialSize = 1023 };

    DWORD m_next, m_size;
    CMgmtInfo **m_data_p;

    DWORD parent(DWORD k) const { return k / 2; }
    DWORD lchild(DWORD k) const { return k * 2; }
    DWORD rchild(DWORD k) const { return k * 2 + 1; }
    void heapify(DWORD k);

public:

    CRMHeap(DWORD size = InitialSize);
    ~CRMHeap();
    BOOL Initialize();

    DWORD length() const { return m_next - 1; }
    CMgmtInfo* minCost() const { return m_data_p[1]; }

    BOOL add(CMgmtInfo*);
    CMgmtInfo* extractMin();
    CMgmtInfo* extractMax();
    CMgmtInfo* extractNotInScene(DWORD dwScene);
    void del(CMgmtInfo*);
    void update(CMgmtInfo*, BOOL inuse, DWORD priority, DWORD ticks); 
    void resetAllTimeStamps(DWORD ticks);
}; // class CRMHeap

inline CRMHeap::CRMHeap(DWORD size)
{
    m_next = 1;
    m_size = size + 1;
} // CRMHeap::CRMHeap

inline CRMHeap::~CRMHeap()
{
    delete[] m_data_p;
} // CRMHeap::~CRMHeap

class CResourceManager
{
    
public:

    CResourceManager();
    ~CResourceManager();

    // Need to call before using the manager
    HRESULT Init(CBaseDevice *pD3D8);

    // Check to see if a type is going to driver managed
    // or going to be D3D managed
    BOOL IsDriverManaged(D3DRESOURCETYPE Type) const;
    
    // Specify that a resource needs to be managed
    //
    // Error indicates that we don't support management for this
    // resource type.
    HRESULT Manage(CResource *pResource, RMHANDLE *pHandle);
    
    // Stop managing a resouce; called when a managed resource
    // is going away
    void UnManage(RMHANDLE hRMHandle);
    
    // The RM manages Priority and LOD for the resource    
    DWORD SetPriority(RMHANDLE hRMHandle, DWORD newPriority);
    DWORD SetLOD(RMHANDLE hRMHandle, DWORD dwLodNew);

    // Preloads resource into video memory
    void PreLoad(RMHANDLE hRMHandle);

    // Checks if the resource is in video memory
    BOOL InVidmem(RMHANDLE hRMHandle) const;

    // This is called when DrawPrimitive needs to 
    // make sure that all resources used in the
    // current call are in video memory and are
    // uptodate.
    HRESULT UpdateVideo(RMHANDLE hRMHandle, BOOL *bDirty);
    HRESULT UpdateVideoInternal(CMgmtInfo *pMgmtInfo);

    // This returns the appropriate handle for a
    // managed resource
    DWORD DrawPrimHandle(RMHANDLE hRMHandle) const;

    // This returns the appropriate kernel handle for a
    // managed resource
    HANDLE KernelHandle(RMHANDLE hRMHandle) const;

    // This call will batch the appropriate resource
    // for the purpose of syncing
    void Batch(RMHANDLE hRMHandle, ULONGLONG batch) const;

    // Called from outside when a managed resource becomes dirty
    void OnResourceDirty(RMHANDLE hRMHandle) const;

    void DiscardBytes(DWORD cbBytes);

    void SceneStamp() { ++m_dwScene; }

private:

    CBaseDevice *m_pD3D8;
    unsigned tcm_ticks, m_dwScene, m_dwNumHeaps;
    BOOL m_PreLoading;
    CRMHeap *m_heap_p;

    BOOL FreeResources(DWORD dwHeap, DWORD dwBytes);

    void Lock(RMHANDLE hRMHandle);
    void Unlock(RMHANDLE hRMHandle);

    void TimeStamp(CMgmtInfo *pMgmtInfo);
    
}; // class CResourceManager

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::IsTypeD3DManaged"

inline BOOL CResource::IsTypeD3DManaged(CBaseDevice        *pDevice, 
                                        D3DRESOURCETYPE     Type, 
                                        D3DPOOL             Pool)
{
    if (Pool == D3DPOOL_MANAGED)
    {
        return !IsTypeDriverManaged(pDevice, Type, Pool);
    }
    else
    {
        return FALSE;
    }
}; // IsTypeD3DManaged

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::IsTypeDriverManaged"

inline BOOL CResource::IsTypeDriverManaged(CBaseDevice     *pDevice, 
                                           D3DRESOURCETYPE  Type, 
                                           D3DPOOL          Pool)
{
    if (Pool == D3DPOOL_MANAGED)
    {
        if (pDevice->ResourceManager()->IsDriverManaged(Type))
        {
            return TRUE;
        }
    }
    return FALSE;
}; // IsTypeDriverManaged

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::DetermineCreationPool"

inline D3DPOOL CResource::DetermineCreationPool(CBaseDevice    *pDevice, 
                                                D3DRESOURCETYPE Type, 
                                                DWORD           dwUsage,
                                                D3DPOOL         Pool)
{
    if (Pool == D3DPOOL_MANAGED)
    {
        if (IsTypeDriverManaged(pDevice, Type, Pool))
        {
            // This pool is used by the thunk layer
            // to use the driver management flag during
            // create
            return D3DPOOL_MANAGED;
        }
        else
        {
            // If it is not driver managed; then it 
            // becomes D3DMANAGED
            return D3DPOOL_SYSTEMMEM;
        }
    }
    else
    {
        // Not managed at all; so we just
        // use the same pool we started with
        return Pool;
    }
} // DetermineCreationPool


#undef DPF_MODNAME
#define DPF_MODNAME "CResource::~CResource"

inline CResource::~CResource()
{
    // If managed, we need to notify
    // the ResourceManager that we are going away
    if (IsD3DManaged())
    {
        Device()->ResourceManager()->UnManage(m_RMHandle);
    }
    // Unlink from the resource list
    if (m_pNext != 0)
    {
        m_pNext->m_pPrev = m_pPrev;
    }    
    if (m_pPrev != 0)
    {
        m_pPrev->m_pNext = m_pNext;
        DXGASSERT(Device()->GetResourceList() != this);
    }
    else
    {
        DXGASSERT(Device()->GetResourceList() == this);
        Device()->SetResourceList(m_pNext);
    }
}; // ~CResource

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::InitializeRMHandle"

// Allows initialization of the RMHandle after
// construction is basically complete
inline HRESULT CResource::InitializeRMHandle()
{
    // We should not already have a handle
    DXGASSERT(m_RMHandle == 0);
    
    // Get a handle from the resource manager
    return Device()->ResourceManager()->Manage(this, &m_RMHandle);
}; // InitializeRMHandle

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::DeleteRMHandle"

inline void CResource::DeleteRMHandle()
{
    // We should already have a handle
    DXGASSERT(m_RMHandle != 0);

    Device()->ResourceManager()->UnManage(m_RMHandle);
    m_RMHandle = 0;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::OnResourceDirty"

// Add a helper to notify the RM that
// we are now dirty. 
inline void CResource::OnResourceDirty()
{
    // Update our state
    m_bIsDirty = TRUE;

    // Only need to notify RM for managed textures
    // that have been been set through SetTexture
    if (IsD3DManaged() && IsInUse())
    {
        Device()->ResourceManager()->OnResourceDirty(m_RMHandle);
    } 

    return;
}; // OnResourceDirty

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::OnResourceClean"

// Add a helper to help maintain m_bIsDirty bit
inline void CResource::OnResourceClean()
{
    DXGASSERT(m_bIsDirty == TRUE);
    m_bIsDirty = FALSE;
    return;
}; // OnResourceDirty


#undef DPF_MODNAME
#define DPF_MODNAME "CResource::DriverAccessibleDrawPrimHandle"

inline DWORD CResource::DriverAccessibleDrawPrimHandle() const
{
    if (IsD3DManaged())
    {
        // Return the DrawPrim handle of my clone
        return Device()->ResourceManager()->DrawPrimHandle(RMHandle());
    }
    else
    {
        return BaseDrawPrimHandle();
    }
} // CResource::DriverAccessibleDrawPrimHandle

#undef DPF_MODNAME
#define DPF_MODNAME "CResource::DriverAccessibleKernelHandle"

inline HANDLE CResource::DriverAccessibleKernelHandle() const
{
    if (IsD3DManaged())
    {
        // Return the DrawPrim handle of my clone
        HANDLE h = Device()->ResourceManager()->KernelHandle(RMHandle());
        
        // If this handle is NULL, then it means it was called
        // without calling UpdateVideo which isn't allowed/sane
        DXGASSERT(h != NULL);
        
        return h;
    }
    else
    {
        return BaseKernelHandle();
    }
} // CResource::DriverAccessibleKernelHandle


#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::CResourceManager"

inline CResourceManager::CResourceManager()
{
    m_pD3D8 = 0;
    tcm_ticks = m_dwScene = m_dwNumHeaps = 0;
    m_heap_p = 0;
    m_PreLoading = FALSE;
} // CResourceManager::CResourceManager

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::~CResourceManager"

inline CResourceManager::~CResourceManager()
{
    // We should not call DiscardBytes here
    // because this destructor can be called via
    // the device destructor chain. In this situation
    // DiscardBytes will access bad or already freed
    // data.
    delete[] m_heap_p;
} // CResourceManager::~CResourceManager

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::DrawPrimHandle"

inline DWORD CResourceManager::DrawPrimHandle(RMHANDLE hRMHandle) const
{
    if (InVidmem(hRMHandle))
    {
        CMgmtInfo* &pMgmtInfo = hRMHandle;
        return pMgmtInfo->m_pRes->BaseDrawPrimHandle();
    }
    else
    {
        return 0;
    }
} // CResourceManager::DrawPrimHandle

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::KernelHandle"

inline HANDLE CResourceManager::KernelHandle(RMHANDLE hRMHandle) const
{
    if (InVidmem(hRMHandle))
    {
        CMgmtInfo* &pMgmtInfo = hRMHandle;
        return pMgmtInfo->m_pRes->BaseKernelHandle();
    }
    else
    {
        return 0;
    }
} // CResourceManager::Kernelhandle

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::InVidmem"

inline BOOL CResourceManager::InVidmem(RMHANDLE hRMHandle) const
{
    CMgmtInfo* &pMgmtInfo = hRMHandle;
    DXGASSERT(pMgmtInfo != 0);
    return pMgmtInfo->m_pRes != 0;
} // CResourceManager::InVidmem

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::Batch"

inline void CResourceManager::Batch(RMHANDLE hRMHandle, ULONGLONG batch) const
{
    if (InVidmem(hRMHandle))
    {
        CMgmtInfo* &pMgmtInfo = hRMHandle;
        pMgmtInfo->m_pRes->SetBatchNumber(batch);
    }
} // CResourceManager::Batch

#undef DPF_MODNAME
#define DPF_MODNAME "CResourceManager::UpdateVideo"

inline HRESULT CResourceManager::UpdateVideo(RMHANDLE hRMHandle, BOOL *bDirty)
{
    HRESULT ddrval = S_OK;
    CMgmtInfo* &pMgmtInfo = hRMHandle;
    if (!InVidmem(hRMHandle))
    {
        ddrval = UpdateVideoInternal(pMgmtInfo);
        *bDirty = TRUE;
    }
    else
    {
        if (pMgmtInfo->m_pBackup->IsDirty())
        {
            ddrval = pMgmtInfo->m_pBackup->UpdateDirtyPortion(pMgmtInfo->m_pRes);
        }
        TimeStamp(pMgmtInfo);
    }
    return ddrval;
}

#endif // __RESOURCE_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\surface.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       surface.cpp
 *  Content:    Implementation of the CSurface class.
 *
 *
 ***************************************************************************/
#include "ddrawpr.h"

#include "surface.hpp"
#include "pixel.hpp"
#include "swapchan.hpp"

#undef DPF_MODNAME
#define DPF_MODNAME "CSurface::Create"

// Static class function for creating a RenderTarget/ZStencil object.
// (Because it is static; it doesn't have a this pointer.)

HRESULT CSurface::Create(CBaseDevice        *pDevice, 
                         DWORD               Width,
                         DWORD               Height,
                         DWORD               Usage,
                         D3DFORMAT           UserFormat,
                         D3DMULTISAMPLE_TYPE MultiSampleType,
                         REF_TYPE            refType,
                         IDirect3DSurface8 **ppSurface)
{
    HRESULT     hr;

    // Do parameter checking here
    if (!VALID_PTR_PTR(ppSurface))
    {
        DPF_ERR("Bad parameter passed for ppSurface for creating a surface. CreateRenderTarget/CreateDepthStencil failed");
        return D3DERR_INVALIDCALL;
    }

    // Zero-out return parameter
    *ppSurface = NULL;

    // Size may need to be 4x4
    if (CPixel::Requires4X4(UserFormat))
    {
        if ((Width & 3) ||
            (Height & 3))
        {
            DPF_ERR("DXT Formats require width/height to be a multiple of 4. CreateRenderTarget/CreateDepthStencil failed.");
            return D3DERR_INVALIDCALL;
        }
    }

    // Validate against zero width/height
    if (Width   == 0 ||
        Height  == 0)
    {
        DPF_ERR("Width/Height must be non-zero. CreateRenderTarget/CreateDepthStencil failed"); 
        return D3DERR_INVALIDCALL;
    }

    // Now verify that the device can support the specified format
    hr = pDevice->CheckDeviceFormat(
            Usage & (D3DUSAGE_RENDERTARGET  |
                     D3DUSAGE_DEPTHSTENCIL),
            D3DRTYPE_SURFACE,
            UserFormat);    
    if (FAILED(hr))
    {
        DPF_ERR("The format is not supported by this device. CreateRenderTarget/CreateDepthStencil failed");
        return D3DERR_INVALIDCALL;
    }

    // Infer lockability for DepthStencil from format
    if (Usage & D3DUSAGE_DEPTHSTENCIL)
    {
        if (!CPixel::IsNonLockableZ(UserFormat))
        {
            Usage |= D3DUSAGE_LOCK;
        }
    }

    // Validate lockability
    if ((MultiSampleType != D3DMULTISAMPLE_NONE) &&
        (Usage & D3DUSAGE_LOCK))
    {
        // RT have explicit lockability
        if (Usage & D3DUSAGE_RENDERTARGET)
        {
            DPF_ERR("Multi-Sampled render-targets are not lockable. CreateRenderTarget failed");
            return D3DERR_INVALIDCALL;
        }
        else
        {
            DPF_ERR("Multi-Sampled Depth Stencil buffers are not lockable. "
                    "Use D3DFMT_D16 instead of D3DFMT_D16_LOCKABLE. CreateDepthStencil failed");
            return D3DERR_INVALIDCALL;
        }
    }
  

    // Map depth/stencil format
    D3DFORMAT RealFormat = pDevice->MapDepthStencilFormat(UserFormat);
   
    // Create the surface 
    CSurface *pSurface;

    pSurface = new CDriverSurface(pDevice, 
                                  Width, 
                                  Height, 
                                  Usage, 
                                  UserFormat,
                                  RealFormat, 
                                  MultiSampleType,
                                  0,            // hKernelHandle
                                  refType,
                                  &hr);

    if (pSurface == NULL)
    {
        DPF_ERR("Out of Memory creating surface. CreateRenderTarget/CreateDepthStencil failed");
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr))
    {
        DPF_ERR("Error during initialization of surface. CreateRenderTarget/CreateDepthStencil failed");
        if (refType == REF_EXTERNAL)
        {
            // External objects get released
            pSurface->Release();
        }
        else
        {
            // Internal and intrinsic objects get decremented
            DXGASSERT(refType == REF_INTERNAL || refType == REF_INTRINSIC);
            pSurface->DecrementUseCount();
        }

        return hr;
    }

    // We're done; just return the object
    *ppSurface = pSurface;

    return hr;
} // static Create for ZBuffers and RenderTargets


#undef DPF_MODNAME
#define DPF_MODNAME "CSurface::CreateImageSurface"
// Function for creating sys-mem stand-alone surfaces
// that can be used with CopyRect and SetCursorSurface and
// ReadBuffer
HRESULT CSurface::CreateImageSurface(CBaseDevice        *pDevice, 
                                     DWORD               Width,
                                     DWORD               Height,
                                     D3DFORMAT           Format,
                                     REF_TYPE            refType,
                                     IDirect3DSurface8 **ppSurface)
{
    HRESULT hr;

    // Do parameter checking here
    if (!VALID_PTR_PTR(ppSurface))
    {
        DPF_ERR("Bad parameter passed for ppSurface for creating a surface. CreateImageSurface failed.");
        return D3DERR_INVALIDCALL;
    }

    // Zero-out return parameter
    *ppSurface = NULL;

    // Has to be supported format
    if (!CPixel::IsSupported(D3DRTYPE_SURFACE, Format))
    {
        DPF_ERR("This format is not supported for CreateImageSurface");
        return D3DERR_INVALIDCALL;
    }

    if (CPixel::IsNonLockableZ(Format))
    {
        DPF_ERR("This Z format is not supported for CreateImageSurface");
        return D3DERR_INVALIDCALL;
    }

    // Size may need to be 4x4
    if (CPixel::Requires4X4(Format))
    {
        if ((Width & 3) ||
            (Height & 3))
        {
            DPF_ERR("DXT Formats require width/height to be a multiple of 4. CreateImageSurface failed.");
            return D3DERR_INVALIDCALL;
        }
    }

    // Validate against zero width/height
    if (Width   == 0 ||
        Height  == 0)
    {
        DPF_ERR("Width/Height must be non-zero. CreateImageSurface failed."); 
        return D3DERR_INVALIDCALL;
    }


    // Usage is explictly just Usage_LOCK
    DWORD Usage = D3DUSAGE_LOCK;

    CSurface *pSurface = new CSysMemSurface(pDevice, 
                                            Width, 
                                            Height, 
                                            Usage, 
                                            Format, 
                                            refType,
                                           &hr);
    if (pSurface == NULL)
    {
        DPF_ERR("Out of Memory creating surface. CreateImageSurface failed.");
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr))
    {
        DPF_ERR("Error during initialization of surface. CreateImageSurface failed.");
        if (refType == REF_EXTERNAL)
        {
            // External objects get released
            pSurface->Release();
        }
        else
        {
            // Internal and intrinsic objects get decremented
            DXGASSERT(refType == REF_INTERNAL || refType == REF_INTRINSIC);
            pSurface->DecrementUseCount();
        }

        return hr;
    }

    // We're done; just return the object
    *ppSurface = pSurface;

    return S_OK;
} // static CreateImageSurface


#undef DPF_MODNAME
#define DPF_MODNAME "CSurface::CSurface"

// Constructor the surface class; this is the 
// base class for render targets/zbuffers/and backbuffers
CSurface::CSurface(CBaseDevice         *pDevice, 
                   DWORD                Width,
                   DWORD                Height,
                   DWORD                Usage,
                   D3DFORMAT            Format,
                   REF_TYPE             refType,
                   HRESULT             *phr
                   ) :
    CBaseObject(pDevice, refType),
    m_qwBatchCount(0)
{
    // Sanity check
    DXGASSERT(phr);

    // Initialize basic structures
    m_desc.Format       = Format;
    m_desc.Pool         = D3DPOOL_DEFAULT;
    m_desc.Usage        = Usage;
    m_desc.Type         = D3DRTYPE_SURFACE;
    m_desc.Width        = Width;
    m_desc.Height       = Height;

    m_formatUser        = Format;
    m_poolUser          = D3DPOOL_DEFAULT;

    // Return success
    *phr = S_OK;

} // CSurface::CSurface


#undef DPF_MODNAME
#define DPF_MODNAME "CSurface::~CSurface"

// Destructor
CSurface::~CSurface()
{
    // The destructor has to handle partially
    // created objects. 

    // Check to make sure that we aren't deleting
    // an object that is referenced in the current (unflushed)
    // command stream buffer.
    DXGASSERT(m_qwBatchCount <= static_cast<CD3DBase*>(Device())->CurrentBatch());
} // CSurface::~CSurface


// IUnknown methods
#undef DPF_MODNAME
#define DPF_MODNAME "CSurface::QueryInterface"

STDMETHODIMP CSurface::QueryInterface(REFIID      riid, 
                                      LPVOID FAR *ppvObj)
{
    API_ENTER(Device());

    if (!VALID_PTR_PTR(ppvObj))
    {
        DPF_ERR("Invalid ppvObj parameter passed to CSurface::QueryInterface");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_PTR(&riid, sizeof(GUID)))
    {
        DPF_ERR("Invalid guid memory address to CSurface::QueryInterface");
        return D3DERR_INVALIDCALL;
    }

    if (riid == IID_IDirect3DSurface8 || riid == IID_IUnknown)
    {
        *ppvObj = static_cast<void*>(static_cast<IDirect3DSurface8 *>(this));
        AddRef();
        return S_OK;
    }

    DPF_ERR("Unsupported Interface identifier passed to CSurface::QueryInterface");

    // Null out param
    *ppvObj = NULL;
    return E_NOINTERFACE;
} // QueryInterface

#undef DPF_MODNAME
#define DPF_MODNAME "CSurface::AddRef"

STDMETHODIMP_(ULONG) CSurface::AddRef()
{
    API_ENTER_NO_LOCK(Device());   
    
    return AddRefImpl();
} // AddRef

#undef DPF_MODNAME
#define DPF_MODNAME "CSurface::Release"

STDMETHODIMP_(ULONG) CSurface::Release()
{
    API_ENTER_SUBOBJECT_RELEASE(Device());   
    
    return ReleaseImpl();
} // Release

// IDirect3DBuffer methods

#undef DPF_MODNAME
#define DPF_MODNAME "CSurface::GetDevice"

STDMETHODIMP CSurface::GetDevice(IDirect3DDevice8 ** ppObj)
{
    API_ENTER(Device());
    return GetDeviceImpl(ppObj);
} // GetDevice

#undef DPF_MODNAME
#define DPF_MODNAME "CSurface::SetPrivateData"

STDMETHODIMP CSurface::SetPrivateData(REFGUID riid, 
                                      CONST VOID* pvData, 
                                      DWORD cbData, 
                                      DWORD dwFlags)
{
    API_ENTER(Device());

    // We use level zero for our data
    return SetPrivateDataImpl(riid, pvData, cbData, dwFlags, 0);
} // SetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CSurface::GetPrivateData"

STDMETHODIMP CSurface::GetPrivateData(REFGUID riid, 
                                      LPVOID pvData, 
                                      LPDWORD pcbData)
{
    API_ENTER(Device());

    // We use level zero for our data
    return GetPrivateDataImpl(riid, pvData, pcbData, 0);
} // GetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CSurface::FreePrivateData"

STDMETHODIMP CSurface::FreePrivateData(REFGUID riid)
{
    API_ENTER(Device());

    // We use level zero for our data
    return FreePrivateDataImpl(riid, 0);
} // FreePrivateData


#undef DPF_MODNAME
#define DPF_MODNAME "CSurface::GetContainer"

STDMETHODIMP CSurface::GetContainer(REFIID riid, 
                                    void **ppContainer)
{
    API_ENTER(Device());

    // Our 'container' is just the device since
    // we are a standalone surface object
    return Device()->QueryInterface( riid, ppContainer);
} // OpenContainer

#undef DPF_MODNAME
#define DPF_MODNAME "CSurface::GetDesc"

STDMETHODIMP CSurface::GetDesc(D3DSURFACE_DESC *pDesc)
{
    API_ENTER(Device());

    // If parameters are bad, then we should fail some stuff
    if (!VALID_WRITEPTR(pDesc, sizeof(*pDesc)))
    {
        DPF_ERR("bad pointer for pDesc passed to CSurface::GetDesc");
        return D3DERR_INVALIDCALL;
    }

    *pDesc                 = m_desc;
    pDesc->Format          = m_formatUser;
    pDesc->Pool            = m_poolUser;
    pDesc->Usage          &= D3DUSAGE_EXTERNAL;

    return S_OK;
} // GetDesc

#undef DPF_MODNAME
#define DPF_MODNAME "CSurface::InternalGetDesc"

D3DSURFACE_DESC CSurface::InternalGetDesc() const
{
    return m_desc;
} // InternalGetDesc


#ifdef DEBUG
#undef DPF_MODNAME
#define DPF_MODNAME "CSurface::ReportWhyLockFailed"

// DPF why Lock failed as clearly as possible
void CSurface::ReportWhyLockFailed(void) const
{
    // If there are multiple reasons that lock failed; we report
    // them all to minimize user confusion

    if (InternalGetDesc().MultiSampleType != D3DMULTISAMPLE_NONE)
    {
        DPF_ERR("Lock is not supported for surfaces that have multi-sampling enabled.");
    }

    if (InternalGetDesc().Usage & D3DUSAGE_DEPTHSTENCIL)
    {
        DPF_ERR("Lock is not supported for depth formats other than D3DFMT_D16_LOCKABLE");
    }

    // If this is not a non-lockable Z format, and
    // we are not multisampled; then the user must
    // have explicitly chosen to create us in an non-lockable way
    if (InternalGetDesc().Usage & D3DUSAGE_BACKBUFFER)
    {
        DPF_ERR("Backbuffers are not lockable unless application specifies "
                "D3DPRESENTFLAG_LOCKABLE_BACKBUFFER at CreateDevice and Reset. "
                "Lockable backbuffers incur a performance cost on some "
                "graphics hardware.");
    }
    else if (InternalGetDesc().Usage & D3DUSAGE_RENDERTARGET)
    {
        DPF_ERR("RenderTargets are not lockable unless application specifies "
                "TRUE for the Lockable parameter for CreateRenderTarget. Lockable "
                "render targets incur a performance cost on some graphics hardware.");
    }

    // If we got here; then USAGE_LOCK should not have been set
    DXGASSERT(!(InternalGetDesc().Usage & D3DUSAGE_LOCK));

    return;
} // CSurface::ReportWhyLockFailed
#endif // DEBUG

//=============================================
// Methods for the CSysMemSurface class
//=============================================
#undef DPF_MODNAME
#define DPF_MODNAME "CSysMemSurface::CSysMemSurface"
CSysMemSurface::CSysMemSurface(CBaseDevice         *pDevice, 
                               DWORD                Width,
                               DWORD                Height,
                               DWORD                Usage,
                               D3DFORMAT            Format,
                               REF_TYPE             refType,
                               HRESULT             *phr
                               ) :
    CSurface(pDevice, 
             Width, 
             Height, 
             Usage, 
             Format, 
             refType, 
             phr),
    m_rgbPixels(NULL)
{
    if (FAILED(*phr))
        return;

    // Compute how much memory we need
    m_desc.Size = CPixel::ComputeSurfaceSize(Width, 
                                             Height, 
                                             Format);

    // Specify system memory
    m_desc.Pool = D3DPOOL_SYSTEMMEM;
    m_poolUser  = D3DPOOL_SYSTEMMEM;

    // Specify no multisampling
    m_desc.MultiSampleType  = D3DMULTISAMPLE_NONE;

    // Allocate the memory
    m_rgbPixels = new BYTE[m_desc.Size];
    if (m_rgbPixels == NULL)
    {
        DPF_ERR("Out of memory allocating surface.");
        *phr = E_OUTOFMEMORY;
        return;
    }

    // Figure out our pitch
    D3DLOCKED_RECT lock;
    CPixel::ComputeSurfaceOffset(&m_desc,
                                  m_rgbPixels,
                                  NULL,       // pRect
                                 &lock);


    // Create a DDSURFACE and CreateSurfaceData object
    DDSURFACEINFO SurfInfo;
    ZeroMemory(&SurfInfo, sizeof(SurfInfo));

    // If we are not passed a handle, then we need to get one from
    // the DDI

    D3D8_CREATESURFACEDATA CreateSurfaceData;
    ZeroMemory(&CreateSurfaceData, sizeof(CreateSurfaceData));

    // Set up the basic information
    CreateSurfaceData.hDD               = pDevice->GetHandle();
    CreateSurfaceData.pSList            = &SurfInfo;
    CreateSurfaceData.dwSCnt            = 1;

    // ImageSurface is an internal type so that the thunk layer
    // knows that it is not really a texture
    CreateSurfaceData.Type              = D3DRTYPE_IMAGESURFACE;
    CreateSurfaceData.Pool              = m_desc.Pool;
    CreateSurfaceData.dwUsage           = m_desc.Usage;
    CreateSurfaceData.MultiSampleType   = D3DMULTISAMPLE_NONE;
    CreateSurfaceData.Format            = Format;

    // Specify the surface data
    SurfInfo.cpWidth  = Width;
    SurfInfo.cpHeight = Height;
    SurfInfo.pbPixels = (BYTE*)lock.pBits;
    SurfInfo.iPitch   = lock.Pitch;

    *phr = pDevice->GetHalCallbacks()->CreateSurface(&CreateSurfaceData);
    if (FAILED(*phr))
    {
        DPF_ERR("Failed to create sys-mem surface");
        return;
    }

    DXGASSERT(CreateSurfaceData.Pool == D3DPOOL_SYSTEMMEM);
    DXGASSERT(m_desc.Pool == D3DPOOL_SYSTEMMEM);
    DXGASSERT(m_poolUser == D3DPOOL_SYSTEMMEM);

    SetKernelHandle(SurfInfo.hKernelHandle);

    return;
} // CSysMemSurface::CSysMemSurface

#undef DPF_MODNAME
#define DPF_MODNAME "CSysMemSurface::~CSysMemSurface"
CSysMemSurface::~CSysMemSurface() 
{
    if (KernelHandle() != 0)
    {
        D3D8_DESTROYSURFACEDATA DestroyData;

        ZeroMemory(&DestroyData, sizeof DestroyData);
        DestroyData.hDD = Device()->GetHandle();
        DestroyData.hSurface = KernelHandle();
        Device()->GetHalCallbacks()->DestroySurface(&DestroyData);
    }

    // Free the memory we've allocated for the surface
    delete [] m_rgbPixels;

    return;
} // CSysMemSurface::CSysMemSurface


#undef DPF_MODNAME
#define DPF_MODNAME "CSysMemSurface::LockRect"

STDMETHODIMP CSysMemSurface::LockRect(D3DLOCKED_RECT *pLockedRectData, 
                                      CONST RECT           *pRect, 
                                      DWORD           dwFlags)
{   
    API_ENTER(Device());

    // If parameters are bad, then we should fail some stuff
    if (!VALID_WRITEPTR(pLockedRectData, sizeof(D3DLOCKED_RECT)))
    {
        DPF_ERR("bad pointer for m_pLockedRectData passed to LockRect for an ImageSurface.");
        return D3DERR_INVALIDCALL;
    }

    // Zero out returned data
    ZeroMemory(pLockedRectData, sizeof(D3DLOCKED_RECT));

    // Validate Rect
    if (pRect != NULL)
    {
        if (!CPixel::IsValidRect(m_desc.Format,
                                 m_desc.Width, 
                                 m_desc.Height, 
                                 pRect))
        {
            DPF_ERR("LockRect for a Surface failed");
            return D3DERR_INVALIDCALL;
        }
    }

    if (dwFlags & ~D3DLOCK_SURF_VALID)
    {
        DPF_ERR("Invalid dwFlags parameter passed to LockRect for an ImageSurface");
        DPF_EXPLAIN_BAD_LOCK_FLAGS(0, dwFlags & ~D3DLOCK_SURF_VALID);
        return D3DERR_INVALIDCALL;
    }

    // Can't lock surfaces that are not lockable
    if (!IsLockable())
    {
        ReportWhyLockFailed();
        return D3DERR_INVALIDCALL;
    }

    return InternalLockRect(pLockedRectData, pRect, dwFlags);
} // LockRect

#undef DPF_MODNAME
#define DPF_MODNAME "CSysMemSurface::InternalLockRect"

HRESULT CSysMemSurface::InternalLockRect(D3DLOCKED_RECT *pLockedRectData, 
                                         CONST RECT     *pRect, 
                                         DWORD           dwFlags)
{   
    // Only one lock outstanding at a time is supported
    // (even internally)
    if (m_isLocked)
    {
        DPF_ERR("LockRect failed on a surface; surface was already locked for an ImageSurface");
        return D3DERR_INVALIDCALL;
    }

    CPixel::ComputeSurfaceOffset(&m_desc,
                                  m_rgbPixels, 
                                  pRect,
                                  pLockedRectData);

    // Mark ourselves as locked
    m_isLocked = TRUE;

    // Done
    return S_OK;
} // InternalLockRect

#undef DPF_MODNAME
#define DPF_MODNAME "CSysMemSurface::UnlockRect"

STDMETHODIMP CSysMemSurface::UnlockRect()
{
    API_ENTER(Device());

    // If we aren't locked; then something is wrong
    if (!m_isLocked)
    {
        DPF_ERR("UnlockRect failed on a mip level; surface wasn't locked for an ImageSurface");
        return D3DERR_INVALIDCALL;
    }

    DXGASSERT(IsLockable());

    return InternalUnlockRect();
} // UnlockRect

#undef DPF_MODNAME
#define DPF_MODNAME "CSysMemSurface::InternalUnlockRect"

HRESULT CSysMemSurface::InternalUnlockRect()
{
    DXGASSERT(m_isLocked);

    // Clear our locked state
    m_isLocked = FALSE;

    // Done
    return S_OK;
} // InternalUnlockRect


//=============================================
// Methods for the CDriverSurface class
//=============================================
#undef DPF_MODNAME
#define DPF_MODNAME "CDriverSurface::CDriverSurface"
CDriverSurface::CDriverSurface(CBaseDevice          *pDevice, 
                               DWORD                 Width,
                               DWORD                 Height,
                               DWORD                 Usage,
                               D3DFORMAT             UserFormat,
                               D3DFORMAT             RealFormat,
                               D3DMULTISAMPLE_TYPE   MultiSampleType,
                               HANDLE                hKernelHandle,
                               REF_TYPE              refType,
                               HRESULT              *phr
                               ) :
    CSurface(pDevice, 
             Width, 
             Height, 
             Usage, 
             RealFormat, 
             refType, 
             phr)
{
    // Even in failure paths, we need to remember
    // the passed in kernel handle so we can uniformly
    // free it
    if (hKernelHandle)
        SetKernelHandle(hKernelHandle);
    
    // On failure; just return here
    if (FAILED(*phr))
    {
        return;
    }

    // Remember User Format
    m_formatUser = UserFormat;

    // Remember multi-sample type
    m_desc.MultiSampleType  = MultiSampleType;

    // Parameter check MS types; (since swapchan bypasses
    // the static Create; we need to parameter check here.)

    if (MultiSampleType != D3DMULTISAMPLE_NONE)
    {
        *phr = pDevice->CheckDeviceMultiSampleType(RealFormat,
                                                   pDevice->SwapChain()->Windowed(),
                                                   MultiSampleType);
        if (FAILED(*phr))
        {
            DPF_ERR("Unsupported multisample type requested. CreateRenderTarget/CreateDepthStencil failed.");
            return;
        }
    }

    // Back buffers are actually, for now, created just like other device
    // surfaces.
    
    // Otherwise, we need to call the driver
    // and get ourselves a handle. 

    // Create a DDSURFACE and CreateSurfaceData object
    DDSURFACEINFO SurfInfo;
    ZeroMemory(&SurfInfo, sizeof(SurfInfo));

    if ((hKernelHandle == NULL) &&
        (!(pDevice->Enum()->NoDDrawSupport(pDevice->AdapterIndex())) ||
         !(D3DUSAGE_PRIMARYSURFACE & Usage))
       )
    {
        // If we are not passed a handle, then we need to get one from
        // the DDI

        D3D8_CREATESURFACEDATA CreateSurfaceData;
        ZeroMemory(&CreateSurfaceData, sizeof(CreateSurfaceData));

        // Set up the basic information
        CreateSurfaceData.hDD             = pDevice->GetHandle();
        CreateSurfaceData.pSList          = &SurfInfo;
        CreateSurfaceData.dwSCnt          = 1;
        CreateSurfaceData.Type            = D3DRTYPE_SURFACE;
        CreateSurfaceData.Pool            = m_desc.Pool;
        CreateSurfaceData.dwUsage         = m_desc.Usage;
        CreateSurfaceData.Format          = RealFormat;
        CreateSurfaceData.MultiSampleType = MultiSampleType;

        // Specify the surface data
        SurfInfo.cpWidth  = Width;
        SurfInfo.cpHeight = Height;

        *phr = pDevice->GetHalCallbacks()->CreateSurface(&CreateSurfaceData);
        if (FAILED(*phr))
        {
            DPF_ERR("Failed to create driver surface");
            return;
        }

        // Remember the kernel handle
        SetKernelHandle(SurfInfo.hKernelHandle);

        // Remember the actual pool
        m_desc.Pool = CreateSurfaceData.Pool;
    }
    else
    {
        // If the caller has already allocated this
        // then we assume that the pool is LocalVidMem
        SurfInfo.hKernelHandle = hKernelHandle;
        m_desc.Pool            = D3DPOOL_LOCALVIDMEM;
    }

    m_desc.Size = SurfInfo.iPitch * Height;
    if (m_desc.MultiSampleType != D3DMULTISAMPLE_NONE)
        m_desc.Size *= (UINT)m_desc.MultiSampleType;

    return;
} // CDriverSurface::CDriverSurface

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverSurface::~CDriverSurface"
CDriverSurface::~CDriverSurface() 
{
    if (KernelHandle() != 0)
    {
        D3D8_DESTROYSURFACEDATA DestroyData;

        ZeroMemory(&DestroyData, sizeof DestroyData);
        DestroyData.hDD = Device()->GetHandle();
        DestroyData.hSurface = KernelHandle();
        Device()->GetHalCallbacks()->DestroySurface(&DestroyData);
    }

    return;
} // CDriverSurface::CDriverSurface


#undef DPF_MODNAME
#define DPF_MODNAME "CDriverSurface::LockRect"

STDMETHODIMP CDriverSurface::LockRect(D3DLOCKED_RECT *pLockedRectData, 
                                      CONST RECT           *pRect, 
                                      DWORD           dwFlags)
{   
    API_ENTER(Device());

    // If parameters are bad, then we should fail some stuff
    if (!VALID_WRITEPTR(pLockedRectData, sizeof(D3DLOCKED_RECT)))
    {
        DPF_ERR("bad pointer for m_pLockedRectData passed to LockRect");
        return D3DERR_INVALIDCALL;
    }

    // Zero out returned data
    ZeroMemory(pLockedRectData, sizeof(D3DLOCKED_RECT));

    // Validate Rect
    if (pRect != NULL)
    {
        if (!CPixel::IsValidRect(m_desc.Format,
                                 m_desc.Width, 
                                 m_desc.Height, 
                                 pRect))
        {
            DPF_ERR("LockRect for a driver-allocated Surface failed");
            return D3DERR_INVALIDCALL;
        }
    }

    if (dwFlags & ~D3DLOCK_SURF_VALID)
    {
        DPF_ERR("Invalid dwFlags parameter passed to LockRect");
        DPF_EXPLAIN_BAD_LOCK_FLAGS(0, dwFlags & ~D3DLOCK_SURF_VALID);
        return D3DERR_INVALIDCALL;
    }

    // Can't lock surfaces that are not lockable
    if (!IsLockable())
    {
        ReportWhyLockFailed();
        return D3DERR_INVALIDCALL;
    }
    return InternalLockRect(pLockedRectData, pRect, dwFlags);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverSurface::InternalLockRect"

HRESULT CDriverSurface::InternalLockRect(D3DLOCKED_RECT *pLockedRectData, 
                                         CONST RECT     *pRect, 
                                         DWORD           dwFlags)
{   
    // Only one lock outstanding at a time is supported
    // (even internally)
    if (m_isLocked)
    {
        DPF_ERR("LockRect failed on a surface; surface was already locked.");
        return D3DERR_INVALIDCALL;
    }

    D3D8_LOCKDATA lockData;
    ZeroMemory(&lockData, sizeof lockData);

    lockData.hDD        = Device()->GetHandle();
    lockData.hSurface   = KernelHandle();
    lockData.dwFlags    = dwFlags;
    if (pRect != NULL)
    {
        lockData.bHasRect = TRUE;
        lockData.rArea = *((RECTL *) pRect);
    }
    else
    {
        DXGASSERT(lockData.bHasRect == FALSE);
    }

    // Sync before allowing read or write access
    Sync();

    HRESULT hr = Device()->GetHalCallbacks()->Lock(&lockData);
    if (FAILED(hr))
    {
        DPF_ERR("Error trying to lock driver surface");
        return hr;
    }

    // Fill in the Locked_Rect fields 
    if (CPixel::IsDXT(m_desc.Format))
    {
        // Pitch is the number of bytes for
        // one row's worth of blocks for linear formats

        // Start with our width
        UINT Width = m_desc.Width;

        // Convert to blocks
        Width = Width / 4;

        // At least one block
        if (Width == 0)
            Width = 1;

        if (m_desc.Format == D3DFMT_DXT1)
        {
            // 8 bytes per block for DXT1
            pLockedRectData->Pitch = Width * 8;
        }
        else
        {
            // 16 bytes per block for DXT2-5
            pLockedRectData->Pitch = Width * 16;
        }
    }
    else
    {
        pLockedRectData->Pitch = lockData.lPitch;
    }
    pLockedRectData->pBits  = lockData.lpSurfData;

    // Mark ourselves as locked
    m_isLocked = TRUE;

    // Done
    return hr;
} // LockRect

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverSurface::UnlockRect"

STDMETHODIMP CDriverSurface::UnlockRect()
{
    API_ENTER(Device());

    // If we aren't locked; then something is wrong
    if (!m_isLocked)
    {
        DPF_ERR("UnlockRect failed; surface wasn't locked.");
        return D3DERR_INVALIDCALL;
    }

    return InternalUnlockRect();
}
#undef DPF_MODNAME
#define DPF_MODNAME "CDriverSurface::InternalUnlockRect"

HRESULT CDriverSurface::InternalUnlockRect()
{
    DXGASSERT(m_isLocked);

    D3D8_UNLOCKDATA unlockData = {
        Device()->GetHandle(),
        KernelHandle()
    };

    HRESULT hr = Device()->GetHalCallbacks()->Unlock(&unlockData);
    if (SUCCEEDED(hr))
    {
        // Clear our locked state
        m_isLocked = FALSE;
    }

    // Done
    return hr;
} // UnlockRect


// End of file : surface.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\texture.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       texture.cpp
 *  Content:    Implementation of the CBaseTexture class.
 *
 *
 ***************************************************************************/
#include "ddrawpr.h"

#include "texture.hpp"
#include "d3di.hpp"
#include "ddi.h"


#undef DPF_MODNAME
#define DPF_MODNAME "CBaseTexture::CanTexBlt"

BOOL CBaseTexture::CanTexBlt(CBaseTexture *pDstTexture) const
{
    const D3D8_DRIVERCAPS* pDriverCaps = Device()->GetCoreCaps();
    D3DPOOL SrcPool = GetBufferDesc()->Pool;
    D3DPOOL DstPool = pDstTexture->GetBufferDesc()->Pool;

    // Real pools should not be default
    DXGASSERT(SrcPool != D3DPOOL_DEFAULT);
    DXGASSERT(DstPool != D3DPOOL_DEFAULT);
    DXGASSERT(VALID_INTERNAL_POOL(SrcPool));
    DXGASSERT(VALID_INTERNAL_POOL(DstPool));

    // Check if the device can do TexBlt
    if (Device()->CanTexBlt() == FALSE)
        return FALSE;

    // Check that source and dest formats match
    DXGASSERT(GetBufferDesc()->Format == pDstTexture->GetBufferDesc()->Format);

    // FourCC may not be copy-able        
    if (CPixel::IsFourCC(GetBufferDesc()->Format))
    {
        if (!(pDriverCaps->D3DCaps.Caps2 & DDCAPS2_COPYFOURCC))
        {
            return FALSE;
        }
    }

    // Note that we do not support TexBlt to anything 
    // that is persistent across Reset; because TexBlt is
    // asynchronous and may not succeed if we get lost. 
    // 
    // This can break apps that expect the blt to have
    // succeeded.

    if (pDriverCaps->D3DCaps.Caps2 & DDCAPS2_NONLOCALVIDMEMCAPS)
    {
        if (SrcPool == D3DPOOL_SYSTEMMEM)
        {
            if ((DstPool == D3DPOOL_NONLOCALVIDMEM) &&
                (pDriverCaps->D3DCaps.DevCaps & D3DDEVCAPS_CANBLTSYSTONONLOCAL))
            {
                return TRUE;
            }
            else if ((DstPool == D3DPOOL_LOCALVIDMEM) &&
                      (pDriverCaps->SVBCaps & DDCAPS_BLT))
            {
                return TRUE;
            }
        }
        else if (SrcPool == D3DPOOL_NONLOCALVIDMEM)
        {
            if ((DstPool == D3DPOOL_LOCALVIDMEM) &&
                 (pDriverCaps->NLVCaps & DDCAPS_BLT))
            {
                return TRUE;
            }
        }
        else if ((SrcPool == D3DPOOL_LOCALVIDMEM) ||
                 (SrcPool == D3DPOOL_MANAGED))
        {
            if ((DstPool == D3DPOOL_LOCALVIDMEM) &&
                 (pDriverCaps->D3DCaps.Caps & DDCAPS_BLT))
            {
                return TRUE;
            }
        }
    }
    else
    {
        if (SrcPool == D3DPOOL_SYSTEMMEM)
        {
            if ((DstPool == D3DPOOL_LOCALVIDMEM) &&
                 (pDriverCaps->SVBCaps & DDCAPS_BLT))
            {
                return TRUE;
            }
        }
        else if ((SrcPool == D3DPOOL_LOCALVIDMEM) ||
                 (SrcPool == D3DPOOL_MANAGED))
        {
            if ((DstPool == D3DPOOL_LOCALVIDMEM) &&
                 (pDriverCaps->D3DCaps.Caps & DDCAPS_BLT))
            {
                return TRUE;
            }
        }
    }

    return FALSE;
} // CBaseTexture::CanTexBlt


#undef DPF_MODNAME
#define DPF_MODNAME "CBaseTexture::VerifyFormat"

HRESULT CBaseTexture::Validate(CBaseDevice    *pDevice,
                               D3DRESOURCETYPE Type, 
                               D3DPOOL         Pool,
                               DWORD           Usage,
                               D3DFORMAT       Format)
{
    DXGASSERT(pDevice);
    DXGASSERT(Type == D3DRTYPE_TEXTURE       ||
              Type == D3DRTYPE_CUBETEXTURE   ||
              Type == D3DRTYPE_VOLUMETEXTURE);

    // Check pool
    if (!VALID_POOL(Pool))
    {
        DPF_ERR("Invalid Pool specified for texture");
        return D3DERR_INVALIDCALL;
    }

    //pool scratch doesn't allow any usages
    if (Pool == D3DPOOL_SCRATCH)
    {
        if (Usage)
        {
            DPF_ERR("D3DPOOL_SCRATCH resources aren't allowed to have any usage flags");
            return D3DERR_INVALIDCALL;
        }
    }

    // Check usage flags
    if (Usage & ~D3DUSAGE_TEXTURE_VALID)
    {
        DPF_ERR("Invalid usage flag specified for texture.");
        return D3DERR_INVALIDCALL;
    }

    // Check if USAGE_DYNAMIC is allowed
    if (Usage & D3DUSAGE_DYNAMIC)
    {
        if (Pool == D3DPOOL_MANAGED)
        {
            DPF_ERR("Managed textures cannot be dynamic.");
            return D3DERR_INVALIDCALL;
        }
    }

    // Check is load-once is supported
    if (Usage & D3DUSAGE_LOADONCE)
    {
        // Only SysMem and Managed are load-once-able
        if (Pool != D3DPOOL_SYSTEMMEM &&
            Pool != D3DPOOL_MANAGED)
        {
            DPF_ERR("Only SysMem and Managed textures support D3DUSAGE_LOADONCE");
            return D3DERR_INVALIDCALL;
        }

        // Only D16_LOCKABLE is a lockable depth; doesn't 
        // make sense to have a non-lockable LOAD_ONCE texture
        if (CPixel::IsNonLockableZ(Format))
        {
            DPF_ERR("Depth formats other than D3DFMT_D16_LOCKABLE are not lockable.");
            return D3DERR_INVALIDCALL;
        }
    }

    // Check that only POOL_DEFAULT is supported for
    // RT or DS textures
    if (Usage & (D3DUSAGE_RENDERTARGET | D3DUSAGE_DEPTHSTENCIL))
    {
        if (Pool != D3DPOOL_DEFAULT)
        {
            DPF_ERR("Pool must be D3DPOOL_DEFAULT for RenderTarget and"
                    " DepthStencil Usages");
            return D3DERR_INVALIDCALL;
        }
    }

    // Sys scratch or Managed must have a format that we can use directly
    if (Pool == D3DPOOL_SYSTEMMEM  || 
        Pool == D3DPOOL_MANAGED ||
        Pool == D3DPOOL_SCRATCH)
    {
        // Can't create format unless it is supported
        if (!CPixel::IsSupported(Type, Format))
        {
            DPF_ERR("SystemMem, Scratch and Managed textures do not support this"
                    " format.");
            return D3DERR_INVALIDCALL;
        }
        if (CPixel::IsNonLockableZ(Format))
        {
            DPF_ERR("This format is not supported for SystemMem, Scratch or Managed textures");
            return D3DERR_INVALIDCALL;
        }
    }

    if (Pool != D3DPOOL_SCRATCH)
    {
        HRESULT hr = pDevice->CheckDeviceFormat(Usage & (D3DUSAGE_RENDERTARGET | D3DUSAGE_DEPTHSTENCIL | D3DUSAGE_DYNAMIC), 
                                                Type, 
                                                Format);
        if (FAILED(hr))
        {
            DPF_ERR("Invalid format specified for texture");
            return D3DERR_INVALIDCALL;
        }
    }

    return S_OK;
}; // CBaseTexture::Validate

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseTexture::InferUsageFlags"

// Infer usage flags based on external parameters
DWORD CBaseTexture::InferUsageFlags(D3DPOOL            Pool,
                                    DWORD              Usage,
                                    D3DFORMAT          Format)
{
    //scratch textures have only usage lock
    if (Pool == D3DPOOL_SCRATCH)
        return D3DUSAGE_LOCK;

    // All textures have this usage set
    DWORD UsageInferred = D3DUSAGE_TEXTURE;

    DXGASSERT(!(Usage & D3DUSAGE_LOCK));
    DXGASSERT(!(Usage & D3DUSAGE_TEXTURE));

    // Infer Lock 
    if ((Pool != D3DPOOL_DEFAULT)       &&
        !(CPixel::IsNonLockableZ(Format)) &&
        !(Usage & D3DUSAGE_LOADONCE))
    {
        // Pool Default is not lockable
        // Usage Load Once implies absence of USAGE_LOCK
        // Z formats (other than D16_LOCKABLE) are not lockable

        // Otherwise, locking is support by default
        UsageInferred |= D3DUSAGE_LOCK;
    }
    else if (CPixel::IsIHVFormat(Format))
    {
        // IHV formats are lockable
        UsageInferred |= D3DUSAGE_LOCK;
    }
    else if (Usage & D3DUSAGE_DYNAMIC)
    {
        DXGASSERT(Pool != D3DPOOL_MANAGED);
        // Dynamic textures are lockable
        UsageInferred |= D3DUSAGE_LOCK;
    }

    return (UsageInferred | Usage);

} // CBaseTexture::InferUsageFlags

#ifdef DEBUG
#undef DPF_MODNAME
#define DPF_MODNAME "CBaseTexture::ReportWhyLockFailed"

// DPF why Lock failed as clearly as possible
void CBaseTexture::ReportWhyLockFailed(void) const
{
    // If there are multiple reasons that lock failed; we report
    // them all to minimize user confusion
    if (GetUserPool() == D3DPOOL_DEFAULT)
    {
        DPF_ERR("Lock is not supported for textures allocated with"
                " POOL_DEFAULT unless they are marked D3DUSAGE_DYNAMIC.");
    }
    if (CPixel::IsNonLockableZ(GetUserFormat()))
    {
        DPF_ERR("Lock is not supported for depth formats other than D3DFMT_D16_LOCKABLE");
    }
    if (GetBufferDesc()->Usage & D3DUSAGE_LOADONCE)
    {
        DPF_ERR("For textures created with D3DUSAGE_LOADONCE,"
                " each level can only be locked once.");
    }

    // If we got here; then USAGE_LOCK should not have been set
    DXGASSERT(!(GetBufferDesc()->Usage & D3DUSAGE_LOCK));

    return;
} // CBaseTexture::ReportWhyLockFailed
#endif // DEBUG

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseTexture::OnDestroy"
// Textures overload this to call OnTextureDestroy on the 
// Device before calling Sync.
void CBaseTexture::OnDestroy(void)
{
    if (GetUserPool() != D3DPOOL_SCRATCH)
    {
        // we need to call this before freeing the texture so
        // that currently set textures get unset.
        if (BaseKernelHandle())
        {
            // m_hKernelHandle might not be available if Create fails early
            CD3DBase *pDev = static_cast<CD3DBase *>(Device());
            pDev->OnTextureDestroy(this);
        }

        // After FE has been notified, then we need
        // to sync; so call our base class
        CResource::OnDestroy();
    }

    return;
} // CBaseTexture::OnDestroy

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseTexture::SetLODImpl"

DWORD CBaseTexture::SetLODImpl(DWORD LOD)
{
    // Clamp to max lod since we can't return errors
    if (LOD >= GetLevelCountImpl())
    {
        DPF_ERR("Invalid dwLOD passed to SetLOD; clamping to number-of-levels-minus-one.");
        LOD = GetLevelCountImpl() - 1;
    }

    DWORD oldLOD = 0;
    if (IsD3DManaged())
    {
        oldLOD = Device()->ResourceManager()->SetLOD(RMHandle(), LOD);
    }
    // If IsD3DManaged() is FALSE and if the actual pool
    // is found to be D3DPOOL_MANAGED then the resource
    // MUST be driver managed.
    else if (GetBufferDesc()->Pool == D3DPOOL_MANAGED)
    {
        CD3DBase *pDev = static_cast<CD3DBase*>(Device());
        DXGASSERT(IS_DX8HAL_DEVICE(pDev));
        oldLOD = SetLODI(LOD);
        pDev->SetTexLOD(this, LOD);
    }
    // If above two conditions are false, then we must
    // check if we have fallen back to sysmem for some
    // reason even if the app requested managed. THIS
    // IS IMPOSSIBLE, so ASSERT.
    else if (GetUserPool() == D3DPOOL_MANAGED)
    {
        // We assert because sysmem fallback is not possible
        // for textures (and hence SetLOD)
        DXGASSERT(FALSE);
    }
    else
    {
        DPF_ERR("LOD set on non-managed object");
    }
    return oldLOD;
}; // SetLODImpl

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseTexture::GetLODImpl"

DWORD CBaseTexture::GetLODImpl()
{
    if (!IsD3DManaged() && GetBufferDesc()->Pool != D3DPOOL_MANAGED)
    {
        DPF_ERR("LOD accessed on non-managed object");
        return 0;
    }
    return GetLODI();
}; // GetLODImpl

// End of file : texture.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\swapchan.hpp ===
//=============================================================================
// Copyright (c) 1999 Microsoft Corporation
//
// swapchan.hpp
//
// Swap chain implementation. A swap chain contains a primary surface, back
// buffers, and exclusive mode state such as fullscreen, stereoscopy, cover
// window, and the what is required to flip back buffers.
//
// Created 11/16/1999 johnstep (John Stephens)
//=============================================================================

#ifndef __SWAPCHAN_HPP__
#define __SWAPCHAN_HPP__

#include "surface.hpp"
#include "dxcursor.hpp"

//-----------------------------------------------------------------------------
// CSwapChain
//-----------------------------------------------------------------------------

class CSwapChain : public CBaseObject, public IDirect3DSwapChain8
{
public:
    CSwapChain(
        CBaseDevice                 *pDevice,
        REF_TYPE                     refType);

    void Init(
        D3DPRESENT_PARAMETERS *pPresentationParameters,
        HRESULT                     *pHr
        );

    virtual ~CSwapChain();

    CDriverSurface *PrimarySurface() const
    {
        return m_pPrimarySurface;
    }

    CDriverSurface *BackBuffer(UINT i) const
    {
        if (m_ppBackBuffers && i < m_PresentationData.BackBufferCount)
            return m_ppBackBuffers[i];
        else
            return NULL;
    }

    UINT Width() const
    {
        return m_PresentationData.BackBufferWidth;
    }
    
    UINT Height() const
    {
        return m_PresentationData.BackBufferHeight;
    }

    D3DFORMAT BackBufferFormat() const
    {
        return m_PresentationData.BackBufferFormat;
    }

    BOOL Windowed() const
    {
        return m_PresentationData.Windowed;
    }

    BOOL PresentUseBlt() const
    {
        return m_PresentUseBlt;
    }
    
    // IUnknown methods
    
    STDMETHODIMP QueryInterface(REFIID iid, void **ppInterface);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirect3D8SwapChain8 methods
    
    STDMETHODIMP 
    GetBackBuffer(
        UINT                iBackBuffer,
        D3DBACKBUFFER_TYPE  Type,
        IDirect3DSurface8 **ppBackBuffer
        );
    
    STDMETHODIMP
    Present(
        CONST RECT    *pSrcRect,
        CONST RECT    *pDestRect, 
        HWND    hTargetWindow,
        CONST RGNDATA *pDstRegion
        );


    // Internal methods
    HRESULT
    Reset(
        D3DPRESENT_PARAMETERS *pPresentationParameters
        );

    HRESULT FlipToGDISurface(void);

    void SetGammaRamp(DWORD dwFlags, CONST D3DGAMMARAMP *pRamp);

    void GetGammaRamp(D3DGAMMARAMP *pRamp);
#ifdef  WINNT
    void MakeFullscreen();
    void DoneExclusiveMode(BOOL);
    void StartExclusiveMode(BOOL);
    void HIDESHOW_IME();                                          
    BOOL IsWinProcDeactivated() const;

    DWORD PickRefreshRate(
            DWORD           Width,
            DWORD           Height,
            DWORD           RefreshRate,
            D3DFORMAT       Format);
#endif  //WINNT
    VOID Destroy();


protected:
    UINT m_presentnext;

    CDriverSurface  *m_pPrimarySurface;
    //HEL and REF allocate the render targets in system memory themselves
    //but the blt from system memory to the primary surface will cause tearing, 
    //so ideally we'd put the n backbuffers in system memory and then a single 
    //m_pMirrorSurface in video memory.  When presenting the system 
    //memory backbuffer, 
    //we can blt to the video memory backbuffer and then flip
    //Naturally device has to have enough video memory and support flip
    //otherwise m_pMirrorSurface will be NULL, and Present will
    //simply Blt from m_ppBackBuffers to m_pPrimarySurface
    CDriverSurface  *m_pMirrorSurface; 
    CDriverSurface **m_ppBackBuffers;
    UINT m_cBackBuffers;

    HRESULT CreateWindowed(
        UINT width,
        UINT height,
        D3DFORMAT backBufferFormat,
        UINT cBackBuffers,
        D3DMULTISAMPLE_TYPE MultiSampleType,
        BOOL bDiscard,
        BOOL bLockable
        );

    HRESULT CreateFullscreen(
        UINT width,
        UINT height,
        D3DFORMAT backBufferFormat,
        UINT cBackBuffers,
        UINT presentationRate,
        D3DMULTISAMPLE_TYPE MultiSampleType,
        BOOL bDiscard,
        BOOL bLockable
        );

#ifdef DEBUG
    void DebugDiscardBackBuffer(HANDLE SurfaceToClear) const;
#else
    void DebugDiscardBackBuffer(HANDLE SurfaceToClear) const
    {
        // No-op in retail
    }; // DebugDiscardBackBuffer
#endif 
        

private:
    friend CBaseDevice;
    friend CCursor;
    D3DPRESENT_PARAMETERS m_PresentationData;
    CCursor*    m_pCursor;
    HANDLE  m_hGDISurface;
    HRESULT SetCooperativeLevel();
    HRESULT SetAppHWnd();
    HRESULT FlipToSurface(HANDLE hTargetSurface);
    void    UpdateFrameRate( void );
    BOOL        m_bExclusiveMode;
    LPVOID      m_pCursorShadow;
    LPVOID      m_pHotTracking;
    LONG        m_lIMEState;
    LONG        m_lSetIME;
    UINT        m_uiErrorMode;
    DWORD       m_dwFlipFlags;
    D3D8_BLTDATA    m_BltData;
    UINT        m_ClientWidth;
    UINT        m_ClientHeight;
    BOOL        m_bClientChanged;
    RECT        m_DstRect;
    RECT        m_SrcRect;
    RECT*       m_pDstRect;
    RECT*       m_pSrcRect;
    DWORD       m_dwFlags;
#ifdef  WINNT
    DWORD       m_dwForceRefreshRate;
#endif
    DWORD	m_dwFlipCnt;
    DWORD       m_dwFlipTime;
    BOOL        m_PresentUseBlt;
    D3DSWAPEFFECT   m_UserSwapEffect; // what the user specified

    // Please keep this entry at the end of the struct... it'll make assembly-
    // level debugging easier.
    BOOL          m_GammaSet;
    D3DGAMMARAMP  m_DesiredGammaRamp;

    // DO NOT PUT ANYTHING HERE

}; // class CSwapChain
#define D3D_REGFLAGS_SHOWFRAMERATE  0x01
#ifdef  WINNT
#define D3D_REGFLAGS_FLIPNOVSYNC    0x02
#endif
#endif // __SWAPCHAN_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\swddi.c ===
#include "ddrawpr.h"
#include <ddrawint.h>
#include "ddithunk.h"
#include <d3d8sddi.h>

typedef struct
{
    DDRAWI_DDRAWSURFACE_LCL     Lcl;
    DDRAWI_DDRAWSURFACE_GBL     Gbl;
    DDRAWI_DDRAWSURFACE_MORE    More;
    ATTACHLIST                  From;
    ATTACHLIST                  To;
} SWDDIDDRAWI_LCL;

LPDDRAWI_DDRAWSURFACE_LCL
SwDDIBuildHeavyWeightSurface (
    LPDDRAWI_DIRECTDRAW_LCL pDDrawLocal,
    PD3D8_CREATESURFACEDATA pCreateSurface,
    DD_SURFACE_LOCAL* pSurfaceLocal,
    DD_SURFACE_GLOBAL* pSurfaceGlobal,
    DD_SURFACE_MORE* pSurfaceMore,
    DWORD index)
{
    SWDDIDDRAWI_LCL             *pSWDDILcl;
    LPDDRAWI_DDRAWSURFACE_LCL   pLcl;

    pSWDDILcl = MemAlloc(sizeof(*pSWDDILcl));
    if (pSWDDILcl == NULL)
    {
        return NULL;
    }

    pLcl = &pSWDDILcl->Lcl;

    pLcl->lpGbl = &pSWDDILcl->Gbl;
    pLcl->lpSurfMore = &pSWDDILcl->More;

    memcpy(&pLcl->lpGbl->ddpfSurface, &pSurfaceGlobal->ddpfSurface, sizeof(DDPIXELFORMAT));
    pLcl->lpGbl->wWidth                 = (WORD) pSurfaceGlobal->wWidth;
    pLcl->lpGbl->wHeight                = (WORD) pSurfaceGlobal->wHeight;
    pLcl->ddsCaps                       = pSurfaceLocal->ddsCaps;
    pLcl->lpSurfMore->ddsCapsEx         = pSurfaceMore->ddsCapsEx;
    pLcl->lpSurfMore->dwSurfaceHandle   = pSurfaceMore->dwSurfaceHandle;
    pLcl->lpSurfMore->lpDD_lcl          = pDDrawLocal;
    pLcl->dwFlags                       = pSurfaceLocal->dwFlags;

    pLcl->lpGbl->fpVidMem               = (FLATPTR) pCreateSurface->pSList[index].pbPixels;
    pLcl->lpGbl->lPitch                 = pCreateSurface->pSList[index].iPitch;

    if ((pCreateSurface->Type == D3DRTYPE_VOLUME) ||
        (pCreateSurface->Type == D3DRTYPE_VOLUMETEXTURE))
    {
        pLcl->lpGbl->lSlicePitch = pCreateSurface->pSList[index].iSlicePitch;
    }

    return pLcl;
}


void
SwDDICreateSurfaceEx(LPDDRAWI_DIRECTDRAW_LCL pDrv,
                     LPDDRAWI_DDRAWSURFACE_LCL pLcl)
{
    PD3D8_SWCALLBACKS       pCallbacks = (PD3D8_SWCALLBACKS)pDrv->lpGbl->lpDDCBtmp;
    DDHAL_CREATESURFACEEXDATA   CreateExData;

    if ((pLcl != NULL) &&
        (pCallbacks->CreateSurfaceEx != NULL))
    {
        CreateExData.dwFlags = 0;
        CreateExData.lpDDLcl = pDrv;
        CreateExData.lpDDSLcl = pLcl;

        pCallbacks->CreateSurfaceEx(&CreateExData);
    }
}


HRESULT
SwDDICreateSurface(PD3D8_CREATESURFACEDATA pCreateSurface,
                    DD_SURFACE_LOCAL* pDDSurfaceLocal,
                    DD_SURFACE_GLOBAL* pDDSurfaceGlobal,
                    DD_SURFACE_MORE*  pDDSurfaceMore)
{
    LPDDRAWI_DIRECTDRAW_LCL pDrv =
        ((PDDDEVICEHANDLE)pCreateSurface->hDD)->pDD;
    DDHAL_CREATESURFACEDATA CreateSurfaceData;
    PD3D8_SWCALLBACKS pCallbacks =
        (PD3D8_SWCALLBACKS)pDrv->lpGbl->lpDDCBtmp;
    DWORD dwRet = DDHAL_DRIVER_NOTHANDLED;
    DDSURFACEDESC2 SurfaceDesc;
    DWORD i;


    if (pCallbacks->CreateSurface)
    {
        memset(&CreateSurfaceData, 0, sizeof(CreateSurfaceData));
        CreateSurfaceData.lpDD = pDrv->lpGbl;
        CreateSurfaceData.lpDDSurfaceDesc = (DDSURFACEDESC*) &SurfaceDesc;
        CreateSurfaceData.lplpSList = NULL;
        CreateSurfaceData.dwSCnt = pCreateSurface->dwSCnt;
        CreateSurfaceData.lplpSList = (LPDDRAWI_DDRAWSURFACE_LCL*)
            MemAlloc(sizeof(LPDDRAWI_DDRAWSURFACE_LCL) * CreateSurfaceData.dwSCnt);
        if (CreateSurfaceData.lplpSList == NULL)
        {
            return E_OUTOFMEMORY;
        }

        // Build a surface desc

        RtlZeroMemory(&SurfaceDesc, sizeof(SurfaceDesc));
        SurfaceDesc.dwSize = sizeof(SurfaceDesc);
        SurfaceDesc.ddsCaps.dwCaps = pDDSurfaceLocal[0].ddsCaps.dwCaps;
        SurfaceDesc.ddpfPixelFormat = pDDSurfaceGlobal[0].ddpfSurface;
        if (pCreateSurface->Type == D3DRTYPE_TEXTURE)
        {
            SurfaceDesc.dwMipMapCount = pCreateSurface->dwSCnt;
        }
        else if (pCreateSurface->dwSCnt > 1)
        {
            SurfaceDesc.dwBackBufferCount = pCreateSurface->dwSCnt - 1;
            SurfaceDesc.dwFlags |= DDSD_BACKBUFFERCOUNT;
        }
        SurfaceDesc.dwHeight = pDDSurfaceGlobal[0].wHeight;
        SurfaceDesc.dwWidth = pDDSurfaceGlobal[0].wWidth;
        SurfaceDesc.dwFlags |= DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH;
        if (pDDSurfaceLocal[0].dwFlags & DDRAWISURF_HASPIXELFORMAT)
        {
            SurfaceDesc.dwFlags |= DDSD_PIXELFORMAT;
        }
        if (pCreateSurface->Type == D3DRTYPE_VERTEXBUFFER)
        {
            SurfaceDesc.dwFVF = pCreateSurface->dwFVF;
            SurfaceDesc.dwFlags |= DDSD_FVF;
        }

        // Have to build a heavy weight surface structure that the driver
        // can understand

        for (i = 0; i < CreateSurfaceData.dwSCnt; i++)
        {
            CreateSurfaceData.lplpSList[i] =
                ((PDDSURFHANDLE)pCreateSurface->pSList[i].hKernelHandle)->pLcl;
        }

        dwRet = pCallbacks->CreateSurface(&CreateSurfaceData);

        // Now copy the fpVidMem and the pitch that the driver setup
        // back to the permanent structures

        for (i = 0; i < CreateSurfaceData.dwSCnt; i++)
        {
            pCreateSurface->pSList[i].pbPixels = (BYTE*)
                CreateSurfaceData.lplpSList[i]->lpGbl->fpVidMem;
            pCreateSurface->pSList[i].iPitch =
                CreateSurfaceData.lplpSList[i]->lpGbl->lPitch;

            if ((pCreateSurface->Type == D3DRTYPE_VOLUME) ||
                (pCreateSurface->Type == D3DRTYPE_VOLUMETEXTURE))
            {
                pCreateSurface->pSList[i].iSlicePitch =
                    CreateSurfaceData.lplpSList[i]->lpGbl->lSlicePitch;
            }

        }

        // Now clean everything up

        MemFree(CreateSurfaceData.lplpSList);

        if (dwRet == DDHAL_DRIVER_NOTHANDLED)
        {
            DPF_ERR("Software Driver failed creation of surface");
            return E_FAIL;
        }
        return CreateSurfaceData.ddRVal;
    }
    else
    {
        DPF_ERR("Software Driver doesn't support creation of surfaces");
        return DDERR_UNSUPPORTED;
    }
}

void
SwDDIAttachSurfaces(LPDDRAWI_DDRAWSURFACE_LCL psurf_from_lcl, LPDDRAWI_DDRAWSURFACE_LCL psurf_to_lcl)
{
    LPATTACHLIST    pal_from;
    LPATTACHLIST    pal_to;

    /*
     * allocate attachment structures
     */
    pal_from = & (((SWDDIDDRAWI_LCL*) psurf_to_lcl)->From);
    pal_to = & (((SWDDIDDRAWI_LCL*) psurf_to_lcl)->To);

    /*
     * connect the surfaces
     */
    pal_from->lpAttached = psurf_to_lcl;
    pal_from->dwFlags = DDAL_IMPLICIT;
    pal_from->lpLink = psurf_from_lcl->lpAttachList;
    psurf_from_lcl->lpAttachList = pal_from;
    psurf_from_lcl->dwFlags |= DDRAWISURF_ATTACHED;

    pal_to->lpAttached = psurf_from_lcl;
    pal_to->dwFlags = DDAL_IMPLICIT;
    pal_to->lpLink = psurf_to_lcl->lpAttachListFrom;
    psurf_to_lcl->lpAttachListFrom = pal_to;
    psurf_to_lcl->dwFlags |= DDRAWISURF_ATTACHED_FROM;

}


DWORD WINAPI
SwContextCreate(PD3D8_CONTEXTCREATEDATA pCreateContext)
{
    LPDDRAWI_DIRECTDRAW_LCL pDrv = ((PDDDEVICEHANDLE)pCreateContext->hDD)->pDD;
    PD3D8_SWCALLBACKS   pCallbacks = (PD3D8_SWCALLBACKS)pDrv->lpGbl->lpDDCBtmp;
    D3DHAL_CONTEXTCREATEDATA    ContextData;

    DWORD dwRet = DDHAL_DRIVER_NOTHANDLED;
    if (pCallbacks->CreateContext != NULL)
    {
        ContextData.lpDDLcl = pDrv;
        ContextData.lpDDSLcl = ((PDDSURFHANDLE)pCreateContext->hSurface)->pLcl;
        if (pCreateContext->hDDSZ == NULL)
        {
            ContextData.lpDDSZLcl = NULL;
        }
        else
        {
            ContextData.lpDDSZLcl = ((PDDSURFHANDLE)pCreateContext->hDDSZ)->pLcl;
        }
        ContextData.dwPID = pCreateContext->dwPID;
        ContextData.dwhContext = pCreateContext->dwhContext;

        dwRet = pCallbacks->CreateContext(&ContextData);

        pCreateContext->dwhContext = ContextData.dwhContext;
        pCreateContext->ddrval = MapLegacyResult(ContextData.ddrval);
    }

    return dwRet;
}


DWORD WINAPI
SwDrawPrimitives2(PD3D8_DRAWPRIMITIVES2DATA pdp2data)
{
    LPDDRAWI_DIRECTDRAW_LCL pDrv = ((PDDSURFHANDLE)pdp2data->hDDCommands)->pDevice->pDD;
    PD3D8_SWCALLBACKS       pCallbacks = (PD3D8_SWCALLBACKS)pDrv->lpGbl->lpDDCBtmp;
    D3DHAL_DRAWPRIMITIVES2DATA  DP2Data;
    HRESULT                 hr;
    DWORD                   dwRet;

    dwRet = DDHAL_DRIVER_NOTHANDLED;
    if (pCallbacks->DrawPrimitives2 != NULL)
    {
        memcpy(&DP2Data, pdp2data, sizeof(DP2Data));
        DP2Data.lpDDCommands    = ((PDDSURFHANDLE)pdp2data->hDDCommands)->pLcl;
        if (!(DP2Data.dwFlags & D3DHALDP2_USERMEMVERTICES))
        {
            DP2Data.lpDDVertex  = ((PDDSURFHANDLE)pdp2data->hDDVertex)->pLcl;
        }

        dwRet = pCallbacks->DrawPrimitives2(&DP2Data);

        pdp2data->ddrval        = DP2Data.ddrval;
        pdp2data->dwErrorOffset = DP2Data.dwErrorOffset;

        // If the call to the driver succeded, swap the buffers if needed and
        // perform GetAliasVidmem
        if (dwRet == DDHAL_DRIVER_HANDLED && (DP2Data.ddrval == S_OK))
        {
            pdp2data->fpVidMem_CB = 0;
            pdp2data->dwLinearSize_CB = 0;
            pdp2data->fpVidMem_VB = 0;
            pdp2data->dwLinearSize_VB = 0;

            if (DP2Data.dwFlags & D3DHALDP2_SWAPCOMMANDBUFFER)
            {
                // CONSIDER: Implement VidMem command buffer
            }

            if ((DP2Data.dwFlags & D3DHALDP2_SWAPVERTEXBUFFER) && !(DP2Data.dwFlags & D3DHALDP2_USERMEMVERTICES))
            {
                pdp2data->fpVidMem_VB = ((PDDSURFHANDLE)pdp2data->hDDVertex)->fpVidMem;
                pdp2data->dwLinearSize_VB = ((PDDSURFHANDLE)pdp2data->hDDVertex)->dwLinearSize;
            }
        }

    }

    return dwRet;
}


DWORD
SwDDILock(HANDLE hDD, PDDSURFHANDLE   pSurf, DD_LOCKDATA* pLockData)
{
    LPDDRAWI_DIRECTDRAW_LCL pDrv = ((PDDDEVICEHANDLE)hDD)->pDD;
    PD3D8_SWCALLBACKS       pCallbacks = (PD3D8_SWCALLBACKS)pDrv->lpGbl->lpDDCBtmp;
    DDHAL_LOCKDATA          LockData;
    DWORD                   dwRet = DDHAL_DRIVER_HANDLED;

    LockData.lpDD = pDrv->lpGbl;
    LockData.lpDDSurface = pSurf->pLcl;
    LockData.bHasRect = pLockData->bHasRect;
    LockData.rArea = pLockData->rArea;
    LockData.dwFlags = pLockData->dwFlags;
    LockData.ddRVal = DDERR_WASSTILLDRAWING;
    LockData.lpSurfData = NULL;

    pSurf->pLcl->lpGbl->dwUsageCount++;
    while (LockData.ddRVal == DDERR_WASSTILLDRAWING)
    {
        if (pCallbacks->Lock != NULL)
        {
            dwRet = pCallbacks->Lock(&LockData);
        }
        else
        {
            LockData.ddRVal = E_FAIL;
        }
    }
    if (LockData.ddRVal != S_OK)
    {
        pSurf->pLcl->lpGbl->dwUsageCount--;
    }

    pLockData->ddRVal = LockData.ddRVal;
    pLockData->lpSurfData = LockData.lpSurfData;

    return dwRet;
}


DWORD
SwDDIUnlock(HANDLE hDD, PDDSURFHANDLE   pSurf, DD_UNLOCKDATA* pUnlockData)
{
    LPDDRAWI_DIRECTDRAW_LCL pDrv = ((PDDDEVICEHANDLE)hDD)->pDD;
    PD3D8_SWCALLBACKS       pCallbacks = (PD3D8_SWCALLBACKS)pDrv->lpGbl->lpDDCBtmp;
    DDHAL_UNLOCKDATA        UnlockData;
    DWORD                   dwRet = DDHAL_DRIVER_HANDLED;

    UnlockData.lpDD = pDrv->lpGbl;
    UnlockData.lpDDSurface = pSurf->pLcl;
    UnlockData.ddRVal = S_OK;

    pSurf->pLcl->lpGbl->dwUsageCount--;
    if (pCallbacks->Unlock != NULL)
    {
        dwRet = pCallbacks->Unlock(&UnlockData);
    }

    pUnlockData->ddRVal = UnlockData.ddRVal;

    return dwRet;
}

void BreakOutstandingLocks(PDDSURFHANDLE pSurf)
{
    DD_UNLOCKDATA   UnlockData;

    while (pSurf->pLcl->lpGbl->dwUsageCount > 0)
    {
        SwDDIUnlock(pSurf->pDevice, pSurf, &UnlockData);
    }
}


DWORD
SwDDIDestroySurface(HANDLE hDD, PDDSURFHANDLE pSurf)
{
    LPDDRAWI_DIRECTDRAW_LCL pDrv = ((PDDDEVICEHANDLE)hDD)->pDD;
    PD3D8_SWCALLBACKS       pCallbacks = (PD3D8_SWCALLBACKS)pDrv->lpGbl->lpDDCBtmp;
    DDHAL_DESTROYSURFACEDATA DestroyData;

    DestroyData.lpDD = pDrv->lpGbl;
    DestroyData.lpDDSurface = pSurf->pLcl;
    DestroyData.ddRVal = S_OK;

    BreakOutstandingLocks(pSurf);

    if (pCallbacks->DestroySurface != NULL)
    {
        pCallbacks->DestroySurface(&DestroyData);
    }

    return DestroyData.ddRVal;
}


LPDDRAWI_DIRECTDRAW_LCL
SwDDICreateDirectDraw(void)
{
    LPDDRAWI_DIRECTDRAW_LCL pLcl;
    LPDDRAWI_DIRECTDRAW_GBL pGbl;
    BYTE*                   pTemp;

    pLcl = (LPDDRAWI_DIRECTDRAW_LCL)MemAlloc(sizeof(DDRAWI_DIRECTDRAW_LCL) +
        sizeof(DDRAWI_DIRECTDRAW_GBL));
    if (pLcl == NULL)
    {
        return NULL;
    }

    pTemp = (BYTE*)pLcl;
    pTemp += sizeof(DDRAWI_DIRECTDRAW_LCL);
    pGbl = (LPDDRAWI_DIRECTDRAW_GBL) pTemp;
    pLcl->lpGbl = pGbl;

    pLcl->dwLocalRefCnt = 1;
    pGbl->dwRefCnt = 1;

    return pLcl;
}

extern HRESULT WINAPI
D3D8GetSWInfo( D3DCAPS8* pCaps, PD3D8_SWCALLBACKS pCallbacks,
               DWORD* pNumTextures, DDSURFACEDESC** ppTexList );

void
SwDDIMungeCaps(HINSTANCE hLibrary, HANDLE hDD,
                PD3D8_DRIVERCAPS    pDriverCaps,
                PD3D8_CALLBACKS     pCallbacks,
                LPDDSURFACEDESC     pTextureFormats,
                UINT*               pcTextureFormats,
                VOID*               pInitFunction
                )
{
    PD3D8GetSWInfo          pfnGetSWInfo = NULL;
    D3DCAPS8                swCaps;
    D3D8_SWCALLBACKS        swCallbacks;
    LPDDRAWI_DIRECTDRAW_LCL pLcl;
    LPDDRAWI_DIRECTDRAW_GBL pGbl;
    PDDDEVICEHANDLE         pDevice = (PDDDEVICEHANDLE) hDD;
    DWORD                   i;
    DWORD                   NumTex = 0;
    DDSURFACEDESC*          pTexList = NULL;

    // Get the info from the software driver
    memset (&swCaps, 0, sizeof(swCaps));
    memset (&swCallbacks, 0, sizeof(swCallbacks));
    if (hLibrary != NULL)
    {
        pfnGetSWInfo = (PD3D8GetSWInfo)GetProcAddress (hLibrary, D3D8HOOK_GETSWINFOPROCNAME);
    }
    else
    {
        pfnGetSWInfo = (PD3D8GetSWInfo)pInitFunction;
    }

    if ((hLibrary == NULL) && (pDevice->DeviceType == D3DDEVTYPE_REF))
    {
        // No hLibrary means time to fall back on defeatured ref.
        DPF(0,"Could not find d3dref8.dll, loading internal defeatured ReferenceDevice, no rendering will take place\n");
        D3D8GetSWInfo (&swCaps, &swCallbacks, &NumTex, &pTexList);
    }
    else if (pfnGetSWInfo != NULL)
    {
        (*pfnGetSWInfo)(&swCaps, &swCallbacks, &NumTex, &pTexList);
    }
    
    // Fill in out DDraw structure with the info that we have

    pLcl = pDevice->pDD;
    pGbl = pLcl->lpGbl;
    strcpy (pGbl->cDriverName, pDevice->szDeviceName);
    pGbl->vmiData.dwDisplayWidth = pDriverCaps->DisplayWidth;
    pGbl->vmiData.dwDisplayHeight = pDriverCaps->DisplayHeight;
    ConvertToOldFormat(&pGbl->vmiData.ddpfDisplay, pDriverCaps->DisplayFormatWithAlpha);

    // Overwite the hardware caps w/ the software caps
    memcpy (&pDriverCaps->D3DCaps, &swCaps, sizeof(swCaps));
    pDriverCaps->dwFlags |= DDIFLAG_D3DCAPS8;

    // Copy over our texture format list if required.
    *pcTextureFormats = NumTex;
    if (pTextureFormats && pTexList)
    {
        memcpy(
            pTextureFormats,
            pTexList,
            sizeof (*pTexList) * NumTex);
    }


    // Now change the callback table to point to the ones for the SW drivers

    if (swCallbacks.CreateContext == NULL)
    {
        pCallbacks->CreateContext           = NULL;
    }
    else
    {
        pCallbacks->CreateContext           = SwContextCreate;
    }
    pCallbacks->ContextDestroy              = (PD3D8DDI_CONTEXTDESTROY) swCallbacks.ContextDestroy;
    pCallbacks->ContextDestroyAll           = (PD3D8DDI_CONTEXTDESTROYALL) swCallbacks.ContextDestroyAll;
    pCallbacks->RenderState                 = (PD3D8DDI_RENDERSTATE) swCallbacks.RenderState;
    pCallbacks->RenderPrimitive             = (PD3D8DDI_RENDERPRIMITIVE) swCallbacks.RenderPrimitive;
    if (swCallbacks.DrawPrimitives2 == NULL)
    {
        pCallbacks->DrawPrimitives2         = NULL;
    }
    else
    {
        pCallbacks->DrawPrimitives2         = SwDrawPrimitives2;
    }
    pCallbacks->GetDriverState              = (PD3D8DDI_GETDRIVERSTATE) swCallbacks.GetDriverState;
    pCallbacks->ValidateTextureStageState   = (PD3D8DDI_VALIDATETEXTURESTAGESTATE) swCallbacks.ValidateTextureStageState;
    pCallbacks->SceneCapture                = (PD3D8DDI_SCENECAPTURE) swCallbacks.SceneCapture;
    pCallbacks->Clear2                      = (PD3D8DDI_CLEAR2) swCallbacks.Clear2;

    // Save the original software callbacks so we can call the software driver later

    if (pGbl->lpDDCBtmp == NULL)
    {
        pGbl->lpDDCBtmp = (LPDDHAL_CALLBACKS) MemAlloc(sizeof(D3D8_SWCALLBACKS));
    }
    if (pGbl->lpDDCBtmp != NULL)
    {
        memcpy(pGbl->lpDDCBtmp, &swCallbacks, sizeof(swCallbacks));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\texture.hpp ===
#ifndef __TEXTURE_HPP__
#define __TEXTURE_HPP__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       texture.h
 *  Content:    Base class for all texture objects. Texture management is
 *              done at this level.
 *
 *
 ***************************************************************************/

// The mip texture class has all of the functionality of the
// the Base Object class along with some additional state for
// managing LODs.
#include <limits.h>
#include "resource.hpp"
#include "pixel.hpp"

#define __INVALIDPALETTE    USHRT_MAX

class CBaseTexture : public IDirect3DBaseTexture8, public CResource
{
public:
    // Constructor
    CBaseTexture(
        CBaseDevice *pDevice,
        DWORD        cLevels,
        D3DPOOL      UserPool,
        D3DFORMAT    UserFormat,
        REF_TYPE     refType);

    // Function to convert a IDirect3DBaseTexture8 * to
    // a CBaseTexture *.
    static CBaseTexture *SafeCast(IDirect3DBaseTexture8 *pInterface);

    // Returns the format that the user passed in
    D3DFORMAT GetUserFormat() const
    {
        return m_formatUser;
    } // GetUserFormat

    BOOL IsPaletted() const
    {
        DXGASSERT(GetBufferDesc()->Format == GetUserFormat());
        return CPixel::IsPaletted(GetUserFormat());
    }

    // Returns the current palette
    DWORD GetPalette() const
    {
        DXGASSERT(GetBufferDesc()->Format == GetUserFormat());
        DXGASSERT(CPixel::IsPaletted(GetUserFormat()));
        return m_Palette;
    } // GetPalette

    // Set the current palette
    void SetPalette(DWORD Palette)
    {
        DXGASSERT(GetBufferDesc()->Format == GetUserFormat());
#if DBG
        if(Palette != __INVALIDPALETTE)
        {
            DXGASSERT(CPixel::IsPaletted(GetUserFormat()));
        }
#endif
        DXGASSERT(Palette <= USHRT_MAX);
        m_Palette = (WORD)Palette;
    } // SetPalette

    // Return current LOD
    DWORD GetLODI() const
    {
        return m_LOD;
    }

    // Sets current LOD (but doesn't actually do any work)
    DWORD SetLODI(DWORD LOD)
    {
        DXGASSERT(LOD <= UCHAR_MAX);
        DWORD oldLOD = m_LOD;
        m_LOD = (BYTE)LOD;
        return oldLOD;
    }

    // Method for UpdateTexture to call; does type-specific
    // parameter checking before calling UpdateDirtyPortion
    virtual HRESULT UpdateTexture(CBaseTexture *pTextureTarget) PURE;

    // Parameter validation method to make sure that no part of
    // the texture is locked.
#ifdef DEBUG
    virtual BOOL IsTextureLocked() PURE;
#endif  // DEBUG

#ifdef DEBUG
    // DPF helper for explaining why lock failed
    void ReportWhyLockFailed(void) const;
#else  // !DEBUG
    void ReportWhyLockFailed(void) const
    {
        // Do Nothing In Retail
    } // ReportWhyLockFailed
#endif // !DEBUG

protected:

    // Remember the format that the user passed in
    D3DFORMAT   m_formatUser;

    // Currently all textures have a number of levels;
    // If that changes, then we should create a derived
    // class CMipTexture and move this data member there.
    BYTE        m_cLevels;

    // Contains the current LOD for D3D managed textures
    BYTE        m_LOD;

    // Currently set palette (valid only if format is paletted)
    WORD        m_Palette;

    // Level Count accessor
    DWORD GetLevelCountImpl() const
    {
        return m_cLevels;
    }; // GetLevelCountImpl

    // Function to verify external parameters
    // to various texture create APIs
    static HRESULT Validate(CBaseDevice       *pDevice,
                            D3DRESOURCETYPE    Type,
                            D3DPOOL            Pool,
                            DWORD              Usage,
                            D3DFORMAT          Format);

    // Infer usage flags based on external parameters
    // (All inferences MUST be device-independent.)
    static DWORD InferUsageFlags(D3DPOOL            Pool,
                                 DWORD              Usage,
                                 D3DFORMAT          Format);

    // Helper to check if TexBlt is support on this
    // device for this texture
    BOOL CanTexBlt(CBaseTexture *pDestTexture) const;

    // Helper function to scale a Rect down by some
    // number of powers of two; useful for figuring out
    // what part of mip-sub-levels to copy
    static void ScaleRectDown(RECT *pRect, UINT PowersOfTwo = 1);

    // Box version for volumes
    static void ScaleBoxDown(D3DBOX *pBox, UINT PowersOfTwo = 1);

    // Compute Levels for the user
    static UINT ComputeLevels(UINT width, UINT height = 0, UINT depth = 0);

    // Common implementation for Set/Get LOD.
    DWORD SetLODImpl(DWORD LOD);
    DWORD GetLODImpl();

private:

    // Textures overload this to call OnTextureDestroy on the
    // Device before calling Sync.
    virtual void OnDestroy(void);

}; // class CBaseTexture


#undef DPF_MODNAME
#define DPF_MODNAME "CBaseTexture::CBaseTexture"


// Inlines
inline CBaseTexture::CBaseTexture(
    CBaseDevice *pDevice,
    DWORD        cLevels,
    D3DPOOL      UserPool,
    D3DFORMAT    UserFormat,
    REF_TYPE     refType)
    :
    CResource(pDevice, UserPool, refType),
    m_cLevels((BYTE)cLevels),
    m_Palette(__INVALIDPALETTE),
    m_formatUser(UserFormat)
{
    DXGASSERT(cLevels > 0 && cLevels < 256);
}; // CBaseTexture::CBaseTexture


#undef DPF_MODNAME
#define DPF_MODNAME "CBaseTexture::SafeCast"

// Function to convert a IDirect3DBaseTexture8 * to
// a CBaseTexture *. Classes that expose IDirect3DBaseTexture8
// must list CBaseTexture FIRST and IDirect3DFoo8*
// SECOND in their list of inheritances. (The Foo8 interface
// must itself inherit from IDirect3DBaseTexture8*.
inline CBaseTexture * CBaseTexture::SafeCast(IDirect3DBaseTexture8 *pInterface)
{
    if (pInterface == NULL)
        return NULL;

    // Textures must by law obey certain layout rules. In
    // particular the CBaseTexture object must reside precisely
    // before the IDirect3DBaseTexture8 interface
    BYTE *pbInt = reinterpret_cast<BYTE *>(pInterface);
    CBaseTexture *pTex = reinterpret_cast<CBaseTexture *>(pbInt - sizeof(CBaseTexture));
    return pTex;
} // CBaseTexture::SafeCast


#undef DPF_MODNAME
#define DPF_MODNAME "CBaseTexture::ScaleRectDown"

// We round down on for left and top; and we round up for
// right and bottom
inline void CBaseTexture::ScaleRectDown(RECT *pRect, UINT PowersOfTwo)
{
    DXGASSERT(PowersOfTwo > 0);
    DXGASSERT(PowersOfTwo < 32);
    DXGASSERT(pRect->right > 0);
    DXGASSERT(pRect->bottom > 0);
    DXGASSERT(pRect->left < pRect->right);
    DXGASSERT(pRect->top < pRect->bottom);
    DXGASSERT(pRect->left >= 0);
    DXGASSERT(pRect->top >= 0);

    // Rounding down is automatic with the shift operator
    pRect->left >>= PowersOfTwo;
    pRect->top  >>= PowersOfTwo;

    if (pRect->right & ((1 << PowersOfTwo) - 1))
    {
        pRect->right >>= PowersOfTwo;
        pRect->right++;
    }
    else
    {
        pRect->right >>= PowersOfTwo;
    }

    if (pRect->bottom & ((1 << PowersOfTwo) - 1))
    {
        pRect->bottom >>= PowersOfTwo;
        pRect->bottom++;
    }
    else
    {
        pRect->bottom >>= PowersOfTwo;
    }

    return;
} // CBaseTexture::ScaleRectDown

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseTexture::ScaleBoxDown"

inline void CBaseTexture::ScaleBoxDown(D3DBOX *pBox, UINT PowersOfTwo)
{
    DXGASSERT(pBox);
    DXGASSERT(pBox->Front < pBox->Back);
    DXGASSERT(pBox->Back > 0);

    ScaleRectDown((RECT*)pBox, PowersOfTwo);

    // Rounding down is automatic with the shift operator
    pBox->Front >>= PowersOfTwo;
    if (pBox->Back & ((1 << PowersOfTwo) - 1))
    {
        pBox->Back >>= PowersOfTwo;
        pBox->Back++;
    }
    else
    {
        pBox->Back >>= PowersOfTwo;
    }

} // CBaseTexture::ScaleBoxDown

#undef DPF_MODNAME
#define DPF_MODNAME "CBaseTexture::ComputeLevels"

inline UINT CBaseTexture::ComputeLevels(UINT width,
                                        UINT height, // = 0,
                                        UINT depth  // = 0
                                        )
{
    UINT maxEdge = max(width, height);
    maxEdge = max(maxEdge, depth);

    UINT cLevels = 0;
    while (maxEdge)
    {
        cLevels++;

        // D3D rule is that sizes round down always
        maxEdge >>= 1;
    }

    return cLevels;
} // CBaseTexture::ComputeLevels

#endif // __TEXTURE_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\volume.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       volume.cpp
 *  Content:    Implementation of the CVolume and CDriverVolumne classes
 *
 *
 ***************************************************************************/

#include "ddrawpr.h"
#include "volume.hpp"

// IUnknown methods

#undef DPF_MODNAME
#define DPF_MODNAME "CVolume::QueryInterface"

STDMETHODIMP CVolume::QueryInterface (REFIID       riid, 
                                      VOID       **ppvObj)
{
    API_ENTER(Device());

    if (!VALID_PTR_PTR(ppvObj))
    {
        DPF_ERR("Invalid ppvObj parameter to QueryInterface for a level of a VolumeTexture");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_PTR(&riid, sizeof(GUID)))
    {
        DPF_ERR("Invalid guid memory address to QueryInterface for a level of a VolumeTexture");
        return D3DERR_INVALIDCALL;
    }


    if (riid == IID_IDirect3DVolume8  ||
        riid == IID_IUnknown)
    {
        *ppvObj = static_cast<void*>(static_cast<IDirect3DVolume8 *>(this));
        AddRef();
        return S_OK;
    }

    DPF_ERR("Unsupported Interface identifier passed to QueryInterface for a level of a VolumeTexture");

    // Null out param
    *ppvObj = NULL;
    return E_NOINTERFACE;
} // QueryInterface

#undef DPF_MODNAME
#define DPF_MODNAME "CVolume::AddRef"

STDMETHODIMP_(ULONG) CVolume::AddRef()
{
    API_ENTER_NO_LOCK(Device());   
    
#ifdef DEBUG
    m_cRefDebug++;
#endif // DEBUG
    return m_pParent->AddRefImpl();
} // AddRef

#undef DPF_MODNAME
#define DPF_MODNAME "CVolume::Release"

STDMETHODIMP_(ULONG) CVolume::Release()
{
    API_ENTER_SUBOBJECT_RELEASE(Device());   
    
#ifdef DEBUG
    m_cRefDebug--;
    if (m_cRefDebug & 0x80000000)
    {
        DPF_ERR("A level of a mip-volume has been released more often than it has been add-ref'ed! Danger!!");
    }
#endif // DEBUG
    return m_pParent->ReleaseImpl();
} // Release

// IBuffer methods

#undef DPF_MODNAME
#define DPF_MODNAME "CVolume::SetPrivateData"

STDMETHODIMP CVolume::SetPrivateData(REFGUID riid, 
                                     CONST VOID   *pvData, 
                                     DWORD   cbData, 
                                     DWORD   dwFlags)
{
    API_ENTER(Device());

    return m_pParent->SetPrivateDataImpl(riid, 
                                         pvData, 
                                         cbData, 
                                         dwFlags, 
                                         m_iLevel);
} // SetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CVolume::GetPrivateData"

STDMETHODIMP CVolume::GetPrivateData(REFGUID riid, 
                                     VOID   *pvData, 
                                     DWORD  *pcbData)
{
    API_ENTER(Device());

    return m_pParent->GetPrivateDataImpl(riid,
                                         pvData,
                                         pcbData,
                                         m_iLevel);

} // GetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CVolume::FreePrivateData"

STDMETHODIMP CVolume::FreePrivateData(REFGUID riid)
{
    API_ENTER(Device());

    return m_pParent->FreePrivateDataImpl(riid,
                                          m_iLevel);
} // FreePrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CVolume::GetContainer"

STDMETHODIMP CVolume::GetContainer(REFIID riid, 
                                   void **ppContainer)
{
    API_ENTER(Device());

    return m_pParent->QueryInterface(riid, ppContainer);
} // OpenContainer

#undef DPF_MODNAME
#define DPF_MODNAME "CVolume::GetDevice"

STDMETHODIMP CVolume::GetDevice(IDirect3DDevice8 **ppDevice)
{
    API_ENTER(Device());

    return m_pParent->GetDevice(ppDevice);
} // OpenDevice

// IDirect3DVolume8 methods

#undef DPF_MODNAME
#define DPF_MODNAME "CVolume::GetDesc"

STDMETHODIMP CVolume::GetDesc(D3DVOLUME_DESC *pDesc)
{
    API_ENTER(Device());

    // If parameters are bad, then we should fail some stuff
    if (!VALID_WRITEPTR(pDesc, sizeof(D3DVOLUME_DESC)))
    {
        DPF_ERR("bad pointer for pDesc passed to GetDesc for a level of a VolumeTexture");
        return D3DERR_INVALIDCALL;
    }

    // We basically get our volume desc from our parent
    // and then modify the width, height, and depth fields.
    *pDesc = *m_pParent->Desc();

    pDesc->Width  >>= m_iLevel;
    pDesc->Height >>= m_iLevel;
    pDesc->Depth  >>= m_iLevel;

    if (pDesc->Width == 0)
    {
        pDesc->Width = 1;
    }
    if (pDesc->Height == 0)
    {
        pDesc->Height = 1;
    }
    if (pDesc->Depth == 0)
    {
        pDesc->Depth = 1;
    }

    // Also need to modify the type field
    pDesc->Type   = D3DRTYPE_VOLUME;

    // Also modify the size field
    pDesc->Size = CPixel::ComputeVolumeSize(pDesc->Width, 
                                            pDesc->Height, 
                                            pDesc->Depth,
                                            pDesc->Format);

    // We also need to modify the pool and format
    // to reflect the data the user passed to us
    pDesc->Pool   = m_pParent->GetUserPool();
    pDesc->Format = m_pParent->GetUserFormat();
    pDesc->Usage &= D3DUSAGE_EXTERNAL;

    // We're done
    return S_OK;
} // GetDesc

#undef DPF_MODNAME
#define DPF_MODNAME "CVolume::LockBox"

STDMETHODIMP CVolume::LockBox(D3DLOCKED_BOX *pLockedBoxData, 
                              CONST D3DBOX  *pBox, 
                              DWORD          dwFlags)
{   
    API_ENTER(Device());

    // If parameters are bad, then we should fail some stuff
    if (!VALID_WRITEPTR(pLockedBoxData, sizeof(D3DLOCKED_BOX)))
    {
        DPF_ERR("bad pointer for pLockedBoxData passed to LockBox for a level of a VolumeTexture");
        return D3DERR_INVALIDCALL;
    }

    // Zero out returned data 
    ZeroMemory(pLockedBoxData, sizeof(D3DLOCKED_BOX));

    // Validate Box
    if (pBox != NULL)
    {
        DWORD Width  = m_pParent->Desc()->Width  >> m_iLevel;
        DWORD Height = m_pParent->Desc()->Height >> m_iLevel;
        DWORD Depth  = m_pParent->Desc()->Depth  >> m_iLevel;

        if (!CPixel::IsValidBox(m_pParent->Desc()->Format,
                                Width, 
                                Height,
                                Depth,
                                pBox))
        {
            DPF_ERR("LockBox for a Volume fails");
            return D3DERR_INVALIDCALL;
        }
    }

    if (dwFlags & ~D3DLOCK_VOL_VALID)
    {
        if (dwFlags & D3DLOCK_DISCARD)
        {
            if (dwFlags & D3DLOCK_READONLY)
            {
                DPF_ERR("D3DLOCK_READONLY is not allowed with D3DLOCK_DISCARD");
                return D3DERR_INVALIDCALL;
            }
            if (!(m_pParent->Desc()->Usage & D3DUSAGE_DYNAMIC))
            {
                DPF_ERR("D3DLOCK_DISCARD is allowed only with dynamic textures");
                return D3DERR_INVALIDCALL;
            }
            if (m_iLevel > 0)
            {
                DPF_ERR("D3DLOCK_DISCARD is allowed only on level 0"
                        " (the top mip level). DISCARD in this case will discard"
                        " the entire volume.");
                return D3DERR_INVALIDCALL;
            }
            if (pBox != NULL)
            {
                DPF_ERR("Subboxes not allowed with D3DLOCK_DISCARD");
                return D3DERR_INVALIDCALL;
            }
        }
        else
        {
            DPF_ERR("Invalid dwFlags parameter passed to LockBox for a level of a VolumeTexture");
            DPF_EXPLAIN_BAD_LOCK_FLAGS(0, dwFlags & ~D3DLOCK_VOL_VALID);
            return D3DERR_INVALIDCALL;
        }
    }

    if (!m_isLockable)
    {
        m_pParent->ReportWhyLockFailed();
        return D3DERR_INVALIDCALL;
    }
    
    return InternalLockBox(pLockedBoxData, pBox, dwFlags);
} // LockBox

#undef DPF_MODNAME
#define DPF_MODNAME "CVolume::InternalLockBox"

HRESULT CVolume::InternalLockBox(D3DLOCKED_BOX *pLockedBoxData, 
                                 CONST D3DBOX  *pBox, 
                                 DWORD          dwFlags)
{
    // Only one lock outstanding at a time is supported
    if (IsLocked())
    {
        DPF_ERR("LockBox failed on a mip level; volume was already locked.");
        return D3DERR_INVALIDCALL;
    }

    // Notify the parent/device if we are about to be modified
    if ( (m_pParent->GetUserPool() != D3DPOOL_SCRATCH) && (!(dwFlags & D3DLOCK_READONLY)) )
    {
        m_pParent->OnVolumeLock(m_iLevel, pBox, dwFlags);
    }

    // Figure out our stride/pointer to bits
    m_pParent->ComputeMipVolumeOffset(m_iLevel, 
                                      pBox,
                                      pLockedBoxData);

    // Mark ourselves as locked
    m_isLocked = TRUE;

    // Done
    return S_OK;
} // InternalLockBox

#undef DPF_MODNAME
#define DPF_MODNAME "CVolume::UnlockBox"

STDMETHODIMP CVolume::UnlockBox()
{
    API_ENTER(Device());

    // If we aren't locked; then something is wrong
    if (!IsLocked())
    {
        DPF_ERR("UnlockBox failed on a volume level; volume wasn't locked.");
        return D3DERR_INVALIDCALL;
    }
    DXGASSERT(m_isLockable);
    return InternalUnlockBox();
} // UnlockBox

#undef DPF_MODNAME
#define DPF_MODNAME "CVolume::InternalUnlockBox"

HRESULT CVolume::InternalUnlockBox()
{
    // Clear our locked state
    m_isLocked = FALSE;

    // If we are lock-once; then we mark ourselves as not lockable
    if (m_pParent->Desc()->Usage & D3DUSAGE_LOADONCE)
    {
        m_isLockable = FALSE;
    }

    // Done
    return S_OK;
} // InternalUnlockBox

//
// CDriverVolume class modifies the implementation
// of the LockBox and UnlockBox methods of the CVolume class
//

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverVolume::LockBox"

STDMETHODIMP CDriverVolume::LockBox(D3DLOCKED_BOX *pLockedBoxData, 
                                    CONST D3DBOX  *pBox, 
                                    DWORD          dwFlags)
{   
    API_ENTER(Device());

    // If parameters are bad, then we should fail some stuff
    if (!VALID_WRITEPTR(pLockedBoxData, sizeof(D3DLOCKED_BOX)))
    {
        DPF_ERR("bad pointer for pLockedBoxData passed to LockBox for a level of a VolumeTexture");
        return D3DERR_INVALIDCALL;
    }

    // Zero out returned data 
    ZeroMemory(pLockedBoxData, sizeof(D3DLOCKED_BOX));

    // Validate Box
    if (pBox != NULL)
    {
        DWORD Width  = m_pParent->Desc()->Width  >> m_iLevel;
        DWORD Height = m_pParent->Desc()->Height >> m_iLevel;
        DWORD Depth  = m_pParent->Desc()->Depth  >> m_iLevel;

        if (!CPixel::IsValidBox(m_pParent->Desc()->Format,
                                 Width, 
                                 Height,
                                 Depth,
                                 pBox))
        {
            DPF_ERR("LockBox for a Volume fails");
            return D3DERR_INVALIDCALL;
        }
    }

    if (dwFlags & ~D3DLOCK_VOL_VALID)
    {
        if (dwFlags & D3DLOCK_DISCARD)
        {
            if (dwFlags & D3DLOCK_READONLY)
            {
                DPF_ERR("D3DLOCK_READONLY is not allowed with D3DLOCK_DISCARD");
                return D3DERR_INVALIDCALL;
            }
            if (!(m_pParent->Desc()->Usage & D3DUSAGE_DYNAMIC))
            {
                DPF_ERR("D3DLOCK_DISCARD is allowed only with dynamic textures");
                return D3DERR_INVALIDCALL;
            }
            if (m_iLevel > 0)
            {
                DPF_ERR("D3DLOCK_DISCARD is allowed only on level 0"
                        " (the top mip level). DISCARD in this case will discard"
                        " the entire volume.");
                return D3DERR_INVALIDCALL;
            }
            if (pBox != NULL)
            {
                DPF_ERR("Subboxes not allowed with D3DLOCK_DISCARD");
                return D3DERR_INVALIDCALL;
            }
        }
        else
        {
            DPF_ERR("Invalid dwFlags parameter passed to LockBox for a level of a VolumeTexture");
            DPF_EXPLAIN_BAD_LOCK_FLAGS(0, dwFlags & ~D3DLOCK_VOL_VALID);
            return D3DERR_INVALIDCALL;
        }
    }

    if (!m_isLockable)
    {
        m_pParent->ReportWhyLockFailed();
        return D3DERR_INVALIDCALL;
    }
    return InternalLockBox(pLockedBoxData, pBox, dwFlags);
} // CDriverVolume::LockBox

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverVolume::InternalLockBox"

HRESULT CDriverVolume::InternalLockBox(D3DLOCKED_BOX *pLockedBoxData, 
                                       CONST D3DBOX  *pBox, 
                                       DWORD          dwFlags)
{
    // Only one lock outstanding at a time is supported
    if (IsLocked())
    {
        DPF_ERR("LockBox failed on a volume level; volume was already locked.");
        return D3DERR_INVALIDCALL;
    }

    // Notify the parent/device if we are about to be accessed.
    // Driver volume textures may be written to by HW through 
    // UpdateTexture. So we may need to sync with the current
    // command batch.
    m_pParent->OnVolumeLock(m_iLevel, pBox, dwFlags);

    // Prepare a LockData structure for the HAL call
    D3D8_LOCKDATA lockData;
    ZeroMemory(&lockData, sizeof lockData);

    lockData.hDD        = m_pParent->Device()->GetHandle();
    lockData.hSurface   = m_hKernelHandle;
    lockData.dwFlags    = dwFlags;
    if (pBox != NULL)
    {
        lockData.bHasBox = TRUE;
        lockData.box     = *pBox;
    }
    
    HRESULT hr = m_pParent->Device()->GetHalCallbacks()->Lock(&lockData);
    if (FAILED(hr))
    {
        DPF_ERR("Failed to lock level of a driver volume");
        return hr;
    }

    // Fill in the Locked_Box fields 
    D3DFORMAT Format = m_pParent->Desc()->Format;

    if (CPixel::IsDXT(Format))
    {
        // Start with our current width/height
        DWORD     Width  = m_pParent->Desc()->Width  >> m_iLevel;
        DWORD     Height = m_pParent->Desc()->Height >> m_iLevel;
   
        // Convert to blocks
        Width  = Width  / 4;
        Height = Height / 4;

        // At least one block
        if (Width == 0)
            Width = 1;
        if (Height == 0)
            Height = 1;

        switch (Format)
        {
            // For linear formats, 
            // Row Pitch is a row of blocks; and SlicePitch is for
            // a plane of blocks.

        case D3DFMT_DXT1:
            // DXT1 is 8 bytes per block
            pLockedBoxData->RowPitch    = Width  * 8;
            pLockedBoxData->SlicePitch  = Height * pLockedBoxData->RowPitch;
            break;

        case D3DFMT_DXT2:
        case D3DFMT_DXT3:
        case D3DFMT_DXT4:
        case D3DFMT_DXT5:
            // DXT2-5 are 16 bytes per block
            pLockedBoxData->RowPitch    = Width  * 16;
            pLockedBoxData->SlicePitch  = Height * pLockedBoxData->RowPitch;
            break;

#ifdef VOLUME_DXT
        case D3DFMT_DXV1:
            // DXV1 is 32-bytes per block
            pLockedBoxData->RowPitch    = Width  * 32;
            pLockedBoxData->SlicePitch  = Height * pLockedBoxData->RowPitch;
            break;

        case D3DFMT_DXV2:
        case D3DFMT_DXV3:
        case D3DFMT_DXV4:
        case D3DFMT_DXV5:
            // DXV2-5 are 64-bytes per block
            pLockedBoxData->RowPitch    = Width  * 64;
            pLockedBoxData->SlicePitch  = Height * pLockedBoxData->RowPitch;
            break;
#endif //VOLUME_DXT

        default:
            DPF_ERR("Unknown DXT format?");
            DXGASSERT(FALSE);
        }
    }
    else
    {
        // For all other formats, just return what
        // the driver gave us
        pLockedBoxData->RowPitch    = lockData.lPitch;
        pLockedBoxData->SlicePitch  = lockData.lSlicePitch;
    }


    pLockedBoxData->pBits       = lockData.lpSurfData;

#ifdef DEBUG
    if ((dwFlags & D3DLOCK_DISCARD))
    {
        DXGASSERT(m_iLevel == 0);
        if (!CPixel::IsFourCC(Format) &&
            !CPixel::IsIHVFormat(Format))
        {
            DXGASSERT(pBox == NULL);
            memset(pLockedBoxData->pBits, 0xDD, pLockedBoxData->SlicePitch * m_pParent->Desc()->Depth);
            for (UINT i = 1; i < m_pParent->GetLevelCount(); ++i)
            {
                D3DLOCKED_BOX Box;
                HRESULT hr = m_pParent->LockBox(i, &Box, NULL, 0);
                if (FAILED(hr))
                {
                    DPF(1, "Lock to mipsublevel failed. Not good.");
                    break;
                }
                D3DVOLUME_DESC LevelDesc;
                m_pParent->GetLevelDesc(i, &LevelDesc);
                memset(Box.pBits, 0xDD, Box.SlicePitch * LevelDesc.Depth);
                m_pParent->UnlockBox(i);
            }
        }
    }
#endif // DEBUG

    // Mark ourselves as locked
    m_isLocked = TRUE;

    // Done
    return S_OK;
} // CDriverVolume::InternalLockBox

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverVolume::UnlockBox"

STDMETHODIMP CDriverVolume::UnlockBox()
{
    API_ENTER(Device());

    // If we aren't locked; then something is wrong
    if (!IsLocked())
    {
        DPF_ERR("UnlockBox failed on a mip level; volume wasn't locked.");
        return D3DERR_INVALIDCALL;
    }

    DXGASSERT(m_isLockable);
    return InternalUnlockBox();
} // CDriverVolume::UnlockBox

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverVolume::InternalUnlockBox"

HRESULT CDriverVolume::InternalUnlockBox()
{
    // Call the driver to perform the unlock
    D3D8_UNLOCKDATA unlockData = {
        m_pParent->Device()->GetHandle(),
        m_hKernelHandle
    };

    HRESULT hr = m_pParent->Device()->GetHalCallbacks()->Unlock(&unlockData);
    if (FAILED(hr))
    {
        DPF_ERR("Driver volume failed to unlock");
        return hr;
    }

    // Clear our locked state
    m_isLocked = FALSE;

    // If we are lock-once; then we mark ourselves as not lockable
    if (m_pParent->Desc()->Usage & D3DUSAGE_LOADONCE)
    {
        m_isLockable = FALSE;
    }

    // Done
    return S_OK;
} // CDriverVolume::InternalUnlockBox


// End of file : volume.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\vbuffer.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       vbuffer.cpp
 *  Content:    Implementation of the CVertexBuffer class.
 *
 *
 ***************************************************************************/
#include "ddrawpr.h"
#include "d3di.hpp"
#include "ddi.h"
#include "drawprim.hpp"
#include "vbuffer.hpp"
#include "resource.inl"

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::Create"

// Static class function for creating a VertexBuffer object.
// (Because it is static; it doesn't have a this pointer.)
//
// We do all parameter checking here to reduce the overhead
// in the constructor which is called by the internal Clone
// method which is used by resource management as part of the
// performance critical download operation.

// Creation function for Vertex Buffers
HRESULT CVertexBuffer::Create(CBaseDevice        *pDevice,
                              DWORD               cbLength,
                              DWORD               Usage,
                              DWORD               dwFVF,
                              D3DPOOL             Pool,
                              REF_TYPE            refType,
                              IDirect3DVertexBuffer8 **ppVertexBuffer)
{
    HRESULT hr;

    // Do parameter checking here
    if (!VALID_PTR_PTR(ppVertexBuffer))
    {
        DPF_ERR("Bad parameter passed for ppVertexBuffer for creating a vertex buffer");
        return D3DERR_INVALIDCALL;
    }

    // Zero-out return parameter
    *ppVertexBuffer = NULL;

    if (cbLength == 0)
    {
        DPF_ERR("Vertex buffer cannot be of zero size");
        return D3DERR_INVALIDCALL;
    }

    if (Pool != D3DPOOL_DEFAULT && Pool != D3DPOOL_MANAGED && Pool != D3DPOOL_SYSTEMMEM)
    {
        DPF_ERR("Vertex buffer pool should be default, managed or sysmem");
        return D3DERR_INVALIDCALL;
    }

    // Usage flag allowed for only mixed mode or software device
    if ((Usage & D3DUSAGE_SOFTWAREPROCESSING) != 0 && 
        (pDevice->BehaviorFlags() & D3DCREATE_MIXED_VERTEXPROCESSING) == 0 &&
        (pDevice->BehaviorFlags() & D3DCREATE_SOFTWARE_VERTEXPROCESSING) == 0)
    {
        DPF_ERR("D3DUSAGE_SOFTWAREPROCESSING can be set only when device is mixed or software mode. CreateVertexBuffer fails.");
        return D3DERR_INVALIDCALL;
    }

    // USAGE_DYNAMIC not allowed with management
    if ((Usage & D3DUSAGE_DYNAMIC) != 0 && Pool == D3DPOOL_MANAGED)
    {
        DPF_ERR("D3DUSAGE_DYNAMIC cannot be used with managed vertex buffers");
        return D3DERR_INVALIDCALL;
    }

    // Validate FVF
    if (dwFVF != 0 && cbLength < ComputeVertexSizeFVF(dwFVF))
    {
        DPF_ERR("Vertex buffer size needs to enough to hold one vertex");
        return D3DERR_INVALIDCALL;
    }

    D3DPOOL ActualPool = Pool;
    DWORD ActualUsage = Usage;

    // Infer Lock from absence of LoadOnce
    if (!(Usage & D3DUSAGE_LOADONCE))
    {
        ActualUsage |= D3DUSAGE_LOCK;
    }

    // On a mixed device, POOL_SYSTEMMEM means the same as D3DUSAGE_SOFTWAREPROCESSING
    if ((pDevice->BehaviorFlags() & D3DCREATE_MIXED_VERTEXPROCESSING) != 0 &&
        Pool == D3DPOOL_SYSTEMMEM)
    {
        ActualUsage |= D3DUSAGE_SOFTWAREPROCESSING;
    }

    /*
     * Put a VB in system memory if the following conditions are TRUE
     * 1. (USAGE_SOFTWAREPROCESSING is set indicating app. wants to use software pipeline or if it is a software device) except if the vertices are pre-clipped TLVERTEX
     * 2. USAGE_POINTS is set and we might do emulation of point sprites except if it is a managed VB on a mixed device
     * 3. The driver does not support vidmem VBs
     * 4. Usage NPathes and driver does not support NPatches
     */
    if (!pDevice->DriverSupportsVidmemVBs())
    {
        ActualPool = D3DPOOL_SYSTEMMEM; // We don't set D3DUSAGE_SOFTWAREPROCESSING to ensure proper validation in fe code
    }
    if (((pDevice->BehaviorFlags() & D3DCREATE_SOFTWARE_VERTEXPROCESSING) != 0 || (ActualUsage & D3DUSAGE_SOFTWAREPROCESSING) != 0) &&
        !((dwFVF & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW && (ActualUsage & D3DUSAGE_DONOTCLIP) != 0))
    {
        if((ActualUsage & D3DUSAGE_INTERNALBUFFER) == 0)
        {
            if ((pDevice->BehaviorFlags() & D3DCREATE_SOFTWARE_VERTEXPROCESSING) != 0 ||
                ActualPool == D3DPOOL_DEFAULT)
            {
                ActualPool = D3DPOOL_SYSTEMMEM; // For software processing, pool can be only sysmem (POOLMANAGED is overwritten)
            }
            ActualUsage |= D3DUSAGE_SOFTWAREPROCESSING;
        }
    }
    if ((ActualUsage & D3DUSAGE_NPATCHES) != 0 &&
        (pDevice->GetD3DCaps()->DevCaps & D3DDEVCAPS_NPATCHES) == 0)
    {
        ActualPool = D3DPOOL_SYSTEMMEM;
        ActualUsage |= D3DUSAGE_SOFTWAREPROCESSING;
    }

    if ((ActualUsage & D3DUSAGE_POINTS) != 0 &&
        (static_cast<LPD3DBASE>(pDevice)->m_dwRuntimeFlags & D3DRT_DOPOINTSPRITEEMULATION) != 0)
    {
        if ((pDevice->BehaviorFlags() & D3DCREATE_SOFTWARE_VERTEXPROCESSING) != 0 ||
            ActualPool == D3DPOOL_DEFAULT)
        {
            ActualPool = D3DPOOL_SYSTEMMEM; // For software processing, pool can be only sysmem (POOLMANAGED is overwritten)
        }
        ActualUsage |= D3DUSAGE_SOFTWAREPROCESSING;
    }

    CVertexBuffer *pVertexBuffer;

    if (ActualPool == D3DPOOL_SYSTEMMEM ||
        IsTypeD3DManaged(pDevice, D3DRTYPE_VERTEXBUFFER, ActualPool))
    {
        hr = CreateSysmemVertexBuffer(pDevice,
                                      cbLength,
                                      dwFVF,
                                      Usage,
                                      ActualUsage,
                                      Pool,
                                      ActualPool,
                                      refType,
                                      &pVertexBuffer);
    }
    else
    {
        if (IsTypeDriverManaged(pDevice, D3DRTYPE_VERTEXBUFFER, ActualPool))
        {
            // If the vertex buffer is driver managed, but the usage is softwareprocessing, then
            // we turn off writeonly since the fe pipe WILL read from the sysmem backup (which
            // actually lives in the driver). It follows that when a driver manages a VB/IB without
            // writeonly, it MUST have a sysmem backup. (snene - 12/00)
            if ((ActualUsage & D3DUSAGE_SOFTWAREPROCESSING) != 0)
            {
                ActualUsage &= ~D3DUSAGE_WRITEONLY;
            }
            hr = CreateDriverManagedVertexBuffer(pDevice,
                                                 cbLength,
                                                 dwFVF,
                                                 Usage,
                                                 ActualUsage,
                                                 Pool,
                                                 ActualPool,
                                                 refType,
                                                 &pVertexBuffer);
            // Driver managed vertex buffer creates can NEVER fail, except for catastrophic reasons so
            // we don't fallback to sysmem. Even if we do fallback to sysmem here, there is no way
            // deferred creates are going to fallback, so no point.
            if (FAILED(hr))
            {
                return hr;
            }
        }
        else
        {
            hr = CreateDriverVertexBuffer(pDevice,
                                          cbLength,
                                          dwFVF,
                                          Usage,
                                          ActualUsage,
                                          Pool,
                                          ActualPool,
                                          refType,
                                          &pVertexBuffer);
        }
        if (FAILED(hr) && (hr != D3DERR_OUTOFVIDEOMEMORY || (ActualUsage & D3DUSAGE_INTERNALBUFFER) != 0))
        {
            if (hr == D3DERR_OUTOFVIDEOMEMORY)
            {
                DPF(2, "Out of video memory creating internal buffer");
            }
            if (pDevice->VBFailOversDisabled())
            {
                DPF_ERR("Cannot create Vidmem or Driver managed vertex buffer. Will ***NOT*** failover to Sysmem.");
                return hr;
            }
            ActualPool = D3DPOOL_SYSTEMMEM;
            hr = CreateSysmemVertexBuffer(pDevice,
                                          cbLength,
                                          dwFVF,
                                          Usage,
                                          ActualUsage,
                                          Pool,
                                          ActualPool,
                                          refType,
                                          &pVertexBuffer);
        }
    }

    if (FAILED(hr))
    {
        return hr;
    }

    // We're done; just return the object
    *ppVertexBuffer = pVertexBuffer;

    return hr;
} // static Create

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::CreateDriverVertexBuffer"

HRESULT CVertexBuffer::CreateDriverVertexBuffer(CBaseDevice *pDevice,
                                                DWORD        cbLength,
                                                DWORD        dwFVF,
                                                DWORD        Usage,
                                                DWORD        ActualUsage,
                                                D3DPOOL      Pool,
                                                D3DPOOL      ActualPool,
                                                REF_TYPE     refType,
                                                CVertexBuffer **pVB)
{
    HRESULT hr;
    CDriverVertexBuffer *pVertexBuffer;

    // Zero out return
    *pVB = 0;

    if((pDevice->BehaviorFlags() & D3DCREATE_MULTITHREADED) != 0)
    {
        pVertexBuffer = new CDriverVertexBufferMT(pDevice,
                                                  cbLength,
                                                  dwFVF,
                                                  Usage,
                                                  ActualUsage,
                                                  Pool,
                                                  ActualPool,
                                                  refType,
                                                  &hr);
    }
    else
    {
        pVertexBuffer = new CDriverVertexBuffer(pDevice,
                                                cbLength,
                                                dwFVF,
                                                Usage,
                                                ActualUsage,
                                                Pool,
                                                ActualPool,
                                                refType,
                                                &hr);
    }
    if (pVertexBuffer == 0)
    {
        DPF_ERR("Out of Memory creating vertex buffer");
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr))
    {
        if (refType == REF_EXTERNAL)
        {
            // External objects get released
            pVertexBuffer->Release();
        }
        else
        {
            // Internal and intrinsic objects get decremented
            DXGASSERT(refType == REF_INTERNAL || refType == REF_INTRINSIC);
            pVertexBuffer->DecrementUseCount();
        }
        return hr;
    }

    *pVB = static_cast<CVertexBuffer*>(pVertexBuffer);

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::CreateSysmemVertexBuffer"

HRESULT CVertexBuffer::CreateSysmemVertexBuffer(CBaseDevice *pDevice,
                                                DWORD        cbLength,
                                                DWORD        dwFVF,
                                                DWORD        Usage,
                                                DWORD        ActualUsage,
                                                D3DPOOL      Pool,
                                                D3DPOOL      ActualPool,
                                                REF_TYPE     refType,
                                                CVertexBuffer **pVB)
{
    HRESULT hr;
    CVertexBuffer *pVertexBuffer;

    // Zero out return
    *pVB = 0;

    if((pDevice->BehaviorFlags() & D3DCREATE_MULTITHREADED) != 0)
    {
        pVertexBuffer = new CVertexBufferMT(pDevice,
                                            cbLength,
                                            dwFVF,
                                            Usage,
                                            ActualUsage,
                                            Pool,
                                            ActualPool,
                                            refType,
                                            &hr);
    }
    else
    {
        pVertexBuffer = new CVertexBuffer(pDevice,
                                          cbLength,
                                          dwFVF,
                                          Usage,
                                          ActualUsage,
                                          Pool,
                                          ActualPool,
                                          refType,
                                          &hr);
    }
    if (pVertexBuffer == 0)
    {
        DPF_ERR("Out of Memory creating vertex buffer");
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr))
    {
        if (refType == REF_EXTERNAL)
        {
            // External objects get released
            pVertexBuffer->Release();
        }
        else
        {
            // Internal and intrinsic objects get decremented
            DXGASSERT(refType == REF_INTERNAL || refType == REF_INTRINSIC);
            pVertexBuffer->DecrementUseCount();
        }
        return hr;
    }

    *pVB = pVertexBuffer;

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::CreateDriverManagedVertexBuffer"

HRESULT CVertexBuffer::CreateDriverManagedVertexBuffer(CBaseDevice *pDevice,
                                                       DWORD        cbLength,
                                                       DWORD        dwFVF,
                                                       DWORD        Usage,
                                                       DWORD        ActualUsage,
                                                       D3DPOOL      Pool,
                                                       D3DPOOL      ActualPool,
                                                       REF_TYPE     refType,
                                                       CVertexBuffer **pVB)
{
    HRESULT hr;
    CDriverManagedVertexBuffer *pVertexBuffer;

    // Zero out return
    *pVB = 0;

    if((pDevice->BehaviorFlags() & D3DCREATE_MULTITHREADED) != 0)
    {
        pVertexBuffer = new CDriverManagedVertexBufferMT(pDevice,
                                                         cbLength,
                                                         dwFVF,
                                                         Usage,
                                                         ActualUsage,
                                                         Pool,
                                                         ActualPool,
                                                         refType,
                                                         &hr);
    }
    else
    {
        pVertexBuffer = new CDriverManagedVertexBuffer(pDevice,
                                                       cbLength,
                                                       dwFVF,
                                                       Usage,
                                                       ActualUsage,
                                                       Pool,
                                                       ActualPool,
                                                       refType,
                                                       &hr);
    }
    if (pVertexBuffer == 0)
    {
        DPF_ERR("Out of Memory creating vertex buffer");
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr))
    {
        if (refType == REF_EXTERNAL)
        {
            // External objects get released
            pVertexBuffer->Release();
        }
        else
        {
            // Internal and intrinsic objects get decremented
            DXGASSERT(refType == REF_INTERNAL || refType == REF_INTRINSIC);
            pVertexBuffer->DecrementUseCount();
        }
        return hr;
    }

    *pVB = static_cast<CVertexBuffer*>(pVertexBuffer);

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::CVertexBuffer"

// Constructor the CVertexBuffer class
CVertexBuffer::CVertexBuffer(CBaseDevice *pDevice,
                             DWORD        cbLength,
                             DWORD        dwFVF,
                             DWORD        Usage,
                             DWORD        ActualUsage,
                             D3DPOOL      Pool,
                             D3DPOOL      ActualPool,
                             REF_TYPE     refType,
                             HRESULT     *phr
                             ) :
    CBuffer(pDevice,
            cbLength,
            dwFVF,
            D3DFMT_VERTEXDATA,
            D3DRTYPE_VERTEXBUFFER,
            Usage,              // UserUsage
            ActualUsage,
            Pool,               // UserPool
            ActualPool,
            refType,
            phr)
{
    if (FAILED(*phr))
        return;

    // Initialize basic structures
    m_desc.Format        = D3DFMT_VERTEXDATA;
    m_desc.Pool          = ActualPool;
    m_desc.Usage         = ActualUsage;
    m_desc.Type          = D3DRTYPE_VERTEXBUFFER;
    m_desc.Size          = cbLength;
    m_desc.FVF           = dwFVF;
    m_usageUser          = Usage;

    if (dwFVF != 0)
    {
        m_vertsize       = ComputeVertexSizeFVF(dwFVF);
        DXGASSERT(m_vertsize != 0);
        m_numverts       = cbLength / m_vertsize;
    }
    else
    {
        m_vertsize       = 0;
        m_numverts       = 0;
    }

    m_pClipCodes         = 0;

    // If this is a D3D managed buffer then we need
    // to tell the Resource Manager to remember us. This has to happen
    // at the very end of the constructor so that the important data
    // members are built up correctly
    if (CResource::IsTypeD3DManaged(Device(), D3DRTYPE_VERTEXBUFFER, ActualPool))
    {
        *phr = InitializeRMHandle();
    }
} // CVertexBuffer::CVertexBuffer

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::Clone"
HRESULT CVertexBuffer::Clone(D3DPOOL     Pool,
                             CResource **ppResource) const
{
    HRESULT hr;
    CVertexBuffer *pVertexBuffer;
    // Note: we treat clones the same as internal; because
    // they are owned by the resource manager which
    // is owned by the device.
    hr = CreateDriverVertexBuffer(Device(),
                                  m_desc.Size,
                                  m_desc.FVF,
                                  m_desc.Usage,
                                  (m_desc.Usage | D3DUSAGE_WRITEONLY) & ~D3DUSAGE_SOFTWAREPROCESSING, // never seen by API!
                                  Pool,
                                  Pool, // never seen by API!
                                  REF_INTERNAL,
                                  &pVertexBuffer);
    *ppResource = static_cast<CResource*>(pVertexBuffer);
    return hr;
} // CVertexBuffer::Clone


#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::GetBufferDesc"
const D3DBUFFER_DESC* CVertexBuffer::GetBufferDesc() const
{
    return (const D3DBUFFER_DESC*)&m_desc;
} // CVertexBuffer::GetBufferDesc

// IUnknown methods
#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::QueryInterface"

STDMETHODIMP CVertexBuffer::QueryInterface(REFIID riid,
                                           LPVOID FAR * ppvObj)
{
    API_ENTER(Device());

    if (!VALID_PTR_PTR(ppvObj))
    {
        DPF_ERR("Invalid ppvObj parameter passed to CVertexBuffer::QueryInterface");
        return D3DERR_INVALIDCALL;
    }

    if (!VALID_PTR(&riid, sizeof(GUID)))
    {
        DPF_ERR("Invalid guid memory address to QueryInterface for VertexBuffer");
        return D3DERR_INVALIDCALL;
    }

    if (riid == IID_IDirect3DVertexBuffer8  ||
        riid == IID_IDirect3DResource8      ||
        riid == IID_IUnknown)
    {
        *ppvObj = static_cast<void*>(static_cast<IDirect3DVertexBuffer8 *>(this));
        AddRef();
        return S_OK;
    }

    DPF_ERR("Unsupported Interface identifier passed to QueryInterface for VertexBuffer");

    // Null out param
    *ppvObj = NULL;
    return E_NOINTERFACE;
} // QueryInterface

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::AddRef"

STDMETHODIMP_(ULONG) CVertexBuffer::AddRef()
{
    API_ENTER_NO_LOCK(Device());

    return AddRefImpl();
} // AddRef

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::Release"

STDMETHODIMP_(ULONG) CVertexBuffer::Release()
{
    API_ENTER_SUBOBJECT_RELEASE(Device());

    return ReleaseImpl();
} // Release

// IDirect3DResource methods

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::GetDevice"

STDMETHODIMP CVertexBuffer::GetDevice(IDirect3DDevice8 ** ppObj)
{
    API_ENTER(Device());

    return GetDeviceImpl(ppObj);
} // GetDevice

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::SetPrivateData"

STDMETHODIMP CVertexBuffer::SetPrivateData(REFGUID riid,
                                           CONST VOID* pvData,
                                           DWORD cbData,
                                           DWORD dwFlags)
{
    API_ENTER(Device());

    // We use level zero for our data
    return SetPrivateDataImpl(riid, pvData, cbData, dwFlags, 0);
} // SetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::GetPrivateData"

STDMETHODIMP CVertexBuffer::GetPrivateData(REFGUID riid,
                                           LPVOID pvData,
                                           LPDWORD pcbData)
{
    API_ENTER(Device());

    // We use level zero for our data
    return GetPrivateDataImpl(riid, pvData, pcbData, 0);
} // GetPrivateData

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::FreePrivateData"

STDMETHODIMP CVertexBuffer::FreePrivateData(REFGUID riid)
{
    API_ENTER(Device());

    // We use level zero for our data
    return FreePrivateDataImpl(riid, 0);
} // FreePrivateData


#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::GetPriority"

STDMETHODIMP_(DWORD) CVertexBuffer::GetPriority()
{
    API_ENTER_RET(Device(), DWORD);

    return GetPriorityImpl();
} // GetPriority

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::SetPriority"

STDMETHODIMP_(DWORD) CVertexBuffer::SetPriority(DWORD dwPriority)
{
    API_ENTER_RET(Device(), DWORD);

    return SetPriorityImpl(dwPriority);
} // SetPriority

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::PreLoad"

STDMETHODIMP_(void) CVertexBuffer::PreLoad(void)
{
    API_ENTER_VOID(Device());

    PreLoadImpl();
    return;
} // PreLoad

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::GetType"
STDMETHODIMP_(D3DRESOURCETYPE) CVertexBuffer::GetType(void)
{
    API_ENTER_RET(Device(), D3DRESOURCETYPE);

    return m_desc.Type;
} // GetType

// Vertex Buffer Methods
#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::GetDesc"

STDMETHODIMP CVertexBuffer::GetDesc(D3DVERTEXBUFFER_DESC *pDesc)
{
    API_ENTER(Device());

    if (!VALID_WRITEPTR(pDesc, sizeof(D3DVERTEXBUFFER_DESC)))
    {
        DPF_ERR("bad pointer for pDesc passed to GetDesc for VertexBuffer");
        return D3DERR_INVALIDCALL;
    }

    *pDesc = m_desc;

    // Need to return pool/usage that the user specified
    pDesc->Pool    = GetUserPool();
    pDesc->Usage   = m_usageUser;

    return S_OK;
} // GetDesc

#if DBG
#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::ValidateLockParams"
HRESULT CVertexBuffer::ValidateLockParams(UINT cbOffsetToLock,
                                          UINT SizeToLock,
                                          BYTE **ppbData,
                                          DWORD dwFlags) const
{
    if (!VALID_PTR_PTR(ppbData))
    {
        DPF_ERR("Bad parameter passed for ppbData for locking a vertexbuffer");
        return D3DERR_INVALIDCALL;
    }

    if ((cbOffsetToLock != 0) && (SizeToLock == 0))
    {
        DPF_ERR("Cannot lock zero bytes. Vertex Buffer Lock fails.");
        return D3DERR_INVALIDCALL;
    }

    if (dwFlags & ~(D3DLOCK_VALID & ~D3DLOCK_NO_DIRTY_UPDATE)) // D3DLOCK_NO_DIRTY_UPDATE not valid for VBs
    {
        DPF_ERR("Invalid flags specified. Vertex Buffer Lock fails.");
        return D3DERR_INVALIDCALL;
    }

    // Can it be locked?
    if (!m_isLockable)
    {
        DPF_ERR("Vertex buffer with D3DUSAGE_LOADONCE can only be locked once");
        return D3DERR_INVALIDCALL;
    }
    if ((dwFlags & (D3DLOCK_DISCARD | D3DLOCK_NOOVERWRITE)) != 0 && (m_usageUser & D3DUSAGE_DYNAMIC) == 0)
    {
        DPF_ERR("Can specify D3DLOCK_DISCARD or D3DLOCK_NOOVERWRITE for only Vertex Buffers created with D3DUSAGE_DYNAMIC");
        return D3DERR_INVALIDCALL;
    }
    if ((dwFlags & (D3DLOCK_READONLY | D3DLOCK_DISCARD)) == (D3DLOCK_READONLY | D3DLOCK_DISCARD))
    {
        DPF_ERR("Should not specify D3DLOCK_DISCARD along with D3DLOCK_READONLY. Vertex Buffer Lock fails.");
        return D3DERR_INVALIDCALL;
    }
    if ((dwFlags & D3DLOCK_READONLY) != 0 && (m_usageUser & D3DUSAGE_WRITEONLY) != 0)
    {
        DPF_ERR("Cannot do READ_ONLY lock on a WRITE_ONLY buffer. Vertex Buffer Lock fails.");
        return D3DERR_INVALIDCALL;
    }

    if (ULONGLONG(cbOffsetToLock) + ULONGLONG(SizeToLock) > ULONGLONG(m_desc.Size))
    {
        DPF_ERR("Lock failed: Locked area exceeds size of buffer. Vertex Buffer Lock fails.");
        return D3DERR_INVALIDCALL;
    }

    if (m_LockCount == 0)
    {
        if ((m_usageUser & D3DUSAGE_DYNAMIC) == 0)
        {
            if (static_cast<CD3DBase*>(Device())->m_SceneStamp == m_SceneStamp &&
                (m_usageUser & D3DUSAGE_WRITEONLY) != 0 &&
                GetUserPool() != D3DPOOL_SYSTEMMEM)
            {
                DPF(1, "Static vertex buffer locked more than once per frame. Could have severe performance penalty.");
            }
            ((CVertexBuffer*)this)->m_SceneStamp = static_cast<CD3DBase*>(Device())->m_SceneStamp;
        }
        else
        {
            if ((dwFlags & (D3DLOCK_DISCARD | D3DLOCK_NOOVERWRITE)) == 0)
            {
                if (m_TimesLocked > 0 &&
                    (m_usageUser & D3DUSAGE_WRITEONLY) != 0 &&
                    GetUserPool() != D3DPOOL_SYSTEMMEM)
                {
                    DPF(3, "Dynamic vertex buffer locked twice or more in a row without D3DLOCK_NOOVERWRITE or D3DLOCK_DISCARD. Could have severe performance penalty.");
                }
                ++(((CVertexBuffer*)this)->m_TimesLocked);
            }
            else
            {
                ((CVertexBuffer*)this)->m_TimesLocked = 0;
            }
        }
    }

    DXGASSERT(m_LockCount < 0x80000000);

    return S_OK;
} // ValidateLockParams
#endif //DBG

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::Lock"

STDMETHODIMP CVertexBuffer::Lock(UINT cbOffsetToLock,
                                 UINT SizeToLock,
                                 BYTE **ppbData,
                                 DWORD dwFlags)
{
    // We do not take the API lock here since the MT class will take it for
    // a multithreaded device. For a non-multithreaded device, there is no
    // MT class nor do we bother to take the API lock. We still need to 
    // call API_ENTER_NO_LOCK_HR however for validation of the THIS pointer in
    // Debug builds
    API_ENTER_NO_LOCK_HR(Device()); 

#if DBG
    HRESULT hr = ValidateLockParams(cbOffsetToLock, SizeToLock, ppbData, dwFlags);
    if (FAILED(hr))
    {
        return hr;
    }
#endif // DBG

    // Sanity check
#if DBG
    if (m_LockCount != 0)
    {
        DXGASSERT(GetPrivateDataPointer() != 0);
    }
#endif // DBG

    // Increment our lock count
    ++m_LockCount;

    if ((dwFlags & (D3DLOCK_READONLY | D3DLOCK_NOOVERWRITE)) == 0 && m_LockCount == 1) // for repeat locks, no syncing
    {
        Sync(); // Sync with device command queue
    }

    LockImpl(cbOffsetToLock,
             SizeToLock,
             ppbData,
             dwFlags,
             m_desc.Size);

    return S_OK;
} // Lock

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::Unlock"

STDMETHODIMP CVertexBuffer::Unlock()
{
    // We do not take the API lock here since the MT class will take it for
    // a multithreaded device. For a non-multithreaded device, there is no
    // MT class nor do we bother to take the API lock. We still need to 
    // call API_ENTER_NO_LOCK however for validation of the THIS pointer in
    // Debug builds
    API_ENTER_NO_LOCK_HR(Device()); 

#if DBG
    // If we aren't locked; then something is wrong
    if (m_LockCount == 0)
    {
        DPF_ERR("Unlock failed on a buffer; vertex buffer wasn't locked.");
        return D3DERR_INVALIDCALL;
    }
#endif // DBG

    // Decrement our lock count
    --m_LockCount;

#if DBG
    if ((m_usageUser & D3DUSAGE_LOADONCE) != 0 && m_LockCount == 0)
    {
        m_isLockable = FALSE;
    }
#endif // DBG

    return S_OK;
} // Unlock

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::AllocateClipCodes"

void CVertexBuffer::AllocateClipCodes()
{
    if (m_pClipCodes == 0)
    {
        DXGASSERT(m_numverts != 0);
        m_pClipCodes = new WORD[m_numverts];
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CVertexBuffer::UpdateDirtyPortion"

HRESULT CVertexBuffer::UpdateDirtyPortion(CResource *pResourceTarget)
{
    if (IsDirty())
    {
        if (Device()->CanBufBlt())
        {
            D3DRANGE range;
            if(m_cbDirtyMin == 0 && m_cbDirtyMax == 0)
            {
                range.Offset = 0;
                range.Size = m_desc.Size;
            }
            else
            {
                range.Offset = m_cbDirtyMin;
                range.Size = m_cbDirtyMax - m_cbDirtyMin;
            }
            HRESULT hr = static_cast<LPD3DBASE>(Device())->BufBlt(static_cast<CBuffer*>(pResourceTarget), this, m_cbDirtyMin, &range);
            if (FAILED(hr))
            {
                DPF_ERR("Failed to copy vertex buffer");
                return hr;
            }
        }
        else
        {
            DXGASSERT(pResourceTarget->GetBufferDesc()->Pool == D3DPOOL_DEFAULT); // make sure that it is safe to assume that this is a driver VB
            CDriverVertexBuffer *pBufferTarget = static_cast<CDriverVertexBuffer *>(pResourceTarget);

            DXGASSERT((pBufferTarget->m_desc.Usage & D3DUSAGE_DYNAMIC) == 0); // Target can never be dynamic
            DXGASSERT(pBufferTarget->m_pbData == 0); // Target can never be locked

            HRESULT hr = pBufferTarget->LockI(D3DLOCK_NOSYSLOCK);
            if (FAILED(hr))
            {
                DPF_ERR("Failed to lock driver vertex buffer");
                return hr;
            }
            DXGASSERT(pBufferTarget->m_pbData != 0);

            if(m_cbDirtyMin == 0 && m_cbDirtyMax == 0)
            {
                memcpy(pBufferTarget->m_pbData, GetPrivateDataPointer(), m_desc.Size);
            }
            else
            {
                memcpy(pBufferTarget->m_pbData + m_cbDirtyMin, GetPrivateDataPointer() + m_cbDirtyMin, m_cbDirtyMax - m_cbDirtyMin);
            }

            hr = pBufferTarget->UnlockI();
            if (FAILED(hr))
            {
                DPF_ERR("Failed to unlock driver vertex buffer");
                return hr;
            }

            DXGASSERT(pBufferTarget->m_pbData == 0); // Target must be unlocked
        }

        // Mark ourselves as all clean now.
        OnResourceClean();
    }

    return S_OK;
} // CVertexBuffer::UpdateDirtyPortion

//=============================================
// Methods for the CDriverVertexBuffer class
//=============================================
#undef DPF_MODNAME
#define DPF_MODNAME "CDriverVertexBuffer::CDriverVertexBuffer"
CDriverVertexBuffer::CDriverVertexBuffer(CBaseDevice *pDevice,
                                         DWORD        cbLength,
                                         DWORD        dwFVF,
                                         DWORD        Usage,
                                         DWORD        ActualUsage,
                                         D3DPOOL      Pool,
                                         D3DPOOL      ActualPool,
                                         REF_TYPE     refType,
                                         HRESULT     *phr
                                         ) :
    CVertexBuffer(pDevice,
                  cbLength,
                  dwFVF,
                  Usage,
                  ActualUsage,
                  Pool,
                  ActualPool,
                  refType,
                  phr),
    m_pbData(0)
{
    if (FAILED(*phr))
    {
        // We want to allow drivers to fail creation of driver vbs. In this
        // case we will fail-over to system memory. However, if we
        // DPF an error here, it will be misunderstood. So don't DPF.
        return;
    }
} // CDriverVertexBuffer::CDriverVertexBuffer

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverVertexBuffer::~CDriverVertexBuffer"
CDriverVertexBuffer::~CDriverVertexBuffer()
{
    if (m_pbData != 0)
    {
        HRESULT hr = UnlockI();
        if (FAILED(hr))
        {
            DPF_ERR("Failed to unlock driver vertex buffer");
        }
    }
} // CDriverVertexBuffer::~CDriverVertexBuffer

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverVertexBuffer::LockI"
HRESULT CDriverVertexBuffer::LockI(DWORD dwFlags)
{
    // We sync first to make sure that the
    // driver has already processed any data that
    // it needs. LockI only gets called if for
    // cases where we need the interlock i.e.
    // not readonly and not nooverwrite.
    Sync();

    // Prepare a LockData structure for the HAL call
    D3D8_LOCKDATA lockData;
    ZeroMemory(&lockData, sizeof lockData);

    lockData.hDD = Device()->GetHandle();
    lockData.hSurface = BaseKernelHandle();
    lockData.bHasRange = FALSE;
    lockData.dwFlags = dwFlags;

    HRESULT hr = Device()->GetHalCallbacks()->Lock(&lockData);
    if (FAILED(hr))
    {
        DPF_ERR("Failed to lock driver vertex buffer");
    }

    // Return value
    m_pbData = (BYTE*)lockData.lpSurfData;

    return hr;
} // LockI

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverVertexBuffer::UnlockI"
HRESULT CDriverVertexBuffer::UnlockI()
{
    // It is sometimes possible for the pre-DX8 DDI FlushStates to call
    // Unlock twice. We safely filter this case.
    if (m_pbData == 0)
    {
        DXGASSERT(!IS_DX8HAL_DEVICE(Device()));
        return D3D_OK;
    }

    // Call the driver to perform the unlock
    D3D8_UNLOCKDATA unlockData = {
        Device()->GetHandle(),
        BaseKernelHandle()
    };

    HRESULT hr = Device()->GetHalCallbacks()->Unlock(&unlockData);
    if (FAILED(hr))
    {
        DPF_ERR("Driver vertex buffer failed to unlock");
        return hr;
    }

    m_pbData = 0;

    return hr;
    
} // UnlockI

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverVertexBuffer::Lock"

STDMETHODIMP CDriverVertexBuffer::Lock(UINT cbOffsetToLock,
                                       UINT SizeToLock,
                                       BYTE **ppbData,
                                       DWORD dwFlags)
{
    // We do not take the API lock here since the MT class will take it for
    // a multithreaded device. For a non-multithreaded device, there is no
    // MT class nor do we bother to take the API lock. We still need to 
    // call API_ENTER_NO_LOCK however for validation of the THIS pointer in
    // Debug builds
    API_ENTER_NO_LOCK_HR(Device()); 

    HRESULT hr;
#if DBG
    hr = ValidateLockParams(cbOffsetToLock, SizeToLock, ppbData, dwFlags);
    if (FAILED(hr))
    {
        return hr;
    }
#endif // DBG

// Sanity check
#if DBG
    if (m_LockCount != 0)
    {
        DXGASSERT(m_pbData != 0);
    }
#endif // DBG

    // Increment our lock count
    // This MUST be done first. DO NOT MOVE THIS LINE.
    ++m_LockCount;

    if(((dwFlags & (D3DLOCK_READONLY | D3DLOCK_NOOVERWRITE)) == 0 || m_pbData == 0) && m_LockCount == 1) // Repeat locks need no work
    {
        hr = static_cast<LPD3DBASE>(Device())->m_pDDI->LockVB(this, dwFlags);
        if (FAILED(hr))
        {
            DPF_ERR("Failed to lock driver vertex buffer");
            *ppbData = 0;
            --m_LockCount;
            return hr;
        }
    }

    *ppbData = m_pbData + cbOffsetToLock;

    // Done
    return S_OK;
} // Lock

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverVertexBuffer::Unlock"

STDMETHODIMP CDriverVertexBuffer::Unlock()
{
    // We do not take the API lock here since the MT class will take it for
    // a multithreaded device. For a non-multithreaded device, there is no
    // MT class nor do we bother to take the API lock. We still need to 
    // call API_ENTER_NO_LOCK however for validation of the THIS pointer in
    // Debug builds
    API_ENTER_NO_LOCK_HR(Device()); 

#if DBG
    // If we aren't locked; then something is wrong
    if (m_LockCount == 0)
    {
        DPF_ERR("Unlock failed on a vertex buffer; buffer wasn't locked.");
        return D3DERR_INVALIDCALL;
    }
#endif // DBG

    if ((m_desc.Usage & D3DUSAGE_DYNAMIC) == 0 && m_LockCount == 1) // do work only for the last unlock
    {
        HRESULT hr = static_cast<LPD3DBASE>(Device())->m_pDDI->UnlockVB(this);
        if (FAILED(hr))
        {
            DPF_ERR("Driver failed to unlock vertex buffer");
            return hr;
        }
    }

    // Decrement our lock count
    --m_LockCount;

#if DBG
    if ((m_usageUser & D3DUSAGE_LOADONCE) != 0 && m_LockCount == 0)
    {
        m_isLockable = FALSE;
    }
#endif // DBG

    // Done
    return S_OK;
} // Unlock

//=================================================
// Methods for the CDriverManagedVertexBuffer class
//=================================================
#undef DPF_MODNAME
#define DPF_MODNAME "CDriverManagedVertexBuffer::CDriverManagedVertexBuffer"
CDriverManagedVertexBuffer::CDriverManagedVertexBuffer(CBaseDevice *pDevice,
                                                       DWORD        cbLength,
                                                       DWORD        dwFVF,
                                                       DWORD        Usage,
                                                       DWORD        ActualUsage,
                                                       D3DPOOL      Pool,
                                                       D3DPOOL      ActualPool,
                                                       REF_TYPE     refType,
                                                       HRESULT     *phr
                                                       ) :
    CVertexBuffer(pDevice,
                  cbLength,
                  dwFVF,
                  Usage,
                  ActualUsage,
                  Pool,
                  ActualPool,
                  refType,
                  phr),
    m_pbData(0),
    m_bDriverCalled(FALSE)
{
    if (FAILED(*phr))
        return;
    // If writeonly is not set, we assume that the vertex/index buffer is going
    // to be read from from time to time. Hence, for optimizing the readonly
    // locks, we lock and cache the pointer. (snene - 12/00)
    if ((ActualUsage & D3DUSAGE_WRITEONLY) == 0)
    {        
        *phr = UpdateCachedPointer(pDevice);
        if (FAILED(*phr))
            return;
    }
} // CDriverManagedVertexBuffer::CDriverManagedVertexBuffer

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverManagedVertexBuffer::UpdateCachedPointer"

HRESULT CDriverManagedVertexBuffer::UpdateCachedPointer(CBaseDevice *pDevice)
{
    HRESULT hr;

    // Prepare a LockData structure for the HAL call
    D3D8_LOCKDATA lockData;
    ZeroMemory(&lockData, sizeof lockData);
    
    lockData.hDD = pDevice->GetHandle();
    lockData.hSurface = BaseKernelHandle();
    lockData.bHasRange = FALSE;
    lockData.range.Offset = 0;
    lockData.range.Size = 0;
    lockData.dwFlags = D3DLOCK_READONLY;
    
    hr = pDevice->GetHalCallbacks()->Lock(&lockData);
    if (FAILED(hr))
        return hr;
    
    // Call the driver to perform the unlock
    D3D8_UNLOCKDATA unlockData = {
        pDevice->GetHandle(),
            BaseKernelHandle()
    };
    
    hr = pDevice->GetHalCallbacks()->Unlock(&unlockData);
    if (FAILED(hr))
        return hr;
    
    m_pbData = (BYTE*)lockData.lpSurfData;

    return S_OK;
} // CDriverManagedVertexBuffer::UpdateCachedPointer

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverManagedVertexBuffer::Lock"

STDMETHODIMP CDriverManagedVertexBuffer::Lock(UINT cbOffsetToLock,
                                              UINT SizeToLock,
                                              BYTE **ppbData,
                                              DWORD dwFlags)
{
    // We do not take the API lock here since the MT class will take it for
    // a multithreaded device. For a non-multithreaded device, there is no
    // MT class nor do we bother to take the API lock. We still need to 
    // call API_ENTER_NO_LOCK however for validation of the THIS pointer in
    // Debug builds
    API_ENTER_NO_LOCK_HR(Device()); 

    HRESULT hr = S_OK;
#if DBG
    hr = ValidateLockParams(cbOffsetToLock, SizeToLock, ppbData, dwFlags);
    if (FAILED(hr))
    {
        return hr;
    }
#endif // DBG

    // Increment our lock count
    ++m_LockCount;

    if((dwFlags & D3DLOCK_READONLY) == 0)
    {
        // Sync with device command queue
        Sync();

        // Prepare a LockData structure for the HAL call
        D3D8_LOCKDATA lockData;
        ZeroMemory(&lockData, sizeof lockData);

        lockData.hDD = Device()->GetHandle();
        lockData.hSurface = BaseKernelHandle();
        lockData.bHasRange = (SizeToLock != 0);
        lockData.range.Offset = cbOffsetToLock;
        lockData.range.Size = SizeToLock;
        lockData.dwFlags = dwFlags;

        hr = Device()->GetHalCallbacks()->Lock(&lockData);
        if (FAILED(hr))
        {
            *ppbData = 0;
            DPF_ERR("Failed to lock driver managed vertex buffer");
            return hr;
        }
        else
        {
            // Update cached pointer
            m_pbData = (BYTE*)lockData.lpSurfData - cbOffsetToLock;
            m_bDriverCalled = TRUE;
        }
    }

    *ppbData = m_pbData + cbOffsetToLock;

    return hr;

} // Lock

#undef DPF_MODNAME
#define DPF_MODNAME "CDriverManagedVertexBuffer::Unlock"

STDMETHODIMP CDriverManagedVertexBuffer::Unlock()
{
    // We do not take the API lock here since the MT class will take it for
    // a multithreaded device. For a non-multithreaded device, there is no
    // MT class nor do we bother to take the API lock. We still need to 
    // call API_ENTER_NO_LOCK however for validation of the THIS pointer in
    // Debug builds
    API_ENTER_NO_LOCK_HR(Device()); 

#if DBG
    // If we aren't locked; then something is wrong
    if (m_LockCount == 0)
    {
        DPF_ERR("Unlock failed on a vertex buffer; buffer wasn't locked.");
        return D3DERR_INVALIDCALL;
    }
#endif // DBG

    if (m_bDriverCalled)
    {
        // Call the driver to perform the unlock
        D3D8_UNLOCKDATA unlockData = {
            Device()->GetHandle(),
            BaseKernelHandle()
        };

        HRESULT hr = Device()->GetHalCallbacks()->Unlock(&unlockData);
        if (FAILED(hr))
        {
            DPF_ERR("Driver vertex buffer failed to unlock");
            return hr;
        }

        m_bDriverCalled = FALSE;
    }

    // Decrement our lock count
    --m_LockCount;

#if DBG
    if ((m_usageUser & D3DUSAGE_LOADONCE) != 0 && m_LockCount == 0)
    {
        m_isLockable = FALSE;
    }
#endif // DBG

    return S_OK;
} // Unlock

// End of file : vbuffer.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\volume.hpp ===
#ifndef __VOLUME_HPP__
#define __VOLUME_HPP__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       volume.hpp
 *  Content:    Class header the volume class. This class acts
 *              as a level for the MipVolume class. The base class
 *              assumes a system-memory allocation; while the
 *              Driver sub-class will call the driver for every
 *              lock and unlock operation.
 *
 *
 ***************************************************************************/

// Includes
#include "mipvol.hpp"

//
// Each Volume implements the IDirect3DVolume8 interface. 
// To reduce overhead per level, we have
// put most of the "real" guts of each volume into the MipVolume container 
// class; i.e. most of the methods of the Volume really just end 
// up calling something in the MipVolume object.
//
// The base class implementation assumes a sys-mem allocation.
//


//
// The CVolume class is a special class that
// works solely with the CMipVolume class. Each Volume
// corresponds to a single level of the mip-volume. They are
// not stand-alone COM objects because they share the
// same life-time as their CMipVolume parent.
//
// The CDriverVolume class is declared later in this file
//

class CVolume : public IDirect3DVolume8
{
public:
    // Constructor
    CVolume(CMipVolume *pParent, 
            BYTE        iLevel,
            HANDLE      hKernelHandle
            ) :
        m_pParent(pParent),
        m_isLocked(FALSE),
        m_iLevel(iLevel),
        m_hKernelHandle(hKernelHandle)
    {
        DXGASSERT(pParent);
        DXGASSERT(hKernelHandle || (pParent->GetUserPool() == D3DPOOL_SCRATCH) );
    #ifdef DEBUG
        m_cRefDebug = 0; 
    #endif // DEBUG

        if (m_pParent->Desc()->Usage & 
                (D3DUSAGE_LOCK | D3DUSAGE_LOADONCE))
        {
            m_isLockable = TRUE;
        }
        else
        {   
            m_isLockable = FALSE;
        }

        return;
    } // CVolume

    ~CVolume()
    {
        DXGASSERT(m_cRefDebug == 0); 
        if (m_pParent->GetUserPool() != D3DPOOL_SCRATCH)
        {
            // Tell the thunk layer that we need to
            // be freed.
            DXGASSERT(m_hKernelHandle);

            D3D8_DESTROYSURFACEDATA DestroySurfData;
            DestroySurfData.hDD = m_pParent->Device()->GetHandle();
            DestroySurfData.hSurface = m_hKernelHandle;
            m_pParent->Device()->GetHalCallbacks()->DestroySurface(&DestroySurfData);
        }
#ifdef DEBUG
        else
        {
            DXGASSERT(m_pParent->GetUserPool() == D3DPOOL_SCRATCH);
        }
#endif //DEBUG
    }; // ~CVolume

public:
    // IUnknown methods
    STDMETHOD(QueryInterface) (REFIID   riid, 
                               VOID   **ppvObj);
    STDMETHOD_(ULONG,AddRef) ();
    STDMETHOD_(ULONG,Release) ();

    // IBuffer methods
    STDMETHOD(SetPrivateData)(REFGUID       riid, 
                              CONST VOID   *pvData, 
                              DWORD         cbData, 
                              DWORD         dwFlags);

    STDMETHOD(GetPrivateData)(REFGUID   riid, 
                              VOID     *pvData, 
                              DWORD    *pcbData);

    STDMETHOD(FreePrivateData)(REFGUID  riid);

    STDMETHOD(GetContainer)(REFIID riid, 
                            void **ppContainer);

    STDMETHOD(GetDevice)(IDirect3DDevice8 **ppDevice);

    // IDirect3DVolume8 methods
    STDMETHOD(GetDesc)(D3DVOLUME_DESC *pDesc);

    STDMETHOD(LockBox)(D3DLOCKED_BOX  *pLockedBox, 
                       CONST D3DBOX   *pBox, 
                       DWORD           dwFlags);
    STDMETHOD(UnlockBox)(void);

    virtual HRESULT InternalLockBox(D3DLOCKED_BOX  *pLockedBox, 
                                    CONST D3DBOX   *pBox, 
                                    DWORD           dwFlags);
    virtual HRESULT InternalUnlockBox();

    BOOL IsLocked() const
    {
        return m_isLocked;
    } // IsLocked

protected:
    CMipVolume *m_pParent;
    BOOL        m_isLocked;
    BOOL        m_isLockable;
    BYTE        m_iLevel;

    // We'll need internal handles so that
    // we can communicate call Destroy 
    // and so that CDriverVolume can call
    // Lock/Unlock etc.
    HANDLE      m_hKernelHandle;

    CBaseDevice * Device() const
    {
        return m_pParent->Device();
    } // Device

    // Debugging trick to help spew better
    // information if someone over-releases a volume
    // (Since our ref's carry over to the parent object; it
    // means that over-releases can be hard to find.)
#ifdef DEBUG
    DWORD   m_cRefDebug;
#endif // DEBUG

}; // CVolume

// The CDriverVolume is a modification of the base volume
// class. It overrides lock and unlock and routes the call to the
// driver
class CDriverVolume : public CVolume
{
public:
    // Constructor
    CDriverVolume(CMipVolume *pParent, 
                  BYTE        iLevel,
                  HANDLE      hKernelHandle
                      ) :
        CVolume(pParent, iLevel, hKernelHandle)
    {
    } // CDriverVolume

public:

    STDMETHOD(LockBox)(D3DLOCKED_BOX  *pLockedBox, 
                       CONST D3DBOX   *pBox, 
                       DWORD            dwFlags);
    STDMETHOD(UnlockBox)();

    virtual HRESULT InternalLockBox(D3DLOCKED_BOX  *pLockedBox, 
                                    CONST D3DBOX   *pBox, 
                                    DWORD           dwFlags);
    virtual HRESULT InternalUnlockBox();

}; // CDriverVolume


#endif // __VOLUME_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\vbuffer.hpp ===
#ifndef __VBUFFER_HPP__
#define __VBUFFER_HPP__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       vbuffer.hpp
 *  Content:    Class header the vertex buffer class
 *
 ***************************************************************************/

// Includes
#include "buffer.hpp"

// The base-class implementation of the vertex buffer assumes
// that it is resides system-memory. It may be managed.
class CVertexBuffer : public IDirect3DVertexBuffer8, public CBuffer
{
public:
    // Creation function for Vertex Buffers
    static HRESULT Create(CBaseDevice             *pDevice,
                          DWORD                    cbLength,
                          DWORD                    dwUsage,
                          DWORD                    dwFVF,
                          D3DPOOL                  Pool,
                          REF_TYPE                 refType,
                          IDirect3DVertexBuffer8 **ppVertexBuffer);
    
    static HRESULT CreateSysmemVertexBuffer(CBaseDevice *pDevice,
                                            DWORD        cbLength,
                                            DWORD        dwFVF,
                                            DWORD        dwUsage,
                                            DWORD        dwActualUsage,
                                            D3DPOOL      Pool,
                                            D3DPOOL      ActualPool,
                                            REF_TYPE     refType,
                                            CVertexBuffer **pVB);

    static HRESULT CreateDriverVertexBuffer(CBaseDevice *pDevice,
                                            DWORD        cbLength,
                                            DWORD        dwFVF,
                                            DWORD        dwUsage,
                                            DWORD        dwActualUsage,
                                            D3DPOOL      Pool,
                                            D3DPOOL      ActualPool,
                                            REF_TYPE     refType,
                                            CVertexBuffer **pVB);

    static HRESULT CreateDriverManagedVertexBuffer(CBaseDevice *pDevice,
                                                   DWORD        cbLength,
                                                   DWORD        dwFVF,
                                                   DWORD        dwUsage,
                                                   DWORD        dwActualUsage,
                                                   D3DPOOL      Pool,
                                                   D3DPOOL      ActualPool,
                                                   REF_TYPE     refType,
                                                   CVertexBuffer **pVB);

    // Methods for Resource Management

    // Create duplicate of current object in new pool;
    // LOD is ignored for our type
    virtual HRESULT Clone(D3DPOOL     Pool,
                          CResource **ppResource) const;

    virtual const D3DBUFFER_DESC* GetBufferDesc() const;

    virtual HRESULT LockI(DWORD dwFlags) {return D3D_OK;}
    virtual HRESULT UnlockI() {return D3D_OK;}
    virtual void SetCachedDataPointer(BYTE *pData) {}

    HRESULT UpdateDirtyPortion(CResource *pResourceTarget);

    DWORD GetFVF() const { return m_desc.FVF; }

    // IUnknown methods
    STDMETHOD(QueryInterface) (REFIID riid,
                               LPVOID FAR * ppvObj);
    STDMETHOD_(ULONG,AddRef) ();
    STDMETHOD_(ULONG,Release) ();

    // Some Methods for IDirect3DBuffer
    STDMETHOD(SetPrivateData)(REFGUID riid,
                              CONST VOID *pvData,
                              DWORD cbData,
                              DWORD dwFlags);

    STDMETHOD(GetPrivateData)(REFGUID riid,
                              LPVOID pvData,
                              LPDWORD pcbData);

    STDMETHOD(FreePrivateData)(REFGUID riid);

    STDMETHOD(GetDevice)(IDirect3DDevice8 **ppDevice);
    STDMETHOD_(DWORD, GetPriority)();
    STDMETHOD_(DWORD, SetPriority)(DWORD dwPriority);
    STDMETHOD_(void, PreLoad)();
    STDMETHOD_(D3DRESOURCETYPE, GetType)();

    // Methods for IDirect3DVertexBuffer8
    STDMETHOD(Lock)(UINT cbOffsetToLock,
                    UINT cbSizeToLock,
                    BYTE **ppbData,
                    DWORD dwFlags);
    STDMETHOD(Unlock)();
    STDMETHOD(GetDesc)(D3DVERTEXBUFFER_DESC *pDesc);

    DWORD GetVertexSize() const { return m_vertsize; }
    DWORD GetNumVertices() const { return m_numverts; }
    WORD* GetClipCodes() const { return m_pClipCodes; }
    void AllocateClipCodes();

    BYTE* Data() const
    {
        DXGASSERT(m_desc.Usage & D3DUSAGE_SOFTWAREPROCESSING);
        DXGASSERT(m_desc.Pool == D3DPOOL_SYSTEMMEM || m_desc.Pool == D3DPOOL_MANAGED);
        DXGASSERT(m_LockCount == 0);
        return GetPrivateDataPointer();
    }

protected:

    CVertexBuffer(CBaseDevice *pDevice,
                  DWORD        cbLength,
                  DWORD        dwFVF,
                  DWORD        dwUsage,
                  DWORD        dwActualUsage,
                  D3DPOOL      Pool,
                  D3DPOOL      ActualPool,
                  REF_TYPE     refType,
                  HRESULT     *phr);
    virtual ~CVertexBuffer()
    {
        delete[] m_pClipCodes;
    }

#if DBG
    HRESULT ValidateLockParams(UINT cbOffsetToLock,
                               UINT SizeToLock,
                               BYTE **ppbData,
                               DWORD dwFlags) const;
#endif // DBG

    D3DVERTEXBUFFER_DESC    m_desc;
    DWORD                   m_usageUser;
    DWORD                   m_numverts;
    DWORD                   m_vertsize;
    WORD*                   m_pClipCodes;

}; // class CVertexBuffer

class CVertexBufferMT : public CVertexBuffer
{
public:
    STDMETHOD(Lock)(UINT cbOffsetToLock,
                    UINT cbSizeToLock,
                    BYTE **ppbData,
                    DWORD dwFlags)
    {
        API_ENTER(Device());
        return CVertexBuffer::Lock(cbOffsetToLock, cbSizeToLock, ppbData, dwFlags);
    }

    STDMETHOD(Unlock)()
    {
        API_ENTER(Device());
        return CVertexBuffer::Unlock();
    }

    friend CVertexBuffer;

protected:

    CVertexBufferMT(CBaseDevice *pDevice,
                    DWORD        cbLength,
                    DWORD        dwFVF,
                    DWORD        Usage,
                    DWORD        ActualUsage,
                    D3DPOOL      Pool,
                    D3DPOOL      ActualPool,
                    REF_TYPE     refType,
                    HRESULT     *phr) :
        CVertexBuffer(pDevice,
                      cbLength,
                      dwFVF,
                      Usage,
                      ActualUsage,
                      Pool,
                      ActualPool,
                      refType,
                      phr)
    {
    }

}; // class CVertexBufferMT

// This derived version of the vertex buffer class
// overrides lock/unlock to call the driver instead
class CDriverVertexBuffer : public CVertexBuffer
{
public:
    STDMETHOD(Lock)(UINT cbOffsetToLock,
                    UINT cbSizeToLock,
                    BYTE **ppbData,
                    DWORD dwFlags);
    STDMETHOD(Unlock)();

    // Alloc CVertexBuffer to construct this object
    friend CVertexBuffer;

    HRESULT LockI(DWORD dwFlags);
    HRESULT UnlockI();
    BYTE* GetCachedDataPointer() const { return m_pbData; }
    void SetCachedDataPointer(BYTE *pData) { m_pbData = pData; }

    BYTE* Data() const
    {
        DXGASSERT(FALSE); // Direct pointer access not supported
        return 0;
    }

protected:
    CDriverVertexBuffer(CBaseDevice *pDevice,
                        DWORD        cbLength,
                        DWORD        dwFVF,
                        DWORD        Usage,
                        DWORD        ActualUsage,
                        D3DPOOL      Pool,
                        D3DPOOL      ActualPool,
                        REF_TYPE     refType,
                        HRESULT     *phr);
    ~CDriverVertexBuffer();

    BYTE*   m_pbData; // stores cached pointer

}; // class CDriverVertexBuffer

class CDriverVertexBufferMT : public CDriverVertexBuffer
{
public:
    STDMETHOD(Lock)(UINT cbOffsetToLock,
                    UINT cbSizeToLock,
                    BYTE **ppbData,
                    DWORD dwFlags)
    {
        API_ENTER(Device());
        return CDriverVertexBuffer::Lock(cbOffsetToLock, cbSizeToLock, ppbData, dwFlags);
    }

    STDMETHOD(Unlock)()
    {
        API_ENTER(Device());
        return CDriverVertexBuffer::Unlock();
    }

    friend CVertexBuffer;

protected:
    CDriverVertexBufferMT(CBaseDevice *pDevice,
                          DWORD        cbLength,
                          DWORD        dwFVF,
                          DWORD        Usage,
                          DWORD        ActualUsage,
                          D3DPOOL      Pool,
                          D3DPOOL      ActualPool,
                          REF_TYPE     refType,
                          HRESULT     *phr) :
        CDriverVertexBuffer(pDevice,
                            cbLength,
                            dwFVF,
                            Usage,
                            ActualUsage,
                            Pool,
                            ActualPool,
                            refType,
                            phr)
    {
    }

}; // class CVertexBufferMT

// This derived version of the vertex buffer class
// overrides lock/unlock to call the driver instead
class CDriverManagedVertexBuffer : public CVertexBuffer
{
public:
    STDMETHOD(Lock)(UINT cbOffsetToLock,
                    UINT cbSizeToLock,
                    BYTE **ppbData,
                    DWORD dwFlags);
    STDMETHOD(Unlock)();

    HRESULT LockI(DWORD dwFlags) {return D3D_OK;}
    HRESULT UnlockI() {return D3D_OK;}

    BYTE* Data() const
    {
        DXGASSERT(m_desc.Usage & D3DUSAGE_SOFTWAREPROCESSING);
        DXGASSERT((m_desc.Usage & D3DUSAGE_WRITEONLY) == 0);
        DXGASSERT(m_LockCount == 0);
        DXGASSERT(m_pbData != 0);
        return m_pbData;
    }

    // Alloc CVertexBuffer to construct this object
    friend CVertexBuffer;

protected:
    CDriverManagedVertexBuffer(CBaseDevice *pDevice,
                               DWORD        cbLength,
                               DWORD        dwFVF,
                               DWORD        Usage,
                               DWORD        ActualUsage,
                               D3DPOOL      Pool,
                               D3DPOOL      ActualPool,
                               REF_TYPE     refType,
                               HRESULT     *phr);

    HRESULT UpdateCachedPointer(CBaseDevice*);

    friend HRESULT CResource::RestoreDriverManagementState(CBaseDevice*);

    BYTE*   m_pbData; // stores cached pointer
    BOOL    m_bDriverCalled;

}; // class CDriverVertexBuffer

class CDriverManagedVertexBufferMT : public CDriverManagedVertexBuffer
{
public:
    STDMETHOD(Lock)(UINT cbOffsetToLock,
                    UINT cbSizeToLock,
                    BYTE **ppbData,
                    DWORD dwFlags)
    {
        API_ENTER(Device());
        return CDriverManagedVertexBuffer::Lock(cbOffsetToLock, cbSizeToLock, ppbData, dwFlags);
    }

    STDMETHOD(Unlock)()
    {
        API_ENTER(Device());
        return CDriverManagedVertexBuffer::Unlock();
    }

    // Alloc CVertexBuffer to construct this object
    friend CVertexBuffer;

protected:
    CDriverManagedVertexBufferMT(CBaseDevice *pDevice,
                                 DWORD        cbLength,
                                 DWORD        dwFVF,
                                 DWORD        Usage,
                                 DWORD        ActualUsage,
                                 D3DPOOL      Pool,
                                 D3DPOOL      ActualPool,
                                 REF_TYPE     refType,
                                 HRESULT     *phr) :
        CDriverManagedVertexBuffer(pDevice,
                                   cbLength,
                                   dwFVF,
                                   Usage,
                                   ActualUsage,
                                   Pool,
                                   ActualPool,
                                   refType,
                                   phr)
    {
    }

}; // class CDriverVertexBufferMT

#endif // __VBUFFER_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\_dpf.c ===
#include "ddrawpr.h"

#include "..\..\misc\dpf.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\gensym\gensym.cpp ===
/*
 * $Id: gensym.cpp,v 1.7 1995/11/21 14:45:51 sjl Exp $
 *
 * Copyright (c) Microsoft Corp. 1993-1997
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * Microsoft Corp.
 *
 */

#include "ddrawpr.h"
#include "dxgint.h"
#include "resource.hpp"
#include "texture.hpp"
#include "volume.hpp"
#include "mipmap.hpp"
#include "mipvol.hpp"
#include "cubemap.hpp"
#include "surface.hpp"
#include "d3d8ddi.h"
#include <windows.h>
#include <assert.h>
#include <math.h>
#include <stdlib.h>
#include <stdio.h>
#include "dpf.h"
#include "d3di.hpp"
#include "ddi.h"
#include "d3dpr.hpp"
#include "ddrawp.h"
#include "memalloc.h"
#include "fltval.h"
#include "stateset.hpp"
#include "hmgr.hpp"
#include "d3dexcept.hpp"
#include "drawprim.hpp"
#include "resource.inl"
#include "pipeln.h"

#define DEFINE(type, member) \
    printf(#type "_" #member "  equ 0%xh\n", ((LONG)(&((type *)0)->member)))

#define MACRO(name) \
    printf(#name "  equ 0%xh\n", name)

main()
// pcomment prints a comment.

#define pcomment(s)  printf("; %s\n",s)

// pequate prints an equate statement.

#define pequate(name, value) printf("%s equ 0x%08lX\n",name,value);

#define OFFSET(type, field) ((LONG)(&((type *)0)->field))

// pblank prints a blank line.

#define pblank()     printf("\n")

#define printVCACHE(name)  \
{                               \
    printf("%-30s equ 0%LXH\n", "PV_VCACHE_"#name, OFFSET(D3DFE_PROCESSVERTICES, vcache.##name)); \
}

#define printD3DI_LIGHT(name)   \
{                               \
    printf("%-30s equ 0%LXH\n", "D3DI_LIGHT_"#name, OFFSET(D3DI_LIGHT, name)); \
}

#define printD3DFE_LIGHTING(name)  \
{                               \
    printf("%-30s equ 0%LXH\n", "PV_LIGHTING_"#name, OFFSET(D3DFE_PROCESSVERTICES, lighting.##name)); \
}

#define printDevice(name)   \
{                           \
    printf("%-30s equ 0%LXH\n", "DEVI_"#name, OFFSET(CD3DHal, name)); \
}

#define printPV(name)   \
{                           \
    printf("%-30s equ 0%LXH\n", "D3DPV_"#name, OFFSET(D3DFE_PROCESSVERTICES, name)); \
}

#define printDeviceDP2(name)   \
{                           \
    printf("%-30s equ 0%LXH\n", #name, OFFSET(CD3DHalDP2, name)); \
}

{
pcomment("------------------------------------------------------------------");
    pcomment(" Module Name: offsets.asm");
    pcomment("");
    pcomment(" Defines D3D assembly-language structures.");
    pcomment(" This file is generated");
    pcomment("");
    pcomment(" Copyright (c) 1998, 1995 Microsoft Corporation");
pcomment("------------------------------------------------------------------");
    pblank();
    pblank();

    DEFINE(D3DINSTRUCTION, wCount);
    DEFINE(D3DINSTRUCTION, bSize);
    DEFINE(D3DINSTRUCTION, bOpcode);

    DEFINE(D3DVERTEX, x);
    DEFINE(D3DVERTEX, y);
    DEFINE(D3DVERTEX, z);
    DEFINE(D3DVERTEX, tu);
    DEFINE(D3DVERTEX, tv);

    DEFINE(D3DHVERTEX, dwFlags);
    DEFINE(D3DHVERTEX, hx);
    DEFINE(D3DHVERTEX, hy);
    DEFINE(D3DHVERTEX, hz);
    printf("D3DHVERTEX_size equ %d\n", sizeof(D3DHVERTEX));

    DEFINE(D3DTRIANGLE, v1);
    DEFINE(D3DTRIANGLE, v2);
    DEFINE(D3DTRIANGLE, v3);
    DEFINE(D3DTRIANGLE, wFlags);
    printf("D3DTRIANGLE_size equ %d\n", sizeof(D3DTRIANGLE));

    DEFINE(D3DMATRIXI, _11);
    DEFINE(D3DMATRIXI, _12);
    DEFINE(D3DMATRIXI, _13);
    DEFINE(D3DMATRIXI, _14);
    DEFINE(D3DMATRIXI, _21);
    DEFINE(D3DMATRIXI, _22);
    DEFINE(D3DMATRIXI, _23);
    DEFINE(D3DMATRIXI, _24);
    DEFINE(D3DMATRIXI, _31);
    DEFINE(D3DMATRIXI, _32);
    DEFINE(D3DMATRIXI, _33);
    DEFINE(D3DMATRIXI, _34);
    DEFINE(D3DMATRIXI, _41);
    DEFINE(D3DMATRIXI, _42);
    DEFINE(D3DMATRIXI, _43);
    DEFINE(D3DMATRIXI, _44);

    printf("D3DMATRIXI_size equ %d\n", sizeof(D3DMATRIXI));
    printf("D3DFE_LIGHTING_size equ %d\n", sizeof(D3DFE_LIGHTING));
    printf("D3DFE_VIEWPORTCACHE_size equ %d\n", sizeof(D3DFE_VIEWPORTCACHE));

    MACRO(D3DOP_TRIANGLE);

    MACRO(D3DCS_LEFT);
    MACRO(D3DCS_RIGHT);
    MACRO(D3DCS_TOP);
    MACRO(D3DCS_BOTTOM);
    MACRO(D3DCS_FRONT);
    MACRO(D3DCS_BACK);

    MACRO(D3DTBLEND_COPY);
    MACRO(D3DSHADE_FLAT);

    MACRO(D3DCMP_LESSEQUAL);
    MACRO(D3DCMP_GREATEREQUAL);
    MACRO(D3DCMP_ALWAYS);

    MACRO(D3DSTATUS_ZNOTVISIBLE);
    MACRO(D3DDEV_DONOTCLIP);

// Geometry pipeline
pcomment("-------------------- VCACHE ------------------------------------");
    printVCACHE(scaleX);
    printVCACHE(scaleY);
    printVCACHE(scaleZ);
    printVCACHE(offsetX);
    printVCACHE(offsetY);
    printVCACHE(offsetZ);
    printVCACHE(minXgb);
    printVCACHE(minYgb);
    printVCACHE(maxXgb);
    printVCACHE(maxYgb);
    printVCACHE(minX);
    printVCACHE(minY);
    printVCACHE(maxX);
    printVCACHE(maxY);
    printVCACHE(gb11);
    printVCACHE(gb22);
    printVCACHE(gb41);
    printVCACHE(gb42);
    printVCACHE(Kgbx1);
    printVCACHE(Kgby1);
    printVCACHE(Kgbx2);
    printVCACHE(Kgby2);
    printVCACHE(dvX);
    printVCACHE(dvY);
    printVCACHE(dvWidth);
    printVCACHE(dvHeight);
    printVCACHE(scaleXi);
    printVCACHE(scaleYi);
    printVCACHE(minXi);
    printVCACHE(minYi);
    printVCACHE(maxXi);
    printVCACHE(maxYi);
pcomment("---------------- D3DFE_LIGHTING ------------------------------------");
    printD3DFE_LIGHTING(diffuse);
    printD3DFE_LIGHTING(alpha);
    printD3DFE_LIGHTING(diffuse0);
    printD3DFE_LIGHTING(currentSpecTable);
    printD3DFE_LIGHTING(specular);
    printD3DFE_LIGHTING(outDiffuse);
    printD3DFE_LIGHTING(vertexAmbient);
    printD3DFE_LIGHTING(vertexDiffuse);
    printD3DFE_LIGHTING(outSpecular);
    printD3DFE_LIGHTING(vertexSpecular);
    printD3DFE_LIGHTING(dwLightingFlags);
    printD3DFE_LIGHTING(alphaSpecular);
    printD3DFE_LIGHTING(model_eye);
    printD3DFE_LIGHTING(activeLights);
    printD3DFE_LIGHTING(material);
    printD3DFE_LIGHTING(ambientSceneScaled);
    printD3DFE_LIGHTING(ambientScene);
    printD3DFE_LIGHTING(fog_mode);
    printD3DFE_LIGHTING(fog_density);
    printD3DFE_LIGHTING(fog_start);
    printD3DFE_LIGHTING(fog_end);
    printD3DFE_LIGHTING(fog_factor);
    printD3DFE_LIGHTING(specThreshold);
    printD3DFE_LIGHTING(ambient_save);
    printD3DFE_LIGHTING(materialAlpha);
    printD3DFE_LIGHTING(materialAlphaS);
    printD3DFE_LIGHTING(dwDiffuse0);
    printD3DFE_LIGHTING(directionToCamera);
    printD3DFE_LIGHTING(dwAmbientSrcIndex);
    printD3DFE_LIGHTING(dwDiffuseSrcIndex);
    printD3DFE_LIGHTING(dwSpecularSrcIndex);
    printD3DFE_LIGHTING(dwEmissiveSrcIndex);
pcomment("---------------- D3DI_LIGHT ------------------------------------");
    printD3DI_LIGHT(model_position);
    printD3DI_LIGHT(type);
    printD3DI_LIGHT(model_direction);
    printD3DI_LIGHT(flags);
    printD3DI_LIGHT(falloff);
    printD3DI_LIGHT(inv_theta_minus_phi);
    printD3DI_LIGHT(halfway);
    printD3DI_LIGHT(next);
    printD3DI_LIGHT(range_squared);
    printD3DI_LIGHT(attenuation0);
    printD3DI_LIGHT(attenuation1);
    printD3DI_LIGHT(attenuation2);
    printD3DI_LIGHT(cos_theta_by_2);
    printD3DI_LIGHT(cos_phi_by_2);
    printD3DI_LIGHT(position);
    printD3DI_LIGHT(direction);
    printD3DI_LIGHT(range);

pcomment("---------------- D3DFE_PROCESSVERTICES ------------------------------");
    printPV(mCTM);
    printPV(dwMaxTextureIndices);
    printPV(lighting);
    printPV(vcache);
    printPV(lpdwRStates);
    printPV(ClipperState);
    printPV(dwFlags);
    printPV(dwDeviceFlags);
    printPV(dwNumVertices);
    printPV(dwNumPrimitives);
    printPV(dwNumIndices);
    printPV(lpwIndices);
    printPV(primType);
    printPV(nTexCoord);
    printPV(position);
    printPV(normal);
    printPV(diffuse);
    printPV(specular);
    printPV(textures);
    printPV(dwVIDIn);
    printPV(dwVIDOut);
    printPV(dwOutputSize);
    printPV(lpvOut);
    printPV(lpClipFlags);
    printPV(dwClipUnion);
    printPV(dwClipIntersection);
    printPV(texOffset);
    printPV(normalOffset);
    printPV(diffuseOffset);
    printPV(specularOffset);
    printPV(texOffsetOut);
    printPV(diffuseOffsetOut);
    printPV(specularOffsetOut);
    printPV(dwClipMaskOffScreen);
    printPV(dwFirstClippedVertex);
    printPV(userClipPlane);
    printPV(dwFlags2);

pcomment("---------------- CD3DHal ------------------------------------");
    printDevice(m_DeviceType              );
    // printDevice(ddiType                   );
    // printDevice(lpD3DHALCallbacks         );
    // printDevice(lpD3DHALGlobalDriverData  );
    // printDevice(lpD3DHALCallbacks2        );
    // printDevice(lpD3DHALCallbacks3        );
    // printDevice(lpDD                      );
    // printDevice(lpD3DExtendedCaps);
    // printDevice(pfnRastService);
    printDevice(transform                 );
    printDevice(dwFEFlags);
    printDevice(specular_tables);
    printDevice(specular_table);
    printDevice(lightVertexFuncTable);
    printDevice(m_lpD3DMappedTexI);
    printDevice(m_dwHintFlags);
//    printDevice(lpwDPBuffer);
    printDevice(HVbuf);
    printDevice(rstates);
    printDevice(tsstates);
pcomment("---------------- MISC ------------------------------------");
    /*
    pequate("DEVI_                              ", OFFSET(CD3DHal, ));
    pequate("DEVI_                              ", OFFSET(CD3DHal, ));
    pequate("DEVI_                              ", OFFSET(CD3DHal, ));
    pequate("DEVI_                              ", OFFSET(CD3DHal, ));
    pequate("DEVI_                              ", OFFSET(CD3DHal, ));
    pequate("DEVI_                              ", OFFSET(CD3DHal, ));
    pequate("DEVI_                              ", OFFSET(CD3DHal, ));
    pequate("DEVI_                              ", OFFSET(CD3DHal, ));
    pequate("DEVI_                              ", OFFSET(CD3DHal, ));
    pequate("DEVI_                              ", OFFSET(CD3DHal, ));
    pequate("DEVI_                              ", OFFSET(CD3DHal, ));
    pequate("DEVI_                              ", OFFSET(CD3DHal, ));
    */
    pequate("_R_", 0);
    pequate("_G_", 4);
    pequate("_B_", 8);

    pequate("_X_", 0);
    pequate("_Y_", 4);
    pequate("_Z_", 8);
    pequate("_W_", 12);
    pequate("D3DLIGHTI_COMPUTE_SPECULAR ", D3DLIGHTI_COMPUTE_SPECULAR);

pcomment("---------------- dwHintFlags-----------------------------------");

    pequate("D3DDEVBOOL_HINTFLAGS_INSCENE        ", D3DDEVBOOL_HINTFLAGS_INSCENE      );
    pequate("D3DDEVBOOL_HINTFLAGS_MULTITHREADED  ", D3DDEVBOOL_HINTFLAGS_MULTITHREADED);

pcomment("---------------- m_dwRuntimeFlags ---------------------------------");
    pequate("D3DRT_RECORDSTATEMODE           ", D3DRT_RECORDSTATEMODE         );
    pequate("D3DRT_EXECUTESTATEMODE          ", D3DRT_EXECUTESTATEMODE        );
    pequate("D3DRT_NEED_TEXTURE_UPDATE       ", D3DRT_NEED_TEXTURE_UPDATE     );
pcomment("---------------- dwFEFlags ------------------------------------");

    pequate("D3DFE_WORLDMATRIX_DIRTY         ", D3DFE_WORLDMATRIX_DIRTY       );
    pequate("D3DFE_TLVERTEX                  ", D3DFE_TLVERTEX                );
    pequate("D3DFE_PROJMATRIX_DIRTY          ", D3DFE_PROJMATRIX_DIRTY        );
    pequate("D3DFE_VIEWMATRIX_DIRTY          ", D3DFE_VIEWMATRIX_DIRTY        );
    pequate("D3DFE_NEED_TRANSFORM_LIGHTS     ", D3DFE_NEED_TRANSFORM_LIGHTS   );
    pequate("D3DFE_MATERIAL_DIRTY            ", D3DFE_MATERIAL_DIRTY          );
    pequate("D3DFE_CLIPPLANES_DIRTY          ", D3DFE_CLIPPLANES_DIRTY        );
    pequate("D3DFE_LIGHTS_DIRTY              ", D3DFE_LIGHTS_DIRTY            );
    pequate("D3DFE_VERTEXBLEND_DIRTY         ", D3DFE_VERTEXBLEND_DIRTY       );
    pequate("D3DFE_FRUSTUMPLANES_DIRTY       ", D3DFE_FRUSTUMPLANES_DIRTY     );
    pequate("D3DFE_WORLDVIEWMATRIX_DIRTY     ", D3DFE_WORLDVIEWMATRIX_DIRTY   );
    pequate("D3DFE_FVF_DIRTY                 ", D3DFE_FVF_DIRTY               );
    pequate("D3DFE_MAP_TSS_TO_RS             ", D3DFE_MAP_TSS_TO_RS           );
    pequate("D3DFE_INVWORLDVIEWMATRIX_DIRTY  ", D3DFE_INVWORLDVIEWMATRIX_DIRTY);
    pequate("D3DRT_LOSTSURFACES              ", D3DRT_LOSTSURFACES            );
    pequate("D3DFE_DISABLE_TEXTURES          ", D3DFE_DISABLE_TEXTURES        );
    pequate("D3DFE_CLIPMATRIX_DIRTY          ", D3DFE_CLIPMATRIX_DIRTY        );
    pequate("D3DFE_TLHAL                     ", D3DFE_TLHAL                   );
pcomment("---------------- pv->dwFlags ------------------------------------");
    pequate("D3DPV_FOG                   ", D3DPV_FOG                 );
    pequate("D3DPV_DOCOLORVERTEX         ", D3DPV_DOCOLORVERTEX       );
    pequate("D3DPV_LIGHTING              ", D3DPV_LIGHTING            );
    pequate("D3DPV_SOA                   ", D3DPV_SOA                 );
    pequate("D3DPV_COLORVERTEX_E         ", D3DPV_COLORVERTEX_E       );
    pequate("D3DPV_COLORVERTEX_D         ", D3DPV_COLORVERTEX_D       );
    pequate("D3DPV_COLORVERTEX_S         ", D3DPV_COLORVERTEX_S       );
    pequate("D3DPV_COLORVERTEX_A         ", D3DPV_COLORVERTEX_A       );
    pequate("D3DPV_DONOTCOPYSPECULAR     ", D3DPV_DONOTCOPYSPECULAR   );
    pequate("D3DPV_NONCLIPPED            ", D3DPV_NONCLIPPED          );
    pequate("D3DPV_FRUSTUMPLANES_DIRTY   ", D3DPV_FRUSTUMPLANES_DIRTY );
    pequate("D3DPV_VBCALL                ", D3DPV_VBCALL              );
    pequate("D3DPV_DONOTCOPYTEXTURE      ", D3DPV_DONOTCOPYTEXTURE    );
    pequate("D3DPV_TLVCLIP               ", D3DPV_TLVCLIP             );
    pequate("D3DPV_TRANSFORMONLY         ", D3DPV_TRANSFORMONLY       );
    pequate("D3DPV_DONOTCOPYDIFFUSE      ", D3DPV_DONOTCOPYDIFFUSE    );
    pequate("D3DPV_PERSIST               ", D3DPV_PERSIST             );
pcomment("---------------- pv->dwDeviceFlags ------------------------------");
    pequate("D3DDEV_GUARDBAND                ", D3DDEV_GUARDBAND          );
    pequate("D3DDEV_RANGEBASEDFOG            ", D3DDEV_RANGEBASEDFOG      );
    pequate("D3DDEV_FOG                      ", D3DDEV_FOG                );
    pequate("D3DDEV_SHADERDIRTY              ", D3DDEV_SHADERDIRTY);
    pequate("D3DDEV_DONOTSTRIPELEMENTS       ", D3DDEV_DONOTSTRIPELEMENTS);
    pequate("D3DDEV_VERTEXSHADERS            ", D3DDEV_VERTEXSHADERS);
    pequate("D3DDEV_VBPROCVER                ", D3DDEV_VBPROCVER);
    pequate("D3DDEV_DOPOINTSPRITEEMULATION   ", D3DDEV_DOPOINTSPRITEEMULATION);
    pequate("D3DDEV_FLATSHADEMODE            ", D3DDEV_FLATSHADEMODE);
    pequate("D3DDEV_SPECULARENABLE           ", D3DDEV_SPECULARENABLE);
    pequate("D3DDEV_TRANSFORMEDFVF           ", D3DDEV_TRANSFORMEDFVF);
    pequate("D3DDEV_INDEXEDVERTEXBLENDENABLE ", D3DDEV_INDEXEDVERTEXBLENDENABLE);
    pequate("D3DDEV_FRUSTUMPLANES_DIRTY      ", D3DDEV_FRUSTUMPLANES_DIRTY);
    pequate("D3DDEV_TEXTRANSFORMDIRTY        ", D3DDEV_TEXTRANSFORMDIRTY  );
    pequate("D3DDEV_TRANSFORMDIRTY           ", D3DDEV_TRANSFORMDIRTY     );
    pequate("D3DDEV_REMAPTEXTUREINDICES      ", D3DDEV_REMAPTEXTUREINDICES);
    pequate("D3DDEV_LIGHTSDIRTY              ", D3DDEV_LIGHTSDIRTY        );
    pequate("D3DDEV_DONOTCLIP                ", D3DDEV_DONOTCLIP          );
    pequate("D3DDEV_MODELSPACELIGHTING       ", D3DDEV_MODELSPACELIGHTING );
    pequate("D3DDEV_LOCALVIEWER              ", D3DDEV_LOCALVIEWER        );
    pequate("D3DDEV_NORMALIZENORMALS         ", D3DDEV_NORMALIZENORMALS   );
    pequate("D3DDEV_TEXTURETRANSFORM         ", D3DDEV_TEXTURETRANSFORM   );
    pequate("D3DDEV_STRIDE                   ", D3DDEV_STRIDE             );
    pequate("D3DDEV_COLORVERTEX              ", D3DDEV_COLORVERTEX        );
    pequate("D3DDEV_POSITIONINCAMERASPACE    ", D3DDEV_POSITIONINCAMERASPACE);
    pequate("D3DDEV_NORMALINCAMERASPACE      ", D3DDEV_NORMALINCAMERASPACE);
    pequate("D3DDEV_LIGHTING                 ", D3DDEV_LIGHTING);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\_memallo.c ===
#include "ddrawpr.h"
#define __DXGUSEALLOC 1
#include "..\..\misc\memalloc.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\gensym\sources.inc ===
TARGETNAME=
TARGETPATH=
TARGETTYPE=NOTARGET

INCLUDES = ..;$(INCLUDES);$(D3DDX8)\tnl;$(D3DDX8)\fe
C_DEFINES = -DBUILD_D3D_LAYER $(C_DEFINES)

NTTARGETFILE0= \
!if !($(AMD64) || $(IA64))
             $(_OBJ_DIR)\$(TARGET_DIRECTORY)\offsets.asm
!endif

SOURCES=
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\gensym\daytona\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#

GENSYMFLAGS = -DWINNT -DNT
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\gensym\win9x\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#

GENSYMFLAGS = -DWIN95 
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\gensym\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#


OFFSETS = $(_OBJ_DIR)\$(TARGET_DIRECTORY)\offsets.asm

D3D_VERSION = 0x0800

GENSYMFLAGS = -DWIN32 -D_WIN32 -DD3D -Zp -DIS_32 -DDIRECT3D_VERSION=$(D3D_VERSION) 
GENSYMBASE = $(_OBJ_DIR)\$(TARGET_DIRECTORY)\gensym
GENSYMEXE = $(GENSYMBASE).exe
GENSYMSOURCE = ..\gensym.cpp
GENSYMINCS = 
GENTGT = $(_OBJ_DIR)\$(TARGET_DIRECTORY)

INCPATHS = \
	-I$(BASEDIR)\public\sdk\inc\
	-I$(BASEDIR)\public\sdk\inc\crt\
	-I$(BASEDIR)\public\oak\inc\
    -I$(BASEDIR)\public\internal\multimedia\inc\
    -I..\
    -I$(BASEDIR)\public\internal\windows\inc\
    -I$(BASEDIR)\public\internal\base\inc\
    -I$(D3DDX8)\inc\
    -I$(D3DDX8)\fe\
    -I$(D3DDX8)\util\
    -I$(D3DDX8)\fw\
    -I$(DXGROOT)\misc\
    -I$(DXGROOT)\inc\
    -I$(DXROOT)\inc\


$(OFFSETS): $(GENSYMSOURCE) $(GENSYMINCS)
    set PASS0ONLY=
    nmake $(GENSYMBASE).obj $(HOST_TARGET_DEFINES) $(HOST_TOOLS) 

    -link -out:$(GENSYMEXE) @<<
-machine:$(HOST_TARGETCPU)
-base:@$(COFFBASE_TXT_FILE),usermode
-subsystem:console
-entry:mainCRTStartup
-ignore:4089
-force:unresolved
-nodefaultlib
$(GENSYMBASE).obj
$(BASEDIR)\public\sdk\lib\$(TARGET_DIRECTORY)\kernel32.lib
$(SDK_LIB_DEST)\$(HOST_TARGETCPU)\msvcrt.lib
$(PERFLIBS)
<<
    -$(GENSYMEXE) > $(OFFSETS)
    -erase $(GENSYMBASE).obj
    -erase $(GENSYMEXE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\inc\d3d8ddi.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       D3D8ddi.h
 *  Content:    Defines the interface between DirectDraw / Direct3D and the
 *      OS specific layer (win32k.sys on NT and ddraw.dll on Win9X).
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   04-nov-99  smac    initial implementation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifndef __D3D8DDI_INCLUDED__
#define __D3D8DDI_INCLUDED__


/*
 * These definitions are required to allow polymorphic structure members (i.e. those
 * that are referred to both as DWORDs and as pointers) to resolve into a type
 * of correct size to hold the largest of those two types (i.e. pointer) on 64 bit
 * systems. For 32 bit environments, ULONG_PTR resolves to a DWORD.
 */
#ifndef MAXULONG_PTR
#define ULONG_PTR    DWORD
#define PULONG_PTR   LPDWORD
#endif //MAXULONG_PTR


// Caps:

// Note this struct is identical in content to D3DHAL_GLOBALDRIVERDATA.
// The only thing that has changed is the name of the texture list, reflecting
// the fact that this struct holds a list of DX8-style pixel format operations.
typedef struct _D3DD8_GLOBALDRIVERDATA {
    DWORD                       dwSize;                 // Size of this structure
    D3DDEVICEDESC_V1            hwCaps;                 // Capabilities of the hardware
    DWORD                       dwNumVertices;          // see following comment
    DWORD                       dwNumClipVertices;      // see following comment
    DWORD                       GDD8NumSupportedFormatOps;
    DDSURFACEDESC              *pGDD8SupportedFormatOps;
} D3D8_GLOBALDRIVERDATA;

typedef struct _D3D8_DRIVERCAPS
{
    D3DCAPS8                    D3DCaps;
    DWORD                       DisplayWidth;           // Current display width
    DWORD                       DisplayHeight;          // Current display height
    D3DFORMAT                   DisplayFormatWithoutAlpha;     // Current display format
    D3DFORMAT                   DisplayFormatWithAlpha;     // Current display format
    DWORD                       DisplayFrequency;       // Current refresh rate
    DWORD                       NLVCaps;                // AGP->Video blt caps
    DWORD                       SVBCaps;                // Sys->Video blt caps
    DWORD                       VSBCaps;                // Video->Sys blt caps
    DWORD                       SVBCaps2;               // More Sys->Video blt caps
    DWORD                       dwFlags;
    DWORD                       GDD8NumSupportedFormatOps;
    DDSURFACEDESC              *pGDD8SupportedFormatOps;
    DWORD                       KnownDriverFlags;
} D3D8_DRIVERCAPS, * PD3D8_DRIVERCAPS;

// Flags
#define DDIFLAG_D3DCAPS8                    0x00000001

// Known driver flags
#define KNOWN_LIGHTWEIGHT                   0x00000001      // Device can support lightweight surfaces
#define KNOWN_HWCURSOR                      0x00000002      // Device can support hardware cursors in Hi-Res
#define KNOWN_MIPPEDCUBEMAPS                0x00000004      // Device can support mipped cubemaps
#define KNOWN_ZSTENCILDEPTH                 0x00000010      // Device cannot support Z/Stencil depths different than the render target
#define KNOWN_HWCURSORLOWRES                0x00000020      // Device can support hardware cursors in LowRes
#define KNOWN_NOTAWINDOWEDBLTQUEUER         0x00000040      // Device has no drivers known to over-queue windowed presentation blts
#define KNOWN_D16_LOCKABLE                  0x00000080      // Device supports lockable D16 format correctly
#define KNOWN_RTTEXTURE_R5G6B5              0x00000100      // RT+Tex formats that are supported
#define KNOWN_RTTEXTURE_X8R8G8B8            0x00000200
#define KNOWN_RTTEXTURE_A8R8G8B8            0x00000400
#define KNOWN_RTTEXTURE_A1R5G5B5            0x00000800
#define KNOWN_RTTEXTURE_A4R4G4B4            0x00001000
#define KNOWN_RTTEXTURE_X1R5G5B5            0x00002000     
#define KNOWN_CANMISMATCHRT                 0x00004000      // All given RT+Tex formats can be used regardless of current display depth.
                                                            //  (If this bit is not set, then any known RT+Tex formats must match bitdepth of display)


/****************************************************************************
 *
 * D3D8 structures for Surface Object callbacks
 *
 ***************************************************************************/

typedef struct _D3D8_BLTDATA
{
    HANDLE                      hDD;       // driver struct
    HANDLE                      hDestSurface;// dest surface
    RECTL                       rDest;      // dest rect
    HANDLE                      hSrcSurface; // src surface
    RECTL                       rSrc;       // src rect
    DWORD                       dwFlags;    // blt flags
    DWORD                       dwROPFlags; // ROP flags (valid for ROPS only)
    DDBLTFX                     bltFX;      // blt FX
    union
    {
    BOOL                        IsClipped;  // clipped blt?
    HWND                        hWnd;       // Window Handle to clip against
    };
    RECTL                       rOrigDest;  // unclipped dest rect
                                            // (only valid if IsClipped)
    RECTL                       rOrigSrc;   // unclipped src rect
                                            // (only valid if IsClipped)
    DWORD                       dwRectCnt;  // count of dest rects
                                            // (only valid if IsClipped)
    LPRECT                      prDestRects;    // array of dest rects
    DWORD                       dwAFlags;   // DDABLT_ flags (for AlphaBlt DDI)
    DDARGB                      ddargbScaleFactors;  // RGBA scaling factors (AlphaBlt)

    DWORD                       msLastPresent;      // Time of last blt with DDBLT_COPYVSYNC
    DWORD                       threshold;  // Display Frequency related for adapter need
                                            // for DDBLT_COPYVSYNC

    HRESULT                     ddRVal;     // return value
} D3D8_BLTDATA, * PD3D8_BLTDATA;

typedef struct _D3D8_LOCKDATA
{
    HANDLE                      hDD;        // driver struct
    HANDLE                      hSurface;   // surface struct
    DWORD                       bHasRange;  // range is valid
    D3DRANGE                    range;      // range for locking
    DWORD                       bHasRect;   // rArea is valid
    RECTL                       rArea;      // area being locked
    DWORD                       bHasBox;    // box is valid
    D3DBOX                      box;        // sub-box locking for volumes
    LPVOID                      lpSurfData; // pointer to screen memory (return value)
    long                        lPitch;     // row pitch
    long                        lSlicePitch;// slice pitch for volumes
    DWORD                       dwFlags;    // DDLOCK flags
} D3D8_LOCKDATA, * PD3D8_LOCKDATA;

typedef struct _D3D8_UNLOCKDATA
{
    HANDLE                      hDD;        // driver struct
    HANDLE                      hSurface;   // surface struct
} D3D8_UNLOCKDATA, * PD3D8_UNLOCKDATA;

typedef struct _D3D8_FLIPDATA
{
    HANDLE                      hDD;        // driver struct
    HANDLE                      hSurfCurr;  // current surface
    HANDLE                      hSurfTarg;  // target surface (to flip to)
    HANDLE                      hSurfCurrLeft; // current surface
    HANDLE                      hSurfTargLeft; // target surface (to flip to)
    DWORD                       dwFlags;    // flags
    HRESULT                     ddRVal;     // return value
} D3D8_FLIPDATA, * PD3D8_FLIPDATA;

typedef struct _D3D8_DESTROYSURFACEDATA
{
    HANDLE                      hDD;       // driver struct
    HANDLE                      hSurface;    // surface struct
    HRESULT                     ddRVal;     // return value
} D3D8_DESTROYSURFACEDATA, * PD3D8_DESTROYSURFACEDATA;

typedef struct _D3D8_ADDATTACHEDSURFACEDATA
{
    HANDLE                          hDD;       // driver struct
    HANDLE                          hSurface;    // surface struct
    HANDLE                          hSurfAttached; // surface to attach
    HRESULT                         ddRVal;     // return value
} D3D8_ADDATTACHEDSURFACEDATA, * PD3D8_ADDATTACHEDSURFACEDATA;

typedef struct _D3D8_GETBLTSTATUSDATA
{
    HANDLE                      hDD;       // driver struct
    HANDLE                      hSurface;    // surface struct
    DWORD                       dwFlags;    // flags
    HRESULT                     ddRVal;     // return value
} D3D8_GETBLTSTATUSDATA, * PD3D8_GETBLTSTATUSDATA;

typedef struct _D3D8_GETFLIPSTATUSDATA
{
    HANDLE                      hDD;       // driver struct
    HANDLE                      hSurface;    // surface struct
    DWORD                       dwFlags;    // flags
    HRESULT                     ddRVal;     // return value
} D3D8_GETFLIPSTATUSDATA, * PD3D8_GETFLIPSTATUSDATA;

typedef struct _DDSURFACEINFO
{
    DWORD               cpWidth;        // For linear, surface and volume
    DWORD               cpHeight;       // For surface and volume
    DWORD               cpDepth;        // For volumes
    BYTE               *pbPixels;       // Pointer to Memory for sys-mem surface
    LONG                iPitch;         // Row Pitch for sys-mem surface
    LONG                iSlicePitch;    // Slice Pitch for sys-mem volume
    HANDLE              hKernelHandle;  // Handle returned by the kernel
} DDSURFACEINFO, *LPDDSURFACEINFO;

typedef struct _D3D8_CREATESURFACEDATA
{
    HANDLE                      hDD;        // driver struct
    LPDDSURFACEINFO             pSList;     // list of created surface objects
    DWORD                       dwSCnt;     // number of surfaces in SList
    D3DRESOURCETYPE             Type;       // Type: MipMap, CubeMap, MipVolume, VertexBuffer, IndexBuffer, CommandBuffer
    DWORD                       dwUsage;    // Usage: Texture or RenderTarget
    D3DPOOL                     Pool;       // SysMem/VidMem/NonLocal
    D3DFORMAT                   Format;     // Format
    D3DMULTISAMPLE_TYPE         MultiSampleType;
    DWORD                       dwFVF;      // FVF format for vertex buffers
    BOOL                        bTreatAsVidMem; // Set if Sys-Mem object was created with POOL_DEFAULT by user.
    BOOL                        bReUse;     // Set if are trying to create driver managed surfaces marked deferred
} D3D8_CREATESURFACEDATA, * PD3D8_CREATESURFACEDATA;

#define DDWAITVB_I_TESTVB           0x80000006l

typedef struct _D3D8_WAITFORVERTICALBLANKDATA
{
    HANDLE                      hDD;       // driver struct
    DWORD                       dwFlags;    // flags
    DWORD                       bIsInVB;    // is in vertical blank
    HRESULT                     ddRVal;     // return value
} D3D8_WAITFORVERTICALBLANKDATA, * PD3D8_WAITFORVERTICALBLANKDATA;

typedef struct _D3D8_SETMODEDATA
{
    HANDLE                      hDD;       // driver struct
    DWORD                       dwWidth;
    DWORD                       dwHeight;
    D3DFORMAT                   Format;
    DWORD                       dwRefreshRate;
    BOOL                        bRestore;
    HRESULT                     ddRVal;     // return value
} D3D8_SETMODEDATA, * PD3D8_SETMODEDATA;

typedef struct _D3D8_GETSCANLINEDATA
{
    HANDLE                      hDD;       // driver struct
    DWORD                       dwScanLine; // returned scan line
    BOOL                        bInVerticalBlank;
    HRESULT                     ddRVal;     // return value
} D3D8_GETSCANLINEDATA, * PD3D8_GETSCANLINEDATA;

typedef struct _D3D8_SETEXCLUSIVEMODEDATA
{
    HANDLE                      hDD;             // driver struct
    DWORD                       dwEnterExcl;      // TRUE if entering exclusive mode, FALSE is leaving
    HRESULT                     ddRVal;           // return value
} D3D8_SETEXCLUSIVEMODEDATA, * PD3D8_SETEXCLUSIVEMODEDATA;

typedef struct _D3D8_FLIPTOGDISURFACEDATA
{
    HANDLE                      hDD;         // driver struct
    DWORD                       dwToGDI;          // TRUE if flipping to the GDI surface, FALSE if flipping away
    HRESULT                     ddRVal;       // return value
} D3D8_FLIPTOGDISURFACEDATA, * PD3D8_FLIPTOGDISURFACEDATA;

typedef struct _D3D8_SETCOLORKEYDATA
{
    HANDLE                      hDD;
    HANDLE                      hSurface;
    DWORD                       ColorValue;
    HRESULT                     ddRVal;
} D3D8_SETCOLORKEYDATA, * PD3D8_SETCOLORKEYDATA;

typedef struct _D3D8_GETAVAILDRIVERMEMORYDATA
{
    HANDLE                  hDD;        // driver struct
    D3DPOOL                Pool;       // Pool they are interested in
    DWORD                   dwUsage;    // What the pool is used for
    DWORD                   dwFree;      // free memory for this kind of surface
    HRESULT                 ddRVal;      // return value
} D3D8_GETAVAILDRIVERMEMORYDATA, * PD3D8_GETAVAILDRIVERMEMORYDATA;

typedef struct _D3D8_GETDRIVERSTATEDATA
{
    DWORD                       dwFlags;        // Flags to indicate the data
                                                // required
    ULONG_PTR                   dwhContext;     // d3d context
    LPDWORD                     lpdwStates;     // ptr to the state data
                                                // to be filled in by the
                                                // driver
    DWORD                       dwLength;
    HRESULT                     ddRVal;         // return value
} D3D8_GETDRIVERSTATEDATA, * PD3D8_GETDRIVERSTATEDATA;

typedef struct _D3D8_DESTROYDDLOCALDATA
{
    DWORD                       dwFlags;
    HANDLE                      hDD;
    HRESULT                     ddRVal;
} D3D8_DESTROYDDLOCALDATA, * PD3D8_DESTROYDDLOCALDATA;

typedef struct _D3D8_CONTEXTCREATEDATA
{
    HANDLE                      hDD;        // in:  Driver struct
    HANDLE                      hSurface;   // in:  Surface to be used as target
    HANDLE                      hDDSZ;      // in:  Surface to be used as Z
    DWORD                       dwPID;      // in:  Current process id
    ULONG_PTR                   dwhContext; // in/out: Context handle
    HRESULT                     ddrval;

    // Private buffer information. To make it similar to
    // D3DNTHAL_CONTEXTCREATEI
    PVOID pvBuffer;
    ULONG cjBuffer;
} D3D8_CONTEXTCREATEDATA, * PD3D8_CONTEXTCREATEDATA;

typedef struct _D3D8_CONTEXTDESTROYDATA
{
    ULONG_PTR                   dwhContext; // in:  Context handle
    HRESULT                     ddrval;     // out: Return value
} D3D8_CONTEXTDESTROYDATA, * PD3D8_CONTEXTDESTROYDATA;

typedef struct _D3D8_CONTEXTDESTROYALLDATA
{
    DWORD                       dwPID;      // in:  Process id to destroy contexts for
    HRESULT                     ddrval;     // out: Return value
} D3D8_CONTEXTDESTROYALLDATA, * PD3D8_CONTEXTDESTROYALLDATA;

typedef struct _D3D8_RENDERSTATEDATA
{
    ULONG_PTR       dwhContext; // in:  Context handle
    DWORD       dwOffset;   // in:  Where to find states in buffer
    DWORD       dwCount;    // in:  How many states to process
    HANDLE      hExeBuf;    // in:  Execute buffer containing data
    HRESULT     ddrval;     // out: Return value
} D3D8_RENDERSTATEDATA, *PD3D8_RENDERSTATEDATA;

typedef struct _D3D8_RENDERPRIMITIVEDATA
{
    ULONG_PTR   dwhContext; // in:  Context handle
    DWORD       dwOffset;   // in:  Where to find primitive data in buffer
    DWORD       dwStatus;   // in/out: Condition branch status
    HANDLE      hExeBuf;    // in:  Execute buffer containing data
    DWORD       dwTLOffset; // in:  Byte offset in lpTLBuf for start of vertex data
    HANDLE      hTLBuf;     // in:  Execute buffer containing TLVertex data
    D3DINSTRUCTION  diInstruction;  // in:  Primitive instruction
    HRESULT     ddrval;     // out: Return value
} D3D8_RENDERPRIMITIVEDATA, *PD3D8_RENDERPRIMITIVEDATA;

typedef struct _D3D8_DRAWPRIMITIVES2DATA
{
    ULONG_PTR  dwhContext;           // in: Context handle
    DWORD      dwFlags;              // in: flags
    DWORD      dwVertexType;         // in: vertex type
    HANDLE     hDDCommands;          // in: vertex buffer command data
    DWORD      dwCommandOffset;      // in: offset to start of vertex buffer commands
    DWORD      dwCommandLength;      // in: number of bytes of command data
    union
    { // based on D3DHALDP2_USERMEMVERTICES flag
       HANDLE  hDDVertex;            // in: surface containing vertex data
       LPVOID  lpVertices;           // in: User mode pointer to vertices
    };
    DWORD      dwVertexOffset;       // in: offset to start of vertex data
    DWORD      dwVertexLength;       // in: number of vertices of vertex data
    DWORD      dwReqVertexBufSize;   // in: number of bytes required for the next vertex buffer
    DWORD      dwReqCommandBufSize;  // in: number of bytes required for the next commnand buffer
    LPDWORD    lpdwRStates;          // in: Pointer to the array where render states are updated
    union
    {
       DWORD   dwVertexSize;         // in: Size of each vertex in bytes
       HRESULT ddrval;               // out: return value
    };
    DWORD      dwErrorOffset;        // out: offset in lpDDCommands to first D3DHAL_COMMAND not handled

    // Private data for the thunk
    ULONG_PTR  fpVidMem_CB;          // out: fpVidMem for the command buffer
    DWORD      dwLinearSize_CB;      // out: dwLinearSize for the command buffer

    ULONG_PTR  fpVidMem_VB;          // out: fpVidMem for the vertex buffer
    DWORD      dwLinearSize_VB;      // out: dwLinearSize for the vertex buffer
} D3D8_DRAWPRIMITIVES2DATA, *PD3D8_DRAWPRIMITIVES2DATA;

typedef struct _D3D8_VALIDATETEXTURESTAGESTATEDATA
{
    ULONG_PTR                   dwhContext;     // in:  Context handle
    DWORD                       dwFlags;        // in:  Flags, currently set to 0
    ULONG_PTR                   dwReserved;     //
    DWORD                       dwNumPasses;    // out: Number of passes the hardware
                                                //      can perform the operation in
    HRESULT                     ddrval;         // out: return value
} D3D8_VALIDATETEXTURESTAGESTATEDATA, * PD3D8_VALIDATETEXTURESTAGESTATEDATA;

typedef struct _D3D8_SCENECAPTUREDATA
{
    ULONG_PTR                   dwhContext; // in:  Context handle
    DWORD                       dwFlag;     // in:  Indicates beginning or end
    HRESULT                     ddrval;     // out: Return value
} D3D8_SCENECAPTUREDATA, * PD3D8_SCENECAPTUREDATA;

typedef struct _D3D8_CLEAR2DATA
{
    ULONG_PTR                   dwhContext;     // in:  Context handle

  // dwFlags can contain D3DCLEAR_TARGET, D3DCLEAR_ZBUFFER, and/or D3DCLEAR_STENCIL
    DWORD                       dwFlags;        // in:  surfaces to clear

    DWORD                       dwFillColor;    // in:  Color value for rtarget
    D3DVALUE                    dvFillDepth;    // in:  Depth value for Z buffer (0.0-1.0)
    DWORD                       dwFillStencil;  // in:  value used to clear stencil buffer

    LPD3DRECT                   lpRects;        // in:  Rectangles to clear
    DWORD                       dwNumRects;     // in:  Number of rectangles

    HRESULT                     ddrval;         // out: Return value

    // This is extra stuff passed down to the thunk layer for emulation
    // of Clear for those drivers (DX6) that cant do it themselves.
    HANDLE                  hDDS;       // in:  render target
    HANDLE                  hDDSZ;      // in:  Z buffer
} D3D8_CLEAR2DATA, * PD3D8_CLEAR2DATA;


typedef struct _D3D8_CLEARDATA
{
    ULONG_PTR               dwhContext;     // in:  Context handle

    // dwFlags can contain D3DCLEAR_TARGET or D3DCLEAR_ZBUFFER
    DWORD               dwFlags;        // in:  surfaces to clear

    DWORD               dwFillColor;    // in:  Color value for rtarget
    DWORD               dwFillDepth;    // in:  Depth value for Z buffer

    LPD3DRECT           lpRects;        // in:  Rectangles to clear
    DWORD               dwNumRects;     // in:  Number of rectangles

    HRESULT             ddrval;         // out: Return value
} D3D8_CLEARDATA, * PD3D8_CLEARDATA;

typedef struct _D3D8_SETRENDERTARGETDATA
{
    ULONG_PTR               dwhContext; // in:  Context handle
    HANDLE                  hDDS;       // in:  new render target
    HANDLE                  hDDSZ;      // in:  new Z buffer
    HRESULT                 ddrval;     // out: Return value
    BOOL                    bNeedUpdate;// out: Does runtime need to update
                                        //      driver state.
} D3D8_SETRENDERTARGETDATA, * PD3D8_SETRENDERTARGETDATA;

typedef struct _D3D8_SETPALETTEDATA
{
    HANDLE                  hDD;        // in:  Driver struct
    HANDLE                  hSurface;   // in:  Surface to be used as target
    DWORD                   Palette;    // in:  Palette identifier
    HRESULT                 ddRVal;     // out: Return value
} D3D8_SETPALETTEDATA, * PD3D8_SETPALETTEDATA;

typedef struct _D3D8_UPDATEPALETTEDATA
{
    HANDLE                  hDD;        // in:  Driver struct
    DWORD                   Palette;    // in:  Palette identifier
    LPPALETTEENTRY          ColorTable; // in:  256 entry color table
    HRESULT                 ddRVal;     // out: Return value
} D3D8_UPDATEPALETTEDATA, * PD3D8_UPDATEPALETTEDATA;

//
// Driver callback table
//

DEFINE_GUID( GUID_D3D8Callbacks,    0xb497a1f3, 0x46cc, 0x4fc7, 0xb4, 0xf2, 0x32, 0xd8, 0x9e, 0xf9, 0xcc, 0x27);

typedef HRESULT     (FAR PASCAL *PD3D8DDI_CREATESURFACE)(PD3D8_CREATESURFACEDATA);
typedef HRESULT     (FAR PASCAL *PD3D8DDI_DESTROYSURFACE)(PD3D8_DESTROYSURFACEDATA);
typedef HRESULT     (FAR PASCAL *PD3D8DDI_LOCK)(PD3D8_LOCKDATA);
typedef HRESULT     (FAR PASCAL *PD3D8DDI_UNLOCK)(PD3D8_UNLOCKDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_CONTEXTCREATE)(PD3D8_CONTEXTCREATEDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_CONTEXTDESTROY)(PD3D8_CONTEXTDESTROYDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_CONTEXTDESTROYALL)(PD3D8_CONTEXTDESTROYALLDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_RENDERSTATE) (PD3D8_RENDERSTATEDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_RENDERPRIMITIVE) (PD3D8_RENDERPRIMITIVEDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_DRAWPRIM2)(PD3D8_DRAWPRIMITIVES2DATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_GETDRIVERSTATE)(PD3D8_GETDRIVERSTATEDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_VALIDATETEXTURESTAGESTATE)(PD3D8_VALIDATETEXTURESTAGESTATEDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_SCENECAPTURE)(PD3D8_SCENECAPTUREDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_CLEAR2)(PD3D8_CLEAR2DATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_BLT)(PD3D8_BLTDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_GETSCANLINE)(PD3D8_GETSCANLINEDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_WAITFORVERTICALBLANK)(PD3D8_WAITFORVERTICALBLANKDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_FLIP)(PD3D8_FLIPDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_GETBLTSTATUS)(PD3D8_GETBLTSTATUSDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_GETFLIPSTATUS)(PD3D8_GETFLIPSTATUSDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_GETAVAILDRIVERMEMORY)(PD3D8_GETAVAILDRIVERMEMORYDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_SETMODE)(PD3D8_SETMODEDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_FLIPTOGDISURFACE)(PD3D8_FLIPTOGDISURFACEDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_SETCOLORKEY)(PD3D8_SETCOLORKEYDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_SETEXCLUSIVEMODE)(PD3D8_SETEXCLUSIVEMODEDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_DESTROYDDLOCAL)(PD3D8_DESTROYDDLOCALDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_SETRENDERTARGET)(PD3D8_SETRENDERTARGETDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_CLEAR)(PD3D8_CLEARDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_SETPALETTE)(PD3D8_SETPALETTEDATA);
typedef DWORD       (FAR PASCAL *PD3D8DDI_UPDATEPALETTE)(PD3D8_UPDATEPALETTEDATA);

typedef struct _D3D8_CALLBACKS
{
    PD3D8DDI_CREATESURFACE                  CreateSurface;
    PD3D8DDI_DESTROYSURFACE                 DestroySurface;
    PD3D8DDI_LOCK                           Lock;
    PD3D8DDI_UNLOCK                         Unlock;
    PD3D8DDI_CONTEXTCREATE                  CreateContext;
    PD3D8DDI_CONTEXTDESTROY                 ContextDestroy;
    PD3D8DDI_CONTEXTDESTROYALL              ContextDestroyAll;
    PD3D8DDI_RENDERSTATE                    RenderState;
    PD3D8DDI_RENDERPRIMITIVE                RenderPrimitive;
    PD3D8DDI_DRAWPRIM2                      DrawPrimitives2;
    PD3D8DDI_GETDRIVERSTATE                 GetDriverState;
    PD3D8DDI_VALIDATETEXTURESTAGESTATE      ValidateTextureStageState;
    PD3D8DDI_SCENECAPTURE                   SceneCapture;
    PD3D8DDI_CLEAR2                         Clear2;
    PD3D8DDI_BLT                            Blt;
    PD3D8DDI_GETSCANLINE                    GetScanLine;
    PD3D8DDI_WAITFORVERTICALBLANK           WaitForVerticalBlank;
    PD3D8DDI_FLIP                           Flip;
    PD3D8DDI_GETBLTSTATUS                   GetBltStatus;
    PD3D8DDI_GETFLIPSTATUS                  GetFlipStatus;
    PD3D8DDI_GETAVAILDRIVERMEMORY           GetAvailDriverMemory;
    PD3D8DDI_GETBLTSTATUS                   GetSysmemBltStatus;
    PD3D8DDI_SETMODE                        SetMode;
    PD3D8DDI_SETEXCLUSIVEMODE               SetExclusiveMode;
    PD3D8DDI_FLIPTOGDISURFACE               FlipToGDISurface;
    PD3D8DDI_SETCOLORKEY                    SetColorkey;

    PD3D8DDI_DESTROYDDLOCAL                 DestroyDDLocal;
    PD3D8DDI_SETRENDERTARGET                SetRenderTarget;
    PD3D8DDI_CLEAR                          Clear;
    PD3D8DDI_SETPALETTE                     SetPalette;
    PD3D8DDI_UPDATEPALETTE                  UpdatePalette;
    LPVOID                                  Reserved1; // For device alignment
    LPVOID                                  Reserved2; // For device alignment
} D3D8_CALLBACKS, * PD3D8_CALLBACKS;


//
// D3D8xxx function prototypes to replace the NT Ddxxxx prototypes from GDI32.
// On NT, these are internal functions, but on Win9X DDRAW.DLL must export
// them, so we will change the export names
//

#ifdef WIN95
#define D3D8CreateDirectDrawObject          DdEntry1
#define D3D8QueryDirectDrawObject           DdEntry2
#define D3D8DeleteDirectDrawObject          DdEntry3
#define D3D8GetDC                           DdEntry4
#define D3D8ReleaseDC                       DdEntry5
#define D3D8ReenableDirectDrawObject        DdEntry6
#define D3D8SetGammaRamp                    DdEntry7
#define D3D8BuildModeTable                  DdEntry8
#define D3D8IsDeviceLost                    DdEntry9
#define D3D8CanRestoreNow                   DdEntry10
#define D3D8RestoreDevice                   DdEntry11
#define D3D8DoVidmemSurfacesExist           DdEntry12
#define D3D8SetMode                         DdEntry13
#define D3D8BeginProfile                    DdEntry14
#define D3D8EndProfile                      DdEntry15
#define D3D8GetMode                         DdEntry16
#define D3D8SetCooperativeLevel             DdEntry17
#define D3D8IsDummySurface                  DdEntry18
#define D3D8LoseDevice                      DdEntry19
#define D3D8GetHALName                      DdEntry20

#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifdef WIN95

VOID APIENTRY D3D8CreateDirectDrawObject(
    LPGUID          pGuid,
    char*           szDeviceName,
    HANDLE*         phDD,
    D3DDEVTYPE      Type,
    HINSTANCE*      phLibrary,
    VOID*           pInitFunction
    );

#else

VOID APIENTRY D3D8CreateDirectDrawObject(
    HDC             hdc,
    char*           szDeviceName,
    HANDLE*         phDD,
    D3DDEVTYPE      Type,
    HINSTANCE*      phLibrary,
    VOID*           pInitFunction
    );

#endif

BOOL APIENTRY D3D8QueryDirectDrawObject(
    HANDLE                      hDD,
    PD3D8_DRIVERCAPS            DriverCaps,
    PD3D8_CALLBACKS             Callbacks,
    char*                       DeviceName,
    HINSTANCE                   hLibrary,
    D3D8_GLOBALDRIVERDATA*      pGblDriverData,
    D3DHAL_D3DEXTENDEDCAPS*     pExtendedCaps,
    LPDDSURFACEDESC             pTextureFormats,
    LPDDPIXELFORMAT             pZStencilFormats,
    UINT*                       pcTextureFormats,
    UINT*                       pcZStencilFormats
    );

HDC APIENTRY D3D8GetDC(
    HANDLE                    hSurface,
    LPPALETTEENTRY            pPalette
    );

BOOL APIENTRY D3D8ReleaseDC(
    HANDLE                  hSurface,
    HDC                     hdc
    );

BOOL APIENTRY D3D8ReenableDirectDrawObject(
    HANDLE                  hDD,
    BOOL*                   pbNewMode
    );

BOOL APIENTRY D3D8SetGammaRamp(
    HANDLE      hDD,
    HDC         hdc,
    LPVOID      lpGammaRamp
    );

VOID APIENTRY D3D8BuildModeTable(
    char*               pDeviceName,
    D3DDISPLAYMODE*     pModeTable,
    DWORD*              pNumEntries,
    D3DFORMAT           Unknown16,
    HANDLE              hProfile,
    BOOL                b16bppSupported,
    BOOL                b32bppSupported
    );

BOOL APIENTRY D3D8IsDeviceLost(
    HANDLE              hDD
    );

BOOL APIENTRY D3D8CanRestoreNow(
    HANDLE              hDD
    );

VOID APIENTRY D3D8RestoreDevice(
    HANDLE hDD
    );

BOOL APIENTRY D3D8DoVidmemSurfacesExist(
    HANDLE hDD
    );

VOID APIENTRY D3D8DeleteDirectDrawObject(
    HANDLE hDD
   );

HANDLE APIENTRY D3D8BeginProfile(
    char* pDeviceName
    );

VOID APIENTRY D3D8EndProfile(
    HANDLE Handle
    );

DWORD APIENTRY D3D8GetMode(
    HANDLE          Handle,
    char*           pDeviceName,
    D3DDISPLAYMODE* pMode,
    D3DFORMAT       Unknown16
    );

DWORD APIENTRY D3D8SetMode(
    HANDLE  Handle,
    char*   pDeviceName,
    UINT    Width,
    UINT    Height,
    UINT    BPP,
    UINT    RefreshRate,
    BOOL    bRestore
    );

DWORD APIENTRY D3D8SetCooperativeLevel(
    HANDLE hDD,
    HWND hWnd,
    DWORD dwFlags );

VOID APIENTRY D3D8LoseDevice(
    HANDLE hDD);

__inline DWORD D3D8GetDrawPrimHandle(HANDLE hSurface)
{
    return *(DWORD *)(hSurface);
}

BOOL APIENTRY D3D8IsDummySurface(
    HANDLE hSurface );

VOID APIENTRY D3D8GetHALName(
    char* pDisplayName, 
    char *pDriverName );


#ifdef __cplusplus
}
#endif


typedef struct _D3D8_DEVICEDATA
{
    D3D8_DRIVERCAPS         DriverData;
    D3D8_CALLBACKS          Callbacks;
    DWORD                   dwFlags;
    char                    DriverName[MAX_DRIVER_NAME];
//    RECT                    DeviceRect;
    HDC                     hDC;
    GUID                    Guid;
    HANDLE                  hDD;
    D3DDEVTYPE              DeviceType;
    HINSTANCE               hLibrary;
    struct _D3D8_DEVICEDATA* pLink;
//    D3DDISPLAYMODE*       pModeTable;
//    DWORD                   dwNumModes;
} D3D8_DEVICEDATA, * PD3D8_DEVICEDATA;

#define DD_DISPLAYDRV       0x00000001
#define DD_GDIDRV           0x00000002

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\inc\d3dfe.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dfe.hpp
 *  Content:    Direct3D internal include file
 *              for geometry pipeline implementations
 *
 ***************************************************************************/

// DX8 Copy the whole file to DX8


#ifndef _D3DFE_H
#define _D3DFE_H

#include "d3dtypesp.h"
#include "d3d8p.h"
#include "lists.hpp"
#include "d3ditype.h"

class RTDebugMonitor;
class CD3DDDI;
class ID3DFE_PVFUNCS;
struct CVStream;

const DWORD __MAX_VERTEX_SIZE = 180;    // Max size of FVF vertex in bytes
//-----------------------------------------------------------------------------
// "link" member should be the last, because we copy the structure using
// offsetof(D3DMATRIXI, link)
//
#define D3DMATRIXI D3DMATRIX
#define LPD3DMATRIXI LPD3DMATRIX

// Bits for m_dwOutRegs
const DWORD CPSGPShader_SPECULAR   = 1 << 0;
const DWORD CPSGPShader_DIFFUSE    = 1 << 1;
const DWORD CPSGPShader_POSITION   = 1 << 2;
const DWORD CPSGPShader_PSIZE      = 1 << 3;
const DWORD CPSGPShader_FOG        = 1 << 4;

//-----------------------------------------------------------------------------
// Base class for PSGP vertex shader
// PSGP should derive its internal shader object from the class and return it
// in CreateShader call.
// Desctructor should be implemented.
//
class CPSGPShader
{
public:
    virtual ~CPSGPShader() {}

    // The following data is initialized by Microsoft after CPSGPShader is
    // created

    // Defines output registers (except texture) written by the shader
    // This member is filled by Microsoft's pipeline. PSGP reads it.
    DWORD   m_dwOutRegs;
    // Output FVF for this shaders
    DWORD   m_dwOutFVF;
    // Diffuse color offset in the output vertex in bytes
    DWORD   m_dwPointSizeOffset;
    // Diffuse color offset in the output vertex in bytes
    DWORD   m_dwDiffuseOffset;
    // Specular color offset in the output vertex in bytes
    DWORD   m_dwSpecularOffset;
    // Fog factor offset in the output vertex in bytes
    DWORD   m_dwFogOffset;
    // Texture offset in the output vertex in bytes
    DWORD   m_dwTextureOffset;
    // Output vertex size in bytes
    DWORD   m_dwOutVerSize;
    // Number of output texture coordinate sets
    DWORD   m_nOutTexCoord;
    // Size of each texture set in bytes
    DWORD   m_dwOutTexCoordSize[D3DDP_MAXTEXCOORD];
};
//-----------------------------------------------------------------------------
//
// Software pipeline constants
//
//-----------------------------------------------------------------------------

// Default color values that should be used when ther is no lighting and
// color in vertices provided
const DWORD __DEFAULT_DIFFUSE = 0xFFFFFFFF;
const DWORD __DEFAULT_SPECULAR = 0;

const DWORD __MAXUSERCLIPPLANES = 6;

const DWORD __NUMELEMENTS = 17;
const DWORD __NUMSTREAMS = __NUMELEMENTS;

//-----------------------------------------------------------------------------
// The CSetD3DFPstate is used to facilitate the changing of FPU settings.
// In the constructor the optimal FPU state is set. In the destructor the
// old state is restored.
//
class CD3DFPstate
{
public:
    CD3DFPstate()
        {
        #ifdef _X86_
            WORD wTemp, wSave;
            wSavedFP = FALSE;
            // Disable floating point exceptions and go to single mode
                __asm fstcw wSave
                if (wSave & 0x300 ||            // Not single mode
                    0x3f != (wSave & 0x3f) ||   // Exceptions enabled
                    wSave & 0xC00)              // Not round to nearest mode
                {
                    __asm {
                        mov ax, wSave
                        and ax, not 300h    ;; single mode
                        or  ax, 3fh         ;; disable all exceptions
                        and ax, not 0xC00   ;; round to nearest mode
                        mov wTemp, ax
                        fldcw   wTemp
                    }
                    wSavedFP = TRUE;
                }
                wSaveFP = wSave;
        #endif
        }
    ~CD3DFPstate()
        {
        #ifdef _X86_
            WORD wSave = wSaveFP;
            if (wSavedFP)
                __asm {
                    fnclex
                    fldcw   wSave
                }
        #endif
        }
protected:
#ifdef _X86_
    WORD wSaveFP;
    WORD wSavedFP;  // WORD-sized to make the data an even DWORD
#endif
};

#define RESPATH_D3D "Software\\Microsoft\\Direct3D"

// this is not available for alpha or IA64
#ifndef LONG_MAX
#define LONG_MAX      2147483647L   /* maximum (signed) long value */
#endif

//-----------------------------------------------------------------------------
// Base definitions
//

// Size of Microsoft's internal clip vertex batch
const DWORD VER_IN_BATCH = 8;

typedef WORD D3DFE_CLIPCODE;

struct BATCHBUFFER;
//-----------------------------------------------------------------------------
struct _D3DFE_LIGHTING;
typedef struct _D3DFE_LIGHTING D3DFE_LIGHTING;

struct _D3DI_LIGHT;
typedef struct _D3DI_LIGHT D3DI_LIGHT;

class D3DFE_PROCESSVERTICES;
typedef class D3DFE_PROCESSVERTICES* LPD3DFE_PROCESSVERTICES;

extern "C"
{
typedef void (*LIGHT_VERTEX_FUNC)(LPD3DFE_PROCESSVERTICES pv,
                                  D3DI_LIGHT *light,
                                  D3DVERTEX *pInpCoord,
                                  D3DVALUE* pWeights,
                                  BYTE* pMatrixIndices,
                                  D3DVECTOR *pInpNormal,
                                  D3DLIGHTINGELEMENT *pEyeSpaceData);
typedef void (*PFN_LIGHTLOOP)(LPD3DFE_PROCESSVERTICES pv,
                              DWORD dwVerCount,
                              BATCHBUFFER *pBatchBuffer,
                              D3DI_LIGHT *light,
                              D3DVERTEX *in,
                              D3DVALUE* pWeights,
                              BYTE* pMatrixIndices,
                              D3DVECTOR *pNormal,
                              DWORD *pDiffuse,
                              DWORD *pSpecular);
}
//-----------------------------------------------------------------------------
// This is per texture stage data
//
typedef struct _D3DFE_TEXTURESTAGE
{
    // Original value of the texture stage - input index
    DWORD       dwInpCoordIndex;
    // Texture coord offset in the FVF vertex
    DWORD       dwInpOffset;
    // Input index of the texture set is mapped to this output index
    DWORD       dwOutCoordIndex;
    DWORD       dwOrgStage;         // Original texture stage
    DWORD       dwOrgWrapMode;      // Original WRAP mode
    // NULL if texture transform is disabled for the stage
    D3DMATRIXI *pmTextureTransform;
    // This is index to a table of functions which perform texture transform.
    // Index is computed as follow:
    //      bits 0-1 - (number of input  texture coordinates - 1)
    //      bits 2-3 - (number of output texture coordinates - 1)
    DWORD       dwTexTransformFuncIndex;
    // Mode of texture generation. This is the same value, passed with 
    // D3DTSS_TEXCOORDINDEX, but with texture index stripped out.
    DWORD       dwTexGenMode;       
    // Set to TRUE, when we need to divide texture coordinates by the last
    // element of a texture coordinate set
    BOOL        bDoTextureProjection;
} D3DFE_TEXTURESTAGE, *LPD3DFE_TEXTURESTAGE;
//-----------------------------------------------------------------------------
typedef struct _RECTV
{
    union
    {
        D3DVALUE x1;
        D3DVALUE dvX1;
    };
    union
    {
        D3DVALUE y1;
        D3DVALUE dvY1;
    };
    union
    {
        D3DVALUE x2;
        D3DVALUE dvX2;
    };
    union
    {
        D3DVALUE y2;
        D3DVALUE dvY2;
    };
} D3DRECTV, *LPD3DRECTV;
//-----------------------------------------------------------------------------
/*
 * Lighting defines
 */
typedef struct _SpecularTable
{
    LIST_MEMBER(_SpecularTable) list;
    float   power;          /* shininess power */
    float   table[260];     /* space for overflows */
} SpecularTable;

typedef struct {D3DVALUE r,g,b;} D3DFE_COLOR;
//-----------------------------------------------------------------------------
// Internal version of lightdata and constants for "flags" member of D3DI_LIGHT
//
const DWORD D3DLIGHTI_ATT0_IS_NONZERO   = 1 << 0;
const DWORD D3DLIGHTI_ATT1_IS_NONZERO   = 1 << 1;
const DWORD D3DLIGHTI_ATT2_IS_NONZERO   = 1 << 2;
const DWORD D3DLIGHTI_LINEAR_FALLOFF    = 1 << 3;
// Set when light data is changed
const DWORD D3DLIGHTI_DIRTY             = 1 << 4;
// This flag depends on D3DRS_SPACULARENABLE and light specular color
const DWORD D3DLIGHTI_COMPUTE_SPECULAR  = 1 << 5;
// Set when the light is enabled
const DWORD D3DLIGHTI_ENABLED           = 1 << 7;
const DWORD D3DLIGHTI_SPECULAR_IS_ZERO  = 1 << 8;
const DWORD D3DLIGHTI_AMBIENT_IS_ZERO   = 1 << 9;
// Set when we need to send the light to the driver when switching to the
// hardware vertex processing mode.
const DWORD D3DLIGHTI_UPDATEDDI         = 1 << 10;
// Set when we need to send "enable" state of the light to the driver when
// switching to the hardware vertex processing mode
const DWORD D3DLIGHTI_UPDATE_ENABLE_DDI = 1 << 11;

const DWORD D3DLIGHTI_OPTIMIZATIONFLAGS = D3DLIGHTI_SPECULAR_IS_ZERO |
                                          D3DLIGHTI_AMBIENT_IS_ZERO  |
                                          D3DLIGHTI_ATT0_IS_NONZERO  |
                                          D3DLIGHTI_ATT1_IS_NONZERO  |
                                          D3DLIGHTI_ATT2_IS_NONZERO  |
                                          D3DLIGHTI_LINEAR_FALLOFF;
//-----------------------------------------------------------------------------
// Members of this structure should be aligned as stated
typedef struct _D3DI_LIGHT
{
    // Should be QWORD aligned
    D3DVECTOR       model_position; // In the camera or model space
    D3DLIGHTTYPE    type;
    // Should be QWORD aligned
    D3DVECTOR       model_direction;// In the camera or model space
    D3DVALUE        falloff;
    // Should be QWORD aligned
    DWORD           flags;
    // Should be QWORD aligned. R,G,B should be adjacent
    D3DFE_COLOR     diffuseMat;     // Material diffuse times light color
    // Should be QWORD aligned. R,G,B should be adjacent
    D3DFE_COLOR     specularMat;    // Material specular times light color
    // Should be QWORD aligned. R,G,B should be adjacent
    D3DFE_COLOR     ambientMat;     // Material specular times light color
    D3DVALUE        inv_theta_minus_phi;
    // Should be QWORD aligned
    D3DVECTOR       halfway;        // Used by directional, parallel-point and
                                    // spot lights when camera is in infinity
    struct _D3DI_LIGHT *next;       // Next in the active light list
    // Should be QWORD aligned
    D3DFE_COLOR     diffuse;        // Original color scaled to 0 - 255
    D3DFE_COLOR     specular;       // Original color scaled to 0 - 255
    D3DFE_COLOR     ambient;        // Original color scaled to 0 - 255

    LIGHT_VERTEX_FUNC lightVertexFunc;  // Function to light a D3DVERTEX

    D3DVALUE        range_squared;
    D3DVALUE        attenuation0;
    D3DVALUE        attenuation1;
    D3DVALUE        attenuation2;
    D3DVALUE        cos_theta_by_2;
    D3DVALUE        cos_phi_by_2;
    D3DVECTOR       position;       // In the world space
    D3DVECTOR       direction;      // In the world space
    D3DVALUE        range;
    // Pointer to a PSGP specific "per light" data
    LPVOID          pPSGPData;
// Microsoft's pipeline specific data
    // Used in multi-loop pipeline for first lights
    PFN_LIGHTLOOP   pfnLightFirst;
    // Used in multi-loop pipeline for not first lights
    PFN_LIGHTLOOP   pfnLightNext;
} D3DI_LIGHT, *LPD3DI_LIGHT;
//-----------------------------------------------------------------------------
// Bits for lighting flags (dwLightingFlags
//
const DWORD __LIGHT_VERTEXTRANSFORMED = 1;  // Vertex is in the camera space
const DWORD __LIGHT_NORMALTRANSFORMED = 2;  // Normal is in the camera space
const DWORD __LIGHT_SPECULARCOMPUTED  = 4;
const DWORD __LIGHT_DIFFUSECOMPUTED   = 8;
//-----------------------------------------------------------------------------
// Members of this structure should be aligned as stated
//
typedef struct _D3DFE_LIGHTING
{
// Temporary data used when computing lighting
    // Should be QWORD aligned
    D3DFE_COLOR       diffuse;
    DWORD             alpha;          // Alpha to use for output vertex color
                                      // (could be overriden by vertex difuse
                                      // color) (0-255) shifted left by 24 bits
    // Should be QWORD aligned
    D3DFE_COLOR       diffuse0;       // Ca*Cma + Cme
    float            *currentSpecTable;
    // Should be QWORD aligned
    D3DFE_COLOR       specular;
    DWORD             outDiffuse;     // Result of lighting
    // Should be QWORD aligned
    D3DVECTOR         model_eye;      // camera position in model (camera) space
    DWORD             vertexAmbient;  // Provided with a vertex
    // Should be QWORD aligned
    D3DFE_COLOR       ambientSceneScaled; // Scene ambient color (scaled 0-255)
    DWORD             vertexDiffuse;  // Provided with a vertex
    // Should be QWORD aligned
    D3DFE_COLOR       ambientScene;         // Scene ambient color (0.0-1.0)
    DWORD             outSpecular;    // Result of lighting
    // Should be QWORD aligned
    // Direction to camera in the model space. Used in model space lighting
    D3DVECTOR         directionToCamera;
    DWORD             vertexSpecular;       // Provided with a vertex
    // Should be QWORD aligned
    D3DMATERIAL8      material;
    DWORD             dwLightingFlags;
    // Alpha to use for output specular vertex color
    // (could be overriden by vertex specular color)
    // (0-255) shifted left by 24 bits
    DWORD             alphaSpecular;
// End of temporary data
    D3DI_LIGHT       *activeLights;
    int               fog_mode;
    D3DVALUE          fog_density;
    D3DVALUE          fog_start;
    D3DVALUE          fog_end;
    D3DVALUE          fog_factor;     // 255 / (fog_end - fog_start)
    D3DVALUE          specThreshold;  // If a dot product less than this value,
                                      // specular factor is zero
    DWORD             ambient_save;   // Original unscaled color
    int               materialAlpha;  // Current material diffuse alpha (0-255)
                                      // shifted left by 24 bits
    int               materialAlphaS; // Current material specular alpha (0-255)
                                      // shifted left by 24 bits
    DWORD             dwDiffuse0;     // Packed diffuse0
    DWORD             dwAmbientSrcIndex;    // 0 - diffuse, 1 - specular
    DWORD             dwDiffuseSrcIndex;    // 0 - diffuse, 1 - specular
    DWORD             dwSpecularSrcIndex;   // 0 - diffuse, 1 - specular
    DWORD             dwEmissiveSrcIndex;   // 0 - diffuse, 1 - specular
} D3DFE_LIGHTING;
//-----------------------------------------------------------------------------
// Some data precomputed for a current viewport
// ATTENTION: If you want to add or re-arrange data, contact IOURIT or ANUJG
//
typedef struct _D3DFE_VIEWPORTCACHE
{
// Coefficients to compute screen coordinates from normalized window
// coordinates
    D3DVALUE scaleX;            // dvWidth
    D3DVALUE scaleY;            // -dvHeight
    D3DVALUE offsetX;           // dvX
    D3DVALUE offsetY;           // dvY + dvHeight
    D3DVALUE scaleZ;            // dvMaxZ - dvMinZ
    D3DVALUE offsetZ;           // dvY + dvHeight
// Min and max window values with gaurd band in pixels
    D3DVALUE minXgb;
    D3DVALUE minYgb;
    D3DVALUE maxXgb;
    D3DVALUE maxYgb;
// Min and max values for viewport window in pixels
    D3DVALUE minX;              // offsetX - scaleX
    D3DVALUE minY;              // offsetY - scaleY
    D3DVALUE maxX;              // offsetX + scaleX
    D3DVALUE maxY;              // offsetY + scaleY
// Coefficients to transform a vertex to perform the guard band clipping
// x*gb11 + w*gb41
// y*gb22 + w*gb42
//
    D3DVALUE gb11;
    D3DVALUE gb22;
    D3DVALUE gb41;
    D3DVALUE gb42;
// Coefficients to apply clipping rules for the guard band clipping
// They are used by clipping routins
// w*Kgbx1 < x < w*Kgbx2
// w*Kgby1 < y < w*Kgby2
//
    D3DVALUE Kgbx1;
    D3DVALUE Kgby1;
    D3DVALUE Kgbx2;
    D3DVALUE Kgby2;

    D3DVALUE dvX;               // dwX
    D3DVALUE dvY;               // dwY
    D3DVALUE dvWidth;           // dwWidth
    D3DVALUE dvHeight;          // dwHeight
// Coefficients to compute screen coordinates from normalized window
// coordinates
    D3DVALUE scaleXi;           // Inverse of scaleX
    D3DVALUE scaleYi;           // Inverse of scaleY
    D3DVALUE scaleZi;           // Inverse of scaleZ
// Min and max values for viewport window in pixels (integer version)
    int      minXi;             // offsetX - scaleX
    int      minYi;             // offsetY - scaleY
    int      maxXi;             // offsetX + scaleX
    int      maxYi;             // offsetY + scaleY
} D3DFE_VIEWPORTCACHE;
//-----------------------------------------------------------------------------
// Process vertices interface
//
// Bits for process vertices flags
//
// D3DDEV_STRIDE D3DPV_SOA
//      0         1       position.dwStride = number of vertices in SOA
//      0         0       position.dwStride = contiguous vertex size
//      1         0       vertex is not contiguous, all dwStride fields are used
//      1         1       reserved
//      1         1       reserved
//
// Do position tweening. Guaranties that position2 pointer is not NULL
const DWORD D3DPV_POSITION_TWEENING = 1 << 6;  
// Do normal tweening. Guaranties that normal2 pointer is not NULL
const DWORD D3DPV_NORMAL_TWEENING= 1 << 7;
const DWORD D3DPV_FOG            = 1 << 8;  // Need to apply fog
const DWORD D3DPV_DOCOLORVERTEX  = 1 << 9;  // Need to apply color vertex
const DWORD D3DPV_LIGHTING       = 1 << 10; // Need to apply lighting
const DWORD D3DPV_SOA            = 1 << 12; // SOA structure is used
// Need to replace emissive material color
const DWORD D3DPV_COLORVERTEX_E  = 1 << 13;
// Need to replace diffuse material color
const DWORD D3DPV_COLORVERTEX_D  = 1 << 14;
// Need to replace specular material color
const DWORD D3DPV_COLORVERTEX_S  = 1 << 15;
// Need to replace ambient material color
const DWORD D3DPV_COLORVERTEX_A  = 1 << 16;
// Set by ProcessVertices call with D3DPV_DONOTCOPYDATA flag set
// Specular color should not be copied to the output vertex
const DWORD D3DPV_DONOTCOPYSPECULAR = 1 << 20;
// Set when one pass clipping and vertex processing is used
const DWORD D3DPV_ONEPASSCLIPPING= 1 << 21;
// This indicates that the primitive is non clipped, but we pretend that it is
// clipped to generate DP2HAL inline primitive. Can only be set by tri fan.
const DWORD D3DPV_NONCLIPPED     = 1 << 25;
// Propagated from dwFEFlags
const DWORD D3DPV_FRUSTUMPLANES_DIRTY = 1 << 26;
// Set if the geometry loop is called from VertexBuffer::ProcessVertices.
// Processing is different because the output buffer FVF format is defined by
// user, not by SetupFVFData function.
const DWORD D3DPV_VBCALL         = 1 << 27;
// Set by ProcessVertices call with D3DPV_DONOTCOPYDATA flag set
// Texture coordinates should not be copied to the output vertex
const DWORD D3DPV_DONOTCOPYTEXTURE = 1 << 28;
// To mark whether we are doing TLVERTEX clipping or not
const DWORD D3DPV_TLVCLIP        = 1 << 29;
// Mictosoft internal !!! Set when only transformation is required
// (no lightng or texture copy)
const DWORD D3DPV_TRANSFORMONLY  = 1 << 30;
// Set by ProcessVertices call with D3DPV_DONOTCOPYDATA flag set
// Diffuse color should not be copied to the output vertex
const DWORD D3DPV_DONOTCOPYDIFFUSE = 1 << 31;
// These flags persist from call to call till something causes them to change
const DWORD D3DPV_PERSIST = D3DPV_FOG                   |
                            D3DPV_LIGHTING              |
                            D3DPV_DONOTCOPYDIFFUSE      |
                            D3DPV_DONOTCOPYSPECULAR     |
                            D3DPV_DONOTCOPYTEXTURE      |
                            D3DPV_POSITION_TWEENING     |
                            D3DPV_NORMAL_TWEENING       |
                            D3DPV_TRANSFORMONLY ;

// Bits for dwDeviceFlags
//
const DWORD D3DDEV_GUARDBAND     = 1 << 1;  // Use guard band clipping
const DWORD D3DDEV_RANGEBASEDFOG = 1 << 2;  // Set if range based fog is enabled
// This bit is set if fog mode is not FOG_NONE and fog is enabled
const DWORD D3DDEV_FOG           = 1 << 3;
// Set when there is no need to compute clip codes, because there are already
// computed
const DWORD D3DDEV_DONOTCOMPUTECLIPCODES = 1 << 4;
// Set when stream source or a shader have been changed
// PSGP should clear the bit
const DWORD D3DDEV_SHADERDIRTY   = 1 << 5;
// Copy of D3DFVFCAPS_DONOTSTRIPELEMENTS
const DWORD D3DDEV_DONOTSTRIPELEMENTS = 1 << 6;
// Vertex shaders are used. If this bit is not set, fixed function pipeline is
// used
const DWORD D3DDEV_VERTEXSHADERS = 1 << 7;
// Set, when a vertex buffer, which was a destination for ProcessVerticess,
// is used as a stream source
const DWORD D3DDEV_VBPROCVER      = 1 << 8;
// Set when we need to do emulation of point sprites (Microsoft specific)
const D3DDEV_DOPOINTSPRITEEMULATION =   1 << 9;
// These are bits in dwDeviceFlags that could be changed, but not
// necessary per every primitive.
//
// Set when D3DRS_SHADEMODE is D3DSHADE_FLAT
const DWORD D3DDEV_FLATSHADEMODE        = 1 << 10;
// Set when D3DRS_SPECULARENABLE is TRUE
const DWORD D3DDEV_SPECULARENABLE       = 1 << 11;
// Set when transformed vertices are passed to the front-end
const DWORD D3DDEV_TRANSFORMEDFVF       = 1 << 12;
// Set when D3DRS_INDEXEDVERTEXBLENDENABLE is true
const DWORD D3DDEV_INDEXEDVERTEXBLENDENABLE = 1 << 13;
// This flag is for PSGP only. PSGP implementation should clear the flag
const DWORD D3DDEV_FRUSTUMPLANES_DIRTY  = 1 << 14;
// This flag is for PSGP only. PSGP implementation should clear the flag
// Need to re-evaluate texture transforms
const DWORD D3DDEV_TEXTRANSFORMDIRTY    = 1 << 15;
// The flag is set when the number of output texture coord is greater then the
// number of the input ones. This could happen when the same texture transform
// matrix is used with the same input texture coord set. In this case we save
// texture indices from the texture stages in the textureStages and map all
// indices sequentially.
const DWORD D3DDEV_REMAPTEXTUREINDICES  = 1 << 16;

// These two flags are for PSGP only. PSGP implementation should clear the flags
// Transform matrix has been changed
const DWORD D3DDEV_TRANSFORMDIRTY       = 1 << 17;
 // Lights have been changed
const DWORD D3DDEV_LIGHTSDIRTY          = 1 << 18;

 // Clipping is disabled
const DWORD D3DDEV_DONOTCLIP            = 1 << 19;
// World-view matrix does not have scale, so we can do lighting
// in the model space
const DWORD D3DDEV_MODELSPACELIGHTING   = 1 << 23;
// Set if viewer is local (used for lighting)
const DWORD D3DDEV_LOCALVIEWER          = 1 << 24;
// Set if we wave to normalize normals after transforming them to the
// camera space
const DWORD D3DDEV_NORMALIZENORMALS     = 1 << 25;
// Set if we wave to do texture transform
const DWORD D3DDEV_TEXTURETRANSFORM     = 1 << 26;
// Set if the last draw primitive call was strided
const DWORD D3DDEV_STRIDE               = 1 << 27;
// Set if D3DRS_COLORVERTEX is TRUE
const DWORD D3DDEV_COLORVERTEX          = 1 << 28;
// Set if position in camera space is always needed
const DWORD D3DDEV_POSITIONINCAMERASPACE= 1 << 29;
// Set if normal in camera space is always needed
const DWORD D3DDEV_NORMALINCAMERASPACE  = 1 << 30;
// Set if D3DRS_LIGHTING is set
const DWORD D3DDEV_LIGHTING             = 1 << 31;
//-----------------------------------------------------------------------------
// Clipper defines
//

// Six standard clipping planes plus six user defined clipping planes.
// See rl\d3d\d3d\d3dtypes.h.
//

#define MAX_CLIPPING_PLANES 12

// Space for vertices generated/copied while clipping one triangle

#define MAX_CLIP_VERTICES   (( 2 * MAX_CLIPPING_PLANES ) + 3 )

// 3 verts. -> 1 tri, 4 v -> 2 t, N vertices -> (N - 2) triangles

#define MAX_CLIP_TRIANGLES  ( MAX_CLIP_VERTICES - 2 )

const DWORD MAX_FVF_TEXCOORD = 8;

class ClipVertex
{
public:
    D3DVALUE    hx;     // Clipping space coordinates. Must be in this order
    D3DVALUE    hy;
    D3DVALUE    hz;
    D3DVALUE    hw;
    int         clip;
    D3DCOLOR    color;
    D3DCOLOR    specular;
    D3DVALUE    sx;     // Screen space coordinates. Must be in this order
    D3DVALUE    sy;
    D3DVALUE    sz;
    D3DVALUE    rhw;
    ClipVertex *next;
    D3DVALUE    tex[MAX_FVF_TEXCOORD*4];
};

typedef struct _ClipTriangle
{
    ClipVertex  *v[3];
} ClipTriangle;

typedef struct _D3DI_CLIPSTATE
{
    ClipVertex  *clip_vbuf1[MAX_CLIP_VERTICES];
    ClipVertex  *clip_vbuf2[MAX_CLIP_VERTICES];
    ClipVertex **current_vbuf;  // clip_vbuf1 or clip_vbuf2
    ClipVertex  clip_vertices[MAX_CLIP_VERTICES];
    BYTE       *clipBuf;      // Used for TL vertices, generated by the clipper
    int         clip_vertices_used;
    DWORD       clip_color;
    DWORD       clip_specular;
} D3DI_CLIPSTATE, *LPD3DI_CLIPSTATE;

// These bit are set when a vertex is clipped by a frustum plane

#define CLIPPED_LEFT    (D3DCS_PLANE5 << 1)
#define CLIPPED_RIGHT   (D3DCS_PLANE5 << 2)
#define CLIPPED_TOP     (D3DCS_PLANE5 << 3)
#define CLIPPED_BOTTOM  (D3DCS_PLANE5 << 4)
#define CLIPPED_FRONT   (D3DCS_PLANE5 << 5)
#define CLIPPED_BACK    (D3DCS_PLANE5 << 6)

#define CLIPPED_ENABLE  (D3DCS_PLANE5 << 7) /* wireframe enable flag */

// These bit are set when a vertex is clipped by a user clipping plane

const DWORD CLIPPED_PLANE0 = D3DCS_PLANE5 << 8;
const DWORD CLIPPED_PLANE1 = D3DCS_PLANE5 << 9;
const DWORD CLIPPED_PLANE2 = D3DCS_PLANE5 << 10;
const DWORD CLIPPED_PLANE3 = D3DCS_PLANE5 << 11;
const DWORD CLIPPED_PLANE4 = D3DCS_PLANE5 << 12;
const DWORD CLIPPED_PLANE5 = D3DCS_PLANE5 << 13;

// Guard band clipping bits
//
// A guard bit is set when a point is out of guard band
// Guard bits should be cleared before a call to clip a triangle, because
// they are the same as CLIPPED_... bits
//
// Example of clipping bits setting for X coordinate:
//
// if -w < x < w           no clipping bit is set
// if -w*ax1 < x <= -w     D3DCS_LEFT bit is set
// if x < -w*ax1           __D3DCLIPGB_LEFT bit is set
//
#define __D3DCLIPGB_LEFT    (D3DCS_PLANE5 << 1)
#define __D3DCLIPGB_RIGHT   (D3DCS_PLANE5 << 2)
#define __D3DCLIPGB_TOP     (D3DCS_PLANE5 << 3)
#define __D3DCLIPGB_BOTTOM  (D3DCS_PLANE5 << 4)
#define __D3DCLIPGB_ALL (__D3DCLIPGB_LEFT | __D3DCLIPGB_RIGHT | \
                         __D3DCLIPGB_TOP | __D3DCLIPGB_BOTTOM)

const DWORD __D3DCS_USERPLANES =  D3DCS_PLANE0 | D3DCS_PLANE1 |
                                    D3DCS_PLANE2 | D3DCS_PLANE3 |
                                    D3DCS_PLANE4 | D3DCS_PLANE5;
// If only these bits are set, then this point is inside the guard band
//
#define __D3DCS_INGUARDBAND (D3DCS_LEFT | D3DCS_RIGHT | \
                               D3DCS_TOP  | D3DCS_BOTTOM)

//---------------------------------------------------------------------
// Bits in the dwFlags2
//
// The bit is set when the texture transform is enabled
const DWORD __FLAGS2_TEXTRANSFORM0 = 1 << 0;
const DWORD __FLAGS2_TEXTRANSFORM1 = 1 << 1;
const DWORD __FLAGS2_TEXTRANSFORM2 = 1 << 2;
const DWORD __FLAGS2_TEXTRANSFORM3 = 1 << 3;
const DWORD __FLAGS2_TEXTRANSFORM4 = 1 << 4;
const DWORD __FLAGS2_TEXTRANSFORM5 = 1 << 5;
const DWORD __FLAGS2_TEXTRANSFORM6 = 1 << 6;
const DWORD __FLAGS2_TEXTRANSFORM7 = 1 << 7;

const DWORD __FLAGS2_TEXTRANSFORM = __FLAGS2_TEXTRANSFORM0 |
                                    __FLAGS2_TEXTRANSFORM1 |
                                    __FLAGS2_TEXTRANSFORM2 |
                                    __FLAGS2_TEXTRANSFORM3 |
                                    __FLAGS2_TEXTRANSFORM4 |
                                    __FLAGS2_TEXTRANSFORM5 |
                                    __FLAGS2_TEXTRANSFORM6 |
                                    __FLAGS2_TEXTRANSFORM7;
// The bit is set when texture projection is enabled for the stage and we need
// to do emulation, because device does not support projected textures.
const DWORD __FLAGS2_TEXPROJ0 = 1 << 8;
const DWORD __FLAGS2_TEXPROJ1 = 1 << 9;
const DWORD __FLAGS2_TEXPROJ2 = 1 << 10;
const DWORD __FLAGS2_TEXPROJ3 = 1 << 11;
const DWORD __FLAGS2_TEXPROJ4 = 1 << 12;
const DWORD __FLAGS2_TEXPROJ5 = 1 << 13;
const DWORD __FLAGS2_TEXPROJ6 = 1 << 14;
const DWORD __FLAGS2_TEXPROJ7 = 1 << 15;

const DWORD __FLAGS2_TEXPROJ = __FLAGS2_TEXPROJ0 |
                               __FLAGS2_TEXPROJ1 |
                               __FLAGS2_TEXPROJ2 |
                               __FLAGS2_TEXPROJ3 |
                               __FLAGS2_TEXPROJ4 |
                               __FLAGS2_TEXPROJ5 |
                               __FLAGS2_TEXPROJ6 |
                               __FLAGS2_TEXPROJ7;
// The bit is set when the texture coordinate set is taken from the vertex data
// (position or normal)
const DWORD __FLAGS2_TEXGEN0 = 1 << 16;
const DWORD __FLAGS2_TEXGEN1 = 1 << 17;
const DWORD __FLAGS2_TEXGEN2 = 1 << 18;
const DWORD __FLAGS2_TEXGEN3 = 1 << 19;
const DWORD __FLAGS2_TEXGEN4 = 1 << 20;
const DWORD __FLAGS2_TEXGEN5 = 1 << 21;
const DWORD __FLAGS2_TEXGEN6 = 1 << 22;
const DWORD __FLAGS2_TEXGEN7 = 1 << 23;

const DWORD __FLAGS2_TEXGEN = __FLAGS2_TEXGEN0 |
                              __FLAGS2_TEXGEN1 |
                              __FLAGS2_TEXGEN2 |
                              __FLAGS2_TEXGEN3 |
                              __FLAGS2_TEXGEN4 |
                              __FLAGS2_TEXGEN5 |
                              __FLAGS2_TEXGEN6 |
                              __FLAGS2_TEXGEN7;
//---------------------------------------------------------------------
#define __TEXTURETRANSFORMENABLED(pv) (pv->dwFlags2 & __FLAGS2_TEXTRANSFORM)

//---------------------------------------------------------------------
//
// CVElement: Describes a vertex element
//            Array of this type is passed to PSGP to create a vertex shader
//
//---------------------------------------------------------------------
class CVElement
{
public:
    DWORD   m_dwRegister;   // Input register index
    DWORD   m_dwDataType;   // Data type and dimension
    // -------- Private Microsoft Data ---------
    // Pointer to a function to convert input vertex element data type to
    // the VVM_WORD
    LPVOID  m_pfnCopy;
    // API stream index
    DWORD   m_dwStreamIndex;
    // Offset in the input stream in bytes
    DWORD   m_dwOffset;
};
//-----------------------------------------------------------------------------
// Data structure used to initialize vertex pointers
//
struct CVertexDesc
{
    // Element memory pointer. Used in vertex loop. Start vertex is used
    // to compute it
    LPVOID      pMemory;
    // Element stride in bytes
    DWORD       dwStride;
    //------------ Private Microsoft data -------------
    union
    {
        // Input vertex register index
        DWORD   dwRegister;
        // Used to initilize fixed-function pipeline vertex pointers
        D3DDP_PTRSTRIDE *pElement;
    };
    // Copies vertex element data to an input register
    LPVOID      pfnCopy;
    // Stream memory pointer
    CVStream*   pStream;
    // Offset of the element in the vertex in bytes
    DWORD       dwVertexOffset;
};
//-----------------------------------------------------------------------------
const DWORD __MAXWORLDMATRICES  = 256;
const DWORD __WORLDMATRIXBASE   = 256;
//-----------------------------------------------------------------------------
// Visible states, input and output data
//
class D3DFE_PROCESSVERTICES
{
public:
    D3DFE_PROCESSVERTICES();
    ~D3DFE_PROCESSVERTICES();

    // Returns current transformation matrix. Computes it if necessary
    inline D3DMATRIXI* GetMatrixCTM(UINT index)
        {
            D3DMATRIXI* m = &mCTM[index];
            if (CTMCount[index] < MatrixStateCount)
            {
                MatrixProduct(m, &world[index], &mVPC);
                CTMCount[index] = MatrixStateCount;
            }
            return m;
        }
    // Returns current matrix to transform to the camera space.
    // Computes it if necessary
    inline D3DMATRIXI* GetMatrixWV(UINT index)
        {
            D3DMATRIXI* m = &mWV[index];
            if (WVCount[index] < MatrixStateCount)
            {
                MatrixProduct(m, &world[index], &view);
                WVCount[index] = MatrixStateCount;
            }
            return m;
        }
    // Returns current matrix to transform normals to the camera space.
    // This is inverse view-world matrix.
    // Computes it if necessary
    inline D3DMATRIXI* GetMatrixWVI(UINT index)
        {
            D3DMATRIXI* m = &mWVI[index];
            if (WVICount[index] < MatrixStateCount)
            {
                D3DMATRIXI* world_view = GetMatrixWV(index);
                Inverse4x4((D3DMATRIX*)world_view, (D3DMATRIX*)m);
                WVICount[index] = MatrixStateCount;
            }
            return m;
        }
// State
    // Should be 16 byte aligned
    D3DMATRIXI view;                        // View matrix (Mview)
    D3DMATRIXI mVPC;                        // Mview * Mprojection * Mclip
    D3DMATRIXI mTexture[D3DDP_MAXTEXCOORD]; // Texture transform;
    D3DMATRIXI world[__MAXWORLDMATRICES];   // User set world matrices
    D3DMATRIXI mCTM[__MAXWORLDMATRICES];    // Matrices used for vertex blending
    D3DMATRIXI mWV[__MAXWORLDMATRICES];
    D3DMATRIXI mWVI[__MAXWORLDMATRICES];
    // Every time we need a matrix (CTM2, WV2, WVI2) we compare its count with
    // the MatrixStateCount and if it is less than it we compute the required
    // matrix.
    ULONGLONG CTMCount[__MAXWORLDMATRICES];
    ULONGLONG WVCount[__MAXWORLDMATRICES];
    ULONGLONG WVICount[__MAXWORLDMATRICES];
    // Every time world, view or projection matrix is changed, the
    // MatrixStateCount is incremented.
    ULONGLONG MatrixStateCount;
    // Current set of matrix indices used for the vertex blending.
    // If there are no matrix indices in vertices, it is set to (0,1,2,3)
    BYTE       MatrixIndices[4];
    // Weights in a vertex. There could be up to 3 weights in a vertex. The
    // last element is assigned as sum(1.0 - weights(i))
    float      VertexWeights[4];
    // Should be QWORD aligned
    D3DFE_LIGHTING lighting;        // Lighting state
    // Should be QWORD aligned
    D3DFE_VIEWPORTCACHE vcache;     // Data, computed fromto viewport settings
    DWORD    dwClipUnion;           // OR of all vertex clip flags
    DWORD    dwClipIntersection;    // AND of all vertex clip flags

    // Current texture stage vector
    LPVOID   *pD3DMappedTexI;
    D3DI_CLIPSTATE  ClipperState;   // State for triangle/line clipper
    // Cache line should start here
    D3DPRIMITIVETYPE primType;
    DWORD   dwNumVertices;  // Number of vertices to process
    DWORD   dwFlags;        // Flags word describing what to do
    // Location of the first vertex in the vertex buffer (DP2 DDI)
    // ATTENTION May be we can get rid of it?
    DWORD   dwNumIndices;           // 0 for non-indexed primitive
    LPWORD  lpwIndices;
    DWORD   dwNumPrimitives;

    // Cache line should start here
    DWORD   dwVIDIn;        // Vertex ID of input vertices
    DWORD   dwDeviceFlags;          // Flags that are constant per device
                                    // D3DPV_.. and primitive flags are combined
    DWORD   dwOutputSize;           // Output vertex size
    DWORD   dwVIDOut;               // Vertex ID of output vertices
    LPVOID  lpvOut;                 // Output pointer (output always packed)

    D3DFE_CLIPCODE* lpClipFlags;          // Clip flags to output
    DWORD   nTexCoord;      // Number of the input texture coordinate sets
    // Number of the output texture coordinate sets to process.
    // WARNING. It could be different from the texture count in dwVIDOut
    // (it could be zero for example when dwVIDOut has 1 texture coord set).
    // If D3DDEV_REMAPTEXTUREINDICES is set this is equal
    // to the number of active texture stages
    DWORD   nOutTexCoord;
    // Total size of all output texture coordinates in bytes
    DWORD   dwTextureCoordSizeTotal;
    union
    {
        struct
        {
            // Order of the fields is very important.
            // It is the same as the order of input registers in the virtual
            // vertex machine
            union
            {
                D3DDP_PTRSTRIDE position;   // dwStride should always be set !!!
                D3DDP_PTRSTRIDE SOA;
            };
            D3DDP_PTRSTRIDE weights;
            D3DDP_PTRSTRIDE matrixIndices;  // Blend matrix indices
            union
            {
                D3DDP_PTRSTRIDE normal;
                DWORD dwSOAStartVertex;
            };
            D3DDP_PTRSTRIDE psize;
            D3DDP_PTRSTRIDE diffuse;
            D3DDP_PTRSTRIDE specular;
            D3DDP_PTRSTRIDE textures[D3DDP_MAXTEXCOORD];
            D3DDP_PTRSTRIDE position2;
            D3DDP_PTRSTRIDE normal2;
        };
        D3DDP_PTRSTRIDE elements[__NUMELEMENTS];
    };
    // Used to offset indices during processing an indexed primitive
    DWORD   dwIndexOffset;
    // Size of output texture coordinate sets in bytes
    DWORD   dwTextureCoordSize[D3DDP_MAXTEXCOORD];
    // Size of input texture coordinate sets in bytes
    DWORD   dwInpTextureCoordSize[D3DDP_MAXTEXCOORD];
// Output
    LPDWORD  lpdwRStates;           // Current render state vector
    D3DFE_TEXTURESTAGE textureStage[D3DDP_MAXTEXCOORD]; // Texture state stages
    // Used when we have to re-map texture indices
    DWORD   dwNumTextureStages;
    // This array is used when we do not do re-mapping of texture coordinates
    D3DMATRIXI *pmTexture[D3DDP_MAXTEXCOORD];
    D3DVECTORH userClipPlane[__MAXUSERCLIPPLANES];
    // Low 8 bits are texture transform enable:
    // bit 0 corresponds to the texture stage 0
    // Bits 8-15 are used to detect if we need to do emulation of texture 
    // projection for the stage (when no stage re-mapping is needed).
    // Bits 16-23 are set if corresponding texture coord set
    // is taken from the vertex data (position or normal)
    DWORD   dwFlags2;
    // Blend factor used in vertex tweening
    float tweenFactor;
    // Number of matrices to apply for vertex blending. Number of weights in a
    // vertex is (dwNumVerBlends-1). The last weight is 1-sum(VertexWeight[i]).
    DWORD   dwNumVerBlends;
    // Number of weights in a vertex. It is dwNumVerBlends - 1
    DWORD   dwNumWeights;
    DWORD   dwMaxUserClipPlanes;
// Internal data for Microsoft implementation
    // Offsets in the input FVF vertex. Recomputed when FVF is changed.
    DWORD   texOffset;
    DWORD   normalOffset;
    DWORD   diffuseOffset;
    DWORD   specularOffset;
    DWORD   pointSizeOffset;
    // Offsets in the output FVF vertex. Recomputed when FVF is changed.
    DWORD   texOffsetOut;
    DWORD   diffuseOffsetOut;
    DWORD   specularOffsetOut;
    DWORD   pointSizeOffsetOut;
    DWORD   fogOffsetOut;
    // When and this mask with the clip code we have bits that are outside the
    // guard band
    DWORD   dwClipMaskOffScreen;

    // Clip vertices. Used in processing  and clipping in the one loop
    ClipVertex  clipVer[VER_IN_BATCH];
    // Index of the first vertex with non-zero clip code
    DWORD   dwFirstClippedVertex;
    DWORD   dwMaxTextureIndices;    // Max number of texture coord sets
    DWORD   dwIndexSize;            // Index size (2 or 4 bytes)
    CD3DDDI*  pDDI;                 // Copy from the device m_pDDI
    float   PointSizeMax;           // Current max point size
    ID3DFE_PVFUNCS* pGeometryFuncs; // Copy from the CD3DHal device

    //-------------- Vertex Shader data -----------------

    // Store information to initialize virtual machine registers
    // The elements of this array match the elements of pElements array, passed
    // with CreateShader call.
    CVertexDesc VertexDesc[__NUMSTREAMS];
    // How many VertexDescs are used
    // It is equal to the number of vertex elements (dwNumElements), in the
    // current active shader. dwNumElements is passed during CreateShader calls
    DWORD   dwNumUsedVertexDescs;
};
//-----------------------------------------------------------------------------
// Prototype for the function to be written for a given processor implementation
//
class ID3DFE_PVFUNCS
{
public:
    virtual ~ID3DFE_PVFUNCS() {};
    virtual DWORD ProcessVertices(LPD3DFE_PROCESSVERTICES)=0;
    virtual HRESULT ProcessPrimitive(LPD3DFE_PROCESSVERTICES)=0;
    virtual HRESULT ProcessIndexedPrimitive(LPD3DFE_PROCESSVERTICES)=0;
    virtual HRESULT OptimizeVertexBuffer
        (DWORD  dwFVFID,            // Vertex type. XYZ position is allowed
         DWORD  dwNumVertices,      // Number of vertices
         DWORD  dwVertexSize,       // Vertex size in bytes
         LPVOID lpSrcBuffer,        // Source buffer.
         LPVOID lpDstBuffer,        // Output buffer.
         DWORD  dwFlags)            // Should be zero for now
        {return E_NOTIMPL;}
    // Returns number of bytes to allocate for an optimized vertex buffer
    // This function is called before OptimizeVertexBuffer
    virtual DWORD  ComputeOptimizedVertexBufferSize
        (DWORD dwFVF,               // Vertex type
         DWORD dwVertexSize,        // Vertex size in bytes
         DWORD dwNumVertices)       // Number of vertices
        {return 0;}
    // This function could be used if PSGP doesn't want to implement complete
    // clipping pipeline
    // Parameters:
    //      pv  - state data
    //      tri - triangle to clip
    //      clipVertexPointer - pointer to an array of pointers to
    //                          generated vertices
    // Returns:
    //      Number of vertices in clipped triangle
    //      0, if the triangle is off screen
    virtual int ClipSingleTriangle(D3DFE_PROCESSVERTICES *pv,
                                   ClipTriangle *tri,
                                   ClipVertex ***clipVertexPointer) = 0;
    virtual HRESULT ProcessTriangleList(LPD3DFE_PROCESSVERTICES)=0;
    virtual HRESULT ProcessTriangleFan(LPD3DFE_PROCESSVERTICES)=0;
    virtual HRESULT ProcessTriangleStrip(LPD3DFE_PROCESSVERTICES)=0;
    // Create a vertex shader
    //
    // D3D run-time:
    //  - parses shader declaration and shader code and does all validation
    //  - computes output FVF for non-fixed pipeline
    //  - creates a shader handle
    //  - calls ID3DFE_PVFUNCS::CreateShader()
    // PSGP:
    //  - compiles shader code using the vertex element descriptions
    //
    // For fixed function pipeline pdwShaderCode is NULL, dwOutputFVF should be
    // ignored (dwVIDOut should be used in Draw calls).
    //
    virtual HRESULT CreateShader(
        // Describes input vertex elements and mapping them to vertex registers
        CVElement*   pElements,
        // Number of elements
        DWORD       dwNumElements,
        // Binary shader code (NULL for fixed function pipeline)
        DWORD*      pdwShaderCode,
        // Describes output vertex format. Ignored by fixed function pipeline
        DWORD       dwOutputFVF,
        // PSGP-created shader object. D3D does not have access to it.
        CPSGPShader** ppPSGPShader
        ) = 0;

    virtual HRESULT SetActiveShader(CPSGPShader *pPSGPShader) = 0;

    // Load vertex shader constants
    virtual HRESULT LoadShaderConstants(
        DWORD start,        // Constant register address
        DWORD count,        // Number of 4-float vectors to load
        LPVOID buffer) = 0; // Memory to load from
    // This function is called when output vertex format is changed, but the
    // active shader remains the same. It is guaranteed that the new FVF is
    // a superset of the FVF, passed to CreateShader. PSGP implementation
    // could re-compute output vertex offsets or it could use updated
    // output offsets and dwOutputSize from PROCESSVERTICES structure.
    virtual HRESULT SetOutputFVF(DWORD dwFVF) = 0;
    virtual HRESULT GetShaderConstants(
        DWORD start,        // Constant register address
        DWORD count,        // Number of 4-float vectors to load
        LPVOID buffer) = 0;
};

typedef ID3DFE_PVFUNCS *LPD3DFE_PVFUNCS;
//-----------------------------------------------------------------------------
// GeometrySetup function takes a DWORD describing the dirty bits and the new
// state vector and passes back the 3 new leaf routines to use.
//
typedef HRESULT (D3DAPI *LPD3DFE_CONTEXTCREATE)(
         // dwDeviceFlags are passed
         DWORD dwFlags,
         // A pointer to the Microsoft object is passed to call when there is no
         // PSGP implementation available. PSGP returns its object hear.
         LPD3DFE_PVFUNCS *ppMicrosoftFuncs
         );
//-----------------------------------------------------------------------------
// Global pointer to Processor specific PV setup routine
// This is defined in dlld3d.cpp
extern LPD3DFE_CONTEXTCREATE pfnFEContextCreate;

//-----------------------------------------------------------------------------
// Check if we need to do emulation of texture projection for the stage
//
inline BOOL NeedTextureProjection(D3DFE_PROCESSVERTICES* pv, UINT stage) 
{
    return pv->dwFlags2 & (__FLAGS2_TEXPROJ0 << stage);
}

#endif // _D3DFE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\inc\d3di.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3di.hpp
 *  Content:    Direct3D internal include file
 *
 *
 ***************************************************************************/

#ifndef _D3DI_HPP
#define _D3DI_HPP

// Allow fast path
#define FAST_PATH

#include "ddrawp.h"
#include "d3d8p.h"
#include "d3dmem.h"

#if !defined(BUILD_DDDDK)
extern "C" {
#include "ddrawi.h"
};
#include "lists.hpp"

#include <d3ditype.h>
#include <d3dutil.h>
#include <d3dfe.hpp>
#include <vshader.hpp>
#include <pshader.hpp>
#include "ddi.h"

//--------------------------------------------------------------------
const DWORD __INIT_VERTEX_NUMBER = 1024;// Initial number of vertices in TL and
                                        // clip flag buffers
//--------------------------------------------------------------------
/*
 * Registry defines
 */
#define RESPATH    "Software\\Microsoft\\Direct3D\\Drivers"
#define RESPATH_D3D "Software\\Microsoft\\Direct3D"

#define STATS_FONT_FACE "Terminal"
#define STATS_FONT_SIZE 9

extern HINSTANCE hGeometryDLL;

/*
 * CPU family and features flags
 */
extern DWORD dwCPUFamily, dwCPUFeatures;
extern char szCPUString[];

// MMX available
#define D3DCPU_MMX          0x00000001L

// FCOMI and CMOV are both supported
#define D3DCPU_FCOMICMOV    0x00000002L

// Reads block until satisfied
#define D3DCPU_BLOCKINGREAD 0x00000004L

// Extended 3D support available
#define D3DCPU_X3D          0x00000008L

// Pentium II CPU
#define D3DCPU_PII          0x000000010L

// Streaming SIMD Extensions (aka Katmai) CPU
#define D3DCPU_SSE          0x000000020L

// Streaming SIMD2 Extensions (aka Willamete) CPU
#define D3DCPU_WLMT         0x000000040L



#define DEFAULT_GAMMA   DTOVAL(1.4)

/*
    INDEX_BATCH_SCALE is the constant which is used by DrawIndexedPrim
    to deterimine if the number of primitives being drawn is small
    relative to the number of vertices being passed.  If it is then
    the prims are dereferenced in batches and sent to DrawPrim.
*/
#define INDEX_BATCH_SCALE   2

#endif // BUILD_DDDDK

#if !defined(BUILD_DDDDK)

class CD3DHal;
class CStateSets;
class CVertexVM;
class CBaseTexture;
class CD3DDDI;
typedef CD3DDDI* LPD3DDDI;

typedef class CD3DHal *LPD3DHAL;
typedef class DIRECT3DLIGHTI *LPDIRECT3DLIGHTI;

BOOL ValidatePixelShaderInternal( const DWORD* pCode, const D3DCAPS8* pCaps );
BOOL ValidateVertexShaderInternal( const DWORD* pCode, const DWORD* pDecl,
                                   const D3DCAPS8* pCaps );

#include "d3dhalp.h"

//-----------------------------------------------------------------------------
// Helper class to hold vertex element pointers and strides
//
class CVertexPointer
{
public:
    BYTE*   pData[__NUMELEMENTS];
    static UINT Stride[__NUMELEMENTS];
    static UINT NumUsedElements;
    static UINT DataType[__NUMELEMENTS];
    
    CVertexPointer() {}
    // Copy constructor
    CVertexPointer(CVertexPointer& vp)
    {
        for (UINT i=0; i < NumUsedElements; i++) 
        {
            pData[i]  = vp.pData[i];
        }
    }
    // Copy constructor
    void operator=(CVertexPointer& vp)
    {
        for (UINT i=0; i < NumUsedElements; i++) 
        {
            pData[i]  = vp.pData[i];
        }
    }
    void SetVertex(CVertexPointer& base, UINT index) 
    {
        for (UINT i=0; i < NumUsedElements; i++) 
            pData[i] = base.pData[i] + index * Stride[i];
    }
    CVertexPointer& operator++(int) 
    {
        for (UINT i=0; i < NumUsedElements; i++) 
            pData[i] += Stride[i];
        return *this;
    }
};
//-----------------------------------------------------------------------------
// Class to convert NPatches to RTPatches
//
class CNPatch2TriPatch
{
public:
    CNPatch2TriPatch();
    ~CNPatch2TriPatch();
    void MakeRectPatch(const CVertexPointer& pV0, 
                       const CVertexPointer& pV1, 
                       const CVertexPointer& pV2);

    CVStream        m_InpStream[__NUMELEMENTS];     // Original vertex streams
    CTLStream*      m_pOutStream[__NUMELEMENTS];    // Computed output vertex streams
    BYTE*           m_pInpStreamMem[__NUMELEMENTS]; // Input stream memory
    BYTE*           m_pOutStreamMem[__NUMELEMENTS]; // Output stream memory
    CVertexPointer  m_InpVertex;                    // Pointers to elements of the first input vertex
    CVertexPointer  m_OutVertex;                    // Pointers to elements of the first output vertex
    UINT            m_PositionIndex;                // Index in vertex element array
    UINT            m_NormalIndex;                  // Index in vertex element array
    D3DORDERTYPE    m_PositionOrder;
    D3DORDERTYPE    m_NormalOrder;
    UINT            m_FirstVertex;                  // Index of the first vertex in the 
                                                    // output buffer
    DWORD           m_bNormalizeNormals;
};
//-----------------------------------------------------------------------------
// Function to compute lighting
//
typedef struct _LIGHT_VERTEX_FUNC_TABLE
{
    LIGHT_VERTEX_FUNC   pfnDirectional;
    LIGHT_VERTEX_FUNC   pfnPointSpot;
// Used in multi-loop pipeline
    PFN_LIGHTLOOP       pfnDirectionalFirst;
    PFN_LIGHTLOOP       pfnDirectionalNext;
    PFN_LIGHTLOOP       pfnPointSpotFirst;
    PFN_LIGHTLOOP       pfnPointSpotNext;
} LIGHT_VERTEX_FUNC_TABLE;
//---------------------------------------------------------------------
class DIRECT3DLIGHTI : public CD3DBaseObj
{
public:
    DIRECT3DLIGHTI() {m_LightI.flags = 0;}   // VALID bit is not set
    HRESULT SetInternalData();
    BOOL Enabled() {return (m_LightI.flags & D3DLIGHTI_ENABLED);}
    // TRUE is we need to send the light to the driver when switching
    // to the hardware vertex processing mode
    BOOL DirtyForDDI() {return (m_LightI.flags & D3DLIGHTI_UPDATEDDI);}
    void SetDirtyForDDI() {m_LightI.flags |= D3DLIGHTI_UPDATEDDI;}
    void ClearDirtyForDDI() {m_LightI.flags &= ~D3DLIGHTI_UPDATEDDI;}
    // TRUE is we need to send the "enable" state of the light to the driver
    // when switching to the hardware vertex processing mode
    BOOL EnableDirtyForDDI() {return (m_LightI.flags & D3DLIGHTI_UPDATE_ENABLE_DDI);}
    void SetEnableDirtyForDDI() {m_LightI.flags |= D3DLIGHTI_UPDATE_ENABLE_DDI;}
    void ClearEnableDirtyForDDI() {m_LightI.flags &= ~D3DLIGHTI_UPDATE_ENABLE_DDI;}

    LIST_MEMBER(DIRECT3DLIGHTI) m_List;     // Active light list member
    D3DLIGHT8   m_Light;
    D3DI_LIGHT  m_LightI;
};
//---------------------------------------------------------------------
struct CPalette : public CD3DBaseObj
{
    CPalette()
    {
        m_dirty = TRUE;
    }

    BOOL         m_dirty;
    PALETTEENTRY m_pEntries[256];
};
#if DBG
//---------------------------------------------------------------------
struct CRTPatchValidationInfo : public CD3DBaseObj
{
    CRTPatchValidationInfo()
    {
        m_ShaderHandle = __INVALIDHANDLE;
    }

    DWORD m_ShaderHandle;
};
#endif // DBG
//---------------------------------------------------------------------
//
// Bits for Runtime state flags (m_dwRuntimeFlags in CD3DBase)
//
// This bit set if UpdateManagedTextures() needs to be called
const DWORD D3DRT_NEED_TEXTURE_UPDATE       = 1 << 1;
// We are in recording state set mode
const DWORD D3DRT_RECORDSTATEMODE           = 1 << 2;
// We are in execution state set mode
// In this mode the front-and executes recorded states but does not pass
// them to the driver (the states will be passed using a set state handle)
const DWORD D3DRT_EXECUTESTATEMODE          = 1 << 3;
//
const DWORD D3DRT_LOSTSURFACES              = 1 << 4;
// Set when D3DRS_SOFTWAREVERTEXPROCESSING is TRUE
const DWORD D3DRT_RSSOFTWAREPROCESSING      = 1 << 5;
// Set when device does not support point sprites
const DWORD D3DRT_DOPOINTSPRITEEMULATION    = 1 << 6;
// Set when input stream has point size. It is computed in the SetVertexShaderI
const DWORD D3DRT_POINTSIZEINVERTEX         = 1 << 7;
// Set when D3DRS_POINTSIZE != 1.0
const DWORD D3DRT_POINTSIZEINRS             = 1 << 8;
// Set when
//  - shader has been changed.
//  - when ForceFVFRecompute has been called
const DWORD D3DRT_SHADERDIRTY               = 1 << 9;
// This bit set if UpdateDirtyStreams() needs to be called
const DWORD D3DRT_NEED_VB_UPDATE            = 1 << 11;
// This bit set if we need to update vertex shader constants in the driver
const DWORD D3DRT_NEED_VSCONST_UPDATE       = 1 << 12;
// Set if device can handle only 2 floats per texture coord set
const DWORD D3DRT_ONLY2FLOATSPERTEXTURE     = 1 << 13;
// Set if device cannot handle projected textures, so we need to emulate them
const DWORD D3DRT_EMULATEPROJECTEDTEXTURE   = 1 << 14;
// Set if a directional light is present in the active light list
const DWORD D3DRT_DIRECTIONALIGHTPRESENT    = 1 << 15;
// Set if a point/spot light is present in the active light list
const DWORD D3DRT_POINTLIGHTPRESENT         = 1 << 16;
// Set if current primitive is user memory primitive
const DWORD D3DRT_USERMEMPRIMITIVE          = 1 << 17;
// Set if reg key to disallow Non-Versioned (FF.FF) pixel shaders was set on device create
const DWORD D3DRT_DISALLOWNVPSHADERS        = 1 << 18;
// Set when MaxPointSize in the device is greater than 1.0
const DWORD D3DRT_SUPPORTSPOINTSPRITES      = 1 << 19;
// Set when we need to do NPatch to RTPatch conversion
const DWORD D3DRT_DONPATCHCONVERSION        = 1 << 20;

const DWORD D3DRT_POINTSIZEPRESENT = D3DRT_POINTSIZEINRS |
                                     D3DRT_POINTSIZEINVERTEX;
//---------------------------------------------------------------------
//
// Bits for D3DFRONTEND flags (dwFEFlags in CD3DHal)
//
const DWORD D3DFE_WORLDMATRIX_DIRTY         = 1 << 0;   // World matrix dirty bits
const DWORD D3DFE_TLVERTEX                  = 1 << 5;
const DWORD D3DFE_PROJMATRIX_DIRTY          = 1 << 8;
const DWORD D3DFE_VIEWMATRIX_DIRTY          = 1 << 9;
// Set when we need to check world-view matrix for orthogonality
const DWORD D3DFE_NEEDCHECKWORLDVIEWVMATRIX = 1 << 10;
// Set when some state has been changed and we have to go through the slow path
// to update state.
// Currently the bit is set when one of the following bits is set:
//     D3DFE_PROJMATRIX_DIRTY
//     D3DFE_VIEWMATRIX_DIRTY
//     D3DFE_WORLDMATRIX_DIRTY
//     D3DFE_VERTEXBLEND_DIRTY
//     D3DFE_LIGHTS_DIRTY
//     D3DFE_MATERIAL_DIRTY
//     D3DFE_FVF_DIRTY
//     D3DFE_CLIPPLANES_DIRTY
//     OutputFVF has been changed
//
const DWORD D3DFE_FRONTEND_DIRTY            = 1 << 11;
const DWORD D3DFE_NEED_TRANSFORM_LIGHTS     = 1 << 14;
const DWORD D3DFE_MATERIAL_DIRTY            = 1 << 15;
const DWORD D3DFE_CLIPPLANES_DIRTY          = 1 << 16;
const DWORD D3DFE_LIGHTS_DIRTY              = 1 << 18;
// This bit is set when vertex blending state is dirty
const DWORD D3DFE_VERTEXBLEND_DIRTY         = 1 << 19;
// Set if the Current Transformation Matrix has been changed
// Reset when frustum planes in the model space have been computed
const DWORD D3DFE_FRUSTUMPLANES_DIRTY       = 1 << 20;
const DWORD D3DFE_WORLDVIEWMATRIX_DIRTY     = 1 << 21;
const DWORD D3DFE_FVF_DIRTY                 = 1 << 22;
// This bit set if mapping DX6 texture blend modes to renderstates is desired
const DWORD D3DFE_MAP_TSS_TO_RS             = 1 << 24;
const DWORD D3DFE_INVWORLDVIEWMATRIX_DIRTY  = 1 << 25;

// This bit set if texturing is disabled
const DWORD D3DFE_DISABLE_TEXTURES          = 1 << 28;
// Clip matrix is used to transform user clipping planes
// to the clipping space
const DWORD D3DFE_CLIPMATRIX_DIRTY          = 1 << 29;
// HAL supports Transformation and Lighting
const DWORD D3DFE_TLHAL                     = 1 << 30;

const DWORD D3DFE_TRANSFORM_DIRTY = D3DFE_PROJMATRIX_DIRTY |
                                    D3DFE_VIEWMATRIX_DIRTY |
                                    D3DFE_WORLDMATRIX_DIRTY |
                                    D3DFE_VERTEXBLEND_DIRTY;
// Are we in a scene?
const DWORD D3DDEVBOOL_HINTFLAGS_INSCENE       = 1 << 0;
// Means the FPU is already in preferred state.
const DWORD D3DDEVBOOL_HINTFLAGS_FPUSETUP      = 1 << 3;

//---------------------------------------------------------------------
// Bits for transform.dwFlags
//

//---------------------------------------------------------------------
typedef struct _D3DFE_TRANSFORM
{
    D3DMATRIXI  proj;
    D3DMATRIXI  mPC;        // Mproj * Mclip
    D3DMATRIXI  mVPCI;      // Inverse Mview * PC, used to transform clipping planes
    D3DVECTORH  userClipPlane[D3DMAXUSERCLIPPLANES];
} D3DFE_TRANSFORM;

typedef void (*D3DFEDestroyProc)(LPD3DHAL lpD3DDevI);

//---------------------------------------------------------------------
#ifdef _IA64_   // Removes IA64 compiler alignment warnings
  #pragma pack(16)
#endif

#ifdef _AXP64_   // Removes AXP64 compiler alignment warnings
  #pragma pack(16)
#endif

// We modify the compiler generated VTable for CD3DHal object. To make
// life easy, all virtual functions are defined in CD3DHal. Also since
// DEVICEI has multiple inheritance, there are more than 1 VTable.
// Currently we assume that it only inherits from IDirect3DDevice7 and
// D3DFE_PROCESSVERTICES and, in that order! Thus IDirect3DDevice7 and
// CD3DHal share the same vtable. This is the VTable we copy and
// modify. The define below is the total entries in this vtable. It is the
// sum of the methods in IDirect3DDevice7 (incl. IUnknown) (49) and all the
// virtual methods in CD3DHal ()
#define D3D_NUM_API_FUNCTIONS (49)
#define D3D_NUM_VIRTUAL_FUNCTIONS (D3D_NUM_API_FUNCTIONS+38)

// These constants are based on the assumption that rsVec array is an array
// of 32-bit intergers
const D3D_RSVEC_SHIFT = 5; // log2(sizeof(DWORD)*8);
const D3D_RSVEC_MASK = sizeof(DWORD) * 8 - 1;
//-----------------------------------------------------------------------------
// The class is used to maintain a packed array of bits
//
class CPackedBitArray
{
public:
    CPackedBitArray()  {m_pArray = NULL;}
    ~CPackedBitArray() {delete m_pArray;}
    // This function could be called to re-allocate the array. All data from the
    // previous array is copied into new array
    HRESULT Init(UINT size)
        {
            // Size in bytes
            UINT allocsize = ((size + D3D_RSVEC_MASK) >> D3D_RSVEC_SHIFT) << 2;
            DWORD* pNew = (DWORD*)new BYTE[allocsize];
            if (pNew == NULL)
                return E_OUTOFMEMORY;
            memset(pNew, 0, allocsize);
            if (m_pArray)
            {
                // User asks to re-allocate the array
                memcpy(pNew, m_pArray, m_sizeInBytes);
                delete m_pArray;
            }
            m_pArray = pNew;
            m_size = size;
            m_sizeInBytes = allocsize;
            return S_OK;
        }
    UINT GetSize() {return m_size;}
    void ClearBit(DWORD index)
    {
#if DBG
            CheckIndex(index);
#endif
            m_pArray[index >> D3D_RSVEC_SHIFT] &= ~(1 << (index & D3D_RSVEC_MASK));
    }
    void SetBit(DWORD index)
        {
#if DBG
            CheckIndex(index);
#endif
            m_pArray[index >> D3D_RSVEC_SHIFT] |= 1 << (index & D3D_RSVEC_MASK);
        }
    BOOL IsBitSet(DWORD index)
        {
#if DBG
            CheckIndex(index);
#endif
            return (m_pArray[index >> D3D_RSVEC_SHIFT] &
                   (1ul << (index & D3D_RSVEC_MASK))) != 0;
        }
private:
    DWORD*  m_pArray;
    UINT    m_sizeInBytes;
    UINT    m_size;       // Number of elements (bits) in the array
#if DBG
    void CheckIndex(UINT index);
#endif // DBG
};
//-----------------------------------------------------------------------------

// Map DX8 texture filter enum to D3DTEXTUREMAGFILTER
const texf2texfg[] = {
    D3DTFG_POINT,           // D3DTEXF_NONE            = 0,
    D3DTFG_POINT,           // D3DTEXF_POINT           = 1,
    D3DTFG_LINEAR,          // D3DTEXF_LINEAR          = 2,
    D3DTFG_ANISOTROPIC,     // D3DTEXF_ANISOTROPIC     = 3,
    D3DTFG_FLATCUBIC,       // D3DTEXF_FLATCUBIC       = 4,
    D3DTFG_GAUSSIANCUBIC,   // D3DTEXF_GAUSSIANCUBIC   = 5,
};
// Map DX8 texture filter enum to D3DTEXTUREMINFILTER
const texf2texfn[] = {
    D3DTFN_POINT,           // D3DTEXF_NONE            = 0,
    D3DTFN_POINT,           // D3DTEXF_POINT           = 1,
    D3DTFN_LINEAR,          // D3DTEXF_LINEAR          = 2,
    D3DTFN_ANISOTROPIC,     // D3DTEXF_ANISOTROPIC     = 3,
    D3DTFN_LINEAR,          // D3DTEXF_FLATCUBIC       = 4,
    D3DTFN_LINEAR,          // D3DTEXF_GAUSSIANCUBIC   = 5,
};
// Map DX8 texture filter enum to D3DTEXTUREMIPFILTER
const texf2texfp[] = {
    D3DTFP_NONE,            // D3DTEXF_NONE            = 0,
    D3DTFP_POINT,           // D3DTEXF_POINT           = 1,
    D3DTFP_LINEAR,          // D3DTEXF_LINEAR          = 2,
    D3DTFP_LINEAR,          // D3DTEXF_ANISOTROPIC     = 3,
    D3DTFP_LINEAR,          // D3DTEXF_FLATCUBIC       = 4,
    D3DTFP_LINEAR,          // D3DTEXF_GAUSSIANCUBIC   = 5,
};

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CD3DBase                                                                //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////
class CD3DBase : public CBaseDevice
{

public:
    // IDirect3DDevice8 Methods
    HRESULT D3DAPI ResourceManagerDiscardBytes(DWORD cbBytes);                                                          // 5

    HRESULT D3DAPI SetRenderTarget(IDirect3DSurface8 *pRenderTarget, IDirect3DSurface8 *pZStencil);                     // 31
    HRESULT D3DAPI GetRenderTarget(IDirect3DSurface8 **ppRenderTarget);                                                 // 32
    HRESULT D3DAPI GetDepthStencilSurface(IDirect3DSurface8 **ppZStencil);                                              // 33

    HRESULT D3DAPI BeginScene();                                                                                        // 34
    HRESULT D3DAPI EndScene();                                                                                          // 35
    HRESULT D3DAPI Clear( DWORD dwCount, CONST D3DRECT* rects, DWORD dwFlags,
                          D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil);                                             // 36
    HRESULT D3DAPI SetTransform(D3DTRANSFORMSTATETYPE, CONST D3DMATRIX*);                                               // 37
    HRESULT D3DAPI GetTransform(D3DTRANSFORMSTATETYPE, LPD3DMATRIX);                                                    // 38
    HRESULT D3DAPI MultiplyTransform(D3DTRANSFORMSTATETYPE, CONST D3DMATRIX*);                                          // 39
    HRESULT D3DAPI SetViewport(CONST D3DVIEWPORT8*);                                                                    // 40
    HRESULT D3DAPI GetViewport(D3DVIEWPORT8*);                                                                          // 41
    HRESULT D3DAPI SetMaterial(CONST D3DMATERIAL8*);                                                                    // 42
    HRESULT D3DAPI GetMaterial(D3DMATERIAL8*);                                                                          // 43
    HRESULT D3DAPI SetLight(DWORD, CONST D3DLIGHT8*);                                                                   // 44
    HRESULT D3DAPI GetLight(DWORD, D3DLIGHT8*);                                                                         // 45
    HRESULT D3DAPI LightEnable(DWORD dwLightIndex, BOOL);                                                               // 46
    HRESULT D3DAPI GetLightEnable(DWORD dwLightIndex, BOOL*);                                                           // 47
    HRESULT D3DAPI SetClipPlane(DWORD dwPlaneIndex, CONST D3DVALUE* pPlaneEquation);                                    // 48
    HRESULT D3DAPI GetClipPlane(DWORD dwPlaneIndex, D3DVALUE* pPlaneEquation);                                          // 49
    HRESULT D3DAPI SetRenderState(D3DRENDERSTATETYPE, DWORD);                                                           // 50
    HRESULT D3DAPI GetRenderState(D3DRENDERSTATETYPE, LPDWORD);                                                         // 51
    HRESULT D3DAPI BeginStateBlock();                                                                                   // 52
    HRESULT D3DAPI EndStateBlock(LPDWORD);                                                                              // 53
    HRESULT D3DAPI ApplyStateBlock(DWORD);                                                                              // 54
    HRESULT D3DAPI CaptureStateBlock(DWORD Handle);                                                                     // 55
    HRESULT D3DAPI DeleteStateBlock(DWORD);                                                                             // 56
    HRESULT D3DAPI CreateStateBlock(D3DSTATEBLOCKTYPE sbt, LPDWORD pdwHandle);                                          // 57
    HRESULT D3DAPI SetClipStatus(CONST D3DCLIPSTATUS8*);                                                                // 58
    HRESULT D3DAPI GetClipStatus(D3DCLIPSTATUS8*);                                                                      // 59
    HRESULT D3DAPI GetTexture(DWORD, IDirect3DBaseTexture8**);                                                          // 60
    HRESULT D3DAPI SetTexture(DWORD, IDirect3DBaseTexture8*);                                                           // 61
    HRESULT D3DAPI GetTextureStageState(DWORD, D3DTEXTURESTAGESTATETYPE, LPDWORD);                                      // 62
    HRESULT D3DAPI SetTextureStageState(DWORD dwStage,
                                        D3DTEXTURESTAGESTATETYPE dwState,
                                        DWORD dwValue);                                                                 // 63
    HRESULT D3DAPI ValidateDevice(LPDWORD lpdwNumPasses);                                                               // 64
    HRESULT D3DAPI GetInfo(DWORD dwDevInfoID, LPVOID pDevInfoStruct,
                           DWORD dwSize);                                                                               // 65
    HRESULT D3DAPI SetPaletteEntries(UINT PaletteNumber, CONST PALETTEENTRY *pEntries);                                 // 66
    HRESULT D3DAPI GetPaletteEntries(UINT PaletteNumber, PALETTEENTRY *pEntries);                                       // 67
    HRESULT D3DAPI SetCurrentTexturePalette(UINT PaletteNumber);                                                        // 68
    HRESULT D3DAPI GetCurrentTexturePalette(UINT *PaletteNumber);                                                       // 69
    HRESULT D3DAPI DrawPrimitive(D3DPRIMITIVETYPE PrimType,
                                 UINT StartVertex, UINT VertexCount);                                                   // 70
    HRESULT D3DAPI DrawIndexedPrimitive(D3DPRIMITIVETYPE, UINT minIndex,
                                         UINT maxIndex, UINT startIndex,
                                         UINT count);                                                                   // 71
    HRESULT D3DAPI DrawPrimitiveUP(
        D3DPRIMITIVETYPE PrimitiveType,
        UINT PrimitiveCount,
        CONST VOID *pVertexStreamZeroData,
        UINT VertexStreamZeroStride);                                                                                   // 72
    HRESULT D3DAPI DrawIndexedPrimitiveUP(
        D3DPRIMITIVETYPE PrimitiveType,
        UINT MinVertexIndex, UINT NumVertexIndices,
        UINT PrimitiveCount,
        CONST VOID *pIndexData, D3DFORMAT IndexDataFormat,
        CONST VOID *pVertexStreamZeroData, UINT VertexStreamZeroStride);                                                // 73
    HRESULT D3DAPI ProcessVertices(UINT SrcStartIndex, UINT DestIndex,
                                   UINT VertexCount,
                                   IDirect3DVertexBuffer8 *pDestBuffer,
                                   DWORD Flags);                                                                        // 74

    HRESULT D3DAPI CreateVertexShader(CONST DWORD* pdwDeclaration,
                                      CONST DWORD* pdwFunction,
                                      DWORD* pdwHandle, DWORD dwUsage);                                                 // 75
    HRESULT D3DAPI SetVertexShader(DWORD dwHandle);                                                                     // 76
    HRESULT D3DAPI GetVertexShader(LPDWORD pdwHandle);                                                                  // 77
    HRESULT D3DAPI DeleteVertexShader(DWORD dwHandle);                                                                  // 78
    HRESULT D3DAPI SetVertexShaderConstant(DWORD dwRegisterAddress,
                                           CONST VOID* lpvConstantData,
                                           DWORD dwConstantCount);                                                      // 79
    HRESULT D3DAPI GetVertexShaderConstant(DWORD dwRegisterAddress,
                                           LPVOID lpvConstantData,
                                           DWORD dwConstantCount);                                                      // 80
    HRESULT D3DAPI GetVertexShaderDeclaration(DWORD dwHandle, void *pData,
                                              DWORD *pSizeOfData);                                                      // 81
    HRESULT D3DAPI GetVertexShaderFunction(DWORD dwHandle, void *pData,
                                           DWORD *pSizeOfData);                                                         // 82

    HRESULT D3DAPI SetStreamSource(UINT StreamNumber,
                                   IDirect3DVertexBuffer8 *pStreamData,
                                   UINT Stride);                                                                        // 83
    HRESULT D3DAPI GetStreamSource(UINT StreamNumber,
                                   IDirect3DVertexBuffer8 **ppStreamData,
                                   UINT* pStride);                                                                      // 84
    HRESULT D3DAPI SetIndices(IDirect3DIndexBuffer8 *pIndexData,
                              UINT BaseVertexIndex);                                                                    // 85
    HRESULT D3DAPI GetIndices(IDirect3DIndexBuffer8 **ppIndexData,
                              UINT* pBaseVertexIndex);                                                                  // 86

    HRESULT D3DAPI CreatePixelShader(CONST DWORD* pdwFunction,
                                     LPDWORD pdwHandle);                                                                // 87
    HRESULT D3DAPI SetPixelShader(DWORD dwHandle);                                                                      // 88
    HRESULT D3DAPI GetPixelShader(LPDWORD pdwHandle);                                                                   // 89
    HRESULT D3DAPI DeletePixelShader(DWORD dwHandle);                                                                   // 90
    HRESULT D3DAPI SetPixelShaderConstant(DWORD dwRegisterAddress,
                                          CONST VOID* lpvConstantData,
                                          DWORD dwConstantCount);                                                       // 91
    HRESULT D3DAPI GetPixelShaderConstant(DWORD dwRegisterAddress,
                                          LPVOID lpvConstantData,
                                          DWORD dwConstantCount);                                                       // 92
    HRESULT D3DAPI GetPixelShaderFunction(DWORD dwHandle, void *pData,
                                          DWORD *pSizeOfData);                                                          // 93

    HRESULT D3DAPI DrawRectPatch(UINT Handle, CONST FLOAT *pNumSegs,
                                 CONST D3DRECTPATCH_INFO *pSurf);                                                       // 94
    HRESULT D3DAPI DrawTriPatch(UINT Handle, CONST FLOAT *pNumSegs,
                                CONST D3DTRIPATCH_INFO *pSurf);                                                         // 95
    HRESULT D3DAPI DeletePatch(UINT Handle);                                                                            // 96

public:

    // Flags to indicate runtime state
    DWORD              m_dwRuntimeFlags;

    // D3DDEVBOOL flags
    DWORD              m_dwHintFlags;

    // This should only be accessed through
    // CurrentBatch and IncrementBatchCount
    ULONGLONG          m_qwBatch;

    // The object encapsulating the DDI styles
    // At the minimum this is a DX6 driver.
    LPD3DDDIDX6        m_pDDI;

    // Pointer to texture objects for currently installed textures.
    // NULL indicates that the texture is either not set (rstate NULL) or that
    // the handle to tex3 pointer mapping is not done.  This mapping is
    // expensive, so it is deferred until needed. This is needed for finding
    // the WRAPU,V mode for texture index clipping (since the WRAPU,V state is
    // part of the device).
    CBaseTexture* m_lpD3DMappedTexI[D3DHAL_TSS_MAXSTAGES];
    DWORD     m_dwDDITexHandle[D3DHAL_TSS_MAXSTAGES];
    // Max number of blend stages supported by a driver
    DWORD     m_dwMaxTextureBlendStages;
    DWORD     m_dwStageDirty, m_dwStreamDirty;

    // Object to record state sets
    CStateSets* m_pStateSets;

    //
    // The following is for validation only
    //

    // Max TSS that can be passed to the driver
    D3DTEXTURESTAGESTATETYPE m_tssMax;

    // Max RS that can be passed to the driver, used for CanHandleRenderState
    D3DRENDERSTATETYPE m_rsMax;

#if defined(PROFILE4) || defined(PROFILE)
    DWORD m_dwProfStart, m_dwProfStop;
#endif

    // This bit array is used to tell if a light has been created or not
    CPackedBitArray* m_pCreatedLights;

    // DX8 related stuff from here -------------------------------------

    // The current shader handle. It is initialized to Zero.
    // Zero means that there is no current shader. User always has to
    // initialize the shader.
    // It is used only by non-pure device
    DWORD       m_dwCurrentShaderHandle;

    // The current pixel shader handle. It is initialized to zero, and
    // is set to zero for legacy pixel processing
    // It is used only by non-pure device
    DWORD       m_dwCurrentPixelShaderHandle;

     // This object gives us pixel shader handles
    CHandleFactory* m_pPShaderArray;

     // This object gives us vertex shader handles
    CVShaderHandleFactory* m_pVShaderArray;
    // Vertex sctreams
    CVStream*   m_pStream;
    // Index stream
    CVIndexStream* m_pIndexStream;
    // Max number of streams allowed. For D3D software it is __NUMSTREAMS
    // For hardware T&L it could be smaller
    DWORD       m_dwNumStreams;
    // Max number of user clipping streams supported
    DWORD       m_dwMaxUserClipPlanes;
    // Currently set palette
    DWORD       m_dwPalette;
    // Palette array
    CHandleArray *m_pPaletteArray;
#if DBG
    // Needed for RT-Patch validation
    CHandleArray *m_pRTPatchValidationInfo;
    // Needed for VB warnings
    DWORD         m_SceneStamp;
#endif // DBG

    // Function pointers for DrawPrimitive processing
    PFN_DRAWPRIMFAST        m_pfnDrawPrim;
    PFN_DRAWINDEXEDPRIMFAST m_pfnDrawIndexedPrim;
    // Function pointers for DrawPrimitive processing from NPatch 
    // conversion function in case of point or line primitives
    PFN_DRAWPRIMFAST        m_pfnDrawPrimFromNPatch;
    PFN_DRAWINDEXEDPRIMFAST m_pfnDrawIndexedPrimFromNPatch;

    // Number of constant register. This could be different for software and
    // hardware vertex processing
    UINT        m_MaxVertexShaderConst;

#ifdef FAST_PATH
#define NUMVTBLENTRIES  135
    VOID        **m_pOrigVtbl;
    VOID         *m_pVtbl[NUMVTBLENTRIES];

    void FastPathSetRenderStateExecute()
    {
        if((BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0)
        {
            m_pVtbl[50] = m_pVtbl[98];
        }
        else
        {
            DXGASSERT(m_pVtbl[50] == m_pOrigVtbl[50]);
        }
    }
    void FastPathSetRenderStateRecord()
    {
        m_pVtbl[50] = m_pOrigVtbl[50];
    }
    void FastPathSetTextureStageStateExecute()
    {
        if((BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0)
        {
            m_pVtbl[63] = m_pVtbl[99];
        }
        else
        {
            DXGASSERT(m_pVtbl[63] == m_pOrigVtbl[63]);
        }
    }
    void FastPathSetTextureStageStateRecord()
    {
        m_pVtbl[63] = m_pOrigVtbl[63];
    }
    void FastPathSetTextureExecute()
    {
        if((BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0)
        {
            m_pVtbl[61] = m_pVtbl[100];
        }
        else
        {
            DXGASSERT(m_pVtbl[61] == m_pOrigVtbl[61]);
        }
    }
    void FastPathSetTextureRecord()
    {
        m_pVtbl[61] = m_pOrigVtbl[61];
    }
    void FastPathApplyStateBlockExecute()
    {
        if((BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0)
        {
            m_pVtbl[54] = m_pVtbl[101];
        }
        else
        {
            DXGASSERT(m_pVtbl[54] == m_pOrigVtbl[54]);
        }
    }
    void FastPathApplyStateBlockRecord()
    {
        m_pVtbl[54] = m_pOrigVtbl[54];
    }
    void FastPathSetVertexShaderFast()
    {
        if((m_dwRuntimeFlags & (D3DRT_RECORDSTATEMODE | D3DRT_RSSOFTWAREPROCESSING)) == 0 &&
            (BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0)
        {
            m_pVtbl[76] = m_pVtbl[102];
        }
        else
        {
            DXGASSERT(m_pVtbl[76] == m_pOrigVtbl[76]);
        }
    }
    void FastPathSetVertexShaderSlow()
    {
        m_pVtbl[76] = m_pOrigVtbl[76];
    }
    void FastPathSetStreamSourceFast()
    {
        if((m_dwRuntimeFlags & (D3DRT_RECORDSTATEMODE | D3DRT_RSSOFTWAREPROCESSING)) == 0 &&
            (BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0)
        {
            m_pVtbl[83] = m_pVtbl[103];
        }
        else
        {
            DXGASSERT(m_pVtbl[83] == m_pOrigVtbl[83]);
        }
    }
    void FastPathSetStreamSourceSlow()
    {
        m_pVtbl[83] = m_pOrigVtbl[83];
    }
    void FastPathSetIndicesFast()
    {
        if((m_dwRuntimeFlags & (D3DRT_RECORDSTATEMODE | D3DRT_RSSOFTWAREPROCESSING)) == 0 &&
            (BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0)
        {
            m_pVtbl[85] = m_pVtbl[104];
        }
        else
        {
            DXGASSERT(m_pVtbl[85] == m_pOrigVtbl[85]);
        }
    }
    void FastPathSetIndicesSlow()
    {
        m_pVtbl[85] = m_pOrigVtbl[85];
    }
    void FastPathSetTransformExecute()
    {
        if((BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0 &&
           (BehaviorFlags() & D3DCREATE_PUREDEVICE) != 0)
        {
            m_pVtbl[37] = m_pVtbl[105];
        }
        else
        {
            DXGASSERT(m_pVtbl[37] == m_pOrigVtbl[37]);
        }
    }
    void FastPathSetTransformRecord()
    {
        m_pVtbl[37] = m_pOrigVtbl[37];
    }
    void FastPathMultiplyTransformExecute()
    {
        if((BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0 &&
           (BehaviorFlags() & D3DCREATE_PUREDEVICE) != 0)
        {
            m_pVtbl[39] = m_pVtbl[106];
        }
        else
        {
            DXGASSERT(m_pVtbl[39] == m_pOrigVtbl[39]);
        }
    }
    void FastPathMultiplyTransformRecord()
    {
        m_pVtbl[39] = m_pOrigVtbl[39];
    }
    void FastPathSetMaterialExecute()
    {
        if((BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0)
        {
            m_pVtbl[42] = m_pVtbl[107];
        }
        else
        {
            DXGASSERT(m_pVtbl[42] == m_pOrigVtbl[42]);
        }
    }
    void FastPathSetMaterialRecord()
    {
        m_pVtbl[42] = m_pOrigVtbl[42];
    }
    void FastPathSetPixelShaderExecute()
    {
        if((BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0)
        {
            m_pVtbl[88] = m_pVtbl[108];
        }
        else
        {
            DXGASSERT(m_pVtbl[88] == m_pOrigVtbl[88]);
        }
    }
    void FastPathSetPixelShaderRecord()
    {
        m_pVtbl[88] = m_pOrigVtbl[88];
    }
    void FastPathSetPixelShaderConstantExecute()
    {
        if((BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0)
        {
            m_pVtbl[91] = m_pVtbl[109];
        }
        else
        {
            DXGASSERT(m_pVtbl[91] == m_pOrigVtbl[91]);
        }
    }
    void FastPathSetPixelShaderConstantRecord()
    {
        m_pVtbl[91] = m_pOrigVtbl[91];
    }
    void FastPathSetVertexShaderConstantExecute()
    {
        if((BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0 &&
           (BehaviorFlags() & D3DCREATE_PUREDEVICE) != 0)
        {
            m_pVtbl[79] = m_pVtbl[110];
        }
        else
        {
            DXGASSERT(m_pVtbl[79] == m_pOrigVtbl[79]);
        }
    }
    void FastPathSetVertexShaderConstantRecord()
    {
        m_pVtbl[79] = m_pOrigVtbl[79];
    }
#endif // FAST_PATH

public:
    CD3DBase();
    virtual ~CD3DBase();                                                                                                // 97

    virtual HRESULT D3DAPI SetRenderStateFast(D3DRENDERSTATETYPE dwState, DWORD value);                                 // 98
    virtual HRESULT D3DAPI SetTextureStageStateFast(DWORD dwStage, D3DTEXTURESTAGESTATETYPE dwState, DWORD dwValue);    // 99
    virtual HRESULT D3DAPI SetTextureFast(DWORD, IDirect3DBaseTexture8 *lpTex);                                         // 100
    virtual HRESULT D3DAPI ApplyStateBlockFast(DWORD);                                                                  // 101
#ifdef FAST_PATH
    virtual HRESULT D3DAPI SetVertexShaderFast(DWORD);                                                                  // 102
    virtual HRESULT D3DAPI SetStreamSourceFast(UINT StreamNumber, IDirect3DVertexBuffer8 *pStreamData, UINT Stride);    // 103
    virtual HRESULT D3DAPI SetIndicesFast(IDirect3DIndexBuffer8 *pIndexData, UINT BaseVertexIndex);                     // 104
    virtual HRESULT D3DAPI SetTransformFast(D3DTRANSFORMSTATETYPE, CONST D3DMATRIX*);                                   // 105
    virtual HRESULT D3DAPI MultiplyTransformFast(D3DTRANSFORMSTATETYPE, CONST D3DMATRIX*);                              // 106
#endif // FAST_PATH
    virtual HRESULT D3DAPI SetMaterialFast(CONST D3DMATERIAL8*);                                                        // 107
    virtual HRESULT D3DAPI SetPixelShaderFast(DWORD dwHandle);                                                          // 108
    virtual HRESULT D3DAPI SetPixelShaderConstantFast(DWORD dwRegisterAddress,                                          // 109
                                                      CONST VOID* lpvConstantData,
                                                      DWORD dwConstantCount);
    virtual HRESULT D3DAPI SetVertexShaderConstantFast(DWORD dwRegisterAddress,                                         // 110
                                                       CONST VOID* lpvConstantData,
                                                       DWORD dwConstantCount);

    virtual void Destroy();                                                                                             // 111

    // Virtual methods for CBaseDevice
    virtual HRESULT InitDevice();                                                                                       // 112
    virtual void StateInitialize(BOOL bZEnable);                                                                        // 113
    virtual void UpdateRenderState(DWORD dwStateType, DWORD value) {}                                                   // 114
    virtual void SetTransformI(D3DTRANSFORMSTATETYPE, CONST D3DMATRIX*);                                                // 115
    virtual void MultiplyTransformI(D3DTRANSFORMSTATETYPE, CONST D3DMATRIX*);                                           // 116
    virtual void SetClipPlaneI(DWORD dwPlaneIndex,                                                                      // 117
                               CONST D3DVALUE* pPlaneEquation);
    virtual void UpdateDriverStates(){ DDASSERT( FALSE ); }                                                             // 118
    virtual void SetViewportI(CONST D3DVIEWPORT8*);                                                                     // 119
    virtual void SetStreamSourceI(CVStream*);                                                                           // 120
    virtual void SetIndicesI(CVIndexStream*);                                                                           // 121
    virtual void CreateVertexShaderI(CONST DWORD* pdwDeclaration,                                                       // 122
                                     DWORD dwDeclSize,
                                     CONST DWORD* pdwFunction,
                                     DWORD dwCodeSize,
                                     DWORD dwHandle);
    virtual void SetVertexShaderI(DWORD dwHandle);                                                                      // 123
    virtual void DeleteVertexShaderI(DWORD dwHandle);                                                                   // 124
    virtual void SetVertexShaderConstantI(DWORD dwRegisterAddress,                                                      // 125
                                          CONST VOID* lpvConstantData,
                                          DWORD dwConstantCount);
    virtual void DrawPointsI(D3DPRIMITIVETYPE PrimitiveType,                                                            // 126
                             UINT StartVertex,
                             UINT PrimitiveCount);
    virtual void SetLightI(DWORD dwLightIndex, CONST D3DLIGHT8*);                                                       // 127
    virtual void LightEnableI(DWORD dwLightIndex, BOOL);                                                                // 128
    virtual void SetRenderStateInternal(D3DRENDERSTATETYPE, DWORD);                                                     // 129
    virtual void DrawPrimitiveUPI(D3DPRIMITIVETYPE PrimitiveType,                                                       // 130
                                 UINT PrimitiveCount);
    virtual void DrawIndexedPrimitiveUPI(D3DPRIMITIVETYPE PrimitiveType,                                                // 131
                                         UINT MinVertexIndex,
                                         UINT NumVertexIndices,
                                         UINT PrimitiveCount);
    virtual void GetPixelShaderConstantI(DWORD Register, DWORD count,                                                   // 132
                                         LPVOID pData );
    virtual void ClearI( DWORD dwCount, CONST D3DRECT* rects, DWORD dwFlags,                                            // 133
                         D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil);
    // Picks the right DrawPrimitive and DrawIndexedPrimitive function to
    // execute
    // Call this function when
    // - vertex shader is changed
    // - stream source is changed
    // - D3DRS_CLIPPING is changed
    // - resource has been changed
    //
    // Base device implementation is empty, because the function pointers are
    // initialized in the constructor and do not change
    virtual void __declspec(nothrow) PickDrawPrimFn() {};                                                               // 134

protected:
    void ValidateDraw(D3DPRIMITIVETYPE primType, UINT StartVertex,
                      UINT PrimitiveCount, UINT NumVertices,
                      BOOL bIndexPrimitive, BOOL bUsedMemPrimitive);
    void CheckIndices(CONST BYTE* pIndices, UINT NumIndices, UINT StartIndex,
                      UINT MinIndex, UINT NumVertices, UINT IndexStride);
    void CheckViewport(CONST D3DVIEWPORT8* lpData);
    void CheckVertexShaderHandle(DWORD dwHandle);
    void CheckPixelShaderHandle(DWORD dwHandle);
    inline void ClearVertexShaderHandle()
    {
        m_dwCurrentShaderHandle = 0;
    }
public:
    // non virtual methods
    HRESULT __declspec(nothrow) Init();
    HRESULT VerifyTexture(DWORD dwStage, IDirect3DBaseTexture8 *lpTex);
    HRESULT CalcDDSurfInfo(BOOL bUpdateZBufferFields);
    // Re-creates hardware pixel and vertex shaders after device is reset
    HRESULT ResetShaders();
    void __declspec(nothrow) NeedResourceStateUpdate()
    {
        this->m_dwRuntimeFlags |= (D3DRT_NEED_TEXTURE_UPDATE | D3DRT_NEED_VB_UPDATE);
        // We shouldn't call PickDrawPrimFn when the device is being destroyed
        if (m_pDDI)
            PickDrawPrimFn();
    }
    HRESULT __declspec(nothrow) SetRenderTargetI(CBaseSurface* pTarget,
                                                 CBaseSurface* pZ);
    // Checks if we can pass the render state to the driver
    BOOL CanHandleRenderState(D3DRENDERSTATETYPE type)
    {
        if (type >= m_rsMax)
        {
            // not an error condition because we don't send front-end stuff to
            // non-TL Hal devices, for example, but don't send to HAL anyway
            return FALSE;
        }
        return TRUE;
    };
    void UpdateTextures();
    void UpdatePalette(CBaseTexture *pTex, DWORD Palette, DWORD dwStage, BOOL bSavedWithinPrimitive);

    HRESULT __declspec(nothrow) TexBlt(CBaseTexture *lpDst,
                                       CBaseTexture* lpSrc,
                                       POINT *pPoint,
                                       RECTL *pRect);

    HRESULT __declspec(nothrow) CubeTexBlt(CBaseTexture *lpDstParent,
                                           CBaseTexture* lpSrcParent,
                                           DWORD dwDestFaceHandle,
                                           DWORD dwSrcFaceHandle,
                                           POINT *pPoint,
                                           RECTL *pRect);

    HRESULT __declspec(nothrow) VolBlt(CBaseTexture *lpDst, CBaseTexture* lpSrc, DWORD dwDestX,
                                       DWORD dwDestY, DWORD dwDestZ, D3DBOX *pBox);
    HRESULT __declspec(nothrow) BufBlt(CBuffer *lpDst, CBuffer* lpSrc, DWORD dwOffset,
                                       D3DRANGE* pRange);

    HRESULT __declspec(nothrow) SetPriority(CResource *pRes, DWORD dwPriority);
    HRESULT __declspec(nothrow) SetTexLOD(CBaseTexture *pTex, DWORD dwLOD);

    HRESULT __declspec(nothrow) AddDirtyRect(CBaseTexture *pTex, CONST RECTL *pRect);
    HRESULT __declspec(nothrow) AddCubeDirtyRect(CBaseTexture *pTex, DWORD dwFaceHandle, CONST RECTL *pRect);
    HRESULT __declspec(nothrow) AddDirtyBox(CBaseTexture *pTex, CONST D3DBOX *pBox);

    void __declspec(nothrow) CleanupTextures();
    void __declspec(nothrow) OnTextureDestroy(CBaseTexture*);

    ULONGLONG __declspec(nothrow) CurrentBatch()
    {
        DDASSERT(m_qwBatch > 0);
        return m_qwBatch;
    }
    void IncrementBatchCount();
    void __declspec(nothrow) Sync(ULONGLONG batch)
    {
        if (m_qwBatch <= batch)
        {
            FlushStatesNoThrow();
        }
    }

    HRESULT __declspec(nothrow) ValidateFVF(DWORD dwFVF);

    void __declspec(nothrow) FlushStatesNoThrow();

#if DBG
#define PROF_DRAWPRIMITIVEDEVICE2           0x0003
#define PROF_DRAWINDEXEDPRIMITIVEDEVICE2    0x0004
#define PROF_DRAWPRIMITIVESTRIDED           0x0005
#define PROF_DRAWINDEXEDPRIMITIVESTRIDED    0x0006
#define PROF_DRAWPRIMITIVEDEVICE3           0x0007
#define PROF_DRAWINDEXEDPRIMITIVEDEVICE3    0x0008
#define PROF_DRAWPRIMITIVEVB                0x0009
#define PROF_DRAWINDEXEDPRIMITIVEVB         0x000a
    DWORD   dwCaller;
    DWORD   dwPrimitiveType[PROF_DRAWINDEXEDPRIMITIVEVB+1];
    DWORD   dwVertexType1[PROF_DRAWINDEXEDPRIMITIVEVB+1];
    DWORD   dwVertexType2[PROF_DRAWINDEXEDPRIMITIVEVB+1];
    void    Profile(DWORD, D3DPRIMITIVETYPE, DWORD);
#else
    #define Profile(a,b,c)
#endif

    friend class CD3DDDIDX6;
};

typedef CD3DBase *LPD3DBASE;

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CD3DHal                                                                 //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

typedef void (CD3DHal::* PFN_PREPARETODRAW)(UINT StartVertex);

class CD3DHal : public CD3DBase
{
public: // Private Data

    // buffer for H vertices
    CAlignedBuffer32    HVbuf;

    // Front end data
    D3DFE_TRANSFORM     transform;      // Transformation state

    D3DCLIPSTATUS8      m_ClipStatus;

    // Pipeline state info

    D3DFE_PROCESSVERTICES* m_pv;        // common data for D3D and PSGP

    DWORD   dwFEFlags;                  // Front-end flags
    //--------------- Lights start -----------------------
    // List of currently enabled lights
    LIST_ROOT(_dlights, DIRECT3DLIGHTI) m_ActiveLights;

    LIST_ROOT(name10,_SpecularTable) specular_tables;
    SpecularTable*    specular_table;
    LIGHT_VERTEX_FUNC_TABLE *lightVertexFuncTable;

    // Light management support
    CHandleArray* m_pLightArray;
    //--------------- Lights end -----------------------

    // Viewports
    D3DVIEWPORT8    m_Viewport;

    DWORD           m_clrCount;   // Number of rects allocated
    LPD3DRECT       m_clrRects;   // Rects used for clearing

    // Runtime copy of the renderstates
    LPDWORD rstates;

    // Runtime copy of texture stage states
    DWORD tsstates[D3DHAL_TSS_MAXSTAGES][D3DHAL_TSS_STATESPERSTAGE];

    // Bit set for a render state means that we have to update internal front-end state
    // Otherwise we can go through a fast path
    CPackedBitArray rsVec;
    // Bit set for a render state means that the render state is retired
    CPackedBitArray rsVecRetired;
    // Bit set for a render state means that the render state is for vertex
    // processing only
    CPackedBitArray rsVertexProcessingOnly;
    // For every transformation matrix there is a bit, which is set if we need
    // to update driver state
    CPackedBitArray* pMatrixDirtyForDDI;

    // Pointer to a specific PrepareToDraw function
    PFN_PREPARETODRAW m_pfnPrepareToDraw;

    // Current vertex shader, corresponding to the dwCurrentShaderHandle
    // NULL for the fixed-function pipeline
    CVShader*   m_pCurrentShader;

    // The instance of the class providing a guaranteed implementation
    D3DFE_PVFUNCSI* GeometryFuncsGuaranteed;

    // Pixel Shader constant registers cached for Hal device
    PVM_WORD    m_PShaderConstReg[D3DPS_CONSTREG_MAX_DX8];

    // Object, used to convert NPatches to TriPatches
    CNPatch2TriPatch*   m_pConvObj;

    // Texture stages, which we need to remap, when number of output texture 
    // coordinates is greater than number of input texture coordinates
    D3DFE_TEXTURESTAGE textureStageToRemap[D3DDP_MAXTEXCOORD]; 
    // Number of texture stages to remap
    DWORD   dwNumTextureStagesToRemap;

    virtual HRESULT D3DAPI SetRenderStateFast(D3DRENDERSTATETYPE dwState, DWORD value);
    virtual HRESULT D3DAPI SetTextureStageStateFast(DWORD dwStage, D3DTEXTURESTAGESTATETYPE dwState, DWORD dwValue);
#ifdef FAST_PATH
    virtual HRESULT D3DAPI SetVertexShaderFast(DWORD);
#endif // FAST_PATH
    virtual HRESULT D3DAPI SetMaterialFast(CONST D3DMATERIAL8*);
    virtual HRESULT D3DAPI SetPixelShaderFast(DWORD dwHandle);
    virtual HRESULT D3DAPI SetPixelShaderConstantFast(DWORD dwRegisterAddress,
                                                      CONST VOID* lpvConstantData,
                                                      DWORD dwConstantCount);

public:
    CD3DHal();
    virtual ~CD3DHal();
    virtual void Destroy();

    //
    // Pure Methods from CD3DBase implemented here
    //

    virtual HRESULT InitDevice();
    virtual void StateInitialize(BOOL bZEnable);
    virtual void SetTransformI(D3DTRANSFORMSTATETYPE, CONST D3DMATRIX*);
    virtual void MultiplyTransformI(D3DTRANSFORMSTATETYPE, CONST D3DMATRIX*);
    virtual void SetViewportI(CONST D3DVIEWPORT8*);
    virtual void SetLightI(DWORD dwLightIndex, CONST D3DLIGHT8*);
    virtual void LightEnableI(DWORD dwLightIndex, BOOL);
    virtual void SetClipPlaneI(DWORD dwPlaneIndex,
                               CONST D3DVALUE* pPlaneEquation);
    virtual void SetStreamSourceI(CVStream*);
    virtual void SetIndicesI(CVIndexStream*);
    virtual void CreateVertexShaderI(CONST DWORD* pdwDeclaration,
                                     DWORD dwDeclSize,
                                     CONST DWORD* pdwFunction,
                                     DWORD dwCodeSize,
                                     DWORD dwHandle);
    virtual void SetVertexShaderI(DWORD dwHandle);
    virtual void DeleteVertexShaderI(DWORD dwHandle);
    virtual void SetVertexShaderConstantI(DWORD dwRegisterAddress,
                                          CONST VOID* lpvConstantData,
                                          DWORD dwConstantCount);
    virtual void DrawPointsI(D3DPRIMITIVETYPE PrimitiveType,
                                   UINT StartVertex,
                                   UINT PrimitiveCount);
    virtual void DrawPrimitiveUPI(D3DPRIMITIVETYPE PrimitiveType,
                                 UINT PrimitiveCount);
    virtual void DrawIndexedPrimitiveUPI(D3DPRIMITIVETYPE PrimitiveType,
                                         UINT MinVertexIndex,
                                         UINT NumVertexIndices,
                                         UINT PrimitiveCount);
    virtual void ClearI( DWORD dwCount, CONST D3DRECT* rects, DWORD dwFlags,
                         D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil);
    // This function is used when in SetRenderTarget the driver context is
    // recreated
    virtual void UpdateDriverStates();  // 10

    virtual void UpdateRenderState(DWORD dwStateType, DWORD value)
        {rstates[dwStateType] = value;}
    virtual void __declspec(nothrow) PickDrawPrimFn();

public: // non virtual methods

    // Called by drawing functions to prepare vertex stream pointers for
    // legacy vertex shaders
    void PrepareToDrawLegacy(UINT dwStartVertex);
    // Called by drawing functions to prepare vertex stream pointers for
    // programmable pipeline
    void PrepareToDrawVVM(UINT dwStartVertex);
    // Called by drawing functions to prepare vertex stream pointers for
    // fixed-function pipeline with declarations
    void PrepareToDraw(UINT dwStartVertex);
    // dwValue could be changed by the function, when we need to filter
    // PROJECTED bit.
    BOOL UpdateInternalTextureStageState(DWORD dwStage,
                                         D3DTEXTURESTAGESTATETYPE dwState,
                                         DWORD* dwValue);
    HRESULT checkDeviceSurface(LPDDRAWI_DDRAWSURFACE_LCL lpDDS, LPDDRAWI_DDRAWSURFACE_LCL lpZbuffer, LPGUID pGuid);
    void SetupFVFDataCommon();
    void SetupFVFData();
    void SwitchVertexProcessingMode(DWORD SoftwareMode);
    void DrawPoints(UINT StartVertex);
    void GetPixelShaderConstantI(DWORD Register, DWORD count, LPVOID pData );

    void PrepareNPatchConversion(UINT PrimitiveCount, UINT StartVertex);

    BOOL NeedInternalTSSUpdate(DWORD dwState)
    {
        return dwState == D3DTSS_TEXCOORDINDEX || dwState >= D3DTSS_TEXTURETRANSFORMFLAGS ||
               dwState == D3DTSS_COLOROP;
    }
    // Always use this function to update "rstates", because we have to
    // set some internal flags when "rstats" is changed.
    void UpdateInternalState(D3DRENDERSTATETYPE type, DWORD value);
    // Checks for 'retired' render state - returns TRUE if not retired
    BOOL CheckForRetiredRenderState(D3DRENDERSTATETYPE type)
    {
        if (!rsVecRetired.IsBitSet(type))
        {
            // not retired
            return TRUE;
        }
        return FALSE;
    }
    // Update internal state
    inline void SetFogFlags(void);
    void ForceFVFRecompute(void)
        {
            dwFEFlags |= D3DFE_FVF_DIRTY | D3DFE_FRONTEND_DIRTY;
            m_pv->dwDeviceFlags &= ~(D3DDEV_POSITIONINCAMERASPACE |
                                     D3DDEV_NORMALINCAMERASPACE);
            m_dwRuntimeFlags |= D3DRT_SHADERDIRTY;
        };
    void DisplayStats();
    void SetRenderStateInternal(D3DRENDERSTATETYPE, DWORD);
    HRESULT Initialize(IUnknown* pUnkOuter, LPDDRAWI_DIRECTDRAW_INT pDDrawInt);
    HRESULT D3DFE_Create();
    void D3DFE_Destroy();
    void ValidateDraw2(D3DPRIMITIVETYPE primType, UINT StartVertex,
                       UINT PrimitiveCount, UINT NumVertices,
                       BOOL bIndexPrimitive, UINT StartIndex = 0);
#if DBG
    void ValidateRTPatch();
#endif // DBG

#if DBG
#define PROF_DRAWPRIMITIVEDEVICE2           0x0003
#define PROF_DRAWINDEXEDPRIMITIVEDEVICE2    0x0004
#define PROF_DRAWPRIMITIVESTRIDED           0x0005
#define PROF_DRAWINDEXEDPRIMITIVESTRIDED    0x0006
#define PROF_DRAWPRIMITIVEDEVICE3           0x0007
#define PROF_DRAWINDEXEDPRIMITIVEDEVICE3    0x0008
#define PROF_DRAWPRIMITIVEVB                0x0009
#define PROF_DRAWINDEXEDPRIMITIVEVB         0x000a
    DWORD   dwCaller;
    DWORD   dwPrimitiveType[PROF_DRAWINDEXEDPRIMITIVEVB+1];
    DWORD   dwVertexType1[PROF_DRAWINDEXEDPRIMITIVEVB+1];
    DWORD   dwVertexType2[PROF_DRAWINDEXEDPRIMITIVEVB+1];
    void    Profile(DWORD, D3DPRIMITIVETYPE, DWORD);
#else
    #define Profile(a,b,c)
#endif
public:
    // IDirect3DDevice8 Methods
    HRESULT D3DAPI GetViewport(D3DVIEWPORT8*);
    HRESULT D3DAPI GetMaterial(D3DMATERIAL8*);
    HRESULT D3DAPI GetTransform(D3DTRANSFORMSTATETYPE, LPD3DMATRIX);
    HRESULT D3DAPI GetLight(DWORD, D3DLIGHT8*);
    HRESULT D3DAPI GetLightEnable(DWORD dwLightIndex, BOOL*);
    HRESULT D3DAPI GetClipPlane(DWORD dwPlaneIndex, D3DVALUE* pPlaneEquation);
    HRESULT D3DAPI GetTextureStageState(DWORD, D3DTEXTURESTAGESTATETYPE,
                                        LPDWORD);
    HRESULT D3DAPI SetTextureStageState(DWORD dwStage,
                                        D3DTEXTURESTAGESTATETYPE dwState,
                                        DWORD dwValue);
    HRESULT D3DAPI GetRenderState(D3DRENDERSTATETYPE, LPDWORD);
    HRESULT D3DAPI SetRenderState(D3DRENDERSTATETYPE, DWORD);

    HRESULT D3DAPI SetClipStatus(CONST D3DCLIPSTATUS8*);
    HRESULT D3DAPI GetClipStatus(D3DCLIPSTATUS8*);
    HRESULT D3DAPI ProcessVertices(UINT SrcStartIndex, UINT DestIndex,
                                   UINT VertexCount,
                                   IDirect3DVertexBuffer8 *DestBuffer,
                                   DWORD Flags);
    HRESULT D3DAPI GetVertexShaderConstant(DWORD dwRegisterAddress,
                                           LPVOID lpvConstantData,
                                           DWORD dwConstantCount);
    HRESULT D3DAPI GetPixelShaderConstant(DWORD dwRegisterAddress,
                                          LPVOID lpvConstantData,
                                          DWORD dwConstantCount);
    HRESULT D3DAPI GetVertexShader(LPDWORD pdwHandle);
    HRESULT D3DAPI GetPixelShader(LPDWORD pdwHandle);
};
//---------------------------------------------------------------------
//  macros to characterize device
//

#define IS_DX7HAL_DEVICE(lpDevI) ((lpDevI)->GetDDIType() >= D3DDDITYPE_DX7)
#define IS_DX8HAL_DEVICE(lpDevI) ((lpDevI)->GetDDIType() >= D3DDDITYPE_DX8)
#define IS_FPU_SETUP(lpDevI) ((lpDevI)->m_dwHintFlags & D3DDEVBOOL_HINTFLAGS_FPUSETUP )
#define IS_HAL_DEVICE(lpDevI) ((lpDevI)->GetDeviceType() == D3DDEVTYPE_HAL)
#define IS_HEL_DEVICE(lpDevI) ((lpDevI)->GetDeviceType() == D3DDEVTYPE_EMULATION)
#define IS_REF_DEVICE(lpDevI) ((lpDevI)->GetDeviceType() == D3DDEVTYPE_REF)

#endif
// @@END_MSINTERNAL

#endif /* _D3DI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\inc\fltval.h ===
/*
 * $Id: fltval.h,v 1.7 1995/12/01 18:07:12 dave Exp $
 *
 * Copyright (c) Microsoft Corp. 1993-1997
 * Version 1.1
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * Microsoft Corp.
 *
 */

#ifndef __D3DFLOAT__
#define __D3DFLOAT__

/*
 * Convert a value to fixed point at given precision.
 */
#define VALTOFXP(d,prec) ((int)SAFE_FLOAT_TO_INT((d) * (double)(1 << (prec))))
extern double RLDDIConvertIEEE[];

__inline int QVALTOFXP(double d, int prec)
{
    double tmp = d+RLDDIConvertIEEE[prec];
    return *(int *)&tmp;
}

/*
 * Convert from fixed point to value.
 */
#define FXPTOVAL(f,prec) ((float)(((double)(f)) / (double)(1 << (prec))))

/*
 * Convert from integer to fixed point.
 */
#define ITOFXP(i,prec)	((i) << (prec))

/*
 * Convert from fixed point to integer, truncating.
 */
#define FXPTOI(f,prec)	((int)((f) >> (prec)))

/*
 * Convert from fixed point to nearest integer greater or equal to f.
 */
#define FXPCEIL(f,prec) ((int)(((f) + (1 << (prec)) - 1) >> (prec)))

/*
 * Convert a double to fixed point at given precision.
 */
#define DTOVALP(d,prec) ((float) (d))

/*
 * Convert from fixed point to double.
 */
#define VALPTOD(f,prec)	((double) (f))

/*
 * Convert from integer to fixed point.
 */
#define ITOVALP(i,prec) ((float)(i))

/*
 * Convert from fixed point to integer, truncating.
 */
#define VALPTOI(f,prec)	((int)(f))

/*
 * Convert from fixed point to integer, rounding.
 */
#define VALPROUND(f,prec) ((int)((f) + 0.5))

/*
 * Convert between fixed point precisions.
 */
#define VALPTOVALP(f,from,to) (f)

/*
 * Increase the precision of a value.
 */
#define INCPREC(f,amount)	(f)

/*
 * Decrease the precision of a value.
 */
#define DECPREC(f,amount)	(f)

#define RLDDIFMul8(a, b)		((a) * (b))

#define RLDDIFMul12(a, b)		((a) * (b))

#define RLDDIFMul16(a, b)		((a) * (b))

#define RLDDIFMul24(a, b)		((a) * (b))

#define RLDDIFInvert12(a)		(1.0f / (a))

#define RLDDIFInvert16(a)		(1.0f / (a))

#define RLDDIFInvert24(a)		(1.0f / (a))

#define RLDDIFMulDiv(a, b, c)	((a) * (b) / (c))

#define RLDDIFDiv24(a, b)		((a) / (b))

#define RLDDIFDiv16(a, b)		((a) / (b))

#define RLDDIFDiv12(a, b)		((a) / (b))

#define RLDDIFDiv8(a, b)		((a) / (b))

/*
 * RLDDIFDiv8, checking for overflow.
 */
#define RLDDICheckDiv8(a, b)      ((a) / (b))

/*
 * RLDDIFDiv16, checking for overflow.
 */
#define RLDDICheckDiv16(a, b)	((a) / (b))

#define RLDDIGetZStep(zl, zr, zm, h3, h1) \
	(((zr - zm) * h3 - (zl - zm) * h1) / denom)

#include <limits.h>
#if defined(i386)
#define SAFE_FLOAT_TO_INT(f)	((f) > LONG_MAX	   \
				 ? LONG_MAX				           \
				 : (f) < LONG_MIN			       \
				 ? LONG_MIN				           \
                                 : (int)(f))
#else
#define SAFE_FLOAT_TO_INT(f)    ((int)(f))
#endif

/*
 * Normal precision used to store numbers.
 */
#define NORMAL_PREC     16
#define DTOVAL(d)       DTOVALP(d,NORMAL_PREC)
#define VALTOD(f)       VALPTOD(f,NORMAL_PREC)
#define ITOVAL(i)       ITOVALP(i,NORMAL_PREC)
#define VALTOI(f)       VALPTOI(f,NORMAL_PREC)
#define VALROUND(f)     VALPROUND(f,NORMAL_PREC)
#define VALTOFX(f)      VALTOFXP(f,NORMAL_PREC)
#define FXTOVAL(f)      FXPTOVAL(f,NORMAL_PREC)
#define ITOFX(i)        ITOFXP(i,NORMAL_PREC)
#define FXTOI(f)        FXPTOI(f,NORMAL_PREC)
#define FXROUND(f)      FXPROUND(f,NORMAL_PREC)
#define FXFLOOR(f)      FXPTOI(f,NORMAL_PREC)
#define FXCEIL(f)       FXPCEIL(f,NORMAL_PREC)
#define VALTOFX24(f)    VALTOFXP(f,24)
#define FX24TOVAL(f)    FXPTOVAL(f,24)
#define VALTOFX20(f)    VALTOFXP(f,20)
#define FX20TOVAL(f)    FXPTOVAL(f,20)
#define VALTOFX12(f)    VALTOFXP(f,12)
#define FX12TOVAL(f)    FXPTOVAL(f,12)
#define VALTOFX8(f)     VALTOFXP(f,8)
#define FX8TOVAL(f)     FXPTOVAL(f,8)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\inc\d3dtempl.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dtempl.hpp
 *  Content:    Direct3D templates include file
 *
 *
 ***************************************************************************/
#ifndef __D3DTEMPL_HPP
#define __D3DTEMPL_HPP

#include <d3dutil.h>
#include "d3dmem.h"

//--------------------------------------------------------------------------
//
// Template for growable arrays
//
//--------------------------------------------------------------------------
template <class ARRAY_ELEMENT>
class GArrayT 
{
public:
    GArrayT() 
    {
        m_pArray = NULL;
        m_dwArraySize = 0;
        m_dwGrowSize = 8;
    }
    
    ~GArrayT()
    {
        if( m_pArray ) 
        {
            DDASSERT( (m_dwArraySize != 0) && (m_pArray != NULL) );
            delete[] m_pArray;
        }
        else
        {
            DDASSERT( (m_dwArraySize == 0) && (m_pArray == NULL) );
        }
    }

    LPVOID GetArrayPointer() const {return m_pArray;}
    
    virtual void SetGrowSize( DWORD dwGrowSize)
    {
         m_dwGrowSize = dwGrowSize;
    }
    
#if 0
    virtual HRESULT Init( DWORD dwInitialSize, DWORD dwGrowSize)
    {
         m_pArray = AllocArray( dwInitialSize );
         if( m_pArray == NULL ) return E_OUTOFMEMORY;
         m_dwArraySize = dwInitialSize;
         m_dwGrowSize = dwGrowSize;
         return S_OK;
    }
#endif
    
    virtual HRESULT Grow( DWORD dwIndex )
    {
        if( dwIndex < m_dwArraySize ) return S_OK;
        DWORD dwNewArraySize = m_dwArraySize;
        while( dwNewArraySize <= dwIndex ) dwNewArraySize += m_dwGrowSize;
        ARRAY_ELEMENT *pNewArray = AllocArray( dwNewArraySize );
        if( pNewArray == NULL ) return E_OUTOFMEMORY;
        
        for( DWORD i = 0; i<m_dwArraySize; i++ )
        {
            pNewArray[i] = m_pArray[i];
            m_pArray[i].m_pObj = NULL; // To prevent deleting the object
        }
        
        delete[] m_pArray;
        m_pArray = pNewArray;
        m_dwArraySize = dwNewArraySize;
        return S_OK;
    }
    
    virtual ARRAY_ELEMENT *AllocArray( DWORD dwSize ) const
    {
        return new ARRAY_ELEMENT[dwSize];
    }
    
    virtual ARRAY_ELEMENT& operator []( DWORD dwIndex ) const
    {
        DDASSERT(dwIndex < m_dwArraySize);
        return m_pArray[dwIndex];
    }

    virtual BOOL Check( DWORD dwIndex ) const
    {
        return (dwIndex < m_dwArraySize);
    }
    
    virtual DWORD GetSize() const
    {
        return m_dwArraySize;
    }
    
    virtual DWORD GetGrowSize() const
    {
        return m_dwGrowSize;
    }
    
protected:
    ARRAY_ELEMENT *m_pArray;
    DWORD          m_dwArraySize;
    DWORD          m_dwGrowSize;
};

#endif //__D3DTEMPL_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\inc\d3ditype.h ===
//----------------------------------------------------------------------------
//
// d3ditype.h
//
// Standard types and supporting declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _D3DITYPE_H_
#define _D3DITYPE_H_

#ifndef FASTCALL
#ifdef _X86_
#define FASTCALL __fastcall
#else
#define FASTCALL
#endif
#endif

#ifndef CDECL
#ifdef _X86_
#define CDECL __cdecl
#else
#define CDECL
#endif
#endif

// Sized types.
#ifndef _BASETSD_H_
typedef signed char             INT8, *PINT8;
typedef short int               INT16, *PINT16;
typedef int                     INT32, *PINT32;
typedef __int64                 INT64, *PINT64;
typedef unsigned char           UINT8, *PUINT8;
typedef unsigned short int      UINT16, *PUINT16;
typedef unsigned int            UINT32, *PUINT32;
typedef unsigned __int64        UINT64, *PUINT64;
#endif

// Basic float types.
typedef float                   FLOAT;
//typedef double                  DOUBLE;

typedef FLOAT                  *PFLOAT;
typedef DOUBLE                 *PDOUBLE;

typedef float D3DVALUE;

typedef struct _D3DVECTORH
{
    D3DVALUE x;
    D3DVALUE y;
    D3DVALUE z;
    D3DVALUE w;
} D3DVECTORH, *LPD3DVECTORH;

// Max point size when D3D does point size emulation
const DWORD __MAX_POINT_SIZE = 64;

#endif // #ifndef _D3DITYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\inc\d3dmem.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dmem.h
 *  Content:    Direct3D memory access include file
 *
 ***************************************************************************/
#ifndef _D3DMEM_H_
#define _D3DMEM_H_

#include "vbuffer.hpp"

class CD3DHal;

 /*
 * Register a set of functions to be used in place of malloc
 * and free for memory allocation.  The functions D3DMalloc
 * and D3DFree will use these functions.  The default is to use the
 * ANSI C library routines malloc and free.
 */
typedef LPVOID (*D3DMALLOCFUNCTION)(size_t);
typedef VOID (*D3DFREEFUNCTION)(LPVOID);

/*
 * Allocate size bytes of memory and return a pointer to it in *p_return.
 * Returns D3DERR_BADALLOC with *p_return unchanged if the allocation fails.
 */
HRESULT D3DAPI      D3DMalloc(LPVOID* p_return, size_t size);

/*
 * Free a block of memory previously allocated with D3DMalloc
 */
VOID D3DAPI     D3DFree(LPVOID p);

HRESULT MallocAligned(void** p_return, size_t size);
void FreeAligned(void* p);

#define __USEGLOBALNEWANDDELETE

#ifndef __USEGLOBALNEWANDDELETE
/* Base class for all D3D classes to use our special allocation functions everywhere */
class CD3DAlloc
{
public:
    void* operator new(size_t s) const
    {
        void *p;
        MallocAligned(&p,s);
        return p;
    };
    void operator delete(void* p) const
    {
        FreeAligned(p);
    };
};

#define D3DNEW CD3DAlloc::new
#define D3DDELETE CD3DAlloc::delete
#else
void* operator new(size_t s);
void operator delete(void* p);
#define D3DNEW ::new
#define D3DDELETE ::delete
#endif
//---------------------------------------------------------------------
// This class manages growing buffer, aligned to 32 byte boundary
// Number if bytes should be power of 2.
// D3DMalloc is used to allocate memory
//
class CAlignedBuffer32
{
public:
    CAlignedBuffer32()  
    {
        size = 0; 
        allocatedBuf = 0; 
        alignedBuf = 0;
    }
    ~CAlignedBuffer32() 
    {
        if (allocatedBuf) 
            D3DFree(allocatedBuf);
    }
    // Returns aligned buffer address
    LPVOID GetAddress() 
    {
        return alignedBuf;
    }
    // Returns aligned buffer size
    DWORD GetSize() 
    {
        return size;
    }
    HRESULT Grow(DWORD dwSize);
    HRESULT CheckAndGrow(DWORD dwSize)
    {
        if (dwSize > size)
            return Grow(dwSize + 1024);
        else
            return D3D_OK;
    }
protected:
    LPVOID allocatedBuf;
    LPVOID alignedBuf;
    DWORD  size;
};

// Forward declarations
class CD3DHal;
class CD3DHalDP2;


#endif //_D3DMEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\inc\ddibase.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   ddi.h
 *  Content:    Direct3D DDI encapsulation implementations
 *
 *
 ***************************************************************************/

#ifndef _DDIBASE_H
#define _DDIBASE_H

#include "d3ditype.h"
#include "d3dhalp.h"

extern char *HrToStr(HRESULT hr);

class CD3DBase;

struct _D3D8_DEVICEDATA;
typedef struct _D3D8_DEVICEDATA D3D8_DEVICEDATA;

class CSurface;
class D3DFE_PROCESSVERTICES;
class CBaseTexture;
class CDriverVertexBuffer;
struct CVStream;
struct CVIndexStream;
class CBaseSurface;
class CResource;
class CBuffer;

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CD3DDDI                                                                 //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////
class CD3DDDI
{
protected:

    // DrawIndexedStream params
    UINT        m_StartIndex;
    UINT        m_MinVertexIndex;
    UINT        m_NumVertices;
    int         m_BaseVertexIndex;
    
public:
    CD3DDDI();
    virtual ~CD3DDDI();

    //++++++++++++++ Interface which the PSGP is using ++++++++++++++++++++++++
    //
    // These functions are used when vertices are processed by D3D pipeline.

    // Internal driver buffers
    // D3D has three driver buffers: TL buffer, which contains primitive 
    // vertices, command buffer, where drawing commands are recorded, and clip
    // buffer, where vertices, generated by clipper, are recorded. D3D maintains 
    // count of vertices in the TL buffer (TL buffer vertex count) and an index 
    // of the first vertex of the current primitive (primitive base). When a 
    // drawing command is recorded, D3D records the current primitive base.
    // All drawing commands expect that vertices have already been copied to the
    // TL buffer (excluding DrawClippedPrim).
    //
    // If a flush occurs during recording a command, vertex buffer is not 
    // flushed, because m_bWithinPrimitive is set to TRUE. So primitive base
    // and TL vertex count stay the same.
    //
    // When PSGP processes and clip a non-indexed primitive, it should update
    // primitive base and TL vertex count, using SkipVertices and 
    // MovePrimitiveBase functions. AddVertices is not used, because DrawPrim()
    // functions calls AddVertices and MovePrimitiveBase inself.

    // Draw unclipped part of non-indexed primitive
    //
    //   Parameters:
    //      pv->lpvOut          - pointer to the first vertex
    //      pv->primType        - primitiveType;                                
    //      pv->dwNumVertices   - vertexCount
    //      pv->dwNumPrimitives - number of primitives
    //  Remarks:
    //      This function is used when vertices are processed by D3D pipeline.
    //      The function inserts a new command to the command buffer.
    //      Primitive base is increased by the number of vertices.
    //      TL buffer vertex count is increased by the number of vertices.
    //
    virtual void DrawPrim(D3DFE_PROCESSVERTICES* pv)                = 0;

    // Draw unclipped part of an indexed primitive
    //
    //   Parameters:
    //      pv->lpvOut          - pointer to the first vertex of the whole
    //                            primitive
    //      pv->primType        - primitiveType                    
    //      pv->dwNumPrimitives - number of primitives
    //      pv->lpwIndices      - pointer to the first index                                     
    //      pv->dwNumIndices    - number of indices                                  
    //      pv->dwIndexSize     - size of an index in bytes (2 or 4)
    //  Remarks:
    //      Vertices must be already copied to the TL buffer.
    //      The function inserts a new command to the command buffer.
    //      Indices are copied to the index buffer. Vertices must be in the TL
    //      buffer already.
    //      Primitive base and TL buffer vertex count are not changed.
    //
    virtual void DrawIndexPrim(D3DFE_PROCESSVERTICES* pv)           = 0;
    
    // Draw a primitive, generated by clipper
    //
    //   Parameters:
    //      pv->lpvOut          - pointer to the first vertex of the primitive
    //      pv->primType        - primitiveType
    //      pv->dwNumVertices   - vertex count
    //      pv->dwNumPrimitives - number of primitives
    //  Remarks:
    //      Vertices are copied to the clipping buffer
    //      The function inserts a new command to the command buffer.
    //      Primitive base and TL buffer vertex count are not changed.
    //
    virtual void DrawClippedPrim(D3DFE_PROCESSVERTICES* pv)         = 0;

    // Increase TL buffer vertex count
    //
    //  The function addes the number of vertices to the current primitive 
    //  base. So when it is called several times without moving the primitive
    //  base, only the last call will have effect.
    //  This function should be called after vertices are added to the
    //  TL buffer, but before a drawing function is called.
    //
    virtual void AddVertices(UINT NumVertices)                      = 0;

    // Decrease TL buffer vertex count
    //
    //  This function should be called after vertices are added to the
    //  TL buffer, but before a drawing function is called.
    //
    virtual void SubVertices(UINT NumVertices)                      = 0;

    // Update primitive base
    //
    // It should be called when some vertices are skipped because of clipping.
    // NumVertices could be negative, 
    //
    virtual void MovePrimitiveBase(int NumVertices)                 = 0;

    // Update primitive base and TL buffer vertex count
    //
    // Call this function when some vertices in the vertex buffer are used
    // for clipping and should be skipped
    //
    virtual void SkipVertices(DWORD NumVertices)                    = 0;

    void SetIndexedPrimParams(UINT StartIndex, UINT MinIndex, UINT NumVertices,
                              UINT BaseVertexIndex)
    {
        m_StartIndex = StartIndex;
        m_MinVertexIndex = MinIndex;
        m_NumVertices = NumVertices;
        m_BaseVertexIndex = BaseVertexIndex;
    }
    
    // Returns offset in bytes of the start vertex of the current primitive in
    // the current TL stream
    virtual DWORD GetCurrentPrimBase() {return 0;}
    //-------------------- End PSGP functions ---------------------------------
};
typedef CD3DDDI *LPD3DDDI;


#endif /* _D3DIBASE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\inc\ids8.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ids.h
 *  Content:    DirectDraw resource ids
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   10-sep-95  toddla  created
 *   20-sep-95	craige	add IDS_PRIMARYDISPLAY
 *
 ***************************************************************************/

// string ids
#define IDS_TITLE           100     // dialog box title
#define IDS_DONTWORK_BPP    101     // you must be in 256 color mode or higher.
#define IDS_PRIMARYDISPLAY  102     // Primary Display Driver
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\inc\hmgr.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       hmgr.hpp
 *  Content:    Handle Manager header file
 *
 ***************************************************************************/
#ifndef _HMGR_HPP_
#define _HMGR_HPP_

#include "d3dtempl.hpp"


//-----------------------------------------------------------------------------
//
// D3D Base object class. All objects that are referred to by handles
// should inherit from this class
//
//-----------------------------------------------------------------------------
class CD3DBaseObj 
{
public:
    virtual ~CD3DBaseObj()
    {
        return;
    }
    
private:
};
typedef CD3DBaseObj* LPD3DBASEOBJ;


//-----------------------------------------------------------------------------
//
// D3D Handle Class.
//
//-----------------------------------------------------------------------------
struct CHandle
{
    CHandle()
    {
        m_Next = 0;
        m_pObj = NULL;
#if DBG
        m_tag = 0;
#endif
    }
    ~CHandle()
    {
        delete m_pObj;
    }
    DWORD        m_Next;     // Used to make list of free handles
    LPD3DBASEOBJ m_pObj;
#if DBG
    // Non zero means that it has been allocated
    DWORD              m_tag;
#endif    
};


const   DWORD __INVALIDHANDLE = 0xFFFFFFFF;

typedef GArrayT<CHandle> CHandleArray;

//-----------------------------------------------------------------------------
//
// D3D HandleFactory Class:
//
// This handle factory assumes that the handle returned can be directly used
// an index into the handle array. This will not work if there is some
// munging required for the handle (in the vertex shader case)
//
//-----------------------------------------------------------------------------

class CHandleFactory 
{
public:
    CHandleFactory();
    CHandleFactory(DWORD dwGrowSize);
    DWORD GetSize() const { return m_Handles.GetSize(); }
    virtual DWORD CreateNewHandle( LPD3DBASEOBJ pObj  );
    virtual LPD3DBASEOBJ GetObject( DWORD dwHandle ) const;
    virtual UINT HandleFromIndex( DWORD index) const {return index;}
    // Sets new object pointer. Returns TRUE if success. Old object is not deleted
    virtual BOOL SetObject( DWORD dwHandle, LPD3DBASEOBJ ); 
    virtual void ReleaseHandle(DWORD handle, BOOL bDeleteObject = TRUE);
    
protected:
    CHandleArray       m_Handles;
    DWORD              m_Free;       // Header for free elements in the array
};


#endif //_HMGR_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\inc\testfile.h ===
//----------------------------------------------------------------------------
//
// testfile.h
//
// Defines for file with test data.
//
// File format:
//      File contains chunks of data. Each chunk has four-byte ID, four-byte data size field and
//      "size" number of bytes of data.
//      Chunks:
//          ID          Meaning           Data
//          1       Scene capture       DWORD flags
//          2       Render state        DWORD states count
//                                      States (D3DSTATE*count)
//          3       Render primitive    DWORD status
//                                      D3DPRIMITIVETYPE primitive type
//                                      DWORD number of vertices
//                                      D3DVERTEXTYPE vertex type
//                                      D3DINSTRUCTION
//                                        Primitive record (D3DPOINT, D3DLINE ...)
//                                        Primitive vertices (TLVERTEX)
//                                        ...
//          4       Draw one primitive  D3DPRIMITIVETYPE primitive type
//                                      DWORD number of vertices
//                                      D3DVERTEXTYPE vertex type
//                                      Vertices
//          5       Draw one indexed    D3DPRIMITIVETYPE primitive type
//                      primitive       DWORD number of vertices
//                                      DWORD number of indices
//                                      D3DVERTEXTYPE vertex type
//                                      Vertices
//                                      Indices (WORD)
//          6       Draw primitives     The same as DDI data, but without 32 byte
//                                      alignment.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------
#ifndef _TESTFILE_H_
#define _TESTFILE_H_

// TF stands for "TestFile"
typedef struct
{
    DWORD id;           // record ID
    DWORD size;         // size of data in bytes (exclude size of REC_HEADER)
} TF_HEADER;

// ID for test file records
const DWORD TFID_SCENECAPTURE               = 1;
const DWORD TFID_RENDERSTATE                = 2;
const DWORD TFID_RENDERPRIMITIVE            = 3;
const DWORD TFID_DRAWONEPRIMITIVE           = 4;
const DWORD TFID_DRAWONEINDEXEDPRIMITIVE    = 5;
const DWORD TFID_DRAWPRIMITIVES             = 6;
const DWORD TFID_DRAWPRIMITIVES2            = 7;

// Fixed size record headers
typedef struct
{
    DWORD               status;
    D3DPRIMITIVETYPE    primitiveType;
    DWORD               vertexCount;
    D3DVERTEXTYPE       vertexType;
} TFREC_RENDERPRIMITIVE;

typedef struct
{
    D3DPRIMITIVETYPE    primitiveType;
    DWORD               vertexCount;
    D3DVERTEXTYPE       vertexType;
    DWORD               dwFlags;
} TFREC_DRAWONEPRIMITIVE;

typedef struct
{
    D3DPRIMITIVETYPE    primitiveType;
    DWORD               vertexCount;
    D3DVERTEXTYPE       vertexType;
    DWORD               indexCount;
    DWORD               dwFlags;
} TFREC_DRAWONEINDEXEDPRIMITIVE;

typedef struct
{
    DWORD               dwFlags;
} TFREC_DRAWPRIMITIVES;

typedef struct
{
    DWORD               dwFlags;
} TFREC_DRAWPRIMITIVES2;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\inc\lists.hpp ===
/* Copyright (c) 1997  Microsoft Corporation */
/* See the .C test code at the end of this file for examples of how to use
   this stuff.
*/
#ifndef _LISTS_H
#define _LISTS_H

#define LIST_ROOT(name, type) struct name {type *Root;}

#define LIST_MEMBER(type) struct { type **Prev; type *Next;}
/* Note!  Prev is the ADDRESS of the previous next element ptr */

#define LIST_INSERT_ROOT(root,element,field)\
{   if(((element)->field.Next = (root)->Root) != 0)\
    (root)->Root->field.Prev = &(element)->field.Next;\
    (root)->Root = (element);\
    (element)->field.Prev = &(root)->Root;\
}

#define LIST_DELETE(element,field)\
{\
    if((element)->field.Next)\
    (element)->field.Next->field.Prev = (element)->field.Prev;\
    if ((element)->field.Prev)\
    {\
        *(element)->field.Prev = (element)->field.Next;\
        (element)->field.Prev = 0;\
    }\
    (element)->field.Next = 0;\
}

#define LIST_INITIALIZE(root)\
{\
    (root)->Root = 0;\
}

#define LIST_INITIALIZE_MEMBER(element,field)\
{   (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define LIST_ORPHAN_MEMBER(element,field) (!((element)->field.Prev))

#define LIST_FIRST(root) (root)->Root
#define LIST_NEXT(element,field) (element)->field.Next



#define TAIL_QUEUE_INITIALIZE(root)\
{\
    (root)->First = NULL;\
    (root)->Last = &(root)->First;\
}

#define TAIL_QUEUE_ROOT(name,type)\
struct name\
{   type *First;\
    type **Last;\
}/* NOTE!  This is the address of the last Next pointer. */


#define TAIL_QUEUE_MEMBER(type)\
struct\
{   type *Next;\
    type **Prev;    /* NOTE!  Address of previous Next element ptr */\
}

#define TAIL_QUEUE_INSERT_END(root,element,field)\
{   (element)->field.Prev = (root)->Last;\
    (element)->field.Next = 0;\
    *(root)->Last = (element);\
    (root)->Last = &(element)->field.Next;\
}

#define TAIL_QUEUE_DELETE(root,element,field)\
{\
    if (((element)->field.Next) != NULL)\
    (element)->field.Next->field.Prev = (element)->field.Prev;\
    else\
    (root)->Last = (element)->field.Prev;\
    *(element)->field.Prev = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define TAIL_QUEUE_FIRST(root) (root)->First
#define TAIL_QUEUE_NEXT(element,field) (element)->field.Next



#define CIRCLE_QUEUE_ROOT(name,type)\
struct name\
{   type *Last;\
    type *First;\
}

#define CIRCLE_QUEUE_MEMBER(type)\
struct\
{   type *Prev;\
    type *Next;\
}

#define CIRCLE_QUEUE_INITIALIZE(root,type)\
{   (root)->Last = (type *)(root);\
    (root)->First = (type *)(root);\
}

#define CIRCLE_QUEUE_INITIALIZE_MEMBER(element,field)\
{ (element)->field.Next = (element)->field.Prev = 0;\
}

#define CIRCLE_QUEUE_INSERT_END(root,type,element,field)\
{   (element)->field.Prev = (root)->Last;\
    (element)->field.Next = (type *)(root);\
    if((root)->First != (type *)(root))\
    (root)->Last->field.Next = (element);\
    else\
    (root)->First = (element);\
    (root)->Last = (element);\
}

#define CIRCLE_QUEUE_INSERT_ROOT(root,type,element,field)\
{   (element)->field.Prev = (type *)(root);\
    (element)->field.Next = (root)->First;\
    if ((root)->Last != (void *)(root))\
    (root)->First->field.Prev = (element);\
    else\
    (root)->Last = (element);\
    (root)->First = (element);\
}

#define CIRCLE_QUEUE_INSERT_PREVIOUS(root,current_element,element,field)\
{   (element)->field.Prev = (current_element)->field.Prev;\
    (element)->field.Next = (current_element);\
    if ((current_element)->field.Prev != (void *)(root))\
    (current_element)->field.Prev->field.Next = (element);\
    else\
    (root)->First = (element);\
    (current_element)->field.Prev = (element);\
}

#define CIRCLE_QUEUE_DELETE(root,element,field)\
{   if((element)->field.Next != (void *)(root))\
    (element)->field.Next->field.Prev = (element)->field.Prev;\
    else\
    (root)->Last = (element)->field.Prev;\
    if((element)->field.Prev != (void *)(root))\
    (element)->field.Prev->field.Next = (element)->field.Next;\
    else\
    (root)->First = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define CIRCLE_QUEUE_FIRST(root)\
((root)->First == (void *) (root)? 0: (root)->First)

#define CIRCLE_QUEUE_LAST(root)\
((root)->Last == (void *) (root)? 0: (root)->Last)

#define CIRCLE_QUEUE_NEXT(root,element,field)\
((void *) (element)->field.Next == (void *) (root)? 0: (element)->field.Next)

#define CIRCLE_QUEUE_PREVIOUS(root,element,field)\
((element)->field.Prev == (void *) (root)? 0: (element)->field.Prev)

//---------------------------------------------------------------------
// To support singly linked lists with no deletion of entries. Useful
// for active lists (Active Lights etc.)
struct CListEntry
{
    CListEntry()    {m_pNext = NULL;}
    virtual ~CListEntry()   {delete m_pNext;}
    
    void Append(CListEntry* p) {p->m_pNext = m_pNext; m_pNext = p;}

    CListEntry *  m_pNext;
};

///////////////////////////////////////////////////////////////////////////////
#if 0
/*
Test code.  Strip it out, put it in a .C (or .CPP) file and compile it as a
console app to test this stuff. It should run without any assertion failures.

Also, use this as example code.
*/

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>


void TestList(void)
{
    struct Foo
    {
    int a;
    LIST_MEMBER(Foo) ListStuff;
    int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    LIST_ROOT(sRoot, Foo) MyListRoot;

    fputs("Testing LIST.\n",stdout);

    LIST_INITIALIZE(&MyListRoot);

    LIST_INITIALIZE_MEMBER(&MyFoo1,ListStuff);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;

    LIST_INITIALIZE_MEMBER(&MyFoo2,ListStuff);
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;

    LIST_INITIALIZE_MEMBER(&MyFoo3,ListStuff);
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;
    assert(LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));

    LIST_INSERT_ROOT(&MyListRoot,&MyFoo3,ListStuff);
    assert(!LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo2,ListStuff);
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo1,ListStuff);

    assert(!LIST_ORPHAN_MEMBER(&MyFoo1,ListStuff));
    assert(!LIST_ORPHAN_MEMBER(&MyFoo2,ListStuff));
    assert(!LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));

    pFoo = LIST_FIRST(&MyListRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x2A);
    assert(pFoo->b == 0x2B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo == 0);

    /* Delete member 2. */
    pFoo = LIST_FIRST(&MyListRoot);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x2B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Make sure that there are only members 1 and 3 in the list now. */
    pFoo = LIST_FIRST(&MyListRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Delete member 3. */
    pFoo = LIST_FIRST(&MyListRoot);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x3B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Delete member 1. */
    pFoo = LIST_FIRST(&MyListRoot);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);
    assert(LIST_FIRST(&MyListRoot) == 0);

    LIST_INSERT_ROOT(&MyListRoot,&MyFoo2,ListStuff);
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo1,ListStuff);
    
    /* Delete member 1 while there are other members in the list. */
    pFoo = LIST_FIRST(&MyListRoot);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);
    assert(LIST_FIRST(&MyListRoot) == &MyFoo2);

    assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
    assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
    assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);

    fputs("List passed.\n", stdout);
}

void TestTailQueue(void)
{
    struct Foo
    {
    int a;
    TAIL_QUEUE_MEMBER(Foo) TQStuff;
    int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    TAIL_QUEUE_ROOT(sRoot, Foo) MyTQRoot;

    fputs("Testing TAIL_QUEUE.\n",stdout);

    TAIL_QUEUE_INITIALIZE(&MyTQRoot);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;

    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo1,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo2,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo3,TQStuff);

    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x2A);
    assert(pFoo->b == 0x2B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo == 0);

    /* Delete member 2. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x2B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Make sure that there are only members 1 and 3 in the list now. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Delete member 3. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x3B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Delete member 1. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);
    assert(TAIL_QUEUE_FIRST(&MyTQRoot) == 0);

    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo1,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo2,TQStuff);
    
    /* Delete member 1 while there are other members in the list. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);
    assert(TAIL_QUEUE_FIRST(&MyTQRoot) == &MyFoo2);

    assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
    assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
    assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);

    fputs("Tail Queue passed.\n", stdout);
}
void TestCircleQueue(void)
{
    enum {END,ROOT,PREVIOUS,DONE} WhichInsert = END;
    int i;
    struct Foo
    {
    int a;
    CIRCLE_QUEUE_MEMBER(Foo) CQStuff;
    int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    CIRCLE_QUEUE_ROOT(sRoot, Foo) MyCQRoot;

    fputs("Testing CIRCLE_QUEUE.\n",stdout);

    while(WhichInsert != DONE)
    {
    CIRCLE_QUEUE_INITIALIZE(&MyCQRoot,Foo);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;
    
    switch(WhichInsert)
    {
    case END:
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo1,CQStuff);
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo2,CQStuff);
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo3,CQStuff);
        WhichInsert = ROOT;
        break;
    case ROOT:
        CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo3,CQStuff);
        CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo2,CQStuff);
        CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo1,CQStuff);
        WhichInsert = PREVIOUS;
        break;
    case PREVIOUS:
        CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo3,CQStuff);
        CIRCLE_QUEUE_INSERT_PREVIOUS(&MyCQRoot,&MyFoo3,&MyFoo2,CQStuff);
        CIRCLE_QUEUE_INSERT_PREVIOUS(&MyCQRoot,&MyFoo2,&MyFoo1,CQStuff);
        WhichInsert = DONE;
        break;
    default:
        assert(0);
    }

        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        assert(pFoo);
        assert(pFoo->a == 0x1A);
        assert(pFoo->b == 0x1B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x2A);
        assert(pFoo->b == 0x2B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x3A);
        assert(pFoo->b == 0x3B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo == 0);

    pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
    assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,pFoo,CQStuff) == 0);
    pFoo = CIRCLE_QUEUE_LAST(&MyCQRoot);
    assert(pFoo == &MyFoo3);
    assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,pFoo,CQStuff) == &MyFoo2);
    assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,&MyFoo2,CQStuff) == &MyFoo1);
    
        /* Delete member 2. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x2B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Make sure that there are only members 1 and 3 in the list now. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        assert(pFoo);
        assert(pFoo->a == 0x1A);
        assert(pFoo->b == 0x1B);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x3A);
        assert(pFoo->b == 0x3B);
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Delete member 3. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x3B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Delete member 1. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x1B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
        assert(CIRCLE_QUEUE_FIRST(&MyCQRoot) == 0);
    
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo1,CQStuff);
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo2,CQStuff);
        
        /* Delete member 1 while there are other members in the list. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x1B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
        assert(CIRCLE_QUEUE_FIRST(&MyCQRoot) == &MyFoo2);
    
        assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
        assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
        assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);
    }

    fputs("Circle Queue passed.\n", stdout);
}

int main()
{
    TestList();
    TestTailQueue();
    TestCircleQueue();
    fputs("All tests passed.", stdout);
    return EXIT_SUCCESS;
}
#endif /* End of test code. */


#endif // !_LISTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\inc\ddi.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   ddi.h
 *  Content:    Direct3D DDI encapsulation implementations
 *
 *
 ***************************************************************************/

#ifndef _DDI_H
#define _DDI_H

#include "ddibase.h"

class CVertexBuffer;
class CCommandBuffer;
class CTLStreamRO;
class CTLIndexStreamRO;
class CD3DDDIDX6;

// Number of point sprites in a point sprite batch
const UINT NUM_SPRITES_IN_BATCH = 500;

extern void CD3DDDIDX6_DrawPrimitive(CD3DBase* pDevice,
                                     D3DPRIMITIVETYPE primType,
                                     UINT StartVertex,
                                     UINT PrimitiveCount);
extern void
CD3DDDIDX8_DrawPrimitive(CD3DBase* pDevice, D3DPRIMITIVETYPE PrimitiveType,
                         UINT StartVertex, UINT PrimitiveCount);
extern void
CD3DDDIDX8_DrawIndexedPrimitive(CD3DBase* pDevice,
                                D3DPRIMITIVETYPE PrimitiveType,
                                UINT BaseVertexIndex,
                                UINT MinIndex, UINT NumVertices,
                                UINT StartIndex, UINT PrimitiveCount);
extern void
CD3DDDITL_DrawIndexedPrimitive(CD3DBase* pDevice,
                               D3DPRIMITIVETYPE PrimitiveType,
                               UINT BaseVertexIndex,
                               UINT MinIndex,
                               UINT NumVertices, UINT StartIndex,
                               UINT PrimitiveCount);
extern void
CD3DDDIDX6_DrawIndexedPrimitive(CD3DBase* pDevice,
                               D3DPRIMITIVETYPE PrimitiveType,
                               UINT BaseVertexIndex,
                               UINT MinIndex,
                               UINT NumVertices, UINT StartIndex,
                               UINT PrimitiveCount);

typedef void (*PFN_DRAWPRIMFAST)(CD3DBase* pDevice, D3DPRIMITIVETYPE primType,
                                 UINT StartVertex, UINT PrimitiveCount);
typedef void (*PFN_DRAWINDEXEDPRIMFAST)(CD3DBase* pDevice,
                                        D3DPRIMITIVETYPE PrimitiveType,
                                        UINT BaseVertexIndex,
                                        UINT MinIndex, UINT NumVertices,
                                        UINT StartIndex, UINT PrimitiveCount);
//-----------------------------------------------------------------------------
class CTLStream: public CVStream
{
public:
    CTLStream(BOOL bWriteOnly);
    CTLStream(BOOL bWriteOnly, UINT Usage);
    UINT GetSize()  {return m_dwSize - m_dwUsedSize;}
    void Grow(UINT RequiredSize, CD3DDDIDX6* pDDI);
    void Reset()    {m_dwPrimitiveBase = 0; m_dwUsedSize = 0;}
    DWORD GetVertexSize() {return m_dwStride;}
    void SetVertexSize(DWORD dwVertexSize) {m_dwStride = dwVertexSize;}
    DWORD GetPrimitiveBase() {return m_dwPrimitiveBase;}
    virtual BYTE* Lock(UINT NeededSize, CD3DDDIDX6* pDDI);
    virtual void Unlock();
    virtual void AddVertices(UINT NumVertices)
    {
        m_dwUsedSize = m_dwPrimitiveBase + NumVertices * m_dwStride;
        DXGASSERT(m_dwSize >= m_dwUsedSize);
    }
    virtual void SubVertices(UINT NumVertices)
    {
        DXGASSERT(m_dwUsedSize >= NumVertices * m_dwStride);
        m_dwUsedSize -= NumVertices * m_dwStride;
        DXGASSERT(m_dwSize >= m_dwUsedSize);
    }
    virtual void MovePrimitiveBase(int NumVertices)
    {
        m_dwPrimitiveBase += NumVertices * m_dwStride;
    }
    virtual void SkipVertices(DWORD NumVertices)
    {
        const UINT size = NumVertices * m_dwStride;
        m_dwPrimitiveBase += size;
        m_dwUsedSize = m_dwPrimitiveBase;
        DXGASSERT(m_dwSize >= m_dwUsedSize);
    }
    BOOL CheckFreeSpace(UINT size) {return (m_dwSize - m_dwUsedSize) >= size;}
protected:
    // Number of bytes used in the buffer
    // It is not used by CTLStreamRO
    DWORD   m_dwUsedSize;
    // Offset in bytes from where the current primitive starts
    DWORD   m_dwPrimitiveBase;
    UINT    m_Usage;
    // TRUE, if buffer is used only for writing
    BOOL    m_bWriteOnly;
#if !DBG
    DWORD   m_dwSize;
#endif
};
//-----------------------------------------------------------------------------
class CTLIndexStream: public CVIndexStream
{
public:
    CTLIndexStream();
    UINT GetSize()  {return m_dwSize - m_dwUsedSize;}
    void Grow(UINT RequiredSize, CD3DDDIDX6* pDDI);
    void Reset()    {m_dwPrimitiveBase = 0; m_dwUsedSize = 0;}
    DWORD GetVertexSize() {return m_dwStride;}
    void SetVertexSize(DWORD dwVertexSize) {m_dwStride = dwVertexSize;}
    DWORD GetPrimitiveBase() {return m_dwPrimitiveBase;}
    virtual BYTE* Lock(UINT NeededSize, CD3DDDIDX6* pDDI);
    BYTE* LockDiscard(UINT NeededSize, CD3DDDIDX6* pDDI);
    virtual void Unlock();
    virtual void AddVertices(UINT NumVertices)
        {
            m_dwUsedSize = m_dwPrimitiveBase + NumVertices * m_dwStride;
            DXGASSERT(m_dwSize >= m_dwUsedSize);
        }
    virtual void SubVertices(UINT NumVertices)
        {
            DXGASSERT(m_dwUsedSize >= NumVertices * m_dwStride);
            m_dwUsedSize -= NumVertices * m_dwStride;
            DXGASSERT(m_dwSize >= m_dwUsedSize);
        }
    virtual void MovePrimitiveBase(int NumVertices)
        {
            m_dwPrimitiveBase += NumVertices * m_dwStride;
        }
    virtual void SkipVertices(DWORD NumVertices)
        {
            const UINT size = NumVertices * m_dwStride;
            m_dwPrimitiveBase += size;
            m_dwUsedSize = m_dwPrimitiveBase;
            DXGASSERT(m_dwSize >= m_dwUsedSize);
        }
protected:
    // Number of bytes used in the buffer
    // It is not used by CTLStreamRO
    DWORD   m_dwUsedSize;
    // Index of a index, which is the start of the current primitive
    DWORD   m_dwPrimitiveBase;
#if !DBG
    DWORD   m_dwSize;
#endif
};

// This class is used to keep track of what set to a DDI stream
struct CDDIStream
{
    CDDIStream()
        {
            m_pStream = NULL;
            m_dwStride = 0;
            m_pBuf = NULL;
        }
    // Pointer to a stream object
    CVStreamBase*   m_pStream;
    // Stride of the currently set stream
    DWORD       m_dwStride;
    // VB pointer of the currently set stream
    CBuffer    *m_pBuf;
};

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CD3DDDIDX6                                                              //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------
// Flags for dwDP2Flags
//
// This flag is set if the current TLVbuf is write only
const DWORD D3DDDI_TLVBUFWRITEONLY      = 1 << 0;
// This flag is set we pass user memory to the DDI
const DWORD D3DDDI_USERMEMVERTICES      = 1 << 1;

// Set when DrawIndexPrim is called. It is used to check if vertices
// of an indexed primitive were used at all. They could not be used because
// of clipping.
const DWORD D3DDDI_INDEXEDPRIMDRAWN     = 1 << 2;

typedef void (CD3DDDIDX6::* PFN_PROCESSPRIM)(D3DFE_PROCESSVERTICES*,
                                             UINT StartVertex);
class CD3DDDIDX6 : public CD3DDDI
{
public:
    CD3DDDIDX6();
    ~CD3DDDIDX6();

    // Virtual functions -----------------------------------------------
    virtual void Init(CD3DBase* pDevice );
    virtual void SetRenderTarget(CBaseSurface*, CBaseSurface*);
    virtual void FlushStates(BOOL bReturnDriverError=FALSE, BOOL bWithinPrimitive = FALSE);
    virtual void ValidateDevice(LPDWORD lpdwNumPasses);
    virtual void Clear(DWORD dwFlags, DWORD clrCount, LPD3DRECT clrRects,
                       D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil);
    virtual HRESULT __declspec(nothrow) LockVB(CDriverVertexBuffer*, DWORD dwFlags);
    virtual HRESULT __declspec(nothrow) UnlockVB(CDriverVertexBuffer*);
    virtual void ClearBatch( BOOL bWithinPrimitive );
    virtual void SceneCapture(BOOL bState);
    // This function is called whe software vertex processing is used
    // Handle should be always legacy
    virtual void SetVertexShader(DWORD dwHandle);
    // This function is called whe hardware vertex processing is used
    virtual void SetVertexShaderHW(DWORD dwHandle);

    virtual void UpdatePalette(DWORD,DWORD,DWORD,PALETTEENTRY*);
    virtual void SetPalette(DWORD,DWORD,CBaseTexture*);
    // Used to pick a function to process (indexed) primitive
    // The picking is based on
    //      D3DDEV_DONOTCLIP
    //      FVF_TRANSFORMED(m_pDevice->m_dwCurrentShaderHandle)
    //      D3DDEV_DOPOINTSPRITEEMULATION
    virtual void PickProcessPrimitive();
    virtual void SetTSS(DWORD, D3DTEXTURESTAGESTATETYPE, DWORD);
    virtual void DrawPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType,
                                 UINT PrimitiveCount);
    virtual void DrawIndexedPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType,
                                        UINT MinVertexIndex,
                                        UINT NumVertices,
                                        UINT PrimitiveCount);
    // Returns max number of renderstates, handled by the DDI
    virtual D3DRENDERSTATETYPE GetMaxRenderState()
    {return D3DRENDERSTATE_CLIPPING;}
    // Returns max number of texture stage states, handled by the DDI
    virtual D3DTEXTURESTAGESTATETYPE GetMaxTSS()
    {return D3DTSS_TEXTURETRANSFORMFLAGS;}
    // Returns TRUE if the device supports T&L
    virtual BOOL CanDoTL() {return FALSE;}
    // DDI can directly accept index buffer
    virtual BOOL AcceptIndexBuffer() {return FALSE;}
    virtual BOOL CanDoTLVertexClipping() {return FALSE;}
    // Process primitive with untransformed vertices and with no clipping
    virtual void ProcessPrimitive(D3DFE_PROCESSVERTICES* pv, UINT StartVertex);
    virtual void ProcessIndexedPrimitive(D3DFE_PROCESSVERTICES* pv,
                                         UINT StartVertex);
    // Process primitive with untransformed vertices and with clipping
    virtual void ProcessPrimitiveC(D3DFE_PROCESSVERTICES* pv,
                                   UINT StartVertex);
    virtual void ProcessIndexedPrimitiveC(D3DFE_PROCESSVERTICES* pv,
                                          UINT StartVertex);
    virtual void SetViewport(CONST D3DVIEWPORT8*);
    virtual void StartPrimVB(D3DFE_PROCESSVERTICES * pv, CVStream* pStream,
                             DWORD dwStartVertex);
    virtual LPVOID StartPrimTL(D3DFE_PROCESSVERTICES*, DWORD dwVertexPoolSize,
                               BOOL bWriteOnly);
    virtual void StartPointSprites();
    virtual void EndPointSprites();

    // Virtual functions: Empty implementations ------------------------
    virtual void SetTransform(D3DTRANSFORMSTATETYPE, CONST D3DMATRIX*){}
    virtual void MultiplyTransform(D3DTRANSFORMSTATETYPE, CONST D3DMATRIX*){}
    virtual void SetMaterial(CONST D3DMATERIAL8*){}
    virtual void CreateLight(DWORD dwLightIndex) {}
    virtual void SetLight(DWORD dwLightIndex, CONST D3DLIGHT8*){}
    virtual void LightEnable(DWORD dwLightIndex, BOOL){}
    virtual void SetClipPlane(DWORD dwPlaneIndex,
                              CONST D3DVALUE* pPlaneEquation){}
    virtual void WriteStateSetToDevice(D3DSTATEBLOCKTYPE sbt) {}
    // Used to notify DDI that a vertex buffer was released. If the DDI keeps a
    // pointer to the VB it should be zeroed
    virtual void VBReleased(CBuffer *pBuf) {}
    // Used to notify DDI that amn index buffer was released. If the DDI keeps
    // a pointer to the IB it should be zeroed
    virtual void VBIReleased(CBuffer *pBuf) {}
    virtual void ResetVertexShader() {}
    virtual void SetVertexShaderConstant(DWORD dwRegisterAddress,
                                         CONST VOID* lpvConstantData,
                                         DWORD dwConstantCount){}
    virtual void SetPixelShaderConstant(DWORD dwRegisterAddress,
                                        CONST VOID* lpvConstantData,
                                        DWORD dwConstantCount){}

    // Virtual functions: Unsupported implementations ------------------
    virtual void SetPriority(CResource*, DWORD dwPriority)
    { NotSupported("SetPriority");}
    virtual void SetTexLOD(CBaseTexture*, DWORD dwLOD)
    { NotSupported("SetTexLOD");}
    virtual void TexBlt(DWORD dwDst, DWORD dwSrc,
                        LPPOINT p, RECTL *r)
    { NotSupported("TexBlt");}
    virtual void VolBlt(CBaseTexture *lpDst, CBaseTexture* lpSrc,
                        DWORD dwDestX, DWORD dwDestY, DWORD dwDestZ,
                        D3DBOX *pBox)
    { NotSupported("VolBlt");}
    virtual void BufBlt(CBuffer *lpDst, CBuffer* lpSrc,
                        DWORD dwOffset, D3DRANGE* pRange)
    { NotSupported("BufBlt");}
    virtual void AddDirtyRect(DWORD dwHandle, 
                              CONST RECTL *pRect)
    { NotSupported("AddDirtyRect");}
    virtual void AddDirtyBox(DWORD dwHandle, 
                             CONST D3DBOX *pBox)
    { NotSupported("AddDirtyRect");}
    virtual void InsertStateSetOp(DWORD dwOperation, DWORD dwParam,
                                  D3DSTATEBLOCKTYPE sbt)
    { NotSupported("InsertStateSetOp");}
    virtual void CreateVertexShader(CONST DWORD* pdwDeclaration,
                                    DWORD dwDeclarationSize,
                                    CONST DWORD* pdwFunction,
                                    DWORD dwFunctionSize,
                                    DWORD dwHandle,
                                    BOOL bLegacyFVF)
    { NotSupported("CreateVertexShader");}
    virtual void DeleteVertexShader(DWORD dwHandle)
    { NotSupported("DeleteVertexShader");}
    virtual void CreatePixelShader(CONST DWORD* pdwFunction,
                                   DWORD dwFunctionSize,
                                   DWORD dwHandle)
    { NotSupported("CreatePixelShader");}
    virtual void SetPixelShader(DWORD dwHandle) {}
    virtual void DeletePixelShader(DWORD dwHandle)
    { NotSupported("DeletePixelShader");}
    virtual void GetInfo(DWORD dwDevInfoID, LPVOID pDevInfoStruct,
                         DWORD dwSize)
    { NotSupported("GetInfo");}
    virtual void DrawRectPatch(UINT Handle, CONST D3DRECTPATCH_INFO *pSurf,
                               CONST FLOAT *pNumSegs)
    { NotSupported("DrawRectPatch");}
    virtual void DrawTriPatch(UINT Handle, CONST D3DTRIPATCH_INFO *pSurf,
                              CONST FLOAT *pNumSegs)
    { NotSupported("DrawTriPatch");}

    // Non Virtual functions -------------------------------------------
    void CreateContext();
    void DestroyContext();
    void SetRenderState(D3DRENDERSTATETYPE, DWORD);
    void FlushStatesReq(DWORD dwReqSize);
    void FlushStatesCmdBufReq(DWORD dwReqSize);
    void SetStreamSource(UINT StreamIndex, CVStream*);
    void SetIndices(CVIndexStream*);
    // Update W range in device. Projection matrix is passed as parameter
    void UpdateWInfo(CONST D3DMATRIX* lpMat);
    // Process points with point sprite expansion
    void ProcessPointSprites(D3DFE_PROCESSVERTICES* pv, UINT StartVertex);
    // Process primitive with transformed vertices and with clipping
    void ProcessPrimitiveTC(D3DFE_PROCESSVERTICES* pv, UINT StartVertex);
    void ProcessIndexedPrimitiveTC(D3DFE_PROCESSVERTICES* pv,
                                   UINT StartVertex);
    void NotSupported(char* msg);
    void BeginScene()
    {
        SceneCapture(TRUE);
    }

    void EndScene();
    void EndPrim(UINT vertexSize);
    void NextSprite(float x, float y, float z, float w, DWORD diffuse,
                    DWORD specular, float* pTexture, UINT TextureSize,
                    float PointSize);

    void AddVertices(UINT NumVertices)
    {
        if (dwDP2VertexCountMask)
        {
            dwDP2VertexCount = max(dwVertexBase + NumVertices, dwDP2VertexCount);
        }
    }
    void SubVertices(UINT NumVertices)
    {
        if (dwDP2VertexCountMask)
        {
            DXGASSERT(dwDP2VertexCount >= NumVertices);
            dwDP2VertexCount -= NumVertices;
        }
    }
    void MovePrimitiveBase(int NumVertices)
    {
        dwVertexBase += NumVertices;
    }
    void SkipVertices(DWORD NumVertices)
    {
        dwVertexBase += NumVertices;
        if (dwDP2VertexCountMask)
            dwDP2VertexCount = max(dwVertexBase, dwDP2VertexCount);
    }
    void SetWithinPrimitive( BOOL bWP ){ m_bWithinPrimitive = bWP; }
    BOOL GetWithinPrimitive(){ return m_bWithinPrimitive; }
    D3DDDITYPE GetDDIType() {return m_ddiType;}
    CD3DBase* GetDevice() {return m_pDevice;}
    ULONG_PTR GetDeviceContext() {return m_dwhContext;}
    virtual PFN_DRAWPRIMFAST __declspec(nothrow) GetDrawPrimFunction()
    {
        return CD3DDDIDX6_DrawPrimitive;
    }
    virtual PFN_DRAWINDEXEDPRIMFAST __declspec(nothrow) GetDrawIndexedPrimFunction()
    {
        return CD3DDDIDX6_DrawIndexedPrimitive;
    }

    // Implementation of base functions ---------------------------------
    // Draw non-indexed primitive
    void DrawPrim(D3DFE_PROCESSVERTICES* pv);
    // Draw point sprites with emulation
    void DrawPrimPS(D3DFE_PROCESSVERTICES* pv);
    // Draw primitive, generated by the clipper
    void DrawClippedPrim(D3DFE_PROCESSVERTICES* pv);
    // Draw indexed primitive
    void DrawIndexPrim(D3DFE_PROCESSVERTICES* pv);

protected:
    // DDI Type
    D3DDDITYPE       m_ddiType;
    CD3DBase*        m_pDevice;
    DWORD            m_dwInterfaceNumber;
    // Driver context
    ULONG_PTR        m_dwhContext;
    // Is it within primitive
    BOOL m_bWithinPrimitive;

    PFN_PROCESSPRIM m_pfnProcessPrimitive;
    PFN_PROCESSPRIM m_pfnProcessIndexedPrimitive;

    // Reserve space in the command buffer. Flush and grow if needed.
    // Returns pointer to where new commands could be inserted
    LPVOID ReserveSpaceInCommandBuffer(UINT ByteCount);
    // Reserve space for a new command in the command buffer. Flush if needed
    // New command is initialized.
    // Returns pointer to where the command data could be inserted
    LPVOID GetHalBufferPointer(D3DHAL_DP2OPERATION op, DWORD dwDataSize);
    DWORD  GetTLVbufSize() { return TLVbuf_size - TLVbuf_base; }
    DWORD& TLVbuf_Base() { return TLVbuf_base; }
    LPVOID TLVbuf_GetAddress() {return (LPBYTE)alignedBuf + TLVbuf_base;}
    void GrowCommandBuffer(DWORD dwSize);
    void GrowTLVbuf(DWORD growSize, BOOL bWriteOnly);
    void PrepareForClipping(D3DFE_PROCESSVERTICES* pv, UINT StartVertex);
    void StartPrimUserMem(D3DFE_PROCESSVERTICES*, UINT VertexPoolSize);
    inline CVertexBuffer* TLVbuf_GetVBI() { return allocatedBuf; }

#if DBG
    void    ValidateVertex(LPDWORD lpdwVertex);
    virtual void    ValidateCommand(LPD3DHAL_DP2COMMAND lpCmd);
#endif

    static const DWORD dwD3DDefaultCommandBatchSize;

    // Index (relative to the TLVbuf start) of the first vertex of
    // the current primitive
    DWORD   dwVertexBase;
    // Number of vertices in the DP2 vertex buffer
    DWORD dwDP2VertexCount;
    // Mask used to prevent modification of dwDP2VertexCount. This is needed
    // when user calls SetStreamSource with TL vertices and uses multiple
    // DrawPrimitive calls with different StartVertex. dwDP2VertexCount should
    // be always set to the number of vertices in the user vertex buffer.
    DWORD dwDP2VertexCountMask;

    // This is the VB interface corresponding to the dp2data.lpDDVertex
    // This is kept so that the VB can be released when done
    // which cannot be done from just the LCL pointer which is lpDDVertex
    CVertexBuffer* lpDP2CurrBatchVBI;

    DWORD TLVbuf_size;
    DWORD TLVbuf_base;

#ifdef VTABLE_HACK
    // Cached dwFlags for fast path
    DWORD dwLastFlags;
    // Last VB used in a call that involved D3D's FE.
    CVertexBuffer* lpDP2LastVBI;
#endif
    DWORD dwDP2CommandBufSize;
    DWORD dwDP2CommandLength;

    // Cache line should start here

    // Pointer to the actual data in CB1
    LPVOID lpvDP2Commands;

    //Pointer to the current position the CB1 buffer
    LPD3DHAL_DP2COMMAND lpDP2CurrCommand;
    // Perf issue: replace the below 3 fields by a 32 bit D3DHAL_DP2COMMAND struct
    WORD wDP2CurrCmdCnt; // Mirror of Count field if the current command
    BYTE bDP2CurrCmdOP;  // Mirror of Opcode of the current command
    BYTE bDummy;         // Force DWORD alignment of next member

    D3D8_DRAWPRIMITIVES2DATA dp2data;

    // The buffer we currently batch into
    CCommandBuffer *lpDDSCB1;
    CVertexBuffer  *allocatedBuf;
    LPVOID alignedBuf;
    CVertexBuffer  *m_pNullVB;

    // Count read/write <-> write-only transistions
    DWORD dwTLVbufChanges;
    // Flags specific to DP2 device
    DWORD dwDP2Flags;

    // This stuff is allocated by the NT Kernel. Need to keep
    // it around to pass it to all the DP2 calls. Kernel validates
    // this pointer.
    WORD *lpwDPBuffer;
    // Used to offset indices in DrawIndexPrim
    DWORD m_dwIndexOffset;

    // Data to draw point sprites

    // Pointer where to insert the next point sprite vertex
    BYTE*   m_pCurSpriteVertex;
    // Pointer where to insert the next point sprite index
    WORD*   m_pCurPointSpriteIndex;
    // Number of sprites in the current point sprite batch
    UINT    m_CurNumberOfSprites;
    // When we need to expand points to quads, we use this stream to process
    // vertices into
    CTLStream*  m_pPointStream;

    // These is used to keep the original dwVertexBase and dwDP2VertexCount,
    // when processing point sprites
    DWORD   m_dwVertexBasePS;
    DWORD   m_dwVertexCountPS;
    // Output vertex FVF for point sprite emulation
    DWORD   m_dwVIDOutPS;
    // Output vertex size for point sprites emulation
    DWORD   m_dwOutputSizePS;

    DWORD dwDPBufferSize;
    // Vertex shader handle currently set to the device driver
    DWORD   m_CurrentVertexShader;
    // Currently used stream 0
    CVStream* m_pStream0;
    // Currently used index stream
    CVIndexStream* m_pIStream;

#if DBG
    // Vertex size, computed from the vertex shader
    DWORD   m_VertexSizeFromShader;
    // Switches on/off command and vertices validation
    BOOL  m_bValidateCommands;
#endif
    friend class CD3DHal;
    friend void CD3DDDIDX6_DrawPrimitive(CD3DBase* pDevice,
                               D3DPRIMITIVETYPE primType,
                               UINT StartVertex,
                               UINT PrimitiveCount);
    friend void CD3DDDIDX6_DrawPrimitiveFast(CD3DBase* pDevice,
                               D3DPRIMITIVETYPE primType,
                               UINT StartVertex,
                               UINT PrimitiveCount);
    friend void CD3DDDIDX6_DrawIndexedPrimitive(CD3DBase* pDevice,
                                         D3DPRIMITIVETYPE PrimitiveType,
                                         UINT BaseVertexIndex,
                                         UINT MinIndex, UINT NumVertices,
                                         UINT StartIndex, UINT PrimitiveCount);
    friend void CD3DDDIDX6_DrawIndexedPrimitiveFast(CD3DBase* pDevice,
                                     D3DPRIMITIVETYPE primType,
                                     UINT BaseVertexIndex,
                                     UINT MinIndex, UINT NumVertices,
                                     UINT StartIndex, UINT PrimitiveCount);
    friend void CD3DHal_DrawPrimitive(CD3DBase* pBaseDevice,
                                      D3DPRIMITIVETYPE PrimitiveType,
                                      UINT StartVertex, UINT PrimitiveCount);
    friend void CD3DHal_DrawIndexedPrimitive(CD3DBase* pBaseDevice,
                                  D3DPRIMITIVETYPE PrimitiveType,
                                  UINT BaseIndex,
                                  UINT MinIndex, UINT NumVertices,
                                  UINT StartIndex,
                                  UINT PrimitiveCount);
};

typedef CD3DDDIDX6 *LPD3DDDIDX6;

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CD3DDDIDX7                                                              //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////
class CD3DDDIDX7 : public CD3DDDIDX6
{
public:
    CD3DDDIDX7();
    ~CD3DDDIDX7();
    void SetRenderTarget(CBaseSurface*, CBaseSurface*);
    void InsertStateSetOp(DWORD dwOperation, DWORD dwParam,
                          D3DSTATEBLOCKTYPE sbt);
    void Clear(DWORD dwFlags, DWORD clrCount, LPD3DRECT clrRects,
               D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil);
    void TexBlt(DWORD dwDst, DWORD dwSrc, LPPOINT p, RECTL *r);
    void SetPriority(CResource*, DWORD dwPriority);
    void SetTexLOD(CBaseTexture*, DWORD dwLOD);
    void AddDirtyRect(DWORD dwHandle, CONST RECTL *pRect);
    void AddDirtyBox(DWORD dwHandle, CONST D3DBOX *pBox);
    void UpdatePalette(DWORD,DWORD,DWORD,PALETTEENTRY*);
    void SetPalette(DWORD,DWORD,CBaseTexture*);
    void WriteStateSetToDevice(D3DSTATEBLOCKTYPE sbt);
    virtual void SceneCapture(BOOL bState);
    virtual D3DTEXTURESTAGESTATETYPE GetMaxTSS()
        {return (D3DTEXTURESTAGESTATETYPE)(D3DTSS_TEXTURETRANSFORMFLAGS+1);}
};

typedef CD3DDDIDX7 *LPD3DDDIDX7;

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CD3DDDITL                                                               //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

class CD3DDDITL : public CD3DDDIDX7
{
public:
    CD3DDDITL();
    ~CD3DDDITL();
    void SetTransform(D3DTRANSFORMSTATETYPE, CONST D3DMATRIX*);
    void SetVertexShader(DWORD dwHandle);
    void SetVertexShaderHW(DWORD dwHandle);
    void SetViewport(CONST D3DVIEWPORT8*);
    void SetMaterial(CONST D3DMATERIAL8*);
    void SetLight(DWORD dwLightIndex, CONST D3DLIGHT8*);
    void LightEnable(DWORD dwLightIndex, BOOL);
    void CreateLight(DWORD dwLightIndex);
    void SetClipPlane(DWORD dwPlaneIndex, CONST D3DVALUE* pPlaneEquation);
    D3DRENDERSTATETYPE GetMaxRenderState()
        {return (D3DRENDERSTATETYPE)(D3DRENDERSTATE_CLIPPLANEENABLE + 1);}
    BOOL CanDoTL() {return TRUE;}
    BOOL CanDoTLVertexClipping() {return TRUE;}
    void CreateVertexShader(CONST DWORD* pdwDeclaration,
                            DWORD dwDeclarationSize,
                            CONST DWORD* pdwFunction,
                            DWORD dwFunctionSize,
                            DWORD dwHandle,
                            BOOL bLegacyFVF);
};

typedef CD3DDDITL *LPD3DDDITL;

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CD3DDDIDX8                                                              //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

class CD3DDDIDX8 : public CD3DDDIDX7
{
public:
    CD3DDDIDX8();
    ~CD3DDDIDX8();
    void Init(CD3DBase* pDevice );
    void SetDummyData();
    void FlushStates(BOOL bReturnDriverError=FALSE, BOOL bWithinPrimitive = FALSE);
    void ClearBatch( BOOL bWithinPrimitive );
    HRESULT __declspec(nothrow) LockVB(CDriverVertexBuffer*, DWORD dwFlags);
    HRESULT __declspec(nothrow) UnlockVB(CDriverVertexBuffer*);
    D3DRENDERSTATETYPE GetMaxRenderState();
    D3DTEXTURESTAGESTATETYPE GetMaxTSS()
        {return (D3DTEXTURESTAGESTATETYPE)(D3DTSS_RESULTARG+1);}
    void SetTSS(DWORD, D3DTEXTURESTAGESTATETYPE, DWORD);
    void SetVertexShader(DWORD dwHandle);
    void SetVertexShaderHW(DWORD dwHandle);
    void ValidateDevice(LPDWORD lpdwNumPasses);
    void VolBlt(CBaseTexture *lpDst, CBaseTexture* lpSrc, DWORD dwDestX,
                DWORD dwDestY, DWORD dwDestZ, D3DBOX *pBox);
    void BufBlt(CBuffer *lpDst, CBuffer* lpSrc, DWORD dwOffset,
                D3DRANGE* pRange);
    void CreatePixelShader(CONST DWORD* pdwFunction,
                            DWORD dwFunctionSize,
                            DWORD dwHandle);
    void SetPixelShader(DWORD dwHandle);
    void DeletePixelShader(DWORD dwHandle);
    void SetPixelShaderConstant(DWORD dwRegisterAddress,
                                CONST VOID* lpvConstantData,
                                DWORD dwConstantCount);
    void DrawPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType, UINT PrimitiveCount);
    void DrawIndexedPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType,
                                UINT MinVertexIndex,
                                UINT NumVertices,
                                UINT PrimitiveCount);
    BOOL AcceptIndexBuffer() {return TRUE;}
    BOOL CanDoTLVertexClipping() {return TRUE;}
    void DrawRectPatch(UINT Handle, CONST D3DRECTPATCH_INFO *pSurf,
                       CONST FLOAT *pNumSegs);
    void DrawTriPatch(UINT Handle, CONST D3DTRIPATCH_INFO *pSurf,
                      CONST FLOAT *pNumSegs);

    void PickProcessPrimitive();
    // Process primitive with untransformed vertices and with no clipping
    void ProcessPrimitive(D3DFE_PROCESSVERTICES* pv, UINT StartVertex);
    void ProcessIndexedPrimitive(D3DFE_PROCESSVERTICES* pv, UINT StartVertex);
    // Process primitive with untransformed vertices and with clipping
    void ProcessPrimitiveC(D3DFE_PROCESSVERTICES* pv, UINT StartVertex);
    void ProcessIndexedPrimitiveC(D3DFE_PROCESSVERTICES* pv, UINT StartVertex);
    // Process primitive with transformed vertices
    void ProcessPrimitiveT(D3DFE_PROCESSVERTICES* pv, UINT StartVertex);
    void ProcessIndexedPrimitiveT(D3DFE_PROCESSVERTICES* pv, UINT StartVertex);

    void StartPrimVB(D3DFE_PROCESSVERTICES * pv, CVStream* pStream,
                     DWORD dwStartVertex);
    LPVOID StartPrimTL(D3DFE_PROCESSVERTICES*, DWORD dwVertexPoolSize,
                       BOOL bWriteOnly);
    void DrawPrim(D3DFE_PROCESSVERTICES* pv);
    void DrawIndexPrim(D3DFE_PROCESSVERTICES* pv);
    void DrawClippedPrim(D3DFE_PROCESSVERTICES* pv);
    void VBReleased(CBuffer *pBuf)
        {
            if (m_pDDIStream[0].m_pBuf == pBuf)
                m_pDDIStream[0].m_pBuf = NULL;
        }
    void VBIReleased(CBuffer *pBuf)
        {
            if (m_pDDIStream[__NUMSTREAMS].m_pBuf == pBuf)
                m_pDDIStream[__NUMSTREAMS].m_pBuf = NULL;
        }
    void AddVertices(UINT NumVertices)
        {
            m_pCurrentTLStream->AddVertices(NumVertices);
        }
    void MovePrimitiveBase(int NumVertices)
        {
            m_pCurrentTLStream->MovePrimitiveBase(NumVertices);
        }
    void SkipVertices(DWORD NumVertices)
        {
            m_pCurrentTLStream->SkipVertices(NumVertices);
        }
    // Returns offset in bytes of the start vertex of the current primitive in
    // the current TL stream
    DWORD GetCurrentPrimBase()
        {
            return m_pCurrentTLStream->GetPrimitiveBase();
        }

    void ResetVertexShader()
    {
        m_CurrentVertexShader = 0;
#if DBG
        m_VertexSizeFromShader = 0;
#endif
    }

    PFN_DRAWPRIMFAST __declspec(nothrow) GetDrawPrimFunction() {return CD3DDDIDX8_DrawPrimitive;}
    PFN_DRAWINDEXEDPRIMFAST __declspec(nothrow) GetDrawIndexedPrimFunction()
    {
        return CD3DDDIDX8_DrawIndexedPrimitive;
    }

protected:
    void StartPointSprites();
    void EndPointSprites();

    void StartIndexPrimVB(CVIndexStream* pStream, UINT StartIndex, UINT IndexSize);
    void UpdateDirtyStreams();
    void InsertStreamSource(CVStream*);
    void InsertStreamSourceUP(DWORD);
    void InsertIndices(CVIndexStream*);
#if DBG
    void ValidateCommand(LPD3DHAL_DP2COMMAND lpCmd);
#endif

    // This array is used to keep track of what stream is set to a DDI stream.
    // __NUMSTREAMS element is used for the indexed DDI stream
    CDDIStream  m_pDDIStream[__NUMSTREAMS+1];
    // Stream for TL vertices, which are the result of the front-end pipeline
    CTLStream*  m_pTLStream;
    // Stream for TL vertices, which are the result of the front-end pipeline
    // This is write-only stream
    CTLStream*  m_pTLStreamW;
    // Stream for TL vertices, generated by the clipper. Write-only stream
    CTLStream*  m_pTLStreamClip;
    // Read-only stream. Used with user provided VBs
    CTLStreamRO*  m_pTLStreamRO;
    // Points to the current TL stream. This could be NULL.
    CTLStream*  m_pCurrentTLStream;
    // Points to the current index stream. This could be NULL.
    CTLIndexStream*  m_pCurrentIndexStream;
    // Internal index stream. Used to store indices during clipping
    CTLIndexStream*  m_pIndexStream;
    // Read-only index stream. Used with user provided VBs
    CTLIndexStreamRO*  m_pTLIndexStreamRO;

    // This is a dummy buffer allocated for DP2 call to pass through
    // the kernel.
    VOID*  m_pvDummyArray;
    static const DWORD  m_dwDummyVertexLength;
    static const DWORD  m_dwDummyVertexSize;

    friend void CD3DDDIDX8_DrawPrimitive(CD3DBase* pDevice,
                                         D3DPRIMITIVETYPE PrimitiveType,
                                         UINT StartVertex, UINT PrimitiveCount);
    friend void CD3DDDIDX8_DrawIndexedPrimitive(CD3DBase* pDevice,
                                    D3DPRIMITIVETYPE PrimitiveType,
                                    UINT BaseVertexIndex,
                                    UINT MinIndex, UINT NumVertices,
                                    UINT StartIndex, UINT PrimitiveCount);
};

typedef CD3DDDIDX8 *LPD3DDDIDX8;

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CD3DDDIDX8TL                                                            //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

class CD3DDDIDX8TL : public CD3DDDIDX8
{
public:
    CD3DDDIDX8TL();
    ~CD3DDDIDX8TL();
    void SetTransform(D3DTRANSFORMSTATETYPE, CONST D3DMATRIX*);
    void MultiplyTransform(D3DTRANSFORMSTATETYPE, CONST D3DMATRIX*);
    void SetViewport(CONST D3DVIEWPORT8*);
    void SetMaterial(CONST D3DMATERIAL8*);
    void SetLight(DWORD dwLightIndex, CONST D3DLIGHT8*);
    void LightEnable(DWORD dwLightIndex, BOOL);
    void CreateLight(DWORD dwLightIndex);
    void SetClipPlane(DWORD dwPlaneIndex, CONST D3DVALUE* pPlaneEquation);

    void CreateVertexShader(CONST DWORD* pdwDeclaration,
                            DWORD dwDeclarationSize,
                            CONST DWORD* pdwFunction,
                            DWORD dwFunctionSize,
                            DWORD dwHandle,
                            BOOL bLegacyFVF);
    void DeleteVertexShader(DWORD dwHandle);
    void SetVertexShaderConstant(DWORD dwRegisterAddress,
                                 CONST VOID* lpvConstantData,
                                 DWORD dwConstantCount);
    BOOL CanDoTL() {return TRUE;}
    BOOL AcceptIndexBuffer() {return TRUE;}
};

typedef CD3DDDIDX8TL *LPD3DDDIDX8TL;

#endif /* _D3DI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\inc\pipeln.h ===
#ifndef __PIPELN_H_
#define __PIPELN_H_
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       pipeln.h
 *  Content:    Common definitions between Microsoft PSGP and the front-end
 *
 ***************************************************************************/

//-----------------------------------------------------------------------------
// Prototype of a function to copy data from input vertex stream to an input
// register
typedef void (*PFN_D3DCOPYELEMENT)(LPVOID pInputStream,
                                   UINT InputStreamStride,
                                   UINT count,
                                   VVM_WORD * pVertexRegister);
//---------------------------------------------------------------------
inline void ComputeOutputVertexOffsets(LPD3DFE_PROCESSVERTICES pv)
{
    DWORD i = 4*sizeof(D3DVALUE);
    pv->pointSizeOffsetOut = i;
    if (pv->dwVIDOut & D3DFVF_PSIZE)
        i += sizeof(DWORD);
    pv->diffuseOffsetOut = i;
    if (pv->dwVIDOut & D3DFVF_DIFFUSE)
        i += sizeof(DWORD);
    pv->specularOffsetOut = i;
    if (pv->dwVIDOut & D3DFVF_SPECULAR)
        i += sizeof(DWORD);
    pv->fogOffsetOut = i;
    if (pv->dwVIDOut & D3DFVF_FOG)
        i += sizeof(DWORD);
    pv->texOffsetOut = i;
}
//----------------------------------------------------------------------
inline DWORD MakeTexTransformFuncIndex(DWORD dwNumInpTexCoord, DWORD dwNumOutTexCoord)
{
    DDASSERT(dwNumInpTexCoord <= 4 && dwNumOutTexCoord <= 4);
    return (dwNumInpTexCoord - 1) + ((dwNumOutTexCoord - 1) << 2);
}
//----------------------------------------------------------------------
// Returns TRUE if the token is instruction token, FALSE if the token is
// an operand token
inline BOOL IsInstructionToken(DWORD token)
{
    return (token & 0x80000000) == 0;
}

#endif // __PIPELN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\inc\pshader.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   pshader.hpp
 *  Content:    Direct3D pixel shader internal include file
 *
 *
 ***************************************************************************/
#ifndef _PSHADER_HPP
#define _PSHADER_HPP

#include "d3dfe.hpp"
#include "hmgr.hpp"

struct PVM_WORD
{
    union
    {
        struct
        {
            D3DVALUE x, y, z, w;
        };
        D3DVALUE v[4];
    };
};

struct CONST_DEF
{
    float   f[4];
    UINT    RegNum;
};

//-----------------------------------------------------------------------------
//
// CPShader: Pixel Shader Class
//
//-----------------------------------------------------------------------------
class CPShader : public CD3DBaseObj
{
public:
    DWORD*      m_pCode;
    UINT        m_dwCodeSize;
    DWORD*      m_pCodeOrig;
    UINT        m_dwCodeSizeOrig;
    DWORD       m_dwNumConstDefs;
    CONST_DEF*  m_pConstDefs;
    
    CPShader(void)
    {
        m_pCodeOrig = NULL;
        m_dwCodeSizeOrig = 0x0;
        m_pCode = m_pCodeOrig;
        m_dwCodeSize = m_dwCodeSizeOrig;
        m_dwNumConstDefs = 0;
        m_pConstDefs = NULL;
    }
    ~CPShader()
    {
        if (NULL != m_pCode) delete[] m_pCode;
        if (NULL != m_pCodeOrig) delete[] m_pCodeOrig;
        if (NULL != m_pConstDefs) delete[] m_pConstDefs;
    }
    HRESULT Initialize(CONST DWORD* pCode, D3DDEVTYPE DevType);
};
typedef CPShader *LPPSHADER;

#endif _PSHADER_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\inc\osthunk.h ===
// Note the following struct should match the declaration in 
// the definition of the kernel mode struct defined in ntgdistr.h
// For D3D context creation information.
typedef struct _D3DNTHAL_CONTEXTCREATEI
{
    // Space for a D3DNTHAL_CONTEXTCREATE record.
    // The structure isn't directly declared here to
    // avoid header inclusion problems.  This field
    // is asserted to be the same size as the actual type.
    ULONG ulContextCreate[6];

    // Private buffer information.
    PVOID pvBuffer;
    ULONG cjBuffer;
} D3DNTHAL_CONTEXTCREATEI;


DWORD APIENTRY OsThunkDdAddAttachedSurface(
    IN     HANDLE hSurface,
    IN     HANDLE hSurfaceAttached,
    IN OUT PDD_ADDATTACHEDSURFACEDATA puAddAttachedSurfaceData);

BOOL APIENTRY OsThunkDdAttachSurface(
    IN     HANDLE hSurfaceFrom,
    IN     HANDLE hSurfaceTo);

DWORD APIENTRY OsThunkDdBlt(
    IN     HANDLE hSurfaceDest,
    IN     HANDLE hSurfaceSrc,
    IN OUT PDD_BLTDATA puBltData);

DWORD APIENTRY OsThunkDdCanCreateSurface(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_CANCREATESURFACEDATA puCanCreateSurfaceData);

DWORD APIENTRY OsThunkDdColorControl(
    IN     HANDLE hSurface,
    IN OUT PDD_COLORCONTROLDATA puColorControlData);

HANDLE APIENTRY OsThunkDdCreateDirectDrawObject(
    IN     HDC hdc);

DWORD  APIENTRY OsThunkDdCreateSurface(
    IN     HANDLE  hDirectDraw,
    IN     HANDLE* hSurface,
    IN OUT DDSURFACEDESC* puSurfaceDescription,
    IN OUT DD_SURFACE_GLOBAL* puSurfaceGlobalData,
    IN OUT DD_SURFACE_LOCAL* puSurfaceLocalData,
    IN OUT DD_SURFACE_MORE* puSurfaceMoreData,
    IN OUT DD_CREATESURFACEDATA* puCreateSurfaceData,
       OUT HANDLE* puhSurface);

HANDLE APIENTRY OsThunkDdCreateSurfaceObject(
    IN     HANDLE hDirectDrawLocal,
    IN     HANDLE hSurface,
    IN     PDD_SURFACE_LOCAL puSurfaceLocal,
    IN     PDD_SURFACE_MORE puSurfaceMore,
    IN     PDD_SURFACE_GLOBAL puSurfaceGlobal,
    IN     BOOL bComplete);

BOOL APIENTRY OsThunkDdDeleteSurfaceObject(
    IN     HANDLE hSurface);

BOOL APIENTRY OsThunkDdDeleteDirectDrawObject(
    IN     HANDLE hDirectDrawLocal);

DWORD APIENTRY OsThunkDdDestroySurface(
    IN     HANDLE hSurface,
    IN     BOOL bRealDestroy);

DWORD APIENTRY OsThunkDdFlip(
    IN     HANDLE hSurfaceCurrent,
    IN     HANDLE hSurfaceTarget,
    IN     HANDLE hSurfaceCurrentLeft,
    IN     HANDLE hSurfaceTargetLeft,
    IN OUT PDD_FLIPDATA puFlipData);

DWORD APIENTRY OsThunkDdGetAvailDriverMemory(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETAVAILDRIVERMEMORYDATA puGetAvailDriverMemoryData);

DWORD APIENTRY OsThunkDdGetBltStatus(
    IN     HANDLE hSurface,
    IN OUT PDD_GETBLTSTATUSDATA puGetBltStatusData);

HDC APIENTRY OsThunkDdGetDC(
    IN     HANDLE hSurface,
    IN     PALETTEENTRY* puColorTable);

DWORD APIENTRY OsThunkDdGetDriverInfo(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETDRIVERINFODATA puGetDriverInfoData);

DWORD APIENTRY OsThunkDdGetFlipStatus(
    IN     HANDLE hSurface,
    IN OUT PDD_GETFLIPSTATUSDATA puGetFlipStatusData);

DWORD APIENTRY OsThunkDdGetScanLine(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETSCANLINEDATA puGetScanLineData);

DWORD APIENTRY OsThunkDdSetExclusiveMode(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_SETEXCLUSIVEMODEDATA puSetExclusiveModeData);

DWORD APIENTRY OsThunkDdFlipToGDISurface(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_FLIPTOGDISURFACEDATA puFlipToGDISurfaceData);

DWORD APIENTRY OsThunkDdLock(
    IN     HANDLE hSurface,
    IN OUT PDD_LOCKDATA puLockData,
    IN HDC hdcClip);

BOOL APIENTRY OsThunkDdQueryDirectDrawObject(
    IN     HANDLE,
    IN OUT PDD_HALINFO,
    IN OUT DWORD*,
    IN OUT LPD3DNTHAL_CALLBACKS,
    IN OUT LPD3DNTHAL_GLOBALDRIVERDATA,
    IN OUT PDD_D3DBUFCALLBACKS,
    IN OUT LPDDSURFACEDESC,
    IN OUT DWORD*,
    IN OUT VIDEOMEMORY*,
    IN OUT DWORD*,
    IN OUT DWORD*);
 
BOOL APIENTRY OsThunkDdReenableDirectDrawObject(
    IN     HANDLE hDirectDrawLocal,
    IN OUT BOOL* pubNewMode);

BOOL APIENTRY OsThunkDdReleaseDC(
    IN     HANDLE hSurface);

BOOL APIENTRY OsThunkDdResetVisrgn(
    IN     HANDLE hSurface,
    IN HWND hwnd);

DWORD APIENTRY OsThunkDdSetColorKey(
    IN     HANDLE hSurface,
    IN OUT PDD_SETCOLORKEYDATA puSetColorKeyData);

DWORD APIENTRY OsThunkDdSetOverlayPosition(
    IN     HANDLE hSurfaceSource,
    IN     HANDLE hSurfaceDestination,
    IN OUT PDD_SETOVERLAYPOSITIONDATA puSetOverlayPositionData);

VOID  APIENTRY OsThunkDdUnattachSurface(
    IN     HANDLE hSurface,
    IN     HANDLE hSurfaceAttached);

DWORD APIENTRY OsThunkDdUnlock(
    IN     HANDLE hSurface,
    IN OUT PDD_UNLOCKDATA puUnlockData);

DWORD APIENTRY OsThunkDdUpdateOverlay(
    IN     HANDLE hSurfaceDestination,
    IN     HANDLE hSurfaceSource,
    IN OUT PDD_UPDATEOVERLAYDATA puUpdateOverlayData);

DWORD APIENTRY OsThunkDdWaitForVerticalBlank(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_WAITFORVERTICALBLANKDATA puWaitForVerticalBlankData);

HANDLE APIENTRY OsThunkDdGetDxHandle(
    IN     HANDLE hDirectDraw,
    IN     HANDLE hSurface,
    IN     BOOL bRelease);

BOOL APIENTRY OsThunkDdSetGammaRamp(
    IN     HANDLE hDirectDraw,
    IN     HDC hdc,
    IN     LPVOID lpGammaRamp);

DWORD APIENTRY OsThunkDdLockD3D(
    IN     HANDLE hSurface,
    IN OUT PDD_LOCKDATA puLockData);

DWORD APIENTRY OsThunkDdUnlockD3D(
    IN     HANDLE hSurface,
    IN OUT PDD_UNLOCKDATA puUnlockData);

DWORD APIENTRY OsThunkDdCreateD3DBuffer(
    IN     HANDLE hDirectDraw,
    IN OUT HANDLE* hSurface,
    IN OUT DDSURFACEDESC* puSurfaceDescription,
    IN OUT DD_SURFACE_GLOBAL* puSurfaceGlobalData,
    IN OUT DD_SURFACE_LOCAL* puSurfaceLocalData,
    IN OUT DD_SURFACE_MORE* puSurfaceMoreData,
    IN OUT DD_CREATESURFACEDATA* puCreateSurfaceData,
    IN OUT HANDLE* puhSurface);

DWORD APIENTRY OsThunkDdCanCreateD3DBuffer(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_CANCREATESURFACEDATA puCanCreateSurfaceData);

DWORD APIENTRY OsThunkDdDestroyD3DBuffer(
    IN     HANDLE hSurface);

DWORD APIENTRY OsThunkD3dContextCreate(
    IN     HANDLE hDirectDrawLocal,
    IN     HANDLE hSurfColor,
    IN     HANDLE hSurfZ,
    IN OUT D3DNTHAL_CONTEXTCREATEI *pdcci);

DWORD APIENTRY OsThunkD3dContextDestroy(
    IN     LPD3DNTHAL_CONTEXTDESTROYDATA);

DWORD APIENTRY OsThunkD3dContextDestroyAll(
       OUT LPD3DNTHAL_CONTEXTDESTROYALLDATA pdcdad);

DWORD APIENTRY OsThunkD3dValidateTextureStageState(
    IN OUT LPD3DNTHAL_VALIDATETEXTURESTAGESTATEDATA pData);

DWORD APIENTRY OsThunkD3dDrawPrimitives2(
    IN     HANDLE hCmdBuf,
    IN     HANDLE hVBuf,
    IN OUT LPD3DNTHAL_DRAWPRIMITIVES2DATA pded,
    IN OUT FLATPTR* pfpVidMemCmd,
    IN OUT DWORD* pdwSizeCmd,
    IN OUT FLATPTR* pfpVidMemVtx,
    IN OUT DWORD* pdwSizeVtx);

DWORD APIENTRY OsThunkDdGetDriverState(
    IN OUT PDD_GETDRIVERSTATEDATA pdata);

DWORD APIENTRY OsThunkDdCreateSurfaceEx(
    IN     HANDLE hDirectDraw,
    IN     HANDLE hSurface,
    IN     DWORD dwSurfaceHandle);

DWORD APIENTRY OsThunkDdGetMoCompGuids(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETMOCOMPGUIDSDATA puGetMoCompGuidsData);

DWORD APIENTRY OsThunkDdGetMoCompFormats(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETMOCOMPFORMATSDATA puGetMoCompFormatsData);

DWORD APIENTRY OsThunkDdGetMoCompBuffInfo(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETMOCOMPCOMPBUFFDATA puGetBuffData);

DWORD APIENTRY OsThunkDdGetInternalMoCompInfo(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETINTERNALMOCOMPDATA puGetInternalData);

HANDLE APIENTRY OsThunkDdCreateMoComp(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_CREATEMOCOMPDATA puCreateMoCompData);

DWORD APIENTRY OsThunkDdDestroyMoComp(
    IN     HANDLE hMoComp,
    IN OUT PDD_DESTROYMOCOMPDATA puDestroyMoCompData);

DWORD APIENTRY OsThunkDdBeginMoCompFrame(
    IN     HANDLE hMoComp,
    IN OUT PDD_BEGINMOCOMPFRAMEDATA puBeginFrameData);

DWORD APIENTRY OsThunkDdEndMoCompFrame(
    IN     HANDLE hMoComp,
    IN OUT PDD_ENDMOCOMPFRAMEDATA  puEndFrameData);

DWORD APIENTRY OsThunkDdRenderMoComp(
    IN     HANDLE hMoComp,
    IN OUT PDD_RENDERMOCOMPDATA puRenderMoCompData);

DWORD APIENTRY OsThunkDdQueryMoCompStatus(
    IN OUT HANDLE hMoComp,
    IN OUT PDD_QUERYMOCOMPSTATUSDATA puQueryMoCompStatusData);

DWORD APIENTRY OsThunkDdAlphaBlt(
    IN     HANDLE hSurfaceDest,
    IN     HANDLE hSurfaceSrc,
    IN OUT PDD_BLTDATA puBltData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\inc\span.h ===
//----------------------------------------------------------------------------
//
// span.h
//
// Structures which define the interface between the edge walker to the
// span interpolator.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPAN_H_
#define _SPAN_H_

#include <d3ditype.h>
#include <d3dhalp.h>

#ifdef __cplusplus
extern "C" {
#endif

// TBD make this machine independent
// don't leave any space between the elements of these structures
// currently smallest element is a UINT16, may have to change this to pack(1)
// if UINT8's are used.
#include <pshpack2.h>

// Limits, shifts and scaling factors for RASTSPAN and RASTPRIM data.
// C_*_LIMIT is the constant integer form of the limit for cases where
// direct integer comparisons can be done.
#define Z_LIMIT         g_fTwoPow31
#define C_Z_LIMIT       0x4f000000
#define Z16_FRAC_SHIFT  15
#define Z16_FRAC_SCALE  g_fTwoPow15
#define OO_Z16_FRAC_SCALE g_fOoTwoPow15
#define Z16_SHIFT       31
#define Z16_SCALE       g_fNearTwoPow31
#define OO_Z16_SCALE    g_fOoNearTwoPow31
#define Z32_FRAC_SHIFT  0
#define Z32_FRAC_SCALE  g_fOne
#define OO_Z32_FRAC_SCALE g_fOoNearTwoPow31
#define Z32_SHIFT       31
#define Z32_SCALE       g_fNearTwoPow31
#define OO_Z32_SCALE    g_fOoNearTwoPow31

#define TEX_LIMIT       g_fTwoPow31
#define C_TEX_LIMIT     0x4f000000
#define TEX_SHIFT       20
#define TEX_SCALE       g_fTwoPow20
#define OO_TEX_SCALE    g_fOoTwoPow20

#define COLOR_LIMIT     g_fTwoPow15
#define C_COLOR_LIMIT   0x47000000
#define COLOR_SHIFT     8
#define COLOR_SCALE     g_fTwoPow8

#define INDEX_COLOR_LIMIT   g_fTwoPow30
#define C_INDEX_COLOR_LIMIT 0x4e800000
#define INDEX_COLOR_SHIFT   16
#define INDEX_COLOR_SCALE   g_fTwoPow16
#define INDEX_COLOR_VERTEX_SHIFT 8
// Shift to go from fixed-point value in vertex color to proper shift.
#define INDEX_COLOR_FIXED_SHIFT (INDEX_COLOR_SHIFT - INDEX_COLOR_VERTEX_SHIFT)

#define LOD_LIMIT       g_fTwoPow15
#define C_LOD_LIMIT     0x47000000
#define LOD_SHIFT       11
#define LOD_SCALE       g_fTwoPow11
#define LOD_MIN         (-15)

#define OOW_LIMIT       g_fTwoPow31
#define C_OOW_LIMIT     0x4f000000
#define OOW_SHIFT       31
#define OOW_SCALE       g_fNearTwoPow31
#define OO_OOW_SCALE    g_fOoNearTwoPow31
#define W_SHIFT         16
#define W_SCALE         g_fTwoPow16
#define OO_W_SCALE      g_fOoTwoPow16
#define OOW_W_SHIFT     (OOW_SHIFT + W_SHIFT)
#define OOW_W_SCALE     g_fTwoPow47

#define FOG_LIMIT       g_fTwoPow15
#define C_FOG_LIMIT     0x47000000
#define FOG_SHIFT       8
#define FOG_SCALE       g_fTwoPow8
#define FOG_ONE_SCALE   g_fTwoPow16
#define FOG_255_SCALE   g_fTwoPow8

#define TEX_FINAL_SHIFT 16
#define TEX_FINAL_FRAC_MASK (0xffff)
#define TEX_TO_FINAL_SHIFT (TEX_SHIFT - TEX_FINAL_SHIFT)
// Multiply with span W so that [U|V]oW times resulting W is in the
// final shift position.  1 / (W_SHIFT + TEX_TO_FINAL_SHIFT).
#define TEX_UVW_TO_FINAL_SCALE g_fOoTwoPow20
// Divide by span OoW so that [U|V]oW times resulting W is in the
// final shift position.  OOW_SHIFT - TEX_TO_FINAL_SHIFT.
#define TEX_OOW_TO_FINAL_SCALE g_fTwoPow27

#define RAST_DIRTYBITS_SIZE     (((D3D_MAXRENDERSTATES + (D3DHAL_TSS_MAXSTAGES * D3DHAL_TSS_STATESPERSTAGE)) >> 3) + 2)
#define RAST_TSS_DIRTYBIT( _Stage, _State ) \
    ((UINT32)(D3D_MAXRENDERSTATES + \
      ((_Stage) * D3DHAL_TSS_STATESPERSTAGE) + (_State)))

typedef struct _UV_UNION {
    union {
        D3DVALUE    tu;
        D3DVALUE    dvTU;

        INT32 iU;
        FLOAT fU;

        INT32 iUoW;        // 1.11.20 texture coordinates
        FLOAT fUoW;

        INT32 iDUoWDX;         // 1.11.20
        FLOAT fDUoWDX;

        INT32 iDUoWDY; // 1.11.20
        FLOAT fDUoWDY;
    };
    union {
        D3DVALUE    tv;
        D3DVALUE    dvTV;

        INT32 iV;
        FLOAT fV;

        INT32 iVoW;        // 1.11.20 texture coordinates
        FLOAT fVoW;

        INT32 iDVoWDX;         // 1.11.20
        FLOAT fDVoWDX;

        INT32 iDVoWDY; // 1.11.20
        FLOAT fDVoWDY;
    };
}UV_UNION;

// General per span data.  This structure is designed to be qword aligned.
typedef struct tagD3DI_RASTSPAN
{
    // Space separated things are quad words and are intended to be
    // quad word aligned.
    UINT16 uPix;            // count of pixels to render
    INT16 iDFog;            // 1.7.8 delta fog
    UINT16 uX;              // 16.0 start X
    UINT16 uY;              // 16.0 start Y

    INT16 iLOD;             // 1.4.11 start LOD
    INT16 iDLOD;            // 1.4.11 delta LOD (so piecewise linear LOD interp
                            //                  is possible)
    union
    {
        UINT32 uZ;          // 16.15 start Z
        FLOAT fZ;
    };

    // If texture stuff (iOoW, iUoW1, etc.) is 32 bits (even if we iterate
    // them at 16 bits under MMX sometimes)
    union
    {
        INT32 iW;           // 1.15.16 first inverted W of span
        FLOAT fW;
    };
    union
    {
        INT32 iOoW;         // 1.31 start 1/W (signed since they are target
                            //                 of MMX multiply)
        FLOAT fOoW;
    };

    UV_UNION UVoW[D3DHAL_TSS_MAXSTAGES];

    union
    {
        struct
        {
            UINT16 uB, uG, uR, uA;  // 8.8 start colors
        };
        struct
        {
            INT32 iIdx, iIdxA;      // 1.8.16 ramp start color and alpha
        };
    };

    UINT16 uBS, uGS, uRS;  // 8.8 start specular colors
    // Specular alpha is fog.  This prevents specular color from
    // being unioned with the texture 2 coordinates below.
    UINT16 uFog;           // 1.7.8 start fog value


    // Pointers into surface and Z buffers interpolated by the edge walker.
    PUINT8 pSurface;
    PUINT8 pZ;

    UINT8 pPad[16];

} D3DI_RASTSPAN, *PD3DI_RASTSPAN;   // sizeof(D3DI_RASTSPAN) == 64
typedef CONST D3DI_RASTSPAN *PCD3DI_RASTSPAN;

// D3DI_RASTPRIM uFlags
#define D3DI_RASTPRIM_X_DEC     (0x00000001L)   // Else X increments.

// General per primitive for edge walking and span scanning.
// Can be expanded to suit the edge walker.
// The information the span rasterizer needs is sensitive to qwords for
// the MMX rasterizers.
typedef struct tagD3DI_RASTPRIM
{
    UINT32 uFlags;
    UINT16 uSpans;              // count of spans
    UINT16 uResvd1;             // perhaps we want to expand uSpans to 32 bits,
                                // or perhaps 16 flag bits are enough

    // X gradients
    union
    {
        INT32 iDZDX;            // 1.16.15
        FLOAT fDZDX;
    };
    union
    {
        INT32 iDOoWDX;          // 1.31
        FLOAT fDOoWDX;
    };

    UV_UNION DUVoWDX[D3DHAL_TSS_MAXSTAGES];

    union
    {
        struct
        {
            INT16 iDBDX, iDGDX, iDRDX, iDADX;   // 1.7.8
        };
        struct
        {
            FLOAT fDBDX, fDGDX, fDRDX, fDADX;
        };
        struct
        {
            INT32 iDIdxDX, iDIdxADX;            // 1.8.16
        };
    };

    struct
    {
        union
        {
            struct
            {
                INT16 iDBSDX, iDGSDX, iDRSDX; // 1.7.8
            };
            struct
            {
                FLOAT fDBSDX, fDGSDX, fDRSDX;
                FLOAT fPad; // Padding to keep this set of attributes
                            // an even multiple of quadwords.
            };
        };
    };

    // Y gradients for some attributes so that span routines
    // can do per-pixel mipmapping.
    UV_UNION DUVoWDY[D3DHAL_TSS_MAXSTAGES];


    union
    {
        INT32 iDOoWDY;          // 1.31
        FLOAT fDOoWDY;
    };

    struct tagD3DI_RASTPRIM *pNext;

    // Pad to an even multiple of 32 bytes for cache alignment.
    UINT8 uPad[72];

    // Anything else needed

} D3DI_RASTPRIM, *PD3DI_RASTPRIM;
typedef CONST D3DI_RASTPRIM *PCD3DI_RASTPRIM;

// D3DI_SPANTEX uFlags
#define D3DI_SPANTEX_HAS_TRANSPARENT    (0x00000001L)
#define D3DI_SPANTEX_SURFACES_LOCKED    (0x00000002L)
#define D3DI_SPANTEX_MAXMIPLEVELS_DIRTY (0x00000004L)
// Palette with alpha
#define D3DI_SPANTEX_ALPHAPALETTE          (0x00000008L)

//  D3DI_SPANTEX uFormat - NOTE: these enumerations match the sequence in the
//  array of DDPIXELFORMAT structures defined for matching in texture creation
//
//  NOTE: these must be kept consistent with the RRPixelFormats for the reference rasterizer
typedef enum _D3DI_SPANTEX_FORMAT
{
    D3DI_SPTFMT_NULL     = 0,
    D3DI_SPTFMT_B8G8R8   = 1,
    D3DI_SPTFMT_B8G8R8A8 = 2,
    D3DI_SPTFMT_B8G8R8X8 = 3,
    D3DI_SPTFMT_B5G6R5   = 4,
    D3DI_SPTFMT_B5G5R5   = 5,
    D3DI_SPTFMT_PALETTE4 = 6,
    D3DI_SPTFMT_PALETTE8 = 7,
    D3DI_SPTFMT_B5G5R5A1 = 8,
    D3DI_SPTFMT_B4G4R4   = 9,
    D3DI_SPTFMT_B4G4R4A4 =10,
    D3DI_SPTFMT_L8       =11,       /* 8 bit luminance-only */
    D3DI_SPTFMT_L8A8     =12,       /* 16 bit alpha-luminance */
    D3DI_SPTFMT_U8V8     =13,       /* 16 bit bump map format */
    D3DI_SPTFMT_U5V5L6   =14,       /* 16 bit bump map format with luminance */
    D3DI_SPTFMT_U8V8L8   =15,       /* 24 bit bump map format with luminance */

    D3DI_SPTFMT_UYVY     =16,       /* UYVY format for PC98 compliance */
    D3DI_SPTFMT_YUY2     =17,       /* YUY2 format for PC98 compliance */
    D3DI_SPTFMT_DXT1    =18,       /* S3 texture compression technique 1 */
    D3DI_SPTFMT_DXT2    =19,       /* S3 texture compression technique 2 */
    D3DI_SPTFMT_DXT3    =20,       /* S3 texture compression technique 3 */
    D3DI_SPTFMT_DXT4    =21,       /* S3 texture compression technique 4 */
    D3DI_SPTFMT_DXT5    =22,       /* S3 texture compression technique 5 */
    D3DI_SPTFMT_B2G3R3   =23,       /* 8 bit RGB texture format */

    D3DI_SPTFMT_Z16S0    =32,
    D3DI_SPTFMT_Z24S8    =33,
    D3DI_SPTFMT_Z15S1    =34,
    D3DI_SPTFMT_Z32S0    =35,
    D3DI_SPTFMT_S1Z15    =36,
    D3DI_SPTFMT_S8Z24    =37,

    // NOTE: this must be changed in conjunction with RR_STYPE in ref\inc\refrast.hpp

    D3DI_SPTFMT_FORCE_DWORD = 0x7fffffff, /* force 32-bit size enum */
} D3DI_SPANTEX_FORMAT;


// This encompasses all needed info about a chain of DD surfaces being used
// as a potentially mipmapped texture.
#define SPANTEX_MAXCLOD   11        // up to 2kx2k texture, all we can do with MMX INT16
                                    // U's and V's
typedef struct tagD3DI_SPANTEX
{
    UINT32  dwSize;

    INT32   iGeneration;            // incremented when the texture changes
    UINT32  uFlags;                 // perspective, etc.
    D3DI_SPANTEX_FORMAT  Format;    // pixel format of the texture
    D3DTEXTUREADDRESS TexAddrU, TexAddrV; // texture address mode
    D3DTEXTUREMAGFILTER  uMagFilter;// TEX3 style filter information
    D3DTEXTUREMINFILTER  uMinFilter;// ATTENTION we could express this information more compactly
    D3DTEXTUREMIPFILTER  uMipFilter;
    D3DCOLOR BorderColor;           // border color for the texture
                                    // (for D3DTADDRESS_BORDER)
    D3DCOLOR TransparentColor;      // color key on texture read

    FLOAT fLODBias;                 // Texture3 LOD bias value.

    PUINT8  pBits[SPANTEX_MAXCLOD]; // pointer for each LOD
    PUINT32 pRampmap;               // set by ramp rasterizer, if necessary
    PUINT32 pPalette;               // pointer to palette, if necessary
    INT32   iPaletteSize;           // size of palette
    INT32   cLOD;                   // contains count of levels - 1 (0 means 1 level)
                                    // to use
    INT32   cLODTex;                // contains count of levels - 1 (0 means 1 level)
                                    // that are actually in the texture
                                    // cLODTex >= cLOD is always true
    INT32   iMaxMipLevel;           // index of largest mip map to use.  0 means use largest.
    INT     iMaxScaledLOD;          // ((cLOD + 1) scaled by LOD_SCALE) - 1.
    INT16   iSizeU, iSizeV;         // LOD 0 size (only support power of 2
                                    // textures)
    INT16   iShiftU, iShiftV;       // LOD 0 log2 size (valid for power-of-2
                                    // size only)
    INT16   iShiftPitch[SPANTEX_MAXCLOD]; // log2 pitch for each LOD
#if (SPANTEX_MAXCLOD & 1) != 0
    // Pad following fields to a DWORD boundary.
    INT16   iPitchPad;
#endif
    UINT16  uMaskU, uMaskV;         // LOD 0 (1<<log2(size))-1
    // Variables for arithmetic address computation.  Computed by DoTexAddrSetup.
    INT16   iFlipMaskU, iFlipMaskV;
    INT16   iClampMinU, iClampMinV;
    INT16   iClampMaxU, iClampMaxV;
    INT16   iClampEnU, iClampEnV;

    LPDIRECTDRAWSURFACE pSurf[SPANTEX_MAXCLOD]; // Added for TextureGetSurf
                                                // and Lock/Unlock Texture

} D3DI_SPANTEX, *PD3DI_SPANTEX;

// Color structure for blending etc. with enough room for 8.8 colors.
// Even for 8 bit colors, this is convenient for lining up the colors
// as we desire in MMX for 16 bit multiplies
typedef struct tagD3DI_RASTCOLOR
{
    UINT16 uB, uG, uR, uA;
} D3DI_RASTCOLOR, *PD3DI_RASTCOLOR;

// This structure has all the temporary storage needed for all the iterated
// values to route the span information between the layers.
// TBD there is lots more to add here, do texture mapping first
typedef struct tagD3DI_SPANITER
{
    // make the colors use the same order as RASTCOLOR above
    UINT16 uBB, uBG, uBR, uBA;  // 8.8 blended color
    UINT16 uFogB, uFogG, uFogR, uFog;   // 8.8 fog color, 0.16 fog value
    INT16  iFogBDX, iFogGDX, iFogRDX, iDFog;  // 1.7.8 fog color deltas
    UINT32 uZDeferred;          // storage for Z for deferred Z write

    UV_UNION TexUV[D3DHAL_TSS_MAXSTAGES];
    D3DCOLOR    TexCol[D3DHAL_TSS_MAXSTAGES];  // [Texture]

    INT32 iDW;              // to remember last delta W in
    UINT16 uDitherOffset;
    INT16  iXStep;          // 1 or -1
    INT16 iSpecialW;        // negative for first or last 3 pixels of span
    INT16 bStencilPass;     // 1 if stencil test passed, otherwise 0
    union
    {
        INT32 iOoW;         // previous OoW to pass between texaddr stages
        FLOAT fOoW;
    };
} D3DI_SPANITER, *PD3DI_SPANITER;

// Z compare macro
// This does depend on the result of a compare being 0 or 1 (for the final XOR, since C
// doesn't have a logical XOR), but this has been true on all processors and
// compilers for some time.
#define ZCMP16(p, g, b)  \
((((((INT32)(g) - (INT32)(b)) & (p)->iZAndMask) - (p)->iZNeg) >= 0) ^ (p)->iZXorMask)

// Assumes the most significant bit of Z is 0 (31 bit Z)
#define ZCMP32(p, g, b)  \
((((((INT32)(g) - (INT32)(b)) & (p)->iZAndMask) - (p)->iZNeg) >= 0) ^ (p)->iZXorMask)

// Alpha Test compare macro
#define ACMP(p, g, b)  \
((((((INT32)(g) - (INT32)(b)) & (p)->iAAndMask) - (p)->iANeg) >= 0) ^ (p)->iAXorMask)

// Stencil Test compare macro
#define SCMP(p, g, b)  \
((((((INT32)(g) - (INT32)(b)) & (p)->iSAndMask) - (p)->iSNeg) >= 0) ^ (p)->iSXorMask)


// Helper macro that converts [0, 0xff] to [0, 5], linearly
#define RGB8_CHANNEL(rgb)   ((((rgb) * 5) + 0x80) >> 8)

// Defines conversion from 24 bit RGB to 8 bit palette index.  Each color has 6 values
// resulting in 6**3 == 216 required colors in the palette.
#define MAKE_RGB8(r, g, b) (RGB8_CHANNEL(r) * 36       \
                 + RGB8_CHANNEL(g) * 6                 \
                 + RGB8_CHANNEL(b))

// forward declaration of D3DI_RASTCTX
struct tagD3DI_RASTCTX;
typedef struct tagD3DI_RASTCTX          D3DI_RASTCTX;
typedef struct tagD3DI_RASTCTX         *PD3DI_RASTCTX;
typedef CONST struct tagD3DI_RASTCTX   *PCD3DI_RASTCTX;

// typedef for each rendering layer
// note that the RASTCTX is changed because of the D3DI_SPANITER values
typedef void (CDECL *PFNSPANLAYER)(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP,
                                   PD3DI_RASTSPAN pS);
typedef void (CDECL *PFNTEXADDRESS)(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP,
                                   PD3DI_RASTSPAN pS, INT32 iTex);

// typedef texture read functions
// this is an actual function so it can be called multiple times
// note that the RASTCTX is changed because of the D3DI_SPANITER values
typedef D3DCOLOR (CDECL *PFNTEXREAD)(INT32 iU, INT32 iV, INT32 iShiftU,
                                     PUINT8 pBits, PD3DI_SPANTEX pTex);

// Typedef for span rendering function pointers.
typedef HRESULT (CDECL *PFNRENDERSPANS)(PD3DI_RASTCTX pCtx);

// typedef for alpha blending functions.
typedef void (CDECL *PFNBLENDFUNC)(PUINT16 pR, PUINT16 pG, PUINT16 pB,
                                   PUINT16 pA, D3DCOLOR DestC,
                                   PD3DI_RASTCTX pCtx);

// typedef for buffer read functions.
typedef D3DCOLOR (CDECL *PFNBUFREAD)(PUINT8 pBits);

// typedef for texture blend get functions.
typedef void (CDECL *PFNTEXBLENDGET)(PD3DI_RASTCOLOR pArg1,
                                     PD3DI_RASTCOLOR pArg2,
                                     PD3DI_RASTCOLOR pInput,
                                     PD3DI_RASTCTX pCtx, PD3DI_RASTSPAN pS,
                                     INT32 iTex);

// typedef for texture blend get functions.
typedef void (CDECL *PFNTEXBLENDOP)(PD3DI_RASTCOLOR pOut,
                                    PD3DI_RASTCOLOR pArg1,
                                    PD3DI_RASTCOLOR pArg2,
                                    PD3DI_RASTCTX pCtx, PD3DI_RASTSPAN pS,
                                    INT32 iTex);

// Prototype for set of bead selections.
typedef enum tagD3DI_BEADSET
{
    D3DIBS_CMMX = 1,        // C emulation of MMX beads
    D3DIBS_MMX = 2,         // MMX beads
    D3DIBS_C = 3,           // C beads
    D3DIBS_RAMP = 4,        // Ramp beads
    D3DIBS_MMXASRGB = 5,    // MMX selected for RGB rasterizer
} D3DI_BEADSET;

// General span scanning context
struct tagD3DI_RASTCTX
{
    UINT32   dwSize;

    //////////////////////////////////////////////////////////////////////
    // Temporary storage for span rendering routines.  Could be global.
    // Not set by caller, and not changed by SpanInit.
    //

    D3DI_SPANITER SI;

    //////////////////////////////////////////////////////////////////////
    // Data that must be set by caller before a SpanInit.
    //

    // we may want to put a pointer to a DDSURFACEDESC or something like it
    // instead of this
    PUINT8 pSurfaceBits;
    INT iSurfaceStride;
    INT iSurfaceStep;
    INT iSurfaceBitCount;
    INT iSurfaceType;     // or however we end up expressing this
    PUINT32 pRampMap;     // pointer to ramp map, if necessary
    LPDIRECTDRAWSURFACE pDDS;

    PUINT8 pZBits;
    INT iZStride;
    INT iZStep;
    INT iZBitCount;
    LPDIRECTDRAWSURFACE pDDSZ;

    // Clip area.
    RECT Clip;

    // Sign of face area that should be culled.  Zero is clockwise,
    // one is CCW and everything else means no culling.
    UINT uCullFaceSign;

    union
    {
        DWORD pdwRenderState[D3D_MAXRENDERSTATES];
        FLOAT pfRenderState[D3D_MAXRENDERSTATES];
    };

    // Since we are adjusting the order of texIdx in the vertex to suit that
    // defined in state TEXCOORDINDEX, we need a copy of adjusted WRAP state.
    // This is declared immediately after pdwRenderState so that we can share
    // a register with it in the assembly code.
    // WARNING WARNING - THIS ABSOLUTELY NEEDS TO BE FOLLOWING pdwRenderState
    // IMMEDIATELY. ASM CODE DEPENDS ON THIS.
    DWORD pdwWrap[D3DHAL_TSS_MAXSTAGES];

    union
    {
    DWORD pdwTextureStageState[D3DHAL_TSS_MAXSTAGES][D3DHAL_TSS_STATESPERSTAGE];
    FLOAT pfTextureStageState[D3DHAL_TSS_MAXSTAGES][D3DHAL_TSS_STATESPERSTAGE];
    };

    // first texture object contains information for texture for first pair
    // of texture coordinates, second contains texture for second pair of
    // texture coordinates, etc.
    PD3DI_SPANTEX pTexture[D3DHAL_TSS_MAXSTAGES];
    // Number of active textures. 0 - texture off; 1 - pTexture[0] is valid
    // 2 - both pTexture[0] and pTexture[1] are valid
    UINT cActTex;
    // Number of active texture stages for blending. It's set in spaninit()
    // and used in TexBlend_TexM_Gen.
    UINT cActBldStage;

    // Dirty bits for render states.
    // ATTENTION - We can reduce the size  to have one bit for each group of
    // states when we implement the light weighted beed chooser.
    // Right now, it's set by SetRenderState and cleared after SpanInit is
    // called. The bit corresponding to D3DHAL_MAX_RSTATES_AND_STAGES is set
    // whenever a state is changed.
    UINT8 StatesDirtyBits[RAST_DIRTYBITS_SIZE];

#if (RAST_DIRTYBITS_SIZE & 1) != 0
    // Pad following fields to a DWORD boundary.
    INT8   StatesDirtyBitsPad0;
#endif
#if (RAST_DIRTYBITS_SIZE & 2) != 0
    // Pad following fields to a DWORD boundary.
    INT16   StatesDirtyBitsPad1;
#endif

    // Version# of the D3DDevice corresponding to this Context
    UINT32  uDevVer;

    //////////////////////////////////////////////////////////////////////
    // Data is set by SpanInit given the input above.
    //

    // Span rendering entry point.
    PFNRENDERSPANS  pfnRenderSpans;

    // function pointers for the beads
    PFNSPANLAYER    pfnBegin;
    PFNSPANLAYER    pfnLoopEnd;
    PFNSPANLAYER    pfnTestPassEnd;
    PFNSPANLAYER    pfnTestFailEnd;

    PFNTEXADDRESS   pfnTexAddr[D3DHAL_TSS_MAXSTAGES];
    PFNSPANLAYER    pfnTexAddrEnd;
    PFNTEXREAD      pfnTexRead[D3DHAL_TSS_MAXSTAGES];
    PFNSPANLAYER    pfnTexBlendEnd;
    PFNTEXBLENDGET  pfnTexBlendGetColor[D3DHAL_TSS_MAXSTAGES];
    PFNTEXBLENDGET  pfnTexBlendGetAlpha[D3DHAL_TSS_MAXSTAGES];
    PFNTEXBLENDOP   pfnTexBlendOpColor[D3DHAL_TSS_MAXSTAGES];
    PFNTEXBLENDOP   pfnTexBlendOpAlpha[D3DHAL_TSS_MAXSTAGES];

    PFNSPANLAYER    pfnColorGenEnd;
    PFNSPANLAYER    pfnAlphaTestPassEnd;
    PFNSPANLAYER    pfnAlphaTestFailEnd;
    PFNBLENDFUNC    pfnSrcBlend;
    PFNBLENDFUNC    pfnDestBlend;
    PFNBUFREAD      pfnBufRead;
    PFNSPANLAYER    pfnColorBlendEnd;

    // Optional bead that can be called after every pixel for rasterizers
    // which loop beads rather than returning.
    PFNSPANLAYER    pfnPixelEnd;

    // Optional bead that can be called after every span for rasterizers
    // which loop spans rather than returning.
    PFNSPANLAYER    pfnSpanEnd;

    // arithmetic Z variables
    INT32 iZAndMask, iZNeg, iZXorMask;

    // arithmetic Alpha test variables.  These could be 16 bits, if we ever really want
    // to save space
    INT32 iAAndMask, iANeg, iAXorMask;
    // 8.8 Alpha reference value
    INT32 iARef;

    // arithmetic stencil test variables.  These could be 16 bits, if we ever really want
    // to save space
    INT32 iSAndMask, iSNeg, iSXorMask;

    // Pointer to first RASTPRIM.
    PD3DI_RASTPRIM pPrim;

    // Pointer to next context.
    PD3DI_RASTCTX pNext;

    // Current BeadTable to use
    D3DI_BEADSET BeadSet;

    // Bit 0 set disables ml1, etc.
#define MMX_FP_DISABLE_MASK_NUM 1
    DWORD dwMMXFPDisableMask[MMX_FP_DISABLE_MASK_NUM];

    // RampLightingDriver, should be NULL except for RampRast and 8 bit palettized RGB
    // output surface cases.
    LPVOID pRampDrv;
    // RAMP_RANGE_INFO RampInfo;
    DWORD RampBase;
    DWORD RampSize;
    PUINT32 pTexRampMap;
    BOOL bRampSpecular;

#ifdef DBG
#define NAME_LEN    128
    char    szTest[NAME_LEN];
    char    szTestFail[NAME_LEN];
    char    szTexAddr[D3DHAL_TSS_MAXSTAGES][NAME_LEN];
    char    szTexRead[D3DHAL_TSS_MAXSTAGES][NAME_LEN];
    char    szTexBlend[NAME_LEN];
    char    szColorGen[NAME_LEN];
    char    szAlphaTest[NAME_LEN];
    char    szColorBlend[NAME_LEN];
    char    szSrcBlend[NAME_LEN];
    char    szDestBlend[NAME_LEN];
    char    szBufRead[NAME_LEN];
    char    szBufWrite[NAME_LEN];
#undef  NAME_LEN
#endif
};

// Data passed to the span rendering functions looks like this:
//
// RASTCTX
// |-> RASTPRIM
// |   |   RASTSPAN
// |   |   RASTSPAN (as many as RASTPRIM.uSpans says there are)
// |   RASTPRIM
// |   |   RASTSPAN
// |   NULL
// RASTCTX
// |-> RASTPRIM
// |   |   RASTSPAN
// |   NULL
// NULL
//
// The given RASTCTX is the head of a list of contexts.  Each context
// points to a list of RASTPRIMs.  Each RASTPRIM structure is immediately
// followed by RASTPRIM.uSpans RASTSPAN structures.

// Prototype for state validation call.
HRESULT SpanInit(PD3DI_RASTCTX pCtx);

// This is used to pack a FVF vertex into one understand by OptRast so it
// does not need to figure out where to get the data it needs. This struct
// can be modified to accommodate more data and it can be broken into more
// specilized and smalled structs.
// Right now, it is an extension of D3DTLVERTEX, and the extra uv is at the
// very end so that OptRast can treat it as a D3DTLVERTEX if only the first
// part of the data needs to be accessed.
typedef struct _RAST_GENERIC_VERTEX {
    union {
    D3DVALUE    sx;             /* Screen coordinates */
    D3DVALUE    dvSX;
    };
    union {
    D3DVALUE    sy;
    D3DVALUE    dvSY;
    };
    union {
    D3DVALUE    sz;
    D3DVALUE    dvSZ;
    };
    union {
    D3DVALUE    rhw;            /* Reciprocal of homogeneous w */
    D3DVALUE    dvRHW;
    };
    union {
    D3DCOLOR    color;          /* Vertex color */
    D3DCOLOR    dcColor;
    };
    union {
    D3DCOLOR    specular;       /* Specular component of vertex */
    D3DCOLOR    dcSpecular;
    };
    UV_UNION  texCoord[D3DHAL_TSS_MAXSTAGES]; /* Texture coordinates */
}RAST_GENERIC_VERTEX, *PRAST_GENERIC_VERTEX;

// Vertex types supported by OptRast
typedef enum _RAST_VERTEX_TYPE
{
    RAST_TLVERTEX       = 1,    /* (Legacy) TL vertex */
    RAST_GENVERTEX      = 2,    /* Generic FVF vertex */
    RAST_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
}RAST_VERTEX_TYPE;

#include <poppack.h>

#ifdef __cplusplus
}
#endif

#endif // _SPAN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\linklib\sources.inc ===
# Sources to link and publish d3d8.lib only

#this file is copied here from ..\linkdll by makefil0
SOURCES = ..\d3d8.rc

!include ..\..\bldlink.inc

# do not binplace from here
NO_BINPLACE=1

# publish d3d8.lib
PASS1_PUBLISH=\
    { $(O)\$(TARGETNAME).lib=$(SDK_LIB_PATH)\$(ALT_PROJECT_TARGET)\$(TARGETNAME).lib }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\osthunk\whistler\sources.inc ===
MAJORCOMP=d3d
MINORCOMP=d3d8
#
# this will cause the checked versions of the object files, libraries, binaries, etc.
#   to land in objd; keeping them seperate from the free versions
#   TARGETPATH should stay as obj or it will get a little wierd
#
#CHECKED_ALT_DIR=1
TARGETPATH=obj
#
# the build environment sets the FREEBUILD macro to 1 when it is a freebuild
#  so you can change the name of the built binary to be different in that case.
#  side affects:
#             need 2 entries in placefil.txt (one for each name)
#             if a lib is published it will be called the new name; depending on your
#                viewpoint this could be a good thing or not
#
TARGETNAME=d3d8thk

TARGETPATH=obj

TARGETTYPE=DYNLINK

SYNCHRONIZE_DRAIN = 1

INCLUDES=$(DXROOT)\inc;$(INCLUDES)

LINKER_FLAGS = $(LINKER_FLAGS) /IGNORE:4088

NO_NTDLL = 1

DLLENTRY = _DllMainCRTStartup

DLLDEF = ..\d3d8thk.def

SOURCES = ..\d3d8thk.rc

PASS1_PUBLISH= \
    {$(O)\d3d8thk.lib=$(SDK_LIB_PATH)\d3d8thk.lib}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\linkdll\sources.inc ===
# Sources to build and binplace d3d8(d).dll
#
#   generates d3d8.dll for FREE build
#   generates d3d8d.dll for !FREE && DIRECTX_REDIST build

!include ..\..\bldlink.inc

!if !$(FREEBUILD)
!ifdef DIRECTX_REDIST
TARGETNAME=$(TARGETNAME)d
!endif
!endif

SOURCES = ..\d3d8.rc

# do regular binplace
# do not publish lib (do not want d3d8d.lib published)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\ref\common.cpp ===
#include "pch.cpp"
#pragma hdrstop

#include "..\..\ref8\drv\refif.cpp"
#include "..\..\ref8\drv\dprim2.cpp"
#include "..\..\ref8\drv\surfman.cpp"
#include "..\..\ref8\drv\rralloc.cpp"
#include "..\..\ref8\common\dxtn.cpp"
#include "..\..\ref8\common\rdsurf.cpp"
#include "..\..\ref8\common\rdutil.cpp"
#include "..\..\ref8\common\pixref.cpp"
#include "..\..\ref8\common\refdev.cpp"
#include "..\..\ref8\common\refdevi.cpp"
#include "..\..\ref8\common\rtarget.cpp"
#include "..\..\ref8\rast\refrast.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\inc\vvm.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       vvm.h
 *  Content:    Virtual Vertex Machine declarations
 *
 *
 ***************************************************************************/
#ifndef __VVM_H__
#define __VVM_H__
#include "d3dhalp.h"

class CVShaderCodeI;
extern HRESULT ComputeShaderCodeSize(CONST DWORD* pCode, DWORD* pdwCodeOnlySize, DWORD* pdwCodeAndCommentSize,
                                     DWORD* pdwNumConstDefs);

// Number of vertices in batch to process
const DWORD VVMVERTEXBATCH = 16;
//-----------------------------------------------------------------------------
// Internal word of the vertual vertex machine
//
struct VVM_WORD
{
    union
    {
        struct
        {
            D3DVALUE x, y, z, w;
        };
        D3DVALUE v[4];
    };
};
//-----------------------------------------------------------------------------
struct VVM_REGISTERS
{
    VVM_REGISTERS()  {m_c = NULL;}
    ~VVM_REGISTERS() {delete [] m_c;}
    // Input registers
    VVM_WORD    m_v[D3DVS_INPUTREG_MAX_V1_1][VVMVERTEXBATCH];
    // Temporary registers
    VVM_WORD    m_r[D3DVS_TEMPREG_MAX_V1_1][VVMVERTEXBATCH];
    // Constant registers. Allocated dynamically, base on MaxVertexShaderConst 
    // cap
    VVM_WORD*    m_c;
    // Address registers
    VVM_WORD    m_a[D3DVS_ADDRREG_MAX_V1_1][VVMVERTEXBATCH];
    // Output register file
    VVM_WORD    m_output[3][VVMVERTEXBATCH];
    // Attribute register file
    VVM_WORD    m_color[D3DVS_ATTROUTREG_MAX_V1_1][VVMVERTEXBATCH];
    // Output texture registers
    VVM_WORD    m_texture[D3DVS_TCRDOUTREG_MAX_V1_1][VVMVERTEXBATCH];
};
//-----------------------------------------------------------------------------
//
// CVShaderCode: Vertex Shader Code
//
//-----------------------------------------------------------------------------
class CVShaderCode: public CPSGPShader
{
public:
    CVShaderCode() {};
    virtual ~CVShaderCode() {};

    virtual DWORD  InstCount( void ) { return 0; };
    virtual DWORD* InstTokens( DWORD Inst ) { return NULL; };
    virtual char*  InstDisasm( DWORD Inst ) { return NULL; };
    virtual DWORD* InstComment( DWORD Inst ) { return NULL; };
    virtual DWORD  InstCommentSize( DWORD Inst ) { return 0; };
};
//-----------------------------------------------------------------------------
// Vertex Virtual Machine object
//
//-----------------------------------------------------------------------------

const UINT __MAX_SRC_OPERANDS = 5;

class CVertexVM
{
public:
    CVertexVM();
    ~CVertexVM();
    void Init(UINT MaxVertexShaderConst);
    // Parses binary shader representatio, compiles is and returns
    // compiled object
    CVShaderCode* CreateShader(CVElement* pElements, DWORD dwNumElements,
                               DWORD* code);
    HRESULT SetActiveShader(CVShaderCode* code);
    CVShaderCode* GetActiveShader() {return (CVShaderCode*)m_pCurrentShader;}
    HRESULT ExecuteShader(LPD3DFE_PROCESSVERTICES pv, UINT vertexCount);
    HRESULT GetDataPointer(DWORD dwMemType, VVM_WORD ** pData);
    // Set internal registers to user data
    HRESULT SetData(DWORD RegType, DWORD start, DWORD count, LPVOID buffer);
    // Get data from internal registers
    HRESULT GetData(DWORD RegType, DWORD start, DWORD count, LPVOID buffer);
    VVM_REGISTERS* GetRegisters();
    DWORD GetCurInstIndex() {return m_CurInstIndex; }

    // Number of allocated constant registers
    UINT            m_MaxVertexShaderConst;
protected:
    void InstMov();
    void InstAdd();
    void InstMad();
    void InstMul();
    void InstRcp();
    void InstRsq();
    void InstDP3();
    void InstDP4();
    void InstMin();
    void InstMax();
    void InstSlt();
    void InstSge();
    void InstExp();
    void InstLog();
    void InstExpP();
    void InstLogP();
    void InstLit();
    void InstDst();
    void InstFrc();
    void InstM4x4();
    void InstM4x3();
    void InstM3x4();
    void InstM3x3();
    void InstM3x2();
    void EvalDestination();
    void EvalSource(DWORD index);
    void EvalSource(DWORD index, DWORD count);
    VVM_WORD* GetDataAddr(DWORD dwRegType, DWORD dwElementIndex);
    void ValidateShader(CVShaderCodeI* shader, DWORD* orgShader);
    void PrintInstCount();
    UINT GetNumSrcOperands(UINT opcode);
    UINT GetInstructionLength(DWORD Inst);
    UINT GetRegisterUsage(UINT opcode, UINT SourceIndex);

    // Virtual machine registers
    VVM_REGISTERS   m_reg;
    // Current shader code
    CVShaderCodeI*  m_pCurrentShader;
    // Current token during parsing
    DWORD*          m_pdwCurToken;
    // Pointer to destination operand
    VVM_WORD*       m_pDest;
    // Offset in the register file for destination operand
    DWORD           m_dwOffset;
    // Write mask for destination operand
    DWORD           m_WriteMask;
    // Current instruction (about to be executed)
    DWORD           m_CurInstIndex;
    // Source operands
    VVM_WORD        m_Source[__MAX_SRC_OPERANDS][VVMVERTEXBATCH];
    // How many vertices to process in a batch
    UINT            m_count;
    // m_count * sizeof(VVM_WORD)
    UINT            m_BatchSize;

    // Initialized flags
#if DBG
    // Constant registers
    BOOL            m_c_initialized[D3DVS_CONSTREG_MAX_V1_1];
#endif // DBG
    friend class D3DFE_PVFUNCSI;
    friend class CD3DHal;
};

#endif // __VVM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\osthunk\win2k\sources.inc ===
MAJORCOMP=d3d
MINORCOMP=d3d8

TARGETNAME=d3d8thk

TARGETPATH=obj

TARGETTYPE=DYNLINK

SYNCHRONIZE_DRAIN = 1

INCLUDES=$(DXROOT)\inc;$(INCLUDES)

LINKER_FLAGS = $(LINKER_FLAGS) /IGNORE:4088

NO_NTDLL = 1

DLLENTRY = _DllMainCRTStartup

DLLDEF = ..\d3d8thk.def

SOURCES = ..\d3d8thk.rc

PASS1_PUBLISH= \
    {lib\i386\w32umode.lib=$(SDK_LIB_PATH)\w2kumode.lib}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\inc\vshader.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   vshader.hpp
 *  Content:    Direct3D vertex shader internal include file
 *
 *
 ***************************************************************************/
#ifndef _VSHADER_HPP
#define _VSHADER_HPP

#include "d3dfe.hpp"
#include "vvm.h"
#include "hmgr.hpp"
#include "vbuffer.hpp"
#include "ibuffer.hpp"

void CheckForNull(LPVOID p, DWORD line, char* file);
class CD3DBase;
//---------------------------------------------------------------------
// macros for parsing Declaration Token Array

// TRUE, if shader handle is DX7 FVF code
//
#define D3DVSD_ISLEGACY(ShaderHandle) !(ShaderHandle & D3DFVF_RESERVED0)

enum D3DVSD_DATALOAD
{
    D3DVSD_LOADREGISTER = 0,
    D3DVSD_SKIP
};

#define D3DVSD_GETTOKENTYPE(token) ((token & D3DVSD_TOKENTYPEMASK) >> D3DVSD_TOKENTYPESHIFT)
#define D3DVSD_ISSTREAMTESS(token) ((token & D3DVSD_STREAMTESSMASK) >> (D3DVSD_TOKENTYPESHIFT - 1))
#define D3DVSD_GETDATALOADTYPE(token) ((token & D3DVSD_DATALOADTYPEMASK) >> D3DVSD_DATALOADTYPESHIFT)
#define D3DVSD_GETDATATYPE(token) ((token & D3DVSD_DATATYPEMASK) >> D3DVSD_DATATYPESHIFT)
#define D3DVSD_GETSKIPCOUNT(token) ((token & D3DVSD_SKIPCOUNTMASK) >> D3DVSD_SKIPCOUNTSHIFT)
#define D3DVSD_GETSTREAMNUMBER(token) ((token & D3DVSD_STREAMNUMBERMASK) >> D3DVSD_STREAMNUMBERSHIFT)
#define D3DVSD_GETVERTEXREG(token) ((token & D3DVSD_VERTEXREGMASK) >> D3DVSD_VERTEXREGSHIFT)
#define D3DVSD_GETCONSTCOUNT(token) ((token & D3DVSD_CONSTCOUNTMASK) >> D3DVSD_CONSTCOUNTSHIFT)
#define D3DVSD_GETCONSTADDRESS(token) ((token & D3DVSD_CONSTADDRESSMASK) >> D3DVSD_CONSTADDRESSSHIFT)
#define D3DVSD_GETCONSTRS(token) ((token & D3DVSD_CONSTRSMASK) >> D3DVSD_CONSTRSSHIFT)
#define D3DVSD_GETEXTCOUNT(token) ((token & D3DVSD_EXTCOUNTMASK) >> D3DVSD_EXTCOUNTSHIFT)
#define D3DVSD_GETEXTINFO(token) ((token & D3DVSD_EXTINFOMASK) >> D3DVSD_EXTINFOSHIFT)

//---------------------------------------------------------------------
//
// CVConstantData: Constant data that is used by a shader
//
//---------------------------------------------------------------------
struct CVConstantData: public CListEntry
{
    CVConstantData()     {m_pData = NULL; m_dwCount = 0;}
    ~CVConstantData()    {delete m_pData;}

    DWORD   m_dwCount;          // Number of 4*DWORDs to load
    DWORD   m_dwAddress;        // Start constant register
    DWORD*  m_pData;            // Data. Multiple of 4*DWORD
};
//---------------------------------------------------------------------
//
// CVStreamDecl:
//
//      Describes a stream, used by a declaration
//
//---------------------------------------------------------------------
class CVStreamDecl: public CListEntry
{
public:
    CVStreamDecl()
    {
        m_dwNumElements = 0;
        m_dwStride = 0;
        m_dwStreamIndex = 0xFFFFFFFF;
#if DBG
        m_dwFVF = 0;
#endif // DBG
    }
    // Parses declaration.
    // For fixed-function pipeline computes FVF, FVF2 (used to record
    // texture presense) and number of floats after position
    void Parse(CD3DBase* pDevice, DWORD CONST ** ppToken, BOOL bFixedFunction,
               DWORD* pdwFVF, DWORD* pdwFVF2, DWORD* pnFloats, 
               BOOL* pbLegacyFVF, UINT Usage, BOOL bTessStream = FALSE);

    CVElement   m_Elements[__NUMELEMENTS];  // Vertex elements in the stream
    DWORD       m_dwNumElements;            // Number of elements to use
    DWORD       m_dwStride;                 // Vertex size in bytes
    DWORD       m_dwStreamIndex;            // Index to device streams
#if DBG
    // FVF, computed from declaration. Used for fixed function pipeline only
    DWORD       m_dwFVF;
#endif //DBG
};
//---------------------------------------------------------------------
//
// CVDeclaration:
//
//      D3D parses declaration byte-codes and creates this data structure.
//
//-----------------------------------------------------------------------------
class CVDeclaration
{
public:
    CVDeclaration(DWORD dwNumStreams);
    ~CVDeclaration();
    //------------- Used during declaration parsing -----------
    // pDeclSize will have size of the declaration in bytes if not NULL
    void Parse(CD3DBase* pDevice, CONST DWORD * decl, BOOL bFixedFunction, 
               DWORD* pDeclSize, UINT Usage);

    // List of streams, which are used by the declaration
    CVStreamDecl*   m_pActiveStreams;
    CVStreamDecl*   m_pActiveStreamsTail;
    // Corresponding FVF for fixed-function pipeline
    // This is OR of all streams input FVF
    DWORD           m_dwInputFVF;
    // This is computed for legacy TL capable hardware.
    // If this is NULL, that means that the declaration is too complex
    // for these devices.
    BOOL           m_bLegacyFVF;
    // TRUE when a tesselator stream is present in the declaration.
    // We need this to validate that the stream is not passed to DrawPrimitive
    // API.
    BOOL           m_bStreamTessPresent;
    // Max number of available streams
    DWORD           m_dwNumStreams;
    // Constant data that should be loaded when shader becomes active
    CVConstantData* m_pConstants;
    CVConstantData* m_pConstantsTail;
    //------------- Used by PSGP ---------------
    // The description of all vertex elements to be loaded into input registers.
    // The array is built by going through active streams and elements inside
    // each stream
    CVElement       m_VertexElements[__NUMELEMENTS];
    // Number of used members of m_VertexElements
    DWORD           m_dwNumElements;

    friend class CD3DHal;
};
//-----------------------------------------------------------------------------
//
//  CVStreamBase: Class representing the digested information for vertex
//                stream in the MS implementation.
//
//-----------------------------------------------------------------------------
struct CVStreamBase
{
    CVStreamBase()
    {
        m_pData = NULL;
        m_dwStride = 0;
#if DBG
        m_dwSize = 0;
#endif
        m_dwNumVertices = 0;
        m_dwIndex = 0;
    }
    // Stream memory. In case of vertex buffers (m_pVB != NULL), we lock the
    // vertex buffer and assign its memory pointer to the m_pData
    LPBYTE  m_pData;
    // Vertex (or index) stride in bytes
    DWORD           m_dwStride;
#if DBG
    // Buffer size in bytes
    DWORD           m_dwSize;
#endif // DBG
    // Index of the stream. Needed when we access streams through pointers
    // m_dwIndex == __NUMSTREAMS is a flag when CIndexBuffer is used
    DWORD           m_dwIndex;
    // Max number of vertices (or indices in case of index buffer) the buffer
    // can store (valid in DBG only !!!).
    // For internal TL buffers this is used as number of vertices, currently
    // written to the buffer.
    DWORD           m_dwNumVertices;
};
//-----------------------------------------------------------------------------
//
//  CVStream: Class representing the digested information for vertex
//             stream in the MS implementation.
//
//-----------------------------------------------------------------------------
struct CVStream: public CVStreamBase
{
    CVStream() {m_pVB = NULL;}
    BYTE* Data()
        {
            if (m_pVB)
                return m_pVB->Data();
            else
                return m_pData;
        }
    ~CVStream();
    virtual BOOL IsUserMemStream() {return FALSE;}
    CVertexBuffer *m_pVB;      // User passed VB
};
//-----------------------------------------------------------------------------
//
//  CVStream: Class representing the digested information for vertex
//             stream in the MS implementation.
//
//-----------------------------------------------------------------------------
struct CVIndexStream: public CVStreamBase
{
    CVIndexStream()
    {
        m_dwBaseIndex = 0;
        m_dwIndex = __NUMSTREAMS; // Mark the stream as index stream
        m_pVBI = NULL;
    }
    BYTE* Data()
        {
            if (m_pVBI)
                return m_pVBI->Data();
            else
                return m_pData;
        }
    ~CVIndexStream();
    DWORD   m_dwBaseIndex;  // Vertex index, that corresponds to the index 0
    CIndexBuffer  *m_pVBI;  // User passed VB
};
//-----------------------------------------------------------------------------
//
// CVShader: Vertex Shader Class
//
//-----------------------------------------------------------------------------
class CVShader : public CD3DBaseObj
{
public:
    CVShader(DWORD dwNumStreams): m_Declaration(dwNumStreams)
        {
            m_dwFlags = 0;
            m_pCode = NULL;
            m_pOrgDeclaration = NULL;
            m_OrgDeclSize = 0;
            m_pOrgFuncCode = NULL;
            m_OrgFuncCodeSize = 0;
            m_pStrippedFuncCode = NULL;
            m_StrippedFuncCodeSize = 0;
        }
    ~CVShader()
        {
            delete m_pCode;
            delete m_pOrgDeclaration;
            delete m_pOrgFuncCode;
            delete m_pStrippedFuncCode;
        }
    HRESULT Initialize(DWORD* lpdwDeclaration, DWORD* lpdwFunction);

    // Bits for m_dwFlags
    static const DWORD FIXEDFUNCTION;   // This is fixed-function shader
    static const DWORD SOFTWARE;        // Shader is used with software pipeline

    CVDeclaration   m_Declaration;
    CVShaderCode*   m_pCode;            // PSGP vertex shader object
                                        // Used to process point sprites.
    DWORD           m_dwFlags;
    DWORD           m_dwInputFVF;       // Input FVF for fixed-function pipeline
    DWORD*          m_pOrgDeclaration;  // Original declaration
    UINT            m_OrgDeclSize;      // Size in bytes
    DWORD*          m_pOrgFuncCode;     // Original function code
    UINT            m_OrgFuncCodeSize;  // Size in bytes
    DWORD*          m_pStrippedFuncCode;    // Comment-stripped function code
    UINT            m_StrippedFuncCodeSize; // Size in bytes
};
typedef CVShader *LPVSHADER;
//-----------------------------------------------------------------------------
//
// CVShaderHandleFactory: Vertex Shader Handle Factory
//
//-----------------------------------------------------------------------------
class CVShaderHandleFactory : public CHandleFactory
{
public:
    DWORD CreateNewHandle( LPVSHADER pVShader  );
    LPD3DBASEOBJ GetObject( DWORD dwHandle ) const;
    void ReleaseHandle(DWORD handle, BOOL);
    BOOL SetObject( DWORD dwHandle, LPD3DBASEOBJ );
    virtual UINT HandleFromIndex( DWORD index) const {return (index << 1) + 1;}
    CVShader* GetObjectFast(DWORD dwHandle) const
    {
        return (CVShader*)((reinterpret_cast<CHandle*>(m_Handles.GetArrayPointer())[dwHandle >> 1]).m_pObj);
    }
};


#endif _VSHADER_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\ref\empty.cpp ===
#include "pch.cpp"
#pragma hdrstop

HRESULT 
RefDev::DrawPrimitives2( PUINT8 pUMVtx,
                         UINT16 dwStride,
                         DWORD dwFvf,
                         DWORD dwNumVertices,
                         LPD3DHAL_DP2COMMAND *ppCmd,
                         LPDWORD lpdwRStates )
{
    return S_OK;
}

void
RefDev::SetSetStateFunctions(void)
{
}

void
RefRast::SetSampleMode( UINT MultiSamples, BOOL bAntialias )
{
}

HRESULT
RefDev::Dp2SetVertexShader(LPD3DHAL_DP2COMMAND pCmd)
{
    return S_OK;
}

void
RefRast::UpdateTextureControls( void )
{
}

void
RefRast::UpdateLegacyPixelShader( void )
{
}

RDVShader::RDVShader()
{
}

RDVShader::~RDVShader()
{
}

RDVDeclaration::~RDVDeclaration()
{
}

RefRast::~RefRast()
{
}

void 
RefRast::Init( RefDev* pRD )
{
}

RefClipper::RefClipper()
{
}

RefVP::RefVP()
{
}

RDPShader::~RDPShader()
{
}

RDLight::RDLight()
{
}

RDVStreamDecl::RDVStreamDecl()
{
}

RDHOCoeffs& RDHOCoeffs::operator=(const RDHOCoeffs &coeffs)
{
    return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\ref\sources.inc ===
TARGETPATH=obj
TARGETNAME=d3dref

TARGETTYPE=LIBRARY

INCLUDES = ..;$(INCLUDES);$(DDK_INC_PATH);$(DXGROOT)\ref8\inc;$(DXGROOT)\ref8\drv
C_DEFINES = $(C_DEFINES) -D__D3D_NULL_REF
386_STDCALL = 0

SOURCES=\
    ..\common.cpp     \
    ..\empty.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\ref\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------
#include "refdev.hpp"

#include "refif.hpp"
///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\shval\errlog.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// errlog.hpp
//
// Direct3D Reference Device - Error log for shader validation.
//
///////////////////////////////////////////////////////////////////////////////
#ifndef __ERRLOG_HPP__
#define __ERRLOG_HPP__

#define ERRORLOG_STRINGSIZE 1024

typedef struct _ErrorLogNode
{
    char String[ERRORLOG_STRINGSIZE]; // For individual errors.
    _ErrorLogNode* pNext;
} ErrorLogNode;

class CErrorLog
{
    ErrorLogNode* m_pHead;
    ErrorLogNode* m_pTail;
    DWORD   m_TotalStringLength;
    BOOL    m_bRememberAllSpew;

public:
    CErrorLog( BOOL bRememberAllSpew );
    ~CErrorLog();
    void AppendText( const char* pszFormat, ... );
    DWORD   GetRequiredLogBufferSize() {return m_TotalStringLength + 1;}
    void    WriteLogToBuffer( char* pBuffer ); // call GetLogBufferSizeRequired first.
};

#endif // __ERRLOG_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\shval\pch.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// pch.cpp
//
// Precompiled header file.
//
///////////////////////////////////////////////////////////////////////////////
#include "ddrawpr.h"

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <malloc.h>
#include <windows.h>

#include "d3d8typesp.h"
#include "d3d8p.h"
#include "d3dhalp.h"

#include "errlog.hpp"
#include "valbase.hpp"
#include "pshdrval.hpp"
#include "vshdrval.hpp"

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\shval\errlog.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// errlog.cpp
//
// Direct3D Reference Device - Error log for shader validation.
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
// CErrorLog::CErrorLog
//-----------------------------------------------------------------------------
CErrorLog::CErrorLog( BOOL bRememberAllSpew )
{
    m_TotalStringLength     = 0;
    m_pHead                 = NULL;
    m_pTail                 = NULL;
    m_bRememberAllSpew      = bRememberAllSpew;
}

//-----------------------------------------------------------------------------
// CErrorLog::~CErrorLog
//-----------------------------------------------------------------------------
CErrorLog::~CErrorLog()
{
    ErrorLogNode*    pCurr = m_pHead;
    while( pCurr )
    {
        ErrorLogNode* pDeleteMe = pCurr;
        pCurr = pCurr->pNext;
        delete pDeleteMe;
    }
    m_pHead = NULL;
    m_pTail = NULL;

}

//-----------------------------------------------------------------------------
// CErrorLog::AppendText
//-----------------------------------------------------------------------------
void CErrorLog::AppendText( const char* pszFormat, ... )
{
#if DBG
    OutputDebugString("D3D Shader Validator: ");
#endif

    ErrorLogNode* pNewString = new ErrorLogNode;
    if( NULL == pNewString )
    {
        OutputDebugString("Out of memory.\n");
        return;
    }
    _snprintf( pNewString->String, ERRORLOG_STRINGSIZE-1, "");

    va_list marker;
    va_start(marker, pszFormat);
    _vsnprintf(pNewString->String+lstrlen(pNewString->String), ERRORLOG_STRINGSIZE - lstrlen(pNewString->String) - 2, pszFormat, marker);
    _snprintf( pNewString->String, ERRORLOG_STRINGSIZE - 2, "%s", pNewString->String );
    strcat( pNewString->String, "\n" ); // force trailing \n
    pNewString->String[ERRORLOG_STRINGSIZE-1] = '\0'; // force trailing \0.
#if DBG
    OutputDebugString(pNewString->String);
#endif

    if( m_bRememberAllSpew )
    {
        // append node
        if( NULL == m_pHead )
            m_pHead = pNewString;

        if( NULL != m_pTail )
            m_pTail->pNext = pNewString;

        m_pTail = pNewString;
        pNewString->pNext = NULL;
        m_TotalStringLength += strlen(pNewString->String);
    }
    else
    {
        delete pNewString;
    }
}

//-----------------------------------------------------------------------------
// CErrorLog::WriteLogToBuffer()
//
// Call GetLogBufferSizeRequired() first to figure out how big to make pBuffer
//-----------------------------------------------------------------------------
void CErrorLog::WriteLogToBuffer( char* pBuffer )
{
    if( NULL == pBuffer )
        return;

    pBuffer[0] = '\0';
    if( NULL != m_pHead )
    {
        ErrorLogNode* pCurr = m_pHead;
        while( pCurr )
        {
            strcat(pBuffer,pCurr->String);
            pCurr = pCurr->pNext;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\shval\sources.inc ===
TARGETNAME=d3dsv
TARGETPATH=obj
TARGETTYPE=LIBRARY
INCLUDES = ..;$(INCLUDES)

SOURCES =                  \
    ..\valbase.cpp         \
    ..\pshdrval.cpp        \
    ..\psval10.cpp         \
    ..\psval14.cpp         \
    ..\vshdrval.cpp        \
    ..\errlog.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\shval\pshdrval.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// pshdrval.hpp
//
// Direct3D Reference Device - PixelShader validation
//
///////////////////////////////////////////////////////////////////////////////
#ifndef __PSHDRVAL_HPP__
#define __PSHDRVAL_HPP__

#define PS_INST_TOKEN_RESERVED_MASK         0xbfff0000 // bits 16-23, 24-29, 31 must be 0
#define PS_DSTPARAM_TOKEN_RESERVED_MASK     0x4000e000 // bits 13-15, 30 must be 0
#define PS_SRCPARAM_TOKEN_RESERVED_MASK     0x4000e000 // bits 13-15, 30 must be 0

//-----------------------------------------------------------------------------
// CPSInstruction
//-----------------------------------------------------------------------------
class CPSInstruction : public CBaseInstruction
{
public:
    CPSInstruction(CPSInstruction* pPrevInst) : CBaseInstruction(pPrevInst)
    {
        m_bTexOp                    = FALSE;
        m_bTexMOp                   = FALSE;
        m_bTexOpThatReadsTexture    = FALSE;
        m_bCoIssue                  = FALSE;
        m_CycleNum                  = (UINT)-1;
    };

    void CalculateComponentReadMasks(DWORD dwVersion);

    BOOL    m_bTexOp;
    BOOL    m_bTexMOp;
    BOOL    m_bTexOpThatReadsTexture;
    BOOL    m_bCoIssue;
    UINT    m_CycleNum; // identical for co-issued instructions
};

//-----------------------------------------------------------------------------
// CBasePShaderValidator
//-----------------------------------------------------------------------------
class CBasePShaderValidator : public CBaseShaderValidator
{
protected:
    UINT            m_CycleNum;
    UINT            m_TexOpCount;
    UINT            m_BlendOpCount;
    UINT            m_TotalOpCount; // not necessarily the sum of TexOpCount and BlendOpCount....

    CRegisterFile*  m_pTempRegFile;    
    CRegisterFile*  m_pInputRegFile;
    CRegisterFile*  m_pConstRegFile;
    CRegisterFile*  m_pTextureRegFile;

    CBaseInstruction* AllocateNewInstruction(CBaseInstruction*pPrevInst);
    BOOL DecodeNextInstruction();
    virtual BOOL InitValidation() = 0;
    virtual BOOL ApplyPerInstructionRules() = 0;
    virtual void ApplyPostInstructionsRules() = 0;
    virtual void IsCurrInstTexOp() = 0;
        
public:
    CBasePShaderValidator( const DWORD* pCode, const D3DCAPS8* pCaps, DWORD Flags );
    ~CBasePShaderValidator();
};

//-----------------------------------------------------------------------------
// CPShaderValidator10
//-----------------------------------------------------------------------------
class CPShaderValidator10 : public CBasePShaderValidator
{
private:
    UINT            m_TexOpCount;
    UINT            m_BlendOpCount;
    UINT            m_TotalOpCount; // not necessarily the sum of TexOpCount and BlendOpCount....
    UINT            m_TexMBaseDstReg;

    BOOL ApplyPerInstructionRules();
    void ApplyPostInstructionsRules();
    void IsCurrInstTexOp();
    BOOL InitValidation();
 
    BOOL Rule_InstructionRecognized();
    BOOL Rule_InstructionSupportedByVersion();
    BOOL Rule_ValidParamCount();
    BOOL Rule_ValidSrcParams(); 
    BOOL Rule_NegateAfterSat();
    BOOL Rule_SatBeforeBiasOrComplement();
    BOOL Rule_MultipleDependentTextureReads();
    BOOL Rule_SrcNoLongerAvailable(); 
    BOOL Rule_SrcInitialized();
    BOOL Rule_ValidDstParam();
    BOOL Rule_ValidRegisterPortUsage();
    BOOL Rule_TexRegsDeclaredInOrder();
    BOOL Rule_TexOpAfterNonTexOp();
    BOOL Rule_ValidTEXM3xSequence();               // Call per instruction AND after all instructions seen
    BOOL Rule_ValidTEXM3xRegisterNumbers();
    BOOL Rule_ValidCNDInstruction();
    BOOL Rule_ValidCMPInstruction();
    BOOL Rule_ValidLRPInstruction();
    BOOL Rule_ValidDEFInstruction();
    BOOL Rule_ValidDP3Instruction();
    BOOL Rule_ValidDP4Instruction();
    BOOL Rule_ValidInstructionPairing();
    BOOL Rule_ValidInstructionCount();             // Call per instruction AND after all instructions seen
    BOOL Rule_R0Written();                         // Call after all instructions seen.
        
public:
    CPShaderValidator10( const DWORD* pCode, const D3DCAPS8* pCaps, DWORD Flags );
};

//-----------------------------------------------------------------------------
// CPShaderValidator14
//-----------------------------------------------------------------------------
class CPShaderValidator14 : public CBasePShaderValidator
{
private:
    UINT            m_BlendOpCount;
    int             m_Phase; // 1 == dependent read setup block, 2 == second pass
    BOOL            m_bPhaseMarkerInShader; // shader is preprocessed to set this bool
    CPSInstruction* m_pPhaseMarkerInst; // only set at the moment marker is encountered in shader
    DWORD           m_TempRegsWithZappedAlpha; // bitmask of temp regs for which alpha was zapped
                                               // (initialized->uninitialized) after the phase marker
    DWORD           m_TempRegsWithZappedBlue;  // bitmask of temp regs for which blue was zapped
                                               // (initialized->uninitialized) due to texcrd with .rg writemask

    BOOL ApplyPerInstructionRules();
    void ApplyPostInstructionsRules();
    void IsCurrInstTexOp();
    BOOL InitValidation();

    BOOL Rule_InstructionRecognized();
    BOOL Rule_InstructionSupportedByVersion();
    BOOL Rule_ValidParamCount();
    BOOL Rule_ValidSrcParams(); 
    BOOL Rule_LimitedUseOfProjModifier(); 
    BOOL Rule_MultipleDependentTextureReads();
    BOOL Rule_SrcInitialized();
    BOOL Rule_ValidMarker();
    BOOL Rule_ValidDstParam();
    BOOL Rule_ValidRegisterPortUsage();
    BOOL Rule_ValidTexOpStageAndRegisterUsage();
    BOOL Rule_TexOpAfterArithmeticOp();
    BOOL Rule_ValidTEXDEPTHInstruction();
    BOOL Rule_ValidTEXKILLInstruction();
    BOOL Rule_ValidBEMInstruction();
    BOOL Rule_ValidDEFInstruction();
    BOOL Rule_ValidInstructionPairing();
    BOOL Rule_ValidInstructionCount();             // Call per instruction AND after all instructions seen
    BOOL Rule_R0Written();                         // Call after all instructions seen.
        
public:
    CPShaderValidator14( const DWORD* pCode, const D3DCAPS8* pCaps, DWORD Flags );
};


#endif __PSHDRVAL_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\shval\pshdrval.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// pshdrval.cpp
//
// Direct3D Reference Device - PixelShader validation
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

// Use these macros when looking at CPSInstruction derived members of the current instruction (CBaseInstruction)
#define _CURR_PS_INST   ((CPSInstruction*)m_pCurrInst)
#define _PREV_PS_INST   (m_pCurrInst?((CPSInstruction*)(m_pCurrInst->m_pPrevInst)):NULL)

//-----------------------------------------------------------------------------
// CPSInstruction::CalculateComponentReadMasks()
//
// Figure out which components of each source parameter is read by a pixelshader
// instruction.  For certain pixelshader instructions, the some components
// are also read from the dest parameter.
//
// Note: When this function is changed, the changes need to be ported to
// refrast's CalculateSourceReadMasks() function in rast\pshader.cpp
// (Though that function does not care about channels read from the dest parameter
//  like this one does).
//-----------------------------------------------------------------------------
void CPSInstruction::CalculateComponentReadMasks(DWORD dwVersion)
{
    UINT i, j;

    switch( m_Type ) // instructions that actually read from the *Destination* register...
    {
    case D3DSIO_TEXM3x2DEPTH:
    case D3DSIO_TEXDEPTH:
        m_DstParam.m_ComponentReadMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1;
        break;
    case D3DSIO_TEXKILL:
        if( (D3DPS_VERSION(1,4) == dwVersion) && (D3DSPR_TEMP == m_DstParam.m_RegType) )
        {
            // for ps.1.4, texkill on an r# register only reads rgb
            m_DstParam.m_ComponentReadMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2;
        }
        else
        {
            m_DstParam.m_ComponentReadMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2 | D3DSP_WRITEMASK_3;
        }
        break;
    }

    for( i = 0; i < m_SrcParamCount; i++ )
    {
        DWORD NeededComponents;
        DWORD ReadComponents = 0;

        switch( m_Type )
        {
        case D3DSIO_TEX:      // only in ps.1.4 does texld have source parameter
            if( D3DPS_VERSION(1,4) == dwVersion )
            {
                // for ps.1.4, texld has a source parameter
                NeededComponents = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2;
            }
            else // versions < ps.1.4 don't have a src param on tex, so we shouldn't get here.  But maybe in ps.2.0...
            {
                NeededComponents = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2 | D3DSP_WRITEMASK_3;
            }
            break;
        case D3DSIO_TEXCOORD:
            if( D3DPS_VERSION(1,4) == dwVersion )
            {
                // for ps.1.4, texcrd has a source parameter
                NeededComponents = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2;
            }
            else // versions < ps.1.4 don't have a src param on texcoord, so we shouldn't get here.  But maybe in ps.2.0...
            {
                NeededComponents = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2 | D3DSP_WRITEMASK_3;
            }
            break;
        case D3DSIO_TEXBEM:
        case D3DSIO_TEXBEML:
            NeededComponents = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1;
            break;
        case D3DSIO_DP3:
            NeededComponents = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2;
            break;
        case D3DSIO_DP4:
            NeededComponents = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2 | D3DSP_WRITEMASK_3;
            break;
        case D3DSIO_BEM: // ps.1.4
            NeededComponents = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1;
            break;
        default: 
            // standard component-wise instruction, 
            // OR an op we know reads .rgba and we also know it will be validated to .rgba writemask
            NeededComponents = m_DstParam.m_WriteMask;
            break;
        }

        // Figure out which components of this source parameter are read (taking into account swizzle)
        for(j = 0; j < 4; j++)
        {
            if( NeededComponents & COMPONENT_MASKS[j] )
                ReadComponents |= COMPONENT_MASKS[(m_SrcParam[i].m_SwizzleShift >> (D3DVS_SWIZZLE_SHIFT + 2*j)) & 0x3];
        }
        m_SrcParam[i].m_ComponentReadMask = ReadComponents;
    }
}

//-----------------------------------------------------------------------------
// CBasePShaderValidator::CBasePShaderValidator
//-----------------------------------------------------------------------------
CBasePShaderValidator::CBasePShaderValidator(   const DWORD* pCode,
                                        const D3DCAPS8* pCaps,
                                        DWORD Flags )
                                        : CBaseShaderValidator( pCode, pCaps, Flags )
{
    // Note that the base constructor initialized m_ReturnCode to E_FAIL.
    // Only set m_ReturnCode to S_OK if validation has succeeded,
    // before exiting this constructor.

    m_CycleNum              = 0;
    m_TexOpCount            = 0;
    m_BlendOpCount          = 0;
    m_TotalOpCount          = 0;

    m_pTempRegFile          = NULL;
    m_pInputRegFile         = NULL;
    m_pConstRegFile         = NULL;
    m_pTextureRegFile       = NULL;

    if( !m_bBaseInitOk )
        return;
}

//-----------------------------------------------------------------------------
// CBasePShaderValidator::~CBasePShaderValidator
//-----------------------------------------------------------------------------
CBasePShaderValidator::~CBasePShaderValidator()
{
    delete m_pTempRegFile;
    delete m_pInputRegFile;
    delete m_pConstRegFile;
    delete m_pTextureRegFile;
}

//-----------------------------------------------------------------------------
// CBasePShaderValidator::AllocateNewInstruction
//-----------------------------------------------------------------------------
CBaseInstruction* CBasePShaderValidator::AllocateNewInstruction(CBaseInstruction*pPrevInst)
{
    return new CPSInstruction((CPSInstruction*)pPrevInst);
}

//-----------------------------------------------------------------------------
// CBasePShaderValidator::DecodeNextInstruction
//-----------------------------------------------------------------------------
BOOL CBasePShaderValidator::DecodeNextInstruction()
{
    m_pCurrInst->m_Type = (D3DSHADER_INSTRUCTION_OPCODE_TYPE)(*m_pCurrToken & D3DSI_OPCODE_MASK);

    if( D3DSIO_COMMENT == m_pCurrInst->m_Type )
    {
        ParseCommentForAssemblerMessages(m_pCurrToken); // does not advance m_pCurrToken

        // Skip comments
        DWORD NumDWORDs = ((*m_pCurrToken) & D3DSI_COMMENTSIZE_MASK) >> D3DSI_COMMENTSIZE_SHIFT;
        m_pCurrToken += (NumDWORDs+1);
        return TRUE;
    }

    // Find out if the instruction is a TexOp and/or TexMOp.  Needed by multiple validation rules,
    // as well as further below in DecodeNextInstruction.
    IsCurrInstTexOp();

    // If the assembler has sent us file and/or line number messages,
    // received by ParseCommentForAssemblerMesssages(),
    // then bind this information to the current instruction.
    // This info can be used in error spew to direct the shader developer
    // to exactly where a problem is located.
    m_pCurrInst->SetSpewFileNameAndLineNumber(m_pLatestSpewFileName,m_pLatestSpewLineNumber);

    if( *m_pCurrToken & D3DSI_COISSUE )
    {
        _CURR_PS_INST->m_bCoIssue = TRUE;
    }
    else if( D3DSIO_NOP != m_pCurrInst->m_Type )
    {
        m_CycleNum++; // First cycle is 1. (co-issued instructions will have same cycle number)
    }
    _CURR_PS_INST->m_CycleNum = m_CycleNum;

    m_SpewInstructionCount++; // only used for spew, not for any limits
    m_pCurrInst->m_SpewInstructionCount = m_SpewInstructionCount;

    DWORD dwReservedBits = PS_INST_TOKEN_RESERVED_MASK;

    if( (*m_pCurrToken) & dwReservedBits )
    {
        Spew(SPEW_INSTRUCTION_ERROR,m_pCurrInst,"Reserved bit(s) set in instruction parameter token!  Aborting validation.");
        return FALSE;
    }

    m_pCurrToken++;

    // Decode dst param
    if (*m_pCurrToken & (1L<<31))
    {
        (m_pCurrInst->m_DstParamCount)++;
        DecodeDstParam( &m_pCurrInst->m_DstParam, *m_pCurrToken );
        if( (*m_pCurrToken) & PS_DSTPARAM_TOKEN_RESERVED_MASK )
        {
            Spew(SPEW_INSTRUCTION_ERROR,m_pCurrInst,"Reserved bit(s) set in destination parameter token!  Aborting validation.");
            return FALSE;
        }
        m_pCurrToken++;
        if( D3DSIO_DEF == m_pCurrInst->m_Type )
        {
            // Skip source params (float vector) - nothing to check
            // This is the only instruction with 4 source params,
            // and further, this is the only instruction that has
            // raw numbers as parameters.  This justifies the
            // special case treatment here - we pretend
            // D3DSIO_DEF only has a dst param (which we will check).
            m_pCurrToken += 4;
            return TRUE;
        }
    }

    // Decode src param(s)
    while (*m_pCurrToken & (1L<<31))
    {
        (m_pCurrInst->m_SrcParamCount)++;
        if( (m_pCurrInst->m_SrcParamCount + m_pCurrInst->m_DstParamCount) > SHADER_INSTRUCTION_MAX_PARAMS )
        {
            m_pCurrInst->m_SrcParamCount--;
            m_pCurrToken++; // eat up extra parameters and skip to next
            continue;
        }

        // Below: index is [SrcParamCount - 1] because m_SrcParam array needs 0 based index.
        DecodeSrcParam( &(m_pCurrInst->m_SrcParam[m_pCurrInst->m_SrcParamCount - 1]),*m_pCurrToken );

        if( (*m_pCurrToken) & PS_SRCPARAM_TOKEN_RESERVED_MASK )
        {
            Spew(SPEW_INSTRUCTION_ERROR,m_pCurrInst,"Reserved bit(s) set in source %d parameter token!  Aborting validation.",
                            m_pCurrInst->m_SrcParamCount);
            return FALSE;
        }
        m_pCurrToken++;
    }

    // Figure out which components of each source operand actually need to be read,
    // taking into account destination write mask, the type of instruction, source swizzle, etc.
    // (must be after IsCurrInstTexOp() )
    m_pCurrInst->CalculateComponentReadMasks(m_Version);

    return TRUE;
}

//-----------------------------------------------------------------------------
//
// CBasePShaderValidator Wrapper Functions
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// GetNewPSValidator
//
// Called by ValidatePixelShaderInternal and ValidatePixelShader below.
//-----------------------------------------------------------------------------
CBasePShaderValidator* GetNewPSValidator( const DWORD* pCode,
                                              const D3DCAPS8* pCaps,
                                              const DWORD Flags )
{
    if( !pCode )
        return NULL;
    else if( D3DPS_VERSION(1,4) > *pCode )
        return new CPShaderValidator10(pCode,pCaps,Flags);
    else
        return new CPShaderValidator14(pCode,pCaps,Flags);
}

//-----------------------------------------------------------------------------
// ValidatePixelShaderInternal
//-----------------------------------------------------------------------------
BOOL ValidatePixelShaderInternal( const DWORD* pCode, const D3DCAPS8* pCaps )
{
    CBasePShaderValidator * pValidator = NULL;
    BOOL bSuccess = FALSE;

    pValidator = GetNewPSValidator( pCode, pCaps, 0 );
    if( NULL == pValidator )
    {
        OutputDebugString("Out of memory.\n");
        return bSuccess;
    }
    bSuccess = SUCCEEDED(pValidator->GetStatus()) ? TRUE : FALSE;
    delete pValidator;
    return bSuccess;
}

//-----------------------------------------------------------------------------
// ValidatePixelShader
//
// Don't forget to call "free" on the buffer returned in ppBuf.
//-----------------------------------------------------------------------------
HRESULT WINAPI ValidatePixelShader( const DWORD* pCode,
                                    const D3DCAPS8* pCaps,
                                    const DWORD Flags,
                                    char** const ppBuf )
{
    CBasePShaderValidator * pValidator = NULL;
    HRESULT hr;

    pValidator = GetNewPSValidator( pCode, pCaps, Flags );
    if( NULL == pValidator )
    {
        OutputDebugString("Out of memory.\n");
        return E_FAIL;
    }
    if( ppBuf )
    {
        *ppBuf = (char*)HeapAlloc(GetProcessHeap(), 0, pValidator->GetRequiredLogBufferSize());
        if( NULL == *ppBuf )
            OutputDebugString("Out of memory.\n");
        else
            pValidator->WriteLogToBuffer(*ppBuf);
    }
    hr = pValidator->GetStatus();
    delete pValidator;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\shval\psval14.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// pshdrval.cpp
//
// Direct3D Reference Device - PixelShader validation
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

// Use these macros when looking at CPSInstruction derived members of the current instruction (CBaseInstruction)
#define _CURR_PS_INST   ((CPSInstruction*)m_pCurrInst)
#define _PREV_PS_INST   (m_pCurrInst?((CPSInstruction*)(m_pCurrInst->m_pPrevInst)):NULL)

#define SWIZZLE_XYZZ (D3DVS_X_X | D3DVS_Y_Y | D3DVS_Z_Z | D3DVS_W_Z)
#define SWIZZLE_XYZW (D3DVS_X_X | D3DVS_Y_Y | D3DVS_Z_Z | D3DVS_W_W)
#define SWIZZLE_XYWW (D3DVS_X_X | D3DVS_Y_Y | D3DVS_Z_W | D3DVS_W_W)

#define ZAPPED_ALPHA_TEXT   "Note that an unfortunate effect of the phase marker earlier in the shader is "\
                            "that the moment it is encountered in certain hardware, values previously "\
                            "written to alpha in any r# register, including the one noted here, are lost. "\
                            "In order to read alpha from an r# register after the phase marker, write to it first."

#define ZAPPED_ALPHA_TEXT2  "Note that an unfortunate effect of the phase marker in the shader is "\
                            "that the moment it is encountered in certain hardware, values previously "\
                            "written to alpha in any r# register, including r0, are lost. "\
                            "So after a phase marker, the alpha component of r0 must be written."

#define ZAPPED_BLUE_TEXT    "Note that when texcrd is used with a .xy(==.rg) writemask, "\
                            "as it is in this shader, a side effect is that anything previously "\
                            "written to the z(==b) component of the destination r# register is lost "\
                            "and this component becomes uninitialized. In order to read blue again, write to it first." 

#define ZAPPED_BLUE_TEXT2   "Note that when texcrd is used with a .xy(==.rg) writemask, "\
                            "as it is in this shader, a side effect is that anything previously "\
                            "written to the z(==b) component of the destination r# register is lost "\
                            "and this component becomes uninitialized. The blue component of r0 must to be written after the texcrd." 

//-----------------------------------------------------------------------------
// CPShaderValidator14::CPShaderValidator14
//-----------------------------------------------------------------------------
CPShaderValidator14::CPShaderValidator14(   const DWORD* pCode,
                                            const D3DCAPS8* pCaps,
                                            DWORD Flags )
                                           : CBasePShaderValidator( pCode, pCaps, Flags )
{
    // Note that the base constructor initialized m_ReturnCode to E_FAIL.
    // Only set m_ReturnCode to S_OK if validation has succeeded,
    // before exiting this constructor.

    m_Phase = 2; // default to second pass.
    m_pPhaseMarkerInst = NULL;
    m_bPhaseMarkerInShader = FALSE;
    m_TempRegsWithZappedAlpha = 0;
    m_TempRegsWithZappedBlue  = 0;

    if( !m_bBaseInitOk )
        return;

    ValidateShader(); // If successful, m_ReturnCode will be set to S_OK.
                      // Call GetStatus() on this object to determine validation outcome.
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::IsCurrInstTexOp
//-----------------------------------------------------------------------------
void CPShaderValidator14::IsCurrInstTexOp()
{
    DXGASSERT(m_pCurrInst);

    switch (m_pCurrInst->m_Type)
    {
    case D3DSIO_TEX:
    case D3DSIO_TEXCOORD:
    case D3DSIO_TEXKILL:
    case D3DSIO_TEXDEPTH:
        _CURR_PS_INST->m_bTexOp = TRUE;
        break;
    }

    switch(m_pCurrInst->m_Type)
    {
    case D3DSIO_TEXKILL:
    case D3DSIO_TEXDEPTH:
    case D3DSIO_TEXCOORD:
        _CURR_PS_INST->m_bTexOpThatReadsTexture = FALSE;
        break;
    case D3DSIO_TEX:
        _CURR_PS_INST->m_bTexOpThatReadsTexture = TRUE;
        break;
    }
}

#define MAX_NUM_STAGES_2_0  6        // #defined because there are dependencies.
//-----------------------------------------------------------------------------
// CPShaderValidator14::InitValidation
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::InitValidation()
{
    switch( m_Version >> 16 )
    {
    case 0xfffe:
        Spew( SPEW_GLOBAL_ERROR, NULL, "Version Token: 0x%x indicates a vertex shader.  Pixel shader version token must be of the form 0xffff****.",
                m_Version);
        return FALSE;
    case 0xffff:
        break; // pixelshader - ok.
    default:
        Spew( SPEW_GLOBAL_ERROR, NULL, "Version Token: 0x%x is invalid. Pixel shader version token must be of the form 0xffff****. Aborting pixel shader validation.",
                m_Version);
        return FALSE;
    }

    if( m_pCaps )
    {
        if( (m_pCaps->PixelShaderVersion & 0x0000FFFF) < (m_Version & 0x0000FFFF) )
        {
            Spew( SPEW_GLOBAL_ERROR, NULL, "Version Token: Pixel shader version %d.%d is too high for device.  Maximum supported version is %d.%d. Aborting shader validation.",
                    D3DSHADER_VERSION_MAJOR(m_Version),D3DSHADER_VERSION_MINOR(m_Version),
                    D3DSHADER_VERSION_MAJOR(m_pCaps->PixelShaderVersion),D3DSHADER_VERSION_MINOR(m_pCaps->PixelShaderVersion));
            return FALSE;
        }
    }

    switch(m_Version)
    {
    case D3DPS_VERSION(1,4):    // DX8.1
        m_pInputRegFile     = new CRegisterFile(2,FALSE,2,TRUE); // #regs, bWritable, max# reads/instruction, pre-shader initialized
        m_pConstRegFile     = new CRegisterFile(8,FALSE,2,TRUE);
        m_pTextureRegFile   = new CRegisterFile(MAX_NUM_STAGES_2_0,FALSE, 1,TRUE);
        m_pTempRegFile      = new CRegisterFile(MAX_NUM_STAGES_2_0,TRUE,3,FALSE);
        break;
    default:
        Spew( SPEW_GLOBAL_ERROR, NULL, "Version Token: %d.%d is not a supported pixel shader version. Aborting pixel shader validation.",
                D3DSHADER_VERSION_MAJOR(m_Version),D3DSHADER_VERSION_MINOR(m_Version));
        return FALSE;
    }
    if( NULL == m_pInputRegFile ||
        NULL == m_pConstRegFile ||
        NULL == m_pTextureRegFile ||
        NULL == m_pTempRegFile )
    {
        Spew( SPEW_GLOBAL_ERROR, NULL, "Out of memory.");
        return FALSE;
    }

    const DWORD* pCurrToken = m_pCurrToken;

    // Loop through all the instructions to see if a phase change marker is present.
    while( *pCurrToken != D3DPS_END() )
    {
        D3DSHADER_INSTRUCTION_OPCODE_TYPE Type = (D3DSHADER_INSTRUCTION_OPCODE_TYPE)(*pCurrToken & D3DSI_OPCODE_MASK);

        if( D3DSIO_COMMENT == Type )
        {
            // Skip comments
            DWORD NumDWORDs = ((*pCurrToken) & D3DSI_COMMENTSIZE_MASK) >> D3DSI_COMMENTSIZE_SHIFT;
            pCurrToken += (NumDWORDs+1);
            continue;
        }

        if( D3DSIO_PHASE == Type )
        {
            m_bPhaseMarkerInShader = TRUE;
            m_Phase = 1;
        }

        pCurrToken++;

        // Dst param
        if (*pCurrToken & (1L<<31))
        {
            pCurrToken++;
            if( D3DSIO_DEF == Type )
            {
                pCurrToken += 4;
                continue;
            }
        }

        // Decode src param(s)
        while (*pCurrToken & (1L<<31))
        {
            pCurrToken++;
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::ApplyPerInstructionRules
//
// Returns FALSE if shader validation must terminate.
// Returns TRUE if validation may proceed to next instruction.
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::ApplyPerInstructionRules()
{
    if( !   Rule_InstructionRecognized()            ) return FALSE;   // Bail completely on unrecognized instr.
    if( !   Rule_InstructionSupportedByVersion()    ) goto EXIT;
    if( !   Rule_ValidParamCount()                  ) goto EXIT;
    if( !   Rule_ValidMarker()                      ) goto EXIT; // must be before any rule that needs to know what the current phase is

   // Rules that examine source parameters
    if( !   Rule_ValidSrcParams()                   ) goto EXIT;
    if( !   Rule_MultipleDependentTextureReads()    ) goto EXIT; // needs to be after _ValidSrcParams(), and before _ValidDstParam(), _SrcInitialized()
    if( !   Rule_SrcInitialized()                   ) goto EXIT; // needs to be before _ValidDstParam()

    if( !   Rule_ValidDstParam()                    ) goto EXIT;
    if( !   Rule_ValidRegisterPortUsage()           ) goto EXIT;
    if( !   Rule_TexOpAfterArithmeticOp()           ) goto EXIT;
    if( !   Rule_ValidTexOpStageAndRegisterUsage()  ) goto EXIT;
    if( !   Rule_LimitedUseOfProjModifier()         ) goto EXIT;
    if( !   Rule_ValidTEXDEPTHInstruction()         ) goto EXIT;
    if( !   Rule_ValidTEXKILLInstruction()          ) goto EXIT;
    if( !   Rule_ValidBEMInstruction()              ) goto EXIT;
    if( !   Rule_ValidDEFInstruction()              ) goto EXIT;
    if( !   Rule_ValidInstructionPairing()          ) goto EXIT;
    if( !   Rule_ValidInstructionCount()            ) goto EXIT;
EXIT:
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::ApplyPostInstructionsRules
//-----------------------------------------------------------------------------
void CPShaderValidator14::ApplyPostInstructionsRules()
{
    Rule_ValidInstructionCount(); // see if we went over the limits
    Rule_R0Written();
}

//-----------------------------------------------------------------------------
//
// Per Instruction Rules
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_InstructionRecognized
//
// ** Rule:
// Is the instruction opcode known? (regardless of shader version)
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// FALSE when instruction not recognized.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_InstructionRecognized()
{
    switch(m_pCurrInst->m_Type)
    {
    case D3DSIO_MOV:
    case D3DSIO_ADD:
    case D3DSIO_SUB:
    case D3DSIO_MUL:
    case D3DSIO_MAD:
    case D3DSIO_LRP:
    case D3DSIO_DP3:
    case D3DSIO_TEX:
    case D3DSIO_TEXBEM:
    case D3DSIO_TEXBEML:
    case D3DSIO_CND:
    case D3DSIO_TEXCOORD:
    case D3DSIO_TEXM3x2PAD:
    case D3DSIO_TEXM3x2TEX:
    case D3DSIO_TEXM3x3PAD:
    case D3DSIO_TEXM3x3TEX:
    case D3DSIO_TEXM3x3SPEC:
    case D3DSIO_TEXM3x3VSPEC:
    case D3DSIO_TEXREG2AR:
    case D3DSIO_TEXREG2GB:
    case D3DSIO_TEXKILL:
    case D3DSIO_END:
    case D3DSIO_NOP:
    case D3DSIO_DEF:
    case D3DSIO_TEXM3x2DEPTH:
    case D3DSIO_TEXDP3:
    case D3DSIO_TEXREG2RGB:
    case D3DSIO_DP4:
    case D3DSIO_CMP:
    case D3DSIO_TEXDP3TEX:
    case D3DSIO_TEXM3x3:
    case D3DSIO_TEXDEPTH:
    case D3DSIO_BEM:
    case D3DSIO_PHASE:
        return TRUE; // instruction recognized - ok.
    }

    // if we get here, the instruction is not recognized
    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Unrecognized instruction. Aborting pixel shader validation.");
    m_ErrorCount++;
    return FALSE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_InstructionSupportedByVersion
//
// ** Rule:
// Is the instruction supported by the current pixel shader version?
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// FALSE when instruction not supported by version.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_InstructionSupportedByVersion()
{
    if( D3DPS_VERSION(1,4) <= m_Version ) // 1.3 and above
    {
        switch(m_pCurrInst->m_Type)
        {
        case D3DSIO_MOV:
        case D3DSIO_ADD:
        case D3DSIO_SUB:
        case D3DSIO_MUL:
        case D3DSIO_MAD:
        case D3DSIO_LRP:
        case D3DSIO_DP3:
        case D3DSIO_DEF:
        case D3DSIO_CND:
        case D3DSIO_CMP:
        case D3DSIO_DP4:
        case D3DSIO_BEM:
        case D3DSIO_TEX:
        case D3DSIO_TEXKILL:
        case D3DSIO_TEXDEPTH:
        case D3DSIO_TEXCOORD:
        case D3DSIO_PHASE:
            return TRUE; // instruction supported - ok.
        }
    }
    switch(m_pCurrInst->m_Type)
    {
    case D3DSIO_END:
    case D3DSIO_NOP:
        return TRUE; // instruction supported - ok.
    }

    // if we get here, the instruction is not supported.
    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Instruction not supported by version %d.%d pixel shader.",
                D3DSHADER_VERSION_MAJOR(m_Version),D3DSHADER_VERSION_MINOR(m_Version));
    m_ErrorCount++;
    return FALSE;  // no more checks on this instruction
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_ValidParamCount
//
// ** Rule:
// Is the parameter count correct for the instruction?
//
// DEF is a special case that is treated as having only 1 dest parameter,
// even though there are also 4 source parameters.  The 4 source params for DEF
// are immediate float values, so there is nothing to check, and no way of
// knowing whether or not those parameter tokens were actually present in the
// token list - all the validator can do is skip over 4 DWORDS (which it does).
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// FALSE when the parameter count is incorrect.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_ValidParamCount()
{
    BOOL bBadParamCount = FALSE;

    if (m_pCurrInst->m_SrcParamCount + m_pCurrInst->m_DstParamCount > SHADER_INSTRUCTION_MAX_PARAMS)  bBadParamCount = TRUE;
    switch (m_pCurrInst->m_Type)
    {
    case D3DSIO_NOP:
    case D3DSIO_PHASE:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 0) || (m_pCurrInst->m_SrcParamCount != 0); break;
    case D3DSIO_MOV:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 1); break;
    case D3DSIO_ADD:
    case D3DSIO_SUB:
    case D3DSIO_MUL:
    case D3DSIO_DP3:
    case D3DSIO_DP4:
    case D3DSIO_BEM:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 2); break;
    case D3DSIO_MAD:
    case D3DSIO_LRP:
    case D3DSIO_CND:
    case D3DSIO_CMP:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 3); break;
    case D3DSIO_TEXKILL:
    case D3DSIO_TEXDEPTH:
    case D3DSIO_DEF: // we skipped the last 4 parameters (float vector) - nothing to check
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 0); break;
    case D3DSIO_TEX:
    case D3DSIO_TEXCOORD:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 1); break;
    }

    if (bBadParamCount)
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid parameter count.");
        m_ErrorCount++;
        return FALSE;  // no more checks on this instruction
    }

    return TRUE;

}

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_ValidSrcParams
//
// ** Rule:
// for each source parameter,
//      if current instruction is a texture instruction, then
//          if texcrd, source register type must be t# (texture coordinate input) 
//          else source register type must be t# or r# (temp)
//          register number must be in range
//          _DZ and _DW are the only source modifiers allowed
//          no source selector allowed,
//          except texcrd/texld which can have: .xyz(==.xyzz), nothing(=.xyzw), and .xyw(=.xyww)
//      else (non texture instruction)
//          if in phase 1 of shader, v# registers not allowed
//          t# registers not allowed (only const or temp allowed)
//          register number must be in range
//          source modifier must be one of:
//                  _NONE/_NEG/_BIAS/_BIASNEG/_SIGN/_SIGNNEG/_X2/_X2NEG
//          source selector must be one of:
//                  _NOSWIZZLE/_REPLICATEALPHA/RED/GREEN/BLUE
//
// Note that the parameter count for D3DSIO_DEF is treated as 1
// (dest only), so this rule does nothing for it.
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
// Errors in any of the source parameters causes m_bSrcParamError[i]
// to be TRUE, so later rules that only apply when a particular source
// parameter was valid know whether they need to execute or not.
// e.g. Rule_SrcInitialized.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_ValidSrcParams()
{
    static DWORD s_TexcrdSrcSwizzle[MAX_NUM_STAGES_2_0];
    static BOOL  s_bSeenTexcrdSrcSwizzle[MAX_NUM_STAGES_2_0];

    if( NULL == m_pCurrInst->m_pPrevInst )   // First instruction - initialize static vars
    {
        for( UINT i = 0; i < MAX_NUM_STAGES_2_0; i++ )
            s_bSeenTexcrdSrcSwizzle[i] = FALSE;
    }

    for( UINT i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
    {
        BOOL bFoundSrcError = FALSE;
        SRCPARAM* pSrcParam = &(m_pCurrInst->m_SrcParam[i]);
        DWORD Swizzle = pSrcParam->m_SwizzleShift;
        char szSourceName[32];
        switch(i + 1)
        {
        case 1:
            if( 1 == m_pCurrInst->m_SrcParamCount )
                sprintf( szSourceName, "(Source param) " );
            else
                sprintf( szSourceName, "(First source param) " );
            break;
        case 2:
            sprintf( szSourceName, "(Second source param) " );
            break;
        case 3:
            sprintf( szSourceName, "(Third source param) " );
            break;
        default:
            DXGASSERT(FALSE);
        }
        if( _CURR_PS_INST->m_bTexOp )
        {
            UINT ValidRegNum = 0;
            switch (m_pCurrInst->m_Type)
            {
            case D3DSIO_TEXCOORD:
                if( D3DSPR_TEXTURE != pSrcParam->m_RegType )
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%sSource register type must be texture coordinate input (t#) for texcrd instruction.",
                            szSourceName);
                    m_ErrorCount++;
                    bFoundSrcError = TRUE;
                }
                ValidRegNum = m_pTextureRegFile->GetNumRegs(); break;
                break;
            default:
                switch(pSrcParam->m_RegType)
                {
                case D3DSPR_TEMP:       ValidRegNum = m_pTempRegFile->GetNumRegs(); break;
                case D3DSPR_TEXTURE:    ValidRegNum = m_pTextureRegFile->GetNumRegs(); break;
                default:
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%sSource register type must be temp (r#) or texture coordinate input (t#) for tex* instruction.",
                            szSourceName);
                    m_ErrorCount++;
                    bFoundSrcError = TRUE;
                    goto LOOP_CONTINUE;
                }
                break;
            }


            if( pSrcParam->m_RegNum >= ValidRegNum )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%sInvalid register number: %d.  Max allowed for this type is %d.",
                        szSourceName, pSrcParam->m_RegNum, ValidRegNum - 1);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }

            BOOL bGenericSrcModError = FALSE;
            switch(pSrcParam->m_SrcMod)
            {
            case D3DSPSM_NONE:
                break;
            case D3DSPSM_DZ:
                switch(m_pCurrInst->m_Type)
                {
                case D3DSIO_TEX: 
                    if( D3DSPR_TEMP != pSrcParam->m_RegType )
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "_dz(=_db) modifier on source param for texld only allowed if source is a temp register (r#)." );
                        m_ErrorCount++;
                        bFoundSrcError = TRUE;
                    }
                    if( 1 == m_Phase )
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "_dz(=_db) modifier on source param for texld only allowed in second phase of a shader.");
                        m_ErrorCount++;
                        bFoundSrcError = TRUE;
                    }
                    if( (SWIZZLE_XYZZ != Swizzle) &&
                        (SWIZZLE_XYZW != Swizzle) )
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "_dz(=_db) modifier on source param for texld must be paired with source selector .xyz(=.rgb). "\
                            "Note: Using no selector is treated same as .xyz here.");
                        m_ErrorCount++;
                        bFoundSrcError = TRUE;
                    }
                    break;
                case D3DSIO_TEXCOORD:
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "_dz(=_db) modifier cannot be used on source parameter for texcrd. "\
                            "It is only available to texld instruction, when source parameter is temp register (r#).");
                    m_ErrorCount++;
                    bFoundSrcError = TRUE;
                    break;
                default:
                    bGenericSrcModError = TRUE; break;
                }
                break;
            case D3DSPSM_DW:
                switch(m_pCurrInst->m_Type)
                {
                case D3DSIO_TEX: 
                    if( D3DSPR_TEXTURE != pSrcParam->m_RegType )
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "_dw(=_da) modifier on source param for texld only allowed if source is a texture coordinate register (t#)." );
                        m_ErrorCount++;
                        bFoundSrcError = TRUE;
                    }
                    // falling through
                case D3DSIO_TEXCOORD: 
                    if( SWIZZLE_XYWW != Swizzle )
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "_dw(=_da) modifier on source param must be paired with source selector .xyw(=.rga)." );
                        m_ErrorCount++;
                        bFoundSrcError = TRUE;
                    }
                    break;
                default:
                    bGenericSrcModError = TRUE; break;
                }
                break;
            default:
                bGenericSrcModError = TRUE; break;
            }
            if( bGenericSrcModError )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%sInvalid source modifier for tex* instruction.", szSourceName);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }

            switch (m_pCurrInst->m_Type)
            {
            case D3DSIO_TEXCOORD:
                if( (SWIZZLE_XYZZ != Swizzle) &&
                    (SWIZZLE_XYZW != Swizzle) &&
                    (SWIZZLE_XYWW != Swizzle) )
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                        "Source for texcrd requires component selector .xyw(==.rga), or .xyz(==.rgb). "\
                        "Note: Using no selector is treated same as .xyz here.");
                    m_ErrorCount++;
                    bFoundSrcError = TRUE;
                }
                break;
            case D3DSIO_TEX:
                if( D3DSPR_TEXTURE == pSrcParam->m_RegType )
                {                    
                if( (SWIZZLE_XYZZ != Swizzle) &&
                    (SWIZZLE_XYZW != Swizzle) &&
                    (SWIZZLE_XYWW != Swizzle) )
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "Using a texture coordinate register (t#) as source for texld requires component selector .xyw(=.rga), or .xyz(=.rgb). "\
                            "Note: Using no selector is treated same as .xyz here.");
                        m_ErrorCount++;
                        bFoundSrcError = TRUE;
                        
                    }
                }
                else if( D3DSPR_TEMP == pSrcParam->m_RegType )
                {
                    if( (SWIZZLE_XYZZ != Swizzle) &&
                        (SWIZZLE_XYZW != Swizzle) )
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "Using a temp register (r#) as source for texld requires component selector .xyz(==.rgb). "\
                            "Note: Using no selector is treated same as .xyz here.");
                        m_ErrorCount++;
                        bFoundSrcError = TRUE;
                    }
                }
                break;
            default:
                switch (pSrcParam->m_SwizzleShift)
                {
                case D3DSP_NOSWIZZLE:
                    break;
                default:
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%sInvalid source selector for tex* instruction.", szSourceName);
                    m_ErrorCount++;
                    bFoundSrcError = TRUE;
                }
                break;
            }

            switch(m_pCurrInst->m_Type)
            {
            case D3DSIO_TEXCOORD:
            case D3DSIO_TEX:
                if( D3DSPR_TEXTURE != pSrcParam->m_RegType )
                    break;

                // Verify that if a specific t# register is read more than once, each read uses the same source selector.
                if( s_bSeenTexcrdSrcSwizzle[pSrcParam->m_RegNum] )
                {
                    // only check rgb swizzle (ignore a)
                    if( (Swizzle & (0x3F << D3DVS_SWIZZLE_SHIFT)) != (s_TexcrdSrcSwizzle[pSrcParam->m_RegNum] & (0x3F << D3DVS_SWIZZLE_SHIFT) ))
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "Texture coordinate register t%d read more than once in shader with different source selector (swizzle). "\
                            "Multiple reads of identical texture coordinate register throughout shader must all use identical source selector. "\
                            "Note this does not restrict mixing use and non-use of a source modifier (i.e. _dw/_da or _dz/_db, depending what the swizzle allows) on these coordinate register reads.",
                            pSrcParam->m_RegNum);
                        m_ErrorCount++;
                        bFoundSrcError = TRUE;
                    }
                }
                s_bSeenTexcrdSrcSwizzle[pSrcParam->m_RegNum] = TRUE;
                s_TexcrdSrcSwizzle[pSrcParam->m_RegNum] = Swizzle;
                break;
            }

        }
        else // not a tex op
        {
            UINT ValidRegNum = 0;
            switch(pSrcParam->m_RegType)
            {
            case D3DSPR_INPUT:
                if( 1 == m_Phase )
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%sInput registers (v#) are not available in phase 1 of the shader.", szSourceName);
                    m_ErrorCount++;
                    bFoundSrcError = TRUE;
                }
                else
                {
                    ValidRegNum = m_pInputRegFile->GetNumRegs(); 
                }
                break;
            case D3DSPR_CONST:      ValidRegNum = m_pConstRegFile->GetNumRegs(); break;
            case D3DSPR_TEMP:       ValidRegNum = m_pTextureRegFile->GetNumRegs(); break;
            case D3DSPR_TEXTURE:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%sTexture coordinate registers (t#) are not available to arithmetic instructions.", szSourceName);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
                break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%sInvalid register type.", szSourceName);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }

            if( (!bFoundSrcError) && (pSrcParam->m_RegNum >= ValidRegNum) )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%sInvalid register number: %d. Max allowed for this type is %d.",
                    szSourceName, pSrcParam->m_RegNum, ValidRegNum - 1);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }

            switch( pSrcParam->m_SrcMod )
            {
            case D3DSPSM_NONE:
            case D3DSPSM_NEG:
            case D3DSPSM_BIAS:
            case D3DSPSM_BIASNEG:
            case D3DSPSM_SIGN:
            case D3DSPSM_SIGNNEG:
            case D3DSPSM_COMP:
            case D3DSPSM_X2:
            case D3DSPSM_X2NEG:
                break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%sInvalid source modifier.",
                                    szSourceName);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }

            switch( pSrcParam->m_SwizzleShift )
            {
            case D3DSP_NOSWIZZLE:
            case D3DSP_REPLICATERED:
            case D3DSP_REPLICATEGREEN:
            case D3DSP_REPLICATEBLUE:
            case D3DSP_REPLICATEALPHA:
                break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%sInvalid source selector.",
                                   szSourceName);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }
        }
LOOP_CONTINUE:
        if( bFoundSrcError )
        {
            m_bSrcParamError[i] = TRUE; // needed in Rule_SrcInitialized
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_LimitedUseOfProjModifier
//
// ** Rule:
// _dz may only appear at most 2 times in shader.
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_LimitedUseOfProjModifier()
{
    static UINT s_ProjZModifierCount;
    static BOOL s_bSpewedError;

    if( NULL == m_pCurrInst->m_pPrevInst )   // First instruction - initialize static vars
    {
        s_ProjZModifierCount = 0;
        s_bSpewedError = FALSE;
    }

    for( UINT i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
    {
        if( m_bSrcParamError[i] )
            continue;

        if( D3DSPSM_DZ == m_pCurrInst->m_SrcParam[i].m_SrcMod)
        {
            s_ProjZModifierCount++;
        }

        if( (2 < s_ProjZModifierCount) && (FALSE == s_bSpewedError)  )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "_dz(=_db) modifier may only be used at most 2 times in a shader." );
            s_bSpewedError = TRUE;
            m_ErrorCount++;
        }
    }
        
    return TRUE;    
}


//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_SrcInitialized
//
// ** Rule:
// for each source parameter,
//      if source is a TEMP register then
//          the components flagged in the component read mask
//          (computed elsewhere) for the paramter must have been initialized
//
// When checking if a component has been written previously,
// it must have been written in a previous cycle - so in the
// case of co-issued instructions, initialization of a component
// by one co-issued instruction is not available to the other for read.
//
// ** When to call:
// Per instruction. This rule must be called before Rule_ValidDstParam().
//
// ** Returns:
// Always TRUE.
//
// NOTE: This rule also updates the access history to indicate reads of the
// affected components of each source register.
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_SrcInitialized()
{
    DSTPARAM* pDstParam = &(m_pCurrInst->m_DstParam);

    BOOL bDestParamIsSrc = pDstParam->m_ComponentReadMask;
    UINT SrcParamCount = bDestParamIsSrc ? 1 : m_pCurrInst->m_SrcParamCount; // assumes if dest param is src, 
                                                                             // there are no source params in instruction
    for( UINT i = 0; i < SrcParamCount; i++ )
    {
        DWORD UninitializedComponentsMask = 0;
        CAccessHistoryNode* pWriterInCurrCycle[4] = {0, 0, 0, 0};
        UINT NumUninitializedComponents = 0;
        UINT RegNum = bDestParamIsSrc ? pDstParam->m_RegNum : m_pCurrInst->m_SrcParam[i].m_RegNum;
        D3DSHADER_PARAM_REGISTER_TYPE Type = bDestParamIsSrc ? pDstParam->m_RegType : m_pCurrInst->m_SrcParam[i].m_RegType;
        DWORD ComponentReadMask = bDestParamIsSrc ? pDstParam->m_ComponentReadMask : m_pCurrInst->m_SrcParam[i].m_ComponentReadMask;
        CRegisterFile* pRegFile = NULL;
        char* RegChar = NULL;

        if( !bDestParamIsSrc && m_bSrcParamError[i] ) 
            continue;

        switch( Type ) 
        {
            case D3DSPR_TEMP:
                pRegFile = m_pTempRegFile;
                RegChar = "r";
                break;
            case D3DSPR_TEXTURE:
                pRegFile = m_pTextureRegFile;
                RegChar = "t";
                break;
            case D3DSPR_INPUT:
                pRegFile = m_pInputRegFile;
                RegChar = "v";
                break;
            case D3DSPR_CONST:
                pRegFile = m_pConstRegFile;
                RegChar = "c";
                break;
        }
        if( !pRegFile ) 
            continue;

        if( RegNum >= pRegFile->GetNumRegs() )
            continue;

        // check for read of uninitialized components
        if( D3DSPR_TEMP == Type ) // only bother doing this for temp regs, since everything else is initialized.
        {
            for( UINT Component = 0; Component < 4; Component++ )
            {
                if( !(ComponentReadMask & COMPONENT_MASKS[Component]) )
                    continue;

                CAccessHistoryNode* pPreviousWriter = pRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                CBaseInstruction* pCurrInst = m_pCurrInst;

                // If co-issue, find the real previous writer.
                while( pPreviousWriter
                       && ((CPSInstruction*)pPreviousWriter->m_pInst)->m_CycleNum == _CURR_PS_INST->m_CycleNum )
                {
                    pWriterInCurrCycle[Component] = pPreviousWriter; // log read just before this write for co-issue
                    pPreviousWriter = pPreviousWriter->m_pPreviousWriter;
                }

                // Even if pPreviousWriter == NULL, the component could have been initialized pre-shader.
                // So to check for initialization, we look at m_bInitialized below, rather than pPreviousWrite
                if(pPreviousWriter == NULL && !pRegFile->m_pAccessHistory[Component][RegNum].m_bPreShaderInitialized)
                {
                    NumUninitializedComponents++;
                    UninitializedComponentsMask |= COMPONENT_MASKS[Component];
                }
            }

            if( NumUninitializedComponents )
            {
                if( (UninitializedComponentsMask & COMPONENT_MASKS[3]) && 
                    (m_TempRegsWithZappedAlpha & (1 << RegNum ) ) &&
                    (UninitializedComponentsMask & COMPONENT_MASKS[2]) && 
                    (m_TempRegsWithZappedBlue & (1 << RegNum ) ) )
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Read of uninitialized component%s(*) in %s%d: %s. "\
                        ZAPPED_BLUE_TEXT " Also: " ZAPPED_ALPHA_TEXT,
                        NumUninitializedComponents > 1 ? "s" : "",
                        RegChar, RegNum, MakeAffectedComponentsText(UninitializedComponentsMask,TRUE,TRUE));
                } 
                else if( (UninitializedComponentsMask & COMPONENT_MASKS[3]) && 
                    (m_TempRegsWithZappedAlpha & (1 << RegNum ) ) )
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Read of uninitialized component%s(*) in %s%d: %s. "\
                        ZAPPED_ALPHA_TEXT,
                        NumUninitializedComponents > 1 ? "s" : "",
                        RegChar, RegNum, MakeAffectedComponentsText(UninitializedComponentsMask,TRUE,TRUE));
                } 
                else if( (UninitializedComponentsMask & COMPONENT_MASKS[2]) && 
                    (m_TempRegsWithZappedBlue & (1 << RegNum ) ) )
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Read of uninitialized component%s(*) in %s%d: %s. "\
                        ZAPPED_BLUE_TEXT,
                        NumUninitializedComponents > 1 ? "s" : "",
                        RegChar, RegNum, MakeAffectedComponentsText(UninitializedComponentsMask,TRUE,TRUE));
                } 
                else
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Read of uninitialized component%s(*) in %s%d: %s",
                        NumUninitializedComponents > 1 ? "s" : "",
                        RegChar, RegNum, MakeAffectedComponentsText(UninitializedComponentsMask,TRUE,TRUE));
                }

                m_ErrorCount++;
            }
        }

        // Update register file to indicate READ.
        // Multiple reads of the same register component by the current instruction
        // will only be logged as one read in the access history.

        for( UINT Component = 0; Component < 4; Component++ )
        {
            #define PREV_READER(_CHAN,_REG) \
                    ((NULL == pRegFile->m_pAccessHistory[_CHAN][_REG].m_pMostRecentReader) ? NULL :\
                    pRegFile->m_pAccessHistory[_CHAN][_REG].m_pMostRecentReader->m_pInst)

            if( !(ComponentReadMask & COMPONENT_MASKS[Component]) )
                continue;

            if( NULL != pWriterInCurrCycle[Component] )
            {
                if( !pWriterInCurrCycle[Component]->m_pPreviousReader ||
                    pWriterInCurrCycle[Component]->m_pPreviousReader->m_pInst != m_pCurrInst )
                {
                    if( !pRegFile->m_pAccessHistory[Component][RegNum].InsertReadBeforeWrite(
                                            pWriterInCurrCycle[Component], m_pCurrInst ) )
                    {
                        Spew( SPEW_GLOBAL_ERROR, NULL, "Out of memory");
                        m_ErrorCount++;
                    }
                }
            }
            else if( PREV_READER(Component,RegNum) != m_pCurrInst )
            {
                if( !pRegFile->m_pAccessHistory[Component][RegNum].NewAccess(m_pCurrInst,FALSE) )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Out of memory");
                    m_ErrorCount++;
                }
            }
        }
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_MultipleDependentTextureReads
//
// ** Rule:
//
// Multiple dependent texture reads are disallowed.  So texture read results
// can be used as an address in a subsequent read, but the results from that
// second read cannot be used as an address in yet another subsequent read.
//
// As pseudocode:
//
// if current instruction (x) is a tex-op that reads a texture
//     for each source param of x
//         if the register is a texture register
//         and there exists a previous writer (y),
//         and y is a tex op that reads a texture
//         if there exists a souce parameter of y that was previously
//              written by an instruction that reads a texture (z)
//              SPEW(Error)
//
// NOTE that it is assumed that tex ops must write to all components, so
// only the read/write history for the R component is being checked.
//
// ** When to call:
// Per instruction. This rule must be called before Rule_ValidDstParam(),
//                  and Rule_SrcInitialized()
//                  but after Rule_ValidSrcParams()
//
// ** Returns:
// Always TRUE.
//
BOOL CPShaderValidator14::Rule_MultipleDependentTextureReads()
{
    DSTPARAM* pDstParam = &(m_pCurrInst->m_DstParam);
    UINT DstRegNum = pDstParam->m_RegNum;
    char RegChar;
    #define THREE_TUPLE 3

    if( !_CURR_PS_INST->m_bTexOp )
        return TRUE;

    BOOL bDestParamIsSrc = pDstParam->m_ComponentReadMask;

    UINT SrcParamCount = bDestParamIsSrc ? 1 : m_pCurrInst->m_SrcParamCount; // assumes if dest param is src, 
                                                                             // there are no source params in instruction
    if( D3DSPR_TEMP != pDstParam->m_RegType )
        return TRUE;

    for( UINT SrcParam = 0; SrcParam < SrcParamCount; SrcParam++ ) 
    {
        
        if( !bDestParamIsSrc && m_bSrcParamError[SrcParam] ) 
            continue;

        SRCPARAM* pSrcParam = bDestParamIsSrc ? NULL : &(m_pCurrInst->m_SrcParam[SrcParam]);
        UINT SrcRegNum = bDestParamIsSrc ? DstRegNum : pSrcParam->m_RegNum;
        CRegisterFile* pSrcRegFile = NULL;

        switch( bDestParamIsSrc ? pDstParam->m_RegType : pSrcParam->m_RegType ) 
        {
            case D3DSPR_TEMP:
                pSrcRegFile = m_pTempRegFile;
                RegChar = 'r';
                break;
            case D3DSPR_TEXTURE:
                pSrcRegFile = m_pTextureRegFile;
                RegChar = 't';
                break;
        }
        if( !pSrcRegFile ) 
            continue;

        if( SrcRegNum >= pSrcRegFile->GetNumRegs() )
            continue;

        for( UINT SrcComp = 0; SrcComp < THREE_TUPLE; SrcComp++ ) // Tex ops only read 3-tuples.
        {
            CAccessHistoryNode* pPreviousWriter = pSrcRegFile->m_pAccessHistory[SrcComp][SrcRegNum].m_pMostRecentWriter;
            CPSInstruction* pInst = pPreviousWriter ? (CPSInstruction*)pPreviousWriter->m_pInst : NULL;

            if( !pInst || !pInst->m_bTexOp )
                continue;

            // If the previous writer was in the current phase of the shader, spew an error.
            if( !m_pPhaseMarkerInst || (pInst->m_CycleNum > m_pPhaseMarkerInst->m_CycleNum) )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                    "The current tex* instruction reads from %c%d, which was written earlier by another "\
                    "tex* instruction in the same block of tex* instructions.  Dependent reads "\
                    "are not permitted within a single block of tex* instructions.  To perform a dependent read, "\
                    "separate texture coordinate derivation from the tex* instruction using the coordinates "\
                    "with a 'phase' marker.", 
                    RegChar,SrcRegNum );

                m_ErrorCount++;

                return TRUE; // Lets only spew this warning once per instruction.
            }
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_ValidDstParam
//
// ** Rule:
// I instruction is D3DSIO_DEF, then do nothing - this case has its own separate rule
// The dst register must be writable.
// If the instruction has a dest parameter (i.e. every instruction except NOP), then
//      the dst register must be of type D3DSPR_TEXTURE, and
//      register # must be within range
//      if instruction is a texture instruction, then
//          the dst register must be of type D3DSPR_TEMP, and
//          the writemask must be D3DSP_WRITEMASK_ALL 
//             or (.rgb for texcrd, .rg for texcrd with _dw source mod), and
//          the dst modifier must be D3DSPDM_NONE (or _SAT on version > 1.1), and
//          the dst shift must be none
//      else (non tex instruction)
//          the dst modifier must be D3DSPDM_NONE or _SATURATE, and
//          dst shift must be /2, none, *2, or *4
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
// NOTE: After checking the dst parameter, if no error was found,
// the write to the appropriate component(s) of the destination register
// is recorded by this function, so subsequent rules may check for previous
// write to registers.
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_ValidDstParam() // could break this down for more granularity
{
    BOOL   bFoundDstError = FALSE;
    DSTPARAM* pDstParam = &(m_pCurrInst->m_DstParam);
    UINT RegNum = pDstParam->m_RegNum;
    if( D3DSIO_DEF == m_pCurrInst->m_Type )
    {
        // _DEF is a special instruction whose dest is a const register.
        // We do the checking for this in a separate function.
        // Also, we don't need to keep track of the fact that
        // this instruction wrote to a register (done below),
        // since _DEF just declares a constant.
        return TRUE;
    }

    if( pDstParam->m_bParamUsed )
    {
        UINT ValidRegNum = 0;
        BOOL bWritingToDest = TRUE;

        switch( pDstParam->m_RegType )
        {
        case D3DSPR_TEMP:
            ValidRegNum = m_pTempRegFile->GetNumRegs();
            break;
        case D3DSPR_TEXTURE:
            ValidRegNum = m_pTempRegFile->GetNumRegs();
            break;
        }

        if( D3DSIO_TEXKILL == m_pCurrInst->m_Type )
        {
            bWritingToDest = FALSE;
        }

        if( 0 == ValidRegNum ||
            (D3DSPR_TEXTURE == pDstParam->m_RegType && bWritingToDest) )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid register type for destination param." );
            m_ErrorCount++;
            bFoundDstError = TRUE;
        } 
        else if( RegNum >= ValidRegNum )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid destination register number: %d. Max allowed for this register type is %d.",
                RegNum, ValidRegNum - 1);
            m_ErrorCount++;
            bFoundDstError = TRUE;
        }

        if( _CURR_PS_INST->m_bTexOp )
        {
            switch( m_pCurrInst->m_Type )
            {
            case D3DSIO_TEXCOORD:
                if( D3DSPSM_DW == m_pCurrInst->m_SrcParam[0].m_SrcMod )
                {
                    if( (D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1) != pDstParam->m_WriteMask )
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "texcrd with _dw(=_da) source modifier must use .xy(=.rg) destination writemask.");
                        m_ErrorCount++;
                        bFoundDstError = TRUE;
                    }
                }
                else
                {
                    if( (D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2) != pDstParam->m_WriteMask )
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "texcrd must use .xyz(=.rgb) destination writemask.");
                        m_ErrorCount++;
                        bFoundDstError = TRUE;
                    }
                }
                break;
            case D3DSIO_TEX:
            case D3DSIO_TEXKILL:
            case D3DSIO_TEXDEPTH:
                if( D3DSP_WRITEMASK_ALL != pDstParam->m_WriteMask )
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "texld/texkill/texdepth instructions must write all components." );
                    m_ErrorCount++;
                    bFoundDstError = TRUE;
                }
                break;
            }
            switch( pDstParam->m_DstMod )
            {
            case D3DSPDM_NONE:
                break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Instruction modifiers not allowed for tex* instructions." );
                m_ErrorCount++;
                bFoundDstError = TRUE;
            }
            switch( pDstParam->m_DstShift )
            {
            case DSTSHIFT_NONE:
                break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Destination shift not allowed for tex* instructions." );
                m_ErrorCount++;
                bFoundDstError = TRUE;
            }
        }
        else
        {
            switch( pDstParam->m_DstMod )
            {
            case D3DSPDM_NONE:
            case D3DSPDM_SATURATE:
                break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid instruction modifier." );
                m_ErrorCount++;
                bFoundDstError = TRUE;
            }

            switch( pDstParam->m_DstShift )
            {
            case DSTSHIFT_NONE:
            case DSTSHIFT_X2:
            case DSTSHIFT_X4:
            case DSTSHIFT_X8:
            case DSTSHIFT_D2:
            case DSTSHIFT_D4:
            case DSTSHIFT_D8:
                break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid destination shift." );
                m_ErrorCount++;
                bFoundDstError = TRUE;
            }
        }

        // Update register file to indicate write.
        if( !bFoundDstError && bWritingToDest)
        {
            CRegisterFile* pRegFile = NULL;
            DWORD WriteMask = pDstParam->m_WriteMask;

            switch( pDstParam->m_RegType )
            {
            case D3DSPR_TEMP:    pRegFile = m_pTempRegFile; break;
            }

            if( pRegFile )
            {
                if( WriteMask & D3DSP_WRITEMASK_0 )
                    pRegFile->m_pAccessHistory[0][RegNum].NewAccess(m_pCurrInst,TRUE);

                if( WriteMask & D3DSP_WRITEMASK_1 )
                    pRegFile->m_pAccessHistory[1][RegNum].NewAccess(m_pCurrInst,TRUE);

                if( WriteMask & D3DSP_WRITEMASK_2 )
                    pRegFile->m_pAccessHistory[2][RegNum].NewAccess(m_pCurrInst,TRUE);
                else if( D3DSIO_TEXCOORD == m_pCurrInst->m_Type ) 
                {
                    // texcrd without b writemask uninitializes b channel.
                    // alpha also gets uninitialized, but phase marker alpha-nuke takes care of that anyway,
                    // and if the texcrd was in the first phase, noone could have written to the register
                    // so there would be nothing to nuke.
                    if( pRegFile->m_pAccessHistory[2][RegNum].m_pMostRecentWriter )
                    {
                        m_pTempRegFile->m_pAccessHistory[2][RegNum].~CAccessHistory();
                        m_pTempRegFile->m_pAccessHistory[2][RegNum].CAccessHistory::CAccessHistory();
                        m_TempRegsWithZappedBlue |= 1 << RegNum;
                    }
                }
                    
                if( WriteMask & D3DSP_WRITEMASK_3 )
                    pRegFile->m_pAccessHistory[3][RegNum].NewAccess(m_pCurrInst,TRUE);
            }
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_ValidRegisterPortUsage
//
// ** Rule:
// Each register class (TEXTURE,INPUT,CONST) may only appear as parameters
// in an individual instruction up to a maximum number of times.
//
// Multiple accesses to the same register number (in the same register class)
// only count as one access.
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_ValidRegisterPortUsage()
{
    UINT i, j;
    UINT TempRegPortUsage[SHADER_INSTRUCTION_MAX_SRCPARAMS];
    UINT InputRegPortUsage[SHADER_INSTRUCTION_MAX_SRCPARAMS];
    UINT ConstRegPortUsage[SHADER_INSTRUCTION_MAX_SRCPARAMS];
    UINT TextureRegPortUsage[SHADER_INSTRUCTION_MAX_SRCPARAMS];
    UINT NumUniqueTempRegs = 0;
    UINT NumUniqueInputRegs = 0;
    UINT NumUniqueConstRegs = 0;
    UINT NumUniqueTextureRegs = 0;
    D3DSHADER_PARAM_REGISTER_TYPE   RegType;
    UINT                            RegNum;

    static UINT s_TempRegPortUsageAcrossCoIssue[SHADER_INSTRUCTION_MAX_SRCPARAMS*2];
    static UINT s_InputRegPortUsageAcrossCoIssue[SHADER_INSTRUCTION_MAX_SRCPARAMS*2];
    static UINT s_ConstRegPortUsageAcrossCoIssue[SHADER_INSTRUCTION_MAX_SRCPARAMS*2];
    static UINT s_TextureRegPortUsageAcrossCoIssue[SHADER_INSTRUCTION_MAX_SRCPARAMS*2];
    static UINT s_NumUniqueTempRegsAcrossCoIssue;
    static UINT s_NumUniqueInputRegsAcrossCoIssue;
    static UINT s_NumUniqueConstRegsAcrossCoIssue;
    static UINT s_NumUniqueTextureRegsAcrossCoIssue;
 
    if( NULL == m_pCurrInst->m_pPrevInst )   // First instruction - initialize static vars
    {
        s_NumUniqueTempRegsAcrossCoIssue = 0;
        s_NumUniqueInputRegsAcrossCoIssue = 0;
        s_NumUniqueConstRegsAcrossCoIssue = 0;
        s_NumUniqueTextureRegsAcrossCoIssue = 0;
    }
 
    for( i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
    {
        UINT*   pRegPortUsage = NULL;
        UINT*   pNumUniqueRegs = NULL;

        RegType = m_pCurrInst->m_SrcParam[i].m_RegType;
        RegNum = m_pCurrInst->m_SrcParam[i].m_RegNum;

        switch( RegType )
        {
        case D3DSPR_TEMP:
            pRegPortUsage = TempRegPortUsage;
            pNumUniqueRegs = &NumUniqueTempRegs;
            break;
        case D3DSPR_INPUT:
            pRegPortUsage = InputRegPortUsage;
            pNumUniqueRegs = &NumUniqueInputRegs;
            break;
        case D3DSPR_CONST:
            pRegPortUsage = ConstRegPortUsage;
            pNumUniqueRegs = &NumUniqueConstRegs;
            break;
        case D3DSPR_TEXTURE:
            pRegPortUsage = TextureRegPortUsage;
            pNumUniqueRegs = &NumUniqueTextureRegs;
            break;
        }

        if( !pRegPortUsage ) continue;

        BOOL    bRegAlreadyAccessed = FALSE;
        for( j = 0; j < *pNumUniqueRegs; j++ )
        {
            if( pRegPortUsage[j] == RegNum )
            {
                bRegAlreadyAccessed = TRUE;
                break;
            }
        }
        if( !bRegAlreadyAccessed )
        {
            pRegPortUsage[*pNumUniqueRegs] = RegNum;
            (*pNumUniqueRegs)++;
        }

    }

    if( NumUniqueTempRegs > m_pTempRegFile->GetNumReadPorts() )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%d different temp registers (r#) read by instruction.  Max. different temp registers readable per instruction is %d.",
                        NumUniqueTempRegs,  m_pTempRegFile->GetNumReadPorts());
        m_ErrorCount++;
    }

    if( NumUniqueInputRegs > m_pInputRegFile->GetNumReadPorts() )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%d different input registers (v#) read by instruction.  Max. different input registers readable per instruction is %d.",
                        NumUniqueInputRegs,  m_pInputRegFile->GetNumReadPorts());
        m_ErrorCount++;
    }

    if( NumUniqueConstRegs > m_pConstRegFile->GetNumReadPorts() )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%d different constant registers (c#) read by instruction.  Max. different constant registers readable per instruction is %d.",
                        NumUniqueConstRegs, m_pConstRegFile->GetNumReadPorts());
        m_ErrorCount++;
    }

    if( NumUniqueTextureRegs > m_pTextureRegFile->GetNumReadPorts() )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%d different texture coordinate registers (t#) read by instruction.  Max. different texture registers readable per instruction is %d.",
                        NumUniqueTextureRegs, m_pTextureRegFile->GetNumReadPorts());
        m_ErrorCount++;
    }

    // Read port limit for different register numbers of any one register type across co-issued instructions is MAX_READPORTS_ACROSS_COISSUE total.

    if( _CURR_PS_INST->m_bCoIssue && _PREV_PS_INST && !(_PREV_PS_INST->m_bCoIssue)) // second 2 clauses are just a simple sanity check -> co-issue only involved 2 instructions.
    {
        for( i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
        {
            UINT*   pRegPortUsageAcrossCoIssue = NULL;
            UINT*   pNumUniqueRegsAcrossCoIssue = NULL;

            RegType = m_pCurrInst->m_SrcParam[i].m_RegType;
            RegNum = m_pCurrInst->m_SrcParam[i].m_RegNum;

            switch( RegType )
            {
            case D3DSPR_TEMP:
                pRegPortUsageAcrossCoIssue = s_TempRegPortUsageAcrossCoIssue;
                pNumUniqueRegsAcrossCoIssue = &s_NumUniqueTempRegsAcrossCoIssue;
                break;
            case D3DSPR_INPUT:
                pRegPortUsageAcrossCoIssue = s_InputRegPortUsageAcrossCoIssue;
                pNumUniqueRegsAcrossCoIssue = &s_NumUniqueInputRegsAcrossCoIssue;
                break;
            case D3DSPR_CONST:
                pRegPortUsageAcrossCoIssue = s_ConstRegPortUsageAcrossCoIssue;
                pNumUniqueRegsAcrossCoIssue = &s_NumUniqueConstRegsAcrossCoIssue;
                break;
            case D3DSPR_TEXTURE:
                pRegPortUsageAcrossCoIssue = s_TextureRegPortUsageAcrossCoIssue;
                pNumUniqueRegsAcrossCoIssue = &s_NumUniqueTextureRegsAcrossCoIssue;
                break;
            }

            if( !pRegPortUsageAcrossCoIssue ) continue;

            BOOL    bRegAlreadyAccessed = FALSE;
            for( j = 0; j < *pNumUniqueRegsAcrossCoIssue; j++ )
            {
                if( pRegPortUsageAcrossCoIssue[j] == RegNum )
                {
                    bRegAlreadyAccessed = TRUE;
                    break;
                }
            }
            if( !bRegAlreadyAccessed )
            {
                pRegPortUsageAcrossCoIssue[*pNumUniqueRegsAcrossCoIssue] = RegNum;
                (*pNumUniqueRegsAcrossCoIssue)++;
            }
        }

        #define MAX_READPORTS_ACROSS_COISSUE    3

        if( s_NumUniqueTempRegsAcrossCoIssue > MAX_READPORTS_ACROSS_COISSUE )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "%d different temp registers (r#) read over 2 co-issued instructions. "\
                            "Max. different register numbers from any one register type readable across co-issued instructions is %d.",
                            s_NumUniqueTempRegsAcrossCoIssue, MAX_READPORTS_ACROSS_COISSUE);
            m_ErrorCount++;
        }

        if( s_NumUniqueInputRegsAcrossCoIssue > MAX_READPORTS_ACROSS_COISSUE )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "%d different input registers (v#) read over 2 co-issued instructions. "\
                            "Max. different register numbers from any one register type readable across co-issued instructions is %d.",
                            s_NumUniqueInputRegsAcrossCoIssue, MAX_READPORTS_ACROSS_COISSUE);
            m_ErrorCount++;
        }

        if( s_NumUniqueConstRegsAcrossCoIssue > MAX_READPORTS_ACROSS_COISSUE )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "%d different constant registers (c#) read over 2 co-issued instructions. "\
                            "Max. different register numbers from any one register type readable across co-issued instructions is %d.",
                            s_NumUniqueConstRegsAcrossCoIssue, MAX_READPORTS_ACROSS_COISSUE);
            m_ErrorCount++;
        }

        if( s_NumUniqueTextureRegsAcrossCoIssue > MAX_READPORTS_ACROSS_COISSUE )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "%d different texture coordinate registers (t#) read over 2 co-issued instructions. "\
                            "Max. different register numbers from any one register type readable across co-issued instructions is %d.",
                            s_NumUniqueTextureRegsAcrossCoIssue, MAX_READPORTS_ACROSS_COISSUE);
            m_ErrorCount++;
        }
    }

    if( !_CURR_PS_INST->m_bCoIssue )
    {
        // Copy all state to static vars so that in case next instruction is co-issued with this one, 
        // cross-coissue read port limit of 3 can be enforced.
        memcpy(&s_TempRegPortUsageAcrossCoIssue,&TempRegPortUsage,NumUniqueTempRegs*sizeof(UINT));
        memcpy(&s_InputRegPortUsageAcrossCoIssue,&InputRegPortUsage,NumUniqueInputRegs*sizeof(UINT));
        memcpy(&s_ConstRegPortUsageAcrossCoIssue,&ConstRegPortUsage,NumUniqueConstRegs*sizeof(UINT));
        memcpy(&s_TextureRegPortUsageAcrossCoIssue,&TextureRegPortUsage,NumUniqueTextureRegs*sizeof(UINT));
        s_NumUniqueTempRegsAcrossCoIssue = NumUniqueTempRegs;
        s_NumUniqueInputRegsAcrossCoIssue = NumUniqueInputRegs;
        s_NumUniqueConstRegsAcrossCoIssue = NumUniqueConstRegs;
        s_NumUniqueTextureRegsAcrossCoIssue = NumUniqueTextureRegs;
    }
    else
    {
        // reset counts because the next instruction cannot be co-issued with this one.
        s_NumUniqueTempRegsAcrossCoIssue = 0;
        s_NumUniqueInputRegsAcrossCoIssue = 0;
        s_NumUniqueConstRegsAcrossCoIssue = 0;
        s_NumUniqueTextureRegsAcrossCoIssue = 0;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_ValidTexOpStageAndRegisterUsage
//
// ** Rule:
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_ValidTexOpStageAndRegisterUsage()
{
    static DWORD s_RegUsed; // bitfield representing if a retister has been used as a destination in this block of tex ops.

    if( NULL == m_pCurrInst->m_pPrevInst )   // First instruction - initialize static vars
    {
        s_RegUsed = 0;
    }
    else if( D3DSIO_PHASE == m_pCurrInst->m_Type )
    {
        s_RegUsed = 0;
    }

    if( !_CURR_PS_INST->m_bTexOp )
        return TRUE;

    if( D3DSPR_TEMP != m_pCurrInst->m_DstParam.m_RegType )
        return TRUE;

    UINT RegNum = m_pCurrInst->m_DstParam.m_RegNum;
    if( RegNum >= m_pTempRegFile->GetNumRegs() )
        return TRUE; // error spewed elsewhere

    if( s_RegUsed & (1<<RegNum) )
    {
        if( 1 == m_Phase )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                  "Register r%d (and thus texture stage %d) already used as a destination for a tex* instruction in this block of the shader. "\
                  "Second use of this register as a tex* destination is only available after the phase marker. ",
                  RegNum, RegNum );
        }
        else // 2 == m_Phase
        {
            if( m_bPhaseMarkerInShader )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                  "Register r%d (and thus texture stage %d) already used as a destination for a tex* instruction in this block of the shader. "\
                  "An r# register may be used as the destination for a tex* instruction at most once before the phase marker and once after. ",
                  RegNum, RegNum );
            }
            else // no phase marker present.  Different spew to indicate 
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                  "Register r%d (and thus texture stage %d) already used as a destination for a tex* instruction in this block of the shader. "\
                  "To perform two tex* instructions with the same destination register, they must be separated by inserting a phase marker. ",
                  RegNum, RegNum );
            }
        }
        m_ErrorCount++;
        return TRUE;
    }

    s_RegUsed |= (1<<RegNum);

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_TexOpAfterArithmeticOp
//
// ** Rule:
// Tex ops (see IsTexOp() for which instructions are considered tex ops)
// must appear before any other instruction, with the exception of DEF or NOP.
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_TexOpAfterArithmeticOp()
{
    static BOOL s_bSeenArithmeticOp;
    static BOOL s_bRuleDisabled;

    if( NULL == m_pCurrInst->m_pPrevInst ) // First instruction - initialize static vars
    {
        s_bSeenArithmeticOp = FALSE;
    }

    if( !(_CURR_PS_INST->m_bTexOp)
        && (D3DSIO_NOP != m_pCurrInst->m_Type)
        && (D3DSIO_DEF != m_pCurrInst->m_Type)
        && (D3DSIO_PHASE != m_pCurrInst->m_Type) )
    {
        s_bSeenArithmeticOp = TRUE;
        return TRUE;
    }

    if( D3DSIO_PHASE == m_pCurrInst->m_Type )
    {
        s_bSeenArithmeticOp = FALSE; // reset flag because we are in new phase of shader.
        return TRUE;
    }

    if( _CURR_PS_INST->m_bTexOp && s_bSeenArithmeticOp )
    {
        if( m_bPhaseMarkerInShader )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "tex* instructions cannot be after arithmetic instructions "\
                                                       "within one phase of the shader.  Each phase can have a block of "\
                                                       "tex* instructions followed by a block of arithmetic instructions. " );
        }
        else
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "tex* instructions cannot be after arithmetic instructions. "\
                                                       "The exception is if a phase marker is present in the shader - "\
                                                       "this separates a shader into two phases.  Each phase may have "\
                                                       "a set of tex* instructions followed by a set of arithmetic instructions.  " );
        }
        m_ErrorCount++;
        s_bRuleDisabled = TRUE;
    }

    return TRUE;
}


//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_ValidMarker
//
// ** Rule:
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// FALSE if more than one marker encountered.  Else TRUE
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_ValidMarker()
{
    static BOOL s_bSeenMarker;

    if( NULL == m_pCurrInst->m_pPrevInst ) // First instruction - initialize static vars
    {
        s_bSeenMarker = FALSE;
    }

    if( D3DSIO_PHASE != m_pCurrInst->m_Type )
        return TRUE;

    if( s_bSeenMarker )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Multiple phase markers not permitted.  Aborting shader validation." );
        m_ErrorCount++;
        return FALSE;
    }

    s_bSeenMarker = TRUE;
    m_pPhaseMarkerInst = (CPSInstruction*)m_pCurrInst;
    m_Phase++;

    // Loop through all temp registers and nuke alpha access history (if any).
    // Remember what we nuked, so if the shader tries to read one of these nuked alphas, we
    // can debug spew that certain hardware is wacko and can't help but commit this atrocity.
    for( UINT i = 0; i < m_pTempRegFile->GetNumRegs(); i++ )
    {
        if( m_pTempRegFile->m_pAccessHistory[3][i].m_pMostRecentWriter )
        {
            m_pTempRegFile->m_pAccessHistory[3][i].~CAccessHistory();
            m_pTempRegFile->m_pAccessHistory[3][i].CAccessHistory::CAccessHistory();
            m_TempRegsWithZappedAlpha |= 1 << i;
        }
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_ValidTEXKILLInstruction
//
// ** Rule:
// texkill may only be present in phase 2
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_ValidTEXKILLInstruction()
{
    if( (D3DSIO_TEXKILL == m_pCurrInst->m_Type) && (1 == m_Phase))
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "When a phase marker is present in a shader, texkill is only permitted after the phase marker." );
        m_ErrorCount++;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_ValidBEMInstruction
//
// ** Rule:
// bem must have writemask .r, .g or .rg
// bem may only be present once in a shader, in phase 1.
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_ValidBEMInstruction()
{
    static BOOL s_bSeenBem;

    if( NULL == m_pCurrInst->m_pPrevInst ) // First instruction - initialize static vars
    {
        s_bSeenBem = FALSE;
    }

    if( (D3DSIO_BEM == m_pCurrInst->m_Type))
    {
        if( s_bSeenBem )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "bem may only be used once in a shader." );
            m_ErrorCount++;
        }

        if( 2 == m_Phase )
        {
            if( m_bPhaseMarkerInShader )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "bem may only be used before the phase marker." );
            }
            else
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "To use bem, a phase marker must be present later in the shader." );
            }
            m_ErrorCount++;
        }

        if( m_pCurrInst->m_DstParam.m_WriteMask != (D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1))
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Writemask for bem must be '.rg'" );
            m_ErrorCount++;            
        }

        for( UINT i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
        {
            SRCPARAM* pSrcParam = &(m_pCurrInst->m_SrcParam[i]);

            if(m_bSrcParamError[i])
                continue;

            if( 0 == i )
            {
                if( (D3DSPR_TEMP != pSrcParam->m_RegType) &&
                    (D3DSPR_CONST != pSrcParam->m_RegType) )
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "First source parameter for bem must be temp (r#) or constant (c#) register." );
                    m_ErrorCount++;            
                    
                }
            }
            else if( 1 == i )
            {
                if( (D3DSPR_TEMP != pSrcParam->m_RegType ) )
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Second source parameter for bem must be temp (r#) register." );
                    m_ErrorCount++;            
                    
                }
            }
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_ValidTEXDEPTHInstruction
//
// ** Rule:
// texdepth must operate on r5.
// texdepth may only be present after a phase marker.
// texdepth may only be used once.
// Once texdepth has been used in a shader, r5 is no longer available
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_ValidTEXDEPTHInstruction()
{
    static BOOL s_bSeenTexDepth;

    if( NULL == m_pCurrInst->m_pPrevInst ) // First instruction - initialize static vars
    {
        s_bSeenTexDepth = FALSE;
    }

    if( D3DSIO_TEXDEPTH == m_pCurrInst->m_Type )
    {
        if( s_bSeenTexDepth )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Only one use of texdepth is permitted." );
            m_ErrorCount++;
            return TRUE;
        }
        s_bSeenTexDepth = TRUE;

        DSTPARAM* pDstParam = &m_pCurrInst->m_DstParam;
        if( (5 != pDstParam->m_RegNum) || (D3DSPR_TEMP != pDstParam->m_RegType) )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Destination for texdepth must be r5." );
            m_ErrorCount++;
        }

        if( (D3DSIO_TEXDEPTH == m_pCurrInst->m_Type) && (1 == m_Phase))
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "When a phase marker is present in a shader, texdepth is only permitted after the phase marker." );
            m_ErrorCount++;
        }
    }
    else if( s_bSeenTexDepth )
    {
        UINT RegNum;
        D3DSHADER_PARAM_REGISTER_TYPE RegType;
        for( UINT i = 0; i <= m_pCurrInst->m_SrcParamCount; i++ )
        {
            if( m_pCurrInst->m_SrcParamCount == i )
            {
                RegNum = m_pCurrInst->m_DstParam.m_RegNum;
                RegType = m_pCurrInst->m_DstParam.m_RegType;
            }
            else
            {
                RegNum = m_pCurrInst->m_SrcParam[i].m_RegNum;
                RegType = m_pCurrInst->m_SrcParam[i].m_RegType;
            }
            if( (5 == RegNum) && (D3DSPR_TEMP == RegType) )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "After texdepth instruction, r5 is no longer available in shader." );
                m_ErrorCount++;
                return TRUE;
            }
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_ValidDEFInstruction
//
// ** Rule:
// For the DEF instruction, make sure the dest parameter is a valid constant,
// and it has no modifiers.
//
// NOTE that we are pretending this instruction only has a dst parameter.
// We skipped over the 4 source parameters since they are immediate floats,
// for which there is nothing that can be checked.
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_ValidDEFInstruction()
{
    static BOOL s_bDEFInstructionAllowed;

    if( NULL == m_pCurrInst->m_pPrevInst ) // First instruction - initialize static vars
    {
        s_bDEFInstructionAllowed = TRUE;
    }

    if( D3DSIO_COMMENT != m_pCurrInst->m_Type &&
        D3DSIO_DEF     != m_pCurrInst->m_Type )
    {
        s_bDEFInstructionAllowed = FALSE;
    }
    else if( D3DSIO_DEF == m_pCurrInst->m_Type )
    {
        if( !s_bDEFInstructionAllowed )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Const declaration (def) must appear before other instructions." );
            m_ErrorCount++;
        }
        DSTPARAM* pDstParam = &m_pCurrInst->m_DstParam;
        if( D3DSP_WRITEMASK_ALL != pDstParam->m_WriteMask ||
            D3DSPDM_NONE != pDstParam->m_DstMod ||
            DSTSHIFT_NONE != pDstParam->m_DstShift ||
            D3DSPR_CONST != pDstParam->m_RegType
            )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Destination for def instruction must be of the form c# (# = reg number, no modifiers)." );
            m_ErrorCount++;
        }

        // Check that the register number is in bounds
        if( D3DSPR_CONST == pDstParam->m_RegType &&
            pDstParam->m_RegNum >= m_pConstRegFile->GetNumRegs() )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid const register num: %d. Max allowed is %d.",
                        pDstParam->m_RegNum,m_pConstRegFile->GetNumRegs() - 1);
            m_ErrorCount++;

        }
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_ValidInstructionPairing
//
// ** Rule:
// - If an instruction is co-issued with another instruction,
// make sure that both do not write to any of RGB at the same time,
// and that neither instruction individually writes to all of RGBA.
//
// - Co-issue can only involve 2 instructions,
// so consecutive instructions cannot have the "+" prefix (D3DSI_COISSUE).
//
// - Co-issue of instructions only applies to pixel blend instructions (non tex-ops).
//
// - The first color blend instruction cannot have "+" (D3DSI_COISSUE) set either.
//
// - NOP may not be used in a co-issue pair.
//
// - DP3 (dot product) always uses the color/vector pipeline (even if it is not writing
// to color components). Thus:
//      - An instruction co-issued with a dot-product can only write to alpha.
//      - A dot-product that writes to alpha cannot be co-issued.
//      - Two dot-products cannot be co-issued.
//
// - For version <= 1.0, coissued instructions must write to the same register.
//
// ------------------
// examples:
//
//      valid pair:             mov r0.a, c0
//                              +add r1.rgb, v1, c1 (note dst reg #'s can be different)
//
//      another valid pair:     mov r0.a, c0
//                              +add r0.rgb, v1, c1
//
//      another valid pair:     dp3 r0.rgb, t1, v1
//                              +mul r0.a, t0, v0
//
//      another valid pair:     mov r0.a, c0
//                              +add r0.a, t0, t1
//
//      invalid pair:           mov r0.rgb, c0
//                              +add r0, t0, t1  (note the dst writes to rgba)
//
//      another invalid pair:   mov r1.rgb, c1
//                              +dp3 r0.a, t0, t1 (dp3 is using up color/vector pipe)
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_ValidInstructionPairing()
{
    static BOOL s_bSeenArithOp;
    BOOL bCurrInstCoIssuable = TRUE;

    if( NULL == m_pCurrInst->m_pPrevInst )   // First instruction - initialize static vars
    {
        s_bSeenArithOp = FALSE;
    }

    if( !_CURR_PS_INST->m_bTexOp )
    {
        switch( m_pCurrInst->m_Type )
        {
        case D3DSIO_PHASE:
        case D3DSIO_DEF:
        case D3DSIO_NOP:
        case D3DSIO_DP4:
            bCurrInstCoIssuable = FALSE;
            break;
        }
    }

    if( D3DSIO_PHASE == m_pCurrInst->m_Type )
    {
        s_bSeenArithOp = FALSE;
    }
    else if( bCurrInstCoIssuable )
    {
        s_bSeenArithOp = TRUE;
    }

    if( !_CURR_PS_INST->m_bCoIssue )
        return TRUE;

    if( _CURR_PS_INST->m_bTexOp )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                "Cannot set co-issue ('+') on a tex* instruction.  Co-issue only applies to arithmetic instructions." );
        m_ErrorCount++;
        return TRUE;
    }

    if( !s_bSeenArithOp || NULL == m_pCurrInst->m_pPrevInst )
    {
        if( D3DSIO_PHASE == m_pCurrInst->m_Type )
        {
            // cannot have co-issue set because we haven't seen an arithmetic op above.
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                "Phase marker cannot be co-issued.");
        }
        else
        {
            // cannot have co-issue set because we haven't seen an arithmetic op above.
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                "Instruction cannot have co-issue ('+') set without a previous arithmetic instruction to pair with.");
        }
        m_ErrorCount++;
        return TRUE;
    }

    if( _PREV_PS_INST->m_bCoIssue )
    {
        // consecutive instructions cannot have co-issue set.
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Cannot set co-issue ('+') on consecutive instructions." );
        m_ErrorCount++;
        return TRUE;
    }

    for( UINT i = 0; i < 2; i++ )
    {
        CBaseInstruction* pInst;
        if( 0 == i )
            pInst = m_pCurrInst;
        else
            pInst = m_pCurrInst->m_pPrevInst;
            
        switch( pInst->m_Type )
        {
        case D3DSIO_PHASE:
            // Phase marker cannot be co-issued
            Spew( SPEW_INSTRUCTION_ERROR, pInst, "phase marker cannot be co-issued." );
            m_ErrorCount++;
            return TRUE;
        case D3DSIO_DEF:
            // DEF cannot be co-issued
            Spew( SPEW_INSTRUCTION_ERROR, pInst, "def cannot be co-issued." );
            m_ErrorCount++;
            return TRUE;
        case D3DSIO_NOP:
            // NOP cannot be co-issued
            Spew( SPEW_INSTRUCTION_ERROR, pInst, "nop cannot be co-issued." );
            m_ErrorCount++;
            return TRUE;
        case D3DSIO_DP4:
            // DP4 cannot be co-issued
            Spew( SPEW_INSTRUCTION_ERROR, pInst, "dp4 cannot be co-issued." );
            m_ErrorCount++;
            return TRUE;
        case D3DSIO_BEM:
            // BEM cannot be co-issued
            Spew( SPEW_INSTRUCTION_ERROR, pInst, "bem cannot be co-issued." );
            m_ErrorCount++;
            return TRUE;
        }

    }

    #define COLOR_WRITE_MASK (D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2)
    #define ALPHA_WRITE_MASK D3DSP_WRITEMASK_3
    DWORD CurrInstWriteMask = 0;
    DWORD PrevInstWriteMask = 0;

    if( m_pCurrInst->m_DstParam.m_bParamUsed )
        CurrInstWriteMask = m_pCurrInst->m_DstParam.m_WriteMask;
    if( m_pCurrInst->m_pPrevInst->m_DstParam.m_bParamUsed )
        PrevInstWriteMask = m_pCurrInst->m_pPrevInst->m_DstParam.m_WriteMask;

    if( D3DSIO_DP3 == m_pCurrInst->m_Type &&
        D3DSIO_DP3 == m_pCurrInst->m_pPrevInst->m_Type )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                            "Co-issued instructions cannot both be dp3, since each require use of the color pipe to execute." );
        m_ErrorCount++;
    }
    else if( D3DSIO_DP3 == m_pCurrInst->m_Type )
    {
        if( COLOR_WRITE_MASK & PrevInstWriteMask )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst->m_pPrevInst,
                            "dp3 needs color pipe to execute, so instruction co-issued with it cannot write to color components." );
            m_ErrorCount++;
        }
        if( D3DSP_WRITEMASK_3 & CurrInstWriteMask ) // alpha in addition to the implied rgb for dp3
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                            "dp3 which writes alpha cannot co-issue since it uses up both the alpha and color pipes." );
            m_ErrorCount++;
        }
    }
    else if( D3DSIO_DP3 == m_pCurrInst->m_pPrevInst->m_Type )
    {
        if( COLOR_WRITE_MASK & CurrInstWriteMask )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst->m_pPrevInst,
                            "dp3 needs color pipe to execute, so instruction co-issued with it cannot write to color components." );
            m_ErrorCount++;
        }
        if( D3DSP_WRITEMASK_3 & PrevInstWriteMask ) // alpha in addition to the implied rgb for dp3
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst->m_pPrevInst,
                            "dp3 which writes alpha cannot co-issue since it uses up both the alpha and color pipes." );
            m_ErrorCount++;
        }
    }

    if( (PrevInstWriteMask & ALPHA_WRITE_MASK) && (PrevInstWriteMask & COLOR_WRITE_MASK))
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst->m_pPrevInst,
                        "Individual instruction in co-issue pair cannot write both alpha and color component(s)." );
        m_ErrorCount++;
    }

    if( (CurrInstWriteMask & ALPHA_WRITE_MASK) && (CurrInstWriteMask & COLOR_WRITE_MASK))
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                        "Individual instruction in co-issue pair cannot write both alpha and color component(s)." );
        m_ErrorCount++;
    }

    if( CurrInstWriteMask & PrevInstWriteMask )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                        "Co-issued instructions cannot both write to the same component(s).  One instruction must write to alpha and the other may write to any combination of red/green/blue.  Destination registers may differ." );
        m_ErrorCount++;
    }

    if( !((CurrInstWriteMask | PrevInstWriteMask) & ALPHA_WRITE_MASK) )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                        "One of the instructions in a co-issue pair must write to alpha only (.a writemask)." );
        m_ErrorCount++;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_ValidInstructionCount
//
// ** Rule:
// Make sure instruction count for pixel shader version has not been exceeded.
//
// Co-issued pixel blending instructions only
// count as one instruction towards the limit.
//
// The def instruction, nop, and comments (already stripped), do not count
// toward any limits.
//
// ** When to call:
// Per instruction AND after all instructions seen.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_ValidInstructionCount()
{
    static UINT s_MaxTexOpCount;
    static UINT s_MaxArithmeticOpCount;

    if( NULL == m_pCurrInst )
        return TRUE;

    if( NULL == m_pCurrInst->m_pPrevInst )   // First instruction - initialize static vars
    {
        m_TexOpCount = 0;
        m_BlendOpCount = 0;
        m_TotalOpCount = 0;

        switch(m_Version)
        {
        default:
        case D3DPS_VERSION(1,4):    // DX8.1
            s_MaxTexOpCount         = 6;
            s_MaxArithmeticOpCount  = 8;
            break;
        }
    }

    if( m_bSeenAllInstructions || D3DSIO_PHASE == m_pCurrInst->m_Type )
    {
        if( m_pCurrInst && (D3DSIO_PHASE == m_pCurrInst->m_Type) )
        {
            if( m_TexOpCount > s_MaxTexOpCount )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Too many (%d) tex* instructions before phase marker. Max. allowed in a phase is %d.",
                      m_TexOpCount, s_MaxTexOpCount);
                m_ErrorCount++;
            }
            if( m_BlendOpCount > s_MaxArithmeticOpCount )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Too many (%d) arithmetic instructions before phase marker. Max. allowed in a phase (counting any co-issued pairs as 1) is %d.",
                      m_BlendOpCount, s_MaxArithmeticOpCount);
                m_ErrorCount++;
            }
        }
        else // 2 == m_Phase
        {
            if( m_bPhaseMarkerInShader )
            {
                if( m_TexOpCount > s_MaxTexOpCount )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Too many (%d) tex* instructions after phase marker. Max. allowed in a phase is %d.",
                          m_TexOpCount, s_MaxTexOpCount);
                    m_ErrorCount++;
                }
                if( m_BlendOpCount > s_MaxArithmeticOpCount )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Too many (%d) arithmetic instructions after phase marker. Max. allowed in a phase (counting any co-issued pairs as 1) is %d.",
                          m_BlendOpCount, s_MaxArithmeticOpCount);
                    m_ErrorCount++;
                }
            }
            else // defaulted to phase 2 because no phase marker was in shader
            {
                if( m_TexOpCount > s_MaxTexOpCount )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Too many (%d) tex* instructions. Max. allowed is %d. Note that adding a phase marker to the shader would double the number of instructions available.",
                          m_TexOpCount, s_MaxTexOpCount);
                    m_ErrorCount++;
                }
                if( m_BlendOpCount > s_MaxArithmeticOpCount )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Too many (%d) arithmetic instructions. Max. allowed (counting any co-issued pairs as 1) is %d. Note that adding a phase marker to the shader would double the number of instructions available.",
                          m_BlendOpCount, s_MaxArithmeticOpCount);
                    m_ErrorCount++;
                }
            }
        }
        if( m_pCurrInst && D3DSIO_PHASE == m_pCurrInst->m_Type )
        {
            // reset counters for next phase.
            m_TexOpCount = 0;
            m_BlendOpCount = 0;
            m_TotalOpCount = 0;
        }
        return TRUE;
    }

    switch(m_pCurrInst->m_Type)
    {
    case D3DSIO_TEX:
    case D3DSIO_TEXCOORD:
    case D3DSIO_TEXKILL:
    case D3DSIO_TEXDEPTH:
        m_TexOpCount++;
        m_TotalOpCount++;
        break;
    case D3DSIO_MOV:
    case D3DSIO_ADD:
    case D3DSIO_SUB:
    case D3DSIO_MUL:
    case D3DSIO_MAD:
    case D3DSIO_LRP:
    case D3DSIO_DP3:
    case D3DSIO_CND:
    case D3DSIO_CMP:
    case D3DSIO_DP4:
        if( !_CURR_PS_INST->m_bCoIssue )
        {
            m_BlendOpCount++;
            m_TotalOpCount++;
        }
        break;
    case D3DSIO_BEM:
        m_BlendOpCount+=2;
        m_TotalOpCount+=2;
        break;
    case D3DSIO_END:
    case D3DSIO_NOP:
    case D3DSIO_DEF:
        break;
    default:
        DXGASSERT(FALSE);
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator14::Rule_R0Written
//
// ** Rule:
// All components (r,g,b,a) of register R0 must have been written by the
// pixel shader.
//
// ** When to call:
// After all instructions have been seen.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator14::Rule_R0Written()
{
    UINT  NumUninitializedComponents    = 0;
    DWORD UninitializedComponentsMask   = 0;

    for( UINT i = 0; i < NUM_COMPONENTS_IN_REGISTER; i++ )
    {
        if( NULL == m_pTempRegFile->m_pAccessHistory[i][0].m_pMostRecentWriter )
        {
            NumUninitializedComponents++;
            UninitializedComponentsMask |= COMPONENT_MASKS[i];
        }
    }
    if( NumUninitializedComponents )
    {
        if( (UninitializedComponentsMask & COMPONENT_MASKS[3]) && 
            (m_TempRegsWithZappedAlpha & (1 << 0 /*regnum=0*/ ) ) &&
            (UninitializedComponentsMask & COMPONENT_MASKS[2]) && 
            (m_TempRegsWithZappedBlue & (1 << 0 /*regnum=0*/ ) ) )
        {
           Spew( SPEW_GLOBAL_ERROR, NULL, "r0 must be written by shader. Uninitialized component%s(*): %s. "\
               ZAPPED_BLUE_TEXT2 " Also: " ZAPPED_ALPHA_TEXT2,
               NumUninitializedComponents > 1 ? "s" : "", MakeAffectedComponentsText(UninitializedComponentsMask,TRUE,FALSE));
        }
        else if( (UninitializedComponentsMask & COMPONENT_MASKS[3]) && 
            (m_TempRegsWithZappedAlpha & (1 << 0 /*regnum=0*/ ) ) )
        {
           Spew( SPEW_GLOBAL_ERROR, NULL, "r0 must be written by shader. Uninitialized component%s(*): %s. "\
               ZAPPED_ALPHA_TEXT2,
               NumUninitializedComponents > 1 ? "s" : "", MakeAffectedComponentsText(UninitializedComponentsMask,TRUE,FALSE));
        }
        else if( (UninitializedComponentsMask & COMPONENT_MASKS[2]) && 
           (m_TempRegsWithZappedBlue & (1 << 0 /*regnum=0*/ ) ) )
        {
           Spew( SPEW_GLOBAL_ERROR, NULL, "r0 must be written by shader. Uninitialized component%s(*): %s. "\
               ZAPPED_BLUE_TEXT2,
               NumUninitializedComponents > 1 ? "s" : "", MakeAffectedComponentsText(UninitializedComponentsMask,TRUE,FALSE));
        }
        else
        {
           Spew( SPEW_GLOBAL_ERROR, NULL, "r0 must be written by shader. Uninitialized component%s(*): %s",
               NumUninitializedComponents > 1 ? "s" : "", MakeAffectedComponentsText(UninitializedComponentsMask,TRUE,FALSE));
        }

        m_ErrorCount++;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\tnl\clip.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clip.h
 *  Content:    Template for functions to clip by a frustum side
 *
 * The following symbol should be defined before included this file:
 * __CLIP_NAME 	    - name for a function to clip triangles
 * __CLIP_LINE_NAME - name for a function to clip lines
 * __CLIP_W         - if this functions are for Coord <= W. Otherwise they 
 *                    are for 0 < Coord
 * __CLIP_COORD     - should be hx, hy or hz
 * __CLIP_FLAG      - clipping flag to set
 * __CLIP_GUARDBAND - defined when clipping by guardband window
 * __CLIP_SIGN      - "-" if clipping by left or bottom sides of guard band 
 *                    window
 * __CLIP_GBCOEF    - coefficient to multiply W when clipping by guard band
 *                    window
 *
 * All these symbols are undefined at the end of this file
 ***************************************************************************/
//
// Clipping for triangle
//
// Returns number of vertices in the clipped triangle
//
int 
__CLIP_NAME(D3DFE_PROCESSVERTICES *pv,
            ClipVertex **inv, 
            ClipVertex **outv,
            int count)
{
    int i;
    int out_count = 0;
    ClipVertex *curr, *prev;
    D3DVALUE curr_inside;
    D3DVALUE prev_inside;

    prev = inv[count-1];
    curr = *inv++;
#ifdef __CLIP_GUARDBAND
    prev_inside = __CLIP_SIGN(prev->hw * pv->vcache.__CLIP_GBCOEF - 
                              prev->__CLIP_COORD);
#else
#ifdef __CLIP_W
    prev_inside = prev->hw - prev->__CLIP_COORD;
#else
    prev_inside = prev->__CLIP_COORD;
#endif
#endif
    for (i = count; i; i--) 
    {
#ifdef __CLIP_GUARDBAND
        curr_inside = __CLIP_SIGN(curr->hw * pv->vcache.__CLIP_GBCOEF - 
                                  curr->__CLIP_COORD);
#else
#ifdef __CLIP_W
        curr_inside = curr->hw - curr->__CLIP_COORD;
#else
        curr_inside = curr->__CLIP_COORD;
#endif
#endif
        // We interpolate always from the inside vertex to the outside vertex
        // to reduce precision problems
        if (FLOAT_LTZ(prev_inside)) 
        { // first point is outside
            if (FLOAT_GEZ(curr_inside)) 
            { // second point is inside
              // Find intersection and insert in into the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                Interpolate(pv,
                            outv[out_count],
                            curr, prev, 
                            (prev->clip & CLIPPED_ENABLE) | __CLIP_FLAG,
                            curr_inside, curr_inside - prev_inside);
                out_count++;
            }
        } else 
        { // first point is inside - put it to the output buffer first
            outv[out_count++] = prev;
            if (FLOAT_LTZ(curr_inside)) 
            { // second point is outside
              // Find intersection and put it to the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                Interpolate(pv, 
                            outv[out_count],
                            prev, curr,
                            __CLIP_FLAG,
                            prev_inside, prev_inside - curr_inside);
                out_count++;
            }
        }
        prev = curr;
        curr = *inv++;
        prev_inside = curr_inside;
    }
    return out_count;
}
//-------------------------------------------------------------------------
// Clipping for lines
//
// Returns 1 if the line is outside the frustum, 0 otherwise
//
int __CLIP_LINE_NAME(D3DFE_PROCESSVERTICES *pv, ClipTriangle *line)
{
    D3DVALUE in1, in2;
    ClipVertex outv;
#ifdef __CLIP_GUARDBAND
    in1 = __CLIP_SIGN(line->v[0]->hw * pv->vcache.__CLIP_GBCOEF - 
                      line->v[0]->__CLIP_COORD);
    in2 = __CLIP_SIGN(line->v[1]->hw * pv->vcache.__CLIP_GBCOEF - 
                      line->v[1]->__CLIP_COORD);
#else
#ifdef __CLIP_W
    in1 = line->v[0]->hw - line->v[0]->__CLIP_COORD;
    in2 = line->v[1]->hw - line->v[1]->__CLIP_COORD;
#else
    in1 = line->v[0]->__CLIP_COORD;
    in2 = line->v[1]->__CLIP_COORD;
#endif
#endif
    if (in1 < 0) 
    {
        if (in2 < 0) 
            return 1;
        Interpolate(pv, &outv, line->v[0], line->v[1], 
                    __CLIP_FLAG, in1, in1 - in2);
        *line->v[0] = outv;
    } 
    else 
    {
        if (in2 < 0) 
        {
            Interpolate(pv,  &outv, line->v[0], line->v[1],
                        __CLIP_FLAG, in1, in1 - in2);
            *line->v[1] = outv;
        }
    }
    return 0;
}

#undef __CLIP_FLAG
#undef __CLIP_COORD
#undef __CLIP_NAME
#undef __CLIP_LINE_NAME
#undef __CLIP_W
#undef __CLIP_SIGN
#undef __CLIP_GBCOEF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\shval\psval10.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// pshdrval.cpp
//
// Direct3D Reference Device - PixelShader validation
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

// Use these macros when looking at CPSInstruction derived members of the current instruction (CBaseInstruction)
#define _CURR_PS_INST   ((CPSInstruction*)m_pCurrInst)
#define _PREV_PS_INST   (m_pCurrInst?((CPSInstruction*)(m_pCurrInst->m_pPrevInst)):NULL)

//-----------------------------------------------------------------------------
// PixelShader Validation Rule Coverage
//
// Below is the list of rules in "DX8 PixelShader Version Specification",
// matched to the function(s) in this file which enforce them.
// Note that the mapping from rules to funtions can be 1->n or n->1
//
// Generic Rules
// -------------
//
// PS-G1:           Rule_R0Written
// PS-G2:           Rule_SrcInitialized
// PS-G3:           Rule_ValidDstParam
//
// TEX Op Specific Rules
// ---------------------
//
// PS-T1:           Rule_TexOpAfterNonTexOp
// PS-T2:           Rule_ValidDstParam
// PS-T3:           Rule_ValidDstParam, Rule_ValidSrcParams
// PS-T4:           Rule_TexRegsDeclaredInOrder
// PS-T5:           Rule_SrcInitialized
// PS-T6:           Rule_ValidTEXM3xSequence, Rule_ValidTEXM3xRegisterNumbers, Rule_InstructionSupportedByVersion
// PS-T7:           Rule_ValidSrcParams
//
// Co-Issue Specific Rules
// -----------------------
//
// PS-C1:           Rule_ValidInstructionPairing
// PS-C2:           Rule_ValidInstructionPairing
// PS-C3:           Rule_ValidInstructionPairing
// PS-C4:           Rule_ValidInstructionPairing
// PS-C5:           Rule_ValidInstructionPairing
//
// Instruction Specific Rules
// --------------------------
//
// PS-I1:           Rule_ValidLRPInstruction
// PS-I2:           Rule_ValidCNDInstruction
// PS-I3:           Rule_ValidDstParam
// PS-I4:           Rule_ValidDP3Instruction
// PS-I5:           Rule_ValidInstructionCount
//
// Pixel Shader Version 1.0 Rules
// ------------------------------
//
// PS.1.0-1:        InitValidation,
//                  Rule_SrcInitialized
// PS.1.0-2:        Rule_ValidInstructionPairing
// PS.1.0-3:        <empty rule>
// PS.1.0-4:        Rule_ValidInstructionCount
// PS.1.0-5:        <empty rule>

//
// Pixel Shader Version 1.1 Rules
// ------------------------------
//
// PS.1.1-1:        Rule_ValidDstParam
// PS.1.1-2:        Rule_ValidSrcParams
// PS.1.1-3:        Rule_SrcNoLongerAvailable
// PS.1.1-4:        Rule_SrcNoLongerAvailable
// PS.1.1-5:        Rule_SrcNoLongerAvailable
// PS.1.1-6:        Rule_ValidDstParam
// PS.1.1-7:        Rule_NegateAfterSat
// PS.1.1-8:        Rule_MultipleDependentTextureReads
// PS.1.1-9:        <not validated - implemented by refrast though>
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// CPShaderValidator10::CPShaderValidator10
//-----------------------------------------------------------------------------
CPShaderValidator10::CPShaderValidator10(   const DWORD* pCode,
                                        const D3DCAPS8* pCaps,
                                        DWORD Flags )
                                        : CBasePShaderValidator( pCode, pCaps, Flags )
{
    // Note that the base constructor initialized m_ReturnCode to E_FAIL.
    // Only set m_ReturnCode to S_OK if validation has succeeded,
    // before exiting this constructor.

    m_TexMBaseDstReg        = 0;

    if( !m_bBaseInitOk )
        return;

    ValidateShader(); // If successful, m_ReturnCode will be set to S_OK.
                      // Call GetStatus() on this object to determine validation outcome.
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::IsCurrInstTexOp
//-----------------------------------------------------------------------------
void CPShaderValidator10::IsCurrInstTexOp()
{
    DXGASSERT(m_pCurrInst);

    switch (m_pCurrInst->m_Type)
    {
    case D3DSIO_TEXM3x2PAD:
    case D3DSIO_TEXM3x2TEX:
    case D3DSIO_TEXM3x2DEPTH:
    case D3DSIO_TEXM3x3PAD:
    case D3DSIO_TEXM3x3TEX:
    case D3DSIO_TEXM3x3SPEC:
    case D3DSIO_TEXM3x3VSPEC:
    case D3DSIO_TEXM3x3:
        _CURR_PS_INST->m_bTexMOp = TRUE;
        // fall through
    case D3DSIO_TEXCOORD:
    case D3DSIO_TEXKILL:
    case D3DSIO_TEX:
    case D3DSIO_TEXBEM:
    case D3DSIO_TEXBEML:
    case D3DSIO_TEXREG2AR:
    case D3DSIO_TEXREG2GB:
    case D3DSIO_TEXDP3:
    case D3DSIO_TEXDP3TEX:
    case D3DSIO_TEXREG2RGB:
        _CURR_PS_INST->m_bTexOp = TRUE;
        break;
    }

    switch(m_pCurrInst->m_Type)
    {
    case D3DSIO_TEXM3x2PAD:
    case D3DSIO_TEXM3x3PAD:
    case D3DSIO_TEXM3x2DEPTH:
    case D3DSIO_TEXCOORD:
    case D3DSIO_TEXKILL:
    case D3DSIO_TEXDP3:
    case D3DSIO_TEXM3x3:
        _CURR_PS_INST->m_bTexOpThatReadsTexture = FALSE;
        break;
    case D3DSIO_TEX:
    case D3DSIO_TEXM3x2TEX:
    case D3DSIO_TEXM3x3TEX:
    case D3DSIO_TEXM3x3SPEC:
    case D3DSIO_TEXM3x3VSPEC:
    case D3DSIO_TEXBEM:
    case D3DSIO_TEXBEML:
    case D3DSIO_TEXREG2AR:
    case D3DSIO_TEXREG2GB:
    case D3DSIO_TEXREG2RGB:
    case D3DSIO_TEXDP3TEX:
        _CURR_PS_INST->m_bTexOpThatReadsTexture = TRUE;
        break;
    }
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::InitValidation
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::InitValidation()
{
    switch( m_Version >> 16 )
    {
    case 0xfffe:
        Spew( SPEW_GLOBAL_ERROR, NULL, "Version Token: 0x%x indicates a vertex shader.  Pixel shader version token must be of the form 0xffff****.",
                m_Version);
        return FALSE;
    case 0xffff:
        break; // pixelshader - ok.
    default:
        Spew( SPEW_GLOBAL_ERROR, NULL, "Version Token: 0x%x is invalid. Pixel shader version token must be of the form 0xffff****. Aborting pixel shader validation.",
                m_Version);
        return FALSE;
    }

    if( m_pCaps )
    {
        if( (m_pCaps->PixelShaderVersion & 0x0000FFFF) < (m_Version & 0x0000FFFF) ) 
        {
            Spew( SPEW_GLOBAL_ERROR, NULL, "Version Token: Pixel shader version %d.%d is too high for device.  Maximum supported version is %d.%d. Aborting shader validation.",
                    D3DSHADER_VERSION_MAJOR(m_Version),D3DSHADER_VERSION_MINOR(m_Version),
                    D3DSHADER_VERSION_MAJOR(m_pCaps->PixelShaderVersion),D3DSHADER_VERSION_MINOR(m_pCaps->PixelShaderVersion));
            return FALSE;
        }
    }

    switch(m_Version)
    {
    case D3DPS_VERSION(1,0):    // DX8.0
        m_pTempRegFile      = new CRegisterFile(2,TRUE,2,FALSE); // #regs, bWritable, max# reads/instruction, pre-shader initialized
        m_pInputRegFile     = new CRegisterFile(2,FALSE,1,TRUE);
        m_pConstRegFile     = new CRegisterFile(8,FALSE,2,TRUE);
        m_pTextureRegFile   = new CRegisterFile(4,FALSE,1,FALSE);
        break;
    case D3DPS_VERSION(1,1):    // DX8.0
        m_pTempRegFile      = new CRegisterFile(2,TRUE,2,FALSE); // #regs, bWritable, max# reads/instruction, pre-shader initialized
        m_pInputRegFile     = new CRegisterFile(2,FALSE,2,TRUE);
        m_pConstRegFile     = new CRegisterFile(8,FALSE,2,TRUE);
        m_pTextureRegFile   = new CRegisterFile(4,TRUE,2,FALSE);
        break;
    case D3DPS_VERSION(1,2):    // DX8.1
    case D3DPS_VERSION(1,3):    // DX8.1
        m_pTempRegFile      = new CRegisterFile(2,TRUE,2,FALSE); // #regs, bWritable, max# reads/instruction, pre-shader initialized
        m_pInputRegFile     = new CRegisterFile(2,FALSE,2,TRUE);
        m_pConstRegFile     = new CRegisterFile(8,FALSE,2,TRUE);
        m_pTextureRegFile   = new CRegisterFile(4,TRUE,3,FALSE);
        break;
    default:
        Spew( SPEW_GLOBAL_ERROR, NULL, "Version Token: %d.%d is not a supported pixel shader version. Aborting pixel shader validation.",
                D3DSHADER_VERSION_MAJOR(m_Version),D3DSHADER_VERSION_MINOR(m_Version));
        return FALSE;
    }
    if( NULL == m_pTempRegFile ||
        NULL == m_pInputRegFile ||
        NULL == m_pConstRegFile ||
        NULL == m_pTextureRegFile )
    {
        Spew( SPEW_GLOBAL_ERROR, NULL, "Out of memory.");
        return FALSE;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::ApplyPerInstructionRules
//
// Returns FALSE if shader validation must terminate.
// Returns TRUE if validation may proceed to next instruction.
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::ApplyPerInstructionRules()
{
    if( !   Rule_InstructionRecognized()            ) return FALSE;   // Bail completely on unrecognized instr.
    if( !   Rule_InstructionSupportedByVersion()    ) goto EXIT;
    if( !   Rule_ValidParamCount()                  ) goto EXIT;

   // Rules that examine source parameters
    if( !   Rule_ValidSrcParams()                   ) goto EXIT;
    if( !   Rule_NegateAfterSat()                   ) goto EXIT;
    if( !   Rule_SatBeforeBiasOrComplement()        ) goto EXIT; // needs to be after _ValidSrcParams(), and before _ValidDstParam(), _SrcInitialized()
    if( !   Rule_MultipleDependentTextureReads()    ) goto EXIT; // needs to be after _ValidSrcParams(), and before _ValidDstParam(), _SrcInitialized()
    if( !   Rule_SrcNoLongerAvailable()             ) goto EXIT; // needs to be after _ValidSrcParams(), and before _ValidDstParam(), _SrcInitialized()
    if( !   Rule_SrcInitialized()                   ) goto EXIT; // needs to be before _ValidDstParam()

    if( !   Rule_ValidDstParam()                    ) goto EXIT;
    if( !   Rule_ValidRegisterPortUsage()           ) goto EXIT;
    if( !   Rule_TexRegsDeclaredInOrder()           ) goto EXIT;
    if( !   Rule_TexOpAfterNonTexOp()               ) goto EXIT;
    if( !   Rule_ValidTEXM3xSequence()              ) goto EXIT;
    if( !   Rule_ValidTEXM3xRegisterNumbers()       ) goto EXIT;
    if( !   Rule_ValidCNDInstruction()              ) goto EXIT;
    if( !   Rule_ValidCMPInstruction()              ) goto EXIT;
    if( !   Rule_ValidLRPInstruction()              ) goto EXIT;
    if( !   Rule_ValidDEFInstruction()              ) goto EXIT;
    if( !   Rule_ValidDP3Instruction()              ) goto EXIT;
    if( !   Rule_ValidDP4Instruction()              ) goto EXIT;
    if( !   Rule_ValidInstructionPairing()          ) goto EXIT;
    if( !   Rule_ValidInstructionCount()            ) goto EXIT;
EXIT:
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::ApplyPostInstructionsRules
//-----------------------------------------------------------------------------
void CPShaderValidator10::ApplyPostInstructionsRules()
{
    Rule_ValidTEXM3xSequence(); // check once more to see if shader ended dangling in mid-sequence
    Rule_ValidInstructionCount(); // see if we went over the limits
    Rule_R0Written();
}

//-----------------------------------------------------------------------------
//
// Per Instruction Rules
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_InstructionRecognized
//
// ** Rule:
// Is the instruction opcode known? (regardless of shader version)
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// FALSE when instruction not recognized.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_InstructionRecognized()
{
    switch(m_pCurrInst->m_Type)
    {
    case D3DSIO_MOV:
    case D3DSIO_ADD:
    case D3DSIO_SUB:
    case D3DSIO_MUL:
    case D3DSIO_MAD:
    case D3DSIO_LRP:
    case D3DSIO_DP3:
    case D3DSIO_TEX:
    case D3DSIO_TEXBEM:
    case D3DSIO_TEXBEML:
    case D3DSIO_CND:
    case D3DSIO_TEXCOORD:
    case D3DSIO_TEXM3x2PAD:
    case D3DSIO_TEXM3x2TEX:
    case D3DSIO_TEXM3x3PAD:
    case D3DSIO_TEXM3x3TEX:
    case D3DSIO_TEXM3x3SPEC:
    case D3DSIO_TEXM3x3VSPEC:
    case D3DSIO_TEXREG2AR:
    case D3DSIO_TEXREG2GB:
    case D3DSIO_TEXKILL:
    case D3DSIO_END:
    case D3DSIO_NOP:
    case D3DSIO_DEF:
    case D3DSIO_TEXM3x2DEPTH:
    case D3DSIO_TEXDP3:
    case D3DSIO_TEXREG2RGB:
    case D3DSIO_DP4:
    case D3DSIO_CMP:
    case D3DSIO_TEXDP3TEX:
    case D3DSIO_TEXM3x3:
    case D3DSIO_TEXDEPTH:
    case D3DSIO_BEM:
    case D3DSIO_PHASE:
        return TRUE; // instruction recognized - ok.
    }

    // if we get here, the instruction is not recognized
    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Unrecognized instruction. Aborting pixel shader validation.");
    m_ErrorCount++;
    return FALSE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_InstructionSupportedByVersion
//
// ** Rule:
// Is the instruction supported by the current pixel shader version?
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// FALSE when instruction not supported by version.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_InstructionSupportedByVersion()
{
    if( D3DPS_VERSION(1,0) <= m_Version ) // 1.0 and above
    {
        switch(m_pCurrInst->m_Type)
        {
        case D3DSIO_MOV:
        case D3DSIO_ADD:
        case D3DSIO_SUB:
        case D3DSIO_MUL:
        case D3DSIO_MAD:
        case D3DSIO_LRP:
        case D3DSIO_DP3:
        case D3DSIO_TEX:
        case D3DSIO_DEF:
        case D3DSIO_TEXBEM:
        case D3DSIO_TEXBEML:
        case D3DSIO_CND:
        case D3DSIO_TEXKILL:
        case D3DSIO_TEXCOORD:
        case D3DSIO_TEXM3x2PAD:
        case D3DSIO_TEXM3x2TEX:
        case D3DSIO_TEXM3x3PAD:
        case D3DSIO_TEXM3x3TEX:
        case D3DSIO_TEXM3x3SPEC:
        case D3DSIO_TEXM3x3VSPEC:
        case D3DSIO_TEXREG2AR:
        case D3DSIO_TEXREG2GB:
            return TRUE; // instruction supported - ok.
        }
    }
    if( D3DPS_VERSION(1,2) <= m_Version ) // 1.2 and above
    {
        switch(m_pCurrInst->m_Type)
        {
        case D3DSIO_CMP:
        case D3DSIO_DP4:
        case D3DSIO_TEXDP3:
        case D3DSIO_TEXDP3TEX:
        case D3DSIO_TEXM3x3:
        case D3DSIO_TEXREG2RGB:
            return TRUE; // instruction supported - ok.
        }
    }

    if( D3DPS_VERSION(1,3) <= m_Version ) // 1.3
    {
        switch(m_pCurrInst->m_Type)
        {
        case D3DSIO_TEXM3x2DEPTH:
            return TRUE; // instruction supported - ok.
        }
    }

    switch(m_pCurrInst->m_Type)
    {
    case D3DSIO_END:
    case D3DSIO_NOP:
        return TRUE; // instruction supported - ok.
    }

    // if we get here, the instruction is not supported.
    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Instruction not supported by version %d.%d pixel shader.",
                D3DSHADER_VERSION_MAJOR(m_Version),D3DSHADER_VERSION_MINOR(m_Version));
    m_ErrorCount++;
    return FALSE;  // no more checks on this instruction
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_ValidParamCount
//
// ** Rule:
// Is the parameter count correct for the instruction?
//
// DEF is a special case that is treated as having only 1 dest parameter,
// even though there are also 4 source parameters.  The 4 source params for DEF
// are immediate float values, so there is nothing to check, and no way of
// knowing whether or not those parameter tokens were actually present in the
// token list - all the validator can do is skip over 4 DWORDS (which it does).
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// FALSE when the parameter count is incorrect.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_ValidParamCount()
{
    BOOL bBadParamCount = FALSE;

    if (m_pCurrInst->m_SrcParamCount + m_pCurrInst->m_DstParamCount > SHADER_INSTRUCTION_MAX_PARAMS)  bBadParamCount = TRUE;
    switch (m_pCurrInst->m_Type)
    {
    case D3DSIO_NOP:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 0) || (m_pCurrInst->m_SrcParamCount != 0); break;
    case D3DSIO_MOV:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 1); break;
    case D3DSIO_ADD:
    case D3DSIO_SUB:
    case D3DSIO_MUL:
    case D3DSIO_DP3:
    case D3DSIO_DP4:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 2); break;
    case D3DSIO_MAD:
    case D3DSIO_LRP:
    case D3DSIO_CND:
    case D3DSIO_CMP:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 3); break;
    case D3DSIO_TEXCOORD:
    case D3DSIO_TEXKILL:
    case D3DSIO_TEX:
    case D3DSIO_DEF: // we skipped the last 4 parameters (float vector) - nothing to check
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 0); break;
    case D3DSIO_TEXBEM:
    case D3DSIO_TEXBEML:
    case D3DSIO_TEXREG2AR:
    case D3DSIO_TEXREG2GB:
    case D3DSIO_TEXM3x2PAD:
    case D3DSIO_TEXM3x2TEX:
    case D3DSIO_TEXM3x3PAD:
    case D3DSIO_TEXM3x3TEX:
    case D3DSIO_TEXM3x3VSPEC:
    case D3DSIO_TEXM3x2DEPTH:
    case D3DSIO_TEXDP3:
    case D3DSIO_TEXREG2RGB:
    case D3DSIO_TEXM3x3:
    case D3DSIO_TEXDP3TEX:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 1); break;
    case D3DSIO_TEXM3x3SPEC:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 2); break;
    }

    if (bBadParamCount)
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid parameter count.");
        m_ErrorCount++;
        return FALSE;  // no more checks on this instruction
    }

    return TRUE;

}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_ValidSrcParams
//
// ** Rule:
// for each source parameter,
//      if current instruction is a texture instruction, then
//          source register type must be texture register
//          (with the exception of D3DSIO_SPEC, where Src1 must be c#), and
//          register # must be within range for texture registers, and
//          modifier must be D3DSPSM_NONE (or _BX2 for TexMatrixOps [version<=1.1], 
//                                            _BX2 for any tex* op [version>=1.2])
//          swizzle must be D3DSP_NOSWIZZLE
//      else (non texture instruction)
//          source register type must be D3DSPR_TEMP/_INPUT/_CONST/_TEXTURE
//          register # must be within range for register type
//          modifier must be D3DSPSM_NONE/_NEG/_BIAS/_BIASNEG/_SIGN/_SIGNNEG/_COMP
//          swizzle must be D3DSP_NOSWIZZLE/_REPLICATEALPHA
//                           and for ps.1.1+, D3DSP_REPLICATEBLUE (only on alpha op)
//
// Note that the parameter count for D3DSIO_DEF is treated as 1
// (dest only), so this rule does nothing for it.
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
// Errors in any of the source parameters causes m_bSrcParamError[i]
// to be TRUE, so later rules that only apply when a particular source
// parameter was valid know whether they need to execute or not.
// e.g. Rule_SrcInitialized.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_ValidSrcParams()  // could break this down for more granularity
{
    for( UINT i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
    {
        BOOL bFoundSrcError = FALSE;
        SRCPARAM* pSrcParam = &(m_pCurrInst->m_SrcParam[i]);
        char* SourceName[3] = {"first", "second", "third"};
        if( _CURR_PS_INST->m_bTexOp )
        {
            if( D3DSPR_TEXTURE != pSrcParam->m_RegType )
            {
                if( D3DSIO_TEXM3x3SPEC == m_pCurrInst->m_Type && (1 == i) )
                {
                    // for _SPEC, last source parameter must be c#
                    if( D3DSPR_CONST != pSrcParam->m_RegType ||
                        D3DSP_NOSWIZZLE != pSrcParam->m_SwizzleShift ||
                        D3DSPSM_NONE != pSrcParam->m_SrcMod )
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Second source parameter for texm3x3spec must be c#.");
                        m_ErrorCount++;
                        bFoundSrcError = TRUE;
                        goto LOOP_CONTINUE;
                    }
                }
                else
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                                    "Src reg for tex* instruction must be t# register (%s source param).",
                                    SourceName[i]);
                    m_ErrorCount++;
                    bFoundSrcError = TRUE;
                }
            }

            UINT ValidRegNum = 0;
            switch(pSrcParam->m_RegType)
            {
            case D3DSPR_CONST:      ValidRegNum = m_pConstRegFile->GetNumRegs(); break;
            case D3DSPR_TEXTURE:    ValidRegNum = m_pTextureRegFile->GetNumRegs(); break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid reg type (%s source param).",
                        SourceName[i]);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
                goto LOOP_CONTINUE;
            }

            if( pSrcParam->m_RegNum >= ValidRegNum )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid reg num %d (%s source param).  Max allowed for this type is %d.",
                        pSrcParam->m_RegNum, SourceName[i], ValidRegNum - 1);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }

            switch(pSrcParam->m_SrcMod)
            {
            case D3DSPSM_NONE:
                break;
            case D3DSPSM_SIGN:
                if( D3DPS_VERSION(1,1) >= m_Version )
                {
                    if( !(_CURR_PS_INST->m_bTexMOp) )
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "_bx2 is a valid src mod for texM* instructions only (%s source param).", SourceName[i]);
                        m_ErrorCount++;
                    }
                }
                break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid src mod for tex* instruction (%s source param).", SourceName[i]);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }
            switch (pSrcParam->m_SwizzleShift)
            {
            case D3DSP_NOSWIZZLE:
                break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Source swizzle not allowed for tex* instruction (%s source param).", SourceName[i]);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }
        }
        else // not a tex op
        {
            UINT ValidRegNum = 0;
            switch(pSrcParam->m_RegType)
            {
            case D3DSPR_TEMP:       ValidRegNum = m_pTempRegFile->GetNumRegs(); break;
            case D3DSPR_INPUT:      ValidRegNum = m_pInputRegFile->GetNumRegs(); break;
            case D3DSPR_CONST:      ValidRegNum = m_pConstRegFile->GetNumRegs(); break;
            case D3DSPR_TEXTURE:    ValidRegNum = m_pTextureRegFile->GetNumRegs(); break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid reg type for %s source param.", SourceName[i]);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }

            if( (!bFoundSrcError) && (pSrcParam->m_RegNum >= ValidRegNum) )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid reg num: %d for %s source param. Max allowed for this type is %d.",
                    pSrcParam->m_RegNum, SourceName[i], ValidRegNum - 1);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }

            switch( pSrcParam->m_SrcMod )
            {
            case D3DSPSM_NONE:
            case D3DSPSM_NEG:
            case D3DSPSM_BIAS:
            case D3DSPSM_BIASNEG:
            case D3DSPSM_SIGN:
            case D3DSPSM_SIGNNEG:
            case D3DSPSM_COMP:
                break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid src mod for %s source param.",
                                    SourceName[i]);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }

            switch( pSrcParam->m_SwizzleShift )
            {
            case D3DSP_NOSWIZZLE:
            case D3DSP_REPLICATEALPHA:
                break;
            case D3DSP_REPLICATEBLUE:
                if( D3DPS_VERSION(1,1) <= m_Version )
                {
                    DSTPARAM* pDstParam = &(m_pCurrInst->m_DstParam);
                    BOOL bVectorOp = FALSE;
                    switch( _CURR_PS_INST->m_Type )
                    {
                    case D3DSIO_DP3:
                    case D3DSIO_DP4:
                        bVectorOp = TRUE;
                        break;
                    }
                    if((m_pCurrInst->m_DstParam.m_WriteMask & (D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2))
                       || bVectorOp )
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Src selector .b (%s source param) is only valid for instructions that occur in the alpha pipe.",
                                           SourceName[i]);
                        m_ErrorCount++;
                        bFoundSrcError = TRUE;
                    }
                    break;
                }
                    
                // falling through
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid src swizzle for %s source param.",
                                   SourceName[i]);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }
        }
LOOP_CONTINUE:
        if( bFoundSrcError )
        {
            m_bSrcParamError[i] = TRUE; // needed in Rule_SrcInitialized
        }
    }


    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_NegateAfterSat
//
// ** Rule:
// for each source parameter,
//      if the last write to the register had _sat destination modifier,
//      then _NEG or _BIASNEG source modifiers are not allowed (version 1.1 and below)
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_NegateAfterSat()
{
    if( D3DPS_VERSION(1,2) <= m_Version )
        return TRUE;

    for( UINT i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
    {
        SRCPARAM* pSrcParam = &(m_pCurrInst->m_SrcParam[i]);
        UINT RegNum = pSrcParam->m_RegNum;
        char* SourceName[3] = {"first", "second", "third"};
        DWORD AffectedComponents = 0;

        if( m_bSrcParamError[i] )
            continue;

        switch( pSrcParam->m_SrcMod )
        {
        case D3DSPSM_NEG:
        case D3DSPSM_BIASNEG:
            break;
        default:
            continue;
        }

        for( UINT Component = 0; Component < 4; Component++ )
        {
            if( !(COMPONENT_MASKS[Component] & pSrcParam->m_ComponentReadMask) )
                continue;

            CAccessHistoryNode* pMostRecentWriter = NULL;
            switch( pSrcParam->m_RegType )
            {
            case D3DSPR_TEXTURE:
                pMostRecentWriter = m_pTextureRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                break;
            case D3DSPR_INPUT:
                pMostRecentWriter = m_pInputRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                break;
            case D3DSPR_TEMP:
                pMostRecentWriter = m_pTempRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                break;
            case D3DSPR_CONST:
                pMostRecentWriter = m_pConstRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                break;
            }

            if( pMostRecentWriter &&
                pMostRecentWriter->m_pInst &&
                (((CPSInstruction*)pMostRecentWriter->m_pInst)->m_CycleNum != _CURR_PS_INST->m_CycleNum) &&
                (D3DSPDM_SATURATE == pMostRecentWriter->m_pInst->m_DstParam.m_DstMod )
              )
            {
                AffectedComponents |= COMPONENT_MASKS[Component];
            }
        }
        if( AffectedComponents )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                "Cannot apply a negation source modifier on data that was last written with the saturate destination modifier. "
                "Affected components(*) of %s source param: %s",
                SourceName[i],MakeAffectedComponentsText(AffectedComponents,TRUE,FALSE));
            m_ErrorCount++;
            m_bSrcParamError[i] = TRUE;
        }
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_SatBeforeBiasOrComplement()
//
// ** Rule:
// for each component of each source parameter,
//     if _BIAS or _COMP is applied to the source parameter, and
//     there was a previous writer that was a non-tex op
//         if the previous writer didn't do a _sat on its write, then
//              -> spew error.
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_SatBeforeBiasOrComplement()
{
#ifdef SHOW_VALIDATION_WARNINGS
    for( UINT i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
    {
        SRCPARAM* pSrcParam = &(m_pCurrInst->m_SrcParam[i]);
        UINT RegNum = pSrcParam->m_RegNum;
        char* SourceName[3] = {"first", "second", "third"};
        DWORD AffectedComponents = 0;

        if( m_bSrcParamError[i] )
            continue;

        switch( pSrcParam->m_SrcMod )
        {
        case D3DSPSM_BIAS:
        case D3DSPSM_COMP:
            break;
        default:
            continue;
        }

        for( UINT Component = 0; Component < 4; Component++ )
        {
            if( !(COMPONENT_MASKS[Component] & pSrcParam->m_ComponentReadMask) )
                continue;

            CAccessHistoryNode* pMostRecentWriter = NULL;
            switch( pSrcParam->m_RegType )
            {
            case D3DSPR_TEXTURE:
                pMostRecentWriter = m_pTextureRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                break;
            case D3DSPR_INPUT:
                pMostRecentWriter = m_pInputRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                break;
            case D3DSPR_TEMP:
                pMostRecentWriter = m_pTempRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                break;
            case D3DSPR_CONST:
                pMostRecentWriter = m_pConstRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                break;
            }

            if( pMostRecentWriter &&
                pMostRecentWriter->m_pInst &&
                (((CPSInstruction*)pMostRecentWriter->m_pInst)->m_CycleNum != _CURR_PS_INST->m_CycleNum) &&
                !((CPSInstruction*)pMostRecentWriter->m_pInst)->m_bTexOp &&
                (D3DSPDM_SATURATE != pMostRecentWriter->m_pInst->m_DstParam.m_DstMod )
              )
            {
                AffectedComponents |= COMPONENT_MASKS[Component];
            }
        }
        if( AffectedComponents )
        {
            // Warnings only

            if( D3DSPSM_BIAS == pSrcParam->m_SrcMod )
                Spew( SPEW_INSTRUCTION_WARNING, m_pCurrInst,
                    "When using the bias source modifier on a register, "
                    "the previous writer should apply the saturate modifier. "
                    "This would ensure consistent behaviour across different hardware. "
                    "Affected components(*) of %s source param: %s",
                    SourceName[i],MakeAffectedComponentsText(AffectedComponents,TRUE,FALSE));
            else
                Spew( SPEW_INSTRUCTION_WARNING, m_pCurrInst,
                    "When using the complement source modifier on a register, "
                    "the previous writer should apply the saturate destination modifier. "
                    "This would ensure consistent behaviour across different hardware. "
                    "Affected components(*) of %s source param: %s",
                    SourceName[i],MakeAffectedComponentsText(AffectedComponents,TRUE,FALSE));
        }
    }
#endif
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_SrcNoLongerAvailable
//
// ** Rule:
// for each source parameter,
//     if it refers to a texture register then
//          for each component of the source register that needs to be read,
//              the src register cannot have been written by TEXKILL or TEXM*PAD TEXM3x2DEPTH instructions, and
//              if the instruction is a tex op then
//                  the src register cannot have been written by TEXBEM or TEXBEML
//              else
//                  the src register cannot have been read by any tex op (1.0 only)
//                          
//
// ** When to call:
// Per instruction. This rule must be called before Rule_ValidDstParam(),
//                  and before Rule_SrcInitialized(),
//                  but after Rule_ValidSrcParams()
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_SrcNoLongerAvailable()
{
    for( UINT i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
    {
        SRCPARAM* pSrcParam = &(m_pCurrInst->m_SrcParam[i]);
        UINT RegNum = pSrcParam->m_RegNum;
        char* SourceName[3] = {"first", "second", "third"};
        DWORD AffectedComponents = 0;

        if( m_bSrcParamError[i] ) continue;

        for( UINT Component = 0; Component < 4; Component++ )
        {
            if( !(pSrcParam->m_ComponentReadMask & COMPONENT_MASKS[Component]) )
                continue;

            if( D3DSPR_TEXTURE == pSrcParam->m_RegType )
            {
                CAccessHistoryNode* pMostRecentWriter = m_pTextureRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                if( pMostRecentWriter && pMostRecentWriter->m_pInst  )
                {
                    switch( pMostRecentWriter->m_pInst->m_Type )
                    {
                    case D3DSIO_TEXKILL:
                    case D3DSIO_TEXM3x2DEPTH:
                    case D3DSIO_TEXM3x2PAD:
                    case D3DSIO_TEXM3x3PAD:
                        AffectedComponents |= COMPONENT_MASKS[Component];
                    }
                }
            }
        }
        if( AffectedComponents )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                "Texture register result of texkill%s or texm*pad instructions must not be read. Affected components(*) of %s source param: %s",
                (D3DPS_VERSION(1,3) <= m_Version) ? ", texm3x2depth" : "",
                SourceName[i],MakeAffectedComponentsText(AffectedComponents,TRUE,FALSE));
            m_ErrorCount++;
            m_bSrcParamError[i] = TRUE;
        }

        if( _CURR_PS_INST->m_bTexOp )
        {
            AffectedComponents = 0;
            for( UINT Component = 0; Component < 4; Component++ )
            {
                if( !(pSrcParam->m_ComponentReadMask & COMPONENT_MASKS[Component]) )
                    continue;

                if( D3DSPR_TEXTURE == pSrcParam->m_RegType )
                {
                    CAccessHistoryNode* pMostRecentWriter = m_pTextureRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                    if( pMostRecentWriter && pMostRecentWriter->m_pInst )
                    {
                        switch( pMostRecentWriter->m_pInst->m_Type )
                        {
                        case D3DSIO_TEXBEM:
                        case D3DSIO_TEXBEML:
                            AffectedComponents |= COMPONENT_MASKS[Component];
                            break;
                        }
                    }
                }
            }
            if( AffectedComponents )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                    "Texture register result of texbem or texbeml instruction must not be read by tex* instruction. Affected components(*) of %s source param: %s",
                    SourceName[i],MakeAffectedComponentsText(AffectedComponents,TRUE,FALSE));
                m_ErrorCount++;
                m_bSrcParamError[i] = TRUE;
            }
        }
        else // non-tex op
        {
            if( D3DPS_VERSION(1,1) <= m_Version )
                continue;

            AffectedComponents = 0;
            for( UINT Component = 0; Component < 4; Component++ )
            {
                if( !(pSrcParam->m_ComponentReadMask & COMPONENT_MASKS[Component]) )
                    continue;

                if( D3DSPR_TEXTURE == pSrcParam->m_RegType )
                {
                    CAccessHistoryNode* pMostRecentAccess = m_pTextureRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentAccess;
                    if( pMostRecentAccess &&
                        pMostRecentAccess->m_pInst &&
                        pMostRecentAccess->m_bRead &&
                        ((CPSInstruction*)(pMostRecentAccess->m_pInst))->m_bTexOp )
                    {
                        AffectedComponents |= COMPONENT_MASKS[Component];
                    }
                }
            }
            if( AffectedComponents )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                    "Texture register that has been read by a tex* instruction cannot be read by a non-tex* instruction. Affected components(*) of %s source param: %s",
                    SourceName[i],MakeAffectedComponentsText(AffectedComponents,TRUE,FALSE));
                m_ErrorCount++;
                m_bSrcParamError[i] = TRUE;
            }
        }
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_MultipleDependentTextureReads
//
// ** Rule:
//
// Multiple dependent texture reads are disallowed.  So texture read results
// can be used as an address in a subsequent read, but the results from that
// second read cannot be used as an address in yet another subsequent read.
//
// As pseudocode:
//
// if current instruction (x) is a tex-op that reads a texture
//     for each source param of x
//         if the register is a texture register
//         and there exists a previous writer (y),
//         and y is a tex op that reads a texture
//         if there exists a souce parameter of y that was previously
//              written by an instruction that reads a texture (z)
//              SPEW(Error)
//
// NOTE that it is assumed that tex ops must write to all components, so
// only the read/write history for the R component is being checked.
//
// ** When to call:
// Per instruction. This rule must be called before Rule_ValidDstParam(),
//                  and Rule_SrcInitialized()
//                  but after Rule_ValidSrcParams()
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_MultipleDependentTextureReads()
{
    if( !_CURR_PS_INST->m_bTexOpThatReadsTexture )
        return TRUE;

    for( UINT i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
    {
        SRCPARAM* pSrcParam = &(m_pCurrInst->m_SrcParam[i]);
        UINT RegNum = pSrcParam->m_RegNum;
        char* SourceName[3] = {"first", "second", "third"};

        if( m_bSrcParamError[i] ) continue;

        // Just looking at component 0 in this function because we assume tex ops write to all components.
        if( !(pSrcParam->m_ComponentReadMask & COMPONENT_MASKS[0]) )
            continue;

        if( D3DSPR_TEXTURE != pSrcParam->m_RegType )
            continue;

        CAccessHistoryNode* pMostRecentWriter = m_pTextureRegFile->m_pAccessHistory[0][RegNum].m_pMostRecentWriter;
        if( (!pMostRecentWriter) || (!pMostRecentWriter->m_pInst) )
            continue;

        if(!((CPSInstruction*)(pMostRecentWriter->m_pInst))->m_bTexOp)
            continue;

        if(!((CPSInstruction*)(pMostRecentWriter->m_pInst))->m_bTexOpThatReadsTexture)
            continue;

        for( UINT j = 0; j < pMostRecentWriter->m_pInst->m_SrcParamCount; j++ )
        {
            if( D3DSPR_TEXTURE != pMostRecentWriter->m_pInst->m_SrcParam[j].m_RegType )
                continue;

            CAccessHistoryNode* pRootInstructionHistoryNode =
                m_pTextureRegFile->m_pAccessHistory[0][pMostRecentWriter->m_pInst->m_SrcParam[j].m_RegNum].m_pMostRecentWriter;

            CPSInstruction* pRootInstruction = pRootInstructionHistoryNode ? (CPSInstruction*)pRootInstructionHistoryNode->m_pInst : NULL;

            if( (D3DSPR_TEXTURE == pMostRecentWriter->m_pInst->m_SrcParam[j].m_RegType)
                && pRootInstruction->m_bTexOpThatReadsTexture )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                    "Multiple dependent texture reads are disallowed (%s source param).  Texture read results can be used as an address for subsequent read, but the results from that read cannot be used as an address in yet another subsequent read.",
                    SourceName[i]);
                m_ErrorCount++;
                m_bSrcParamError[i] = TRUE;
                break;
            }
        }
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_SrcInitialized
//
// ** Rule:
// for each source parameter,
//      if source is a TEMP or TEXTURE register then
//          if the source swizzle is D3DSP_NOSWIZZLE then
//              if the current instruction is DP3 (a cross component op) then
//                  the r, g and b components of of the source reg
//                  must have been previously written
//              else if there is a dest parameter, then
//                  the components in the dest parameter write mask must
//                  have been written to in the source reg. previously
//              else
//                  all components of the source must have been written
//          else if the source swizzle is _REPLICATEALPHA then
//              alpha component of reg must have been previously
//              written
//
// When checking if a component has been written previously,
// it must have been written in a previous cycle - so in the
// case of co-issued instructions, initialization of a component
// by one co-issued instruction is not available to the other for read.
//
// Note that the parameter count for D3DSIO_DEF is treated as 1
// (dest only), so this rule does nothing for it.
//
// ** When to call:
// Per instruction. This rule must be called before Rule_ValidDstParam().
//
// ** Returns:
// Always TRUE.
//
// NOTE: This rule also updates the access history to indicate reads of the
// affected components of each source register.
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_SrcInitialized()
{
    DSTPARAM* pDstParam = &(m_pCurrInst->m_DstParam);

    for( UINT i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
    {
        SRCPARAM* pSrcParam = &(m_pCurrInst->m_SrcParam[i]);
        UINT RegNum = pSrcParam->m_RegNum;
        CRegisterFile* pRegFile = NULL;
        char* RegChar = NULL;
        DWORD UninitializedComponentsMask = 0;
        CAccessHistoryNode* pWriterInCurrCycle[4] = {0, 0, 0, 0};
        UINT NumUninitializedComponents = 0;

        if( m_bSrcParamError[i] ) continue;

        switch( pSrcParam->m_RegType )
        {
            case D3DSPR_TEMP:
                pRegFile = m_pTempRegFile;
                RegChar = "r";
                break;
            case D3DSPR_TEXTURE:
                pRegFile = m_pTextureRegFile;
                RegChar = "t";
                break;
            case D3DSPR_INPUT:
                pRegFile = m_pInputRegFile;
                RegChar = "v";
                break;
            case D3DSPR_CONST:
                pRegFile = m_pConstRegFile;
                RegChar = "c";
                break;
        }
        if( !pRegFile ) continue;

        // check for read of uninitialized components
        if( D3DSPR_TEMP == pSrcParam->m_RegType ||
            D3DSPR_TEXTURE == pSrcParam->m_RegType )
        {
            for( UINT Component = 0; Component < 4; Component++ )
            {
                if( !(pSrcParam->m_ComponentReadMask & COMPONENT_MASKS[Component]) )
                    continue;

                CAccessHistoryNode* pPreviousWriter = pRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                CBaseInstruction* pCurrInst = m_pCurrInst;

                // If co-issue, find the real previous writer.
                while( pPreviousWriter
                       && ((CPSInstruction*)pPreviousWriter->m_pInst)->m_CycleNum == _CURR_PS_INST->m_CycleNum )
                {
                    pWriterInCurrCycle[Component] = pPreviousWriter; // log read just before this write for co-issue
                    pPreviousWriter = pPreviousWriter->m_pPreviousWriter;
                }

                // Even if pPreviousWriter == NULL, the component could have been initialized pre-shader.
                // So to check for initialization, we look at m_bInitialized below, rather than pPreviousWrite
                if(pPreviousWriter == NULL && !pRegFile->m_pAccessHistory[Component][RegNum].m_bPreShaderInitialized)
                {
                    NumUninitializedComponents++;
                    UninitializedComponentsMask |= COMPONENT_MASKS[Component];
                }
            }

            if( NumUninitializedComponents )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Read of uninitialized component%s(*) in %s%d: %s",
                    NumUninitializedComponents > 1 ? "s" : "",
                    RegChar, RegNum, MakeAffectedComponentsText(UninitializedComponentsMask,TRUE,FALSE));
                m_ErrorCount++;
            }
        }

        // Update register file to indicate READ.
        // Multiple reads of the same register component by the current instruction
        // will only be logged as one read in the access history.

        for( UINT Component = 0; Component < 4; Component++ )
        {
            #define PREV_READER(_CHAN,_REG) \
                    ((NULL == pRegFile->m_pAccessHistory[_CHAN][_REG].m_pMostRecentReader) ? NULL :\
                    pRegFile->m_pAccessHistory[_CHAN][_REG].m_pMostRecentReader->m_pInst)

            if( !(pSrcParam->m_ComponentReadMask & COMPONENT_MASKS[Component]) )
                continue;

            if( NULL != pWriterInCurrCycle[Component] )
            {
                if( !pWriterInCurrCycle[Component]->m_pPreviousReader ||
                    pWriterInCurrCycle[Component]->m_pPreviousReader->m_pInst != m_pCurrInst )
                {
                    if( !pRegFile->m_pAccessHistory[Component][RegNum].InsertReadBeforeWrite(
                                            pWriterInCurrCycle[Component], m_pCurrInst ) )
                    {
                        Spew( SPEW_GLOBAL_ERROR, NULL, "Out of memory");
                        m_ErrorCount++;
                    }
                }
            }
            else if( PREV_READER(Component,RegNum) != m_pCurrInst )
            {
                if( !pRegFile->m_pAccessHistory[Component][RegNum].NewAccess(m_pCurrInst,FALSE) )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Out of memory");
                    m_ErrorCount++;
                }
            }
        }
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_ValidDstParam
//
// ** Rule:
// if instruction is D3DSIO_DEF, then do nothing - this case has its own separate rule
// the dst register must be writable.
// if the instruction has a dest parameter (i.e. every instruction except NOP), then
//      the dst register must be of type D3DSPR_TEMP or _TEXTURE, and
//      register # must be within range for the register type, and
//      the write mask must be: .rgba, .a or .rgb
//      if instruction is a texture instruction, then
//          the dst register must be of type D3DSPR_TEXTURE, and
//          the writemask must be D3DSP_WRITEMASK_ALL, and
//          the dst modifier must be D3DSPDM_NONE (or _SAT on version > 1.2), and
//          the dst shift must be none
//      else (non tex instruction)
//          the dst modifier must be D3DSPDM_NONE or _SATURATE, and
//          dst shift must be /2, none, *2, or *4
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
// NOTE: After checking the dst parameter, if no error was found,
// the write to the appropriate component(s) of the destination register
// is recorded by this function, so subsequent rules may check for previous
// write to registers.
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_ValidDstParam() // could break this down for more granularity
{
    BOOL   bFoundDstError = FALSE;
    DSTPARAM* pDstParam = &(m_pCurrInst->m_DstParam);
    UINT RegNum = pDstParam->m_RegNum;
    if( D3DSIO_DEF == m_pCurrInst->m_Type )
    {
        // _DEF is a special instruction whose dest is a const register.
        // We do the checking for this in a separate function.
        // Also, we don't need to keep track of the fact that
        // this instruction wrote to a register (done below),
        // since _DEF just declares a constant.
        return TRUE;
    }

    if( pDstParam->m_bParamUsed )
    {
        UINT ValidRegNum = 0;

        BOOL bWritable = FALSE;
        switch( pDstParam->m_RegType )
        {
        case D3DSPR_TEMP:
            bWritable = m_pTempRegFile->IsWritable();
            ValidRegNum = m_pTempRegFile->GetNumRegs();
            break;
        case D3DSPR_TEXTURE:
            if( _CURR_PS_INST->m_bTexOp )
                bWritable = TRUE;
            else
                bWritable = m_pTextureRegFile->IsWritable();

            ValidRegNum = m_pTextureRegFile->GetNumRegs();
            break;
        }

        if( !bWritable || !ValidRegNum )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid reg type for dest param." );
            m_ErrorCount++;
            bFoundDstError = TRUE;
        }
        else if( RegNum >= ValidRegNum )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid dest reg num: %d. Max allowed for this reg type is %d.",
                RegNum, ValidRegNum - 1);
            m_ErrorCount++;
            bFoundDstError = TRUE;
        }
        else
        {
            // Make sure we aren't writing to a register that is no longer available.

            if( D3DSPR_TEXTURE == pDstParam->m_RegType )
            {
                for( UINT Component = 0; Component < 4; Component++ )
                {
                    CAccessHistoryNode* pMostRecentWriter = m_pTextureRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                    if( pMostRecentWriter && pMostRecentWriter->m_pInst  )
                    {
                        switch( pMostRecentWriter->m_pInst->m_Type )
                        {
                        case D3DSIO_TEXM3x2DEPTH:
                            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                                "Destination of texm3x2depth instruction (t%d) is not available elsewhere in shader.",
                                RegNum);
                            m_ErrorCount++;
                            return TRUE;
                        }
                    }
                }
            }
        }

        if( _CURR_PS_INST->m_bTexOp )
        {
            if( D3DSPR_TEXTURE != pDstParam->m_RegType )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Must use texture register a dest param for tex* instructions." );
                m_ErrorCount++;
                bFoundDstError = TRUE;
            }
            if( D3DSP_WRITEMASK_ALL != pDstParam->m_WriteMask )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "tex* instructions must write all components." );
                m_ErrorCount++;
                bFoundDstError = TRUE;
            }
            switch( pDstParam->m_DstMod )
            {
            case D3DSPDM_NONE:
                break;
            case D3DSPDM_SATURATE:
                // falling through
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Instruction modifiers are not allowed for tex* instructions." );
                m_ErrorCount++;
                bFoundDstError = TRUE;
            }
            switch( pDstParam->m_DstShift )
            {
            case DSTSHIFT_NONE:
                break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Dest shift not allowed for tex* instructions." );
                m_ErrorCount++;
                bFoundDstError = TRUE;
            }
        }
        else
        {
            switch( pDstParam->m_DstMod )
            {
            case D3DSPDM_NONE:
            case D3DSPDM_SATURATE:
                break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid dst modifier." );
                m_ErrorCount++;
                bFoundDstError = TRUE;
            }

            switch( pDstParam->m_DstShift )
            {
            case DSTSHIFT_NONE:
            case DSTSHIFT_X2:
            case DSTSHIFT_X4:
            case DSTSHIFT_D2:
                break;
            default:
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid dst shift." );
                m_ErrorCount++;
                bFoundDstError = TRUE;
            }
        }

        if( (D3DSP_WRITEMASK_ALL != pDstParam->m_WriteMask)
            && ((D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2) != pDstParam->m_WriteMask )
            && (D3DSP_WRITEMASK_3 != pDstParam->m_WriteMask ) )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Dest write mask must be .rgb, .a, or .rgba (all)." );
            m_ErrorCount++;
            bFoundDstError = TRUE;
        }

        if( !bFoundDstError )
        {
            // Update register file to indicate write.
            
            CRegisterFile* pRegFile = NULL;
            switch( pDstParam->m_RegType )
            {
            case D3DSPR_TEMP:       pRegFile = m_pTempRegFile; break;
            case D3DSPR_TEXTURE:    pRegFile = m_pTextureRegFile; break;
            }

            if( pRegFile )
            {
                if( pDstParam->m_WriteMask & D3DSP_WRITEMASK_0 )
                    pRegFile->m_pAccessHistory[0][RegNum].NewAccess(m_pCurrInst,TRUE);

                if( pDstParam->m_WriteMask & D3DSP_WRITEMASK_1 )
                    pRegFile->m_pAccessHistory[1][RegNum].NewAccess(m_pCurrInst,TRUE);

                if( pDstParam->m_WriteMask & D3DSP_WRITEMASK_2 )
                    pRegFile->m_pAccessHistory[2][RegNum].NewAccess(m_pCurrInst,TRUE);

                if( pDstParam->m_WriteMask & D3DSP_WRITEMASK_3 )
                    pRegFile->m_pAccessHistory[3][RegNum].NewAccess(m_pCurrInst,TRUE);
            }
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_ValidRegisterPortUsage
//
// ** Rule:
// Each register class (TEMP,TEXTURE,INPUT,CONST) may only appear as parameters
// in an individual instruction up to a maximum number of times.
//
// Multiple accesses to the same register number (in the same register class)
// only count as one access.
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_ValidRegisterPortUsage()
{
    UINT i, j;
    UINT TempRegPortUsage[SHADER_INSTRUCTION_MAX_SRCPARAMS];
    UINT InputRegPortUsage[SHADER_INSTRUCTION_MAX_SRCPARAMS];
    UINT ConstRegPortUsage[SHADER_INSTRUCTION_MAX_SRCPARAMS];
    UINT TextureRegPortUsage[SHADER_INSTRUCTION_MAX_SRCPARAMS];
    UINT NumUniqueTempRegs = 0;
    UINT NumUniqueInputRegs = 0;
    UINT NumUniqueConstRegs = 0;
    UINT NumUniqueTextureRegs = 0;
    D3DSHADER_PARAM_REGISTER_TYPE   RegType;
    UINT                            RegNum;

    static UINT s_TempRegPortUsageAcrossCoIssue[SHADER_INSTRUCTION_MAX_SRCPARAMS];
    static UINT s_InputRegPortUsageAcrossCoIssue[SHADER_INSTRUCTION_MAX_SRCPARAMS];
    static UINT s_ConstRegPortUsageAcrossCoIssue[SHADER_INSTRUCTION_MAX_SRCPARAMS];
    static UINT s_TextureRegPortUsageAcrossCoIssue[SHADER_INSTRUCTION_MAX_SRCPARAMS];
    static UINT s_NumUniqueTempRegsAcrossCoIssue;
    static UINT s_NumUniqueInputRegsAcrossCoIssue;
    static UINT s_NumUniqueConstRegsAcrossCoIssue;
    static UINT s_NumUniqueTextureRegsAcrossCoIssue;
 
    if( NULL == m_pCurrInst->m_pPrevInst )   // First instruction - initialize static vars
    {
        s_NumUniqueTempRegsAcrossCoIssue = 0;
        s_NumUniqueInputRegsAcrossCoIssue = 0;
        s_NumUniqueConstRegsAcrossCoIssue = 0;
        s_NumUniqueTextureRegsAcrossCoIssue = 0;
    }
 
    for( i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
    {
        UINT*   pRegPortUsage = NULL;
        UINT*   pNumUniqueRegs = NULL;

        RegType = m_pCurrInst->m_SrcParam[i].m_RegType;
        RegNum = m_pCurrInst->m_SrcParam[i].m_RegNum;

        switch( RegType )
        {
        case D3DSPR_TEMP:
            pRegPortUsage = TempRegPortUsage;
            pNumUniqueRegs = &NumUniqueTempRegs;
            break;
        case D3DSPR_INPUT:
            pRegPortUsage = InputRegPortUsage;
            pNumUniqueRegs = &NumUniqueInputRegs;
            break;
        case D3DSPR_CONST:
            pRegPortUsage = ConstRegPortUsage;
            pNumUniqueRegs = &NumUniqueConstRegs;
            break;
        case D3DSPR_TEXTURE:
            pRegPortUsage = TextureRegPortUsage;
            pNumUniqueRegs = &NumUniqueTextureRegs;
            break;
        }

        if( !pRegPortUsage ) continue;

        BOOL    bRegAlreadyAccessed = FALSE;
        for( j = 0; j < *pNumUniqueRegs; j++ )
        {
            if( pRegPortUsage[j] == RegNum )
            {
                bRegAlreadyAccessed = TRUE;
                break;
            }
        }
        if( !bRegAlreadyAccessed )
        {
            pRegPortUsage[*pNumUniqueRegs] = RegNum;
            (*pNumUniqueRegs)++;
        }

    }

    if( NumUniqueTempRegs > m_pTempRegFile->GetNumReadPorts() )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%d different temp registers (r#) read by instruction.  Max. different temp registers readable per instruction is %d.",
                        NumUniqueTempRegs,  m_pTempRegFile->GetNumReadPorts());
        m_ErrorCount++;
    }

    if( NumUniqueInputRegs > m_pInputRegFile->GetNumReadPorts() )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%d different input registers (v#) read by instruction.  Max. different input registers readable per instruction is %d.",
                        NumUniqueInputRegs,  m_pInputRegFile->GetNumReadPorts());
        m_ErrorCount++;
    }

    if( NumUniqueConstRegs > m_pConstRegFile->GetNumReadPorts() )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%d different constant registers (c#) read by instruction.  Max. different constant registers readable per instruction is %d.",
                        NumUniqueConstRegs, m_pConstRegFile->GetNumReadPorts());
        m_ErrorCount++;
    }

    if( NumUniqueTextureRegs > m_pTextureRegFile->GetNumReadPorts() )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%d different texture registers (t#) read by instruction.  Max. different texture registers readable per instruction is %d.",
                        NumUniqueTextureRegs, m_pTextureRegFile->GetNumReadPorts());
        m_ErrorCount++;
    }

    // Read port limit for different register numbers of any one register type across co-issued instructions is MAX_READPORTS_ACROSS_COISSUE total.

    if( _CURR_PS_INST->m_bCoIssue && _PREV_PS_INST && !(_PREV_PS_INST->m_bCoIssue)) // second clause is just a simple sanity check -> co-issue only involved 2 instructions.
    {
        for( i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
        {
            UINT*   pRegPortUsageAcrossCoIssue = NULL;
            UINT*   pNumUniqueRegsAcrossCoIssue = NULL;

            RegType = m_pCurrInst->m_SrcParam[i].m_RegType;
            RegNum = m_pCurrInst->m_SrcParam[i].m_RegNum;

            switch( RegType )
            {
            case D3DSPR_TEMP:
                pRegPortUsageAcrossCoIssue = s_TempRegPortUsageAcrossCoIssue;
                pNumUniqueRegsAcrossCoIssue = &s_NumUniqueTempRegsAcrossCoIssue;
                break;
            case D3DSPR_INPUT:
                pRegPortUsageAcrossCoIssue = s_InputRegPortUsageAcrossCoIssue;
                pNumUniqueRegsAcrossCoIssue = &s_NumUniqueInputRegsAcrossCoIssue;
                break;
            case D3DSPR_CONST:
                pRegPortUsageAcrossCoIssue = s_ConstRegPortUsageAcrossCoIssue;
                pNumUniqueRegsAcrossCoIssue = &s_NumUniqueConstRegsAcrossCoIssue;
                break;
            case D3DSPR_TEXTURE:
                pRegPortUsageAcrossCoIssue = s_TextureRegPortUsageAcrossCoIssue;
                pNumUniqueRegsAcrossCoIssue = &s_NumUniqueTextureRegsAcrossCoIssue;
                break;
            }

            if( !pRegPortUsageAcrossCoIssue ) continue;

            BOOL    bRegAlreadyAccessed = FALSE;
            for( j = 0; j < *pNumUniqueRegsAcrossCoIssue; j++ )
            {
                if( pRegPortUsageAcrossCoIssue[j] == RegNum )
                {
                    bRegAlreadyAccessed = TRUE;
                    break;
                }
            }
            if( !bRegAlreadyAccessed )
            {
                pRegPortUsageAcrossCoIssue[*pNumUniqueRegsAcrossCoIssue] = RegNum;
                (*pNumUniqueRegsAcrossCoIssue)++;
            }
        }

        #define MAX_READPORTS_ACROSS_COISSUE    3

        if( s_NumUniqueTempRegsAcrossCoIssue > MAX_READPORTS_ACROSS_COISSUE )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "%d different temp registers (r#) read over 2 co-issued instructions. "\
                            "Max. different register numbers from any one register type readable across co-issued instructions is %d.",
                            s_NumUniqueTempRegsAcrossCoIssue, MAX_READPORTS_ACROSS_COISSUE);
            m_ErrorCount++;
        }

        if( s_NumUniqueInputRegsAcrossCoIssue > MAX_READPORTS_ACROSS_COISSUE )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "%d different input registers (v#) read over 2 co-issued instructions. "\
                            "Max. different register numbers from any one register type readable across co-issued instructions is %d.",
                            s_NumUniqueInputRegsAcrossCoIssue, MAX_READPORTS_ACROSS_COISSUE);
            m_ErrorCount++;
        }

        if( s_NumUniqueConstRegsAcrossCoIssue > MAX_READPORTS_ACROSS_COISSUE )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "%d different constant registers (c#) read over 2 co-issued instructions. "\
                            "Max. different register numbers from any one register type readable across co-issued instructions is %d.",
                            s_NumUniqueConstRegsAcrossCoIssue, MAX_READPORTS_ACROSS_COISSUE);
            m_ErrorCount++;
        }

        if( s_NumUniqueTextureRegsAcrossCoIssue > MAX_READPORTS_ACROSS_COISSUE )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "%d different texture registers (t#) read over 2 co-issued instructions. "\
                            "Max. different register numbers from any one register type readable across co-issued instructions is %d.",
                            s_NumUniqueTextureRegsAcrossCoIssue, MAX_READPORTS_ACROSS_COISSUE);
            m_ErrorCount++;
        }
    }

    if( !_CURR_PS_INST->m_bCoIssue )
    {
        // Copy all state to static vars so that in case next instruction is co-issued with this one, 
        // cross-coissue read port limit of 3 can be enforced.
        memcpy(&s_TempRegPortUsageAcrossCoIssue,&TempRegPortUsage,NumUniqueTempRegs*sizeof(UINT));
        memcpy(&s_InputRegPortUsageAcrossCoIssue,&InputRegPortUsage,NumUniqueInputRegs*sizeof(UINT));
        memcpy(&s_ConstRegPortUsageAcrossCoIssue,&ConstRegPortUsage,NumUniqueConstRegs*sizeof(UINT));
        memcpy(&s_TextureRegPortUsageAcrossCoIssue,&TextureRegPortUsage,NumUniqueTextureRegs*sizeof(UINT));
        s_NumUniqueTempRegsAcrossCoIssue = NumUniqueTempRegs;
        s_NumUniqueInputRegsAcrossCoIssue = NumUniqueInputRegs;
        s_NumUniqueConstRegsAcrossCoIssue = NumUniqueConstRegs;
        s_NumUniqueTextureRegsAcrossCoIssue = NumUniqueTextureRegs;
    }
    else
    {
        // reset counts because the next instruction cannot be co-issued with this one.
        s_NumUniqueTempRegsAcrossCoIssue = 0;
        s_NumUniqueInputRegsAcrossCoIssue = 0;
        s_NumUniqueConstRegsAcrossCoIssue = 0;
        s_NumUniqueTextureRegsAcrossCoIssue = 0;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_TexRegsDeclaredInOrder
//
// ** Rule:
// Tex registers must declared in increasing order.
// ex. invalid sequence:    tex t0
//                          tex t3
//                          tex t1
//
//     another invalid seq: tex t0
//                          tex t1
//                          texm3x2pad t1, t0 (t1 already declared)
//                          texm3x2pad t2, t0
//
//     valid sequence:      tex t0
//                          tex t1
//                          tex t3 (note missing t2.. OK)
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_TexRegsDeclaredInOrder()
{
    static DWORD s_TexOpRegDeclOrder; // bit flags

    if( NULL == m_pCurrInst->m_pPrevInst )   // First instruction - initialize static vars
    {
        s_TexOpRegDeclOrder = 0;
    }
    if( !_CURR_PS_INST->m_bTexOp )
        return TRUE;

    DWORD RegNum = m_pCurrInst->m_DstParam.m_RegNum;
    if( (D3DSPR_TEXTURE != m_pCurrInst->m_DstParam.m_RegType) ||
        (RegNum > m_pTextureRegFile->GetNumRegs()) )
    {
        return TRUE;
    }

    DWORD RegMask = 1 << m_pCurrInst->m_DstParam.m_RegNum;
    if( RegMask & s_TexOpRegDeclOrder)
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Tex register t%d already declared.",
                        RegNum);
        m_ErrorCount++;
    } 
    else if( s_TexOpRegDeclOrder > RegMask )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "t# registers must appear in sequence (i.e. t0 before t2 OK, but t1 before t0 not valid)." );
        m_ErrorCount++;
    }
    s_TexOpRegDeclOrder |= (1 << m_pCurrInst->m_DstParam.m_RegNum);
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_TexOpAfterNonTexOp
//
// ** Rule:
// Tex ops (see IsTexOp() for which instructions are considered tex ops)
// must appear before any other instruction, with the exception of DEF or NOP.
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_TexOpAfterNonTexOp()
{
    static BOOL s_bFoundNonTexOp;
    static BOOL s_bRuleDisabled;

    if( NULL == m_pCurrInst->m_pPrevInst ) // First instruction - initialize static vars
    {
        s_bFoundNonTexOp = FALSE;
        s_bRuleDisabled = FALSE;
    }

    if( s_bRuleDisabled )
        return TRUE;

    // Execute the rule.

    if( !(_CURR_PS_INST->m_bTexOp)
        && m_pCurrInst->m_Type != D3DSIO_NOP
        && m_pCurrInst->m_Type != D3DSIO_DEF)
    {
        s_bFoundNonTexOp = TRUE;
        return TRUE;
    }

    if( _CURR_PS_INST->m_bTexOp && s_bFoundNonTexOp )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Cannot use tex* instruction after non-tex* instruction." );
        m_ErrorCount++;
        s_bRuleDisabled = TRUE;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_ValidTEXM3xSequence
//
// ** Rule:
// TEXM3x* instructions, if present in the pixel shader, must appear in
// any of the follwing sequences:
//
//      1) texm3x2pad
//      2) texm3x2tex / texdepth
//
// or   1) texm3x3pad
//      2) texm3x3pad
//      3) texm3x3tex
//
// or   1) texm3x3pad
//      2) texm3x3pad
//      3) texm3x3spec / texm3x3vspec
//
// ** When to call:
// Per instruction AND after all instructions have been seen.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_ValidTEXM3xSequence()
{
    static UINT s_TexMSequence;
    static UINT s_LastInst;

    if( NULL == m_pCurrInst )
    {
        return TRUE;
    }

    if( NULL == m_pCurrInst->m_pPrevInst ) // First instruction - initialize static vars
    {
       s_TexMSequence = 0;
       s_LastInst = D3DSIO_NOP;
    }

    if( m_bSeenAllInstructions )
    {
        if( s_TexMSequence )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Incomplete texm* sequence." );
            m_ErrorCount++;
        }
        return TRUE;
    }

    // Execute the rule.

    if( _CURR_PS_INST->m_bTexMOp )
    {
        switch( m_pCurrInst->m_Type )
        {
        case D3DSIO_TEXM3x2PAD:
            if( s_TexMSequence ) goto _TexMSeqInvalid;
            m_TexMBaseDstReg = m_pCurrInst->m_DstParam.m_RegNum;
            s_TexMSequence = 1;
            break;
        case D3DSIO_TEXM3x2TEX:
        case D3DSIO_TEXM3x2DEPTH:
            // must be one 3x2PAD previous
            if ( (s_TexMSequence != 1) ||
                 (s_LastInst != D3DSIO_TEXM3x2PAD) ) goto _TexMSeqInvalid;
            s_TexMSequence = 0;
            break;
        case D3DSIO_TEXM3x3PAD:
            if (s_TexMSequence)
            {
                // if in sequence, then must be one 3x3PAD previous
                if ( (s_TexMSequence != 1) ||
                     (s_LastInst != D3DSIO_TEXM3x3PAD) ) goto _TexMSeqInvalid;
                s_TexMSequence = 2;
                break;
            }
            m_TexMBaseDstReg = m_pCurrInst->m_DstParam.m_RegNum;
            s_TexMSequence = 1;
            break;
        case D3DSIO_TEXM3x3:
        case D3DSIO_TEXM3x3TEX:
        case D3DSIO_TEXM3x3SPEC:
        case D3DSIO_TEXM3x3VSPEC:
            // must be two 3x3PAD previous
            if ( (s_TexMSequence != 2) ||
                 (s_LastInst != D3DSIO_TEXM3x3PAD) ) goto _TexMSeqInvalid;
            s_TexMSequence = 0;
            break;
        default:
            break;
        }
        goto _TexMSeqOK;
_TexMSeqInvalid:
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid texm* sequence." );
        m_ErrorCount++;
    }
_TexMSeqOK:

    s_LastInst = m_pCurrInst->m_Type;
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_ValidTEXM3xRegisterNumbers
//
// ** Rule:
// If instruction is a TEXM3x*, register numbers must be as follows:
//
//      1) texm3x2pad / texm3x2depth    t(x), t(y)
//      2) texm3x2tex                   t(x+1), t(y)
//
//      1) texm3x3pad                   t(x), t(y)
//      2) texm3x3pad                   t(x+1), t(y)
//      3) texm3x3tex/texm3x3           t(x+2), t(y)
//
//      1) texm3x3pad                   t(x), t(y)
//      2) texm3x3pad                   t(x+1), t(y)
//      3) texm3x3spec                  t(x+2), t(y), c#
//
//      1) texm3x3pad                   t(x), t(y)
//      2) texm3x3pad                   t(x+1), t(y)
//      3) texm3x3vspec                 t(x+2), t(y)
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_ValidTEXM3xRegisterNumbers()
{
    #define PREV_INST_TYPE(_INST) \
                ((_INST && _INST->m_pPrevInst) ? _INST->m_pPrevInst->m_Type : D3DSIO_NOP)

    #define PREV_INST_SRC0_REGNUM(_INST) \
                ((_INST && _INST->m_pPrevInst) ? _INST->m_pPrevInst->m_SrcParam[0].m_RegNum : -1)

    if( _CURR_PS_INST->m_bTexMOp )
    {
        DWORD DstParamR = m_pCurrInst->m_DstParam.m_RegNum;
        DWORD SrcParam0R = m_pCurrInst->m_SrcParam[0].m_RegNum;
        switch (m_pCurrInst->m_Type)
        {
        case D3DSIO_TEXM3x2PAD:
            break;
        case D3DSIO_TEXM3x2TEX:
        case D3DSIO_TEXM3x2DEPTH:
            if ( DstParamR != (m_TexMBaseDstReg + 1) )
                goto _TexMRegInvalid;
            if( SrcParam0R != PREV_INST_SRC0_REGNUM(m_pCurrInst) )
                goto _TexMRegInvalid;
            break;
        case D3DSIO_TEXM3x3PAD:
        {
            if ( D3DSIO_TEXM3x3PAD == PREV_INST_TYPE(m_pCurrInst) &&
                 (DstParamR != (m_TexMBaseDstReg + 1) ) )
                    goto _TexMRegInvalid;

            if ( D3DSIO_TEXM3x3PAD == PREV_INST_TYPE(m_pCurrInst) &&
                 (SrcParam0R != PREV_INST_SRC0_REGNUM(m_pCurrInst)) )
                    goto _TexMRegInvalid;
            break;
        }
        case D3DSIO_TEXM3x3SPEC:
            // SPEC requires second src param to be from const regs
            if ( m_pCurrInst->m_SrcParam[1].m_RegType != D3DSPR_CONST )
                goto _TexMRegInvalid;
            // fall through
        case D3DSIO_TEXM3x3:
        case D3DSIO_TEXM3x3TEX:
        case D3DSIO_TEXM3x3VSPEC:
            if ( DstParamR != (m_TexMBaseDstReg + 2) )
                goto _TexMRegInvalid;
            if( SrcParam0R != PREV_INST_SRC0_REGNUM(m_pCurrInst) )
                    goto _TexMRegInvalid;
            break;
        default:
            break;
        }
        goto _TexMRegOK;
_TexMRegInvalid:
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid texm* register." );
        m_ErrorCount++;
    }
_TexMRegOK:
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_ValidCNDInstruction
//
// ** Rule:
// First source for cnd instruction must be 'r0.a' (exactly).
// i.e. cnd r1, r0.a, t0, t1
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_ValidCNDInstruction()
{
    if( D3DSIO_CND == m_pCurrInst->m_Type )
    {
        SRCPARAM Src0 = m_pCurrInst->m_SrcParam[0];
        if( Src0.m_bParamUsed &&
            D3DSPR_TEMP == Src0.m_RegType &&
            0 == Src0.m_RegNum &&
            D3DSP_REPLICATEALPHA == Src0.m_SwizzleShift &&
            D3DSPSM_NONE == Src0.m_SrcMod )
        {
            return TRUE;    // Src 0 is r0.a
        }

        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "First source for cnd instruction must be 'r0.a'." );
        m_ErrorCount++;
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_ValidCMPInstruction
//
// ** Rule:
// There may be at most 3 cmp instructions per shader.
// (only executed for ps.1.2)
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_ValidCMPInstruction()
{
    static UINT s_cCMPInstCount;

    if( NULL == m_pCurrInst->m_pPrevInst ) // First instruction - initialize static vars
    {
        s_cCMPInstCount = 0;
    }

    if( D3DSIO_CMP == m_pCurrInst->m_Type && D3DPS_VERSION(1,3) >= m_Version)
    {
        s_cCMPInstCount++;

        if( 3 < s_cCMPInstCount )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Maximum of 3 cmp instructions allowed." );
            m_ErrorCount++;
        }

    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_ValidLRPInstruction
//
// ** Rule:
// The only valid source modifier for the src0 operand for LRP is complement
// (1-reg)
// i.e. lrp r1, 1-r0, t0, t1
//
// If there was a previous writer to src0, then it must have applied
// the _sat destination modifier.
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_ValidLRPInstruction()
{
    if( D3DSIO_LRP == m_pCurrInst->m_Type )
    {
        SRCPARAM Src0 = m_pCurrInst->m_SrcParam[0];
        if( !Src0.m_bParamUsed )
            return TRUE;

        switch( Src0.m_SrcMod )
        {
        case D3DSPSM_NONE:
        case D3DSPSM_COMP:
            break;
        default:
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "The only valid modifiers for the first source parameter of lrp are: reg (no mod) or 1-reg (complement)." );
            m_ErrorCount++;
        }
#ifdef SHOW_VALIDATION_WARNINGS
        UINT RegNum = Src0.m_RegNum;
        DWORD AffectedComponents = 0;

        if( m_bSrcParamError[0] )
            return TRUE;

        for( UINT Component = 0; Component < 4; Component++ )
        {
            if( !(COMPONENT_MASKS[Component] & Src0.m_ComponentReadMask) )
                continue;

            CAccessHistoryNode* pMostRecentWriter = NULL;
            switch( Src0.m_RegType )
            {
            case D3DSPR_TEXTURE:
                pMostRecentWriter = m_pTextureRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                break;
            case D3DSPR_INPUT:
                pMostRecentWriter = m_pInputRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                break;
            case D3DSPR_TEMP:
                pMostRecentWriter = m_pTempRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                break;
            case D3DSPR_CONST:
                pMostRecentWriter = m_pConstRegFile->m_pAccessHistory[Component][RegNum].m_pMostRecentWriter;
                break;
            }

            // The previous writer may be the current instruction.
            // If so, go back one step (the previous writer before the current instruction).
            if( pMostRecentWriter && pMostRecentWriter->m_pInst &&
                pMostRecentWriter->m_pInst == m_pCurrInst )
            {
                pMostRecentWriter = pMostRecentWriter->m_pPreviousWriter;
            }

            if( pMostRecentWriter &&
                pMostRecentWriter->m_pInst &&
                !((CPSInstruction*)pMostRecentWriter->m_pInst)->m_bTexOp &&
                (D3DSPDM_SATURATE != pMostRecentWriter->m_pInst->m_DstParam.m_DstMod )
              )
            {
                AffectedComponents |= COMPONENT_MASKS[Component];
            }
        }
        if( AffectedComponents )
        {
            // A warning.
            Spew( SPEW_INSTRUCTION_WARNING, m_pCurrInst,
                "Previous writer to the first source register of lrp instruction "
                "should apply the saturate destination modifier.  This ensures consistent "
                "behaviour across different hardware. "
                "Affected components(*) of first source register: %s",
                MakeAffectedComponentsText(AffectedComponents,TRUE,FALSE));
        }
#endif // SHOW_VALIDATION_WARNINGS
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_ValidDEFInstruction
//
// ** Rule:
// For the DEF instruction, make sure the dest parameter is a valid constant,
// and it has no modifiers.
//
// NOTE that we are pretending this instruction only has a dst parameter.
// We skipped over the 4 source parameters since they are immediate floats,
// for which there is nothing that can be checked.
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_ValidDEFInstruction()
{

    static BOOL s_bDEFInstructionAllowed;

    if( NULL == m_pCurrInst->m_pPrevInst ) // First instruction - initialize static vars
    {
        s_bDEFInstructionAllowed = TRUE;
    }

    if( D3DSIO_COMMENT != m_pCurrInst->m_Type &&
        D3DSIO_DEF     != m_pCurrInst->m_Type )
    {
        s_bDEFInstructionAllowed = FALSE;
    }
    else if( D3DSIO_DEF == m_pCurrInst->m_Type )
    {
        if( !s_bDEFInstructionAllowed )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Const declaration (def) must appear before other instructions." );
            m_ErrorCount++;
        }
        DSTPARAM* pDstParam = &m_pCurrInst->m_DstParam;
        if( D3DSP_WRITEMASK_ALL != pDstParam->m_WriteMask ||
            D3DSPDM_NONE != pDstParam->m_DstMod ||
            DSTSHIFT_NONE != pDstParam->m_DstShift ||
            D3DSPR_CONST != pDstParam->m_RegType
            )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Destination for def instruction must be of the form c# (# = reg number, no modifiers)." );
            m_ErrorCount++;
        }

        // Check that the register number is in bounds
        if( D3DSPR_CONST == pDstParam->m_RegType &&
            pDstParam->m_RegNum >= m_pConstRegFile->GetNumRegs() )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid const register num: %d. Max allowed is %d.",
                        pDstParam->m_RegNum,m_pConstRegFile->GetNumRegs() - 1);
            m_ErrorCount++;

        }
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_ValidDP3Instruction
//
// ** Rule:
// The .a result write mask is not valid for the DP3 instruction.
// (version <= 1.2)
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_ValidDP3Instruction()
{
    if( D3DSIO_DP3 == m_pCurrInst->m_Type &&
        D3DPS_VERSION(1,3) >= m_Version )
    {
        if( (D3DSP_WRITEMASK_ALL != m_pCurrInst->m_DstParam.m_WriteMask)
            && ((D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2) != m_pCurrInst->m_DstParam.m_WriteMask ) )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Dest write mask must be .rgb, or .rgba (all) for dp3." );
            m_ErrorCount++;
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_ValidDP4Instruction
//
// ** Rule:
// There may be at most 4 DP4 instructions per shader.
// (only executed for ps.1.2)
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_ValidDP4Instruction()
{
    static UINT s_cDP4InstCount;

    if( NULL == m_pCurrInst->m_pPrevInst ) // First instruction - initialize static vars
    {
        s_cDP4InstCount = 0;
    }

    if( D3DSIO_DP4 == m_pCurrInst->m_Type && D3DPS_VERSION(1,3) >= m_Version )
    {
        s_cDP4InstCount++;

        if( 4 < s_cDP4InstCount )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Maximum of 4 dp4 instructions allowed." );
            m_ErrorCount++;
        }
    }
    return TRUE;
}


//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_ValidInstructionPairing
//
// ** Rule:
// - If an instruction is co-issued with another instruction,
// make sure that both do not write to any of RGB at the same time,
// and that neither instruction individually writes to all of RGBA.
//
// - Co-issue can only involve 2 instructions,
// so consecutive instructions cannot have the "+" prefix (D3DSI_COISSUE).
//
// - Co-issue of instructions only applies to pixel blend instructions (non tex-ops).
//
// - The first color blend instruction cannot have "+" (D3DSI_COISSUE) set either.
//
// - NOP may not be used in a co-issue pair.
//
// - DP4 may not be used in a co-issue pair.
//
// - DP3 (dot product) always uses the color/vector pipeline (even if it is not writing
// to color components). Thus:
//      - An instruction co-issued with a dot-product can only write to alpha.
//      - A dot-product that writes to alpha cannot be co-issued.
//      - Two dot-products cannot be co-issued.
//
// - For version <= 1.0, coissued instructions must write to the same register.
//
// ------------------
// examples:
//
//      valid pair:             mov r0.a, c0
//                              +add r1.rgb, v1, c1 (note dst reg #'s can be different)
//
//      another valid pair:     mov r0.a, c0
//                              +add r0.rgb, v1, c1
//
//      another valid pair:     dp3 r0.rgb, t1, v1
//                              +mul r0.a, t0, v0
//
//      another valid pair:     mov r0.a, c0
//                              +add r0.a, t0, t1
//
//      invalid pair:           mov r0.rgb, c0
//                              +add r0, t0, t1  (note the dst writes to rgba)
//
//      another invalid pair:   mov r1.rgb, c1
//                              +dp3 r0.a, t0, t1 (dp3 is using up color/vector pipe)
//
// ** When to call:
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_ValidInstructionPairing()
{
    static BOOL s_bSeenNonTexOp;

    if( NULL == m_pCurrInst->m_pPrevInst )   // First instruction - initialize static vars
    {
        s_bSeenNonTexOp = FALSE;
    }

    if( !s_bSeenNonTexOp && !_CURR_PS_INST->m_bTexOp )
    {
        // first non-tex op.  this cannot have co-issue set.
        if( _CURR_PS_INST->m_bCoIssue )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                "First arithmetic instruction cannot have co-issue ('+') set; there is no previous arithmetic instruction to pair with.");
            m_ErrorCount++;
        }
        s_bSeenNonTexOp = TRUE;
    }

    if( _CURR_PS_INST->m_bTexOp && _CURR_PS_INST->m_bCoIssue )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                "Cannot set co-issue ('+') on a texture instruction.  Co-issue only applies to arithmetic instructions." );
        m_ErrorCount++;
    }

    if( _CURR_PS_INST->m_bCoIssue && m_pCurrInst->m_pPrevInst &&
        _PREV_PS_INST->m_bCoIssue )
    {
        // consecutive instructions cannot have co-issue set.
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Cannot set co-issue ('+') on consecutive instructions." );
        m_ErrorCount++;
    }

    if( _CURR_PS_INST->m_bCoIssue && m_pCurrInst->m_pPrevInst &&
        (D3DSIO_NOP == m_pCurrInst->m_pPrevInst->m_Type))
    {
        // NOP cannot be part of co-issue (previous instruction found to be NOP)
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst->m_pPrevInst, "nop instruction cannot be co-issued." );
        m_ErrorCount++;
    }

    if( _CURR_PS_INST->m_bCoIssue && D3DSIO_NOP == m_pCurrInst->m_Type )
    {
        // NOP cannot be part of co-issue (current instruction found to be NOP)
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "nop instruction cannot be co-issued." );
        m_ErrorCount++;
    }

    if( _CURR_PS_INST->m_bCoIssue && m_pCurrInst->m_pPrevInst &&
        (D3DSIO_DP4 == m_pCurrInst->m_pPrevInst->m_Type))
    {
        // DP4 cannot be part of co-issue (previous instruction found to be DP4)
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst->m_pPrevInst, "dp4 instruction cannot be co-issued." );
        m_ErrorCount++;
    }

    if( _CURR_PS_INST->m_bCoIssue && D3DSIO_DP4 == m_pCurrInst->m_Type )
    {
        // DP4 cannot be part of co-issue (current instruction found to be DP4)
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "dp4 instruction cannot be co-issued." );
        m_ErrorCount++;
    }

    if( _CURR_PS_INST->m_bCoIssue && !_CURR_PS_INST->m_bTexOp &&
        NULL != m_pCurrInst->m_pPrevInst && !_PREV_PS_INST->m_bTexOp &&
        !_PREV_PS_INST->m_bCoIssue )
    {
        // instruction and previous instruction are candidate for co-issue.
        // ...do further validation...
        DWORD ColorWriteMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2;
        DWORD CurrInstWriteMask = 0;
        DWORD PrevInstWriteMask = 0;

        if( m_pCurrInst->m_DstParam.m_bParamUsed )
            CurrInstWriteMask = m_pCurrInst->m_DstParam.m_WriteMask;
        if( m_pCurrInst->m_pPrevInst->m_DstParam.m_bParamUsed )
            PrevInstWriteMask = m_pCurrInst->m_pPrevInst->m_DstParam.m_WriteMask;

        if( D3DSIO_DP3 == m_pCurrInst->m_Type &&
            D3DSIO_DP3 == m_pCurrInst->m_pPrevInst->m_Type )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                                "Co-issued instructions cannot both be dot-product, since each require use of the color/vector pipeline to execute." );
            m_ErrorCount++;
        }
        else if( D3DSIO_DP3 == m_pCurrInst->m_Type )
        {
            if( ColorWriteMask & PrevInstWriteMask )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst->m_pPrevInst,
                                    "Dot-product needs color/vector pipeline to execute, so instruction co-issued with it cannot write to color components." );
                m_ErrorCount++;
            }
            if( D3DSP_WRITEMASK_3 & CurrInstWriteMask ) // alpha in addition to the implied rgb for dp3
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                                    "Dot-product which writes alpha cannot co-issue, because both alpha and color/vector pipelines used." );
                m_ErrorCount++;
            }
        }
        else if( D3DSIO_DP3 == m_pCurrInst->m_pPrevInst->m_Type )
        {
            if( ColorWriteMask & CurrInstWriteMask )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                                    "Dot-product needs color/vector pipeline to execute, so instruction co-issued with it cannot write to color components." );
                m_ErrorCount++;
            }
            if( D3DSP_WRITEMASK_3 & PrevInstWriteMask ) // alpha in addition to the implied rgb for dp3
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst->m_pPrevInst,
                                    "Dot-product which writes alpha cannot co-issue, because both alpha and color/vector pipelines used by the dot product." );
                m_ErrorCount++;
            }
        }
        else
        {
            if( PrevInstWriteMask == D3DSP_WRITEMASK_ALL )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst->m_pPrevInst,
                                    "Co-issued instruction cannot write all components - must write either alpha or color." );
                m_ErrorCount++;
            }
            if( CurrInstWriteMask == D3DSP_WRITEMASK_ALL )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                                    "Co-issued instruction cannot write all components - must write either alpha or color." );
                m_ErrorCount++;
            }
            if( (m_pCurrInst->m_DstParam.m_RegType == m_pCurrInst->m_pPrevInst->m_DstParam.m_RegType) &&
                (m_pCurrInst->m_DstParam.m_RegNum == m_pCurrInst->m_pPrevInst->m_DstParam.m_RegNum) &&
                ((CurrInstWriteMask & PrevInstWriteMask) != 0) )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst,
                    "Co-issued instructions cannot both write to the same components of a register.  Affected components: %s",
                    MakeAffectedComponentsText(CurrInstWriteMask & PrevInstWriteMask,TRUE,FALSE)
                    );
                m_ErrorCount++;
            }
            if( (CurrInstWriteMask & ColorWriteMask) && (PrevInstWriteMask & ColorWriteMask) )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Co-issued instructions cannot both write to color components." );
                m_ErrorCount++;
            }
            if( (CurrInstWriteMask & D3DSP_WRITEMASK_3) && (PrevInstWriteMask & D3DSP_WRITEMASK_3) )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Co-issued instructions cannot both write to alpha component." );
                m_ErrorCount++;
            }
        }

        if( D3DPS_VERSION(1,0) >= m_Version )
        {
            // both co-issued instructions must write to the same register number.
            if( m_pCurrInst->m_DstParam.m_RegType != m_pCurrInst->m_pPrevInst->m_DstParam.m_RegType )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Co-issued instructions must both write to the same register type for pixelshader version <= 1.0." );
                m_ErrorCount++;
            }
            if( (m_pCurrInst->m_DstParam.m_RegNum != m_pCurrInst->m_pPrevInst->m_DstParam.m_RegNum) )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Co-issued instructions must both write to the same register number for pixelshader version <= 1.0." );
                m_ErrorCount++;
            }
        }
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_ValidInstructionCount
//
// ** Rule:
// Make sure instruction count for pixel shader version has not been exceeded.
// Separate counts are kept for texture address instructions, for
// pixel blending instructions, and for the total number of instructions.
// Note that the total may not be the sum of texture + pixel instructions.
//
// For version 1.0+, D3DSIO_TEX counts only toward the tex op limit,
// but not towards the total op count.
//
// TEXBEML takes 3 instructions.
//
// Co-issued pixel blending instructions only
// count as one instruction towards the limit.
//
// The def instruction, nop, and comments (already stripped), do not count
// toward any limits.
//
// ** When to call:
// Per instruction AND after all instructions seen.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_ValidInstructionCount()
{
    static UINT s_MaxTexOpCount;
    static UINT s_MaxBlendOpCount;
    static UINT s_MaxTotalOpCount;

    if( NULL == m_pCurrInst )
        return TRUE;

    if( NULL == m_pCurrInst->m_pPrevInst )   // First instruction - initialize static vars
    {
        m_TexOpCount = 0;
        m_BlendOpCount = 0;

        switch(m_Version)
        {
        case D3DPS_VERSION(1,0):    // DX8.0
            s_MaxTexOpCount   = 4;
            s_MaxBlendOpCount = 8;
            s_MaxTotalOpCount = 8;
            break;
        default:
        case D3DPS_VERSION(1,1):    // DX8.0
        case D3DPS_VERSION(1,2):    // DX8.1
        case D3DPS_VERSION(1,3):    // DX8.1
            s_MaxTexOpCount   = 4;
            s_MaxBlendOpCount = 8;
            s_MaxTotalOpCount = 12;
            break;
        }
    }

    if( m_bSeenAllInstructions )
    {
        if( m_TexOpCount > s_MaxTexOpCount )
        {
            Spew( SPEW_GLOBAL_ERROR, NULL, "Too many texture addressing instruction slots used: %d. Max. allowed is %d. (Note that some texture addressing instructions may use up more than one instruction slot)",
                  m_TexOpCount, s_MaxTexOpCount);
            m_ErrorCount++;
        }
        if( m_BlendOpCount > s_MaxBlendOpCount )
        {
            Spew( SPEW_GLOBAL_ERROR, NULL, "Too many arithmetic instruction slots used: %d. Max. allowed (counting any co-issued pairs as 1) is %d.",
                  m_BlendOpCount, s_MaxBlendOpCount);
            m_ErrorCount++;
        }
        if( !(m_TexOpCount > s_MaxTexOpCount && m_BlendOpCount > s_MaxBlendOpCount) // not already spewed avove 2 errors
            && (m_TotalOpCount > s_MaxTotalOpCount) )
        {
            Spew( SPEW_GLOBAL_ERROR, NULL, "Total number of instruction slots used too high: %d. Max. allowed (counting any co-issued pairs as 1) is %d.",
                  m_TotalOpCount, s_MaxTotalOpCount);
            m_ErrorCount++;
        }
        return TRUE;
    }

    switch(m_pCurrInst->m_Type)
    {
    case D3DSIO_TEXBEML:
        m_BlendOpCount += 1;
        m_TotalOpCount += 1;
        // falling through
    case D3DSIO_TEXBEM:
        if(D3DPS_VERSION(1,0) >= m_Version )
        {
            m_TexOpCount += 2;
            m_TotalOpCount += 2;
        }
        else
        {
            m_TexOpCount += 1;
            m_TotalOpCount += 1;
        }
        break;
    case D3DSIO_TEX:
        m_TexOpCount++;
        if(D3DPS_VERSION(1,1) <= m_Version)
            m_TotalOpCount += 1;
        break;
    case D3DSIO_TEXCOORD:
    case D3DSIO_TEXM3x2PAD:
    case D3DSIO_TEXM3x2TEX:
    case D3DSIO_TEXM3x3PAD:
    case D3DSIO_TEXM3x3TEX:
    case D3DSIO_TEXM3x3SPEC:
    case D3DSIO_TEXM3x3VSPEC:
    case D3DSIO_TEXREG2AR:
    case D3DSIO_TEXREG2GB:
    case D3DSIO_TEXKILL:
    case D3DSIO_TEXM3x2DEPTH:
    case D3DSIO_TEXDP3:
    case D3DSIO_TEXREG2RGB:
    case D3DSIO_TEXDP3TEX:
    case D3DSIO_TEXM3x3:
        m_TexOpCount++;
        m_TotalOpCount++;
        break;
    case D3DSIO_MOV:
    case D3DSIO_ADD:
    case D3DSIO_SUB:
    case D3DSIO_MUL:
    case D3DSIO_MAD:
    case D3DSIO_LRP:
    case D3DSIO_DP3:
    case D3DSIO_CMP:
    case D3DSIO_CND:
    case D3DSIO_DP4:
        if( !_CURR_PS_INST->m_bCoIssue )
        {
            m_BlendOpCount++;
            m_TotalOpCount++;
        }
        break;
    case D3DSIO_NOP:
    case D3DSIO_END:
    case D3DSIO_DEF:
        break;
    default:
        DXGASSERT(FALSE);
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CPShaderValidator10::Rule_R0Written
//
// ** Rule:
// All components (r,g,b,a) of register R0 must have been written by the
// pixel shader.
//
// ** When to call:
// After all instructions have been seen.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CPShaderValidator10::Rule_R0Written()
{
    UINT  NumUninitializedComponents    = 0;
    DWORD UninitializedComponentsMask   = 0;

    for( UINT i = 0; i < NUM_COMPONENTS_IN_REGISTER; i++ )
    {
        if( NULL == m_pTempRegFile->m_pAccessHistory[i][0].m_pMostRecentWriter )
        {
            NumUninitializedComponents++;
            UninitializedComponentsMask |= COMPONENT_MASKS[i];
        }
    }
    if( NumUninitializedComponents )
    {
        Spew( SPEW_GLOBAL_ERROR, NULL, "r0 must be written by shader. Uninitialized component%s(*): %s",
            NumUninitializedComponents > 1 ? "s" : "", MakeAffectedComponentsText(UninitializedComponentsMask,TRUE,FALSE));
        m_ErrorCount++;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\shval\valbase.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// valbase.cpp
//
// Direct3D Reference Device - PixelShader validation common infrastructure
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
// DSTPARAM::DSTPARAM
//-----------------------------------------------------------------------------
DSTPARAM::DSTPARAM()
{
    m_bParamUsed        = FALSE;
    m_RegNum            = (UINT)-1;
    m_WriteMask         = 0;
    m_DstMod            = D3DSPDM_NONE;
    m_DstShift          = (DSTSHIFT)-1;
    m_RegType           = (D3DSHADER_PARAM_REGISTER_TYPE)-1;
    m_ComponentReadMask = 0;
}

//-----------------------------------------------------------------------------
// SRCPARAM::SRCPARAM
//-----------------------------------------------------------------------------
SRCPARAM::SRCPARAM()
{  
    m_bParamUsed            = FALSE;
    m_RegNum                = (UINT)-1;
    m_SwizzleShift          = D3DSP_NOSWIZZLE;
    m_AddressMode           = D3DVS_ADDRMODE_ABSOLUTE;
    m_RelativeAddrComponent = 0;
    m_SrcMod                = D3DSPSM_NONE;
    m_RegType               = (D3DSHADER_PARAM_REGISTER_TYPE)-1;
    m_ComponentReadMask     = D3DSP_WRITEMASK_ALL;
}

//-----------------------------------------------------------------------------
// CBaseInstruction::CBaseInstruction
//-----------------------------------------------------------------------------
CBaseInstruction::CBaseInstruction(CBaseInstruction* pPrevInst)
{
    m_Type                  = D3DSIO_NOP;
    m_SrcParamCount         = 0;
    m_DstParamCount         = 0;
    m_pPrevInst             = pPrevInst;
    m_pNextInst             = NULL;
    m_pSpewLineNumber       = NULL;
    m_pSpewFileName         = NULL;
    m_SpewInstructionCount  = 0;

    if( pPrevInst )
    {
        pPrevInst->m_pNextInst = this;
    }
}

//-----------------------------------------------------------------------------
// CBaseInstruction::SetSpewFileNameAndLineNumber
//-----------------------------------------------------------------------------
void CBaseInstruction::SetSpewFileNameAndLineNumber(const char* pFileName, const DWORD* pLineNumber)
{
    m_pSpewFileName = pFileName;
    m_pSpewLineNumber = pLineNumber;
}

//-----------------------------------------------------------------------------
// CBaseInstruction::MakeInstructionLocatorString
//
// Don't forget to 'delete' the string returned.
//-----------------------------------------------------------------------------
char* CBaseInstruction::MakeInstructionLocatorString()
{
    
    for(UINT Length = 128; Length < 65536; Length *= 2)
    {
        int BytesStored;
        char *pBuffer = new char[Length];

        if( !pBuffer )
        {
            OutputDebugString("Out of memory.\n");
            return NULL;
        }

        if( m_pSpewFileName )
        {
            BytesStored = _snprintf( pBuffer, Length, "%s(%d) : ", 
                m_pSpewFileName, m_pSpewLineNumber ? *m_pSpewLineNumber : 1);
        }
        else
        {
            BytesStored = _snprintf( pBuffer, Length, "(Statement %d) ", 
                m_SpewInstructionCount );
        }


        if( BytesStored >= 0 )
            return pBuffer;

        delete [] pBuffer;
    }

    return NULL;
}

//-----------------------------------------------------------------------------
// CAccessHistoryNode::CAccessHistoryNode
//-----------------------------------------------------------------------------
CAccessHistoryNode::CAccessHistoryNode( CAccessHistoryNode* pPreviousAccess, 
                                        CAccessHistoryNode* pPreviousWriter,
                                        CAccessHistoryNode* pPreviousReader,
                                        CBaseInstruction* pInst,
                                        BOOL bWrite )
{
    DXGASSERT(pInst);

    m_pNextAccess       = NULL;
    m_pPreviousAccess   = pPreviousAccess;
    if( m_pPreviousAccess )
        m_pPreviousAccess->m_pNextAccess = this;

    m_pPreviousWriter   = pPreviousWriter;
    m_pPreviousReader   = pPreviousReader;
    m_pInst             = pInst;
    m_bWrite            = bWrite;
    m_bRead             = !bWrite;
}

//-----------------------------------------------------------------------------
// CAccessHistory::CAccessHistory
//-----------------------------------------------------------------------------
CAccessHistory::CAccessHistory()
{
    m_pFirstAccess          = NULL;
    m_pMostRecentAccess     = NULL;
    m_pMostRecentWriter     = NULL;
    m_pMostRecentReader     = NULL;
    m_bPreShaderInitialized = FALSE;
}

//-----------------------------------------------------------------------------
// CAccessHistory::~CAccessHistory
//-----------------------------------------------------------------------------
CAccessHistory::~CAccessHistory()
{
    CAccessHistoryNode* pCurrNode = m_pFirstAccess;
    CAccessHistoryNode* pDeleteMe;
    while( pCurrNode )
    {
        pDeleteMe = pCurrNode;
        pCurrNode = pCurrNode->m_pNextAccess;
        delete pDeleteMe;
    }
}

//-----------------------------------------------------------------------------
// CAccessHistory::NewAccess
//-----------------------------------------------------------------------------
BOOL CAccessHistory::NewAccess(CBaseInstruction* pInst, BOOL bWrite )
{
    m_pMostRecentAccess = new CAccessHistoryNode(   m_pMostRecentAccess, 
                                                    m_pMostRecentWriter,
                                                    m_pMostRecentReader,
                                                    pInst,
                                                    bWrite );
    if( NULL == m_pMostRecentAccess )
    {
        return FALSE;   // out of memory
    }
    if( m_pFirstAccess == NULL )
    {
        m_pFirstAccess = m_pMostRecentAccess;            
    }
    if( bWrite )
    {
        m_pMostRecentWriter = m_pMostRecentAccess;
    }
    else // it is a read.
    {
        m_pMostRecentReader = m_pMostRecentAccess;
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CAccessHistory::InsertReadBeforeWrite
//-----------------------------------------------------------------------------
BOOL CAccessHistory::InsertReadBeforeWrite(CAccessHistoryNode* pWriteNode, CBaseInstruction* pInst)
{
    DXGASSERT(pWriteNode && pWriteNode->m_bWrite && pInst );

    // append new node after node before pWriteNode
    CAccessHistoryNode* pReadBeforeWrite 
                        = new CAccessHistoryNode(  pWriteNode->m_pPreviousAccess, 
                                                   pWriteNode->m_pPreviousWriter,
                                                   pWriteNode->m_pPreviousReader,
                                                   pInst,
                                                   FALSE);
    if( NULL == pReadBeforeWrite )
    {
        return FALSE; // out of memory
    }

    // Patch up all the dangling pointers

    // Pointer to first access may change
    if( m_pFirstAccess == pWriteNode )
    {
        m_pFirstAccess = pReadBeforeWrite;
    }

    // Pointer to most recent reader may change
    if( m_pMostRecentReader == pWriteNode->m_pPreviousReader )
    {
        m_pMostRecentReader = pReadBeforeWrite;
    }

    // Update all m_pPreviousRead pointers that need to be updated to point to the newly
    // inserted read.
    CAccessHistoryNode* pCurrAccess = pWriteNode;
    while(pCurrAccess && 
         !(pCurrAccess->m_bRead && pCurrAccess->m_pPreviousAccess && pCurrAccess->m_pPreviousAccess->m_bRead) )
    {
        pCurrAccess->m_pPreviousReader = pReadBeforeWrite;
        pCurrAccess = pCurrAccess->m_pPreviousAccess;
    }

    // re-attach pWriteNode and the accesses linked after it back to the original list
    pWriteNode->m_pPreviousAccess = pReadBeforeWrite;
    pReadBeforeWrite->m_pNextAccess = pWriteNode;

    return TRUE;
}

//-----------------------------------------------------------------------------
// CRegisterFile::CRegisterFile
//-----------------------------------------------------------------------------
CRegisterFile::CRegisterFile(UINT NumRegisters, 
                             BOOL bWritable, 
                             UINT NumReadPorts, 
                             BOOL bPreShaderInitialized)
{
    m_bInitOk = FALSE;
    m_NumRegisters = NumRegisters;
    m_bWritable = bWritable;
    m_NumReadPorts = NumReadPorts;

    for( UINT i = 0; i < NUM_COMPONENTS_IN_REGISTER; i++ )
    {
        if( m_NumRegisters )
        {
            m_pAccessHistory[i] = new CAccessHistory[m_NumRegisters];
            if( NULL == m_pAccessHistory[i] )
            {
                OutputDebugString( "Direct3D Shader Validator: Out of memory.\n" );
                m_NumRegisters = 0;
                return;
            }
        }
        for( UINT j = 0; j < m_NumRegisters; j++ )
        {
            m_pAccessHistory[i][j].m_bPreShaderInitialized = bPreShaderInitialized;
        }
        // To get the access history for a component of a register, use:
        // m_pAccessHistory[component][register number]
    }
}

//-----------------------------------------------------------------------------
// CRegisterFile::~CRegisterFile
//-----------------------------------------------------------------------------
CRegisterFile::~CRegisterFile()
{
    for( UINT i = 0; i < NUM_COMPONENTS_IN_REGISTER; i++ )
    {
        delete [] m_pAccessHistory[i];
    }
}

//-----------------------------------------------------------------------------
// CBaseShaderValidator::CBaseShaderValidator
//-----------------------------------------------------------------------------
CBaseShaderValidator::CBaseShaderValidator( const DWORD* pCode, const D3DCAPS8* pCaps, DWORD Flags )
{
    m_ReturnCode            = E_FAIL;  // do this first.
    m_bBaseInitOk           = FALSE;

    m_pLog                  = new CErrorLog(Flags & SHADER_VALIDATOR_LOG_ERRORS);
    if( NULL == m_pLog )
    {
        OutputDebugString("D3D PixelShader Validator: Out of memory.\n");
        return;
    }

    // ----------------------------------------------------
    // Member variable initialization
    //

    m_pCaps                 = pCaps;
    m_ErrorCount            = 0;
    m_bSeenAllInstructions  = FALSE;
    m_SpewInstructionCount  = 0;
    m_pInstructionList      = NULL;
    m_pCurrInst             = NULL;
    m_pCurrToken            = pCode; // can be null - vertex shader fixed function 
    if( m_pCurrToken )
        m_Version           = *(m_pCurrToken++);
    else
        m_Version           = 0;

    m_pLatestSpewLineNumber = NULL; 
    m_pLatestSpewFileName   = NULL;

    for( UINT i = 0; i < SHADER_INSTRUCTION_MAX_SRCPARAMS; i++ )
    {
        m_bSrcParamError[i] = FALSE;
    }

    m_bBaseInitOk           = TRUE;
    return;
}

//-----------------------------------------------------------------------------
// CBaseShaderValidator::~CBaseShaderValidator
//-----------------------------------------------------------------------------
CBaseShaderValidator::~CBaseShaderValidator()
{
    while( m_pCurrInst )    // Delete the linked list of instructions
    {
        CBaseInstruction* pDeleteMe = m_pCurrInst;
        m_pCurrInst = m_pCurrInst->m_pPrevInst;
        delete pDeleteMe;
    }
    delete m_pLog;
}

//-----------------------------------------------------------------------------
// CBaseShaderValidator::DecodeDstParam
//-----------------------------------------------------------------------------
void CBaseShaderValidator::DecodeDstParam( DSTPARAM* pDstParam, DWORD Token )
{
    DXGASSERT(pDstParam);
    pDstParam->m_bParamUsed = TRUE;
    pDstParam->m_RegNum = Token & D3DSP_REGNUM_MASK;
    pDstParam->m_WriteMask = Token & D3DSP_WRITEMASK_ALL;
    pDstParam->m_DstMod = (D3DSHADER_PARAM_DSTMOD_TYPE)(Token & D3DSP_DSTMOD_MASK);
    pDstParam->m_DstShift = (DSTSHIFT)((Token & D3DSP_DSTSHIFT_MASK) >> D3DSP_DSTSHIFT_SHIFT );
    pDstParam->m_RegType = (D3DSHADER_PARAM_REGISTER_TYPE)(Token & D3DSP_REGTYPE_MASK);
}

//-----------------------------------------------------------------------------
// CBaseShaderValidator::DecodeSrcParam
//-----------------------------------------------------------------------------
void CBaseShaderValidator::DecodeSrcParam( SRCPARAM* pSrcParam, DWORD Token )
{
    DXGASSERT(pSrcParam);
    pSrcParam->m_bParamUsed = TRUE;
    pSrcParam->m_RegNum = Token & D3DSP_REGNUM_MASK;
    pSrcParam->m_SwizzleShift = Token & D3DSP_SWIZZLE_MASK;
    pSrcParam->m_AddressMode = (D3DVS_ADDRESSMODE_TYPE)(Token & D3DVS_ADDRESSMODE_MASK);
    pSrcParam->m_RelativeAddrComponent = COMPONENT_MASKS[(Token >> 14) & 0x3];
    pSrcParam->m_SrcMod = (D3DSHADER_PARAM_SRCMOD_TYPE)(Token & D3DSP_SRCMOD_MASK);
    pSrcParam->m_RegType = (D3DSHADER_PARAM_REGISTER_TYPE)(Token & D3DSP_REGTYPE_MASK);
}

//-----------------------------------------------------------------------------
// CBaseShaderValidator::ValidateShader
//-----------------------------------------------------------------------------
void CBaseShaderValidator::ValidateShader()
{
    m_SpewInstructionCount++; // Consider the version token as the first
                              // statement (1) for spew counting.

    if( !InitValidation() )                 // i.e. Set up max register counts
    {
        // Returns false on:
        // 1) Unrecognized version token, 
        // 2) Vertex shader declaration validation with no shader code (fixed function).
        //    In this case InitValidation() sets m_ReturnCode as appropriate.
        return;
    }

    // Loop through all the instructions
    while( *m_pCurrToken != D3DPS_END() )
    {
        m_pCurrInst = AllocateNewInstruction(m_pCurrInst);  // New instruction in linked list
        if( NULL == m_pCurrInst )
        {
            Spew( SPEW_GLOBAL_ERROR, NULL, "Out of memory." );
            return;
        }
        if( NULL == m_pInstructionList )
            m_pInstructionList = m_pCurrInst;

        if( !DecodeNextInstruction() )
            return;
        
        // Skip comments
        if( m_pCurrInst->m_Type == D3DSIO_COMMENT )
        {
            CBaseInstruction* pDeleteMe = m_pCurrInst;
            m_pCurrInst = m_pCurrInst->m_pPrevInst;
            if( pDeleteMe == m_pInstructionList )
                m_pInstructionList = NULL;
            delete pDeleteMe;
            continue; 
        }

        for( UINT i = 0; i < SHADER_INSTRUCTION_MAX_SRCPARAMS; i++ )
        {
            m_bSrcParamError[i] = FALSE;
        }

        // Apply all the per-instruction rules - order the rule checks sensibly.
        // Note: Rules only return FALSE if they find an error that is so severe that it is impossible to
        //       continue validation.

        if( !ApplyPerInstructionRules() )
            return;
    }

    m_bSeenAllInstructions = TRUE;

    // Apply any rules that also need to run after all instructions seen.
    // 
    // NOTE: It is possible to get here with m_pCurrInst == NULL, if there were no
    // instructions.  So any rules you add here must be able to account for that
    // possiblity.
    //
    ApplyPostInstructionsRules();

    // If no errors, then success!
    if( 0 == m_ErrorCount )
        m_ReturnCode = D3D_OK;
}

//-----------------------------------------------------------------------------
// CBaseShaderValidator::ParseCommentForAssemblerMessages
//-----------------------------------------------------------------------------
void CBaseShaderValidator::ParseCommentForAssemblerMessages(const DWORD* pComment)
{
    if( !pComment )
        return;

    // There must be at least 2 DWORDS in the comment
    if( (((*(pComment++)) & D3DSI_COMMENTSIZE_MASK) >> D3DSI_COMMENTSIZE_SHIFT) < 2 )
        return;

    switch(*(pComment++))
    {
    case MAKEFOURCC('F','I','L','E'):
        m_pLatestSpewFileName = (const char*)pComment;
        break;
    case MAKEFOURCC('L','I','N','E'):
        m_pLatestSpewLineNumber = pComment;
        break;
    }
}

//-----------------------------------------------------------------------------
// CBaseShaderValidator::Spew
//-----------------------------------------------------------------------------
void CBaseShaderValidator::Spew(    SPEW_TYPE SpewType, 
                                    CBaseInstruction* pInst /* can be NULL */, 
                                    const char* pszFormat, ... )
{
    int Length = 128;
    char* pBuffer = NULL;
    va_list marker;

    if( !m_pLog )
        return;
    
    while( pBuffer == NULL )
    {
        int BytesStored = 0;
        int BytesLeft = Length;
        char *pIndex    = NULL;
        char* pErrorLocationText = NULL;

        pBuffer = new char[Length];
        if( !pBuffer )
        {
            OutputDebugString("Out of memory.\n");
            return;
        }
        pIndex = pBuffer;

        // Code location text
        switch( SpewType )
        {
        case SPEW_INSTRUCTION_ERROR:
        case SPEW_INSTRUCTION_WARNING:
            if( pInst )
                pErrorLocationText = pInst->MakeInstructionLocatorString();
            break;
        }

        if( pErrorLocationText )
        {
            BytesStored = _snprintf( pIndex, BytesLeft - 1, pErrorLocationText );
            if( BytesStored < 0 ) goto OverFlow;
            BytesLeft -= BytesStored;
            pIndex += BytesStored;
        }

        // Spew text prefix
        switch( SpewType )
        {
        case SPEW_INSTRUCTION_ERROR:
            BytesStored = _snprintf( pIndex, BytesLeft - 1, "(Validation Error) " );
            break;
        case SPEW_GLOBAL_ERROR:
            BytesStored = _snprintf( pIndex, BytesLeft - 1, "(Global Validation Error) " );
            break;
        case SPEW_INSTRUCTION_WARNING:
            BytesStored = _snprintf( pIndex, BytesLeft - 1, "(Validation Warning) " );
            break;
        case SPEW_GLOBAL_WARNING:
            BytesStored = _snprintf( pIndex, BytesLeft - 1, "(Global Validation Warning) " );
            break;
        }
        if( BytesStored < 0 ) goto OverFlow;
        BytesLeft -= BytesStored; 
        pIndex += BytesStored;

        // Formatted text
        va_start( marker, pszFormat );
        BytesStored = _vsnprintf( pIndex, BytesLeft - 1, pszFormat, marker );
        va_end( marker );

        if( BytesStored < 0 ) goto OverFlow;
        BytesLeft -= BytesStored;
        pIndex += BytesStored;

        m_pLog->AppendText(pBuffer);

        delete [] pErrorLocationText;
        delete [] pBuffer;
        break;
OverFlow:
        delete [] pErrorLocationText;
        delete [] pBuffer;
        pBuffer = NULL;
        Length = Length * 2;
    }
}

//-----------------------------------------------------------------------------
// CBaseShaderValidator::MakeAffectedComponentsText
//
// Note that the string returned is STATIC.
//-----------------------------------------------------------------------------
char* CBaseShaderValidator::MakeAffectedComponentsText( DWORD ComponentMask, 
                                                        BOOL bColorLabels, 
                                                        BOOL bPositionLabels)
{
    char* ColorLabels[4] = {"r/", "g/", "b/", "a/"};
    char* PositionLabels[4] = {"x/", "y/", "z/", "w/"};
    char* NumericLabels[4] = {"0 ", "1 ", "2 ", "3"}; // always used
    static char s_AffectedComponents[28]; // enough to hold "*r/x/0 *g/y/1 *b/z/2 *a/w/3"
    UINT  LabelCount = 0;

    s_AffectedComponents[0] = '\0';

    for( UINT i = 0; i < 4; i++ )
    {
        if( COMPONENT_MASKS[i] & ComponentMask )
        {
            strcat( s_AffectedComponents, "*" );
        }
        if( bColorLabels )
            strcat( s_AffectedComponents, ColorLabels[i] );
        if( bPositionLabels )
            strcat( s_AffectedComponents, PositionLabels[i] );

        strcat( s_AffectedComponents, NumericLabels[i] ); // always used
    }
    return s_AffectedComponents;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\shval\valbase.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// valbase.hpp
//
// Direct3D Reference Device - Vertex/PixelShader validation common infrastructure
//
///////////////////////////////////////////////////////////////////////////////
#ifndef __VALBASE_HPP__
#define __VALBASE_HPP__

#define NUM_COMPONENTS_IN_REGISTER  4
#define SHADER_INSTRUCTION_MAX_PARAMS       4
#define SHADER_INSTRUCTION_MAX_SRCPARAMS    (SHADER_INSTRUCTION_MAX_PARAMS - 1)

typedef enum _SPEW_TYPE
{
    SPEW_INSTRUCTION_ERROR,
    SPEW_INSTRUCTION_WARNING,
    SPEW_GLOBAL_ERROR,
    SPEW_GLOBAL_WARNING
} SPEW_TYPE;

typedef enum _SHADER_VALIDATOR_FLAGS
{
    SHADER_VALIDATOR_LOG_ERRORS             = 0x1,
    SHADER_VALIDATOR_OPTIMIZE_WRITEMASKS    = 0x2
} SHADER_VALIDATOR_FLAGS;

typedef enum _DSTSHIFT
{
    DSTSHIFT_NONE   = 0x0,
    DSTSHIFT_X2     = 0x1,
    DSTSHIFT_X4     = 0x2,
    DSTSHIFT_X8     = 0x3,
    DSTSHIFT_D2     = 0xF,
    DSTSHIFT_D4     = 0xE,
    DSTSHIFT_D8     = 0xD
} DSTSHIFT;

const DWORD COMPONENT_MASKS[4] = {D3DSP_WRITEMASK_0, D3DSP_WRITEMASK_1, D3DSP_WRITEMASK_2, D3DSP_WRITEMASK_3};

//-----------------------------------------------------------------------------
// DSTPARAM - part of CBaseInstruction
//-----------------------------------------------------------------------------
class DSTPARAM
{
public:
    DSTPARAM();

    BOOL                            m_bParamUsed;   // Does instruction have dest param?
    UINT                            m_RegNum;
    DWORD                           m_WriteMask;    // writemasks (D3DSP_WRITEMASK_*)  
    D3DSHADER_PARAM_DSTMOD_TYPE     m_DstMod;       // D3DSPDM_NONE, D3DSPDM_SATURATE (PShader)
    DSTSHIFT                        m_DstShift;     // _x2, _x4, etc. (PShader)
    D3DSHADER_PARAM_REGISTER_TYPE   m_RegType;      // _TEMP, _ADDRESS, etc.

    DWORD                           m_ComponentReadMask; // Which components instruction needs to read
                                                         // This seems strage, but in ps.2.0 there are some ops
                                                         // that have one parameter (dest), but they read from it, and write back to it.
};

//-----------------------------------------------------------------------------
// SRCPARAM - part of CBaseInstruction
//-----------------------------------------------------------------------------
class SRCPARAM
{
public:
    SRCPARAM();

    BOOL                            m_bParamUsed;   // Does instruction have this src param?
    UINT                            m_RegNum;
    DWORD                           m_SwizzleShift; // D3DVS_*_*, or D3DSP_NOSWIZZLE/
                                                    // D3DSP_REPLICATERED/GREEN/BLUE/ALPHA
    D3DVS_ADDRESSMODE_TYPE          m_AddressMode;  // D3DVS_ADDRMODE_ABSOLUTE / _RELATIVE (VShader)
    DWORD                           m_RelativeAddrComponent; // One of D3DSP_WRITEMASK_0, 1, 2, or 3. (VShader)
    D3DSHADER_PARAM_SRCMOD_TYPE     m_SrcMod;       // _NEG, _BIAS, etc.
    D3DSHADER_PARAM_REGISTER_TYPE   m_RegType;      // _TEMP, _CONST, etc.

    DWORD                           m_ComponentReadMask; // Which components instruction needs to read
};

//-----------------------------------------------------------------------------
// CBaseInstruction
//-----------------------------------------------------------------------------
class CBaseInstruction
{
public:
    CBaseInstruction(CBaseInstruction* pPrevInst);  // Append to linked list
    void SetSpewFileNameAndLineNumber(const char* pFileName, const DWORD* pLineNumber);
    char* MakeInstructionLocatorString();
    virtual void CalculateComponentReadMasks(DWORD dwVersion) = 0; // which components to each source read?

    // Instruction Description
    D3DSHADER_INSTRUCTION_OPCODE_TYPE   m_Type;
    UINT                                m_DstParamCount;
    UINT                                m_SrcParamCount;
    CBaseInstruction*                   m_pPrevInst;
    CBaseInstruction*                   m_pNextInst;
    const DWORD*                        m_pSpewLineNumber; // points to line number embedded in shader by assembler (if present)
    const char*                         m_pSpewFileName;   // points to file name embedded in shader (if present)
    UINT                                m_SpewInstructionCount; // only used for spew, not for any limit checking

    // Destination Parameter Description
    DSTPARAM    m_DstParam;
    
    // Source Parameters
    SRCPARAM    m_SrcParam[SHADER_INSTRUCTION_MAX_SRCPARAMS];
};

//-----------------------------------------------------------------------------
// CAccessHistoryNode
//-----------------------------------------------------------------------------
class CAccessHistoryNode
{
public:
    CAccessHistoryNode(CAccessHistoryNode* pPreviousAccess, 
                       CAccessHistoryNode* pPreviousWriter,
                       CAccessHistoryNode* pPreviousReader,
                       CBaseInstruction* pInst,
                       BOOL bWrite );

    CAccessHistoryNode* m_pPreviousAccess;
    CAccessHistoryNode* m_pNextAccess;
    CAccessHistoryNode* m_pPreviousWriter;
    CAccessHistoryNode* m_pPreviousReader;
    CBaseInstruction*   m_pInst;
    BOOL m_bWrite;
    BOOL m_bRead;
};

//-----------------------------------------------------------------------------
// CAccessHistory
//-----------------------------------------------------------------------------
class CAccessHistory
{
public:
    CAccessHistory();
    ~CAccessHistory();
    CAccessHistoryNode* m_pFirstAccess;
    CAccessHistoryNode* m_pMostRecentAccess;
    CAccessHistoryNode* m_pMostRecentWriter;
    CAccessHistoryNode* m_pMostRecentReader;
    BOOL                m_bPreShaderInitialized;

    BOOL NewAccess(CBaseInstruction* pInst, BOOL bWrite );
    BOOL InsertReadBeforeWrite(CAccessHistoryNode* pWriteNode, CBaseInstruction* pInst);
};

//-----------------------------------------------------------------------------
// CRegisterFile
//-----------------------------------------------------------------------------
class CRegisterFile
{
    UINT    m_NumRegisters;
    BOOL    m_bWritable;
    UINT    m_NumReadPorts;
    BOOL    m_bInitOk;
public:
    CRegisterFile(UINT NumRegisters, BOOL bWritable, UINT NumReadPorts, BOOL bPreShaderInitialized );
    ~CRegisterFile();

    inline UINT GetNumRegs() {return m_NumRegisters;};    
    inline BOOL IsWritable() {return m_bWritable;};    
    inline UINT GetNumReadPorts() {return m_NumReadPorts;};    
    inline BOOL InitOk() {return m_bInitOk;};    
    CAccessHistory*     m_pAccessHistory[NUM_COMPONENTS_IN_REGISTER];
};

//-----------------------------------------------------------------------------
// CBaseShaderValidator
//-----------------------------------------------------------------------------
class CBaseShaderValidator
{
protected:
    BOOL                        m_bBaseInitOk;
    DWORD                       m_Version;
    UINT                        m_SpewInstructionCount; // only used for spew, not for any limit checking
    CBaseInstruction*           m_pInstructionList;
    const DWORD*                m_pCurrToken;
    HRESULT                     m_ReturnCode;
    BOOL                        m_bSeenAllInstructions;
    DWORD                       m_ErrorCount;
    CErrorLog*                  m_pLog;
    CBaseInstruction*           m_pCurrInst;
    const D3DCAPS8*             m_pCaps;  // can be NULL if not provided.
    const DWORD*                m_pLatestSpewLineNumber; // points to latest line number sent in comment from D3DX Assembler
    const char*                 m_pLatestSpewFileName;   // points to latest file name sent in comment from D3DX Assembler

    // m_bSrcParamError needed by Rule_SrcInitialized (in both vshader and pshader)
    BOOL                        m_bSrcParamError[SHADER_INSTRUCTION_MAX_SRCPARAMS]; 

    virtual BOOL                DecodeNextInstruction() = 0;
    void                        DecodeDstParam( DSTPARAM* pDstParam, DWORD Token );
    void                        DecodeSrcParam( SRCPARAM* pSrcParam, DWORD Token );
    virtual BOOL                InitValidation() = 0;
    void                        ValidateShader();
    virtual BOOL                ApplyPerInstructionRules() = 0;
    virtual void                ApplyPostInstructionsRules() = 0;
    virtual CBaseInstruction*   AllocateNewInstruction(CBaseInstruction* pPrevInst) = 0;
    void                        ParseCommentForAssemblerMessages(const DWORD* pComment);
    void                        Spew(   SPEW_TYPE SpewType, 
                                        CBaseInstruction* pInst /* can be NULL */, 
                                        const char* pszFormat, ... );
    char*                       MakeAffectedComponentsText( DWORD ComponentMask, 
                                                            BOOL bColorLabels = TRUE, 
                                                            BOOL bPositionLabels = TRUE);

public:
    CBaseShaderValidator( const DWORD* pCode, const D3DCAPS8* pCaps, DWORD Flags );
    ~CBaseShaderValidator();

    DWORD GetRequiredLogBufferSize()
    {
        if( m_pLog ) 
            return m_pLog->GetRequiredLogBufferSize();
        else
            return 0;
    }

    void WriteLogToBuffer( char* pBuffer )
    {
        if( m_pLog ) m_pLog->WriteLogToBuffer( pBuffer );
    }

    HRESULT GetStatus() { return m_ReturnCode; }; 
};

#endif //__VALBASE_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\shval\vshdrval.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// vshdrval.cpp
//
// Direct3D Reference Device - VertexShader validation
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

// Use these macros when looking at CVSInstruction derived members of the current instruction (CBaseInstruction)
#define _CURR_VS_INST   ((CVSInstruction*)m_pCurrInst)
#define _PREV_VS_INST   (m_pCurrInst?((CVSInstruction*)(m_pCurrInst->m_pPrevInst)):NULL)

//-----------------------------------------------------------------------------
// VertexShader Validation Rule Coverage
//
// Below is the list of rules in "DX8 VertexShader Version Specification",
// matched to the function(s) in this file which enforce them.
// Note that the mapping from rules to funtions can be 1->n or n->1
//
// Generic Rules
// -------------
//
// VS-G1:           Rule_oPosWritten
// VS-G2:           Rule_ValidAddressRegWrite
//
// Vertex Shader Version 1.0 Rules
// ------------------------------
//
// VS.1.0-1:        Rule_ValidAddressRegWrite
//
// Vertex Shader Version 1.1 Rules
// ------------------------------
//
// VS.1.1-1:        Rule_ValidInstructionCount
// VS.1.1-2:        Rule_ValidAddressRegWrite, Rule_ValidSrcParams
// VS.1.1-3:        Rule_ValidFRCInstruction
// VS.1.1-4:        ?
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// CVSInstruction::CalculateComponentReadMasks(DWORD dwVersion)
//-----------------------------------------------------------------------------
void CVSInstruction::CalculateComponentReadMasks(DWORD dwVersion)
{
    for( UINT i = 0; i < m_SrcParamCount; i++ )
    {
        DWORD PostSwizzleComponentReadMask = 0;
        switch( m_Type )
        {
            case D3DSIO_ADD:
            case D3DSIO_FRC:
            case D3DSIO_MAD:
            case D3DSIO_MAX:
            case D3DSIO_MIN:
            case D3DSIO_MOV:
            case D3DSIO_MUL:
            case D3DSIO_SLT:
            case D3DSIO_SGE:
                PostSwizzleComponentReadMask = m_DstParam.m_WriteMask; // per-component ops.
                break;
            case D3DSIO_DP3:
                PostSwizzleComponentReadMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2;
                break;
            case D3DSIO_DP4:
                PostSwizzleComponentReadMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2 | D3DSP_WRITEMASK_3;
                break;
            case D3DSIO_LIT:
                PostSwizzleComponentReadMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_3;
                break;
            case D3DSIO_DST:
                if( 0 == i )        PostSwizzleComponentReadMask = D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2;
                else if( 1 == i )   PostSwizzleComponentReadMask = D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_3;
                break;
            case D3DSIO_EXP:
            case D3DSIO_LOG:
            case D3DSIO_EXPP:
            case D3DSIO_LOGP:
            case D3DSIO_RCP:
            case D3DSIO_RSQ:
                PostSwizzleComponentReadMask = D3DSP_WRITEMASK_3;
                break;
            case D3DSIO_M3x2:
                PostSwizzleComponentReadMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2;
                break;
            case D3DSIO_M3x3:
                PostSwizzleComponentReadMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2;
                break;
            case D3DSIO_M3x4:
                PostSwizzleComponentReadMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2;
                break;
            case D3DSIO_M4x3:
                PostSwizzleComponentReadMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2 | D3DSP_WRITEMASK_3;
                break;
            case D3DSIO_M4x4:
                PostSwizzleComponentReadMask = D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2 | D3DSP_WRITEMASK_3;
                break;
            case D3DSIO_NOP:
            default:
                break;
        }

        // Now that we know which components of the source will be used by the instruction,
        // we need to figure out which components of the actual source register need to be read to provide the data,
        // taking into account source component swizzling.
        m_SrcParam[i].m_ComponentReadMask = 0;
        for( UINT j = 0; j < 4; j++ )
        {
            if( PostSwizzleComponentReadMask & COMPONENT_MASKS[j] )
                m_SrcParam[i].m_ComponentReadMask |= COMPONENT_MASKS[(m_SrcParam[i].m_SwizzleShift >> (D3DVS_SWIZZLE_SHIFT + j*2)) & 3];
        }
    }
}

//-----------------------------------------------------------------------------
// CVShaderValidator::CVShaderValidator
//-----------------------------------------------------------------------------
CVShaderValidator::CVShaderValidator( const DWORD* pCode, 
                                      const DWORD* pDecl,
                                      const D3DCAPS8* pCaps,
                                      DWORD Flags ) 
                                      : CBaseShaderValidator( pCode, pCaps, Flags )
{
    // Note that the base constructor initialized m_ReturnCode to E_FAIL.  
    // Only set m_ReturnCode to S_OK if validation has succeeded, 
    // before exiting this constructor.

    m_pDecl                     = pDecl;
    m_bFixedFunction            = pDecl && !pCode;
    if( pCaps )
    {
        m_dwMaxVertexShaderConst = pCaps->MaxVertexShaderConst;
        m_bIgnoreConstantInitializationChecks = FALSE;
    }
    else
    {
        m_dwMaxVertexShaderConst = 0;
        m_bIgnoreConstantInitializationChecks = TRUE;
    }

    m_pTempRegFile              = NULL;
    m_pInputRegFile             = NULL;
    m_pConstRegFile             = NULL;
    m_pAddrRegFile              = NULL;
    m_pTexCrdOutputRegFile      = NULL;
    m_pAttrOutputRegFile        = NULL;
    m_pRastOutputRegFile        = NULL;

    if( NULL == pCode && NULL == pDecl )
    {
        Spew( SPEW_GLOBAL_ERROR, NULL, "Version Token: Code and declaration pointers passed into shader vertex shader validator cannot both be NULL.");
        return;
    }

    if( !m_bBaseInitOk )
        return;

    ValidateShader(); // If successful, m_ReturnCode will be set to S_OK.
                      // Call GetStatus() on this object to determine validation outcome.
}

//-----------------------------------------------------------------------------
// CVShaderValidator::~CVShaderValidator
//-----------------------------------------------------------------------------
CVShaderValidator::~CVShaderValidator()
{
    delete m_pTempRegFile;
    delete m_pInputRegFile;
    delete m_pConstRegFile;
    delete m_pAddrRegFile;
    delete m_pTexCrdOutputRegFile;
    delete m_pAttrOutputRegFile;
    delete m_pRastOutputRegFile;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::AllocateNewInstruction
//-----------------------------------------------------------------------------
CBaseInstruction* CVShaderValidator::AllocateNewInstruction(CBaseInstruction*pPrevInst)
{
    return new CVSInstruction((CVSInstruction*)pPrevInst);
}

//-----------------------------------------------------------------------------
// CVShaderValidator::DecodeNextInstruction
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::DecodeNextInstruction()
{
    m_pCurrInst->m_Type = (D3DSHADER_INSTRUCTION_OPCODE_TYPE)(*m_pCurrToken & D3DSI_OPCODE_MASK);

    if( m_pCurrInst->m_Type == D3DSIO_COMMENT )
    {
        ParseCommentForAssemblerMessages(m_pCurrToken); // does not advance m_pCurrToken

        // Skip comments
        DWORD NumDWORDs = ((*m_pCurrToken) & D3DSI_COMMENTSIZE_MASK) >> D3DSI_COMMENTSIZE_SHIFT;
        m_pCurrToken += (NumDWORDs+1);
        return TRUE;
    }

    // If the assembler has sent us file and/or line number messages,
    // received by ParseCommentForAssemblerMesssages(), 
    // then bind this information to the current instruction.
    // This info can be used in error spew to direct the shader developer
    // to exactly where a problem is located.
    m_pCurrInst->SetSpewFileNameAndLineNumber(m_pLatestSpewFileName,m_pLatestSpewLineNumber);

    m_SpewInstructionCount++; // only used for spew, not for any limits
    m_pCurrInst->m_SpewInstructionCount = m_SpewInstructionCount;

    DWORD dwReservedBits = VS_INST_TOKEN_RESERVED_MASK;

    if( (*m_pCurrToken) & dwReservedBits )
    {
        Spew(SPEW_INSTRUCTION_ERROR,m_pCurrInst,"Reserved bit(s) set in instruction parameter token!  Aborting validation.");
        return FALSE;
    }

    m_pCurrToken++;

    // Decode dst param
    if (*m_pCurrToken & (1L<<31))
    {
        (m_pCurrInst->m_DstParamCount)++;
        DecodeDstParam( &m_pCurrInst->m_DstParam, *m_pCurrToken );
        if( (*m_pCurrToken) & VS_DSTPARAM_TOKEN_RESERVED_MASK )
        {
            Spew(SPEW_INSTRUCTION_ERROR,m_pCurrInst,"Reserved bit(s) set in destination parameter token!  Aborting validation.");
            return FALSE;
        }
        m_pCurrToken++;
    }

    // Decode src param(s)
    while (*m_pCurrToken & (1L<<31))
    {   
        (m_pCurrInst->m_SrcParamCount)++;
        if( (m_pCurrInst->m_DstParamCount + m_pCurrInst->m_SrcParamCount) > SHADER_INSTRUCTION_MAX_PARAMS )
        {
            m_pCurrInst->m_SrcParamCount--;
            m_pCurrToken++; // eat up extra parameters and skip to next
            continue;
        }
        
        // Below: index is [SrcParamCount - 1] because m_SrcParam array needs 0 based index.
        DecodeSrcParam( &(m_pCurrInst->m_SrcParam[m_pCurrInst->m_SrcParamCount - 1]),*m_pCurrToken );

        if( (*m_pCurrToken) & VS_SRCPARAM_TOKEN_RESERVED_MASK )
        {
            Spew(SPEW_INSTRUCTION_ERROR,m_pCurrInst,"Reserved bit(s) set in source %d parameter token!  Aborting validation.",
                            m_pCurrInst->m_SrcParamCount);
            return FALSE;
        }
        m_pCurrToken++;
    }

    // Figure out which components of each source operand actually need to be read,
    // taking into account destination write mask, the type of instruction, source swizzle, etc.
    m_pCurrInst->CalculateComponentReadMasks(m_Version);

    return TRUE;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::InitValidation
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::InitValidation()
{
    if( m_bFixedFunction ) 
    {
        m_pTempRegFile              = new CRegisterFile(0,FALSE,0,TRUE);// #regs, bWritable, max# reads/instruction, pre-shader initialized
        m_pInputRegFile             = new CRegisterFile(17,FALSE,0,TRUE);
        m_pConstRegFile             = new CRegisterFile(0,FALSE,0,TRUE);
        m_pAddrRegFile              = new CRegisterFile(0,FALSE,0,TRUE);
        m_pTexCrdOutputRegFile      = new CRegisterFile(0,FALSE,0,TRUE);
        m_pAttrOutputRegFile        = new CRegisterFile(0,FALSE,0,TRUE);
        m_pRastOutputRegFile        = new CRegisterFile(0,FALSE,0,TRUE);
    }
    else
    {    
        if( m_pCaps )
        {
            if( (m_pCaps->VertexShaderVersion & 0x0000FFFF) < (m_Version & 0x0000FFFF) )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Version Token: Vertex shader version %d.%d is too high for device. Maximum supported version is %d.%d. Aborting shader validation.",
                        D3DSHADER_VERSION_MAJOR(m_Version),D3DSHADER_VERSION_MINOR(m_Version), 
                        D3DSHADER_VERSION_MAJOR(m_pCaps->VertexShaderVersion),D3DSHADER_VERSION_MINOR(m_pCaps->VertexShaderVersion));
                return FALSE;
            }
        }

        switch( m_Version >> 16 )
        {
        case 0xffff:
            Spew( SPEW_GLOBAL_ERROR, NULL, "Version token: 0x%x indicates a pixel shader.  Vertex shader version token must be of the form 0xfffe****.",
                    m_Version);
            return FALSE;
        case 0xfffe:
            break; // vertexshader - ok.
        default:
            Spew( SPEW_GLOBAL_ERROR, NULL, "Version Token: 0x%x is invalid. Vertex shader version token must be of the form 0xfffe****. Aborting vertex shader validation.",
                    m_Version);
            return FALSE;
        }

        switch(m_Version)
        {
        case D3DVS_VERSION(1,0):    // DX8
            m_pTempRegFile              = new CRegisterFile(12,TRUE,3,FALSE);// #regs, bWritable, max# reads/instruction, pre-shader initialized
            m_pInputRegFile             = new CRegisterFile(16,FALSE,1,TRUE);
            if( m_bIgnoreConstantInitializationChecks )
                m_pConstRegFile             = new CRegisterFile(0,FALSE,1,TRUE); // still creating register file so we can validate number of read ports
            else
                m_pConstRegFile             = new CRegisterFile(m_dwMaxVertexShaderConst,FALSE,1,TRUE);
            m_pAddrRegFile              = new CRegisterFile(0,TRUE,0,FALSE);
            m_pTexCrdOutputRegFile      = new CRegisterFile(8,TRUE,0,FALSE);
            m_pAttrOutputRegFile        = new CRegisterFile(2,TRUE,0,FALSE);
            m_pRastOutputRegFile        = new CRegisterFile(3,TRUE,0,FALSE);
            break;
        case D3DVS_VERSION(1,1):    // DX8
            m_pTempRegFile              = new CRegisterFile(12,TRUE,3,FALSE);// #regs, bWritable, max# reads/instruction, pre-shader initialized
            m_pInputRegFile             = new CRegisterFile(16,FALSE,1,TRUE);
            if( m_bIgnoreConstantInitializationChecks )
                m_pConstRegFile             = new CRegisterFile(0,FALSE,1,TRUE); // still creating register file so we can validate number of read ports
            else
                m_pConstRegFile             = new CRegisterFile(m_dwMaxVertexShaderConst,FALSE,1,TRUE);
            m_pAddrRegFile              = new CRegisterFile(1,TRUE,0,FALSE);
            m_pTexCrdOutputRegFile      = new CRegisterFile(8,TRUE,0,FALSE);
            m_pAttrOutputRegFile        = new CRegisterFile(2,TRUE,0,FALSE);
            m_pRastOutputRegFile        = new CRegisterFile(3,TRUE,0,FALSE);
            break;
        default:
            Spew( SPEW_GLOBAL_ERROR, NULL, "Version Token: %d.%d is not a supported vertex shader version. Aborting vertex shader validation.",
                    D3DSHADER_VERSION_MAJOR(m_Version),D3DSHADER_VERSION_MINOR(m_Version));
            return FALSE;
        }

    }

    if( NULL == m_pTempRegFile ||
        NULL == m_pInputRegFile ||
        NULL == m_pConstRegFile ||
        NULL == m_pAddrRegFile ||
        NULL == m_pTexCrdOutputRegFile ||
        NULL == m_pAttrOutputRegFile ||
        NULL == m_pRastOutputRegFile )
    {
        Spew( SPEW_GLOBAL_ERROR, NULL, "Out of memory.");
        return FALSE;
    }

    ValidateDeclaration(); // no matter what happens here, we can continue checking shader code, if present.

    if( m_bFixedFunction ) // no shader code - fixed function, so we only validate declaration
    {
        if( 0 == m_ErrorCount )
            m_ReturnCode = S_OK;

        return FALSE; // returning false just makes validation stop here (not for indicating success/failure of validation)
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::ValidateDeclaration
//-----------------------------------------------------------------------------
void CVShaderValidator::ValidateDeclaration()
{
    if( !m_pDecl ) // no shader declaration passed in.
        return;

    DXGASSERT(m_pInputRegFile);

    typedef struct _NORMAL_GEN {
        UINT DestReg;
        UINT SourceReg;
        UINT TokenNum;
    } NORMAL_GEN;

    const DWORD*    pCurrToken                 = m_pDecl;
    DWORD           MaxStreams                 = 0;
    UINT            TokenNum                   = 1;
    UINT            NumInputRegs               = m_pInputRegFile->GetNumRegs();
    BOOL            bInStream                  = FALSE;
    BOOL*           pVertexStreamDeclared      = NULL;
    BOOL            bInTessStream              = FALSE;
    BOOL            bTessStreamDeclared        = FALSE;
    BOOL            bAtLeastOneDataDefinition  = FALSE;
    NORMAL_GEN*     pNormalGenOperations       = new NORMAL_GEN[m_pInputRegFile->GetNumRegs()];
    UINT            NumNormalGenOperations     = 0;
    BOOL            bErrorInForLoop            = FALSE;

    if( NULL == pNormalGenOperations )
    {
        Spew( SPEW_GLOBAL_ERROR, NULL, "Out of memory.  Aborting shader decl. validation.");
        m_ErrorCount++;
        goto Exit;
    }
                                
    DXGASSERT(m_pConstRegFile && m_pInputRegFile); // if we have a declaration, we better have these two register files 
    DXGASSERT(!m_bIgnoreConstantInitializationChecks); // we better have d3d8 caps if we have a decl to verify!

    if( m_pCaps ) // only validate stream numbers when caps present
    {
        MaxStreams = m_pCaps->MaxStreams;
        if( MaxStreams > 0 )
        {
            pVertexStreamDeclared  = new BOOL[MaxStreams];
            if( NULL == pVertexStreamDeclared )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Out of memory.  Aborting shader decl. validation.");
                m_ErrorCount++;
                goto Exit;
            }

            for( UINT i = 0; i < MaxStreams; i++ )
                pVertexStreamDeclared[i] = FALSE;
        }
    }

    // The constructor for the input register file assumed that the input regs were initialized,
    // but now that we are parsing a shader declaration, 
    // we can check initialization of input registers.
    for( UINT i = 0; i < 4; i++ )
    {
        for( UINT j = 0; j < m_pInputRegFile->GetNumRegs(); j++ )
            m_pInputRegFile->m_pAccessHistory[i][j].m_bPreShaderInitialized = FALSE;
    }
    
    // Now parse the declaration.
    while( D3DVSD_END() != *pCurrToken )
    {
        DWORD Token             = *pCurrToken;
        switch( (Token & D3DVSD_TOKENTYPEMASK) >> D3DVSD_TOKENTYPESHIFT )
        {
        case D3DVSD_TOKEN_NOP:
            break;
        case D3DVSD_TOKEN_STREAM:
        {
            UINT StreamNum = (Token & D3DVSD_STREAMNUMBERMASK) >> D3DVSD_STREAMNUMBERSHIFT;
            bInTessStream = (Token & D3DVSD_STREAMTESSMASK) >> D3DVSD_STREAMTESSSHIFT;
            bInStream = !bInTessStream;
            bAtLeastOneDataDefinition = FALSE;

            if( bInStream )
            {
                if( m_pCaps && (StreamNum >= MaxStreams) )
                {
                    if( MaxStreams )
                        Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Stream number %d is out of range. Max allowed is %d.  Aborting shader decl. validation.",
                                    TokenNum, StreamNum, m_pCaps->MaxStreams - 1);
                    else
                        Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Stream number %d is out of range. There are no streams available.  Aborting shader decl. validation.",
                                    TokenNum, StreamNum, m_pCaps->MaxStreams - 1);

                    m_ErrorCount++;
                    goto Exit;
                }
            }
            else if( StreamNum > 0 )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Stream number must not be specified for tesselator stream.",
                            TokenNum);
                m_ErrorCount++;
            }

            if( bInStream && pVertexStreamDeclared )
            {
                if( TRUE == pVertexStreamDeclared[StreamNum] )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Stream number %d has already been declared.  Aborting shader decl. validation.",
                                TokenNum, StreamNum );
                    m_ErrorCount++;
                    goto Exit;
                }
                pVertexStreamDeclared[StreamNum] = TRUE;                
            }

            if( bInTessStream )
            {
                if( bTessStreamDeclared )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Tesselation stream has already been declared.  Aborting shader decl. validation.",
                                TokenNum);
                    m_ErrorCount++;
                    goto Exit;
                }
                bTessStreamDeclared = TRUE;
            }

            break;
        }
        case D3DVSD_TOKEN_STREAMDATA:
            if( !bInStream )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Cannot set stream input without first setting stream #.  Aborting shader decl. validation.",
                            TokenNum);
                m_ErrorCount++;
                goto Exit;
            }
            if( (Token & D3DVSD_DATALOADTYPEMASK) >> D3DVSD_DATALOADTYPESHIFT ) // SKIP
            {
                if( m_bFixedFunction )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: SKIP not permitted in fixed-function declarations.",
                                TokenNum);
                    m_ErrorCount++;
                    break;
                }
            }
            else
            {
                UINT RegNum = (Token & D3DVSD_VERTEXREGMASK) >> D3DVSD_VERTEXREGSHIFT; 
                if( RegNum >= m_pInputRegFile->GetNumRegs() )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Invalid reg num: %d. Max allowed is %d.",
                           TokenNum, RegNum, m_pInputRegFile->GetNumRegs() - 1);
                    m_ErrorCount++;
                    break;
                }
                
                switch( (Token & D3DVSD_DATATYPEMASK) >> D3DVSD_DATATYPESHIFT )
                {
                case D3DVSDT_FLOAT1:
                case D3DVSDT_FLOAT2:
                case D3DVSDT_FLOAT3:
                case D3DVSDT_FLOAT4:
                case D3DVSDT_D3DCOLOR:
                case D3DVSDT_UBYTE4:
                case D3DVSDT_SHORT2:
                case D3DVSDT_SHORT4:
                    break;
                default:
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Unrecognized stream data type.",
                                TokenNum);
                    m_ErrorCount++;
                    break;
                }

                bErrorInForLoop = FALSE;
                for( UINT i = 0; i < 4; i++ )
                {
                    if( TRUE == m_pInputRegFile->m_pAccessHistory[i][RegNum].m_bPreShaderInitialized )
                    {
                        Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Input register %d already declared.",
                                    TokenNum, RegNum);
                        m_ErrorCount++;
                        bErrorInForLoop = TRUE;
                        break;
                    }
                    m_pInputRegFile->m_pAccessHistory[i][RegNum].m_bPreShaderInitialized = TRUE;
                }
                if( bErrorInForLoop )
                    break;

                bAtLeastOneDataDefinition = TRUE;
            }
            break;
        case D3DVSD_TOKEN_TESSELLATOR:
        {
            if( !bInTessStream )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Cannot set tesselator stream input without first setting tesselator stream #.  Aborting shader decl. validation.",
                            TokenNum);
                m_ErrorCount++;
                goto Exit;
            }

            DWORD InRegNum = (Token & D3DVSD_VERTEXREGINMASK) >> D3DVSD_VERTEXREGINSHIFT;
            DWORD RegNum = (Token & D3DVSD_VERTEXREGMASK) >> D3DVSD_VERTEXREGSHIFT;
            BOOL  bNormalGen = !(Token & 0x10000000); // TODO: Why isnt there a const for this in the d3d api headers?

            if( RegNum >= m_pInputRegFile->GetNumRegs() )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Invalid reg num: %d. Max allowed is %d.",
                       TokenNum, RegNum, m_pInputRegFile->GetNumRegs() - 1);
                m_ErrorCount++;
                break;
            }
            
            if( bNormalGen )
            {
                if( InRegNum >= m_pInputRegFile->GetNumRegs() )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Invalid input reg num: %d. Max allowed is %d.",
                           TokenNum, InRegNum, m_pInputRegFile->GetNumRegs() - 1);
                    m_ErrorCount++;
                    break;
                }

                bErrorInForLoop = FALSE;
                for( UINT i = 0; i < NumNormalGenOperations; i++ )
                {
                    if( pNormalGenOperations[i].DestReg == RegNum )
                    {
                        Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Duplicate declaration of input register %d as destination for normal generation.",
                               TokenNum, RegNum );
                        m_ErrorCount++;
                        bErrorInForLoop = TRUE;
                        break;                
                    }
                }
                if( bErrorInForLoop )
                    break;

                // Defer checking of initialization of inputs for normal gen until the entire declaration has been seen.
                // Also, defer setting of normal gen destination reg. to initialized, 
                // in order to disallow normal generation loops.
                pNormalGenOperations[NumNormalGenOperations].DestReg = RegNum;
                pNormalGenOperations[NumNormalGenOperations].SourceReg = InRegNum;
                pNormalGenOperations[NumNormalGenOperations].TokenNum = TokenNum; // used later for spew
                NumNormalGenOperations++;
            }
            else
            {
                if( ((Token & D3DVSD_DATATYPEMASK) >> D3DVSD_DATATYPESHIFT) != D3DVSDT_FLOAT2 )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Tess datatype must be FLOAT2 for UV generation.",
                                TokenNum);
                    m_ErrorCount++;
                    break;
                }

                if( InRegNum > 0 )
                {
                    Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Input register number must not be specified (does not apply) for UV tesselation.",
                           TokenNum);
                    m_ErrorCount++;
                    break;                
                }

                for( UINT i = 0; i < 4; i++ )
                {
                    if( TRUE == m_pInputRegFile->m_pAccessHistory[i][RegNum].m_bPreShaderInitialized )
                    {
                        Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Input register %d already declared.",
                                    TokenNum, RegNum);
                        m_ErrorCount++;
                        break;
                    }
                    m_pInputRegFile->m_pAccessHistory[i][RegNum].m_bPreShaderInitialized = TRUE;
                }
            }
            bAtLeastOneDataDefinition = TRUE;
            break;
        }
        case D3DVSD_TOKEN_CONSTMEM:
        {
            DWORD ConstCount = (Token & D3DVSD_CONSTCOUNTMASK) >> D3DVSD_CONSTCOUNTSHIFT;
            DWORD MaxOffset = ((Token & D3DVSD_CONSTADDRESSMASK) >> D3DVSD_CONSTADDRESSSHIFT) + ConstCount;
            DWORD NumConstRegs = m_pConstRegFile->GetNumRegs();
            DXGASSERT(NumConstRegs > 0);
            if( (bInStream || bInTessStream) && !bAtLeastOneDataDefinition )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Stream selector token must be followed by at least one stream data definition token.",
                            TokenNum);
                m_ErrorCount++;
            }
            if( 0 == NumConstRegs )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Write to const register %d is not valid.  There are no constant registers available.",
                            TokenNum,MaxOffset );
            }
            else if( MaxOffset > NumConstRegs )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Write to const register %d is out of range.  Max offset is %d.",
                            TokenNum,MaxOffset,m_pConstRegFile->GetNumRegs() - 1 );
                m_ErrorCount++;
            }
            pCurrToken += ConstCount*4;
            bInStream = bInTessStream = FALSE;
            break;
        }
        case D3DVSD_TOKEN_EXT:
            pCurrToken += ((Token & D3DVSD_EXTCOUNTMASK) >> D3DVSD_EXTCOUNTSHIFT);
            if( (bInStream || bInTessStream) && !bAtLeastOneDataDefinition )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Stream selector token must be followed by at least one stream data definition token.",
                            TokenNum);
                m_ErrorCount++;
            }
            bInStream = bInTessStream = FALSE;
            break;
        default:
            Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Unrecognized stream declaration token.  Aborting shader decl. validation.",
                        TokenNum);
            m_ErrorCount++;
            goto Exit;
        }
        pCurrToken++;
    }

    // Make sure inputs to normal gen operations have been initialized
    for( UINT i = 0; i < NumNormalGenOperations; i++ )
    {
        for( UINT Component = 0; Component < 4; Component++ )
        {
            if( FALSE == m_pInputRegFile->m_pAccessHistory[Component][pNormalGenOperations[i].SourceReg].m_bPreShaderInitialized )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token %d: Source input register %d for normal generation has not been declared.",
                       pNormalGenOperations[i].TokenNum, pNormalGenOperations[i].SourceReg);
                m_ErrorCount++;
                break;                
            }
        }
    }

    // Set outputs of normal gen operations to initialized
    for( UINT i = 0; i < NumNormalGenOperations; i++ )
    {
        for( UINT Component = 0; Component < 4; Component++ )
        {
            if( TRUE == m_pInputRegFile->m_pAccessHistory[Component][pNormalGenOperations[i].DestReg].m_bPreShaderInitialized )
            {
                Spew( SPEW_GLOBAL_ERROR, NULL, "Declaration Token #%d: Input reg %d specified as destination for normal generation is already declared elsewhere.",
                            pNormalGenOperations[i].TokenNum, pNormalGenOperations[i].DestReg);
                m_ErrorCount++;
                break;
            }
            m_pInputRegFile->m_pAccessHistory[Component][pNormalGenOperations[i].DestReg].m_bPreShaderInitialized = TRUE;
        }
    }

Exit:
    if( pVertexStreamDeclared )
        delete [] pVertexStreamDeclared;
    if( pNormalGenOperations )
        delete [] pNormalGenOperations;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::ApplyPerInstructionRules
//
// Returns FALSE if shader validation must terminate.
// Returns TRUE if validation may proceed to next instruction.
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::ApplyPerInstructionRules()
{
    if( !   Rule_InstructionRecognized()            ) return FALSE;   // Bail completely on unrecognized instr.
    if( !   Rule_InstructionSupportedByVersion()    ) goto EXIT;
    if( !   Rule_ValidParamCount()                  ) goto EXIT;
    if( !   Rule_ValidSrcParams()                   ) goto EXIT;
    if( !   Rule_SrcInitialized()                   ) goto EXIT; // needs to be before ValidDstParam()
    if( !   Rule_ValidAddressRegWrite()             ) goto EXIT;
    if( !   Rule_ValidDstParam()                    ) goto EXIT;
    if( !   Rule_ValidFRCInstruction()              ) goto EXIT;
    if( !   Rule_ValidRegisterPortUsage()           ) goto EXIT;
    if( !   Rule_ValidInstructionCount()            ) goto EXIT;
EXIT:
    return TRUE;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::ApplyPostInstructionsRules
//-----------------------------------------------------------------------------
void CVShaderValidator::ApplyPostInstructionsRules()
{
    Rule_ValidInstructionCount(); // see if we went over the limits
    Rule_oPosWritten();
}

//-----------------------------------------------------------------------------
//
// Per Instruction Rules
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// CVShaderValidator::Rule_InstructionRecognized
//
// ** Rule:
// Is the instruction opcode known? (regardless of shader version)
//
// ** When to call:  
// Per instruction.
//
// ** Returns:  
// FALSE when instruction not recognized.
//
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::Rule_InstructionRecognized()
{
    switch(m_pCurrInst->m_Type)
    {
    case D3DSIO_MOV:
    case D3DSIO_ADD:
    case D3DSIO_MAD:
    case D3DSIO_MUL:
    case D3DSIO_RCP:
    case D3DSIO_RSQ:
    case D3DSIO_DP3:
    case D3DSIO_DP4:
    case D3DSIO_MIN:
    case D3DSIO_MAX:
    case D3DSIO_SLT:
    case D3DSIO_SGE:
    case D3DSIO_EXPP:
    case D3DSIO_LOGP:
    case D3DSIO_LIT:
    case D3DSIO_DST:
    case D3DSIO_M4x4:
    case D3DSIO_M4x3:
    case D3DSIO_M3x4:
    case D3DSIO_M3x3:
    case D3DSIO_M3x2:
    case D3DSIO_FRC:
    case D3DSIO_EXP:
    case D3DSIO_LOG:
    case D3DSIO_END:
    case D3DSIO_NOP:
        return TRUE; // instruction recognized - ok.
    }

    // if we get here, the instruction is not recognized
    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Unrecognized instruction. Aborting vertex shader validation." );
    m_ErrorCount++;
    return FALSE;  
}

//-----------------------------------------------------------------------------
// CVShaderValidator::Rule_InstructionSupportedByVersion
//
// ** Rule:
// Is the instruction supported by the current pixel shader version?
//
// ** When to call:  
// Per instruction.
//
// ** Returns:  
// FALSE when instruction not supported by version.
//
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::Rule_InstructionSupportedByVersion()
{
  
    if( D3DVS_VERSION(1,0) <= m_Version ) // 1.0 and above
    {
        switch(m_pCurrInst->m_Type)
        {
        case D3DSIO_MOV:
        case D3DSIO_ADD:
        case D3DSIO_MAD:
        case D3DSIO_MUL:
        case D3DSIO_RCP:
        case D3DSIO_RSQ:
        case D3DSIO_DP3:
        case D3DSIO_DP4:
        case D3DSIO_MIN:
        case D3DSIO_MAX:
        case D3DSIO_SLT:
        case D3DSIO_SGE:
        case D3DSIO_EXPP:
        case D3DSIO_LOGP:
        case D3DSIO_LIT:
        case D3DSIO_DST:
        case D3DSIO_M4x4:
        case D3DSIO_M4x3:
        case D3DSIO_M3x4:
        case D3DSIO_M3x3:
        case D3DSIO_M3x2:
        case D3DSIO_FRC:
        case D3DSIO_EXP:
        case D3DSIO_LOG:
            return TRUE; // instruction supported - ok.
        }
    }

    switch(m_pCurrInst->m_Type)
    {
    case D3DSIO_END:
    case D3DSIO_NOP:
        return TRUE; // instruction supported - ok.
    }

    // if we get here, the instruction is not supported.
    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Instruction not supported by version %d.%d vertex shader.",
                D3DSHADER_VERSION_MAJOR(m_Version),D3DSHADER_VERSION_MINOR(m_Version));
    m_ErrorCount++;
    return FALSE;  // no more checks on this instruction
}

//-----------------------------------------------------------------------------
// CVShaderValidator::Rule_ValidParamCount
//
// ** Rule:
// Is the parameter count correct for the instruction?
// The count includes dest + source parameters.
//
// DEF is a special case that is treated as having only 1 dest parameter,
// even though there are also 4 source parameters.  The 4 source params for DEF
// are immediate float values, so there is nothing to check, and no way of
// knowing whether or not those parameter tokens were actually present in the
// token list - all the validator can do is skip over 4 DWORDS (which it does).
//
// ** When to call:  
// Per instruction.
//
// ** Returns:
//
// FALSE when the parameter count is incorrect.
//
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::Rule_ValidParamCount()
{
    BOOL bBadParamCount = FALSE;

    if ((m_pCurrInst->m_DstParamCount + m_pCurrInst->m_SrcParamCount) > SHADER_INSTRUCTION_MAX_PARAMS)  bBadParamCount = TRUE;
    switch (m_pCurrInst->m_Type)
    {
    case D3DSIO_NOP:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 0) || (m_pCurrInst->m_SrcParamCount != 0); break;
    case D3DSIO_EXP:
    case D3DSIO_EXPP:
    case D3DSIO_FRC:
    case D3DSIO_LOG:
    case D3DSIO_LOGP:
    case D3DSIO_LIT:
    case D3DSIO_MOV:
    case D3DSIO_RCP:
    case D3DSIO_RSQ:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 1); break;
    case D3DSIO_ADD:
    case D3DSIO_DP3:
    case D3DSIO_DP4:
    case D3DSIO_DST:
    case D3DSIO_M3x2:
    case D3DSIO_M3x3:
    case D3DSIO_M3x4:
    case D3DSIO_M4x3:
    case D3DSIO_M4x4:
    case D3DSIO_MAX:
    case D3DSIO_MIN:
    case D3DSIO_MUL:
    case D3DSIO_SGE:
    case D3DSIO_SLT:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 2); break;
    case D3DSIO_MAD:
        bBadParamCount = (m_pCurrInst->m_DstParamCount != 1) || (m_pCurrInst->m_SrcParamCount != 3); break;
    }

    if (bBadParamCount)
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid parameter count." );
        m_ErrorCount++;
        return FALSE;  // no more checks on this instruction
    }

    return TRUE;

}

//-----------------------------------------------------------------------------
// CVShaderValidator::Rule_ValidSrcParams
//
// ** Rule:
// For each source parameter,
//     Source register type must be D3DSPR_TEMP/_INPUT/_CONST.
//     Register # must be within range for register type,
//     including the special case where matrix macro ops read source reg# + offset.
//     Modifier must be D3DSPSM_NONE or _NEG.
//     If version is < 1.1, addressmode must be absolute.
//     If the register type is not _CONST, addressmode must be absolute.
//     If relative addressing is used for constants, a0.x must be referenced.
//     Swizzle cannot be used for vector*matrix instructions.
//     
// ** When to call:  
// Per instruction.
//
// ** Returns:
// Always TRUE.
// 
// Errors in any of the source parameters causes m_bSrcParamError[i]
// to be TRUE, so later rules that only apply when a particular source
// parameter was valid know whether they need to execute or not.
// e.g. Rule_SrcInitialized.
//
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::Rule_ValidSrcParams()  // could break this down for more granularity
{
    for( UINT i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
    {
        DXGASSERT(i < 3);
        BOOL bFoundSrcError = FALSE;
        SRCPARAM* pSrcParam = &(m_pCurrInst->m_SrcParam[i]);
        UINT ValidRegNum = 0;
        BOOL bSkipOutOfRangeCheck = FALSE;
        char* SourceName[3] = {"first", "second", "third"};
        switch(pSrcParam->m_RegType)
        {
        case D3DSPR_TEMP:       ValidRegNum = m_pTempRegFile->GetNumRegs(); break;
        case D3DSPR_INPUT:      ValidRegNum = m_pInputRegFile->GetNumRegs(); break;
        case D3DSPR_CONST:      
            if(m_bIgnoreConstantInitializationChecks)
                bSkipOutOfRangeCheck = TRUE;
            else
                ValidRegNum = m_pConstRegFile->GetNumRegs(); 
            break;
        default:
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid reg type for %s source param.", SourceName[i]);
            m_ErrorCount++;
            bFoundSrcError = TRUE;
        }

        if( (!bFoundSrcError) && (!bSkipOutOfRangeCheck)) 
        {
            UINT NumConsecutiveRegistersUsed = 1;
            if( 1 == i )
            {
                switch( m_pCurrInst->m_Type )
                {
                    case D3DSIO_M3x2:
                        NumConsecutiveRegistersUsed = 2;
                        break;
                    case D3DSIO_M3x3:
                        NumConsecutiveRegistersUsed = 3;
                        break;
                    case D3DSIO_M3x4:
                        NumConsecutiveRegistersUsed = 4;
                        break;
                    case D3DSIO_M4x3:
                        NumConsecutiveRegistersUsed = 3;
                        break;
                    case D3DSIO_M4x4:
                        NumConsecutiveRegistersUsed = 4;
                        break;
                }
            }

            if((pSrcParam->m_RegNum >= ValidRegNum) && (D3DVS_ADDRMODE_ABSOLUTE == pSrcParam->m_AddressMode))
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid reg num: %d for %s source param. Max allowed for this type is %d.",
                                    pSrcParam->m_RegNum, SourceName[i], ValidRegNum - 1);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }
            else if( NumConsecutiveRegistersUsed > 1 )
            {
                if( pSrcParam->m_RegNum + NumConsecutiveRegistersUsed - 1 >= ValidRegNum )
                {
                    if( !((D3DSPR_CONST == pSrcParam->m_RegType) && (D3DVS_ADDRMODE_RELATIVE == pSrcParam->m_AddressMode)) )
                    {
                        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                            "Reg num: %d for %s source param on matrix instruction causes attempt to access out of range register number %d. Max allowed for this type is %d.",
                                            pSrcParam->m_RegNum, SourceName[i], pSrcParam->m_RegNum + NumConsecutiveRegistersUsed - 1, ValidRegNum - 1);
                    }
                    m_ErrorCount++;
                    bFoundSrcError = TRUE;
                }
            }
        }
        

        switch( pSrcParam->m_SrcMod )
        {
        case D3DSPSM_NEG:
            if( 1 == i )
            {
                switch( m_pCurrInst->m_Type )
                {
                case D3DSIO_M3x2:
                case D3DSIO_M3x3:
                case D3DSIO_M3x4:
                case D3DSIO_M4x3:
                case D3DSIO_M4x4:
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Cannot negate second source parameter to vector*matrix instructions.");
                    m_ErrorCount++;
                    bFoundSrcError = TRUE;        
                    break;
                }
            }
            break;
        case D3DSPSM_NONE:
            break;
        default:
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid src mod for %s source param.",
                                SourceName[i]);
            m_ErrorCount++;
            bFoundSrcError = TRUE;
        }
    
        if( pSrcParam->m_AddressMode != D3DVS_ADDRMODE_ABSOLUTE 
            &&
            ( m_Version < D3DVS_VERSION(1,1) || pSrcParam->m_RegType != D3DSPR_CONST )
          )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Address mode must be absolute (%s source param).",
                                SourceName[i]);
            m_ErrorCount++;
            bFoundSrcError = TRUE;
        }
        
        if( (pSrcParam->m_AddressMode == D3DVS_ADDRMODE_RELATIVE) &&
            (D3DSPR_CONST == pSrcParam->m_RegType) )
        {
            if( pSrcParam->m_RelativeAddrComponent != D3DSP_WRITEMASK_0 )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Relative addressing of constant register must reference a0.x only.",
                                    SourceName[i]);
                m_ErrorCount++;
                bFoundSrcError = TRUE;
            }
        }

        if( pSrcParam->m_SwizzleShift != D3DSP_NOSWIZZLE )
        {
            if( 1 == i )
            {
                switch( m_pCurrInst->m_Type )
                {
                case D3DSIO_M3x2:
                case D3DSIO_M3x3:
                case D3DSIO_M3x4:
                case D3DSIO_M4x3:
                case D3DSIO_M4x4:
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Cannot swizzle second source parameter to vector*matrix instructions.");
                    m_ErrorCount++;
                    bFoundSrcError = TRUE;        
                    break;
                }
            }
        }

        if( bFoundSrcError )
        {
            m_bSrcParamError[i] = TRUE; // needed in Rule_SrcInitialized
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::Rule_SrcInitialized
//
// ** Rule:
// for each source parameter,
//     The register type must be _TEMP, _INPUT or _CONST.
//     Certain components of the register need to have been initialized, depending
//     on what the instruction is and also taking into account the source swizzle.
//     For reads of the _CONST register file, do no validation.
//
// ** When to call:  
// Per instruction. This rule must be called before Rule_ValidDstParam().
//
// ** Returns:
// Always TRUE.
//
// NOTE: This rule also updates the access history to indicate reads of the
// affected components of each source register.
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::Rule_SrcInitialized()
{
    DSTPARAM* pDstParam = &(m_pCurrInst->m_DstParam);

    for( UINT i = 0; i < m_pCurrInst->m_SrcParamCount; i++ )
    {
        SRCPARAM* pSrcParam = &(m_pCurrInst->m_SrcParam[i]);
        UINT RegNum = pSrcParam->m_RegNum;
        CRegisterFile* pRegFile = NULL;
        char* RegChar = NULL;
        UINT NumConsecutiveRegistersUsed = 1; // more than one for matrix mul macros.
        DWORD RelativeAddrComponent = 0;

        if( m_bSrcParamError[i] ) continue;

        switch( pSrcParam->m_RegType )
        {
            case D3DSPR_TEMP:       
                pRegFile = m_pTempRegFile; 
                RegChar = "r";
                break;
            case D3DSPR_INPUT:       
                pRegFile = m_pInputRegFile; 
                RegChar = "v";
                break;
            case D3DSPR_CONST:    
                if( D3DVS_ADDRMODE_RELATIVE == pSrcParam->m_AddressMode )
                {
                    // make sure a0 was initialized.
                    pRegFile = m_pAddrRegFile;
                    RegChar = "a";
                    RegNum = 0;
                    RelativeAddrComponent = pSrcParam->m_RelativeAddrComponent;
                    break;
                }
                continue; // no validation for const register reads (no need to update access history either).
        }
        if( !pRegFile ) continue;

        if( 1 == i )
        {
            switch( m_pCurrInst->m_Type )
            {
                case D3DSIO_M3x2:
                    NumConsecutiveRegistersUsed = 2;
                    break;
                case D3DSIO_M3x3:
                    NumConsecutiveRegistersUsed = 3;
                    break;
                case D3DSIO_M3x4:
                    NumConsecutiveRegistersUsed = 4;
                    break;
                case D3DSIO_M4x3:
                    NumConsecutiveRegistersUsed = 3;
                    break;
                case D3DSIO_M4x4:
                    NumConsecutiveRegistersUsed = 4;
                    break;
            }
        }
        // check for read of uninitialized components
        for( UINT j = 0; j < (RelativeAddrComponent?1:NumConsecutiveRegistersUsed); j++ ) // will loop for macro matrix instructions
        {
            DWORD  UninitializedComponentsMask = 0;
            UINT   NumUninitializedComponents = 0;

            for( UINT k = 0; k < 4; k++ )
            {
                if( (RelativeAddrComponent ? RelativeAddrComponent : pSrcParam->m_ComponentReadMask) & COMPONENT_MASKS[k] )
                {
                    if( NULL == pRegFile->m_pAccessHistory[k][RegNum + j].m_pMostRecentWriter &&
                        !pRegFile->m_pAccessHistory[k][RegNum + j].m_bPreShaderInitialized )
                    {
                        NumUninitializedComponents++;
                        UninitializedComponentsMask |= COMPONENT_MASKS[k];
                    }
                }

            }

            if( NumUninitializedComponents )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Read of uninitialized component%s(*) in %s%d: %s",
                    NumUninitializedComponents > 1 ? "s" : "",
                    RegChar, RegNum + j, MakeAffectedComponentsText(UninitializedComponentsMask,FALSE,TRUE));
                m_ErrorCount++;
            }

            // Update register file to indicate READ.
            // Multiple reads of the same register component by the current instruction
            // will only be logged as one read in the access history.

            for( UINT k = 0; k < 4; k++ )
            {
                #define PREV_READER(_CHAN,_REG) \
                        ((NULL == pRegFile->m_pAccessHistory[_CHAN][_REG].m_pMostRecentReader) ? NULL :\
                        pRegFile->m_pAccessHistory[_CHAN][_REG].m_pMostRecentReader->m_pInst)
                if((RelativeAddrComponent ? RelativeAddrComponent : pSrcParam->m_ComponentReadMask) & COMPONENT_MASKS[k])
                {
                    if( PREV_READER(k,RegNum) != m_pCurrInst )
                    {
                        if( !pRegFile->m_pAccessHistory[k][RegNum].NewAccess(m_pCurrInst,FALSE) )
                        {
                            Spew( SPEW_GLOBAL_ERROR, NULL, "Out of memory");
                            m_ErrorCount++;
                        }
                    }
                }
            }
        }
    }
    return TRUE;
}
//-----------------------------------------------------------------------------
// CVShaderValidator::Rule_ValidAddressRegWrite
//
// ** Rule:
// Address register may only be written by MOV, and only for version >= 1.1.
// Register format must be a0.x
//
// ** When to call:  
// Per instruction.
//
// ** Returns:
// Always TRUE
//
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::Rule_ValidAddressRegWrite() 
{
    DSTPARAM* pDstParam = &(m_pCurrInst->m_DstParam);

    if( pDstParam->m_bParamUsed )
    {
        if( D3DSPR_ADDR == pDstParam->m_RegType )
        {
            if( m_Version < D3DVS_VERSION(1,1) )
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Address register not available for vertex shader version %d.%d.  Version 1.1 required.",
                            D3DSHADER_VERSION_MAJOR(m_Version),D3DSHADER_VERSION_MINOR(m_Version) );
                m_ErrorCount++;
            }
            if( D3DSIO_MOV == m_pCurrInst->m_Type )
            {
                if( 0 != pDstParam->m_RegNum ||
                    D3DSP_WRITEMASK_0 != pDstParam->m_WriteMask ||
                    D3DSPDM_NONE != pDstParam->m_DstMod ||
                    DSTSHIFT_NONE != pDstParam->m_DstShift )
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Format for address register must be a0.x." );
                    m_ErrorCount++;
                }
            }
            else
            {
                Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Only the mov instruction is allowed to write to the address register." );
                m_ErrorCount++;
            }
        }
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::Rule_ValidDstParam
//
// ** Rule:
// Dst register type must be temp/addr/rastout/attrout/texcrdout,
// and reg num must be within range for register type.
//
// There can be no dst modifiers or shifts with vertex shaders.
//
// The writemask cannot be 'none'.
//
// ** When to call:  
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
// NOTE: After checking the dst parameter, if no error was found,
// the write to the appropriate component(s) of the destination register
// is recorded by this function, so subsequent rules may check for previous
// write to registers.
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::Rule_ValidDstParam() // could break this down for more granularity
{
    BOOL   bFoundDstError = FALSE;
    DSTPARAM* pDstParam = &(m_pCurrInst->m_DstParam);
    UINT RegNum = pDstParam->m_RegNum;

    if( pDstParam->m_bParamUsed )
    {
        UINT ValidRegNum = 0;

        BOOL bWritable = FALSE;
        switch( pDstParam->m_RegType )
        {
        case D3DSPR_TEMP:       
            bWritable = m_pTempRegFile->IsWritable(); //(TRUE)
            ValidRegNum = m_pTempRegFile->GetNumRegs();
            break;
        case D3DSPR_ADDR:       
            bWritable = m_pAddrRegFile->IsWritable(); //(TRUE)
            ValidRegNum = m_pAddrRegFile->GetNumRegs();                                
            break;
        case D3DSPR_RASTOUT:    
            bWritable = m_pRastOutputRegFile->IsWritable(); //(TRUE)
            ValidRegNum = m_pRastOutputRegFile->GetNumRegs();            
            break;
        case D3DSPR_ATTROUT:    
            bWritable = m_pAttrOutputRegFile->IsWritable(); //(TRUE)
            ValidRegNum = m_pAttrOutputRegFile->GetNumRegs();                        
            break;
        case D3DSPR_TEXCRDOUT:  
            bWritable = m_pTexCrdOutputRegFile->IsWritable(); //(TRUE)
            ValidRegNum = m_pTexCrdOutputRegFile->GetNumRegs();                                    
            break;
        }

        if( !bWritable || !ValidRegNum )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid reg type for dest param." );
            m_ErrorCount++;
            bFoundDstError = TRUE;
        } 
        else if( RegNum >= ValidRegNum )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Invalid dest reg num: %d. Max allowed for this reg type is %d.", RegNum, ValidRegNum - 1);
            m_ErrorCount++;
            bFoundDstError = TRUE;
        }

        switch( pDstParam->m_DstMod )
        {
        case D3DSPDM_NONE:
            break;
        default:
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Dst modifiers not allowed for vertex shaders." );
            m_ErrorCount++;
            bFoundDstError = TRUE;
        }

        switch( pDstParam->m_DstShift )
        {
        case DSTSHIFT_NONE:
            break;
        default:
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Dest shifts not allowed for vertex shaders." );
            m_ErrorCount++;
            bFoundDstError = TRUE;
        }

        if( 0 == pDstParam->m_WriteMask )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Dest write mask cannot be empty." );
            m_ErrorCount++;
            bFoundDstError = TRUE;
        }

        // Update register file to indicate write.
        if( !bFoundDstError )
        {
            CRegisterFile* pRegFile = NULL;
            switch( pDstParam->m_RegType )
            {
            case D3DSPR_TEMP:       
                pRegFile = m_pTempRegFile; 
                break;
            case D3DSPR_ADDR:       
                pRegFile = m_pAddrRegFile; 
                break;
            case D3DSPR_RASTOUT:    
                pRegFile = m_pRastOutputRegFile; 
                break;
            case D3DSPR_ATTROUT:    
                pRegFile = m_pAttrOutputRegFile; 
                break;
            case D3DSPR_TEXCRDOUT:  
                pRegFile = m_pTexCrdOutputRegFile; 
                break;
            }

            if( pRegFile )
            {
                if( pDstParam->m_WriteMask & D3DSP_WRITEMASK_0 ) 
                    pRegFile->m_pAccessHistory[0][RegNum].NewAccess(m_pCurrInst,TRUE);

                if( pDstParam->m_WriteMask & D3DSP_WRITEMASK_1 ) 
                    pRegFile->m_pAccessHistory[1][RegNum].NewAccess(m_pCurrInst,TRUE);

                if( pDstParam->m_WriteMask & D3DSP_WRITEMASK_2 ) 
                    pRegFile->m_pAccessHistory[2][RegNum].NewAccess(m_pCurrInst,TRUE);

                if( pDstParam->m_WriteMask & D3DSP_WRITEMASK_3 ) 
                    pRegFile->m_pAccessHistory[3][RegNum].NewAccess(m_pCurrInst,TRUE);
            }
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::Rule_ValidFRCInstruction
//
// ** Rule:
// The only valid write masks for the FRC instruction are .y and .xy
// 
// ** When to call:  
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::Rule_ValidFRCInstruction()
{
    if( NULL == m_pCurrInst )
        return TRUE;

    if( D3DSIO_FRC == m_pCurrInst->m_Type )
    {
        if( ( (D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1) != m_pCurrInst->m_DstParam.m_WriteMask ) &&
            (                      D3DSP_WRITEMASK_1  != m_pCurrInst->m_DstParam.m_WriteMask ) )
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                "The only valid write masks for the FRC instruction are .xy and .y." );
            m_ErrorCount++;                            
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::Rule_ValidRegisterPortUsage
//
// ** Rule:
// Each register class (TEMP,TEXTURE,INPUT,CONST) may only appear as parameters
// in an individual instruction up to a maximum number of times.
//
// In additon there is special treatment for constant registers:
//      - absolute and relative addressing of constants cannot be combined
//      - relative addressing of constants can be used more than once in an
//        instruction, as long as each instance is identical
//
// For matrix ops, 
//      - multiple constant registers of any type (including relative offset)
//        can never be paired as sources 
//      - multiple input registers (same or different) can never be paired as sources
//
// ** When to call:  
// Per instruction.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::Rule_ValidRegisterPortUsage()
{
    UINT TempRegAccessCount = 0;
    UINT TempRegAccess[SHADER_INSTRUCTION_MAX_SRCPARAMS];
    UINT InputRegAccessCount = 0;
    UINT InputRegAccess[SHADER_INSTRUCTION_MAX_SRCPARAMS];
    UINT ConstRegAccessCount = 0; // mad r0, c0, c0, c1 counts as *2* const reg accesses
    UINT ConstRegAccess[SHADER_INSTRUCTION_MAX_SRCPARAMS];

    BOOL bMatrixOp = FALSE;
    BOOL bSeenRelativeAddr = FALSE;
    UINT SeenRelativeAddrBase = 0;
    DWORD SeenRelativeAddrComp = 0;
    BOOL bSeenAbsoluteAddr = FALSE;
    UINT NumConsecutiveRegistersUsed = 1;
    UINT NumConstRegs = 0; // mad r0, c0, c0, c1 counts as *3* const reg accesses with this variable
    UINT NumInputRegs = 0; // mad r0, v0, v0, v1 counts as *3* input reg accesses with this variable

    switch( m_pCurrInst->m_Type )
    {
        case D3DSIO_M3x2:
            NumConsecutiveRegistersUsed = 2;
            bMatrixOp = TRUE;
            break;
        case D3DSIO_M3x3:
            NumConsecutiveRegistersUsed = 3;
            bMatrixOp = TRUE;
            break;
        case D3DSIO_M3x4:
            NumConsecutiveRegistersUsed = 4;
            bMatrixOp = TRUE;
            break;
        case D3DSIO_M4x3:
            NumConsecutiveRegistersUsed = 3;
            bMatrixOp = TRUE;
            break;
        case D3DSIO_M4x4:
            NumConsecutiveRegistersUsed = 4;
            bMatrixOp = TRUE;
            break;
        default:
            break;
    }

    for( UINT i = 0; i < SHADER_INSTRUCTION_MAX_SRCPARAMS; i++ )
    {
        D3DSHADER_PARAM_REGISTER_TYPE   RegType;
        UINT                            RegNum;

        if( !m_pCurrInst->m_SrcParam[i].m_bParamUsed ) continue;
        RegType = m_pCurrInst->m_SrcParam[i].m_RegType;
        RegNum  = m_pCurrInst->m_SrcParam[i].m_RegNum;

        UINT* pCount = NULL;
        UINT* pAccess = NULL;
        switch( RegType )
        {
        case D3DSPR_TEMP:
            pCount = &TempRegAccessCount;
            pAccess = TempRegAccess;
            break;
        case D3DSPR_INPUT:
            NumInputRegs++;
            pCount = &InputRegAccessCount;
            pAccess = InputRegAccess;
            break;
        case D3DSPR_CONST:
            NumConstRegs++;
            pCount = &ConstRegAccessCount;
            pAccess = ConstRegAccess;

            if( D3DVS_ADDRMODE_RELATIVE == m_pCurrInst->m_SrcParam[i].m_AddressMode )
            {
                if( bSeenAbsoluteAddr )
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                        "Absolute and relative addressing of constant registers cannot be combined in one instruction.");
                    m_ErrorCount++;        
                }
                else if( bSeenRelativeAddr && 
                        ((SeenRelativeAddrBase != RegNum) || (SeenRelativeAddrComp != m_pCurrInst->m_SrcParam[i].m_RelativeAddrComponent)))
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                        "Different relative addressing of constant registers cannot be combined in one instruction.");
                    m_ErrorCount++;                            
                }

                bSeenRelativeAddr = TRUE;
                SeenRelativeAddrBase = RegNum;
                SeenRelativeAddrComp = m_pCurrInst->m_SrcParam[i].m_RelativeAddrComponent;
            }
            else
            {
                if( bSeenRelativeAddr )
                {
                    Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, 
                        "Absolute and relative addressing of constant registers cannot be combined in one instruction.");
                    m_ErrorCount++;        
                }
                bSeenAbsoluteAddr = TRUE;
            }
            break;
        }

        if( pCount && pAccess )
        {
            BOOL bNewRegNumberAccessed = TRUE;
            for( UINT j = 0; j < *pCount; j++ )
            {
                if( RegNum == pAccess[j] )
                {
                    bNewRegNumberAccessed = FALSE;
                    break;
                }
            }
            if( bNewRegNumberAccessed )
            {
                pAccess[*pCount] = RegNum;
                (*pCount)++;
            }
        }
    }

    if( TempRegAccessCount > m_pTempRegFile->GetNumReadPorts() )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%d different temp registers (r#) read by instruction.  Max. different temp registers readable per instruction is %d.",
                        TempRegAccessCount,  m_pTempRegFile->GetNumReadPorts());
        m_ErrorCount++;        
    }

    if( InputRegAccessCount > m_pInputRegFile->GetNumReadPorts() )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%d different input registers (v#) read by instruction.  Max. different input registers readable per instruction is %d.",
                        InputRegAccessCount,  m_pInputRegFile->GetNumReadPorts());
        m_ErrorCount++;        
    }

    if( ConstRegAccessCount > m_pConstRegFile->GetNumReadPorts() )
    {
        Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "%d different constant registers (c#) read by instruction.  Max. different constant registers readable per instruction is %d.",
                        ConstRegAccessCount, m_pConstRegFile->GetNumReadPorts());
        m_ErrorCount++;        
    }

    if( bMatrixOp )
    {
        if(1 < NumConstRegs)
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Multiple constant registers cannot be read by a matrix op.");
            m_ErrorCount++;        
        }
        if(1 < NumInputRegs)
        {
            Spew( SPEW_INSTRUCTION_ERROR, m_pCurrInst, "Multiple input registers cannot be read by a matrix op.");
            m_ErrorCount++;        
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::Rule_ValidInstructionCount
//
// ** Rule:
// Make sure instruction count for vertex shader version has not been exceeded.
//
// Nop, and comments (already stripped) do not count towards the limit.
//
// ** When to call:  
// Per instruction AND after all instructions seen.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::Rule_ValidInstructionCount()
{
    static UINT s_OpCount;
    static UINT s_MaxTotalOpCount;

    if( NULL == m_pCurrInst->m_pPrevInst )   // First instruction - initialize static vars
    {
        s_OpCount = 0;

        switch(m_Version)
        {
        case D3DVS_VERSION(1,0):
        case D3DVS_VERSION(1,1):
        default:
            s_MaxTotalOpCount   = 128;
            break;
        }
    }

    if( m_bSeenAllInstructions )
    {
        if( s_OpCount > s_MaxTotalOpCount )
        {
            Spew( SPEW_GLOBAL_ERROR, NULL, "Number of instruction slots used too high: %d. Max. allowed is %d.",
                  s_OpCount, s_MaxTotalOpCount);
            m_ErrorCount++;
        }
        return TRUE;
    }

    switch( m_pCurrInst->m_Type )
    {
    case D3DSIO_NOP:
        s_OpCount += 0; break;
    case D3DSIO_ADD:
    case D3DSIO_DP3:
    case D3DSIO_DP4:
    case D3DSIO_DST:
    case D3DSIO_EXPP:
    case D3DSIO_LIT:
    case D3DSIO_LOGP:
    case D3DSIO_MAD:
    case D3DSIO_MAX:
    case D3DSIO_MIN:
    case D3DSIO_MOV:
    case D3DSIO_MUL:
    case D3DSIO_RCP:
    case D3DSIO_RSQ:
    case D3DSIO_SGE:
    case D3DSIO_SLT:
        s_OpCount += 1; break;
    case D3DSIO_M3x2:
        s_OpCount += 2; break;
    case D3DSIO_FRC:
    case D3DSIO_M3x3:
    case D3DSIO_M4x3:
        s_OpCount += 3; break;
    case D3DSIO_M3x4:
    case D3DSIO_M4x4:
        s_OpCount += 4; break;
    case D3DSIO_EXP:
    case D3DSIO_LOG:
        s_OpCount += 10; break;
    }
    
    return TRUE;
}

//-----------------------------------------------------------------------------
// CVShaderValidator::Rule_oPosWritten
//
// ** Rule:
// First two channels (x,y) of oPos output register must be written.
//
// ** When to call:  
// After all instructions have been seen.
//
// ** Returns:
// Always TRUE.
//
//-----------------------------------------------------------------------------
BOOL CVShaderValidator::Rule_oPosWritten()
{
    UINT  NumUninitializedComponents    = 0;
    DWORD UninitializedComponentsMask   = 0;

    for( UINT i = 0; i < 2; i++ ) // looking at component 0 (X) and component 1 (Y)
    {
        if( NULL == m_pRastOutputRegFile->m_pAccessHistory[i][0].m_pMostRecentWriter )
        {
            NumUninitializedComponents++;
            UninitializedComponentsMask |= COMPONENT_MASKS[i];
        }
    }
    if( 1 == NumUninitializedComponents )
    {
        Spew( SPEW_GLOBAL_ERROR, NULL, "Vertex shader must minimally write first two (x,y) components of oPos output register.  Affected component%s(*): %s",
            NumUninitializedComponents > 1 ? "s" : "", MakeAffectedComponentsText(UninitializedComponentsMask,FALSE,TRUE));
        m_ErrorCount++;
    } 
    else if( 2 == NumUninitializedComponents )
    {
        Spew( SPEW_GLOBAL_ERROR, NULL, "Vertex shader must minimally write first two (x,y) components of oPos output register.");
        m_ErrorCount++;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
//
// CVShaderValidator Wrapper Functions
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// ValidateVertexShaderInternal
//-----------------------------------------------------------------------------
BOOL ValidateVertexShaderInternal(   const DWORD* pCode, 
                                     const DWORD* pDecl, 
                                     const D3DCAPS8* pCaps )
{
    CVShaderValidator Validator(pCode,pDecl,pCaps,0);
    return SUCCEEDED(Validator.GetStatus()) ? TRUE : FALSE;
}

//-----------------------------------------------------------------------------
// ValidateVertexShader
//
// Don't forget to call "free" on the buffer returned in ppBuf.
//-----------------------------------------------------------------------------
HRESULT WINAPI ValidateVertexShader(    const DWORD* pCode, 
                                        const DWORD* pDecl,
                                        const D3DCAPS8* pCaps, 
                                        const DWORD Flags, 
                                        char** const ppBuf )
{
    CVShaderValidator Validator(pCode,pDecl,pCaps,Flags);
    if( ppBuf )
    {
        *ppBuf = (char*)HeapAlloc(GetProcessHeap(), 0, Validator.GetRequiredLogBufferSize());
        if( NULL == *ppBuf )
            OutputDebugString("Out of memory.\n");
        else
            Validator.WriteLogToBuffer(*ppBuf);
    }
    return Validator.GetStatus();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\shval\vshdrval.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// vshdrval.hpp
//
// Direct3D Reference Device - VertexShader validation
//
///////////////////////////////////////////////////////////////////////////////
#ifndef __VSHDRVAL_HPP__
#define __VSHDRVAL_HPP__

#define VS_INST_TOKEN_RESERVED_MASK         0xffff0000 // bits 16-23, 24-29, 30, 31 must be 0
#define VS_DSTPARAM_TOKEN_RESERVED_MASK     0x0ff0e000 // bits 13-15, 20-23, 24-27 must be 0
#define VS_SRCPARAM_TOKEN_RESERVED_MASK     0x40000000 // bit 30 must be 0

//-----------------------------------------------------------------------------
// CVSInstruction
//-----------------------------------------------------------------------------
class CVSInstruction : public CBaseInstruction
{
public:
    CVSInstruction(CVSInstruction* pPrevInst) : CBaseInstruction(pPrevInst) {};

    void CalculateComponentReadMasks(DWORD dwVersion);
};

//-----------------------------------------------------------------------------
// CVShaderValidator
//-----------------------------------------------------------------------------
class CVShaderValidator : public CBaseShaderValidator
{
private:
    void ValidateDeclaration();
    const DWORD*    m_pDecl;
    BOOL            m_bFixedFunction;
    DWORD           m_dwMaxVertexShaderConst; // d3d8 cap
    BOOL            m_bIgnoreConstantInitializationChecks;

    CRegisterFile*  m_pTempRegFile;    
    CRegisterFile*  m_pInputRegFile;
    CRegisterFile*  m_pConstRegFile;
    CRegisterFile*  m_pAddrRegFile;
    CRegisterFile*  m_pTexCrdOutputRegFile;
    CRegisterFile*  m_pAttrOutputRegFile;
    CRegisterFile*  m_pRastOutputRegFile;

    CBaseInstruction* AllocateNewInstruction(CBaseInstruction*pPrevInst);
    BOOL DecodeNextInstruction();
    BOOL InitValidation();
    BOOL ApplyPerInstructionRules();
    void ApplyPostInstructionsRules();

    BOOL Rule_InstructionRecognized();
    BOOL Rule_InstructionSupportedByVersion();
    BOOL Rule_ValidParamCount();
    BOOL Rule_ValidSrcParams(); 
    BOOL Rule_SrcInitialized();
    BOOL Rule_ValidAddressRegWrite();
    BOOL Rule_ValidDstParam();
    BOOL Rule_ValidFRCInstruction();
    BOOL Rule_ValidRegisterPortUsage();
    BOOL Rule_ValidInstructionCount();             // Call per instruction AND after all instructions seen
    BOOL Rule_oPosWritten();                       // Call after all instructions seen
        
public:
    CVShaderValidator(  const DWORD* pCode, 
                        const DWORD* pDecl, 
                        const D3DCAPS8* pCaps, 
                        DWORD Flags );
    ~CVShaderValidator();
};

#endif __VSHDRVAL_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\tnl\clipper.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clipper.c
 *  Content:    Clipper
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#define GET_NEW_CLIP_VERTEX \
&pv->ClipperState.clip_vertices[pv->ClipperState.clip_vertices_used++];
//---------------------------------------------------------------------
__inline void
InterpolateColor(DWORD* p,      // Output
                 DWORD p1,
                 DWORD p2,
                 D3DVALUE num_denom )
{
    float r1, g1, b1, a1;
    float r2, g2, b2, a2;

    r1 = (float)(RGBA_GETRED(p1));
    g1 = (float)(RGBA_GETGREEN(p1));
    b1 = (float)(RGBA_GETBLUE(p1));
    a1 = (float)(RGBA_GETALPHA(p1));
    r2 = (float)(RGBA_GETRED(p2));
    g2 = (float)(RGBA_GETGREEN(p2));
    b2 = (float)(RGBA_GETBLUE(p2));
    a2 = (float)(RGBA_GETALPHA(p2));
    DWORD r = FTOI(r1 + (r2 - r1) * num_denom);
    DWORD g = FTOI(g1 + (g2 - g1) * num_denom);
    DWORD b = FTOI(b1 + (b2 - b1) * num_denom);
    DWORD a = FTOI(a1 + (a2 - a1) * num_denom);
    *p = RGBA_MAKE(r, g, b, a);
}
//---------------------------------------------------------------------
__inline D3DVALUE
InterpolateTexture(D3DVALUE t1,
                   D3DVALUE t2,
                   D3DVALUE num_denom,
                   DWORD    bWrap)
{
    if (!bWrap)
        return ((t2 - t1) * num_denom + t1);
    else
    {
        D3DVALUE t = (TextureDiff(t2, t1, 1) * num_denom + t1);
        if (t > 1.0f)
            t -= 1.0f;
        return t;
    }
}
//---------------------------------------------------------------------
void
Interpolate(D3DFE_PROCESSVERTICES *pv,
            ClipVertex *p,
            ClipVertex *p1,
            ClipVertex *p2,
            int code,
            D3DVALUE num, D3DVALUE denom)
{
    D3DVALUE num_denom = num / denom;

    p->clip = (((int)p1->clip & (int)p2->clip) & ~CLIPPED_ENABLE) | code;
    p->hx = p1->hx + (p2->hx - p1->hx) * num_denom;
    p->hy = p1->hy + (p2->hy - p1->hy) * num_denom;
    p->hz = p1->hz + (p2->hz - p1->hz) * num_denom;
    p->hw = p1->hw + (p2->hw - p1->hw) * num_denom;

    // Note: for the flat shade mode we assigned the same color (except fog 
    // factor) to all vertices  when we prepared the triangle (line) for 
    // clipping
    if (pv->dwVIDOut & D3DFVF_DIFFUSE)
    {
        if (!(pv->dwDeviceFlags & D3DDEV_FLATSHADEMODE))
            InterpolateColor(&p->color, p1->color, p2->color, num_denom);
        else
            p->color = p1->color;
    }
    
    if (pv->dwVIDOut & D3DFVF_SPECULAR)
    {
        if (!(pv->dwDeviceFlags & D3DDEV_FLATSHADEMODE))
            InterpolateColor(&p->specular, p1->specular, p2->specular, num_denom);
        else
        {
            float a1 = (float)(RGBA_GETALPHA(p1->specular));
            float a2 = (float)(RGBA_GETALPHA(p2->specular));
            DWORD a = FTOI(a1 + (a2 - a1) * num_denom);
            p->specular = (p1->specular & 0xFFFFFF) + ((a & 0xFF) << 24);
        }
    }

    // Assume that D3DRENDERSTATE_WRAPi are sequential
    D3DVALUE *pTexture1 = p1->tex;
    D3DVALUE *pTexture2 = p2->tex;
    D3DVALUE *pTexture = p->tex;
    for (DWORD i = 0; i < pv->nOutTexCoord; i++)
    {
        DWORD wrapState = pv->lpdwRStates[D3DRENDERSTATE_WRAP0 + i];
        DWORD n = (DWORD)(pv->dwTextureCoordSize[i] >> 2);
        DWORD dwWrapBit = 1;
        for (DWORD j=0; j < n; j++)
        {
            *pTexture = InterpolateTexture(*pTexture1, *pTexture2,
                                           num_denom, wrapState & dwWrapBit);
            dwWrapBit <<= 1;
            pTexture ++;
            pTexture1++;
            pTexture2++;
        }
    }
}
//------------------------------------------------------------------------------
// Functions for clipping by frustum window
//
#define __CLIP_NAME ClipLeft
#define __CLIP_LINE_NAME ClipLineLeft
#define __CLIP_FLAG CLIPPED_LEFT
#define __CLIP_COORD hx
#include "clip.h"

#define __CLIP_NAME ClipRight
#define __CLIP_LINE_NAME ClipLineRight
#define __CLIP_W
#define __CLIP_FLAG CLIPPED_RIGHT
#define __CLIP_COORD hx
#include "clip.h"

#define __CLIP_NAME ClipBottom
#define __CLIP_LINE_NAME ClipLineBottom
#define __CLIP_FLAG CLIPPED_BOTTOM
#define __CLIP_COORD hy
#include "clip.h"

#define __CLIP_NAME ClipTop
#define __CLIP_LINE_NAME ClipLineTop
#define __CLIP_W
#define __CLIP_FLAG CLIPPED_TOP
#define __CLIP_COORD hy
#include "clip.h"

#define __CLIP_NAME ClipBack
#define __CLIP_LINE_NAME ClipLineBack
#define __CLIP_W
#define __CLIP_FLAG CLIPPED_BACK
#define __CLIP_COORD hz
#include "clip.h"

#define __CLIP_NAME ClipFront
#define __CLIP_LINE_NAME ClipLineFront
#define __CLIP_FLAG CLIPPED_FRONT
#define __CLIP_COORD hz
#include "clip.h"
//------------------------------------------------------------------------------
// Functions for guard band clipping
//
#define __CLIP_GUARDBAND
#define __CLIP_NAME ClipLeftGB
#define __CLIP_LINE_NAME ClipLineLeftGB
#define __CLIP_FLAG CLIPPED_LEFT
#define __CLIP_COORD hx
#define __CLIP_SIGN -
#define __CLIP_GBCOEF Kgbx1
#include "clip.h"

#define __CLIP_NAME ClipRightGB
#define __CLIP_LINE_NAME ClipLineRightGB
#define __CLIP_FLAG CLIPPED_RIGHT
#define __CLIP_COORD hx
#define __CLIP_GBCOEF Kgbx2
#define __CLIP_SIGN +
#include "clip.h"

#define __CLIP_NAME ClipBottomGB
#define __CLIP_LINE_NAME ClipLineBottomGB
#define __CLIP_FLAG CLIPPED_BOTTOM
#define __CLIP_COORD hy
#define __CLIP_SIGN -
#define __CLIP_GBCOEF Kgby1
#include "clip.h"

#define __CLIP_NAME ClipTopGB
#define __CLIP_LINE_NAME ClipLineTopGB
#define __CLIP_FLAG CLIPPED_TOP
#define __CLIP_COORD hy
#define __CLIP_GBCOEF Kgby2
#define __CLIP_SIGN +
#include "clip.h"

#undef __CLIP_GUARDBAND
//
// Clipping a triangle by a plane
//
// Returns number of vertices in the clipped triangle
//
int ClipByPlane (D3DFE_PROCESSVERTICES *pv,
                 ClipVertex **inv, 
                 ClipVertex **outv,
                 D3DVECTORH *plane,
                 DWORD dwClipFlag,
                 int count)
{
    int i;
    int out_count = 0;
    ClipVertex *curr, *prev;
    D3DVALUE curr_inside;
    D3DVALUE prev_inside;

    prev = inv[count-1];
    curr = *inv++;
    prev_inside = prev->hx*plane->x + prev->hy*plane->y + 
                  prev->hz*plane->z + prev->hw*plane->w;
    for (i = count; i; i--) 
    {
        curr_inside = curr->hx*plane->x + curr->hy*plane->y + 
                      curr->hz*plane->z + curr->hw*plane->w;
        // We interpolate always from the inside vertex to the outside vertex
        // to reduce precision problems
        if (FLOAT_LTZ(prev_inside)) 
        { // first point is outside
            if (FLOAT_GEZ(curr_inside)) 
            { // second point is inside
              // Find intersection and insert in into the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                Interpolate(pv,
                            outv[out_count],
                            curr, prev, 
                            (prev->clip & CLIPPED_ENABLE) | dwClipFlag,
                            curr_inside, curr_inside - prev_inside);
                out_count++;
            }
        } else 
        { // first point is inside - put it to the output buffer first
            outv[out_count++] = prev;
            if (FLOAT_LTZ(curr_inside)) 
            { // second point is outside
              // Find intersection and put it to the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                Interpolate(pv, 
                            outv[out_count],
                            prev, curr,
                            dwClipFlag,
                            prev_inside, prev_inside - curr_inside);
                out_count++;
            }
        }
        prev = curr;
        curr = *inv++;
        prev_inside = curr_inside;
    }
    return out_count;
}
//-------------------------------------------------------------------------
// Clips a line by a plane
//
// Returns 1 if the line is outside the frustum, 0 otherwise
//
int ClipLineByPlane(D3DFE_PROCESSVERTICES *pv, 
                    ClipTriangle *line, 
                    D3DVECTORH *plane,
                    DWORD dwClipBit)
{
    D3DVALUE in1, in2;
    ClipVertex outv;
    in1 = line->v[0]->hx * plane->x + 
          line->v[0]->hy * plane->y + 
          line->v[0]->hz * plane->z + 
          line->v[0]->hw * plane->w;
    in2 = line->v[1]->hx * plane->x + 
          line->v[1]->hy * plane->y + 
          line->v[1]->hz * plane->z + 
          line->v[1]->hw * plane->w;
    if (in1 < 0) 
    {
        if (in2 < 0) 
            return 1;
        Interpolate(pv, &outv, line->v[0], line->v[1], 
                    dwClipBit, in1, in1 - in2);
        *line->v[0] = outv;
    } 
    else 
    {
        if (in2 < 0) 
        {
            Interpolate(pv,  &outv, line->v[0], line->v[1],
                        dwClipBit, in1, in1 - in2);
            *line->v[1] = outv;
        }
    }
    return 0;
}
/*------------------------------------------------------------------------
 * Calculate the screen coords for any new vertices
 * introduced into the polygon.
 */
void ComputeScreenCoordinates(D3DFE_PROCESSVERTICES *pv,
                              ClipVertex **inv,
                              int count)
{
    int i;
    D3DFE_VIEWPORTCACHE& VPORT = pv->vcache;

    for (i = 0; i < count; i++)
    {
        ClipVertex *p;
        p = inv[i];

        /*
         * Catch any vertices that need screen co-ordinates generated.
         * There are two possibilities
         *      1) Vertices generated during interpolation
         *      2) Vertices marked for clipping by the transform but
         *              not clipped here due to the finite precision
         *              of the floating point unit.
         */

        if (p->clip & ~CLIPPED_ENABLE)
        {
            D3DVALUE w;

            w = D3DVAL(1.0)/p->hw;
            switch ((int)p->clip & (CLIPPED_LEFT|CLIPPED_RIGHT))
            {
            case CLIPPED_LEFT:  p->sx = VPORT.minXgb; break;
            case CLIPPED_RIGHT: p->sx = VPORT.maxXgb; break;
            default:
                p->sx = p->hx * VPORT.scaleX * w + VPORT.offsetX;
                if (p->sx < VPORT.minXgb)
                        p->sx = VPORT.minXgb;
                if (p->sx > VPORT.maxXgb)
                        p->sx = VPORT.maxXgb;
            }
            switch ((int)p->clip & (CLIPPED_TOP|CLIPPED_BOTTOM))
            {
            case CLIPPED_BOTTOM: p->sy = VPORT.maxYgb; break;
            case CLIPPED_TOP:    p->sy = VPORT.minYgb; break;
            default:
                p->sy = p->hy * VPORT.scaleY * w + VPORT.offsetY;
                if (p->sy < VPORT.minYgb)
                        p->sy = VPORT.minYgb;
                if (p->sy > VPORT.maxYgb)
                        p->sy = VPORT.maxYgb;
            }
            p->sz = p->hz * w * pv->vcache.scaleZ + pv->vcache.offsetZ;
            p->rhw = w;
        }
    }
}
//---------------------------------------------------------------------
inline DWORD ComputeClipCodeUserPlanes(D3DFE_PROCESSVERTICES *pv, ClipVertex *p)
{
    DWORD clip = 0;
    DWORD dwClipBit = D3DCS_PLANE0;
    for (DWORD i=0; i < pv->dwMaxUserClipPlanes; i++)
    {
        if ((p->hx*pv->userClipPlane[i].x + 
             p->hy*pv->userClipPlane[i].y + 
             p->hz*pv->userClipPlane[i].z + 
             p->hw*pv->userClipPlane[i].w) < 0)
        {
            clip |= dwClipBit;
        }
        dwClipBit <<= 1;
    }
    return clip;
}
//---------------------------------------------------------------------
inline DWORD ComputeClipCodeGB(D3DFE_PROCESSVERTICES *pv, ClipVertex *p)
{
    DWORD clip = 0;
    if (p->hx < p->hw * pv->vcache.Kgbx1)
        clip |= __D3DCLIPGB_LEFT;
    if (p->hx > p->hw * pv->vcache.Kgbx2)
        clip |= __D3DCLIPGB_RIGHT;
    if (p->hy < p->hw * pv->vcache.Kgby1)
        clip |= __D3DCLIPGB_BOTTOM;
    if (p->hy > p->hw * pv->vcache.Kgby2)
        clip |= __D3DCLIPGB_TOP;
    if (p->hz > p->hw)
        clip |= D3DCS_BACK;
    clip |= ComputeClipCodeUserPlanes(pv, p);
    p->clip = (p->clip & (CLIPPED_ENABLE | CLIPPED_FRONT)) | clip;
    return clip;
}
//---------------------------------------------------------------------
inline DWORD ComputeClipCode(D3DFE_PROCESSVERTICES *pv, ClipVertex *p)
{
    DWORD clip = 0;
    if (FLOAT_LTZ(p->hx))
        clip |= D3DCS_LEFT;
    if (p->hx > p->hw)
        clip |= D3DCS_RIGHT;
    if (FLOAT_LTZ(p->hy))
        clip |= D3DCS_BOTTOM;
    if (p->hy > p->hw)
        clip |= D3DCS_TOP;
    if (p->hz > p->hw)
        clip |= D3DCS_BACK;
    clip |= ComputeClipCodeUserPlanes(pv, p);
    p->clip = (p->clip & (CLIPPED_ENABLE | CLIPPED_FRONT)) | clip;
    return clip;
}
//***********************************************************************
//
//  Returns 0, if triangle is clipped. Number of vertices otherwise.
//
//  Original vertices should not be modified inside the function
//
#undef DPF_MODNAME
#define DPF_MODNAME "ClipSingleTriangle"

int D3DFE_PVFUNCSI::ClipSingleTriangle(D3DFE_PROCESSVERTICES *pv,
                                      ClipTriangle *tri,
                                      ClipVertex ***clipVertexPointer)
{
    int accept;
    int i;
    int count;
    ClipVertex **inv;
    ClipVertex **outv;
    ClipVertex *p;
    ULONG_PTR swapv;

    CD3DFPstate D3DFPstate;  // Sets optimal FPU state for D3D.

    accept = (tri->v[0]->clip | tri->v[1]->clip | tri->v[2]->clip);

    inv = tri->v;

    count = 3;
    outv = pv->ClipperState.clip_vbuf1;
    pv->ClipperState.clip_color = tri->v[0]->color;
    pv->ClipperState.clip_specular = tri->v[0]->specular;

    /*
     * XXX assumes sizeof(void*) == sizeof(unsigned long)
     */
    {
        ULONG_PTR tmp1;
        ULONG_PTR tmp2;

        tmp1 = (ULONG_PTR)pv->ClipperState.clip_vbuf1;
        tmp2 = (ULONG_PTR)pv->ClipperState.clip_vbuf2;

        swapv = tmp1 + tmp2;
    }
    pv->ClipperState.clip_vertices_used = 0;

#define SWAP(inv, outv)     \
    inv = outv;             \
    outv = (ClipVertex**) (swapv - (ULONG_PTR) outv)

    if (accept & D3DCS_FRONT)
    {
        count = ClipFront(pv, inv, outv, count);
        if (count < 3)
            goto out_of_here;
        SWAP(inv, outv);
    }
    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if (accept & D3DCS_FRONT)
        {
            accept = 0;
            for (i = 0; i < count; i++)
            {
                ClipVertex *p;
                p = inv[i];
                if (p->clip & CLIPPED_FRONT)
                    accept |= ComputeClipCodeGB(pv, p);
                else
                    accept |= p->clip;
            }
        }
        if (accept & D3DCS_BACK)
        {
            count = ClipBack(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & __D3DCLIPGB_LEFT)
        {
            count = ClipLeftGB(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & __D3DCLIPGB_RIGHT)
        {
            count = ClipRightGB(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & __D3DCLIPGB_BOTTOM)
        {
            count = ClipBottomGB(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & __D3DCLIPGB_TOP)
        {
            count = ClipTopGB(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
    }
    else
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if (accept & D3DCS_FRONT)
        {
            accept = 0;
            for (i = 0; i < count; i++)
            {
                ClipVertex *p;
                p = inv[i];
                if (p->clip & (CLIPPED_FRONT))
                    accept |= ComputeClipCode(pv, p);
                else
                    accept |= p->clip;
            }
        }
        if (accept & D3DCS_BACK)
        {
            count = ClipBack(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & D3DCS_LEFT)
        {
            count = ClipLeft(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & D3DCS_RIGHT)
        {
            count = ClipRight(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & D3DCS_BOTTOM)
        {
            count = ClipBottom(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & D3DCS_TOP)
        {
            count = ClipTop(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
    }
    if (pv->dwMaxUserClipPlanes)
    {
        DWORD dwClipBit = D3DCS_PLANE0;
        DWORD dwClippedBit = CLIPPED_PLANE0;
        for (DWORD i=0; i < pv->dwMaxUserClipPlanes; i++)
        {
            if (accept & dwClipBit)
            {
                count = ClipByPlane(pv, inv, outv, &pv->userClipPlane[i], 
                                    dwClippedBit, count);
                if (count < 3)
                    goto out_of_here;
                SWAP(inv, outv);
            }
            dwClipBit <<= 1;
            dwClippedBit <<= 1;
        }
    }

#undef SWAP

    ComputeScreenCoordinates(pv, inv, count);

    *clipVertexPointer = inv;
    pv->ClipperState.current_vbuf = inv;
    return count;

out_of_here:

    *clipVertexPointer = NULL;
    return 0;
}
//*************************************************************************
//
#undef DPF_MODNAME
#define DPF_MODNAME "ClipSingleLine"

int D3DFE_PVFUNCSI::ClipSingleLine(D3DFE_PROCESSVERTICES *pv,
                                   ClipTriangle *line)
{
    int         accept;
    D3DVALUE    in1, in2;

    CD3DFPstate D3DFPstate;  // Sets optimal FPU state for D3D.

    accept = (line->v[0]->clip | line->v[1]->clip);

    pv->ClipperState.clip_color = line->v[0]->color;
    pv->ClipperState.clip_specular = line->v[0]->specular;

    if (accept & D3DCS_FRONT)
        if (ClipLineFront(pv, line))
            goto out_of_here;
    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if (accept & D3DCS_FRONT)
        {
            ClipVertex * p;
            accept = 0;
            p = line->v[0];
            if (p->clip & CLIPPED_FRONT)
                accept |= ComputeClipCodeGB(pv, p);
            else
                accept |= p->clip;
            p = line->v[1];
            if (p->clip & CLIPPED_FRONT)
                accept |= ComputeClipCodeGB(pv, p);
            else
                accept |= p->clip;
        }
        if (accept & D3DCS_BACK)
            if (ClipLineBack(pv, line))
                goto out_of_here;
        if (accept & __D3DCLIPGB_LEFT)
            if (ClipLineLeftGB(pv, line))
                goto out_of_here;
        if (accept & __D3DCLIPGB_RIGHT)
            if (ClipLineRightGB(pv, line))
                goto out_of_here;
        if (accept & __D3DCLIPGB_TOP)
            if (ClipLineTopGB(pv, line))
                goto out_of_here;
        if (accept & __D3DCLIPGB_BOTTOM)
            if (ClipLineBottomGB(pv, line))
                goto out_of_here;
    }
    else
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if (accept & D3DCS_FRONT)
        {
            ClipVertex * p;
            accept = 0;
            p = line->v[0];
            if (p->clip & CLIPPED_FRONT)
                accept |= ComputeClipCode(pv, p);
            else
                accept |= p->clip;
            p = line->v[1];
            if (p->clip & CLIPPED_FRONT)
                accept |= ComputeClipCode(pv, p);
            else
                accept |= p->clip;
        }
        if (accept & D3DCS_BACK)
            if (ClipLineBack(pv, line))
                goto out_of_here;
        if (accept & D3DCS_LEFT)
            if (ClipLineLeft(pv, line))
                goto out_of_here;
        if (accept & D3DCS_RIGHT)
            if (ClipLineRight(pv, line))
                goto out_of_here;
        if (accept & D3DCS_TOP)
            if (ClipLineTop(pv, line))
                goto out_of_here;
        if (accept & D3DCS_BOTTOM)
            if (ClipLineBottom(pv, line))
                goto out_of_here;
    }
    if (pv->dwMaxUserClipPlanes)
    {
        DWORD dwClipBit = D3DCS_PLANE0;
        DWORD dwClippedBit = CLIPPED_PLANE0;
        for (DWORD i=0; i < pv->dwMaxUserClipPlanes; i++)
        {
            if (accept & dwClipBit)
            {
                if (ClipLineByPlane(pv, line, &pv->userClipPlane[i], 
                                    dwClippedBit))
                    goto out_of_here;
            }
            dwClipBit <<= 1;
            dwClippedBit <<= 1;
        }
    }

    ComputeScreenCoordinates(pv, line->v, 2);

    return 1;
out_of_here:
    return 0;
} // ClipSingleLine
//----------------------------------------------------------------------
//    GenClipFlags()  Generates clip flags for a set of FVF
//
#undef DPF_MODNAME
#define DPF_MODNAME "GenClipFlags"

DWORD D3DFE_GenClipFlags(D3DFE_PROCESSVERTICES *pv)
{
    DWORD clip_intersection, clip_union;
    float left   = pv->vcache.minX;
    float top    = pv->vcache.minY;
    float right  = pv->vcache.maxX;
    float bottom = pv->vcache.maxY;
    float leftgb  ;         // Guard band window
    float topgb   ;
    float rightgb ;
    float bottomgb;
    DWORD clipZF, clipZB;
    DWORD stride = pv->position.dwStride;

    clipZF = pv->lpdwRStates[D3DRENDERSTATE_ZENABLE] ? D3DCS_FRONT : 0;
    clipZB = pv->lpdwRStates[D3DRENDERSTATE_ZENABLE] ? D3DCS_BACK : 0;

    clip_intersection = (DWORD)~0;
    clip_union = (DWORD)0;

    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)
    {
        leftgb   = pv->vcache.minXgb;
        topgb    = pv->vcache.minYgb;
        rightgb  = pv->vcache.maxXgb;
        bottomgb = pv->vcache.maxYgb;
    }
     /* Only generate clip flags */
    D3DTLVERTEX *lpVertices = (D3DTLVERTEX*)pv->position.lpvData;
    D3DFE_CLIPCODE *clipCode = pv->lpClipFlags;
    DWORD i;

    // Point sprites are clipped only by Z planes. Clipping by X and Y planes
    // will be done when we expand point sprites
    if (pv->primType == D3DPT_POINTLIST && 
        pv->dwDeviceFlags & D3DDEV_DOPOINTSPRITEEMULATION)
    {
        for (i = pv->dwNumVertices; i; i--)
        {
            DWORD clip = 0;
            D3DVALUE x,y,z;
            if (lpVertices->rhw < 0)
            {
                x = -lpVertices->sx;
                y = -lpVertices->sy;
                z = -lpVertices->sz;
            }
            else
            {
                x = lpVertices->sx;
                y = lpVertices->sy;
                z = lpVertices->sz;
            }

            if (z < 0.0f)
                clip |= clipZF;
            else
            if (z >= 1.0f)
                clip |= clipZB;

            clip_intersection &= clip;
            clip_union |= clip;
            *clipCode++ = (D3DFE_CLIPCODE)clip;
            lpVertices = (D3DTLVERTEX*)((char*)lpVertices + stride);
        }
    }
    else
    for (i = pv->dwNumVertices; i; i--)
    {
        DWORD clip = 0;
        D3DVALUE x,y,z;
        if (lpVertices->rhw < 0)
        {
            x = -lpVertices->sx;
            y = -lpVertices->sy;
            z = -lpVertices->sz;
        }
        else
        {
            x = lpVertices->sx;
            y = lpVertices->sy;
            z = lpVertices->sz;
        }

        if (x < left)
            clip |= D3DCS_LEFT;
        else
        if (x >= right)
            clip |= D3DCS_RIGHT;

        if (y < top)
            clip |= D3DCS_TOP;
        else
        if (y >= bottom)
            clip |= D3DCS_BOTTOM;

        if (z < 0.0f)
            clip |= clipZF;
        else
        if (z >= 1.0f)
            clip |= clipZB;

        if (pv->dwDeviceFlags & D3DDEV_GUARDBAND && clip)
        {
            if (x < leftgb)
                clip |= __D3DCLIPGB_LEFT;
            else
            if (x >= rightgb)
                clip |= __D3DCLIPGB_RIGHT;

            if (y < topgb)
                clip |= __D3DCLIPGB_TOP;
            else
            if (y >= bottomgb)
                clip |= __D3DCLIPGB_BOTTOM;
        }

        clip_intersection &= clip;
        clip_union |= clip;
        *clipCode++ = (D3DFE_CLIPCODE)clip;
        lpVertices = (D3DTLVERTEX*)((char*)lpVertices + stride);
    }
    pv->dwClipIntersection = clip_intersection;
    pv->dwClipUnion = clip_union;

    return clip_intersection;
}   // end of GenClipFlags()
//---------------------------------------------------------------------
// Make clip vertex from D3D vertex
//
// device - CD3DHal *
// pp1    - clipVertex
// p1     - TL vertex
//
void MAKE_CLIP_VERTEX_FVF(D3DFE_PROCESSVERTICES *pv, ClipVertex& pp1, BYTE* p1,                   
                          DWORD clipFlag, BOOL transformed)
{                                                               
    D3DFE_VIEWPORTCACHE& VPORT = pv->vcache;
    BYTE *v = (BYTE*)p1;                                               
    if (transformed || !(clipFlag & pv->dwClipMaskOffScreen))         
    {                                                           
        pp1.sx  = ((D3DVALUE*)v)[0];                            
        pp1.sy  = ((D3DVALUE*)v)[1];                            
        pp1.sz  = ((D3DVALUE*)v)[2];                            
        pp1.rhw = ((D3DVALUE*)v)[3];
        pp1.hw  = 1.0f / ((D3DVALUE*)v)[3];                     
        pp1.hx  = (pp1.sx - VPORT.offsetX) * pp1.hw * VPORT.scaleXi;                                
        pp1.hy  = (pp1.sy - VPORT.offsetY) * pp1.hw * VPORT.scaleYi;                                
        pp1.hz  = (pp1.sz - VPORT.offsetZ) * pp1.hw * VPORT.scaleZi;
    }                                                           
    else                                                        
    {                                                           
        pp1.hx = ((D3DVALUE*)v)[0];                             
        pp1.hy = ((D3DVALUE*)v)[1];                             
        pp1.hz = ((D3DVALUE*)v)[2];                             
        pp1.hw = ((D3DVALUE*)v)[3];                      