 - 0x3FFF) is
 * further broken down into ranges to make assigning new property IDs easier.
 *
 *  From    To      Kind of property
 *  --------------------------------
 *  3000    32FF    MAPI_defined common property
 *  3200    33FF    MAPI_defined form property
 *  3400    35FF    MAPI_defined message store property
 *  3600    36FF    MAPI_defined Folder or AB Container property
 *  3700    38FF    MAPI_defined attachment property
 *  3900    39FF    MAPI_defined address book property
 *  3A00    3BFF    MAPI_defined mailuser property
 *  3C00    3CFF    MAPI_defined DistList property
 *  3D00    3DFF    MAPI_defined Profile Section property
 *  3E00    3EFF    MAPI_defined Status property
 *  3F00    3FFF    MAPI_defined display table property
 */

/*
 *  Properties common to numerous MAPI objects.
 *
 *  Those properties that can appear on messages are in the
 *  non-transmittable range for messages. They start at the high
 *  end of that range and work down.
 *
 *  Properties that never appear on messages are defined in the common
 *  property range (see above).
 */

/*
 * properties that are common to multiple objects (including message objects)
 * -- these ids are in the non-transmittable range
 */

#define PR_ENTRYID                                  PROP_TAG( PT_BINARY,    0x0FFF)
#define PR_OBJECT_TYPE                              PROP_TAG( PT_LONG,      0x0FFE)
#define PR_ICON                                     PROP_TAG( PT_BINARY,    0x0FFD)
#define PR_MINI_ICON                                PROP_TAG( PT_BINARY,    0x0FFC)
#define PR_STORE_ENTRYID                            PROP_TAG( PT_BINARY,    0x0FFB)
#define PR_STORE_RECORD_KEY                         PROP_TAG( PT_BINARY,    0x0FFA)
#define PR_RECORD_KEY                               PROP_TAG( PT_BINARY,    0x0FF9)
#define PR_MAPPING_SIGNATURE                        PROP_TAG( PT_BINARY,    0x0FF8)
#define PR_ACCESS_LEVEL                             PROP_TAG( PT_LONG,      0x0FF7)
#define PR_INSTANCE_KEY                             PROP_TAG( PT_BINARY,    0x0FF6)
#define PR_ROW_TYPE                                 PROP_TAG( PT_LONG,      0x0FF5)
#define PR_ACCESS                                   PROP_TAG( PT_LONG,      0x0FF4)

/*
 * properties that are common to multiple objects (usually not including message objects)
 * -- these ids are in the transmittable range
 */

#define PR_ROWID                                    PROP_TAG( PT_LONG,      0x3000)
#define PR_DISPLAY_NAME                             PROP_TAG( PT_TSTRING,   0x3001)
#define PR_DISPLAY_NAME_W                           PROP_TAG( PT_UNICODE,   0x3001)
#define PR_DISPLAY_NAME_A                           PROP_TAG( PT_STRING8,   0x3001)
#define PR_ADDRTYPE                                 PROP_TAG( PT_TSTRING,   0x3002)
#define PR_ADDRTYPE_W                               PROP_TAG( PT_UNICODE,   0x3002)
#define PR_ADDRTYPE_A                               PROP_TAG( PT_STRING8,   0x3002)
#define PR_EMAIL_ADDRESS                            PROP_TAG( PT_TSTRING,   0x3003)
#define PR_EMAIL_ADDRESS_W                          PROP_TAG( PT_UNICODE,   0x3003)
#define PR_EMAIL_ADDRESS_A                          PROP_TAG( PT_STRING8,   0x3003)
#define PR_COMMENT                                  PROP_TAG( PT_TSTRING,   0x3004)
#define PR_COMMENT_W                                PROP_TAG( PT_UNICODE,   0x3004)
#define PR_COMMENT_A                                PROP_TAG( PT_STRING8,   0x3004)
#define PR_DEPTH                                    PROP_TAG( PT_LONG,      0x3005)
#define PR_PROVIDER_DISPLAY                         PROP_TAG( PT_TSTRING,   0x3006)
#define PR_PROVIDER_DISPLAY_W                       PROP_TAG( PT_UNICODE,   0x3006)
#define PR_PROVIDER_DISPLAY_A                       PROP_TAG( PT_STRING8,   0x3006)
#define PR_CREATION_TIME                            PROP_TAG( PT_SYSTIME,   0x3007)
#define PR_LAST_MODIFICATION_TIME                   PROP_TAG( PT_SYSTIME,   0x3008)
#define PR_RESOURCE_FLAGS                           PROP_TAG( PT_LONG,      0x3009)
#define PR_PROVIDER_DLL_NAME                        PROP_TAG( PT_TSTRING,   0x300A)
#define PR_PROVIDER_DLL_NAME_W                      PROP_TAG( PT_UNICODE,   0x300A)
#define PR_PROVIDER_DLL_NAME_A                      PROP_TAG( PT_STRING8,   0x300A)
#define PR_SEARCH_KEY                               PROP_TAG( PT_BINARY,    0x300B)
#define PR_PROVIDER_UID                             PROP_TAG( PT_BINARY,    0x300C)
#define PR_PROVIDER_ORDINAL                         PROP_TAG( PT_LONG,      0x300D)

/*
 *  MAPI Form properties
 */
#define PR_FORM_VERSION                             PROP_TAG(PT_TSTRING,    0x3301)
#define PR_FORM_VERSION_W                           PROP_TAG(PT_UNICODE,    0x3301)
#define PR_FORM_VERSION_A                           PROP_TAG(PT_STRING8,    0x3301)
#define PR_FORM_CLSID                               PROP_TAG(PT_CLSID,      0x3302)
#define PR_FORM_CONTACT_NAME                        PROP_TAG(PT_TSTRING,    0x3303)
#define PR_FORM_CONTACT_NAME_W                      PROP_TAG(PT_UNICODE,    0x3303)
#define PR_FORM_CONTACT_NAME_A                      PROP_TAG(PT_STRING8,    0x3303)
#define PR_FORM_CATEGORY                            PROP_TAG(PT_TSTRING,    0x3304)
#define PR_FORM_CATEGORY_W                          PROP_TAG(PT_UNICODE,    0x3304)
#define PR_FORM_CATEGORY_A                          PROP_TAG(PT_STRING8,    0x3304)
#define PR_FORM_CATEGORY_SUB                        PROP_TAG(PT_TSTRING,    0x3305)
#define PR_FORM_CATEGORY_SUB_W                      PROP_TAG(PT_UNICODE,    0x3305)
#define PR_FORM_CATEGORY_SUB_A                      PROP_TAG(PT_STRING8,    0x3305)
#define PR_FORM_HOST_MAP                            PROP_TAG(PT_MV_LONG,    0x3306)
#define PR_FORM_HIDDEN                              PROP_TAG(PT_BOOLEAN,    0x3307)
#define PR_FORM_DESIGNER_NAME                       PROP_TAG(PT_TSTRING,    0x3308)
#define PR_FORM_DESIGNER_NAME_W                     PROP_TAG(PT_UNICODE,    0x3308)
#define PR_FORM_DESIGNER_NAME_A                     PROP_TAG(PT_STRING8,    0x3308)
#define PR_FORM_DESIGNER_GUID                       PROP_TAG(PT_CLSID,      0x3309)
#define PR_FORM_MESSAGE_BEHAVIOR                    PROP_TAG(PT_LONG,       0x330A)

/*
 *  Message store properties
 */

#define PR_DEFAULT_STORE                            PROP_TAG( PT_BOOLEAN,   0x3400)
#define PR_STORE_SUPPORT_MASK                       PROP_TAG( PT_LONG,      0x340D)

#define PR_IPM_SUBTREE_SEARCH_KEY                   PROP_TAG( PT_BINARY,    0x3410)
#define PR_IPM_OUTBOX_SEARCH_KEY                    PROP_TAG( PT_BINARY,    0x3411)
#define PR_IPM_WASTEBASKET_SEARCH_KEY               PROP_TAG( PT_BINARY,    0x3412)
#define PR_IPM_SENTMAIL_SEARCH_KEY                  PROP_TAG( PT_BINARY,    0x3413)
#define PR_MDB_PROVIDER                             PROP_TAG( PT_BINARY,    0x3414)
#define PR_RECEIVE_FOLDER_SETTINGS                  PROP_TAG( PT_OBJECT,    0x3415)

#define PR_VALID_FOLDER_MASK                        PROP_TAG( PT_LONG,      0x35DF)
#define PR_IPM_SUBTREE_ENTRYID                      PROP_TAG( PT_BINARY,    0x35E0)

#define PR_IPM_OUTBOX_ENTRYID                       PROP_TAG( PT_BINARY,    0x35E2)
#define PR_IPM_WASTEBASKET_ENTRYID                  PROP_TAG( PT_BINARY,    0x35E3)
#define PR_IPM_SENTMAIL_ENTRYID                     PROP_TAG( PT_BINARY,    0x35E4)
#define PR_VIEWS_ENTRYID                            PROP_TAG( PT_BINARY,    0x35E5)
#define PR_COMMON_VIEWS_ENTRYID                     PROP_TAG( PT_BINARY,    0x35E6)
#define PR_FINDER_ENTRYID                           PROP_TAG( PT_BINARY,    0x35E7)

/* Proptags 35E8-35FF reserved for folders "guaranteed" by PR_VALID_FOLDER_MASK */


/*
 *  Folder and AB Container properties
 */

#define PR_CONTAINER_FLAGS                          PROP_TAG( PT_LONG,      0x3600)
#define PR_FOLDER_TYPE                              PROP_TAG( PT_LONG,      0x3601)
#define PR_CONTENT_COUNT                            PROP_TAG( PT_LONG,      0x3602)
#define PR_CONTENT_UNREAD                           PROP_TAG( PT_LONG,      0x3603)
#define PR_CREATE_TEMPLATES                         PROP_TAG( PT_OBJECT,    0x3604)
#define PR_DETAILS_TABLE                            PROP_TAG( PT_OBJECT,    0x3605)
#define PR_SEARCH                                   PROP_TAG( PT_OBJECT,    0x3607)
#define PR_SELECTABLE                               PROP_TAG( PT_BOOLEAN,   0x3609)
#define PR_SUBFOLDERS                               PROP_TAG( PT_BOOLEAN,   0x360a)
#define PR_STATUS                                   PROP_TAG( PT_LONG,      0x360b)
#define PR_ANR                                      PROP_TAG( PT_TSTRING,   0x360c)
#define PR_ANR_W                                    PROP_TAG( PT_UNICODE,   0x360c)
#define PR_ANR_A                                    PROP_TAG( PT_STRING8,   0x360c)
#define PR_CONTENTS_SORT_ORDER                      PROP_TAG( PT_MV_LONG,   0x360d)
#define PR_CONTAINER_HIERARCHY                      PROP_TAG( PT_OBJECT,    0x360e)
#define PR_CONTAINER_CONTENTS                       PROP_TAG( PT_OBJECT,    0x360f)
#define PR_FOLDER_ASSOCIATED_CONTENTS               PROP_TAG( PT_OBJECT,    0x3610)
#define PR_DEF_CREATE_DL                            PROP_TAG( PT_BINARY,    0x3611)
#define PR_DEF_CREATE_MAILUSER                      PROP_TAG( PT_BINARY,    0x3612)
#define PR_CONTAINER_CLASS                          PROP_TAG( PT_TSTRING,   0x3613)
#define PR_CONTAINER_CLASS_W                        PROP_TAG( PT_UNICODE,   0x3613)
#define PR_CONTAINER_CLASS_A                        PROP_TAG( PT_STRING8,   0x3613)
#define PR_CONTAINER_MODIFY_VERSION                 PROP_TAG( PT_I8,        0x3614)
#define PR_AB_PROVIDER_ID                           PROP_TAG( PT_BINARY,    0x3615)
/* Don't use 36FE and 36FF */

/*
 *  Attachment properties
 */

#define PR_ATTACHMENT_X400_PARAMETERS               PROP_TAG( PT_BINARY,    0x3700)
#define PR_ATTACH_DATA_OBJ                          PROP_TAG( PT_OBJECT,    0x3701)
#define PR_ATTACH_DATA_BIN                          PROP_TAG( PT_BINARY,    0x3701)
#define PR_ATTACH_ENCODING                          PROP_TAG( PT_BINARY,    0x3702)
#define PR_ATTACH_EXTENSION                         PROP_TAG( PT_TSTRING,   0x3703)
#define PR_ATTACH_EXTENSION_W                       PROP_TAG( PT_UNICODE,   0x3703)
#define PR_ATTACH_EXTENSION_A                       PROP_TAG( PT_STRING8,   0x3703)
#define PR_ATTACH_FILENAME                          PROP_TAG( PT_TSTRING,   0x3704)
#define PR_ATTACH_FILENAME_W                        PROP_TAG( PT_UNICODE,   0x3704)
#define PR_ATTACH_FILENAME_A                        PROP_TAG( PT_STRING8,   0x3704)
#define PR_ATTACH_METHOD                            PROP_TAG( PT_LONG,      0x3705)
#define PR_ATTACH_LONG_FILENAME                     PROP_TAG( PT_TSTRING,   0x3707)
#define PR_ATTACH_LONG_FILENAME_W                   PROP_TAG( PT_UNICODE,   0x3707)
#define PR_ATTACH_LONG_FILENAME_A                   PROP_TAG( PT_STRING8,   0x3707)
#define PR_ATTACH_PATHNAME                          PROP_TAG( PT_TSTRING,   0x3708)
#define PR_ATTACH_PATHNAME_W                        PROP_TAG( PT_UNICODE,   0x3708)
#define PR_ATTACH_PATHNAME_A                        PROP_TAG( PT_STRING8,   0x3708)
#define PR_ATTACH_RENDERING                         PROP_TAG( PT_BINARY,    0x3709)
#define PR_ATTACH_TAG                               PROP_TAG( PT_BINARY,    0x370A)
#define PR_RENDERING_POSITION                       PROP_TAG( PT_LONG,      0x370B)
#define PR_ATTACH_TRANSPORT_NAME                    PROP_TAG( PT_TSTRING,   0x370C)
#define PR_ATTACH_TRANSPORT_NAME_W                  PROP_TAG( PT_UNICODE,   0x370C)
#define PR_ATTACH_TRANSPORT_NAME_A                  PROP_TAG( PT_STRING8,   0x370C)

/*
 *  AB Object properties
 */

#define PR_DISPLAY_TYPE                             PROP_TAG( PT_LONG,      0x3900)
#define PR_TEMPLATEID                               PROP_TAG( PT_BINARY,    0x3902)
#define PR_CAPABILITIES_TABLE                       PROP_TAG( PT_OBJECT,    0x3903)
#define PR_PRIMARY_CAPABILITY                       PROP_TAG( PT_BINARY,    0x3904)

/*
 *  Mail user properties
 */

#define PR_ACCOUNT                                  PROP_TAG( PT_TSTRING,   0x3A00)
#define PR_ACCOUNT_W                                PROP_TAG( PT_UNICODE,   0x3A00)
#define PR_ACCOUNT_A                                PROP_TAG( PT_STRING8,   0x3A00)
#define PR_ALTERNATE_RECIPIENT                      PROP_TAG( PT_BINARY,    0x3A01)
#define PR_CALLBACK_TELEPHONE_NUMBER                PROP_TAG( PT_TSTRING,   0x3A02)
#define PR_CALLBACK_TELEPHONE_NUMBER_W              PROP_TAG( PT_UNICODE,   0x3A02)
#define PR_CALLBACK_TELEPHONE_NUMBER_A              PROP_TAG( PT_STRING8,   0x3A02)
#define PR_CONVERSION_PROHIBITED                    PROP_TAG( PT_BOOLEAN,   0x3A03)
#define PR_DISCLOSE_RECIPIENTS                      PROP_TAG( PT_BOOLEAN,   0x3A04)
#define PR_GENERATION                               PROP_TAG( PT_TSTRING,   0x3A05)
#define PR_GENERATION_W                             PROP_TAG( PT_UNICODE,   0x3A05)
#define PR_GENERATION_A                             PROP_TAG( PT_STRING8,   0x3A05)
#define PR_GIVEN_NAME                               PROP_TAG( PT_TSTRING,   0x3A06)
#define PR_GIVEN_NAME_W                             PROP_TAG( PT_UNICODE,   0x3A06)
#define PR_GIVEN_NAME_A                             PROP_TAG( PT_STRING8,   0x3A06)
#define PR_GOVERNMENT_ID_NUMBER                     PROP_TAG( PT_TSTRING,   0x3A07)
#define PR_GOVERNMENT_ID_NUMBER_W                   PROP_TAG( PT_UNICODE,   0x3A07)
#define PR_GOVERNMENT_ID_NUMBER_A                   PROP_TAG( PT_STRING8,   0x3A07)
#define PR_BUSINESS_TELEPHONE_NUMBER                PROP_TAG( PT_TSTRING,   0x3A08)
#define PR_BUSINESS_TELEPHONE_NUMBER_W              PROP_TAG( PT_UNICODE,   0x3A08)
#define PR_BUSINESS_TELEPHONE_NUMBER_A              PROP_TAG( PT_STRING8,   0x3A08)
#define PR_OFFICE_TELEPHONE_NUMBER                  PR_BUSINESS_TELEPHONE_NUMBER
#define PR_OFFICE_TELEPHONE_NUMBER_W                PR_BUSINESS_TELEPHONE_NUMBER_W
#define PR_OFFICE_TELEPHONE_NUMBER_A                PR_BUSINESS_TELEPHONE_NUMBER_A
#define PR_HOME_TELEPHONE_NUMBER                    PROP_TAG( PT_TSTRING,   0x3A09)
#define PR_HOME_TELEPHONE_NUMBER_W                  PROP_TAG( PT_UNICODE,   0x3A09)
#define PR_HOME_TELEPHONE_NUMBER_A                  PROP_TAG( PT_STRING8,   0x3A09)
#define PR_INITIALS                                 PROP_TAG( PT_TSTRING,   0x3A0A)
#define PR_INITIALS_W                               PROP_TAG( PT_UNICODE,   0x3A0A)
#define PR_INITIALS_A                               PROP_TAG( PT_STRING8,   0x3A0A)
#define PR_KEYWORD                                  PROP_TAG( PT_TSTRING,   0x3A0B)
#define PR_KEYWORD_W                                PROP_TAG( PT_UNICODE,   0x3A0B)
#define PR_KEYWORD_A                                PROP_TAG( PT_STRING8,   0x3A0B)
#define PR_LANGUAGE                                 PROP_TAG( PT_TSTRING,   0x3A0C)
#define PR_LANGUAGE_W                               PROP_TAG( PT_UNICODE,   0x3A0C)
#define PR_LANGUAGE_A                               PROP_TAG( PT_STRING8,   0x3A0C)
#define PR_LOCATION                                 PROP_TAG( PT_TSTRING,   0x3A0D)
#define PR_LOCATION_W                               PROP_TAG( PT_UNICODE,   0x3A0D)
#define PR_LOCATION_A                               PROP_TAG( PT_STRING8,   0x3A0D)
#define PR_MAIL_PERMISSION                          PROP_TAG( PT_BOOLEAN,   0x3A0E)
#define PR_MHS_COMMON_NAME                          PROP_TAG( PT_TSTRING,   0x3A0F)
#define PR_MHS_COMMON_NAME_W                        PROP_TAG( PT_UNICODE,   0x3A0F)
#define PR_MHS_COMMON_NAME_A                        PROP_TAG( PT_STRING8,   0x3A0F)
#define PR_ORGANIZATIONAL_ID_NUMBER                 PROP_TAG( PT_TSTRING,   0x3A10)
#define PR_ORGANIZATIONAL_ID_NUMBER_W               PROP_TAG( PT_UNICODE,   0x3A10)
#define PR_ORGANIZATIONAL_ID_NUMBER_A               PROP_TAG( PT_STRING8,   0x3A10)
#define PR_SURNAME                                  PROP_TAG( PT_TSTRING,   0x3A11)
#define PR_SURNAME_W                                PROP_TAG( PT_UNICODE,   0x3A11)
#define PR_SURNAME_A                                PROP_TAG( PT_STRING8,   0x3A11)
#define PR_ORIGINAL_ENTRYID                         PROP_TAG( PT_BINARY,    0x3A12)
#define PR_ORIGINAL_DISPLAY_NAME                    PROP_TAG( PT_TSTRING,   0x3A13)
#define PR_ORIGINAL_DISPLAY_NAME_W                  PROP_TAG( PT_UNICODE,   0x3A13)
#define PR_ORIGINAL_DISPLAY_NAME_A                  PROP_TAG( PT_STRING8,   0x3A13)
#define PR_ORIGINAL_SEARCH_KEY                      PROP_TAG( PT_BINARY,    0x3A14)
#define PR_POSTAL_ADDRESS                           PROP_TAG( PT_TSTRING,   0x3A15)
#define PR_POSTAL_ADDRESS_W                         PROP_TAG( PT_UNICODE,   0x3A15)
#define PR_POSTAL_ADDRESS_A                         PROP_TAG( PT_STRING8,   0x3A15)
#define PR_COMPANY_NAME                             PROP_TAG( PT_TSTRING,   0x3A16)
#define PR_COMPANY_NAME_W                           PROP_TAG( PT_UNICODE,   0x3A16)
#define PR_COMPANY_NAME_A                           PROP_TAG( PT_STRING8,   0x3A16)
#define PR_TITLE                                    PROP_TAG( PT_TSTRING,   0x3A17)
#define PR_TITLE_W                                  PROP_TAG( PT_UNICODE,   0x3A17)
#define PR_TITLE_A                                  PROP_TAG( PT_STRING8,   0x3A17)
#define PR_DEPARTMENT_NAME                          PROP_TAG( PT_TSTRING,   0x3A18)
#define PR_DEPARTMENT_NAME_W                        PROP_TAG( PT_UNICODE,   0x3A18)
#define PR_DEPARTMENT_NAME_A                        PROP_TAG( PT_STRING8,   0x3A18)
#define PR_OFFICE_LOCATION                          PROP_TAG( PT_TSTRING,   0x3A19)
#define PR_OFFICE_LOCATION_W                        PROP_TAG( PT_UNICODE,   0x3A19)
#define PR_OFFICE_LOCATION_A                        PROP_TAG( PT_STRING8,   0x3A19)
#define PR_PRIMARY_TELEPHONE_NUMBER                 PROP_TAG( PT_TSTRING,   0x3A1A)
#define PR_PRIMARY_TELEPHONE_NUMBER_W               PROP_TAG( PT_UNICODE,   0x3A1A)
#define PR_PRIMARY_TELEPHONE_NUMBER_A               PROP_TAG( PT_STRING8,   0x3A1A)
#define PR_BUSINESS2_TELEPHONE_NUMBER               PROP_TAG( PT_TSTRING,   0x3A1B)
#define PR_BUSINESS2_TELEPHONE_NUMBER_W             PROP_TAG( PT_UNICODE,   0x3A1B)
#define PR_BUSINESS2_TELEPHONE_NUMBER_A             PROP_TAG( PT_STRING8,   0x3A1B)
#define PR_OFFICE2_TELEPHONE_NUMBER                 PR_BUSINESS2_TELEPHONE_NUMBER
#define PR_OFFICE2_TELEPHONE_NUMBER_W               PR_BUSINESS2_TELEPHONE_NUMBER_W
#define PR_OFFICE2_TELEPHONE_NUMBER_A               PR_BUSINESS2_TELEPHONE_NUMBER_A
#define PR_MOBILE_TELEPHONE_NUMBER                  PROP_TAG( PT_TSTRING,   0x3A1C)
#define PR_MOBILE_TELEPHONE_NUMBER_W                PROP_TAG( PT_UNICODE,   0x3A1C)
#define PR_MOBILE_TELEPHONE_NUMBER_A                PROP_TAG( PT_STRING8,   0x3A1C)
#define PR_CELLULAR_TELEPHONE_NUMBER                PR_MOBILE_TELEPHONE_NUMBER
#define PR_CELLULAR_TELEPHONE_NUMBER_W              PR_MOBILE_TELEPHONE_NUMBER_W
#define PR_CELLULAR_TELEPHONE_NUMBER_A              PR_MOBILE_TELEPHONE_NUMBER_A
#define PR_RADIO_TELEPHONE_NUMBER                   PROP_TAG( PT_TSTRING,   0x3A1D)
#define PR_RADIO_TELEPHONE_NUMBER_W                 PROP_TAG( PT_UNICODE,   0x3A1D)
#define PR_RADIO_TELEPHONE_NUMBER_A                 PROP_TAG( PT_STRING8,   0x3A1D)
#define PR_CAR_TELEPHONE_NUMBER                     PROP_TAG( PT_TSTRING,   0x3A1E)
#define PR_CAR_TELEPHONE_NUMBER_W                   PROP_TAG( PT_UNICODE,   0x3A1E)
#define PR_CAR_TELEPHONE_NUMBER_A                   PROP_TAG( PT_STRING8,   0x3A1E)
#define PR_OTHER_TELEPHONE_NUMBER                   PROP_TAG( PT_TSTRING,   0x3A1F)
#define PR_OTHER_TELEPHONE_NUMBER_W                 PROP_TAG( PT_UNICODE,   0x3A1F)
#define PR_OTHER_TELEPHONE_NUMBER_A                 PROP_TAG( PT_STRING8,   0x3A1F)
#define PR_TRANSMITABLE_DISPLAY_NAME                PROP_TAG( PT_TSTRING,   0x3A20)
#define PR_TRANSMITABLE_DISPLAY_NAME_W              PROP_TAG( PT_UNICODE,   0x3A20)
#define PR_TRANSMITABLE_DISPLAY_NAME_A              PROP_TAG( PT_STRING8,   0x3A20)
#define PR_PAGER_TELEPHONE_NUMBER                   PROP_TAG( PT_TSTRING,   0x3A21)
#define PR_PAGER_TELEPHONE_NUMBER_W                 PROP_TAG( PT_UNICODE,   0x3A21)
#define PR_PAGER_TELEPHONE_NUMBER_A                 PROP_TAG( PT_STRING8,   0x3A21)
#define PR_BEEPER_TELEPHONE_NUMBER                  PR_PAGER_TELEPHONE_NUMBER
#define PR_BEEPER_TELEPHONE_NUMBER_W                PR_PAGER_TELEPHONE_NUMBER_W
#define PR_BEEPER_TELEPHONE_NUMBER_A                PR_PAGER_TELEPHONE_NUMBER_A
#define PR_USER_CERTIFICATE                         PROP_TAG( PT_BINARY,    0x3A22)
#define PR_PRIMARY_FAX_NUMBER                       PROP_TAG( PT_TSTRING,   0x3A23)
#define PR_PRIMARY_FAX_NUMBER_W                     PROP_TAG( PT_UNICODE,   0x3A23)
#define PR_PRIMARY_FAX_NUMBER_A                     PROP_TAG( PT_STRING8,   0x3A23)
#define PR_BUSINESS_FAX_NUMBER                      PROP_TAG( PT_TSTRING,   0x3A24)
#define PR_BUSINESS_FAX_NUMBER_W                    PROP_TAG( PT_UNICODE,   0x3A24)
#define PR_BUSINESS_FAX_NUMBER_A                    PROP_TAG( PT_STRING8,   0x3A24)
#define PR_HOME_FAX_NUMBER                          PROP_TAG( PT_TSTRING,   0x3A25)
#define PR_HOME_FAX_NUMBER_W                        PROP_TAG( PT_UNICODE,   0x3A25)
#define PR_HOME_FAX_NUMBER_A                        PROP_TAG( PT_STRING8,   0x3A25)
#define PR_COUNTRY                                  PROP_TAG( PT_TSTRING,   0x3A26)
#define PR_COUNTRY_W                                PROP_TAG( PT_UNICODE,   0x3A26)
#define PR_COUNTRY_A                                PROP_TAG( PT_STRING8,   0x3A26)
#define PR_LOCALITY                                 PROP_TAG( PT_TSTRING,   0x3A27)
#define PR_LOCALITY_W                               PROP_TAG( PT_UNICODE,   0x3A27)
#define PR_LOCALITY_A                               PROP_TAG( PT_STRING8,   0x3A27)
#define PR_STATE_OR_PROVINCE                        PROP_TAG( PT_TSTRING,   0x3A28)
#define PR_STATE_OR_PROVINCE_W                      PROP_TAG( PT_UNICODE,   0x3A28)
#define PR_STATE_OR_PROVINCE_A                      PROP_TAG( PT_STRING8,   0x3A28)
#define PR_STREET_ADDRESS                           PROP_TAG( PT_TSTRING,   0x3A29)
#define PR_STREET_ADDRESS_W                         PROP_TAG( PT_UNICODE,   0x3A29)
#define PR_STREET_ADDRESS_A                         PROP_TAG( PT_STRING8,   0x3A29)
#define PR_POSTAL_CODE                              PROP_TAG( PT_TSTRING,   0x3A2A)
#define PR_POSTAL_CODE_W                            PROP_TAG( PT_UNICODE,   0x3A2A)
#define PR_POSTAL_CODE_A                            PROP_TAG( PT_STRING8,   0x3A2A)
#define PR_POST_OFFICE_BOX                          PROP_TAG( PT_TSTRING,   0x3A2B)
#define PR_POST_OFFICE_BOX_W                        PROP_TAG( PT_UNICODE,   0x3A2B)
#define PR_POST_OFFICE_BOX_A                        PROP_TAG( PT_STRING8,   0x3A2B)
#define PR_TELEX_NUMBER                             PROP_TAG( PT_TSTRING,   0x3A2C)
#define PR_TELEX_NUMBER_W                           PROP_TAG( PT_UNICODE,   0x3A2C)
#define PR_TELEX_NUMBER_A                           PROP_TAG( PT_STRING8,   0x3A2C)
#define PR_ISDN_NUMBER                              PROP_TAG( PT_TSTRING,   0x3A2D)
#define PR_ISDN_NUMBER_W                            PROP_TAG( PT_UNICODE,   0x3A2D)
#define PR_ISDN_NUMBER_A                            PROP_TAG( PT_STRING8,   0x3A2D)
#define PR_ASSISTANT_TELEPHONE_NUMBER               PROP_TAG( PT_TSTRING,   0x3A2E)
#define PR_ASSISTANT_TELEPHONE_NUMBER_W             PROP_TAG( PT_UNICODE,   0x3A2E)
#define PR_ASSISTANT_TELEPHONE_NUMBER_A             PROP_TAG( PT_STRING8,   0x3A2E)
#define PR_HOME2_TELEPHONE_NUMBER                   PROP_TAG( PT_TSTRING,   0x3A2F)
#define PR_HOME2_TELEPHONE_NUMBER_W                 PROP_TAG( PT_UNICODE,   0x3A2F)
#define PR_HOME2_TELEPHONE_NUMBER_A                 PROP_TAG( PT_STRING8,   0x3A2F)
#define PR_ASSISTANT                                PROP_TAG( PT_TSTRING,   0x3A30)
#define PR_ASSISTANT_W                              PROP_TAG( PT_UNICODE,   0x3A30)
#define PR_ASSISTANT_A                              PROP_TAG( PT_STRING8,   0x3A30)

/*
 *  Profile section properties
 */

#define PR_STORE_PROVIDERS                          PROP_TAG( PT_BINARY,    0x3D00)
#define PR_AB_PROVIDERS                             PROP_TAG( PT_BINARY,    0x3D01)
#define PR_TRANSPORT_PROVIDERS                      PROP_TAG( PT_BINARY,    0x3D02)

#define PR_DEFAULT_PROFILE                          PROP_TAG( PT_BOOLEAN,   0x3D04)
#define PR_AB_SEARCH_PATH                           PROP_TAG( PT_MV_BINARY, 0x3D05)
#define PR_AB_DEFAULT_DIR                           PROP_TAG( PT_BINARY,    0x3D06)
#define PR_AB_DEFAULT_PAB                           PROP_TAG( PT_BINARY,    0x3D07)
#define PR_FILTERING_HOOKS                          PROP_TAG( PT_BINARY,    0x3D08)
#define PR_SERVICE_NAME                             PROP_TAG( PT_TSTRING,   0x3D09)
#define PR_SERVICE_NAME_W                           PROP_TAG( PT_UNICODE,   0x3D09)
#define PR_SERVICE_NAME_A                           PROP_TAG( PT_STRING8,   0x3D09)
#define PR_SERVICE_DLL_NAME                         PROP_TAG( PT_TSTRING,   0x3D0A)
#define PR_SERVICE_DLL_NAME_W                       PROP_TAG( PT_UNICODE,   0x3D0A)
#define PR_SERVICE_DLL_NAME_A                       PROP_TAG( PT_STRING8,   0x3D0A)
#define PR_SERVICE_ENTRY_NAME                       PROP_TAG( PT_STRING8,   0x3D0B)
#define PR_SERVICE_UID                              PROP_TAG( PT_BINARY,    0x3D0C)
#define PR_SERVICE_EXTRA_UIDS                       PROP_TAG( PT_BINARY,    0x3D0D)
#define PR_SERVICES                                 PROP_TAG( PT_BINARY,    0x3D0E)
#define PR_SERVICE_SUPPORT_FILES                    PROP_TAG( PT_MV_TSTRING, 0x3D0F)
#define PR_SERVICE_SUPPORT_FILES_W                  PROP_TAG( PT_MV_UNICODE, 0x3D0F)
#define PR_SERVICE_SUPPORT_FILES_A                  PROP_TAG( PT_MV_STRING8, 0x3D0F)
#define PR_SERVICE_DELETE_FILES                     PROP_TAG( PT_MV_TSTRING, 0x3D10)
#define PR_SERVICE_DELETE_FILES_W                   PROP_TAG( PT_MV_UNICODE, 0x3D10)
#define PR_SERVICE_DELETE_FILES_A                   PROP_TAG( PT_MV_STRING8, 0x3D10)
// #define PR_AB_SEARCH_PATH_FLAGS                      PROP_TAG( PT_LONG,      0x3D11)

/*
 *  Status object properties
 */

#define PR_IDENTITY_DISPLAY                         PROP_TAG( PT_TSTRING,   0x3E00)
#define PR_IDENTITY_DISPLAY_W                       PROP_TAG( PT_UNICODE,   0x3E00)
#define PR_IDENTITY_DISPLAY_A                       PROP_TAG( PT_STRING8,   0x3E00)
#define PR_IDENTITY_ENTRYID                         PROP_TAG( PT_BINARY,    0x3E01)
#define PR_RESOURCE_METHODS                         PROP_TAG( PT_LONG,      0x3E02)
#define PR_RESOURCE_TYPE                            PROP_TAG( PT_LONG,      0x3E03)
#define PR_STATUS_CODE                              PROP_TAG( PT_LONG,      0x3E04)
#define PR_IDENTITY_SEARCH_KEY                      PROP_TAG( PT_BINARY,    0x3E05)
#define PR_OWN_STORE_ENTRYID                        PROP_TAG( PT_BINARY,    0x3E06)
#define PR_RESOURCE_PATH                            PROP_TAG( PT_TSTRING,   0x3E07)
#define PR_RESOURCE_PATH_W                          PROP_TAG( PT_UNICODE,   0x3E07)
#define PR_RESOURCE_PATH_A                          PROP_TAG( PT_STRING8,   0x3E07)
#define PR_STATUS_STRING                            PROP_TAG( PT_TSTRING,   0x3E08)
#define PR_STATUS_STRING_W                          PROP_TAG( PT_UNICODE,   0x3E08)
#define PR_STATUS_STRING_A                          PROP_TAG( PT_STRING8,   0x3E08)
#define PR_X400_DEFERRED_DELIVERY_CANCEL            PROP_TAG( PT_BOOLEAN,   0x3E09)
#define PR_HEADER_FOLDER_ENTRYID                    PROP_TAG( PT_BINARY,    0x3E0A)
#define PR_REMOTE_PROGRESS                          PROP_TAG( PT_LONG,      0x3E0B)
#define PR_REMOTE_PROGRESS_TEXT                     PROP_TAG( PT_TSTRING,   0x3E0C)
#define PR_REMOTE_PROGRESS_TEXT_W                   PROP_TAG( PT_UNICODE,   0x3E0C)
#define PR_REMOTE_PROGRESS_TEXT_A                   PROP_TAG( PT_STRING8,   0x3E0C)
#define PR_REMOTE_VALIDATE_OK                       PROP_TAG( PT_BOOLEAN,   0x3E0D)

/*
 * Display table properties
 */

#define PR_CONTROL_FLAGS                            PROP_TAG( PT_LONG,      0x3F00)
#define PR_CONTROL_STRUCTURE                        PROP_TAG( PT_BINARY,    0x3F01)
#define PR_CONTROL_TYPE                             PROP_TAG( PT_LONG,      0x3F02)
#define PR_DELTAX                                   PROP_TAG( PT_LONG,      0x3F03)
#define PR_DELTAY                                   PROP_TAG( PT_LONG,      0x3F04)
#define PR_XPOS                                     PROP_TAG( PT_LONG,      0x3F05)
#define PR_YPOS                                     PROP_TAG( PT_LONG,      0x3F06)
#define PR_CONTROL_ID                               PROP_TAG( PT_BINARY,    0x3F07)
#define PR_INITIAL_DETAILS_PANE                     PROP_TAG( PT_LONG,      0x3F08)

/*
 * Secure property id range
 */

#define PROP_ID_SECURE_MIN                          0x67F0
#define PROP_ID_SECURE_MAX                          0x67FF


#endif  /* MAPITAGS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\mapi\inc\msfs.h ===
#if !defined( _MSFS_H )
#define _MSFS_H

/*
 *  M S F S . H
 *
 *
 *  Copyright Microsoft Corporation 1993-1995, All Rights Reserved
 *
 *
 *  Definitions used by the the Microsoft Mail transport, address book
 *  and shared folder service providers.  CFG properties are programatically 
 *  configurable via calls to ConfigureMsgService().  
 *
 *  The following MSFS defined properties are configurable via ConfigureMsgService()
 *  calls.  They are grouped by function.
 *
 *  C o n n e c t i o n   P r o p e r t i e s
 *
 *  PR_CFG_SERVER_PATH
 *      --  The path to the users post office.  Mapped network drives, UNC and NETWARE paths
 *          are acceptable.  NETWARE paths of the type NWServer/share:dir\dir1 are converted to 
 *          UNC paths of the type \\NWServer\share\dir\dir1. 
 *          $REVIEW: If no path is specified, the path will default to the path found in MAIL.DAT
 *                   or if MAIL.DAT is not found to m:
 *
 *  PR_CFG_MAILBOX
 *      --  The users mailbox name.  eg. in a NET/PO/USER address,
 *          this is USER.  The maximum mailbox name is 10 characters.
 *
 *  PR_CFG_PASSWORD
 *      --  The users mailbox password.  The maximum password is 8 characters.
 *
 *  PR_CFG_REMEMBER
 *      --  A boolean value indicating whether the users password is
 *          to be remembered in the profile or not.
 *
 *  PR_CFG_CONN_TYPE
 *      --  The connection type.  This may be one of CFG_CONN_LAN,
 *          CFG_CONN_REMOTE, CFG_CONN_OFFLINE as defined below.
 *
 *  PR_CFG_SESSION_LOG
 *      --  A boolean value indicating whether session logging
 *          is/is not required.
 *
 *  PR_CFG_SESSION_LOG_FILE
 *      --  The path to the session log file.
 *
 *  D e l i v e r y   P r o p e r t i e s
 *
 *  PR_CFG_ENABLE_UPLOAD
 *      --  A boolean value which indicates whether mail in the outbox
 *          is sent.
 *
 *  PR_CFG_ENABLE_DOWNLOAD
 *      --  A boolean value which indicates whether mail in the server
 *          mailbag is downloaded.
 *
 *  PR_CFG_UPLOADTO
 *      --  A bit array which allows the user to indicate which addresses
 *          for which the transport is to attempt delivery.  This is useful
 *          in order to allow a user to specify that a transport only handle
 *          delivery for a subset of the addresses it can really process.
 *          When multiple transports are installed and the user wants a
 *          different transport to handle some specific address types they
 *          can use this bit array to specify that the MSMAIL transport
 *          only handle a specific set of addresses.
 *
 *          Possible values as defined below include:
 *
 *          CFG_UPLOADTO_PCMAIL     --  Local Post Office and External Post Office address types
 *          CFG_UPLOADTO_PROFS      --  PROFS address types
 *          CFG_UPLOADTO_SNADS      --  SNADS address types
 *          CFG_UPLOADTO_OV         --  OfficeVision address types
 *          CFG_UPLOADTO_MCI        --  MCI address types
 *          CFG_UPLOADTO_X400       --  X.400 address types
 *          CFG_UPLOADTO_FAX        --  FAX address types
 *          CFG_UPLOADTO_MHS        --  MHS address types
 *          CFG_UPLOADTO_SMTP       --  SMTP address types
 *          CFG_UPLOADTO_MACMAIL    --  MacMail address types
 *          CFG_UPLOADTO_ALL        --  All MSMAIL address types
 *
 *
 *  PR_CFG_NETBIOS_NTFY
 *      --  A boolean value which indicates whether a netbios notification
 *          is sent to a recipients transport when mail is delivered to
 *          their server inbox.
 *
 *  PR_CFG_SPOOLER_POLL
 *      --  The polling interval in minutes when the transport
 *          checks for new mail.  1 <= polling interval <= 9999
 *
 *  F a s t  L A N  P r o p e r t i e s
 *
 *  PR_CFG_LAN_HEADERS
 *      --  A boolean value which indicates whether the user wants to enable
 *          headers while working on the LAN.  Headers mode allows the user
 *          to download message headers and selectively choose which mail
 *          to download.
 *
 *  PR_CFG_LAN_LOCAL_AB
 *      --  A boolean value which indicates whether the user wants to use
 *          name resolution based on a local copy of the server address book
 *          rather than the server address book itself.
 *
 *  S l o w  L A N  P r o p e r t i e s
 *
 *  PR_CFG_RAS_HEADERS
 *      --  A boolean value which indicates whether the user wants to enable
 *          headers while working over a slow speed link.  Headers mode
 *          allows the user to download message headers and selectively
 *          choose which mail to download.
 *
 *  PR_CFG_RAS_LOCAL_AB
 *      --  A boolean value which indicates whether the user wants to use
 *          name resolution based on a local copy of the server address book
 *          rather than the server address book itself.
 *
 *  PR_CFG_RAS_INIT_ON_START
 *      --  A boolean value which indicates that a RAS connection should
 *          be established when the transport provider starts up.
 *
 *  PR_CFG_RAS_TERM_ON_HDRS
 *      --  A boolean value which indicates that a RAS connection should
 *          be automatically terminated when headers are finished downloading.
 *
 *  PR_CFG_RAS_TERM_ON_XFER
 *      --  A boolean value which indicates that a RAS connection should
 *          be automatically terminated after mail has finished being sent
 *          received.
 *
 *  PR_CFG_RAS_TERM_ON_EXIT
 *      --  A boolean value which indicates that a RAS connection should
 *          be automatically terminated when the provider is exited.
 *
 *  PR_CFG_RAS_PROFILE
 *      --  The name of the RAS profile that the transport will use by
 *          default to attempt the connection.
 *
 *  PR_CFG_RAS_RETRYATTEMPTS
 *      --  Number of times to attempt dial for connection.
 *          1 <= retry attempts <= 9999
 *
 *  PR_CFG_RAS_RETRYDELAY
 *      --  Delay between retry attempts in seconds.
 *          30 <= retry delay <= 9999
 *
 *  PR_CFG_RAS_CONFIRM
 *      --  A value which determines whether, on a RAS connection, the
 *          user should be prompted to select a RAS phonebook entry.
 *          Possible values as defined below include:
 *          CFG_ALWAYS      --  Always use the default RAS profile.
 *                              Never prompt the user.
 *          CFG_ASK_FIRST   --  Prompt the user to select a profile on the
 *                              first connection or after any error occurs.
 *          CFG_ASK_EVERY   --  Always prompt the user to select the RAS
 *                              profile.
 *
 *  S c h e d u l e d   S e s s i o n   P r o p e r t i e s 
 *
 *  PR_CFG_SCHED_SESS
 *      --  A property that contains information on scheduled sessions.  The
 *          maximum number of entries that may be stored is CFG_SS_MAX.  The
 *          information is stored in the data structure SchedSess.
 *          $REVIEW Probably want to flesh this out more.
 *
 */

#include <ras.h>
#include <mapitags.h>

/*
 * Connection Properties
 */
#define PR_CFG_SERVER_PATH              PROP_TAG (PT_STRING8,   0x6600)
#define PR_CFG_MAILBOX                  PROP_TAG (PT_STRING8,   0x6601)
// Password must be in the secure property range (See MAPITAGS.H)
#define PR_CFG_PASSWORD                 PROP_TAG (PT_STRING8,   PROP_ID_SECURE_MIN)
#define PR_CFG_CONN_TYPE                PROP_TAG (PT_LONG,      0x6603)
#define     CFG_CONN_LAN            0
#define     CFG_CONN_REMOTE         1
#define     CFG_CONN_OFFLINE        2
#define PR_CFG_SESSION_LOG              PROP_TAG (PT_BOOLEAN,   0x6604)
#define PR_CFG_SESSION_LOG_FILE         PROP_TAG (PT_STRING8,   0x6605)
#define PR_CFG_REMEMBER                 PROP_TAG (PT_BOOLEAN,   0x6606)

/*
 * Delivery Properties
 */

#define PR_CFG_ENABLE_UPLOAD            PROP_TAG (PT_BOOLEAN,   0x6620)
#define PR_CFG_ENABLE_DOWNLOAD          PROP_TAG (PT_BOOLEAN,   0x6621)
#define PR_CFG_UPLOADTO                 PROP_TAG (PT_LONG,      0x6622)
#define     CFG_UPLOADTO_PCMAIL     0x00000001
#define     CFG_UPLOADTO_PROFS      0x00000002
#define     CFG_UPLOADTO_SNADS      0x00000004
#define     CFG_UPLOADTO_MCI        0x00000008
#define     CFG_UPLOADTO_X400       0x00000010
#define     CFG_UPLOADTO_FAX        0x00000040
#define     CFG_UPLOADTO_MHS        0x00000080
#define     CFG_UPLOADTO_SMTP       0x00000100
#define     CFG_UPLOADTO_OV         0x00000800
#define     CFG_UPLOADTO_MACMAIL    0x00001000
#define     CFG_UPLOADTO_ALL        CFG_UPLOADTO_PCMAIL | CFG_UPLOADTO_PROFS | CFG_UPLOADTO_SNADS | \
                                    CFG_UPLOADTO_MCI | CFG_UPLOADTO_X400 | CFG_UPLOADTO_FAX | \
                                    CFG_UPLOADTO_MHS | CFG_UPLOADTO_SMTP | CFG_UPLOADTO_OV | \
                                    CFG_UPLOADTO_MACMAIL
#define PR_CFG_NETBIOS_NTFY             PROP_TAG (PT_BOOLEAN,   0x6623)
#define PR_CFG_SPOOLER_POLL             PROP_TAG (PT_STRING8,   0x6624)

/*
 * Fast LAN Properties
 */

#define PR_CFG_LAN_HEADERS              PROP_TAG (PT_BOOLEAN,   0x6630)
#define PR_CFG_LAN_LOCAL_AB             PROP_TAG (PT_BOOLEAN,   0x6631)

/*
 * Slow LAN Properties
 */

#define PR_CFG_RAS_HEADERS              PROP_TAG (PT_BOOLEAN,   0x6640)
#define PR_CFG_RAS_LOCAL_AB             PROP_TAG (PT_BOOLEAN,   0x6641)
#define PR_CFG_RAS_INIT_ON_START        PROP_TAG (PT_BOOLEAN,   0x6642)
#define PR_CFG_RAS_TERM_ON_HDRS         PROP_TAG (PT_BOOLEAN,   0x6643)
#define PR_CFG_RAS_TERM_ON_XFER         PROP_TAG (PT_BOOLEAN,   0x6644)
#define PR_CFG_RAS_TERM_ON_EXIT         PROP_TAG (PT_BOOLEAN,   0x6645)
#define PR_CFG_RAS_PROFILE              PROP_TAG (PT_STRING8,   0x6646)
#define PR_CFG_RAS_CONFIRM              PROP_TAG (PT_LONG,      0x6647)
#define     CFG_ALWAYS              0
#define     CFG_ASK_FIRST           1
#define     CFG_ASK_EVERY           2
#define PR_CFG_RAS_RETRYATTEMPTS        PROP_TAG (PT_STRING8,   0x6648)
#define PR_CFG_RAS_RETRYDELAY           PROP_TAG (PT_STRING8,   0x6649)


/*
 * Message Header Property
 */

#define PR_CFG_LOCAL_HEADER             PROP_TAG (PT_BOOLEAN,   0x6650)

/*
 * Scheduled Session Properties
 */
#define     CFG_SS_MAX          16
#define     CFG_SS_BASE_ID      0x6700
#define     CFG_SS_MAX_ID       CFG_SS_BASE_ID + CFG_SS_MAX - 1
#define SchedPropTag(n)         PROP_TAG (PT_BINARY, CFG_SS_BASE_ID+(n))
#define PR_CFG_SCHED_SESS       SchedPropTag(0)

typedef struct SchedSess {
    USHORT          sSessType;
    USHORT          sDayMask;
    FILETIME        ftTime;         // sched time
    FILETIME        ftStart;        // start time
    ULONG           ulFlags;        // flags and task list
    TCHAR           szPhoneEntry[RAS_MaxEntryName+1];

} SCHEDSESS, FAR *LPSCHEDSESS;

// Day bits
#define     CFG_SS_SUN  0x0001
#define     CFG_SS_MON  0x0002
#define     CFG_SS_TUE  0x0004
#define     CFG_SS_WED  0x0008
#define     CFG_SS_THU  0x0010
#define     CFG_SS_FRI  0x0020
#define     CFG_SS_SAT  0x0040

#define IsDayChecked(sDayMask, nDay)  ( (sDayMask) & (1<<(nDay)) )

// Session types
#define     CFG_SS_EVERY    0
#define     CFG_SS_WEEKLY   1
#define     CFG_SS_ONCE     2
#define     CFG_SS_NULLTYPE 3

// Property range identifiers; useful for asserting
#define PR_CFG_MIN              PROP_TAG (PT_STRING8,   0x6600)
#define PR_CFG_MAX              SchedPropTag(CFG_SS_MAX-1)

// Shared Folder Service Provider Properties

// PR_ASSIGNED_ACCESS - MAPI Access rights given to users other than the owner of the folder
//                      This property can be retrieved and set. The following MAPI access flags
//                      are valid: 
//                          MAPI_ACCESS_READ
//                          (MAPI_ACCESS_CREATE_HIERARCHY | MAPI_ACCESS_CREATE_CONTENTS)
//                          MAPI_ACCESS_DELETE
//  
#define PR_ASSIGNED_ACCESS  PROP_TAG(PT_LONG, 0x66ff)

// SFSP_ACCESS_OWNER -  This flag is returned when PR_ASSIGNED_ACCESS is retrieved by the owner
//                      of the folder. It can not be set.
#define SFSP_ACCESS_OWNER   0x8000


// Unique Provider Identifiers
//
#define MSFS_UID_ABPROVIDER     { 0x00,0x60,0x94,0x64,0x60,0x41,0xb8,0x01, \
                                  0x08,0x00,0x2b,0x2b,0x8a,0x29,0x00,0x00 }

#define MSFS_UID_SFPROVIDER     { 0x00,0xff,0xb8,0x64,0x60,0x41,0xb8,0x01, \
                                  0x08,0x00,0x2b,0x2b,0x8a,0x29,0x00,0x00 }
                                                                            

#endif // _MSFS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\trialoc\stdatl.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\mapi\inc\mspst.h ===
/*
 *  M S P S T . H
 *  
 *  This file lists internal properties of the Microsoft Personal
 *  Information Store
 *  
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _MSPST_H_
#define _MSPST_H_


/*  The following is a list of properties that may be passed in
    as the properties in the array of SPropValue structure on the
    MsgServiceConfigure function.
    
    Creating a PST profile section through CreateMsgService.
    The creation of the actual PST file is a two step process.  First the
    client should call CreateMsgService to setup the profile section and then
    ConfigureMsgService to create the PST file.
    The CreateMsgService call will setup the PR_DISPLAY_NAME property in the
    profile section to be used on the PST when it is created.

    Configuring an PST file through ConfigureMsgService.
    The configuration of an PST can take two forms, either configuring an
    existing PST or creating a new PST.  The Microsoft Personal Information
    Store provider will try to find the necessary properties by first looking
    in the array of SPropValue structures provided by the client and then in the
    profile section, except for PR_PST_PW_SZ_OLD for which it will only look
    in the array of properties.

    The Microsoft PST provider will try to open the file specified by the
    PR_PST_PATH property, using the password given in the PR_PST_PW_SZ_OLD
    property.  If it finds a file and it recognizes it as a PST
    file, it will start the configuration routine.  Otherwise it will start the
    creation routine.

    The configuration routine will look for the PR_DISPLAY_NAME_A and
    PR_COMMENT_A properties and set them in the message store object.  Then it
    will look for the PR_PST_REMEMBER_PW property to decide if it should
    remember the password in the profile. (If not found then it will defaut to
    the current status of the profile password.)  Then if it is supposed to
    use UI, it will display the configuration property sheet to the user.  After
    all has succeeded, it will update the profile.

    The creation routine will follow one of two paths to get the PR_PST_PATH
    property.  If it is supposed to use UI it will always display the file open
    dialog to confirm the path passed in or allow the user to change it.  If
    the user chooses an existing file and it recognizes it as an PST it will
    drop back to the configuration routine.  If the user chooses an existing
    file and it is not recognized as an PST file, the user will be given the
    option of choosing another file or  creating a new PST in its place, in
    which case is will continue with the create routine.  If the user chooses
    a new file it will continue with the create routine.  If the routine is not
    allowed to use UI, then the routine will create a file at the given path
    even if another file exists there.

    Once it decides to continue with the creation process it will get the
    PR_DISPLAY_NAME, PR_COMMENT, PR_PST_ENCRYPTION, and PR_PST_SZ_PW_NEW
    properties.  If it is supposed to use UI, it will use these to initialize
    the creation dialog and get any changes the user want.  Then it will create
    a new file and update the profile.
    
    PR_DISPLAY_NAME_A   display name for the PST service
    PR_COMMENT_A        comment to the place on the PST store object
    PR_PST_PATH         location the store to create or configure
    PR_PST_REMEMBER_PW  whether or not the remember the password in the profile
    PR_PST_ENCRYPTION   encryption level at which to create the file
    PR_PST_PW_SZ_OLD    password of the PST being configured
    PR_PST_PW_SZ_NEW    password to use for future access to the PST
*/

#define PST_EXTERN_PROPID_BASE          (0x6700)
#define PR_PST_PATH                     PROP_TAG(PT_STRING8, PST_EXTERN_PROPID_BASE + 0)
#define PR_PST_REMEMBER_PW              PROP_TAG(PT_BOOLEAN, PST_EXTERN_PROPID_BASE + 1)
#define PR_PST_ENCRYPTION               PROP_TAG(PT_LONG, PST_EXTERN_PROPID_BASE + 2)
#define PR_PST_PW_SZ_OLD                PROP_TAG(PT_STRING8, PST_EXTERN_PROPID_BASE + 3)
#define PR_PST_PW_SZ_NEW                PROP_TAG(PT_STRING8, PST_EXTERN_PROPID_BASE + 4)
    
#define PSTF_NO_ENCRYPTION              ((DWORD)0x80000000)
#define PSTF_COMPRESSABLE_ENCRYPTION    ((DWORD)0x40000000)
#define PSTF_BEST_ENCRYPTION            ((DWORD)0x20000000)

/*
 *  PR_MDB_PROVIDER is the GUID that represent the Microsoft Personal
 *  Information Store.  This guid is available as a property in the stores
 *  table and on the message store and status objects.
 */
#define MSPST_UID_PROVIDER  {   0x4e, 0x49, 0x54, 0x41, \
                                0xf9, 0xbf, 0xb8, 0x01, \
                                0x00, 0xaa, 0x00, 0x37, \
                                0xd9, 0x6e, 0x00, 0x00 }

#endif  /* _MSPST_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\trialoc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by icwhelp.rc
//
#define IDS_PROJNAME                    100

#define IDR_TRIALEND                    1036

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         603
#define _APS_NEXT_SYMED_VALUE           1044
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\trialoc\debug.cpp ===
//
//
//
#include "stdafx.h"

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "trialoc"
#define SZ_MODULE           "trialoc"
#define DECLARE_DEBUG
#include "..\inc\debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\trialoc\sources.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

GETCONN_DIR     = ..\..

#
# Cross-compiler macros for unique naming
#

MAJORCOMP       = ie4
MINORCOMP       = trialoc


#
# Defines for common.inc
#

TARGET_BOTH     = 1

#
# Include our common makefile
#

!include $(GETCONN_DIR)\common.inc

INCLUDES = $(INCLUDES);$(GETCONN_DIR)\trialoc


PASS0_HEADERDIR   = $(O)
PASS0_SOURCEDIR   = $(O)
MIDL_TLBDIR       = $(O)
MIDL_UUIDDIR      = $(O)

#
# Common settings required by build.exe and makefile.def
#

#WINVER_VERSION  = 0x400
TARGETNAME      = trialoc
TARGETPATH      = obj
TARGETTYPE      = DYNLINK
TARGETLIBS      = $(LIBRARY_PATH)\gdi32.lib             \
                  $(LIBRARY_PATH)\kernel32.lib          \
                  $(LIBRARY_PATH)\user32.lib            \
                  $(LIBRARY_PATH)\advapi32.lib          \
                  $(LIBRARY_PATH)\shell32.lib           \
                  $(LIBRARY_PATH)\uuid.lib              \
                  $(LIBRARY_PATH)\ole32.lib             \
                  $(LIBRARY_PATH)\oleaut32.lib          \
                  $(SDK_LIB_PATH)\version.lib           \
!if defined(NOT_UNICODE)
                  $(GETCONN_DIR)\lib\ansi\$O\stocklib.lib    \
!else
                  $(GETCONN_DIR)\lib\unicode\$O\stocklib.lib    \
!endif

PRECOMPILED_CXX = 1
USE_STATIC_ATL  = 1
USE_MSVCRT      = 1

DLLDEF          = ..\trialoc.def
DLLBASE         = 0x63A00000
DLLENTRY        = DllMain

#
# List of sources
#

SOURCES =                       \
            ..\trialoc.rc       \
            ..\trialoc.idl      \
            ..\debug.cpp        \
            ..\trialoc.cpp      \
            ..\trialend.cpp     \
            ..\stdatl.cpp

PRECOMPILED_INCLUDE = ..\stdafx.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\tdc\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\trialoc\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__1E7949FE_86F4_11D1_ADD8_0000F87734F0__INCLUDED_)
#define AFX_STDAFX_H__1E7949FE_86F4_11D1_ADD8_0000F87734F0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

// Includes
#include <atlcom.h>
#include <atlctl.h>

#include <ccstock.h>

#include "trialoc.h"

#include "resource.h"

// Common global include for ICWHELP

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1E7949FE_86F4_11D1_ADD8_0000F87734F0__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\trialoc\trialend.cpp ===
// TrialEnd.cpp : Implementation of CTrialEnd
#include "stdafx.h"
#include "trialoc.h"
#include "TrialEnd.h"

static const TCHAR cszKeyIcwRmind[] = TEXT("Software\\Microsoft\\Internet Connection Wizard\\IcwRmind");
static const TCHAR cszTrialConverted[] = TEXT("TrialConverted");

/////////////////////////////////////////////////////////////////////////////
// CTrialEnd


HRESULT CTrialEnd::OnDraw(ATL_DRAWINFO& di)
{
    return S_OK;
}

STDMETHODIMP CTrialEnd::CleanupTrialReminder(BOOL * pbRetVal)
{
    HKEY    hkey;
    DWORD   dwValue = 1;
                
    if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                      cszKeyIcwRmind,
                      0,
                      KEY_ALL_ACCESS,
                      &hkey) == ERROR_SUCCESS)
    {
        RegSetValueEx(hkey,
                      cszTrialConverted,
                      0,
                      REG_DWORD,
                      (LPBYTE) &dwValue,
                      sizeof(DWORD));                              

        RegCloseKey(hkey);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\trialoc\trialend.h ===
// TrialEnd.h : Declaration of the CTrialEnd

#ifndef __TRIALEND_H_
#define __TRIALEND_H_

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CTrialEnd
class ATL_NO_VTABLE CTrialEnd :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTrialEnd,&CLSID_TrialEnd>,
	public CComControl<CTrialEnd>,
	public IDispatchImpl<ITrialEnd, &IID_ITrialEnd, &LIBID_TRIALOCLib>,
	public IPersistStreamInitImpl<CTrialEnd>,
	public IOleControlImpl<CTrialEnd>,
	public IOleObjectImpl<CTrialEnd>,
	public IOleInPlaceActiveObjectImpl<CTrialEnd>,
	public IViewObjectExImpl<CTrialEnd>,
	public IOleInPlaceObjectWindowlessImpl<CTrialEnd>,
    public IObjectSafetyImpl<CTrialEnd>
{
public:
	CTrialEnd()
	{
 
	}

DECLARE_REGISTRY_RESOURCEID(IDR_TRIALEND)

BEGIN_COM_MAP(CTrialEnd) 
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ITrialEnd)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY_IMPL(IOleControl)
	COM_INTERFACE_ENTRY_IMPL(IOleObject)
	COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CTrialEnd)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()


BEGIN_MSG_MAP(CTrialEnd)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
	MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
END_MSG_MAP()


// IViewObjectEx
	STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
	{
		ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
		*pdwStatus = 0;
		return S_OK;
	}

// ITrialEnd
public:
	STDMETHOD(CleanupTrialReminder)(/*[out,revtal]*/ BOOL *pbRetVal);
	HRESULT OnDraw(ATL_DRAWINFO& di);

};

#endif //__TRIALEND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\trialoc\trialoc.cpp ===
// trialoc.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//        To build a separate proxy/stub DLL, 
//        run nmake -f trialocps.mk in the project directory.

#include "stdafx.h"
#include "initguid.h"
#include "trialoc.h"

#include "trialoc_i.c"
#include "trialend.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_TrialEnd, CTrialEnd)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\tdc\common.inc ===
SOURCES_USED=$(ROOT)\common.inc

!if $(ALPHA)
MSC_WARNING_LEVEL = /W3 /WX
!endif

!ifndef MSC_WARNING_LEVEL
MSC_WARNING_LEVEL = /W4 /WX
!endif

C_DEFINES = \
    /D_WCTYPE_INLINE_DEFINED \
    /DSTRICT

!if !$(FREEBUILD)
USE_RTTI=1
MSC_OPTIMIZATION=/Od
#USER_CPP_FLAGS=/zmf
WATCOM_OPTS=/ei /zt16 /zm /zff /zgf
LINKER_NOICF=1      # ICF is s-l-o-w
!else
MSC_OPTIMIZATION=/Oxs
#USER_CPP_FLAGS=/zmf
WATCOM_OPTS=/ei /zt16 /ox /oe /zm /zff /zgf
!endif

MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /Ob1 /Oi

NOT_LEAN_AND_MEAN=1

USE_NOLIBS=1
UMTYPE=windows

# Use NT 4.0/Win95 functionality only

WIN32_IE_VERSION=0x0400
WIN32_WINNT_VERSION=0x0400
WIN32_WIN95_VERSION=0x0400
SUBSYSTEM_VERSION=4.00

!ifdef WIN16

# Win 16 Specific Environment.
!ifndef __MSVC_ENV__
__WATCOM_ENV__=1
!endif
C_DEFINES = $(C_DEFINES) /DINC_WIN16X /DWRAP_RECTL /DFULL_DEBUG

FULL_DEBUG=1

!endif

NO_NTDLL=1

CHECKED_ALT_DIR=1

#
# The IE build lab sets this flag for debug builds so we get full debug
#   on IE drops. The NT build lab wants debug lite builds and therefore
#   does not set it.
#
!ifdef MSHTML_FULL_DEBUG
!message MSHTML_FULL_DEBUG was defined. Building full debug.
FULL_DEBUG=1
!endif

# By default, don't generate a .bsc file
NO_BROWSER_FILE=1

!ifdef USE_ICECAP
C_DEFINES = $(C_DEFINES) /DPRODUCT_PROF
!endif

!ifdef USE_PERFTEST
C_DEFINES = $(C_DEFINES) /DPRODUCT_PERFTEST
!endif

!ifdef USE_PERFBUG
C_DEFINES = $(C_DEFINES) /DPRODUCT_PERFBUG
!endif

!ifdef USE_PERFTAGS
!if $(FREEBUILD)
C_DEFINES = $(C_DEFINES) /DPERFTAGS
!message PERFTAGS was defined
!endif
!endif

!ifdef USE_MSHTML_INCREMENTAL_LINKING
!if !$(FREEBUILD) && $(USE_MSHTML_INCREMENTAL_LINKING)
NTDEBUG=ntsd
NTDEBUGTYPE=windbg
NTDBGFILES=1
!undef USE_MAPSYM
USE_INCREMENTAL_LINKING=1
LINKER_FLAGS=$(LINKER_FLAGS) -INCREMENTAL:YES
USE_PDB_TO_COMPILE=1
TARGETPDB=TDC
!message USE_MSHTML_INCREMENTAL_LINKING was defined
!message $(TARGETPDB) was defined
!endif
!else
# Compatibility with existing usage before use_mshtml_incremental_linking
!ifdef USE_INCREMENTAL_LINKING
!message DOING IT THE OLD WAY
LINKER_FLAGS = -INCREMENTAL:YES
USE_PDB_TO_COMPILE=1
!else
USE_MAPSYM=1
!endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\tdc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TDC.rc
//
#define IDS_PROJNAME    100
#define IDR_TDCCtl  101
#define IDR_SimpleTabularData   102
#define IDI_TDCICON 203

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        205
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\tdc\notify.h ===
//+-----------------------------------------------------------------------
//
//  TDC / STD Notifications
//  Copyright (C) Microsoft Corporation, 1996, 1997
//
//  File:       Notify.h
//
//  Contents:   Declaration of the CEventBroker class.
//              This class translates internal TDC / STD events into
//              appropriate notifications for the external world.
//
//------------------------------------------------------------------------

#include "msdatsrc.h"

template <class T> class CMyBindStatusCallback;
class CTDCCtl;

interface DATASRCListener : public IUnknown
{
    STDMETHOD(datasrcChanged)(BSTR bstrQualifier, BOOL fDataAvail);
};

//------------------------------------------------------------------------
//
//  CEventBroker
//
//  This class translates internal STD / TDC events into appropriate
//  notifications for the outside world.
//
//------------------------------------------------------------------------

class CEventBroker
{
public:
    STDMETHOD_(ULONG,AddRef)    (THIS);
    STDMETHOD_(ULONG,Release)   (THIS);
// ;begin_internal
    STDMETHOD(SetDATASRCListener)(DATASRCListener *);
// ;end_internal
    STDMETHOD(SetDataSourceListener)(DataSourceListener *);
    STDMETHOD(SetSTDEvents)(OLEDBSimpleProviderListener *);
    inline DataSourceListener *GetDataSourceListener();
    inline DATASRCListener *GetDATASRCListener();
    inline OLEDBSimpleProviderListener *GetSTDEvents();

    CEventBroker(CTDCCtl *pReadyStateControl);
    ~CEventBroker();

    STDMETHOD(aboutToChangeCell)(LONG iRow, LONG iCol);
    STDMETHOD(cellChanged)(LONG iRow, LONG iCol);
    STDMETHOD(aboutToDeleteRows)(LONG iRowStart, LONG iRowCount);
    STDMETHOD(deletedRows)(LONG iRowStart, LONG iRowCount);
    STDMETHOD(aboutToInsertRows)(LONG iRowStart, LONG iRowCount);
    STDMETHOD(insertedRows)(LONG iRowStart, LONG iRowCount);
    STDMETHOD(rowsAvailable)(LONG iRowStart, LONG iRowCount);

    STDMETHOD(RowChanged)(LONG iRow);
    STDMETHOD(ColChanged)(LONG iCol);
// ;begin_internal
#ifdef NEVER
    STDMETHOD(DeletedCols)(LONG iColStart, LONG iColCount);
    STDMETHOD(InsertedCols)(LONG iColStart, LONG iColCount);
#endif
// ;end_internal
    STDMETHOD(STDLoadStarted)(CComObject<CMyBindStatusCallback<CTDCCtl> > *pBSC,
                              boolean fAppending);
    STDMETHOD(STDLoadCompleted)();
    STDMETHOD(STDLoadStopped)();
    STDMETHOD(STDLoadedHeader)();
    STDMETHOD(STDDataSetChanged)();

    STDMETHOD(GetReadyState)(LONG *plReadyState);
    STDMETHOD(UpdateReadyState)(LONG lReadyState);    
    CMyBindStatusCallback<CTDCCtl> *m_pBSC;

private:
    ULONG                    m_cRef;         // interface reference count
    DataSourceListener      *m_pDataSourceListener;
// ;begin_internal
    DATASRCListener         *m_pDATASRCListener;
// ;end_internal
    OLEDBSimpleProviderListener *m_pSTDEvents;
    LONG                     m_lReadyState;
    CTDCCtl                  *m_pReadyStateControl;
};

inline DataSourceListener *CEventBroker::GetDataSourceListener()
{
    return m_pDataSourceListener;
}

// ;begin_internal
inline DATASRCListener *CEventBroker::GetDATASRCListener()
{
    return m_pDATASRCListener;
}
// ;end_internal

inline OLEDBSimpleProviderListener *CEventBroker::GetSTDEvents()
{
    return m_pSTDEvents;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\tdc\stdafx.h ===
// disable warning C4510: '__unnamed' : default constructor could not be generated
#pragma warning(disable : 4510)
// disable warning C4610: union '__unnamed' can never be instantiated - user defined constructor required
#pragma warning(disable : 4610)
// disable warning C4100: 'di' : unreferenced formal parameter
#pragma warning(disable : 4100)
// disable warning C4244: '=' : conversion from 'int' to 'unsigned short', possible loss of data
#pragma warning(disable : 4244)
// disable warning C4310: case truncates constant value (ATL gets this only on Alpha!)
#pragma warning(disable : 4310)
// disable warning C4505: 'HKeyFromCompoundString' : unreferenced local function has been removed
#pragma warning(disable : 4505)

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define STRICT 1
#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

// defaults for this project..
#define _WINDLL 1

#if defined(_UNICODE) || defined(UNICODE) || defined(OLE2ANSI)
#error The flags you have set will create a build that will \
       either not work on Win95 or not support Unicode.
#error
#endif

#include <atlbase.h>

// turn off ATL debugging, always
#undef _ATL_DEBUG_QI
// AddField messages can be so numerous, we have a separate flag
// for them..
#undef TDC_ATL_DEBUG_ADDFIELD
#ifdef _DEBUG
#define TDC_ATL_DEBUG
#endif

//#define MemAlloc(a) CoTaskMemAlloc((a))
//#define MemFree(a) CoTaskMemFree((a))
//#define MemRealloc(a,b) (((*(a) = CoTaskMemRealloc(*(a),(b))) ? S_OK : E_FAIL))

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

void ClearInterfaceFn(IUnknown ** ppUnk);

template <class PI>
inline void
ClearInterface(PI * ppI)
{
#ifdef _DEBUG
    IUnknown * pUnk = *ppI;
    _ASSERTE((void *) pUnk == (void *) *ppI);
#endif

    ClearInterfaceFn((IUnknown **) ppI);
}

#ifdef TDC_ATL_DEBUG
#define OutputDebugStringX(X) OutputDebugString(X)
#else
#define OutputDebugStringX(X)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\tdc\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\tdc\tarray.h ===
//+-----------------------------------------------------------------------
//
//  Template Array Implementation
//  Copyright (C) Microsoft Corporation, 1996, 1997
//
//  File:      tarray.h
//
//  Contents:  Template for resizeable arrays.  Allows for the creation
//             and manipulation of arrays of any type.  Arrays can
//             be dynamically reallocated, and thus can "grow and shrink".
//             Constructors and destructors of array elements is
//             automatically handles, even when the size of the array is
//             changed.
//  Templates: TSTDArray
//
//------------------------------------------------------------------------

#ifndef _TARRAY_H_
#define _TARRAY_H_



//+-----------------------------------------------------------------------
//
//  Class:     TSTDArray
//
//  Synopsis:  Contains an array of "type".  Allows array to grow
//             dynamically.  During debug, can check bounds on indices.
//             Array is indexed 0 to _cArraySize-1.  _cArraySize holds
//               number of elements.
//
//  Methods:   Init          allocate memory for array
//             Passivate
//             []            allows indexing of array
//             GetSize       returns size of array
//             InsertElems   insert elements anywhere in array
//             DeleteElems   delete elements anywhere in array
//
//------------------------------------------------------------------------

template <class TYPE>
class TSTDArray
{
public:
    TSTDArray();
#if DBG == 1
    ~TSTDArray();
#endif
    HRESULT Init(const size_t cSize); // initialize data structures
    void Passivate();

    TYPE& operator[](const size_t iElement);
    const TYPE& operator[](const size_t iElement) const; // constant reference
    size_t GetSize() const { return _cArraySize; }

    HRESULT InsertElems(const size_t iElem, const size_t cElems);
    void DeleteElems(const size_t iElem, const size_t cElems);

private:
#if DBG == 1
    void IsValidObject() const;
#else
    void IsValidObject() const
        {   }
#endif

// All elements are packaged inside a class CElem.  This allows us to
//   overload the new operator so that we can manually invoke the
//   constructors.

    class CElem
    {
        friend TSTDArray;
    private:
        // Now we overload the new operator to allow placement argument
        void *operator new(size_t uSize, void *pv) { return pv; }

        // Internal data:
        TYPE _Element;       // actual element
    };

// Internal data:
    CElem *_paArray;        // pointer to actual data
    size_t _cArraySize;
    size_t _cAllocSize;     // the size of allocated object

#if DBG == 1
    // Ensure we call constructors and destructors right number of times.
    //   Used only as a check.
    size_t _cNumElems;
#endif
};


//+---------------------------------------------------------------------------
//
//  Member:     IsValidObject
//
//  Synopsis:   Validation method.  Checks that array structure is valid.
//              It is usefull to call this member function at the beginning
//              of each member function that uses the internal array to
//              ensure that the array is not corrupt before attempting to
//              modify it.
//

#if DBG == 1
template <class TYPE>
void
TSTDArray<TYPE>::IsValidObject() const
{
    _ASSERT("Must have valid this pointer" &&
           this );

    _ASSERT("Array has no memory" &&
           _paArray );

    _ASSERT("destructors called wrong number of times" &&
           (_cNumElems == _cArraySize) );
}
#endif


//+-----------------------------------------------------------------------
//
//  Constructor for TSTDArray
//
//  Synopsis:  Doesn't do anything.  Must call member function init to
//             actually initialize.  Only call init once.
//
//  Arguments: None.
//
//  Returns:   Nothing.
//

template <class TYPE>
TSTDArray<TYPE>::TSTDArray()
{
// We null the internal data, so that they are not actually used
// until the init member function is called.

    _paArray = 0;
    _cArraySize = 0;
    _cAllocSize = 0;

#if DBG == 1
    _cNumElems = 0;
#endif
}


//+-----------------------------------------------------------------------
//
//  Destructor for TSTDArray
//
//  Synopsis:  Must call member function passivate
//             to actually de-initialize.
//
//  Arguments: None.
//
//  Returns:   Nothing.
//

#if DBG == 1
template <class TYPE>
TSTDArray<TYPE>::~TSTDArray()
{
    _ASSERT("Passivate must be called first" &&
           !_paArray );

    _ASSERT("Destructors called wrong number of times" &&
           (_cNumElems == 0) );
}
#endif


//+-----------------------------------------------------------------------
//
//  Member:    Init
//
//  Synopsis:  Initializes the array abstract data type.  Allocates
//             memory for the array.  Also sets the cArraySize to
//             the number of elements.
//
//  Arguments: cSize    initial size of array (# of elements)
//
//  Returns:   Success if memory can be allocated for table.
//             Returns E_OUTOFMEMORY if can't get memory.
//

template <class TYPE>
HRESULT
TSTDArray<TYPE>::Init(const size_t cSize)
{
    HRESULT hr;

    _ASSERT(this);

    _ASSERT("Only call init once" &&
           !_paArray );

// Get memory:

    // 0 element array is made into 1 element array so that it functions
    //   normally.
    {
        //;begin_internal
        // BUGBUG:
        // MSVC 2.0 has a bug in it.  Evaluating the expression sizeof(CElem)
        //   seems to confuse it.  CElem is a class containing a variable
        //   whose size can only be calculated when the template containing it
        //   is instantiated.  In addition to this, CElem is a member of that
        //   template.  Placing the sizeof(CElem) expression within a more
        //   complicated expression is not possible.
        //;end_internal
        size_t uCElemSize;

        uCElemSize = sizeof(CElem);
        uCElemSize *= (cSize == 0 ? 1 : cSize);
        _paArray = (CElem *) CoTaskMemAlloc(uCElemSize);
    }
    if (!_paArray)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        CElem *pTemp;                   // index used to call constructors

        // We need to call the constructors manually for each element:
        for (pTemp = _paArray; pTemp < _paArray + cSize; pTemp++)
        {
            new (pTemp) CElem;
#if DBG == 1
            _cNumElems++;
#endif
        }

        _cArraySize = cSize;
        _cAllocSize = (cSize == 0 ? 1 : cSize);
        hr = S_OK;
    }

    return hr;
}


//+-----------------------------------------------------------------------
//
//  Member:    Passivate
//
//  Synopsis:  Releases memory held in array.  Should be called before
//             the object is destroyed.  Should only be called once on an
//             object.
//
//  Arguments: None.
//
//  Returns:   Nothing.
//
//------------------------------------------------------------------------

template <class TYPE>
void
TSTDArray<TYPE>::Passivate()
{
    IsValidObject();

    _ASSERT("Only call Passivate once" &&
           _paArray );

    // We need to call the destructors manually for each element:

    {
        CElem *pTemp;                   // index used to call destructors

        for (pTemp = _paArray; pTemp < _paArray + _cArraySize; pTemp++)
        {
            pTemp->CElem::~CElem();
#if DBG == 1
            _cNumElems--;
#endif
        }
    }

    CoTaskMemFree(_paArray);

    _paArray = 0;         // make sure we don't call Passivate again
    _cArraySize = 0;
    _cAllocSize = 0;
}


//+-----------------------------------------------------------------------
//
//  Member:    operator[]
//
//  Synopsis:  Allows indexing of array's elements.  Use this to either
//             store an element in the array or read an element from
//             the array.  It is the user's responsibility to ensure
//             that the index is within the proper range, 0.._cArraySize-1.
//             During debugging, the index range is checked.
//
//  Arguments: iElement       Element index
//
//  Returns:   Reference to element.
//

template <class TYPE>
inline
TYPE&
TSTDArray<TYPE>::operator[](const size_t iElement)
{
    IsValidObject();

    _ASSERT("Index is out of range" &&
           (iElement < _cArraySize) );

    return _paArray[iElement]._Element;
}


//+-----------------------------------------------------------------------
//
//  Member:    operator[] const
//
//  Synopsis:  Same as previous [] operator, but returns a constant
//             reference so that it can't be used as an l-value.
//
//  Arguments: iElement       Element index
//
//  Returns:   Constant reference to element.
//

template <class TYPE>
inline
const TYPE&
TSTDArray<TYPE>::operator[](const size_t iElement) const
{
    IsValidObject(this);

    _ASSERT("Index is out of range" &&
           (iElement < _cArraySize) );

    return _paArray[iElement]._Element;
}


//+-----------------------------------------------------------------------
//
//  Member:    InsertElems
//
//  Synopsis:  Changes the size of the array by using MemRealloc().
//             Inserts a number of elements cElems into the array at
//             iElem.  This can be used to add new elements to the end of
//             the array by specifying iElem equal to _cArraySize.  It is
//             the responsibility of the user to make sure that iElem is
//             within the proper bounds of the array, although this will
//             be checked during debug mode.
//
//  Arguments: iElem       place to insert first element
//             cElems      number of new elements
//
//  Returns:   Returns success if elements can be added.
//             Returns E_OUTOFMEMORY if request cannot be met.
//             Array retains its old size if the request cannot be met.
//

template<class TYPE>
HRESULT
TSTDArray<TYPE>::InsertElems(const size_t iElem, const size_t cElems)
{
    HRESULT hr = S_OK;

    // Note that you can insert past the END of an array (appending to it):
    _ASSERT("iElem is too large" &&
           (iElem <= _cArraySize) );

    if (_cArraySize + cElems > _cAllocSize)
    {
        // Resize the current array we have:
        ULONG cAllocSize = _cAllocSize ? _cAllocSize : 8;
        CElem * paArray;                // new array

        // Double alloc size until it's big enough.  This will, I suppose, loop
        // forever if someone asks to allocate more than 2^31 elements.
        _ASSERT(_cArraySize + cElems < MAXLONG);
        while (_cArraySize + cElems > cAllocSize) cAllocSize <<= 1;

        paArray = (CElem *)CoTaskMemRealloc(_paArray, sizeof(CElem) * cAllocSize);

        if (!paArray)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }

        _paArray = paArray;
        _cAllocSize = cAllocSize;
    }


    IsValidObject();

    // Now we have to shift elements to allow space for the new elements:
    memmove(_paArray + iElem + cElems,      // dest
            _paArray + iElem,
            (_cArraySize - iElem) * sizeof(CElem));

    // Call constructors on all new elements:
    {
        CElem *pTemp;   // index used to call constructors

        for (pTemp = _paArray + iElem;
             pTemp < _paArray + iElem + cElems;
             pTemp++)
        {
            new (pTemp) CElem;
#if DBG == 1
            _cNumElems++;
#endif
        }
    }
    
    _cArraySize += cElems;

Error:
    return hr;
}


//+-----------------------------------------------------------------------
//
//  Member:    DeleteElems
//
//  Synopsis:  Deletes a number of elements cElems from the array at
//             iElem.  It is the responsibility of the user to make sure
//             that the region to be deleted is within the proper bounds
//             of the array, although this will be checked during
//             debug mode.
//
//  Arguments: iElem       place to delete first element
//             cElems      number of elements to delete
//
//  Returns:   Returns success.
//

template<class TYPE>
void
TSTDArray<TYPE>::DeleteElems(const size_t iElem, const size_t cElems)
{
    IsValidObject();

    _ASSERT("Region to delete is too large" &&
           (iElem+cElems-1 < _cArraySize) );


    // First we need to call destructors on elements:
    {
        CElem *pTemp;   // index used to call destructors

        for (pTemp = _paArray + iElem;
             pTemp < _paArray + iElem + cElems;
             pTemp++)
        {
            pTemp->CElem::~CElem();
#if DBG == 1
            _cNumElems--;
#endif
        }
    }

    // Now we need to shift the remaining elements in:
    memmove(_paArray + iElem,                // dest
            _paArray + iElem + cElems,
            (_cArraySize - (iElem + cElems)) * sizeof(CElem));

    _cArraySize -= cElems;
}


#endif  // _TARRAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\tdc\notify.cpp ===
//+-----------------------------------------------------------------------
//
//  TDC / STD Notifications
//  Copyright (C) Microsoft Corporation, 1996, 1997
//
//  File:       Notify.cpp
//
//  Contents:   Implementation of the CEventBroker class.
//              This class translates internal TDC / STD events into
//              appropriate notifications for the external world.
//
//------------------------------------------------------------------------

#include "stdafx.h"
#include <simpdata.h>
#include "TDC.h"
#include <MLang.h>
#include "Notify.h"
#include "TDCParse.h"
#include "TDCArr.h"
#include "SimpData.h"
#include "TDCIds.h"
#include "TDCCtl.h"


//------------------------------------------------------------------------
//
//  Method:    CEventBroker()
//
//  Synopsis:  Class constructor
//
//  Arguments: None
//
//------------------------------------------------------------------------

CEventBroker::CEventBroker(CTDCCtl *pReadyStateControl)
{
    m_cRef = 1;
    m_pSTDEvents = NULL;
// ;begin_internal
    m_pDATASRCListener = NULL;
// ;end_internal
    m_pDataSourceListener = NULL;
    m_pBSC = NULL;

    //  Can't AddRef this control, since it has a ref on this object;
    //  would lead to circular refs & zombie objects.
    //
    m_pReadyStateControl = pReadyStateControl;

    // When we're born, we'd better be born READYSTATE_COMPLETE.
    // If and when a query starts, we can go READYSTATE_LOADED.
    m_lReadyState = READYSTATE_COMPLETE;
}

CEventBroker::~CEventBroker()
{

    SetDataSourceListener(NULL);
// ;begin_internal
    SetDATASRCListener(NULL);
// ;end_internal
    SetSTDEvents(NULL);
}

//+-----------------------------------------------------------------------
//
//  Method:    AddRef()
//
//  Synopsis:  Implements part of the standard IUnknown COM interface.
//               (Adds a reference to this COM object)
//
//  Arguments: None
//
//  Returns:   Number of references to this COM object.
//
//+-----------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CEventBroker::AddRef ()
{
    return ++m_cRef;
}


//+-----------------------------------------------------------------------
//
//  Method:    Release()
//
//  Synopsis:  Implements part of the standard IUnknown COM interface.
//               (Removes a reference to this COM object)
//
//  Arguments: None
//
//  Returns:   Number of remaining references to this COM object.
//             0 if the COM object is no longer referenced.
//
//+-----------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CEventBroker::Release ()
{
    ULONG retval;

    retval = --m_cRef;

    if (m_cRef == 0)
    {
        m_cRef = 0xffff;
        delete this;
    }

    return retval;
}

//------------------------------------------------------------------------
//
//  Method:    GetReadyState()
//
//  Synopsis:  Returns the current ReadyState in the supplied pointer.
//
//  Arguments: plReadyState    Pointer to space to hold ReadyState result
//
//  Returns:   S_OK indicating success.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::GetReadyState(LONG *plReadyState)
{
    *plReadyState = m_lReadyState;
    return S_OK;
}

//------------------------------------------------------------------------
//
//  Method:    UpdateReadySTate()
//
//  Synopsis:  Update our ReadyState and FireOnChanged iif it changed
//
//  Arguments: lReadyState    new ReadyState
//
//  Returns:   S_OK indicating success.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::UpdateReadyState(LONG lReadyState)
{
    // If we're actually stopping something, then fire READYSTATE_COMPLETE
    if (m_lReadyState != lReadyState)
    {
        m_lReadyState = lReadyState;
        if (m_pReadyStateControl != NULL)
        {
            m_pReadyStateControl->FireOnChanged(DISPID_READYSTATE);
            m_pReadyStateControl->FireOnReadyStateChanged();
        }
    }

    return S_OK;
}

//------------------------------------------------------------------------
//
//  Method:    SetDataSourceListener()
//
//  Synopsis:  Sets the COM object which should receive DATASRC
//             notification events.
//
//  Arguments: pDataSourceLIstener  Pointer to COM object to receive notification
//                               events, or NULL if no notifications to be sent.
//
//  Returns:   S_OK indicating success.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::SetDataSourceListener(DataSourceListener *pDataSourceListener)
{
    // If we've changed/reset the data source listener, make sure we don't
    // think we've fired dataMemberChanged on it yet.
    ClearInterface(&m_pDataSourceListener);

    if (pDataSourceListener != NULL)
    {
        m_pDataSourceListener = pDataSourceListener;
        m_pDataSourceListener->AddRef();
    }
    return S_OK;
}

// ;begin_internal
//------------------------------------------------------------------------
//
//  Method:    SetDATASRCListener()
//
//  Synopsis:  Sets the COM object which should receive DATASRC
//             notification events.
//
//  Arguments: pDATASRCLIstener  Pointer to COM object to receive notification
//                               events, or NULL if no notifications to be sent.
//
//  Returns:   S_OK indicating success.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::SetDATASRCListener(DATASRCListener *pDATASRCListener)
{
    // If we've changed/reset the data source listener, make sure we don't
    // think we've fired dataMemberChanged on it yet.
    ClearInterface(&m_pDATASRCListener);

    if (pDATASRCListener != NULL)
    {
        m_pDATASRCListener = pDATASRCListener;
        m_pDATASRCListener->AddRef();
    }
    return S_OK;
}
// ;end_internal

//------------------------------------------------------------------------
//
//  Method:    SetSTDEvents()
//
//  Synopsis:  Sets the COM object which should receive DATASRC
//             notification events.
//
//  Arguments: pSTDEvents     Pointer to COM object to receive notification
//                            events, or NULL if no notifications to be sent.
//
//  Returns:   S_OK indicating success.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::SetSTDEvents(OLEDBSimpleProviderListener *pSTDEvents)
{
    ClearInterface(&m_pSTDEvents);

    if (pSTDEvents != NULL)
    {
        m_pSTDEvents = pSTDEvents;
        m_pSTDEvents->AddRef();
    }
    return S_OK;
}

//------------------------------------------------------------------------
//
//  Method:    aboutToChangeCell()
//
//  Synopsis:  Notifies anyone who wants to know that a particular cell
//             is about to change.
//
//  Arguments: iRow           Row number of the cell that has changed.
//             iCol           Column number of the cell that has changed.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::aboutToChangeCell(LONG iRow, LONG iCol)
{
    HRESULT hr = S_OK;

    _ASSERT(iRow >= 0);
    _ASSERT(iCol >= 1);
    if (m_pSTDEvents != NULL)
        hr = m_pSTDEvents->aboutToChangeCell(iRow, iCol);
    return hr;
}

//------------------------------------------------------------------------
//
//  Method:    CellChanged()
//
//  Synopsis:  Notifies anyone who wants to know that a particular cell
//             has changed.
//
//  Arguments: iRow           Row number of the cell that has changed.
//             iCol           Column number of the cell that has changed.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::cellChanged(LONG iRow, LONG iCol)
{
    HRESULT hr = S_OK;

    _ASSERT(iRow >= 0);
    _ASSERT(iCol >= 1);
    if (m_pSTDEvents != NULL)
        hr = m_pSTDEvents->cellChanged(iRow, iCol);
    return hr;
}

//------------------------------------------------------------------------
//
//  Method:    RowChanged()
//
//  Synopsis:  Notifies anyone who wants to know that a particular row
//             has changed.
//
//  Arguments: iRow           Number of the row that has changed.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::RowChanged(LONG iRow)
{
    HRESULT hr = S_OK;

    _ASSERT(iRow >= 0);
    if (m_pSTDEvents != NULL)
        hr = m_pSTDEvents->cellChanged(iRow, -1);
    return hr;
}

//------------------------------------------------------------------------
//
//  Method:    ColChanged()
//
//  Synopsis:  Notifies anyone who wants to know that a particular column
//             has changed.
//
//  Arguments: iCol           Number of the column that has changed.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::ColChanged(LONG iCol)
{
    HRESULT hr = S_OK;

    _ASSERT(iCol > 0);
    if (m_pSTDEvents != NULL)
        hr = m_pSTDEvents->cellChanged(-1, iCol);
    return hr;
}

//------------------------------------------------------------------------
//
//  Method:    aboutToDeleteRows()
//
//  Synopsis:  Notifies anyone who wants to know that a some rows
//             have been deleted.
//
//  Arguments: iRowStart      Number of row on which deletion started.
//             iRowCount      Number of rows deleted.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::aboutToDeleteRows(LONG iRowStart, LONG iRowCount)
{
    HRESULT hr = S_OK;

    _ASSERT(iRowStart >= 0);
    _ASSERT(iRowCount > 0);
    if (m_pSTDEvents != NULL)
        hr = m_pSTDEvents->aboutToDeleteRows(iRowStart, iRowCount);
    return hr;
}

//------------------------------------------------------------------------
//
//  Method:    deletedRows()
//
//  Synopsis:  Notifies anyone who wants to know that a some rows
//             have been deleted.
//
//  Arguments: iRowStart      Number of row on which deletion started.
//             iRowCount      Number of rows deleted.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::deletedRows(LONG iRowStart, LONG iRowCount)
{
    HRESULT hr = S_OK;

    _ASSERT(iRowStart >= 0);
    _ASSERT(iRowCount > 0);
    if (m_pSTDEvents != NULL)
        hr = m_pSTDEvents->deletedRows(iRowStart, iRowCount);
    return hr;
}

//------------------------------------------------------------------------
//
//  Method:    aboutToInsertRows()
//
//  Synopsis:  Notifies anyone who wants to know that a some rows
//             have been inserted.
//
//  Arguments: iRowStart      Number of row on which insertion started.
//             iRowCount      Number of rows inserted.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::aboutToInsertRows(LONG iRowStart, LONG iRowCount)
{
    HRESULT hr = S_OK;

    _ASSERT(iRowStart >= 0);
    _ASSERT(iRowCount > 0);
    if (m_pSTDEvents != NULL)
            m_pSTDEvents->aboutToInsertRows(iRowStart, iRowCount);
    return hr;
}

//------------------------------------------------------------------------
//
//  Method:    insertedRows()
//
//  Synopsis:  Notifies anyone who wants to know that a some rows
//             have been inserted.
//
//  Arguments: iRowStart      Number of row on which insertion started.
//             iRowCount      Number of rows inserted.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::insertedRows(LONG iRowStart, LONG iRowCount)
{
    HRESULT hr = S_OK;

    _ASSERT(iRowStart >= 0);
    _ASSERT(iRowCount > 0);
    if (m_pSTDEvents != NULL)
            m_pSTDEvents->insertedRows(iRowStart, iRowCount);
    return hr;
}


//------------------------------------------------------------------------
//
//  Method:    rowsAvailable()
//
//  Synopsis:  Notifies anyone who wants to know that a some rows
//             have arrived.  Although this is very similar to insertedRows
//             we want to preserve the distinction between rows that
//             arrive on the wire and an insert operation that might be
//             performed while some data is still downloading.
//
//  Arguments: iRowStart      Number of row on which insertion started.
//             iRowCount      Number of rows inserted.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::rowsAvailable(LONG iRowStart, LONG iRowCount)
{
    HRESULT hr = S_OK;

    _ASSERT(iRowStart >= 0);
    _ASSERT(iRowCount > 0);
    if (m_pSTDEvents != NULL)
        hr = m_pSTDEvents->rowsAvailable(iRowStart, iRowCount);
    return hr;
}

// ;begin_internal
#ifdef NEVER
//------------------------------------------------------------------------
//
//  Method:    DeletedCols()
//
//  Synopsis:  Notifies anyone who wants to know that a some columns
//             have been deleted.
//
//  Arguments: iColStart      Number of column on which deletion started.
//             iColCount      Number of columns deleted.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::DeletedCols(LONG iColStart, LONG iColCount)
{
    HRESULT hr = S_OK;

    _ASSERT(iColStart > 0);
    _ASSERT(iColCount > 0);
    if (m_pSTDEvents != NULL)
        hr = m_pSTDEvents->DeletedColumns(iColStart, iColCount);
    return hr;
}

//------------------------------------------------------------------------
//
//  Method:    InsertedCols()
//
//  Synopsis:  Notifies anyone who wants to know that a some columns
//             have been inserted.
//
//  Arguments: iColStart      Number of column on which insertion started.
//             iColCount      Number of columns inserted.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::InsertedCols(LONG iColStart, LONG iColCount)
{
    HRESULT hr = S_OK;

    _ASSERT(iColStart > 0);
    _ASSERT(iColCount > 0);
    if (m_pSTDEvents != NULL)
        hr = m_pSTDEvents->InsertedColumns(iColStart, iColCount);
    return hr;
}
#endif
// ;end_internal

//------------------------------------------------------------------------
//
//  Method:    STDLoadStarted()
//
//  Synopsis:  Notifies anyone who wants to know that the STD control
//             has begun loading its data.
//
//  Arguments: pBSC      Pointer to data-retrieval object.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::STDLoadStarted(CComObject<CMyBindStatusCallback<CTDCCtl> > *pBSC, boolean fAppending)
{
    HRESULT hr = S_OK;

    m_pBSC = pBSC;
    return hr;
}

//------------------------------------------------------------------------
//
//  Method:    STDLoadCompleted()
//
//  Synopsis:  Notifies anyone who wants to know that the STD control
//             has loaded all of its data.
//             Note this function should be idempotent -- i.e. it may be
//             called more than once in synchronous cases, once when the
//             transfer actually completes, and again as soon as the event
//             sink is actually hooked up in order to fire the transferComplete
//             event.
//
//  Arguments: None.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::STDLoadCompleted()
{
    HRESULT hr = S_OK;

    m_pBSC = NULL;
    if (m_pSTDEvents != NULL)
        hr = m_pSTDEvents->transferComplete(OSPXFER_COMPLETE);
    UpdateReadyState(READYSTATE_COMPLETE);
    return hr;
}

//------------------------------------------------------------------------
//
//  Method:    STDLoadStopped()
//
//  Synopsis:  Notifies anyone who wants to know that the STD control
//             has aborted the data load operation.
//
//  Arguments: OSPXFER giving reason for stop
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::STDLoadStopped()
{
    HRESULT hr = S_OK;

    if (m_pBSC && m_pBSC->m_spBinding)
    {
        hr = m_pBSC->m_spBinding->Abort();
        m_pBSC = NULL;
    }

    // Right now, any error results in not returning an STD object,
    // therefore we should not fire transfer complete.
    if (m_pSTDEvents)
        hr = m_pSTDEvents->transferComplete(OSPXFER_ABORT);

    UpdateReadyState(READYSTATE_COMPLETE);

    return hr;
}

//------------------------------------------------------------------------
//
//  Method:    STDLoadedHeader()
//
//  Synopsis:  Notifies anyone who wants to know that the STD control
//             has loaded its header row.
//
//  Arguments: None.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::STDLoadedHeader()
{
    HRESULT hr = S_OK;

    hr = STDDataSetChanged();

    UpdateReadyState(READYSTATE_INTERACTIVE);
    return hr;
}

//------------------------------------------------------------------------
//
//  Method:    STDSortFilterCompleted()
//
//  Synopsis:  Notifies anyone who wants to know that the STD control
//             has refiltered / resorted its data.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CEventBroker::STDDataSetChanged()
{
    HRESULT hr = S_OK;

    if (m_pDataSourceListener != NULL)
        hr = m_pDataSourceListener->dataMemberChanged(NULL);
// ;begin_internal
    if (m_pDATASRCListener != NULL)
        hr = m_pDATASRCListener->datasrcChanged(NULL, TRUE);
// ;end_internal
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\tdc\tdcarr.cpp ===
//+-----------------------------------------------------------------------
//
//  Tabular Data Control Array
//  Copyright (C) Microsoft Corporation, 1996, 1997
//
//  File:       TDCArr.cpp
//
//  Contents:   Implementation of the CTDCArr object.
//              This class forms the heart of the Tabular Data Control.
//              It provides the core 2D array of variant values, plus
//              a (possibly filtered/sorted) view of this data for
//              presentation through an ISimpleTabularData interface.
//
//------------------------------------------------------------------------

#include "stdafx.h"
#include "wch.h"
#include <simpdata.h>
#include "TDC.h"
#include <MLang.h>
#include "Notify.h"
#include "TDCParse.h"
#include "TDCArr.h"
#include "TDCIds.h"

//------------------------------------------------------------------------
//
//  Function:  fWCHIsSpace()
//
//  Synopsis:  Indicates whether a WCHAR is considered a space character
//
//  Arguments: wch      Character to test
//
//  Returns:   TRUE/FALSE indicating whether the given character is
//             considered a space.
//
//------------------------------------------------------------------------

inline boolean fWCHIsSpace(WCHAR wch)
{
    return (wch == L' ' || wch == L'\t');
}


//------------------------------------------------------------------------
//
//  Function:  fWCHEatTest()
//
//  Synopsis:  Advances a string pointer over a given test character.
//
//  Arguments: ppwch      Pointer to string to test
//             wch        Match character
//
//  Returns:   TRUE indicating the character matched and the pointer has
//               been advanceed
//             FALSE indicating no match (character pointer left unchanged)
//
//------------------------------------------------------------------------

inline boolean fWCHEatTest(LPWCH *ppwch, WCHAR wch)
{
    if (**ppwch != wch)
        return FALSE;
    (*ppwch)++;
    return TRUE;
}


//------------------------------------------------------------------------
//
//  Function:  fWCHEatSpace()
//
//  Synopsis:  Advances a string pointer over white space.
//
//  Arguments: ppwch      String pointer.
//
//  Returns:   Nothing.
//
//------------------------------------------------------------------------

inline void fWCHEatSpace(LPWCH *ppwch)
{
    while (fWCHIsSpace(**ppwch))
        (*ppwch)++;
}


//------------------------------------------------------------------------
//
//  Method:    CTDCArr()
//
//  Synopsis:  Class constructor.  Due to the COM model, the
//             member function "Create" should be called to actually
//             initialise the STD data structures.
//
//  Arguments: None.
//
//------------------------------------------------------------------------

CTDCArr::CTDCArr() : m_cRef(1)
{
    m_pEventBroker = NULL;
    m_pSortList = NULL;
    m_bstrSortExpr = NULL;
    m_pFilterTree = NULL;
    m_bstrFilterExpr = NULL;
}

//------------------------------------------------------------------------
//
//  Member:    Init()
//
//  Synopsis:  Initialises the internal data.
//
//  Arguments: pEventBroker       Object to delegate notifications to.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCArr::Init(CEventBroker *pEventBroker, IMultiLanguage *pML)
{
    HRESULT hr = S_OK;

    hr = m_arrparrCells.Init(0);
    if (SUCCEEDED(hr))
        hr = m_arrparrFilter.Init(0);
    if (SUCCEEDED(hr))
        hr = m_arrColInfo.Init(0);
    m_iFilterRows = CalcFilterRows();
    m_iDataRows = CalcDataRows();
    m_iCols = CalcCols();
    m_fLastFilter = FALSE;
    m_fSortFilterDisrupted = FALSE;
    m_state = LS_UNINITIALISED;
    m_lcid = GetUserDefaultLCID();
    m_lcidRead = m_lcid;
    _ASSERT(pEventBroker != NULL);

    m_pEventBroker = pEventBroker;
    m_pEventBroker->AddRef();           // better not be called with NULL

    m_pML = pML;
    m_pML->AddRef();

    m_fAsync = FALSE;                   // assume non-asynch for error cases
    return hr;
}


//------------------------------------------------------------------------
//
//  Member:    ~CTDCArr()
//
//  Synopsis:  Destructor for CTDCArr
//
//------------------------------------------------------------------------

CTDCArr::~CTDCArr()
{
    for (LONG iRow = CalcDataRows(); iRow >= 0; iRow--)
    {
        m_arrparrCells[iRow]->Passivate();
        delete m_arrparrCells[iRow];
    }
    m_arrparrCells.Passivate();
    m_arrparrFilter.Passivate();
    m_arrColInfo.Passivate();
    if (m_pSortList != NULL)
        delete m_pSortList;
    SysFreeString(m_bstrSortExpr);
    if (m_pFilterTree != NULL)
        delete m_pFilterTree;
    SysFreeString(m_bstrFilterExpr);

    if (m_pEventBroker)
    {
        m_pEventBroker->Release();
        m_pEventBroker = NULL;
    }

    ClearInterface(&m_pML);
}

LONG CTDCArr::CalcDataRows()
{
    return m_arrparrCells.GetSize() - 1;
}

LONG CTDCArr::CalcFilterRows()
{
    return m_arrparrFilter.GetSize() - 1;
}

LONG CTDCArr::CalcCols()
{
    return m_arrparrCells.GetSize() > 0
                ? m_arrparrCells[0]->GetSize() : 0;
}

//------------------------------------------------------------------------
//
//  Member:    GetRowCount()
//
//  Synopsis:  Retrieves the number of rows in the table.
//
//  Arguments: pcRows          pointer to number of rows    (OUT)
//
//  Returns:   S_OK to indicate success.
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCArr::getRowCount(DBROWCOUNT *pcRows)
{
    *pcRows = m_iFilterRows;
    return S_OK;
}

//------------------------------------------------------------------------
//
//  Member:    GetColumnCount()
//
//  Synopsis:  Retrieves the number of column in the table.
//
//  Arguments: pcCols       pointer to number of columns (OUT)
//
//  Returns:   S_OK to indicate success.
//             E_UNEXPECTED if the table has not been loaded yet.
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCArr::getColumnCount(DB_LORDINAL *pcCols)
{
    *pcCols = m_iCols;
    return S_OK;
}

//------------------------------------------------------------------------
//
//  Member:    GetRWStatus()
//
//  Synopsis:  Gets the read/write status of a cell, row, column or the
//             entire array.  Since this implementation of STD can never
//             set the read/write status of a cell anywhere, all data
//             cells are presumed to have the default access and all
//             column heading cells are presumed to be read-only.  Therefore,
//             it is not necessary to keep track of this information in
//             individual cells, and this function need only return
//             the value OSPRW_DEFAULT.
//
//  Arguments: iRow            row index (-1 means all rows)
//             iCols           column index (-1 means all columns)
//             prwStatus       pointer to read/write status (OUT)
//
//  Returns:   S_OK if indices are correct (prwStatus set).
//             E_INVALIDARG if indices are out of bounds.
//             E_UNEXPECTED if the table has not been loaded yet.
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCArr::getRWStatus(DBROWCOUNT iRow, DB_LORDINAL iCol, OSPRW *prwStatus)
{
    HRESULT hr  = S_OK;

    if ((fValidFilterRow(iRow) || iRow == -1) &&
        (fValidCol(iCol) || iCol == -1))
    {
        if (iRow == -1)
        {
            //  Should return READONLY if there is only a label row,
            //  but frameworks tend to get confused if they want to
            //  later insert data.
            //
//          *prwStatus = m_iDataRows > 0 ? OSPRW_MIXED : OSPRW_READONLY;
            *prwStatus = OSPRW_MIXED;
        }
        else if (iRow == 0)
            *prwStatus = OSPRW_READONLY;
        else
            *prwStatus = OSPRW_DEFAULT;
    }
    else
        hr = E_INVALIDARG;
    return hr;
}

//------------------------------------------------------------------------
//
//  Member:    GetVariant()
//
//  Synopsis:  Retrieves a variant value for a cell.
//
//  Arguments: iRow            row index
//             iCols           column index
//             format          output format
//             pVar            pointer to storage for resulting value
//
//  Returns:   S_OK upon success (contents of pVar set).
//             E_INVALIDARG if indices are out of bounds.
//             E_UNEXPECTED if the table has not been loaded yet.
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCArr::getVariant(DBROWCOUNT iRow, DB_LORDINAL iCol, OSPFORMAT format, VARIANT *pVar)
{
    HRESULT hr  = S_OK;

    if (fValidFilterCell(iRow, iCol))
    {
        CTDCCell    *pCell  = GetFilterCell(iRow, iCol);

        if (format == OSPFORMAT_RAW)
        {
            //  Copy the raw variant value
            //
            hr = VariantCopy(pVar, pCell);
        }
        else if (format == OSPFORMAT_FORMATTED || format == OSPFORMAT_HTML)
        {
            //  Construct a BSTR value representing the cell
            //
            if (pCell->vt == VT_BOOL)
            {
                //  For OLE DB spec compliance:
                //    VariantChangeTypeEx converts booleans in BSTR "0", "-1".
                //    This code yields BSTR "False", "True" instead.
                //
                VariantClear(pVar);
                pVar->vt = VT_BSTR;
                hr = VarBstrFromBool(pCell->boolVal, m_lcid, 0, &pVar->bstrVal);
            }
            else
            {
                hr = VariantChangeTypeEx(pVar, pCell, m_lcid, 0, VT_BSTR);
            }
            if (!SUCCEEDED(hr))
            {
                VariantClear(pVar);
                pVar->vt = VT_BSTR;
                pVar->bstrVal = SysAllocString(L"#Error");
            }
        }
        else
            hr = E_INVALIDARG;
    }
    else
        hr = E_INVALIDARG;

    return hr;
}

//------------------------------------------------------------------------
//
//  Member:    SetVariant()
//
//  Synopsis:  Sets a cell's variant value from a given variant value.
//             The given variant type is coerced into the column's
//             underlying type.
//
//  Arguments: iRow            row index
//             iCols           column index
//             format          output format
//             Var             value to be stored in the cell.
//
//  Returns:   S_OK upon success (contents of pVar set).
//             E_INVALIDARG if indices are out of bounds.
//             E_UNEXPECTED if the table has not been loaded yet.
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCArr::setVariant(DBROWCOUNT iRow, DB_LORDINAL iCol, OSPFORMAT format, VARIANT Var)
{
    HRESULT hr;

    if (fValidFilterCell(iRow, iCol))
    {
        CTDCCell    *pCell  = GetFilterCell(iRow, iCol);
        CTDCColInfo *pColInfo   = GetColInfo(iCol);

        if (format == OSPFORMAT_RAW ||
            format == OSPFORMAT_FORMATTED || format == OSPFORMAT_HTML)
        {
            if (m_pEventBroker != NULL)
            {
                hr = m_pEventBroker->aboutToChangeCell(iRow, iCol);
                if (!SUCCEEDED(hr))
                    goto Cleanup;
            }

            if (Var.vt == pColInfo->vtType)
                hr = VariantCopy(pCell, &Var);
            else
            {
                //  For OLE DB spec compliance:
                //    VariantChangeTypeEx converts booleans in BSTR "0", "-1".
                //    This code yields BSTR "False", "True" instead.
                //
                if (Var.vt == VT_BOOL && pColInfo->vtType==VT_BSTR)
                {
                    VariantClear(pCell);
                    pCell->vt = VT_BSTR;
                    hr = VarBstrFromBool(Var.boolVal, m_lcid, 0, &pCell->bstrVal);
                }
                else
                    hr = VariantChangeTypeEx(pCell, &Var, m_lcid,
                                             0, pColInfo->vtType);
            }
            if (SUCCEEDED(hr) && m_pEventBroker != NULL)
                hr = m_pEventBroker->cellChanged(iRow, iCol);
            m_fSortFilterDisrupted = TRUE;
        }
        else
            hr = E_INVALIDARG;
    }
    else
        hr = E_INVALIDARG;

Cleanup:
    return hr;
}

//------------------------------------------------------------------------
//
//  Member:    GetLocale()
//
//  Synopsis:  Returns the locale of our data.
//
//  Arguments: Returns a BSTR, representing an RFC1766 form string for our
//             locale.  Note this may not necessarily match our LANGUAGE
//             param, if we had one, because teh string is canoncialized
//             by using MLang to convert it to an LCID and back to a string
//             again.
//
//  Returns:   S_OK to indicate success.
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCArr::getLocale(BSTR *pbstrLocale)
{
    return m_pML->GetRfc1766FromLcid(m_lcid, pbstrLocale);
}


//+-----------------------------------------------------------------------
//
//  Member:    DeleteRows
//
//  Synopsis:  Used to delete rows from the table.  Bounds are checked
//             to make sure that the rows can all be deleted.  Label row
//             cannot be deleted.
//
//  Arguments: iRow            first row to delete
//             cRows           number of rows to delete
//             pcRowsDeleted   actual number of rows deleted (OUT)
//
//  Returns:   S_OK upon success, i.e. all rows could be deleted
//             E_INVALIDARG if cRows < 0 or any rows to be deleted
//               are out of bounds
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCArr::deleteRows(DBROWCOUNT iRow, DBROWCOUNT cRows, DBROWCOUNT *pcRowsDeleted)
{
    HRESULT hr;
    *pcRowsDeleted = 0;

    if (fValidFilterRow(iRow) && iRow > 0 && cRows >= 0 &&
        fValidFilterRow(iRow + cRows - 1))
    {
        if (m_pEventBroker != NULL)
        {
            hr = m_pEventBroker->aboutToDeleteRows(iRow, cRows);
            if (!SUCCEEDED(hr))
                goto Cleanup;
        }

        *pcRowsDeleted = cRows;
        hr = S_OK;
        if (cRows > 0)
        {
            //  Delete the rows from the array
            //
            m_arrparrFilter.DeleteElems(iRow, cRows);
            m_iFilterRows = CalcFilterRows();

            m_fSortFilterDisrupted = TRUE;
            //  Notify the event-handler of the deletion
            //
            if (m_pEventBroker != NULL)
                hr = m_pEventBroker->deletedRows(iRow, cRows);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }
Cleanup:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    InsertRows()
//
//  Synopsis:  Allows for the insertion of new rows.  This can either be
//             used to insert new rows between existing rows, or to
//             append new rows to the end of the table.  Thus, to
//             insert new rows at the end of the table, a user would
//             specify the initial row as 1 greater than the current
//             row dimension.
//             Note that iRow is checked to ensure that it is within the
//             proper bounds (1..<current # of rows>+1).
//             User cannot delete column heading row.
//
//  Arguments: iRow            rows will be inserted *before* row 'iRow'
//             cRows           how many rows to insert
//             pcRowsInserted  actual number of rows inserted (OUT)
//
//  Returns:   S_OK upon success, i.e. all rows could be inserted.
//             E_INVALIDARG if row is out of allowed bounds.
//             It is possible that fewer than the requested rows were
//             inserted.  In this case, E_OUTOFMEMORY would be returned,
//             and the actual number of rows inserted would be set.
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCArr::insertRows(DBROWCOUNT iRow, DBROWCOUNT cRows, DBROWCOUNT *pcRowsInserted)
{
    HRESULT hr  = S_OK;
    TSTDArray<CTDCCell> **pRows = NULL;
    LONG    iTmpRow;

    //  Verify that the insertion row is within range
    //
    if (iRow < 1 || iRow > m_iFilterRows + 1)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (cRows <= 0)
    {
        if (cRows < 0)
            hr = E_INVALIDARG;
        goto Cleanup;
    }

    //  Unless success is complete, assume 0 rows inserted.
    //
    *pcRowsInserted = 0;

    //  Allocate a temporary array of rows
    //
    pRows = new TSTDArray<CTDCCell>* [cRows];
    if (pRows == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    memset(pRows, '\0', sizeof(pRows[0]) * cRows);

    for (iTmpRow = 0; iTmpRow < cRows; iTmpRow++)
    {
        if ((pRows[iTmpRow] = new TSTDArray<CTDCCell>) == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto CleanupTmpRows;
        }
        hr = pRows[iTmpRow]->InsertElems(0, m_iCols);
        if (!SUCCEEDED(hr))
            goto CleanupTmpRows;
    }


    //  Expand the Cell-Rows and Filter-Rows arrays to cope with the new rows.
    //
    _ASSERT(m_iFilterRows <= m_iDataRows);
    hr = m_arrparrCells.InsertElems(iRow, cRows);
    if (!SUCCEEDED(hr))
        goto CleanupTmpRows;
    hr = m_arrparrFilter.InsertElems(iRow, cRows);
    if (!SUCCEEDED(hr))
    {
        //  Undo the previous allocation
        //
        m_arrparrCells.DeleteElems(iRow, cRows);
        goto CleanupTmpRows;
    }

    if (m_pEventBroker != NULL)
    {
        hr = m_pEventBroker->aboutToInsertRows(iRow, cRows);
        if (FAILED(hr))
            goto CleanupTmpRows;
    }

    //  Copy across the row pointers
    //
    for (iTmpRow = 0; iTmpRow < cRows; iTmpRow++)
    {
        m_arrparrCells[iRow + iTmpRow] = pRows[iTmpRow];
        m_arrparrFilter[iRow + iTmpRow] = pRows[iTmpRow];
    }

    //  Return indicating success
    //
    *pcRowsInserted = cRows;
    m_iFilterRows = CalcFilterRows();;
    m_iDataRows = CalcDataRows();

    // Fire events:
    if (*pcRowsInserted != 0)
    {
        m_fSortFilterDisrupted = TRUE;
        if (m_pEventBroker != NULL)
            hr = m_pEventBroker->insertedRows(iRow, cRows);
    }
    goto Cleanup;

CleanupTmpRows:
    //  Free the memory associated with the tmp rows.
    //
    for (iTmpRow = 0; iTmpRow < cRows; iTmpRow++)
        if (pRows[iTmpRow] != NULL)
            delete pRows[iTmpRow];

Cleanup:
    if (pRows != NULL)
        delete pRows;
    return hr;
}

// ;begin_internal
//+-----------------------------------------------------------------------
//
//  Member:    DeleteColumns()
//
//  Synopsis:  Used to delete columns from the table.  Bounds are checked
//             to make sure that the columns can all be deleted.  Label
//             column cannot be deleted.
//
//  Arguments: iCol               first column to delete
//             cCols              number of columns to delete
//             pcColsDeleted      actual number of rows deleted (OUT)
//
//  Returns:   S_OK upon succes, i.e. all columns could be deleted
//             E_INVALIDARG if column is out of allowed bounds.
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCArr::DeleteColumns(DB_LORDINAL iCol, DB_LORDINAL cCols, DB_LORDINAL *pcColsDeleted)
{
    HRESULT hr;

    if (fValidCol(iCol) && iCol > 0 && cCols >= 0 &&
        fValidCol(iCol + cCols - 1))
    {
        *pcColsDeleted = cCols;
        hr = S_OK;
        if (cCols > 0)
        {
            for (LONG iRow = 0; iRow < m_iFilterRows; iRow++)
            {
                TSTDArray<CTDCCell> *pRow;

                pRow = m_arrparrCells[iRow];
                pRow->DeleteElems(iCol - 1, cCols);
            }
            m_arrColInfo.DeleteElems(iCol - 1, cCols);
            m_iCols = CalcCols();

            if (!m_fUseHeader)
                RenumberColumnHeadings();

            m_fSortFilterDisrupted = TRUE;

            //  Notify the event-handler of the deletion
            //
#ifdef NEVER
            if (m_pEventBroker != NULL)
                hr = m_pEventBroker->DeletedCols(iCol, cCols);
#endif
        }
        _ASSERT(m_arrColInfo.GetSize() == (ULONG) m_iCols);
    }
    else
    {
        hr = E_INVALIDARG;
        *pcColsDeleted = 0;
    }
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    InsertColumns()
//
//  Synopsis:  Allows for the insertion of new columns.  This can either be
//             used to insert new columns between existing columns, or to
//             append new columns to the end of the table.  Thus, to
//             insert new columns at the end of the table, a user would
//             specify the initial columns as 1 greater than the current
//             columns dimension.
//             Note that iColumn is checked to ensure that it is within the
//             proper bounds (1..<current # of cols>+1).
//
//  Arguments: iCol            columns will be inserted *before* row 'iCol'
//             cCols           how many columns to insert
//             pcColsInserted  actual number of columns inserted (OUT)
//
//  Returns:   S_OK upon success, i.e. all columns could be inserted.
//             E_INVALIDARG if column is out of allowed bounds.
//             It is possible that fewer than the requested columns were
//             inserted.  In this case, E_OUTOFMEMORY would be returned,
//             and the actual number of columns inserted would be set.
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCArr::InsertColumns(DB_LORDINAL iCol, DB_LORDINAL cCols, DB_LORDINAL *pcColsInserted)
{
    HRESULT hr  = S_OK;
    LONG iTmpRow;

    //  Verify that the insertion column is within range
    //
    if (iCol < 1 || iCol > m_iCols + 1)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (cCols <= 0)
    {
        if (cCols < 0)
            hr = E_INVALIDARG;
        goto Cleanup;
    }

    //  Unless success is complete, assume 0 columns inserted.
    //
    *pcColsInserted = 0;

    for (iTmpRow = 0; iTmpRow <= m_iDataRows; iTmpRow++)
    {
        hr = m_arrparrCells[iTmpRow]->InsertElems(iCol, cCols);
        if (!SUCCEEDED(hr))
        {
            //  Undo the changes we've done
            //
            while (--iTmpRow >= 0)
                m_arrparrCells[iTmpRow]->DeleteElems(iCol, cCols);
            goto Cleanup;
        }
    }

    //  Return indicating success
    //
    *pcColsInserted = cCols;
    m_iCols = CalcCols();

    // Fire events:
    if (*pcColsInserted != 0)
    {
        m_fSortFilterDisrupted = TRUE;
#ifdef NEVER
        if (m_pEventBroker != NULL)
            hr = m_pEventBroker->InsertedCols(iCol, cCols);
#endif
    }

Cleanup:
    //  If we're using automatically numbered column headings and some
    //  columns were inserted, then renumber the columns.
    //
    if (*pcColsInserted > 0 && !m_fUseHeader)
        RenumberColumnHeadings();

    return hr;
}
// ;end_internal

//+-----------------------------------------------------------------------
//
//  Member:    Find()
//
//  Synopsis:  Searches for a row matching the specified criteria
//
//  Arguments: iRowStart       The starting row for the search
//             iCol            The column being tested
//             vTest           The value against which cells in the
//                               test column are tested
//             findFlags       Flags indicating whether to search up/down
//                               and whether comparisons are case sensitive.
//             compType        The comparison operator for matching (find a
//                             cell =, >=, <=, >, <, <> the test value)
//             piRowFound      The row with a matching cell [OUT]
//
//  Returns:   S_OK upon success, i.e. a row was found (piRowFound set).
//             E_FAIL upon failure, i.e. a row was not found.
//             E_INVALIDARG if starting row 'iRowStart' or test column 'iCol'
//               are out of bounds.
//             DISP_E_TYPEMISMATCH if the test value's type does not match
//               the test column's type.
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCArr::find(DBROWCOUNT iRowStart, DB_LORDINAL iCol, VARIANT vTest,
        OSPFIND findFlags, OSPCOMP compType, DBROWCOUNT *piRowFound)
{
    HRESULT hr = S_OK;
    boolean fUp = FALSE;
    boolean fCaseSensitive  = FALSE;
    LONG    iRow;

    *piRowFound = -1;

    //  Validate arguments
    //
    if (iRowStart < 1 || !fValidFilterRow(iRowStart) || !fValidCol(iCol))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (GetColInfo(iCol)->vtType != vTest.vt)
    {
        //  Search-value type does not match the underlying column type
        //  Fail as per spec.
        //
        hr = DISP_E_TYPEMISMATCH;
        goto Cleanup;
    }

    if ((findFlags & OSPFIND_UP) != 0)
        fUp = TRUE;
    if ((findFlags & OSPFIND_CASESENSITIVE) != 0)
        fCaseSensitive = TRUE;

    for (iRow = iRowStart;
         fUp ? iRow > 0 : iRow <= m_iFilterRows;
         fUp ? iRow-- : iRow++)
    {
        int         iCmp = VariantComp(GetFilterCell(iRow, iCol), &vTest, vTest.vt, fCaseSensitive);
        boolean     fFound  = FALSE;

        switch (compType)
        {
        case OSPCOMP_LT:    fFound = iCmp <  0; break;
        case OSPCOMP_LE:    fFound = iCmp <= 0; break;
        case OSPCOMP_GT:    fFound = iCmp >  0; break;
        case OSPCOMP_GE:    fFound = iCmp >= 0; break;
        case OSPCOMP_EQ:    fFound = iCmp == 0; break;
        case OSPCOMP_NE:    fFound = iCmp != 0; break;
        default:
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        if (fFound)
        {
            *piRowFound = iRow;
            hr = S_OK;
            goto Cleanup;
        }
    }

    hr = E_FAIL;

Cleanup:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    addOLEDBSimpleProviderListener()
//
//  Synopsis:  Sets or clears a reference to the COM object which receives
//             notifications of cell changes, row/column insert/deletes etc.
//
//  Arguments: pEvent          Pointer to the COM object to receive
//                             notifications, or NULL if no notifications
//                             are to be sent.
//
//  Returns:   S_OK upon success.
//             Error code upon success.
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCArr::addOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pSTDEvents)
{
    HRESULT hr = S_OK;

    if (m_pEventBroker == NULL)
        hr = E_FAIL;
    else
    {
        hr = m_pEventBroker->SetSTDEvents(pSTDEvents);
        // If the event sink has been added, and we're already loaded,
        // then fire transferComplete, because we probably couldn't before.
        if (LS_LOADED==m_state)
            m_pEventBroker->STDLoadCompleted();
    }
    return hr;
}

STDMETHODIMP
CTDCArr::removeOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pSTDEvents)
{
    HRESULT hr = S_OK;

    if (m_pEventBroker && pSTDEvents==m_pEventBroker->GetSTDEvents())
        hr = m_pEventBroker->SetSTDEvents(NULL);
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    FindCol()
//
//  Synopsis:  Locate a column by name
//
//  Arguments: pwchColName        Name of column to locate
//
//  Returns:   +ve Column number upon success (column name matched)
//             0 upon failure (no column name matched)
//
//------------------------------------------------------------------------

LONG
CTDCArr::FindCol(LPWCH pwchColName)
{
    LONG iCol = 0;

    if (pwchColName != NULL)
    {
        for (iCol = m_iCols; iCol > 0; iCol--)
        {
            CTDCCell    *pCell  = GetDataCell(0, iCol);

            _ASSERT(pCell->vt == VT_BSTR);
            if (wch_icmp(pwchColName, pCell->bstrVal) == 0)
                break;
        }
    }
    return iCol;
}

class SortElt
{
public:
    CTDCArr *pInstance;
    int     iRow;
    TSTDArray<CTDCCell> *   parrRow;
};

//+-----------------------------------------------------------------------
//
//  Function:  CompareSort()
//
//  Synopsis:  Called by qsort() to order the rows of a table.
//
//  Arguments: pElt1, pElt1       pointers to elements to be compared
//
//  Returns:   -1 if the first element is less than the second element
//              0 if the first element equals the second element
//             +1 if the first element is greater than the second element
//
//------------------------------------------------------------------------

static int __cdecl
CompareSort(const void *pElt1, const void *pElt2)
{
    SortElt *pse1   = (SortElt *) pElt1;
    SortElt *pse2   = (SortElt *) pElt2;

    return pse1->pInstance->SortComp(pse1->iRow, pse2->iRow);
}

//+-----------------------------------------------------------------------
//
//  Function:  extract_num()
//
//  Synopsis:  Extracts the first non-negative number from the character
//             stream referenced by 'ppwch'.  Updates 'ppwch' to point
//             to the character following the digits found.
//
//  Arguments: ppwch      Pointer to null-terminated WCHAR string
//
//  Returns:   Non-negative number extracted upon success (pointer updated)
//             -1 upon failure (no digits found; pointer moved to end-of-string
//
//+-----------------------------------------------------------------------

static int
extract_num(WCHAR **ppwch)
{
    int retval  = 0;
    boolean fFoundDigits    = FALSE;

    if (*ppwch != NULL)
    {
        //  Skip over leading non-digits
        //
        while ((**ppwch) != 0 && ((**ppwch) < L'0' || (**ppwch) > L'9'))
            (*ppwch)++;

        //  Accumulate digits
        //
        fFoundDigits = *ppwch != 0;
        while ((**ppwch) >= L'0' && (**ppwch) <= L'9')
            retval = 10 * retval + *(*ppwch)++ - L'0';
    }

    return fFoundDigits ? retval : -1;
}


//+-----------------------------------------------------------------------
//
//  Member:    CreateNumberedColumnHeadings()
//
//  Synopsis:  Allocates cells for numbered column headings.
//
//  Arguments: None.
//
//  Returns:   S_OK upon success.
//             E_OUTOFMEMORY if there was insufficient memory to complete
//             the operation.
//
//------------------------------------------------------------------------

HRESULT CTDCArr::CreateNumberedColumnHeadings()
{
    HRESULT hr  = S_OK;
    LONG    iCol;

    iCol = m_iCols;

    //  Allocate a new row entry
    //
    hr = m_arrparrCells.InsertElems(0, 1);
    if (!SUCCEEDED(hr))
        goto Cleanup;

    //  Allocate a new row of cells
    //
    m_arrparrCells[0] = new TSTDArray<CTDCCell>;
    if (m_arrparrCells[0] == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    hr = m_arrparrCells[0]->InsertElems(0, iCol);

Cleanup:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    RenumberColumnHeadings()
//
//  Synopsis:  Set the automatic name "Column<column-number>" for each column
//
//  Arguments: None.
//
//  Returns:   Nothing.
//
//------------------------------------------------------------------------

void CTDCArr::RenumberColumnHeadings()
{
    for (LONG iCol = m_iCols; iCol > 0; iCol--)
    {
        CTDCCell    *pCell  = GetDataCell(0, iCol);
        WCHAR       awchLabel[20];

        wch_cpy(awchLabel, L"Column");
        _ltow(iCol, &awchLabel[6], 10);

        pCell->clear();
        pCell->vt = VT_BSTR;
        pCell->bstrVal = SysAllocString(awchLabel);
    }
}

//+-----------------------------------------------------------------------
//
//  Member:    ParseColumnHeadings()
//
//  Synopsis:  Extracts type information (if present) from column
//             headings, removes leadning
//
//  Arguments: None.
//
//  Returns:   S_OK upon success.
//             E_OUTOFMEMORY if there was insufficient memory to complete
//             the operation.
//
//------------------------------------------------------------------------

HRESULT CTDCArr::ParseColumnHeadings()
{
    LPWCH   pwchIntType     = L"int";
    LPWCH   pwchFloatType   = L"float";
    LPWCH   pwchStringType  = L"string";
    LPWCH   pwchBooleanType = L"boolean";
    LPWCH   pwchDateType    = L"date";

    HRESULT hr  = S_OK;
    LONG    iCol;

    iCol = m_iCols;

    //  Allocate space for column type info
    //
    hr = m_arrColInfo.InsertElems(0, iCol);
    if (!SUCCEEDED(hr))
        goto Cleanup;

    for (; iCol > 0; iCol--)
    {
        //  Column headings have the format:
        //      <column-name>[:<typename>[,<format>]]
        //
        CTDCColInfo *pColInfo   = GetColInfo(iCol);
        CTDCCell    *pCell      = GetDataCell(0, iCol);

        _ASSERT(pCell->vt == VT_BSTR);

        BSTR        bstr;
        LPWCH       pColon;

        bstr = pCell->bstrVal;
        pColInfo->vtType = VT_BSTR;     //  Default type for a column is BSTR
        pColon = wch_chr(bstr, L':');
        if (pColon != NULL)
        {
            WCHAR   *pwchFormat = NULL;
            LPWCH   pSpace;

            *pColon++ = 0;
            pSpace = wch_chr(pColon, L' ');

            if (pSpace != NULL)
            {
                *pSpace++ = '\0';
                pwchFormat = pSpace;
            }
            if (wch_icmp(pColon, pwchIntType) == 0)
                pColInfo->vtType = VT_I4;
            else if (wch_icmp(pColon, pwchFloatType) == 0)
                pColInfo->vtType = VT_R8;
            else if (wch_icmp(pColon, pwchStringType) == 0)
                pColInfo->vtType = VT_BSTR;
            else if (wch_icmp(pColon, pwchBooleanType) == 0)
                pColInfo->vtType = VT_BOOL;
            else if (wch_icmp(pColon, pwchDateType) == 0)
            {
                pColInfo->vtType = VT_DATE;

                TDCDateFmt  fmt = TDCDF_NULL;

                if (pwchFormat != NULL)
                {
                    int nPos    = 0;
                    int nDayPos = 0;
                    int nMonPos = 0;
                    int nYearPos= 0;

                    //  Convert the format string into an internal enum type
                    //  Find the relative positions of the letters 'D' 'M' 'Y'
                    //
                    for (; *pwchFormat != 0; nPos++, pwchFormat++)
                    {
                        switch (*pwchFormat)
                        {
                        case L'D':
                        case L'd':
                            nDayPos = nPos;
                            break;
                        case L'M':
                        case L'm':
                            nMonPos = nPos;
                            break;
                        case L'Y':
                        case L'y':
                            nYearPos = nPos;
                            break;
                        }
                    }
                    //  Compare the relative positions to work out the format
                    //
                    if (nDayPos < nMonPos && nMonPos < nYearPos)
                        fmt = TDCDF_DMY;
                    else if (nMonPos < nDayPos && nDayPos < nYearPos)
                        fmt = TDCDF_MDY;
                    else if (nDayPos < nYearPos && nYearPos < nMonPos)
                        fmt = TDCDF_DYM;
                    else if (nMonPos < nYearPos && nYearPos < nDayPos)
                        fmt = TDCDF_MYD;
                    else if (nYearPos < nMonPos && nMonPos < nDayPos)
                        fmt = TDCDF_YMD;
                    else if (nYearPos < nDayPos && nDayPos < nMonPos)
                        fmt = TDCDF_YDM;
                }
                pColInfo->datefmt = fmt;
            }
        }

        if (bstr != NULL)
        {
            //  Remove leading/trailing spaces from column name
            //
            LPWCH       pwch;
            LPWCH       pwchDest = NULL;
            LPWCH       pLastNonSpace = NULL;

            for (pwch = bstr; *pwch != 0; pwch++)
            {
                if (!fWCHIsSpace(*pwch))
                {
                    if (pwchDest == NULL)
                        pwchDest = bstr;
                    pLastNonSpace = pwchDest;
                }
                if (pwchDest != NULL)
                    *pwchDest++ = *pwch;
            }
            if (pLastNonSpace == NULL)
                bstr[0] = 0;        // all spaces!  Make it null string.
            else
                pLastNonSpace[1] = 0;
        }

        //  Copy the modified column header and free the original
        //
        pCell->bstrVal = SysAllocString(bstr);
        SysFreeString(bstr);

        if (pCell->bstrVal == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }
Cleanup:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    VariantFromBSTR()
//
//  Synopsis:  Convert a BSTR value into a variant compatible with a
//             given column type.
//
//  Arguments: pVar       Pointer to resultant variant value
//             bstr       Source BSTR
//             pColInfo   Column information (type, format options etc).
//             lcid       Locale # for locale-specific conversion.
//
//  Returns:   S_OK upon success (pVar set)
//             OLE_E_CANTCONVERT if the given BSTR is badly formatted
//               (e.g. contains an invalid date value for a date conversion).
//             E_OUTOFMEMORY if insufficient memory is available for
//               a conversion.
//
//------------------------------------------------------------------------

HRESULT CTDCArr::VariantFromBSTR(VARIANT *pVar, BSTR bstr, CTDCColInfo *pColInfo, LCID lcid)
{
    HRESULT hr  = E_FAIL;

    VariantInit(pVar);
    switch (pColInfo->vtType)
    {
    case VT_DATE:
        if (pColInfo->datefmt != TDCDF_NULL)
        {
            //  Parse the date string according to specified format.
            //  First, find the three numeric components in the date.
            //
            USHORT  n1;
            USHORT  n2;
            USHORT  n3;
            WCHAR   *pwch   = bstr;
            SYSTEMTIME  st;

            n1 = (USHORT)extract_num(&pwch);
            n2 = (USHORT)extract_num(&pwch);
            n3 = (USHORT)extract_num(&pwch);

            memset(&st, '\0', sizeof(st));
            switch (pColInfo->datefmt)
            {
            case TDCDF_DMY:
                st.wDay = n1;
                st.wMonth = n2;
                st.wYear = n3;
                break;
            case TDCDF_MDY:
                st.wDay = n2;
                st.wMonth = n1;
                st.wYear = n3;
                break;
            case TDCDF_DYM:
                st.wDay = n1;
                st.wMonth = n3;
                st.wYear = n2;
                break;
            case TDCDF_MYD:
                st.wDay = n3;
                st.wMonth = n1;
                st.wYear = n2;
                break;
            case TDCDF_YMD:
                st.wDay = n3;
                st.wMonth = n2;
                st.wYear = n1;
                break;
            case TDCDF_YDM:
                st.wDay = n2;
                st.wMonth = n3;
                st.wYear = n1;
                break;
            }

            VariantClear(pVar);
            if (n1 >= 0 && n2 >= 0 && n3 >= 0 &&
                SystemTimeToVariantTime(&st, &pVar->date))
            {
                pVar->vt = VT_DATE;
                hr = S_OK;
            }
            else
                hr = OLE_E_CANTCONVERT;
        }
        else
        {
            //  No date format specified - just use the default conversion
            //
            VARIANT vSrc;

            VariantInit(&vSrc);
            vSrc.vt = VT_BSTR;
            vSrc.bstrVal = bstr;
            hr = VariantChangeTypeEx(pVar, &vSrc, lcid, 0, pColInfo->vtType);
        }
        break;
    case VT_BOOL:
    case VT_I4:
    case VT_R8:
    default:
        //
        //  Perform a standard conversion.
        //
        {
            VARIANT vSrc;

            VariantInit(&vSrc);
            vSrc.vt = VT_BSTR;
            vSrc.bstrVal = bstr;
            hr = VariantChangeTypeEx(pVar, &vSrc, lcid, 0, pColInfo->vtType);
        }
        break;
    case VT_BSTR:
        //
        //  Duplicate the BSTR
        //
        pVar->bstrVal = SysAllocString(bstr);
        if (bstr != NULL && pVar->bstrVal == NULL)
            hr = E_OUTOFMEMORY;
        else
        {
            pVar->vt = VT_BSTR;
            hr = S_OK;
        }
        break;
    }
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    VariantComp()
//
//  Synopsis:  Compares two variant values.
//
//  Arguments: pVar1            First variant value
//             pVar2            Second variant value
//             fCaseSensitive   TRUE if string comparisons should be
//                              case-sensitive, false if string comparisons
//                              should be case-insensitive.  Ignored if
//                              non-string data types are being compared.
//
//  Returns:   -1 if
//             OLE_E_CANTCONVERT if the given BSTR is badly formatted
//               (e.g. contains an invalid date value for a date conversion).
//             E_OUTOFMEMORY if insufficient memory is available for
//               a conversion.
//
//------------------------------------------------------------------------

int CTDCArr::VariantComp(VARIANT *pVar1, VARIANT *pVar2, VARTYPE type,
    boolean fCaseSensitive)
{
    int retval = 0;

    //  NULLs are lexically less than anything else
    //
    if (pVar1->vt == VT_NULL)
        retval = pVar2->vt == VT_NULL ? 0 : -1;
    else if (pVar2->vt == VT_NULL)
        retval = 1;
    else if (pVar1->vt != type)
    {
        //  Type-mismatches are lexically greater than anything else
        //
        retval = pVar2->vt == type ? 1 : 0;
    }
    else if (pVar2->vt != type)
    {
        //  Type-mismatches are lexically greater than anything else
        //
        retval = -1;
    }
    else
    {
        switch (type)
        {
        case VT_I4:
            retval = pVar1->lVal < pVar2->lVal
                ? -1
                : pVar1->lVal > pVar2->lVal
                    ? 1
                    : 0;
            break;
        case VT_R8:
            retval = pVar1->dblVal < pVar2->dblVal
                ? -1
                : pVar1->dblVal > pVar2->dblVal
                    ? 1
                    : 0;
            break;
        case VT_BSTR:
            retval = fCaseSensitive
                ? wch_cmp(pVar1->bstrVal, pVar2->bstrVal)
                : wch_icmp(pVar1->bstrVal, pVar2->bstrVal);
            break;
        case VT_BOOL:
            retval = pVar1->boolVal
                ? (pVar2->boolVal ? 0 : 1)
                : (pVar2->boolVal ? -1 : 0);
            break;
        case VT_DATE:
            retval = pVar1->date < pVar2->date
                ? -1
                : pVar1->date > pVar2->date
                    ? 1
                    : 0;
            break;
        default:
            retval = 0;     //  Unrecognised types are all lexically equal
            break;
        }
    }

    return retval;
}

//+-----------------------------------------------------------------------
//
//  Method:    CreateSortList()
//
//  Synopsis:  Creates a list of sort criteria from a text description.
//
//  Arguments: bstrSortCols          ';'-separted list of column names,
//                                   optionally prefixed with '+' (default)
//                                   or '-' indicating ascending or descending
//                                   sort order respectively for that column.
//
//  Returns:   S_OK upon success.
//             E_OUTOFMEMORY if insufficient memory is available for
//               the construction of sort criteria.
//
//  Side Effect:   Saves created list in m_pSortList
//
//+-----------------------------------------------------------------------

HRESULT CTDCArr::CreateSortList(BSTR bstrSortCols)
{
    HRESULT     hr = S_OK;

    if (m_pSortList != NULL)
    {
        delete m_pSortList;
        m_pSortList = NULL;
    }
    if (bstrSortCols != NULL)
    {
        WCHAR   *pwchEnd  = bstrSortCols;
        CTDCSortCriterion   **pLast = &m_pSortList;

        while (*pwchEnd != 0)
        {
            WCHAR   *pwchStart  = pwchEnd;
            boolean fSortAscending = TRUE;

            //  Discard leading white space and field-separators
            //
            while (*pwchStart == L';' || fWCHIsSpace(*pwchStart))
                pwchStart++;

            //  Strip off optional direction indicator + white space
            //
            if (*pwchStart == L'+' || *pwchStart == '-')
            {
                fSortAscending = *pwchStart++ == L'+';
                while (fWCHIsSpace(*pwchStart))
                    pwchStart++;
            }

            //  Find the field terminator.
            //  Strip out trailing white spaces.
            //
            for (pwchEnd = pwchStart; *pwchEnd != 0 && *pwchEnd != L';';)
                pwchEnd++;

            while (pwchStart < pwchEnd && fWCHIsSpace(pwchEnd[-1]))
                pwchEnd--;

            //  Ignore blank column names - this could be the result of
            //  a leading or trailing ';'.
            //
            if (pwchStart >= pwchEnd)
                continue;

            //  Find the column number from the column name
            //
            BSTR bstrColName = SysAllocStringLen(pwchStart, pwchEnd - pwchStart);

            if (bstrColName == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            LONG iCol = FindCol(bstrColName);
            SysFreeString(bstrColName);

            if (iCol > 0)
            {
                //  Allocate a node for this criterion
                //
                _ASSERT(*pLast == NULL);
                *pLast = new CTDCSortCriterion;
                if (*pLast == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }
                (*pLast)->m_fSortAscending = fSortAscending;
                (*pLast)->m_iSortCol = iCol;
                pLast = &(*pLast)->m_pNext;
            }
        }
    }

Cleanup:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Method:    SortComp()
//
//  Synopsis:  Compares two rows using the elememts in the columns specified
//             by the current sort criteria.
//
//  Arguments: iRow1      Index of first row being compared
//             iRow2      Index of second row being compared
//
//  Returns:   -1 if first row should be sorted before the second row
//             0 if rows are equal
//             1 if first row should be sorted after the second row
//
//+-----------------------------------------------------------------------

int CTDCArr::SortComp(LONG iRow1, LONG iRow2)
{
    CTDCSortCriterion   *pCriterion;
    int     cmp = 0;

    for (pCriterion = m_pSortList;
         pCriterion != NULL && cmp == 0;
         pCriterion = pCriterion->m_pNext)
    {
        CTDCCell    *pCell1 = GetFilterCell(iRow1, pCriterion->m_iSortCol);
        CTDCCell    *pCell2 = GetFilterCell(iRow2, pCriterion->m_iSortCol);

        cmp = VariantComp(pCell1, pCell2, GetColInfo(pCriterion->m_iSortCol)->vtType,
                         m_fCaseSensitive);
        if (!pCriterion->m_fSortAscending)
            cmp = -cmp;
    }
    return cmp;
}

//+-----------------------------------------------------------------------
//
//  Method:    FilterParseComplex()
//
//  Synopsis:  Takes the text of a filter query, parses it and creates
//             a tree of CTDCFilterNode representing the query.
//
//  Arguments: phr: pointer to HRESULT value, set to indicate success/failure.
//
//             ppwchQuery:  This is a textual representation of a query.  The
//                          query language syntax is:
//
//               Query ::== Complex
//
//               Complex ::== Simple
//                       ::== Simple '&' Simple ( '&' Simple ... )
//                       ::== Simple '|' Simple ( '|' Simple ... )
//
//               Simple ::== '(' Complex ')'
//                      ::== Atom Relop Atom
//
//               Relop ::== '=' | '>' | '>=' | '<' | '<=' | '<>'
//
//               Atom ::== Bunch of characters up to a (, ), >, <, =, & or |
//                         If it's recognisable as field name, then it's
//                         treated as a field name.  Otherwise it's treated
//                         as a value.  Quotes (") are processed, and force
//                         the atom to be treated as a value.  Escape
//                         characters (\) are processed and allow the
//                         use of special characters within a field name.
//
//               Notes:
//               -----
//                  * The definition of 'Complex' expressly forbids mixing
//                    logical ANDs and ORs ('&' and '|') unless parentheses
//                    are used to clarify the query.  Something like:
//                          field1 > 2 & field3 = "lime" | field4 < 5
//                    is illegal, but:
//                          (field1 > 2 & field3 = "lime") | field4 < 5
//                    is fine.
//
//                  * It is illegal to attempt a comparison of two columns
//                    with different types.
//
//
//  Returns:   Pointer to parsed Filter Node upon success (*phr set to S_OK)
//             NULL upon failure (*phr set to an appropriate error code)
//
//+-----------------------------------------------------------------------

CTDCFilterNode *CTDCArr::FilterParseComplex(LPWCH *ppwchQuery, HRESULT *phr)
{
    *phr = S_OK;
    CTDCFilterNode  *retval;
    WCHAR   wchBoolOp   = 0;

    retval = FilterParseSimple(ppwchQuery, phr);

    //  Stop if there's an error, or we encounter a terminating ')' or '\0'
    //
    while (retval != NULL && **ppwchQuery != L')' && **ppwchQuery != 0)
    {
        //  Next character should be a matching logical connector ...
        //
        if (**ppwchQuery != L'&' && **ppwchQuery != L'|')
        {
            *phr = E_FAIL;
            break;
        }
        if (wchBoolOp == 0)
            wchBoolOp = **ppwchQuery;
        else if (wchBoolOp != **ppwchQuery)
        {
            *phr = E_FAIL;
            break;
        }
        (*ppwchQuery)++;
        CTDCFilterNode *pTmp = new CTDCFilterNode;
        if (pTmp == NULL)
        {
            *phr = E_OUTOFMEMORY;
            break;
        }
        pTmp->m_type = (wchBoolOp == L'&')
            ? CTDCFilterNode::NT_AND
            : CTDCFilterNode::NT_OR;
        pTmp->m_pLeft = retval;
        retval = pTmp;
        retval->m_pRight = FilterParseSimple(ppwchQuery, phr);
        if (retval->m_pRight == NULL)
            break;
    }
    if (!SUCCEEDED(*phr) && retval != NULL)
    {
        delete retval;
        retval = NULL;
    }
    return retval;
}

CTDCFilterNode *CTDCArr::FilterParseSimple(LPWCH *ppwch, HRESULT *phr)
{
    *phr = S_OK;
    CTDCFilterNode  *retval = NULL;

    fWCHEatSpace(ppwch);    //  Eat up white space

    if (fWCHEatTest(ppwch, L'('))
    {
        retval = FilterParseComplex(ppwch, phr);
        if (retval != NULL)
        {
            if (fWCHEatTest(ppwch, L')'))
                fWCHEatSpace(ppwch);    //  Eat up white space
            else
                *phr = E_FAIL;
        }
        goto Cleanup;
    }

    retval = FilterParseAtom(ppwch, phr);
    if (retval == NULL)
        goto Cleanup;

    {
        CTDCFilterNode *pTmp = new CTDCFilterNode;
        if (pTmp == NULL)
        {
            *phr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        pTmp->m_pLeft = retval;
        retval = pTmp;
    }

    retval->m_vt = retval->m_pLeft->m_vt;

    //  Get the relational operator
    //
    if (fWCHEatTest(ppwch, L'='))
        retval->m_type = CTDCFilterNode::NT_EQ;
    else if (fWCHEatTest(ppwch, L'>'))
        retval->m_type = fWCHEatTest(ppwch, L'=')
            ? CTDCFilterNode::NT_GE
            : CTDCFilterNode::NT_GT;
    else if (fWCHEatTest(ppwch, L'<'))
        retval->m_type = fWCHEatTest(ppwch, L'=')
                ? CTDCFilterNode::NT_LE
                : fWCHEatTest(ppwch, L'>')
                    ? CTDCFilterNode::NT_NE
                    : CTDCFilterNode::NT_LT;
    else
    {
        *phr = E_FAIL;
        goto Cleanup;
    }

    retval->m_pRight = FilterParseAtom(ppwch, phr);
    if (retval->m_pRight == NULL)
        goto Cleanup;

    if (retval->m_pLeft->m_iCol <= 0 && retval->m_pRight->m_iCol <= 0)
    {
        //  At least one of the atoms being compared must be a column
        //
        //  This condition means we don't have to test for comparison
        //  of two wildcard values.
        //
        *phr = E_FAIL;
        goto Cleanup;
    }

    //  Check type compatibility of atoms
    //
    if (retval->m_pRight->m_vt != retval->m_vt)
    {
        CTDCFilterNode  *pSrc = retval->m_pRight;
        CTDCFilterNode  *pTarg= retval->m_pLeft;

        if (retval->m_pLeft->m_iCol > 0)
        {
            if (retval->m_pRight->m_iCol > 0)
            {
                //  Two columns of incompatible type - can't resolve
                //
                *phr = E_FAIL;
                goto Cleanup;
            }
            pSrc = retval->m_pLeft;
            pTarg = retval->m_pRight;
        }
        _ASSERT(pTarg->m_vt == VT_BSTR);
        _ASSERT(pTarg->m_iCol == 0);
        _ASSERT(pSrc->m_iCol > 0);
        CTDCColInfo *pColInfo = GetColInfo(pSrc->m_iCol);
        _ASSERT(pColInfo->vtType == pSrc->m_vt);
        VARIANT vtmp;
        VariantInit(&vtmp);
        *phr = VariantFromBSTR(&vtmp, pTarg->m_value.bstrVal, pColInfo, m_lcid);
        if (!SUCCEEDED(*phr))
            goto Cleanup;
        VariantClear(&pTarg->m_value);
        pTarg->m_value = vtmp;
        pTarg->m_vt = pSrc->m_vt;
        retval->m_vt = pSrc->m_vt;
    }

Cleanup:
    if (!SUCCEEDED(*phr) && retval != NULL)
    {
        delete retval;
        retval = NULL;
    }
    return retval;
}

CTDCFilterNode *CTDCArr::FilterParseAtom(LPOLESTR *ppwch, HRESULT *phr)
{
    *phr = S_OK;
    CTDCFilterNode  *retval = NULL;
    int nQuote  = 0;
    boolean fDone = FALSE;
    LPOLESTR   pwchDest;
    LPOLESTR   pwchLastStrip;

    fWCHEatSpace(ppwch);    //  Eat up white space

    OLECHAR   *pwchTmpBuf = new OLECHAR[wch_len(*ppwch) + 1];
    if (pwchTmpBuf == NULL)
    {
        *phr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pwchDest = pwchTmpBuf;
    pwchLastStrip = pwchTmpBuf;

    while (**ppwch != 0 && !fDone)
        switch (**ppwch)
        {
            case _T('\\'):
            //  Handle escape characters
            //
                if ((*pwchDest++ = *++(*ppwch)) != 0)
                {
                    (*ppwch)++;
                    pwchLastStrip = pwchDest;
                }
                break;
            case _T('"'):
            //  Quotes
            //
                (*ppwch)++;
                pwchLastStrip = pwchDest;
                nQuote++;
                break;
            case _T('>'):
            case _T('<'):
            case _T('='):
            case _T('('):
            case _T(')'):
            case _T('&'):
            case _T('|'):
                fDone = ((nQuote & 1) == 0);
                if (fDone)
                    break;

            default:
                *pwchDest++ = *(*ppwch)++;
        }

    //  Strip off trailing white space
    //
    while (pwchDest > pwchLastStrip && fWCHIsSpace(pwchDest[-1]))
        pwchDest--;
    *pwchDest = 0;

    if ((pwchDest == pwchTmpBuf && nQuote == 0) || (nQuote & 1))
    {
        //  Empty string or mismatched quote
        //
        *phr = E_FAIL;
        goto Cleanup;
    }

    retval = new CTDCFilterNode;
    if (retval == NULL)
    {
        *phr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    retval->m_type = CTDCFilterNode::NT_ATOM;
    retval->m_iCol = nQuote > 0 ? 0 : FindCol(pwchTmpBuf);
    if (retval->m_iCol == 0)
    {
        retval->m_vt = VT_BSTR;
        retval->m_value.vt = VT_BSTR;
        retval->m_value.bstrVal = SysAllocString(pwchTmpBuf);
        if (retval->m_value.bstrVal == NULL)
        {
            *phr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        retval->m_fWildcard = wch_chr(retval->m_value.bstrVal, _T('*')) != NULL;
    }
    else
    {
        retval->m_vt = GetColInfo(retval->m_iCol)->vtType;
        retval->m_fWildcard = FALSE;
    }

Cleanup:
    if (pwchTmpBuf != NULL)
        delete pwchTmpBuf;
    if (!SUCCEEDED(*phr) && retval != NULL)
    {
        delete retval;
        retval = NULL;
    }
    return retval;
}

//+-----------------------------------------------------------------------
//
//  Method:    EvalDataRow()
//
//  Synopsis:  Evaluates the given data row # against the filter query
//             represented by 'pNode'.
//
//  Arguments: iRow      The number of the row to evaluate.
//             pNode     A filter query to the row against.
//
//  Returns:   TRUE if the given row satisfies the filter query.
//             FALSE otherwise.
//
//+-----------------------------------------------------------------------

boolean CTDCArr::EvalDataRow(LONG iRow, CTDCFilterNode *pNode)
{
    boolean retval  = TRUE;
    VARIANT *pVar1;
    VARIANT *pVar2;

    _ASSERT(pNode != NULL);
    switch (pNode->m_type)
    {
    case CTDCFilterNode::NT_AND:
        retval = EvalDataRow(iRow, pNode->m_pLeft) &&
                 EvalDataRow(iRow, pNode->m_pRight);
        break;
    case CTDCFilterNode::NT_OR:
        retval = EvalDataRow(iRow, pNode->m_pLeft) ||
                 EvalDataRow(iRow, pNode->m_pRight);
        break;
    case CTDCFilterNode::NT_EQ:
    case CTDCFilterNode::NT_NE:
    case CTDCFilterNode::NT_LT:
    case CTDCFilterNode::NT_GT:
    case CTDCFilterNode::NT_LE:
    case CTDCFilterNode::NT_GE:
        pVar1 = &pNode->m_pLeft->m_value;
        pVar2 = &pNode->m_pRight->m_value;

        if (pNode->m_pLeft->m_iCol > 0)
            pVar1 = GetDataCell(iRow, pNode->m_pLeft->m_iCol);
        if (pNode->m_pRight->m_iCol > 0)
            pVar2 = GetDataCell(iRow, pNode->m_pRight->m_iCol);

        if ((pNode->m_pLeft->m_fWildcard || pNode->m_pRight->m_fWildcard) &&
            (pNode->m_type == CTDCFilterNode::NT_EQ ||
             pNode->m_type == CTDCFilterNode::NT_NE) &&
             pVar1->vt == VT_BSTR && pVar2->vt == VT_BSTR)
        {
            //  Wildcards are only meaningful in comparing strings
            //  for equlaity / inequality
            //
            VARIANT *pText;
            VARIANT *pPattern;

            if (pNode->m_pLeft->m_fWildcard)
            {
                pPattern = pVar1;
                pText = pVar2;
            }
            else
            {
                pText = pVar1;
                pPattern = pVar2;
            }

            retval = wch_wildcardMatch(pText->bstrVal, pPattern->bstrVal,
                                       m_fCaseSensitive)
                ? (pNode->m_type == CTDCFilterNode::NT_EQ)
                : (pNode->m_type == CTDCFilterNode::NT_NE);
        }
        else
        {
            int     cmp;

            cmp = VariantComp(pVar1, pVar2, pNode->m_vt, m_fCaseSensitive);

            switch (pNode->m_type)
            {
            case CTDCFilterNode::NT_LT:    retval = cmp <  0;  break;
            case CTDCFilterNode::NT_LE:    retval = cmp <= 0;  break;
            case CTDCFilterNode::NT_GT:    retval = cmp >  0;  break;
            case CTDCFilterNode::NT_GE:    retval = cmp >= 0;  break;
            case CTDCFilterNode::NT_EQ:    retval = cmp == 0;  break;
            case CTDCFilterNode::NT_NE:    retval = cmp != 0;  break;
            }
        }
        break;

    default:
        _ASSERT(FALSE);
    }
    return retval;
}

//+-----------------------------------------------------------------------
//
//  Method:    ApplySortFilterCriteria()
//
//  Synopsis:  Resets any filter and sorting criterion for the control to
//             the values specified.  Initiates sort/filter operations
//             if appropriate.
//
//  Arguments: None.
//
//  Returns:   S_OK upon success.
//             E_OUTOFMEMORY if there was insufficient memory to complete
//               the operation.
//
//+-----------------------------------------------------------------------

STDMETHODIMP
CTDCArr::ApplySortFilterCriteria()
{
    HRESULT hr  = S_OK;
    LONG iRow;

    if (!m_fSortFilterDisrupted ||
        m_state == LS_UNINITIALISED ||
        m_state == LS_LOADING_HEADER_UNAVAILABLE)
    {
        //  No change, or can't do anything yet.
        //
        goto Cleanup;
    }

    //  Discard the old parse trees
    //
    if (m_pSortList != NULL)
        delete m_pSortList;
    if (m_pFilterTree != NULL)
        delete m_pFilterTree;

    m_pSortList = NULL;
    m_pFilterTree = NULL;

    //  Discard old filtered rows
    //
    if (m_arrparrFilter.GetSize() > 0)
        m_arrparrFilter.DeleteElems(0, m_arrparrFilter.GetSize());

    //  Create an array of filter rows from the data rows
    //
    hr = m_arrparrFilter.InsertElems(0, m_iDataRows + 1);
    if (!SUCCEEDED(hr))
        goto Cleanup;
    for (iRow = 0; iRow <= m_iDataRows; iRow++)
        m_arrparrFilter[iRow] = m_arrparrCells[iRow];
    m_iFilterRows = CalcFilterRows();

    //  Create the filter parse tree
    //
    if (m_bstrFilterExpr != NULL)
    {
        LPWCH pwchQuery = m_bstrFilterExpr;

        m_pFilterTree = FilterParseComplex(&pwchQuery, &hr);
        if (hr == E_FAIL || (m_pFilterTree != NULL && *pwchQuery != 0))
        {
            //  Parse failed or there were unparsed characters left over.
            //  This gets treated as an 'include everything' filter.
            //
            if (m_pFilterTree != NULL)
            {
                delete m_pFilterTree;
                m_pFilterTree = NULL;
            }
            hr = S_OK;
        }
    }

    //  Filter the rows
    //
    if (m_pFilterTree != NULL)
    {
        LONG    iRowDest    = 1;

        for (iRow = 1; iRow <= m_iFilterRows; iRow++)
            if (EvalDataRow(iRow, m_pFilterTree))
                m_arrparrFilter[iRowDest++] = m_arrparrFilter[iRow];
        if (iRowDest < iRow)
            m_arrparrFilter.DeleteElems(iRowDest, iRow - iRowDest);
        m_iFilterRows = CalcFilterRows();
    }

    //  Create the sort list
    //
    hr = CreateSortList(m_bstrSortExpr);
    if (!SUCCEEDED(hr))
        goto Cleanup;

    //  Sort the filtered rows
    //
    if (m_pSortList != NULL && m_iFilterRows > 0)
    {
        SortElt *pSortArr   = new SortElt[m_iFilterRows + 1];
        if (pSortArr == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        for (iRow = 0; iRow <= m_iFilterRows; iRow++)
        {
            pSortArr[iRow].pInstance = this;
            pSortArr[iRow].iRow = iRow;
            pSortArr[iRow].parrRow = m_arrparrFilter[iRow];
        }

        qsort((void *)&pSortArr[1], m_iFilterRows, sizeof(pSortArr[0]), CompareSort);

        for (iRow = 0; iRow <= m_iFilterRows; iRow++)
            m_arrparrFilter[iRow] = pSortArr[iRow].parrRow;

        delete pSortArr;

    }

    m_fSortFilterDisrupted = FALSE;

    if (m_state == LS_LOADING_HEADER_AVAILABLE && m_iDataRows > 0)
    {
        //  We've just parsed the sort/filter expressions - there
        //  was no data to sort/filter, so dont register a change.
    }
    else
    {
        //  Notify the event-broker of the changes
        //
        if (m_pEventBroker != NULL)
			hr = m_pEventBroker->STDDataSetChanged();
    }

Cleanup:
    return hr;
}


//+-----------------------------------------------------------------------
//
//  Method:    SetSortFilterCriteria()
//
//  Synopsis:  Resets any filter and sorting criterion for the control to
//             the values specified.  Initiates sort/filter operations
//             if any the changes invalidate existing criteria.
//
//  Arguments: bstrSortExpr    List of columns for sorting ("" = no sorting)
//             bstrFilterExpr  Expression for filtering ("" = no filtering)
//
//  Returns:   S_OK upon success.
//             E_OUTOFMEMORY if there was insufficient memory to complete
//               the operation.
//
//+-----------------------------------------------------------------------

STDMETHODIMP
CTDCArr::SetSortFilterCriteria(BSTR bstrSortExpr, BSTR bstrFilterExpr,
                              boolean fCaseSensitive)
{
    HRESULT hr  = S_OK;


    //  Check if we need to reparse the sort/filter criteria
    //

    if (wch_cmp(bstrSortExpr, m_bstrSortExpr) != 0 ||
        wch_cmp(bstrFilterExpr, m_bstrFilterExpr) != 0 ||
        fCaseSensitive != m_fCaseSensitive)
    {
        m_fSortFilterDisrupted = TRUE;
    }
    SysFreeString(m_bstrSortExpr);
    SysFreeString(m_bstrFilterExpr);
    m_bstrSortExpr = bstrSortExpr;
    m_bstrFilterExpr = bstrFilterExpr;
    m_fCaseSensitive = fCaseSensitive;

    //  If not loaded, leave it to the load process to apply any changes
    //
    if (m_state == LS_LOADED)
        hr = ApplySortFilterCriteria();
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Method:    CTDCCStartDataLoad()
//
//  Synopsis:  Preparation for a load operation via FieldSink routines below
//
//  Arguments: fUseHeader      TRUE if the first line of fields should
//                               be interpreted as column name/type info.
//             bstrSortExpr    Sort expression for ordering rows
//             bstrFilterExpr  Filter expression for including/excluding rows
//             lcidRead        Locale ID to use for interpreting locale-
//                               dependent data formats (date, number etc).
//             pBSC            COM object performing the data transfer
//             fAppend         Flag indicating whether the data should be
//                             appended to any existing data.
//
//  Returns:   S_OK indicating success.
//
//+-----------------------------------------------------------------------

STDMETHODIMP
CTDCArr::StartDataLoad(boolean fUseHeader, BSTR bstrSortExpr,
    BSTR bstrFilterExpr, LCID lcidRead,
    CComObject<CMyBindStatusCallback<CTDCCtl> > *pBSC,
    boolean fAppend, boolean fCaseSensitive)
{
    HRESULT hr  = S_OK;

    //  If we're asked to append to existing data AND
    //     - there isn't any OR
    //     - the previous load didn't load a header row
    //  then treat it as an initial load.
    //
    if (fAppend && m_state == LS_UNINITIALISED)
        fAppend = FALSE;

    if (fAppend)
    {
        if (m_state != LS_LOADED || m_iDataRows < 0)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
        m_state = LS_LOADING_HEADER_AVAILABLE;
    }
    else
    {
        if (m_state != LS_UNINITIALISED ||
            m_iDataRows != -1 ||
            m_iFilterRows != -1 ||
            m_iCols != 0)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
        m_state = LS_LOADING_HEADER_UNAVAILABLE;
        m_fSortFilterDisrupted = TRUE;
    }

    SetSortFilterCriteria(bstrSortExpr, bstrFilterExpr,
                         fCaseSensitive);

    m_fUseHeader = fUseHeader;
    m_fSkipRow = fAppend && fUseHeader;
    _ASSERT(m_iFilterRows == CalcFilterRows());
    _ASSERT(m_iDataRows == CalcDataRows());
    _ASSERT(m_iCols == CalcCols());
    m_iCurrRow = m_iDataRows + 1;
    m_iCurrCol = 1;
    m_lcidRead = lcidRead;
    if (m_pEventBroker != NULL)
    hr = m_pEventBroker->STDLoadStarted(pBSC, fAppend);

Cleanup:
    return hr;
}



//////////////////////////////////////////////////////////////////////////
//
//        CTDCFieldSink Methods - see comments in file TDCParse.h
//        ---------------------
//
//////////////////////////////////////////////////////////////////////////

//+-----------------------------------------------------------------------
//
//  Method:    AddField()
//
//  Synopsis:  Adds a data cell to the growing cell grid.
//
//  Arguments: pwch         Wide-char string holding data for the cell
//             dwSize       # of significant bytes in 'pwch'
//
//  Returns:   S_OK indicating success.
//             E_OUTOFMEMORY if there was not enough memory to add the cell.
//
//+-----------------------------------------------------------------------

STDMETHODIMP
CTDCArr::AddField(LPWCH pwch, DWORD dwSize)
{
    _ASSERT(m_state == LS_LOADING_HEADER_UNAVAILABLE ||
            m_state == LS_LOADING_HEADER_AVAILABLE);

    HRESULT hr          = S_OK;
    LONG    nCols       = 0;
    BSTR    bstr        = NULL;

    if (m_fSkipRow)
        goto Cleanup;
#ifdef TDC_ATL_DEBUG_ADDFIELD
    ATLTRACE( _T("CTDCArr::AddField called: %d, %d\n"), m_iCurrRow, m_iCurrCol);
#endif

    if (m_iCurrRow > m_iDataRows && m_iCurrCol == 1)
    {
        TSTDArray<CTDCCell> *pRow;

        //  Need to insert a new row
        //
        _ASSERT(m_iCurrRow == m_iDataRows + 1);
        hr = m_arrparrCells.InsertElems(m_iCurrRow, 1);
        if (!SUCCEEDED(hr))
            goto Cleanup;
        pRow = new TSTDArray<CTDCCell>;
        if (pRow == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        m_arrparrCells[m_iCurrRow] = pRow;
        if (m_iCurrRow > 0)
        {
            //  We've already read at least one row, so we know how
            //  many columns to insert for this row
            //
            hr = m_arrparrCells[m_iCurrRow]->InsertElems(0, m_iCols);
            if (!SUCCEEDED(hr))
                goto Cleanup;
        }
    }
    if (m_iCurrRow == 0)
    {
        //  This is the first row - we don't know how many columns there
        //  will be, so just insert a single cell for this new element.
        //
        _ASSERT(m_iCurrCol == m_iCols + 1);
        hr = m_arrparrCells[m_iCurrRow]->InsertElems(m_iCurrCol - 1, 1);
        if (!SUCCEEDED(hr))
            goto Cleanup;
        m_iCols++;
    }

    if (m_iCurrCol <= m_iCols)
    {
        CTDCCell    *pCell  = GetDataCell(m_iCurrRow, m_iCurrCol);

        pCell->clear();
        pCell->vt = VT_BSTR;

        if (dwSize <= 0)
            pCell->bstrVal = NULL;
        else
        {
            pCell->bstrVal = SysAllocStringLen(pwch, dwSize);
            if (pCell->bstrVal == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }

        if (m_iCurrRow > 0)
        {
            CTDCColInfo *pColInfo = GetColInfo(m_iCurrCol);

            if (pColInfo->vtType != VT_BSTR)
            {
                VARIANT     v;
                HRESULT     hr;

                hr = VariantFromBSTR(&v, pCell->bstrVal, pColInfo, m_lcidRead);
                if (SUCCEEDED(hr))
                {
                    hr = VariantCopy(pCell, &v);
                    VariantClear(&v);
                }
                else
                {
                    //  Leave it as a BSTR
                    //
                    hr = S_OK;
                }
            }
        }
    }

    m_iCurrCol++;

Cleanup:
    return hr;
}

// InsertionSortHelper -
//  returns -1 if the candidate row < current filter array row
//           0 if the candidate row = current filter array row
//           1 if the candidate row > current filter array row

int
CTDCArr::InsertionSortHelper(int iRow)
{
    CTDCSortCriterion *pCriterion;
    int cmp = 0;

    for (pCriterion = m_pSortList; pCriterion != NULL;
         pCriterion = pCriterion->m_pNext)
    {
        CTDCCell    *pCell1 = GetDataCell(m_iDataRows, pCriterion->m_iSortCol);
        CTDCCell    *pCell2 = GetFilterCell(iRow, pCriterion->m_iSortCol);

        cmp = VariantComp(pCell1, pCell2,
                          GetColInfo(pCriterion->m_iSortCol)->vtType, m_fCaseSensitive);

        if (!pCriterion->m_fSortAscending)
            cmp = -cmp;

        // if < or >, we don't have to look at any further criterion
        if (cmp)
            break;
    }
    return cmp;
}

//+-----------------------------------------------------------------------
//
//  Method:    EOLN()
//
//  Synopsis:  Closes of the current row in the growing cell grid,
//               handling column headings if it's the first row.
//
//  Arguments: None.
//
//  Returns:   S_OK indicating success.
//             E_OUTOFMEMORY if insufficient memory is available for
//               a conversion.
//
//+-----------------------------------------------------------------------

STDMETHODIMP
CTDCArr::EOLN()
{
    ATLTRACE(_T("CTDCArr::EOLN called, row: %d\n"), m_iCurrRow);

    HRESULT hr  = S_OK;

    _ASSERT(m_state == LS_LOADING_HEADER_UNAVAILABLE ||
            m_state == LS_LOADING_HEADER_AVAILABLE);

    if (m_fSkipRow)
    {
        //  Appending to existing data; skip over the first (header) line
        m_fSkipRow = FALSE;
        goto Cleanup;
    }

    if (m_iCurrRow == 0)
    {
        //  The first row has been inserted - if m_fUseHeader indicates
        //  that the first row contains header information then parse
        //  it; otherwise, create some numbered column headings.
        //
        if (!m_fUseHeader)
        {
            hr = CreateNumberedColumnHeadings();
            if (!SUCCEEDED(hr))
                goto Cleanup;

            //  An extra row has been inserted - update the insertion
            //  row index for later insertion of new elements
            //
            m_iCurrRow++;

            //  Initialise each column heading as "Column<column#>"
            //
            RenumberColumnHeadings();
        }

        m_iDataRows++;
        m_iFilterRows++;
        _ASSERT(m_iDataRows == 0);
        _ASSERT(m_iFilterRows == 0);

        ParseColumnHeadings();

        m_state = LS_LOADING_HEADER_AVAILABLE;

        //  Insert the hedaer row into the list of filtered rows
        //
        hr = m_arrparrFilter.InsertElems(0, 1);
        if (!SUCCEEDED(hr))
            goto Cleanup;
        m_arrparrFilter[0] = m_arrparrCells[0];

        //  Notify the event handler that the headers have been loaded
        //
        if (m_pEventBroker != NULL)
        {
            hr = m_pEventBroker->STDLoadedHeader();
            OutputDebugStringX(_T("TDCCtl: header loaded\n"));
            if (!SUCCEEDED(hr))
                goto Cleanup;
        }
    }

    if (m_iCurrRow > 0)
    {
        //  Convert uninitialised cells into their column's type.
        //
        LONG    iCol;

        for (iCol = m_iCurrCol; iCol < m_iCols; iCol++)
        {
            CTDCCell    *pCell    = GetDataCell(m_iCurrRow, iCol);

            //  This uninitialised VARIANT is assumed to be the result
            //  of specifying too few cells in a row.
            //
            _ASSERT(pCell->vt == VT_EMPTY);
            pCell->vt = VT_BSTR;
            pCell->bstrVal = NULL;

            CTDCColInfo *pColInfo = GetColInfo(iCol);

            if (pColInfo->vtType != VT_BSTR)
            {
                VARIANT     v;
                HRESULT     tmp_hr;

                tmp_hr = VariantFromBSTR(&v, pCell->bstrVal, pColInfo, m_lcidRead);
                if (SUCCEEDED(tmp_hr))
                {
                    hr = VariantCopy(pCell, &v);
                    VariantClear(&v);
                    if (!SUCCEEDED(hr))
                        goto Cleanup;
                }
                else
                {
                    //  Leave the cell as a BSTR
                    //
                }
            }
        }
        m_iDataRows++;
    }

    m_iCurrCol = 1;
    m_iCurrRow++;

    if (m_fSortFilterDisrupted)
    {
        //  This will have the side-effect of incorporating any new data rows
        //
        hr = ApplySortFilterCriteria();
        if (!SUCCEEDED(hr))
            goto Cleanup;
    }
    else if (m_iDataRows > 0 &&
        (m_pFilterTree == NULL || EvalDataRow(m_iDataRows, m_pFilterTree)))
    {
        //  The new row passed the filter criteria.
        //  Insert the new row into the filtered list
        //
        LONG iRowInsertedAt = m_iFilterRows + 1;

        //  at the correct insertion point according to the current
        //  sort criteria, if there is one.  We only need to do the search
        //  if this is not the first row, and if the candidate row is less
        //  than the last row.
        if (m_pSortList != NULL && m_iFilterRows != 0
            && InsertionSortHelper(m_iFilterRows) < 0)
        {
            // not at end, do traditional binary search.
            LONG lLow = 1;          // we don't use element zero!
            LONG lHigh = m_iFilterRows + 1;
            LONG lMid;

            while (lLow < lHigh)
            {
                lMid = (lLow + lHigh) / 2;
                // Note that InsertionSortHelper automatically flips the comparison
                // if m_fAscending flag is off.
                if (InsertionSortHelper(lMid) <= 0)
                {
                    lHigh = lMid;
                }
                else
                {
                    lLow = lMid + 1;
                }
            }
            iRowInsertedAt = lLow;
        }

        hr = m_arrparrFilter.InsertElems(iRowInsertedAt, 1);
        if (!SUCCEEDED(hr))
            goto Cleanup;
        m_arrparrFilter[iRowInsertedAt] = m_arrparrCells[m_iDataRows];
        ++m_iFilterRows;

        //  Notify event handler of row insertion
        //
        if (m_pEventBroker != NULL)
            hr = m_pEventBroker->rowsAvailable(iRowInsertedAt, 1);

    }

Cleanup:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Method:    EOF()
//
//  Synopsis:  Indicates no more cells will be added to the cell grid.
//             The column-heading cells are added unless it was indicated
//             that cell headings should be taken from the data read.
//             The cells in each column are converted to that column's
//             specified data type.
//
//  Arguments: None.
//
//  Returns:   S_OK indicating success.
//
//+-----------------------------------------------------------------------

STDMETHODIMP
CTDCArr::EOF()
{
    OutputDebugStringX(_T("CTDArr::EOF() called\n"));
    _ASSERT(m_state == LS_LOADING_HEADER_UNAVAILABLE ||
            m_state == LS_LOADING_HEADER_AVAILABLE);
    HRESULT hr = S_OK;

    if (m_iCurrCol > 1)
        EOLN();
    m_state = LS_LOADED;
    m_iFilterRows = CalcFilterRows();
    _ASSERT(m_iDataRows == CalcDataRows());
    _ASSERT(m_iCols == CalcCols());

    if (m_fSortFilterDisrupted)
    {
        hr = ApplySortFilterCriteria();
        if (!SUCCEEDED(hr))
            goto Cleanup;
    }
    if (m_pEventBroker != NULL)
        hr = m_pEventBroker->STDLoadCompleted();

Cleanup:
    return hr;
}

// GetEstimatedRows..
// We should really see if URLMon has a means of giving a byte count on the file
// we're downloading.  For now though..
STDMETHODIMP
CTDCArr::getEstimatedRows(DBROWCOUNT *pcRows)
{
    *pcRows = m_iFilterRows;
    if (m_state<LS_LOADED)
    {
        // Return twice number of rows, but be careful not to return 2 * 0.
        *pcRows = m_iFilterRows ? m_iFilterRows * 2 : -1;
    }
    return S_OK;
}

STDMETHODIMP
CTDCArr::isAsync(BOOL *pbAsync)
{
//    *pbAsync = m_fAsync;
    // The TDC always behaves as if it's Async.  Specifically, we always fire
    // TransferComplete, even if we have to buffer the notification until our
    // addOLEDBSimplerProviderListener is actually called.
    *pbAsync = TRUE;
    return S_OK;
}

STDMETHODIMP
CTDCArr::stopTransfer()
{
    HRESULT hr = S_OK;

    //  Force the load state into UNINITIALISED or LOADED ...
    //
    switch (m_state)
    {
    case LS_UNINITIALISED:
    case LS_LOADED:
        break;

    case LS_LOADING_HEADER_UNAVAILABLE:
        //  Free any allocated cell memory
        //
        if (m_arrparrFilter.GetSize() > 0)
            m_arrparrFilter.DeleteElems(0, m_arrparrFilter.GetSize());
        if (m_arrparrCells.GetSize() > 0)
            m_arrparrCells.DeleteElems(0, m_arrparrCells.GetSize());
        m_state = LS_UNINITIALISED;
        m_iFilterRows = CalcFilterRows();
        m_iDataRows = CalcDataRows();
        m_iCols = CalcCols();

        // If we stop the load before the header was parsed, we won't
        // have a dataset, but we still need to fire datasetchanged,
        // to let our customer know the query failed.
        if (m_pEventBroker != NULL)
            hr = m_pEventBroker->STDDataSetChanged();

        //
        // fall through to LOADING_HEADER_AVAILABLE!
        //

    case LS_LOADING_HEADER_AVAILABLE:
        m_state = LS_LOADED;            // mark us as finished now

        // LoadStopped will abort any transfer in progress, and fire
        // transferComplete with the OSPXFER_ABORT flag.
        if (m_pEventBroker != NULL)
            hr = m_pEventBroker->STDLoadStopped();
        break;
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////
//
//        Implementation of IUnknown COM interface.
//        -----------------------------------------
//
//////////////////////////////////////////////////////////////////////////

//+-----------------------------------------------------------------------
//
//  Method:    QueryInterface()
//
//  Synopsis:  Implements part of the standard IUnknown COM interface.
//               (Returns a pointer to this COM object)
//
//  Arguments: riid          GUID to recognise
//             ppv           Pointer to this COM object [OUT]
//
//  Returns:   S_OK upon success.
//             E_NOINTERFACE if queried for an unrecognised interface.
//
//+-----------------------------------------------------------------------

STDMETHODIMP
CTDCArr::QueryInterface (REFIID riid, LPVOID * ppv)
{
    HRESULT hr;

    _ASSERTE(ppv != NULL);

    // This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown || riid == IID_OLEDBSimpleProvider)
    {
        *ppv = this;
        ((LPUNKNOWN)*ppv)->AddRef();
        hr = S_OK;
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

#ifdef _ATL_DEBUG_QI
    AtlDumpIID(riid, _T("CTDCArr"), hr);
#endif
    return hr;
}


//+-----------------------------------------------------------------------
//
//  Method:    AddRef()
//
//  Synopsis:  Implements part of the standard IUnknown COM interface.
//               (Adds a reference to this COM object)
//
//  Arguments: None
//
//  Returns:   Number of references to this COM object.
//
//+-----------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CTDCArr::AddRef ()
{
    return ++m_cRef;
}


//+-----------------------------------------------------------------------
//
//  Method:    Release()
//
//  Synopsis:  Implements part of the standard IUnknown COM interface.
//               (Removes a reference to this COM object)
//
//  Arguments: None
//
//  Returns:   Number of remaining references to this COM object.
//             0 if the COM object is no longer referenced.
//
//+-----------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CTDCArr::Release ()
{
    ULONG retval;

    m_cRef -= 1;
    retval = m_cRef;
    if (!m_cRef)
    {
        m_cRef = 0xffff;    //MM: Use this 'flag' for debug?
        delete this;
    }

    return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\tdc\tdc.cpp ===
// TDC.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 or higher in order to build 
// this project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f TDCps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <simpdata.h>
#include "TDCIds.h"
#include "TDC.h"
#include <MLang.h>

#define IID_DEFINED         // for now avoid a conflict with ATL
#include "TDC_i.c"
//#include "mlang_i.c"
#include "Notify.h"
#include "TDCParse.h"
#include "TDCArr.h"
#include "TDCCtl.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CTDCCtl, CTDCCtl)
//MM    OBJECT_ENTRY(CLSID_CSimpleTabularData, CSimpleTabularData)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
#if _WIN32_WINNT >= 0x0400
    UnRegisterTypeLib(LIBID_TDCLib, 1, 1, NULL, SYS_WIN32);
#endif
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\tdc\tdcarr.h ===
//+-----------------------------------------------------------------------
//
//  TDC Array
//  Copyright (C) Microsoft Corporation, 1996, 1997
//
//  File:       TDCArr.h
//
//  Contents:   Declaration of the CTDCArr class.
//              This class forms the heart of the Tabular Data Control.
//              It provides the core 2D array of variant values, plus
//              a (possibly filtered/sorted) view of this data for
//              presentation through an ISimpleTabularData interface.
//
//------------------------------------------------------------------------

// ;begin_internal
#ifndef TDC_SKEL
// ;end_internal
#include "tarray.h"

//------------------------------------------------------------------------
//
//  CTDCCell
//
//  This class represents a cell value within the 2D TDC control
//
//------------------------------------------------------------------------

class CTDCCell : public VARIANT
{
public:
    CTDCCell()
    {
        VariantInit(this);
    }
    ~CTDCCell()
    {
        clear();
    }
    void clear()
    {
        VariantClear(this);
    }
};

//------------------------------------------------------------------------
//
//  TDCDateFmt
//
//  This enum represents the 6 meaningful ways to format dates
//
//------------------------------------------------------------------------
typedef enum
{
    TDCDF_NULL,
    TDCDF_DMY,
    TDCDF_DYM,
    TDCDF_MDY,
    TDCDF_MYD,
    TDCDF_YMD,
    TDCDF_YDM,
}
    TDCDateFmt;

//------------------------------------------------------------------------
//
//  CTDCColInfo
//
//  This class represents type/formatting information for a column
//
//------------------------------------------------------------------------

class CTDCColInfo
{
public:
    VARTYPE vtType;
    TDCDateFmt  datefmt;        //  Format string for dates

    CTDCColInfo()
    {
        vtType = VT_EMPTY;
    }
};
// ;begin_internal
#endif  // TDC_SKEL
// ;end_internal

//------------------------------------------------------------------------
//
//  CTDCSortCriterion
//
//  This class represents a sorting criterion (sort column and direction)
//
//------------------------------------------------------------------------

class CTDCSortCriterion
{
public:
    LONG    m_iSortCol;
    boolean m_fSortAscending;
    CTDCSortCriterion *m_pNext;

    CTDCSortCriterion()
    {
        m_pNext = NULL;
    }
    ~CTDCSortCriterion()
    {
        if (m_pNext != NULL)
            delete m_pNext;
    }
};

//------------------------------------------------------------------------
//
//  CTDCFilterNode
//
//  This class represents a tree node in a filter query.
//
//------------------------------------------------------------------------

class CTDCFilterNode
{
public:
    enum NODE_OP
    {
        NT_AND,
        NT_OR,
        NT_EQ,
        NT_NE,
        NT_LT,
        NT_GT,
        NT_LE,
        NT_GE,
        NT_ATOM,
        NT_NULL,
    };
    NODE_OP        m_type;
    CTDCFilterNode *m_pLeft;    // NT_AND ... NT_GE
    CTDCFilterNode *m_pRight;   // NT_AND ... NT_GE
    LONG           m_iCol;      // NT_ATOM, +ve column #, 0 means fixed value
    VARIANT        m_value;     // NT_ATOM, m_iCol == 0: optional fixed value
    VARTYPE        m_vt;        // NT_EQ ... NT_ATOM - type of comparison/atom
    boolean        m_fWildcard; // True for string literals with '*' wildcard

    CTDCFilterNode()
    {
        m_type = NT_NULL;
        m_pLeft = NULL;
        m_pRight = NULL;
        m_iCol = 0;
        m_vt = VT_EMPTY;
        VariantInit(&m_value);
    }
    ~CTDCFilterNode()
    {
        if (m_pLeft != NULL)
            delete m_pLeft;
        if (m_pRight != NULL)
            delete m_pRight;
        VariantClear(&m_value);
    }
};

class CEventBroker;

//------------------------------------------------------------------------
//
//  CTDCArr
//
//------------------------------------------------------------------------

class CTDCArr : public OLEDBSimpleProvider,
                public CTDCFieldSink
{
public:
    STDMETHOD(QueryInterface)   (REFIID, LPVOID FAR*);
    STDMETHOD_(ULONG,AddRef)    (THIS);
    STDMETHOD_(ULONG,Release)   (THIS);

    CTDCArr();
    STDMETHOD(Init)(CEventBroker *pEventBroker, IMultiLanguage *pML);

    //  CTDCFieldSink methods
    //
    STDMETHOD(AddField)(LPWCH pwch, DWORD dwSize);
    STDMETHOD(EOLN)();
    STDMETHOD(EOF)();

    //  TDC control methods
    //
    STDMETHOD(StartDataLoad)(boolean fUseHeader,
                             BSTR bstrSortExpr, BSTR bstrFilterExpr, LCID lcid,
                             CComObject<CMyBindStatusCallback<CTDCCtl> > *pBSC,
                             boolean fAppend, boolean fCaseSensitive);
    STDMETHOD(SetSortFilterCriteria)(BSTR bstrSortExpr, BSTR bstrFilterExpr,
                                    boolean fCaseSensitive);

    //  OLEDBSimpleProvider methods
    //
    STDMETHOD(getRowCount)(DBROWCOUNT *pcRows);
    STDMETHOD(getColumnCount)(DB_LORDINAL *pcCols);
    STDMETHOD(getRWStatus)(DBROWCOUNT iRow, DB_LORDINAL iCol, OSPRW *prwStatus);
    STDMETHOD(getVariant)(DBROWCOUNT iRow, DB_LORDINAL iCol, OSPFORMAT format, VARIANT *pVar);
    STDMETHOD(setVariant)(DBROWCOUNT iRow, DB_LORDINAL iCol, OSPFORMAT format, VARIANT Var);
    STDMETHOD(getLocale)(BSTR *pbstrLocale);
    STDMETHOD(deleteRows)(DBROWCOUNT iRow, DBROWCOUNT cRows, DBROWCOUNT *pcRowsDeleted);
    STDMETHOD(insertRows)(DBROWCOUNT iRow, DBROWCOUNT cRows, DBROWCOUNT *pcRowsInserted);
    STDMETHOD(find) (DBROWCOUNT iRowStart, DB_LORDINAL iCol, VARIANT val,
            OSPFIND findFlags, OSPCOMP compType, DBROWCOUNT *piRowFound);
    STDMETHOD(addOLEDBSimpleProviderListener)(OLEDBSimpleProviderListener *pospIListener);
    STDMETHOD(removeOLEDBSimpleProviderListener)(OLEDBSimpleProviderListener *pospIListener);
    STDMETHOD(getEstimatedRows)(DBROWCOUNT *pcRows);    
    STDMETHOD(isAsync)(BOOL *pbAsync);
    STDMETHOD(stopTransfer)();
// ;begin_internal
    STDMETHOD(DeleteColumns)(DB_LORDINAL iCol, DB_LORDINAL cCols, DB_LORDINAL *pcColsDeleted);
    STDMETHOD(InsertColumns)(DB_LORDINAL iCol, DB_LORDINAL cCols, DB_LORDINAL *pcColsInserted);
// ;end_internal

    //  This member is used during a sort operation
    //
    int SortComp(LONG iRow1, LONG iRow2);

    enum LOAD_STATE
    {
        LS_UNINITIALISED,
        LS_LOADING_HEADER_UNAVAILABLE,
        LS_LOADING_HEADER_AVAILABLE,
        LS_LOADED,
    };
    LOAD_STATE  GetLoadState()  { return m_state; }
    void SetIsAsync(BOOL fAsync) { m_fAsync = fAsync; }
    CEventBroker    *m_pEventBroker;
    IMultiLanguage  *m_pML;

private:


    ULONG       m_cRef;         // interface reference count
    LOAD_STATE  m_state;
    LCID        m_lcid;         // Default user LCID
    LCID        m_lcidRead;     // User LCID corresponding to LANGUAGE property

    ~CTDCArr();

// ;begin_internal
#ifndef TDC_SKEL
// ;end_internal
    boolean     m_fSortFilterDisrupted;
    STDMETHOD(ApplySortFilterCriteria)();

    //  These members are used during a sort operation
    //
    CTDCSortCriterion   *m_pSortList;
    BSTR                m_bstrSortExpr;
    HRESULT CreateSortList(BSTR bstrSortCols);

    //  These members are used during a filter operation
    //
    CTDCFilterNode  *m_pFilterTree;
    BSTR            m_bstrFilterExpr;
    boolean EvalDataRow(LONG iRow, CTDCFilterNode *pNode);
    CTDCFilterNode *FilterParseComplex(LPWCH *ppwch, HRESULT *phr);
    CTDCFilterNode *FilterParseSimple(LPWCH *ppwch, HRESULT *phr);
    CTDCFilterNode *FilterParseAtom(LPWCH *ppwch, HRESULT *phr);
    LONG    m_fLastFilter;
// ;begin_internal
#endif // TDC_SKEL
// ;end_internal

    //  These members are used during a load
    //
    boolean m_fUseHeader;
    boolean m_fSkipRow;
    LONG    m_iCurrRow;
    LONG    m_iCurrCol;

    LONG    m_iDataRows;
    LONG    m_iFilterRows;
    LONG    m_iCols;
    boolean m_fCaseSensitive;

    BOOL    m_fAsync;                   // TRUE iff Async

    //  These methods and members form the internal array implementation
    //
    inline boolean fValidDataRow(LONG iRow);
    inline boolean fValidFilterRow(LONG iRow);
    inline boolean fValidCol(LONG iCol);
    inline boolean fValidDataCell(LONG iRow, LONG iCol);
    inline boolean fValidFilterCell(LONG iRow, LONG iCol);
    inline CTDCCell *GetDataCell(LONG iRow, LONG iCol);
    inline CTDCCell *GetFilterCell(LONG iRow, LONG iCol);
    inline CTDCColInfo *GetColInfo(LONG iCol);
    LONG CalcDataRows();
    LONG CalcFilterRows();
    LONG CalcCols();

    TSTDArray<TSTDArray<CTDCCell> *>   m_arrparrCells;
    TSTDArray<TSTDArray<CTDCCell> *>   m_arrparrFilter;
    TSTDArray<CTDCColInfo>             m_arrColInfo;

    //  Misc internal methods
    //
    LONG    FindCol(BSTR bstrColName);
    HRESULT GetVariantBSTR(VARIANT *pv, BSTR *pbstr, boolean *pfAllocated);
    void    RenumberColumnHeadings();
    HRESULT CreateNumberedColumnHeadings();
    HRESULT ParseColumnHeadings();
    HRESULT VariantFromBSTR(VARIANT *pv, BSTR bstr, CTDCColInfo *pColInfo, LCID);
    int VariantComp(VARIANT *pVar1, VARIANT *pVar2, VARTYPE type,
                    boolean fCaseSensitive);
    int InsertionSortHelper(int iRow);
};

inline boolean CTDCArr::fValidDataRow(LONG iRow)
{
    return iRow >= 0 && iRow <= m_iDataRows;
}

inline boolean CTDCArr::fValidFilterRow(LONG iRow)
{
    return iRow >= 0 && iRow <= m_iFilterRows;
}

inline boolean CTDCArr::fValidCol(LONG iCol)
{
    return iCol >= 1 && iCol <= m_iCols;
}

inline boolean CTDCArr::fValidDataCell(LONG iRow, LONG iCol)
{
    return fValidDataRow(iRow) && fValidCol(iCol);
}

inline boolean CTDCArr::fValidFilterCell(LONG iRow, LONG iCol)
{
    return fValidFilterRow(iRow) && fValidCol(iCol);
}

// ;begin_internal
#ifndef TDC_SKEL
// ;end_internal
inline CTDCCell *CTDCArr::GetDataCell(LONG iRow, LONG iCol)
{
    return &((*m_arrparrCells[iRow])[iCol - 1]);
}

inline CTDCColInfo *CTDCArr::GetColInfo(LONG iCol)
{
    return &m_arrColInfo[iCol - 1];
}

inline CTDCCell *CTDCArr::GetFilterCell(LONG iRow, LONG iCol)
{
    return &((*m_arrparrFilter[iRow])[iCol - 1]);
}
// ;begin_internal
#endif  // TDC_SKEL
// ;end_internal
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\tdc\tdcctl.cpp ===
//------------------------------------------------------------------------
//
//  Tabular Data Control
//  Copyright (C) Microsoft Corporation, 1996, 1997
//
//  File:       TDCCtl.cpp
//
//  Contents:   Implementation of the CTDCCtl ActiveX control.
//
//------------------------------------------------------------------------

#include "stdafx.h"
#include <simpdata.h>
#include "TDCIds.h"
#include "TDC.h"
#include <MLang.h>
#include "Notify.h"
#include "TDCParse.h"
#include "TDCArr.h"
#include "TDCCtl.h"
#include "locale.h"

//------------------------------------------------------------------------
//
//  Function:   EmptyBSTR()
//
//  Synopsis:   Indicates whether the given BSTR object represents an
//              empty string.
//
//  Arguments:  bstr     String to test
//
//  Returns:    TRUE if 'bstr' represents an empty string
//              FALSE otherwise.
//
//------------------------------------------------------------------------

inline boolean EmptyBSTR(BSTR bstr)
{
    return bstr == NULL || bstr[0] == 0;
}

void
ClearInterfaceFn(IUnknown ** ppUnk)
{
    IUnknown * pUnk;

    pUnk = *ppUnk;
    *ppUnk = NULL;
    if (pUnk)
        pUnk->Release();
}

// For some reason the standard definition of VARIANT_TRUE (0xffff) generates
// truncation warnings when assigned to a VARIANT_BOOL
#define TDCVARIANT_TRUE -1

//------------------------------------------------------------------------
//
//  Method:     CTDCCtl()
//
//  Synopsis:   Class constructor
//
//  Arguments:  None
//
//------------------------------------------------------------------------

CTDCCtl::CTDCCtl()
{
    m_cbstrFieldDelim = DEFAULT_FIELD_DELIM;
    m_cbstrRowDelim = DEFAULT_ROW_DELIM;
    m_cbstrQuoteChar = DEFAULT_QUOTE_CHAR;
    m_fUseHeader = FALSE;
    m_fSortAscending = TRUE;
    m_fAppendData = FALSE;
    m_pSTD = NULL;
    m_pArr = NULL;
    m_pUnify = NULL;
    m_pEventBroker = new CEventBroker(this);
    m_pDataSourceListener = NULL;
// ;begin_internal
    m_pDATASRCListener = NULL;
// ;end_internal
    m_pBSC = NULL;
    m_enumFilterCriterion = (OSPCOMP) 0;
    m_fDataURLChanged = FALSE;
    m_lTimer = 0;
    m_fCaseSensitive = TRUE;
    m_hrDownloadStatus = S_OK;
    m_fInReset = FALSE;

    //  Create an MLANG object
    //
    m_nCodePage = 0;                    // use default from host
    {
        HRESULT hr;

        m_pML = NULL;
        hr = CoCreateInstance(CLSID_CMultiLanguage, NULL,
                              CLSCTX_INPROC_SERVER, IID_IMultiLanguage,
                              (void**) &m_pML);
        // Don't set the default Charset here.  Leave m_nCodepage set
        // to 0 to indicate default charset.  Later we'll try to query
        // our host's default charset, and failing that we'll use CP_ACP.
        _ASSERTE(SUCCEEDED(hr) && m_pML != NULL);
    }

    m_lcidRead = 0x0000;                // use default from host
}


//------------------------------------------------------------------------
//
//  Method:     ~CTDCCtl()
//
//  Synopsis:   Class destructor
//
//------------------------------------------------------------------------

CTDCCtl::~CTDCCtl()
{
    ULONG cRef = _ThreadModel::Decrement(&m_dwRef);

    ClearInterface(&m_pSTD);

    if (cRef ==0)
    {
        TimerOff();
        ReleaseTDCArr(FALSE);

        if (m_pEventBroker)
        {
            m_pEventBroker->Release();
            m_pEventBroker = NULL;
        }
        ClearInterface(&m_pDataSourceListener);
// ;begin_internal
        ClearInterface(&m_pDATASRCListener);
// ;end_internal
        ClearInterface(&m_pML);
    }
}

//------------------------------------------------------------------------
//
//  These set/get methods implement the control's properties,
//  copying values to and from class members.  They perform no
//  other processing apart from argument validation.
//
//------------------------------------------------------------------------

STDMETHODIMP CTDCCtl::get_ReadyState(LONG *plReadyState)
{
    HRESULT hr;

    if (m_pEventBroker == NULL)
    {
        // We must provide a ReadyState whether we want to or not, or our
        // host can never go COMPLETE.
        *plReadyState = READYSTATE_COMPLETE;
        hr = S_OK;
    }
    else
        hr = m_pEventBroker->GetReadyState(plReadyState);
    return hr;
}

STDMETHODIMP CTDCCtl::put_ReadyState(LONG lReadyState)
{
    // We don't allow setting of Ready State, but take advantage of a little
    // kludge here to update our container's impression of our readystate
    FireOnChanged(DISPID_READYSTATE);
    return S_OK;
}

STDMETHODIMP CTDCCtl::get_FieldDelim(BSTR* pbstrFieldDelim)
{
    *pbstrFieldDelim = m_cbstrFieldDelim.Copy();
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_FieldDelim(BSTR bstrFieldDelim)
{
    HRESULT hr = S_OK;

    if (bstrFieldDelim == NULL || bstrFieldDelim[0] == 0)
    {
        m_cbstrFieldDelim = DEFAULT_FIELD_DELIM;
        if (m_cbstrFieldDelim == NULL)
            hr = E_OUTOFMEMORY;
    }
    else
        m_cbstrFieldDelim = bstrFieldDelim;
    return S_OK;
}

STDMETHODIMP CTDCCtl::get_RowDelim(BSTR* pbstrRowDelim)
{
    *pbstrRowDelim = m_cbstrRowDelim.Copy();
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_RowDelim(BSTR bstrRowDelim)
{
    HRESULT hr = S_OK;

    if (bstrRowDelim == NULL || bstrRowDelim[0] == 0)
    {
        m_cbstrRowDelim = DEFAULT_ROW_DELIM;
        if (m_cbstrRowDelim == NULL)
            hr = E_OUTOFMEMORY;
    }
    else
        m_cbstrRowDelim = bstrRowDelim;
    return hr;
}

STDMETHODIMP CTDCCtl::get_TextQualifier(BSTR* pbstrTextQualifier)
{
    *pbstrTextQualifier = m_cbstrQuoteChar.Copy();
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_TextQualifier(BSTR bstrTextQualifier)
{
    m_cbstrQuoteChar = bstrTextQualifier;
    return S_OK;
}

STDMETHODIMP CTDCCtl::get_EscapeChar(BSTR* pbstrEscapeChar)
{
    *pbstrEscapeChar = m_cbstrEscapeChar.Copy();
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_EscapeChar(BSTR bstrEscapeChar)
{
    m_cbstrEscapeChar = bstrEscapeChar;
    return S_OK;
}

STDMETHODIMP CTDCCtl::get_UseHeader(VARIANT_BOOL* pfUseHeader)
{
    *pfUseHeader = (VARIANT_BOOL)m_fUseHeader;
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_UseHeader(VARIANT_BOOL fUseHeader)
{
    m_fUseHeader = fUseHeader;
    return S_OK;
}

STDMETHODIMP CTDCCtl::get_SortColumn(BSTR* pbstrSortColumn)
{
    *pbstrSortColumn = m_cbstrSortColumn.Copy();
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_SortColumn(BSTR bstrSortColumn)
{
    m_cbstrSortColumn = bstrSortColumn;
    return S_OK;
}

STDMETHODIMP CTDCCtl::get_SortAscending(VARIANT_BOOL* pfSortAscending)
{
    *pfSortAscending = m_fSortAscending ? TDCVARIANT_TRUE : VARIANT_FALSE;
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_SortAscending(VARIANT_BOOL fSortAscending)
{
    m_fSortAscending = fSortAscending ? TRUE : FALSE;
    return S_OK;
}

STDMETHODIMP CTDCCtl::get_FilterValue(BSTR* pbstrFilterValue)
{
    *pbstrFilterValue = m_cbstrFilterValue.Copy();
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_FilterValue(BSTR bstrFilterValue)
{
    m_cbstrFilterValue = bstrFilterValue;
    return S_OK;
}

STDMETHODIMP CTDCCtl::get_FilterCriterion(BSTR* pbstrFilterCriterion)
{
    HRESULT hr;
    WCHAR   *pwchCriterion;

    switch (m_enumFilterCriterion)
    {
    case OSPCOMP_EQ:    pwchCriterion = L"=";   break;
    case OSPCOMP_LT:    pwchCriterion = L"<";   break;
    case OSPCOMP_LE:    pwchCriterion = L"<=";  break;
    case OSPCOMP_GE:    pwchCriterion = L">=";  break;
    case OSPCOMP_GT:    pwchCriterion = L">";   break;
    case OSPCOMP_NE:    pwchCriterion = L"<>";  break;
    default:            pwchCriterion = L"??";  break;
    }
    *pbstrFilterCriterion = SysAllocString(pwchCriterion);
    hr = (*pbstrFilterCriterion == NULL) ? E_OUTOFMEMORY : S_OK;

    return hr;
}

STDMETHODIMP CTDCCtl::put_FilterCriterion(BSTR bstrFilterCriterion)
{
    m_enumFilterCriterion = (OSPCOMP) 0;
    if (bstrFilterCriterion != NULL)
    {
        switch (bstrFilterCriterion[0])
        {
        case L'<':
            if (bstrFilterCriterion[1] == 0)
                m_enumFilterCriterion = OSPCOMP_LT;
            else if (bstrFilterCriterion[2] == 0)
            {
                if (bstrFilterCriterion[1] == L'>')
                    m_enumFilterCriterion = OSPCOMP_NE;
                else if (bstrFilterCriterion[1] == L'=')
                    m_enumFilterCriterion = OSPCOMP_LE;
            }
            break;
        case L'>':
            if (bstrFilterCriterion[1] == 0)
                m_enumFilterCriterion = OSPCOMP_GT;
            else if (bstrFilterCriterion[1] == L'=' && bstrFilterCriterion[2] == 0)
                m_enumFilterCriterion = OSPCOMP_GE;
            break;
        case L'=':
            if (bstrFilterCriterion[1] == 0)
                m_enumFilterCriterion = OSPCOMP_EQ;
            break;
        }
    }

    //  Return SUCCESS, even on an invalid value; otherwise the
    //  frameworks using the control will panic and abandon all hope.
    //
    return S_OK;
}

STDMETHODIMP CTDCCtl::get_FilterColumn(BSTR* pbstrFilterColumn)
{
    *pbstrFilterColumn = m_cbstrFilterColumn.Copy();
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_FilterColumn(BSTR bstrFilterColumn)
{
    m_cbstrFilterColumn = bstrFilterColumn;
    return S_OK;
}

STDMETHODIMP CTDCCtl::get_CharSet(BSTR* pbstrCharSet)
{
    HRESULT hr = E_FAIL;

    *pbstrCharSet = NULL;

    if (m_pML != NULL)
    {
        MIMECPINFO  info;

        hr = m_pML->GetCodePageInfo(m_nCodePage, &info);
        if (SUCCEEDED(hr))
        {
            *pbstrCharSet = SysAllocString(info.wszWebCharset);
            if (*pbstrCharSet == NULL)
                hr = E_OUTOFMEMORY;
        }
    }
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_CharSet(BSTR bstrCharSet)
{
    HRESULT hr = E_FAIL;

    if (m_pML != NULL)
    {
        MIMECSETINFO    info;

        hr = m_pML->GetCharsetInfo(bstrCharSet, &info);
        if (SUCCEEDED(hr))
        {
            m_nCodePage = info.uiInternetEncoding;
        }
    }
    return S_OK;
}

STDMETHODIMP CTDCCtl::get_Language(BSTR* pbstrLanguage)
{
    if (m_pArr)
    {
        return m_pArr->getLocale(pbstrLanguage);
    }

    *pbstrLanguage = m_cbstrLanguage.Copy();
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_Language_(LPWCH pwchLanguage)
{
    HRESULT hr  = S_OK;
    LCID    lcid;

    hr = m_pML->GetLcidFromRfc1766(&lcid, pwchLanguage);
    if (SUCCEEDED(hr))
    {
        m_cbstrLanguage = pwchLanguage;
        m_lcidRead = lcid;
    }
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_Language(BSTR bstrLanguage)
{
    return put_Language_(bstrLanguage);
}

STDMETHODIMP CTDCCtl::get_DataURL(BSTR* pbstrDataURL)
{
    *pbstrDataURL = m_cbstrDataURL.Copy();
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_DataURL(BSTR bstrDataURL)
{
    HRESULT hr = S_OK;

    m_cbstrDataURL = bstrDataURL;
    m_fDataURLChanged = TRUE;
    return hr;
}

// ;begin_internal
#ifdef NEVER
STDMETHODIMP CTDCCtl::get_RefreshInterval(LONG* plTimer)
{
    *plTimer = m_lTimer;
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_RefreshInterval(LONG lTimer)
{
    m_lTimer = lTimer;
    if (m_lTimer > 0)
        TimerOn(m_lTimer * 1000);
    else
        TimerOff();
    return S_OK;
}
#endif
// ;end_internal

STDMETHODIMP CTDCCtl::get_Filter(BSTR* pbstrFilterExpr)
{
    *pbstrFilterExpr = m_cbstrFilterExpr.Copy();
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_Filter(BSTR bstrFilterExpr)
{
    m_cbstrFilterExpr = bstrFilterExpr;
    return S_OK;
}

STDMETHODIMP CTDCCtl::get_Sort(BSTR* pbstrSortExpr)
{
    *pbstrSortExpr = m_cbstrSortExpr.Copy();
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_Sort(BSTR bstrSortExpr)
{
    m_cbstrSortExpr = bstrSortExpr;
    return S_OK;
}

STDMETHODIMP CTDCCtl::get_AppendData(VARIANT_BOOL* pfAppendData)
{
    *pfAppendData = m_fAppendData ? TDCVARIANT_TRUE : VARIANT_FALSE;
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_AppendData(VARIANT_BOOL fAppendData)
{
    m_fAppendData = fAppendData ? TRUE : FALSE;
    return S_OK;
}

STDMETHODIMP CTDCCtl::get_CaseSensitive(VARIANT_BOOL* pfCaseSensitive)
{
    *pfCaseSensitive = m_fCaseSensitive ? TDCVARIANT_TRUE : VARIANT_FALSE;
    return S_OK;
}

STDMETHODIMP CTDCCtl::put_CaseSensitive(VARIANT_BOOL fCaseSensitive)
{
    m_fCaseSensitive = fCaseSensitive ? TRUE : FALSE;
    return S_OK;
}

STDMETHODIMP CTDCCtl::get_OSP(OLEDBSimpleProviderX ** ppISTD)
{
    // Return an OSP if we have one, but don't create one on demand!
    // (Otherwise property bag load stuff will cause us to create an
    // OSP prematurely).
    *ppISTD = NULL;
    if (m_pSTD)
    {
        *ppISTD = (OLEDBSimpleProviderX *)m_pSTD;
        m_pSTD->AddRef();
    }
    return S_OK;
}


//------------------------------------------------------------------------
//
//  Method:    UpdateReadyState
//
//  Synopsis:  Vectors to the event brokers ReadyState, if there is one.
// ;begin_internal
//             Note, we have to be able to set our readystate and fire change
//             events on it, whether or not creation of the broker succeeded,
//             or we prevent our host container from reaching
//             READYSTATE_COMPLETE, which is not acceptable.  We therefore
//             have to duplicate some of the broker's work here.  This makes
//             me wonder whether the broker architecture was a good idea.
// ;end_internal
//
//  Arguments: None.
//
//  Returns:   S_OK upon success.
//             Error codes as per Reset() upon error.
//
//------------------------------------------------------------------------
void
CTDCCtl::UpdateReadyState(LONG lReadyState)
{
    if (m_pEventBroker)
        m_pEventBroker->UpdateReadyState(lReadyState);
    else
    {
        // We have no broker, but our host is still waiting for us to
        // go READYSTATE_COMPLETE.  We fire the OnChange here noting that
        // get_ReadyState with no broker will return COMPLETE.
        FireOnChanged(DISPID_READYSTATE);
        FireOnReadyStateChanged();
    }
}

//------------------------------------------------------------------------
//
//  Method:    _OnTimer()
//
//  Synopsis:  Handles an internal timer event by refreshing the control.
//
//  Arguments: None.
//
//  Returns:   S_OK upon success.
//             Error codes as per Reset() upon error.
//
//------------------------------------------------------------------------

STDMETHODIMP CTDCCtl::_OnTimer()
{
    HRESULT hr = S_OK;

    if (m_pArr != NULL && m_pArr->GetLoadState() == CTDCArr::LS_LOADED)
    {
        m_fDataURLChanged = TRUE;
        hr = Reset();
    }

    return hr;
}


//------------------------------------------------------------------------
//
//  Method:    msDataSourceObject()
//
//  Synopsis:  Yields an ISimpleTabularData interface for this control.
//             If this is the first call, a load operation is initiated
//             reading data from the control's specified DataURL property.
//             An STD object is created to point to the control's embedded
//             TDCArr object.
//
//  Arguments: qualifier     Ignored - must be an empty BSTR.
//             ppUnk         Pointer to returned interface  [OUT]
//
//  Returns:   S_OK upon success.
//             E_INVALIDARG if 'qualifier' isn't an empty BSTR.
//             E_OUTOFMEMORY if non enough memory could be allocated to
//               complete the construction of the interface.
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCCtl::msDataSourceObject(BSTR qualifier, IUnknown **ppUnk)
{
    HRESULT hr  = S_OK;

    *ppUnk = NULL;                      // NULL in case of failure

    if (!EmptyBSTR(qualifier))
    {
        hr = E_INVALIDARG;
        goto error;
    }

    // Was there a previous attempt to load this page that failed?
    // (Probably due to security or file not found or something).
    if (m_hrDownloadStatus)
    {
        hr = m_hrDownloadStatus;
        goto error;
    }

    if (m_pArr == NULL)
    {
        // We don't have a valid TDC to give back, probably have to try
        // downloading one.
        UpdateReadyState(READYSTATE_LOADED);
        hr = CreateTDCArr(FALSE);
        if (hr)
            goto error;
    }

    _ASSERTE(m_pArr != NULL);

    if (m_pSTD == NULL)
    {
        OutputDebugStringX(_T("Creating an STD COM object\n"));

        // fetch ISimpleTabularData interface pointer
        m_pArr->QueryInterface(IID_OLEDBSimpleProvider, (void**)&m_pSTD);
        _ASSERTE(m_pSTD != NULL);
    }

    // Return the STD if we have one, otherwise it stays NULL
    if (m_pSTD && m_pArr->GetLoadState() >= CTDCArr::LS_LOADING_HEADER_AVAILABLE)
    {
        *ppUnk = (OLEDBSimpleProviderX *) m_pSTD;
        m_pSTD->AddRef();           // We must AddRef the STD we return!
    }

cleanup:
    return hr;

error:
    UpdateReadyState(READYSTATE_COMPLETE);
    goto cleanup;
}

// Override IPersistPropertyBagImpl::Load
STDMETHODIMP
CTDCCtl::Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
{
    HRESULT hr;
    IUnknown *pSTD;

    // Find out our Ambient Charset.  We need to know this surprisingly
    // early in life.
    VARIANT varCodepage;
    // 0 means user didn't set one, so ask our container.
    VariantInit(&varCodepage);
    GetAmbientProperty(DISPID_AMBIENT_CODEPAGE, varCodepage);

    // Ultimate default is Latin-1
    m_nAmbientCodePage = (varCodepage.vt == VT_UI4)
                         ? (ULONG)varCodepage.lVal
                         : CP_1252;

    // ignore Unicode ambient codepage - we want to allow non-Unicode
    // data files from Unicode pages.  If the data file is Unicode,
    // we'll find out anyway when we see the Unicode signature.
    if (m_nAmbientCodePage == UNICODE_CP ||
        m_nAmbientCodePage == UNICODE_REVERSE_CP)
    {
        m_nAmbientCodePage = CP_1252;
    }

    // Do normal load
    // IPersistPropertyBagImpl<CTDCCtl>
    hr = IPersistPropertyBagImpl<CTDCCtl>::Load(pPropBag, pErrorLog);

    // and then start download, if we can
    (void)msDataSourceObject(NULL, &pSTD);

    // If we actually got an STD, we should release it.  This won't really
    // make it go away, since we still have the ref from the QI.  This is
    // a bit of a kludge that we should clean up later.
    ClearInterface(&pSTD);

    return hr;
}


//------------------------------------------------------------------------
//
//  Method:    CreateTDCArr()
//
//  Synopsis:  Creates the control's embedded TDCArr object.
//             Initiates a data download from the DataURL property.
//
//  Arguments: fAppend         Flag indicating whether data should be
//                             appended to an existing TDC object.
//
//  Returns:   S_OK upon success.
//             E_OUTOFMEMORY if non enough memory could be allocated to
//               complete the construction of the TDCArr object.
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCCtl::CreateTDCArr(boolean fAppend)
{
    HRESULT hr  = S_OK;

    if (m_pEventBroker == NULL)
    {
        hr = E_FAIL;
        goto Error;
    }

    // Iff we're appending is m_pArr allowed to be non-null here.
    _ASSERT ((m_pArr != NULL) == !!fAppend);

    if (m_pArr == NULL)
    {
        m_pArr = new CTDCArr();
        if (m_pArr == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }

        hr = m_pArr->Init(m_pEventBroker, m_pML);
        if (FAILED(hr))
            goto Error;
    }

    hr = InitiateDataLoad(fAppend);
    if (hr)
        goto Error;

    // We decide something is not async if it finished loading during
    // the InitiateDataLoad call.
    m_pArr->SetIsAsync(!(m_pArr->GetLoadState()==CTDCArr::LS_LOADED));

Cleanup:
    return hr;

Error:
    if (!fAppend)
    {
        ClearInterface(&m_pArr);
    }
    goto Cleanup;
}

//------------------------------------------------------------------------
//
//  Method:    ReleaseTDCArr()
//
//  Synopsis:  Releases the control's embedded TDCArr object.
//             Releases the control's CTDCUnify and CTDCTokenise objects.
//             Releases the old event broker and re-creates it if replacing.
//
//  Arguments: fReplacingTDCArr   Flag indicating whether a new TDCArr object
//                                will be created.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//             E_OUTOFMEMORY if non enough memory could be allocated to
//               complete the construction of the new CEventBroker object.
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCCtl::ReleaseTDCArr(boolean fReplacingTDCArr)
{
    HRESULT hr = S_OK;

    TerminateDataLoad(m_pBSC);

    //  Release the reference to the current TDCArr object
    //
    if (m_pArr != NULL)
    {
        m_pArr->Release();
        m_pArr = NULL;

        // Since we've shut down the CTDCArr object, we should release
        // it's OLEDBSimplerProviderListener sink.
        if (m_pEventBroker)
        {
            m_pEventBroker->SetSTDEvents(NULL);
        }

        if (fReplacingTDCArr)
        {
            // Release our previous Event Broker.
            if (m_pEventBroker)
            {
                m_pEventBroker->Release();
                m_pEventBroker = NULL;
            }

            //  Create a new event broker.
            m_pEventBroker = new CEventBroker(this);
            if (m_pEventBroker == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            // Set the DataSourceListener for the new event broker.
            m_pEventBroker->SetDataSourceListener(m_pDataSourceListener);

// ;begin_internal
            m_pEventBroker->SetDATASRCListener(m_pDATASRCListener);
// ;end_internal
        }
    }

Cleanup:
    return hr;
}

const IID IID_IDATASRCListener = {0x3050f380,0x98b5,0x11cf,{0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b}};
const IID IID_DataSourceListener = {0x7c0ffab2,0xcd84,0x11d0,{0x94,0x9a,0x00,0xa0,0xc9,0x11,0x10,0xed}};

//------------------------------------------------------------------------
//
//  Method:    addDataSourceListener()
//
//  Synopsis:  Sets the COM object which should receive notification
//             events.
//
//  Arguments: pEvent        Pointer to COM object to receive notification
//                           events, or NULL if no notifications to be sent.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP
CTDCCtl::addDataSourceListener(IUnknown *pListener)
{

    if (m_pEventBroker != NULL)
    {
        HRESULT hr = S_OK;
        IUnknown * pDatasrcListener;

        // Make sure this is the interface we expect
        hr = pListener->QueryInterface(IID_DataSourceListener,
                                       (void **)&pDatasrcListener);
        if (SUCCEEDED(hr))
        {
            m_pEventBroker->
                    SetDataSourceListener((DataSourceListener *)pDatasrcListener);

            // Clear any previous
            ClearInterface (&m_pDataSourceListener);
            // and remember the new.
            m_pDataSourceListener = (DataSourceListener *)pDatasrcListener;
        }
// ;begin_internal
        else
        {
            // The definition of this interface was changed from IDATASRCListener to
            // DataSourceListener.  To make sure we don't cause crashes, we QI to
            // determine which one we were handed.
            hr = pListener->QueryInterface(IID_IDATASRCListener,
                                           (void **)&pDatasrcListener);
            if (SUCCEEDED(hr))
            {
                m_pEventBroker->
                        SetDATASRCListener((DATASRCListener *) pDatasrcListener);

                // Clear any previous
                ClearInterface (&m_pDATASRCListener);
                // and remember the new.
                m_pDATASRCListener = (DATASRCListener *)pDatasrcListener;
            }
        }
// ;end_internal
        return hr;
    }
    else
        return E_FAIL;
}

//------------------------------------------------------------------------
//
//  Method:    Reset()
//
//  Synopsis:  Reset the control's filter/sort criteria.
//
//  Arguments: None.
//
//  Returns:   S_OK upon success.
//             Error code upon failure.
//
//------------------------------------------------------------------------

STDMETHODIMP CTDCCtl::Reset()
{
    HRESULT hr  = S_OK;

    // The next query to msDataSourceObject should get a new STD
    ClearInterface(&m_pSTD);

    // Infinite recursive calls to Reset can occur if script code calls reset
    // from within the datasetchanged event.  This isn't a good idea.
    if (m_fInReset)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    m_fInReset = TRUE;

    // Clear any previous error
    m_hrDownloadStatus = S_OK;

    if (m_fDataURLChanged)
    {
        if (!m_fAppendData)
        {
            // Release previous TDC array with "replacing" flag.
            hr = ReleaseTDCArr(TRUE);
            if (!SUCCEEDED(hr))         // possible memory failure
                goto Cleanup;
        }

        // Read the new data into a TDC arry, appending if specified.
        hr = CreateTDCArr((BOOL)m_fAppendData);
    }
    else if (m_pArr != NULL)
    {
        // Re-apply the sort and filter criteria
        hr = m_pArr->SetSortFilterCriteria(bstrConstructSortExpr(),
                                           bstrConstructFilterExpr(),
                                           m_fCaseSensitive ? 1 : 0);
    }

    m_fInReset = FALSE;

Cleanup:
    return hr;
}


//------------------------------------------------------------------------
//
//  Method:    bstrConstructSortExpr()
//
//  Synopsis:  Constructs a sort expression from the Sort property or
//             (for backward compatibility) from the SortColumn/SortAscending
//             properties.
//
//             This method only exists to isolate backward-compatibility
//             with the old-fashioned sort properties.
//
//  Arguments: None.
//
//  Returns:   The constructed sort expression.
//
//  NB!  It is the caller's responsibility to free the string returned.
//
//------------------------------------------------------------------------

BSTR
CTDCCtl::bstrConstructSortExpr()
{
    BSTR    bstr = NULL;

    if (!EmptyBSTR(m_cbstrSortExpr))
        bstr = SysAllocString(m_cbstrSortExpr);
    else if (!EmptyBSTR(m_cbstrSortColumn))
    {
        //  Use the old-fashioned sort properties
        //  Construct a sort expression of the form:
        //     <SortColumn>  or
        //    -<SortColumn>
        //
        if (m_fSortAscending)
            bstr = SysAllocString(m_cbstrSortColumn);
        else
        {
            bstr = SysAllocStringLen(NULL, SysStringLen(m_cbstrSortColumn) + 1);
            if (bstr != NULL)
            {
                bstr[0] = L'-';
                wch_cpy(&bstr[1], m_cbstrSortColumn);
            }
        }
    }

    return bstr;
}

//------------------------------------------------------------------------
//
//  Method:    bstrConstructFilterExpr()
//
//  Synopsis:  Constructs a filter expression from the Filter property or
//             (for backward compatibility) from the FilterColumn/FilterValue/
//             FilterCriterion properties.
//
//             This method only exists to isolate backward-compatibility
//             with the old-fashioned filter properties.
//
//  Arguments: None.
//
//  Returns:   The constructed filter expression
//
//  NB!  It is the caller's responsibility to free the string returned.
//
//------------------------------------------------------------------------

BSTR
CTDCCtl::bstrConstructFilterExpr()
{
    BSTR    bstr = NULL;

    if (!EmptyBSTR(m_cbstrFilterExpr))
        bstr = SysAllocString(m_cbstrFilterExpr);
    else if (!EmptyBSTR(m_cbstrFilterColumn))
    {
        //  Use the old-fashioned filter properties
        //  Construct a sort expression of the form:
        //     <FilterColumn> <FilterCriterion> "<FilterValue>"
        //
        BSTR bstrFilterOp;
        HRESULT hr;

        hr = get_FilterCriterion(&bstrFilterOp);
        if (!SUCCEEDED(hr))
            goto Cleanup;
        bstr = SysAllocStringLen(NULL,
                    SysStringLen(m_cbstrFilterColumn) +
                    SysStringLen(bstrFilterOp) +
                    1 +
                    SysStringLen(m_cbstrFilterValue) +
                    1);
        if (bstr != NULL)
        {
            DWORD pos = 0;

            wch_cpy(&bstr[pos], m_cbstrFilterColumn);
            pos = wch_len(bstr);
            wch_cpy(&bstr[pos], bstrFilterOp);
            pos = wch_len(bstr);
            bstr[pos++] = L'"';
            wch_cpy(&bstr[pos], m_cbstrFilterValue);
            pos = wch_len(bstr);
            bstr[pos++] = L'"';
            bstr[pos] = 0;
        }
        SysFreeString(bstrFilterOp);
    }
Cleanup:
    return bstr;
}

//------------------------------------------------------------------------
//
//  Method:    TerminateDataLoad()
//
//  Synopsis:  Stop the current data load operation.
//
//  Returns:   S_OK upon success.
//
//------------------------------------------------------------------------

STDMETHODIMP CTDCCtl::TerminateDataLoad(CMyBindStatusCallback<CTDCCtl> *pBSC)
{
    HRESULT hr  = S_OK;

    // if the termination isn't for the current download, ignore it (bug 104042)
    if (pBSC != m_pBSC)
        goto done;

    // Make sure if we call Reset() right away now, we don't re-download
    // the data.
    m_fDataURLChanged = FALSE;

    m_pBSC = NULL;      //  Block any outstanding OnData calls

    if (m_pEventBroker)
        m_pEventBroker->m_pBSC = NULL;  // kill all

    if (m_pUnify != NULL)
        delete m_pUnify;

    m_pUnify = NULL;

done:
    return hr;
}

//------------------------------------------------------------------------
//
//  Method:    InitiateDataLoad()
//
//  Synopsis:  Start loading data from the control's DataURL property.
//
//  Arguments: fAppend        Flag to indicate whether data should be
//                            appended to an existing TDCArr object.
//
//  Returns:   S_OK upon success.
//             E_OUTOFMEMORY if not enough memory could be allocated to
//               complete the download.
//
//------------------------------------------------------------------------

STDMETHODIMP CTDCCtl::InitiateDataLoad(boolean fAppend)
{
    HRESULT hr  = S_OK;

    WCHAR   wchFieldDelim = (!m_cbstrFieldDelim) ? 0 : m_cbstrFieldDelim[0];
    WCHAR   wchRowDelim   = (!m_cbstrRowDelim)   ? 0 : m_cbstrRowDelim[0];
    // Default quote char to double-quote, not NULL
    WCHAR   wchQuoteChar  = (!m_cbstrQuoteChar)  ? 0 : m_cbstrQuoteChar[0];
    WCHAR   wchEscapeChar = (!m_cbstrEscapeChar) ? 0 : m_cbstrEscapeChar[0];

    //
    // Default LCID
    //
    if (0==m_lcidRead)
    {
        hr = GetAmbientLocaleID(m_lcidRead);
        if (FAILED(hr))
        {
            // Ultimate default is US locale -- sort of Web global
            // language default.
            put_Language_(L"en-us");
        }
    }

    if (EmptyBSTR(m_cbstrDataURL))
    {
        hr = S_FALSE;                   // quiet failure
        goto Error;
    }

    OutputDebugStringX(_T("Initiating Data Download\n"));

    //  No data load should currently be in progress -
    //  This data load has been initiated on the construction of a new
    //  TDCArr object, or appending to an existing loaded TDCArr object.
    //  Any currently running data load would have been
    //  terminated by the call to ReleaseTDCArr().
    //

    _ASSERT(m_pUnify == NULL);
    _ASSERT(m_pBSC == NULL);


    m_hrDownloadStatus = S_OK;

    //  Create a pipeline of objects to process the URL data
    //
    //    CMyBindStatusCallback -> CTDCUnify -> CTDCTokenise -> CTDCArr
    //

    CComObject<CMyBindStatusCallback<CTDCCtl> >::CreateInstance(&m_pBSC);

    if (m_pBSC == NULL)
    {
        hr = E_FAIL;
        goto Error;
    }
    hr = m_pArr->StartDataLoad(m_fUseHeader ? TRUE : FALSE,
                               bstrConstructSortExpr(),
                               bstrConstructFilterExpr(),
                               m_lcidRead,
                               m_pBSC,
                               fAppend,
                               m_fCaseSensitive ? 1 : 0);
    if (!SUCCEEDED(hr))
        goto Error;

    m_pUnify = new CTDCUnify();
    if (m_pUnify == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }
    m_pUnify->Create(m_nCodePage, m_nAmbientCodePage, m_pML);

    // Init tokenizer
    m_pUnify->InitTokenizer(m_pArr, wchFieldDelim, wchRowDelim,
                            wchQuoteChar, wchEscapeChar);



    m_fSecurityChecked = FALSE;

    // Start (and maybe perform) actual download.
    // If we're within a Reset() call, always force a "reload" of the data
    // from the server -- i.e. turn on BINDF_GETNEWESTVERSION to make sure
    // sure the cache data isn't stale.
    hr = m_pBSC->StartAsyncDownload(this, OnData, m_cbstrDataURL, m_spClientSite, TRUE,
                                    m_fInReset == TRUE);
    if (FAILED(hr))
        goto Error;

    // m_hrDownloadStatus remembers the first (if any) error that occured during
    // the OnData callbacks.  Unlike an error returning from StartAsyncDownload,
    // this doesn't necessarily cause us to throw away the TDC array.
    hr = m_hrDownloadStatus;
    if (!SUCCEEDED(hr))
        m_pBSC = NULL;

Cleanup:
    return hr;

Error:
    TerminateDataLoad(m_pBSC);
    if (m_pEventBroker)
    {
        // Fire data set changed to indicate query failed,
        m_pEventBroker->STDDataSetChanged();
        // and go complete.
        UpdateReadyState(READYSTATE_COMPLETE);
    }
    goto Cleanup;
}

//------------------------------------------------------------------------
//
//  Method:    SecurityCheckDataURL(pszURL)
//
//  Synopsis:  Check that the data URL is within the same security zone
//             as the document that loaded the control.
//
//  Arguments: URL to check
//
//  Returns:   S_OK upon success.
//             E_INVALID if the security check failed or we failed to get
//               an interface that we needed
//
//------------------------------------------------------------------------


// ;begin_internal
// Wendy Richards(v-wendri) 6/6/97
// Copied this here because I couldn't link without it. The version
// of URLMON.LIB I have does not have this symbol exported
// ;end_internal

EXTERN_C const IID IID_IInternetHostSecurityManager;

#define MAX_SEC_ID 256

STDMETHODIMP CTDCCtl::SecurityCheckDataURL(LPOLESTR pszURL)
{
    CComQIPtr<IServiceProvider, &IID_IServiceProvider> pSP(m_spClientSite);
    CComPtr<IInternetSecurityManager> pSM;
    CComPtr<IInternetHostSecurityManager> pHSM;
    CComPtr<IMoniker> pMoniker;

    BYTE     bSecIDHost[MAX_SEC_ID], bSecIDURL[MAX_SEC_ID];
    DWORD    cbSecIDHost = MAX_SEC_ID, cbSecIDURL = MAX_SEC_ID;
    HRESULT  hr = E_FAIL;

    USES_CONVERSION;

    // If we're running under the timer, it's quite possible our ClientSite will
    // disappear out from under us.  We'll obviously fail the security check,
    // but things are shutting down anyway..
    if (pSP==NULL)
        goto Cleanup;

    hr = CoInternetCreateSecurityManager(pSP, &pSM, 0L);
    if (!SUCCEEDED(hr))
        goto Cleanup;

    hr = pSP->QueryService(IID_IInternetHostSecurityManager,
                           IID_IInternetHostSecurityManager,
                           (LPVOID *)&pHSM);
    if (!SUCCEEDED(hr))
        goto Cleanup;

    hr = pHSM->GetSecurityId(bSecIDHost, &cbSecIDHost, 0L);
    if (!SUCCEEDED(hr))
        goto Cleanup;

    hr = pSM->GetSecurityId(OLE2W(pszURL), bSecIDURL, &cbSecIDURL, 0L);
    if (!SUCCEEDED(hr))
        goto Cleanup;

    if (cbSecIDHost != cbSecIDURL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (memcmp(bSecIDHost, bSecIDURL, cbSecIDHost) != 0)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:
#ifdef ATLTRACE
    LPOLESTR pszHostName = NULL;
    TCHAR *pszFailPass = hr ? _T("Failed") : _T("Passed");
    GetHostURL(m_spClientSite, &pszHostName);
    ATLTRACE(_T("CTDCCtl: %s security check on %S referencing %S\n"), pszFailPass,
             pszHostName, pszURL);
    bSecIDHost[cbSecIDHost] = 0;
    bSecIDURL[cbSecIDURL] = 0;
    ATLTRACE(_T("CTDCCtl: Security ID Host %d bytes: %s\n"), cbSecIDHost, bSecIDHost);
    ATLTRACE(_T("CTDCCtl: Security ID URL %d bytes: %s\n"), cbSecIDURL, bSecIDURL);
    CoTaskMemFree(pszHostName);
#endif
    return hr;
}

//------------------------------------------------------------------------
//
//  Method:    OnData()
//
//  Synopsis:  Accepts a chunk of data loaded from a URL and parses it.
//
//  Arguments: pBSC       The invoking data transfer object.
//             pBytes     Character buffer containing data.
//             dwSize     Count of the number of bytes in 'pBytes'.
//
//  Returns:   Nothing.
//
//------------------------------------------------------------------------

void CTDCCtl::OnData(CMyBindStatusCallback<CTDCCtl> *pBSC, BYTE *pBytes, DWORD dwSize)
{
    HRESULT hr = S_OK;
    CTDCUnify::ALLOWDOMAINLIST nAllowDomainList;

    if (pBSC != m_pBSC)
    {
        OutputDebugStringX(_T("OnData called from invalid callback object\n"));
        goto Cleanup;
    }

    // ignore callbacks from an aborted download
    if (m_hrDownloadStatus == E_ABORT)
        goto Cleanup;

    //  Process this chunk of data
    //
    hr = m_pUnify->ConvertByteBuffer(pBytes, dwSize);

    if (hr == S_FALSE)
    {
        // not enough data has shown up yet, just keep going
        hr = S_OK;
        goto Cleanup;
    }

    if (hr)
        goto Error;

    if (!m_fSecurityChecked)
    {
        // this forces the code below to check the DataURL, unless the allow_domain
        // list needs checking and it passes.  In that case, we need only check
        // the protocols, not the whole URL.
        hr = E_FAIL;

        if (!m_pUnify->ProcessedAllowDomainList())
        {
            // Note that we MUST check for the allow domain list at the
            // front of every file, even if it's on the same host.  This
            // is to make sure if we always strip off the @!allow_domain line.
            nAllowDomainList = m_pUnify->CheckForAllowDomainList();

            switch (nAllowDomainList)
            {
                // Don't have enough chars to tell yet.
                case CTDCUnify::ALLOW_DOMAINLIST_DONTKNOW:
                    if (pBytes != NULL && dwSize != 0)
                    {
                        // Return without errors or arborting.
                        // Presumably the next data packet will bring more info.
                        return;
                    }
                    _ASSERT(FAILED(hr));
                    break;

                case CTDCUnify::ALLOW_DOMAINLIST_NO:
                    _ASSERT(FAILED(hr));
                    break;

                case CTDCUnify::ALLOW_DOMAINLIST_YES:
                    // The file is decorated.  Now check the domain list
                    // against our host domain name.
                    hr = SecurityMatchAllowDomainList();
#ifdef ATLTRACE
                    if (!hr) ATLTRACE(_T("CTDCCtl: @!allow_domain list matched."));
                    else ATLTRACE(_T("CTDCCtl: @!allow_domain list did not match"));
#endif
                    break;
            }
        }

        // Unless we passed the previous security check, we still have to
        // do the next one.
        if (FAILED(hr))
        {
            if (FAILED(hr = SecurityCheckDataURL(m_pBSC->m_pszURL)))
                goto Error;
        }
        else
        {
            hr = SecurityMatchProtocols(m_pBSC->m_pszURL);
            if (FAILED(hr))
                goto Error;
        }


        // Set m_fSecurityChecked only if it passes security.  This is in case for some
        // reason we get more callbacks before the StopTransfer takes affect.
        m_fSecurityChecked = TRUE;
    }

    if (pBytes != NULL && dwSize != 0)
    {
        OutputDebugStringX(_T("OnData called with data buffer\n"));

        // Normal case, we can process data!
        hr = m_pUnify->AddWcharBuffer(FALSE);
        if (hr == E_ABORT)
            goto Error;
    }
    else if (pBytes == NULL || dwSize == 0)
    {
        OutputDebugStringX(_T("OnData called with empty (terminating) buffer\n"));

        //  No more data - trigger an EOF
        //
        hr = m_pUnify->AddWcharBuffer(TRUE); // last chance to parse any stragglers
        if (hr == E_ABORT)
            goto Error;

        if (m_pArr!=NULL)
            hr = m_pArr->EOF();

        TerminateDataLoad(pBSC);
    }

Cleanup:
    //  Void fn - can't return an error code ...
    //
    if (SUCCEEDED(m_hrDownloadStatus))
        m_hrDownloadStatus = hr;
    return;

Error:
    // Security failure.
    // Abort the current download
    if (m_pBSC && m_pBSC->m_spBinding)
    {
        (void) m_pBSC->m_spBinding->Abort();

        // also delete the downloaded file from the internet cache
        m_pBSC->DeleteDataFile();
    }

    m_hrDownloadStatus = hr;

    // Notify data set changed for the abort
    if (m_pEventBroker != NULL)
    {
        hr = m_pEventBroker->STDDataSetChanged();
        // and go complete.
        UpdateReadyState(READYSTATE_COMPLETE);
    }
    goto Cleanup;
}

//
// Utility routine to get our
//
HRESULT
GetHostURL(IOleClientSite *pSite, LPOLESTR *ppszHostName)
{
    HRESULT hr;
    CComPtr<IMoniker> spMoniker;
    CComPtr<IBindCtx> spBindCtx;

    if (!pSite)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pSite->GetMoniker(OLEGETMONIKER_ONLYIFTHERE, OLEWHICHMK_CONTAINER,
                           &spMoniker);
    if (FAILED(hr))
        goto Cleanup;

    hr = CreateBindCtx(0, &spBindCtx);
    if (FAILED(hr))
        goto Cleanup;

    hr = spMoniker->GetDisplayName(spBindCtx, NULL, ppszHostName);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

HRESULT
CTDCCtl::SecurityMatchProtocols(LPOLESTR pszURL)
{
    HRESULT hr = E_FAIL;

    LPOLESTR pszHostURL = NULL;
    LPWCH pszPostHostProtocol;
    LPWCH pszPostProtocol;

    if (FAILED(GetHostURL(m_spClientSite, &pszHostURL)))
        goto Cleanup;

    pszPostHostProtocol = wch_chr(pszHostURL, _T(':'));
    pszPostProtocol     = wch_chr(pszURL, _T(':'));
    if (!pszPostHostProtocol || !pszPostProtocol)
        goto Cleanup;
    else
    {
        int ccChars1 = pszPostHostProtocol - pszHostURL;
        int ccChars2 = pszPostProtocol - pszURL;
        if (ccChars1 != ccChars2)
            goto Cleanup;
        else if (wch_ncmp(pszHostURL, pszURL, ccChars1) != 0)
            goto Cleanup;
    }
    hr = S_OK;

Cleanup:
    if (pszHostURL)
        CoTaskMemFree(pszHostURL);

    return hr;
}

HRESULT
CTDCCtl::SecurityMatchAllowDomainList()
{
    HRESULT hr;
    WCHAR swzHostDomain[INTERNET_MAX_HOST_NAME_LENGTH];
    DWORD cchHostDomain = INTERNET_MAX_HOST_NAME_LENGTH;
    LPOLESTR pszHostName = NULL;

    hr = GetHostURL(m_spClientSite, &pszHostName);
    if (FAILED(hr))
        goto Cleanup;

    hr = CoInternetParseUrl(pszHostName, PARSE_DOMAIN, 0, swzHostDomain, cchHostDomain,
                            &cchHostDomain, 0);
    if (FAILED(hr))
        goto Cleanup;

    hr = m_pUnify->MatchAllowDomainList(swzHostDomain);

Cleanup:
    CoTaskMemFree(pszHostName);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\tdc\tdcids.h ===
#define DISPID_FIELDDELIM       1
#define DISPID_ROWDELIM         2
#define DISPID_TEXTQUALIFIER    3
#define DISPID_ESCAPECHAR       4
#define DISPID_USEHEADER        5
#define DISPID_SORTCOLUMN       6
#define DISPID_SORTASCENDING    7
#define DISPID_FILTERVALUE      8
#define DISPID_FILTERCRITERION  9
#define DISPID_FILTERCOLUMN     10
#define DISPID_CHARSET          11
#define DISPID_DATAURL          12
#define DISPID_SIMPLEPROVIDER   13
#define DISPID_LANGUAGE         14
#define DISPID_TIMER            15
#define DISPID_FILTER           16
#define DISPID_SORT             17
#define DISPID_APPENDDATA       18
#define DISPID_OSP              19
#define DISPID_CASESENSITIVE    20
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\tdc\tdcctl.h ===
//+-----------------------------------------------------------------------
//
//  Tabular Data Control
//  Copyright (C) Microsoft Corporation, 1996, 1997
//
//  File:       TDCCtl.h
//
//  Contents:   Declaration of the CTDCCtl ActiveX Control.
//
//------------------------------------------------------------------------


#include "resource.h"       // main symbols
#include <simpdata.h>
#include "wch.h"
#include <wininet.h>        // for INTERNET_MAX_URL_LENGTH

#pragma comment(lib, "wininet.lib")

#ifndef DISPID_AMBIENT_CODEPAGE
#define DISPID_AMBIENT_CODEPAGE (-725)
#endif

// Declare helper needed in IHttpNegotiateImpl
HRESULT
GetHostURL(IOleClientSite *pSite, LPOLESTR *ppszHostName);

//------------------------------------------------------------------------
//
//  Template:  CMyBindStatusCallback
//
//  Synopsis:  This is a temporary kludge to get around an ATL feature
//             while we're waiting for it to become official code.
//
//------------------------------------------------------------------------

template <class T>
class ATL_NO_VTABLE IServiceProviderImpl
{
    public:
        // IUnknown
        //
        STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
        _ATL_DEBUG_ADDREF_RELEASE_IMPL(IServiceProviderImpl)

        STDMETHOD(QueryService) (REFGUID guidService,
                                 REFIID riid,
                                 void **ppvObject)
        {
            return S_OK;
        }

};

template <class T>
class ATL_NO_VTABLE IHttpNegotiateImpl
{
    public:
        // IUnknown
        //
        STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
        _ATL_DEBUG_ADDREF_RELEASE_IMPL(IHttpNegotiateImpl)

        STDMETHOD(BeginningTransaction) (LPCWSTR szURL,
                                         LPCWSTR szHeaders,
                                         DWORD dwReserved,
                                         LPWSTR *pszAdditionalHeaders)
        {
            return S_OK;
        }

        STDMETHOD(OnResponse) (DWORD dwResponseCode,
                               LPCWSTR szResponseHeaders,
                               LPCWSTR szRequestHeaders,
                               LPWSTR *pszAdditionalRequestHeaders)
        {
            return S_OK;
        }

};


// IE5 85290:  mshtml needs a way to recognize the TDC from
// its IBindStatusCallback.  We define a dummy interface for this.

template <class T>
class ATL_NO_VTABLE IAmTheTDCImpl
{
    public:
        // IUnknown
        //
        STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
        _ATL_DEBUG_ADDREF_RELEASE_IMPL(IAmTheTDCImpl)
};


template <class T>
class ATL_NO_VTABLE CMyBindStatusCallback :
    public CComObjectRootEx<typename T::_ThreadModel::ThreadModelNoCS>,
    public IBindStatusCallbackImpl<T>, public IHttpNegotiateImpl<T>, public IServiceProviderImpl<T>,
    public IAmTheTDCImpl<T>
{
    typedef void (T::*ATL_PDATAAVAILABLE)(CMyBindStatusCallback<T>* pbsc, BYTE* pBytes, DWORD dwSize);

    public:

        BEGIN_COM_MAP(CMyBindStatusCallback<T>)
                COM_INTERFACE_ENTRY_IID(IID_IBindStatusCallback, IBindStatusCallbackImpl<T>)
                COM_INTERFACE_ENTRY_IID(IID_IHttpNegotiate, IHttpNegotiateImpl<T>)
                COM_INTERFACE_ENTRY_IID(IID_IServiceProvider, IServiceProviderImpl<T>)
                COM_INTERFACE_ENTRY_IID(IID_IAmTheTDC, IAmTheTDCImpl<T>)
        END_COM_MAP()

        CMyBindStatusCallback()
        {
            m_pT = NULL;
            m_pFunc = NULL;
            m_fReload = FALSE;
        }
        ~CMyBindStatusCallback()
        {
            ATLTRACE(_T("~CMyBindStatusCallback\n"));
        }

        // IServiceProvider methods

        STDMETHOD(QueryService) (REFGUID guidService,
                                 REFIID riid,
                                 void **ppvObject)
        {
            // As it turns out, the service ID for IHttpNegotiate is the same
            // as it's IID (confusing).  This is the only service we support.
            if (IsEqualGUID(IID_IHttpNegotiate, guidService))
            {
                return ((IHttpNegotiate *)this)->QueryInterface(riid, ppvObject);
            }
            else return E_NOTIMPL;
        }

        //
        // IHttpNegotiate methods
        //

        STDMETHOD(BeginningTransaction) (LPCWSTR szURL,
                                         LPCWSTR szHeaders,
                                         DWORD dwReserved,
                                         LPWSTR *pszAdditionalHeaders)
        {
            HRESULT hr = S_OK;
            WCHAR swzHostScheme[INTERNET_MAX_URL_LENGTH];
            DWORD cchHostScheme = INTERNET_MAX_URL_LENGTH;
            WCHAR swzFileScheme[INTERNET_MAX_URL_LENGTH];
            DWORD cchFileScheme = INTERNET_MAX_URL_LENGTH;            

            LPOLESTR pszHostName;

            *pszAdditionalHeaders = NULL;

            hr = GetHostURL(m_spClientSite, &pszHostName);
            if (FAILED(hr))
                goto Cleanup;

            // PARSE_SCHEMA didn't work, so we'll just CANONICALIZE and then use the first N
            // characters of the URL
            hr = CoInternetParseUrl(pszHostName, PARSE_CANONICALIZE, 0, swzHostScheme, cchHostScheme,
                                    &cchHostScheme, 0);
            if (FAILED(hr))
                goto Cleanup;

            // Don't send a referer which isn't http: or https:, it's none
            // of the servers' business.  Further, don't send an https:
            // referer when requesting an http: file.
            if (0 != wch_incmp(swzHostScheme, L"https:", 6) &&
                0 != wch_incmp(swzHostScheme, L"http:", 5))
                goto Cleanup;

            if (0 == wch_incmp(swzHostScheme, L"https:", 6))
            {
                hr = CoInternetParseUrl(szURL, PARSE_CANONICALIZE, 0, swzFileScheme, cchFileScheme,
                                        &cchFileScheme, 0);
                if (0 == wch_incmp(swzFileScheme, L"http:", 5)) // don't send https: referer
                    goto Cleanup;                                // to an http: file.
            }

            // 3*sizeof(WCHAR) is for CR, LF, & '\0'
            *pszAdditionalHeaders = (WCHAR *)CoTaskMemAlloc(sizeof(L"Referer: ") +
                                                            ocslen(pszHostName)*sizeof(WCHAR) +
                                                            3*sizeof(WCHAR));
            if (NULL != *pszAdditionalHeaders)
            {
                ocscpy(*pszAdditionalHeaders, L"Referer: ");
                ocscpy(&((*pszAdditionalHeaders)[9]), pszHostName);
                ocscpy(&((*pszAdditionalHeaders)[9+ocslen(pszHostName)]), L"\r\n");
            }

Cleanup:
            CoTaskMemFree(pszHostName);
            return hr;
        }

        STDMETHOD(OnResponse) (DWORD dwResponseCode,
                               LPCWSTR szResponseHeaders,
                               LPCWSTR szRequestHeaders,
                               LPWSTR *pszAdditionalRequestHeaders)
        {
            return S_OK;
        }



        //
        // IBindStatusCallback methods
        //

        STDMETHOD(OnStartBinding)(DWORD dwReserved, IBinding *pBinding)
        {
            ATLTRACE(_T("CMyBindStatusCallback::OnStartBinding\n"));
            m_spBinding = pBinding;
            return S_OK;
        }

        STDMETHOD(GetPriority)(LONG *pnPriority)
        {
            ATLTRACENOTIMPL(_T("CMyBindStatusCallback::GetPriority"));
        }

        STDMETHOD(OnLowResource)(DWORD reserved)
        {
            ATLTRACENOTIMPL(_T("CMyBindStatusCallback::OnLowResource"));
        }

        STDMETHOD(OnProgress)(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText)
        {
            if (BINDSTATUS_REDIRECTING == ulStatusCode && szStatusText != NULL)
            {
                ocscpy(m_pszURL, szStatusText);
            }
            return S_OK;
        }

        STDMETHOD(OnStopBinding)(HRESULT hresult, LPCWSTR szError)
        {
            //      ATLTRACE(_T("CMyBindStatusCallback::OnStopBinding\n"));
            (m_pT->*m_pFunc)(this, NULL, 0);
            if (m_spWinInetFileStream)
            {
                m_spWinInetFileStream.Release();
            }
            m_spBinding.Release();
            m_spBindCtx.Release();
            m_spMoniker.Release();
            return S_OK;
        }

        STDMETHOD(GetBindInfo)(DWORD *pgrfBINDF, BINDINFO *pbindInfo)
        {
            ATLTRACE(_T("CMyBindStatusCallback::GetBindInfo\n"));

            if (!pbindInfo || !pbindInfo->cbSize || !pgrfBINDF)
                return E_INVALIDARG;

            *pgrfBINDF = BINDF_ASYNCHRONOUS
                         | BINDF_ASYNCSTORAGE
                         ;
// ;begin_internal
#ifdef NEVER
            // I want DEBUG mode to NOT cache things!! -cfranks
            *pgrfBINDF |= BINDF_GETNEWESTVERSION
                          | BINDF_NOWRITECACHE
                          | BINDF_RESYNCHRONIZE
                          ;
#endif
// ;end_internal

#ifndef DISPID_AMBIENT_OFFLINE
#define DISPID_AMBIENT_OFFLINE          (-5501)
#endif
            // Get our offline property from container
            VARIANT var;
            VariantInit(&var);
            DWORD dwConnectedStateFlags;
            m_pT->GetAmbientProperty(DISPID_AMBIENT_OFFLINE, var);
            if (var.vt==VT_BOOL && var.boolVal)
            {
                if (!(InternetGetConnectedState(&dwConnectedStateFlags, 0)) &&
                    (0 == (dwConnectedStateFlags & INTERNET_CONNECTION_MODEM_BUSY)))
                {
                    ATLTRACE(_T("CMyBindStatusCallback::GetBindInfo OFFLINE\n"));
                   // We're not even dialed out to another connectoid
                    *pgrfBINDF |= BINDF_OFFLINEOPERATION;
                }
                else
                {
                    ATLTRACE(_T("CMyBindStatusCallback::GetBindInfo OFFLINE\n"));
                    *pgrfBINDF &= ~BINDF_OFFLINEOPERATION;                   
                }
            }

            // See if we should force a reload, iff we're not offline.
            if (!(*pgrfBINDF & BINDF_OFFLINEOPERATION) && m_fReload)
            {
                *pgrfBINDF |= BINDF_RESYNCHRONIZE|BINDF_PRAGMA_NO_CACHE;
            }

            ULONG cbSize = pbindInfo->cbSize;
            memset(pbindInfo, 0, cbSize);

            pbindInfo->cbSize = cbSize;
            pbindInfo->dwBindVerb = BINDVERB_GET;

            return S_OK;
        }

        STDMETHOD(OnDataAvailable)(DWORD grfBSCF, DWORD dwSize, FORMATETC *pformatetc, STGMEDIUM *pstgmed)
        {
            ATLTRACE(_T("CMyBindStatusCallback::OnDataAvailable\n"));
            HRESULT hr = S_OK;

            // Get the Stream passed
            if (BSCF_FIRSTDATANOTIFICATION & grfBSCF)
            {
                if (!m_spStream && pstgmed->tymed == TYMED_ISTREAM)
                {
                    m_spStream = pstgmed->pstm;
                    (void)m_spStream->QueryInterface(IID_IWinInetFileStream, (void **)&m_spWinInetFileStream);

                    if (m_spWinInetFileStream)
                    {
                        CComPtr<IWinInetHttpInfo> spWinInetHttpInfo;
                        (void)m_spBinding->QueryInterface(IID_IWinInetHttpInfo, (void **)&spWinInetHttpInfo);
                        if (spWinInetHttpInfo)
                        {
                            HANDLE hWinInetLock = NULL;
                            DWORD dwHandleSize = sizeof(HANDLE);
                            HRESULT hr = spWinInetHttpInfo->QueryOption(WININETINFO_OPTION_LOCK_HANDLE, (LPVOID)&hWinInetLock, &dwHandleSize);
                            if (SUCCEEDED(hr) && hWinInetLock)
                            {
                                m_spWinInetFileStream->SetHandleForUnlock((DWORD_PTR)hWinInetLock, 0);
                            }
                            spWinInetHttpInfo.Release();
                        }
                    }
                }
            }

            DWORD dwRead = dwSize - m_dwTotalRead; // Minimum amount available that hasn't been read
            DWORD dwActuallyRead = 0;            // Placeholder for amount read during this pull

            // If there is some data to be read then go ahead and read them
            if (m_spStream)
            {
                if (dwRead > 0)
                {
                    BYTE* pBytes = NULL;
                    ATLTRY(pBytes = new BYTE[dwRead + 1]);
                    if (pBytes == NULL)
                        return S_FALSE;
                    hr = m_spStream->Read(pBytes, dwRead, &dwActuallyRead);
                    if (SUCCEEDED(hr))
                    {
                        pBytes[dwActuallyRead] = 0;
                        if (dwActuallyRead>0)
                        {
                            (m_pT->*m_pFunc)(this, pBytes, dwActuallyRead);
                            m_dwTotalRead += dwActuallyRead;
                        }
                    }
                    delete[] pBytes;
                }
            }

            if (BSCF_LASTDATANOTIFICATION & grfBSCF)
                m_spStream.Release();
            return hr;
        }

        STDMETHOD(OnObjectAvailable)(REFIID riid, IUnknown *punk)
        {
            ATLTRACENOTIMPL(_T("CMyBindStatusCallback::OnObjectAvailable"));
        }

        HRESULT _StartAsyncDownload(BSTR bstrURL, IUnknown* pUnkContainer, BOOL bRelative)
        {
            m_dwTotalRead = 0;
            m_dwAvailableToRead = 0;
            HRESULT hr = S_OK;
            CComQIPtr<IServiceProvider, &IID_IServiceProvider> spServiceProvider(pUnkContainer);
            CComPtr<IBindHost> spBindHost;
            CComPtr<IStream> spStream;
            if (spServiceProvider)
                spServiceProvider->QueryService(SID_IBindHost, IID_IBindHost, (void**)&spBindHost);

            // We don't bother checking this QI, because the only failure mode is that our
            // BeginningNegotitation method won't be able able to properly add the referer string.
            (void)pUnkContainer->QueryInterface(IID_IOleClientSite, (void **)&m_spClientSite);

            if (spBindHost == NULL)
            {
                if (bRelative)
                    return E_NOINTERFACE;  // relative asked for, but no IBindHost
                hr = CreateURLMoniker(NULL, bstrURL, &m_spMoniker);
                if (SUCCEEDED(hr))
                    hr = CreateBindCtx(0, &m_spBindCtx);

                if (SUCCEEDED(hr))
                    hr = RegisterBindStatusCallback(m_spBindCtx, reinterpret_cast<IBindStatusCallback*>(static_cast<IBindStatusCallbackImpl<T>*>(this)), 0, 0L);
                else
                    m_spMoniker.Release();

                if (SUCCEEDED(hr))
                {
                    LPOLESTR pszTemp = NULL;
                    hr = m_spMoniker->GetDisplayName(m_spBindCtx, NULL, &pszTemp);
                    if (!hr && pszTemp != NULL)
                        ocscpy(m_pszURL, pszTemp);
                    CoTaskMemFree(pszTemp);

                    hr = m_spMoniker->BindToStorage(m_spBindCtx, 0, IID_IStream, (void**)&spStream);
                }
            }
            else
            {
                hr = CreateBindCtx(0, &m_spBindCtx);
                if (SUCCEEDED(hr))
                    hr = RegisterBindStatusCallback(m_spBindCtx, reinterpret_cast<IBindStatusCallback*>(static_cast<IBindStatusCallbackImpl<T>*>(this)), 0, 0L);

                if (SUCCEEDED(hr))
                {
                    if (bRelative)
                        hr = spBindHost->CreateMoniker(bstrURL, m_spBindCtx, &m_spMoniker, 0);
                    else
                        hr = CreateURLMoniker(NULL, bstrURL, &m_spMoniker);
                }

                if (SUCCEEDED(hr))
                {
                    LPOLESTR pszTemp = NULL;
                    hr = m_spMoniker->GetDisplayName(m_spBindCtx, NULL, &pszTemp);
                    if (!hr && pszTemp != NULL)
                        ocscpy(m_pszURL, pszTemp);
                    CoTaskMemFree(pszTemp);
                    hr = spBindHost->MonikerBindToStorage(m_spMoniker, NULL, reinterpret_cast<IBindStatusCallback*>(static_cast<IBindStatusCallbackImpl<T>*>(this)), IID_IStream, (void**)&spStream);
                    ATLTRACE(_T("Bound"));
                }
            }
            return hr;
        }

        HRESULT StartAsyncDownload(T* pT, ATL_PDATAAVAILABLE pFunc, BSTR bstrURL, IUnknown* pUnkContainer, BOOL bRelative,
                                   BOOL fReload)
        {
            m_pT = pT;
            m_pFunc = pFunc;
            m_fReload = fReload;        // force reload if TRUE
            return  _StartAsyncDownload(bstrURL, pUnkContainer, bRelative);
        }

        static HRESULT Download(T* pT, ATL_PDATAAVAILABLE pFunc, BSTR bstrURL, IUnknown* pUnkContainer = NULL, BOOL bRelative = FALSE)
        {
            CComObject<CMyBindStatusCallback<T> > *pbsc;
            HRESULT hRes = CComObject<CMyBindStatusCallback<T> >::CreateInstance(&pbsc);
            if (FAILED(hRes))
                return hRes;
            return pbsc->StartAsyncDownload(pT, pFunc, bstrURL, pUnkContainer, bRelative, FALSE);
        }

        void DeleteDataFile()
        {
            // we can't delete the file at the time of the call (it's in use), so
            // mark it for deletion later - at stream destruction time
            if (m_spWinInetFileStream)
            {
                m_spWinInetFileStream->SetDeleteFile(0);
            }
        }

        CComPtr<IMoniker> m_spMoniker;
        CComPtr<IBindCtx> m_spBindCtx;
        CComPtr<IBinding> m_spBinding;
        CComPtr<IWinInetFileStream> m_spWinInetFileStream;
        CComPtr<IStream> m_spStream;
        CComPtr<IOleClientSite> m_spClientSite;
        BOOL m_fReload;
        OLECHAR m_pszURL[INTERNET_MAX_URL_LENGTH];
        T* m_pT;
        ATL_PDATAAVAILABLE m_pFunc;
        DWORD m_dwTotalRead;
        DWORD m_dwAvailableToRead;
};

//////////////////////////////////////////////////////////////////////////////////////////////////
// CTimer
template <class Derived, class T, const IID* piid>
class CTimer
{
public:

    CTimer()
    {
        m_bTimerOn = FALSE;
    }

    HRESULT TimerOn(DWORD dwTimerInterval)
    {
        Derived* pDerived = ((Derived*)this);

        m_dwTimerInterval = dwTimerInterval;
        if (m_bTimerOn) // already on, just change interval
            return S_OK;

        m_bTimerOn = TRUE;
        m_dwTimerInterval = dwTimerInterval;
        m_pStream = NULL; 

        HRESULT hRes;

        hRes = CoMarshalInterThreadInterfaceInStream(*piid, (T*)pDerived, &m_pStream);

        // Create thread and pass the thread proc the this ptr
        m_hThread = CreateThread(NULL, 0, &_Apartment, (void*)this, 0, &m_dwThreadID);

        return S_OK;
    }

    void TimerOff()
    {
        if (m_bTimerOn)
        {
            m_bTimerOn = FALSE;
            AtlWaitWithMessageLoop(m_hThread);
        }
    }


// Implementation
private:
    static DWORD WINAPI _Apartment(void* pv)
    {
        CTimer<Derived, T, piid>* pThis = (CTimer<Derived, T, piid>*) pv;
        pThis->Apartment();
        return 0;
    }

    DWORD Apartment()
    {
        CoInitialize(NULL);
        HRESULT hRes;

        m_spT.Release();

        if (m_pStream)
        {
            hRes = CoGetInterfaceAndReleaseStream(m_pStream, *piid, (void**)&m_spT);
        }

        while(m_bTimerOn)
        {
            Sleep(m_dwTimerInterval);
            if (!m_bTimerOn)
                break;

            m_spT->_OnTimer();
        }
        m_spT.Release();

        CoUninitialize();
        return 0;
    }

// Attributes
public:
    DWORD m_dwTimerInterval;

// Implementation
private:
    HANDLE m_hThread;
    DWORD m_dwThreadID;
    LPSTREAM m_pStream;
    CComPtr<T> m_spT;
    BOOL m_bTimerOn;
};

class CEventBroker;

//////////////////////////////////////////////////////////////////////////////
// CProxyITDCCtlEvents
template <class T>
class CProxyITDCCtlEvents : public IConnectionPointImpl<T, &IID_ITDCCtlEvents, CComDynamicUnkArray>
{
//ITDCCtlEvents : IDispatch
public:
    void FireOnReadyStateChanged()
    {
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                DISPPARAMS dispParams;
                dispParams.cArgs = 0;
                dispParams.cNamedArgs = 0;
                dispParams.rgvarg = NULL;
                dispParams.rgdispidNamedArgs = NULL;
                ITDCCtlEvents* pITDCCtlEvents = reinterpret_cast<ITDCCtlEvents*>(*pp);
                pITDCCtlEvents->Invoke(DISPID_READYSTATECHANGE, IID_NULL, CP_ACP, DISPATCH_METHOD, &dispParams,
                                       NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
        return;
    }

};


//------------------------------------------------------------------------
//
//  Class:     CTDCCtl
//
//  Synopsis:  This is the TabularDataControl COM object.
//             It creates a CTDCArr object to manage the control's data.
//
//------------------------------------------------------------------------

class CTDCCtl :
    public CComObjectRoot,
    public CComCoClass<CTDCCtl, &CLSID_CTDCCtl>,
    public CComControl<CTDCCtl>,
    public CStockPropImpl<CTDCCtl, ITDCCtl, &IID_ITDCCtl, &LIBID_TDCLib>,
    public IProvideClassInfo2Impl<&CLSID_CTDCCtl, &IID_ITDCCtlEvents, &LIBID_TDCLib>,
    public IPersistStreamInitImpl<CTDCCtl>,
    public IOleControlImpl<CTDCCtl>,
    public IOleObjectImpl<CTDCCtl>,
    public IOleInPlaceActiveObjectImpl<CTDCCtl>,
    public IViewObjectExImpl<CTDCCtl>,
    public IOleInPlaceObjectWindowlessImpl<CTDCCtl>,
    public IPersistPropertyBagImpl<CTDCCtl>,
    public CTimer<CTDCCtl, ITDCCtl, &IID_ITDCCtl>,
    public IRunnableObjectImpl<CTDCCtl>,
    public IConnectionPointContainerImpl<CTDCCtl>,
    public IPropertyNotifySinkCP<CTDCCtl>,
    public CProxyITDCCtlEvents<CTDCCtl>
{
public:
    CTDCCtl();
    ~CTDCCtl();

DECLARE_REGISTRY_RESOURCEID(IDR_TDCCtl)

DECLARE_NOT_AGGREGATABLE(CTDCCtl)

BEGIN_COM_MAP(CTDCCtl) 
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITDCCtl)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY_IMPL(IOleControl)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
    COM_INTERFACE_ENTRY_IMPL(IRunnableObject)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CTDCCtl)
    PROP_ENTRY("RowDelim",      DISPID_ROWDELIM,    CLSID_CTDCCtl)
    PROP_ENTRY("FieldDelim",    DISPID_FIELDDELIM,  CLSID_CTDCCtl)
    PROP_ENTRY("TextQualifier", DISPID_TEXTQUALIFIER,   CLSID_CTDCCtl)
    PROP_ENTRY("EscapeChar",    DISPID_ESCAPECHAR,  CLSID_CTDCCtl)
    PROP_ENTRY("UseHeader",     DISPID_USEHEADER,   CLSID_CTDCCtl)
    PROP_ENTRY("SortAscending", DISPID_SORTASCENDING,   CLSID_CTDCCtl)
    PROP_ENTRY("SortColumn",    DISPID_SORTCOLUMN,  CLSID_CTDCCtl)
    PROP_ENTRY("FilterValue",   DISPID_FILTERVALUE, CLSID_CTDCCtl)
    PROP_ENTRY("FilterCriterion",   DISPID_FILTERCRITERION, CLSID_CTDCCtl)
    PROP_ENTRY("FilterColumn",  DISPID_FILTERCOLUMN,CLSID_CTDCCtl)
    PROP_ENTRY("CharSet",       DISPID_CHARSET,     CLSID_CTDCCtl)
    PROP_ENTRY("Language",      DISPID_LANGUAGE,    CLSID_CTDCCtl)
    PROP_ENTRY("CaseSensitive", DISPID_CASESENSITIVE, CLSID_CTDCCtl)
    PROP_ENTRY("Sort",          DISPID_SORT,        CLSID_CTDCCtl)
// ;begin_internal
//  Doesn't work right yet.
//    PROP_ENTRY("RefreshInterval",   DISPID_TIMER,      CLSID_CTDCCtl)
// ;end_internal
    PROP_ENTRY("Filter",        DISPID_FILTER,      CLSID_CTDCCtl)
    PROP_ENTRY("AppendData",    DISPID_APPENDDATA,  CLSID_CTDCCtl)
// ;begin_internal
//  Trying to save this property causes OLEAUT to GP Fault trying
//  to conver the IDispatch * to a BSTR!
//    PROP_ENTRY("OSP",           DISPID_OSP,         CLSID_CTDCCtl)
// ;end_internal
    //  This will be removed when we learn more about the HTML
    //  sub-tag "OBJECT"
    PROP_ENTRY("DataURL",       DISPID_DATAURL,     CLSID_CTDCCtl)
    PROP_ENTRY("ReadyState",    DISPID_READYSTATE,  CLSID_CTDCCtl)
END_PROPERTY_MAP()

BEGIN_CONNECTION_POINT_MAP(CTDCCtl)
CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
CONNECTION_POINT_ENTRY(IID_ITDCCtlEvents)
END_CONNECTION_POINT_MAP()

BEGIN_MSG_MAP(CTDCCtl)
    MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_GETDLGCODE, OnGetDlgCode)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
END_MSG_MAP()

private:
    CComBSTR     m_cbstrFieldDelim;
    CComBSTR     m_cbstrRowDelim;
    CComBSTR     m_cbstrQuoteChar;
    CComBSTR     m_cbstrEscapeChar;
    BOOL         m_fUseHeader;
    CComBSTR     m_cbstrSortColumn;
    BOOL         m_fSortAscending;
    CComBSTR     m_cbstrFilterValue;
    OSPCOMP      m_enumFilterCriterion;
    CComBSTR     m_cbstrFilterColumn;
    UINT         m_nCodePage;
    UINT         m_nAmbientCodePage;
    CComBSTR     m_cbstrLanguage;
    CComBSTR     m_cbstrDataURL;
    LCID         m_lcidRead;
    boolean      m_fDataURLChanged;
    HRESULT      m_hrDownloadStatus;
    LONG         m_lTimer;
    CComBSTR     m_cbstrFilterExpr;
    CComBSTR     m_cbstrSortExpr;
    BOOL         m_fAppendData;
    BOOL         m_fCaseSensitive;
    boolean      m_fInReset;

    OLEDBSimpleProvider *m_pSTD;
    CTDCArr      *m_pArr;
    IMultiLanguage  *m_pML;
    BOOL         m_fSecurityChecked;

// ;begin_internal
    DATASRCListener *m_pDATASRCListener;
// ;end_internal
    DataSourceListener *m_pDataSourceListener;
    CEventBroker *m_pEventBroker;


    //  These member objects are used while parsing the input stream
    //
    CTDCUnify       *m_pUnify;
    CComObject<CMyBindStatusCallback<CTDCCtl> > *m_pBSC;

// These members and methods expose the ITDCCtl interface
//
public:

    //  Control Properties
    //
    STDMETHOD(get_FieldDelim)(BSTR* pbstrFieldDelim);
    STDMETHOD(put_FieldDelim)(BSTR bstrFieldDelim);
    STDMETHOD(get_RowDelim)(BSTR* pbstrRowDelim);
    STDMETHOD(put_RowDelim)(BSTR bstrRowDelim);
    STDMETHOD(get_TextQualifier)(BSTR* pbstrTextQualifier);
    STDMETHOD(put_TextQualifier)(BSTR bstrTextQualifier);
    STDMETHOD(get_EscapeChar)(BSTR* pbstrEscapeChar);
    STDMETHOD(put_EscapeChar)(BSTR bstrEscapeChar);
    STDMETHOD(get_UseHeader)(VARIANT_BOOL* pfUseHeader);
    STDMETHOD(put_UseHeader)(VARIANT_BOOL fUseHeader);
    STDMETHOD(get_SortColumn)(BSTR* pbstrSortColumn);
    STDMETHOD(put_SortColumn)(BSTR bstrSortColumn);
    STDMETHOD(get_SortAscending)(VARIANT_BOOL* pfSortAscending);
    STDMETHOD(put_SortAscending)(VARIANT_BOOL fSortAscending);
    STDMETHOD(get_FilterValue)(BSTR* pbstrFilterValue);
    STDMETHOD(put_FilterValue)(BSTR bstrFilterValue);
    STDMETHOD(get_FilterCriterion)(BSTR* pbstrFilterCriterion);
    STDMETHOD(put_FilterCriterion)(BSTR bstrFilterCriterion);
    STDMETHOD(get_FilterColumn)(BSTR* pbstrFilterColumn);
    STDMETHOD(put_FilterColumn)(BSTR bstrFilterColumn);
    STDMETHOD(get_CharSet)(BSTR *pbstrCharSet);
    STDMETHOD(put_CharSet)(BSTR bstrCharSet);
    STDMETHOD(get_Language)(BSTR* pbstrLanguage);
    STDMETHOD(put_Language_)(LPWCH pwchLanguage);
    STDMETHOD(put_Language)(BSTR bstrLanguage);
    STDMETHOD(get_CaseSensitive)(VARIANT_BOOL *pfCaseSensitive);
    STDMETHOD(put_CaseSensitive)(VARIANT_BOOL fCaseSensitive);
    STDMETHOD(get_DataURL)(BSTR* pbstrDataURL); // 
    STDMETHOD(put_DataURL)(BSTR bstrDataURL);
// ;begin_internal
//    STDMETHOD(get_RefreshInterval)(LONG* plTimer);
//    STDMETHOD(put_RefreshInterval)(LONG lTimer);
// ;end_internal
    STDMETHOD(get_Filter)(BSTR* pbstrFilterExpr);
    STDMETHOD(put_Filter)(BSTR bstrFilterExpr);
    STDMETHOD(get_Sort)(BSTR* pbstrSortExpr);
    STDMETHOD(put_Sort)(BSTR bstrSortExpr);
    STDMETHOD(get_AppendData)(VARIANT_BOOL* pfAppendData);
    STDMETHOD(put_AppendData)(VARIANT_BOOL fAppendData);
    STDMETHOD(get_OSP)(OLEDBSimpleProviderX ** ppISTD);

    STDMETHOD(get_ReadyState)(LONG *lReadyState);
    STDMETHOD(put_ReadyState)(LONG lReadyState);

    // Override IPersistPropertyBagImpl::Load
    STDMETHOD(Load)(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog);

    void UpdateReadyState(LONG lReadyState);
    //  Data source notification methods
    STDMETHOD(msDataSourceObject)(BSTR qualifier, IUnknown **ppUnk);
    STDMETHOD(addDataSourceListener)(IUnknown *pEvent);

    //  Control Methods
    //
    STDMETHOD(Reset)();
    STDMETHOD(_OnTimer)(void);

private:
    STDMETHOD(CreateTDCArr)(boolean fAppend);
    STDMETHOD(ReleaseTDCArr)(boolean fReplacing);
    void LockBSC();
    void UnlockBSC();
    STDMETHOD(InitiateDataLoad)(boolean fAppend);
    STDMETHOD(SecurityCheckDataURL)(LPOLESTR pszURL);
    STDMETHOD(SecurityMatchAllowDomainList)();
    STDMETHOD(SecurityMatchProtocols)(LPOLESTR pszURL);
    STDMETHOD(TerminateDataLoad)(CMyBindStatusCallback<CTDCCtl> *pBSC);
    BSTR bstrConstructSortExpr();
    BSTR bstrConstructFilterExpr();

protected:
    void OnData(CMyBindStatusCallback<CTDCCtl> *pbsc, BYTE *pBytes, DWORD dwSize);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\tdc\wch.h ===
//+-----------------------------------------------------------------------
//
//  Wide Character Routines
//  Copyright (C) Microsoft Corporation, 1996, 1997
//
//  File:       wch.h
//
//  Contents:   Declaration of wide characters routines.
//              These routines are being used to avoid dragging in
//              the initialisation chunk of the C run-time library
//              that would be required by library routines such as
//              wcsicmp() etc.
//
//------------------------------------------------------------------------

extern int wch_icmp(LPWCH pwch1, LPWCH pwch2);
extern int wch_incmp(LPWCH pwch1, LPWCH pwch2, DWORD dwMaxCmp);
extern int wch_cmp(LPWCH pwch1, LPWCH pwch2);
extern int wch_ncmp(LPWCH pwch1, LPWCH pwch2, DWORD dwMaxCmp);
extern int wch_len(LPWCH pwch);
extern void wch_cpy(LPWCH pwch1, LPWCH pwch2);
extern LPWCH wch_chr(LPWCH pwch, WCHAR wch);
extern boolean wch_wildcardMatch(LPWCH pwchText, LPWCH pwchPattern,
                                 boolean fCaseSensitive);

//------------------------------------------------------------------------
//
//  Function:  wch_ncpy()
//
//  Synopsis:  Perform an n-character wide-string copy.
//             Copies 'dwSize' characters from 'pwchSrc' to 'pwchDest'.
//
//  Arguments: pwchDesc  Destination buffer.
//             pwchSrc   Source string.
//             dwSize    Number of characters to copy.
//
//  Returns:   Nothing.
//
//------------------------------------------------------------------------

inline void wch_ncpy(LPWCH pwchDest, LPWCH pwchSrc, DWORD dwSize)
{
    memcpy(pwchDest, pwchSrc, dwSize * sizeof(WCHAR));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\tdc\tdcparse.cpp ===
//------------------------------------------------------------------------
//
//  Tabular Data Control Parsing Module
//  Copyright (C) Microsoft Corporation, 1996, 1997
//
//  File:       TDCParse.cpp
//
//  Contents:   Implementation of CTDCParse classes.
//
//------------------------------------------------------------------------


#include "stdafx.h"
#include <simpdata.h>
#include "TDC.h"
#include <MLang.h>
#include "Notify.h"
#include "TDCParse.h"
#include "TDCArr.h"
#include "locale.h"
#include "wch.h"

//#ifndef DISPID_AMBIENT_CODEPAGE
//#define DISPID_AMBIENT_CODEPAGE (-725)
//#endif

#define BYTE_ORDER_MARK 0xFEFF
#define REVERSE_BYTE_ORDER_MARK 0xFFFE

//------------------------------------------------------------------------
//
//  Function:   IsSpace()
//
//  Synopsis:   Returns TRUE if the given character is a space or tab character.
//
//  Arguments:  ch            Character to test.
//
//  Returns:    TRUE if 'ch' is a space or tab character.
//              FALSE otherwise.
//
//------------------------------------------------------------------------

inline boolean IsSpace(WCHAR ch)
{
    return (ch == L' ' || ch == L'\t');
}

//////////////////////////////////////////////////////////////////////////
//
//        CTDCTokenise Class - see comments in file TDCParse.h
//        ------------------
//////////////////////////////////////////////////////////////////////////


//------------------------------------------------------------------------
//
//  Method:     CTDCTokenise::Create()
//
//  Synopsis:   Initialise the CTDCTokenise object
//
//  Arguments:  pFieldSink         Object to send parsed fields to.
//              wchDelimField      \
//              wchDelimRow         |  Set of characters that control
//              wchQuote            |  the parsing of fields
//              wchEscape          /
//
//  Returns:    S_OK indicating success.
//
//------------------------------------------------------------------------

HRESULT CTDCUnify::InitTokenizer(CTDCFieldSink *pFieldSink, WCHAR wchDelimField,
                                 WCHAR wchDelimRow, WCHAR wchQuote, WCHAR wchEscape)
{
    _ASSERT(pFieldSink != NULL);
    m_pFieldSink = pFieldSink;
    m_wchDelimField = wchDelimField;
    m_wchDelimRow = wchDelimRow;
    m_wchQuote = wchQuote;
    m_wchEscape = wchEscape;
    m_ucParsed = 0;

    m_fIgnoreNextLF = FALSE;
    m_fIgnoreNextCR = FALSE;
    m_fIgnoreNextWhiteSpace = FALSE;
    m_fEscapeActive = FALSE;
    m_fQuoteActive = FALSE;
    m_fFoldWhiteSpace = FALSE;

    //  Ensure that the field and row delimiters are set.
    //
    if (m_wchDelimRow == 0)
        m_wchDelimRow = DEFAULT_ROW_DELIM[0];

    //  Remove conflicting delimiter values
    //
    if (m_wchDelimRow == m_wchDelimField)
        m_wchDelimRow = 0;
    if (m_wchQuote != 0)
    {
        if (m_wchQuote == m_wchDelimField || m_wchQuote == m_wchDelimRow)
            m_wchQuote = 0;
    }
    if (m_wchEscape != 0)
    {
        if (m_wchEscape == m_wchDelimField ||
            m_wchEscape == m_wchDelimRow ||
            m_wchEscape == m_wchQuote)
            m_wchEscape = 0;
    }

    m_fFoldCRLF = (m_wchDelimRow == L'\r' || m_wchDelimRow == L'\n');

    return S_OK;
}

//------------------------------------------------------------------------
//
//  Method:     CTDCTokenise::AddWcharBuffer()
//
//  Synopsis:   Takes a buffer of characters, breaks it up into fields
//              and passes them to the embedded CTDCFieldSink object
//              as fields.
//
//  Arguments:  pwch               Buffer containing characters to be parsed.
//              dwSize             Number of significant characters in 'pwch'
//                                  dwSize == 0 means "End-of-stream"
//
//  Returns:    S_OK upon success.
//              E_OUTOFMEMORY indicating insufficient memory to carry
//                out the parse operation.
//              Other misc error code upon failure.
//
//------------------------------------------------------------------------

HRESULT CTDCUnify::AddWcharBuffer(BOOL fLastData)
{

    OutputDebugStringX(_T("CTDCTokenise::AddWcharBuffer called\n"));

    _ASSERT(m_pFieldSink != NULL);

    HRESULT hr = S_OK;

    LPWCH   pwchCurr;   //  Next character to process
    LPWCH   pwchEnd;    //  End-of-buffer marker
    LPWCH   pwchDest;   //  Where to write next char processed
    LPWCH   pwchStart;  //  Beginning of current token

    pwchStart = &m_psWcharBuf[0];
    pwchCurr = pwchStart + m_ucParsed;
    pwchDest = pwchCurr;
    pwchEnd = &m_psWcharBuf[m_ucWcharBufCount];

    //  Read up to the next field boundary (field or row delimiter)
    //
    while (pwchCurr < pwchEnd)
    {
        // Security:  If we see a null character, it's not a text file.  Abort the
        // download, so that no one can use the TDC to download .exe's or other
        // binary files.
        if (*pwchCurr == 0)
        {
            hr = E_ABORT;
            goto Cleanup;
        }

        if (m_fIgnoreNextLF)
        {
            //  We're expecting a LF to terminate a CR-LF sequence.
            //
            m_fIgnoreNextLF = FALSE;
            if (*pwchCurr == L'\n')
            {
                //  Found a LF - ignore it
                //
                pwchCurr++;
                continue;
            }

            //  Found something else - carry on ...
            //
        }

        if (m_fIgnoreNextCR)
        {
            //  We're expecting a CR to terminate a LF-CR sequence.
            //
            m_fIgnoreNextCR = FALSE;
            if (*pwchCurr == L'\r')
            {
                //  Found a CR - ignore it
                //
                pwchCurr++;
                continue;
            }

            //  Found something else - carry on ...
            //
        }

        if (m_fIgnoreNextWhiteSpace)
        {
            //  We're expecting the rest of a white-space sequence
            //
            if (IsSpace(*pwchCurr))
            {
                //  Found white-space - ignore it
                //
                pwchCurr++;
                continue;
            }
            m_fIgnoreNextWhiteSpace = FALSE;
        }

        //  Escape characters work, even in quoted strings
        //
        if (m_fEscapeActive)
        {
            *pwchDest++ = *pwchCurr++;
            m_fEscapeActive = FALSE;
            continue;
        }
        if (*pwchCurr == m_wchEscape)
        {
            pwchCurr++;
            m_fEscapeActive = TRUE;
            continue;
        }

        //  Quotes activate/deactivate Field/Row delimiters
        //
        if (*pwchCurr == m_wchQuote)
        {
            pwchCurr++;
            m_fQuoteActive = !m_fQuoteActive;
            continue;
        }

        if (m_fQuoteActive)
        {
            *pwchDest++ = *pwchCurr++;
            continue;
        }


        if (*pwchCurr == m_wchDelimField ||
            (m_fFoldWhiteSpace && IsSpace(*pwchCurr)))
        {
            hr = m_pFieldSink->AddField(pwchStart, pwchDest - pwchStart);
            if (!SUCCEEDED(hr))
                goto Cleanup;
            pwchCurr++;
            if (m_fFoldWhiteSpace && IsSpace(*pwchCurr))
                m_fIgnoreNextWhiteSpace = TRUE;
            pwchStart = &m_psWcharBuf[0];
            pwchDest = pwchStart;
            continue;
        }

        if (*pwchCurr == m_wchDelimRow ||
            (m_fFoldCRLF && (*pwchCurr == L'\r' || *pwchCurr == L'\n')))
        {
            hr = m_pFieldSink->AddField(pwchStart, pwchDest - pwchStart);
            if (!SUCCEEDED(hr))
                goto Cleanup;
            hr = m_pFieldSink->EOLN();
            if (!SUCCEEDED(hr))
                goto Cleanup;
            if (m_fFoldCRLF)
            {
                m_fIgnoreNextLF = (*pwchCurr == L'\r');
                m_fIgnoreNextCR = (*pwchCurr == L'\n');
            }
            pwchCurr++;
            pwchStart = &m_psWcharBuf[0];
            pwchDest = pwchStart;
            continue;
        }

        *pwchDest++ = *pwchCurr++;
    }
    
    m_ucWcharBufCount = pwchDest - pwchStart;
    m_ucParsed = pwchDest - pwchStart;  // amount we've already parsed

    // If this is the last data packet, and there's a fragment left,
    // parse it.
    if (m_ucWcharBufCount && fLastData)
    {
        hr = m_pFieldSink->AddField(pwchStart, m_ucParsed);
        if (!SUCCEEDED(hr))
            goto Cleanup;
        m_ucParsed = 0;
        hr = m_pFieldSink->EOLN();
        return hr;
    }


Cleanup:
    return hr;
}




//////////////////////////////////////////////////////////////////////////
//
//        CTDCUnify Class - see comments in file TDCParse.h
//        ---------------
//////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------------
//
//  Method:     CTDCUnify::CTDCUnify()
//
//  Synopsis:   Constuctor
//
//------------------------------------------------------------------------

CTDCUnify::CTDCUnify()
{
    m_pML = NULL;
}

//------------------------------------------------------------------------
//
//  Method:     CTDCUnify::~CTDCUnify()
//
//  Synopsis:   Destructor
//
//------------------------------------------------------------------------

CTDCUnify::~CTDCUnify()
{
    delete [] m_psByteBuf;
    delete [] m_psWcharBuf;

    if (m_pML != NULL)
        m_pML->Release();
}

//------------------------------------------------------------------------
//
//  Method:     CTDCUnify::Create()
//
//  Synopsis:   Initialise the CTDCUnify object
//
//  Arguments:  pTokenise         Object to send converted buffers to.
//              nCodePage         Code page for ASCII->Unicode conversions
//              pML               MLANG COM object (used for conversions)
//
//  Returns:    S_OK to indicate success.
//
//------------------------------------------------------------------------

HRESULT CTDCUnify::Create(UINT nCodePage, UINT nAmbientCodePage, IMultiLanguage *pML)
{
    m_pML = pML;
    m_pML->AddRef();
    m_nCodePage = nCodePage;
    m_nAmbientCodePage = nAmbientCodePage;
    m_fDataMarkedUnicode = FALSE;
    m_fDataIsUnicode = FALSE;
    m_dwBytesProcessed = 0;
    m_fCanConvertToUnicode = 0;
    m_nUnicode = 0;
    m_fProcessedAllowDomainList = FALSE;

    m_dwConvertMode = 0;
    m_ucByteBufSize = 0;
    m_ucByteBufCount = 0;
    m_psByteBuf = NULL;

    m_ucWcharBufSize = 0;
    m_ucWcharBufCount = 0;
    m_psWcharBuf = NULL;

    if (m_nCodePage && S_OK != m_pML->IsConvertible(m_nCodePage, UNICODE_CP))
    {
        m_nCodePage = 0;
    }

    if (m_nAmbientCodePage && S_OK != m_pML->IsConvertible(m_nAmbientCodePage, UNICODE_CP))
    {
        m_nAmbientCodePage = 0;
    }

    return S_OK;
}

//------------------------------------------------------------------------
//
//  Method:     CTDCUnify::IsUnicode
//
//  Synopsis:   Determines if our text buffer is Unicode or not.  Should
//              only be called once on the FIRST text buffer.
//
//              Assume if the data is marked as Unicode, that it's correct.
//
//              The determination this routine makes will override any
//              single byte codepage the user may have specified.
//
//              
//  Arguments:  pBytes            Buffer containing characters to be converted.
//              dwSize            Number of significant characters in 'pBytes'
//
//  Returns:    Code page of text, or zero if not Unicode (UNICODE_CP,
//              UNICODE_REVERSE_CP, or 0)
//              
//
//------------------------------------------------------------------------
int
CTDCUnify::IsUnicode(BYTE * pBytes, DWORD dwSize)
{
    if (BYTE_ORDER_MARK == *(WCHAR *)pBytes)
        return UNICODE_CP;

    if (REVERSE_BYTE_ORDER_MARK == *(WCHAR *)pBytes)
        return UNICODE_REVERSE_CP;

    else return 0;
}

//------------------------------------------------------------------------
//
//  Method:     CTDCUnify::ConvertByteBuffer()
//
//  Synopsis:   Converts a byte-buffer into a wide-character stream
//              (applying unicode conversions if necessary) and passes
//              it to the embedded TDCTokenise object to be broken into
//              fields.
//
//  Arguments:  pBytes            Buffer containing characters to be converted.
//              dwSize            Number of significant characters in 'pBytes'
//                                  dwSize == 0 means "End-of-stream"
//
//  Returns:    S_OK upon success.
//              S_FALSE if not enough data has shown up yet to be useful
//              OLE_E_CANTCONVERT if a non-unicode buffer can't be
//                converted into unicode.
//              E_OUTOFMEMORY if there isn't enough memory to perform
//                a data conversion.
//
//------------------------------------------------------------------------

HRESULT CTDCUnify::ConvertByteBuffer(BYTE *pBytes, DWORD dwSize)
{
    OutputDebugStringX(_T("CTDCUnify::ConvertByteBuffer called\n"));

    _ASSERT(pBytes != NULL || dwSize == 0);

    HRESULT     hr = S_OK;
    UINT        ucBytes;
    UINT        ucWchars;

    // Is there enough space in Byte buffer for this packet?
    if (dwSize > (m_ucByteBufSize - m_ucByteBufCount))
    {
        // No, the current buffer is too small, make a new one.
        BYTE * psTemp = new BYTE[m_ucByteBufCount + dwSize];
        if (psTemp==NULL)
        {
            hr = E_OUTOFMEMORY;
            
            goto Done;
        }

        if (m_psByteBuf != NULL)        // if not first time
        {
            memmove(psTemp, m_psByteBuf, m_ucByteBufCount);
            delete [] m_psByteBuf;
        }
        m_ucByteBufSize = m_ucByteBufCount + dwSize;
        m_psByteBuf = psTemp;
    }

    // Append the new data to the old data.
    memmove(m_psByteBuf + m_ucByteBufCount, pBytes, dwSize);
    m_ucByteBufCount += dwSize;

    // Is there enough space in the Wchar buffer for the converted data?
    // We make a very conservative assumption here that N source buffer bytes
    // convert to N Wchar buffer chars (or 2*N bytes).  This will ensure that
    // our call to ConvertToUnicode will never not finish because there wasn't
    // enough room in the output buffer.
    if (m_ucByteBufCount > (m_ucWcharBufSize - m_ucWcharBufCount))
    {
        // The current buffer is too small, make a new one.
        WCHAR * psTemp = new WCHAR[m_ucWcharBufCount + m_ucByteBufCount];
        if (psTemp==NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Done;
        }

        if (m_psWcharBuf != NULL)       // if not first time
        {
            memmove(psTemp, m_psWcharBuf,
                    m_ucWcharBufCount*sizeof(WCHAR));
            delete [] m_psWcharBuf;
        }
        m_psWcharBuf = psTemp;
        m_ucWcharBufSize = m_ucWcharBufCount + m_ucByteBufCount;
    }

    if (0 == m_dwBytesProcessed)
    {
        // if we can't determine the codepage yet, try again later
        if (!DetermineCodePage(dwSize==0))
        {
            hr = S_FALSE;
            goto Done;
        }
    }

    // Convert as many source bytes as we can to Unicode chars
    ucBytes = m_ucByteBufCount;
    ucWchars = m_ucWcharBufSize - m_ucWcharBufCount;

    // ConvertStringToUnicode won't convert Unicode to Unicode for us.
    // So we'll do it ourselves.
    if (m_nUnicode)
    {
        _ASSERT( ucWchars * sizeof(WCHAR) >= ucBytes);

        // This might copy an odd extra byte
        memmove((BYTE *)(m_psWcharBuf + m_ucWcharBufCount), m_psByteBuf,
                ucBytes);

        // But we only count the number of complete WCHAR's we copied.
        ucWchars = ucBytes / sizeof(WCHAR); 
        ucBytes = ucWchars * sizeof(WCHAR);

        if (UNICODE_REVERSE_CP == m_nUnicode)
        {
            // need to byte swap
            BYTE *pByteSwap = (BYTE *)(m_psWcharBuf + m_ucWcharBufCount);
            BYTE bTemp;
            for (ULONG i = ucWchars; i != 0; i--)
            {
                // Well, OK, we've kind of hardwired WCHAR == 2 here, but ..
                bTemp = pByteSwap[0];
                pByteSwap[0] = pByteSwap[1];
                pByteSwap[1] = bTemp;
                pByteSwap += 2;
            }
        }

        // On first packet, need to remove Unicode signature.
        // Only need to look for 0xFFFE -- we already swapped bytes.
        if (0 == m_dwBytesProcessed && m_psWcharBuf[0] == BYTE_ORDER_MARK)
        {
            ucWchars--;
            memmove((BYTE *)m_psWcharBuf, (BYTE *)m_psWcharBuf+2,
                   ucWchars*sizeof(ucWchars));
        }
    }
    else
    {
        hr = m_pML->ConvertStringToUnicode(&m_dwConvertMode, m_nCodePage,
                                           (char *)m_psByteBuf, &ucBytes,
                                           m_psWcharBuf +m_ucWcharBufCount,
                                           &ucWchars);

        // Some character(s) failed conversion.  The best we can do is
        // attempt to skip the character that failed conversion.
        if (FAILED(hr))
        {
            // Did we come back around and try to unconvertable portion again?
            if (ucBytes==0)
            {
                // Yes, and it made no progress.  Skip a char to try to make
                // forward progress.
                ucBytes++;
            }
            // We can't return this error, or we won't look a the rest of the
            // file.
            hr = S_OK;
        }

    }

    // Move any leftover source characters to the start of the buffer.
    // These are probably split Unicode chars, lead bytes without trail
    // bytes, etc.
    m_ucByteBufCount -= ucBytes;
    memmove(m_psByteBuf, m_psByteBuf + ucBytes,
            m_ucByteBufCount);

    // The number of useful chars in the output buf is increased by the
    // number we managed to convert.
    m_ucWcharBufCount += ucWchars;
    m_dwBytesProcessed += ucWchars;

Done:
    return hr;
}


//------------------------------------------------------------------------
//
//  Method:     CTDCUnify::DetermineCodePage()
//
//  Synopsis:   Figures out what codepage to use to read the data.
//              Sets m_nCodePage and m_nUnicode appropriately.
//
//  Arguments:  fForce      determine the answer, no matter what
//
//  Returns:    TRUE        the codepage is determined.
//              FALSE       not enough data yet to determine
//
//------------------------------------------------------------------------

BOOL
CTDCUnify::DetermineCodePage(BOOL fForce)
{
    DWORD   dwConvertMode = 0;
    HRESULT hr;
    UINT    ucBytes = m_ucByteBufCount;
    UINT    ucWchars = m_ucWcharBufSize - m_ucWcharBufCount;
    UINT    cpDetected;
    IMultiLanguage2 *pML2 = NULL;

    _ASSERT(m_dwBytesProcessed == 0 && m_pML);

    // First look for Unicode.  Assume it's not Unicode to start.
    m_nUnicode = 0;

    // Need at least 2 chars for Unicode signature (0xFFFE or 0xFEFF)
    if (m_ucByteBufCount > 1)
    {
        // If we detect Unicode, it overrides any user specified code page.
        m_nUnicode = IsUnicode(m_psByteBuf, m_ucByteBufCount);
        if (m_nUnicode)
        {
            m_nCodePage = m_nUnicode;
            return TRUE;
        }

        // It's not Unicode.  If the user specified a code page, use it.
        if (m_nCodePage)
        {
            return TRUE;
        }
    }

    // if we need an answer and user specified a code page, use it
    if (fForce && m_nCodePage)
    {
        return TRUE;
    }

    // At this point, we have to guess.  If we have enough input or if we
    // need an answer now, use MLang to do the guessing
    if (fForce || m_ucByteBufCount >= CODEPAGE_BYTE_THRESHOLD)
    {
        // First see if the auto-detect interface is available.
        hr = m_pML->QueryInterface(IID_IMultiLanguage2, (void**)&pML2);
        if (!hr && pML2)
        {
            DetectEncodingInfo info[N_DETECTENCODINGINFO];
            int nInfo = N_DETECTENCODINGINFO;

            // auto-detect
            hr = pML2->DetectInputCodepage(
                            MLDETECTCP_NONE,
                            CP_ACP,
                            (char *)m_psByteBuf,
                            (int*)&ucBytes,
                            info,
                            &nInfo);
            pML2->Release();

            if (!hr)
            {
                // if one of the returned codepages is "good enough", use it.
                for (int i=0; i<nInfo; ++i)
                {
                    if (info[i].nConfidence >= 90 && info[i].nDocPercent >= 90)
                    {
                        if (S_OK == m_pML->IsConvertible(info[i].nCodePage, UNICODE_CP))
                        {
                            m_nCodePage = info[i].nCodePage;
                            return TRUE;
                        }
                    }
                }
            }
        }
        
        // Try plain old MLang.
        // Ask MLang to convert the input using the"auto-detect" codepage.
        hr = m_pML->ConvertStringToUnicode(&dwConvertMode, CP_AUTO,
                                           (char *)m_psByteBuf, &ucBytes,
                                           m_psWcharBuf + m_ucWcharBufCount,
                                           &ucWchars);
        cpDetected = HIWORD(dwConvertMode);

        // if MLang detected a codepage, use it
        if (!hr && cpDetected != 0)
        {
            if (S_OK == m_pML->IsConvertible(cpDetected, UNICODE_CP))
            {
                m_nCodePage = cpDetected;
                return TRUE;
            }
        }
    }

    // guessing didn't work.  If we don't have to decide now, try again later
    if (!fForce)
    {
        return FALSE;
    }

    // if we have to decide and all else has failed, use the host page's
    // encoding.  If even that isn't available, use the machine's ASCII codepage.
    m_nCodePage = m_nAmbientCodePage ? m_nAmbientCodePage : GetACP();

    // and if this still isn't convertible to Unicode, use windows-1252
    if (m_nCodePage == 0 || S_OK != m_pML->IsConvertible(m_nCodePage, UNICODE_CP))
    {
        m_nCodePage = CP_1252;
    }

    return TRUE;
}


LPWCH SkipSpace(LPWCH pwchCurr)
{
    while (IsSpace(*pwchCurr)) pwchCurr++;
    return pwchCurr;
}

static
boolean IsEnd(WCHAR ch)
{
    return (ch == 0 || ch == L'\r' || ch == L'\n');
}

static
boolean IsBreak(WCHAR ch)
{
    return (ch == L';' || IsEnd(ch));
}

// Returns FALSE if names didn't match.
// Returns TRUE if they did.
// Sets *ppwchAdvance to terminator of the match name
BOOL
MatchName(LPWCH pwchMatchName, LPCWCH pwzHostName, LPWCH *ppwchAdvance)
{
    // match from right to left
    LPWCH pwchMatchRight = &pwchMatchName[0];
    LPCWCH pwchHostRight = &pwzHostName[0] + ocslen(pwzHostName) -1;
                     
    // handle empty match name
    if (IsBreak(*pwchMatchRight))
    {
        if (!IsEnd(*pwchMatchRight))    // be sure to advance (unless at end)
            ++ pwchMatchRight;
        *ppwchAdvance = pwchMatchRight;
        return FALSE;
    }
    
    // Find end of Match name.
    while (!IsBreak(*pwchMatchRight)) pwchMatchRight++;

    *ppwchAdvance = pwchMatchRight;     // return pointer to terminator

    pwchMatchRight--;

    while (IsSpace(*pwchMatchRight) && pwchMatchRight >= pwchMatchName)
        -- pwchMatchRight;              // ignore trailing whitespace

    // match full wildcard the easy way
    if (pwchMatchRight == pwchMatchName && pwchMatchRight[0] == '*')
        return TRUE;
    
    // match right-to-left, stop at mismatch or beginning of either string
    for (; pwchMatchRight>=pwchMatchName && pwchHostRight>=pwzHostName;
            --pwchMatchRight, --pwchHostRight)
    {
        if (*pwchMatchRight != *pwchHostRight || *pwchMatchRight == '*')
            break;
    }

    // it's a match if strings matched completely
    if (pwchMatchRight+1 == pwchMatchName  &&  pwchHostRight+1 == pwzHostName)
        return TRUE;

    // or if match name started with "*." and the rest matched a suffix of host name
    if (pwchMatchRight == pwchMatchName  &&  pwchMatchRight[0] == '*'  &&
        pwchMatchRight[1] == '.')
        return TRUE;

    // otherwise it's not a match
    return FALSE;
}

HRESULT
CTDCUnify::MatchAllowDomainList(LPCWSTR pwzURL)
{
    HRESULT hr = E_FAIL;                // assume failure
    LPWCH pwchCurr = &m_psWcharBuf[0];
    LPWCH pwchCurr2;
    int cchHostDoman = ocslen(pwzURL);

    // skip over white space
    pwchCurr = SkipSpace(pwchCurr);
    if (IsEnd(*pwchCurr))
        goto Cleanup;

    // must have the equal sign
    if (*pwchCurr++ != '=' || *pwchCurr == '\0')
        goto Cleanup;

    while (TRUE)
    {
        // skip over white space
        pwchCurr = SkipSpace(pwchCurr);

        if (IsEnd(*pwchCurr))           // terminate on \r, \n, \0
            break;

        if (IsBreak(*pwchCurr))         // Must be ';',
            pwchCurr++;                 // skip it.

        // skip over white space
        pwchCurr = SkipSpace(pwchCurr);

        if (MatchName(pwchCurr, pwzURL, &pwchCurr2))
        {
            hr = S_OK;
            break;
        }
        pwchCurr = pwchCurr2;
    }

Cleanup:
    while (!IsEnd(*pwchCurr))
        pwchCurr++;

    // Skip CRLF combos
    if (*pwchCurr == '\r' && pwchCurr[1] == '\n') pwchCurr++;

    // Eat the AllowDomain line so it doesn't screw up the data.
    m_ucWcharBufCount -= (ULONG)(pwchCurr+1 - m_psWcharBuf);
    memmove(m_psWcharBuf, pwchCurr+1, m_ucWcharBufCount*sizeof(WCHAR));

    m_fProcessedAllowDomainList = TRUE;

    return hr;
}

//------------------------------------------------------------------------
//
//  Method:     CTDCUnify::CheckForAllowDomainList
//
//  Synopsis:   Checks the beggining of the Wide Char buffer to see if it
//              contains the string "@!allow.domains".  This is used to
//              determine if this file has a list of domain names which are
//              allowed to access this file, even though the access may be
//              coming from another internet host.
//
//  Arguments:  uses CTDCUnify state variables for the Wide Char buffer:
//              m_psWcharBUf            the Wide char buffer
//              m_ucWcharBufCount       the # of chars in the wide char buf
//
//  Returns:    ALLOW_DOMAINLIST_NO             signature not found
//              ALLOW_DOMAINLIST_YES            signature was found
//              ALLOW_DOMAINLIST_DONTKNOW       don't have enough characters
//                                              to know for sure yet.
//
//------------------------------------------------------------------------

CTDCUnify::ALLOWDOMAINLIST
CTDCUnify::CheckForAllowDomainList()
{
    ULONG cAllowDomainLen = ocslen(ALLOW_DOMAIN_STRING);

    // Make sure we have a whole line.
    LPWCH pwchCurr = m_psWcharBuf;
    LPWCH pwchEnd = &m_psWcharBuf[m_ucWcharBufCount];
    
    while (pwchCurr < pwchEnd)
    {
        if (IsEnd(*pwchCurr))
            break;
        ++ pwchCurr;
    }

    if (pwchCurr >= pwchEnd)            // if buffer ended before line did
        return ALLOW_DOMAINLIST_DONTKNOW;

    if (0 == wch_incmp(m_psWcharBuf, ALLOW_DOMAIN_STRING, cAllowDomainLen))
    {
        // We matched equal and have the whole string.
        // Take the "@!allow.domains" out of the buffer..
        m_ucWcharBufCount -= cAllowDomainLen;
        memmove(m_psWcharBuf, &m_psWcharBuf[cAllowDomainLen],
                m_ucWcharBufCount*sizeof(WCHAR));
        return ALLOW_DOMAINLIST_YES;
    }

    // We didn't match equal, no point in looking any more.
    return ALLOW_DOMAINLIST_NO;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\tdc\winres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// winres.h - Windows resource definitions
//  extracted from WINUSER.H and COMMCTRL.H

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define VS_VERSION_INFO     1

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS // Ignore following symbols
#endif

#ifndef WINVER
#define WINVER 0x0400   // default to Windows Version 4.0
#endif

#include <winresrc.h>

#ifdef _MAC
#define DS_WINDOWSUI    0x8000L
#endif

// operation messages sent to DLGINIT
#define LB_ADDSTRING    (WM_USER+1)
#define CB_ADDSTRING    (WM_USER+3)

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC      (-1)

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\tdc\tdcparse.h ===
//------------------------------------------------------------------------
//
//  Tabular Data Control Parse Module
//  Copyright (C) Microsoft Corporation, 1996, 1997
//
//  File:       TDCParse.h
//
//  Contents:   Declaration of the TDC parser classes.
//
//  The intent of these classes once was to create a pipeline.
//
//
//          |
//          |       Wide-character stream
//          |       ~~~~~~~~~~~~~~~~~~~~~
//         \|/
//  ------------------------
//  | CTDCTokenise object  | Created with field & row delimiters, quote &
//  |   AddWcharBuffer()   |     escape characters
//  ------------------------
//          |
//          |       Stream of <field>, <eoln> and <eof> tokens
//          |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//         \|/
//  ------------------------
//  | CTDCFieldSink object | Abstract class, e.g. STD object created with
//  |   AddField()         |     sort/filter criteria & fUseHeader flag
//  |   EOLN()             |     to interpret the sequence of fields.
//  |   EOF()              |
//  ------------------------
//
//------------------------------------------------------------------------

#define DEFAULT_FIELD_DELIM L","
#define DEFAULT_ROW_DELIM   L"\n"
#define DEFAULT_QUOTE_CHAR  L"\""

#define UNICODE_CP          1200        // Win32's Unicode codepage
#define UNICODE_REVERSE_CP  1201        // Byte-swapped Unicode codepage
#define CP_1252             1252        // Ansi, Western Europe
#define CP_AUTO             50001       // cross language detection

// number of bytes for MLang to make a good guess for the codepage
// (this is a somewhat arbitrary number)
#define CODEPAGE_BYTE_THRESHOLD     (4096)
#define N_DETECTENCODINGINFO        (5)

#define ALLOW_DOMAIN_STRING L"@!allow_domains"

//------------------------------------------------------------------------
//
//  Class:  CTDCFieldSink
//
//  This class accumulates a sequence of <fields> and <eoln> tokens
//  into a 2-D array.
//
//  An admissible calling sequence on this object is:
//   * 0 or more calls to AddField() or EOLN()
//   * 1 call to EOF()
//
//------------------------------------------------------------------------

class CTDCFieldSink
{
public:
    STDMETHOD(AddField)(LPWCH pwch, DWORD dwSize) PURE;
    STDMETHOD(EOLN)() PURE;
    STDMETHOD(EOF)() PURE;
};

//------------------------------------------------------------------------
//
//  Class: CTDCUnify
//
//  This class takes a series of byte buffers and breaks them up into
//  UNICODE buffers.
//  The resulting buffers are passed to a CTDCTokenise object.
//
//  An admissible calling sequence on this object is:
//   * Exactly 1 call to Create()
//   * 0 or more calls to AddByteBuffer() with a non-zero-sized buffer
//   * Exactly 1 call to AddByteBuffer() with a zero-sized buffer
//
//  Calls to query the characteristics of the parsed data are allowed
//  after the call to Create(), but are only meaningful after a
//  reasonable amount of data has been collected.
//  
//
//  Caveats:
//  ~~~~~~~
//  The class characterises the input stream as ASCII/UNICODE/COMPOSITE
//  based on the buffer passed in the initial call to AddByteBuffer().
//  If this buffer is too small, the class may make an incorrect
//  characterisation.
//
//------------------------------------------------------------------------

class CTDCUnify
{
public:
    CTDCUnify();
    ~CTDCUnify();
    HRESULT Create(UINT nCodePage, UINT nAmbientCodePage, IMultiLanguage *pML);
    HRESULT ConvertByteBuffer(BYTE *pBytes, DWORD dwSize);
    HRESULT InitTokenizer(CTDCFieldSink *pFieldSink,
                          WCHAR wchDelimField,
                          WCHAR wchDelimRow,
                          WCHAR wchQuote,
                          WCHAR wchEscape);    
    HRESULT AddWcharBuffer(BOOL fAtEnd);
    int IsUnicode(BYTE * pBytes, DWORD dwSize);
    BOOL DetermineCodePage(BOOL fForce);
    enum ALLOWDOMAINLIST
    {
        ALLOW_DOMAINLIST_YES,
        ALLOW_DOMAINLIST_NO,
        ALLOW_DOMAINLIST_DONTKNOW
    };

    ALLOWDOMAINLIST CheckForAllowDomainList();
    HRESULT MatchAllowDomainList(LPCWSTR pwzURL);
    boolean ProcessedAllowDomainList() {return m_fProcessedAllowDomainList;}

private:
    CTDCFieldSink *m_pFieldSink;
    WCHAR m_wchDelimField;
    WCHAR m_wchDelimRow;
    WCHAR m_wchQuote;
    WCHAR m_wchEscape;
    WCHAR m_ucParsed;

    boolean m_fEscapeActive;
    boolean m_fQuoteActive;
    boolean m_fIgnoreNextLF;
    boolean m_fIgnoreNextCR;
    boolean m_fIgnoreNextWhiteSpace;
    boolean m_fFoldCRLF;
    boolean m_fFoldWhiteSpace;

    UINT            m_nUnicode;
    boolean         m_fDataMarkedUnicode;
    boolean         m_fDataIsUnicode;
    boolean         m_fCanConvertToUnicode;
    boolean         m_fProcessedAllowDomainList;
    DWORD           m_dwBytesProcessed;
    DWORD           m_dwConvertMode;
    UINT            m_nCodePage;
    UINT            m_nAmbientCodePage;

    BYTE            *m_psByteBuf;
    ULONG           m_ucByteBufSize;
    ULONG           m_ucByteBufCount;

    WCHAR           *m_psWcharBuf;
    ULONG           m_ucWcharBufSize;
    ULONG           m_ucWcharBufCount;

    IMultiLanguage *m_pML;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\tdc\wch.cpp ===
//+-----------------------------------------------------------------------
//
//  Wide Character Routines
//  Copyright (C) Microsoft Corporation, 1996, 1997
//
//  File:       wch.cpp
//
//  Contents:   Implementation of wide characters routines.
//              These routines are being used to avoid dragging in
//              the initialisation chunk of the C run-time library
//              that would be required by library routines such as
//              wcsicmp() etc.
//
//------------------------------------------------------------------------

#include "stdafx.h"
#include "shlwapi.h"            // Wrapper routines for non-Win95 calls

#pragma comment(lib, "shlwapi.lib")

//------------------------------------------------------------------------
//
//  Function:  wch_icmp()
//
//  Synopsis:  Perform a case-insensitive comparison of two strings.
//
//  Arguments: pwch1     First string to compare
//             pwch2     Second string to compare
//             Treats NULLs as empty strings.
//
//  Returns:   0 if the strings are lexically equal (allowing for
//               case insensitivity)
//             -1 if pwch1 lexically less than pwch2
//             +1 if pwch1 lexically greater than pwch2
//
//------------------------------------------------------------------------

int wch_icmp(LPWCH pwch1, LPWCH pwch2)
{
    USES_CONVERSION;

    if (pwch1 == NULL)
        pwch1 = L"";
    if (pwch2 == NULL)
        pwch2 = L"";

    return StrCmpIW(pwch1, pwch2);
}

//------------------------------------------------------------------------
//
//  Function:  wch_incmp()
//
//  Synopsis:  Perform a case-insensitive comparison of two strings,
//             up to a specified maximum number of characters.
//
//  Arguments: pwch1     First string to compare
//             pwch2     Second string to compare
//             dwMaxLen  Maximum number of characters to compare.
//
//             Treats NULLs as empty strings.
//
//  Returns:   0 if the strings are lexically equal (allowing for
//               case insensitivity)
//             -1 if pwch1 lexically less than pwch2
//             +1 if pwch1 lexically greater than pwch2
//
//------------------------------------------------------------------------

int wch_incmp(LPWCH pwch1, LPWCH pwch2, DWORD dwMaxLen)
{

    if (pwch1 == NULL)
        pwch1 = L"";
    if (pwch2 == NULL)
        pwch2 = L"";

    return StrCmpNIW(pwch1, pwch2, dwMaxLen);
}

//------------------------------------------------------------------------
//
//  Function:  wch_len()
//
//  Synopsis:  Calculate the length of a string.
//             Treats NULL as an empty string.
//
//  Arguments: pwch      String to measure
//
//  Returns:   Length of given string.
//
//------------------------------------------------------------------------

int wch_len(LPWCH pwch)
{
    LPWCH   pwchOrig = pwch;

    if (pwch == NULL)
        return 0;
    while (*pwch++ != 0)
        ;
    return pwch - pwchOrig - 1;
}

//------------------------------------------------------------------------
//
//  Function:  wch_cmp()
//
//  Synopsis:  Perform a case-sensitive comparison of two strings.
//             Treats NULLs as empty strings.
//
//  Arguments: pwch1     First string to compare
//             pwch2     Second string to compare
//
//  Returns:   0 if the strings are lexically equal
//             -1 if pwch1 lexically less than pwch2
//             +1 if pwch1 lexically greater than pwch2
//
//------------------------------------------------------------------------

int wch_cmp(LPWCH pwch1, LPWCH pwch2)
{
    if (pwch1 == NULL)
        pwch1 = L"";
    if (pwch2 == NULL)
        pwch2 = L"";
    for (; *pwch1 != 0 && *pwch1 == *pwch2; pwch1++, pwch2++)
        ;
    return *pwch1 - *pwch2;
}

//------------------------------------------------------------------------
//
//  Function:  wch_ncmp()
//
//  Synopsis:  Perform a case-sensitive comparison of two strings,
//             up to a specified maximum number of characters.
//
//  Arguments: pwch1     First string to compare
//             pwch2     Second string to compare
//             dwMaxLen  Maximum number of characters to compare.
//
//             Treats NULLs as empty strings.
//
//  Returns:   0 if the strings are lexically equal (allowing for
//               case insensitivity)
//             -1 if pwch1 lexically less than pwch2
//             +1 if pwch1 lexically greater than pwch2
//
//------------------------------------------------------------------------

int wch_ncmp(LPWCH pwch1, LPWCH pwch2, DWORD dwMaxLen)
{
    int cmp;

    if (pwch1 == NULL)
        pwch1 = L"";
    if (pwch2 == NULL)
        pwch2 = L"";

    for (cmp = 0; cmp == 0 && dwMaxLen-- > 0; pwch1++, pwch2++)
        if (*pwch1 == 0)
        {
            cmp = (*pwch2 == 0) ? 0 : -1;
            break;
        }
        else
            cmp = (*pwch2 == 0) ? 1 : (*pwch2 - *pwch1);

    return cmp;
}

//------------------------------------------------------------------------
//
//  Function:  wch_cpy()
//
//  Synopsis:  Copy a wide-character null-terminated string.
//             Treats NULL source as an empty string.
//
//  Arguments: pwchDesc  Destination buffer.
//             pwchSrc   Source string.
//
//  Returns:   Nothing.
//
//------------------------------------------------------------------------

void wch_cpy(LPWCH pwchDest, LPWCH pwchSrc)
{
    if (pwchSrc == NULL)
        *pwchDest = 0;
    else
        while ((*pwchDest++ = *pwchSrc++) != 0)
            ;
}

//------------------------------------------------------------------------
//
//  Function:  wch_chr()
//
//  Synopsis:  Searches for a character in a null-terminated wide-character
//             string.
//             Treats NULL pwch as an empty string.
//
//  Arguments: pwch      Search string.
//             wch       Character to search for.copy.
//
//  Returns:   Pointer to first occurrence of 'wch' in 'pwch' if found.
//             NULL if 'wch' does not occur in 'pwch'.
//
//------------------------------------------------------------------------

LPWCH wch_chr(LPWCH pwch, WCHAR wch)
{
    if (pwch != NULL)
        for (; *pwch != 0; pwch++)
            if (*pwch == wch)
                return pwch;
    return NULL;
}

//------------------------------------------------------------------------
//
//  Function:  wch_wildcardMatch()
//
//  Synopsis:  Determines whether the given text matches the given
//             pattern, which interprets the character '*' as a match
//             for 0-or-more characters.
//             Treats NULL pwchText as an empty string.
//             Treats NULL pwchPattern as an empty string.
//
//  Arguments: pwchText         Text to match.
//             pwchPattern      Pattern to match against.
//             fCaseSensitive   Flag to indicate whether match should be
//                                case sensitive.
//
//  Returns:   TRUE if the text matches the given pattern.
//             FALSE otherwise.
//
//------------------------------------------------------------------------

// ;begin_internal
// compiler bug (VC5 with optimise?)
// ;end_internal
boolean wch_wildcardMatch(LPWCH pwchText, LPWCH pwchPattern,
                          boolean fCaseSensitive)
{
    boolean fMatched;
    LPWCH pwchStar;
    DWORD   dwPatternLen;

    if (pwchText == NULL || pwchText[0] == 0)
    {
        //  Empty/NULL text.  This matches:
        //     - Empty/NULL patterns
        //     - Patterns consisting of a string of '*'s
        //
        //  Equivalently, the text FAILS to match if there
        //  is at least one non-* character in the pattern.
        //
        fMatched = TRUE;
        if (pwchPattern != NULL)
            while (fMatched && *pwchPattern != 0)
                fMatched = *pwchPattern++ == L'*';
        goto Done;
    }
    if (pwchPattern == NULL || pwchPattern[0] == 0)
    {
        //  NULL pattern can only match empty text.
        //  Since we've already dealt with the case of empty text above,
        //  the match must fail
        //
        fMatched = FALSE;
        goto Done;
    }

    //  Find the occurrence of the first '*' in the pattern ...
    //
    pwchStar = wch_chr(pwchPattern, L'*');

    if (pwchStar == NULL)
    {
        //  No '*'s in the pattern - compute an exact match
        //
        fMatched = fCaseSensitive
            ? wch_cmp(pwchText, pwchPattern) == 0
            : wch_icmp(pwchText, pwchPattern) == 0;
        goto Done;
    }

    int (*pfnBufCmp)(LPWCH pwch1, LPWCH pwch2, DWORD dwMaxCmp);

    pfnBufCmp = fCaseSensitive ? wch_ncmp : wch_incmp;

    //  Ensure an exact match for characters preceding the first '*', if any
    //
    dwPatternLen = pwchStar - pwchPattern;
    fMatched = (*pfnBufCmp)(pwchText, pwchPattern, dwPatternLen) == 0;
    if (!fMatched)
        goto Done;
    pwchText += dwPatternLen;

    for (;;)
    {
        DWORD dwTextLen = wch_len(pwchText);

        //  Skip over leading '*'s in the pattern
        //
        _ASSERT(*pwchStar == L'*');
        while (*pwchStar == L'*')
            pwchStar++;

        pwchPattern = pwchStar;

        //  Find the next occurrence of a '*' in the pattern
        //
        if (*pwchPattern == 0)
        {
            //  This must be have been a trailing '*' in the pattern.
            //  It automatically matches what remains of the text.
            //
            fMatched = TRUE;
            goto Done;
        }
        pwchStar = wch_chr(pwchPattern, L'*');
        if (pwchStar == NULL)
        {
            //  No more '*'s - require an exact match of remaining
            //  pattern text with the end of the text.
            //
            dwPatternLen = wch_len(pwchPattern);
            fMatched = (dwTextLen >= dwPatternLen) &&
                        (*pfnBufCmp)(pwchText + dwTextLen - dwPatternLen,
                                     pwchPattern, dwPatternLen) == 0;
            goto Done;
        }

        //  Locate an exact match for the pattern-up-to-next-*
        //  within the text buffer
        //
        dwPatternLen = pwchStar - pwchPattern;
        fMatched = FALSE;
        while (dwTextLen >= dwPatternLen)
        {
            fMatched = (*pfnBufCmp)(pwchText, pwchPattern, dwPatternLen) == 0;
            if (fMatched)
                break;
             dwTextLen--;
             pwchText++;
        }
        if (!fMatched)
            goto Done;
        pwchText += dwPatternLen;
    }

Done:
    return fMatched;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\array_p.h ===
//---------------------------------------------------------------------------
// ARRAY_P.h : CPtrArray header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------


#ifndef __CPTRARRAY__
#define __CPTRARRAY__

////////////////////////////////////////////////////////////////////////////

class CPtrArray
{

public:

// Construction
	CPtrArray();

// Attributes
	int GetSize() const;
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	void* GetAt(int nIndex) const;
	void SetAt(int nIndex, void* newElement);
	void*& ElementAt(int nIndex);

	// Direct Access to the element data (may return NULL)
	const void** GetData() const;
	void** GetData();

	// Potentially growing the array
	void SetAtGrow(int nIndex, void* newElement);
	int Add(void* newElement);
	int Append(const CPtrArray& src);
	void Copy(const CPtrArray& src);

	// overloaded operator helpers
	void* operator[](int nIndex) const;
	void*& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, void* newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CPtrArray* pNewArray);

// Implementation
protected:
	void** m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CPtrArray();
//#ifdef _DEBUG
//	void Dump(CDumpContext&) const;
//	void AssertValid() const;
//#endif

protected:
	// local typedefs for class templates
//	typedef void* BASE_TYPE;
//	typedef void* BASE_ARG_TYPE;
};
////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////

#endif //__CPTRARRAY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\array_p.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
//
// Implementation of parameterized Array
//
/////////////////////////////////////////////////////////////////////////////
// NOTE: we allocate an array of 'm_nMaxSize' elements, but only
//  the current size 'm_nSize' contains properly constructed
//  objects.

#include "stdafx.h"

SZTHISFILE

#include "ARRAY_P.INL"

/////////////////////////////////////////////////////////////////////////////

CPtrArray::CPtrArray()
{
	m_pData = NULL;
	m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

CPtrArray::~CPtrArray()
{
//	ASSERT_VALID(this);

	delete[] (BYTE*)m_pData;
}

void CPtrArray::SetSize(int nNewSize, int nGrowBy)
{
//	ASSERT_VALID(this);
	ASSERT_(nNewSize >= 0);

	if (nGrowBy != -1)
		m_nGrowBy = nGrowBy;  // set new size

	if (nNewSize == 0)
	{
		// shrink to nothing
		delete[] (BYTE*)m_pData;
		m_pData = NULL;
		m_nSize = m_nMaxSize = 0;
	}
	else if (m_pData == NULL)
	{
		// create one with exact size
#ifdef SIZE_T_MAX
		ASSERT_(nNewSize <= SIZE_T_MAX/sizeof(void*));    // no overflow
#endif
		m_pData = (void**) new BYTE[nNewSize * sizeof(void*)];

		memset(m_pData, 0, nNewSize * sizeof(void*));  // zero fill

		m_nSize = m_nMaxSize = nNewSize;
	}
	else if (nNewSize <= m_nMaxSize)
	{
		// it fits
		if (nNewSize > m_nSize)
		{
			// initialize the new elements

			memset(&m_pData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(void*));

		}

		m_nSize = nNewSize;
	}
	else
	{
		// otherwise, grow array
		int nGrowBy = m_nGrowBy;
		if (nGrowBy == 0)
		{
			// heuristically determine growth when nGrowBy == 0
			//  (this avoids heap fragmentation in many situations)
			nGrowBy = min(1024, max(4, m_nSize / 8));
		}
		int nNewMax;
		if (nNewSize < m_nMaxSize + nGrowBy)
			nNewMax = m_nMaxSize + nGrowBy;  // granularity
		else
			nNewMax = nNewSize;  // no slush

		ASSERT_(nNewMax >= m_nMaxSize);  // no wrap around
#ifdef SIZE_T_MAX
		ASSERT_(nNewMax <= SIZE_T_MAX/sizeof(void*)); // no overflow
#endif
		void** pNewData = (void**) new BYTE[nNewMax * sizeof(void*)];

		// copy new data from old
		memcpy(pNewData, m_pData, m_nSize * sizeof(void*));

		// construct remaining elements
		ASSERT_(nNewSize > m_nSize);

		memset(&pNewData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(void*));


		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nSize = nNewSize;
		m_nMaxSize = nNewMax;
	}
}

int CPtrArray::Append(const CPtrArray& src)
{
//	ASSERT_VALID(this);
	ASSERT_(this != &src);   // cannot append to itself

	int nOldSize = m_nSize;
	SetSize(m_nSize + src.m_nSize);

	memcpy(m_pData + nOldSize, src.m_pData, src.m_nSize * sizeof(void*));

	return nOldSize;
}

void CPtrArray::Copy(const CPtrArray& src)
{
//	ASSERT_VALID(this);
	ASSERT_(this != &src);   // cannot append to itself

	SetSize(src.m_nSize);

	memcpy(m_pData, src.m_pData, src.m_nSize * sizeof(void*));

}

void CPtrArray::FreeExtra()
{
//	ASSERT_VALID(this);

	if (m_nSize != m_nMaxSize)
	{
		// shrink to desired size
#ifdef SIZE_T_MAX
		ASSERT_(m_nSize <= SIZE_T_MAX/sizeof(void*)); // no overflow
#endif
		void** pNewData = NULL;
		if (m_nSize != 0)
		{
			pNewData = (void**) new BYTE[m_nSize * sizeof(void*)];
			// copy new data from old
			memcpy(pNewData, m_pData, m_nSize * sizeof(void*));
		}

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nMaxSize = m_nSize;
	}
}

/////////////////////////////////////////////////////////////////////////////

void CPtrArray::SetAtGrow(int nIndex, void* newElement)
{
//	ASSERT_VALID(this);
	ASSERT_(nIndex >= 0);

	if (nIndex >= m_nSize)
		SetSize(nIndex+1);
	m_pData[nIndex] = newElement;
}

void CPtrArray::InsertAt(int nIndex, void* newElement, int nCount)
{
//	ASSERT_VALID(this);
	ASSERT_(nIndex >= 0);    // will expand to meet need
	ASSERT_(nCount > 0);     // zero or negative size not allowed

	if (nIndex >= m_nSize)
	{
		// adding after the end of the array
		SetSize(nIndex + nCount);  // grow so nIndex is valid
	}
	else
	{
		// inserting in the middle of the array
		int nOldSize = m_nSize;
		SetSize(m_nSize + nCount);  // grow it to new size
		// shift old data up to fill gap
		memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
			(nOldSize-nIndex) * sizeof(void*));

		// re-init slots we copied from

		memset(&m_pData[nIndex], 0, nCount * sizeof(void*));

	}

	// insert new value in the gap
	ASSERT_(nIndex + nCount <= m_nSize);
	while (nCount--)
		m_pData[nIndex++] = newElement;
}

void CPtrArray::RemoveAt(int nIndex, int nCount)
{
//	ASSERT_VALID(this);
	ASSERT_(nIndex >= 0);
	ASSERT_(nCount >= 0);
	ASSERT_(nIndex + nCount <= m_nSize);

	// just remove a range
	int nMoveCount = m_nSize - (nIndex + nCount);

	if (nMoveCount)
		memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
			nMoveCount * sizeof(void*));
	m_nSize -= nCount;
}

void CPtrArray::InsertAt(int nStartIndex, CPtrArray* pNewArray)
{
//	ASSERT_VALID(this);
	ASSERT_(pNewArray != NULL);
//	ASSERT_KINDOF(CPtrArray, pNewArray);
//	ASSERT_VALID(pNewArray);
	ASSERT_(nStartIndex >= 0);

	if (pNewArray->GetSize() > 0)
	{
		InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
		for (int i = 0; i < pNewArray->GetSize(); i++)
			SetAt(nStartIndex + i, pNewArray->GetAt(i));
	}
}



/////////////////////////////////////////////////////////////////////////////
// Diagnostics
/*
#ifdef _DEBUG
void CPtrArray::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "with " << m_nSize << " elements";
	if (dc.GetDepth() > 0)
	{
		for (int i = 0; i < m_nSize; i++)
			dc << "\n\t[" << i << "] = " << m_pData[i];
	}

	dc << "\n";
}

void CPtrArray::AssertValid() const
{
	CObject::AssertValid();

	if (m_pData == NULL)
	{
		ASSERT_(m_nSize == 0);
		ASSERT_(m_nMaxSize == 0);
	}
	else
	{
		ASSERT_(m_nSize >= 0);
		ASSERT_(m_nMaxSize >= 0);
		ASSERT_(m_nSize <= m_nMaxSize);
		ASSERT_(AfxIsValidAddress(m_pData, m_nMaxSize * sizeof(void*)));
	}
}
#endif //_DEBUG

#ifdef AFX_INIT_SEG
#pragma code_seg(AFX_INIT_SEG)
#endif


IMPLEMENT_DYNAMIC(CPtrArray, CObject)
*/
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\clssfcty.h ===
////////////////////////////////////////////////////////////////////
// File:	CSSCFcty.h
// Desc:	Definitions, classes, and prototypes for a DLL that
//			provides CSSFormat objects to any other object user.
////////////////////////////////////////////////////////////////////
#ifndef _CCLASSFACTORY_H_
#define _CCLASSFACTORY_H_

BOOL SetKeyAndValue(LPTSTR pszKey, LPTSTR pszSubkey, LPTSTR pszValue, LPTSTR pszThreadingModel);

class CClassFactory : public IClassFactory
{
	protected:
		// members
		ULONG m_cRef;

	public:
		// methods
		CClassFactory(void);
		~CClassFactory(void);
		STDMETHODIMP			QueryInterface(REFIID, LPVOID *);
		STDMETHODIMP_(ULONG)	AddRef(void);
		STDMETHODIMP_(ULONG)	Release(void);
		STDMETHODIMP			CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
		STDMETHODIMP			LockServer(BOOL);
};

typedef CClassFactory* PCClassFactory;

#endif _CCLASSFACTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\bookmark.h ===
//---------------------------------------------------------------------------
// Bookmark.h : CVDBookmark header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------


#ifndef __CVDBOOKMARK__
#define __CVDBOOKMARK__

#define VDBOOKMARKSTATUS_INVALID	0	// same as CURSOR_DBBMK_INVALID  
#define VDBOOKMARKSTATUS_CURRENT	1	// same as CURSOR_DBBMK_CURRENT  
#define VDBOOKMARKSTATUS_BEGINNING	2	// same as CURSOR_DBBMK_BEGINNING
#define VDBOOKMARKSTATUS_END		3	// same as CURSOR_DBBMK_END      

class CVDCursorPosition;

class CVDBookmark
{
	friend class CVDCursorPosition;
public:
// Construction/Destruction
    CVDBookmark();
	~CVDBookmark();

public:

// Access functions
	CURSOR_DBVARIANT GetBookmarkVariant(){return m_varBookmark;}
	HROW GetHRow(){return m_hRow;}
	BYTE* GetBookmark(){return m_pBookmark;}
	ULONG GetBookmarkLen(){return m_cbBookmark;}
	WORD GetStatus(){return m_wStatus;}

// validation functions
	BOOL IsSameBookmark(CVDBookmark * pbm);
	BOOL IsSameHRow(HROW hRow){return VDBOOKMARKSTATUS_CURRENT == m_wStatus && hRow == m_hRow ? TRUE : FALSE;}

protected:
// Data members
    CURSOR_DBVARIANT m_varBookmark;  // variant that holds bookmark as a safearray 
    ULONG           m_cbBookmark;    // length of bookmark in bytes
    BYTE *          m_pBookmark;     // pointer to bookmark's data
    HROW            m_hRow;          // hRow associated with this bookmark
    WORD			m_wStatus;		 // beginning/end/row/unknown

// Initialization functions
	void Reset();
	HRESULT SetBookmark(WORD wStatus, HROW hRow = 0, BYTE* pBookmark = NULL, ULONG cbBookmark = 0);

};


#endif //__CVDBOOKMARK__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\cmsr2c.cpp ===
//---------------------------------------------------------------------------
// CMSR2C.cpp : CVDCursorFromRowset implementation
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"         
#include "MSR2C.h"        
#include "CMSR2C.h"        
#include "Notifier.h"    
#include "RSColumn.h"     
#include "RSSource.h"         
#include "CursMain.h"

SZTHISFILE

//=--------------------------------------------------------------------------=
// CreateInstance - Same params as IClassFactory::CreateInstance
//
// Desc:	instantiates an CVDCursorFromRowset object, returning an interface
//			pointer.
// Parms:	riid -		ID identifying the interface the caller
//						desires	to have for the new object.
//			ppvObj -	pointer in which to store the desired
//						interface pointer for the new object.
// Return:	HRESULT -	NOERROR if successful, otherwise
//						E_NOINTERFACE if we cannot support the
//						requested interface.
//
HRESULT CVDCursorFromRowset::CreateInstance(LPUNKNOWN pUnkOuter, 
											REFIID riid, 
											LPVOID * ppvObj)
{
	if (!ppvObj)
		return E_INVALIDARG;

	*ppvObj=NULL;

    if (pUnkOuter) 
	{
		//If aggregating then they have to ask for IUnknown
        if (!DO_GUIDS_MATCH(riid, IID_IUnknown))
            return E_INVALIDARG;
    }
																	   
	//Create the object 
	CVDCursorFromRowset * pNewObj = new CVDCursorFromRowset(pUnkOuter);

	if (NULL==pNewObj)
		return E_OUTOFMEMORY;

	//Get interface from private unknown - needed for aggreagation support
	HRESULT hr=pNewObj->m_UnkPrivate.QueryInterface(riid, ppvObj);

	if FAILED(hr)
		delete pNewObj;

	return hr;
}

//=--------------------------------------------------------------------------=
// CVDCursorPosition - Constructor
//
CVDCursorFromRowset::CVDCursorFromRowset(LPUNKNOWN pUnkOuter)
{
	m_pUnkOuter	= pUnkOuter;

	VDUpdateObjectCount(1);  // update global object counter to prevent dll from being unloaded
}

//=--------------------------------------------------------------------------=
// CVDCursorPosition - Destructor
//
CVDCursorFromRowset::~CVDCursorFromRowset()
{
	VDUpdateObjectCount(-1);  // update global object counter to allow dll to be unloaded
}
///////////////////////////////////////////////////////////////////
// Name:	QueryInterface
// Desc:	allows a client to ask our object if we support a
//			particular method.
// Parms:	[in] riid - ID of method the client is querying for.
//			[out] ppv - pointer to the interface requested.
// Return:	HRESULT -	NOERROR if a pointer to the interface will
//						be returned, or E_NOINTERFACE if it cannot.
////////////////////////////////////////////////////////////////////
STDMETHODIMP CVDCursorFromRowset::QueryInterface(REFIID riid, void** ppv)
{
	if (m_pUnkOuter)
		return m_pUnkOuter->QueryInterface(riid, ppv);
	else
		return m_UnkPrivate.QueryInterface(riid, ppv);
}


////////////////////////////////////////////////////////////////////
// Name:	AddRef
// Desc:	increment the reference count on our object.
// Parms:	none
// Return:	current reference count.
////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CVDCursorFromRowset::AddRef(void)
{
	if (m_pUnkOuter)
		return m_pUnkOuter->AddRef();
	else
		return m_UnkPrivate.AddRef();
}

////////////////////////////////////////////////////////////////////
// Name:	Release
// Desc:	decrement the reference count on our object.  If the
//			count has gone to 0, destroy the object.
// Parms:	none
// Return:	current reference count.
////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CVDCursorFromRowset::Release(void)
{
	if (m_pUnkOuter)
		return m_pUnkOuter->Release();
	else
		return m_UnkPrivate.Release();
}

//=--------------------------------------------------------------------------=
// GetCursor - Get cursor from rowset
//=--------------------------------------------------------------------------=
STDMETHODIMP CVDCursorFromRowset::GetCursor(IRowset * pRowset,
										    ICursor ** ppCursor,
										    LCID lcid)
{
    return CVDCursorMain::Create(pRowset, ppCursor, lcid);
}

//=--------------------------------------------------------------------------=
// GetCursor - Get cursor from row position
//=--------------------------------------------------------------------------=
STDMETHODIMP CVDCursorFromRowset::GetCursor(IRowPosition * pRowPosition,
										    ICursor ** ppCursor,
										    LCID lcid)
{
    return CVDCursorMain::Create(pRowPosition, ppCursor, lcid);
}

//=--------------------------------------------------------------------------=
// CVDCursorFromRowset::CPrivateUnknownObject::m_pMainUnknown
//=--------------------------------------------------------------------------=
// this method is used when we're sitting in the private unknown object,
// and we need to get at the pointer for the main unknown.  basically, it's
// a little better to do this pointer arithmetic than have to store a pointer
// to the parent, etc.
//
inline CVDCursorFromRowset *CVDCursorFromRowset::CPrivateUnknownObject::m_pMainUnknown
(
    void
)
{
    return (CVDCursorFromRowset *)((LPBYTE)this - offsetof(CVDCursorFromRowset, m_UnkPrivate));
}

//=--------------------------------------------------------------------------=
// CVDCursorFromRowset::CPrivateUnknownObject::QueryInterface
//=--------------------------------------------------------------------------=
// this is the non-delegating internal QI routine.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
STDMETHODIMP CVDCursorFromRowset::CPrivateUnknownObject::QueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
	if (!ppvObjOut)
		return E_INVALIDARG;

	*ppvObjOut = NULL;

    if (DO_GUIDS_MATCH(riid, IID_IUnknown)) 
	{
		m_cRef++;
        *ppvObjOut = (IUnknown *)this;
	}
	else
    if (DO_GUIDS_MATCH(riid, IID_ICursorFromRowset)) 
	{
        m_pMainUnknown()->AddRef();
        *ppvObjOut = m_pMainUnknown();
	}
	else
    if (DO_GUIDS_MATCH(riid, IID_ICursorFromRowPosition)) 
	{
        m_pMainUnknown()->AddRef();
        *ppvObjOut = (ICursorFromRowPosition*)m_pMainUnknown();
	}

	return *ppvObjOut ? S_OK : E_NOINTERFACE;

}

//=--------------------------------------------------------------------------=
// CVDCursorFromRowset::CPrivateUnknownObject::AddRef
//=--------------------------------------------------------------------------=
// adds a tick to the current reference count.
//
// Output:
//    ULONG        - the new reference count
//
// Notes:
//
ULONG CVDCursorFromRowset::CPrivateUnknownObject::AddRef
(
    void
)
{
    return ++m_cRef;
}

//=--------------------------------------------------------------------------=
// CVDCursorFromRowset::CPrivateUnknownObject::Release
//=--------------------------------------------------------------------------=
// removes a tick from the count, and delets the object if necessary
//
// Output:
//    ULONG         - remaining refs
//
// Notes:
//
ULONG CVDCursorFromRowset::CPrivateUnknownObject::Release
(
    void
)
{
    ULONG cRef = --m_cRef;

    if (!m_cRef)
        delete m_pMainUnknown();

    return cRef;
}

//=--------------------------------------------------------------------------=
// VDGetICursorFromIRowset
//=--------------------------------------------------------------------------=
// MSR2C entry point
//
HRESULT WINAPI VDGetICursorFromIRowset(IRowset * pRowset,
                                       ICursor ** ppCursor,
                                       LCID lcid)
{
	// call update object count to initialize g_pMalloc if not already initialized 
	VDUpdateObjectCount(1);

    HRESULT hr = CVDCursorMain::Create(pRowset, ppCursor, lcid);

	// maintain correct object count (object count is incremented in the constructor
	// of CVDCursorMain)
	VDUpdateObjectCount(-1);

	return hr;
}

// object construction/destruction counters (debug only)
//
#ifdef _DEBUG
int g_cVDNotifierCreated;                    // CVDNotifier
int g_cVDNotifierDestroyed;
int g_cVDNotifyDBEventsConnPtCreated;        // CVDNotifyDBEventsConnPt
int g_cVDNotifyDBEventsConnPtDestroyed;
int g_cVDNotifyDBEventsConnPtContCreated;    // CVDNotifyDBEventsConnPtCont
int g_cVDNotifyDBEventsConnPtContDestroyed;
int g_cVDEnumConnPointsCreated;              // CVDEnumConnPoints
int g_cVDEnumConnPointsDestroyed;
int g_cVDRowsetColumnCreated;                // CVDRowsetColumn
int g_cVDRowsetColumnDestroyed;
int g_cVDRowsetSourceCreated;                // CVDRowsetSource
int g_cVDRowsetSourceDestroyed;
int g_cVDCursorMainCreated;                  // CVDCursorMain
int g_cVDCursorMainDestroyed;
int g_cVDCursorPositionCreated;              // CVDCursorPosition
int g_cVDCursorPositionDestroyed;
int g_cVDCursorBaseCreated;                  // CVDCursorBase
int g_cVDCursorBaseDestroyed;
int g_cVDCursorCreated;                      // CVDCursor
int g_cVDCursorDestroyed;
int g_cVDMetadataCursorCreated;              // CVDMetadataCursor
int g_cVDMetadataCursorDestroyed;
int g_cVDEntryIDDataCreated;                 // CVDEntryIDData
int g_cVDEntryIDDataDestroyed;
int g_cVDStreamCreated;                      // CVDStream
int g_cVDStreamDestroyed;
int g_cVDColumnUpdateCreated;                // CVDColumnUpdate
int g_cVDColumnUpdateDestroyed;
#endif // _DEBUG

// dump oject counters
//
#ifdef _DEBUG
void DumpObjectCounters()
{
    CHAR str[256];
    OutputDebugString("MSR2C Objects-\n");
    wsprintf(str, "CVDNotifier:                 Created = %d, Destroyed = %d, Equal = %d.\n", 
        g_cVDNotifierCreated,   g_cVDNotifierDestroyed, 
        g_cVDNotifierCreated == g_cVDNotifierDestroyed);
    OutputDebugString(str);
    wsprintf(str, "CVDNotifyDBEventsConnPt:     Created = %d, Destroyed = %d, Equal = %d.\n", 
        g_cVDNotifyDBEventsConnPtCreated,   g_cVDNotifyDBEventsConnPtDestroyed, 
        g_cVDNotifyDBEventsConnPtCreated == g_cVDNotifyDBEventsConnPtDestroyed);
    OutputDebugString(str);
    wsprintf(str, "CVDNotifyDBEventsConnPtCont: Created = %d, Destroyed = %d, Equal = %d.\n", 
        g_cVDNotifyDBEventsConnPtContCreated,   g_cVDNotifyDBEventsConnPtContDestroyed, 
        g_cVDNotifyDBEventsConnPtContCreated == g_cVDNotifyDBEventsConnPtContDestroyed);
    OutputDebugString(str);
    wsprintf(str, "CVDEnumConnPoints:           Created = %d, Destroyed = %d, Equal = %d.\n", 
        g_cVDEnumConnPointsCreated,   g_cVDEnumConnPointsDestroyed,
        g_cVDEnumConnPointsCreated == g_cVDEnumConnPointsDestroyed);
    OutputDebugString(str);
    wsprintf(str, "CVDRowsetColumn:             Created = %d, Destroyed = %d, Equal = %d.\n", 
        g_cVDRowsetColumnCreated,   g_cVDRowsetColumnDestroyed, 
        g_cVDRowsetColumnCreated == g_cVDRowsetColumnDestroyed);
    OutputDebugString(str);
    wsprintf(str, "CVDRowsetSource:             Created = %d, Destroyed = %d, Equal = %d.\n", 
        g_cVDRowsetSourceCreated,   g_cVDRowsetSourceDestroyed, 
        g_cVDRowsetSourceCreated == g_cVDRowsetSourceDestroyed);
    OutputDebugString(str);
    wsprintf(str, "CVDCursorMain:               Created = %d, Destroyed = %d, Equal = %d.\n", 
        g_cVDCursorMainCreated,   g_cVDCursorMainDestroyed, 
        g_cVDCursorMainCreated == g_cVDCursorMainDestroyed);
    OutputDebugString(str);
    wsprintf(str, "CVDCursorPosition:           Created = %d, Destroyed = %d, Equal = %d.\n", 
        g_cVDCursorPositionCreated,   g_cVDCursorPositionDestroyed, 
        g_cVDCursorPositionCreated == g_cVDCursorPositionDestroyed);
    OutputDebugString(str);
    wsprintf(str, "CVDCursorBase:               Created = %d, Destroyed = %d, Equal = %d.\n", 
        g_cVDCursorBaseCreated,   g_cVDCursorBaseDestroyed, 
        g_cVDCursorBaseCreated == g_cVDCursorBaseDestroyed);
    OutputDebugString(str);
    wsprintf(str, "CVDCursor:                   Created = %d, Destroyed = %d, Equal = %d.\n", 
        g_cVDCursorCreated,   g_cVDCursorDestroyed, 
        g_cVDCursorCreated == g_cVDCursorDestroyed);
    OutputDebugString(str);
    wsprintf(str, "CVDMetadataCursor:           Created = %d, Destroyed = %d, Equal = %d.\n", 
        g_cVDMetadataCursorCreated,   g_cVDMetadataCursorDestroyed, 
        g_cVDMetadataCursorCreated == g_cVDMetadataCursorDestroyed);
    OutputDebugString(str);
    wsprintf(str, "CVDEntryIDData:              Created = %d, Destroyed = %d, Equal = %d.\n", 
        g_cVDEntryIDDataCreated,   g_cVDEntryIDDataDestroyed, 
        g_cVDEntryIDDataCreated == g_cVDEntryIDDataDestroyed);
    OutputDebugString(str);
    wsprintf(str, "CVDStream:                   Created = %d, Destroyed = %d, Equal = %d.\n", 
        g_cVDStreamCreated,   g_cVDStreamDestroyed, 
        g_cVDStreamCreated == g_cVDStreamDestroyed);
    OutputDebugString(str);
    wsprintf(str, "CVDColumnUpdate:             Created = %d, Destroyed = %d, Equal = %d.\n", 
        g_cVDColumnUpdateCreated,   g_cVDColumnUpdateDestroyed, 
        g_cVDColumnUpdateCreated == g_cVDColumnUpdateDestroyed);
    OutputDebugString(str);
}
#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\bookmark.cpp ===
//---------------------------------------------------------------------------
// Bookmark.cpp : CVDBookmark implementation
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"         
#include "bookmark.h"         

SZTHISFILE

//=--------------------------------------------------------------------------=
// CVDBookmark - Constructor
//
CVDBookmark::CVDBookmark()
{

    VariantInit((VARIANT*)&m_varBookmark);
    m_pBookmark			= NULL;

	Reset();
}

//=--------------------------------------------------------------------------=
// ~CVDBookmark - Destructor
//
CVDBookmark::~CVDBookmark()
{

	SAFEARRAY * psa = NULL;

	if ((VT_ARRAY | VT_UI1) == V_VT(&m_varBookmark))
		psa = V_ARRAY(&m_varBookmark);

	if (psa && m_pBookmark)
		SafeArrayUnaccessData(psa);

    VariantClear((VARIANT*)&m_varBookmark);
}

//=--------------------------------------------------------------------------=
// Reset
//
void CVDBookmark::Reset()
{
    m_cbBookmark		= 0;   
    m_hRow				= 0;
	SetBookmark(VDBOOKMARKSTATUS_BEGINNING);
}

//=--------------------------------------------------------------------------=
// SetBookmark 
//
HRESULT CVDBookmark::SetBookmark(WORD wStatus, HROW hRow, BYTE* pBookmark, ULONG cbBookmark)
{

	SAFEARRAY * psa = NULL;

	switch (wStatus)
	{
		case VDBOOKMARKSTATUS_BEGINNING:
			cbBookmark	= CURSOR_DB_BMK_SIZE;
			pBookmark	= (BYTE*)&CURSOR_DBBMK_BEGINNING;
			break;
		case VDBOOKMARKSTATUS_END:
			cbBookmark	= CURSOR_DB_BMK_SIZE;
			pBookmark	= (BYTE*)&CURSOR_DBBMK_END;
			break;
		case VDBOOKMARKSTATUS_CURRENT:
			break;
		case VDBOOKMARKSTATUS_INVALID:
			return S_OK;
		default:
			ASSERT_(FALSE);
			return E_FAIL;
	}

	// initialize status flag
	m_wStatus	= VDBOOKMARKSTATUS_INVALID;

	// get pointer to existing safe array
	if ((VT_ARRAY | VT_UI1) == V_VT(&m_varBookmark))
		psa = V_ARRAY(&m_varBookmark);

	if (psa)
	{
		// if len changed and new len not = zero then redim array
		if (cbBookmark && cbBookmark != m_cbBookmark)
		{
			long lUbound;
			HRESULT hr = SafeArrayGetUBound(psa, 1, &lUbound);
			ASSERT_(!hr);
			if ((ULONG)lUbound + 1 != cbBookmark)	// confirm array needs rediming
			{
				if (psa && m_pBookmark)
					SafeArrayUnaccessData(psa);	// release old lock
				SAFEARRAYBOUND sab;
				sab.lLbound = 0; 
				sab.cElements = cbBookmark; 
				hr = SafeArrayRedim(psa, &sab);
				ASSERT_(!hr);
				if SUCCEEDED(hr)
					SafeArrayAccessData(psa, (void**)&m_pBookmark);
				else
					return hr;
			}
		}
	}
	else
	// if no existing array create one if passed in length not zero 
	if (cbBookmark && pBookmark)
	{
		SAFEARRAYBOUND sab;
		sab.lLbound = 0; 
		sab.cElements = cbBookmark; 
		psa = SafeArrayCreate(VT_UI1, 1, &sab);
		// if create was successful intital VARIANT structure
		if (psa)
		{
			V_VT(&m_varBookmark) = VT_ARRAY | VT_UI1;
            V_ARRAY(&m_varBookmark) = psa;
			SafeArrayAccessData(psa, (void**)&m_pBookmark);
		}
		else
			return E_OUTOFMEMORY;
	}

	// if everthing ok then copy bookmark data into safe array
	if (psa && m_pBookmark && pBookmark && cbBookmark)
		memcpy(m_pBookmark, pBookmark, cbBookmark);

	m_wStatus		= wStatus;
	m_cbBookmark	= cbBookmark;
	m_hRow			= hRow;

	return S_OK;
}

//=--------------------------------------------------------------------------=
// IsSameBookmark - compares bookmark data 
//
BOOL CVDBookmark::IsSameBookmark(CVDBookmark * pbm)
{
	ASSERT_(pbm);

	if (!pbm ||	
		VDBOOKMARKSTATUS_INVALID == pbm->GetStatus() ||
		VDBOOKMARKSTATUS_INVALID == m_wStatus)
		return FALSE;

	if (pbm->GetBookmarkLen() == m_cbBookmark	&&
		memcmp(pbm->GetBookmark(), m_pBookmark, m_cbBookmark) == 0)
		return TRUE;
	else
		return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\array_p.inl ===
//---------------------------------------------------------------------------
// ARRAY_P.inl : CPtrArray inline functions
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------


#ifndef __CPTRARRAY_INL__
#define __CPTRARRAY_INL__


inline int CPtrArray::GetSize() const
	{ return m_nSize; }
inline int CPtrArray::GetUpperBound() const
	{ return m_nSize-1; }
inline void CPtrArray::RemoveAll()
	{ SetSize(0); }
inline void* CPtrArray::GetAt(int nIndex) const
	{ ASSERT_(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
inline void CPtrArray::SetAt(int nIndex, void* newElement)
	{ ASSERT_(nIndex >= 0 && nIndex < m_nSize);
		m_pData[nIndex] = newElement; }
inline void*& CPtrArray::ElementAt(int nIndex)
	{ ASSERT_(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
inline const void** CPtrArray::GetData() const
	{ return (const void**)m_pData; }
inline void** CPtrArray::GetData()
	{ return (void**)m_pData; }
inline int CPtrArray::Add(void* newElement)
	{ int nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }
inline void* CPtrArray::operator[](int nIndex) const
	{ return GetAt(nIndex); }
inline void*& CPtrArray::operator[](int nIndex)
	{ return ElementAt(nIndex); }

#endif // __CPTRARRAY_INL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\cmsr2c.h ===
//---------------------------------------------------------------------------
// CMSR2C.h : CVDCursorFromRowset header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#ifndef _CMSR2C_H_
#define _CMSR2C_H_

class CVDCursorFromRowset : public ICursorFromRowset,
						    public ICursorFromRowPosition
{
public:
	static HRESULT CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj);

protected:
	// construction/destruction
	CVDCursorFromRowset(LPUNKNOWN pUnkOuter);
	~CVDCursorFromRowset();

	// data members
	LPUNKNOWN m_pUnkOuter;	// pointer to controlling unknown

public:
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR *ppvObj);
	STDMETHOD_(ULONG,AddRef)(THIS);
	STDMETHOD_(ULONG,Release)(THIS);

	// ICursorFromRowset method
	STDMETHOD(GetCursor)(THIS_ IRowset *pRowset, ICursor **ppCursor, LCID lcid);

	// ICursorFromRowPosition method
	STDMETHOD(GetCursor)(THIS_ IRowPosition *pRowPosition, ICursor **ppCursor, LCID lcid);

  private:
    // the inner, private unknown implementation is for the aggregator
    // to control the lifetime of this object
    //
    class CPrivateUnknownObject : public IUnknown {
      public:
        STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);

        // constructor is remarkably trivial
        //
        CPrivateUnknownObject() : m_cRef(0) {}

      private:
        CVDCursorFromRowset *m_pMainUnknown();
        ULONG m_cRef;
    } m_UnkPrivate;

    friend class CPrivateUnknownObject;
};

typedef CVDCursorFromRowset* PCVDCursorFromRowset;

#endif //_CMSR2C_H_

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\colupdat.cpp ===
//---------------------------------------------------------------------------
// ColumnUpdate.cpp : ColumnUpdate implementation
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h" 
#include "stdafx.h"
#include "Notifier.h"
#include "RSColumn.h"
#include "RSSource.h"
#include "CursMain.h"         
#include "CursBase.h"
#include "ColUpdat.h"
#include "resource.h"         

SZTHISFILE


//=--------------------------------------------------------------------------=
// CVDColumnUpdate - Constructor
//
CVDColumnUpdate::CVDColumnUpdate()
{
    m_dwRefCount    = 1;
    m_pColumn       = NULL;
    m_cbVarDataLen  = 0;
    m_dwInfo        = 0;

    VariantInit((VARIANT*)&m_variant);

#ifdef _DEBUG
    g_cVDColumnUpdateCreated++;
#endif         
}

//=--------------------------------------------------------------------------=
// ~CVDColumnUpdate - Destructor
//
CVDColumnUpdate::~CVDColumnUpdate()
{
    VariantClear((VARIANT*)&m_variant);

#ifdef _DEBUG
    g_cVDColumnUpdateDestroyed++;
#endif         
}

//=--------------------------------------------------------------------------=
// ExtractVariant - Extract variant
//=--------------------------------------------------------------------------=
// This function extracts a variant from update update data
//
// Parameters:
//    pBindParams       - [in]  a pointer to column update data
//    pVariant          - [out] a pointer a variant where to return data
//
// Output:
//    HRESULT - S_OK if successful
//              E_OUTOFMEMORY not enough memory to create object
//
// Notes:
//
HRESULT CVDColumnUpdate::ExtractVariant(CURSOR_DBBINDPARAMS * pBindParams, CURSOR_DBVARIANT * pVariant)
{
    ASSERT_POINTER(pBindParams, CURSOR_DBBINDPARAMS)
    ASSERT_POINTER(pVariant, CURSOR_DBVARIANT)

    // make sure we have all necessary pointers
    if (!pBindParams || !pBindParams->pData || !pVariant)
        return E_INVALIDARG;

    CURSOR_DBVARIANT varTemp;

    // initialize all variants
    VariantInit((VARIANT*)&varTemp);
    VariantInit((VARIANT*)pVariant);

    // create temporary variant from supplied data
    if (pBindParams->dwBinding & CURSOR_DBBINDING_VARIANT)
    {
	    varTemp = *(CURSOR_DBVARIANT*)pBindParams->pData;
    }
    else // extract variant from default binding
    {
        BYTE * pData = (BYTE*)pBindParams->pData;
	    varTemp.vt = (VARTYPE)pBindParams->dwDataType;

        switch (pBindParams->dwDataType)
        {
            case CURSOR_DBTYPE_BYTES:
    	        varTemp.vt = CURSOR_DBTYPE_BLOB;
				varTemp.blob.cbSize = *(ULONG*)pData;
				varTemp.blob.pBlobData = (BYTE*)(pData + sizeof(ULONG));
                break;

            case CURSOR_DBTYPE_CHARS:
    	        varTemp.vt = CURSOR_DBTYPE_LPSTR;
        	    varTemp.pszVal = (CHAR*)pData;
                break;

            case CURSOR_DBTYPE_WCHARS:
    	        varTemp.vt = CURSOR_DBTYPE_LPWSTR;
        	    varTemp.pwszVal = (WCHAR*)pData;
                break;

            case CURSOR_DBTYPE_BLOB:
				varTemp.blob.cbSize = *(ULONG*)pData;
				varTemp.blob.pBlobData = *(LPBYTE*)(pData + sizeof(ULONG));
                break;

            case CURSOR_DBTYPE_LPSTR:
        	    varTemp.pszVal = *(LPSTR*)pData;
                break;

            case CURSOR_DBTYPE_LPWSTR:
        	    varTemp.pwszVal = *(LPWSTR*)pData;
                break;

            default:
                memcpy(&varTemp.cyVal, pBindParams->pData, CVDCursorBase::GetCursorTypeLength(varTemp.vt, 0));
                break;
        }
    }

    HRESULT hr = S_OK;

    // convert temporary variant to a desirable type and return
    switch (varTemp.vt)
    {
        case CURSOR_DBTYPE_LPSTR:
            pVariant->vt      = VT_BSTR;
            pVariant->bstrVal = BSTRFROMANSI(varTemp.pszVal);
            break;

        case CURSOR_DBTYPE_LPWSTR:
            pVariant->vt      = VT_BSTR;
            pVariant->bstrVal = SysAllocString(varTemp.pwszVal);
            break;

        default:
            hr = VariantCopy((VARIANT*)pVariant, (VARIANT*)&varTemp);
            break;
    }

    return hr;
}

//=--------------------------------------------------------------------------=
// Create - Create column update object
//=--------------------------------------------------------------------------=
// This function creates and initializes a new column update object
//
// Parameters:
//    pColumn           - [in]  rowset column pointer
//    pBindParams       - [in]  a pointer to column update data
//    ppColumnUpdate    - [out] a pointer in which to return pointer to 
//                              column update object
//    pResourceDLL      - [in]  a pointer which keeps track of resource DLL
//
// Output:
//    HRESULT - S_OK if successful
//              E_OUTOFMEMORY not enough memory to create object
//
// Notes:
//
HRESULT CVDColumnUpdate::Create(CVDRowsetColumn * pColumn, CURSOR_DBBINDPARAMS * pBindParams,
    CVDColumnUpdate ** ppColumnUpdate, CVDResourceDLL * pResourceDLL)
{
    ASSERT_POINTER(pColumn, CVDRowsetColumn)
    ASSERT_POINTER(pBindParams, CURSOR_DBBINDPARAMS)
    ASSERT_POINTER(ppColumnUpdate, CVDColumnUpdate)

    // make sure we have all necessary pointers
    if (!pColumn || !pBindParams || !pBindParams->pData || !ppColumnUpdate)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursorUpdateARow, pResourceDLL);
        return E_INVALIDARG;
    }

    // init out parameter
    *ppColumnUpdate = NULL;

    // create new column update object
    CVDColumnUpdate * pColumnUpdate = new CVDColumnUpdate();

    if (!pColumnUpdate)
    {
        VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursorUpdateARow, pResourceDLL);
        return E_OUTOFMEMORY;
    }

    CURSOR_DBVARIANT variant;

    // extract a variant from update data
    HRESULT hr = ExtractVariant(pBindParams, &variant);

    if (FAILED(hr))
    {
        // destroy object
        delete pColumnUpdate;

        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursorUpdateARow, pResourceDLL);
        return E_INVALIDARG;
    }

    // store update information
    pColumnUpdate->m_pColumn        = pColumn;
    pColumnUpdate->m_variant        = variant;
    pColumnUpdate->m_cbVarDataLen   = pBindParams->cbVarDataLen;
    pColumnUpdate->m_dwInfo         = pBindParams->dwInfo;
    pColumnUpdate->m_pResourceDLL   = pResourceDLL;

    // we're done
    *ppColumnUpdate = pColumnUpdate;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// AddRef
//
ULONG CVDColumnUpdate::AddRef(void)
{
    return ++m_dwRefCount;
}

//=--------------------------------------------------------------------------=
// Release
//
ULONG CVDColumnUpdate::Release(void)
{
    if (1 > --m_dwRefCount)
    {
        delete this;
        return 0;
    }

    return m_dwRefCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\crerror.cpp ===
//---------------------------------------------------------------------------
// CursorErrorInfo.cpp : CVDCursor ISupportErrorInfo implementation file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "Notifier.h"
#include "RSColumn.h"
#include "RSSource.h"
#include "CursMain.h"         
#include "CursBase.h"         
#include "fastguid.h"         

// needed for ASSERTs and FAIL
//
SZTHISFILE

//=--------------------------------------------------------------------------=
// ISupportErrorInfo Methods
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// ISupportErrorInfo InterfaceSupportsErrorInfo
//
HRESULT CVDCursorBase::InterfaceSupportsErrorInfo(REFIID riid)
{
	BOOL fSupportsErrorInfo	= FALSE;

	switch (riid.Data1) 
	{
		SUPPORTS_ERROR_INFO(ICursor);
		SUPPORTS_ERROR_INFO(ICursorMove);
		SUPPORTS_ERROR_INFO(ICursorScroll);
		SUPPORTS_ERROR_INFO(ICursorUpdateARow);
		SUPPORTS_ERROR_INFO(ICursorFind);
		SUPPORTS_ERROR_INFO(IEntryID);
	}						

    return fSupportsErrorInfo ? S_OK : S_FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\cursbase.cpp ===
//---------------------------------------------------------------------------
// CursorBase.cpp : CursorBase implementation
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "Notifier.h"
#include "RSColumn.h"
#include "RSSource.h"
#include "CursMain.h"         
#include "CursBase.h"
#include "fastguid.h"
#include "resource.h"

SZTHISFILE


//=--------------------------------------------------------------------------=
// CVDCursorBase - Constructor
//
CVDCursorBase::CVDCursorBase()
{
    m_ulCursorBindings  = 0;
    m_pCursorBindings   = NULL;
    m_fNeedVarData      = FALSE;
    m_cbRowLength       = 0;
    m_cbVarRowLength    = 0;

#ifdef _DEBUG
    g_cVDCursorBaseCreated++;
#endif         
}

//=--------------------------------------------------------------------------=
// ~CVDCursorBase - Destructor
//
CVDCursorBase::~CVDCursorBase()
{
    DestroyCursorBindings(&m_pCursorBindings, &m_ulCursorBindings);

#ifdef _DEBUG
    g_cVDCursorBaseDestroyed++;
#endif         
}

//=--------------------------------------------------------------------------=
// DestroyCursorBindings - Destroy cursor bindings and column identifer names
//
void CVDCursorBase::DestroyCursorBindings(CURSOR_DBCOLUMNBINDING** ppCursorBindings,
											ULONG* pcBindings)
{
    for (ULONG ulBind = 0; ulBind < *pcBindings; ulBind++)
    {
        CURSOR_DBCOLUMNID * pCursorColumnID = &(*ppCursorBindings)[ulBind].columnID;

        if (pCursorColumnID->dwKind == CURSOR_DBCOLKIND_GUID_NAME || pCursorColumnID->dwKind == CURSOR_DBCOLKIND_NAME)
            delete [] pCursorColumnID->lpdbsz;
    }

    delete [] *ppCursorBindings;

    *ppCursorBindings = NULL;
    *pcBindings = 0;
}

//=--------------------------------------------------------------------------=
// IsValidCursorType - Return TRUE if specified cursor data type is valid
//
BOOL CVDCursorBase::IsValidCursorType(DWORD dwCursorType)
{
    BOOL fValid = FALSE;

    switch (dwCursorType)
    {
        case CURSOR_DBTYPE_I2:
        case CURSOR_DBTYPE_I4:
        case CURSOR_DBTYPE_I8:
        case CURSOR_DBTYPE_R4:
        case CURSOR_DBTYPE_R8:
        case CURSOR_DBTYPE_CY:
        case CURSOR_DBTYPE_DATE:
        case CURSOR_DBTYPE_FILETIME:
        case CURSOR_DBTYPE_BOOL:
        case CURSOR_DBTYPE_LPSTR:
        case CURSOR_DBTYPE_LPWSTR:
        case CURSOR_DBTYPE_BLOB:
        case CURSOR_DBTYPE_UI2:
        case CURSOR_DBTYPE_UI4:
        case CURSOR_DBTYPE_UI8:
        case CURSOR_DBTYPE_COLUMNID:
        case CURSOR_DBTYPE_BYTES:
        case CURSOR_DBTYPE_CHARS:
        case CURSOR_DBTYPE_WCHARS:
        case CURSOR_DBTYPE_ANYVARIANT:
        case VT_VARIANT:
        case VT_BSTR:
        case VT_UI1:
        case VT_I1:
            fValid = TRUE;
            break;
    }

    return fValid;
}

//=--------------------------------------------------------------------------=
// DoesCursorTypeNeedVarData - Return TRUE if specified cursor type needs 
//                             variable length buffer
//
BOOL CVDCursorBase::DoesCursorTypeNeedVarData(DWORD dwCursorType)
{
    BOOL fNeedsVarData = FALSE;

    switch (dwCursorType)
    {
        case CURSOR_DBTYPE_BLOB:
        case CURSOR_DBTYPE_LPSTR:
        case CURSOR_DBTYPE_LPWSTR:
            fNeedsVarData = TRUE;
            break;
    }

    return fNeedsVarData;
}

//=--------------------------------------------------------------------------=
// GetCursorTypeLength - Get the size in bytes required by cursor data type
//
ULONG CVDCursorBase::GetCursorTypeLength(DWORD dwCursorType, ULONG cbMaxLen)
{
    ULONG cbRequired = 0;

    switch (dwCursorType)
    {
        case CURSOR_DBTYPE_I2:
        case CURSOR_DBTYPE_UI2:
            cbRequired = sizeof(short);
            break;

        case CURSOR_DBTYPE_I4:
        case CURSOR_DBTYPE_UI4:
            cbRequired = sizeof(long);
            break;

        case CURSOR_DBTYPE_I8:
        case CURSOR_DBTYPE_UI8:
            cbRequired = sizeof(LARGE_INTEGER);
            break;

        case CURSOR_DBTYPE_R4:
            cbRequired = sizeof(float);
            break;

        case CURSOR_DBTYPE_R8:
            cbRequired = sizeof(double);
            break;

        case CURSOR_DBTYPE_CY:
            cbRequired = sizeof(CY);
            break;

        case CURSOR_DBTYPE_DATE:
            cbRequired = sizeof(DATE);
            break;

        case CURSOR_DBTYPE_FILETIME:
            cbRequired = sizeof(FILETIME);
            break;

        case CURSOR_DBTYPE_BOOL:
            cbRequired = sizeof(VARIANT_BOOL);
            break;

        case CURSOR_DBTYPE_LPSTR:
            cbRequired = sizeof(LPSTR);
            break;

        case CURSOR_DBTYPE_LPWSTR:
            cbRequired = sizeof(LPWSTR);
            break;

        case CURSOR_DBTYPE_BLOB:
            cbRequired = sizeof(BLOB);
            break;

        case CURSOR_DBTYPE_COLUMNID:
            cbRequired = sizeof(CURSOR_DBCOLUMNID);
            break;

        case CURSOR_DBTYPE_BYTES:
            cbRequired = cbMaxLen;
            break;

        case CURSOR_DBTYPE_CHARS:
            cbRequired = cbMaxLen;
            break;

        case CURSOR_DBTYPE_WCHARS:
            cbRequired = cbMaxLen;
            break;

        case CURSOR_DBTYPE_ANYVARIANT:
            cbRequired = sizeof(CURSOR_DBVARIANT);
            break;

        case VT_VARIANT:
            cbRequired = sizeof(VARIANT);
            break;

        case VT_I1:
        case VT_UI1:
            cbRequired = sizeof(BYTE);
            break;
    }

    return cbRequired;
}

//=--------------------------------------------------------------------------=
// IsEqualCursorColumnID - Return TRUE if cursor column identifier are the same
//
BOOL CVDCursorBase::IsEqualCursorColumnID(const CURSOR_DBCOLUMNID& cursorColumnID1, const CURSOR_DBCOLUMNID& cursorColumnID2)
{
    // first check to see if column identifers are the same kind
    if (cursorColumnID1.dwKind != cursorColumnID1.dwKind)
        return FALSE;

    // then, check to see if they are equal
    BOOL bResult = TRUE;

    switch (cursorColumnID1.dwKind)
    {
	    case CURSOR_DBCOLKIND_GUID_NAME:
            if (!IsEqualGUID(cursorColumnID1.guid, cursorColumnID2.guid))
                bResult = FALSE;
            else if (lstrcmpW(cursorColumnID1.lpdbsz, cursorColumnID2.lpdbsz))
                bResult = FALSE;
            break;
            
	    case CURSOR_DBCOLKIND_GUID_NUMBER:
            if (!IsEqualGUID(cursorColumnID1.guid, cursorColumnID2.guid))
                bResult = FALSE;
            else if (cursorColumnID1.lNumber != cursorColumnID2.lNumber)
                bResult = FALSE;
            break;

        case CURSOR_DBCOLKIND_NAME:
            if (lstrcmpW(cursorColumnID1.lpdbsz, cursorColumnID2.lpdbsz))
                bResult = FALSE;
            break;
    }

    return bResult;
}

//=--------------------------------------------------------------------------=
// GetCursorColumnIDNameLength - Get the size in bytes of possible name attached
//                               to the specified cursor column identifier
//
ULONG CVDCursorBase::GetCursorColumnIDNameLength(const CURSOR_DBCOLUMNID& cursorColumnID)
{
    ULONG cbName = 0;

    if (cursorColumnID.dwKind == CURSOR_DBCOLKIND_GUID_NAME || cursorColumnID.dwKind == CURSOR_DBCOLKIND_NAME)
        cbName = (lstrlenW(cursorColumnID.lpdbsz) + 1) * sizeof(WCHAR);

    return cbName;
}

//=--------------------------------------------------------------------------=
// ValidateCursorBindings - Validate cursor column bindings
//=--------------------------------------------------------------------------=
// This function makes sure the specified column bindings are acceptable
//
// Parameters:
//    ulColumns             - [in]  the number available columns
//    pColumns              - [in]  an array of available columns
//    ulBindings            - [in]  the number of cursor column bindings
//    pCursorBindings       - [in]  an array of cursor column bindings
//    cbRequestedRowLength  - [in]  the requested number of bytes of inline 
//                                  memory in a single row of data
//    dwFlags               - [in]  a flag that specifies whether to replace the
//                                  existing column bindings or add to them
//    pcbNewRowLength       - [out] a pointer to memory in which to return
//                                  the new number of bytes of inline memory
//                                  in a single row of data for all bindings
//    pcbNewRowLength       - [out] a pointer to memory in which to return
//                                  the new number of bytes of out-of-line memory
//                                  in a single row of data for all bindings
//
// Output:
//    HRESULT - S_OK if successful
//              CURSOR_DB_E_BADBINDINFO bad binding information
//              CURSOR_DB_E_COLUMNUNAVAILABLE columnID is not available
//              CURSOR_DB_E_ROWTOOSHORT cbRequestedRowLength was less than the minumum (and not zero)
//
// Notes:
//    This function also computes and returns the new fixed and variable buffer row length required
//    by all the cursor bindings.
//
HRESULT CVDCursorBase::ValidateCursorBindings(ULONG ulColumns, 
											  CVDRowsetColumn * pColumns, 
											  ULONG ulBindings, 
											  CURSOR_DBCOLUMNBINDING * pCursorBindings, 
											  ULONG cbRequestedRowLength, 
											  DWORD dwFlags,
                                              ULONG * pcbNewRowLength,
                                              ULONG * pcbNewVarRowLength)
{
    DWORD cbMaxLength;
    DWORD dwCursorType;
    BOOL fColumnIDAvailable;

    CVDRowsetColumn * pColumn;

    ULONG cbRequiredRowLength = 0;
    ULONG cbRequiredVarRowLength = 0;

    CURSOR_DBCOLUMNBINDING * pBinding = pCursorBindings;

    // iterate through bindings
    for (ULONG ulBind = 0; ulBind < ulBindings; ulBind++)
    {
        // make sure column identifier is available
        fColumnIDAvailable = FALSE;

        pColumn = pColumns;

        for (ULONG ulCol = 0; ulCol < ulColumns && !fColumnIDAvailable; ulCol++)
        {
            if (IsEqualCursorColumnID(pBinding->columnID, pColumn->GetCursorColumnID()))
            {
                cbMaxLength = pColumn->GetMaxLength();
                dwCursorType = pColumn->GetCursorType();
                fColumnIDAvailable = TRUE;
            }

            pColumn++;
        }

        if (!fColumnIDAvailable)
        {
            VDSetErrorInfo(IDS_ERR_COLUMNUNAVAILABLE, IID_ICursor, m_pResourceDLL);
            return CURSOR_DB_E_COLUMNUNAVAILABLE;
        }

        // make sure caller supplied a maximum length if a default binding was specified 
        // for the cursor types CURSOR_DBTYPE_CHARS, CURSOR_DBTYPE_WCHARS or CURSOR_DBTYPE_BYTES
        if (pBinding->cbMaxLen == CURSOR_DB_NOMAXLENGTH && 
            pBinding->dwBinding == CURSOR_DBBINDING_DEFAULT)
        {
            if (pBinding->dwDataType == CURSOR_DBTYPE_CHARS || 
                pBinding->dwDataType == CURSOR_DBTYPE_WCHARS || 
                pBinding->dwDataType == CURSOR_DBTYPE_BYTES)
            {
                VDSetErrorInfo(IDS_ERR_BADCURSORBINDINFO, IID_ICursor, m_pResourceDLL);
                return CURSOR_DB_E_BADBINDINFO;
            }
        }

        // check binding bit mask for possible values
        if (pBinding->dwBinding != CURSOR_DBBINDING_DEFAULT && 
            pBinding->dwBinding != CURSOR_DBBINDING_VARIANT &&
            pBinding->dwBinding != CURSOR_DBBINDING_ENTRYID && 
            pBinding->dwBinding != (CURSOR_DBBINDING_VARIANT | CURSOR_DBBINDING_ENTRYID))
        {
            VDSetErrorInfo(IDS_ERR_BADCURSORBINDINFO, IID_ICursor, m_pResourceDLL);
            return CURSOR_DB_E_BADBINDINFO;
        }

        // check for valid cursor type
        if (!IsValidCursorType(pBinding->dwDataType))
        {
            VDSetErrorInfo(IDS_ERR_BADCURSORBINDINFO, IID_ICursor, m_pResourceDLL);
            return CURSOR_DB_E_BADBINDINFO;
        }

        // if a variant binding was specified make sure the cursor type is not CURSOR_DBTYPE_CHARS, 
        // CURSOR_DBTYPE_WCHARS or CURSOR_DBTYPE_BYTES
        if (pBinding->dwBinding & CURSOR_DBBINDING_VARIANT)
        {
            if (pBinding->dwDataType == CURSOR_DBTYPE_CHARS || 
                pBinding->dwDataType == CURSOR_DBTYPE_WCHARS || 
                pBinding->dwDataType == CURSOR_DBTYPE_BYTES)
            {
                VDSetErrorInfo(IDS_ERR_BADCURSORBINDINFO, IID_ICursor, m_pResourceDLL);
                return CURSOR_DB_E_BADBINDINFO;
            }
        }

        // if its not a variant binding make sure the cursor type is not CURSOR_DBTYPE_ANYVARIANT
        if (!(pBinding->dwBinding & CURSOR_DBBINDING_VARIANT) && pBinding->dwDataType == CURSOR_DBTYPE_ANYVARIANT)
        {
            VDSetErrorInfo(IDS_ERR_BADCURSORBINDINFO, IID_ICursor, m_pResourceDLL);
            return CURSOR_DB_E_BADBINDINFO;
        }

        // calulate row length required by data field
        if (!(pBinding->dwBinding & CURSOR_DBBINDING_VARIANT))
            cbRequiredRowLength += GetCursorTypeLength(pBinding->dwDataType, pBinding->cbMaxLen);
        else
            cbRequiredRowLength += sizeof(CURSOR_DBVARIANT);

        // calulate row length required by variable data length field
        if (pBinding->obVarDataLen != CURSOR_DB_NOVALUE)
            cbRequiredRowLength += sizeof(ULONG);

        // calulate row length required by information field
        if (pBinding->obInfo != CURSOR_DB_NOVALUE)
            cbRequiredRowLength += sizeof(DWORD);

        // calulate variable row length required by data field
        if (!(pBinding->dwBinding & CURSOR_DBBINDING_VARIANT))
        {
            if (DoesCursorTypeNeedVarData(pBinding->dwDataType))
            {
                if (pBinding->cbMaxLen != CURSOR_DB_NOMAXLENGTH)
                    cbRequiredVarRowLength += pBinding->cbMaxLen;
                else
                    cbRequiredVarRowLength += cbMaxLength;
            }
        }
        else    // variant binding
        {
            if (DoesCursorTypeNeedVarData(pBinding->dwDataType))
            {
                if (pBinding->cbMaxLen != CURSOR_DB_NOMAXLENGTH)
                    cbRequiredVarRowLength += pBinding->cbMaxLen;
                else
                    cbRequiredVarRowLength += cbMaxLength;
            }

            if (pBinding->dwDataType == CURSOR_DBTYPE_COLUMNID)
                cbRequiredVarRowLength += sizeof(CURSOR_DBCOLUMNID);
        }

        pBinding++;
    }

    // if we're replacing bindings reset row lengths
    if (dwFlags == CURSOR_DBCOLUMNBINDOPTS_REPLACE)
    {
        *pcbNewRowLength    = 0;
        *pcbNewVarRowLength = 0;
    }
    else // if we're adding bindings set to current row lengths
    {
        *pcbNewRowLength    = m_cbRowLength;
        *pcbNewVarRowLength = m_cbVarRowLength;
    }

    // if no row length was requested, use required row length
    if (!cbRequestedRowLength)
    {
        *pcbNewRowLength += cbRequiredRowLength;
    }
    else    // make sure row length is large enough
    {
        if (cbRequestedRowLength < *pcbNewRowLength + cbRequiredRowLength)
        {
            VDSetErrorInfo(IDS_ERR_ROWTOOSHORT, IID_ICursor, m_pResourceDLL);
            return CURSOR_DB_E_ROWTOOSHORT;
        }

        // use requested row length
        *pcbNewRowLength += cbRequestedRowLength;
    }

    // calculate required variable row length
    *pcbNewVarRowLength += cbRequiredVarRowLength;

    return S_OK;
}


//=--------------------------------------------------------------------------=
// DoCursorBindingsNeedVarData - Return TRUE if current cursor column bindings
//                               need variable length buffer
//
BOOL CVDCursorBase::DoCursorBindingsNeedVarData()
{
    BOOL fNeedVarData = FALSE;

    CURSOR_DBCOLUMNBINDING * pCursorBinding = m_pCursorBindings;

    for (ULONG ulBind = 0; ulBind < m_ulCursorBindings && !fNeedVarData; ulBind++)
    {
        if (DoesCursorTypeNeedVarData(pCursorBinding->dwDataType))
            fNeedVarData = TRUE;

        pCursorBinding++;
    }

    return fNeedVarData;
}

//=--------------------------------------------------------------------------=
// Validate fetch params
//=--------------------------------------------------------------------------=
//
// Parameters:
//    pFetchParams   - [in] ptr to the CURSOR_DBFETCHROWS structure
//    riid		     - [in] guid of calling interface (used for error generation)
//
// Output:
//    HRESULT - S_OK if pFetchParams valid
//              CURSOR_DB_E_BADFETCHINFO if pFetchParams invalid
//
//
HRESULT CVDCursorBase::ValidateFetchParams(CURSOR_DBFETCHROWS *pFetchParams, REFIID riid)
{

    if (!pFetchParams)
	{
        VDSetErrorInfo(IDS_ERR_INVALIDARG, riid, m_pResourceDLL);
        return E_INVALIDARG;
	}

    // init out parameter
    pFetchParams->cRowsReturned = 0;

    // return if caller didn't ask for any rows
    if (!pFetchParams->cRowsRequested)
        return S_OK;

	HRESULT hr = S_OK;

    // make sure fetch flags has only valid values
    if (pFetchParams->dwFlags != CURSOR_DBROWFETCH_DEFAULT &&
        pFetchParams->dwFlags != CURSOR_DBROWFETCH_CALLEEALLOCATES &&
        pFetchParams->dwFlags != CURSOR_DBROWFETCH_FORCEREFRESH &&
        pFetchParams->dwFlags != (CURSOR_DBROWFETCH_CALLEEALLOCATES | CURSOR_DBROWFETCH_FORCEREFRESH))
        hr =  CURSOR_DB_E_BADFETCHINFO;

    // if memory was caller allocated, make sure caller supplied data pointer 
    if (!(pFetchParams->dwFlags & CURSOR_DBROWFETCH_CALLEEALLOCATES) && !pFetchParams->pData)
        hr =  CURSOR_DB_E_BADFETCHINFO;

    // if memory was caller allocated, make sure caller supplied var-data pointer and size if needed
    if (!(pFetchParams->dwFlags & CURSOR_DBROWFETCH_CALLEEALLOCATES) && m_fNeedVarData &&
        (!pFetchParams->pVarData || !pFetchParams->cbVarData))
        hr =  CURSOR_DB_E_BADFETCHINFO;

	if (FAILED(hr))
        VDSetErrorInfo(IDS_ERR_BADFETCHINFO, riid, m_pResourceDLL);

	return hr;

}

//=--------------------------------------------------------------------------=
// IUnknown methods implemented
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// IUnknown QueryInterface
//
HRESULT CVDCursorBase::QueryInterface(REFIID riid, void **ppvObjOut)
{
    ASSERT_POINTER(ppvObjOut, IUnknown*)

    if (!ppvObjOut)
        return E_INVALIDARG;

    *ppvObjOut = NULL;

    switch (riid.Data1) 
    {
        QI_INTERFACE_SUPPORTED((ICursor*)this, IUnknown);
        QI_INTERFACE_SUPPORTED(this, ICursor);
        QI_INTERFACE_SUPPORTED(this, ICursorMove);
        QI_INTERFACE_SUPPORTED_IF(this, ICursorScroll, SupportsScroll());
		QI_INTERFACE_SUPPORTED(this, ISupportErrorInfo);
    }                   

    if (NULL == *ppvObjOut)
        return E_NOINTERFACE;

    AddRef();

    return S_OK;
}

//=--------------------------------------------------------------------------=
// IUnknown AddRef (Notifier and MetadataCursor maintain reference count)
//
ULONG CVDCursorBase::AddRef(void)
{
   return (ULONG)E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// IUnknown Release (Notifier and MetadataCursor maintain reference count)
//
ULONG CVDCursorBase::Release(void)
{
   return (ULONG)E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// ICursor methods implemented
//=--------------------------------------------------------------------------=
// ICursor SetBindings
//=--------------------------------------------------------------------------=
// Replaces the existing column bindings or adds new column bindings to the 
// existing ones
//
// Parameters:
//    cCol              - [in] the number of columns to bind
//    rgBoundColumns    - [in] an array of column bindings, one for each 
//                             column for which data is to be returned
//    cbRowLength       - [in] the number of bytes of inline memory in a 
//                             single row of data
//    dwFlags           - [in] a flag that specifies whether to replace the
//                             existing column bindings or add to them
//
// Output:
//    HRESULT - S_OK if successful
//              E_OUTOFMEMORY not enough memory
//
// Notes:
//    Parameter validation is performed by derived classes
//
HRESULT CVDCursorBase::SetBindings(ULONG cCol, CURSOR_DBCOLUMNBINDING rgBoundColumns[], ULONG cbRowLength, DWORD dwFlags)
{
    // reset flag
    m_fNeedVarData = FALSE;

    // if we should replace, then first destroy existing bindings
    if (dwFlags == CURSOR_DBCOLUMNBINDOPTS_REPLACE)
	    DestroyCursorBindings(&m_pCursorBindings, &m_ulCursorBindings);
    
    // if no new bindings are supplied, we're done
    if (!cCol)
        return S_OK;

    // create new storage
    CURSOR_DBCOLUMNBINDING * pCursorBindings = new CURSOR_DBCOLUMNBINDING[m_ulCursorBindings + cCol];

    if (!pCursorBindings)
    {
        VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
        return E_OUTOFMEMORY;
    }

    // if we have exsiting bindings, then copy them over
    if (m_pCursorBindings)
        memcpy(pCursorBindings, m_pCursorBindings, m_ulCursorBindings * sizeof(CURSOR_DBCOLUMNBINDING));

    // then append new bindings directly,
    memcpy(pCursorBindings + m_ulCursorBindings, rgBoundColumns, cCol * sizeof(CURSOR_DBCOLUMNBINDING));

    // and adjust possible cursor column identifier names in new bindings
    for (ULONG ulBind = m_ulCursorBindings; ulBind < m_ulCursorBindings + cCol; ulBind++)
    {
        CURSOR_DBCOLUMNID * pCursorColumnID = &pCursorBindings[ulBind].columnID; 

        if (pCursorColumnID->dwKind == CURSOR_DBCOLKIND_GUID_NAME || pCursorColumnID->dwKind == CURSOR_DBCOLKIND_NAME)
        {
            const int nLength = lstrlenW(pCursorColumnID->lpdbsz);

            WCHAR * pwszName = new WCHAR[nLength + 1];
			if (!pwszName)
			{
				DestroyCursorBindings(&pCursorBindings, &ulBind);
				delete [] m_pCursorBindings;
				m_ulCursorBindings	= 0;
				VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
				return E_OUTOFMEMORY;
			}
			memcpy(pwszName, pCursorColumnID->lpdbsz, (nLength + 1) * sizeof(WCHAR));
			pCursorColumnID->lpdbsz = pwszName;
        }
    }

    m_ulCursorBindings += cCol;

    // delete previous storage
	// any existing bindings will have been copied over into 
	delete [] m_pCursorBindings;

    m_pCursorBindings = pCursorBindings;

    // determine if new bindings need variable length buffer
    m_fNeedVarData = DoCursorBindingsNeedVarData();

    return S_OK;
}

//=--------------------------------------------------------------------------=
// ICursor GetBindings
//=--------------------------------------------------------------------------=
// Returns the current column bindings
//
// Parameters:
//    pcCol             - [out] a pointer to memory in which to return the 
//                              number of bound columns
//    prgBoundColumns   - [out] a pointer to memory in which to return a 
//                              pointer to an array containing the current
//                              column bindings (callee allocated)
//    pcbRowLength      - [out] a pointer to memory in which to return the
//                              number of bytes of inline memory in a single 
//                              row
//
// Output:
//    HRESULT - S_OK if successful
//              E_OUTOFMEMORY not enough memory
//
// Notes: 
//
HRESULT CVDCursorBase::GetBindings(ULONG *pcCol, 
								   CURSOR_DBCOLUMNBINDING *prgBoundColumns[], 
								   ULONG *pcbRowLength)
{
    ASSERT_NULL_OR_POINTER(pcCol, ULONG)
    ASSERT_NULL_OR_POINTER(prgBoundColumns, CURSOR_DBCOLUMNBINDING)
    ASSERT_NULL_OR_POINTER(pcbRowLength, ULONG)

    // init out parameters
    if (pcCol)
        *pcCol = 0;

    if (prgBoundColumns)
        *prgBoundColumns = NULL;

    if (pcbRowLength)
        *pcbRowLength = 0;

    // return column bindings
    if (prgBoundColumns && m_ulCursorBindings)    
    {
        // calculate size of bindings
        ULONG cbBindings = m_ulCursorBindings * sizeof(CURSOR_DBCOLUMNBINDING);

        // calculate extra space needed for names in column identifers
        ULONG cbNames = 0;

        for (ULONG ulBind = 0; ulBind < m_ulCursorBindings; ulBind++)
            cbNames += GetCursorColumnIDNameLength(m_pCursorBindings[ulBind].columnID);

        // allocate memory for bindings and names
        CURSOR_DBCOLUMNBINDING * pCursorBindings = (CURSOR_DBCOLUMNBINDING*)g_pMalloc->Alloc(cbBindings + cbNames);

        if (!pCursorBindings)
        {
            VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
            return E_OUTOFMEMORY;
        }

        // copy bindings directly
        memcpy(pCursorBindings, m_pCursorBindings, cbBindings);

        // adjust column identifier names
        WCHAR * pwszName = (WCHAR*)(pCursorBindings + m_ulCursorBindings);

        for (ulBind = 0; ulBind < m_ulCursorBindings; ulBind++)
        {
            CURSOR_DBCOLUMNID * pCursorColumnID = &pCursorBindings[ulBind].columnID;

            if (pCursorColumnID->dwKind == CURSOR_DBCOLKIND_GUID_NAME || pCursorColumnID->dwKind == CURSOR_DBCOLKIND_NAME)
            {
                const int nLength = lstrlenW(pCursorColumnID->lpdbsz);

                memcpy(pwszName, pCursorColumnID->lpdbsz, (nLength + 1) * sizeof(WCHAR)); 
                pCursorColumnID->lpdbsz = pwszName;
                pwszName += nLength + 1;
            }
        }

        *prgBoundColumns = pCursorBindings;

		// sanity check
		ASSERT_((BYTE*)pwszName == ((BYTE*)pCursorBindings) + cbBindings + cbNames);
    
	}
    
    // return bound column count
    if (pcCol)  
        *pcCol = m_ulCursorBindings;

    // return row length
    if (pcbRowLength)
        *pcbRowLength = m_cbRowLength;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\cursmain.cpp ===
//---------------------------------------------------------------------------
// CursorMain.cpp : CursorMain implementation
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "MSR2C.h"
#include "Notifier.h"
#include "RSColumn.h"
#include "RSSource.h"
#include "CursMain.h"
#include "ColUpdat.h"
#include "CursPos.h"
#include "CursBase.h"
#include "enumcnpt.h"
#include "Cursor.h"
#include "Bookmark.h"
#include "fastguid.h"

SZTHISFILE

#include "ARRAY_P.inl"

// static data
DWORD               CVDCursorMain::s_dwMetaRefCount   = 0;
ULONG               CVDCursorMain::s_ulMetaColumns    = 0;
CVDRowsetColumn *   CVDCursorMain::s_rgMetaColumns    = NULL;


//=--------------------------------------------------------------------------=
// CVDCursorMain - Constructor
//
CVDCursorMain::CVDCursorMain(LCID lcid) : m_resourceDLL(lcid)
{
    m_fWeAddedMetaRef		    = FALSE;
	m_fPassivated			    = FALSE;
	m_fColumnsRowsetSupported   = FALSE;
    m_fInternalInsertRow        = FALSE;
    m_fInternalDeleteRows       = FALSE;
    m_fInternalSetData          = FALSE;

	m_fLiteralBookmarks		    = FALSE;			
	m_fOrderedBookmarks		    = FALSE;
    m_fBookmarkSkipped          = FALSE;			

	m_fConnected			    = FALSE;
	m_dwAdviseCookie		    = 0;
    m_ulColumns				    = 0;
    m_rgColumns				    = NULL;

    m_cbMaxBookmark			    = 0;

	VDUpdateObjectCount(1);  // update object count to prevent dll from being unloaded

#ifdef _DEBUG
    g_cVDCursorMainCreated++;
#endif
}

//=--------------------------------------------------------------------------=
// ~CVDCursorMain - Destructor
//
CVDCursorMain::~CVDCursorMain()
{
	Passivate();

	VDUpdateObjectCount(-1);  // update object count to allow dll to be unloaded

#ifdef _DEBUG
    g_cVDCursorMainDestroyed++;
#endif
}

//=--------------------------------------------------------------------------=
// Pasivate when external ref count gets to zero
//
void CVDCursorMain::Passivate()
{

	if (m_fPassivated)
		return;

	m_fPassivated			= TRUE;

    if (IsRowsetValid())
	{
		if (m_hAccessorBM)
			GetAccessor()->ReleaseAccessor(m_hAccessorBM, NULL);

		if (m_fConnected)
			DisconnectIRowsetNotify();
	}

    DestroyColumns();
    DestroyMetaColumns();

}

//=--------------------------------------------------------------------------=
// Create - Create cursor provider from row position or rowset
//=--------------------------------------------------------------------------=
// This function creates and initializes a new cursor main object
//
// Parameters:
//    pRowPosition  - [in]  original IRowPosition provider (may be NULL)
//    pRowset       - [in]  original IRowset provider
//    ppCursor      - [out] resulting ICursor provider
//    lcid          - [in]  locale identifier
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//              E_OUTOFMEMORY not enough memory
//              VD_E_CANNOTCONNECTIROWSETNOTIFY unable to connect IRowsetNotify
//
// Notes:
//
HRESULT CVDCursorMain::Create(IRowPosition* pRowPosition, IRowset * pRowset, ICursor ** ppCursor, LCID lcid)
{
    ASSERT_POINTER(pRowset, IRowset)
    ASSERT_POINTER(ppCursor, ICursor*)

    if (!pRowset || !ppCursor)
        return E_INVALIDARG;

    // create new cursor main object
    CVDCursorMain * pCursorMain = new CVDCursorMain(lcid);

    if (!pCursorMain)
        return E_OUTOFMEMORY;

    // initialize rowset source
    HRESULT hr = pCursorMain->Initialize(pRowset);

    if (FAILED(hr))
    {
        pCursorMain->Release();
        return hr;
    }

    // create array of column objects
    hr = pCursorMain->CreateColumns();

    if (FAILED(hr))
    {
        pCursorMain->Release();
        return hr;
    }

    // create array of meta-column objects
    hr = pCursorMain->CreateMetaColumns();

    if (FAILED(hr))
    {
        pCursorMain->Release();
        return hr;
    }

	// create bookmark accessor
    DBBINDING rgBindings[1];
	DBBINDSTATUS rgStatus[1];

	memset(rgBindings, 0, sizeof(DBBINDING));

	rgBindings[0].iOrdinal      = 0;
    rgBindings[0].obValue       = 4;
    rgBindings[0].obLength      = 0;
    rgBindings[0].dwPart        = DBPART_VALUE | DBPART_LENGTH;
    rgBindings[0].dwMemOwner    = DBMEMOWNER_CLIENTOWNED;
    rgBindings[0].cbMaxLen      = pCursorMain->GetMaxBookmarkLen();
    rgBindings[0].wType         = DBTYPE_BYTES;

	hr = pCursorMain->GetAccessor()->CreateAccessor(DBACCESSOR_ROWDATA,
													1,
													rgBindings,
													0,
													&pCursorMain->m_hAccessorBM,
													rgStatus);
    if (FAILED(hr))
    {
        pCursorMain->Release();
        return VD_E_CANNOTCREATEBOOKMARKACCESSOR;
    }

    // create new cursor position object
    CVDCursorPosition * pCursorPosition;

    hr = CVDCursorPosition::Create(pRowPosition, pCursorMain, &pCursorPosition, &pCursorMain->m_resourceDLL);

    if (FAILED(hr))
    {
        pCursorMain->Release();
        return hr;
    }

    // create new cursor object
    CVDCursor * pCursor;

    hr = CVDCursor::Create(pCursorPosition, &pCursor, &pCursorMain->m_resourceDLL);

    if (FAILED(hr))
    {
        ((CVDNotifier*)pCursorPosition)->Release();
        pCursorMain->Release();
        return hr;
    }

    // connect IRowsetNotify
	hr = pCursorMain->ConnectIRowsetNotify();

	if (SUCCEEDED(hr))
		pCursorMain->m_fConnected = TRUE;

    // check rowset properties
    BOOL fCanHoldRows = TRUE;

	IRowsetInfo * pRowsetInfo = pCursorMain->GetRowsetInfo();

	if (pRowsetInfo)
	{
		DBPROPID propids[] = { DBPROP_LITERALBOOKMARKS,
							   DBPROP_ORDEREDBOOKMARKS,
                               DBPROP_BOOKMARKSKIPPED,
                               DBPROP_CANHOLDROWS };

		const DBPROPIDSET propsetids[] = { propids, 4, {0,0,0,0} };
		memcpy((void*)&propsetids[0].guidPropertySet, &DBPROPSET_ROWSET, sizeof(DBPROPSET_ROWSET));

		ULONG cPropertySets = 0;
		DBPROPSET * propset = NULL;
		hr = pRowsetInfo->GetProperties(1, propsetids, &cPropertySets, &propset);

		if (SUCCEEDED(hr) && propset && propset->rgProperties)
		{
			if (DBPROPSTATUS_OK == propset->rgProperties[0].dwStatus)
				pCursorMain->m_fLiteralBookmarks = V_BOOL(&propset->rgProperties[0].vValue);

			if (DBPROPSTATUS_OK == propset->rgProperties[1].dwStatus)
				pCursorMain->m_fOrderedBookmarks = V_BOOL(&propset->rgProperties[1].vValue);

			if (DBPROPSTATUS_OK == propset->rgProperties[2].dwStatus)
				pCursorMain->m_fBookmarkSkipped = V_BOOL(&propset->rgProperties[2].vValue);

			if (DBPROPSTATUS_OK == propset->rgProperties[3].dwStatus)
				fCanHoldRows = V_BOOL(&propset->rgProperties[3].vValue);
		}

		if (propset)
		{
			if (propset->rgProperties)
				g_pMalloc->Free(propset->rgProperties);

			g_pMalloc->Free(propset);
		}
	}

    // release our references
    pCursorMain->Release();
    ((CVDNotifier*)pCursorPosition)->Release();

    // check for required property
    if (!fCanHoldRows)
    {
        pCursor->Release();
        return VD_E_REQUIREDPROPERTYNOTSUPPORTED;
    }

    // we're done
    *ppCursor = pCursor;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// Create - Create cursor provider from rowset
//=--------------------------------------------------------------------------=
// This function creates and initializes a new cursor main object
//
// Parameters:
//    pRowset       - [in]  original IRowset provider
//    ppCursor      - [out] resulting ICursor provider
//    lcid          - [in]  locale identifier
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//              E_OUTOFMEMORY not enough memory
//              VD_E_CANNOTCONNECTIROWSETNOTIFY unable to connect IRowsetNotify
//
// Notes:
//
HRESULT CVDCursorMain::Create(IRowset * pRowset, ICursor ** ppCursor, LCID lcid)
{
    ASSERT_POINTER(pRowset, IRowset)
    ASSERT_POINTER(ppCursor, ICursor*)

    if (!pRowset || !ppCursor)
        return E_INVALIDARG;

	// create cursor as done before row position
	return Create(NULL, pRowset, ppCursor, lcid);
}

//=--------------------------------------------------------------------------=
// Create - Create cursor provider from row position
//=--------------------------------------------------------------------------=
// This function creates and initializes a new cursor main object
//
// Parameters:
//    pRowPosition  - [in]  original IRowPosition provider
//    ppCursor      - [out] resulting ICursor provider
//    lcid          - [in]  locale identifier
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//              E_OUTOFMEMORY not enough memory
//              VD_E_CANNOTCONNECTIROWSETNOTIFY unable to connect IRowPositionNotify
//				VD_E_CANNOTGETROWSETINTERFACE unable to get IRowset
//
// Notes:
//
HRESULT CVDCursorMain::Create(IRowPosition * pRowPosition, ICursor ** ppCursor, LCID lcid)
{
    ASSERT_POINTER(pRowPosition, IRowPosition)
    ASSERT_POINTER(ppCursor, ICursor*)

    if (!pRowPosition || !ppCursor)
        return E_INVALIDARG;

	IRowset * pRowset;

	// get IRowset from IRowPosition
	HRESULT hr = pRowPosition->GetRowset(IID_IRowset, (IUnknown**)&pRowset);

	if (FAILED(hr))
		return VD_E_CANNOTGETROWSETINTERFACE;

	// create cursor with new row position parameter
	hr = Create(pRowPosition, pRowset, ppCursor, lcid);

	pRowset->Release();

    // we're done
	return hr;
}

typedef struct tagVDMETADATA_METADATA
	{
        const CURSOR_DBCOLUMNID * pCursorColumnID;
		ULONG	cbMaxLength;
		CHAR *	pszName;
		DWORD	dwCursorType;
	} VDMETADATA_METADATA;

#define MAX_METADATA_COLUMNS 21

static const VDMETADATA_METADATA g_MetaDataMetaData[MAX_METADATA_COLUMNS] =
{
    // Bookmark column
	{ &CURSOR_COLUMN_BMKTEMPORARY,		sizeof(ULONG),				NULL,					CURSOR_DBTYPE_BLOB },
    // data columns
	{ &CURSOR_COLUMN_COLUMNID,			sizeof(CURSOR_DBCOLUMNID),	"COLUMN_COLUMNID",		CURSOR_DBTYPE_COLUMNID },
	{ &CURSOR_COLUMN_DATACOLUMN,		sizeof(VARIANT_BOOL),		"COLUMN_DATACOLUMN",	CURSOR_DBTYPE_BOOL },
	{ &CURSOR_COLUMN_ENTRYIDMAXLENGTH,	sizeof(ULONG),				"COLUMN_ENTRYIDMAXLENGTH",CURSOR_DBTYPE_I4 },
	{ &CURSOR_COLUMN_FIXED,				sizeof(VARIANT_BOOL),		"COLUMN_FIXED",			CURSOR_DBTYPE_BOOL },
	{ &CURSOR_COLUMN_MAXLENGTH,			sizeof(ULONG),				"COLUMN_MAXLENGTH",		CURSOR_DBTYPE_I4 },
	{ &CURSOR_COLUMN_NAME,				256,						"COLUMN_NAME",			VT_LPWSTR },
	{ &CURSOR_COLUMN_NULLABLE,			sizeof(VARIANT_BOOL),		"COLUMN_NULLABLE",		CURSOR_DBTYPE_BOOL },
	{ &CURSOR_COLUMN_NUMBER,			sizeof(ULONG),				"COLUMN_NUMBER",		CURSOR_DBTYPE_I4 },
	{ &CURSOR_COLUMN_SCALE,				sizeof(ULONG),				"COLUMN_SCALE",			CURSOR_DBTYPE_I4 },
	{ &CURSOR_COLUMN_TYPE,				sizeof(ULONG),				"COLUMN_TYPE",			CURSOR_DBTYPE_I4 },
	{ &CURSOR_COLUMN_UPDATABLE,			sizeof(ULONG),				"COLUMN_UPDATABLE",		CURSOR_DBTYPE_I4 },
	{ &CURSOR_COLUMN_BINDTYPE,			sizeof(ULONG),				"COLUMN_BINDTYPE",		CURSOR_DBTYPE_I4 },
    // optional metadata columns - supported with IColumnsRowset only)
	{ &CURSOR_COLUMN_AUTOINCREMENT,		sizeof(VARIANT_BOOL),		"COLUMN_AUTOINCREMENT",	CURSOR_DBTYPE_BOOL },
	{ &CURSOR_COLUMN_BASECOLUMNNAME,	256,						"COLUMN_BASECOLUMNNAME",VT_LPWSTR },
	{ &CURSOR_COLUMN_BASENAME,			256,						"COLUMN_BASENAME",		VT_LPWSTR },
	{ &CURSOR_COLUMN_COLLATINGORDER,	sizeof(LCID),				"COLUMN_COLLATINGORDER",CURSOR_DBTYPE_I4 },
	{ &CURSOR_COLUMN_DEFAULTVALUE,		256,						"COLUMN_DEFAULTVALUE",	VT_LPWSTR },
	{ &CURSOR_COLUMN_HASDEFAULT,		sizeof(VARIANT_BOOL),		"COLUMN_HASDEFAULT",	CURSOR_DBTYPE_BOOL },
	{ &CURSOR_COLUMN_CASESENSITIVE,		sizeof(VARIANT_BOOL),		"COLUMN_CASESENSITIVE",	CURSOR_DBTYPE_BOOL },
	{ &CURSOR_COLUMN_UNIQUE,			sizeof(VARIANT_BOOL),		"COLUMN_UNIQUE",		CURSOR_DBTYPE_BOOL },
};

//=--------------------------------------------------------------------------=
// CreateMetaColumns - Create array of meta-column objects
//
HRESULT CVDCursorMain::CreateMetaColumns()
{
    HRESULT hr = S_OK;

    EnterCriticalSection(&g_CriticalSection);

    if (!s_dwMetaRefCount)
    {
		// allocate a static aray of metadata metadata columns
        s_rgMetaColumns = new CVDRowsetColumn[MAX_METADATA_COLUMNS];

        if (!s_rgMetaColumns)
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }

        s_ulMetaColumns = MAX_METADATA_COLUMNS; // number of columns for IColumnsInfo

		// initialize the array elments from the static g_MetaDataMetaData table
		for (int i = 0; i < MAX_METADATA_COLUMNS; i++)
		{
	        s_rgMetaColumns[i].Initialize(g_MetaDataMetaData[i].pCursorColumnID,
										  (BOOL)i, // false for 1st column (bookmark) TRUE for all other columns
										  g_MetaDataMetaData[i].cbMaxLength,
										  g_MetaDataMetaData[i].pszName,
										  g_MetaDataMetaData[i].dwCursorType,
										  i );	// ordinal number
		}
    }

    s_dwMetaRefCount++;

    m_fWeAddedMetaRef = TRUE;

cleanup:
    LeaveCriticalSection(&g_CriticalSection);

    return hr;
}

//=--------------------------------------------------------------------------=
// DestroyMetaColumns - Destroy array of meta-columns objects
//
void CVDCursorMain::DestroyMetaColumns()
{
    EnterCriticalSection(&g_CriticalSection);

    if (m_fWeAddedMetaRef)
    {
        s_dwMetaRefCount--;

        if (!s_dwMetaRefCount)
        {
            delete [] s_rgMetaColumns;

            s_ulMetaColumns = 0;
            s_rgMetaColumns = NULL;
        }
    }

    LeaveCriticalSection(&g_CriticalSection);
}

//=--------------------------------------------------------------------------=
// CreateColumns - Create array of column objects
//
HRESULT CVDCursorMain::CreateColumns()
{
    IColumnsInfo * pColumnsInfo;

    // try to get IRowset's simple metadata interface
    HRESULT hr = m_pRowset->QueryInterface(IID_IColumnsInfo, (void**)&pColumnsInfo);

    if (FAILED(hr))
        return VD_E_CANNOTGETMANDATORYINTERFACE;

    ULONG cColumns          = 0;
    DBCOLUMNINFO * pInfo    = NULL;
    WCHAR * pStringsBuffer  = NULL;

    // now get column information
    hr = pColumnsInfo->GetColumnInfo(&cColumns, &pInfo, &pStringsBuffer);

    if (FAILED(hr))
    {
        pColumnsInfo->Release();
        return VD_E_CANNOTGETCOLUMNINFO;
    }

    // store column count
	// note cColumns includes the bookmark column (0)
    m_ulColumns = cColumns;

    // add one for CURSOR_COLUMN_BMK_CURSOR
    m_ulColumns++;

    // if rowset supports DBPROP_BOOKMARKSKIPPED add two for
    // CURSOR_COLUMN_BMK_TEMPORARYREL and CURSOR_COLUMN_BMK_CURSORREL
    if (m_fBookmarkSkipped)
        m_ulColumns += 2;

    // create array of rowset column objects
    m_rgColumns = new CVDRowsetColumn[m_ulColumns];

    if (!m_rgColumns)
    {
        if (pInfo)
            g_pMalloc->Free(pInfo);

        if (pStringsBuffer)
            g_pMalloc->Free(pStringsBuffer);

        pColumnsInfo->Release();

        return E_OUTOFMEMORY;
    }

    ULONG ulCursorOrdinal = 0;

    // get maximum length of bookmarks
    m_cbMaxBookmark = pInfo[0].ulColumnSize;

    // initialize data column(s)
    for (ULONG ulCol = 1; ulCol < cColumns; ulCol++)
    {
        m_rgColumns[ulCursorOrdinal].Initialize(ulCol, ulCursorOrdinal, &pInfo[ulCol], m_cbMaxBookmark);
        ulCursorOrdinal++;
    }

    // initialize bookmark columns
    pInfo[0].pwszName = NULL;   // ICursor requires bookmark columns have a NULL name

    m_rgColumns[ulCursorOrdinal].Initialize(0, ulCursorOrdinal, &pInfo[0], m_cbMaxBookmark,
        (CURSOR_DBCOLUMNID*)&CURSOR_COLUMN_BMKTEMPORARY);
    ulCursorOrdinal++;

    m_rgColumns[ulCursorOrdinal].Initialize(0, ulCursorOrdinal, &pInfo[0], m_cbMaxBookmark,
        (CURSOR_DBCOLUMNID*)&CURSOR_COLUMN_BMKCURSOR);
    ulCursorOrdinal++;

    if (m_fBookmarkSkipped)
    {
        m_rgColumns[ulCursorOrdinal].Initialize(0, ulCursorOrdinal, &pInfo[0], m_cbMaxBookmark,
            (CURSOR_DBCOLUMNID*)&CURSOR_COLUMN_BMKTEMPORARYREL);
        ulCursorOrdinal++;

        m_rgColumns[ulCursorOrdinal].Initialize(0, ulCursorOrdinal, &pInfo[0], m_cbMaxBookmark,
            (CURSOR_DBCOLUMNID*)&CURSOR_COLUMN_BMKCURSORREL);
        ulCursorOrdinal++;
    }

    // free resources
    if (pInfo)
        g_pMalloc->Free(pInfo);

    if (pStringsBuffer)
        g_pMalloc->Free(pStringsBuffer);

    pColumnsInfo->Release();

    InitOptionalMetadata(cColumns);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// InitOptionalMetadata - gets additional metadata from IColumnsRowset (if available)
//
void CVDCursorMain::InitOptionalMetadata(ULONG cColumns)
{
	// we should return if there is only a bookmark column
	if (cColumns < 2)
		return;

	IColumnsRowset * pColumnsRowset = NULL;

    // try to get IColumnsRowset interface
    HRESULT hr = m_pRowset->QueryInterface(IID_IColumnsRowset, (void**)&pColumnsRowset);

    if (FAILED(hr))
        return;

	IRowset * pRowset	= NULL;
	IColumnsInfo * pColumnsInfo = NULL;
	IAccessor * pAccessor = NULL;

	ULONG	cOptColumnsAvailable = 0;
	DBID *	rgOptColumnsAvailable = NULL;
	DBID *	pOptColumnsAvailable = NULL;  // work ptr

	ULONG	cOptColumns = 0;
	DBID *	rgOptColumns = NULL;
	DBID *	pOptColumns = NULL;	 //work ptr

	ULONG	ulBuffLen = 0;
	BYTE *	pBuff = NULL;
	HACCESSOR hAccessor;
	BOOL	fAccessorCreated = FALSE;

	HROW *	rgRows = NULL;
	ULONG	cRowsObtained = 0;

	// we are only interested in a few of the optional columns
	ULONG		rgColumnPropids[VD_COLUMNSROWSET_MAX_OPT_COLUMNS];
	ULONG		rgOrdinals[VD_COLUMNSROWSET_MAX_OPT_COLUMNS];
	DBBINDING	rgBindings[VD_COLUMNSROWSET_MAX_OPT_COLUMNS];
	DBBINDING * pBinding = NULL; // work ptr
	BOOL		fMatched;
	GUID		guidCID	= DBCIDGUID;

	ULONG	cColumnsMatched = 0;
	ULONG	i, j;

    // get array of available columns
	hr = pColumnsRowset->GetAvailableColumns(&cOptColumnsAvailable, &rgOptColumnsAvailable);

    if (FAILED(hr) || 0 == cOptColumnsAvailable)
		goto cleanup;

	ASSERT_(rgOptColumnsAvailable);

	// allocate enough DBIDs for the lesser of the total available columns or the total number of
	// columns we're interested in
	rgOptColumns = (DBID *)g_pMalloc->Alloc(min(cOptColumnsAvailable, VD_COLUMNSROWSET_MAX_OPT_COLUMNS)
											* sizeof(DBID));

	if (!rgOptColumns)
		goto cleanup;

	// initalize work pointers
	pOptColumnsAvailable	= rgOptColumnsAvailable;
	pOptColumns				= rgOptColumns;			
	pBinding				= rgBindings;

	memset(pBinding, 0, sizeof(DBBINDING) * VD_COLUMNSROWSET_MAX_OPT_COLUMNS);

	// search available columns for the ones we are interested in copying them into rgOptColumns
	for (i = 0; i < cOptColumnsAvailable && cColumnsMatched < VD_COLUMNSROWSET_MAX_OPT_COLUMNS; i++)
	{
		fMatched = FALSE; // initialize to false
		if (DBKIND_GUID_PROPID == pOptColumnsAvailable->eKind	&&
			DO_GUIDS_MATCH(pOptColumnsAvailable->uGuid.guid, guidCID))
		{
			switch (pOptColumnsAvailable->uName.ulPropid)
			{
				case 12: //DBCOLUMN_COLLATINGSEQUENCE     = {DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)12};
					pBinding->obValue     = ulBuffLen;
					ulBuffLen			 +=	sizeof(ULONG);
					pBinding->obStatus    = ulBuffLen;
					ulBuffLen			 +=	sizeof(DBSTATUS);
					pBinding->dwPart      = DBPART_VALUE | DBPART_STATUS;
					pBinding->dwMemOwner  = DBMEMOWNER_CLIENTOWNED;
					pBinding->wType       = DBTYPE_I4;
					fMatched			  = TRUE;
					break;

				//string properties
				case 10: //DBCOLUMN_BASECOLUMNNAME        = {DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)10};
				case 11: //DBCOLUMN_BASETABLENAME         = {DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)11};
				case 14: //DBCOLUMN_DEFAULTVALUE          = {DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)14};
					pBinding->obValue     = ulBuffLen;
					ulBuffLen			 +=	512;
					pBinding->obLength    = ulBuffLen;
					ulBuffLen			 +=	sizeof(ULONG);
					pBinding->obStatus    = ulBuffLen;
					ulBuffLen			 +=	sizeof(DBSTATUS);
					pBinding->dwPart      = DBPART_VALUE | DBPART_LENGTH |DBPART_STATUS;
					pBinding->dwMemOwner  = DBMEMOWNER_CLIENTOWNED;
					pBinding->cbMaxLen    = 512;
					pBinding->wType       = DBTYPE_WSTR;
					fMatched			  = TRUE;
					break;

					// bool properties
				case 16: //DBCOLUMN_HASDEFAULT            = {DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)16};
				case 17: //DBCOLUMN_ISAUTOINCREMENT       = {DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)17};
				case 18: //DBCOLUMN_ISCASESENSITIVE       = {DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)18};
				case 21: //DBCOLUMN_ISUNIQUE              = {DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)21};
					pBinding->obValue     = ulBuffLen;
					ulBuffLen			 +=	sizeof(VARIANT_BOOL);
					pBinding->obStatus    = ulBuffLen;
					ulBuffLen			 +=	sizeof(DBSTATUS);
					pBinding->dwPart      = DBPART_VALUE | DBPART_STATUS;
					pBinding->dwMemOwner  = DBMEMOWNER_CLIENTOWNED;
					pBinding->wType       = DBTYPE_BOOL;
					fMatched			  = TRUE;
					break;
			}
		}

		if (fMatched)
		{
			rgColumnPropids[cColumnsMatched]	= pOptColumnsAvailable->uName.ulPropid;
			*pOptColumns						= *pOptColumnsAvailable;
			pBinding++;
			pOptColumns++;
			cColumnsMatched++;
		}
		pOptColumnsAvailable++;
	}

	if (!cColumnsMatched)
		goto cleanup;

    // get column's rowset
	hr = pColumnsRowset->GetColumnsRowset(NULL,
											cColumnsMatched,
											rgOptColumns,
											IID_IRowset,
											0,
											NULL,
											(IUnknown**)&pRowset);

    if FAILED(hr)
	{
		ASSERT_(FALSE);
		goto cleanup;
	}

    // get IColumnsInfo interface on column's rowset
    hr = pRowset->QueryInterface(IID_IColumnsInfo, (void**)&pColumnsInfo);

    if (FAILED(hr))
	{
		ASSERT_(FALSE);
		goto cleanup;
	}

	// get ordinals for our optional columns
	hr = pColumnsInfo->MapColumnIDs(cColumnsMatched, rgOptColumns, rgOrdinals);

    if (S_OK != hr)
	{
		ASSERT_(FALSE);
		goto cleanup;
	}

	// update binding structures with ordinals
	for (i = 0; i < cColumnsMatched; i++)
		rgBindings[i].iOrdinal    = rgOrdinals[i];

    // get IAccessor interface on column's rowset
    hr = pRowset->QueryInterface(IID_IAccessor, (void**)&pAccessor);

    if (FAILED(hr))
	{
		ASSERT_(FALSE);
		goto cleanup;
	}

    // create accessor based on rgBindings array
	hr = pAccessor->CreateAccessor(DBACCESSOR_ROWDATA,
									cColumnsMatched,
									rgBindings,
									ulBuffLen,
									&hAccessor,
									NULL);

    if (S_OK != hr)
	{
		ASSERT_(FALSE);
		goto cleanup;
	}

	// set flag that accessor was successfully created (used during cleanup)
	fAccessorCreated = TRUE;

	// allocate a buffer to hold the metadata
	pBuff = (BYTE *)g_pMalloc->Alloc(ulBuffLen);

	if (!pBuff)
	{
		ASSERT_(FALSE);
		goto cleanup;
	}
									
	// get all rows (each row represents a column in the original rowset)
	// except the first row which represents the bookmark column
	hr = pRowset->GetNextRows(0, // reserved
							  1, // skip the bookmark row
							  cColumns - 1,	// get 1 less than cColumns to account for bookmark row
							  &cRowsObtained, // return count of rows obtanied
							  &rgRows);

    if (FAILED(hr) || !cRowsObtained)
	{
		ASSERT_(FALSE);
		goto cleanup;
	}

	BYTE *		pValue;

	// loop through all rows obtained
	for (i = 0; i < cRowsObtained; i++)
	{
		// call GetData to get the metadata for this row (which represents a column in the orig rowset)
		hr = pRowset->GetData(rgRows[i], hAccessor, pBuff);
		if SUCCEEDED(hr)
		{
			// now update the CVDRowsetColumn object (that this row represents)
			// with the values returned from GetData
			for (j = 0; j < cColumnsMatched; j++)
			{
				if (DBBINDSTATUS_OK != *(DBSTATUS*)(pBuff + rgBindings[j].obStatus))
					continue;

				// set pValue to point into buffer at correct offset
				pValue = pBuff + rgBindings[j].obValue;

				switch (rgColumnPropids[j])
				{
					case 12: //DBCOLUMN_COLLATINGSEQUENCE     = {DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)12};
						m_rgColumns[i].SetCollatingOrder(*(LCID*)pValue);
						break;

					//string properties
					case 10: //DBCOLUMN_BASECOLUMNNAME        = {DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)10};
						m_rgColumns[i].SetBaseColumnName((WCHAR*)pValue, *(ULONG*)(pBuff + rgBindings[j].obLength));
						break;
					case 11: //DBCOLUMN_BASETABLENAME         = {DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)11};
						m_rgColumns[i].SetBaseName((WCHAR*)pValue, *(ULONG*)(pBuff + rgBindings[j].obLength));
						break;
					case 14: //DBCOLUMN_DEFAULTVALUE          = {DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)14};
						m_rgColumns[i].SetDefaultValue((WCHAR*)pValue, *(ULONG*)(pBuff + rgBindings[j].obLength));
						break;

						// bool properties
					case 16: //DBCOLUMN_HASDEFAULT            = {DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)16};
						m_rgColumns[i].SetHasDefault(*(VARIANT_BOOL*)pValue);
						break;
					case 17: //DBCOLUMN_ISAUTOINCREMENT       = {DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)17};
						m_rgColumns[i].SetAutoIncrement(*(VARIANT_BOOL*)pValue);
						break;
					case 18: //DBCOLUMN_ISCASESENSITIVE       = {DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)18};
						m_rgColumns[i].SetCaseSensitive(*(VARIANT_BOOL*)pValue);
						break;
					case 21: //DBCOLUMN_ISUNIQUE              = {DBCIDGUID, DBKIND_GUID_PROPID, (LPWSTR)21};
						m_rgColumns[i].SetUnique(*(VARIANT_BOOL*)pValue);
						break;
					default:
						ASSERT_(FALSE);
						break;
				}
			}
		}
		else
			ASSERT_(FALSE);
	}

	m_fColumnsRowsetSupported = TRUE;

cleanup:


	if (pBuff)
		g_pMalloc->Free(pBuff);

	if (pAccessor)
	{
		if (fAccessorCreated)
			pAccessor->ReleaseAccessor(hAccessor, NULL);
		pAccessor->Release();
	}

	if (pRowset)
	{
		if (cRowsObtained)
		{
			pRowset->ReleaseRows(cRowsObtained, rgRows, NULL, NULL, NULL);
			ASSERT_(rgRows);
			g_pMalloc->Free(rgRows);
		}
		pRowset->Release();
	}

	if (pColumnsInfo)
		pColumnsInfo->Release();

    if (rgOptColumnsAvailable)
		g_pMalloc->Free(rgOptColumnsAvailable);

    if (rgOptColumns)
		g_pMalloc->Free(rgOptColumns);
	
	if (pColumnsRowset)	
		pColumnsRowset->Release();

}

//=--------------------------------------------------------------------------=
// DestroyColumns - Destroy array of column objects
//
void CVDCursorMain::DestroyColumns()
{
    delete [] m_rgColumns;

    m_ulColumns = 0;
    m_rgColumns = NULL;
}

//=--------------------------------------------------------------------------=
// ConnectIRowsetNotify - Connect IRowsetNotify interface
//
HRESULT CVDCursorMain::ConnectIRowsetNotify()
{
    IConnectionPointContainer * pConnectionPointContainer;

    HRESULT hr = GetRowset()->QueryInterface(IID_IConnectionPointContainer, (void**)&pConnectionPointContainer);

    if (FAILED(hr))
        return VD_E_CANNOTCONNECTIROWSETNOTIFY;

    IConnectionPoint * pConnectionPoint;

    hr = pConnectionPointContainer->FindConnectionPoint(IID_IRowsetNotify, &pConnectionPoint);

    if (FAILED(hr))
    {
        pConnectionPointContainer->Release();
        return VD_E_CANNOTCONNECTIROWSETNOTIFY;
    }

    hr = pConnectionPoint->Advise(&m_RowsetNotify, &m_dwAdviseCookie);

    pConnectionPointContainer->Release();
    pConnectionPoint->Release();

    return hr;
}

//=--------------------------------------------------------------------------=
// DisconnectIRowsetNotify - Disconnect IRowsetNotify interface
//
void CVDCursorMain::DisconnectIRowsetNotify()
{
    IConnectionPointContainer * pConnectionPointContainer;

    HRESULT hr = GetRowset()->QueryInterface(IID_IConnectionPointContainer, (void**)&pConnectionPointContainer);

    if (FAILED(hr))
        return;

    IConnectionPoint * pConnectionPoint;

    hr = pConnectionPointContainer->FindConnectionPoint(IID_IRowsetNotify, &pConnectionPoint);

    if (FAILED(hr))
    {
        pConnectionPointContainer->Release();
        return;
    }

    hr = pConnectionPoint->Unadvise(m_dwAdviseCookie);

    if (SUCCEEDED(hr))
        m_dwAdviseCookie = 0;   // clear connection point identifier

    pConnectionPointContainer->Release();
    pConnectionPoint->Release();
}

//=--------------------------------------------------------------------------=
// IUnknown QueryInterface
//
HRESULT CVDCursorMain::QueryInterface(REFIID riid, void **ppvObjOut)
{
    ASSERT_POINTER(ppvObjOut, IUnknown*)

    if (!ppvObjOut)
        return E_INVALIDARG;

	*ppvObjOut = NULL;

	if (DO_GUIDS_MATCH(riid, IID_IUnknown))
		{
		*ppvObjOut = this;
		AddRef();
		return S_OK;
		}

	return E_NOINTERFACE;
}

//=--------------------------------------------------------------------------=
// IUnknown AddRef (needed to resolve ambiguity)
//
ULONG CVDCursorMain::AddRef(void)
{
    return CVDNotifier::AddRef();
}

//=--------------------------------------------------------------------------=
// IUnknown Release (needed to resolve ambiguity)
//
ULONG CVDCursorMain::Release(void)
{

	if (1 == m_dwRefCount)
		Passivate();  // unhook everything including notification sink

	if (1 > --m_dwRefCount)
	{
		if (0 == m_RowsetNotify.GetRefCount())
			delete this;
		return 0;
	}

	return m_dwRefCount;
}

//=--------------------------------------------------------------------------=
// IsSameRowAsNew - Determine if specified hRow is an addrow
//
BOOL CVDCursorMain::IsSameRowAsNew(HROW hrow)
{
	for (int k = 0; k < m_Children.GetSize(); k++)
    {
		if (((CVDCursorPosition*)(CVDNotifier*)m_Children[k])->IsSameRowAsNew(hrow) == S_OK)
			return TRUE;
	}

	return FALSE;
}

//=--------------------------------------------------------------------------=
// AddedRows - Get the number of add-rows in cursor
//
ULONG CVDCursorMain::AddedRows()
{
	ULONG cAdded = 0;

	for (int k = 0; k < m_Children.GetSize(); k++)
    {
		if (((CVDCursorPosition*)(CVDNotifier*)m_Children[k])->GetEditMode() == CURSOR_DBEDITMODE_ADD)
			cAdded++;
	}

	return cAdded;
}

//=--------------------------------------------------------------------------=
// IRowsetNotify Methods
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// IRowsetNotify OnFieldChange
//=--------------------------------------------------------------------------=
// Forward to all CVDCursorPosition objects in our family
//
HRESULT CVDCursorMain::OnFieldChange(IRowset *pRowset,
									   HROW hRow,
									   ULONG cColumns,
									   ULONG rgColumns[],
									   DBREASON eReason,
									   DBEVENTPHASE ePhase,
									   BOOL fCantDeny)
{
	HRESULT hr = S_OK;

    // return if notification caused by internal rowset call
    if (m_fInternalSetData && eReason == DBREASON_COLUMN_SET)
        return hr;

	for (int k = 0; k < m_Children.GetSize(); k++)
    {
		hr = ((CVDCursorPosition*)(CVDNotifier*)m_Children[k])->OnFieldChange(pRowset,
															   hRow,
															   cColumns,
															   rgColumns,
															   eReason,
															   ePhase,
															   fCantDeny);
		if (hr)
			break;
	}

	return hr;

}

//=--------------------------------------------------------------------------=
// IRowsetNotify OnRowChange
//=--------------------------------------------------------------------------=
// Forward to all CVDCursorPosition objects in our family
//
HRESULT CVDCursorMain::OnRowChange(IRowset *pRowset,
									 ULONG cRows,
									 const HROW rghRows[],
									 DBREASON eReason,
									 DBEVENTPHASE ePhase,
									 BOOL fCantDeny)
{
	HRESULT hr = S_OK;

    // return if notification caused by internal rowset call (either insert or delete)
    if (m_fInternalInsertRow && eReason == DBREASON_ROW_INSERT || m_fInternalDeleteRows && eReason == DBREASON_ROW_DELETE)
        return hr;

	for (int k = 0; k < m_Children.GetSize(); k++)
    {
		hr = ((CVDCursorPosition*)(CVDNotifier*)m_Children[k])->OnRowChange(pRowset,
															   cRows,
															   rghRows,
															   eReason,
															   ePhase,
															   fCantDeny);
		if (hr)
			break;
    }

	return hr;
}

//=--------------------------------------------------------------------------=
// IRowsetNotify OnRowsetChange
//=--------------------------------------------------------------------------=
// Forward to all CVDCursorPosition objects in our family
//
HRESULT CVDCursorMain::OnRowsetChange(IRowset *pRowset,
										DBREASON eReason,
										DBEVENTPHASE ePhase,
										BOOL fCantDeny)
{
	HRESULT hr = S_OK;

	for (int k = 0; k < m_Children.GetSize(); k++)
    {
		hr = ((CVDCursorPosition*)(CVDNotifier*)m_Children[k])->OnRowsetChange(pRowset,
															   eReason,
															   ePhase,
															   fCantDeny);
		if (hr)
			break;
	}

	return hr;
}

//=--------------------------------------------------------------------------=
// CVDCursorMain::CVDRowsetNotify::m_pMainUnknown
//=--------------------------------------------------------------------------=
// this method is used when we're sitting in the private unknown object,
// and we need to get at the pointer for the main unknown.  basically, it's
// a little better to do this pointer arithmetic than have to store a pointer
// to the parent, etc.
//
inline CVDCursorMain *CVDCursorMain::CVDRowsetNotify::m_pMainUnknown
(
    void
)
{
    return (CVDCursorMain *)((LPBYTE)this - offsetof(CVDCursorMain, m_RowsetNotify));
}

//=--------------------------------------------------------------------------=
// CVDCursorMain::CVDRowsetNotify::QueryInterface
//=--------------------------------------------------------------------------=
// this is the non-delegating internal QI routine.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
STDMETHODIMP CVDCursorMain::CVDRowsetNotify::QueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
	if (!ppvObjOut)
		return E_INVALIDARG;

	*ppvObjOut = NULL;

    if (DO_GUIDS_MATCH(riid, IID_IUnknown))
        *ppvObjOut = (IUnknown *)this;
	else
    if (DO_GUIDS_MATCH(riid, IID_IRowsetNotify))
        *ppvObjOut = (IUnknown *)this;

	if (*ppvObjOut)
	{
		m_cRef++;
        return S_OK;
	}

	return E_NOINTERFACE;

}

//=--------------------------------------------------------------------------=
// CVDCursorMain::CVDRowsetNotify::AddRef
//=--------------------------------------------------------------------------=
// adds a tick to the current reference count.
//
// Output:
//    ULONG        - the new reference count
//
// Notes:
//
ULONG CVDCursorMain::CVDRowsetNotify::AddRef
(
    void
)
{
    return ++m_cRef;
}

//=--------------------------------------------------------------------------=
// CVDCursorMain::CVDRowsetNotify::Release
//=--------------------------------------------------------------------------=
// removes a tick from the count, and delets the object if necessary
//
// Output:
//    ULONG         - remaining refs
//
// Notes:
//
ULONG CVDCursorMain::CVDRowsetNotify::Release
(
    void
)
{
    ULONG cRef = --m_cRef;

    if (!m_cRef && !m_pMainUnknown()->m_dwRefCount)
        delete m_pMainUnknown();

    return cRef;
}

//=--------------------------------------------------------------------------=
// IRowsetNotify Methods
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// IRowsetNotify OnFieldChange
//=--------------------------------------------------------------------------=
// Forward to all CVDCursorPosition objects in our family
//
HRESULT CVDCursorMain::CVDRowsetNotify::OnFieldChange(IRowset *pRowset,
													   HROW hRow,
													   ULONG cColumns,
													   ULONG rgColumns[],
													   DBREASON eReason,
													   DBEVENTPHASE ePhase,
													   BOOL fCantDeny)
{
	
	return m_pMainUnknown()->OnFieldChange(pRowset,
											hRow,
											cColumns,
											rgColumns,
											eReason,
											ePhase,
											fCantDeny);
}

//=--------------------------------------------------------------------------=
// IRowsetNotify OnRowChange
//=--------------------------------------------------------------------------=
// Forward to all CVDCursorPosition objects in our family
//
HRESULT CVDCursorMain::CVDRowsetNotify::OnRowChange(IRowset *pRowset,
													 ULONG cRows,
													 const HROW rghRows[],
													 DBREASON eReason,
													 DBEVENTPHASE ePhase,
													 BOOL fCantDeny)
{
	return m_pMainUnknown()->OnRowChange(pRowset,
											cRows,
											rghRows,
											eReason,
											ePhase,
											fCantDeny);
}

//=--------------------------------------------------------------------------=
// IRowsetNotify OnRowsetChange
//=--------------------------------------------------------------------------=
// Forward to all CVDCursorPosition objects in our family
//
HRESULT CVDCursorMain::CVDRowsetNotify::OnRowsetChange(IRowset *pRowset,
														DBREASON eReason,
														DBEVENTPHASE ePhase,
														BOOL fCantDeny)
{
	return m_pMainUnknown()->OnRowsetChange(pRowset,
											eReason,
											ePhase,
											fCantDeny);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\colupdat.h ===
//---------------------------------------------------------------------------
// ColumnUpdate.h : CVDColumnUpdate header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------


#ifndef __CVDCOLUMNUPDATE__
#define __CVDCOLUMNUPDATE__


class CVDColumnUpdate
{
protected:
// Construction/Destruction
	CVDColumnUpdate();
	virtual ~CVDColumnUpdate();

// Helper function
    static HRESULT ExtractVariant(CURSOR_DBBINDPARAMS * pBindParams, CURSOR_DBVARIANT * pVariant);

public:
    static HRESULT Create(CVDRowsetColumn * pColumn, CURSOR_DBBINDPARAMS * pBindParams,
        CVDColumnUpdate ** ppColumnUpdate, CVDResourceDLL * pResourceDLL);

// Reference count
    ULONG AddRef();
    ULONG Release();

// Access functions
    CVDRowsetColumn * GetColumn() const {return m_pColumn;}
    CURSOR_DBVARIANT GetVariant() const {return m_variant;}
    VARTYPE GetVariantType() const {return m_variant.vt;}
    ULONG GetVarDataLen() const {return m_cbVarDataLen;}
    DWORD GetInfo() const {return m_dwInfo;}

protected:
// Data members
    DWORD               m_dwRefCount;   // reference count
    CVDRowsetColumn *   m_pColumn;      // rowset column pointer
    CURSOR_DBVARIANT    m_variant;      // update variant
    ULONG               m_cbVarDataLen; // variable data length
    DWORD               m_dwInfo;       // information field
    CVDResourceDLL *    m_pResourceDLL; // pointer which keeps track of resource DLL
};


#endif //__CVDCOLUMNUPDATE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\common.inc ===
SOURCES_USED=$(ROOT)\common.inc

!if $(ALPHA)
MSC_WARNING_LEVEL = /W3 /WX
!endif

!ifndef MSC_WARNING_LEVEL
MSC_WARNING_LEVEL = /W3 /WX
!endif

C_DEFINES = \
    /D_WCTYPE_INLINE_DEFINED \
!if $(FREEBUILD)
    /D_ATL_MIN_CRT \
!else
    /D_DEBUG \
!endif
    /DSTRICT

!if !$(FREEBUILD)
USE_RTTI=1
MSC_OPTIMIZATION=/Od
#USER_CPP_FLAGS=/zmf
WATCOM_OPTS=/ei /zt16 /zm /zff /zgf
LINKER_NOICF=1      # ICF is s-l-o-w
!else
MSC_OPTIMIZATION=/Oxs
#USER_CPP_FLAGS=/zmf
WATCOM_OPTS=/ei /zt16 /ox /oe /zm /zff /zgf
!endif

MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /Ob1 /Oi

NOT_LEAN_AND_MEAN=1

USE_NOLIBS=1
UMTYPE=windows

# Use NT 4.0/Win95 functionality only

WIN32_IE_VERSION=0x0400
WIN32_WINNT_VERSION=0x0400
WIN32_WIN95_VERSION=0x0400
SUBSYSTEM_VERSION=4.00

!ifdef WIN16

# Win 16 Specific Environment.
!ifndef __MSVC_ENV__
__WATCOM_ENV__=1
!endif
C_DEFINES = $(C_DEFINES) /DINC_WIN16X /DWRAP_RECTL /DFULL_DEBUG

FULL_DEBUG=1

!else

!if !$(FREEBUILD)
DEBUG_CRTS=1
!endif

# Win 32 Environment.
C_DEFINES = $(C_DEFINES) /D_MT

!endif

!if $(386)
NO_NTDLL=1
!else
# USE_NTDLL=1
!endif

CHECKED_ALT_DIR=1

#
# The IE build lab sets this flag for debug builds so we get full debug
#   on IE drops. The NT build lab wants debug lite builds and therefore
#   does not set it.
#
!ifdef MSHTML_FULL_DEBUG
!message MSHTML_FULL_DEBUG was defined. Building full debug.
FULL_DEBUG=1
!endif

!ifdef USE_ICECAP
C_DEFINES = $(C_DEFINES) /DPRODUCT_PROF
!endif

!ifdef USE_PERFTEST
C_DEFINES = $(C_DEFINES) /DPRODUCT_PERFTEST
!endif

!ifdef USE_PERFBUG
C_DEFINES = $(C_DEFINES) /DPRODUCT_PERFBUG
!endif

!ifdef USE_PERFTAGS
!if $(FREEBUILD)
C_DEFINES = $(C_DEFINES) /DPERFTAGS
!message PERFTAGS was defined
!endif
!endif

!ifdef USE_MSHTML_INCREMENTAL_LINKING
!if !$(FREEBUILD) && $(USE_MSHTML_INCREMENTAL_LINKING)
NTDEBUG=ntsd
NTDEBUGTYPE=windbg
NTDBGFILES=1
!undef USE_MAPSYM
USE_INCREMENTAL_LINKING=1
LINKER_FLAGS=$(LINKER_FLAGS) -INCREMENTAL:YES
USE_PDB_TO_COMPILE=1
TARGETPDB=TDC
!message USE_MSHTML_INCREMENTAL_LINKING was defined
!message $(TARGETPDB) was defined
!endif
!else
# Compatibility with existing usage before use_mshtml_incremental_linking
!ifdef USE_INCREMENTAL_LINKING
!message DOING IT THE OLD WAY
LINKER_FLAGS = -INCREMENTAL:YES
USE_PDB_TO_COMPILE=1
!else
USE_MAPSYM=1
!endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\cursmain.h ===
//---------------------------------------------------------------------------
// CursorMain.h : CVDCursorMain header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------


#ifndef __CVDCURSORMAIN__
#define __CVDCURSORMAIN__

class CVDBookmark;
class CVDCursorPosition;

class CVDCursorMain : public CVDRowsetSource

{
protected:
// Construction/Destruction
    CVDCursorMain(LCID lcid);
	virtual ~CVDCursorMain();

protected:
    static HRESULT Create(IRowPosition * pRowPosition, IRowset * pRowset, ICursor ** ppCursor, LCID lcid);
public:
    static HRESULT Create(IRowset * pRowset, ICursor ** ppCursor, LCID lcid);
    static HRESULT Create(IRowPosition * pRowPosition, ICursor ** ppCursor, LCID lcid);

protected:
// Rowset columns
    HRESULT CreateMetaColumns();
	void InitOptionalMetadata(ULONG cColumns);
    void DestroyMetaColumns();

    HRESULT CreateColumns();
    void DestroyColumns();

public:
// Access functions
    ULONG GetMetaColumnsCount() const {return s_ulMetaColumns;}
    CVDRowsetColumn * InternalGetMetaColumns() const {return s_rgMetaColumns;}

    ULONG GetColumnsCount() const {return m_ulColumns;}
    CVDRowsetColumn * InternalGetColumns() const {return m_rgColumns;}

	HACCESSOR GetBookmarkAccessor() const {return m_hAccessorBM;}
	ULONG GetMaxBookmarkLen() const {return m_cbMaxBookmark;}

	BOOL IsColumnsRowsetSupported() const {return m_fColumnsRowsetSupported;}

    void SetInternalInsertRow(BOOL fInternalInsertRow) {m_fInternalInsertRow = fInternalInsertRow;}
    void SetInternalDeleteRows(BOOL fInternalDeleteRows) {m_fInternalDeleteRows = fInternalDeleteRows;}
    void SetInternalSetData(BOOL fInternalSetData) {m_fInternalSetData = fInternalSetData;}
	BOOL IsSameRowAsNew(HROW hrow);
	ULONG AddedRows(void);

protected:
// Rowset columns
    static DWORD                s_dwMetaRefCount;   // reference count for meta-columns
    static ULONG                s_ulMetaColumns;    // number of meta-columns for IColumnsInfo
    static CVDRowsetColumn *    s_rgMetaColumns;    // pointer to an array of meta-column objects

    ULONG                       m_ulColumns;        // number of rowset columns
    CVDRowsetColumn *           m_rgColumns;        // pointer to an array of column objects

// IRowsetNotify
	VARIANT_BOOL    m_fConnected;			// have we added ourselves to the Rowset's connection point
    DWORD           m_dwAdviseCookie;		// connection point identifier

	HRESULT ConnectIRowsetNotify();
	void DisconnectIRowsetNotify();

	void Passivate();

// Other
    ULONG                       m_cbMaxBookmark;    // sizeof maximum bookmark
    HACCESSOR					m_hAccessorBM;		// hAccessor for the bookmark column
	CVDResourceDLL		        m_resourceDLL;		// keeps track of resource DLL

// booleans
	WORD m_fWeAddedMetaRef	        : 1;			// we added a reference count to meta-columns
    WORD m_fPassivated			    : 1;			// external ref count went to zero
    WORD m_fColumnsRowsetSupported  : 1;			// does rowset expose IColumnsRowset
    WORD m_fInternalInsertRow       : 1;            // row insert caused by internal call
    WORD m_fInternalDeleteRows      : 1;            // row delete caused by internal call
    WORD m_fInternalSetData         : 1;            // set column caused by internal call

// rowset properties
	WORD m_fLiteralBookmarks	: 1;			
	WORD m_fOrderedBookmarks	: 1;
    WORD m_fBookmarkSkipped     : 1;			

public:
    //=--------------------------------------------------------------------------=
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);
	//=--------------------------------------------------------------------------=
	// IRowsetNotify methods passed up from CVDRowsetNotify implementation
	//
	STDMETHOD(OnFieldChange)(IRowset *pRowset, HROW hRow, ULONG cColumns, ULONG rgColumns[], DBREASON eReason,
		DBEVENTPHASE ePhase, BOOL fCantDeny);
	STDMETHOD(OnRowChange)(IRowset *pRowset, ULONG cRows, const HROW rghRows[], DBREASON eReason, DBEVENTPHASE ePhase,
			BOOL fCantDeny);
	STDMETHOD(OnRowsetChange)(IRowset *pRowset, DBREASON eReason, DBEVENTPHASE ePhase, BOOL fCantDeny);

  private:
    // the inner, private unknown implementation to give to connection point
    // container to avoid circular ref count
    //
    class CVDRowsetNotify : public IRowsetNotify {
      public:
        STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);

        // constructor is remarkably trivial
        //
        CVDRowsetNotify() : m_cRef(0) {}

		ULONG GetRefCount() const {return m_cRef;}

      private:
        CVDCursorMain *m_pMainUnknown();
        ULONG m_cRef;
		//=--------------------------------------------------------------------------=
		// IRowsetNotify methods
		//
		STDMETHOD(OnFieldChange)(IRowset *pRowset, HROW hRow, ULONG cColumns, ULONG rgColumns[], DBREASON eReason,
			DBEVENTPHASE ePhase, BOOL fCantDeny);
		STDMETHOD(OnRowChange)(IRowset *pRowset, ULONG cRows, const HROW rghRows[], DBREASON eReason, DBEVENTPHASE ePhase,
				BOOL fCantDeny);
		STDMETHOD(OnRowsetChange)(IRowset *pRowset, DBREASON eReason, DBEVENTPHASE ePhase, BOOL fCantDeny);

    } m_RowsetNotify;

    friend class CVDRowsetNotify;

};


#endif //__CVDCURSORMAIN__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\cursbase.h ===
//---------------------------------------------------------------------------
// CursorBase.h : CVDCursorBase header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------


#ifndef __CVDCURSORBASE__
#define __CVDCURSORBASE__


class CVDCursorBase : public ICursorScroll,
       				  public ISupportErrorInfo
{
protected:
// Construction/Destruction
	CVDCursorBase();
	virtual ~CVDCursorBase();

    void DestroyCursorBindings(CURSOR_DBCOLUMNBINDING** ppCursorBindings,
											ULONG* pcBindings);


protected:
// Data members
    ULONG                       m_ulCursorBindings;     // number of cursor column bindings
    CURSOR_DBCOLUMNBINDING *    m_pCursorBindings;      // pointer to an array of cursor column bindings
    VARIANT_BOOL                m_fNeedVarData;         // do the cursor column bindings required variable length buffer?
    ULONG                       m_cbRowLength;          // fixed length buffer single row length
    ULONG                       m_cbVarRowLength;       // variable length buffer single row length

    CVDResourceDLL *            m_pResourceDLL;         // pointer which keeps track of resource DLL

public:
// Helper functions
    static BOOL IsValidCursorType(DWORD dwCursorType);
    static BOOL DoesCursorTypeNeedVarData(DWORD dwCursorType);
    static ULONG GetCursorTypeLength(DWORD dwCursorType, ULONG cbMaxLen);
    static BOOL IsEqualCursorColumnID(const CURSOR_DBCOLUMNID& cursorColumnID1, const CURSOR_DBCOLUMNID& cursorColumnID2);
    static ULONG GetCursorColumnIDNameLength(const CURSOR_DBCOLUMNID& cursorColumnID);

    HRESULT ValidateCursorBindings(ULONG ulColumns, CVDRowsetColumn * pColumns, 
        ULONG ulBindings, CURSOR_DBCOLUMNBINDING * pCursorBindings, ULONG cbRequestedRowLength, DWORD dwFlags,
        ULONG * pcbNewRowLength, ULONG * pcbNewVarRowLength);

	HRESULT ValidateFetchParams(CURSOR_DBFETCHROWS *pFetchParams, REFIID riid);

    BOOL DoCursorBindingsNeedVarData();

// Other
    virtual BOOL SupportsScroll() {return TRUE;}

	//=--------------------------------------------------------------------------=
    // IUnknown methods implemented
    //
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    //=--------------------------------------------------------------------------=
    // ICursor methods implemented
    //
    STDMETHOD(SetBindings)(ULONG cCol, CURSOR_DBCOLUMNBINDING rgBoundColumns[], ULONG cbRowLength, DWORD dwFlags);
    STDMETHOD(GetBindings)(ULONG *pcCol, CURSOR_DBCOLUMNBINDING *prgBoundColumns[], ULONG *pcbRowLength);

    //=--------------------------------------------------------------------------=
    // ISupportErrorInfo methods    
	//
	STDMETHOD(InterfaceSupportsErrorInfo)(THIS_ REFIID riid);
};


#endif //__CVDCURSORBASE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\cursmeta.cpp ===
//---------------------------------------------------------------------------
// MetadataCursor.cpp : MetadataCursor implementation
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "Notifier.h"
#include "RSColumn.h"
#include "RSSource.h"
#include "CursMain.h"
#include "CursBase.h"
#include "CursMeta.h"
#include "fastguid.h"
#include "resource.h"

SZTHISFILE


//=--------------------------------------------------------------------------=
// CVDMetadataCursor - Constructor
//
CVDMetadataCursor::CVDMetadataCursor()
{
    m_dwRefCount    = 1;
    m_lCurrentRow   = -1;   // before first

    m_ulColumns     = 0;
    m_pColumns      = NULL;

    m_ulMetaColumns = 0;
    m_pMetaColumns  = NULL;

#ifdef _DEBUG
    g_cVDMetadataCursorCreated++;
#endif
}

//=--------------------------------------------------------------------------=
// ~CVDMetadataCursor - Destructor
//
CVDMetadataCursor::~CVDMetadataCursor()
{
#ifdef _DEBUG
    g_cVDMetadataCursorDestroyed++;
#endif
}

//=--------------------------------------------------------------------------=
// RowToBookmark - Convert row to bookmark
//=--------------------------------------------------------------------------=
//
// Parameters:
//    lRow          - [in]  a row number
//    pcbBookmark   - [out] a pointer to memory in which to return the length
//                          in bytes of the corresponding bookmark
//    pBookmark     - [out] a pointer to memory in which to return the bookmark
//
// Notes:
//
void CVDMetadataCursor::RowToBookmark(LONG lRow, ULONG * pcbBookmark, void * pBookmark) const
{

    if (lRow < 0)
    {
        *pcbBookmark = CURSOR_DB_BMK_SIZE;
    	memcpy(pBookmark, &CURSOR_DBBMK_BEGINNING, CURSOR_DB_BMK_SIZE);
    }
    else if (lRow >= (LONG)m_ulColumns)
    {
        *pcbBookmark = CURSOR_DB_BMK_SIZE;
    	memcpy(pBookmark, &CURSOR_DBBMK_END, CURSOR_DB_BMK_SIZE);
    }
    else
    {
        *pcbBookmark = sizeof(LONG);
    	memcpy(pBookmark, &lRow, sizeof(LONG));
    }

}
//=--------------------------------------------------------------------------=
// BookmarkToRow - Convert bookmark to row
//=--------------------------------------------------------------------------=
//
// Parameters:
//    cbBookmark    - [in]  the length in bytes of the bookmark
//    pBookmark     - [in]  a pointer to the bookmark
//    pRow          - [out] a pointer to memory in which to return the
//                          corresponding row
//
// Output:
//    BOOL          - TRUE if successful
//
// Notes:
//
BOOL CVDMetadataCursor::BookmarkToRow(ULONG cbBookmark, void * pBookmark, LONG * plRow) const
{
    BOOL fResult = FALSE;

    if (cbBookmark == CURSOR_DB_BMK_SIZE)
    {
        if (memcmp(pBookmark, &CURSOR_DBBMK_BEGINNING, CURSOR_DB_BMK_SIZE) == 0)
        {
            *plRow = -1;
            fResult = TRUE;
        }
        else if (memcmp(pBookmark, &CURSOR_DBBMK_END, CURSOR_DB_BMK_SIZE) == 0)
        {
            *plRow = (LONG)m_ulColumns;
            fResult = TRUE;
        }
        else if (memcmp(pBookmark, &CURSOR_DBBMK_CURRENT, CURSOR_DB_BMK_SIZE) == 0)
        {
            *plRow = m_lCurrentRow;
            fResult = TRUE;
        }
    }
    else
    if (cbBookmark == sizeof(LONG))
    {
        memcpy(plRow, pBookmark, sizeof(LONG));
        if (*plRow >= 0 && *plRow < (LONG)m_ulColumns)
            fResult = TRUE;
    }

    return fResult;
}

//=--------------------------------------------------------------------------=
// ReturnData_I4 - Coerce I4 data into buffers
//=--------------------------------------------------------------------------=
// This function coerces the specified data into supplied buffers
//
// Parameters:
//    dwData            - [in] the 4-byte data
//    pCursorBinding    - [in] the cursor binding describing the format of the
//                             returned information
//    pData             - [in] a pointer to the fixed area buffer
//    pVarData          - [in] a pointer to the variable length buffer
//
// Output:
//    ULONG - the number of bytes used in variable length buffer
//
// Notes:
//
ULONG CVDMetadataCursor::ReturnData_I4(DWORD dwData, CURSOR_DBCOLUMNBINDING * pCursorBinding,
    BYTE * pData, BYTE * pVarData)
{
    ULONG cbVarData = 0;

    if (pCursorBinding->dwBinding == CURSOR_DBBINDING_DEFAULT)
    {
        if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
            *(DWORD*)(pData + pCursorBinding->obData) = dwData;
    }
    else if (pCursorBinding->dwBinding == CURSOR_DBBINDING_VARIANT)
    {
        if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
        {
            CURSOR_DBVARIANT * pVariant = (CURSOR_DBVARIANT*)(pData + pCursorBinding->obData);

            VariantInit((VARIANT*)pVariant);

            pVariant->vt    = CURSOR_DBTYPE_I4;
            pVariant->lVal  = dwData;
        }
    }

    if (pCursorBinding->obVarDataLen != CURSOR_DB_NOVALUE)
        *(ULONG*)(pData + pCursorBinding->obVarDataLen) = 0;

    if (pCursorBinding->obInfo != CURSOR_DB_NOVALUE)
        *(DWORD*)(pData + pCursorBinding->obInfo) = CURSOR_DB_NOINFO;

    return cbVarData;
}

//=--------------------------------------------------------------------------=
// ReturnData_BOOL - Coerce BOOL data into buffers
//=--------------------------------------------------------------------------=
// This function coerces the specified data into supplied buffers
//
// Parameters:
//    fData             - [in] the boolean data
//    pCursorBinding    - [in] the cursor binding describing the format of the
//                             returned information
//    pData             - [in] a pointer to the fixed area buffer
//    pVarData          - [in] a pointer to the variable length buffer
//
// Output:
//    ULONG - the number of bytes used in variable length buffer
//
// Notes:
//
ULONG CVDMetadataCursor::ReturnData_BOOL(VARIANT_BOOL fData, CURSOR_DBCOLUMNBINDING * pCursorBinding,
    BYTE * pData, BYTE * pVarData)
{
    ULONG cbVarData = 0;

    if (pCursorBinding->dwBinding == CURSOR_DBBINDING_DEFAULT)
    {
        if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
            *(VARIANT_BOOL*)(pData + pCursorBinding->obData) = fData;
    }
    else if (pCursorBinding->dwBinding == CURSOR_DBBINDING_VARIANT)
    {
        if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
        {
            CURSOR_DBVARIANT * pVariant = (CURSOR_DBVARIANT*)(pData + pCursorBinding->obData);

            VariantInit((VARIANT*)pVariant);

            pVariant->vt        = CURSOR_DBTYPE_BOOL;
            pVariant->boolVal   = fData;
        }
    }

    if (pCursorBinding->obVarDataLen != CURSOR_DB_NOVALUE)
        *(ULONG*)(pData + pCursorBinding->obVarDataLen) = 0;

    if (pCursorBinding->obInfo != CURSOR_DB_NOVALUE)
        *(DWORD*)(pData + pCursorBinding->obInfo) = CURSOR_DB_NOINFO;

    return cbVarData;
}

//=--------------------------------------------------------------------------=
// ReturnData_LPWSTR - Coerce LPWSTR data into buffers
//=--------------------------------------------------------------------------=
// This function coerces the specified data into supplied buffers
//
// Parameters:
//    pwszData          - [in] the string data
//    pCursorBinding    - [in] the cursor binding describing the format of the
//                             returned information
//    pData             - [in] a pointer to the fixed area buffer
//    pVarData          - [in] a pointer to the variable length buffer
//
// Output:
//    ULONG - the number of bytes used in variable length buffer
//
// Notes:
//
ULONG CVDMetadataCursor::ReturnData_LPWSTR(WCHAR * pwszData, CURSOR_DBCOLUMNBINDING * pCursorBinding,
    BYTE * pData, BYTE * pVarData)
{
    ULONG cbVarData = 0;

    ULONG cbLength = 0;
    DWORD dwInfo = CURSOR_DB_NOINFO;

    if (pCursorBinding->dwBinding == CURSOR_DBBINDING_DEFAULT)
    {
        if (pCursorBinding->dwDataType == CURSOR_DBTYPE_CHARS)
        {
            if (pwszData)
                cbLength = GET_MBCSLEN_FROMWIDE(pwszData);

            if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
            {
                if (pwszData)
                {
                    MAKE_MBCSPTR_FROMWIDE(pszData, pwszData);

                    memcpy(pData + pCursorBinding->obData, pszData, min(pCursorBinding->cbMaxLen, cbLength));

                    if (pCursorBinding->cbMaxLen < cbLength)
                        dwInfo = CURSOR_DB_TRUNCATED;
                }
                else
				{
                    *(CHAR*)(pData + pCursorBinding->obData) = 0;
					dwInfo = CURSOR_DB_NULL;
				}
            }
        }
        else if (pCursorBinding->dwDataType == CURSOR_DBTYPE_WCHARS)
        {
            if (pwszData)
                cbLength = (lstrlenW(pwszData) + 1) * sizeof(WCHAR);

            if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
            {
                if (pwszData)
                {
                    memcpy(pData + pCursorBinding->obData, pwszData, min(pCursorBinding->cbMaxLen, cbLength));

                    if (pCursorBinding->cbMaxLen < cbLength)
                        dwInfo = CURSOR_DB_TRUNCATED;
                }
                else
				{
                    *(WCHAR*)(pData + pCursorBinding->obData) = 0;
					dwInfo = CURSOR_DB_NULL;
				}
            }
        }
        else if (pCursorBinding->dwDataType == CURSOR_DBTYPE_LPSTR)
        {
            if (pwszData)
                cbLength = GET_MBCSLEN_FROMWIDE(pwszData);

            if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
            {
                if (pwszData)
                {
                    MAKE_MBCSPTR_FROMWIDE(pszData, pwszData);

                    *(LPSTR*)(pData + pCursorBinding->obData) = (LPSTR)pVarData;

                    if (pCursorBinding->cbMaxLen == CURSOR_DB_NOMAXLENGTH)
                    {
                        memcpy(pVarData, pszData, cbLength);
	
	                    cbVarData = cbLength;
                    }
                    else
                    {
                        memcpy(pVarData, pszData, min(pCursorBinding->cbMaxLen, cbLength));

	                    cbVarData = min(pCursorBinding->cbMaxLen, cbLength);

                        if (pCursorBinding->cbMaxLen < cbLength)
                            dwInfo = CURSOR_DB_TRUNCATED;
                    }
                }
                else
				{
                    *(LPSTR*)(pData + pCursorBinding->obData) = NULL;
					dwInfo = CURSOR_DB_NULL;
				}
            }
        }
        else if (pCursorBinding->dwDataType == CURSOR_DBTYPE_LPWSTR)
        {
            if (pwszData)
                cbLength = (lstrlenW(pwszData) + 1) * sizeof(WCHAR);

            if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
            {
                if (pwszData)
                {
                    *(LPWSTR*)(pData + pCursorBinding->obData) = (LPWSTR)pVarData;

                    if (pCursorBinding->cbMaxLen == CURSOR_DB_NOMAXLENGTH)
                    {
                        memcpy(pVarData, pwszData, cbLength);

	                    cbVarData = cbLength;
                    }
                    else
                    {
                        memcpy(pVarData, pwszData, min(pCursorBinding->cbMaxLen, cbLength));

	                    cbVarData = min(pCursorBinding->cbMaxLen, cbLength);

                        if (pCursorBinding->cbMaxLen < cbLength)
                            dwInfo = CURSOR_DB_TRUNCATED;
                    }
                }
                else
				{
                    *(LPWSTR*)(pData + pCursorBinding->obData) = NULL;
					dwInfo = CURSOR_DB_NULL;
				}
            }
        }
    }
    else if (pCursorBinding->dwBinding == CURSOR_DBBINDING_VARIANT)
    {
        if (pCursorBinding->dwDataType == CURSOR_DBTYPE_LPSTR)
        {
            if (pwszData)
                cbLength = GET_MBCSLEN_FROMWIDE(pwszData);

            if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
            {
                CURSOR_DBVARIANT * pVariant = (CURSOR_DBVARIANT*)(pData + pCursorBinding->obData);

                VariantInit((VARIANT*)pVariant);

                if (pwszData)
                {
                    MAKE_MBCSPTR_FROMWIDE(pszData, pwszData);

                    pVariant->vt        = CURSOR_DBTYPE_LPSTR;
                    pVariant->pszVal    = (LPSTR)pVarData;

                    if (pCursorBinding->cbMaxLen == CURSOR_DB_NOMAXLENGTH)
                    {
                        memcpy(pVarData, pszData, cbLength);

	                    cbVarData = cbLength;
                    }
                    else
                    {
                        memcpy(pVarData, pszData, min(pCursorBinding->cbMaxLen, cbLength));

	                    cbVarData = min(pCursorBinding->cbMaxLen, cbLength);

                        if (pCursorBinding->cbMaxLen < cbLength)
                            dwInfo = CURSOR_DB_TRUNCATED;
                    }
                }
                else
				{
                    pVariant->vt = VT_NULL;
					dwInfo = CURSOR_DB_NULL;
				}
            }
        }
        else if (pCursorBinding->dwDataType == CURSOR_DBTYPE_LPWSTR)
        {
            if (pwszData)
                cbLength = (lstrlenW(pwszData) + 1) * sizeof(WCHAR);

            if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
            {
                CURSOR_DBVARIANT * pVariant = (CURSOR_DBVARIANT*)(pData + pCursorBinding->obData);

                VariantInit((VARIANT*)pVariant);

                if (pwszData)
                {
                    pVariant->vt        = CURSOR_DBTYPE_LPWSTR;
                    pVariant->pwszVal   = (LPWSTR)pVarData;

                    if (pCursorBinding->cbMaxLen == CURSOR_DB_NOMAXLENGTH)
                    {
                        memcpy(pVarData, pwszData, cbLength);

	                    cbVarData = cbLength;
                    }
                    else
                    {
                        memcpy(pVarData, pwszData, min(pCursorBinding->cbMaxLen, cbLength));

	                    cbVarData = min(pCursorBinding->cbMaxLen, cbLength);

                        if (pCursorBinding->cbMaxLen < cbLength)
                            dwInfo = CURSOR_DB_TRUNCATED;
                    }
                }
                else
				{
                    pVariant->vt = VT_NULL;
					dwInfo = CURSOR_DB_NULL;
				}
            }
        }
        else if (pCursorBinding->dwDataType == VT_BSTR)
        {
            if (pwszData)
                cbLength = (lstrlenW(pwszData) + 1) * sizeof(WCHAR);

            if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
			{
                CURSOR_DBVARIANT * pVariant = (CURSOR_DBVARIANT*)(pData + pCursorBinding->obData);

                VariantInit((VARIANT*)pVariant);

                if (pwszData)
				{
                    pVariant->vt        = VT_BSTR;
                    pVariant->pwszVal   = SysAllocString(pwszData);
				}
                else
				{
                    pVariant->vt = VT_NULL;
					dwInfo = CURSOR_DB_NULL;
				}
			}
		}
	}

    if (pCursorBinding->obVarDataLen != CURSOR_DB_NOVALUE)
        *(ULONG*)(pData + pCursorBinding->obVarDataLen) = cbLength;

    if (pCursorBinding->obInfo != CURSOR_DB_NOVALUE)
        *(DWORD*)(pData + pCursorBinding->obInfo) = dwInfo;

    return cbVarData;
}

//=--------------------------------------------------------------------------=
// ReturnData_DBCOLUMNID - Coerce DBCOLUMNID data into buffers
//=--------------------------------------------------------------------------=
// This function coerces the specified data into supplied buffers
//
// Parameters:
//    cursorColumnID    - [in] the cursor column identifier
//    pCursorBinding    - [in] the cursor binding describing the format of the
//                             returned information
//    pData             - [in] a pointer to the fixed area buffer
//    pVarData          - [in] a pointer to the variable length buffer
//
// Output:
//    ULONG - the number of bytes used in variable length buffer
//
// Notes:
//
ULONG CVDMetadataCursor::ReturnData_DBCOLUMNID(CURSOR_DBCOLUMNID cursorColumnID, CURSOR_DBCOLUMNBINDING * pCursorBinding,
    BYTE * pData, BYTE * pVarData)
{
    ULONG cbVarData = 0;

    if (pCursorBinding->dwBinding == CURSOR_DBBINDING_DEFAULT)
    {
        if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
            *(CURSOR_DBCOLUMNID*)(pData + pCursorBinding->obData) = cursorColumnID;
    }
    else if (pCursorBinding->dwBinding == CURSOR_DBBINDING_VARIANT)
    {
        if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
        {
            CURSOR_DBVARIANT * pVariant = (CURSOR_DBVARIANT*)(pData + pCursorBinding->obData);
            CURSOR_DBCOLUMNID * pCursorColumnID = (CURSOR_DBCOLUMNID*)pVarData;

            VariantInit((VARIANT*)pVariant);

            pVariant->vt        = CURSOR_DBTYPE_COLUMNID;
            pVariant->pColumnid = pCursorColumnID;

            *pCursorColumnID = cursorColumnID;

            cbVarData = sizeof(CURSOR_DBCOLUMNID);
        }
    }

    if (pCursorBinding->obVarDataLen != CURSOR_DB_NOVALUE)
        *(DWORD*)(pData + pCursorBinding->obVarDataLen) = 0;

    if (pCursorBinding->obInfo != CURSOR_DB_NOVALUE)
        *(DWORD*)(pData + pCursorBinding->obInfo) = CURSOR_DB_NOINFO;

    return cbVarData;
}

//=--------------------------------------------------------------------------=
// ReturnData_Bookmark - Coerce bookmark data into buffers
//=--------------------------------------------------------------------------=
// This function coerces the specified data into supplied buffers
//
// Parameters:
//    lRow              - [in] the current row
//    pCursorBinding    - [in] the cursor binding describing the format of the
//                             returned information
//    pData             - [in] a pointer to the fixed area buffer
//    pVarData          - [in] a pointer to the variable length buffer
//
// Output:
//    ULONG - the number of bytes used in variable length buffer
//
// Notes:
//
ULONG CVDMetadataCursor::ReturnData_Bookmark(LONG lRow, CURSOR_DBCOLUMNBINDING * pCursorBinding,
    BYTE * pData, BYTE * pVarData)
{
    ULONG cbVarData = 0;

    ULONG cbLength = sizeof(LONG);
    DWORD dwInfo = CURSOR_DB_NOINFO;

    if (pCursorBinding->dwBinding == CURSOR_DBBINDING_DEFAULT)
    {
        if (pCursorBinding->dwDataType == CURSOR_DBTYPE_BYTES)
        {
            if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
            {
                memcpy(pData + pCursorBinding->obData, &lRow, min(pCursorBinding->cbMaxLen, cbLength));

                if (pCursorBinding->cbMaxLen < cbLength)
                    dwInfo = CURSOR_DB_TRUNCATED;
            }
        }
        else if (pCursorBinding->dwDataType == CURSOR_DBTYPE_BLOB)
        {
            if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
            {
                *(ULONG*)(pData + pCursorBinding->obData) = cbLength;
                *(LPBYTE*)(pData + pCursorBinding->obData + sizeof(ULONG)) = (LPBYTE)pVarData;

                if (pCursorBinding->cbMaxLen == CURSOR_DB_NOMAXLENGTH)
                {
                    memcpy((LPBYTE)pVarData, &lRow, cbLength);

	                cbVarData = cbLength;
                }
                else
                {
                    memcpy(pVarData, &lRow, min(pCursorBinding->cbMaxLen, cbLength));

	                cbVarData = min(pCursorBinding->cbMaxLen, cbLength);

                    if (pCursorBinding->cbMaxLen < cbLength)
                        dwInfo = CURSOR_DB_TRUNCATED;
                }
            }
        }
    }
    else if (pCursorBinding->dwBinding == CURSOR_DBBINDING_VARIANT)
    {
        if (pCursorBinding->dwDataType == CURSOR_DBTYPE_BLOB)
        {
            if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
            {
                CURSOR_DBVARIANT * pVariant = (CURSOR_DBVARIANT*)(pData + pCursorBinding->obData);

                VariantInit((VARIANT*)pVariant);

                pVariant->vt                = CURSOR_DBTYPE_BLOB;
                pVariant->blob.cbSize       = cbLength;
                pVariant->blob.pBlobData    = (LPBYTE)pVarData;

                if (pCursorBinding->cbMaxLen == CURSOR_DB_NOMAXLENGTH)
                {
                    memcpy((LPBYTE)pVarData, &lRow, cbLength);

	                cbVarData = cbLength;
                }
                else
                {
                    memcpy(pVarData, &lRow, min(pCursorBinding->cbMaxLen, cbLength));

	                cbVarData = min(pCursorBinding->cbMaxLen, cbLength);

                    if (pCursorBinding->cbMaxLen < cbLength)
                        dwInfo = CURSOR_DB_TRUNCATED;
                }
            }
        }
    }

    if (pCursorBinding->obVarDataLen != CURSOR_DB_NOVALUE)
        *(ULONG*)(pData + pCursorBinding->obVarDataLen) = cbLength;

    if (pCursorBinding->obInfo != CURSOR_DB_NOVALUE)
        *(DWORD*)(pData + pCursorBinding->obInfo) = dwInfo;

    return cbVarData;
}

//=--------------------------------------------------------------------------=
// Create - Create metadata cursor object
//=--------------------------------------------------------------------------=
// This function creates and initializes a new metadata cursor object
//
// Parameters:
//    ulColumns             - [in]  the number of rowset columns
//    pColumns              - [in]  a pointer to rowset columns where to
//                                  retrieve metadata
//    ulMetaColumns         - [in]  the number of rowset meta-columns (can be 0)
//    pMetaColumns          - [in]  a pointer to rowset meta-columns where to
//                                  retrieve metadata (can be NULL)
//    ppMetaDataCursor      - [out] a pointer in which to return pointer to
//                                  metadata cursor object
//    pResourceDLL          - [in]  a pointer which keeps track of resource DLL
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//              E_OUTOFMEMORY not enough memory to create object
//
// Notes:
//
HRESULT CVDMetadataCursor::Create(ULONG ulColumns, CVDRowsetColumn * pColumns, ULONG ulMetaColumns,
    CVDRowsetColumn * pMetaColumns, CVDMetadataCursor ** ppMetadataCursor, CVDResourceDLL * pResourceDLL)
{
    ASSERT_POINTER(pColumns, CVDRowsetColumn)
    ASSERT_NULL_OR_POINTER(pMetaColumns, CVDRowsetColumn)
    ASSERT_POINTER(ppMetadataCursor, CVDMetadataCursor*)
    ASSERT_POINTER(pResourceDLL, CVDResourceDLL)

    if (!ppMetadataCursor || !pColumns)
        return E_INVALIDARG;

    *ppMetadataCursor = NULL;

    CVDMetadataCursor * pMetadataCursor = new CVDMetadataCursor();

    if (!pMetadataCursor)
        return E_OUTOFMEMORY;

    pMetadataCursor->m_ulColumns        = ulColumns;
    pMetadataCursor->m_pColumns         = pColumns;
    pMetadataCursor->m_ulMetaColumns    = ulMetaColumns;
    pMetadataCursor->m_pMetaColumns     = pMetaColumns;
    pMetadataCursor->m_pResourceDLL     = pResourceDLL;

    *ppMetadataCursor = pMetadataCursor;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// IUnknown methods implemented
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// IUnknown QueryInterface
//
HRESULT CVDMetadataCursor::QueryInterface(REFIID riid, void **ppvObjOut)
{
    ASSERT_POINTER(ppvObjOut, IUnknown*)

    if (!ppvObjOut)
        return E_INVALIDARG;

    *ppvObjOut = NULL;

    switch (riid.Data1)
    {
        QI_INTERFACE_SUPPORTED((ICursor*)this, IUnknown);
        QI_INTERFACE_SUPPORTED(this, ICursor);
        QI_INTERFACE_SUPPORTED(this, ICursorMove);
        QI_INTERFACE_SUPPORTED(this, ICursorScroll);
		QI_INTERFACE_SUPPORTED(this, ISupportErrorInfo);
    }

    if (NULL == *ppvObjOut)
        return E_NOINTERFACE;

    AddRef();

    return S_OK;
}

//=--------------------------------------------------------------------------=
// IUnknown AddRef
//
ULONG CVDMetadataCursor::AddRef(void)
{
   return ++m_dwRefCount;
}

//=--------------------------------------------------------------------------=
// IUnknown Release
//
ULONG CVDMetadataCursor::Release(void)
{
    if (1 > --m_dwRefCount)
    {
        delete this;
        return 0;
    }

    return m_dwRefCount;
}

//=--------------------------------------------------------------------------=
// ICursor methods implemented
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// ICursor GetColumnsCursor
//=--------------------------------------------------------------------------=
// Creates a cursor containing information about the current cursor
//
// Parameters:
//    riid              - [in]  the interface ID to which to return a pointer
//    ppvColumnsCursor  - [out] a pointer to memory in which to return the
//                              interface pointer
//    pcRows            - [out] a pointer to memory in which to return the
//                              number of rows in the metadata cursor
//
// Output:
//    HRESULT - S_OK if successful
//              E_FAIL can't create cursor
//              E_INVALIDARG bad parameter
//              E_OUTOFMEMORY not enough memory
//              E_NOINTERFACE interface not available
//
// Notes:
//    This function only succeeds when creating a meta-metadata cursor.
//
HRESULT CVDMetadataCursor::GetColumnsCursor(REFIID riid, IUnknown **ppvColumnsCursor, ULONG *pcRows)
{
    ASSERT_POINTER(ppvColumnsCursor, IUnknown*)
    ASSERT_NULL_OR_POINTER(pcRows, ULONG)

    if (!ppvColumnsCursor)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursor, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // init out parameters
    *ppvColumnsCursor = NULL;

    if (pcRows)
        *pcRows = 0;

    if (!m_ulMetaColumns)   // can't create meta-meta-metadata cursor
    {
        VDSetErrorInfo(IDS_ERR_CANTCREATEMETACURSOR, IID_ICursor, m_pResourceDLL);
        return E_FAIL;
    }

    // make sure caller asked for an available interface
    if (riid != IID_IUnknown && riid != IID_ICursor && riid != IID_ICursorMove && riid != IID_ICursorScroll)
    {
        VDSetErrorInfo(IDS_ERR_NOINTERFACE, IID_ICursor, m_pResourceDLL);
        return E_NOINTERFACE;
    }

    // create meta-metadata cursor
    CVDMetadataCursor * pMetadataCursor;

    HRESULT hr = CVDMetadataCursor::Create(m_ulMetaColumns, m_pMetaColumns, 0, 0, &pMetadataCursor, m_pResourceDLL);

    if (FAILED(hr)) // the only reason for failing here is an out of memory condition
    {
        VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
        return hr;
    }

    *ppvColumnsCursor = (ICursor*)pMetadataCursor;

    if (pcRows)
        *pcRows = m_ulMetaColumns;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// ICursor SetBindings
//=--------------------------------------------------------------------------=
// Replaces the existing column bindings or adds new column bindings to the
// existing ones
//
// Parameters:
//    cCol              - [in] the number of columns to bind
//    rgBoundColumns    - [in] an array of column bindings, one for each
//                             column for which data is to be returned
//    cbRowLength       - [in] the number of bytes of inline memory in a
//                             single row of data
//    dwFlags           - [in] a flag that specifies whether to replace the
//                             existing column bindings or add to them
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//              E_OUTOFMEMORY not enough memory
//              CURSOR_DB_E_BADBINDINFO bad binding information
//              CURSOR_DB_E_COLUMNUNAVAILABLE columnID is not available
//              CURSOR_DB_E_ROWTOOSHORT cbRowLength was less than the minumum (and not zero)
//
// Notes:
//
HRESULT CVDMetadataCursor::SetBindings(ULONG cCol, CURSOR_DBCOLUMNBINDING rgBoundColumns[], ULONG cbRowLength, DWORD dwFlags)
{
    ASSERT_NULL_OR_POINTER(rgBoundColumns, CURSOR_DBCOLUMNBINDING)

    if (!cCol && dwFlags == CURSOR_DBCOLUMNBINDOPTS_ADD)
        return S_OK;

    if (cCol && !rgBoundColumns)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursor, m_pResourceDLL);
        return E_INVALIDARG;
    }

    if (dwFlags != CURSOR_DBCOLUMNBINDOPTS_REPLACE && dwFlags != CURSOR_DBCOLUMNBINDOPTS_ADD)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursor, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // make sure the bindings are okay
    ULONG ulColumns = m_ulMetaColumns;
    CVDRowsetColumn * pColumns = m_pMetaColumns;

    if (!pColumns)
    {
        ulColumns = m_ulColumns;
        pColumns = m_pColumns;
    }

    ULONG cbNewRowLength;
    ULONG cbNewVarRowLength;

    HRESULT hr = ValidateCursorBindings(ulColumns, pColumns, cCol, rgBoundColumns, cbRowLength, dwFlags,
        &cbNewRowLength, &cbNewVarRowLength);

    if (SUCCEEDED(hr))  // if so, then set them in cursor
    {
        hr = CVDCursorBase::SetBindings(cCol, rgBoundColumns, cbRowLength, dwFlags);

        if (SUCCEEDED(hr))  // store new row lengths computed during validation
        {
            m_cbRowLength = cbNewRowLength;
            m_cbVarRowLength = cbNewVarRowLength;
        }
    }

    return hr;
}

//=--------------------------------------------------------------------------=
// ICursor GetNextRows
//=--------------------------------------------------------------------------=
// Fetches the specified number of rows starting with the row after the
// current one
//
// Parameters:
//    udlRowsToSkip     - [in]      the number of rows to skip before fetching
//    pFetchParams      - [in, out] a pointer to fetch rows structure
//
// Output:
//    HRESULT - S_OK if successful
//              CURSOR_DB_S_ENDOFCURSOR reached end of the cursor
//
// Notes:
//
HRESULT CVDMetadataCursor::GetNextRows(LARGE_INTEGER udlRowsToSkip, CURSOR_DBFETCHROWS *pFetchParams)
{
    ASSERT_NULL_OR_POINTER(pFetchParams, CURSOR_DBFETCHROWS)

    // return if caller doesn't supply fetch rows structure
    if (!pFetchParams)
        return S_OK;

    // init out parameter
    pFetchParams->cRowsReturned = 0;

    // return if caller didn't ask for any rows
    if (!pFetchParams->cRowsRequested)
        return S_OK;

    // make sure fetch flags has only valid values
    if (pFetchParams->dwFlags != CURSOR_DBROWFETCH_DEFAULT &&
        pFetchParams->dwFlags != CURSOR_DBROWFETCH_CALLEEALLOCATES &&
        pFetchParams->dwFlags != CURSOR_DBROWFETCH_FORCEREFRESH &&
        pFetchParams->dwFlags != (CURSOR_DBROWFETCH_CALLEEALLOCATES | CURSOR_DBROWFETCH_FORCEREFRESH))
        return CURSOR_DB_E_BADFETCHINFO;

    // if memory was caller allocated, make sure caller supplied data pointer
    if (!(pFetchParams->dwFlags & CURSOR_DBROWFETCH_CALLEEALLOCATES) && !pFetchParams->pData)
        return CURSOR_DB_E_BADFETCHINFO;

    // if memory was caller allocated, make sure caller supplied var-data pointer and size if needed
    if (!(pFetchParams->dwFlags & CURSOR_DBROWFETCH_CALLEEALLOCATES) && m_fNeedVarData &&
        (!pFetchParams->pVarData || !pFetchParams->cbVarData))
        return CURSOR_DB_E_BADFETCHINFO;

    // allocate necessary memory
    if (pFetchParams->dwFlags & CURSOR_DBROWFETCH_CALLEEALLOCATES)
    {
        // inline memory
        pFetchParams->pData = g_pMalloc->Alloc(pFetchParams->cRowsRequested * m_cbRowLength);

        if (!pFetchParams->pData)
        {
			VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
            return E_OUTOFMEMORY;
        }

        if (m_fNeedVarData)
        {
            // out-of-line memory
            pFetchParams->pVarData = g_pMalloc->Alloc(pFetchParams->cRowsRequested * m_cbVarRowLength);

            if (!pFetchParams->pData)
            {
                g_pMalloc->Free(pFetchParams->pData);
                pFetchParams->pData = NULL;
			    VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
                return E_OUTOFMEMORY;
            }
        }
        else
            pFetchParams->pVarData = NULL;
    }

    // fetch data
    HRESULT hrFetch = S_OK;
    CVDRowsetColumn * pColumn;
    CURSOR_DBCOLUMNID cursorColumnID;
    CURSOR_DBCOLUMNBINDING * pCursorBinding;
    BYTE * pData = (BYTE*)pFetchParams->pData;
    BYTE * pVarData = (BYTE*)pFetchParams->pVarData;

    // iterate through rows
    for (ULONG ulRow = 0; ulRow < pFetchParams->cRowsRequested; ulRow++)
    {
        // increment row
        m_lCurrentRow++;

        // make sure we didn't hit end of table
        if (m_lCurrentRow >= (LONG)m_ulColumns)
        {
            m_lCurrentRow = (LONG)m_ulColumns;
            hrFetch = CURSOR_DB_S_ENDOFCURSOR;
            goto DoneFetchingMetaData;
        }

        pCursorBinding = m_pCursorBindings;
        pColumn = &m_pColumns[m_lCurrentRow];

        // iterate through bindings
        for (ULONG ulBind = 0; ulBind < m_ulCursorBindings; ulBind++)
        {
            cursorColumnID = pCursorBinding->columnID;

            // return requested data
            if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_BINDTYPE))
            {
                pVarData += ReturnData_I4(pColumn->GetBindType(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_COLUMNID))
            {
                pVarData += ReturnData_DBCOLUMNID(pColumn->GetCursorColumnID(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_DATACOLUMN))
            {
                pVarData += ReturnData_BOOL(pColumn->GetDataColumn(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_ENTRYIDMAXLENGTH))
            {
                pVarData += ReturnData_I4(pColumn->GetEntryIDMaxLength(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_FIXED))
            {
                pVarData += ReturnData_BOOL(pColumn->GetFixed(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_MAXLENGTH))
            {
                pVarData += ReturnData_I4(pColumn->GetMaxLength(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_NAME))
            {
                pVarData += ReturnData_LPWSTR(pColumn->GetName(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_NUMBER))
            {
                pVarData += ReturnData_I4(pColumn->GetNumber(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_NULLABLE))
            {
                pVarData += ReturnData_BOOL(pColumn->GetNullable(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_SCALE))
            {
                pVarData += ReturnData_I4(pColumn->GetScale(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_TYPE))
            {
                pVarData += ReturnData_I4(pColumn->GetCursorType(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_UPDATABLE))
            {
                pVarData += ReturnData_I4(pColumn->GetUpdatable(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_UNIQUE))
            {
                pVarData += ReturnData_BOOL(pColumn->GetUnique(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_CASESENSITIVE))
            {
                pVarData += ReturnData_BOOL(pColumn->GetCaseSensitive(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_AUTOINCREMENT))
            {
                pVarData += ReturnData_BOOL(pColumn->GetAutoIncrement(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_HASDEFAULT))
            {
                pVarData += ReturnData_BOOL(pColumn->GetHasDefault(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_COLLATINGORDER))
            {
                pVarData += ReturnData_I4(pColumn->GetCollatingOrder(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_BASENAME))
            {
                pVarData += ReturnData_LPWSTR(pColumn->GetBaseName(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_BASECOLUMNNAME))
            {
                pVarData += ReturnData_LPWSTR(pColumn->GetBaseColumnName(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_DEFAULTVALUE))
            {
                pVarData += ReturnData_LPWSTR(pColumn->GetDefaultValue(), pCursorBinding, pData, pVarData);
            }
            else if (IsEqualCursorColumnID(cursorColumnID, CURSOR_COLUMN_BMKTEMPORARY))
            {
                pVarData += ReturnData_Bookmark(m_lCurrentRow, pCursorBinding, pData, pVarData);
            }

            pCursorBinding++;
        }

        // increment returned row count
        pFetchParams->cRowsReturned++;
        pData += m_cbRowLength;
    }

DoneFetchingMetaData:
    // cleanup memory allocations if we did not retrieve any rows
    if (pFetchParams->dwFlags & CURSOR_DBROWFETCH_CALLEEALLOCATES && !pFetchParams->cRowsReturned)
    {
        if (pFetchParams->pData)
        {
            g_pMalloc->Free(pFetchParams->pData);
            pFetchParams->pData = NULL;
        }

        if (pFetchParams->pVarData)
        {
            g_pMalloc->Free(pFetchParams->pVarData);
            pFetchParams->pVarData = NULL;
        }
    }

    return hrFetch;
}

//=--------------------------------------------------------------------------=
// ICursor Requery
//=--------------------------------------------------------------------------=
// Repopulates the cursor based on its original definition
//
// Parameters:
//              none
//
// Output:
//    HRESULT - S_OK if successful
//
// Notes:
//
HRESULT CVDMetadataCursor::Requery(void)
{
    m_lCurrentRow = -1;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// ICursorMove methods implemented
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// ICursorMove Move
//=--------------------------------------------------------------------------=
// Moves the current row to a new row within the cursor and optionally fetches
// rows from that new position
//
// Parameters:
//    cbBookmark    - [in]      length in bytes of the bookmark
//    pBookmark     - [in]      a pointer to a bookmark which serves as the
//                              origin for the calculation that determines the
//                              target row
//    dlOffset      - [in]      a signed count of the rows from the origin
//                              bookmark to the target row
//    pFetchParams  - [in, out] a pointer to fetch rows structure
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//
// Notes:
//
HRESULT CVDMetadataCursor::Move(ULONG cbBookmark, void *pBookmark, LARGE_INTEGER dlOffset, CURSOR_DBFETCHROWS *pFetchParams)
{
    ASSERT_POINTER(pBookmark, BYTE)
    ASSERT_NULL_OR_POINTER(pFetchParams, CURSOR_DBFETCHROWS)

    if (!cbBookmark || !pBookmark)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursor, m_pResourceDLL);
        return E_INVALIDARG;
    }

	if (!BookmarkToRow(cbBookmark, pBookmark, &m_lCurrentRow))
    {
        VDSetErrorInfo(IDS_ERR_BADBOOKMARK, IID_ICursor, m_pResourceDLL);
        return CURSOR_DB_E_BADBOOKMARK;
    }

    m_lCurrentRow += (LONG)dlOffset.LowPart;

	if (m_lCurrentRow < -1)
	{
		m_lCurrentRow = -1;
		return CURSOR_DB_S_ENDOFCURSOR;
	}
	else
	if (m_lCurrentRow >= (LONG)m_ulColumns)
	{
		m_lCurrentRow = (LONG)m_ulColumns;
		return CURSOR_DB_S_ENDOFCURSOR;
	}

	if (!pFetchParams)
		return S_OK;

	// since get next rows starts from the row after the current row we must
	// back up one row
	m_lCurrentRow--;
	if (m_lCurrentRow < -1)
		m_lCurrentRow	= -1;

    return CVDMetadataCursor::GetNextRows(g_liZero, pFetchParams);
}

//=--------------------------------------------------------------------------=
// ICursorMove GetBookmark
//=--------------------------------------------------------------------------=
// Returns the bookmark of the current row
//
// Parameters:
//    pBookmarkType - [in]  a pointer to the type of bookmark desired
//    cbMaxSize     - [in]  length in bytes of the client buffer to put the
//                          returned bookmark into
//    pcbBookmark   - [out] a pointer to memory in which to return the actual
//                          length of the returned bookmark
//    pBookmark     - [out] a pointer to client buffer to put the returned
//                          bookmark into
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//
// Notes:
//
HRESULT CVDMetadataCursor::GetBookmark(CURSOR_DBCOLUMNID *pBookmarkType,
									   ULONG cbMaxSize,
									   ULONG *pcbBookmark,
									   void *pBookmark)
{
    ASSERT_POINTER(pBookmarkType, CURSOR_DBCOLUMNID)
    ASSERT_POINTER(pcbBookmark, ULONG)
    ASSERT_POINTER(pBookmark, BYTE)

    if (!pBookmarkType || !pcbBookmark || !pBookmark)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursor, m_pResourceDLL);
        return E_INVALIDARG;
    }

    if (cbMaxSize < sizeof(LONG))
    {
        VDSetErrorInfo(IDS_ERR_BUFFERTOOSMALL, IID_ICursor, m_pResourceDLL);
        return CURSOR_DB_E_BUFFERTOOSMALL;
    }

	RowToBookmark(m_lCurrentRow, pcbBookmark, pBookmark);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// ICursorMove Clone
//=--------------------------------------------------------------------------=
// Returns a clone of the cursor
//
// Parameters:
//    dwFlags           - [in]  a flag that specifies the clone options
//    riid              - [in]  the interface desired for the returned clone
//    ppvClonedCursor   - [out] a pointer to memory in which to return newly
//                              created clone pointer
//
// Output:
//    HRESULT - S_OK if successful
//
// Notes:
//
HRESULT CVDMetadataCursor::Clone(DWORD dwFlags, REFIID riid, IUnknown **ppvClonedCursor)
{

    CVDMetadataCursor * pMetaCursor = 0;

	HRESULT hr = CVDMetadataCursor::Create(m_ulColumns,
										m_pColumns,
										m_ulMetaColumns,
										m_pMetaColumns,
										&pMetaCursor,
										m_pResourceDLL);

    *ppvClonedCursor = (ICursor*)pMetaCursor;

    return hr;
}

//=--------------------------------------------------------------------------=
// ICursorScroll methods implemented
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// ICursorScroll Scroll
//=--------------------------------------------------------------------------=
// Moves the current row to a new row within the cursor, specified as a
// fraction, and optionally fetches rows from that new position
//
// Parameters:
//    ulNumerator   - [in]      the numerator of the fraction that states the
//                              position to scroll to in the cursor
//    ulDenominator - [in]      the denominator of that same fraction
//    pFetchParams  - [in, out] a pointer to fetch rows structure
//
// Output:
//    HRESULT - S_OK if successful
//              CURSOR_DB_E_BADFRACTION - bad fraction
//
// Notes:
//
HRESULT CVDMetadataCursor::Scroll(ULONG ulNumerator, ULONG ulDenominator, CURSOR_DBFETCHROWS *pFetchParams)
{
    ASSERT_NULL_OR_POINTER(pFetchParams, CURSOR_DBFETCHROWS)

    if (!ulDenominator) // division by zero is a bad thing!
    {
        // this is a Viaduct1 error message, which doesn't really apply
        VDSetErrorInfo(IDS_ERR_BADFRACTION, IID_ICursor, m_pResourceDLL);
        return CURSOR_DB_E_BADFRACTION;
    }

    m_lCurrentRow = (LONG)((ulNumerator * m_ulColumns) / ulDenominator);

	if (m_lCurrentRow >= (LONG)m_ulColumns)
		m_lCurrentRow = (LONG)m_ulColumns - 1;

	if (!pFetchParams)
		return S_OK;

	// since get next rows starts from the row after the current row we must
	// back up one row
	m_lCurrentRow--;
	if (m_lCurrentRow < -1)
		m_lCurrentRow = -1;

    return CVDMetadataCursor::GetNextRows(g_liZero, pFetchParams);
}

//=--------------------------------------------------------------------------=
// ICursorScroll GetApproximatePosition
//=--------------------------------------------------------------------------=
// Returns the approximate location of a bookmark within the cursor, specified
// as a fraction
//
// Parameters:
//    cbBookmark        - [in]  length in bytes of the bookmark
//    pBookmark         - [in]  a pointer to the bookmark
//    pulNumerator      - [out] a pointer to memory in which to return the
//                              numerator of the faction that defines the
//                              approximate position of the bookmark
//    pulDenominator    - [out] a pointer to memory in which to return the
//                              denominator of that same faction
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//
// Notes:
//
HRESULT CVDMetadataCursor::GetApproximatePosition(ULONG cbBookmark, void *pBookmark, ULONG *pulNumerator, ULONG *pulDenominator)
{
    ASSERT_POINTER(pBookmark, BYTE)
    ASSERT_POINTER(pulNumerator, ULONG)
    ASSERT_POINTER(pulDenominator, ULONG)

    if (!pBookmark || !pulNumerator || !pulDenominator)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursor, m_pResourceDLL);
        return E_INVALIDARG;
    }

	LONG lRow;

	if (!BookmarkToRow(cbBookmark, pBookmark, &lRow))
    {
        VDSetErrorInfo(IDS_ERR_BADBOOKMARK, IID_ICursor, m_pResourceDLL);
        return CURSOR_DB_E_BADBOOKMARK;
    }

    *pulNumerator = lRow + 1;
    *pulDenominator = m_ulColumns ? m_ulColumns : 1;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// ICursorScroll GetApproximateCount
//=--------------------------------------------------------------------------=
// Returns the approximate number of rows in the cursor
//
// Parameters:
//    pudlApproxCount       - [out] a pointer to a buffer containing the
//                                  returned approximate count of the rows
//                                  in the cursor
//    pdwFullyPopuldated    - [out] a pointer to a buffer containing returned
//                                  flags indicating whether the cursor is fully
//                                  populated
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//
// Notes:
//
HRESULT CVDMetadataCursor::GetApproximateCount(LARGE_INTEGER *pudlApproxCount, DWORD *pdwFullyPopulated)
{
    ASSERT_POINTER(pudlApproxCount, LARGE_INTEGER)
    ASSERT_NULL_OR_POINTER(pdwFullyPopulated, DWORD)

    if (!pudlApproxCount)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursor, m_pResourceDLL);
        return E_INVALIDARG;
    }

    pudlApproxCount->HighPart = 0;
    pudlApproxCount->LowPart  = m_ulColumns;

    if (pdwFullyPopulated)
        *pdwFullyPopulated = CURSOR_DBCURSORPOPULATED_FULLY;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\cursmeta.h ===
//---------------------------------------------------------------------------
// MetadataCursor.h : CVDMetadataCursor header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------


#ifndef __CVDMETADATACURSOR__
#define __CVDMETADATACURSOR__


class CVDMetadataCursor : public CVDCursorBase
{
protected:
// Construction/Destruction
	CVDMetadataCursor();
	virtual ~CVDMetadataCursor();

public:
    static HRESULT Create(ULONG ulColumns, CVDRowsetColumn * pColumns, ULONG ulMetaColumns, CVDRowsetColumn * pMetaColumns,
        CVDMetadataCursor ** ppMetadataCursor, CVDResourceDLL * pResourceDLL);

protected:
// Helper functions
    void RowToBookmark(LONG lRow, ULONG * pcbBookmark, void * pBookmark) const;
    BOOL BookmarkToRow(ULONG cbBookmark, void * pBookmark, LONG * plRow) const;

    ULONG ReturnData_I4(DWORD dwData, CURSOR_DBCOLUMNBINDING * pCursorBinding, BYTE * pData, BYTE * pVarData);
    ULONG ReturnData_BOOL(VARIANT_BOOL fData, CURSOR_DBCOLUMNBINDING * pCursorBinding, BYTE * pData, BYTE * pVarData);
    ULONG ReturnData_LPWSTR(WCHAR * pwszData, CURSOR_DBCOLUMNBINDING * pCursorBinding, BYTE * pData, BYTE * pVarData);
    ULONG ReturnData_DBCOLUMNID(CURSOR_DBCOLUMNID cursorColumnID, CURSOR_DBCOLUMNBINDING * pCursorBinding, 
        BYTE * pData, BYTE * pVarData);
    ULONG ReturnData_Bookmark(LONG lRow, CURSOR_DBCOLUMNBINDING * pCursorBinding, BYTE * pData, BYTE * pVarData);

protected:
// Data members
    DWORD               m_dwRefCount;       // reference count
    LONG                m_lCurrentRow;      // current row in metadata columns

    ULONG               m_ulColumns;        // number of rowset columns
    CVDRowsetColumn *   m_pColumns;         // pointer to array of column objects

    ULONG               m_ulMetaColumns;    // number of rowset meta-columns
    CVDRowsetColumn *   m_pMetaColumns;     // pointer to array of meta-column objects

public:
    //=--------------------------------------------------------------------------=
    // IUnknown methods implemented
    //
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    //=--------------------------------------------------------------------------=
    // ICursor methods implemented
    //
    STDMETHOD(GetColumnsCursor)(REFIID riid, IUnknown **ppvColumnsCursor, ULONG *pcRows);
    STDMETHOD(SetBindings)(ULONG cCol, CURSOR_DBCOLUMNBINDING rgBoundColumns[], ULONG cbRowLength, DWORD dwFlags);
    STDMETHOD(GetNextRows)(LARGE_INTEGER udlRowsToSkip, CURSOR_DBFETCHROWS *pFetchParams);
    STDMETHOD(Requery)(void);

    //=--------------------------------------------------------------------------=
    // ICursorMove methods implemented
    //
    STDMETHOD(Move)(ULONG cbBookmark, void *pBookmark, LARGE_INTEGER dlOffset, CURSOR_DBFETCHROWS *pFetchParams);
    STDMETHOD(GetBookmark)(CURSOR_DBCOLUMNID *pBookmarkType, ULONG cbMaxSize, ULONG *pcbBookmark, void *pBookmark);
    STDMETHOD(Clone)(DWORD dwFlags, REFIID riid, IUnknown **ppvClonedCursor);

    //=--------------------------------------------------------------------------=
    // ICursorScroll methods implemented
    //
    STDMETHOD(Scroll)(ULONG ulNumerator, ULONG ulDenominator, CURSOR_DBFETCHROWS *pFetchParams);
    STDMETHOD(GetApproximatePosition)(ULONG cbBookmark, void *pBookmark, ULONG *pulNumerator, ULONG *pulDenominator);
    STDMETHOD(GetApproximateCount)(LARGE_INTEGER *pudlApproxCount, DWORD *pdwFullyPopulated);
};


#endif //__CVDMETADATACURSOR__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\curspos.cpp ===
//---------------------------------------------------------------------------
// CursorPosition.cpp : CursorPosition implementation
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "Notifier.h"
#include "RSColumn.h"
#include "RSSource.h"
#include "CursMain.h"
#include "ColUpdat.h"
#include "CursPos.h"
#include "fastguid.h"
#include "MSR2C.h"
#include "resource.h"

SZTHISFILE


//=--------------------------------------------------------------------------=
// CVDCursorPosition - Constructor
//
CVDCursorPosition::CVDCursorPosition()
{
    m_pCursorMain       = NULL;
	m_pRowPosition		= NULL;
    m_pSameRowClone     = NULL;
    m_dwEditMode        = CURSOR_DBEDITMODE_NONE;
    m_ppColumnUpdates   = NULL;
	m_fTempEditMode		= FALSE;
	m_fConnected		= FALSE;
	m_dwAdviseCookie	= 0;
	m_fPassivated	    = FALSE;
	m_fInternalSetRow	= FALSE;

#ifdef _DEBUG
    g_cVDCursorPositionCreated++;
#endif
}

//=--------------------------------------------------------------------------=
// ~CVDCursorPosition - Destructor
//
CVDCursorPosition::~CVDCursorPosition()
{
	Passivate();

#ifdef _DEBUG
    g_cVDCursorPositionDestroyed++;
#endif
}

//=--------------------------------------------------------------------------=
// Pasivate when external ref count gets to zero
//
void CVDCursorPosition::Passivate()
{
	if (m_fPassivated)
		return;

	m_fPassivated = TRUE;

    DestroyColumnUpdates();
	ReleaseCurrentRow();
    ReleaseAddRow();

	LeaveFamily(); // remove myself from pCursorMain's notification family

	if (m_pCursorMain)
	    m_pCursorMain->Release();   // release associated cursor main object

	if (m_fConnected)
		DisconnectIRowPositionChange();	// disconnect IRowPosition change

	if (m_pRowPosition)
		m_pRowPosition->Release();	// release associated row position
}

//=--------------------------------------------------------------------------=
// Create - Create cursor position object
//=--------------------------------------------------------------------------=
// This function creates and initializes a new cursor position object
//
// Parameters:
//    pRowPosition		- [in]  IRowPosition provider (may be NULL)
//    pCursorMain       - [in]  backwards pointer to CVDCursorMain object
//    ppCursorPosition  - [out] a pointer in which to return pointer to cursor position object
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//              E_OUTOFMEMORY not enough memory to create object
//
// Notes:
//
HRESULT CVDCursorPosition::Create(IRowPosition * pRowPosition,
								  CVDCursorMain * pCursorMain,
								  CVDCursorPosition ** ppCursorPosition,
								  CVDResourceDLL * pResourceDLL)
{
    ASSERT_POINTER(pCursorMain, CVDCursorMain)
    ASSERT_POINTER(ppCursorPosition, CVDCursorPosition*)

    if (!pCursorMain || !ppCursorPosition)
	{
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursorMove, pResourceDLL);
        return E_INVALIDARG;
	}

    *ppCursorPosition = NULL;

    CVDCursorPosition * pCursorPosition = new CVDCursorPosition();

    if (!pCursorPosition)
	{
        VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursorMove, pResourceDLL);
        return E_OUTOFMEMORY;
	}

    pCursorPosition->m_pResourceDLL	= pResourceDLL;
	pCursorPosition->m_pCursorMain	= pCursorMain;
	pCursorPosition->m_pRowPosition = pRowPosition;

    pCursorMain->AddRef();  // add reference to associated cursor main object

	if (pRowPosition)	// add reference to associated row position (if needed)
	{
		pRowPosition->AddRef();	

		// connect IRowPositionChange
		HRESULT hr = pCursorPosition->ConnectIRowPositionChange();

		if (SUCCEEDED(hr))
			pCursorPosition->m_fConnected = TRUE;
	}

	// add to pCursorMain's notification family
	pCursorPosition->JoinFamily(pCursorMain);

	pCursorPosition->PositionToFirstRow();
	
    *ppCursorPosition = pCursorPosition;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CreateColumnUpdates - Create array of column update pointers
//
HRESULT CVDCursorPosition::CreateColumnUpdates()
{
    const ULONG ulColumns = m_pCursorMain->GetColumnsCount();

    m_ppColumnUpdates = new CVDColumnUpdate*[ulColumns];

    if (!m_ppColumnUpdates)
    {
    	VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_OUTOFMEMORY;
    }

    // set all column update pointers to NULL
    memset(m_ppColumnUpdates, 0, ulColumns * sizeof(CVDColumnUpdate*));

    return S_OK;
}

//=--------------------------------------------------------------------------=
// ResetColumnUpdates - Reset column updates array
//
HRESULT CVDCursorPosition::ResetColumnUpdates()
{
    HRESULT hr = S_OK;

    if (m_ppColumnUpdates)
    {
        const ULONG ulColumns = m_pCursorMain->GetColumnsCount();

        // set all column update pointers to NULL
        for (ULONG ulCol = 0; ulCol < ulColumns; ulCol++)
            SetColumnUpdate(ulCol, NULL);
    }
    else
    {
        // create array of column update pointers
        hr = CreateColumnUpdates();
    }

    return hr;
}

//=--------------------------------------------------------------------------=
// DestroyColumnUpdates - Destroy column updates and array of update pointers
//
void CVDCursorPosition::DestroyColumnUpdates()
{
    if (m_ppColumnUpdates)
    {
        // set all column update pointers to NULL
        ResetColumnUpdates();

        // destroy array of column update pointers
        delete [] m_ppColumnUpdates;
        m_ppColumnUpdates = NULL;
    }
}

//=--------------------------------------------------------------------------=
// GetColumnUpdate - Get column update
//
CVDColumnUpdate * CVDCursorPosition::GetColumnUpdate(ULONG ulColumn) const
{
    CVDColumnUpdate * pColumnUpdate = NULL;

    const ULONG ulColumns = m_pCursorMain->GetColumnsCount();

    // make sure column index is in range
    if (ulColumn < ulColumns)
        pColumnUpdate = m_ppColumnUpdates[ulColumn];

    return pColumnUpdate;
}

//=--------------------------------------------------------------------------=
// SetColumnUpdate - Set column update
//
void CVDCursorPosition::SetColumnUpdate(ULONG ulColumn, CVDColumnUpdate * pColumnUpdate)
{
    const ULONG ulColumns = m_pCursorMain->GetColumnsCount();

    // make sure column index is in range
    if (ulColumn < ulColumns)
    {
        // release update if it already exists
        if (m_ppColumnUpdates[ulColumn])
            m_ppColumnUpdates[ulColumn]->Release();

        // store new column update
        m_ppColumnUpdates[ulColumn] = pColumnUpdate;
    }
}

//=--------------------------------------------------------------------------=
// PositionToFirstRow
//=--------------------------------------------------------------------------=
// Positions to the first row in the rowset
//
void CVDCursorPosition::PositionToFirstRow()
{
	m_bmCurrent.Reset();

	ULONG cRowsObtained = 0;
	HROW * rghRows = NULL;
	BYTE bSpecialBM;
	bSpecialBM			= DBBMK_FIRST;
	HRESULT hr = GetRowsetSource()->GetRowsetLocate()->GetRowsAt(0, 0, sizeof(BYTE), &bSpecialBM, 0,
															1, &cRowsObtained, &rghRows);

	if (cRowsObtained)
	{
		// set current row to first row
		SetCurrentHRow(rghRows[0]);
		// release hRows and associated memory
		GetRowsetSource()->GetRowset()->ReleaseRows(cRowsObtained, rghRows, NULL, NULL, NULL);
		g_pMalloc->Free(rghRows);
	}

}

//=--------------------------------------------------------------------------=
// ReleaseCurrentRow
//=--------------------------------------------------------------------------=
// Releases old current row
//
void CVDCursorPosition::ReleaseCurrentRow()
{
    if (!GetRowsetSource()->IsRowsetValid()		||
		m_bmCurrent.GetStatus() != VDBOOKMARKSTATUS_CURRENT)
		return;

    if (m_bmCurrent.m_hRow)
    {
	    GetRowsetSource()->GetRowset()->ReleaseRows(1, &m_bmCurrent.m_hRow, NULL, NULL, NULL);
    	m_bmCurrent.m_hRow = NULL;
    }
}

//=--------------------------------------------------------------------------=
// ReleaseAddRow
//=--------------------------------------------------------------------------=
// Releases temporary add row
//
void CVDCursorPosition::ReleaseAddRow()
{
    if (!GetRowsetSource()->IsRowsetValid())
		return;

    if (m_bmAddRow.m_hRow)
    {
	    GetRowsetSource()->GetRowset()->ReleaseRows(1, &m_bmAddRow.m_hRow, NULL, NULL, NULL);
	    m_bmAddRow.m_hRow = NULL;
    }
}

//=--------------------------------------------------------------------------=
// SetCurrentRowStatus
//=--------------------------------------------------------------------------=
// Sets status to beginning or end (releasing current hrow)
//
void CVDCursorPosition::SetCurrentRowStatus(WORD wStatus)
{
	if (VDBOOKMARKSTATUS_BEGINNING  == wStatus  ||
		VDBOOKMARKSTATUS_END		== wStatus)
	{
		ReleaseCurrentRow();
		m_bmCurrent.SetBookmark(wStatus);
	}
}

//=--------------------------------------------------------------------------=
// SetCurrentHRow
//=--------------------------------------------------------------------------=
// Reads the bookmark from the hrow and sets the m_bmCurrent
//
// Parameters:
//    hRowNew       - [in]  hrow of new current row
//
// Output:
//    HRESULT - S_OK if successful
//
// Notes:
//
HRESULT CVDCursorPosition::SetCurrentHRow(HROW hRowNew)
{
    if (!GetRowsetSource()->IsRowsetValid())
	{
		VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursor, m_pResourceDLL);
		return E_FAIL;
	}

	IRowset * pRowset = GetRowsetSource()->GetRowset();

	// allocate buffer for bookmark plus length indicator
	BYTE * pBuff = new BYTE[GetCursorMain()->GetMaxBookmarkLen() + sizeof(ULONG)];

	if (!pBuff)
    {
		VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
		return E_OUTOFMEMORY;
	}

	// get the bookmark data
	HRESULT hr = pRowset->GetData(hRowNew,
								  GetCursorMain()->GetBookmarkAccessor(),
								  pBuff);
	if (S_OK == hr)
	{
		ReleaseCurrentRow();
		pRowset->AddRefRows(1, &hRowNew, NULL, NULL);
		ULONG * pulLen = (ULONG*)pBuff;
		BYTE * pbmdata = pBuff + sizeof(ULONG);
		m_bmCurrent.SetBookmark(VDBOOKMARKSTATUS_CURRENT, hRowNew, pbmdata, *pulLen);
	}
	else
	{
		ASSERT_(FALSE);
		hr = VDMapRowsetHRtoCursorHR(hr,
									 IDS_ERR_GETDATAFAILED,
									 IID_ICursorMove,
									 pRowset,
									 IID_IRowset,
									 m_pResourceDLL);
	}

	delete [] pBuff;

	return hr;

}

//=--------------------------------------------------------------------------=
// IsSameRowAsCurrent - Compares current bookmark to supplied hrow
//=--------------------------------------------------------------------------=
//
// Parameters:
//    hRow				- [in]	hrow to check
//    fCacheIfNotSame	- [in]	If TRUE same hrow in cached CVDBookmark
//
// Output:
//    HRESULT   - S_OK if both hrows correspond to the same logical row
//				  S_FALSE if not same row
//				  E_INVALIDARG
//				  E_UNEXPECTED
//				  DB_E_BADROWHANDLE
//				  DB_E_DELETEDROW
//				  DB_E_NEWLYINSERTED
//
// Notes:
//

HRESULT CVDCursorPosition::IsSameRowAsCurrent(HROW hRow, BOOL fCacheIfNotSame)		
{

	if (!GetRowsetSource()->IsRowsetValid())
	{
		VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursor, m_pResourceDLL);
		return E_FAIL;
	}

	if (m_bmCurrent.IsSameHRow(hRow))
		return S_OK;

	HRESULT hrSame = S_FALSE;

	IRowsetIdentity * pRowsetIdentity = GetRowsetSource()->GetRowsetIdentity();

	if (pRowsetIdentity)
	{
		hrSame = pRowsetIdentity->IsSameRow(hRow, m_bmCurrent.GetHRow());
		// return if hrow matches or not cache flag set
		if (S_OK == hrSame || !fCacheIfNotSame)
			return hrSame;
	}
	else
	if (fCacheIfNotSame)
	{
		// check if hRow matches cache
		if (m_bmCache.IsSameHRow(hRow))
		{
			// return TRUE if bookmark matches cache
			return m_bmCurrent.IsSameBookmark(&m_bmCache) ? S_OK : S_FALSE;
		}
	}

	// allocate buffer for bookmark plus length indicator
	BYTE * pBuff = new BYTE[GetCursorMain()->GetMaxBookmarkLen() + sizeof(ULONG)];

	if (!pBuff)
    {
		VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
		return E_OUTOFMEMORY;
	}

	// get the bookmark data
	HRESULT hrWork = GetRowsetSource()->GetRowset()->GetData(hRow, GetCursorMain()->GetBookmarkAccessor(), pBuff);

	if (S_OK == hrWork)
	{
		ULONG * pulLen = (ULONG*)pBuff;
		BYTE * pbmdata = pBuff + sizeof(ULONG);
		// if IRowsetIdentity isn't supported, compare bookmarks
		if (!pRowsetIdentity)
		{
			DBCOMPARE dbcompare;
			hrWork = GetRowsetSource()->GetRowsetLocate()->Compare(0,
											m_bmCurrent.GetBookmarkLen(),
											m_bmCurrent.GetBookmark(),
											*pulLen,
											pbmdata,
											&dbcompare);
			if (SUCCEEDED(hrWork))
			{
				if (DBCOMPARE_EQ == dbcompare)
					hrSame = S_OK;
				else
					hrSame = S_FALSE;
			}
		}
		if (fCacheIfNotSame && S_OK != hrSame)
			m_bmCache.SetBookmark(VDBOOKMARKSTATUS_CURRENT, hRow, pbmdata, *pulLen);
	}
	else
		hrSame = hrWork;

	delete [] pBuff;

	return hrSame;

}

//=--------------------------------------------------------------------------=
// IsSameRowAsAddRow - Compares addrow bookmark to supplied hrow 
//=--------------------------------------------------------------------------=
//
// Parameters:
//    hRow				- [in]	hrow to check
//
// Output:
//    HRESULT   - S_OK if both hrows correspond to the same logical row
//				  S_FALSE if not same row
//				  E_INVALIDARG 
//				  E_UNEXPECTED
//				  DB_E_BADROWHANDLE
//				  DB_E_DELETEDROW
//				  DB_E_NEWLYINSERTED
//
// Notes:
//

HRESULT CVDCursorPosition::IsSameRowAsNew(HROW hRow)		
{

	if (!GetRowsetSource()->IsRowsetValid())
	{
		VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursor, m_pResourceDLL);
		return E_FAIL;
	}

	if (m_bmAddRow.IsSameHRow(hRow))
		return S_OK;

    if (m_bmAddRow.m_hRow == NULL)
        return S_FALSE;

	HRESULT hrSame = S_FALSE;

	IRowsetIdentity * pRowsetIdentity = GetRowsetSource()->GetRowsetIdentity();

	if (pRowsetIdentity)
	{
		hrSame = pRowsetIdentity->IsSameRow(hRow, m_bmAddRow.GetHRow());
		// return result
		return hrSame;
	}

	// allocate buffer for bookmark plus length indicator
	BYTE * pBuff = new BYTE[GetCursorMain()->GetMaxBookmarkLen() + sizeof(ULONG)];

	if (!pBuff)
    {
		VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
		return E_OUTOFMEMORY;
	}

	// get the bookmark data
	HRESULT hrWork = GetRowsetSource()->GetRowset()->GetData(hRow, GetCursorMain()->GetBookmarkAccessor(), pBuff);

	if (S_OK == hrWork)
	{
		ULONG * pulLen = (ULONG*)pBuff;
		BYTE * pbmdata = pBuff + sizeof(ULONG);

		// since IRowsetIdentity isn't supported, compare bookmarks
		DBCOMPARE dbcompare;
		hrWork = GetRowsetSource()->GetRowsetLocate()->Compare(0,
										m_bmAddRow.GetBookmarkLen(),
										m_bmAddRow.GetBookmark(),
										*pulLen,
										pbmdata,
										&dbcompare);
		if (SUCCEEDED(hrWork))
		{
			if (DBCOMPARE_EQ == dbcompare)
				hrSame = S_OK;
			else
				hrSame = S_FALSE;
		}
	}
	else
		hrSame = hrWork;

	delete [] pBuff;

	return hrSame;

}


//=--------------------------------------------------------------------------=
// SetAddHRow
//=--------------------------------------------------------------------------=
// Reads the bookmark from the hrow and sets the m_bmAddRow
//
// Parameters:
//    hRowNew       - [in]  hrow of new add row
//
// Output:
//    HRESULT - S_OK if successful
//
// Notes:
//
HRESULT CVDCursorPosition::SetAddHRow(HROW hRowNew)
{
    if (!GetRowsetSource()->IsRowsetValid())
	{
		VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursor, m_pResourceDLL);
		return E_FAIL;
	}

	IRowset * pRowset = GetRowsetSource()->GetRowset();

	// allocate buffer for bookmark plus length indicator
	BYTE * pBuff = new BYTE[GetCursorMain()->GetMaxBookmarkLen() + sizeof(ULONG)];

	if (!pBuff)
    {
		VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
		return E_OUTOFMEMORY;
	}

	// get the bookmark data
	HRESULT hr = pRowset->GetData(hRowNew,
								  GetCursorMain()->GetBookmarkAccessor(),
								  pBuff);
	if (S_OK == hr)
	{
		ReleaseAddRow();
		pRowset->AddRefRows(1, &hRowNew, NULL, NULL);
		ULONG * pulLen = (ULONG*)pBuff;
		BYTE * pbmdata = pBuff + sizeof(ULONG);
		m_bmAddRow.SetBookmark(VDBOOKMARKSTATUS_CURRENT, hRowNew, pbmdata, *pulLen);
	}
	else
	{
		ASSERT_(FALSE);
		hr = VDMapRowsetHRtoCursorHR(hr,
									 IDS_ERR_GETDATAFAILED,
									 IID_ICursorMove,
									 pRowset,
									 IID_IRowset,
									 m_pResourceDLL);
	}

	delete [] pBuff;

	return hr;

}

//=--------------------------------------------------------------------------=
// GetEditRow - Get hRow of the row currently being edited
//
HROW CVDCursorPosition::GetEditRow() const
{
    HROW hRow = NULL;

    switch (m_dwEditMode)
    {
        case CURSOR_DBEDITMODE_UPDATE:
            hRow = m_bmCurrent.m_hRow;
            break;

        case CURSOR_DBEDITMODE_ADD:
            hRow = m_bmAddRow.m_hRow;
            break;
    }

    return hRow;
}

//=--------------------------------------------------------------------------=
// SetRowPosition - Set new current hRow
//
HRESULT CVDCursorPosition::SetRowPosition(HROW hRow)
{
	if (!m_pRowPosition)
		return S_OK;

    // set new current row (set/clear internal set row flag)
	m_fInternalSetRow = TRUE;

	HRESULT hr = m_pRowPosition->ClearRowPosition();

	if (SUCCEEDED(hr))
		hr = m_pRowPosition->SetRowPosition(NULL, hRow, DBPOSITION_OK);

	m_fInternalSetRow = FALSE;

	return hr;
}

#ifndef VD_DONT_IMPLEMENT_ISTREAM

//=--------------------------------------------------------------------------=
// UpdateEntryIDStream - Update entry identifier from stream
//=--------------------------------------------------------------------------=
// This function updates the entry identifier's data from stream
//
// Parameters:
//  pColumn     - [in] rowset column pointer
//  hRow        - [in] the row handle
//  pStream     - [in] stream pointer
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//              E_OUTOFMEMORY not enough memory
//
HRESULT CVDCursorPosition::UpdateEntryIDStream(CVDRowsetColumn * pColumn, HROW hRow, IStream * pStream)
{
    ASSERT_POINTER(pStream, IStream)

	IAccessor * pAccessor = GetCursorMain()->GetAccessor();
	IRowsetChange * pRowsetChange = GetCursorMain()->GetRowsetChange();

    // make sure we have valid accessor and change pointers
    if (!pAccessor || !pRowsetChange || !GetCursorMain()->IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_IEntryID, m_pResourceDLL);
        return E_FAIL;
    }

    // make sure we have all necessary pointers
    if (!pColumn || !pStream)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_IEntryID, m_pResourceDLL);
        return E_INVALIDARG;
    }

    STATSTG statstg;

    // retrieve status structure
    HRESULT hr = pStream->Stat(&statstg, STATFLAG_NONAME);

    if (FAILED(hr))
    {
        VDSetErrorInfo(IDS_ERR_STATFAILED, IID_IEntryID, m_pResourceDLL);
        return E_FAIL;
    }

    // determine length of data
    ULONG cbData = statstg.cbSize.LowPart;

    HGLOBAL hData;

    // get handle to data
    hr = GetHGlobalFromStream(pStream, &hData);

    if (FAILED(hr))
        return hr;

    // get pointer to data
    BYTE * pData = (BYTE*)GlobalLock(hData);

    DBBINDING binding;

    // clear out binding
    memset(&binding, 0, sizeof(DBBINDING));

    // create value binding
    binding.iOrdinal    = pColumn->GetOrdinal();
    binding.obValue     = sizeof(DBSTATUS) + sizeof(ULONG);
    binding.obLength    = sizeof(DBSTATUS);
    binding.obStatus    = 0;
    binding.dwPart      = DBPART_VALUE | DBPART_LENGTH | DBPART_STATUS;
    binding.dwMemOwner  = DBMEMOWNER_CLIENTOWNED;
    binding.cbMaxLen    = cbData;
    binding.wType       = DBTYPE_BYREF | DBTYPE_BYTES;

    HACCESSOR hAccessor;

    // create update accessor
    hr = pAccessor->CreateAccessor(DBACCESSOR_ROWDATA, 1, &binding, 0, &hAccessor, NULL);

	hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_CREATEACCESSORFAILED, IID_IEntryID, pAccessor, IID_IAccessor, m_pResourceDLL);

    if (FAILED(hr))
    {
        // release pointer to data
        GlobalUnlock(hData);
        return hr;
    }

    // create update buffer
    BYTE * pBuffer = new BYTE[sizeof(DBSTATUS) + sizeof(ULONG) + sizeof(LPBYTE)];

    if (!pBuffer)
    {
        // release pointer to data
        GlobalUnlock(hData);

        // release update accessor
        pAccessor->ReleaseAccessor(hAccessor, NULL);

        VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_IEntryID, m_pResourceDLL);
        return E_OUTOFMEMORY;
    }

    // set status, length and value
    *(DBSTATUS*)pBuffer = DBSTATUS_S_OK;
    *(ULONG*)(pBuffer + sizeof(DBSTATUS)) = cbData;
    *(LPBYTE*)(pBuffer + sizeof(DBSTATUS) + sizeof(ULONG)) = pData;

    // modify column
    hr = pRowsetChange->SetData(hRow, hAccessor, pBuffer);

	hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_SETDATAFAILED, IID_IEntryID, pRowsetChange, IID_IRowsetChange,
        m_pResourceDLL);

    // release pointer to data
    GlobalUnlock(hData);

    // release update accessor
    pAccessor->ReleaseAccessor(hAccessor, NULL);

    // destroy update buffer
    delete [] pBuffer;

    return hr;
}

#endif //VD_DONT_IMPLEMENT_ISTREAM

//=--------------------------------------------------------------------------=
// ReleaseSameRowClone - Release same-row clone, if we still have one
//
void CVDCursorPosition::ReleaseSameRowClone()
{
    if (m_pSameRowClone)
    {
        // must be set to NULL before release
        ICursor * pSameRowClone = m_pSameRowClone;
        m_pSameRowClone = NULL;

        pSameRowClone->Release();
    }
}

//=--------------------------------------------------------------------------=
// IRowsetNotify Methods
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// IRowsetNotify OnFieldChange
//=--------------------------------------------------------------------------=
// This function is called on any change to the value of a field
//
// Parameters:
//    pRowset       - [in]  the IRowset that is generating the notification
//							(we can ignore this since we are only ever dealing
//							with a single rowset).
//    hRow          - [in]  the HROW of the row in which the field value has
//							changed
//    cColumns      - [in]  the count of columns in rgColumns
//    rgColumns     - [in]  an array of column (ordinal positions) in the row
//							for which the value has changed
//    eReason       - [in]  the kind of action which caused this change
//    ePhase        - [in]  the phase of this notification
//    fCantDeny     - [in]  when this flag is set to TRUE, the consumer cannot
//							veto the event (by returning S_FALSE)
//
// Output:
//    HRESULT - S_OK if successful
//				S_FALSE the event/phase is vetoed
//              DB_S_UNWANTEDPHASE
//              DB_S_UNWANTEDREASON
//
// Notes:
//
HRESULT CVDCursorPosition::OnFieldChange(IUnknown *pRowset,
									   HROW hRow,
									   ULONG cColumns,
									   ULONG rgColumns[],
									   DBREASON eReason,
									   DBEVENTPHASE ePhase,
									   BOOL fCantDeny)
{
	// make sure rowset is valid
	if (!GetRowsetSource()->IsRowsetValid())
		return S_OK;

	// check for columns
	if (0 == cColumns)
		return S_OK;

	// check for known reasons
	if (eReason != DBREASON_COLUMN_SET && eReason != DBREASON_COLUMN_RECALCULATED)
		return S_OK;

	HRESULT hr = S_OK;

	// send edit mode notification if needed
	if (ePhase == DBEVENTPHASE_OKTODO && m_dwEditMode == CURSOR_DBEDITMODE_NONE)
	{
		// setup notification structures
   		DWORD dwEventWhat = CURSOR_DBEVENT_CURRENT_ROW_DATA_CHANGED |
							CURSOR_DBEVENT_SET_OF_ROWS_CHANGED;

		CURSOR_DBNOTIFYREASON rgReasons[1];
		VariantInit((VARIANT*)&rgReasons[0].arg1);
		VariantInit((VARIANT*)&rgReasons[0].arg2);

    	rgReasons[0].dwReason = CURSOR_DBREASON_EDIT;

		// notify other interested parties of action
		hr = NotifyBefore(dwEventWhat, 1, rgReasons);

		if (hr == S_OK)	
		{
			// notify other interested parties of success
			NotifyAfter(dwEventWhat, 1, rgReasons);

			// temporarily place cursor into edit mode
			m_fTempEditMode = TRUE;
		}
		else
		{
			// notify other interested parties of failure
			NotifyFail(dwEventWhat, 1, rgReasons);
		}
	}
	
	// sent set column notifications
	if (hr == S_OK && (ePhase == DBEVENTPHASE_OKTODO || 
					   ePhase == DBEVENTPHASE_DIDEVENT || 
					   ePhase == DBEVENTPHASE_FAILEDTODO))
	{
		// setup notification structures
		DWORD dwEventWhat = CURSOR_DBEVENT_CURRENT_ROW_DATA_CHANGED;

		CURSOR_DBNOTIFYREASON rgReasons[1];
		VariantInit((VARIANT*)&rgReasons[0].arg1);
		VariantInit((VARIANT*)&rgReasons[0].arg2);

		switch (eReason)
		{
			case DBREASON_COLUMN_SET:
				rgReasons[0].dwReason = CURSOR_DBREASON_SETCOLUMN;
				break;

			case DBREASON_COLUMN_RECALCULATED:
				rgReasons[0].dwReason = CURSOR_DBREASON_RECALC;
				break;
		}

		// get internal column pointers
		ULONG ulColumns = m_pCursorMain->GetColumnsCount();
		CVDRowsetColumn * pColumn = m_pCursorMain->InternalGetColumns();

		for (ULONG ulCol = 0; ulCol < cColumns; ulCol++)
		{
			// determine which column is changing
			for (ULONG ulRSCol = 0; ulRSCol < ulColumns; ulRSCol++)
			{
				if (pColumn[ulRSCol].GetOrdinal() == rgColumns[ulCol])
				{
					rgReasons[0].arg1.vt   = VT_I4;
					rgReasons[0].arg1.lVal = ulRSCol;
				}
			}

			HRESULT hrNotify = S_OK;

			// notify other interested parties
			switch (ePhase)
			{
				case DBEVENTPHASE_OKTODO:
					hrNotify = NotifyBefore(dwEventWhat, 1, rgReasons);
					break;

				case DBEVENTPHASE_DIDEVENT:
					NotifyAfter(dwEventWhat, 1, rgReasons);
					break;

				case DBEVENTPHASE_FAILEDTODO:
					NotifyFail(dwEventWhat, 1, rgReasons);
					break;
			}

			if (hrNotify != S_OK)
				hr = S_FALSE;
		}
	}

	// take cursor out of edit mode if we placed it into that mode (success)
	if (ePhase == DBEVENTPHASE_DIDEVENT && m_fTempEditMode)
	{
		// setup notification structures
   		DWORD dwEventWhat = CURSOR_DBEVENT_CURRENT_ROW_DATA_CHANGED |
							CURSOR_DBEVENT_NONCURRENT_ROW_DATA_CHANGED |
							CURSOR_DBEVENT_SET_OF_ROWS_CHANGED;

		CURSOR_DBNOTIFYREASON rgReasons[1];
		VariantInit((VARIANT*)&rgReasons[0].arg1);
		VariantInit((VARIANT*)&rgReasons[0].arg2);

		rgReasons[0].dwReason   = CURSOR_DBREASON_MODIFIED;
		
		// notify other interested parties of action
		NotifyBefore(dwEventWhat, 1, rgReasons);
		NotifyAfter(dwEventWhat, 1, rgReasons);

		// take out of edit mode
		m_fTempEditMode = FALSE;
	}

	// take cursor out of edit mode if we placed it into that mode (failure)
	if (ePhase == DBEVENTPHASE_FAILEDTODO && m_fTempEditMode)
	{
		// setup notification structures
		DWORD dwEventWhat = CURSOR_DBEVENT_CURRENT_ROW_DATA_CHANGED;

		CURSOR_DBNOTIFYREASON rgReasons[1];
		VariantInit((VARIANT*)&rgReasons[0].arg1);
		VariantInit((VARIANT*)&rgReasons[0].arg2);

		rgReasons[0].dwReason = CURSOR_DBREASON_CANCELUPDATE;

		// notify other interested parties of action
		NotifyBefore(dwEventWhat, 1, rgReasons);
		NotifyAfter(dwEventWhat, 1, rgReasons);

		// take out of edit mode
		m_fTempEditMode = FALSE;
	}

	// reset cache on ending phase
	if (DBEVENTPHASE_FAILEDTODO == ePhase ||
		DBEVENTPHASE_DIDEVENT	== ePhase)
		m_bmCache.Reset();

	return hr;
}

//=--------------------------------------------------------------------------=
// IRowsetNotify OnRowChange
//=--------------------------------------------------------------------------=
// This function is called on the first change to a row, or any whole-row change
//
// Parameters:
//    pRowset       - [in]  the IRowset that is generating the notification
//							(we can ignore this since we are only ever dealing
//							with a single rowset).
//    cRows         - [in]  the count of HROWs in rghRows
//    rghRows       - [in]  an array of HROWs which are changing
//    eReason       - [in]  the kind of action which caused this change
//    ePhase        - [in]  the phase of this notification
//    fCantDeny     - [in]  when this flag is set to TRUE, the consumer cannot
//							veto the event (by returning S_FALSE)
//
// Output:
//    HRESULT - S_OK if successful
//				S_FALSE the event/phase is vetoed
//              DB_S_UNWANTEDPHASE
//              DB_S_UNWANTEDREASON
//
// Notes:
//
HRESULT CVDCursorPosition::OnRowChange(IUnknown *pRowset,
									 ULONG cRows,
									 const HROW rghRows[],
									 DBREASON eReason,
									 DBEVENTPHASE ePhase,
									 BOOL fCantDeny)
{
    // make sure we still have a valid rowset
	if (!(GetRowsetSource()->IsRowsetValid()))
		return S_OK;

	// check for rows
	if (0 == cRows)
		return S_OK;

	// filter notifications
	switch (eReason)
	{
		case DBREASON_ROW_DELETE:
		case DBREASON_ROW_INSERT:
		case DBREASON_ROW_RESYNCH:
		case DBREASON_ROW_UPDATE:
		case DBREASON_ROW_UNDOCHANGE:
		case DBREASON_ROW_UNDOINSERT:
			break;

// the following do not generate notifications
//
//		case DBREASON_ROW_ACTIVATE:
//		case DBREASON_ROW_RELEASE:
//		case DBREASON_ROW_FIRSTCHANGE:
//		case DBREASON_ROW_UNDODELETE:

		default:
			return S_OK;
	}

	// create variables
	DWORD dwEventWhat = 0;
	CURSOR_DBNOTIFYREASON * pReasons = (CURSOR_DBNOTIFYREASON *)g_pMalloc->Alloc(cRows * sizeof(CURSOR_DBNOTIFYREASON));

	if (!pReasons)
		return S_OK;

    memset(pReasons, 0, cRows * sizeof(CURSOR_DBNOTIFYREASON));

	HRESULT hr;
	BOOL fCurrentRow;

	// iterate through supplied rows
	for (ULONG ul = 0; ul < cRows; ul++)
	{
		if (eReason != DBREASON_ROW_UNDOINSERT)
		{
			// check to see if this row is current
			hr = IsSameRowAsCurrent(rghRows[ul], TRUE);

			switch (hr)
			{
				case S_OK:
					fCurrentRow = TRUE;
    				pReasons[ul].arg1 = m_bmCurrent.GetBookmarkVariant();
					break;
				case S_FALSE:
					fCurrentRow = FALSE;
    				pReasons[ul].arg1 = m_bmCache.GetBookmarkVariant();
					break;
				default:
					hr = S_OK;
					goto cleanup;
			}
		}
		else
		{
			// check to see of this row is current add-row
			if (m_dwEditMode == CURSOR_DBEDITMODE_ADD)
				hr = IsSameRowAsNew(rghRows[ul]);
			else
				hr = E_FAIL;

			switch (hr)
			{
				case S_OK:
					fCurrentRow = TRUE;
    				pReasons[ul].arg1 = m_bmAddRow.GetBookmarkVariant();
					break;
				default:
					hr = S_OK;
					goto cleanup;
			}
		}

		// setup variables
		switch (eReason)
		{
			case DBREASON_ROW_DELETE:
				if (fCurrentRow)
					dwEventWhat |=	CURSOR_DBEVENT_CURRENT_ROW_CHANGED |
									CURSOR_DBEVENT_CURRENT_ROW_DATA_CHANGED |
									CURSOR_DBEVENT_SET_OF_ROWS_CHANGED;
				else
					dwEventWhat |=	CURSOR_DBEVENT_SET_OF_ROWS_CHANGED;
				pReasons[ul].dwReason = CURSOR_DBREASON_DELETED;
				break;
			
			case DBREASON_ROW_INSERT:
				if (fCurrentRow)
					dwEventWhat |=	CURSOR_DBEVENT_CURRENT_ROW_CHANGED |
									CURSOR_DBEVENT_SET_OF_ROWS_CHANGED;
				else
					dwEventWhat |=	CURSOR_DBEVENT_SET_OF_ROWS_CHANGED;
				pReasons[ul].dwReason = CURSOR_DBREASON_INSERTED;
				break;

			case DBREASON_ROW_RESYNCH:
				if (fCurrentRow)
					dwEventWhat |=	CURSOR_DBEVENT_CURRENT_ROW_DATA_CHANGED;
				else
					dwEventWhat |=	CURSOR_DBEVENT_NONCURRENT_ROW_DATA_CHANGED;
				pReasons[ul].dwReason = CURSOR_DBREASON_REFRESH;
				break;

			case DBREASON_ROW_UPDATE:
				if (fCurrentRow)
					dwEventWhat |=	CURSOR_DBEVENT_CURRENT_ROW_CHANGED |
									CURSOR_DBEVENT_CURRENT_ROW_DATA_CHANGED |
									CURSOR_DBEVENT_SET_OF_ROWS_CHANGED;
				else
					dwEventWhat |=	CURSOR_DBEVENT_SET_OF_ROWS_CHANGED;
				pReasons[ul].dwReason = CURSOR_DBREASON_MODIFIED;
				break;

			case DBREASON_ROW_UNDOCHANGE:
				if (fCurrentRow)
   					dwEventWhat |=	CURSOR_DBEVENT_CURRENT_ROW_DATA_CHANGED |
									CURSOR_DBEVENT_SET_OF_ROWS_CHANGED;
				else
   					dwEventWhat |=	CURSOR_DBEVENT_NONCURRENT_ROW_DATA_CHANGED |
									CURSOR_DBEVENT_SET_OF_ROWS_CHANGED;
				pReasons[ul].dwReason = CURSOR_DBREASON_MODIFIED;
				break;

			case DBREASON_ROW_UNDOINSERT:
				if (fCurrentRow)
					dwEventWhat	|=	CURSOR_DBEVENT_CURRENT_ROW_DATA_CHANGED;
				pReasons[ul].dwReason = CURSOR_DBREASON_CANCELUPDATE;
				break;
		}
	}

    // notify interested cursor listeners
	hr = SendNotification(ePhase, dwEventWhat, cRows, pReasons);

	// take cursor out of add-mode if we received UNDOINSERT on current add-row
	if (eReason == DBREASON_ROW_UNDOINSERT && ePhase == DBEVENTPHASE_DIDEVENT && hr == S_OK)
	{
		// if acquired, release same-row clone
		if (GetSameRowClone())
			ReleaseSameRowClone();

		// also, release add row if we have one
		if (m_bmAddRow.GetHRow())
			ReleaseAddRow();

		// reset edit mode
		SetEditMode(CURSOR_DBEDITMODE_NONE);

		// reset column updates
		ResetColumnUpdates();
	}

cleanup:
	g_pMalloc->Free(pReasons);

	// reset cache on ending phase
	if (DBEVENTPHASE_FAILEDTODO == ePhase ||
		DBEVENTPHASE_DIDEVENT	== ePhase)
		m_bmCache.Reset();

	return hr;
}

//=--------------------------------------------------------------------------=
// IRowsetNotify OnRowsetChange
//=--------------------------------------------------------------------------=
// This function is called on any change affecting the entire rowset
//
// Parameters:
//    pRowset       - [in]  the IRowset that is generating the notification
//							(we can ignore this since we are only ever dealing
//							with a single rowset).
//    eReason       - [in]  the kind of action which caused this change
//    ePhase        - [in]  the phase of this notification
//    fCantDeny     - [in]  when this flag is set to TRUE, the consumer cannot
//							veto the event (by returning S_FALSE)
//
// Output:
//    HRESULT - S_OK if successful
//				S_FALSE the event/phase is vetoed
//              DB_S_UNWANTEDPHASE
//              DB_S_UNWANTEDREASON
//
// Notes:
//
HRESULT CVDCursorPosition::OnRowsetChange(IUnknown *pRowset,
										DBREASON eReason,
										DBEVENTPHASE ePhase,
										BOOL fCantDeny)
{
	if (!(GetRowsetSource()->IsRowsetValid()))
		return S_OK;

	switch (eReason)
	{
		case DBREASON_ROWSET_RELEASE:
			GetRowsetSource()->SetRowsetReleasedFlag();
			break;
		case DBREASON_ROWSET_FETCHPOSITIONCHANGE:
		{
/*


			What do we do here



			DWORD dwEventWhat = CURSOR_DBEVENT_CURRENT_ROW_CHANGED;
			CURSOR_DBNOTIFYREASON reason;
			memset(&reason, 0, sizeof(CURSOR_DBNOTIFYREASON));
			reason.dwReason		= CURSOR_DBREASON_MOVE;
			reason.arg1			= m_bmCurrent.GetBookmarkVariant();
			VariantInit((VARIANT*)&reason.arg2);
			reason.arg2.vt		= VT_I4;
			// the ICursor spec states that this is the value of dlOffset in
			// iCursorMove::Move. Since we can't get that from the Rowset spec
			// we are setting the value to an arbitrary 1
			reason.arg2.lVal	= 1;	
			return SendNotification(ePhase,	CURSOR_DBEVENT_CURRENT_ROW_CHANGED, 1, &reason);
*/
			break;
		}
	}

    return S_OK;
}

//=--------------------------------------------------------------------------=
// ConnectIRowPositionChange - Connect IRowPositionChange interface
//
HRESULT CVDCursorPosition::ConnectIRowPositionChange()
{
    IConnectionPointContainer * pConnectionPointContainer;

    HRESULT hr = m_pRowPosition->QueryInterface(IID_IConnectionPointContainer, (void**)&pConnectionPointContainer);

    if (FAILED(hr))
        return VD_E_CANNOTCONNECTIROWPOSITIONCHANGE;

    IConnectionPoint * pConnectionPoint;

    hr = pConnectionPointContainer->FindConnectionPoint(IID_IRowPositionChange, &pConnectionPoint);

    if (FAILED(hr))
    {
        pConnectionPointContainer->Release();
        return VD_E_CANNOTCONNECTIROWPOSITIONCHANGE;
    }

    hr = pConnectionPoint->Advise(&m_RowPositionChange, &m_dwAdviseCookie);

    pConnectionPointContainer->Release();
    pConnectionPoint->Release();

    return hr;
}

//=--------------------------------------------------------------------------=
// DisconnectIRowPositionChange - Disconnect IRowPositionChange interface
//
void CVDCursorPosition::DisconnectIRowPositionChange()
{
    IConnectionPointContainer * pConnectionPointContainer;

    HRESULT hr = m_pRowPosition->QueryInterface(IID_IConnectionPointContainer, (void**)&pConnectionPointContainer);

    if (FAILED(hr))
        return;

    IConnectionPoint * pConnectionPoint;

    hr = pConnectionPointContainer->FindConnectionPoint(IID_IRowPositionChange, &pConnectionPoint);

    if (FAILED(hr))
    {
        pConnectionPointContainer->Release();
        return;
    }

    hr = pConnectionPoint->Unadvise(m_dwAdviseCookie);

    if (SUCCEEDED(hr))
        m_dwAdviseCookie = 0;   // clear connection point identifier

    pConnectionPointContainer->Release();
    pConnectionPoint->Release();
}

//=--------------------------------------------------------------------------=
// SendNotification maps the event phases to the corresponding INotifyDBEvents
//					methods
//
HRESULT	CVDCursorPosition::SendNotification(DBEVENTPHASE ePhase,
										  DWORD dwEventWhat,
										  ULONG cReasons,
										  CURSOR_DBNOTIFYREASON rgReasons[])
{
	HRESULT hr = S_OK;
	
	switch (ePhase)
	{
		case DBEVENTPHASE_OKTODO:
			hr = NotifyOKToDo(dwEventWhat, cReasons, rgReasons);
			break;
		case DBEVENTPHASE_ABOUTTODO:
			hr = NotifyAboutToDo(dwEventWhat, cReasons, rgReasons);
			if (S_OK == hr)
				hr = NotifySyncBefore(dwEventWhat, cReasons, rgReasons);
			break;
		case DBEVENTPHASE_SYNCHAFTER:
            // SyncAfter fired from DidEvent for reentrant safety
			break;
		case DBEVENTPHASE_FAILEDTODO:
			NotifyCancel(dwEventWhat, cReasons, rgReasons);
			NotifyFail(dwEventWhat, cReasons, rgReasons);
			break;
		case DBEVENTPHASE_DIDEVENT:
			hr = NotifySyncAfter(dwEventWhat, cReasons, rgReasons);
			if (S_OK == hr)
    		    hr = NotifyDidEvent(dwEventWhat, cReasons, rgReasons);
			break;
	}

	if (CURSOR_DB_S_CANCEL == hr)
		hr = S_FALSE;

	return hr;
}

//=--------------------------------------------------------------------------=
// IUnknown QueryInterface
//
HRESULT CVDCursorPosition::QueryInterface(REFIID riid, void **ppvObjOut)
{
    ASSERT_POINTER(ppvObjOut, IUnknown*)

    if (!ppvObjOut)
        return E_INVALIDARG;

	*ppvObjOut = NULL;

	if (DO_GUIDS_MATCH(riid, IID_IUnknown))
		{
		*ppvObjOut = this;
		AddRef();
		return S_OK;
		}

	return E_NOINTERFACE;
}

//=--------------------------------------------------------------------------=
// IUnknown AddRef (needed to resolve ambiguity)
//
ULONG CVDCursorPosition::AddRef(void)
{
    return CVDNotifier::AddRef();
}

//=--------------------------------------------------------------------------=
// IUnknown Release (needed to resolve ambiguity)
//
ULONG CVDCursorPosition::Release(void)
{
	if (1 == m_dwRefCount)
		Passivate();  // unhook everything including notification sink

	if (1 > --m_dwRefCount)
	{
		if (0 == m_RowPositionChange.GetRefCount())
			delete this;
		return 0;
	}

	return m_dwRefCount;
}

//=--------------------------------------------------------------------------=
// IRowPositionChange methods implemented
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// IRowPositionChange OnRowPositionChange
//=--------------------------------------------------------------------------=
// This function is called on any change affecting the current row
//
// Parameters:
//    eReason       - [in]  the kind of action which caused this change
//    ePhase        - [in]  the phase of this notification
//    fCantDeny     - [in]  when this flag is set to TRUE, the consumer cannot
//							veto the event (by returning S_FALSE)
//
// Output:
//    HRESULT - S_OK if successful
//				S_FALSE the event/phase is vetoed
//              DB_S_UNWANTEDPHASE
//              DB_S_UNWANTEDREASON
//
// Notes:
//
HRESULT CVDCursorPosition::OnRowPositionChange(DBREASON eReason, DBEVENTPHASE ePhase, BOOL fCantDeny)
{
    // return if notification caused by internal set row call
    if (m_fInternalSetRow)
        return S_OK;

	// return if reason has anything to do with chapter changes
	if (eReason == DBREASON_ROWPOSITION_CHAPTERCHANGED)
		return S_OK;

	IRowset * pRowset = GetRowsetSource()->GetRowset();

    // make sure we have valid row position and rowset pointers
    if (!m_pRowPosition || !pRowset || !GetRowsetSource()->IsRowsetValid())
        return S_OK;

	// synchronize hRow after event occurs
	if (ePhase == DBEVENTPHASE_SYNCHAFTER)
	{
		HROW hRow = NULL;
		HCHAPTER hChapterDummy = NULL;
		DBPOSITIONFLAGS dwPositionFlags = NULL;

		// get new current hRow and position flags from row position object
		HRESULT hr = m_pRowPosition->GetRowPosition(&hChapterDummy, &hRow, &dwPositionFlags);

		if (FAILED(hr))
			return hr;

		if (hRow)
		{
			// set new hRow
			SetCurrentHRow(hRow);
			pRowset->ReleaseRows(1, &hRow, NULL, NULL, NULL);
		}
		else
		{
			// set row status to beginning or end
			if (dwPositionFlags == DBPOSITION_BOF)
				SetCurrentRowStatus(VDBOOKMARKSTATUS_BEGINNING);
			else if (dwPositionFlags == DBPOSITION_EOF)
				SetCurrentRowStatus(VDBOOKMARKSTATUS_END);
		}
	}

	CURSOR_DBNOTIFYREASON rgReasons[1];
	
	rgReasons[0].dwReason	= CURSOR_DBREASON_MOVE;
	rgReasons[0].arg1		= m_bmCurrent.GetBookmarkVariant();

	VariantInit((VARIANT*)&rgReasons[0].arg2);

    // notify other interested parties
	return SendNotification(ePhase, CURSOR_DBEVENT_CURRENT_ROW_CHANGED, 1, rgReasons);
}

//=--------------------------------------------------------------------------=
// CVDCursorPosition::CVDRowPositionChange::m_pMainUnknown
//=--------------------------------------------------------------------------=
// this method is used when we're sitting in the private unknown object,
// and we need to get at the pointer for the main unknown.  basically, it's
// a little better to do this pointer arithmetic than have to store a pointer
// to the parent, etc.
//
inline CVDCursorPosition *CVDCursorPosition::CVDRowPositionChange::m_pMainUnknown
(
    void
)
{
    return (CVDCursorPosition *)((LPBYTE)this - offsetof(CVDCursorPosition, m_RowPositionChange));
}

//=--------------------------------------------------------------------------=
// CVDCursorPosition::CVDRowPositionChange::QueryInterface
//=--------------------------------------------------------------------------=
// this is the non-delegating internal QI routine.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
STDMETHODIMP CVDCursorPosition::CVDRowPositionChange::QueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
	if (!ppvObjOut)
		return E_INVALIDARG;

	*ppvObjOut = NULL;

    if (DO_GUIDS_MATCH(riid, IID_IUnknown))
        *ppvObjOut = (IUnknown *)this;
	else
    if (DO_GUIDS_MATCH(riid, IID_IRowPositionChange))
        *ppvObjOut = (IUnknown *)this;

	if (*ppvObjOut)
	{
		m_cRef++;
        return S_OK;
	}

	return E_NOINTERFACE;

}

//=--------------------------------------------------------------------------=
// CVDCursorPosition::CVDRowPositionChange::AddRef
//=--------------------------------------------------------------------------=
// adds a tick to the current reference count.
//
// Output:
//    ULONG        - the new reference count
//
// Notes:
//
ULONG CVDCursorPosition::CVDRowPositionChange::AddRef
(
    void
)
{
    return ++m_cRef;
}

//=--------------------------------------------------------------------------=
// CVDCursorPosition::CVDRowPositionChange::Release
//=--------------------------------------------------------------------------=
// removes a tick from the count, and delets the object if necessary
//
// Output:
//    ULONG         - remaining refs
//
// Notes:
//
ULONG CVDCursorPosition::CVDRowPositionChange::Release
(
    void
)
{
    ULONG cRef = --m_cRef;

    if (!m_cRef && !m_pMainUnknown()->m_dwRefCount)
        delete m_pMainUnknown();

    return cRef;
}

//=--------------------------------------------------------------------------=
// IRowPositionChange OnRowPositionChange
//=--------------------------------------------------------------------------=
// Forward to all CVDCursor objects in our family
//
HRESULT CVDCursorPosition::CVDRowPositionChange::OnRowPositionChange(DBREASON eReason, 
																	 DBEVENTPHASE ePhase, 
																	 BOOL fCantDeny)
{
	return m_pMainUnknown()->OnRowPositionChange(eReason, ePhase, fCantDeny);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\curspos.h ===
//---------------------------------------------------------------------------
// CursorPosition.h : CVDCursorPosition header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------


#ifndef __CVDCURSORPOSITION__
#define __CVDCURSORPOSITION__

#include "bookmark.h"

class CVDRowsetSource;

class CVDCursorPosition : public CVDNotifier
{
protected:
// Construction/Destruction
    CVDCursorPosition();
	virtual ~CVDCursorPosition();

public:
    static HRESULT Create(IRowPosition * pRowPosition,
						  CVDCursorMain * pCursorMain,
						  CVDCursorPosition ** ppCursorPosition,
						  CVDResourceDLL * pResourceDLL);

public:
// Access functions
    CVDCursorMain * GetCursorMain() const {return m_pCursorMain;}
    CVDRowsetSource * GetRowsetSource() const {return m_pCursorMain;}

// Updating
    ICursor * GetSameRowClone() const {return m_pSameRowClone;}
    void SetSameRowClone(ICursor * pSameRowClone) {m_pSameRowClone = pSameRowClone;}
	DWORD GetEditMode() const {return m_dwEditMode;}
	void SetEditMode(DWORD dwEditMode) {m_dwEditMode = dwEditMode;}

// Column updates
    HRESULT CreateColumnUpdates();
    HRESULT ResetColumnUpdates();
    void DestroyColumnUpdates();
    CVDColumnUpdate * GetColumnUpdate(ULONG ulColumn) const;
    void SetColumnUpdate(ULONG ulColumn, CVDColumnUpdate * pColumnUpdate);

// Positioning/reset functions
	void PositionToFirstRow();
	HRESULT SetCurrentHRow(HROW hRowNew);
	void SetCurrentRowStatus(WORD wStatus);
	HRESULT SetAddHRow(HROW hRowNew);

	HRESULT IsSameRowAsCurrent(HROW hRow, BOOL fCacheIfNotSame);
	HRESULT IsSameRowAsNew(HROW hRow);

	HRESULT SetRowPosition(HROW hRow);

// adding/editing functions
#ifndef VD_DONT_IMPLEMENT_ISTREAM
    HRESULT UpdateEntryIDStream(CVDRowsetColumn * pColumn, HROW hRow, IStream * pStream);
#endif //VD_DONT_IMPLEMENT_ISTREAM
    void ReleaseSameRowClone();
    HROW GetEditRow() const;

// bookmarks
	CVDBookmark		    m_bmCurrent;			// current row's bookmark
	CVDBookmark		    m_bmCache;				// used to cache bookmark of last non-current
    CVDBookmark         m_bmAddRow;             // add row's bookmark

protected:
// Data members
	CVDResourceDLL *    m_pResourceDLL;
    CVDCursorMain *     m_pCursorMain;          // backwards pointer to CVDCursorMain
	IRowPosition *		m_pRowPosition;			// row position pointer, used to synchronize current position
    ICursor *           m_pSameRowClone;        // same-row clone used in ICursorUpdateARow::GetColumn() calls
    DWORD               m_dwEditMode;           // current edit mode
    CVDColumnUpdate **  m_ppColumnUpdates;      // column updates
	VARIANT_BOOL		m_fTempEditMode;		// temporary edit mode? (caused by external SetData call)

// IRowPositionChange
	VARIANT_BOOL    m_fConnected;		// have we added ourselves to the RowPosition's connection point
    DWORD           m_dwAdviseCookie;	// connection point identifier
    VARIANT_BOOL	m_fPassivated;		// external ref count went to zero
    VARIANT_BOOL	m_fInternalSetRow;  // OnRowPositionChange caused by internal call

	HRESULT ConnectIRowPositionChange();
	void DisconnectIRowPositionChange();

	void Passivate();

	HRESULT	SendNotification(DBEVENTPHASE ePhase,
							 DWORD dwEventWhat,
							 ULONG cReasons,
							 CURSOR_DBNOTIFYREASON rgReasons[]);
public:
	void ReleaseCurrentRow();
	void ReleaseAddRow();

    //=--------------------------------------------------------------------------=
    // IRowsetNotify methods  - IRowsetNotify is actually implemented off of CVDCursorMain
	//							which forwards each method to the CVDCursorPosition objects
	//							in its family
    //
    STDMETHOD(OnFieldChange)(IUnknown *pRowset, HROW hRow, ULONG cColumns, ULONG rgColumns[], DBREASON eReason,
        DBEVENTPHASE ePhase, BOOL fCantDeny);
    STDMETHOD(OnRowChange)(IUnknown *pRowset, ULONG cRows, const HROW rghRows[], DBREASON eReason, DBEVENTPHASE ePhase,
            BOOL fCantDeny);
    STDMETHOD(OnRowsetChange)(IUnknown *pRowset, DBREASON eReason, DBEVENTPHASE ePhase, BOOL fCantDeny);

public:
    //=--------------------------------------------------------------------------=
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

	//=--------------------------------------------------------------------------=
	// IRowPositionChange method passed up from CVDRowPositionChange implementation
	//
    STDMETHOD(OnRowPositionChange)(DBREASON eReason, DBEVENTPHASE ePhase, BOOL fCantDeny);

private:
    // the inner, private unknown implementation to give to connection point
    // container to avoid circular ref count
    //
    class CVDRowPositionChange : public IRowPositionChange 
	{
	public:
		STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
		STDMETHOD_(ULONG, AddRef)(void);
		STDMETHOD_(ULONG, Release)(void);

		// constructor is remarkably trivial
		//
		CVDRowPositionChange() : m_cRef(0) {}

		ULONG GetRefCount() const {return m_cRef;}

	private:
		CVDCursorPosition *m_pMainUnknown();
		ULONG m_cRef;

		//=--------------------------------------------------------------------------=
		// IRowPositionChange method
		//
	    STDMETHOD(OnRowPositionChange)(DBREASON eReason, DBEVENTPHASE ePhase, BOOL fCantDeny);

    } m_RowPositionChange;

    friend class CVDRowPositionChange;
};


#endif //__CVDCURSORPOSITION__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\cursor.h ===
//---------------------------------------------------------------------------
// Cursor.h : CVDCursor header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------


#ifndef __CVDCURSOR__
#define __CVDCURSOR__

#define VD_ADJUST_VARIANT_TO_BYTE   1
#define VD_ADJUST_VARIANT_TO_WSTR   2
#define VD_ADJUST_VARIANT_TO_STR    3


class CVDCursor : public CVDNotifier,
                  public CVDCursorBase,
                  public ICursorUpdateARow,
                  public ICursorFind,
                  public IEntryID
{
protected:
// Construction/Destruction
	CVDCursor();
	virtual ~CVDCursor();

// Helper functions
    CVDRowsetColumn * GetRowsetColumn(ULONG ulOrdinal);
    CVDRowsetColumn * GetRowsetColumn(CURSOR_DBCOLUMNID& cursorColumnID);
    HRESULT GetOrdinal(CURSOR_DBCOLUMNID& cursorColumnID, ULONG * pulOrdinal);
    DWORD StatusToCursorInfo(DBSTATUS dwStatus);
    DBSTATUS CursorInfoToStatus(DWORD dwCursorInfo);

    HRESULT ValidateCursorBindParams(CURSOR_DBCOLUMNID * pCursorColumnID, CURSOR_DBBINDPARAMS * pCursorBindParams,
        CVDRowsetColumn ** ppRowsetColumn);

    HRESULT ValidateEntryID(ULONG cbEntryID, BYTE * pEntryID, CVDRowsetColumn ** ppColumn, HROW * phRow);
    HRESULT QueryEntryIDInterface(CVDRowsetColumn * pColumn, HROW hRow, DWORD dwFlags, REFIID riid, IUnknown ** ppUnknown);
#ifndef VD_DONT_IMPLEMENT_ISTREAM
    HRESULT CreateEntryIDStream(CVDRowsetColumn * pColumn, HROW hRow, IStream ** ppStream);
#endif //VD_DONT_IMPLEMENT_ISTREAM

    HRESULT MakeAdjustments(ULONG ulBindings, DBBINDING * pBindings, ULONG * pulIndex, ULONG ulTotalBindings,
        HACCESSOR ** prghAdjustAccessors, DWORD ** ppdwAdjustFlags, BOOL fBefore);
    HRESULT ReCreateAccessors(ULONG ulNewCursorBindings, CURSOR_DBCOLUMNBINDING * pNewCursorBindings, DWORD dwFlags);
    void ReleaseAccessorArray(HACCESSOR * rghAccessors);
    void DestroyAccessors();

    HRESULT ReCreateColumns();
    void DestroyColumns();
	HRESULT FilterNewRow(ULONG *pcRowsObtained, HROW *rghrow, HRESULT hr);

	HRESULT UseAdjustments(HROW hRow, BYTE * pData);
    HRESULT FillConsumersBuffer(HRESULT hrFetch,
								  CURSOR_DBFETCHROWS *pFetchParams,
								  ULONG cRowsObtained,
								  HROW * rghRows);
	
	HRESULT FetchAtBookmark(ULONG cbBookmark,
								void *pBookmark,
								LARGE_INTEGER dlOffset,
								CURSOR_DBFETCHROWS *pFetchParams);

    HRESULT InsertNewRow();

    HRESULT GetOriginalColumn(CVDRowsetColumn * pColumn, CURSOR_DBBINDPARAMS * pBindParams);
    HRESULT GetModifiedColumn(CVDColumnUpdate * pColumnUpdate, CURSOR_DBBINDPARAMS * pBindParams);

public:
    static HRESULT Create(CVDCursorPosition * pCursorPosition, CVDCursor ** ppCursor, CVDResourceDLL * pResourceDLL);

// Access functions
    CVDCursorMain * GetCursorMain() const       {return m_pCursorPosition->GetCursorMain();}

    BOOL IsRowsetValid() const                  {return m_pCursorPosition->GetRowsetSource()->IsRowsetValid();}

    IRowset * GetRowset() const                 {return m_pCursorPosition->GetRowsetSource()->GetRowset();}
    IAccessor * GetAccessor() const             {return m_pCursorPosition->GetRowsetSource()->GetAccessor();}
    IRowsetLocate * GetRowsetLocate() const     {return m_pCursorPosition->GetRowsetSource()->GetRowsetLocate();}
    IRowsetScroll * GetRowsetScroll() const     {return m_pCursorPosition->GetRowsetSource()->GetRowsetScroll();}
    IRowsetChange * GetRowsetChange() const     {return m_pCursorPosition->GetRowsetSource()->GetRowsetChange();}
    IRowsetUpdate * GetRowsetUpdate() const     {return m_pCursorPosition->GetRowsetSource()->GetRowsetUpdate();}
    IRowsetFind * GetRowsetFind() const         {return m_pCursorPosition->GetRowsetSource()->GetRowsetFind();}
    IRowsetInfo * GetRowsetInfo() const         {return m_pCursorPosition->GetRowsetSource()->GetRowsetInfo();}
    IRowsetIdentity * GetRowsetIdentity() const {return m_pCursorPosition->GetRowsetSource()->GetRowsetIdentity();}

// Other
    virtual BOOL SupportsScroll() {return (BOOL)m_pCursorPosition->GetRowsetSource()->GetRowsetScroll();}

protected:
// Retrieving data
    HACCESSOR                   m_hAccessor;            // fixed length buffer accessor
    HACCESSOR                   m_hVarHelper;           // variable length buffer accessors helper
    ULONG                       m_ulVarBindings;        // number of variable length buffer bindings
    HACCESSOR *                 m_rghVarAccessors;      // variable length buffer accessors
    HACCESSOR *                 m_rghAdjustAccessors;   // adjusted fixed length buffer accessors
    DWORD *                     m_pdwAdjustFlags;       // adjusted fixed length buffer accessors flags
    CVDRowsetColumn **          m_ppColumns;            // rowset columns associated with current bindings

// Other
    CVDCursorPosition * m_pCursorPosition;				// backwards pointer to CVDCursorPosition
	CVDNotifyDBEventsConnPtCont * m_pConnPtContainer;	// INotifyDBEvent connection points

// overridden virtual functions from CVDNotifier
	HRESULT NotifyFail  (DWORD, ULONG, CURSOR_DBNOTIFYREASON[]);
	HRESULT	NotifyOKToDo    (DWORD, ULONG, CURSOR_DBNOTIFYREASON[]);
	HRESULT NotifySyncBefore(DWORD, ULONG, CURSOR_DBNOTIFYREASON[]);
	HRESULT NotifyAboutToDo (DWORD, ULONG, CURSOR_DBNOTIFYREASON[]);
	HRESULT NotifySyncAfter (DWORD, ULONG, CURSOR_DBNOTIFYREASON[]);
	HRESULT NotifyDidEvent  (DWORD, ULONG, CURSOR_DBNOTIFYREASON[]);
	HRESULT NotifyCancel    (DWORD, ULONG, CURSOR_DBNOTIFYREASON[]);

public:
    //=--------------------------------------------------------------------------=
    // IUnknown methods implemented
    //
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    //=--------------------------------------------------------------------------=
    // ICursor methods implemented
    //
    STDMETHOD(GetColumnsCursor)(REFIID riid, IUnknown **ppvColumnsCursor, ULONG *pcRows);
    STDMETHOD(SetBindings)(ULONG cCol, CURSOR_DBCOLUMNBINDING rgBoundColumns[], ULONG cbRowLength, DWORD dwFlags);
    STDMETHOD(GetNextRows)(LARGE_INTEGER udlRowsToSkip, CURSOR_DBFETCHROWS *pFetchParams);
    STDMETHOD(Requery)(void);

    //=--------------------------------------------------------------------------=
    // ICursorMove methods implemented
    //
    STDMETHOD(Move)(ULONG cbBookmark, void *pBookmark, LARGE_INTEGER dlOffset, CURSOR_DBFETCHROWS *pFetchParams);
    STDMETHOD(GetBookmark)(CURSOR_DBCOLUMNID *pBookmarkType, ULONG cbMaxSize, ULONG *pcbBookmark, void *pBookmark);
    STDMETHOD(Clone)(DWORD dwFlags, REFIID riid, IUnknown **ppvClonedCursor);

    //=--------------------------------------------------------------------------=
    // ICursorScroll methods implemented
    //
    STDMETHOD(Scroll)(ULONG ulNumerator, ULONG ulDenominator, CURSOR_DBFETCHROWS *pFetchParams);
    STDMETHOD(GetApproximatePosition)(ULONG cbBookmark, void *pBookmark, ULONG *pulNumerator, ULONG *pulDenominator);
    STDMETHOD(GetApproximateCount)(LARGE_INTEGER *pudlApproxCount, DWORD *pdwFullyPopulated);

    //=--------------------------------------------------------------------------=
    // ICursorUpdateARow methods
    //
    STDMETHOD(BeginUpdate)(DWORD dwFlags);
    STDMETHOD(SetColumn)(CURSOR_DBCOLUMNID *pcid, CURSOR_DBBINDPARAMS *pBindParams);
    STDMETHOD(GetColumn)(CURSOR_DBCOLUMNID *pcid, CURSOR_DBBINDPARAMS *pBindParams, DWORD *pdwFlags);
    STDMETHOD(GetEditMode)(DWORD *pdwState);
    STDMETHOD(Update)(CURSOR_DBCOLUMNID *pBookmarkType, ULONG *pcbBookmark, void **ppBookmark);
    STDMETHOD(Cancel)(void);
    STDMETHOD(Delete)(void);

    //=--------------------------------------------------------------------------=
    // ICursorFind methods
    //
    STDMETHOD(FindByValues)(ULONG cbBookmark, LPVOID pBookmark, DWORD dwFindFlags, ULONG cValues,
        CURSOR_DBCOLUMNID rgColumns[], CURSOR_DBVARIANT rgValues[], DWORD rgdwSeekFlags[],
        CURSOR_DBFETCHROWS FAR *pFetchParams);

    //=--------------------------------------------------------------------------=
    // IEnrtyID methods
    //
    STDMETHOD(GetInterface)(ULONG cbEntryID, void *pEntryID, DWORD dwFlags, REFIID riid, IUnknown **ppvObj);
};


#endif //__CVDCURSOR__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\cursor.cpp ===
//---------------------------------------------------------------------------
// Cursor.cpp : Cursor implementation
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "Notifier.h"
#include "RSColumn.h"
#include "RSSource.h"
#include "CursMain.h"
#include "ColUpdat.h"
#include "CursPos.h"
#include "enumcnpt.h"
#include "CursBase.h"
#include "Cursor.h"
#include "CursMeta.h"
#include "EntryID.h"
#include "Stream.h"
#include "fastguid.h"
#include "resource.h"
#include "NConnPt.h"
#include "NConnPtC.h"
#include "FromVar.h"
#include "timeconv.h"

SZTHISFILE


//=--------------------------------------------------------------------------=
// CVDCursor - Constructor
//
CVDCursor::CVDCursor()
{
    m_hAccessor             = 0;
    m_hVarHelper            = 0;
    m_ulVarBindings         = 0;
    m_rghVarAccessors       = NULL;
    m_rghAdjustAccessors    = NULL;
    m_pdwAdjustFlags        = NULL;
    m_ppColumns             = NULL;

    m_pCursorPosition       = NULL;
    m_pConnPtContainer      = NULL;

#ifdef _DEBUG
    g_cVDCursorCreated++;
#endif
}

//=--------------------------------------------------------------------------=
// ~CVDCursor - Destructor
//
CVDCursor::~CVDCursor()
{
    DestroyAccessors();
    DestroyColumns();

    if (m_pCursorPosition->GetSameRowClone())
        m_pCursorPosition->ReleaseSameRowClone();

	LeaveFamily();  // leave m_pCursorPosition's notification family

	if (m_pConnPtContainer)
		m_pConnPtContainer->Destroy();

	if (m_pCursorPosition)
		((CVDNotifier*)m_pCursorPosition)->Release();   // release associated cursor position object

#ifdef _DEBUG
    g_cVDCursorDestroyed++;
#endif
}

//=--------------------------------------------------------------------------=
// GetRowsetColumn - Get rowset column from ordinal
//=--------------------------------------------------------------------------=
// This function retrieves the rowset column with the specified rowset ordinal
//
// Parameters:
//    ulOrdinal    - [in]  rowset ordinal
//
// Output:
//    CVDRowsetColumn pointer
//
// Notes:
//
CVDRowsetColumn * CVDCursor::GetRowsetColumn(ULONG ulOrdinal)
{
    CVDRowsetColumn * pRowsetColumn = NULL;

    ULONG ulColumns = GetCursorMain()->GetColumnsCount();
    CVDRowsetColumn * pColumn = GetCursorMain()->InternalGetColumns();

    for (ULONG ulCol = 0; ulCol < ulColumns && !pRowsetColumn; ulCol++)
    {
        if (pColumn->GetOrdinal() == ulOrdinal)
            pRowsetColumn = pColumn;

        pColumn++;
    }

    return pRowsetColumn;
}

//=--------------------------------------------------------------------------=
// GetRowsetColumn - Get rowset column from cursor column identifier
//=--------------------------------------------------------------------------=
// This function retrieves the rowset column associated with the specified
// cursor column identifier
//
// Parameters:
//    cursorColumnID    - [in]  a reference to cursor column identifier
//
// Output:
//    CVDRowsetColumn pointer
//
// Notes:
//
CVDRowsetColumn * CVDCursor::GetRowsetColumn(CURSOR_DBCOLUMNID& cursorColumnID)
{
    CVDRowsetColumn * pRowsetColumn = NULL;

    ULONG ulColumns = GetCursorMain()->GetColumnsCount();
    CVDRowsetColumn * pColumn = GetCursorMain()->InternalGetColumns();

    for (ULONG ulCol = 0; ulCol < ulColumns && !pRowsetColumn; ulCol++)
    {
        if (IsEqualCursorColumnID(cursorColumnID, pColumn->GetCursorColumnID()))
            pRowsetColumn = pColumn;

        pColumn++;
    }

    return pRowsetColumn;
}

//=--------------------------------------------------------------------------=
// GetOrdinal - Get ordinal from cursor column identifier
//=--------------------------------------------------------------------------=
// This function converts a cursor column identifier its ordinal eqivalent
//
// Parameters:
//    cursorColumnID    - [in]  a reference to cursor column identifier
//    pulOrdinal        - [out] a pointer to memory in which to return ordinal
//
// Output:
//    HRESULT - S_OK if successful
//              E_FAIL bad cursor column identifier
//
// Notes:
//
HRESULT CVDCursor::GetOrdinal(CURSOR_DBCOLUMNID& cursorColumnID, ULONG * pulOrdinal)
{
    HRESULT hr = E_FAIL;

    ULONG ulColumns = GetCursorMain()->GetColumnsCount();
    CVDRowsetColumn * pColumn = GetCursorMain()->InternalGetColumns();

    for (ULONG ulCol = 0; ulCol < ulColumns && FAILED(hr); ulCol++)
    {
        if (IsEqualCursorColumnID(cursorColumnID, pColumn->GetCursorColumnID()))
        {
            *pulOrdinal = pColumn->GetOrdinal();
            hr = S_OK;
        }

        pColumn++;
    }

    return hr;
}

//=--------------------------------------------------------------------------=
// StatusToCursorInfo - Get cursor info from rowset status field
//=--------------------------------------------------------------------------=
// This function converts a rowset status to its cursor information field
// eqivalent
//
// Parameters:
//    dwStatus  - [in] rowset status
//
// Output:
//    DWORD - cursor information
//
// Notes:
//    There are more rowset statuses than cursor information values
//
DWORD CVDCursor::StatusToCursorInfo(DBSTATUS dwStatus)
{
    DWORD dwCursorInfo = CURSOR_DB_UNKNOWN;

    switch (dwStatus)
    {
        case DBSTATUS_S_OK:
            dwCursorInfo = CURSOR_DB_NOINFO;
            break;

        case DBSTATUS_E_CANTCONVERTVALUE:
            dwCursorInfo = CURSOR_DB_CANTCOERCE;
            break;

        case DBSTATUS_S_ISNULL:
        	dwCursorInfo = CURSOR_DB_NULL;
            break;

        case DBSTATUS_S_TRUNCATED:
            dwCursorInfo = CURSOR_DB_TRUNCATED;
            break;
    }

    return dwCursorInfo;
}

//=--------------------------------------------------------------------------=
// CursorInfoToStatus - Get rowset status from cursor info field
//=--------------------------------------------------------------------------=
// This function converts a cursor information field to its rowset status
// eqivalent
//
// Parameters:
//    dwInfo  - [in] rowset status
//
// Output:
//    DWORD - cursor information
//
// Notes:
//    This function only converts successful cursor information fields for
//    the purpose of setting data
//
DBSTATUS CVDCursor::CursorInfoToStatus(DWORD dwCursorInfo)
{
    DBSTATUS dwStatus;

    switch (dwCursorInfo)
    {
        case CURSOR_DB_NULL:
            dwStatus = DBSTATUS_S_ISNULL;
            break;

        case CURSOR_DB_EMPTY:
            dwStatus = DBSTATUS_S_ISNULL;
            break;

        case CURSOR_DB_TRUNCATED:
            dwStatus = DBSTATUS_S_TRUNCATED;
            break;

        case CURSOR_DB_NOINFO:
            dwStatus = DBSTATUS_S_OK;
            break;
    }

    return dwStatus;
}

//=--------------------------------------------------------------------------=
// ValidateCursorBindParams - Validate cursor column binding parameters
//=--------------------------------------------------------------------------=
// This function makes sure the specified column binding parameters are
// acceptable and then returns a pointer to the corresponding rowset column
//
// Parameters:
//    pCursorColumnID       - [in]  a pointer to column identifier of the
//                                  column to bind
//    pCursorBindParams     - [in]  a pointer to binding structure
//    ppRowsetColumn        - [out] a pointer to memory in which to return
//                                  a pointer to the rowset column to bind
//
// Output:
//    HRESULT - S_OK if successful
//              CURSOR_DB_E_BADBINDINFO bad binding information
//              CURSOR_DB_E_BADCOLUMNID columnID is not available
//
// Notes:
//
HRESULT CVDCursor::ValidateCursorBindParams(CURSOR_DBCOLUMNID * pCursorColumnID, CURSOR_DBBINDPARAMS * pCursorBindParams,
    CVDRowsetColumn ** ppRowsetColumn)
{
    ASSERT_POINTER(pCursorColumnID, CURSOR_DBCOLUMNID)
    ASSERT_POINTER(pCursorBindParams, CURSOR_DBBINDPARAMS)
    ASSERT_POINTER(ppRowsetColumn, CVDRowsetColumn*)

    // make sure we have all necessary pointers
    if (!pCursorColumnID || !pCursorBindParams || !ppRowsetColumn)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // init out parameter
    *ppRowsetColumn = NULL;

    // make sure column identifier is available
    BOOL fColumnIDAvailable = FALSE;

    DWORD dwCursorType;
    ULONG ulColumns = GetCursorMain()->GetColumnsCount();
    CVDRowsetColumn * pColumns = GetCursorMain()->InternalGetColumns();
    CVDRowsetColumn * pColumn = pColumns;

    // iterate through rowset columns looking for match
    for (ULONG ulCol = 0; ulCol < ulColumns && !fColumnIDAvailable; ulCol++)
    {
        if (IsEqualCursorColumnID(*pCursorColumnID, pColumn->GetCursorColumnID()))
        {
            dwCursorType = pColumn->GetCursorType();
            *ppRowsetColumn = pColumn;
            fColumnIDAvailable = TRUE;
        }

        pColumn++;
    }

    // get out if not found
    if (!fColumnIDAvailable)
    {
        VDSetErrorInfo(IDS_ERR_BADCOLUMNID, IID_ICursorUpdateARow, m_pResourceDLL);
        return CURSOR_DB_E_BADCOLUMNID;
    }

    // make sure caller supplied a maximum length if a default binding was specified
    // for the cursor types CURSOR_DBTYPE_CHARS, CURSOR_DBTYPE_WCHARS or CURSOR_DBTYPE_BYTES
    if (pCursorBindParams->cbMaxLen == CURSOR_DB_NOMAXLENGTH &&
        pCursorBindParams->dwBinding == CURSOR_DBBINDING_DEFAULT)
    {
        if (pCursorBindParams->dwDataType == CURSOR_DBTYPE_CHARS ||
            pCursorBindParams->dwDataType == CURSOR_DBTYPE_WCHARS ||
            pCursorBindParams->dwDataType == CURSOR_DBTYPE_BYTES)
        {
            VDSetErrorInfo(IDS_ERR_BADCURSORBINDINFO, IID_ICursorUpdateARow, m_pResourceDLL);
            return CURSOR_DB_E_BADBINDINFO;
        }
    }

    // check binding bit mask for possible values
    if (pCursorBindParams->dwBinding != CURSOR_DBBINDING_DEFAULT &&
        pCursorBindParams->dwBinding != CURSOR_DBBINDING_VARIANT &&
        pCursorBindParams->dwBinding != CURSOR_DBBINDING_ENTRYID &&
        pCursorBindParams->dwBinding != (CURSOR_DBBINDING_VARIANT | CURSOR_DBBINDING_ENTRYID))
    {
        VDSetErrorInfo(IDS_ERR_BADCURSORBINDINFO, IID_ICursorUpdateARow, m_pResourceDLL);
        return CURSOR_DB_E_BADBINDINFO;
    }

    // check for valid cursor type
    if (!IsValidCursorType(pCursorBindParams->dwDataType))
    {
        VDSetErrorInfo(IDS_ERR_BADCURSORBINDINFO, IID_ICursorUpdateARow, m_pResourceDLL);
        return CURSOR_DB_E_BADBINDINFO;
    }

    // if a variant binding was specified make sure the cursor type is not CURSOR_DBTYPE_CHARS,
    // CURSOR_DBTYPE_WCHARS or CURSOR_DBTYPE_BYTES
    if (pCursorBindParams->dwBinding & CURSOR_DBBINDING_VARIANT)
    {
        if (pCursorBindParams->dwDataType == CURSOR_DBTYPE_CHARS ||
            pCursorBindParams->dwDataType == CURSOR_DBTYPE_WCHARS ||
            pCursorBindParams->dwDataType == CURSOR_DBTYPE_BYTES)
        {
            VDSetErrorInfo(IDS_ERR_BADCURSORBINDINFO, IID_ICursorUpdateARow, m_pResourceDLL);
            return CURSOR_DB_E_BADBINDINFO;
        }
    }

    // if its not a variant binding make sure the cursor type is not CURSOR_DBTYPE_ANYVARIANT
    if (!(pCursorBindParams->dwBinding & CURSOR_DBBINDING_VARIANT) &&
        pCursorBindParams->dwDataType == CURSOR_DBTYPE_ANYVARIANT)
    {
        VDSetErrorInfo(IDS_ERR_BADCURSORBINDINFO, IID_ICursorUpdateARow, m_pResourceDLL);
        return CURSOR_DB_E_BADBINDINFO;
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// ValidateEntryID - Validate entry identifier
//=--------------------------------------------------------------------------=
// This function makes sure the specified enrty identifier is acceptable,
// if it is, then return rowset column and hRow associated with it
//
// Parameters:
//  cbEntryID   - [in]  the size of the entryID
//  pEntryID    - [in]  a pointer to the entryID
//  ppColumn    - [out] a pointer to memory in which to return rowset column pointer
//  phRow       - [out] a pointer to memory in which to return row handle
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//              CURSOR_DB_E_BADENTRYID bad entry identifier
//
HRESULT CVDCursor::ValidateEntryID(ULONG cbEntryID, BYTE * pEntryID, CVDRowsetColumn ** ppColumn, HROW * phRow)
{
    ASSERT_POINTER(pEntryID, BYTE)
    ASSERT_POINTER(ppColumn, CVDRowsetColumn*)
    ASSERT_POINTER(phRow, HROW)

	IRowsetLocate * pRowsetLocate = GetRowsetLocate();

    // make sure we have a valid rowset locate pointer
    if (!pRowsetLocate || !IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_IEntryID, m_pResourceDLL);
        return E_FAIL;
    }

    // make sure we have all necessary pointers
    if (!pEntryID || !ppColumn || !phRow)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_IEntryID, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // init out parameters
    *ppColumn = NULL;
    *phRow = NULL;

    // check length of enrtyID
    if (cbEntryID != sizeof(ULONG) + sizeof(ULONG) + GetCursorMain()->GetMaxBookmarkLen())
    {
        VDSetErrorInfo(IDS_ERR_BADENTRYID, IID_IEntryID, m_pResourceDLL);
        return CURSOR_DB_E_BADENTRYID;
    }

    // extract column ordinal
    ULONG ulOrdinal = *(ULONG*)pEntryID;

    // make sure column ordinal is okay
    BOOL fColumnOrdinalOkay = FALSE;

    ULONG ulColumns = GetCursorMain()->GetColumnsCount();
    CVDRowsetColumn * pColumn = GetCursorMain()->InternalGetColumns();

    // iterate through rowset columns looking for match
    for (ULONG ulCol = 0; ulCol < ulColumns && !fColumnOrdinalOkay; ulCol++)
    {
        if (ulOrdinal == pColumn->GetOrdinal())
            fColumnOrdinalOkay = TRUE;
        else
            pColumn++;
    }

    // if not found, get out
    if (!fColumnOrdinalOkay)
    {
        VDSetErrorInfo(IDS_ERR_BADENTRYID, IID_IEntryID, m_pResourceDLL);
        return CURSOR_DB_E_BADENTRYID;
    }

    // set column pointer
    *ppColumn = pColumn;

    // extract row bookmark
    ULONG cbBookmark = *(ULONG*)(pEntryID + sizeof(ULONG));
    BYTE * pBookmark = (BYTE*)pEntryID + sizeof(ULONG) + sizeof(ULONG);

    // attempt to retrieve hRow from bookmark
    HRESULT hr = pRowsetLocate->GetRowsByBookmark(0, 1, &cbBookmark, (const BYTE**)&pBookmark, phRow, NULL);

    if (FAILED(hr))
        VDSetErrorInfo(IDS_ERR_BADENTRYID, IID_IEntryID, m_pResourceDLL);

    return hr;
}

//=--------------------------------------------------------------------------=
// QueryEntryIDInterface - Get specified interface for entry identifier
//=--------------------------------------------------------------------------=
// This function attempts to get the requested interface from the specified
// column row
//
// Parameters:
//  pColumn     - [in]  rowset column pointer
//  hRow        - [in]  the row handle
//  dwFlags     - [in]  interface specific flags
//  riid        - [in]  interface identifier requested
//  ppUnknown   - [out] a pointer to memory in which to return interface pointer
//
// Output:
//    HRESULT - S_OK if successful
//              E_FAIL error occured
//              E_INVALIDARG bad parameter
//              E_OUTOFMEMORY not enough memory
//              E_NOINTERFACE interface not available
//
HRESULT CVDCursor::QueryEntryIDInterface(CVDRowsetColumn * pColumn, HROW hRow, DWORD dwFlags, REFIID riid,
    IUnknown ** ppUnknown)
{
    ASSERT_POINTER(pColumn, CVDRowsetColumn)
    ASSERT_POINTER(ppUnknown, IUnknown*)

	IRowset * pRowset = GetRowset();
	IAccessor * pAccessor = GetAccessor();

    // make sure we have valid rowset and accessor pointers
    if (!pRowset || !pAccessor || !IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_IEntryID, m_pResourceDLL);
        return E_FAIL;
    }

    // make sure we have all necessay pointers
    if (!pColumn || !ppUnknown)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_IEntryID, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // init out parameters
    *ppUnknown = NULL;

    DBOBJECT object;
    DBBINDING binding;

    // clear out binding
    memset(&binding, 0, sizeof(DBBINDING));

    // create interface binding
    binding.iOrdinal            = pColumn->GetOrdinal();
    binding.pObject             = &object;
    binding.pObject->dwFlags    = dwFlags;
    binding.pObject->iid        = riid;
    binding.dwPart              = DBPART_VALUE;
    binding.dwMemOwner          = DBMEMOWNER_CLIENTOWNED;
    binding.cbMaxLen            = sizeof(IUnknown*);
    binding.wType               = DBTYPE_IUNKNOWN;

    HACCESSOR hAccessor;

    // create interface accessor
    HRESULT hr = pAccessor->CreateAccessor(DBACCESSOR_ROWDATA, 1, &binding, 0, &hAccessor, NULL);

    if (FAILED(hr))
        return E_NOINTERFACE;

    IUnknown * pUnknown = NULL;

    // try to get interface
    hr = pRowset->GetData(hRow, hAccessor, &pUnknown);

    // release interface accessor
    pAccessor->ReleaseAccessor(hAccessor, NULL);

    if (FAILED(hr))
        return E_NOINTERFACE;

    // return pointer
    *ppUnknown = pUnknown;

    return hr;
}

#ifndef VD_DONT_IMPLEMENT_ISTREAM

//=--------------------------------------------------------------------------=
// CreateEntryIDStream - Create stream for entry identifier
//=--------------------------------------------------------------------------=
// This function retrieves supplied column row's data and create a
// stream containing this data
//
// Parameters:
//  pColumn     - [in]  rowset column pointer
//  hRow        - [in]  the row handle
//  ppStream    - [out] a pointer to memory in which to return stream pointer
//
// Output:
//    HRESULT - S_OK if successful
//              E_FAIL error occured
//              E_INVALIDARG bad parameter
//              E_OUTOFMEMORY not enough memory
//
HRESULT CVDCursor::CreateEntryIDStream(CVDRowsetColumn * pColumn, HROW hRow, IStream ** ppStream)
{
    ASSERT_POINTER(pColumn, CVDRowsetColumn)
    ASSERT_POINTER(ppStream, IStream*)

	IRowset * pRowset = GetRowset();
	IAccessor * pAccessor = GetAccessor();

    // make sure we have valid rowset and accessor pointers
    if (!pRowset || !pAccessor || !IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_IEntryID, m_pResourceDLL);
        return E_FAIL;
    }

    // make sure we have all necessay pointers
    if (!pColumn || !ppStream)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_IEntryID, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // init out parameters
    *ppStream = NULL;

    DBBINDING binding;

    // clear out binding
    memset(&binding, 0, sizeof(DBBINDING));

    // create length binding
    binding.iOrdinal    = pColumn->GetOrdinal();
    binding.obLength    = 0;
    binding.dwPart      = DBPART_LENGTH;
    binding.dwMemOwner  = DBMEMOWNER_CLIENTOWNED;
    binding.wType       = DBTYPE_BYTES;

    HACCESSOR hAccessor;

    // create length accessor
    HRESULT hr = pAccessor->CreateAccessor(DBACCESSOR_ROWDATA, 1, &binding, 0, &hAccessor, NULL);

	hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_CREATEACCESSORFAILED, IID_IEntryID, pAccessor, IID_IAccessor, m_pResourceDLL);

    if (FAILED(hr))
        return hr;

    ULONG cbData;

    // get size of data
    hr = pRowset->GetData(hRow, hAccessor, &cbData);

	hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_GETDATAFAILED, IID_IEntryID, pRowset, IID_IRowset, m_pResourceDLL);

    // release length accessor
    pAccessor->ReleaseAccessor(hAccessor, NULL);

    if (FAILED(hr))
        return hr;

    // create value binding
    binding.iOrdinal    = pColumn->GetOrdinal();
    binding.obValue     = 0;
    binding.dwPart      = DBPART_VALUE;
    binding.dwMemOwner  = DBMEMOWNER_CLIENTOWNED;
    binding.cbMaxLen    = cbData;
    binding.wType       = DBTYPE_BYTES;

    // create value accessor
    hr = pAccessor->CreateAccessor(DBACCESSOR_ROWDATA, 1, &binding, 0, &hAccessor, NULL);

	hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_CREATEACCESSORFAILED, IID_IEntryID, pAccessor, IID_IAccessor, m_pResourceDLL);

    if (FAILED(hr))
        return hr;

    // create data buffer
    HGLOBAL hData = GlobalAlloc(GMEM_MOVEABLE | GMEM_NODISCARD, cbData);

    if (!hData)
    {
        // release value accessor
        pAccessor->ReleaseAccessor(hAccessor, NULL);

        VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_IEntryID, m_pResourceDLL);
        return E_OUTOFMEMORY;
    }

    // get pointer to data buffer
    BYTE * pData = (BYTE*)GlobalLock(hData);

    // get data value
    hr = pRowset->GetData(hRow, hAccessor, pData);

    // release pointer to data buffer
    GlobalUnlock(hData);

	hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_GETDATAFAILED, IID_IEntryID, pRowset, IID_IRowset, m_pResourceDLL);

    // release value accessor
    pAccessor->ReleaseAccessor(hAccessor, NULL);

    if (FAILED(hr))
    {
        GlobalFree(hData);
        return hr;
    }

    // create stream containing data
    hr = CreateStreamOnHGlobal(hData, TRUE, ppStream);

    if (FAILED(hr))
        GlobalFree(hData);

    return hr;
}

#endif //VD_DONT_IMPLEMENT_ISTREAM

//=--------------------------------------------------------------------------=
// MakeAdjustments - Make adjustments to fixed length buffer accessor bindings
//=--------------------------------------------------------------------------=
// This function makes adjustments to the fixed length buffer accessor
// bindings, after a call to CreateAccessor fails, to try and make the
// binding more suitable
//
// Parameters:
//    ulBindings            - [in]   number of fixed length buffer bindings
//    pBindings             - [in]   a pointer to fixed length buffer bindings
//    pulIndex              - [in]   a pointer to an array of indices, which
//                                   specify which cursor binding each fixed
//                                   length buffer binding applies
//    ulTotalBindings       - [in]   number of cursor bindings
//    prghAdjustAccessors   - [out]  a pointer to memory in which to return
//                                   a pointer to adjusted fixed length buffer
//                                   accessors
//    ppdwAdjustFlags       - [out]  a pointer to memory in which to return
//                                   a pointer to adjusted fixed length buffer
//                                   accessors flags
//    fBefore               - [in]   a flag which indicated whether this call
//                                   has been made before or after the call
//                                   to CreateAccessor
//
// Output:
//    S_OK - if adjustments were made
//    E_FAIL - failed to make any adjustments
//    E_OUTOFMEMORY - not enough memory
//    E_INVALIDARG - bad parameter
//
// Notes:
//    Specifically, this function can make the following adjustments...
//       (1) Change variant binding byte field -> byte binding          (fails in GetData)
//       (2) Change variant binding date field -> wide string binding   (fails in CreateAccessor)
//       (3) Change variant binding memo field -> string binding        (fails in CreateAccessor)
//
HRESULT CVDCursor::MakeAdjustments(ULONG ulBindings, DBBINDING * pBindings, ULONG * pulIndex, ULONG ulTotalBindings,
    HACCESSOR ** prghAdjustAccessors, DWORD ** ppdwAdjustFlags, BOOL fBefore)
{
    ASSERT_POINTER(pBindings, DBBINDING)
    ASSERT_POINTER(pulIndex, ULONG)
    ASSERT_POINTER(prghAdjustAccessors, HACCESSOR*)
    ASSERT_POINTER(ppdwAdjustFlags, DWORD*)

    IAccessor * pAccessor = GetAccessor();

    // make sure we have a valid accessor pointer
    if (!pAccessor || !IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursor, m_pResourceDLL);
        return E_FAIL;
    }

    // make sure we have all necessary pointers
    if (!pBindings || !pulIndex || !prghAdjustAccessors || !ppdwAdjustFlags)
        return E_INVALIDARG;

    BOOL fWeAllocatedMemory = FALSE;

    // try to get storage for adjusted accessors and flags
    HACCESSOR * rghAdjustAccessors = *prghAdjustAccessors;
    DWORD * pdwAdjustFlags = *ppdwAdjustFlags;

    // if not supplied, then create storage
    if (!rghAdjustAccessors || !pdwAdjustFlags)
    {
        rghAdjustAccessors = new HACCESSOR[ulTotalBindings];
        pdwAdjustFlags = new DWORD[ulTotalBindings];

        // make sure we got the requested memory
        if (!rghAdjustAccessors || !pdwAdjustFlags)
        {
            delete [] rghAdjustAccessors;
            delete [] pdwAdjustFlags;
		    VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
            return E_OUTOFMEMORY;
        }

        // clear adjusted accessors and flags
        memset(rghAdjustAccessors, 0, ulTotalBindings * sizeof(HACCESSOR));
        memset(pdwAdjustFlags, 0, ulTotalBindings * sizeof(DWORD));

        fWeAllocatedMemory = TRUE;
    }

    // initialize variables
    DBBINDING * pBinding = pBindings;
    CVDRowsetColumn * pColumn;
    DBTYPE wType;
    ULONG cbMaxLength;
    DBBINDING binding;
    HRESULT hr;
    HACCESSOR hAccessor;
    HRESULT hrAdjust = E_FAIL;

    // iterate through fixed length buffer bindings
    for (ULONG ulBind = 0; ulBind < ulBindings; ulBind++)
    {
        // first check for a variant binding, where value is to be returned
        if (pBinding->wType == DBTYPE_VARIANT && (pBinding->dwPart & DBPART_VALUE))
        {
            // get rowset column associated with this binding
            pColumn = GetRowsetColumn(pBinding->iOrdinal);

            if (pColumn)
            {
                // get attributes of this column
                wType = pColumn->GetType();
                cbMaxLength = pColumn->GetMaxLength();

                // check for a byte field
                if (fBefore && wType == DBTYPE_UI1)
                {
                    // make adjustments to fixed length buffer binding
                    pBinding->wType = DBTYPE_UI1;

                    // store associated flag
                    pdwAdjustFlags[pulIndex[ulBind]] = VD_ADJUST_VARIANT_TO_BYTE;

                    // we succeeded
                    hrAdjust = S_OK;
                }

                // check for a date field
                if (!fBefore && wType == DBTYPE_DBTIMESTAMP)
                {
                    // clear binding
                    memset(&binding, 0, sizeof(DBBINDING));

                    // create adjusted accessor binding
                    binding.iOrdinal    = pBinding->iOrdinal;
                    binding.dwPart      = DBPART_VALUE;
                    binding.dwMemOwner  = DBMEMOWNER_CLIENTOWNED;
                    binding.cbMaxLen    = 0x7FFFFFFF;
                    binding.wType       = DBTYPE_WSTR;

                    // try to create adjusted accessor
                    hr = pAccessor->CreateAccessor(DBACCESSOR_ROWDATA, 1, &binding, 0, &hAccessor, NULL);

                    if (SUCCEEDED(hr))
                    {
                        // make adjustments to fixed length buffer binding
                        pBinding->obLength  = pBinding->obValue;
                        pBinding->dwPart   &= ~DBPART_VALUE;
                        pBinding->dwPart   |= DBPART_LENGTH;
                        pBinding->wType     = DBTYPE_WSTR;

                        // store adjusted accessor and associated flag
                        rghAdjustAccessors[pulIndex[ulBind]] = hAccessor;
                        pdwAdjustFlags[pulIndex[ulBind]] = VD_ADJUST_VARIANT_TO_WSTR;

                        // we succeeded
                        hrAdjust = S_OK;
                    }
                }

                // check for a memo field
                if (!fBefore && wType == DBTYPE_STR && cbMaxLength >= 0x40000000)
                {
                    // clear binding
                    memset(&binding, 0, sizeof(DBBINDING));

                    // create adjusted accessor binding
                    binding.iOrdinal    = pBinding->iOrdinal;
                    binding.dwPart      = DBPART_VALUE;
                    binding.dwMemOwner  = DBMEMOWNER_CLIENTOWNED;
                    binding.cbMaxLen    = 0x7FFFFFFF;
                    binding.wType       = DBTYPE_STR;

                    // try to create adjusted accessor
                    hr = pAccessor->CreateAccessor(DBACCESSOR_ROWDATA, 1, &binding, 0, &hAccessor, NULL);

                    if (SUCCEEDED(hr))
                    {
                        // make adjustments to fixed length buffer binding
                        pBinding->obLength  = pBinding->obValue;
                        pBinding->dwPart   &= ~DBPART_VALUE;
                        pBinding->dwPart   |= DBPART_LENGTH;
                        pBinding->wType     = DBTYPE_STR;

                        // store adjusted accessor and associated flag
                        rghAdjustAccessors[pulIndex[ulBind]] = hAccessor;
                        pdwAdjustFlags[pulIndex[ulBind]] = VD_ADJUST_VARIANT_TO_STR;

                        // we succeeded
                        hrAdjust = S_OK;
                    }
                }
            }
        }

        pBinding++;
    }

    if (SUCCEEDED(hrAdjust))
    {
        // if we made any adjustments, return accessors and flags
        *prghAdjustAccessors = rghAdjustAccessors;
        *ppdwAdjustFlags = pdwAdjustFlags;
    }
    else if (fWeAllocatedMemory)
    {
        // destroy allocated memory
        delete [] rghAdjustAccessors;
        delete [] pdwAdjustFlags;
    }

    return hrAdjust;
}

//=--------------------------------------------------------------------------=
// ReCreateAccessors - Re-create accessors
//=--------------------------------------------------------------------------=
// This function attempts to recreate accessors based on old and new bindings
//
// Parameters:
//    ulNewCursorBindings   - [in] the number of new cursor column bindings
//    pNewCursorBindings    - [in] an array of new cursor column bindings
//    dwFlags               - [in] a flag that specifies whether to replace the
//                                 existing column bindings or add to them
//
// Output:
//    HRESULT - S_OK if successful
//              E_OUTOFMEMORY not enough memory to create object
//
// Notes:
//
HRESULT CVDCursor::ReCreateAccessors(ULONG ulNewCursorBindings, CURSOR_DBCOLUMNBINDING * pNewCursorBindings, DWORD dwFlags)
{
    IAccessor * pAccessor = GetAccessor();

    // make sure we have a valid accessor pointer
    if (!pAccessor || !IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursor, m_pResourceDLL);
        return E_FAIL;
    }

    ULONG ulOldCursorBindings = 0;
    CURSOR_DBCOLUMNBINDING * pOldCursorBindings = NULL;

    // if we're adding bindings include old bindings
    if (dwFlags == CURSOR_DBCOLUMNBINDOPTS_ADD)
    {
        ulOldCursorBindings = m_ulCursorBindings;
        pOldCursorBindings = m_pCursorBindings;
    }

    // get total binding count (sum of old and new)
    ULONG ulTotalBindings = ulOldCursorBindings + ulNewCursorBindings;

    ULONG * pulIndex = NULL;
    DBBINDING * pBindings = NULL;
    DBBINDING * pHelperBindings = NULL;
    DBBINDING * pVarBindings = NULL;

	if (ulTotalBindings)
	{
		// create storage for new rowset bindings
		pulIndex = new ULONG[ulTotalBindings];
		pBindings = new DBBINDING[ulTotalBindings];
		pHelperBindings = new DBBINDING[ulTotalBindings];
		pVarBindings = new DBBINDING[ulTotalBindings];

		// make sure we got all requested memory
		if (!pulIndex || !pBindings || !pHelperBindings || !pVarBindings)
		{
			delete [] pulIndex;
			delete [] pBindings;
			delete [] pHelperBindings;
			delete [] pVarBindings;
			VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
			return E_OUTOFMEMORY;
		}

		// clear rowset bindings
		memset(pulIndex, 0, ulTotalBindings * sizeof(ULONG));
		memset(pBindings, 0, ulTotalBindings * sizeof(DBBINDING));
		memset(pHelperBindings, 0, ulTotalBindings * sizeof(DBBINDING));
		memset(pVarBindings, 0, ulTotalBindings * sizeof(DBBINDING));
	}

    // set adjustments to null
    HACCESSOR * rghAdjustAccessors = NULL;
    DWORD * pdwAdjustFlags = NULL;

    HRESULT hr;
    WORD wType;
    ULONG ulBindings = 0;
    ULONG ulHelperBindings = 0;
    ULONG ulVarBindings = 0;
    ULONG obVarDataInfo = 0;
    DBBINDING * pBinding = pBindings;
    DBBINDING * pHelperBinding = pHelperBindings;
    DBBINDING * pVarBinding = pVarBindings;
    CURSOR_DBCOLUMNBINDING * pCursorBinding = pOldCursorBindings;
    CVDRowsetColumn * pColumn;
    BOOL fEntryIDBinding;

    // iterate through cursor bindings and set rowset bindings
	for (ULONG ulCol = 0; ulCol < ulTotalBindings; ulCol++)
    {
        // if necessary, switch to new bindings
        if (ulCol == ulOldCursorBindings)
            pCursorBinding = pNewCursorBindings;

        // get rowset column for this binding
        pColumn = GetRowsetColumn(pCursorBinding->columnID);

        // get desired rowset datatype
        wType = CVDRowsetColumn::CursorTypeToType((CURSOR_DBVARENUM)pCursorBinding->dwDataType);

        // set entryID binding flag
        fEntryIDBinding = (pCursorBinding->dwBinding & CURSOR_DBBINDING_ENTRYID);

        // check for datatypes which require variable length buffer
        if (DoesCursorTypeNeedVarData(pCursorBinding->dwDataType))
        {
            // create fixed length buffer binding
            pBinding->iOrdinal      = pColumn->GetOrdinal();
            pBinding->dwMemOwner    = DBMEMOWNER_CLIENTOWNED;
            pBinding->wType         = wType;

            // determine offset to the length part
            if (pCursorBinding->obVarDataLen != CURSOR_DB_NOVALUE)
            {
                pBinding->obLength  = pCursorBinding->obVarDataLen;
                pBinding->dwPart   |= DBPART_LENGTH;
            }

            // determine offset to the status part
            if (pCursorBinding->obInfo != CURSOR_DB_NOVALUE)
            {
                pBinding->obStatus  = pCursorBinding->obInfo;
                pBinding->dwPart   |= DBPART_STATUS;
            }

            // BLOBs always require the length part
            if (pCursorBinding->dwDataType == CURSOR_DBTYPE_BLOB &&
                pCursorBinding->obData != CURSOR_DB_NOVALUE && !fEntryIDBinding)
            {
                pBinding->obLength  = pCursorBinding->obData;
                pBinding->dwPart   |= DBPART_LENGTH;
            }

            // bookmark columns require native type
            if (!pColumn->GetDataColumn())
                pBinding->wType = pColumn->GetType();

            // create variable length helper buffer binding
            if (!pColumn->GetFixed() && !fEntryIDBinding)
            {
                // if column contains variable length data, then create binding
                pHelperBinding->iOrdinal    = pColumn->GetOrdinal();
                pHelperBinding->obLength    = obVarDataInfo;
                pHelperBinding->obStatus    = obVarDataInfo + sizeof(ULONG);
                pHelperBinding->dwPart      = DBPART_LENGTH | DBPART_STATUS;
                pHelperBinding->dwMemOwner  = DBMEMOWNER_CLIENTOWNED;
                pHelperBinding->wType       = wType;
            }

            // always increase offset in helper buffer
            obVarDataInfo += sizeof(ULONG) + sizeof(DBSTATUS);

            // create variable length buffer binding
            pVarBinding->iOrdinal       = pColumn->GetOrdinal();
            pVarBinding->dwPart         = DBPART_VALUE;
            pVarBinding->dwMemOwner     = DBMEMOWNER_CLIENTOWNED;
            pVarBinding->cbMaxLen       = pCursorBinding->cbMaxLen;
            pVarBinding->wType          = wType;

            // adjust for no maximum length
            if (pVarBinding->cbMaxLen == CURSOR_DB_NOMAXLENGTH)
                pVarBinding->cbMaxLen = 0x7FFFFFFF;
        }
        else    // datatype requires only fixed length buffer
        {
            // create fixed length buffer binding
            pBinding->iOrdinal      = pColumn->GetOrdinal();
            pBinding->dwMemOwner    = DBMEMOWNER_CLIENTOWNED;
            pBinding->cbMaxLen      = pCursorBinding->cbMaxLen;
            pBinding->wType         = wType;

            // determine offset to the value part
            if (pCursorBinding->obData != CURSOR_DB_NOVALUE && !fEntryIDBinding)
            {
                pBinding->obValue   = pCursorBinding->obData;
                pBinding->dwPart   |= DBPART_VALUE;
            }

            // determine offset to the length part
            if (pCursorBinding->obVarDataLen != CURSOR_DB_NOVALUE)
            {
                pBinding->obLength  = pCursorBinding->obVarDataLen;
                pBinding->dwPart   |= DBPART_LENGTH;
            }

            // determine offset to the status part
            if (pCursorBinding->obInfo != CURSOR_DB_NOVALUE)
            {
                pBinding->obStatus  = pCursorBinding->obInfo;
                pBinding->dwPart   |= DBPART_STATUS;
            }

            // BYTES always require the length part
            if (pCursorBinding->dwDataType == CURSOR_DBTYPE_BYTES &&
                pCursorBinding->obData != CURSOR_DB_NOVALUE && !fEntryIDBinding)
            {
                pBinding->obLength  = pCursorBinding->obData;
                pBinding->obValue  += sizeof(ULONG);
                pBinding->dwPart   |= DBPART_LENGTH;
            }

            // check for variant binding, in which case ask for variant
            if (pCursorBinding->dwBinding & CURSOR_DBBINDING_VARIANT)
                pBinding->wType = DBTYPE_VARIANT;
        }

        // if any parts needed, increment fixed buffer binding
        if (pBinding->dwPart)
        {
            pulIndex[ulBindings] = ulCol;
            ulBindings++;
            pBinding++;
        }

        // if any parts needed, increment variable buffer helper binding
        if (pHelperBinding->dwPart)
        {
            ulHelperBindings++;
            pHelperBinding++;
        }

        // if any parts needed, increment variable buffer binding count
        if (pVarBinding->dwPart)
        {
            // entryID bindings do not need value part
            if (fEntryIDBinding)
                pVarBinding->dwPart &= ~DBPART_VALUE;

            ulVarBindings++;
        }

        // however, always increment variable buffer binding
        pVarBinding++;

        // get next cursor binding
        pCursorBinding++;
    }

    hr = S_OK;

    // try to create fixed length buffer accessor
    HACCESSOR hAccessor = 0;

    if (ulBindings)
	{
		// make adjustments that can cause failure in GetData
		MakeAdjustments(ulBindings, pBindings, pulIndex, ulTotalBindings, &rghAdjustAccessors, &pdwAdjustFlags, TRUE);

    	hr = pAccessor->CreateAccessor(DBACCESSOR_ROWDATA, ulBindings, pBindings, 0, &hAccessor, NULL);
	}

    if (FAILED(hr))
    {
        // make other known adjustments that can cause CreateAccessor to fail
        hr = MakeAdjustments(ulBindings, pBindings, pulIndex, ulTotalBindings, &rghAdjustAccessors, &pdwAdjustFlags, FALSE);

        if (SUCCEEDED(hr))
            hr = pAccessor->CreateAccessor(DBACCESSOR_ROWDATA, ulBindings, pBindings, 0, &hAccessor, NULL);
    }

    delete [] pulIndex;
    delete [] pBindings;

	hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_CREATEACCESSORFAILED, IID_ICursor, pAccessor, IID_IAccessor, m_pResourceDLL);

    if (FAILED(hr))
    {
        delete [] pHelperBindings;
        delete [] pVarBindings;
        ReleaseAccessorArray(rghAdjustAccessors);
        delete [] rghAdjustAccessors;
        delete [] pdwAdjustFlags;
        return hr;
    }

    // try to create variable length buffer accessors helper
    HACCESSOR hVarHelper = 0;

    if (ulHelperBindings)
    	hr = pAccessor->CreateAccessor(DBACCESSOR_ROWDATA, ulHelperBindings, pHelperBindings, 0, &hVarHelper, NULL);

    delete [] pHelperBindings;

	hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_CREATEACCESSORFAILED, IID_ICursor, pAccessor, IID_IAccessor, m_pResourceDLL);

    if (FAILED(hr))
    {
        pAccessor->ReleaseAccessor(hAccessor, NULL);
        delete [] pVarBindings;
        ReleaseAccessorArray(rghAdjustAccessors);
        delete [] rghAdjustAccessors;
        delete [] pdwAdjustFlags;
        return hr;
    }

    // try to create variable length buffer accessors
    HACCESSOR * rghVarAccessors = NULL;

    if (ulTotalBindings)
    {
        rghVarAccessors = new HACCESSOR[ulTotalBindings];

        if (!rghVarAccessors)
            hr = E_OUTOFMEMORY;
        else
        {
            pVarBinding = pVarBindings;
            memset(rghVarAccessors, 0, ulTotalBindings * sizeof(HACCESSOR));

            // iterate through rowset bindings and create accessor for one which have a part
            for (ULONG ulBind = 0; ulBind < ulTotalBindings && SUCCEEDED(hr); ulBind++)
            {
                if (pVarBinding->dwPart)
	                hr = pAccessor->CreateAccessor(DBACCESSOR_ROWDATA, 1, pVarBinding, 0, &rghVarAccessors[ulBind], NULL);

                pVarBinding++;
            }
        }
    }

    delete [] pVarBindings;

	hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_CREATEACCESSORFAILED, IID_ICursor, pAccessor, IID_IAccessor, m_pResourceDLL);

    if (FAILED(hr))
    {
        if (rghVarAccessors)
        {
            // iterate through rowset bindings and destroy any created accessors
            for (ULONG ulBind = 0; ulBind < ulTotalBindings; ulBind++)
            {
                if (rghVarAccessors[ulBind])
                    pAccessor->ReleaseAccessor(rghVarAccessors[ulBind], NULL);
            }

            delete [] rghVarAccessors;
        }

        pAccessor->ReleaseAccessor(hAccessor, NULL);
        pAccessor->ReleaseAccessor(hVarHelper, NULL);
        ReleaseAccessorArray(rghAdjustAccessors);
        delete [] rghAdjustAccessors;
        delete [] pdwAdjustFlags;
        return hr;
    }

    // destroy old accessors
    DestroyAccessors();

    // store new accessors
    m_hAccessor = hAccessor;
    m_hVarHelper = hVarHelper;
    m_ulVarBindings = ulVarBindings;
    m_rghVarAccessors = rghVarAccessors;
    m_rghAdjustAccessors = rghAdjustAccessors;
    m_pdwAdjustFlags = pdwAdjustFlags;

    return hr;
}

//=--------------------------------------------------------------------------=
// ReleaseAccessorArray - Release all accessors in specified array
//
void CVDCursor::ReleaseAccessorArray(HACCESSOR * rghAccessors)
{
    IAccessor * pAccessor = GetAccessor();

    if (pAccessor && rghAccessors)
    {
        for (ULONG ulBind = 0; ulBind < m_ulCursorBindings; ulBind++)
        {
            if (rghAccessors[ulBind])
            {
                pAccessor->ReleaseAccessor(rghAccessors[ulBind], NULL);
                rghAccessors[ulBind] = NULL;
            }
        }
    }
}

//=--------------------------------------------------------------------------=
// DestroyAccessors - Destroy all rowset accessors
//
void CVDCursor::DestroyAccessors()
{
    IAccessor * pAccessor = GetAccessor();

    if (pAccessor && m_hAccessor)
    {
        pAccessor->ReleaseAccessor(m_hAccessor, NULL);
        m_hAccessor = 0;
    }

    if (pAccessor && m_hVarHelper)
    {
        pAccessor->ReleaseAccessor(m_hVarHelper, NULL);
        m_hVarHelper = 0;
    }

    m_ulVarBindings = 0;

    ReleaseAccessorArray(m_rghVarAccessors);
    delete [] m_rghVarAccessors;
    m_rghVarAccessors = NULL;

    ReleaseAccessorArray(m_rghAdjustAccessors);
    delete [] m_rghAdjustAccessors;
    m_rghAdjustAccessors = NULL;

    delete [] m_pdwAdjustFlags;
    m_pdwAdjustFlags = NULL;
}

//=--------------------------------------------------------------------------=
// ReCreateColumns - Re-create rowset columns associated with current bindings
//
HRESULT CVDCursor::ReCreateColumns()
{
    DestroyColumns();

    if (m_ulCursorBindings)
    {
        m_ppColumns = new CVDRowsetColumn*[m_ulCursorBindings];

        if (!m_ppColumns)
        {
            VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
            return E_OUTOFMEMORY;
        }

        CURSOR_DBCOLUMNBINDING * pCursorBinding = m_pCursorBindings;

        for (ULONG ulBind = 0; ulBind < m_ulCursorBindings; ulBind++)
        {
            m_ppColumns[ulBind] = GetRowsetColumn(pCursorBinding->columnID);
            pCursorBinding++;
        }
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// DestroyColumns - Destroy rowset column pointers
//
void CVDCursor::DestroyColumns()
{
    delete [] m_ppColumns;
    m_ppColumns = NULL;
}

//=--------------------------------------------------------------------------=
// InsertNewRow - Insert a new row and set in cursor position object
//
HRESULT CVDCursor::InsertNewRow()
{
	IRowset * pRowset = GetRowset();
    IAccessor * pAccessor = GetAccessor();
	IRowsetChange * pRowsetChange = GetRowsetChange();

    // make sure we have valid rowset, accessor and change pointers
    if (!pRowset || !pAccessor || !pRowsetChange || !IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_FAIL;
    }

    HACCESSOR hAccessor;

    // create null accessor
    HRESULT hr = pAccessor->CreateAccessor(DBACCESSOR_ROWDATA, 0, NULL, 0, &hAccessor, NULL);

    hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_CREATEACCESSORFAILED, IID_ICursorUpdateARow, pAccessor, IID_IAccessor,
        m_pResourceDLL);

    if (FAILED(hr))
        return hr;

    HROW hRow;

    // insert an empty row using null accessor (set/clear internal insert row flag)
    GetCursorMain()->SetInternalInsertRow(TRUE);
    hr = pRowsetChange->InsertRow(0, hAccessor, NULL, &hRow);
    GetCursorMain()->SetInternalInsertRow(FALSE);

    hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_INSERTROWFAILED, IID_ICursorUpdateARow, pRowsetChange, IID_IRowsetChange,
        m_pResourceDLL);

    // release null accessor
    pAccessor->ReleaseAccessor(hAccessor, NULL);

    if (FAILED(hr))
        return hr;

    // set hRow in cursor position object
    hr = m_pCursorPosition->SetAddHRow(hRow);

    // release our reference on hRow
	pRowset->ReleaseRows(1, &hRow, NULL, NULL, NULL);

    return hr;
}

//=--------------------------------------------------------------------------=
// GetOriginalColumn - Get original column data using same-row clone
//
HRESULT CVDCursor::GetOriginalColumn(CVDRowsetColumn * pColumn, CURSOR_DBBINDPARAMS * pBindParams)
{
    ASSERT_POINTER(pColumn, CVDRowsetColumn)
    ASSERT_POINTER(pBindParams, CURSOR_DBBINDPARAMS)

    // make sure we have all necessary pointers
    if (!pColumn || !pBindParams || !pBindParams->pData)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // get hRow of the row currently being edited
    HROW hRow = m_pCursorPosition->GetEditRow();

    // see if we already have a same-row clone
    ICursor * pSameRowClone = m_pCursorPosition->GetSameRowClone();

    if (!pSameRowClone)
    {
        // if not, create new same-row clone
        HRESULT hr = Clone(CURSOR_DBCLONEOPTS_SAMEROW, IID_ICursor, (IUnknown**)&pSameRowClone);

        if (FAILED(hr))
            return hr;

        // set same-row clone in cursor position object
        m_pCursorPosition->SetSameRowClone(pSameRowClone);
    }

    CURSOR_DBCOLUMNBINDING columnBinding;

    // set common column binding members
    columnBinding.columnID      = pColumn->GetCursorColumnID();
    columnBinding.obData        = CURSOR_DB_NOVALUE;
    columnBinding.cbMaxLen      = pBindParams->cbMaxLen;
    columnBinding.obVarDataLen  = CURSOR_DB_NOVALUE;
    columnBinding.obInfo        = CURSOR_DB_NOVALUE;
    columnBinding.dwBinding     = CURSOR_DBBINDING_DEFAULT;
    columnBinding.dwDataType    = pBindParams->dwDataType;

    // adjust column binding for variable length datatypes
    if (DoesCursorTypeNeedVarData(pBindParams->dwDataType))
    {
        switch (pBindParams->dwDataType)
        {
            case CURSOR_DBTYPE_BLOB:
                columnBinding.dwDataType = CURSOR_DBTYPE_BYTES;
                break;

            case CURSOR_DBTYPE_LPSTR:
                columnBinding.dwDataType = CURSOR_DBTYPE_CHARS;
                break;

            case CURSOR_DBTYPE_LPWSTR:
                columnBinding.dwDataType = CURSOR_DBTYPE_WCHARS;
                break;
        }
    }

    CURSOR_DBFETCHROWS fetchRows;

    // set common fetch rows members
    fetchRows.cRowsRequested    = 1;
    fetchRows.dwFlags           = CURSOR_DBROWFETCH_DEFAULT;
    fetchRows.pVarData          = NULL;
    fetchRows.cbVarData         = 0;

    // retrieve length and/or information field if requested
    if (pBindParams->cbVarDataLen != CURSOR_DB_NOVALUE || pBindParams->dwInfo != CURSOR_DB_NOVALUE)
    {
        // set column binding offsets
        if (pBindParams->cbVarDataLen != CURSOR_DB_NOVALUE)
            columnBinding.obVarDataLen = offsetof(CURSOR_DBBINDPARAMS, cbVarDataLen);

        if (pBindParams->dwInfo != CURSOR_DB_NOVALUE)
            columnBinding.obInfo = offsetof(CURSOR_DBBINDPARAMS, dwInfo);

        // set bindings on same-row clone
        HRESULT hr = pSameRowClone->SetBindings(1, &columnBinding, 0, CURSOR_DBCOLUMNBINDOPTS_REPLACE);

        if (FAILED(hr))
            return hr;

        // set fetch rows buffer
        fetchRows.pData = pBindParams;

        // retrieve length and/or information field from same-row clone
        hr = ((CVDCursor*)pSameRowClone)->FillConsumersBuffer(S_OK, &fetchRows, 1, &hRow);

        if (FAILED(hr))
            return hr;
    }

    // set column binding offsets and bind-type
    columnBinding.obData        = 0;
    columnBinding.obVarDataLen  = CURSOR_DB_NOVALUE;
    columnBinding.obInfo        = CURSOR_DB_NOVALUE;
    columnBinding.dwBinding     = pBindParams->dwBinding;

    // adjust offsets for variable length datatypes
    if (DoesCursorTypeNeedVarData(pBindParams->dwDataType))
    {
        columnBinding.dwBinding = CURSOR_DBBINDING_DEFAULT;

        if (pBindParams->dwBinding & CURSOR_DBBINDING_VARIANT)
        {
            if (pBindParams->dwDataType == CURSOR_DBTYPE_BLOB)
                columnBinding.obVarDataLen = columnBinding.obData;

            columnBinding.obData += sizeof(CURSOR_DBVARIANT);
        }
        else
        {
            switch (pBindParams->dwDataType)
            {
                case CURSOR_DBTYPE_BLOB:
                    columnBinding.obVarDataLen  = columnBinding.obData;
                    columnBinding.obData       += sizeof(ULONG) + sizeof(LPBYTE);
                    break;

                case CURSOR_DBTYPE_LPSTR:
                    columnBinding.obData       += sizeof(LPSTR);
                    break;

                case CURSOR_DBTYPE_LPWSTR:
                    columnBinding.obData       += sizeof(LPWSTR);
                    break;
            }
        }
    }

    // set bindings on same-row clone
    HRESULT hr = pSameRowClone->SetBindings(1, &columnBinding, pBindParams->cbMaxLen, CURSOR_DBCOLUMNBINDOPTS_REPLACE);

    if (FAILED(hr))
        return hr;

    // set fetch rows buffer
    fetchRows.pData = pBindParams->pData;

    // retrieve data value from same-row clone
    hr = ((CVDCursor*)pSameRowClone)->FillConsumersBuffer(S_OK, &fetchRows, 1, &hRow);

    if (FAILED(hr))
        return hr;

    // place data pointers in buffer for variable length datatypes
    if (DoesCursorTypeNeedVarData(pBindParams->dwDataType))
    {
        BYTE * pData = (BYTE*)pBindParams->pData;

        // first check for variant binding
        if (pBindParams->dwBinding & CURSOR_DBBINDING_VARIANT)
        {
            CURSOR_BLOB cursorBlob;
            CURSOR_DBVARIANT * pVariant = (CURSOR_DBVARIANT*)pBindParams->pData;

            switch (pBindParams->dwDataType)
			{
				case CURSOR_DBTYPE_BLOB:
					cursorBlob.cbSize       = *(ULONG*)pVariant;
					cursorBlob.pBlobData    = pData + sizeof(CURSOR_DBVARIANT);
					VariantInit((VARIANT*)pVariant);
					pVariant->vt            = CURSOR_DBTYPE_BLOB;
					pVariant->blob          = cursorBlob;
					break;

				case CURSOR_DBTYPE_LPSTR:
					VariantInit((VARIANT*)pVariant);
					pVariant->vt        = CURSOR_DBTYPE_LPSTR;
					pVariant->pszVal    = (LPSTR)(pData + sizeof(CURSOR_DBVARIANT));
					break;

				case CURSOR_DBTYPE_LPWSTR:
					VariantInit((VARIANT*)pVariant);
					pVariant->vt        = CURSOR_DBTYPE_LPSTR;
					pVariant->pwszVal   = (LPWSTR)(pData + sizeof(CURSOR_DBVARIANT));
					break;
			}
        }
        else // otherwise, default binding
        {
            switch (pBindParams->dwDataType)
            {
                case CURSOR_DBTYPE_BLOB:
                    *(LPBYTE*)(pData + sizeof(ULONG)) = pData + sizeof(ULONG) + sizeof(LPBYTE);
                    break;

                case CURSOR_DBTYPE_LPSTR:
                    *(LPSTR*)pData = (LPSTR)(pData + sizeof(LPSTR));
                    break;

                case CURSOR_DBTYPE_LPWSTR:
                    *(LPWSTR*)pData = (LPWSTR)(pData + sizeof(LPWSTR));
                    break;
            }
        }
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// GetModifiedColumn - Get modified column data from column update object
//
HRESULT CVDCursor::GetModifiedColumn(CVDColumnUpdate * pColumnUpdate, CURSOR_DBBINDPARAMS * pBindParams)
{
    ASSERT_POINTER(pColumnUpdate, CVDColumnUpdate)
    ASSERT_POINTER(pBindParams, CURSOR_DBBINDPARAMS)

    // make sure we have all necessary pointers
    if (!pColumnUpdate || !pBindParams || !pBindParams->pData)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // get source variant
    CURSOR_DBVARIANT varSrc = pColumnUpdate->GetVariant();

    // check for any variant binding
    if (pBindParams->dwDataType == CURSOR_DBTYPE_ANYVARIANT)
        pBindParams->dwDataType = varSrc.vt;

    // determine which type the destination variant should be
    VARTYPE vtDest = (VARTYPE)pBindParams->dwDataType;

    switch (vtDest)
    {
        case CURSOR_DBTYPE_BYTES:
            vtDest = CURSOR_DBTYPE_BLOB;
            break;

        case CURSOR_DBTYPE_CHARS:
        case CURSOR_DBTYPE_WCHARS:
        case CURSOR_DBTYPE_LPSTR:
        case CURSOR_DBTYPE_LPWSTR:
            vtDest = VT_BSTR;
            break;
    }

    HRESULT hr = S_OK;
    CURSOR_DBVARIANT varDest;
    BOOL fVariantCreated = FALSE;

    // init destination variant
    VariantInit((VARIANT*)&varDest);

    // get destination variant
    if (varSrc.vt != vtDest)
    {
        // if the types do not match, then create a variant of the desired type
        hr = VariantChangeType((VARIANT*)&varDest, (VARIANT*)&varSrc, 0, vtDest);
        fVariantCreated = TRUE;
    }
    else
        varDest = varSrc;

    if (FAILED(hr))
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // get pointer to data
    BYTE * pData = (BYTE*)pBindParams->pData;

    // return coerced data
    if (pBindParams->dwBinding & CURSOR_DBBINDING_VARIANT)
    {
        // get pointer to variant data
        CURSOR_DBVARIANT * pVariant = (CURSOR_DBVARIANT*)pData;

        // return variant
        *pVariant = varDest;

        // adjust variant for variable length datatypes
        if (pBindParams->dwDataType == CURSOR_DBTYPE_BLOB)
        {
            pVariant->blob.pBlobData = pData + sizeof(CURSOR_DBVARIANT);
            memcpy(pData + sizeof(CURSOR_DBVARIANT), varDest.blob.pBlobData, varDest.blob.cbSize);
        }
        else if (pBindParams->dwDataType == CURSOR_DBTYPE_LPSTR)
        {
			ULONG cbLength = GET_MBCSLEN_FROMWIDE(varDest.bstrVal);
		    MAKE_MBCSPTR_FROMWIDE(psz, varDest.bstrVal);
            pVariant->pszVal = (LPSTR)(pData + sizeof(CURSOR_DBVARIANT));
		    memcpy(pData + sizeof(CURSOR_DBVARIANT), psz, min(pBindParams->cbMaxLen, cbLength));
        }
        else if (pBindParams->dwDataType == CURSOR_DBTYPE_LPWSTR)
        {
            ULONG cbLength = (lstrlenW(varDest.bstrVal) + 1) * sizeof(WCHAR);
            pVariant->pwszVal = (LPWSTR)(pData + sizeof(CURSOR_DBVARIANT));
            memcpy(pData + sizeof(CURSOR_DBVARIANT), varDest.bstrVal, min(pBindParams->cbMaxLen, cbLength));
        }
        else if (pBindParams->dwDataType == VT_BSTR)
        {
            pVariant->bstrVal = SysAllocString(pVariant->bstrVal);
        }
    }
    else // otherwise, default binding
    {
        // first check for variable length datatypes
        if (pBindParams->dwDataType == CURSOR_DBTYPE_BYTES)
        {
            *(ULONG*)pData = varDest.blob.cbSize;
            memcpy(pData + sizeof(ULONG), varDest.blob.pBlobData, varDest.blob.cbSize);
        }
        else if (pBindParams->dwDataType == CURSOR_DBTYPE_CHARS)
        {
			ULONG cbLength = GET_MBCSLEN_FROMWIDE(varDest.bstrVal);
		    MAKE_MBCSPTR_FROMWIDE(psz, varDest.bstrVal);
		    memcpy(pData, psz, min(pBindParams->cbMaxLen, cbLength));
        }
        else if (pBindParams->dwDataType == CURSOR_DBTYPE_WCHARS)
        {
            ULONG cbLength = (lstrlenW(varDest.bstrVal) + 1) * sizeof(WCHAR);
            memcpy(pData, varDest.bstrVal, min(pBindParams->cbMaxLen, cbLength));
        }
        else if (pBindParams->dwDataType == CURSOR_DBTYPE_BLOB)
        {
            *(ULONG*)pData = varDest.blob.cbSize;
            *(LPBYTE*)(pData + sizeof(ULONG)) = pData + sizeof(ULONG) + sizeof(LPBYTE);
            memcpy(pData + sizeof(ULONG) + sizeof(LPBYTE), varDest.blob.pBlobData, varDest.blob.cbSize);
        }
        else if (pBindParams->dwDataType == CURSOR_DBTYPE_LPSTR)
        {
			ULONG cbLength = GET_MBCSLEN_FROMWIDE(varDest.bstrVal);
		    MAKE_MBCSPTR_FROMWIDE(psz, varDest.bstrVal);
            *(LPSTR*)pData = (LPSTR)(pData + sizeof(LPSTR));
		    memcpy(pData + sizeof(LPSTR), psz, min(pBindParams->cbMaxLen, cbLength));
        }
        else if (pBindParams->dwDataType == CURSOR_DBTYPE_LPWSTR)
        {
            ULONG cbLength = (lstrlenW(varDest.bstrVal) + 1) * sizeof(WCHAR);
            *(LPWSTR*)pData = (LPWSTR)(pData + sizeof(LPWSTR));
            memcpy(pData + sizeof(LPWSTR), varDest.bstrVal, min(pBindParams->cbMaxLen, cbLength));
        }
        else // fixed length datatypes
        {
            ULONG cbLength = CVDCursorBase::GetCursorTypeLength(pBindParams->dwDataType, 0);
            memcpy(pData, &varDest.cyVal, cbLength);
        }
    }

    // if created, destroy variant
    if (fVariantCreated)
        VariantClear((VARIANT*)&varDest);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// Create - Create cursor object
//=--------------------------------------------------------------------------=
// This function creates and initializes a new cursor object
//
// Parameters:
//    pCursorPosition   - [in]  backwards pointer to CVDCursorPosition object
//    ppCursor          - [out] a pointer in which to return pointer to cursor object
//    pResourceDLL      - [in]  a pointer which keeps track of resource DLL
//
// Output:
//    HRESULT - S_OK if successful
//              E_OUTOFMEMORY not enough memory to create object
//
// Notes:
//
HRESULT CVDCursor::Create(CVDCursorPosition * pCursorPosition, CVDCursor ** ppCursor, CVDResourceDLL * pResourceDLL)
{
    ASSERT_POINTER(pCursorPosition, CVDCursorPosition)
    ASSERT_POINTER(ppCursor, CVDCursor*)
    ASSERT_POINTER(pResourceDLL, CVDResourceDLL)

    if (!pCursorPosition || !ppCursor)
        return E_INVALIDARG;

    *ppCursor = NULL;

    CVDCursor * pCursor = new CVDCursor();

    if (!pCursor)
        return E_OUTOFMEMORY;

	// create connection point container
    HRESULT hr = CVDNotifyDBEventsConnPtCont::Create(pCursor, &pCursor->m_pConnPtContainer);

	if (FAILED(hr))
	{
		delete pCursor;
		return hr;
	}

    ((CVDNotifier*)pCursorPosition)->AddRef();  // add reference to associated cursor position object

    pCursor->m_pCursorPosition = pCursorPosition;
    pCursor->m_pResourceDLL = pResourceDLL;

	// add to pCursorPosition's notification family
	pCursor->JoinFamily(pCursorPosition);

    *ppCursor = pCursor;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// IUnknown methods implemented
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// IUnknown QueryInterface
//
HRESULT CVDCursor::QueryInterface(REFIID riid, void **ppvObjOut)
{
    ASSERT_POINTER(ppvObjOut, IUnknown*)

    if (!ppvObjOut)
        return E_INVALIDARG;

    *ppvObjOut = NULL;

    switch (riid.Data1)
    {
        QI_INTERFACE_SUPPORTED_IF(this, ICursorUpdateARow, GetRowsetChange());
        QI_INTERFACE_SUPPORTED_IF(this, ICursorFind, GetRowsetFind());
        QI_INTERFACE_SUPPORTED(this, IEntryID);
        QI_INTERFACE_SUPPORTED(m_pConnPtContainer, IConnectionPointContainer);
    }

    if (NULL == *ppvObjOut)
        return CVDCursorBase::QueryInterface(riid, ppvObjOut);

    CVDNotifier::AddRef();

    return S_OK;
}

//=--------------------------------------------------------------------------=
// IUnknown AddRef (this override is needed to instantiate class)
//
ULONG CVDCursor::AddRef(void)
{
    return CVDNotifier::AddRef();
}

//=--------------------------------------------------------------------------=
// IUnknown Release (this override is needed to instantiate class)
//
ULONG CVDCursor::Release(void)
{
    return CVDNotifier::Release();
}

//=--------------------------------------------------------------------------=
// ICursor methods implemented
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// ICursor GetColumnsCursor
//=--------------------------------------------------------------------------=
// Creates a cursor containing information about the current cursor
//
// Parameters:
//    riid              - [in]  the interface ID to which to return a pointer
//    ppvColumnsCursor  - [out] a pointer to memory in which to return the
//                              interface pointer
//    pcRows            - [out] a pointer to memory in which to return the
//                              number of rows in the metadata cursor
//
// Output:
//    HRESULT - S_OK if successful
//              E_FAIL can't create cursor
//              E_INVALIDARG bad parameter
//              E_OUTOFMEMORY not enough memory
//              E_NOINTERFACE interface not available
//
// Notes:
//
HRESULT CVDCursor::GetColumnsCursor(REFIID riid, IUnknown **ppvColumnsCursor, ULONG *pcRows)
{
    ASSERT_POINTER(ppvColumnsCursor, IUnknown*)
    ASSERT_NULL_OR_POINTER(pcRows, ULONG)

    if (!IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursor, m_pResourceDLL);
        return E_FAIL;
    }

    if (!ppvColumnsCursor)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursor, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // init out parameters
    *ppvColumnsCursor = NULL;

    if (pcRows)
        *pcRows = 0;

    // make sure caller asked for an available interface
    if (riid != IID_IUnknown && riid != IID_ICursor && riid != IID_ICursorMove && riid != IID_ICursorScroll)
    {
        VDSetErrorInfo(IDS_ERR_NOINTERFACE, IID_ICursor, m_pResourceDLL);
        return E_NOINTERFACE;
    }

    // create metadata cursor
    CVDMetadataCursor * pMetadataCursor;

    ULONG ulColumns = GetCursorMain()->GetColumnsCount();
    CVDRowsetColumn * pColumns = GetCursorMain()->InternalGetColumns();

    ULONG ulMetaColumns = GetCursorMain()->GetMetaColumnsCount();
    CVDRowsetColumn * pMetaColumns = GetCursorMain()->InternalGetMetaColumns();
	
	if (!GetCursorMain()->IsColumnsRowsetSupported())
		ulMetaColumns -= VD_COLUMNSROWSET_MAX_OPT_COLUMNS;

    HRESULT hr = CVDMetadataCursor::Create(ulColumns,
											pColumns,
											ulMetaColumns,
											pMetaColumns,
											&pMetadataCursor,
											m_pResourceDLL);

    if (FAILED(hr)) // the only reason for failing here is an out of memory condition
    {
        VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
        return hr;
    }

    *ppvColumnsCursor = (ICursor*)pMetadataCursor;

    if (pcRows)
        *pcRows = ulColumns;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// ICursor SetBindings
//=--------------------------------------------------------------------------=
// Replaces the existing column bindings or adds new column bindings to the
// existing ones
//
// Parameters:
//    cCol              - [in] the number of columns to bind
//    rgBoundColumns    - [in] an array of column bindings, one for each
//                             column for which data is to be returned
//    cbRowLength       - [in] the number of bytes of inline memory in a
//                             single row of data
//    dwFlags           - [in] a flag that specifies whether to replace the
//                             existing column bindings or add to them
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//              E_OUTOFMEMORY not enough memory
//              CURSOR_DB_E_BADBINDINFO bad binding information
//              CURSOR_DB_E_COLUMNUNAVAILABLE columnID is not available
//              CURSOR_DB_E_ROWTOOSHORT cbRowLength was less than the minumum (and not zero)
//
// Notes:
//
HRESULT CVDCursor::SetBindings(ULONG cCol, CURSOR_DBCOLUMNBINDING rgBoundColumns[], ULONG cbRowLength, DWORD dwFlags)
{
    ASSERT_NULL_OR_POINTER(rgBoundColumns, CURSOR_DBCOLUMNBINDING)

    if (!IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursor, m_pResourceDLL);
        return E_FAIL;
    }

    if (!cCol && dwFlags == CURSOR_DBCOLUMNBINDOPTS_ADD)
        return S_OK;

    if (cCol && !rgBoundColumns)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursor, m_pResourceDLL);
        return E_INVALIDARG;
    }

    if (dwFlags != CURSOR_DBCOLUMNBINDOPTS_REPLACE && dwFlags != CURSOR_DBCOLUMNBINDOPTS_ADD)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursor, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // make sure the bindings are okay
    ULONG ulColumns = GetCursorMain()->GetColumnsCount();
    CVDRowsetColumn * pColumns = GetCursorMain()->InternalGetColumns();

    ULONG cbNewRowLength;
    ULONG cbNewVarRowLength;

    HRESULT hr = ValidateCursorBindings(ulColumns, pColumns, cCol, rgBoundColumns, cbRowLength, dwFlags,
        &cbNewRowLength, &cbNewVarRowLength);

    if (SUCCEEDED(hr))
    {
        // if so, then try to create new accessors
        hr = ReCreateAccessors(cCol, rgBoundColumns, dwFlags);

        if (SUCCEEDED(hr))
        {
            // if all is okay, then set bindings in cursor
            hr = CVDCursorBase::SetBindings(cCol, rgBoundColumns, cbRowLength, dwFlags);

            if (SUCCEEDED(hr))
            {
                // store new row lengths computed during validation
                m_cbRowLength = cbNewRowLength;
                m_cbVarRowLength = cbNewVarRowLength;

                // recreate column pointers
                hr = ReCreateColumns();
            }
        }
    }

    return hr;
}

//=--------------------------------------------------------------------------=
// FilterNewRow - Filter addrow from fetch
//=--------------------------------------------------------------------------=
// This function determines if the last row fetch was an addrow, in which case
// it releases and removes this row from the block of fetched hRows
//
// Parameters:
//    pcRowsObtained    - [in/out] a pointer to the number of hRows
//    rghRows           - [in/out] an array of nRows fetched
//    hr				- [in]     result of fetch
//
// Output:
//    HRESULT - E_FAIL rowset is invalid
//              E_INVALIDARG bad parameter
//              DB_E_BADSTARTPOSITION no rows fetched
//              DB_S_ENDOFROWSET reached end of rowset
//
// Notes:
//    This function was added to assist in filtering out of add-rows which 
//    appear as part of the underlying rowset, however should not appear as 
//    part of the implemeted cursor.
//
HRESULT CVDCursor::FilterNewRow(ULONG * pcRowsObtained, HROW * rghRows, HRESULT hr)
{
    ASSERT_POINTER(pcRowsObtained, ULONG)
    ASSERT_NULL_OR_POINTER(rghRows, HROW)

	IRowset * pRowset = GetRowset();

    // make sure we have a valid rowset pointer
    if (!pRowset || !IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursor, m_pResourceDLL);
        return E_FAIL;
    }

    // make sure we have necessary pointers
    if (!pcRowsObtained || *pcRowsObtained && !rghRows)
        return E_INVALIDARG;

	if (*pcRowsObtained == 0)
		return hr;

    // detemine if last row fetched is an addrow
	if (GetCursorMain()->IsSameRowAsNew(rghRows[*pcRowsObtained - 1]))
	{
		// if so, release hRow
		pRowset->ReleaseRows(1, &rghRows[*pcRowsObtained - 1], NULL, NULL, NULL);

		// decrement fetch count
        *pcRowsObtained -= 1;

        // return appropriate result
		return *pcRowsObtained == 0 ? DB_E_BADSTARTPOSITION : DB_S_ENDOFROWSET;
	}

	return hr;
}

//=--------------------------------------------------------------------------=
// ICursor GetNextRows
//=--------------------------------------------------------------------------=
// Fetches the specified number of rows starting with the row after the
// current one
//
// Parameters:
//    udlRowsToSkip     - [in]      the number of rows to skip before fetching
//    pFetchParams      - [in, out] a pointer to fetch rows structure
//
// Output:
//    HRESULT - S_OK if successful
//              E_FAIL rowset is invalid
//              CURSOR_DB_S_ENDOFCURSOR reached end of the cursor
//
// Notes:
//
HRESULT CVDCursor::GetNextRows(LARGE_INTEGER udlRowsToSkip, CURSOR_DBFETCHROWS *pFetchParams)
{
    ASSERT_NULL_OR_POINTER(pFetchParams, CURSOR_DBFETCHROWS)

    if (!IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursor, m_pResourceDLL);
        return E_FAIL;
    }

    // return if caller doesn't supply fetch rows structure
    if (!pFetchParams)
        return S_OK;

    // vaildate fetch params (implemented on CVDCursorBase
	HRESULT hr = ValidateFetchParams(pFetchParams, IID_ICursor);

    // return if fetch params are invalid
	if (FAILED(hr))
		return hr;

    // return if caller didn't ask for any rows
    if (!pFetchParams->cRowsRequested)
        return S_OK;

    HRESULT hrFetch;
    IRowset * pRowset = GetRowset();

    // notify other interested parties
   	DWORD dwEventWhat = CURSOR_DBEVENT_CURRENT_ROW_CHANGED;
	CURSOR_DBNOTIFYREASON rgReasons[1];
	
	rgReasons[0].dwReason	= CURSOR_DBREASON_MOVE;
	rgReasons[0].arg1		= m_pCursorPosition->m_bmCurrent.GetBookmarkVariant();

	VariantInit((VARIANT*)&rgReasons[0].arg2);
	rgReasons[0].arg2.vt		= VT_I8;
	rgReasons[0].arg2.cyVal.Lo	= udlRowsToSkip.LowPart;
	rgReasons[0].arg2.cyVal.Hi	= udlRowsToSkip.HighPart;

	hrFetch = m_pCursorPosition->NotifyBefore(dwEventWhat, 1, rgReasons);

    // make sure action was not cancelled
    if (hrFetch != S_OK)
    {
        VDSetErrorInfo(IDS_ERR_ACTIONCANCELLED, IID_ICursor, m_pResourceDLL);
        return E_FAIL;
    }

	// make sure that an update is not already in progress
	if (m_pCursorPosition->GetEditMode() != CURSOR_DBEDITMODE_NONE)
	{
	    m_pCursorPosition->NotifyFail(dwEventWhat, 1, rgReasons);
        VDSetErrorInfo(IDS_ERR_UPDATEINPROGRESS, IID_ICursor, m_pResourceDLL);
		return CURSOR_DB_E_UPDATEINPROGRESS;
	}

    ULONG cRowsObtained = 0;
    HROW * rghRows = NULL;

	BYTE bSpecialBM;
	ULONG cbBookmark;
	BYTE * pBookmark;
	switch (m_pCursorPosition->m_bmCurrent.GetStatus())
	{
		case VDBOOKMARKSTATUS_BEGINNING:
			cbBookmark			= sizeof(BYTE);
			bSpecialBM			= DBBMK_FIRST;
			pBookmark			= &bSpecialBM;
			break;

		case VDBOOKMARKSTATUS_END:
			m_pCursorPosition->NotifyFail(dwEventWhat, 1, rgReasons);
			return CURSOR_DB_S_ENDOFCURSOR;

		case VDBOOKMARKSTATUS_CURRENT:
			cbBookmark	= m_pCursorPosition->m_bmCurrent.GetBookmarkLen();
			pBookmark	= m_pCursorPosition->m_bmCurrent.GetBookmark();
            udlRowsToSkip.LowPart++;
			break;

		default:
			m_pCursorPosition->NotifyFail(dwEventWhat, 1, rgReasons);
			ASSERT_(FALSE);
		    VDSetErrorInfo(IDS_ERR_INVALIDBMSTATUS, IID_ICursor, m_pResourceDLL);
			return E_FAIL;
	}

	hrFetch = GetRowsetLocate()->GetRowsAt(0, 0, cbBookmark, pBookmark,
										udlRowsToSkip.LowPart,
										pFetchParams->cRowsRequested,
										&cRowsObtained, &rghRows);

    hrFetch = FilterNewRow(&cRowsObtained, rghRows, hrFetch);

    if (S_OK != hrFetch)
		hrFetch = VDMapRowsetHRtoCursorHR(hrFetch, IDS_ERR_GETROWSATFAILED, IID_ICursor, GetRowsetLocate(), IID_IRowsetLocate, m_pResourceDLL);

    if FAILED(hrFetch)
	{
		if (cRowsObtained)
		{
			// release hRows and associated memory
			pRowset->ReleaseRows(cRowsObtained, rghRows, NULL, NULL, NULL);
			g_pMalloc->Free(rghRows);
		}
		m_pCursorPosition->NotifyFail(dwEventWhat, 1, rgReasons);
        return hrFetch;
	}

	if (cRowsObtained)
	{
		HRESULT hrMove = S_OK;

		// if got all rows requested then set current position to last row retrieved
		if (SUCCEEDED(hrFetch)	&&
			cRowsObtained == pFetchParams->cRowsRequested)
			hrMove = m_pCursorPosition->SetRowPosition(rghRows[cRowsObtained - 1]);

        // only do this if succeeded
		if (SUCCEEDED(hrMove))
		{
			// fill consumers buffer
			hrFetch = FillConsumersBuffer(hrFetch, pFetchParams, cRowsObtained, rghRows);

			// if got all rows requested then set current position to last row retrieved (internally)
			if (SUCCEEDED(hrFetch)	&&
				cRowsObtained == pFetchParams->cRowsRequested)
				m_pCursorPosition->SetCurrentHRow(rghRows[cRowsObtained - 1]);
		}

		// release hRows and associated memory
		pRowset->ReleaseRows(cRowsObtained, rghRows, NULL, NULL, NULL);
		g_pMalloc->Free(rghRows);

		// report failure
		if (FAILED(hrMove))
		{
			cRowsObtained = 0;
			hrFetch = E_FAIL;
		}
	}

	if (SUCCEEDED(hrFetch)	&&
		cRowsObtained < pFetchParams->cRowsRequested)
		m_pCursorPosition->SetCurrentRowStatus(VDBOOKMARKSTATUS_END);

	if SUCCEEDED(hrFetch)
	{
		rgReasons[0].arg1		= m_pCursorPosition->m_bmCurrent.GetBookmarkVariant();
		m_pCursorPosition->NotifyAfter(dwEventWhat, 1, rgReasons);
	}
	else
		m_pCursorPosition->NotifyFail(dwEventWhat, 1, rgReasons);

    return hrFetch;
}

//=--------------------------------------------------------------------------=
// UseAdjustments - Use adjustments to fix-up returned data
//=--------------------------------------------------------------------------=
// This uses adjustments to fix-up returned data, see MakeAdjustments function
//
// Parameters:
//    hRow      - [in]   row handle
//    pData     - [in]   a pointer to data
//
// Output:
//    S_OK - if successful
//    E_INVALIDARG - bad parameter
//    E_OUTOFMEMORY - not enough memory
//
// Notes:
//
HRESULT CVDCursor::UseAdjustments(HROW hRow, BYTE * pData)
{
    ASSERT_POINTER(m_rghAdjustAccessors, HACCESSOR)
    ASSERT_POINTER(m_pdwAdjustFlags, DWORD)
    ASSERT_POINTER(pData, BYTE)

	IRowset * pRowset = GetRowset();

    // make sure we have a valid rowset pointer
    if (!pRowset || !IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursor, m_pResourceDLL);
        return E_FAIL;
    }

    // make sure we have all neccessary pointers
    if (!m_rghAdjustAccessors || !m_pdwAdjustFlags || !pData)
        return E_INVALIDARG;

    // iterate through cursor bindings, checking for adjustments
    for (ULONG ulBind = 0; ulBind < m_ulCursorBindings; ulBind++)
    {
        // check for variant binding byte field -> byte binding
        if (m_pdwAdjustFlags[ulBind] == VD_ADJUST_VARIANT_TO_BYTE)
        {
            // get variant pointer
            VARIANT * pVariant = (VARIANT*)(pData + m_pCursorBindings[ulBind].obData);

            // extract byte
            BYTE value = *(BYTE*)pVariant;

            // init byte variant
            VariantInit(pVariant);

            // fix-up returned data
            pVariant->vt = VT_UI1;
            pVariant->bVal = value;
        }

        // check for variant binding date field -> wide string binding
        if (m_pdwAdjustFlags[ulBind] == VD_ADJUST_VARIANT_TO_WSTR)
        {
            // get variant pointer
            VARIANT * pVariant = (VARIANT*)(pData + m_pCursorBindings[ulBind].obData);

            // extract length of string
            ULONG ulLength = *(ULONG*)pVariant;

            // place length field in proper place, if originally requested
            if (m_pCursorBindings[ulBind].obVarDataLen != CURSOR_DB_NOVALUE)
                *(ULONG*)(pData + m_pCursorBindings[ulBind].obVarDataLen) = ulLength;

            // init string variant
            VariantInit(pVariant);

            // create storage for string
            BSTR bstr = SysAllocStringByteLen(NULL, ulLength);

            if (!bstr)
            {
                VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
                return E_OUTOFMEMORY;
            }

            // clear wide string
            memset(bstr, 0, ulLength);

            HRESULT hr = S_OK;

            // get memo string value
            if (ulLength)
			{
                hr = pRowset->GetData(hRow, m_rghAdjustAccessors[ulBind], bstr);

				// ignore these return values
				if (hr == DB_S_ERRORSOCCURRED || hr == DB_E_ERRORSOCCURRED)
					hr = S_OK;
			}

            if (SUCCEEDED(hr))
            {
                // fix-up returned data
                pVariant->vt = VT_BSTR;
                pVariant->bstrVal = bstr;
            }
            else
                SysFreeString(bstr);
        }

        // check for variant binding memo field -> string binding
        if (m_pdwAdjustFlags[ulBind] == VD_ADJUST_VARIANT_TO_STR)
        {
            // get variant pointer
            VARIANT * pVariant = (VARIANT*)(pData + m_pCursorBindings[ulBind].obData);

            // extract length of string
            ULONG ulLength = *(ULONG*)pVariant;

            // place length field in proper place, if originally requested
            if (m_pCursorBindings[ulBind].obVarDataLen != CURSOR_DB_NOVALUE)
                *(ULONG*)(pData + m_pCursorBindings[ulBind].obVarDataLen) = ulLength;

            // init string variant
            VariantInit(pVariant);

            // create temporary string buffer
            CHAR * pszBuffer = new CHAR[ulLength + 1];

            if (!pszBuffer)
            {
                VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
                return E_OUTOFMEMORY;
            }

            // clear string buffer
            memset(pszBuffer, 0, ulLength + 1);

            HRESULT hr = S_OK;

            // get memo string value
            if (ulLength)
			{
                hr = pRowset->GetData(hRow, m_rghAdjustAccessors[ulBind], pszBuffer);

				// ignore these return values
				if (hr == DB_S_ERRORSOCCURRED || hr == DB_E_ERRORSOCCURRED)
					hr = S_OK;
			}

            if (SUCCEEDED(hr))
            {
                // fix-up returned data
                pVariant->vt = VT_BSTR;
                pVariant->bstrVal = BSTRFROMANSI(pszBuffer);
            }

            delete [] pszBuffer;
        }
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// FillConsumersBuffer
//=--------------------------------------------------------------------------=
// Fills the ICursor consumer's buffer with data from the obtained rows.
// Called from our implementations of GetNextRows, Move, Find, Scroll etc.
//
// Notes:
//    End of string characters are inserted into variable length buffer to resolve an
//    apparent difference between ICursor and IRowset.  ICursor places an empty string
//    in variable length buffer for NULL data, but this does not seem to be the behavior
//    with IRowset, because it does not touch the variable length buffer in this case.
//
//    Likewise, all variants are initialized before they are fetched to resolve another
//    apparent difference between ICursor and IRowset.  ICursor returns a NULL variant
//    in cases where the underlying data is NULL, however IRowset leaves the variant
//    untouched similar to the above.
//
HRESULT CVDCursor::FillConsumersBuffer(HRESULT hrFetch,
										 CURSOR_DBFETCHROWS *pFetchParams,
										 ULONG cRowsObtained,
										 HROW * rghRows)
{
    HRESULT hr;
    ULONG ulRow;
    ULONG ulBind;
    BYTE * pVarLength = NULL;
    BYTE * pVarHelperData = NULL;
    CURSOR_DBCOLUMNBINDING * pCursorBinding;
    BOOL fEntryIDBinding;

    IRowset * pRowset = GetRowset();

    // if caller requested callee allocated memory, then compute sizes and allocate memory
    if (pFetchParams->dwFlags & CURSOR_DBROWFETCH_CALLEEALLOCATES)
    {
        // allocate inline memory
        pFetchParams->pData = g_pMalloc->Alloc(cRowsObtained * m_cbRowLength);

        if (!pFetchParams->pData)
        {
			VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
            return E_OUTOFMEMORY;
        }

        // if needed, allocate out-of-line memory
        if (m_ulVarBindings)
        {
            // create variable length data table
            ULONG cbVarHelperData = cRowsObtained * m_ulVarBindings * (sizeof(ULONG) + sizeof(DBSTATUS));

            pVarHelperData = new BYTE[cbVarHelperData];

            if (!pVarHelperData)
            {
                g_pMalloc->Free(pFetchParams->pData);
                pFetchParams->pData = NULL;
			    VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
                return E_OUTOFMEMORY;
            }

            // clear table
            memset(pVarHelperData, 0, cbVarHelperData);

            ULONG cbVarData = 0;
            pVarLength = pVarHelperData;

            // determine necessary size of variable length buffer
            for (ulRow = 0; ulRow < cRowsObtained; ulRow++)
            {
                hr = S_OK;

                // if necessary, get variable length and status information
                if (m_hVarHelper)
                {
                    hr = pRowset->GetData(rghRows[ulRow], m_hVarHelper, pVarLength);

					// ignore these errors
					if (hr == DB_S_ERRORSOCCURRED || hr == DB_E_ERRORSOCCURRED)
						hr = S_OK;

        	        hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_GETDATAFAILED, IID_ICursor, pRowset, IID_IRowset,
                        m_pResourceDLL);
                }

                if (FAILED(hr))
                {
                    g_pMalloc->Free(pFetchParams->pData);
                    pFetchParams->pData = NULL;
                    delete [] pVarHelperData;
                    return hr;
                }

                pCursorBinding = m_pCursorBindings;

                // calculate sizes of data returned in out-of-line memory
                for (ulBind = 0; ulBind < m_ulCursorBindings; ulBind++)
                {
                    // set entryID binding flag
                    fEntryIDBinding = (pCursorBinding->dwBinding & CURSOR_DBBINDING_ENTRYID);

                    if (m_rghVarAccessors[ulBind] || fEntryIDBinding && pCursorBinding->dwDataType == CURSOR_DBTYPE_BLOB)
                    {
                        // insert length entries for fixed datatypes
                        if (m_ppColumns[ulBind]->GetFixed())
                        {
                            *(ULONG*)pVarLength = m_ppColumns[ulBind]->GetMaxStrLen();
                            *(DBSTATUS*)(pVarLength + sizeof(ULONG)) = DBSTATUS_S_OK;
                        }

                        // insert length entries for entryID bindings
                        if (fEntryIDBinding)
                        {
                            *(ULONG*)pVarLength =  sizeof(ULONG) + sizeof(ULONG) + GetCursorMain()->GetMaxBookmarkLen();
                            *(DBSTATUS*)(pVarLength + sizeof(ULONG)) = DBSTATUS_S_OK;
                        }

                        // allow for null-terminator
                        if (pCursorBinding->dwDataType == CURSOR_DBTYPE_LPSTR ||
                            pCursorBinding->dwDataType == CURSOR_DBTYPE_LPWSTR)
                           *((ULONG*)pVarLength) += 1;

                        // allow for wide characters
                        if (pCursorBinding->dwDataType == CURSOR_DBTYPE_LPWSTR)
                           *((ULONG*)pVarLength) *= sizeof(WCHAR);

                        cbVarData += *(ULONG*)pVarLength;
                        pVarLength += sizeof(ULONG) + sizeof(DBSTATUS);
                    }

                    pCursorBinding++;
                }
            }

            // now, allocate out-of-line memory
            pFetchParams->pVarData = g_pMalloc->Alloc(cbVarData);

            if (!pFetchParams->pData)
            {
                g_pMalloc->Free(pFetchParams->pData);
                pFetchParams->pData = NULL;
                delete [] pVarHelperData;
			    VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursor, m_pResourceDLL);
                return E_OUTOFMEMORY;
            }
        }
        else
            pFetchParams->pVarData = NULL;
    }

    // fetch data
    CURSOR_BLOB cursorBlob;
    BYTE * pData = (BYTE*)pFetchParams->pData;
    BYTE * pVarData = (BYTE*)pFetchParams->pVarData;
    pVarLength = pVarHelperData;

    // iterate through the returned hRows
    for (ulRow = 0; ulRow < cRowsObtained; ulRow++)
    {
        hr = S_OK;

        pCursorBinding = m_pCursorBindings;

        // iterate through bindings and initialize variants
        for (ulBind = 0; ulBind < m_ulCursorBindings; ulBind++)
        {
            if (pCursorBinding->dwBinding & CURSOR_DBBINDING_VARIANT)
            {
                if (pCursorBinding->obData != CURSOR_DB_NOVALUE)
				    VariantInit((VARIANT*)(pData + pCursorBinding->obData));
            }

            pCursorBinding++;
        }

        // if necessary get fixed length data
        if (m_hAccessor)
        {
            hr = pRowset->GetData(rghRows[ulRow], m_hAccessor, pData);

			// ignore these return values
			if (hr == DB_S_ERRORSOCCURRED || hr == DB_E_ERRORSOCCURRED)
				hr = S_OK;

            // check to see if need to use adjustments
            if (m_rghAdjustAccessors && SUCCEEDED(hr))
                hr = UseAdjustments(rghRows[ulRow], pData);

	        hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_GETDATAFAILED, IID_ICursor, pRowset, IID_IRowset, m_pResourceDLL);
        }

        if (FAILED(hr))
        {
            hrFetch = hr;
            pFetchParams->cRowsReturned = 0;
            goto DoneFetchingData;
        }

        pCursorBinding = m_pCursorBindings;

        // if necessary get fixed length entryIDs
        for (ulBind = 0; ulBind < m_ulCursorBindings; ulBind++)
        {
            // set entryID binding flag
            fEntryIDBinding = (pCursorBinding->dwBinding & CURSOR_DBBINDING_ENTRYID);

            if (fEntryIDBinding && pCursorBinding->dwDataType == CURSOR_DBTYPE_BYTES)
            {
                // return entryID length
				*(ULONG*)(pData + pCursorBinding->obData) =
                    sizeof(ULONG) + sizeof(ULONG) + GetCursorMain()->GetMaxBookmarkLen();

				// return column ordinal
                *(ULONG*)(pData + pCursorBinding->obData + sizeof(ULONG)) = m_ppColumns[ulBind]->GetOrdinal();

                // return row bookmark
                hr = pRowset->GetData(rghRows[ulRow], GetCursorMain()->GetBookmarkAccessor(),
                    pData + pCursorBinding->obData + sizeof(ULONG) + sizeof(ULONG));

	            hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_GETDATAFAILED, IID_ICursor, pRowset, IID_IRowset,
                    m_pResourceDLL);

                if (FAILED(hr))
                {
                    hrFetch = hr;
                    pFetchParams->cRowsReturned = 0;
                    goto DoneFetchingData;
                }
            }

            pCursorBinding++;
        }

        pCursorBinding = m_pCursorBindings;

        // if necessary get variable length data
        if (m_rghVarAccessors)
        {
            for (ulBind = 0; ulBind < m_ulCursorBindings; ulBind++)
            {
                // set entryID binding flag
                fEntryIDBinding = (pCursorBinding->dwBinding & CURSOR_DBBINDING_ENTRYID);

                if (m_rghVarAccessors[ulBind] || fEntryIDBinding && pCursorBinding->dwDataType == CURSOR_DBTYPE_BLOB)
                {
  		    // place end of string characters in variable length buffer
                    if (pCursorBinding->dwDataType == CURSOR_DBTYPE_LPSTR)
                    {
                        pVarData[0] = 0;
                    }
                    else if (pCursorBinding->dwDataType == CURSOR_DBTYPE_LPWSTR)
                    {
                        pVarData[0] = 0;
                        pVarData[1] = 0;
                    }

                    // get data if we have accessor
                    if (m_rghVarAccessors[ulBind])
                    {
                        // get variable length data
                        hr = pRowset->GetData(rghRows[ulRow], m_rghVarAccessors[ulBind], pVarData);

						// ignore these return values
						if (hr == DB_S_ERRORSOCCURRED || hr == DB_E_ERRORSOCCURRED)
							hr = S_OK;

	                    hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_GETDATAFAILED, IID_ICursor, pRowset, IID_IRowset,
                            m_pResourceDLL);
                    }
                    else // otherwise, get variable length entryIDs
                    {
                        // return entryID length
				        *(ULONG*)(pData + pCursorBinding->obData) =
                            sizeof(ULONG) + sizeof(ULONG) + GetCursorMain()->GetMaxBookmarkLen();

				        // return column ordinal
                        *(ULONG*)(pVarData) = m_ppColumns[ulBind]->GetOrdinal();

                        // return row bookmark
                        hr = pRowset->GetData(rghRows[ulRow], GetCursorMain()->GetBookmarkAccessor(),
                            pVarData + sizeof(ULONG));

	                    hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_GETDATAFAILED, IID_ICursor, pRowset, IID_IRowset,
                            m_pResourceDLL);
                    }

                    if (FAILED(hr))
                    {
                        hrFetch = hr;
                        pFetchParams->cRowsReturned = 0;
                        goto DoneFetchingData;
                    }

                    // make adjustments in fixed length buffer for default bindings
                    if (!(pCursorBinding->dwBinding & CURSOR_DBBINDING_VARIANT))
                    {
                        switch (pCursorBinding->dwDataType)
					    {
						    case CURSOR_DBTYPE_BLOB:
							    *(LPBYTE*)(pData + pCursorBinding->obData + sizeof(ULONG)) = (LPBYTE)pVarData;
							    break;

						    case CURSOR_DBTYPE_LPSTR:
							    *(LPSTR*)(pData + pCursorBinding->obData) = (LPSTR)pVarData;
							    break;

						    case CURSOR_DBTYPE_LPWSTR:
							    *(LPWSTR*)(pData + pCursorBinding->obData) = (LPWSTR)pVarData;
							    break;
					    }
                    }
                    else    // make adjustments in fixed length buffer for variant bindings
                    {
                        CURSOR_DBVARIANT * pVariant = (CURSOR_DBVARIANT*)(pData + pCursorBinding->obData);

                        switch (pCursorBinding->dwDataType)
					    {
						    case CURSOR_DBTYPE_BLOB:
							    cursorBlob.cbSize       = *(ULONG*)pVariant;
							    cursorBlob.pBlobData    = (LPBYTE)pVarData;
							    VariantInit((VARIANT*)pVariant);
							    pVariant->vt            = CURSOR_DBTYPE_BLOB;
							    pVariant->blob          = cursorBlob;
							    break;

						    case CURSOR_DBTYPE_LPSTR:
							    VariantInit((VARIANT*)pVariant);
							    pVariant->vt        = CURSOR_DBTYPE_LPSTR;
							    pVariant->pszVal    = (LPSTR)pVarData;
							    break;

						    case CURSOR_DBTYPE_LPWSTR:
							    VariantInit((VARIANT*)pVariant);
							    pVariant->vt        = CURSOR_DBTYPE_LPSTR;
							    pVariant->pwszVal   = (LPWSTR)pVarData;
							    break;
					    }
                    }

                    if (pVarLength)
                    {
                        pVarData += *(ULONG*)pVarLength;
                        pVarLength += sizeof(ULONG) + sizeof(DBSTATUS);
                    }
                    else
						{
						if (pCursorBinding->dwDataType == CURSOR_DBTYPE_BLOB)
							pVarData += *(ULONG *) (pData + pCursorBinding->obData);
						else
							pVarData += pCursorBinding->cbMaxLen;
						}
                }
			    else
			    {
				    if (pCursorBinding->dwDataType == CURSOR_DBTYPE_FILETIME)
				    {
					    VDConvertToFileTime((DBTIMESTAMP*)(pData + pCursorBinding->obData),
										    (FILETIME*)(pData + pCursorBinding->obData));
				    }
			    }

                pCursorBinding++;
            }
        }

        pCursorBinding = m_pCursorBindings;

        // make adjustments for status fields
        for (ulBind = 0; ulBind < m_ulCursorBindings; ulBind++)
        {
            if (pCursorBinding->obInfo != CURSOR_DB_NOVALUE)
            {
                *(DWORD*)(pData + pCursorBinding->obInfo) =
                    StatusToCursorInfo(*(DBSTATUS*)(pData + pCursorBinding->obInfo));
            }

            pCursorBinding++;
        }

        // increment returned row count
        pFetchParams->cRowsReturned++;
        pData += m_cbRowLength;
    }

DoneFetchingData:
    delete [] pVarHelperData;

    // cleanup memory allocations if we did not retrieve any rows
    if (pFetchParams->dwFlags & CURSOR_DBROWFETCH_CALLEEALLOCATES && !pFetchParams->cRowsReturned)
    {
        if (pFetchParams->pData)
        {
            g_pMalloc->Free(pFetchParams->pData);
            pFetchParams->pData = NULL;
        }

        if (pFetchParams->pVarData)
        {
            g_pMalloc->Free(pFetchParams->pVarData);
            pFetchParams->pVarData = NULL;
        }
    }

    return hrFetch;
}

//=--------------------------------------------------------------------------=
// ICursor Requery
//=--------------------------------------------------------------------------=
// Repopulates the cursor based on its original definition
//
// Parameters:
//              none
//
// Output:
//    HRESULT - S_OK if successful
//
// Notes:
//
HRESULT CVDCursor::Requery(void)
{

    if (!IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursor, m_pResourceDLL);
        return E_FAIL;
    }

    IRowset * pRowset = GetRowset();
	IRowsetResynch * pRowsetResynch = NULL;

	HRESULT hr = pRowset->QueryInterface(IID_IRowsetResynch, (void**)&pRowsetResynch);

	if (SUCCEEDED(hr))
	{
		hr = pRowsetResynch->ResynchRows(0, NULL, NULL, NULL, NULL);
		pRowsetResynch->Release();
		if (FAILED(hr))
			return VDMapRowsetHRtoCursorHR(hr, IDS_ERR_RESYNCHFAILED, IID_ICursor, pRowset, IID_IRowsetResynch, m_pResourceDLL);
	}

    hr = pRowset->RestartPosition(0);

	hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_RESTARTPOSFAILED, IID_ICursor, pRowset, IID_IRowset, m_pResourceDLL);

	m_pCursorPosition->PositionToFirstRow();

    return hr;
}

//=--------------------------------------------------------------------------=
// FetchAtBookmark
//=--------------------------------------------------------------------------=
// Called from ICursorMove::Move, ICursorScroll::Scroll and	ICursorFind::Find
//
// Parameters:
//	cbBookmark		[in]	The length of the bookmark
//	pBookmark		[in]	A pointer to the bookmarks data
//	dlOffset		[in]	Offset from the bookmark position
//	pFetchParams	[in]	A pointer to the CURSOR_DBFETCHROWS structure (optional)
//
// Output:
//    HRESULT - S_OK if successful
//
// Notes:
//
//
HRESULT CVDCursor::FetchAtBookmark(ULONG cbBookmark,
									  void *pBookmark,
									  LARGE_INTEGER dlOffset,
									  CURSOR_DBFETCHROWS *pFetchParams)
{

	HRESULT hr = S_OK;

    // vaildate fetch params (implemented on CVDCursorBase
    if (pFetchParams)
		hr = ValidateFetchParams(pFetchParams, IID_ICursorMove);

    // return if fetch params are invalid
	if (FAILED(hr))
		return hr;

    IRowset * pRowset = GetRowset();

	// make sure that an update is not already in progress
    if (m_pCursorPosition->GetEditMode() != CURSOR_DBEDITMODE_NONE)
	{
        VDSetErrorInfo(IDS_ERR_UPDATEINPROGRESS, IID_ICursor, m_pResourceDLL);
		return CURSOR_DB_E_UPDATEINPROGRESS;
	}

    ULONG cRowsObtained = 0;
    HROW * rghRows = NULL;

    HRESULT hrFetch = S_OK;
	BYTE bSpecialBM;
    BOOL fFetchData = TRUE;
    WORD wSpecialBMStatus = 0;

	if (CURSOR_DB_BMK_SIZE == cbBookmark)
	{
		if (memcmp(&CURSOR_DBBMK_BEGINNING, pBookmark, CURSOR_DB_BMK_SIZE) == 0)
		{
            if ((long)dlOffset.LowPart < 0)
            {
        		m_pCursorPosition->SetCurrentRowStatus(VDBOOKMARKSTATUS_BEGINNING);
                return CURSOR_DB_S_ENDOFCURSOR;
            }

			bSpecialBM	= DBBMK_FIRST;
			pBookmark	= &bSpecialBM;

            // make sure we properly handle situation when caller move before the first,
            // and does not fetch any rows
            if ((!pFetchParams || !pFetchParams->cRowsRequested) && (long)dlOffset.LowPart < 1)
            {
                fFetchData  = FALSE;
                wSpecialBMStatus = VDBOOKMARKSTATUS_BEGINNING;
            }
            else
                dlOffset.LowPart--;
		}
		else
		if (memcmp(&CURSOR_DBBMK_END, pBookmark, CURSOR_DB_BMK_SIZE) == 0)
		{
            if ((long)dlOffset.LowPart > 0)
            {
        		m_pCursorPosition->SetCurrentRowStatus(VDBOOKMARKSTATUS_END);
                return CURSOR_DB_S_ENDOFCURSOR;
            }

			bSpecialBM	= DBBMK_LAST;
			pBookmark	= &bSpecialBM;

            // make sure we properly handle situation when caller move after the last
            if ((!pFetchParams || !pFetchParams->cRowsRequested) && (long)dlOffset.LowPart > -1)
            {
                fFetchData  = FALSE;
                wSpecialBMStatus = VDBOOKMARKSTATUS_END;
            }
            else
                dlOffset.LowPart++;
		}
		else
		if (memcmp(&CURSOR_DBBMK_CURRENT, pBookmark, CURSOR_DB_BMK_SIZE) == 0)
		{
			switch (m_pCursorPosition->m_bmCurrent.GetStatus())
			{
				case VDBOOKMARKSTATUS_BEGINNING:
					cbBookmark  = sizeof(BYTE);
        			bSpecialBM	= DBBMK_FIRST;
		        	pBookmark	= &bSpecialBM;
                    dlOffset.LowPart--;
                    break;

				case VDBOOKMARKSTATUS_END:
					cbBookmark  = sizeof(BYTE);
        			bSpecialBM	= DBBMK_LAST;
		        	pBookmark	= &bSpecialBM;
                    dlOffset.LowPart++;
                    break;

				case VDBOOKMARKSTATUS_CURRENT:
					cbBookmark	= m_pCursorPosition->m_bmCurrent.GetBookmarkLen();
					pBookmark	= m_pCursorPosition->m_bmCurrent.GetBookmark();
					break;

				default:
					ASSERT_(FALSE);
					VDSetErrorInfo(IDS_ERR_INVALIDBMSTATUS, IID_ICursor, m_pResourceDLL);
					return E_FAIL;
			}
		}
	}
	
	ULONG cRowsToFetch = 1;

    // if caller requested rows, fetch that count
    if (pFetchParams && pFetchParams->cRowsRequested > 0)
        cRowsToFetch = pFetchParams->cRowsRequested;

    if (fFetchData)
    {
        // fetch hRows
	    hrFetch = GetRowsetLocate()->GetRowsAt(0, 0, cbBookmark, (const BYTE *)pBookmark,
										    dlOffset.LowPart,
										    cRowsToFetch,
										    &cRowsObtained, &rghRows);

		if (hrFetch == E_UNEXPECTED)
		{
			// set rowset released flag, since original rowset is zombie'd
			m_pCursorPosition->GetRowsetSource()->SetRowsetReleasedFlag();
		}

        hrFetch = FilterNewRow(&cRowsObtained, rghRows, hrFetch);
        // check for before the first or after the last
        if (hrFetch == DB_E_BADSTARTPOSITION)
        {
            if ((long)dlOffset.LowPart < 0)
                wSpecialBMStatus = VDBOOKMARKSTATUS_BEGINNING;
            else
                wSpecialBMStatus = VDBOOKMARKSTATUS_END;

            hrFetch = DB_S_ENDOFROWSET;
            fFetchData  = FALSE;
        }
    }

	hrFetch = VDMapRowsetHRtoCursorHR(hrFetch, IDS_ERR_GETROWSATFAILED, IID_ICursorMove, GetRowsetLocate(),
        IID_IRowsetLocate, m_pResourceDLL);

    if (FAILED(hrFetch))
	{
		if (cRowsObtained)
		{
			// release hRows and associated memory
			pRowset->ReleaseRows(cRowsObtained, rghRows, NULL, NULL, NULL);
			g_pMalloc->Free(rghRows);
		}
        return hrFetch;
	}

	if (cRowsObtained)
	{
		HRESULT hrMove = S_OK;

		// if got all rows requested then set current position to last row retrieved
		if (SUCCEEDED(hrFetch)	&&
			cRowsObtained == cRowsToFetch)
			hrMove = m_pCursorPosition->SetRowPosition(rghRows[cRowsObtained - 1]);

        // only do this if succeeded
        if (SUCCEEDED(hrMove))
		{
			// fill consumers buffer
			if (pFetchParams && pFetchParams->cRowsRequested > 0)
				hrFetch = FillConsumersBuffer(hrFetch, pFetchParams, cRowsObtained, rghRows);

			// if got all rows requested then set current position to last row retrieved (internally)
			if (SUCCEEDED(hrFetch)	&&
				cRowsObtained == cRowsToFetch)
				m_pCursorPosition->SetCurrentHRow(rghRows[cRowsObtained - 1]);
		}

		// release hRows and associated memory
		pRowset->ReleaseRows(cRowsObtained, rghRows, NULL, NULL, NULL);
		g_pMalloc->Free(rghRows);

		// report failure
		if (FAILED(hrMove))
		{
			cRowsObtained = 0;
			hrFetch = E_FAIL;
		}
	}
    else if (wSpecialBMStatus)
    {
		m_pCursorPosition->SetCurrentRowStatus(wSpecialBMStatus);
        hrFetch = CURSOR_DB_S_ENDOFCURSOR;
    }

	if (SUCCEEDED(hrFetch)	&&
		cRowsObtained < cRowsToFetch &&
        !wSpecialBMStatus)
		m_pCursorPosition->SetCurrentRowStatus(VDBOOKMARKSTATUS_END);

    return hrFetch;
}

//=--------------------------------------------------------------------------=
// ICursorMove methods implemented
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// ICursorMove Move
//=--------------------------------------------------------------------------=
// Moves the current row to a new row within the cursor and optionally fetches
// rows from that new position
//
// Parameters:
//    cbBookmark    - [in]      length in bytes of the bookmark
//    pBookmark     - [in]      a pointer to a bookmark which serves as the
//                              origin for the calculation that determines the
//                              target row
//    dlOffset      - [in]      a signed count of the rows from the origin
//                              bookmark to the target row
//    pFetchParams  - [in, out] a pointer to fetch rows structure
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//
// Notes:
//
HRESULT CVDCursor::Move(ULONG cbBookmark, void *pBookmark, LARGE_INTEGER dlOffset, CURSOR_DBFETCHROWS *pFetchParams)
{
    ASSERT_POINTER(pBookmark, BYTE)
    ASSERT_NULL_OR_POINTER(pFetchParams, CURSOR_DBFETCHROWS)

    if (!IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursorMove, m_pResourceDLL);
        return E_FAIL;
    }

	if (!cbBookmark || !pBookmark)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursorMove, m_pResourceDLL);
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    BOOL fNotifyOthers = TRUE;

    // get current bookmark
    ULONG cbCurrent = m_pCursorPosition->m_bmCurrent.GetBookmarkLen();
    BYTE * pCurrent = m_pCursorPosition->m_bmCurrent.GetBookmark();

    // check to see if caller is moving to the current row using the standard bookmark
    if (CURSOR_DB_BMK_SIZE == cbBookmark && memcmp(&CURSOR_DBBMK_CURRENT, pBookmark, CURSOR_DB_BMK_SIZE) == 0 &&
        dlOffset.HighPart == 0 && dlOffset.LowPart == 0)
    {
        // if caller is not fetching any rows, then get out
        if (!pFetchParams || pFetchParams->cRowsRequested == 0)
            return S_OK;

        // if caller is only fetching one row, then don't generate notifications
        if (pFetchParams && pFetchParams->cRowsRequested == 1)
            fNotifyOthers = FALSE;
    }

	CURSOR_DBNOTIFYREASON rgReasons[1];
	
	rgReasons[0].dwReason	= CURSOR_DBREASON_MOVE;
	rgReasons[0].arg1		= m_pCursorPosition->m_bmCurrent.GetBookmarkVariant();

	VariantInit((VARIANT*)&rgReasons[0].arg2);

    // notify other interested parties
	DWORD dwEventWhat = CURSOR_DBEVENT_CURRENT_ROW_CHANGED;

	if (fNotifyOthers)
        hr = m_pCursorPosition->NotifyBefore(dwEventWhat, 1, rgReasons);

    // make sure action was not cancelled
    if (hr != S_OK)
    {
        VDSetErrorInfo(IDS_ERR_ACTIONCANCELLED, IID_ICursorMove, m_pResourceDLL);
        return E_FAIL;
    }

	hr = FetchAtBookmark(cbBookmark, pBookmark, dlOffset, pFetchParams);

	if (SUCCEEDED(hr))
	{
		rgReasons[0].arg1	= m_pCursorPosition->m_bmCurrent.GetBookmarkVariant();
		
    	if (fNotifyOthers)
            m_pCursorPosition->NotifyAfter(dwEventWhat, 1, rgReasons);
	}
	else
    {
    	if (fNotifyOthers)
	    	m_pCursorPosition->NotifyFail(dwEventWhat, 1, rgReasons);
    }

	return hr;
}

//=--------------------------------------------------------------------------=
// ICursorMove GetBookmark
//=--------------------------------------------------------------------------=
// Returns the bookmark of the current row
//
// Parameters:
//    pBookmarkType - [in]  a pointer to the type of bookmark desired
//    cbMaxSize     - [in]  length in bytes of the client buffer to put the
//                          returned bookmark into
//    pcbBookmark   - [out] a pointer to memory in which to return the actual
//                          length of the returned bookmark
//    pBookmark     - [out] a pointer to client buffer to put the returned
//                          bookmark into
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//
// Notes:
//
HRESULT CVDCursor::GetBookmark(CURSOR_DBCOLUMNID *pBookmarkType,
							   ULONG cbMaxSize,
							   ULONG *pcbBookmark,
							   void *pBookmark)
{

	ASSERT_POINTER(pBookmarkType, CURSOR_DBCOLUMNID);
	ASSERT_POINTER(pcbBookmark, ULONG);
	ASSERT_POINTER(pBookmark, BYTE);
	ASSERT_(cbMaxSize > 0)

    if (!IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursorMove, m_pResourceDLL);
        return E_FAIL;
    }

	if (!pcbBookmark || !pBookmark)
	{
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursorMove, m_pResourceDLL);
		return E_INVALIDARG;
	}

	// verify bookmark type
	if (memcmp(&CURSOR_COLUMN_BMKTEMPORARY,	pBookmarkType, sizeof(CURSOR_DBCOLUMNID)) != 0 &&
		memcmp(&CURSOR_COLUMN_BMKTEMPORARYREL, pBookmarkType, sizeof(CURSOR_DBCOLUMNID)) != 0)
	{
        VDSetErrorInfo(IDS_ERR_BADCOLUMNID, IID_ICursorMove, m_pResourceDLL);
		return DB_E_BADCOLUMNID;
	}

	HRESULT hr = S_OK;

	if (0 == cbMaxSize)
	{
        VDSetErrorInfo(IDS_ERR_BUFFERTOOSMALL, IID_ICursorMove, m_pResourceDLL);
		hr = CURSOR_DB_E_BUFFERTOOSMALL;
	}
	else
	{
		switch (m_pCursorPosition->m_bmCurrent.GetStatus())
		{
			case VDBOOKMARKSTATUS_BEGINNING:
			case VDBOOKMARKSTATUS_END:
			case VDBOOKMARKSTATUS_CURRENT:
				if (m_pCursorPosition->m_bmCurrent.GetBookmarkLen() > cbMaxSize)
				{
			        VDSetErrorInfo(IDS_ERR_BUFFERTOOSMALL, IID_ICursorMove, m_pResourceDLL);
					hr = CURSOR_DB_E_BUFFERTOOSMALL;
					break;
				}
				*pcbBookmark		= m_pCursorPosition->m_bmCurrent.GetBookmarkLen();
				memcpy(pBookmark, m_pCursorPosition->m_bmCurrent.GetBookmark(), *pcbBookmark);
				break;

			case VDBOOKMARKSTATUS_INVALID:
				*pcbBookmark		= CURSOR_DB_BMK_SIZE;
				*(BYTE*)pBookmark	= CURSOR_DBBMK_INVALID;
				break;

			default:
				ASSERT_(FALSE);
		        VDSetErrorInfo(IDS_ERR_INVALIDBMSTATUS, IID_ICursorMove, m_pResourceDLL);
				hr =  E_FAIL;
				break;
		}
	}

	return hr;
}

//=--------------------------------------------------------------------------=
// ICursorMove Clone
//=--------------------------------------------------------------------------=
// Returns a clone of the cursor
//
// Parameters:
//    dwFlags           - [in]  a flag that specifies the clone options
//    riid              - [in]  the interface desired for the returned clone
//    ppvClonedCursor   - [out] a pointer to memory in which to return newly
//                              created clone pointer
//
// Output:
//    HRESULT - S_OK if successful
//
// Notes:
//
HRESULT CVDCursor::Clone(DWORD dwFlags, REFIID riid, IUnknown **ppvClonedCursor)
{

    if (!IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursorMove, m_pResourceDLL);
        return E_FAIL;
    }

	CVDCursorPosition * pCursorPosition;

	HRESULT hr;

	if (CURSOR_DBCLONEOPTS_SAMEROW == dwFlags)
	{
		pCursorPosition = m_pCursorPosition;
	}
	else
	{
		// create new cursor position object
		hr = CVDCursorPosition::Create(NULL,
									   m_pCursorPosition->GetCursorMain(),
									   &pCursorPosition,
									   m_pResourceDLL);
		if (FAILED(hr))
			return hr;
	}

    CVDCursor * pCursor = 0;

    hr = CVDCursor::Create(pCursorPosition, &pCursor, m_pResourceDLL);

	if (CURSOR_DBCLONEOPTS_SAMEROW != dwFlags)
    {
        // release our reference
        pCursorPosition->Release();
    }

    *ppvClonedCursor = (ICursorScroll*)pCursor;

    return hr;
}

//=--------------------------------------------------------------------------=
// ICursorScroll methods implemented
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// ICursorScroll Scroll
//=--------------------------------------------------------------------------=
// Moves the current row to a new row within the cursor, specified as a
// fraction, and optionally fetches rows from that new position
//
// Parameters:
//    ulNumerator   - [in]      the numerator of the fraction that states the
//                              position to scroll to in the cursor
//    ulDenominator - [in]      the denominator of that same fraction
//    pFetchParams  - [in, out] a pointer to fetch rows structure
//
// Output:
//    HRESULT - S_OK if successful
//              CURSOR_DB_E_BADFRACTION - bad fraction
//
// Notes:
//
HRESULT CVDCursor::Scroll(ULONG ulNumerator, ULONG ulDenominator, CURSOR_DBFETCHROWS *pFetchParams)
{

    if (!IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursorScroll, m_pResourceDLL);
        return E_FAIL;
    }

	IRowsetScroll * pRowsetScroll = GetRowsetScroll();

	if (!pRowsetScroll)
		return E_NOTIMPL;

	CURSOR_DBNOTIFYREASON rgReasons[1];

	rgReasons[0].dwReason	= CURSOR_DBREASON_MOVEPERCENT;
	
	VariantInit((VARIANT*)&rgReasons[0].arg1);
	rgReasons[0].arg1.vt		= VT_UI4;
	rgReasons[0].arg1.lVal		= ulNumerator;

	VariantInit((VARIANT*)&rgReasons[0].arg2);
	rgReasons[0].arg2.vt		= VT_UI4;
	rgReasons[0].arg2.lVal		= ulDenominator;

    // notify other interested parties
	DWORD dwEventWhat = CURSOR_DBEVENT_CURRENT_ROW_CHANGED;

	HRESULT hr = m_pCursorPosition->NotifyBefore(dwEventWhat, 1, rgReasons);

    // make sure action was not cancelled
    if (hr != S_OK)
    {
        VDSetErrorInfo(IDS_ERR_ACTIONCANCELLED, IID_ICursorScroll, m_pResourceDLL);
        return E_FAIL;
    }

	if (0 == ulNumerator) // go to first row
	{
		LARGE_INTEGER dlOffset;
		dlOffset.HighPart	= 0;
		dlOffset.LowPart	= 1;
		hr = FetchAtBookmark(CURSOR_DB_BMK_SIZE, (void*)&CURSOR_DBBMK_BEGINNING, dlOffset, pFetchParams);
	}
	else
	if (ulDenominator == ulNumerator) // go to last row
	{
		LARGE_INTEGER dlOffset;
		dlOffset.HighPart	= -1;
		dlOffset.LowPart	= 0xFFFFFFFF;
		hr = FetchAtBookmark(CURSOR_DB_BMK_SIZE, (void*)&CURSOR_DBBMK_END, dlOffset, pFetchParams);
	}
	else
	{
		HROW * pRow = NULL;
		ULONG cRowsObtained = 0;

		hr = pRowsetScroll->GetRowsAtRatio(0, 0,
											ulNumerator,
											ulDenominator,
											1,
											&cRowsObtained,
											&pRow);

		if FAILED(hr)
			hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_SCROLLFAILED, IID_ICursorScroll, pRowsetScroll, IID_IRowsetScroll, m_pResourceDLL);

		if (SUCCEEDED(hr) && cRowsObtained)
		{

			// allocate buffer for bookmark plus length indicator
			BYTE * pBuff = new BYTE[GetCursorMain()->GetMaxBookmarkLen() + sizeof(ULONG)];
	
			if (!pBuff)
				hr = E_OUTOFMEMORY;
			else
			{
			// get the bookmark data
				hr = GetRowset()->GetData(*pRow, GetCursorMain()->GetBookmarkAccessor(), pBuff);
				if SUCCEEDED(hr)
				{
					ULONG * pulLen = (ULONG*)pBuff;
					BYTE * pbmdata = pBuff + sizeof(ULONG);
					LARGE_INTEGER dlOffset;
					dlOffset.HighPart	= 0;
					dlOffset.LowPart	= 0;
					hr = FetchAtBookmark(*pulLen, pbmdata, dlOffset, pFetchParams);
				}
				else
				{
					hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_GETDATAFAILED, IID_ICursorScroll, pRowsetScroll, IID_IRowset, m_pResourceDLL);
				}

				delete [] pBuff;
			}

		}
		
		if (pRow)
		{
			if (cRowsObtained)
				GetRowset()->ReleaseRows(1, pRow, NULL, NULL, NULL);
			g_pMalloc->Free(pRow);
		}
	}

	if SUCCEEDED(hr)
	{
		rgReasons[0].arg1	= m_pCursorPosition->m_bmCurrent.GetBookmarkVariant();
		VariantClear((VARIANT*)&rgReasons[0].arg2);
		m_pCursorPosition->NotifyAfter(dwEventWhat, 1, rgReasons);
	}
	else
		m_pCursorPosition->NotifyFail(dwEventWhat, 1, rgReasons);

    return hr;
}

//=--------------------------------------------------------------------------=
// ICursorScroll GetApproximatePosition
//=--------------------------------------------------------------------------=
// Returns the approximate location of a bookmark within the cursor, specified
// as a fraction
//
// Parameters:
//    cbBookmark        - [in]  length in bytes of the bookmark
//    pBookmark         - [in]  a pointer to the bookmark
//    pulNumerator      - [out] a pointer to memory in which to return the
//                              numerator of the faction that defines the
//                              approximate position of the bookmark
//    pulDenominator    - [out] a pointer to memory in which to return the
//                              denominator of that same faction
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//
// Notes:
//
HRESULT CVDCursor::GetApproximatePosition(ULONG cbBookmark, void *pBookmark, ULONG *pulNumerator, ULONG *pulDenominator)
{

    if (!IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursorScroll, m_pResourceDLL);
        return E_FAIL;
    }

	ASSERT_(cbBookmark);
	ASSERT_POINTER(pBookmark, BYTE);
	ASSERT_POINTER(pulNumerator, ULONG);
	ASSERT_POINTER(pulDenominator, ULONG);

	if (!cbBookmark || !pBookmark || !pulNumerator || !pulDenominator)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursorScroll, m_pResourceDLL);
        return E_INVALIDARG;
    }

	if (CURSOR_DB_BMK_SIZE == cbBookmark)
	{
		if (memcmp(&CURSOR_DBBMK_BEGINNING, pBookmark, CURSOR_DB_BMK_SIZE) == 0)
		{
			*pulNumerator		= 0;
			*pulDenominator		= 1;
			return S_OK;
		}
		if (memcmp(&CURSOR_DBBMK_END, pBookmark, CURSOR_DB_BMK_SIZE) == 0)
		{
			*pulNumerator		= 1;
			*pulDenominator		= 1;
			return S_OK;
		}
		if (memcmp(&CURSOR_DBBMK_CURRENT, pBookmark, CURSOR_DB_BMK_SIZE) == 0)
		{
			cbBookmark	= m_pCursorPosition->m_bmCurrent.GetBookmarkLen();
			pBookmark	= m_pCursorPosition->m_bmCurrent.GetBookmark();
		}
	}

	IRowsetScroll * pRowsetScroll = GetRowsetScroll();

	if (!pRowsetScroll)
		return E_NOTIMPL;

	HRESULT hr = pRowsetScroll->GetApproximatePosition(0,
														cbBookmark,
														(const BYTE *)pBookmark,
														pulNumerator,
														pulDenominator);

	if SUCCEEDED(hr)
	{
		// since ICursor returns a zero based approximate position and IRowset is 1 based
		// we need to adjust the return value
		if (0 < *pulNumerator)
			(*pulNumerator)--;
	}
	else
		hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_GETAPPROXPOSFAILED, IID_ICursorScroll, pRowsetScroll, IID_IRowsetScroll, m_pResourceDLL);

    return hr;

}

//=--------------------------------------------------------------------------=
// ICursorScroll GetApproximateCount
//=--------------------------------------------------------------------------=
// Returns the approximate number of rows in the cursor
//
// Parameters:
//    pudlApproxCount       - [out] a pointer to a buffer containing the
//                                  returned approximate count of the rows
//                                  in the cursor
//    pdwFullyPopuldated    - [out] a pointer to a buffer containing returned
//                                  flags indicating whether the cursor is fully
//                                  populated
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//
// Notes:
//
HRESULT CVDCursor::GetApproximateCount(LARGE_INTEGER *pudlApproxCount, DWORD *pdwFullyPopulated)
{

    if (!IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursorScroll, m_pResourceDLL);
        return E_FAIL;
    }

	ASSERT_POINTER(pudlApproxCount, LARGE_INTEGER);
	ASSERT_NULL_OR_POINTER(pdwFullyPopulated, DWORD);

	if (!pudlApproxCount)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursorScroll, m_pResourceDLL);
        return E_INVALIDARG;
    }

	IRowsetScroll * pRowsetScroll = GetRowsetScroll();

	if (!pRowsetScroll)
		return E_NOTIMPL;

	HRESULT hr;

	if (pdwFullyPopulated)
	{
		*pdwFullyPopulated = CURSOR_DBCURSORPOPULATED_FULLY;

		IDBAsynchStatus * pDBAsynchStatus = NULL;
		hr = pRowsetScroll->QueryInterface(IID_IDBAsynchStatus, (void**)&pDBAsynchStatus);
		if (SUCCEEDED(hr) && pDBAsynchStatus)
		{
			ULONG ulProgress;
			ULONG ulProgressMax;
			ULONG ulStatusCode;
			hr = pDBAsynchStatus->GetStatus(DB_NULL_HCHAPTER, DBASYNCHOP_OPEN, &ulProgress, &ulProgressMax, &ulStatusCode, NULL);
			if (SUCCEEDED(hr))
			{
				if (ulProgress < ulProgressMax)
					*pdwFullyPopulated = CURSOR_DBCURSORPOPULATED_PARTIALLY;
			}
			pDBAsynchStatus->Release();
		}
	}

    pudlApproxCount->HighPart = 0;

	hr = pRowsetScroll->GetApproximatePosition(0, 0, NULL, NULL, &pudlApproxCount->LowPart);

	if FAILED(hr)
		hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_GETAPPROXPOSFAILED, IID_ICursorScroll, pRowsetScroll, IID_IRowsetScroll, m_pResourceDLL);
	else
		pudlApproxCount->LowPart -= m_pCursorPosition->GetCursorMain()->AddedRows();

    return hr;
}

//=--------------------------------------------------------------------------=
// ICursorUpdateARow methods
//=--------------------------------------------------------------------------=
// ICursorUpdateARow BeginUpdate
//=--------------------------------------------------------------------------=
// Begins an operation that updates the current or adds a new row
//
// Parameters:
//	dwFlags         - [in] specifies the operation to begin
//
//
// Output:
//    HRESULT - S_OK if successful
//              E_FAIL a provider-specific error occured
//              E_INVALIDARG bad parameter
//              E_OUTOFMEMORY not enough memory
//              CURSOR_DB_E_UPDATEINPROGRESS an update is already in progress
//
// Notes:
//
HRESULT CVDCursor::BeginUpdate(DWORD dwFlags)
{
	IRowset * pRowset = GetRowset();
    IAccessor * pAccessor = GetAccessor();
	IRowsetChange * pRowsetChange = GetRowsetChange();

    // make sure we have valid rowset, accessor and change pointers
    if (!pRowset || !pAccessor || !pRowsetChange || !IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_FAIL;
    }

    // check dwFlags for acceptable values
    if (dwFlags != CURSOR_DBROWACTION_UPDATE && dwFlags != CURSOR_DBROWACTION_ADD)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // make sure that an update is not already in progress
    if (m_pCursorPosition->GetEditMode() != CURSOR_DBEDITMODE_NONE)
    {
        VDSetErrorInfo(IDS_ERR_UPDATEINPROGRESS, IID_ICursorUpdateARow, m_pResourceDLL);
        return CURSOR_DB_E_UPDATEINPROGRESS;
    }

    // setup notification structures
   	DWORD dwEventWhat = CURSOR_DBEVENT_CURRENT_ROW_DATA_CHANGED |
                        CURSOR_DBEVENT_SET_OF_ROWS_CHANGED;

	CURSOR_DBNOTIFYREASON rgReasons[1];
	VariantInit((VARIANT*)&rgReasons[0].arg1);
	VariantInit((VARIANT*)&rgReasons[0].arg2);

    switch (dwFlags)
    {
        case CURSOR_DBROWACTION_UPDATE:
    	    rgReasons[0].dwReason = CURSOR_DBREASON_EDIT;
            break;

        case CURSOR_DBROWACTION_ADD:
    	    rgReasons[0].dwReason = CURSOR_DBREASON_ADDNEW;
            break;
    }

    // notify other interested parties of action
    HRESULT hr = m_pCursorPosition->NotifyBefore(dwEventWhat, 1, rgReasons);

	// make sure action was not cancelled
	if (hr != S_OK)
    {
        VDSetErrorInfo(IDS_ERR_ACTIONCANCELLED, IID_ICursorUpdateARow, m_pResourceDLL);
		return E_FAIL;
    }

    // insert new hRow if we're going into add mode
    if (dwFlags == CURSOR_DBROWACTION_ADD)
    {
        hr = InsertNewRow();

        if (FAILED(hr))
        {
            // notify other interested parties of failure
            m_pCursorPosition->NotifyFail(dwEventWhat, 1, rgReasons);
            return hr;
        }
    }

    // reset column updates
    hr = m_pCursorPosition->ResetColumnUpdates();

    if (FAILED(hr))
    {
        // notify other interested parties of failure
        m_pCursorPosition->NotifyFail(dwEventWhat, 1, rgReasons);
        return hr;
    }

    // place cursor in correct mode
    switch (dwFlags)
    {
        case CURSOR_DBROWACTION_UPDATE:
            m_pCursorPosition->SetEditMode(CURSOR_DBEDITMODE_UPDATE);
            break;

        case CURSOR_DBROWACTION_ADD:
            m_pCursorPosition->SetEditMode(CURSOR_DBEDITMODE_ADD);
            break;
    }

    // notify other interested parties of success
    m_pCursorPosition->NotifyAfter(dwEventWhat, 1, rgReasons);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// ICursorUpdateARow SetColumn
//=--------------------------------------------------------------------------=
// Sets the current value of the specified column
//
// Parameters:
//	pcid            - [in] a pointer to the columnID for which data is
//                         to be set
//  pBindParams     - [in] a pointer to a column binding structure containing
//                         information about the data and a pointer to the data
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//              E_OUTOFMEMORY not enough memory
//              E_FAIL a provider-specific error occured
//              CURSOR_DB_E_STATEERROR not in update or add mode
//              CURSOR_DB_E_BADCOLUMNID pcid was not a valid column identifier
//              CURSOR_DB_E_BADBINDINFO bad binding information
//
// Notes:
//
HRESULT CVDCursor::SetColumn(CURSOR_DBCOLUMNID *pcid, CURSOR_DBBINDPARAMS *pBindParams)
{
    ASSERT_POINTER(pcid, CURSOR_DBCOLUMNID)
    ASSERT_POINTER(pBindParams, CURSOR_DBBINDPARAMS)

    // make sure we have valid rowset
    if (!IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_FAIL;
    }

    // make sure we have all necessary pointers
    if (!pcid || !pBindParams || !pBindParams->pData)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // make sure we are in update or add mode
    if (m_pCursorPosition->GetEditMode() == CURSOR_DBEDITMODE_NONE)
    {
        VDSetErrorInfo(IDS_ERR_STATEERROR, IID_ICursorUpdateARow, m_pResourceDLL);
        return CURSOR_DB_E_STATEERROR;
    }

    CVDRowsetColumn * pColumn;

    // validate cursor binding parameters and get rowset column
    HRESULT hr = ValidateCursorBindParams(pcid, pBindParams, &pColumn);

    if (FAILED(hr))
        return hr;

    CVDColumnUpdate * pColumnUpdate;

    // create new column update object
    hr = CVDColumnUpdate::Create(pColumn, pBindParams, &pColumnUpdate, m_pResourceDLL);

    if (FAILED(hr))
        return hr;

    // setup notification structures
   	DWORD dwEventWhat = CURSOR_DBEVENT_CURRENT_ROW_DATA_CHANGED;

	CURSOR_DBNOTIFYREASON rgReasons[1];
	VariantInit((VARIANT*)&rgReasons[0].arg1);
	VariantInit((VARIANT*)&rgReasons[0].arg2);

	rgReasons[0].dwReason   = CURSOR_DBREASON_SETCOLUMN;
	rgReasons[0].arg1.vt    = VT_I4;
	rgReasons[0].arg1.lVal  = pColumn->GetNumber();
    rgReasons[0].arg2       = pColumnUpdate->GetVariant();

    // notify other interested parties of action
	hr = m_pCursorPosition->NotifyBefore(dwEventWhat, 1, rgReasons);

	// make sure action was not cancelled
	if (hr != S_OK)
    {
        // release column update object
        pColumnUpdate->Release();

        VDSetErrorInfo(IDS_ERR_ACTIONCANCELLED, IID_ICursorUpdateARow, m_pResourceDLL);
		return E_FAIL;
    }

    // update column in cursor position
    m_pCursorPosition->SetColumnUpdate(pColumn->GetNumber(), pColumnUpdate);

    // notify other interested parties of success
    m_pCursorPosition->NotifyAfter(dwEventWhat, 1, rgReasons);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// ICursorUpdateARow GetColumn
//=--------------------------------------------------------------------------=
// Gets the current value of the specified column
//
// Parameters:
//	pcid            - [in]  a pointer to the columnID for which data is
//                          to be returned
//  pBindParams     - [out] a pointer to a column binding structure in which
//                          to return data
//  pdwFlags        - [out] a pointer to memory in which to return the
//                          changed state of the returned data
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//              E_OUTOFMEMORY not enough memory
//              E_FAIL a provider-specific error occured
//              CURSOR_DB_E_STATEERROR not in update or add mode
//              CURSOR_DB_E_BADCOLUMNID pcid was not a valid column identifier
//              CURSOR_DB_E_BADBINDINFO bad binding information
//
// Notes:
//
HRESULT CVDCursor::GetColumn(CURSOR_DBCOLUMNID *pcid, CURSOR_DBBINDPARAMS *pBindParams, DWORD *pdwFlags)
{
    ASSERT_POINTER(pcid, CURSOR_DBCOLUMNID)
    ASSERT_POINTER(pBindParams, CURSOR_DBBINDPARAMS)
    ASSERT_NULL_OR_POINTER(pdwFlags, DWORD)

    // make sure rowset is valid
    if (!IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_FAIL;
    }

    // make sure we have all necessary pointers
    if (!pcid || !pBindParams || !pBindParams->pData)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // make sure we are in update or add mode
    if (m_pCursorPosition->GetEditMode() == CURSOR_DBEDITMODE_NONE)
    {
        VDSetErrorInfo(IDS_ERR_STATEERROR, IID_ICursorUpdateARow, m_pResourceDLL);
        return CURSOR_DB_E_STATEERROR;
    }

    CVDRowsetColumn * pColumn;

    // validate cursor binding parameters and get rowset column
    HRESULT hr = ValidateCursorBindParams(pcid, pBindParams, &pColumn);

    if (FAILED(hr))
        return hr;

    // get column update pointer for this column
    CVDColumnUpdate * pColumnUpdate = m_pCursorPosition->GetColumnUpdate(pColumn->GetNumber());

    // if not changed, get original value
    if (!pColumnUpdate)
    {
        hr = GetOriginalColumn(pColumn, pBindParams);

        if (pdwFlags)
            *pdwFlags = CURSOR_DBCOLUMNDATA_UNCHANGED;
    }
    else // otherwise, get modified value
    {
        hr = GetModifiedColumn(pColumnUpdate, pBindParams);

        if (pdwFlags)
            *pdwFlags = CURSOR_DBCOLUMNDATA_CHANGED;
    }

    return hr;
}

//=--------------------------------------------------------------------------=
// ICursorUpdateARow GetEditMode
//=--------------------------------------------------------------------------=
// Gets the current edit mode: add, update or none
//
// Parameters:
//	pdwState        - [out] a pointer to memory in which to return the
//                          current edit mode
//
// Output:
//    HRESULT - S_OK if successful
//              E_FAIL a provider-specific error occured
//              E_INVALIDARG bad parameter
//
// Notes:
//
HRESULT CVDCursor::GetEditMode(DWORD *pdwState)
{
    ASSERT_POINTER(pdwState, DWORD)

    // make sure we have a valid rowset
    if (!IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_FAIL;
    }

    // make sure we have a pointer
    if (!pdwState)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // return edit mode
    *pdwState = m_pCursorPosition->GetEditMode();

    return S_OK;
}

//=--------------------------------------------------------------------------=
// ICursorUpdateARow Update
//=--------------------------------------------------------------------------=
// Sends the contents of the edit buffer to the database and optionally
// returns the bookmark for the updated or added row
//
// Parameters:
//	pBookmarkType   - [in]  a pointer to a columnID that specifies the type
//                          of bookmark desired
//  pcbBookmark     - [out] a pointer to memory in which to return the actual
//                          length of the returned bookmark
//  ppBookmark      - [out] a pointer to memory in which to return a pointer
//                          to a bookmark
//
// Output:
//    HRESULT - S_OK if successful
//              E_FAIL a provider-specific error occured
//              E_OUTOFMEMORY not enough memory
//              CURSOR_DB_E_STATEERROR not in update or add mode
//
// Notes:
//    Kagera does not allow variant bindings on dbtimestamp fields, so this code
//    updates dbtimestamp fields using string pointers if possible.
//
HRESULT CVDCursor::Update(CURSOR_DBCOLUMNID *pBookmarkType, ULONG *pcbBookmark, void **ppBookmark)
{
    ASSERT_NULL_OR_POINTER(pBookmarkType, CURSOR_DBCOLUMNID)
    ASSERT_NULL_OR_POINTER(pcbBookmark, ULONG)
    ASSERT_NULL_OR_POINTER(ppBookmark, void*)

    IAccessor * pAccessor = GetAccessor();
    IRowsetChange * pRowsetChange = GetRowsetChange();
	IRowsetUpdate * pRowsetUpdate = GetRowsetUpdate();
	BOOL fUndo = FALSE;
	BOOL fInsert = FALSE;

    // make sure we have valid accessor and change pointers
    if (!pAccessor || !pRowsetChange || !IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_FAIL;
    }

    // get current edit mode
    const DWORD dwEditMode = m_pCursorPosition->GetEditMode();

    // make sure we are in update or add mode
    if (dwEditMode == CURSOR_DBEDITMODE_NONE)
    {
        VDSetErrorInfo(IDS_ERR_STATEERROR, IID_ICursorUpdateARow, m_pResourceDLL);
        return CURSOR_DB_E_STATEERROR;
    }


    // get hRow of the row currently being edited
    HROW hRow = m_pCursorPosition->GetEditRow();

    // get column count
    const ULONG ulColumns = GetCursorMain()->GetColumnsCount();

    // create update buffer accessor bindings
    DBBINDING * pBindings = new DBBINDING[ulColumns];

    if (!pBindings)
    {
		VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_OUTOFMEMORY;
    }

    // clear out bindings
    memset(pBindings, 0, ulColumns * sizeof(DBBINDING));

    // setup notification structures
   	DWORD dwEventWhat = CURSOR_DBEVENT_CURRENT_ROW_DATA_CHANGED |
                        CURSOR_DBEVENT_NONCURRENT_ROW_DATA_CHANGED |
                        CURSOR_DBEVENT_SET_OF_ROWS_CHANGED;

	CURSOR_DBNOTIFYREASON rgReasons[1];
	VariantInit((VARIANT*)&rgReasons[0].arg1);
	VariantInit((VARIANT*)&rgReasons[0].arg2);

    switch (dwEditMode)
    {
        case CURSOR_DBEDITMODE_UPDATE:
	        rgReasons[0].dwReason   = CURSOR_DBREASON_MODIFIED;
	        rgReasons[0].arg1       = m_pCursorPosition->m_bmCurrent.GetBookmarkVariant();
            break;

        case CURSOR_DBEDITMODE_ADD:
	        rgReasons[0].dwReason   = CURSOR_DBREASON_INSERTED;
	        rgReasons[0].arg1       = m_pCursorPosition->m_bmAddRow.GetBookmarkVariant();
            break;
    }
	
    // notify other interested parties of action
	HRESULT hr = m_pCursorPosition->NotifyBefore(dwEventWhat, 1, rgReasons);

	// make sure action was not cancelled
	if (hr != S_OK)
    {
        // destroy bindings
        delete [] pBindings;

        VDSetErrorInfo(IDS_ERR_ACTIONCANCELLED, IID_ICursorUpdateARow, m_pResourceDLL);
		return E_FAIL;
    }

    // variables
    ULONG cBindings = 0;
    DBBINDING * pBinding = pBindings;
    CVDColumnUpdate * pColumnUpdate;
    ULONG obUpdate = 0;

    // iterate through columns and setup binding structures
    for (ULONG ulCol = 0; ulCol < ulColumns; ulCol++)
    {
        // get column update pointer
        pColumnUpdate = m_pCursorPosition->GetColumnUpdate(ulCol);

        if (pColumnUpdate)
        {
            // create column update buffer binding
            pBinding->iOrdinal      = pColumnUpdate->GetColumn()->GetOrdinal();
            pBinding->obValue       = obUpdate + sizeof(DBSTATUS) + sizeof(ULONG);
            pBinding->obLength      = obUpdate + sizeof(DBSTATUS);
            pBinding->obStatus      = obUpdate;
            pBinding->dwPart        = DBPART_VALUE;
            pBinding->dwMemOwner    = DBMEMOWNER_CLIENTOWNED;
            pBinding->wType         = DBTYPE_VARIANT;

            // determine if length part is included
            if (pColumnUpdate->GetVarDataLen() != CURSOR_DB_NOVALUE)
                pBinding->dwPart |= DBPART_LENGTH;

			pBinding->dwPart |= DBPART_STATUS;

            // check for variant binding on dbtimestamp field, and supplied variant is a bstr
            if (pColumnUpdate->GetColumn()->GetType() == DBTYPE_DBTIMESTAMP && pColumnUpdate->GetVariantType() == VT_BSTR)
            {
                pBinding->dwPart &= ~DBPART_LENGTH;
                pBinding->wType   = DBTYPE_BYREF | DBTYPE_WSTR;
            }

            // increment update offset
            obUpdate += sizeof(DBSTATUS) + sizeof(ULONG) + sizeof(VARIANT);

            // increment binding
            cBindings++;
            pBinding++;
        }
    }

    // if we have any bindings, then update
    if (cBindings)
    {
        HACCESSOR hAccessor;

        // create update accessor
  	    hr = pAccessor->CreateAccessor(DBACCESSOR_ROWDATA, cBindings, pBindings, 0, &hAccessor, NULL);

	    hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_CREATEACCESSORFAILED, IID_ICursorUpdateARow, pAccessor, IID_IAccessor,
            m_pResourceDLL);

        if (FAILED(hr))
        {
            // destroy bindings
            delete [] pBindings;

            // notify other interested parties of failure
		    m_pCursorPosition->NotifyFail(dwEventWhat, 1, rgReasons);
            return hr;
        }

        // create update buffer
        BYTE * pBuffer = new BYTE[cBindings * (sizeof(DBSTATUS) + sizeof(ULONG) + sizeof(VARIANT))];
		BYTE * pBufferOld = new BYTE[cBindings * (sizeof(DBSTATUS) + sizeof(ULONG) + sizeof(VARIANT))];

        if (!pBuffer || !pBufferOld)
        {
            // destroy bindings
            delete [] pBindings;

			// destroy buffers
			delete [] pBuffer;
			delete [] pBufferOld;

            // release update accessor
      	    pAccessor->ReleaseAccessor(hAccessor, NULL);

            // notify other interested parties of failure
		    m_pCursorPosition->NotifyFail(dwEventWhat, 1, rgReasons);
            return E_OUTOFMEMORY;
        }


        // variables
        obUpdate = 0;
        pBinding = pBindings;
        CURSOR_DBVARIANT variant;

        // iterate through columns and setup buffer
        for (ULONG ulCol = 0; ulCol < ulColumns; ulCol++)
        {
            // get column update pointer
            pColumnUpdate = m_pCursorPosition->GetColumnUpdate(ulCol);

            if (pColumnUpdate)
            {
				// obtain current status
				DBSTATUS status = CursorInfoToStatus(pColumnUpdate->GetInfo());

				// get value
				variant = pColumnUpdate->GetVariant();

				// check for empty value since some controls treat this as NULL and make sure that we
				// treat the empty value as null
				if (status == DBSTATUS_S_OK &&
					variant.vt == VT_BSTR &&
					wcslen(variant.bstrVal) == 0)
					{
					*(DBSTATUS*)(pBuffer + obUpdate) = DBSTATUS_S_ISNULL;
					}
				else
					{
					*(DBSTATUS*)(pBuffer + obUpdate) = status;
					}

				*(DBSTATUS*)(pBufferOld + obUpdate) = DBSTATUS_S_ISNULL;

                // if necessary, set length part in buffer
                if (pBinding->dwPart & DBPART_LENGTH)
					{
                    *(ULONG*)(pBuffer + obUpdate + sizeof(DBSTATUS)) = pColumnUpdate->GetVarDataLen();
					*(ULONG*)(pBufferOld + obUpdate + sizeof(DBSTATUS)) = 0;
					}

                // always set value part in buffer
                if (pBinding->wType == (DBTYPE_BYREF | DBTYPE_WSTR))
					{
                    *(BSTR*)(pBuffer + obUpdate + sizeof(DBSTATUS) + sizeof(ULONG)) = variant.bstrVal;
					*(BSTR*)(pBufferOld + obUpdate + sizeof(DBSTATUS) + sizeof(ULONG)) = NULL;
					}
                else
					{
                    memcpy(pBuffer + obUpdate + sizeof(DBSTATUS) + sizeof(ULONG), &variant, sizeof(VARIANT));
					VariantInit((VARIANT *) (pBufferOld + obUpdate + sizeof(DBSTATUS) + sizeof(ULONG)));
					}

                // increment update offset
                obUpdate += sizeof(DBSTATUS) + sizeof(ULONG) + sizeof(VARIANT);

                // increment binding
                pBinding++;
            }
        }

		DBPENDINGSTATUS status;

	    if (dwEditMode == CURSOR_DBEDITMODE_ADD)
			fInsert = TRUE;
		else if (pRowsetUpdate)
			{
			pRowsetUpdate->GetRowStatus(NULL, 1, &hRow, &status);
			if (status == DBPENDINGSTATUS_UNCHANGED)
				fUndo = TRUE;
			}


		if (!fUndo && !fInsert)
			{
            hr = GetRowset()->GetData(hRow, hAccessor, pBufferOld);
			if (status != DBPENDINGSTATUS_NEW)
				fUndo = TRUE;
			}

        // modify columns (set/clear internal set data flag)
        GetCursorMain()->SetInternalSetData(TRUE);
        hr = pRowsetChange->SetData(hRow, hAccessor, pBuffer);
		if (hr == DB_S_ERRORSOCCURRED)
			{
			// since partial changes occurred, restore data back
			// to original values.
			if (fUndo)
				pRowsetUpdate->Undo(NULL, 1, &hRow, NULL, NULL, NULL);
			else if (status != DBPENDINGSTATUS_NEW)
				pRowsetChange->SetData(hRow, hAccessor, pBufferOld);

			hr = DB_E_ERRORSOCCURRED;
			}

        GetCursorMain()->SetInternalSetData(FALSE);

	    hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_SETDATAFAILED, IID_ICursorUpdateARow, pRowsetChange, IID_IRowsetChange,
            m_pResourceDLL);

        // release update accessor
  	    pAccessor->ReleaseAccessor(hAccessor, NULL);

		obUpdate = 0;
		pBinding = pBindings;
		// iterate through columns and reset buffer
        for (ulCol = 0; ulCol < ulColumns; ulCol++)
        {
            if (m_pCursorPosition->GetColumnUpdate(ulCol))
            {
				VARIANT var;

                if (pBinding->wType == (DBTYPE_BYREF | DBTYPE_WSTR))
					{
					var.vt = VT_BSTR;
					var.bstrVal = *(BSTR*)(pBufferOld + obUpdate + sizeof(DBSTATUS) + sizeof(ULONG));
					}
                else
					{
                    memcpy(&var, pBufferOld + obUpdate + sizeof(DBSTATUS) + sizeof(ULONG), sizeof(VARIANT));
					}

			    VariantClear(&var);

                // increment update offset
                obUpdate += sizeof(DBSTATUS) + sizeof(ULONG) + sizeof(VARIANT);

                // increment binding
                pBinding++;
            }
        }


        // destroy update buffer
        delete [] pBuffer;
		delete [] pBufferOld;
    }

    // destroy bindings
    delete [] pBindings;

    if (FAILED(hr))
    {
        // notify other interested parties of failure
	    m_pCursorPosition->NotifyFail(dwEventWhat, 1, rgReasons);
    }
    else
    {
        // return bookmark if requested to do so
        if (pBookmarkType && pcbBookmark && ppBookmark)
        {
            switch (dwEditMode)
            {
                case CURSOR_DBEDITMODE_UPDATE:
        		    *pcbBookmark = m_pCursorPosition->m_bmCurrent.GetBookmarkLen();
        		    memcpy(*ppBookmark, m_pCursorPosition->m_bmCurrent.GetBookmark(), *pcbBookmark);
                    break;

                case CURSOR_DBEDITMODE_ADD:
        		    *pcbBookmark = m_pCursorPosition->m_bmAddRow.GetBookmarkLen();
		            memcpy(*ppBookmark, m_pCursorPosition->m_bmAddRow.GetBookmark(), *pcbBookmark);
                    break;
            }
        }

        //  if acquired, release same-row clone
        if (m_pCursorPosition->GetSameRowClone())
            m_pCursorPosition->ReleaseSameRowClone();

        // also, release add row if we have one
        if (m_pCursorPosition->m_bmAddRow.GetHRow())
            m_pCursorPosition->ReleaseAddRow();

        // reset edit mode
        m_pCursorPosition->SetEditMode(CURSOR_DBEDITMODE_NONE);

		// reset column updates
		m_pCursorPosition->ResetColumnUpdates();

        // notify other interested parties of success
	    m_pCursorPosition->NotifyAfter(dwEventWhat, 1, rgReasons);
    }

    return hr;
}

//=--------------------------------------------------------------------------=
// ICursorUpdateARow Cancel
//=--------------------------------------------------------------------------=
// Cancels the update or add operation
//
// Parameters:
//              none
//
// Output:
//    HRESULT - S_OK if successful
//              E_FAIL a provider-specific error occured
//              CURSOR_DB_E_STATEERROR not in update or add mode
//
// Notes:
//
HRESULT CVDCursor::Cancel(void)
{
    // make sure we have a valid rowset
    if (!IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_FAIL;
    }

    // get current edit mode
    const DWORD dwEditMode = m_pCursorPosition->GetEditMode();

    // make sure we are in update or add mode
    if (dwEditMode == CURSOR_DBEDITMODE_NONE)
    {
        VDSetErrorInfo(IDS_ERR_STATEERROR, IID_ICursorUpdateARow, m_pResourceDLL);
        return CURSOR_DB_E_STATEERROR;
    }

    // try to get update pointer
    IRowsetUpdate * pRowsetUpdate = GetRowsetUpdate();

    // get hRow of the row currently being edited
    HROW hRow = m_pCursorPosition->GetEditRow();

    // setup notification structures
    DWORD dwEventWhat = CURSOR_DBEVENT_CURRENT_ROW_DATA_CHANGED;

    CURSOR_DBNOTIFYREASON rgReasons[1];
    VariantInit((VARIANT*)&rgReasons[0].arg1);
    VariantInit((VARIANT*)&rgReasons[0].arg2);

    rgReasons[0].dwReason = CURSOR_DBREASON_CANCELUPDATE;

    // notify other interested parties of action
    HRESULT hr = m_pCursorPosition->NotifyBefore(dwEventWhat, 1, rgReasons);

    // make sure action was not cancelled
    if (hr != S_OK)
    {
        VDSetErrorInfo(IDS_ERR_ACTIONCANCELLED, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_FAIL;
    }

    // if we are comming out of add mode, undo inserted row
    if (pRowsetUpdate && dwEditMode == CURSOR_DBEDITMODE_ADD)
    {
        hr = pRowsetUpdate->Undo(0, 1, &hRow, NULL, NULL, NULL);

        hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_UNDOFAILED, IID_ICursorUpdateARow, pRowsetUpdate, IID_IRowsetUpdate,
            m_pResourceDLL);

        if (FAILED(hr))
        {
            // notify other interested parties of failure
            m_pCursorPosition->NotifyFail(dwEventWhat, 1, rgReasons);
            return hr;
        }
    }

    // if acquired, release same-row clone
    if (m_pCursorPosition->GetSameRowClone())
        m_pCursorPosition->ReleaseSameRowClone();

    // also, release add row if we have one
    if (m_pCursorPosition->m_bmAddRow.GetHRow())
        m_pCursorPosition->ReleaseAddRow();

    // reset edit mode
    m_pCursorPosition->SetEditMode(CURSOR_DBEDITMODE_NONE);

    // reset column updates
    m_pCursorPosition->ResetColumnUpdates();

    // notify other interested parties of success
    m_pCursorPosition->NotifyAfter(dwEventWhat, 1, rgReasons);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// ICursorUpdateARow Delete
//=--------------------------------------------------------------------------=
// Deletes the current row
//
// Parameters:
//              none
//
// Output:
//    HRESULT - S_OK if successful
//              E_FAIL a provider-specific error occured
//              CURSOR_DB_E_UPDATEINPROGRESS an update is already in progress
//
// Notes:
//
HRESULT CVDCursor::Delete(void)
{
	IRowsetChange * pRowsetChange = GetRowsetChange();

    // make sure we have a valid change pointer
    if (!pRowsetChange || !IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_ICursorUpdateARow, m_pResourceDLL);
        return E_FAIL;
    }

    // make sure that an update is not already in progress
    if (m_pCursorPosition->GetEditMode() != CURSOR_DBEDITMODE_NONE)
    {
        VDSetErrorInfo(IDS_ERR_UPDATEINPROGRESS, IID_ICursorUpdateARow, m_pResourceDLL);
        return CURSOR_DB_E_UPDATEINPROGRESS;
    }

    // get current hRow
    HROW hRow = m_pCursorPosition->m_bmCurrent.GetHRow();

    // setup notification structures
   	DWORD dwEventWhat = CURSOR_DBEVENT_CURRENT_ROW_DATA_CHANGED |
                        CURSOR_DBEVENT_SET_OF_ROWS_CHANGED;

	CURSOR_DBNOTIFYREASON rgReasons[1];
	VariantInit((VARIANT*)&rgReasons[0].arg1);
	VariantInit((VARIANT*)&rgReasons[0].arg2);
	
	rgReasons[0].dwReason   = CURSOR_DBREASON_DELETED;
	rgReasons[0].arg1       = m_pCursorPosition->m_bmCurrent.GetBookmarkVariant();

    // notify other interested parties of action
	HRESULT hr = m_pCursorPosition->NotifyBefore(dwEventWhat, 1, rgReasons);

	// make sure action was not cancelled
	if (hr != S_OK)
    {
        VDSetErrorInfo(IDS_ERR_ACTIONCANCELLED, IID_ICursorUpdateARow, m_pResourceDLL);
		return E_FAIL;
    }

    // try to delete current row (set/clear internal delete rows flag)
    GetCursorMain()->SetInternalDeleteRows(TRUE);
    hr = pRowsetChange->DeleteRows(0, 1, &hRow, NULL);
    GetCursorMain()->SetInternalDeleteRows(FALSE);

    hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_DELETEROWSFAILED, IID_ICursorUpdateARow, pRowsetChange, IID_IRowsetChange,
        m_pResourceDLL);

    if (FAILED(hr))
    {
        // notify other interested parties of failure
		m_pCursorPosition->NotifyFail(dwEventWhat, 1, rgReasons);
    }
    else
    {
        // notify other interested parties of success
	    m_pCursorPosition->NotifyAfter(dwEventWhat, 1, rgReasons);
    }

    return hr;
}

//=--------------------------------------------------------------------------=
// ICursorFind methods
//=--------------------------------------------------------------------------=
// ICursorFind FindByValues
//
HRESULT CVDCursor::FindByValues(ULONG cbBookmark,
								LPVOID pBookmark,
								DWORD dwFindFlags,
								ULONG cValues,
								CURSOR_DBCOLUMNID rgColumns[],
								CURSOR_DBVARIANT rgValues[],
								DWORD rgdwSeekFlags[],
								CURSOR_DBFETCHROWS FAR *pFetchParams)
{
	//////////////////////////////////////////////////////////////////////////
	// this implementation limits the number of columns that can be searched
	// to one, since current OLEDB spec only allows a single column accessor
	// to be passed to IRowsetFind::FindNextRow (06/11/97)
	//
	if (cValues > 1)
		return E_FAIL;
	//
	//////////////////////////////////////////////////////////////////////////

	IAccessor * pAccessor = GetAccessor();
	IRowsetFind * pRowsetFind = GetRowsetFind();

    // make sure we have valid accessor and find pointers
    if (!pAccessor || !pRowsetFind || !IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_IEntryID, m_pResourceDLL);
        return E_FAIL;
    }

	// check for values
	if (!cValues)
		return S_OK;

	DWORD dwEventWhat = CURSOR_DBEVENT_CURRENT_ROW_CHANGED;

	CURSOR_DBNOTIFYREASON rgReasons[1];
	rgReasons[0].dwReason	= CURSOR_DBREASON_FIND;
	
	VariantInit((VARIANT*)&rgReasons[0].arg1);
	rgReasons[0].arg1.vt	= VT_UI4;
	rgReasons[0].arg1.lVal	= dwFindFlags;

	VariantInit((VARIANT*)&rgReasons[0].arg2);

    // notify other interested parties
	HRESULT hr = m_pCursorPosition->NotifyBefore(dwEventWhat, 1, rgReasons);

    // make sure action was not cancelled
    if (hr != S_OK)
    {
        VDSetErrorInfo(IDS_ERR_ACTIONCANCELLED, IID_ICursorFind, m_pResourceDLL);
        return E_FAIL;
    }

	ULONG ul;
	HROW * pRow = NULL;
	ULONG cRowsObtained = 0;
    HACCESSOR hAccessor = NULL;

	// allocate necessary memory
	ULONG * pColumns = new ULONG[cValues];
	DBTYPE * pDBTypes = new DBTYPE[cValues];
	DBCOMPAREOP * pDBCompareOp = new DBCOMPAREOP[cValues];
	BYTE ** ppValues = new BYTE*[cValues];
	BOOL * fMemAllocated = new BOOL[cValues];

	if (fMemAllocated)
	{
		// always init fMemAllocated flags to false
		memset(fMemAllocated, 0, sizeof(BOOL) * cValues);
	}

	// make sure we received all requested memory
	if (!pColumns || !pDBTypes || !ppValues || !pDBCompareOp || !fMemAllocated)
	{
		VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_IRowsetFind, m_pResourceDLL);
		hr = E_OUTOFMEMORY;
		goto cleanup;
	}

	// iterate through columns
	for (ul = 0; ul < cValues; ul++)
	{
		// get column ordinal position
		hr = GetOrdinal(rgColumns[ul], &pColumns[ul]);
		
		if (FAILED(hr))
		{
			VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_IRowsetFind, m_pResourceDLL);
			hr = E_INVALIDARG;
			goto cleanup;
		}

		// get find values from CURSOR_DBVARIANT
		hr = GetDataFromDBVariant(&rgValues[ul],
								  &pDBTypes[ul],
								  &(ppValues[ul]),
								  &fMemAllocated[ul]);

		if (FAILED(hr))
		{
			VDSetErrorInfo(IDS_ERR_CANTCOERCE, IID_IRowsetFind, m_pResourceDLL);
			goto cleanup;
		}

		// setup seek flags
		switch (rgdwSeekFlags[ul])
		{
			case CURSOR_DBSEEK_LT:
				pDBCompareOp[ul] = DBCOMPAREOPS_LT;
				break;

			case CURSOR_DBSEEK_LE:
				pDBCompareOp[ul] = DBCOMPAREOPS_LE;
				break;

			case CURSOR_DBSEEK_EQ:
				pDBCompareOp[ul] = DBCOMPAREOPS_EQ;
				break;

			case CURSOR_DBSEEK_GE:
				pDBCompareOp[ul] = DBCOMPAREOPS_GE;
				break;

			case CURSOR_DBSEEK_GT:
				pDBCompareOp[ul] = DBCOMPAREOPS_GT;
				break;

			case CURSOR_DBSEEK_PARTIALEQ:
				pDBCompareOp[ul] = DBCOMPAREOPS_BEGINSWITH;
				break;

			default:
				VDSetErrorInfo(IDS_ERR_INVALIDSEEKFLAGS, IID_IRowsetFind, m_pResourceDLL);
				hr = E_FAIL;
				goto cleanup;
		}
	}

	LONG cRows;
	BOOL fSkipCurrent;

	// determine direction of seek
	if (CURSOR_DBFINDFLAGS_FINDPRIOR == dwFindFlags)
	{
		cRows		 = -1;
		fSkipCurrent = TRUE;
	}
	else
	{
		cRows		 = 1;
		fSkipCurrent = TRUE;
	}

	BYTE bSpecialBM;

	// check for standard bookmarks
	if (CURSOR_DB_BMK_SIZE == cbBookmark)
	{
		if (memcmp(&CURSOR_DBBMK_BEGINNING, pBookmark, CURSOR_DB_BMK_SIZE) == 0)
		{
			cbBookmark		= sizeof(BYTE);
			bSpecialBM		= DBBMK_FIRST;
			pBookmark		= &bSpecialBM;
			fSkipCurrent	= FALSE;
		}
		else
		if (memcmp(&CURSOR_DBBMK_END, pBookmark, CURSOR_DB_BMK_SIZE) == 0)
		{
			cbBookmark		= sizeof(BYTE);
			bSpecialBM		= DBBMK_LAST;
			pBookmark		= &bSpecialBM;
			fSkipCurrent	= FALSE;
		}
		else
		if (memcmp(&CURSOR_DBBMK_CURRENT, pBookmark, CURSOR_DB_BMK_SIZE) == 0)
		{
			cbBookmark	= m_pCursorPosition->m_bmCurrent.GetBookmarkLen();
			pBookmark	= m_pCursorPosition->m_bmCurrent.GetBookmark();
		}
	}

    DBBINDING binding;

    // clear out binding
    memset(&binding, 0, sizeof(DBBINDING));

    // create value binding
    binding.iOrdinal    = pColumns[0];
    binding.obValue     = 0;
    binding.dwPart      = DBPART_VALUE;
    binding.dwMemOwner	= DBMEMOWNER_CLIENTOWNED;
    binding.cbMaxLen    = 0x7FFFFFFF;
    binding.wType       = pDBTypes[0];

    // create accessor describing the value to be matched
	hr = pAccessor->CreateAccessor(DBACCESSOR_ROWDATA, 1, &binding, 0, &hAccessor, NULL);

	if (FAILED(hr))
		goto cleanup;

	// try to find hRow satisfying our condition
	hr = pRowsetFind->FindNextRow(DB_NULL_HCHAPTER, 
								  hAccessor,
								  ppValues[0],
								  pDBCompareOp[0],
								  cbBookmark,
								  (BYTE*)pBookmark,
								  fSkipCurrent,
								  cRows,
								  &cRowsObtained,
								  &pRow);

	// check to see if we rached end of rowset
	if (hr == DB_S_ENDOFROWSET && !cRowsObtained)
		hr = E_FAIL;

	if (FAILED(hr))
		hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_FINDFAILED, IID_ICursorFind, pRowsetFind, IID_IRowsetFind, m_pResourceDLL);

	// check to see if we got the hRow
	if (SUCCEEDED(hr) && cRowsObtained)
	{
		// allocate buffer for bookmark plus length indicator
		BYTE * pBuff = new BYTE[GetCursorMain()->GetMaxBookmarkLen() + sizeof(ULONG)];

		if (!pBuff)
			hr = E_OUTOFMEMORY;
		else
		{
			// get the bookmark data
			hr = GetRowset()->GetData(*pRow, GetCursorMain()->GetBookmarkAccessor(), pBuff);
			if (SUCCEEDED(hr))
			{
				ULONG * pulLen = (ULONG*)pBuff;
				BYTE * pbmdata = pBuff + sizeof(ULONG);
				LARGE_INTEGER dlOffset;
				dlOffset.HighPart	= 0;
				dlOffset.LowPart	= 0;
				hr = FetchAtBookmark(*pulLen, pbmdata, dlOffset, pFetchParams);
			}
			else
				hr = VDMapRowsetHRtoCursorHR(hr, IDS_ERR_GETDATAFAILED, IID_ICursorFind, pRowsetFind, IID_IRowset, m_pResourceDLL);

			delete [] pBuff;
		}

	}
	
	if (pRow)
	{
		// release hRow
		if (cRowsObtained)
			GetRowset()->ReleaseRows(1, pRow, NULL, NULL, NULL);
		g_pMalloc->Free(pRow);
	}

cleanup:

	rgReasons[0].arg2.vt		= VT_BOOL;
	V_BOOL(&rgReasons[0].arg2)	= SUCCEEDED(hr) ? TRUE : FALSE;

	if (SUCCEEDED(hr))
	{
        // notify other interested parties of success
		m_pCursorPosition->NotifyAfter(dwEventWhat, 1, rgReasons);
	}
	else
	{
        // notify other interested parties of failure
		m_pCursorPosition->NotifyFail(dwEventWhat, 1, rgReasons);
	}

	// free values
	if (ppValues && fMemAllocated)
	{
		for (ul = 0; ul < cValues; ul++)
		{
			if (fMemAllocated[ul] && ppValues[ul])
				g_pMalloc->Free(ppValues[ul]);
		}
	}

	// free memory
	delete [] pColumns;
	delete [] pDBTypes;
	delete [] ppValues;
	delete [] pDBCompareOp;
	delete [] fMemAllocated;

	// release accessor
	if (hAccessor)
	    pAccessor->ReleaseAccessor(hAccessor, NULL);

    return hr;
}

//=--------------------------------------------------------------------------=
// IEnrtyID methods
//=--------------------------------------------------------------------------=
// IEntryID GetInterface
//=--------------------------------------------------------------------------=
// Gets the requested interface pointer to the given entryID
//
// Parameters:
//  cbEntryID   - [in]  the size of the entryID
//  pEntryID    - [in]  a pointer to the entryID
//  dwFlags     - [in]  interface specific flags
//  riid        - [in]  the interface id for the interface desired
//  ppvObj      - [out] a pointer to memory in which to return interface pointer
//
// Output:
//    HRESULT - S_OK if successful
//              E_INVALIDARG bad parameter
//              E_OUTOFMEMORY not enough memory
//              E_FAIL a provider-specific error occured
//              E_NOINTERFACE no such interface supported
//              CURSOR_DB_E_BADENTRYID bad entry identifier
//
// Notes:
//
HRESULT CVDCursor::GetInterface(ULONG cbEntryID, void *pEntryID, DWORD dwFlags, REFIID riid, IUnknown **ppvObj)
{
    ASSERT_POINTER(pEntryID, BYTE)
    ASSERT_POINTER(ppvObj, IUnknown*)

	IRowset * pRowset = GetRowset();

    // make sure we have a valid rowset pointer
    if (!pRowset || !IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_IEntryID, m_pResourceDLL);
        return E_FAIL;
    }

    // make sure we have all necessary pointers
    if (!pEntryID || !ppvObj)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_IEntryID, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // init out parameter
    *ppvObj = NULL;

    HROW hRow;
    CVDRowsetColumn * pColumn;

    // validate supplied entryID, and get rowset column and hRow
    HRESULT hr = ValidateEntryID(cbEntryID, (BYTE*)pEntryID, &pColumn, &hRow);

    if (FAILED(hr))
        return hr;

    IUnknown * pUnknown = NULL;

    // first, try to get requested interface from entry identifier
    hr = QueryEntryIDInterface(pColumn, hRow, dwFlags, riid, &pUnknown);

    // if we succeeded or caller is not asking for IStream then leave
    if (SUCCEEDED(hr) || riid != IID_IStream)
    {
        // release reference on hRow
        pRowset->ReleaseRows(1, &hRow, NULL, NULL, NULL);
        *ppvObj = pUnknown;
        return hr;
    }

#ifndef VD_DONT_IMPLEMENT_ISTREAM

    IStream * pStream;

    // create stream from entry identifier
    hr = CreateEntryIDStream(pColumn, hRow, &pStream);

    if (FAILED(hr))
    {
        // release reference on hRow
        pRowset->ReleaseRows(1, &hRow, NULL, NULL, NULL);
        return hr;
    }

    CVDEntryIDData * pEntryIDData;

    // create entryID data object
    hr = CVDEntryIDData::Create(m_pCursorPosition, pColumn, hRow, pStream, &pEntryIDData, m_pResourceDLL);

    // release reference on hRow
    pRowset->ReleaseRows(1, &hRow, NULL, NULL, NULL);

    // release reference on stream
    pStream->Release();

    if (FAILED(hr))
        return hr;

    CVDStream * pVDStream;

    // create viaduct stream object
    hr = CVDStream::Create(pEntryIDData, pStream, &pVDStream, m_pResourceDLL);

    // release reference on entryID data object
    pEntryIDData->Release();

    if (FAILED(hr))
        return hr;

    // return stream
    *ppvObj = pVDStream;

    return S_OK;

#else //VD_DONT_IMPLEMENT_ISTREAM

    // release reference on hRow
    pRowset->ReleaseRows(1, &hRow, NULL, NULL, NULL);

    VDSetErrorInfo(IDS_ERR_NOINTERFACE, IID_IEntryID, m_pResourceDLL);
    return E_NOINTERFACE;

#endif //VD_DONT_IMPLEMENT_ISTREAM
}

/////////////////////////////////////////////////////////////////////////
// CVDNotifier functions
/////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
// Member:		Notify Fail (public)
//
// Synopsis:	send NotifyFail notification
//
// Arguments:	dwEventWhat	[in] what event is causing the notification
//				cReasons	[in] how many reasons
//				rgReasons	[in] list of reasons for the event
//
// Returns:		S_OK		it worked

HRESULT
CVDCursor::NotifyFail(DWORD dwEventWhat, ULONG cReasons,
					   CURSOR_DBNOTIFYREASON rgReasons[])
{
    CVDNotifyDBEventsConnPt * pNotifyDBEventsConnPt = m_pConnPtContainer->GetNotifyDBEventsConnPt();

    UINT uiConnectionsActive = pNotifyDBEventsConnPt->GetConnectionsActive();

    INotifyDBEvents ** ppNotifyDBEvents = pNotifyDBEventsConnPt->GetNotifyDBEventsTable();

    for (UINT uiConn = 0; uiConn < uiConnectionsActive; uiConn++)
		ppNotifyDBEvents[uiConnectionsActive - uiConn - 1]->FailedToDo(dwEventWhat, cReasons, rgReasons);

    return S_OK;
}



/////////////////////////////////////////////////////////////////////////
// CCursorNotifier helper functions
/////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
// Member:		Notify OK To Do (public)
//
// Synopsis:	Send OKToDo notification.  If a client objects (by
//				returning a non-zero HR, send FailedToDo to notified
//				clients to cancel the event.
//
// Arguments:	dwEventWhat	[in] what event is causing the notification
//				cReasons	[in] how many reasons
//				rgReasons	[in] list of reasons for the event
//
// Returns:		S_OK		all clients agree it's OK to do the event
//				other		some client disagrees

HRESULT
CVDCursor::NotifyOKToDo(DWORD dwEventWhat, ULONG cReasons,
						 CURSOR_DBNOTIFYREASON rgReasons[])
{
    HRESULT hr = S_OK;

    CVDNotifyDBEventsConnPt * pNotifyDBEventsConnPt = m_pConnPtContainer->GetNotifyDBEventsConnPt();

    UINT uiConnectionsActive = pNotifyDBEventsConnPt->GetConnectionsActive();

    INotifyDBEvents ** ppNotifyDBEvents = pNotifyDBEventsConnPt->GetNotifyDBEventsTable();

    for (UINT uiConn = 0; uiConn < uiConnectionsActive; uiConn++)
	{
		hr = ppNotifyDBEvents[uiConnectionsActive - uiConn - 1]->OKToDo(dwEventWhat, cReasons, rgReasons);
		if (S_OK != hr)
		{
			for (UINT ui = 0; ui <= uiConn; ui++)	
				ppNotifyDBEvents[uiConnectionsActive - ui - 1]->Cancelled(dwEventWhat, cReasons, rgReasons);
			break;
		}
	}

    return hr;
}


//+-------------------------------------------------------------------------
// Member:		Notify Sync Before (public)
//
// Synopsis:	Send SyncBefore notification
//
// Arguments:	dwEventWhat	[in] what event is causing the notification
//				cReasons	[in] how many reasons
//				rgReasons	[in] list of reasons for the event
//
// Returns:		S_OK		all clients received notification
//				other		some client returned an error

HRESULT
CVDCursor::NotifySyncBefore(DWORD dwEventWhat, ULONG cReasons,
							 CURSOR_DBNOTIFYREASON rgReasons[])
{
    HRESULT hr = S_OK;

    CVDNotifyDBEventsConnPt * pNotifyDBEventsConnPt = m_pConnPtContainer->GetNotifyDBEventsConnPt();

    UINT uiConnectionsActive = pNotifyDBEventsConnPt->GetConnectionsActive();

    INotifyDBEvents ** ppNotifyDBEvents = pNotifyDBEventsConnPt->GetNotifyDBEventsTable();

    for (UINT uiConn = 0; uiConn < uiConnectionsActive; uiConn++)
	{
		hr = ppNotifyDBEvents[uiConnectionsActive - uiConn - 1]->SyncBefore(dwEventWhat, cReasons, rgReasons);
		if (S_OK != hr)
			break;
	}

    return hr;
}


//+-------------------------------------------------------------------------
// Member:		Notify About To Do (public)
//
// Synopsis:	Send AboutToDo notification
//
// Arguments:	dwEventWhat	[in] what event is causing the notification
//				cReasons	[in] how many reasons
//				rgReasons	[in] list of reasons for the event
//
// Returns:		S_OK		all clients notified
//				other		some client returned an error

HRESULT
CVDCursor::NotifyAboutToDo(DWORD dwEventWhat, ULONG cReasons,
							CURSOR_DBNOTIFYREASON rgReasons[])
{
    HRESULT hr = S_OK;

    CVDNotifyDBEventsConnPt * pNotifyDBEventsConnPt = m_pConnPtContainer->GetNotifyDBEventsConnPt();

    UINT uiConnectionsActive = pNotifyDBEventsConnPt->GetConnectionsActive();

    INotifyDBEvents ** ppNotifyDBEvents = pNotifyDBEventsConnPt->GetNotifyDBEventsTable();

    for (UINT uiConn = 0; uiConn < uiConnectionsActive; uiConn++)
	{
		hr = ppNotifyDBEvents[uiConnectionsActive - uiConn - 1]->AboutToDo(dwEventWhat, cReasons, rgReasons);
		if (S_OK != hr)
			break;
	}

    return hr;
}


//+-------------------------------------------------------------------------
// Member:		Notify Sync After (public)
//
// Synopsis:	Send SyncAfter notification.
//
// Arguments:	dwEventWhat	[in] what event is causing the notification
//				cReasons	[in] how many reasons
//				rgReasons	[in] list of reasons for the event
//
// Returns:		S_OK		all clients notified

HRESULT
CVDCursor::NotifySyncAfter(DWORD dwEventWhat, ULONG cReasons,
								CURSOR_DBNOTIFYREASON rgReasons[])
{
    CVDNotifyDBEventsConnPt * pNotifyDBEventsConnPt = m_pConnPtContainer->GetNotifyDBEventsConnPt();

    UINT uiConnectionsActive = pNotifyDBEventsConnPt->GetConnectionsActive();

    INotifyDBEvents ** ppNotifyDBEvents = pNotifyDBEventsConnPt->GetNotifyDBEventsTable();

    for (UINT uiConn = 0; uiConn < uiConnectionsActive; uiConn++)
		ppNotifyDBEvents[uiConnectionsActive - uiConn - 1]->SyncAfter(dwEventWhat, cReasons, rgReasons);

    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:		Notify Did Event (public)
//
// Synopsis:	Send DidEvent notification
//
// Arguments:	dwEventWhat	[in] what event is causing the notification
//				cReasons	[in] how many reasons
//				rgReasons	[in] list of reasons for the event
//
// Returns:		S_OK		all clients notified

HRESULT
CVDCursor::NotifyDidEvent(DWORD dwEventWhat, ULONG cReasons,
							   CURSOR_DBNOTIFYREASON rgReasons[])
{
    CVDNotifyDBEventsConnPt * pNotifyDBEventsConnPt = m_pConnPtContainer->GetNotifyDBEventsConnPt();

    UINT uiConnectionsActive = pNotifyDBEventsConnPt->GetConnectionsActive();

    INotifyDBEvents ** ppNotifyDBEvents = pNotifyDBEventsConnPt->GetNotifyDBEventsTable();

    for (UINT uiConn = 0; uiConn < uiConnectionsActive; uiConn++)
		ppNotifyDBEvents[uiConnectionsActive - uiConn - 1]->DidEvent(dwEventWhat, cReasons, rgReasons);

    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:		Notify Cancel (public)
//
// Synopsis:	Send Cancelled notification
//
// Arguments:	dwEventWhat	[in] what event is causing the notification
//				cReasons	[in] how many reasons
//				rgReasons	[in] list of reasons for the event
//
// Returns:		S_OK		all clients notified

HRESULT
CVDCursor::NotifyCancel(DWORD dwEventWhat, ULONG cReasons,
						 	 CURSOR_DBNOTIFYREASON rgReasons[])
{
    CVDNotifyDBEventsConnPt * pNotifyDBEventsConnPt = m_pConnPtContainer->GetNotifyDBEventsConnPt();

    UINT uiConnectionsActive = pNotifyDBEventsConnPt->GetConnectionsActive();

    INotifyDBEvents ** ppNotifyDBEvents = pNotifyDBEventsConnPt->GetNotifyDBEventsTable();

    for (UINT uiConn = 0; uiConn < uiConnectionsActive; uiConn++)
		ppNotifyDBEvents[uiConnectionsActive - uiConn - 1]->Cancelled(dwEventWhat, cReasons, rgReasons);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\debug.cpp ===
//=--------------------------------------------------------------------------=
// Debug.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains various methods that will only really see any use in DEBUG builds
//

#include "stdafx.h"   // not really used here, but NT Build env. doesn't like
                      // some files in a dir to have pre-comp hdrs & some not
#ifdef _DEBUG


#include "IPServer.H"
#include <stdlib.h>


//=--------------------------------------------------------------------------=
// Private Constants
//---------------------------------------------------------------------------=
//
static char szFormat[]  = "%s\nFile %s, Line %d";
static char szFormat2[] = "%s\n%s\nFile %s, Line %d";
LPSTR Deb_lpszAssertInfo = NULL;

#define _SERVERNAME_ "Viaduct"

static char szTitle[]  = _SERVERNAME_ " Assertion  (Abort = UAE, Retry = INT 3, Ignore = Continue)";


//=--------------------------------------------------------------------------=
// Local functions
//=--------------------------------------------------------------------------=
int NEAR _IdMsgBox(LPSTR pszText, LPSTR pszTitle, UINT mbFlags);

//=--------------------------------------------------------------------------=
// DisplayAssert
//=--------------------------------------------------------------------------=
// Display an assert message box with the given pszMsg, pszAssert, source
// file name, and line number. The resulting message box has Abort, Retry,
// Ignore buttons with Abort as the default.  Abort does a FatalAppExit;
// Retry does an int 3 then returns; Ignore just returns.
//
VOID DisplayAssert
(
    LPSTR	 pszMsg,
    LPSTR	 pszAssert,
    LPSTR	 pszFile,
    UINT	 line
)
{
    char	szMsg[250 * 2];
    LPSTR	lpszText;

    lpszText = pszMsg;		// Assume no file & line # info

    // If C file assert, where you've got a file name and a line #
    //
    if (pszFile) {

        // Was additional information supplied?
        //
        if (Deb_lpszAssertInfo) {

            // Then format the assert nicely, using this additional information:
            //
            wsprintf(szMsg, szFormat2, (pszMsg&&*pszMsg) ? pszMsg : pszAssert, Deb_lpszAssertInfo, pszFile, line);
            Deb_lpszAssertInfo = NULL;
	} else {

            // Then format the assert nicely without the extra information:
            //
            wsprintf(szMsg, szFormat, (pszMsg&&*pszMsg) ? pszMsg : pszAssert, pszFile, line);
        }

        lpszText = szMsg;
    }

    // Put up a dialog box
    //
    switch (_IdMsgBox(lpszText, szTitle, MB_ICONHAND|MB_ABORTRETRYIGNORE|MB_SYSTEMMODAL)) {
        case IDABORT:
            FatalAppExit(0, lpszText);
            return;

        case IDRETRY:
            // call the win32 api to break us.
            //
            DebugBreak();
            return;
    }

    return;
}


//=---------------------------------------------------------------------------=
// Beefed-up version of WinMessageBox.
//=---------------------------------------------------------------------------=
//
int NEAR _IdMsgBox
(
    LPSTR	pszText,
    LPSTR	pszTitle,
    UINT	mbFlags
)
{
    HWND hwndActive;
    int  id;

    hwndActive = GetActiveWindow();

    id = MessageBox(hwndActive, pszText, pszTitle, mbFlags);

    return id;
}


#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\debug.h ===
//=--------------------------------------------------------------------------=
// Debug.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the various macros and the like which are only useful in DEBUG
// builds
//
#ifndef _DEBUG_H_

//=---------------------------------------------------------------------------=
// all the things required to handle our ASSERT mechanism
//=---------------------------------------------------------------------------=
//
#ifdef _DEBUG

// Function Prototypes
//
VOID DisplayAssert(LPSTR pszMsg, LPSTR pszAssert, LPSTR pszFile, UINT line);

// Macros
//
// *** Include this macro at the top of any source file using *ASSERT*() macros ***
//
#define SZTHISFILE	static char _szThisFile[] = __FILE__;


// our versions of the ASSERT and FAIL macros.
//
#define ASSERT(fTest, szMsg)                                \
    if (!(fTest))  {                                        \
        static char szMsgCode[] = szMsg;                    \
        static char szAssert[] = #fTest;                    \
        DisplayAssert(szMsgCode, szAssert, _szThisFile, __LINE__); \
    }

#define ASSERT_(fTest)                                \
    if (!(fTest))  {                                        \
        static char szMsgCode[] = "Assertion failure";                    \
        static char szAssert[] = #fTest;                    \
        DisplayAssert(szMsgCode, szAssert, _szThisFile, __LINE__); \
    }

#define FAIL(szMsg)                                         \
        { static char szMsgCode[] = szMsg;                    \
        DisplayAssert(szMsgCode, "FAIL", _szThisFile, __LINE__); }


#define ASSERT_POINTER(p, type) \
	ASSERT(((p) != NULL) && !IsBadReadPtr((p), sizeof(type)), "Null or bad Pointer")

#define ASSERT_NULL_OR_POINTER(p, type) \
	ASSERT(((p) == NULL) || !IsBadReadPtr((p), sizeof(type)), "Bad Pointer")

#define ASSERT_POINTER_LEN(p, len) \
	ASSERT(((p) != NULL) && !IsBadReadPtr((p), len), "Null or bad Pointer")

#define ASSERT_POINTER_OCCURS(p, type, occurs) \
	ASSERT(((p) != NULL) && !IsBadReadPtr((p), sizeof(type) * occurs), "Null or bad Pointer")

// macro that checks a pointer for validity on input
//
#define CHECK_POINTER(val) if (!(val) || IsBadWritePtr((void *)(val), sizeof(void *))) return E_POINTER

// Viaduct 1
#define VD_ASSERTMSG_SEMAPHORECOUNTTOOLOW "Semaphore count too low"
#define VD_ASSERTMSG_SEMAPHOREWAITERROR "Semaphore wait failed"
#define VD_ASSERTMSG_OUTOFMEMORY "Out of memory"
#define VD_ASSERTMSG_BADSTATUS "Bad status"
#define VD_ASSERTMSG_UNKNOWNDBTYPE "Unknown DBTYPE"
#define VD_ASSERTMSG_BADCOLUMNINDEX "Bad column index"
#define VD_ASSERTMSG_INVALIDROWSTATUS "Invalid row status"
#define VD_ASSERTMSG_COLALREADYINITIALIZED "CVDColumn already initialized"
#define VD_ASSERTMSG_COLCOUNTDOESNTMATCH "Column counts don't match"
#define VD_ASSERTMSG_CANTDIVIDEBYZERO "Can't divide by zero"
#define VD_ASSERTMSG_CANTFINDRESOURCEDLL "Can't find error string resource dll."

// Viaduct 2
#define VD_ASSERTMSG_ROWSRCALREADYINITIALIZED "CVDRowsetSource already initialized"

#else  // DEBUG

#define SZTHISFILE
#define ASSERT_POINTER(p, type)
#define ASSERT_NULL_OR_POINTER(p, type)
#define ASSERT_POINTER_LEN(p, len)
#define ASSERT_POINTER_OCCURS(p, type, occurs) 
#define ASSERT(fTest, err)
#define ASSERT_(fTest)                               
#define FAIL(err)

#define CHECK_POINTER(val)

#define VD_ASSERTMSG_SEMAPHORECOUNTTOOLOW 0
#define VD_ASSERTMSG_SEMAPHOREWAITERROR 0
#define VD_ASSERTMSG_OUTOFMEMORY 0
#define VD_ASSERTMSG_BADSTATUS 0
#define VD_ASSERTMSG_UNKNOWNDBTYPE 0
#define VD_ASSERTMSG_BADCOLUMNINDEX 0
#define VD_ASSERTMSG_INVALIDROWSTATUS 0
#define VD_ASSERTMSG_COLALREADYINITIALIZED 0
#define VD_ASSERTMSG_COLCOUNTDOESNTMATCH 0
#define VD_ASSERTMSG_CANTDIVIDEBYZERO 0
#define VD_ASSERTMSG_CANTFINDRESOURCEDLL 0

#endif	// DEBUG




#define _DEBUG_H_
#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\entryid.cpp ===
//---------------------------------------------------------------------------
// EntryIDData.cpp : EntryIDData implementation
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"
 
#ifndef VD_DONT_IMPLEMENT_ISTREAM

#include "Notifier.h"        
#include "RSColumn.h"
#include "RSSource.h"
#include "CursMain.h"        
#include "ColUpdat.h"
#include "CursPos.h"        
#include "EntryID.h"         
#include "resource.h"         

SZTHISFILE


//=--------------------------------------------------------------------------=
// CVDEntryIDData - Constructor
//
CVDEntryIDData::CVDEntryIDData()
{
    m_dwRefCount        = 1;
    m_pCursorPosition   = NULL;
    m_pColumn           = NULL;
    m_hRow              = 0;
    m_pStream           = NULL;
	m_pResourceDLL		= NULL;
    m_fDirty            = FALSE;

#ifdef _DEBUG
    g_cVDEntryIDDataCreated++;
#endif         
}

//=--------------------------------------------------------------------------=
// ~CVDEntryIDData - Destructor
//
CVDEntryIDData::~CVDEntryIDData()
{
    if (m_fDirty)
        Commit();

	if (m_pCursorPosition)
    {
        if (m_hRow) 
        {
	        IRowset * pRowset = m_pCursorPosition->GetCursorMain()->GetRowset();

            if (pRowset && m_pCursorPosition->GetCursorMain()->IsRowsetValid())
                pRowset->ReleaseRows(1, &m_hRow, NULL, NULL, NULL);
        }

		((CVDNotifier*)m_pCursorPosition)->Release();
    }

    if (m_pStream)
        m_pStream->Release();

#ifdef _DEBUG
    g_cVDEntryIDDataDestroyed++;
#endif         
}

//=--------------------------------------------------------------------------=
// Create - Create entryID data object
//=--------------------------------------------------------------------------=
// This function creates and initializes a new entryID data object
//
// Parameters:
//    pCursorPosition   - [in]  backwards pointer to CVDCursorPosition object
//    pColumn           - [in]  rowset column pointer
//    hRow              - [in]  row handle
//    pStream           - [in]  data stream pointer
//    ppEntryIDData     - [out] a pointer in which to return pointer to 
//                              entryID data object
//    pResourceDLL      - [in]  a pointer which keeps track of resource DLL
//
// Output:
//    HRESULT - S_OK if successful
//              E_OUTOFMEMORY not enough memory to create object
//
// Notes:
//
HRESULT CVDEntryIDData::Create(CVDCursorPosition * pCursorPosition, CVDRowsetColumn * pColumn, HROW hRow, 
    IStream * pStream, CVDEntryIDData ** ppEntryIDData, CVDResourceDLL * pResourceDLL)
{
    ASSERT_POINTER(pCursorPosition, CVDCursorPosition)
    ASSERT_POINTER(pStream, IStream)
    ASSERT_POINTER(ppEntryIDData, CVDEntryIDData*)
    ASSERT_POINTER(pResourceDLL, CVDResourceDLL)

    // make sure we have all necessary pointers
    if (!pCursorPosition || !pStream || !ppEntryIDData)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_IEntryID, pResourceDLL);
        return E_INVALIDARG;
    }

	IRowset * pRowset = pCursorPosition->GetCursorMain()->GetRowset();

    // make sure we have a valid rowset pointer
    if (!pRowset || !pCursorPosition->GetCursorMain()->IsRowsetValid())
    {
        VDSetErrorInfo(IDS_ERR_ROWSETRELEASED, IID_IEntryID, pResourceDLL);
        return E_FAIL;
    }

    *ppEntryIDData = NULL;

    CVDEntryIDData * pEntryIDData = new CVDEntryIDData();

    if (!pEntryIDData)
    {
        VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_IEntryID, pResourceDLL);
        return E_OUTOFMEMORY;
    }

    ((CVDNotifier*)pCursorPosition)->AddRef();
    pRowset->AddRefRows(1, &hRow, NULL, NULL); 
    pStream->AddRef();

    pEntryIDData->m_pCursorPosition = pCursorPosition;
    pEntryIDData->m_pColumn         = pColumn;
    pEntryIDData->m_hRow            = hRow;
    pEntryIDData->m_pStream         = pStream;
	pEntryIDData->m_pResourceDLL    = pResourceDLL;

    *ppEntryIDData = pEntryIDData;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// AddRef
//
ULONG CVDEntryIDData::AddRef(void)
{
    return ++m_dwRefCount;
}

//=--------------------------------------------------------------------------=
// Release
//
ULONG CVDEntryIDData::Release(void)
{
    if (1 > --m_dwRefCount)
    {
        delete this;
        return 0;
    }

    return m_dwRefCount;
}

//=--------------------------------------------------------------------------=
// Commit
//
HRESULT CVDEntryIDData::Commit()
{
    HRESULT hr = S_OK;

    if (m_fDirty)
    {
        hr = m_pCursorPosition->UpdateEntryIDStream(m_pColumn, m_hRow, m_pStream);

        if (SUCCEEDED(hr))
            m_fDirty = FALSE;
    }

    return hr;
}


#endif //VD_DONT_IMPLEMENT_ISTREAM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\enumcnpt.h ===
//---------------------------------------------------------------------------
// enumcnpt.h : CVDConnectionPointContainer header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#ifndef __CVDENUMCONNECTIONPOINTS__
#define __CVDENUMCONNECTIONPOINTS__

class CVDEnumConnPoints : public IEnumConnectionPoints
{
public:
	CVDEnumConnPoints(IConnectionPoint* pConnPt);
	virtual ~CVDEnumConnPoints();

protected:
	DWORD				m_dwRefCount;
	DWORD				m_dwCurrentPosition;
	IConnectionPoint*	m_pConnPt; // there is only one connection point

public:
    // IUnknown methods -- there are required since we inherit from variuos
    // people who themselves inherit from IUnknown.
    //
    //=--------------------------------------------------------------------------=
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    //=--------------------------------------------------------------------------=
	// IEnumConnectionPoints methods
    //
	STDMETHOD(Next)(THIS_ ULONG cConnections, LPCONNECTIONPOINT FAR* rgpcn,
		ULONG FAR* lpcFetched);
	STDMETHOD(Skip)(THIS_ ULONG cConnections);
	STDMETHOD(Reset)(THIS);
	STDMETHOD(Clone)(THIS_ LPENUMCONNECTIONPOINTS FAR* ppEnum);

};
/////////////////////////////////////////////////////////////////////////////
#endif //__CVDENUMCONNECTIONPOINTS__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\entryid.h ===
//---------------------------------------------------------------------------
// EntryIDData.h : CVDEntryIDData header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------


#ifndef __CVDENTRYIDDATA__
#define __CVDENTRYIDDATA__

#ifndef VD_DONT_IMPLEMENT_ISTREAM


class CVDEntryIDData
{
protected:
// Construction/Destruction
	CVDEntryIDData();
	virtual ~CVDEntryIDData();

public:
    static HRESULT Create(CVDCursorPosition * pCursorPosition, CVDRowsetColumn * pColumn, HROW hRow, IStream * pStream, 
        CVDEntryIDData ** ppEntryIDData, CVDResourceDLL * pResourceDLL);

// Reference count
    ULONG AddRef();
    ULONG Release();

// Updating data
    void SetDirty(BOOL fDirty) {m_fDirty = fDirty;}
    HRESULT Commit();

protected:
// Data members
    DWORD               m_dwRefCount;       // reference count
    CVDCursorPosition * m_pCursorPosition;	// backwards pointer to CVDCursorPosition
    CVDRowsetColumn *   m_pColumn;          // rowset column pointer
    HROW                m_hRow;             // row handle
    IStream *           m_pStream;          // data stream pointer
	CVDResourceDLL *	m_pResourceDLL;     // resource DLL
    BOOL                m_fDirty;           // dirty flag
};


#endif //VD_DONT_IMPLEMENT_ISTREAM

#endif //__CVDENTRYIDDATA__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\fastguid.h ===
//---------------------------------------------------------------------------
// Fastguid.h : Macros used to speed up guid comparisons
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#ifndef __FASTGUID__
#define __FASTGUID__

#define SUPPORTS_ERROR_INFO(itf)              \
    case Data1_##itf:                       \
      if(DO_GUIDS_MATCH(riid, IID_##itf))    \
      {                                     \
		fSupportsErrorInfo	= TRUE;	\
      }                                     \
      break;

#define QI_INTERFACE_SUPPORTED(pObj, itf)              \
    case Data1_##itf:                       \
      if(DO_GUIDS_MATCH(riid, IID_##itf))    \
      {                                     \
        *ppvObjOut = (void *)(itf *)pObj;   \
      }                                     \
      break;

#define QI_INTERFACE_SUPPORTED_IF(pObj, itf, supportif) \
    case Data1_##itf:                       \
      if(supportif && DO_GUIDS_MATCH(riid, IID_##itf))    \
      {                                     \
        *ppvObjOut = (void *)(itf *)pObj;   \
      }                                     \
      break;

#define BOOL_PROP_SUPPORTED(itf, value) \
    case itf: \
		var.boolVal     = (VARIANT_BOOL)value; \
		fPropSupported	= TRUE; \
		break;

#define I4_PROP_SUPPORTED(itf, value)    \
    case itf:  \
		var.vt			= VT_I4; \
		var.lVal	    = value; \
		fPropSupported	= TRUE;	\
		break;

// Viaduct 1
#define Data1_IUnknown                     0x00000000
#define Data1_IConnectionPointContainer    0xb196b284
#define Data1_INotifyDBEvents              0xdb526cc0
#define Data1_IRowset					   0x0c733a7c
#define Data1_IRowsetLocate 	           0x0c733a7d
#define Data1_IRowsetScroll 	           0x0c733a7e
#define Data1_IAccessor	   				   0x0c733a8c
#define Data1_IColumnsInfo  	           0x0c733a11
#define Data1_IRowsetInfo   	           0x0c733a55
#define Data1_IRowsetChange 	           0x0c733a05
#define Data1_IRowsetUpdate 	           0x0c733a6d
//#define Data1_IRowsetNewRow 	           
#define Data1_IRowsetIdentity			   0x0c733a09
//#define Data1_IRowsetDelete
#define Data1_IRowsetFind   	           0x0c733a0d
#define Data1_IRowsetAsynch 	           0x0c733a0f
#define Data1_ISupportErrorInfo	           0xdf0b3d60
#define Data1_IRowPosition				   0x0c733a94

// Viaduct 2
#define Data1_IStream	                   0x00000030
#define Data1_IStreamEx	                   0xf74e27fc
#define Data1_ICursor                      0x9f6aa700
#define Data1_ICursorMove                  0xacff0690
#define Data1_ICursorScroll                0xbb87e420
#define Data1_ICursorUpdateARow            0xd14216a0
#define Data1_ICursorFind                  0xe01d7850
#define Data1_IEntryID                     0xe4d19810
#define Data1_IRowPositionChange		   0x0997a571

#endif //__FASTGUID__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\errorinf.h ===
//---------------------------------------------------------------------------
// ErrorInf.h  
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#ifndef __VDSETERRORINFO__
#define __VDSETERRORINFO__

//=--------------------------------------------------------------------------=
// CVDResourceDLL
//=--------------------------------------------------------------------------=
// Keeps track of the resource DLL for error strings
//
class CVDResourceDLL
{
public:
	CVDResourceDLL(LCID lcid);
	virtual ~CVDResourceDLL();

    int LoadString(UINT uID,			// resource identifier 
					LPTSTR lpBuffer,	// address of buffer for resource 
					int nBufferMax);	// size of buffer 

protected:
	LCID		m_lcid;					// passed in to the constructor
	HINSTANCE	m_hinstance;
};

//=--------------------------------------------------------------------------=
// VDSetErrorInfo
//=--------------------------------------------------------------------------=
// Sets rich error info.
//
// Parameters:
//    nErrStringResID	- [in]  The resource ID of the error string
//	  riid  			- [in]  The guid of the interface that will used in
//								the ICreateErrorInfo::SetGUID method
//	  pResDLL  			- [in]  A pointer to the CVDResourceDLL object
//								that keeps track of the resource DLL 
//								for error strings
//
void VDSetErrorInfo(UINT nErrStringResID,
				    REFIID riid,
					CVDResourceDLL * pResDLL);

//=--------------------------------------------------------------------------=
// VDCheckErrorInfo
//=--------------------------------------------------------------------------=
// Checks if rich error info is already available, otherwise it supplies it  
//
// Parameters:
//    nErrStringResID	- [in]  The resource ID of the error string
//	  riid  			- [in]  The guid of the interface that will used in
//								the ICreateErrorInfo::SetGUID method
//	  punkSource		- [in]  The interface that generated the error.
//								(e.g. a call to ICursorFind)
//	  riidSource		- [in]  The interface ID of the interface that 
//								generated the error. If punkSource is not 
//								NULL then this guid is passed into the  
//								ISupportErrorInfo::InterfaceSupportsErrorInfo
//								method.
//	  pResDLL  			- [in]  A pointer to the CVDResourceDLL object
//								that keeps track of the resource DLL 
//								for error strings
//
void VDCheckErrorInfo(UINT nErrStringResID,
						REFIID riid,
						LPUNKNOWN punkSource,
   						REFIID riidSource,
						CVDResourceDLL * pResDLL);

//=--------------------------------------------------------------------------=
// VDGetErrorInfo
//=--------------------------------------------------------------------------=
// if available, gets rich error info from supplied interface
//
// Parameters:
//	  punkSource		- [in]  The interface that generated the error.
//								(e.g. a call to ICursorFind)
//	  riidSource		- [in]  The interface ID of the interface that 
//								generated the error. If punkSource is not 
//								NULL then this guid is passed into the  
//								ISupportErrorInfo::InterfaceSupportsErrorInfo
//								method.
//    pbstrErrorDesc    - [out] a pointer to memory in which to return
//                              error description BSTR.
//
// Note - this function is no longer used, however it might be useful in
//        the future so it was not permanently removed.
//
//* HRESULT VDGetErrorInfo(LPUNKNOWN punkSource,
//* 				           REFIID riidSource,
//*                            BSTR * pbstrErrorDesc);

//=--------------------------------------------------------------------------=
// VDMapCursorHRtoRowsetHR
//=--------------------------------------------------------------------------=
// Translates an ICursor HRESULT to an IRowset HRESULT
//
// Parameters:
//    nErrStringResID	- [in]  ICursor HRESULT
//    nErrStringResID	- [in]  The resource ID of the error string
//	  riid  			- [in]  The guid of the interface that will used in
//								the ICreateErrorInfo::SetGUID method
//	  punkSource		- [in]  The interface that generated the error.
//								(e.g. a call to ICursorFind)
//	  riidSource		- [in]  The interface ID of the interface that 
//								generated the error. If punkSource is not 
//								NULL then this guid is passed into the  
//								ISupportErrorInfo::InterfaceSupportsErrorInfo
//								method.
//	  pResDLL  			- [in]  A pointer to the CVDResourceDLL object
//								that keeps track of the resource DLL 
//								for error strings
//
// Output:
//    HRESULT - Translated IRowset HRESULT
//

HRESULT VDMapCursorHRtoRowsetHR(HRESULT hr,
							 UINT nErrStringResIDFailed,
							 REFIID riid,
							 LPUNKNOWN punkSource,
   							 REFIID riidSource,
							 CVDResourceDLL * pResDLL);

//=--------------------------------------------------------------------------=
// VDMapRowsetHRtoCursorHR
//=--------------------------------------------------------------------------=
// Translates an IRowset HRESULT to an ICursor HRESULT
//
// Parameters:
//    hr	            - [in]  IRowset HRESULT
//    nErrStringResID	- [in]  The resource ID of the error string
//	  riid  			- [in]  The guid of the interface that will used in
//								the ICreateErrorInfo::SetGUID method
//	  punkSource		- [in]  The interface that generated the error.
//								(e.g. a call to IRowsetFind)
//	  riidSource		- [in]  The interface ID of the interface that 
//								generated the error. If punkSource is not 
//								NULL then this guid is passed into the  
//								ISupportErrorInfo::InterfaceSupportsErrorInfo
//								method.
//	  pResDLL  			- [in]  A pointer to the CVDResourceDLL object
//								that keeps track of the resource DLL 
//								for error strings
//
// Output:
//    HRESULT - Translated ICursor HRESULT
//

HRESULT VDMapRowsetHRtoCursorHR(HRESULT hr,
							 UINT nErrStringResIDFailed,
							 REFIID riid,
							 LPUNKNOWN punkSource,
   							 REFIID riidSource,
							 CVDResourceDLL * pResDLL);

/////////////////////////////////////////////////////////////////////////////
#endif //__VDSETERRORINFO__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\fromvar.h ===
//---------------------------------------------------------------------------
// FromVar.h : GetDataFromDBVariant header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------


#ifndef __VDFROMVAR__
#define __VDFROMVAR__

HRESULT GetDataFromDBVariant(CURSOR_DBVARIANT * pVar,
							 DBTYPE * pwType, 
							 BYTE ** ppData, 
							 BOOL * pfMemAllocated);


#endif //__VDFROMVAR__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\enumcnpt.cpp ===
//---------------------------------------------------------------------------
// enumcnpt.cpp : CVDEnumConnPoints implementation file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"         
#include "enumcnpt.h"         

// needed for ASSERTs and FAIL
//
SZTHISFILE

//=--------------------------------------------------------------------------=
// CVDEnumConnPoints constructor
//
CVDEnumConnPoints::CVDEnumConnPoints(IConnectionPoint* pConnPt)
{
	m_dwRefCount			= 1;
	m_dwCurrentPosition		= 0;
	m_pConnPt				= pConnPt;
	ADDREF_OBJECT(m_pConnPt);

#ifdef _DEBUG
    g_cVDEnumConnPointsCreated++;
#endif			
}

//=--------------------------------------------------------------------------=
// CVDEnumConnPoints destructor
//
CVDEnumConnPoints::~CVDEnumConnPoints()
{
	RELEASE_OBJECT(m_pConnPt);

#ifdef _DEBUG
    g_cVDEnumConnPointsDestroyed++;
#endif			
}

//=--------------------------------------------------------------------------=
// IUnknown QueryInterface 
//
HRESULT CVDEnumConnPoints::QueryInterface(REFIID riid, void **ppvObjOut)
{
	ASSERT_POINTER(ppvObjOut, IUnknown*)

	*ppvObjOut = NULL;

	if (DO_GUIDS_MATCH(riid, IID_IUnknown) ||
		DO_GUIDS_MATCH(riid, IID_IEnumConnectionPoints) )
		{
		*ppvObjOut = this;
		AddRef();
		return S_OK;
		}

	return E_NOINTERFACE;

}

//=--------------------------------------------------------------------------=
// IUnknown AddRef
//
ULONG CVDEnumConnPoints::AddRef(void)
{
	return ++m_dwRefCount;
}

//=--------------------------------------------------------------------------=
// IUnknown Release
//
ULONG CVDEnumConnPoints::Release(void)
{
	
	if (1 > --m_dwRefCount)
		{
		delete this;
		return 0;
		}

	return m_dwRefCount;
}

//=--------------------------------------------------------------------------=
// IEnumConnectionPoints Methods
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// IEnumConnectionPoints Next
//
HRESULT CVDEnumConnPoints::Next(ULONG cConnections, LPCONNECTIONPOINT FAR* rgpcn,
		ULONG FAR* lpcFetched)
{
	ASSERT_POINTER(rgpcn, LPCONNECTIONPOINT)
	ASSERT_NULL_OR_POINTER(lpcFetched, ULONG)

	if (cConnections > 0 && m_dwCurrentPosition == 0 && m_pConnPt)
		{
		*rgpcn		= m_pConnPt;
		if (lpcFetched)
			*lpcFetched	= 1;
		m_dwCurrentPosition	= 1;
		return S_OK;
		}
	else
		return S_FALSE;
}

//=--------------------------------------------------------------------------=
// IEnumConnectionPoints Skip
//
HRESULT CVDEnumConnPoints::Skip(ULONG cConnections)
{
	m_dwCurrentPosition	= 1;
	return S_FALSE;
}

//=--------------------------------------------------------------------------=
// IEnumConnectionPoints Reset
//
HRESULT CVDEnumConnPoints::Reset()
{
	m_dwCurrentPosition = 0;

	return S_OK;
}

//=--------------------------------------------------------------------------=
// IEnumConnectionPoints Clone
//
HRESULT CVDEnumConnPoints::Clone(LPENUMCONNECTIONPOINTS FAR* ppEnum)
{
	ASSERT_POINTER(ppEnum, LPENUMCONNECTIONPOINTS)

	*ppEnum = new CVDEnumConnPoints(m_pConnPt);
	return (*ppEnum != NULL) ? S_OK : E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\errorinf.cpp ===
//---------------------------------------------------------------------------
// SetErrorInfo.cpp 
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "globals.h"
#include "resource.h"
#include <mbstring.h>

// needed for ASSERTs and FAIL
//
SZTHISFILE

#define MAX_STRING_BUFFLEN	512

CVDResourceDLL::CVDResourceDLL(LCID lcid)
{
	m_lcid = lcid; 
	m_hinstance = 0;
}

CVDResourceDLL::~CVDResourceDLL()
{
	if (m_hinstance)
		FreeLibrary(m_hinstance);
}

int CVDResourceDLL::LoadString(UINT uID,			// resource identifier 
								LPTSTR lpBuffer,	// address of buffer for resource 
								int nBufferMax)		// size of buffer 
{
	lpBuffer[0] = 0;  //initialize buffer

	if (!m_hinstance)
	{
		// Get this dll's full path
		TCHAR szDllName[MAX_PATH];
		GetModuleFileName(g_hinstance, szDllName, MAX_PATH);

		// Strip off filename/ext leaving dir path
		TBYTE * szDirectory = _mbsrchr((TBYTE*)szDllName, '\\');

		if (!szDirectory)
			szDirectory = _mbsrchr((TBYTE*)szDllName, ':');

		if (szDirectory)
		{
			szDirectory = _mbsinc(szDirectory);
			*szDirectory = 0;
		}

		// construct dll name from supplied lcid
		TCHAR szLang[4 * 2];
		szLang[0] = 0;
		GetLocaleInfo (m_lcid, 
					   LOCALE_SABBREVLANGNAME,
					   szLang, 
					   4 * 2);
	   	_mbscat((TBYTE*)szDllName, (TBYTE*)VD_DLL_PREFIX);
	   	_mbscat((TBYTE*)szDllName, (TBYTE*)szLang);
	   	_mbscat((TBYTE*)szDllName, (TBYTE*)".DLL");
		m_hinstance = LoadLibrary(szDllName);

		// if dll not found try english us dll which should always be there
		if (!m_hinstance && szDirectory)	
		{
			*szDirectory = 0;
			_mbscat((TBYTE*)szDllName, (TBYTE*)VD_DLL_PREFIX);
	   		_mbscat((TBYTE*)szDllName, (TBYTE*)"ENU.DLL");
			m_hinstance = LoadLibrary(szDllName);
			ASSERT(m_hinstance, VD_ASSERTMSG_CANTFINDRESOURCEDLL);
		}
	}

	return m_hinstance ? ::LoadString(m_hinstance, uID, lpBuffer, nBufferMax) : 0;
}

//=--------------------------------------------------------------------------=
// VDSetErrorInfo
//=--------------------------------------------------------------------------=
// Sets rich error info
//
// Parameters:
//    nErrStringResID	- [in]  The resource ID of the error string
//	  riid  			- [in]  The guid of the interface that will used in
//								the ICreateErrorInfo::SetGUID method
//	  pResDLL  			- [in]  A pointer to the CVDResourceDLL object
//								that keeps track of the resource DLL 
//								for error strings
//

void VDSetErrorInfo(UINT nErrStringResID,
				    REFIID riid,
					CVDResourceDLL * pResDLL)
{

	ICreateErrorInfo *pCreateErrorInfo;  

	HRESULT hr = CreateErrorInfo(&pCreateErrorInfo); 
	if (SUCCEEDED(hr))
	{
		TCHAR buff[MAX_STRING_BUFFLEN];
		
		// set guid
		pCreateErrorInfo->SetGUID(riid);

		// load source string
		int nLen = pResDLL->LoadString(IDS_ERR_SOURCE,
									   buff,
									   MAX_STRING_BUFFLEN);
		
		if (nLen > 0)
		{
			BSTR bstr = BSTRFROMANSI(buff);

			if (bstr)
			{
				pCreateErrorInfo->SetSource(bstr);
				SysFreeString(bstr);
			}
			
			// load error description
			nLen = pResDLL->LoadString(nErrStringResID,
									   buff,
									   MAX_STRING_BUFFLEN);
			if (nLen > 0)
			{
				bstr = BSTRFROMANSI(buff);

				if (bstr)
				{
					pCreateErrorInfo->SetDescription(bstr);
					SysFreeString(bstr);
				}
			}
			
			IErrorInfo *pErrorInfo;
			hr = pCreateErrorInfo->QueryInterface(IID_IErrorInfo, (LPVOID FAR*) &pErrorInfo);

			if (SUCCEEDED(hr))
			{
				SetErrorInfo(0, pErrorInfo);
				pErrorInfo->Release();
			}
		}
		
		pCreateErrorInfo->Release();
	}  
 
}


//=--------------------------------------------------------------------------=
// VDCheckErrorInfo
//=--------------------------------------------------------------------------=
// Checks if rich error info is already available, otherwise it supplies it  
//
// Parameters:
//    nErrStringResID	- [in]  The resource ID of the error string
//	  riid  			- [in]  The guid of the interface that will used in
//								the ICreateErrorInfo::SetGUID method
//	  punkSource		- [in]  The interface that generated the error.
//								(e.g. a call to ICursorFind)
//	  riidSource		- [in]  The interface ID of the interface that 
//								generated the error. If punkSource is not 
//								NULL then this guid is passed into the  
//								ISupportErrorInfo::InterfaceSupportsErrorInfo
//								method.
//	  pResDLL  			- [in]  A pointer to the CVDResourceDLL object
//								that keeps track of the resource DLL 
//								for error strings
//

void VDCheckErrorInfo(UINT nErrStringResID,
						REFIID riid,
						LPUNKNOWN punkSource,
   						REFIID riidSource,
						CVDResourceDLL * pResDLL)
{

	if (punkSource)
	{
		// check if the ISupportErrorInfo interface is implemented
		ISupportErrorInfo * pSupportErrorInfo = NULL;
		HRESULT hr = punkSource->QueryInterface(IID_ISupportErrorInfo, 
											(void**)&pSupportErrorInfo); 
		if SUCCEEDED(hr)
		{
			// check if the interface that generated the error supports error info
			BOOL fInterfaceSupported = (S_OK == pSupportErrorInfo->InterfaceSupportsErrorInfo(riidSource));
			pSupportErrorInfo->Release();
			if (fInterfaceSupported)
				return;	// rich error info has already been supplied so just return
		}
	}

	// rich error info wasn't supplied so set it ourselves
	VDSetErrorInfo(nErrStringResID, riid, pResDLL);
}

//=--------------------------------------------------------------------------=
// VDGetErrorInfo
//=--------------------------------------------------------------------------=
// if available, gets rich error info from supplied interface
//
// Parameters:
//	  punkSource		- [in]  The interface that generated the error.
//								(e.g. a call to ICursorFind)
//	  riidSource		- [in]  The interface ID of the interface that 
//								generated the error. If punkSource is not 
//								NULL then this guid is passed into the  
//								ISupportErrorInfo::InterfaceSupportsErrorInfo
//								method.
//    pbstrErrorDesc    - [out] a pointer to memory in which to return
//                              error description BSTR.
//
// Note - this function is no longer used, however it might be useful in
//        the future so it was not permanently removed.
//
/*
HRESULT VDGetErrorInfo(LPUNKNOWN punkSource,
   				            REFIID riidSource,
                            BSTR * pbstrErrorDesc)
{
    ASSERT_POINTER(pbstrErrorDesc, BSTR)

	if (punkSource && pbstrErrorDesc)
	{
        // init out parameter
        *pbstrErrorDesc = NULL;

		// check if the ISupportErrorInfo interface is implemented
		ISupportErrorInfo * pSupportErrorInfo = NULL;
		HRESULT hr = punkSource->QueryInterface(IID_ISupportErrorInfo, 
											(void**)&pSupportErrorInfo); 
		if (SUCCEEDED(hr))
		{
			// check if the interface that generated the error supports error info
			BOOL fInterfaceSupported = (S_OK == pSupportErrorInfo->InterfaceSupportsErrorInfo(riidSource));
			pSupportErrorInfo->Release();

			if (fInterfaceSupported)
            {
                // get error info interface
                IErrorInfo * pErrorInfo = NULL;
                hr = GetErrorInfo(0, &pErrorInfo);

                if (hr == S_OK)
                {
    			    // get rich error info
                    hr = pErrorInfo->GetDescription(pbstrErrorDesc);
                    pErrorInfo->Release();
                    return hr;
                }
            }
		}
	}

    return E_FAIL;
}
*/

//=--------------------------------------------------------------------------=
// VDMapCursorHRtoRowsetHR
//=--------------------------------------------------------------------------=
// Translates an ICursor HRESULT to an IRowset HRESULT
//
// Parameters:
//    nErrStringResID	- [in]  ICursor HRESULT
//    nErrStringResID	- [in]  The resource ID of the error string
//	  riid  			- [in]  The guid of the interface that will used in
//								the ICreateErrorInfo::SetGUID method
//	  punkSource		- [in]  The interface that generated the error.
//								(e.g. a call to ICursorFind)
//	  riidSource		- [in]  The interface ID of the interface that 
//								generated the error. If punkSource is not 
//								NULL then this guid is passed into the  
//								ISupportErrorInfo::InterfaceSupportsErrorInfo
//								method.
//	  pResDLL  			- [in]  A pointer to the CVDResourceDLL object
//								that keeps track of the resource DLL 
//								for error strings
//
// Output:
//    HRESULT - Translated IRowset HRESULT
//

HRESULT VDMapCursorHRtoRowsetHR(HRESULT hr,
							 UINT nErrStringResIDFailed,
							 REFIID riid,
							 LPUNKNOWN punkSource,
   							 REFIID riidSource,
							 CVDResourceDLL * pResDLL)
{

    switch (hr)
    {
        case CURSOR_DB_S_ENDOFCURSOR:
            hr = DB_S_ENDOFROWSET;
            break;

        case CURSOR_DB_E_BADBOOKMARK:
			VDCheckErrorInfo(IDS_ERR_BADBOOKMARK, riid, punkSource, riidSource, pResDLL); 
            hr = DB_E_BADBOOKMARK;
            break;

        case CURSOR_DB_E_ROWDELETED:
			VDCheckErrorInfo(IDS_ERR_DELETEDROW, riid, punkSource, riidSource, pResDLL); 
            hr = DB_E_DELETEDROW;
            break;

        case CURSOR_DB_E_BADFRACTION:
			VDCheckErrorInfo(IDS_ERR_BADFRACTION, riid, punkSource, riidSource, pResDLL); 
            hr = DB_E_BADRATIO;
            break;

       case CURSOR_DB_E_UPDATEINPROGRESS:
			VDCheckErrorInfo(IDS_ERR_UPDATEINPROGRESS, riid, punkSource, riidSource, pResDLL); 
			hr = E_FAIL;
            break;

        case E_OUTOFMEMORY:
			VDCheckErrorInfo((UINT)E_OUTOFMEMORY, riid, punkSource, riidSource, pResDLL); 
            hr = E_OUTOFMEMORY;
            break;

        default:
			if FAILED(hr)
			{
				VDCheckErrorInfo(nErrStringResIDFailed, riid, punkSource, riidSource, pResDLL); 
				hr = E_FAIL;
			}
            break;
    }

	return hr;
}

//=--------------------------------------------------------------------------=
// VDMapRowsetHRtoCursorHR
//=--------------------------------------------------------------------------=
// Translates an IRowset HRESULT to an ICursor HRESULT
//
// Parameters:
//    hr	            - [in]  IRowset HRESULT
//    nErrStringResID	- [in]  The resource ID of the error string
//	  riid  			- [in]  The guid of the interface that will used in
//								the ICreateErrorInfo::SetGUID method
//	  punkSource		- [in]  The interface that generated the error.
//								(e.g. a call to IRowsetFind)
//	  riidSource		- [in]  The interface ID of the interface that 
//								generated the error. If punkSource is not 
//								NULL then this guid is passed into the  
//								ISupportErrorInfo::InterfaceSupportsErrorInfo
//								method.
//	  pResDLL  			- [in]  A pointer to the CVDResourceDLL object
//								that keeps track of the resource DLL 
//								for error strings
//
// Output:
//    HRESULT - Translated ICursor HRESULT
//

HRESULT VDMapRowsetHRtoCursorHR(HRESULT hr,
							 UINT nErrStringResIDFailed,
							 REFIID riid,
							 LPUNKNOWN punkSource,
   							 REFIID riidSource,
							 CVDResourceDLL * pResDLL)
{
    switch (hr)
    {
        case DB_S_ENDOFROWSET:
            hr = CURSOR_DB_S_ENDOFCURSOR;
            break;

        case DB_E_DELETEDROW:
			VDCheckErrorInfo(IDS_ERR_DELETEDROW, riid, punkSource, riidSource, pResDLL); 
            hr = CURSOR_DB_E_ROWDELETED;
            break;

		case DB_E_BADBOOKMARK:
			VDCheckErrorInfo(IDS_ERR_BADBOOKMARK, riid, punkSource, riidSource, pResDLL); 
            hr = CURSOR_DB_E_BADBOOKMARK;
			break;

        case DB_E_BADRATIO: 
			VDCheckErrorInfo(IDS_ERR_BADFRACTION, riid, punkSource, riidSource, pResDLL); 
            hr = CURSOR_DB_E_BADFRACTION;
            break;

        case E_OUTOFMEMORY:
			VDCheckErrorInfo((UINT)E_OUTOFMEMORY, riid, punkSource, riidSource, pResDLL); 
            hr = E_OUTOFMEMORY;
            break;

        default:
			if FAILED(hr)
			{
				VDCheckErrorInfo(nErrStringResIDFailed, riid, punkSource, riidSource, pResDLL); 
				hr = E_FAIL;
			}
            break;
    }

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\fromvar.cpp ===
//---------------------------------------------------------------------------
// FromVar.cpp : GetDataFromDBVariant implementation
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "timeconv.h"
#include "fromvar.h"
#include <math.h>
#include <limits.h>

SZTHISFILE


//=--------------------------------------------------------------------------=
// CoerceToDBVariant
//=--------------------------------------------------------------------------=
// Coerce a CURSOR_DBVARIANT to data suitable for IRowsetFind::GetRowsByValues
//
// Parameters:
//	  pVar 		        - [in]  a pointer to the variant containing the data
//	  pwType			- [out] a pointer to memory in which to return the DBTYPE
//								of the data
//    ppValue			- [out] a pointer to memory in which to return a pointer
//								to the date
//	  pfMemAllocated	- [out] a pointer to memory in which to return whether
//								new memory was allocated for the data. This is 
//								assumed to be initialzed to false by caller
//
// Output:
//    HRESULT - S_OK if successful
//
HRESULT GetDataFromDBVariant(CURSOR_DBVARIANT * pVar,
							 DBTYPE * pwType, 
							 BYTE ** ppData, 
							 BOOL * pfMemAllocated)
{
	ASSERT_POINTER(pVar, CURSOR_DBVARIANT)
	ASSERT_POINTER(pwType, DBTYPE)
	ASSERT_POINTER(ppData, BYTE*)
	ASSERT_POINTER(pfMemAllocated, BOOL)

    if (!pVar || !pwType || !ppData || !pfMemAllocated)
        return E_INVALIDARG;

	VARTYPE vt		= pVar->vt;
	BOOL fByRef		= FALSE;
	BOOL fArray		= FALSE;
	BOOL fVector	= FALSE;

	*pwType			= 0;

	if (vt & VT_VECTOR)
	{
		vt ^= VT_VECTOR;
		*pwType		= DBTYPE_VECTOR;
		if (vt & VT_BYREF)
		{
			*pwType	 |= DBTYPE_BYREF;
			vt ^= VT_BYREF;
		}
		fVector		= TRUE;
	}
	else
	if (vt & VT_ARRAY)
	{
		vt ^= VT_ARRAY;
		fArray		= TRUE;
		*pwType		= DBTYPE_ARRAY;
	}
	else
	if (vt & VT_BYREF)
	{
		vt ^= VT_BYREF;
		fByRef		= TRUE;
		*pwType		= DBTYPE_BYREF;
	}

	*ppData		= (BYTE*)&pVar->iVal;

	HRESULT hr = S_OK;

    switch (vt)
	{
		case CURSOR_DBTYPE_EMPTY:
			*pwType		= DBTYPE_EMPTY;
			break;

		case CURSOR_DBTYPE_NULL:
			*pwType		= DBTYPE_NULL;
			break;

		case CURSOR_DBTYPE_I2:
			*pwType		|= DBTYPE_I2;
			break;

		case CURSOR_DBTYPE_I4:
			*pwType		|= DBTYPE_I4;
			break;

		case CURSOR_DBTYPE_I8:
			*pwType		|= DBTYPE_I8;
			break;

		case CURSOR_DBTYPE_R4:
			*pwType		|= DBTYPE_R4;
			break;

		case CURSOR_DBTYPE_R8:
			*pwType		|= DBTYPE_R8;
			break;

		case CURSOR_DBTYPE_CY:
			*pwType		|= DBTYPE_CY;
			break;

		case CURSOR_DBTYPE_DATE:
			*pwType		|= DBTYPE_DATE;
			break;

		case CURSOR_DBTYPE_BOOL:
			*pwType		|= DBTYPE_BOOL;
			break;

		case CURSOR_DBTYPE_HRESULT:
			*pwType		|= DBTYPE_ERROR;
			break;

		case CURSOR_DBTYPE_LPSTR:
			*pwType		|= DBTYPE_STR;
			if (!fByRef && !fArray && !fVector)
				*ppData		= (BYTE*)pVar->pszVal;
			break;

		case CURSOR_DBTYPE_LPWSTR:
			*pwType		|= DBTYPE_WSTR;
			if (!fByRef && !fArray && !fVector)
				*ppData		= (BYTE*)pVar->pwszVal;
			break;

		case VT_BSTR:
			*pwType		|= DBTYPE_WSTR;
			if (!fByRef && !fArray && !fVector)
				*ppData		= (BYTE*)pVar->bstrVal;
			break;

		case CURSOR_DBTYPE_UUID:
			*pwType		|= DBTYPE_GUID;
			break;

		case CURSOR_DBTYPE_UI2:
			*pwType		|= DBTYPE_UI2;
			break;

		case CURSOR_DBTYPE_UI4:
			*pwType		|= DBTYPE_UI4;
			break;

		case CURSOR_DBTYPE_UI8:
			*pwType		|= DBTYPE_UI8;
			break;

		case CURSOR_DBTYPE_ANYVARIANT:
			*pwType		|= DBTYPE_VARIANT;
			break;

		case CURSOR_DBTYPE_BYTES:
		case CURSOR_DBTYPE_CHARS:
		case CURSOR_DBTYPE_BLOB:
			*pwType		|= DBTYPE_BYTES;
			break;

		case CURSOR_DBTYPE_WCHARS:
			*pwType		|= DBTYPE_UI2;
			break;

		case CURSOR_DBTYPE_FILETIME:

		{
			FILETIME *pFileTime = NULL;
			if (fVector)
			{
				DBVECTOR * pvector = (DBVECTOR*)pVar->byref;
				if (pvector)
					pFileTime = (FILETIME*)pvector->ptr;
			}
			else
			if (fByRef)
			{
				pFileTime = (FILETIME*)pVar->byref;
			}
			else
			if (!fArray)
			{
				pFileTime = (FILETIME*)&pVar->cyVal;
			}
			if (pFileTime)
			{
				DBTIMESTAMP * pstamp = (DBTIMESTAMP*)g_pMalloc->Alloc(sizeof(DBTIMESTAMP));
				if (pstamp)
				{
					if (VDConvertToDBTimeStamp(pFileTime, pstamp))
					{
						*ppData				= (BYTE*)pstamp;
						*pwType				|= DBTYPE_DBTIMESTAMP;
						*pfMemAllocated		= TRUE;
					}
					else
					{
						g_pMalloc->Free(pstamp);
						hr = CURSOR_DB_CANTCOERCE;
					}
				}
				else
					hr = E_OUTOFMEMORY;
			}
			else
				hr = CURSOR_DB_CANTCOERCE;
			break;
		}

		case CURSOR_DBTYPE_DBEXPR:
		case CURSOR_DBTYPE_COLUMNID:
		default:
			hr = CURSOR_DB_CANTCOERCE;
			break;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\guids.cpp ===
//---------------------------------------------------------------------------
// Guids.cpp : Contains guids we will define ourselves
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#define INITGUID                   // define all the guids.
#define DBINITCONSTANTS
#define CURSOR_DBINITCONSTANTS

#include "stdafx.h"

#include "olectl.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\globals.cpp ===
//---------------------------------------------------------------------------
// Globals.cpp : Global information 
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"

SZTHISFILE

// our global memory allocator and global memory pool
//
HANDLE    g_hHeap;
LPMALLOC  g_pMalloc;
HINSTANCE g_hinstance;

//Count number of objects and number of locks.
ULONG     g_cLockCount=0;
ULONG     g_cObjectCount=0;

CRITICAL_SECTION    g_CriticalSection;

// frequently used large integers
//
LARGE_INTEGER g_liMinus = {(ULONG)-1, -1};  // minus one
LARGE_INTEGER g_liZero = {0, 0};            // - zero -
LARGE_INTEGER g_liPlus = {0, 1};            // plus one
//=--------------------------------------------------------------------------=
// VDInitGlobals
//=--------------------------------------------------------------------------=
// Initialize global variables
//
// Parameters:
//    hinstResource	- [in]  The instance handle that contains resource strings
//
// Output:
//    TRUE if successful otherwise FALSE
//
BOOL VDInitGlobals(HINSTANCE hinstance)
{
	g_pMalloc = NULL;
	g_hinstance = hinstance;
	g_hHeap = GetProcessHeap();
	if (!g_hHeap) 
	{
		FAIL("Couldn't get Process Heap.");
		return FALSE;
	}

	InitializeCriticalSection(&g_CriticalSection);

	return TRUE;
}

//=--------------------------------------------------------------------------=
// VDReleaseGlobals
//=--------------------------------------------------------------------------=
//
void VDReleaseGlobals()
{
	if (g_pMalloc)
	{
		g_pMalloc->Release();
		g_pMalloc = NULL;
	}
      
    #ifdef _DEBUG
	     DumpObjectCounters();    
    #endif // _DEBUG

	DeleteCriticalSection(&g_CriticalSection);

}

//=--------------------------------------------------------------------------=
// VDUpdateObjectCount increments/decrements global object count
//=--------------------------------------------------------------------------=
//
void VDUpdateObjectCount(int cChange)
{

    EnterCriticalSection(&g_CriticalSection);

	g_cObjectCount += cChange;

	// get global malloc pointer object count greater than zero
	if (!g_pMalloc && g_cObjectCount > 0)
	{
		CoGetMalloc(MEMCTX_TASK, &g_pMalloc);
	}
	else
	// release hold	on global malloc pointer when no more objects
	if (0 == g_cObjectCount && g_pMalloc)
	{
		g_pMalloc->Release();
		g_pMalloc = NULL;
	}

    LeaveCriticalSection(&g_CriticalSection);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\globals.h ===
//=--------------------------------------------------------------------------=
// Globals.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains externs and stuff for Global variables, etc ..
//
#ifndef _GLOBALS_H_

//=--------------------------------------------------------------------------=
// our global memory allocator and global memory pool
//
extern HANDLE    g_hHeap;
extern LPMALLOC  g_pMalloc;
extern HINSTANCE g_hinstance;
extern ULONG     g_cLockCount;
extern ULONG     g_cObjectCount;

extern CRITICAL_SECTION g_CriticalSection;

//=--------------------------------------------------------------------------=
// frequently used large integers
//
extern LARGE_INTEGER g_liMinus;     // minus one
extern LARGE_INTEGER g_liZero;      // - zero -
extern LARGE_INTEGER g_liPlus;      // plus one

#ifdef _DEBUG
void DumpObjectCounters();
#endif // _DEBUG

//=--------------------------------------------------------------------------=
// VDInitGlobals
//=--------------------------------------------------------------------------=
// Initialize global variables
//
// Parameters:
//    hinstResource	- [in]  The instance handle that contains resource strings
//
// Output:
//    TRUE if successful otherwise FALSE
//
BOOL VDInitGlobals(HINSTANCE hinstance);

//=--------------------------------------------------------------------------=
// VDReleaseGlobals
//=--------------------------------------------------------------------------=
void VDReleaseGlobals();

void VDUpdateObjectCount(int cChange);

#define _GLOBALS_H_
#endif // _GLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\msdadc.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu May 22 17:20:43 1997
 */
/* Compiler settings for msdadc.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __msdadc_h__
#define __msdadc_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IDataConvert_FWD_DEFINED__
#define __IDataConvert_FWD_DEFINED__
typedef interface IDataConvert IDataConvert;
#endif 	/* __IDataConvert_FWD_DEFINED__ */


#ifndef __IRowPosition_FWD_DEFINED__
#define __IRowPosition_FWD_DEFINED__
typedef interface IRowPosition IRowPosition;
#endif 	/* __IRowPosition_FWD_DEFINED__ */


#ifndef __IRowPositionChange_FWD_DEFINED__
#define __IRowPositionChange_FWD_DEFINED__
typedef interface IRowPositionChange IRowPositionChange;
#endif 	/* __IRowPositionChange_FWD_DEFINED__ */


#ifndef __DataConvert_FWD_DEFINED__
#define __DataConvert_FWD_DEFINED__

#ifdef __cplusplus
typedef class DataConvert DataConvert;
#else
typedef struct DataConvert DataConvert;
#endif /* __cplusplus */

#endif 	/* __DataConvert_FWD_DEFINED__ */


#ifndef __RowPosition_FWD_DEFINED__
#define __RowPosition_FWD_DEFINED__

#ifdef __cplusplus
typedef class RowPosition RowPosition;
#else
typedef struct RowPosition RowPosition;
#endif /* __cplusplus */

#endif 	/* __RowPosition_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IDataConvert_INTERFACE_DEFINED__
#define __IDataConvert_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDataConvert
 * at Thu May 22 17:20:43 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][uuid][object] */ 


typedef DWORD DBDATACONVERT;


enum DBDATACONVERTENUM
    {	DBDATACONVERT_DEFAULT	= 0,
	DBDATACONVERT_SETDATABEHAVIOR	= 0x1,
	DBDATACONVERT_LENGTHFROMNTS	= 0x2
    };

EXTERN_C const IID IID_IDataConvert;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a8d-2a1c-11ce-ade5-00aa0044773d")
    IDataConvert : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DataConvert( 
            /* [in] */ DBTYPE wSrcType,
            /* [in] */ DBTYPE wDstType,
            /* [in] */ ULONG cbSrcLength,
            /* [out][in] */ ULONG __RPC_FAR *pcbDstLength,
            /* [in] */ void __RPC_FAR *pSrc,
            /* [out] */ void __RPC_FAR *pDst,
            /* [in] */ ULONG cbDstMaxLength,
            /* [in] */ DBSTATUS dbsSrcStatus,
            /* [out] */ DBSTATUS __RPC_FAR *pdbsStatus,
            /* [in] */ BYTE bPrecision,
            /* [in] */ BYTE bScale,
            /* [in] */ DBDATACONVERT dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanConvert( 
            /* [in] */ DBTYPE wSrcType,
            /* [in] */ DBTYPE wDstType) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetConversionSize( 
            /* [in] */ DBTYPE wSrcType,
            /* [in] */ DBTYPE wDstType,
            /* [in] */ ULONG __RPC_FAR *pcbSrcLength,
            /* [out] */ ULONG __RPC_FAR *pcbDstLength,
            /* [size_is][in] */ void __RPC_FAR *pSrc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDataConvertVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDataConvert __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDataConvert __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDataConvert __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DataConvert )( 
            IDataConvert __RPC_FAR * This,
            /* [in] */ DBTYPE wSrcType,
            /* [in] */ DBTYPE wDstType,
            /* [in] */ ULONG cbSrcLength,
            /* [out][in] */ ULONG __RPC_FAR *pcbDstLength,
            /* [in] */ void __RPC_FAR *pSrc,
            /* [out] */ void __RPC_FAR *pDst,
            /* [in] */ ULONG cbDstMaxLength,
            /* [in] */ DBSTATUS dbsSrcStatus,
            /* [out] */ DBSTATUS __RPC_FAR *pdbsStatus,
            /* [in] */ BYTE bPrecision,
            /* [in] */ BYTE bScale,
            /* [in] */ DBDATACONVERT dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanConvert )( 
            IDataConvert __RPC_FAR * This,
            /* [in] */ DBTYPE wSrcType,
            /* [in] */ DBTYPE wDstType);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConversionSize )( 
            IDataConvert __RPC_FAR * This,
            /* [in] */ DBTYPE wSrcType,
            /* [in] */ DBTYPE wDstType,
            /* [in] */ ULONG __RPC_FAR *pcbSrcLength,
            /* [out] */ ULONG __RPC_FAR *pcbDstLength,
            /* [size_is][in] */ void __RPC_FAR *pSrc);
        
        END_INTERFACE
    } IDataConvertVtbl;

    interface IDataConvert
    {
        CONST_VTBL struct IDataConvertVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDataConvert_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDataConvert_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDataConvert_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDataConvert_DataConvert(This,wSrcType,wDstType,cbSrcLength,pcbDstLength,pSrc,pDst,cbDstMaxLength,dbsSrcStatus,pdbsStatus,bPrecision,bScale,dwFlags)	\
    (This)->lpVtbl -> DataConvert(This,wSrcType,wDstType,cbSrcLength,pcbDstLength,pSrc,pDst,cbDstMaxLength,dbsSrcStatus,pdbsStatus,bPrecision,bScale,dwFlags)

#define IDataConvert_CanConvert(This,wSrcType,wDstType)	\
    (This)->lpVtbl -> CanConvert(This,wSrcType,wDstType)

#define IDataConvert_GetConversionSize(This,wSrcType,wDstType,pcbSrcLength,pcbDstLength,pSrc)	\
    (This)->lpVtbl -> GetConversionSize(This,wSrcType,wDstType,pcbSrcLength,pcbDstLength,pSrc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local] */ HRESULT STDMETHODCALLTYPE IDataConvert_DataConvert_Proxy( 
    IDataConvert __RPC_FAR * This,
    /* [in] */ DBTYPE wSrcType,
    /* [in] */ DBTYPE wDstType,
    /* [in] */ ULONG cbSrcLength,
    /* [out][in] */ ULONG __RPC_FAR *pcbDstLength,
    /* [in] */ void __RPC_FAR *pSrc,
    /* [out] */ void __RPC_FAR *pDst,
    /* [in] */ ULONG cbDstMaxLength,
    /* [in] */ DBSTATUS dbsSrcStatus,
    /* [out] */ DBSTATUS __RPC_FAR *pdbsStatus,
    /* [in] */ BYTE bPrecision,
    /* [in] */ BYTE bScale,
    /* [in] */ DBDATACONVERT dwFlags);


void __RPC_STUB IDataConvert_DataConvert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDataConvert_CanConvert_Proxy( 
    IDataConvert __RPC_FAR * This,
    /* [in] */ DBTYPE wSrcType,
    /* [in] */ DBTYPE wDstType);


void __RPC_STUB IDataConvert_CanConvert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE IDataConvert_GetConversionSize_Proxy( 
    IDataConvert __RPC_FAR * This,
    /* [in] */ DBTYPE wSrcType,
    /* [in] */ DBTYPE wDstType,
    /* [in] */ ULONG __RPC_FAR *pcbSrcLength,
    /* [out] */ ULONG __RPC_FAR *pcbDstLength,
    /* [size_is][in] */ void __RPC_FAR *pSrc);


void __RPC_STUB IDataConvert_GetConversionSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDataConvert_INTERFACE_DEFINED__ */


#ifndef __IRowPosition_INTERFACE_DEFINED__
#define __IRowPosition_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowPosition
 * at Thu May 22 17:20:43 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][uuid][object] */ 


typedef DWORD DBPOSITIONFLAGS;


enum DBPOSITIONFLAGSENUM
    {	DBPOSITION_OK	= 0,
	DBPOSITION_NOROW	= DBPOSITION_OK + 1,
	DBPOSITION_BOF	= DBPOSITION_NOROW + 1,
	DBPOSITION_EOF	= DBPOSITION_BOF + 1
    };

EXTERN_C const IID IID_IRowPosition;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a94-2a1c-11ce-ade5-00aa0044773d")
    IRowPosition : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ClearRowPosition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRowPosition( 
            /* [out] */ HCHAPTER __RPC_FAR *phChapter,
            /* [out] */ HROW __RPC_FAR *phRow,
            /* [out] */ DBPOSITIONFLAGS __RPC_FAR *pdwPositionFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRowset( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPUNKNOWN __RPC_FAR *ppRowset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IUnknown __RPC_FAR *pRowset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRowPosition( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ HROW hRow,
            /* [in] */ DBPOSITIONFLAGS dwPositionFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowPositionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRowPosition __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRowPosition __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRowPosition __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearRowPosition )( 
            IRowPosition __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRowPosition )( 
            IRowPosition __RPC_FAR * This,
            /* [out] */ HCHAPTER __RPC_FAR *phChapter,
            /* [out] */ HROW __RPC_FAR *phRow,
            /* [out] */ DBPOSITIONFLAGS __RPC_FAR *pdwPositionFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRowset )( 
            IRowPosition __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPUNKNOWN __RPC_FAR *ppRowset);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IRowPosition __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pRowset);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRowPosition )( 
            IRowPosition __RPC_FAR * This,
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ HROW hRow,
            /* [in] */ DBPOSITIONFLAGS dwPositionFlags);
        
        END_INTERFACE
    } IRowPositionVtbl;

    interface IRowPosition
    {
        CONST_VTBL struct IRowPositionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowPosition_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowPosition_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowPosition_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowPosition_ClearRowPosition(This)	\
    (This)->lpVtbl -> ClearRowPosition(This)

#define IRowPosition_GetRowPosition(This,phChapter,phRow,pdwPositionFlags)	\
    (This)->lpVtbl -> GetRowPosition(This,phChapter,phRow,pdwPositionFlags)

#define IRowPosition_GetRowset(This,riid,ppRowset)	\
    (This)->lpVtbl -> GetRowset(This,riid,ppRowset)

#define IRowPosition_Initialize(This,pRowset)	\
    (This)->lpVtbl -> Initialize(This,pRowset)

#define IRowPosition_SetRowPosition(This,hChapter,hRow,dwPositionFlags)	\
    (This)->lpVtbl -> SetRowPosition(This,hChapter,hRow,dwPositionFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRowPosition_ClearRowPosition_Proxy( 
    IRowPosition __RPC_FAR * This);


void __RPC_STUB IRowPosition_ClearRowPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowPosition_GetRowPosition_Proxy( 
    IRowPosition __RPC_FAR * This,
    /* [out] */ HCHAPTER __RPC_FAR *phChapter,
    /* [out] */ HROW __RPC_FAR *phRow,
    /* [out] */ DBPOSITIONFLAGS __RPC_FAR *pdwPositionFlags);


void __RPC_STUB IRowPosition_GetRowPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowPosition_GetRowset_Proxy( 
    IRowPosition __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ LPUNKNOWN __RPC_FAR *ppRowset);


void __RPC_STUB IRowPosition_GetRowset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowPosition_Initialize_Proxy( 
    IRowPosition __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pRowset);


void __RPC_STUB IRowPosition_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowPosition_SetRowPosition_Proxy( 
    IRowPosition __RPC_FAR * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ HROW hRow,
    /* [in] */ DBPOSITIONFLAGS dwPositionFlags);


void __RPC_STUB IRowPosition_SetRowPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowPosition_INTERFACE_DEFINED__ */


#ifndef __IRowPositionChange_INTERFACE_DEFINED__
#define __IRowPositionChange_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowPositionChange
 * at Thu May 22 17:20:43 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



enum DBREASONPOSITIONENUM
    {	DBREASON_ROWPOSITION_CHANGED	= DBREASON_ROWSET_CHANGED + 1,
	DBREASON_ROWPOSITION_CHAPTERCHANGED	= DBREASON_ROWPOSITION_CHANGED + 1,
	DBREASON_ROWPOSITION_CLEARED	= DBREASON_ROWPOSITION_CHAPTERCHANGED + 1
    };

EXTERN_C const IID IID_IRowPositionChange;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0997a571-126e-11d0-9f8a-00a0c9a0631e")
    IRowPositionChange : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnRowPositionChange( 
            /* [in] */ DBREASON eReason,
            /* [in] */ DBEVENTPHASE ePhase,
            /* [in] */ BOOL fCantDeny) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowPositionChangeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRowPositionChange __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRowPositionChange __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRowPositionChange __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnRowPositionChange )( 
            IRowPositionChange __RPC_FAR * This,
            /* [in] */ DBREASON eReason,
            /* [in] */ DBEVENTPHASE ePhase,
            /* [in] */ BOOL fCantDeny);
        
        END_INTERFACE
    } IRowPositionChangeVtbl;

    interface IRowPositionChange
    {
        CONST_VTBL struct IRowPositionChangeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowPositionChange_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowPositionChange_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowPositionChange_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowPositionChange_OnRowPositionChange(This,eReason,ePhase,fCantDeny)	\
    (This)->lpVtbl -> OnRowPositionChange(This,eReason,ePhase,fCantDeny)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRowPositionChange_OnRowPositionChange_Proxy( 
    IRowPositionChange __RPC_FAR * This,
    /* [in] */ DBREASON eReason,
    /* [in] */ DBEVENTPHASE ePhase,
    /* [in] */ BOOL fCantDeny);


void __RPC_STUB IRowPositionChange_OnRowPositionChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowPositionChange_INTERFACE_DEFINED__ */



#ifndef __MSDAUTILLib_LIBRARY_DEFINED__
#define __MSDAUTILLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: MSDAUTILLib
 * at Thu May 22 17:20:43 1997
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_MSDAUTILLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_DataConvert;

class DECLSPEC_UUID("c8b522d1-5cf3-11ce-ade5-00aa0044773d")
DataConvert;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_RowPosition;

class DECLSPEC_UUID("2048EEE6-7FA2-11D0-9E6A-00A0C9138C29")
RowPosition;

DEFINE_GUID(CLSID_RowPosition, 0x2048eee6, 0x7fa2, 0x11d0, 0x9e, 0x6a, 0x0, 0xa0, 0xc9, 0x13, 0x8c, 0x29);
DEFINE_GUID(IID_IRowPosition,  0x0c733a94, 0x2a1c, 0x11ce, 0xad, 0xe5, 0x0, 0xaa, 0x0, 0x44, 0x77, 0x3d);
DEFINE_GUID(IID_IRowPositionChange,  0x0997a571, 0x126e, 0x11d0, 0x9f, 0x8a, 0x0, 0xa0, 0xc9, 0xa0, 0x63, 0x1e);


#endif
#endif /* __MSDAUTILLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\msr2c.cpp ===
//---------------------------------------------------------------------------
// MSR2C.cpp : implements DllMain
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "MSR2C.h"
#include "CMSR2C.h"
#include "clssfcty.h"
#include <mbstring.h>

SZTHISFILE

// DllMain
//
BOOL WINAPI DllMain(HINSTANCE hinstDll, DWORD dwReason, LPVOID lpvReserved)
{

	switch (dwReason)
	{
		case DLL_PROCESS_ATTACH:
			return VDInitGlobals(hinstDll);

		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
			break;
		
		case DLL_PROCESS_DETACH:
			VDReleaseGlobals();
			break;
	}

	return TRUE;

}

////////////////////////////////////////////////////////////////////
// Name:	DllGetClassObject
// Desc:	provides an IClassFactory for a given CLSID that this DLL
//			is registered to support.  This DLL is placed under the
//			CLSID in the registration database as the InProcServer.
// Parms:	rclsid - identifies the class factory desired. since the
//			'this' parameter is passed, this DLL can handle any
//			number of objects simply by returning different class
//			factories here for different CLSIDs.
//			riid - ID specifying the interface the caller wants on
//			the class object, usually IID_ClassFactory.
//			ppv - pointer in which to return the interface pointer.
// Return:	HRESULT - NOERROR on success, otherwise an error code.
////////////////////////////////////////////////////////////////////
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void ** ppv)
{
	HRESULT hr;
	CClassFactory *pObj;

	if (CLSID_CCursorFromRowset!=rclsid)
		return ResultFromScode(E_FAIL);

	pObj=new CClassFactory();

	if (NULL==pObj)
		return ResultFromScode(E_OUTOFMEMORY);

	hr=pObj->QueryInterface(riid, ppv);

	if (FAILED(hr))
		delete pObj;

	return hr;
}

////////////////////////////////////////////////////////////////////
// Name:	DllCanUnloadNow
// Desc:	lets the client know if this DLL can be freed, ie if
//			there are no references to anything this DLL provides.
// Parms:	none
// Return:	TRUE if nothing is using us, FALSE otherwise.
////////////////////////////////////////////////////////////////////
STDAPI DllCanUnloadNow(void)
{
	SCODE   sc;

	//Our answer is whether there are any object or locks
    EnterCriticalSection(&g_CriticalSection);

	sc=(0L==g_cObjectCount && 0L==g_cLockCount) ? S_OK : S_FALSE;

    LeaveCriticalSection(&g_CriticalSection);

	return ResultFromScode(sc);
}

////////////////////////////////////////////////////////////////////
// Name:	CSSCFcty
// Desc:	constructor
// Parms:	none
// Return:	none
////////////////////////////////////////////////////////////////////
CClassFactory::CClassFactory(void)
{
	m_cRef=0L;
	return;
}

////////////////////////////////////////////////////////////////////
// Name:	~CClassFactory
// Desc:	destructor
// Parms:	none
// Return:	none
////////////////////////////////////////////////////////////////////
CClassFactory::~CClassFactory(void)
{
	return;
}

////////////////////////////////////////////////////////////////////
// Name:	QueryInterface
// Desc:	queries the class factory for a method.
// Parms:	riid -
//			ppv -
// Return:	HRESULT - NOERROR if successful, otherwise an error code.
////////////////////////////////////////////////////////////////////
STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID * ppv)
{
	*ppv=NULL;

	if (IID_IUnknown==riid || IID_IClassFactory==riid)
		*ppv=this;

	if (NULL!=*ppv)
	{
		((LPUNKNOWN)*ppv)->AddRef();
		return NOERROR;
	}

	return ResultFromScode(E_NOINTERFACE);
}

////////////////////////////////////////////////////////////////////
// Name:	AddRef
// Desc:	incrementes the class factory object reference count.
// Parms:	none
// Return:	current reference count.
////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CClassFactory::AddRef(void)
{
	return ++m_cRef;
}

////////////////////////////////////////////////////////////////////
// Name:	Release
// Desc:	decrement the reference count on the class factory.  If
//			the count has gone to 0, destroy the object.
// Parms:	none
// Return:	current reference count.
////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CClassFactory::Release(void)
{
	// if ref count can be decremented, return count
	if (0L!=--m_cRef)
		return m_cRef;

	// delete this object
	delete this;
	return 0L;
}

////////////////////////////////////////////////////////////////////
// Name:	CreateInstance
// Desc:	instantiates an CVDCursorFromRowset object, returning an interface
//			pointer.
// Parms:	riid -		ID identifying the interface the caller
//						desires	to have for the new object.
//			ppvObj -	pointer in which to store the desired
//						interface pointer for the new object.
// Return:	HRESULT -	NOERROR if successful, otherwise
//						E_NOINTERFACE if we cannot support the
//						requested interface.
////////////////////////////////////////////////////////////////////
STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj)
{
	return CVDCursorFromRowset::CreateInstance(pUnkOuter, riid, ppvObj);
}

////////////////////////////////////////////////////////////////////
// Name:	LockServer
// Desc:	increments or decrements the lock count of the DLL.  if
//			the lock count goes to zero, and there are no objects,
//			the DLL is allowed to unload.
// Parms:	fLock - boolean specifies whether to increment or
//					decrement the lock count.
// Return:	HRESULT: NOERROR always.
////////////////////////////////////////////////////////////////////
STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    EnterCriticalSection(&g_CriticalSection);

	if (fLock)
	{
		g_cLockCount++;
	}
	else
	{
		g_cLockCount--;
	}

    LeaveCriticalSection(&g_CriticalSection);

	return NOERROR;
}

////////////////////////////////////////////////////////////////////
// Name:	DllRegisterServer
// Desc:	instructs the server to create its own registry entries.
//			all entries are put in the HKEY_CLASSES_ROOT.
// Parms:	none
// Return:	HRESULT -	NOERROR if registration is successful, error
//						otherwise.
////////////////////////////////////////////////////////////////////
STDAPI DllRegisterServer(void)
{
	OLECHAR szID[128 * 2];
	TCHAR	szTID[128 * 2];
	TCHAR	szCLSID[128 * 2];
	TCHAR	szModule[512 * 2];

	// put the guid in the form of a string with class id prefix
	StringFromGUID2(CLSID_CCursorFromRowset, szID, 128 * 2);
	WideCharToMultiByte(CP_ACP, 0, szID, -1, szTID, 128 * 2, NULL, NULL);

	_mbscpy((TBYTE*)szCLSID, (TBYTE*)TEXT("CLSID\\"));
	_mbscat((TBYTE*)szCLSID, (TBYTE*)szTID);

	SetKeyAndValue(szCLSID, NULL, NULL, NULL);

	GetModuleFileName(g_hinstance, szModule, sizeof(szModule)/sizeof(TCHAR));

	SetKeyAndValue(szCLSID, TEXT("InprocServer32"), szModule, TEXT("Apartment"));

	return S_OK;
}

////////////////////////////////////////////////////////////////////
// Name:	DllUnregisterServer
// Desc:	instructs the server to remove its own registry entries.
// Parms:	none
// Return:	HRESULT: NOERROR if unregistration is successful, error
//			otherwise.
////////////////////////////////////////////////////////////////////
STDAPI DllUnregisterServer(void)
{
	OLECHAR szID[128 * 2];
	TCHAR	szTID[128 * 2];
	TCHAR	szCLSID[128 * 2];
	TCHAR	szCLSIDInproc[128 * 2];

	// put the guid in the form of a string with class id prefix
	StringFromGUID2(CLSID_CCursorFromRowset, szID, 128 * 2);
	WideCharToMultiByte(CP_ACP, 0, szID, -1, szTID, 128 * 2, NULL, NULL);

	_mbscpy((TBYTE*)szCLSID, (TBYTE*)TEXT("CLSID\\"));
	_mbscat((TBYTE*)szCLSID, (TBYTE*)szTID);
    _mbscpy((TBYTE*)szCLSIDInproc, (TBYTE*)szCLSID);
	_mbscat((TBYTE*)szCLSIDInproc, (TBYTE*)TEXT("\\InprocServer32"));

	// delete the InprocServer32 key
	RegDeleteKey(HKEY_CLASSES_ROOT, szCLSIDInproc);

	// delete the class ID key
	RegDeleteKey(HKEY_CLASSES_ROOT, szCLSID);

	return S_OK;
}


////////////////////////////////////////////////////////////////////
// Name:	SetKeyAndValue
// Desc:	creates a registry key, sets a value, and closes the key.
// Parms:	pszKey -	pointer to a registry key.
//			pszSubkey -	pointer to a registry subkey.
//			pszValue -	pointer to value to enter for key-subkey
//			pszThreadingModel - pointer to threading model literal (optional) 		
// Return:	BOOL -		TRUE if successful, FALSE otherwise.
////////////////////////////////////////////////////////////////////
BOOL SetKeyAndValue(LPTSTR pszKey, LPTSTR pszSubkey, LPTSTR pszValue, LPTSTR pszThreadingModel)
{
	HKEY	hKey;
	TCHAR	szKey[256 * 2];

	_mbscpy((TBYTE*)szKey, (TBYTE*)pszKey);

	if (NULL!=pszSubkey)
	{
		_mbscat((TBYTE*)szKey, (TBYTE*)TEXT("\\"));
		_mbscat((TBYTE*)szKey, (TBYTE*)pszSubkey);
	}

	if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
											szKey,
											0,
											NULL,
											REG_OPTION_NON_VOLATILE,
											KEY_ALL_ACCESS,
											NULL,
											&hKey,
											NULL))
		return FALSE;

	if (NULL!=pszValue)
	{
		RegSetValueEx(	hKey,
						NULL,
						0,
						REG_SZ,
						(BYTE *)pszValue,
						_mbsnbcnt((TBYTE*)pszValue, (ULONG)-1) + 1);
	}

	if (NULL!=pszThreadingModel)
	{
		RegSetValueEx(	hKey,
						TEXT("ThreadingModel"),
						0,
						REG_SZ,
						(BYTE *)pszThreadingModel,
						_mbsnbcnt((TBYTE*)pszThreadingModel, (ULONG)-1) + 1);
	}

	RegCloseKey(hKey);

	return TRUE;
}

//=--------------------------------------------------------------------------=
// CRT stubs
//=--------------------------------------------------------------------------=
// these two things are here so the CRTs aren't needed. this is good.
//
// basically, the CRTs define this to take in a bunch of stuff.  we'll just
// define them here so we don't get an unresolved external.
//
// TODO: if you are going to use the CRTs, then remove this line.
//
//extern "C" int __cdecl _fltused = 1;

extern "C" int _cdecl _purecall(void)
{
  FAIL("Pure virtual function called.");
  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\ipserver.h ===
//=--------------------------------------------------------------------------=
// InProcServer.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// global header file that contains all the windows stuff, etc ...  should
// be pre-compiled to speed things up a little bit.
//
#ifndef _INPROCSERVER_H_

#define INC_OLE2
#include <windows.h>
#include <stddef.h>                    // for offsetof()
#include <olectl.h>




// things that -everybody- wants [read: is going to get]
//
#include "Debug.H"

//=--------------------------------------------------------------------------=
// we don't want to use the CRTs, and would like some memory tracking in the
// debug case, so we'll override these guys
//=--------------------------------------------------------------------------=
//
void * _cdecl operator new(size_t size);
void  _cdecl operator delete(void *ptr);


//=--------------------------------------------------------------------------=
// Useful macros
//=--------------------------------------------------------------------------=
//
// handy error macros, randing from cleaning up, to returning to clearing
// rich error information as well.
//
#define RETURN_ON_FAILURE(hr) if (FAILED(hr)) return hr
#define RETURN_ON_NULLALLOC(ptr) if (!(ptr)) return E_OUTOFMEMORY
#define CLEANUP_ON_FAILURE(hr) if (FAILED(hr)) goto CleanUp
#define CLEARERRORINFORET(hr) { SetErrorInfo(0, NULL); return hr; }
#define CLEARERRORINFORET_ON_FAILURE(hr) if (FAILED(hr)) { SetErrorInfo(0, NULL); return hr; }

#define CLEANUP_ON_ERROR(l)    if (l != ERROR_SUCCESS) goto CleanUp

// conversions
//
#define BOOL_TO_VARIANTBOOL(f) (f) ? VARIANT_TRUE : VARIANT_FALSE

// for optimizing QI's
//
#define DO_GUIDS_MATCH(riid1, riid2) ((riid1.Data1 == riid2.Data1) && (riid1 == riid2))

// Reference counting help.
//
#define RELEASE_OBJECT(ptr)    if (ptr) { IUnknown *pUnk = (ptr); (ptr) = NULL; pUnk->Release(); }
#define ADDREF_OBJECT(ptr)     if (ptr) (ptr)->AddRef()


#define _INPROCSERVER_H_
#endif // _INPROCSERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\msr2c.h ===
//---------------------------------------------------------------------------
// MSR2C.h : Main header file for Viaduct phase II
//
// Copyright (c) 1996, 1997 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

  /////////////////////////////////////////////////////////////////////////
  // NOTE - you must define VD_INCLUDE_ROWPOSITION before including this //
  //        header for ICursorFromRowPosition to be defined in your code //
  /////////////////////////////////////////////////////////////////////////

#ifndef __MSR2C_H__
#define __MSR2C_H__

// {5B5E7E70-E653-11cf-84A5-0000C08C00C4}
const GUID CLSID_CCursorFromRowset =	
	{ 0x5b5e7e70, 0xe653, 0x11cf, { 0x84, 0xa5, 0x0, 0x0, 0xc0, 0x8c, 0x0, 0xc4 } };

// {5B5E7E72-E653-11cf-84A5-0000C08C00C4}
const IID IID_ICursorFromRowset = 
	{ 0x5b5e7e72, 0xe653, 0x11cf, { 0x84, 0xa5, 0x0, 0x0, 0xc0, 0x8c, 0x0, 0xc4 } };

#ifdef VD_INCLUDE_ROWPOSITION

// {5B5E7E73-E653-11cf-84A5-0000C08C00C4}
const IID IID_ICursorFromRowPosition = 
	{ 0x5b5e7e73, 0xe653, 0x11cf, { 0x84, 0xa5, 0x0, 0x0, 0xc0, 0x8c, 0x0, 0xc4 } };

#endif //VD_INCLUDE_ROWPOSITION

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ICursorFromRowset : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCursor( 
            /* [in]  */ IRowset __RPC_FAR *pRowset,
            /* [out] */ ICursor __RPC_FAR **ppCursor,
            /* [in]  */ LCID lcid) = 0;
    };
    
#ifdef VD_INCLUDE_ROWPOSITION

    interface ICursorFromRowPosition : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCursor( 
            /* [in]  */ IRowPosition __RPC_FAR *pRowPosition,
            /* [out] */ ICursor __RPC_FAR **ppCursor,
            /* [in]  */ LCID lcid) = 0;
    };

#endif //VD_INCLUDE_ROWPOSITION

#else 	/* C style interface */

    typedef struct ICursorFromRowset
    {
        BEGIN_INTERFACE
        
        HRESULT (STDMETHODCALLTYPE __RPC_FAR *QueryInterface)( 
            ICursorFromRowset __RPC_FAR *This,
            /* [in]  */ REFIID riid,
            /* [out] */ void __RPC_FAR **ppvObject);
        
        ULONG (STDMETHODCALLTYPE __RPC_FAR *AddRef)( 
            ICursorFromRowset __RPC_FAR *This);
        
        ULONG (STDMETHODCALLTYPE __RPC_FAR *Release)( 
            ICursorFromRowset __RPC_FAR *This);
        
        HRESULT (STDMETHODCALLTYPE __RPC_FAR *GetCursor)( 
            ICursorFromRowset __RPC_FAR *This,
            /* [in]  */ IRowset __RPC_FAR *pRowset,
            /* [out] */ ICursor __RPC_FAR **ppCursor,
            /* [in]  */ LCID lcid);
        
        END_INTERFACE
    } ICursorFromRowsetVtbl;

    interface ICursorFromRowset
    {
        CONST_VTBL struct ICursorFromRowsetVtbl __RPC_FAR *lpVtbl;
    };

#ifdef VD_INCLUDE_ROWPOSITION

    typedef struct ICursorFromRowPosition
    {
        BEGIN_INTERFACE
        
        HRESULT (STDMETHODCALLTYPE __RPC_FAR *QueryInterface)( 
            ICursorFromRowPosition __RPC_FAR *This,
            /* [in]  */ REFIID riid,
            /* [out] */ void __RPC_FAR **ppvObject);
        
        ULONG (STDMETHODCALLTYPE __RPC_FAR *AddRef)( 
            ICursorFromRowPosition __RPC_FAR *This);
        
        ULONG (STDMETHODCALLTYPE __RPC_FAR *Release)( 
            ICursorFromRowPosition __RPC_FAR *This);
        
        HRESULT (STDMETHODCALLTYPE __RPC_FAR *GetCursor)( 
            ICursorFromRowPosition __RPC_FAR *This,
            /* [in]  */ IRowPosition __RPC_FAR *pRowPosition,
            /* [out] */ ICursor __RPC_FAR **ppCursor,
            /* [in]  */ LCID lcid);
        
        END_INTERFACE
    } ICursorFromRowPositionVtbl;

    interface ICursorFromRowPosition
    {
        CONST_VTBL struct ICursorFromRowPositionVtbl __RPC_FAR *lpVtbl;
    };

#endif //VD_INCLUDE_ROWPOSITION

#endif 	/* C style interface */

#ifdef __cplusplus
extern "C" {
#endif
// old entry point
HRESULT WINAPI VDGetICursorFromIRowset(IRowset * pRowset, 
                                       ICursor ** ppCursor,
                                       LCID lcid);
#ifdef __cplusplus
}
#endif

//
// MessageId: VD_E_CANNOTGETMANDATORYINTERFACE
//
// MessageText:
//
//  Unable to get required interface
//
#define VD_E_CANNOTGETMANDATORYINTERFACE        ((HRESULT)0x80050E00L)

//
// MessageId: VD_E_CANNOTCONNECTIROWSETNOTIFY
//
// MessageText:
//
//  Unable to connect IRowsetNotify
//
#define VD_E_CANNOTCONNECTIROWSETNOTIFY         ((HRESULT)0x80050E31L)

//
// MessageId: VD_E_CANNOTGETCOLUMNINFO
//
// MessageText:
//
//  Unable to get column information
//
#define VD_E_CANNOTGETCOLUMNINFO                ((HRESULT)0x80050E32L)

//
// MessageId: VD_E_CANNOTCREATEBOOKMARKACCESSOR
//
// MessageText:
//
//  Unable to create bookmark accessor
//
#define VD_E_CANNOTCREATEBOOKMARKACCESSOR       ((HRESULT)0x80050E33L)

//
// MessageId: VD_E_REQUIREDPROPERTYNOTSUPPORTED
//
// MessageText:
//
//  Require rowset property is not supported
//
#define VD_E_REQUIREDPROPERTYNOTSUPPORTED       ((HRESULT)0x80050E34L)

//
// MessageId: VD_E_CANNOTGETROWSETINTERFACE
//
// MessageText:
//
//  Unable to get rowset interface
//
#define VD_E_CANNOTGETROWSETINTERFACE			((HRESULT)0x80050E35L)

//
// MessageId: VD_E_CANNOTCONNECTIROWPOSITIONCHANGE
//
// MessageText:
//
//  Unable to connect IRowPositionChange
//
#define VD_E_CANNOTCONNECTIROWPOSITIONCHANGE	((HRESULT)0x80050E36L)

#endif //__MSR2C_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\nconnpt.h ===
//---------------------------------------------------------------------------
// NotifyConnPt.h : CVDNotifyDBEventsConnPt header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#ifndef __CVDNOTIFYDBEVENTSCONNPT__
#define __CVDNOTIFYDBEVENTSCONNPT__

class CVDNotifyDBEventsConnPt : public IConnectionPoint
{
protected:
// Construction/Destruction
	CVDNotifyDBEventsConnPt();
	~CVDNotifyDBEventsConnPt();

public:
    static HRESULT Create(IConnectionPointContainer * pConnPtContainer, CVDNotifyDBEventsConnPt ** ppNotifyDBEventsConnPt);

public:
// Access functions
    UINT GetConnectionsActive() const {return m_uiConnectionsActive;}
    INotifyDBEvents ** GetNotifyDBEventsTable() const {return m_ppNotifyDBEvents;}

protected:
// Data members
	DWORD			            m_dwRefCount;
	UINT			            m_uiConnectionsAllocated;
	UINT			            m_uiConnectionsActive;
	INotifyDBEvents **	        m_ppNotifyDBEvents; // pointer to an array of INotifyDBEvents ptrs
	IConnectionPointContainer * m_pConnPtContainer;

public:
    // IUnknown methods -- there are required since we inherit from variuos
    // people who themselves inherit from IUnknown.
    //
    //=--------------------------------------------------------------------------=
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    //=--------------------------------------------------------------------------=
	// IConnectionPoint methods
    //
	STDMETHOD(GetConnectionInterface)(THIS_ IID FAR* pIID);
	STDMETHOD(GetConnectionPointContainer)(THIS_
		IConnectionPointContainer FAR* FAR* ppCPC);
	STDMETHOD(Advise)(THIS_ LPUNKNOWN pUnkSink, DWORD FAR* pdwCookie);
	STDMETHOD(Unadvise)(THIS_ DWORD dwCookie);
	STDMETHOD(EnumConnections)(THIS_ LPENUMCONNECTIONS FAR* ppEnum);

};
/////////////////////////////////////////////////////////////////////////////
#endif //__CVDNOTIFYDBEVENTSCONNPT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\nconnpt.cpp ===
//---------------------------------------------------------------------------
// NotifyConnPt.cpp : CVDNotifyDBEventsConnPt implementation file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"         
#include "NConnPt.h"         
#include <memory.h>

// needed for ASSERTs and FAIL
//
SZTHISFILE

//=--------------------------------------------------------------------------=
// CVDNotifyDBEventsConnPt constructor
//
CVDNotifyDBEventsConnPt::CVDNotifyDBEventsConnPt()
{
	m_dwRefCount				= 1;
	m_uiConnectionsAllocated	= 0;
	m_uiConnectionsActive		= 0;
	m_pConnPtContainer			= NULL;
	m_ppNotifyDBEvents			= NULL;

#ifdef _DEBUG
    g_cVDNotifyDBEventsConnPtCreated++;
#endif			
}

//=--------------------------------------------------------------------------=
// CVDNotifyDBEventsConnPt destructor
//
CVDNotifyDBEventsConnPt::~CVDNotifyDBEventsConnPt()
{
	for (UINT i = 0; i < m_uiConnectionsActive; i++)
		RELEASE_OBJECT(m_ppNotifyDBEvents[i])

	delete [] m_ppNotifyDBEvents;   // free up table

#ifdef _DEBUG
    g_cVDNotifyDBEventsConnPtDestroyed++;
#endif			
}

//=--------------------------------------------------------------------------=
// Create - Create rowset notify connection point object
//=--------------------------------------------------------------------------=
// This function creates a new rowset notify connection point object
//
// Parameters:
//    pConnPtContainer      - [in]  a pointer to connection point container 
//                                  object
//    ppNotifyDBEventsConnPt  - [out] a pointer in which to return pointer to 
//                                  connection point object
//
// Output:
//    HRESULT - S_OK if successful
//              E_OUTOFMEMORY not enough memory to create object
//
// Notes:
//
HRESULT CVDNotifyDBEventsConnPt::Create(IConnectionPointContainer * pConnPtContainer, CVDNotifyDBEventsConnPt ** ppNotifyDBEventsConnPt)
{
    *ppNotifyDBEventsConnPt = NULL;

    CVDNotifyDBEventsConnPt * pNotifyDBEventsConnPt = new CVDNotifyDBEventsConnPt();

    if (!pNotifyDBEventsConnPt)
        return E_OUTOFMEMORY;

    pNotifyDBEventsConnPt->m_pConnPtContainer = pConnPtContainer;

    *ppNotifyDBEventsConnPt = pNotifyDBEventsConnPt;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// IUnknown QueryInterface 
//
HRESULT CVDNotifyDBEventsConnPt::QueryInterface(REFIID riid, void **ppvObjOut)
{
	ASSERT_POINTER(ppvObjOut, IUnknown*)

	*ppvObjOut = NULL;

	if (DO_GUIDS_MATCH(riid, IID_IUnknown) ||
		DO_GUIDS_MATCH(riid, IID_IConnectionPoint) )
		{
		*ppvObjOut = this;
		AddRef();
		return S_OK;
		}

	return E_NOINTERFACE;

}

//=--------------------------------------------------------------------------=
// IUnknown AddRef
//
ULONG CVDNotifyDBEventsConnPt::AddRef(void)
{
	return ++m_dwRefCount;
}

//=--------------------------------------------------------------------------=
// IUnknown Release
//
ULONG CVDNotifyDBEventsConnPt::Release(void)
{
	
	if (1 > --m_dwRefCount)
		{
		delete this;
		return 0;
		}

	return m_dwRefCount;
}

//=--------------------------------------------------------------------------=
// IConnectionPoint Methods
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// IConnectionPoint GetConnectionInterface
//
HRESULT CVDNotifyDBEventsConnPt::GetConnectionInterface(IID FAR* pIID)
{
	ASSERT_POINTER(pIID, IID)
	*pIID = IID_INotifyDBEvents;
	return S_OK;
}

//=--------------------------------------------------------------------------=
// IConnectionPoint GetConnectionPointContainer
//
HRESULT CVDNotifyDBEventsConnPt::GetConnectionPointContainer(IConnectionPointContainer FAR* FAR* ppCPC)
{
	ASSERT_POINTER(ppCPC, IConnectionPointContainer*)

	if ((*ppCPC = m_pConnPtContainer) != NULL)
		return S_OK;

	return E_FAIL;
}

//=--------------------------------------------------------------------------=
// IConnectionPoint Advise
//
#define VD_ADVISE_TABLE_GROWBY  10

HRESULT CVDNotifyDBEventsConnPt::Advise(LPUNKNOWN pUnkSink, DWORD FAR* pdwCookie)
{
	ASSERT_NULL_OR_POINTER(pdwCookie, DWORD)
	ASSERT_POINTER(pUnkSink, IUnknown)

	if (pUnkSink == NULL)
		return E_POINTER;

	LPUNKNOWN lpInterface;

	if (SUCCEEDED(pUnkSink->QueryInterface(IID_INotifyDBEvents, (LPVOID*)&lpInterface)))
		{
		// 1st check to see if we need to allocate more entries
		if (m_uiConnectionsAllocated <= m_uiConnectionsActive) 
			{
			ULONG ulNewLen = (m_uiConnectionsAllocated + VD_ADVISE_TABLE_GROWBY) * sizeof(INotifyDBEvents**);
			INotifyDBEvents ** pNewMem = new INotifyDBEvents *[m_uiConnectionsAllocated + VD_ADVISE_TABLE_GROWBY];
			if (!pNewMem)
				return E_OUTOFMEMORY;
			memset(pNewMem, 0, (int)ulNewLen);
			// check to see if a table already exists
			if (m_ppNotifyDBEvents)
				{
				// if there are active connections copy them over to the new table
				if (m_uiConnectionsActive > 0)
					memcpy(pNewMem, m_ppNotifyDBEvents, m_uiConnectionsActive * sizeof(INotifyDBEvents**));
				 delete [] m_ppNotifyDBEvents;  // free up old table
				}
			m_ppNotifyDBEvents		= pNewMem;
			m_uiConnectionsAllocated += VD_ADVISE_TABLE_GROWBY;  // grow table by 10 entries each allocation
			}
		// append to end of table 
		m_ppNotifyDBEvents[m_uiConnectionsActive]	= (INotifyDBEvents*)lpInterface;
		m_uiConnectionsActive++;
		if (pdwCookie != NULL)
			*pdwCookie = (DWORD)lpInterface;
		return S_OK;
		}

	return E_NOINTERFACE;
}

//=--------------------------------------------------------------------------=
// IConnectionPoint Unadvise
//
HRESULT CVDNotifyDBEventsConnPt::Unadvise(DWORD dwCookie)
{
	ASSERT_POINTER((INotifyDBEvents*)dwCookie, INotifyDBEvents)

	for (UINT i = 0; i < m_uiConnectionsActive; i++)
		{
		if (m_ppNotifyDBEvents[i] == (INotifyDBEvents*)dwCookie)
			{
			RELEASE_OBJECT(m_ppNotifyDBEvents[i])
			// compress remaining entries in table
			for (UINT j = i; j < m_uiConnectionsActive - 1; j++)
				 m_ppNotifyDBEvents[j] = m_ppNotifyDBEvents[j + 1];
			m_uiConnectionsActive--;
			return S_OK;
			}
		}

	return CONNECT_E_NOCONNECTION;
}

//=--------------------------------------------------------------------------=
// IConnectionPoint EnumConnections
//
HRESULT CVDNotifyDBEventsConnPt::EnumConnections(LPENUMCONNECTIONS FAR* ppEnum)
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\nconnptc.h ===
//---------------------------------------------------------------------------
// NotifyConnPtCn.h : CVDNotifyDBEventsConnPtCont header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#ifndef __CVDNOTIFYDBEVENTSCONNPTCONT__
#define __CVDNOTIFYDBEVENTSCONNPTCONT__

class CVDNotifier;            // forward references
class CVDNotifyDBEventsConnPt;

class CVDNotifyDBEventsConnPtCont : public IConnectionPointContainer
{
protected:
// Construction/Destruction
	CVDNotifyDBEventsConnPtCont();
	~CVDNotifyDBEventsConnPtCont();

public:    
    static HRESULT Create(CVDNotifier * pNotifier, CVDNotifyDBEventsConnPtCont ** ppConnPtContainer);
    void Destroy();

public:
// Access functions
    CVDNotifyDBEventsConnPt * GetNotifyDBEventsConnPt() const {return m_pNotifyDBEventsConnPt;}

protected:
// Data members
	CVDNotifier *				m_pNotifier;
	CVDNotifyDBEventsConnPt *	m_pNotifyDBEventsConnPt;  // there is only one connection point
														  // namely INotifyDBEvents
public:
    // IUnknown methods -- there are required since we inherit from variuos
    // people who themselves inherit from IUnknown.
    //
    //=--------------------------------------------------------------------------=
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    //=--------------------------------------------------------------------------=
	// IConnectionPointContainer methods
    //
	STDMETHOD(EnumConnectionPoints)(THIS_ LPENUMCONNECTIONPOINTS FAR* ppEnum);
	STDMETHOD(FindConnectionPoint)(THIS_ REFIID iid, LPCONNECTIONPOINT FAR* ppCP);

};
/////////////////////////////////////////////////////////////////////////////
#endif //__CVDNOTIFYDBEVENTSCONNPTCONT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\ocdb.h ===
/*=--------------------------------------------------------------------------=
 * ocdb.h
 *=--------------------------------------------------------------------------=
 * defines the interfaces and constants for use with the OLE Controls Data
 * binding interfaces.
 *
 * Copyright (c) 1994-1995 Microsoft Corporation, All Rights Reserved.
 *
 *
 * Note: This header file has been modified by Sheridan Software to resolve
 *       name conflicts with other Microsoft header files.  All defines,
 *       enumerations and structures have been prefixed with "CURSOR_".
 *
 */
#ifndef __OCDB_H_

#undef Delete
#ifdef __cplusplus
extern "C" {
#endif

/* CURSOR_LPDBSTRs are MultiByte in 16bits, and Unicode in 32bits.
 */
#if WIN16

#define CURSOR_LPDBSTR              LPSTR
#define CURSOR_DBCHAR               char
#define CURSOR_ldbstrlen(str)       lstrlen(str)
#define CURSOR_ldbstrcpy(a, b)      lstrcpy((a), (b))
#define CURSOR_ldbstrcpyn(a,b,n)    lstrcpyn((a), (b), (n))
#define CURSOR_ldbstrcmp(a, b)      lstrcmp((a), (b))
#define CURSOR_ldbstrcat(a, b)      lstrcat((a), (b))
#define CURSOR_ldbstrcmpi(a,b)      lstrcmpi((a),(b))
#define CURSOR_DBTEXT(quote)        quote

#else

#define CURSOR_LPDBSTR              LPWSTR
#define CURSOR_DBCHAR               WCHAR
#define CURSOR_ldbstrlen(str)       wcslen(str)
#define CURSOR_ldbstrcpy(a, b)      wcscpy((a), (b))
#define CURSOR_ldbstrcpyn(a,b,n)    wcsncpy((a), (b), (n))
#define CURSOR_ldbstrcmp(a, b)      wcscmp((a), (b))
#define CURSOR_ldbstrcat(a, b)      wcscat((a), (b))
#define CURSOR_ldbstrcmpi(a,b)      wcsicmp((a),(b))
#define CURSOR_DBTEXT(quote)        L##quote

#endif /* WIN16 */

typedef CURSOR_LPDBSTR FAR *  CURSOR_LPLPDBSTR;


/* Many systems don't have BLOBs defined.
 */
#ifndef _tagCURSOR_BLOB_DEFINED
#define _tagCURSOR_BLOB_DEFINED
#define _CURSOR_BLOB_DEFINED
#define _CURSOR_LPBLOB_DEFINED

typedef struct tagCURSOR_BLOB {

    ULONG cbSize;
    BYTE *pBlobData;

} CURSOR_BLOB, *CURSOR_LPBLOB;

#endif

/*----------------------------------------------------------------------------
 *
 *	dbvar.h
 *
 *----------------------------------------------------------------------------
 */
#ifndef _CURSOR_DBCOLUMNID_DEFINED
#define _CURSOR_DBCOLUMNID_DEFINED
typedef enum tagCURSOR_DBCOLKIND
    {
	    CURSOR_DBCOLKIND_GUID_NAME = 0,
	    CURSOR_DBCOLKIND_GUID_NUMBER = 1,
        CURSOR_DBCOLKIND_NAME = 2
    }
CURSOR_DBCOLKIND;

#define CURSOR_GUID_NAMEONLY	{0x88c8d398,0x863c,0x101b,{0xac,0x3b,0x00,0xaa,0x00,0x44,0x77,0x3d}}
#define CURSOR_GUID_NUMBERONLY  {0x88c8d399,0x863c,0x101b,{0xac,0x3b,0x00,0xaa,0x00,0x44,0x77,0x3d}}

typedef struct tagCURSOR_DBCOLUMNID
    {
        GUID guid;
        CURSOR_DBCOLKIND dwKind;
union
    {
        LONG lNumber;
        CURSOR_LPDBSTR lpdbsz;
    }
  ;
  }
CURSOR_DBCOLUMNID;
#endif   /* ndef _CURSOR_COLUMNID_DEFINED */

#ifndef _CURSOR_DBVARENUM_DEFINED
#define _CURSOR_DBVARENUM_DEFINED
enum CURSOR_DBVARENUM
    {
        CURSOR_DBTYPE_EMPTY = 0,
        CURSOR_DBTYPE_NULL = 1,
        CURSOR_DBTYPE_I2 = 2,
        CURSOR_DBTYPE_I4 = 3,
        CURSOR_DBTYPE_I8 = 20,
        CURSOR_DBTYPE_R4 = 4,
        CURSOR_DBTYPE_R8 = 5,
        CURSOR_DBTYPE_CY = 6,
        CURSOR_DBTYPE_DATE = 7,
        CURSOR_DBTYPE_BOOL = 11,
        CURSOR_DBTYPE_HRESULT = 25,
        CURSOR_DBTYPE_LPSTR = 30,
        CURSOR_DBTYPE_LPWSTR = 31,
        CURSOR_DBTYPE_FILETIME = 64,
        CURSOR_DBTYPE_BLOB = 65,
        CURSOR_DBTYPE_UUID = 72,
        CURSOR_DBTYPE_DBEXPR = 503,
        CURSOR_DBTYPE_UI2 = 504,
        CURSOR_DBTYPE_UI4 = 505,
        CURSOR_DBTYPE_UI8 = 506,
        CURSOR_DBTYPE_COLUMNID = 507,
        CURSOR_DBTYPE_BYTES = 508,
        CURSOR_DBTYPE_CHARS = 509,
        CURSOR_DBTYPE_WCHARS = 510,
        CURSOR_DBTYPE_ANYVARIANT = 511
    }
;
#endif   /* ndef _CURSOR_DBVARENUM_DEFINED */

#define CURSOR_DBTYPE_EXT       0x100
#define CURSOR_DBTYPE_VECTOR	0x1000

typedef struct tagCURSOR_DBVARIANT CURSOR_DBVARIANT;

struct FARSTRUCT tagCURSOR_DBVARIANT {
    VARTYPE vt;
    unsigned short wReserved1;
    unsigned short wReserved2;
    unsigned short wReserved3;
    union {
        unsigned char       bVal;	                /* VT_UI1                   */
        short	            iVal;                   /* VT_I2                    */
        long	            lVal;                   /* VT_I4                    */
        float	            fltVal;                 /* VT_R4                    */
        double	            dblVal;                 /* VT_R8                    */
#pragma warning(disable: 4237)
		VARIANT_BOOL        bool;                   /* (obsolete)               */
#pragma warning(default: 4237)
        VARIANT_BOOL        boolVal;                /* VT_BOOL                  */
        SCODE	            scode;                  /* VT_ERROR                 */
        CY	                cyVal;                  /* VT_CY                    */
        DATE	            date;                   /* VT_DATE                  */
        BSTR	            bstrVal;                /* VT_BSTR                  */
        IUnknown	        FAR* punkVal;           /* VT_UNKNOWN               */
        IDispatch	        FAR* pdispVal;          /* VT_DISPATCH              */
        SAFEARRAY	        FAR* parray;	        /* VT_ARRAY|*               */
                                                                                
        unsigned char       FAR* pbVal;             /* VT_BYREF|VT_UI1          */
        short	            FAR* piVal;             /* VT_BYREF|VT_I2	        */
        long	            FAR* plVal;             /* VT_BYREF|VT_I4	        */
        float	            FAR* pfltVal;           /* VT_BYREF|VT_R4           */
        double	            FAR* pdblVal;           /* VT_BYREF|VT_R8           */
        VARIANT_BOOL        FAR* pbool;             /* VT_BYREF|VT_BOOL         */
        SCODE	            FAR* pscode;            /* VT_BYREF|VT_ERROR        */
        CY	                FAR* pcyVal;            /* VT_BYREF|VT_CY           */
        DATE	            FAR* pdate;             /* VT_BYREF|VT_DATE         */
        BSTR	            FAR* pbstrVal;          /* VT_BYREF|VT_BSTR         */
        IUnknown            FAR* FAR* ppunkVal;     /* VT_BYREF|VT_UNKNOWN      */
        IDispatch           FAR* FAR* ppdispVal;    /* VT_BYREF|VT_DISPATCH     */
        SAFEARRAY           FAR* FAR* pparray;      /* VT_BYREF|VT_ARRAY|*      */
        VARIANT	            FAR* pvarVal;           /* VT_BYREF|VT_VARIANT      */
                                                                                
        void	            FAR* byref;	            /* Generic ByRef            */
                                                                                
        // types new to CURSOR_DBVARIANTs                                              
        //                                                                      
        CURSOR_BLOB         blob;                   /* VT_BLOB                  */
        CURSOR_DBCOLUMNID   *pColumnid;             /* CURSOR_DBTYPE_COLUMNID   */
        LPSTR               pszVal;                 /* VT_LPSTR                 */
#if WIN32                                                                       
        LPWSTR              pwszVal;                /* VT_LPWSTR                */
        LPWSTR FAR          *ppwszVal;              /* VT_LPWSTR|VT_BYREF       */
#endif /* WIN32 */                                                              
        CURSOR_BLOB FAR     *pblob;                 /* VT_BYREF|VT_BLOB                 */
        CURSOR_DBCOLUMNID   **ppColumnid;           /* VT_BYREF|CURSOR_DBTYPE_COLUMNID  */
        CURSOR_DBVARIANT    *pdbvarVal;             /* VT_BYREF|CURSOR_DBTYPE_VARIANT   */
    }
#if defined(NONAMELESSUNION) || (defined(_MAC) && !defined(__cplusplus) && !defined(_MSC_VER))
    u
#endif
    ;
};

/*----------------------------------------------------------------------------
 *
 *	dbs.h
 *
 *----------------------------------------------------------------------------
 */
typedef enum tagCURSOR_DBROWFETCH
    {
	    CURSOR_DBROWFETCH_DEFAULT = 0,
	    CURSOR_DBROWFETCH_CALLEEALLOCATES = 1,
	    CURSOR_DBROWFETCH_FORCEREFRESH = 2
    }
CURSOR_DBROWFETCH;

typedef struct tagCURSOR_DBFETCHROWS
    {
        ULONG      cRowsRequested;
        DWORD      dwFlags;
        VOID HUGEP *pData;
        VOID HUGEP *pVarData;
        ULONG      cbVarData;
        ULONG      cRowsReturned;
    }
CURSOR_DBFETCHROWS;

#define CURSOR_DB_NOMAXLENGTH   (DWORD)0
#define CURSOR_DB_NOVALUE       (DWORD)0xFFFFFFFF
#define CURSOR_DB_NULL          (DWORD)0xFFFFFFFF
#define CURSOR_DB_EMPTY         (DWORD)0xFFFFFFFE
#define CURSOR_DB_USEENTRYID    (DWORD)0xFFFFFFFD
#define CURSOR_DB_CANTCOERCE    (DWORD)0xFFFFFFFC
#define CURSOR_DB_TRUNCATED     (DWORD)0xFFFFFFFB
#define CURSOR_DB_UNKNOWN       (DWORD)0xFFFFFFFA
#define CURSOR_DB_NOINFO        (DWORD)0xFFFFFFF9

typedef enum tagCURSOR_DBBINDING
    {
	    CURSOR_DBBINDING_DEFAULT = 0,
	    CURSOR_DBBINDING_VARIANT = 1,
	    CURSOR_DBBINDING_ENTRYID = 2
    }
CURSOR_DBBINDING;

typedef enum tagCURSOR_DBBINDTYPE
    {
        CURSOR_DBBINDTYPE_DATA    = 0,
	    CURSOR_DBBINDTYPE_ENTRYID = 1,
	    CURSOR_DBBDINTYPE_EITHER  = 2,
	    CURSOR_DBBINDTYPE_BOTH    = 3
    }
CURSOR_DBBINDTYPE;

typedef struct tagCURSOR_DBCOLUMNBINDING
    {
        CURSOR_DBCOLUMNID columnID;
        ULONG obData;
        ULONG cbMaxLen;
        ULONG obVarDataLen;
        ULONG obInfo;
        DWORD dwBinding;
        DWORD dwDataType;
    }
CURSOR_DBCOLUMNBINDING;

typedef struct tagCURSOR_DBBINDPARAMS
    {
        ULONG cbMaxLen;
        DWORD dwBinding;
        DWORD dwDataType;
        ULONG cbVarDataLen;
        DWORD dwInfo;
        void *pData;
    }
CURSOR_DBBINDPARAMS;

#define CURSOR_CID_NUMBER_INVALID              -1
#define CURSOR_CID_NUMBER_AUTOINCREMENT         0
#define CURSOR_CID_NUMBER_BASECOLUMNNAME        1
#define CURSOR_CID_NUMBER_BASENAME              2
#define CURSOR_CID_NUMBER_BINARYCOMPARABLE      3
#define CURSOR_CID_NUMBER_BINDTYPE              4
#define CURSOR_CID_NUMBER_CASESENSITIVE         5
#define CURSOR_CID_NUMBER_COLLATINGORDER        6
#define CURSOR_CID_NUMBER_COLUMNID              7
#define CURSOR_CID_NUMBER_CURSORCOLUMN          8
#define CURSOR_CID_NUMBER_DATACOLUMN            9
#define CURSOR_CID_NUMBER_DEFAULTVALUE          10
#define CURSOR_CID_NUMBER_ENTRYIDMAXLENGTH      11
#define CURSOR_CID_NUMBER_FIXED                 12
#define CURSOR_CID_NUMBER_HASDEFAULT            13
#define CURSOR_CID_NUMBER_MAXLENGTH             14
#define CURSOR_CID_NUMBER_MULTIVALUED           15
#define CURSOR_CID_NUMBER_NAME                  16
#define CURSOR_CID_NUMBER_NULLABLE              17
#define CURSOR_CID_NUMBER_PHYSICALSORT          18
#define CURSOR_CID_NUMBER_NUMBER                19
#define CURSOR_CID_NUMBER_ROWENTRYID            20
#define CURSOR_CID_NUMBER_SCALE                 21
#define CURSOR_CID_NUMBER_SEARCHABLE            22
#define CURSOR_CID_NUMBER_TYPE                  23
#define CURSOR_CID_NUMBER_UNIQUE                24
#define CURSOR_CID_NUMBER_UPDATABLE             25
#define CURSOR_CID_NUMBER_VERSION               26
#define CURSOR_CID_NUMBER_STATUS                27

/* c and C++ have different meanings for const.
 */
#ifdef __cplusplus
#define EXTERNAL_DEFN    extern const
#else
#define EXTERNAL_DEFN    const
#endif /* __cplusplus */



#define CURSOR_DBCIDGUID {0xfe284700L,0xd188,0x11cd,{0xad,0x48, 0x0,0xaa, 0x0,0x3c,0x9c,0xb6}}
#ifdef CURSOR_DBINITCONSTANTS

EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMNID_INVALID        = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, -1};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_AUTOINCREMENT    = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 0};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BASECOLUMNNAME   = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 1};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BASENAME         = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 2};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BINARYCOMPARABLE = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 3};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BINDTYPE         = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 4};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_CASESENSITIVE    = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 5};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_COLLATINGORDER   = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 6};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_COLUMNID         = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 7};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_CURSORCOLUMN     = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 8};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_DATACOLUMN       = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 9};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_DEFAULTVALUE     = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 10};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_ENTRYIDMAXLENGTH = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 11};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_FIXED            = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 12};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_HASDEFAULT       = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 13};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_MAXLENGTH        = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 14};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_MULTIVALUED      = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 15};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_NAME             = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 16};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_NULLABLE         = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 17};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_PHYSICALSORT     = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 18};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_NUMBER           = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 19};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_ROWENTRYID       = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 20};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_SCALE            = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 21};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_SEARCHABLE       = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 22};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_TYPE             = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 23};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_UNIQUE           = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 24};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_UPDATABLE        = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 25};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_VERSION          = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 26};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_STATUS           = {CURSOR_DBCIDGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 27};
#else
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMNID_INVALID;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_AUTOINCREMENT;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BASECOLUMNNAME;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BASENAME;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BINARYCOMPARABLE;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BINDTYPE;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_CASESENSITIVE;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_COLLATINGORDER;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_COLUMNID;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_CURSORCOLUMN;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_DATACOLUMN;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_DEFAULTVALUE;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_ENTRYIDMAXLENGTH;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_FIXED;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_HASDEFAULT;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_MAXLENGTH;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_MULTIVALUED;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_NAME;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_NULLABLE;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_PHYSICALSORT;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_NUMBER;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_ROWENTRYID;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_SCALE;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_SEARCHABLE;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_TYPE;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_UNIQUE;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_UPDATABLE;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_VERSION;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_STATUS;
#endif

#define CURSOR_BMK_NUMBER_BMKTEMPORARY      0
#define CURSOR_BMK_NUMBER_BMKTEMPORARYREL   1
#define CURSOR_BMK_NUMBER_BMKCURSOR         2
#define CURSOR_BMK_NUMBER_BMKCURSORREL      3
#define CURSOR_BMK_NUMBER_BMKSESSION        4
#define CURSOR_BMK_NUMBER_BMKSESSIONREL     5
#define CURSOR_BMK_NUMBER_BMKPERSIST        6
#define CURSOR_BMK_NUMBER_BMKPERSISTREL     7


#define CURSOR_DBBMKGUID {0xf6304bb0L,0xd188,0x11cd,{0xad,0x48, 0x0,0xaa, 0x0,0x3c,0x9c,0xb6}}
#ifdef CURSOR_DBINITCONSTANTS
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKTEMPORARY     = {CURSOR_DBBMKGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 0};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKTEMPORARYREL  = {CURSOR_DBBMKGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 1};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKCURSOR        = {CURSOR_DBBMKGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 2};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKCURSORREL     = {CURSOR_DBBMKGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 3};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKSESSION       = {CURSOR_DBBMKGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 4};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKSESSIONREL    = {CURSOR_DBBMKGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 5};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKPERSIST       = {CURSOR_DBBMKGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 6};
EXTERNAL_DEFN CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKPERSISTREL    = {CURSOR_DBBMKGUID, CURSOR_DBCOLKIND_GUID_NUMBER, 7};
#else
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKINVALID;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKTEMPORARY;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKTEMPORARYREL;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKCURSOR;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKCURSORREL;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKSESSION;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKSESSIONREL;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKPERSIST;
extern const CURSOR_DBCOLUMNID NEAR CURSOR_COLUMN_BMKPERSISTREL;
#endif

#define CURSOR_DB_BMK_SIZE  sizeof(BYTE)
#ifdef CURSOR_DBINITCONSTANTS
EXTERNAL_DEFN BYTE NEAR CURSOR_DBBMK_INVALID    = 0x0;
EXTERNAL_DEFN BYTE NEAR CURSOR_DBBMK_CURRENT    = 0x1;
EXTERNAL_DEFN BYTE NEAR CURSOR_DBBMK_BEGINNING  = 0x2;
EXTERNAL_DEFN BYTE NEAR CURSOR_DBBMK_END        = 0x3;
#else
extern const BYTE NEAR CURSOR_DBBMK_INVALID;
extern const BYTE NEAR CURSOR_DBBMK_CURRENT;
extern const BYTE NEAR CURSOR_DBBMK_BEGINNING;
extern const BYTE NEAR CURSOR_DBBMK_END;
#endif

typedef enum tagCURSOR_DBCOLUMNBINDOPTS
    {
	    CURSOR_DBCOLUMNBINDOPTS_REPLACE = 0,
	    CURSOR_DBCOLUMNBINDOPTS_ADD = 1
    }
CURSOR_DBCOLUMNBINDOPTS;

typedef enum tagCURSOR_DBUPDATELOCK
    {
	    CURSOR_DBUPDATELOCK_PESSIMISTIC = 0,
	    CURSOR_DBUPDATELOCK_OPTIMISTIC = 1
    }
CURSOR_DBUPDATELOCK;

typedef enum tagCURSOR_DBCOLUMNDATA
    {
	    CURSOR_DBCOLUMNDATA_UNCHANGED = 0,
	    CURSOR_DBCOLUMNDATA_CHANGED = 1,
        CURSOR_DBCOLUMNDATA_UNKNOWN = 2
    }
CURSOR_DBCOLUMNDATA;

typedef enum tagCURSOR_DBROWACTION
    {
	    CURSOR_DBROWACTION_IGNORE = 0,
	    CURSOR_DBROWACTION_UPDATE = 1,
	    CURSOR_DBROWACTION_DELETE = 2,
	    CURSOR_DBROWACTION_ADD = 3,
	    CURSOR_DBROWACTION_LOCK = 4,
	    CURSOR_DBROWACTION_UNLOCK = 5
    }
CURSOR_DBROWACTION;

typedef enum tagCURSOR_DBUPDATEABLE
    {
	    CURSOR_DBUPDATEABLE_UPDATEABLE = 0,
	    CURSOR_DBUPDATEABLE_NOTUPDATEABLE = 1,
	    CURSOR_DBUPDATEABLE_UNKNOWN = 2
    }
CURSOR_DBUPDATEABLE;

typedef struct tagCURSOR_DBROWSTATUS
    {
        HRESULT hrStatus;
        CURSOR_BLOB Bookmark;
    }
CURSOR_DBROWSTATUS;

typedef enum tagCURSOR_DBEVENTWHATS
    {
        CURSOR_DBEVENT_CURRENT_ROW_CHANGED = 1,
        CURSOR_DBEVENT_CURRENT_ROW_DATA_CHANGED = 2,
        CURSOR_DBEVENT_NONCURRENT_ROW_DATA_CHANGED = 4,
        CURSOR_DBEVENT_SET_OF_COLUMNS_CHANGED = 8,
        CURSOR_DBEVENT_ORDER_OF_COLUMNS_CHANGED = 16,
        CURSOR_DBEVENT_SET_OF_ROWS_CHANGED = 32,
        CURSOR_DBEVENT_ORDER_OF_ROWS_CHANGED = 64,
        CURSOR_DBEVENT_METADATA_CHANGED = 128,
        CURSOR_DBEVENT_ASYNCH_OP_FINISHED = 256,
        CURSOR_DBEVENT_FIND_CRITERIA_CHANGED = 512,
    }
CURSOR_DBEVENTWHATS;

typedef enum tagCURSOR_DBREASON
    {
        CURSOR_DBREASON_DELETED = 1,
        CURSOR_DBREASON_INSERTED = 2,
        CURSOR_DBREASON_MODIFIED = 3,
        CURSOR_DBREASON_REMOVEDFROMCURSOR = 4,
        CURSOR_DBREASON_MOVEDINCURSOR = 5,
        CURSOR_DBREASON_MOVE = 6,
        CURSOR_DBREASON_FIND = 7,
        CURSOR_DBREASON_NEWINDEX = 8,
        CURSOR_DBREASON_ROWFIXUP = 9,
        CURSOR_DBREASON_RECALC = 10,
        CURSOR_DBREASON_REFRESH = 11,
        CURSOR_DBREASON_NEWPARAMETERS = 12,
        CURSOR_DBREASON_SORTCHANGED = 13,
        CURSOR_DBREASON_FILTERCHANGED = 14,
        CURSOR_DBREASON_QUERYSPECCHANGED = 15,
        CURSOR_DBREASON_SEEK = 16,
        CURSOR_DBREASON_PERCENT = 17,
        CURSOR_DBREASON_FINDCRITERIACHANGED = 18,
        CURSOR_DBREASON_SETRANGECHANGED = 19,
        CURSOR_DBREASON_ADDNEW = 20,
        CURSOR_DBREASON_MOVEPERCENT = 21,
        CURSOR_DBREASON_BEGINTRANSACT = 22,
        CURSOR_DBREASON_ROLLBACK = 23,
        CURSOR_DBREASON_COMMIT = 24,
        CURSOR_DBREASON_CLOSE = 25,
        CURSOR_DBREASON_BULK_ERROR = 26,
        CURSOR_DBREASON_BULK_NOTTRANSACTABLE = 27,
        CURSOR_DBREASON_BULK_ABOUTTOEXECUTE = 28,
        CURSOR_DBREASON_CANCELUPDATE = 29,
        CURSOR_DBREASON_SETCOLUMN = 30,
        CURSOR_DBREASON_EDIT = 31
    }
CURSOR_DBREASON;

// Arg1 values for CURSOR_DBREASON_FIND
typedef enum tagCURSOR_DBFINDTYPES
    {
        CURSOR_DB_FINDFIRST = 1,
        CURSOR_DB_FINDLAST = 2,
        CURSOR_DB_FINDNEXT = 3,
        CURSOR_DB_FINDPRIOR = 4,
        CURSOR_DB_FIND = 5
    }
CURSOR_DBFINDTYPES;

typedef struct tagCURSOR_DBNOTIFYREASON
    {
        DWORD dwReason;
        CURSOR_DBVARIANT arg1;
        CURSOR_DBVARIANT arg2;
    }
CURSOR_DBNOTIFYREASON;

#define CURSOR_DB_E_BADBINDINFO           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e00)
#define CURSOR_DB_E_BADBOOKMARK           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e01)
#define CURSOR_DB_E_BADCOLUMNID           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e02)
#define CURSOR_DB_E_BADCRITERIA           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e03)
#define CURSOR_DB_E_BADENTRYID            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e04)
#define CURSOR_DB_E_BADFRACTION           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e05)
#define CURSOR_DB_E_BADINDEXID            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e06)
#define CURSOR_DB_E_BADQUERYSPEC          MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e07)
#define CURSOR_DB_E_BADSORTORDER          MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e08)
#define CURSOR_DB_E_BADVALUES             MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e09)
#define CURSOR_DB_E_CANTCOERCE            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0a)
#define CURSOR_DB_E_CANTLOCK              MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0b)
#define CURSOR_DB_E_COLUMNUNAVAILABLE     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0c)
#define CURSOR_DB_E_DATACHANGED           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0d)
#define CURSOR_DB_E_INVALIDCOLUMNORDINAL  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0e)
#define CURSOR_DB_E_INVALIDINTERFACE      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0f)
#define CURSOR_DB_E_LOCKFAILED            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e10)
#define CURSOR_DB_E_ROWDELETED            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e11)
#define CURSOR_DB_E_ROWTOOSHORT           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e12)
#define CURSOR_DB_E_SCHEMAVIOLATION       MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e13)
#define CURSOR_DB_E_SEEKKINDNOTSUPPORTED  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e14)
#define CURSOR_DB_E_UPDATEINPROGRESS      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e15)
#define CURSOR_DB_E_USEENTRYID            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e16)
#define CURSOR_DB_E_STATEERROR            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e17)
#define CURSOR_DB_E_BADFETCHINFO          MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e18)
#define CURSOR_DB_E_NOASYNC               MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e19)
#define CURSOR_DB_E_ENTRYIDOPEN           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e1a)
#define CURSOR_DB_E_BUFFERTOOSMALL        MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e1b)
#define CURSOR_DB_S_BUFFERTOOSMALL        MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec0)
#define CURSOR_DB_S_CANCEL                MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec1)
#define CURSOR_DB_S_DATACHANGED           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec2)
#define CURSOR_DB_S_ENDOFCURSOR           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec3)
#define CURSOR_DB_S_ENDOFRESULTSET        MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec4)
#define CURSOR_DB_S_OPERATIONCANCELLED    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec5)
#define CURSOR_DB_S_QUERYINTERFACE        MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec6)
#define CURSOR_DB_S_WORKINGASYNC          MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec7)
//#define CURSOR_DB_S_COULDNTCOERCE         MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec8)
#define CURSOR_DB_S_MOVEDTOFIRST          MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec9)
#define CURSOR_DB_S_CURRENTROWUNCHANGED   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0eca)
#define CURSOR_DB_S_ROWADDED              MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ecb)
#define CURSOR_DB_S_ROWUPDATED            MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ecc)
#define CURSOR_DB_S_ROWDELETED            MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ecd)

/*----------------------------------------------------------------------------
 *
 *	ICursor
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursor ICursor;

#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursor;

interface ICursor : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE GetColumnsCursor
    (
	REFIID riid,
	IUnknown **ppvColumnsCursor,
	ULONG *pcRows
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetBindings
    (
	ULONG cCol,
	CURSOR_DBCOLUMNBINDING rgBoundColumns[],
	ULONG cbRowLength,
	DWORD dwFlags
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetBindings
    (
	ULONG *pcCol,
	CURSOR_DBCOLUMNBINDING *prgBoundColumns[],
	ULONG *pcbRowLength
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetNextRows
    (
	LARGE_INTEGER udlRowsToSkip,
	CURSOR_DBFETCHROWS *pFetchParams
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Requery
    (
        void
    ) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_ICursor;

typedef struct ICursorVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        ICursor FAR *this,
	REFIID riid,
	void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        ICursor FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        ICursor FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetColumnsCursor)
    (
        ICursor FAR *this,
	REFIID riid,
	IUnknown **ppvColumnsCursor,
	ULONG *pcRows
    );

    HRESULT (STDMETHODCALLTYPE FAR *SetBindings)
    (
        ICursor FAR *this,
	ULONG cCol,
	CURSOR_DBCOLUMNBINDING rgBoundColumns[],
	ULONG cbRowLength,
	DWORD dwFlags
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetBindings)
    (
        ICursor FAR *this,
	ULONG *pcCol,
	CURSOR_DBCOLUMNBINDING *prgBoundColumns[],
	ULONG *pcbRowLength
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetNextRows)
    (
        ICursor FAR *this,
	LARGE_INTEGER udlRowsToSkip,
	CURSOR_DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *Requery)
    (
        ICursor FAR *this
    );

} ICursorVtbl;

interface ICursor
{
    ICursorVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursor_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursor_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define ICursor_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define ICursor_GetColumnsCursor(pI, riid, ppvColumnsCursor, pcRows) \
    (*(pI)->lpVtbl->GetColumnsCursor)((pI), riid, ppvColumnsCursor, pcRows)

#define ICursor_SetBindings(pI, cCol, rgBoundColumns, cbRowLength, dwFlags) \
    (*(pI)->lpVtbl->SetBindings)((pI), cCol, rgBoundColumns, cbRowLength, dwFlags)

#define ICursor_GetBindings(pI, pcCol, prgBoundColumns, pcbRowLength) \
    (*(pI)->lpVtbl->GetBindings)((pI), pcCol, prgBoundColumns, pcbRowLength)

#define ICursor_GetNextRows(pI, udlRowsToSkip, pFetchParams) \
    (*(pI)->lpVtbl->GetNextRows)((pI), udlRowsToSkip, pFetchParams)

#define ICursor_Requery(pI) \
    (*(pI)->lpVtbl->Requery)((pI))

#endif /* COBJMACROS */

#endif

/*----------------------------------------------------------------------------
 *
 *	ICursorMove
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursorMove ICursorMove;

typedef enum tagCURSOR_DBCLONEOPTS
    {  
        CURSOR_DBCLONEOPTS_DEFAULT = 0,
        CURSOR_DBCLONEOPTS_SAMEROW = 1
    }
CURSOR_DBCLONEOPTS;


#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursorMove;

interface ICursorMove : public ICursor
{
public:
    virtual HRESULT STDMETHODCALLTYPE Move
    (
	ULONG cbBookmark,
	void *pBookmark,
	LARGE_INTEGER dlOffset,
	CURSOR_DBFETCHROWS *pFetchParams
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetBookmark
    (
	CURSOR_DBCOLUMNID *pBookmarkType,
	ULONG cbMaxSize,
	ULONG *pcbBookmark,
	void *pBookmark
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Clone
    (
	DWORD dwFlags,
	REFIID riid,
	IUnknown **ppvClonedCursor
    ) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_ICursorMove;

typedef struct ICursorMoveVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        ICursorMove FAR *this,
	REFIID riid,
	void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        ICursorMove FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        ICursorMove FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetColumnsCursor)
    (
        ICursorMove FAR *this,
	REFIID riid,
	IUnknown **ppvColumnsCursor,
	ULONG *pcRows
    );

    HRESULT (STDMETHODCALLTYPE FAR *SetBindings)
    (
        ICursorMove FAR *this,
	ULONG cCol,
	CURSOR_DBCOLUMNBINDING rgBoundColumns[],
	ULONG cbRowLength,
	DWORD dwFlags
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetBindings)
    (
        ICursorMove FAR *this,
	ULONG *pcCol,
	CURSOR_DBCOLUMNBINDING *prgBoundColumns[],
	ULONG *pcbRowLength
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetNextRows)
    (
        ICursorMove FAR *this,
	LARGE_INTEGER udlRowsToSkip,
	CURSOR_DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *Requery)
    (
        ICursorMove FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *Move)
    (
        ICursorMove FAR *this,
	ULONG cbBookmark,
	void *pBookmark,
	LARGE_INTEGER dlOffset,
	CURSOR_DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetBookmark)
    (
        ICursorMove FAR *this,
	CURSOR_DBCOLUMNID *pBookmarkType,
	ULONG cbMaxSize,
	ULONG *pcbBookmark,
	void *pBookmark
    );

    HRESULT (STDMETHODCALLTYPE FAR *Clone)
    (
        ICursorMove FAR *this,
	DWORD dwFlags,
	REFIID riid,
	IUnknown **ppvClonedCursor
    );

} ICursorMoveVtbl;

interface ICursorMove
{
    ICursorMoveVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursorMove_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursorMove_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define ICursorMove_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define ICursorMove_GetColumnsCursor(pI, riid, ppvColumnsCursor, pcRows) \
    (*(pI)->lpVtbl->GetColumnsCursor)((pI), riid, ppvColumnsCursor, pcRows)

#define ICursorMove_SetBindings(pI, cCol, rgBoundColumns, cbRowLength, dwFlags) \
    (*(pI)->lpVtbl->SetBindings)((pI), cCol, rgBoundColumns, cbRowLength, dwFlags)

#define ICursorMove_GetBindings(pI, pcCol, prgBoundColumns, pcbRowLength) \
    (*(pI)->lpVtbl->GetBindings)((pI), pcCol, prgBoundColumns, pcbRowLength)

#define ICursorMove_GetNextRows(pI, udlRowsToSkip, pFetchParams) \
    (*(pI)->lpVtbl->GetNextRows)((pI), udlRowsToSkip, pFetchParams)

#define ICursorMove_Requery(pI) \
    (*(pI)->lpVtbl->Requery)((pI))

#define ICursorMove_Move(pI, cbBookmark, pBookmark, dlOffset, pFetchParams) \
    (*(pI)->lpVtbl->Move)((pI), cbBookmark, pBookmark, dlOffset, pFetchParams)

#define ICursorMove_GetBookmark(pI, pBookmarkType, cbMaxSize, pcbBookmark, pBookmark) \
    (*(pI)->lpVtbl->GetBookmark)((pI), pBookmarkType, cbMaxSize, pcbBookmark, pBookmark)

#define ICursorMove_Clone(pI, dwFlags, riid, ppvClonedCursor) \
    (*(pI)->lpVtbl->Clone)((pI), dwFlags, riid, ppvClonedCursor)
#endif /* COBJMACROS */

#endif

/*----------------------------------------------------------------------------
 *
 *	ICursorScroll
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursorScroll ICursorScroll;

typedef enum tagCURSOR_DBCURSORPOPULATED
    {
        CURSOR_DBCURSORPOPULATED_FULLY = 0,
        CURSOR_DBCURSORPOPULATED_PARTIALLY = 1
    }
CURSOR_DBCURSORPOPULATED;


#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursorScroll;

interface ICursorScroll : public ICursorMove
{
public:
    virtual HRESULT STDMETHODCALLTYPE Scroll
    (
	ULONG ulNumerator,
	ULONG ulDenominator,
	CURSOR_DBFETCHROWS *pFetchParams
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetApproximatePosition
    (
	ULONG cbBookmark,
	void *pBookmark,
	ULONG *pulNumerator,
	ULONG *pulDenominator
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetApproximateCount
    (
	LARGE_INTEGER *pudlApproxCount,
	DWORD *pdwFullyPopulated
    ) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_ICursorScroll;

typedef struct ICursorScrollVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        ICursorScroll FAR *this,
	REFIID riid,
	void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        ICursorScroll FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        ICursorScroll FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetColumnsCursor)
    (
        ICursorScroll FAR *this,
	REFIID riid,
	IUnknown **ppvColumnsCursor,
	ULONG *pcRows
    );

    HRESULT (STDMETHODCALLTYPE FAR *SetBindings)
    (
        ICursorScroll FAR *this,
	ULONG cCol,
	CURSOR_DBCOLUMNBINDING rgBoundColumns[],
	ULONG cbRowLength,
	DWORD dwFlags
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetBindings)
    (
        ICursorScroll FAR *this,
	ULONG *pcCol,
	CURSOR_DBCOLUMNBINDING *prgBoundColumns[],
	ULONG *pcbRowLength
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetNextRows)
    (
        ICursorScroll FAR *this,
	LARGE_INTEGER udlRowsToSkip,
	CURSOR_DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *Requery)
    (
        ICursorScroll FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *Move)
    (
        ICursorScroll FAR *this,
	ULONG cbBookmark,
	void *pBookmark,
	LARGE_INTEGER dlOffset,
	CURSOR_DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetBookmark)
    (
        ICursorScroll FAR *this,
	CURSOR_DBCOLUMNID *pBookmarkType,
	ULONG cbMaxSize,
	ULONG *pcbBookmark,
	void *pBookmark
    );

    HRESULT (STDMETHODCALLTYPE FAR *Clone)
    (
        ICursorScroll FAR *this,
	DWORD dwFlags,
	REFIID riid,
	IUnknown **ppvClonedCursor
    );

    HRESULT (STDMETHODCALLTYPE FAR *Scroll)
    (
        ICursorScroll FAR *this,
	ULONG ulNumerator,
	ULONG ulDenominator,
	CURSOR_DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetApproximatePosition)
    (
        ICursorScroll FAR *this,
	ULONG cbBookmark,
	void *pBookmark,
	ULONG *pulNumerator,
	ULONG *pulDenominator
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetApproximateCount)
    (
        ICursorScroll FAR *this,
	LARGE_INTEGER *pudlApproxCount,
	DWORD *pdwFullyPopulated
    );

} ICursorScrollVtbl;

interface ICursorScroll
{
    ICursorScrollVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursorScroll_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursorScroll_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define ICursorScroll_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define ICursorScroll_GetColumnsCursor(pI, riid, ppvColumnsCursor, pcRows) \
    (*(pI)->lpVtbl->GetColumnsCursor)((pI), riid, ppvColumnsCursor, pcRows)

#define ICursorScroll_SetBindings(pI, cCol, rgBoundColumns, cbRowLength, dwFlags) \
    (*(pI)->lpVtbl->SetBindings)((pI), cCol, rgBoundColumns, cbRowLength, dwFlags)

#define ICursorScroll_GetBindings(pI, pcCol, prgBoundColumns, pcbRowLength) \
    (*(pI)->lpVtbl->GetBindings)((pI), pcCol, prgBoundColumns, pcbRowLength)

#define ICursorScroll_GetNextRows(pI, udlRowsToSkip, pFetchParams) \
    (*(pI)->lpVtbl->GetNextRows)((pI), udlRowsToSkip, pFetchParams)

#define ICursorScroll_Requery(pI) \
    (*(pI)->lpVtbl->Requery)((pI))

#define ICursorScroll_Move(pI, cbBookmark, pBookmark, dlOffset, pFetchParams) \
    (*(pI)->lpVtbl->Move)((pI), cbBookmark, pBookmark, dlOffset, pFetchParams)

#define ICursorScroll_GetBookmark(pI, pBookmarkType, cbMaxSize, pcbBookmark, pBookmark) \
    (*(pI)->lpVtbl->GetBookmark)((pI), pBookmarkType, cbMaxSize, pcbBookmark, pBookmark)

#define ICursorScroll_Clone(pI, dwFlags, riid, ppvClonedCursor) \
    (*(pI)->lpVtbl->Clone)((pI), dwFlags, riid, ppvClonedCursor)

#define ICursorScroll_Scroll(pI, ulNumerator, ulDenominator, pFetchParams) \
    (*(pI)->lpVtbl->Scroll)((pI), ulNumerator, ulDenominator, pFetchParams)

#define ICursorScroll_GetApproximatePosition(pI, cbBookmark, pBookmark, pulNumerator, pulDenominator) \
    (*(pI)->lpVtbl->GetApproximatePosition)((pI), cbBookmark, pBookmark, pulNumerator, pulDenominator)

#define ICursorScroll_GetApproximateCount(pI, pudlApproxCount, pdwFullyPopulated) \
    (*(pI)->lpVtbl->GetApproximateCount)((pI), pudlApproxCount, pdwFullyPopulated)
#endif /* COBJMACROS */

#endif

/*----------------------------------------------------------------------------
 *
 *	ICursorUpdateARow
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursorUpdateARow ICursorUpdateARow;

typedef enum tagCURSOR_DBEDITMODE
    {
        CURSOR_DBEDITMODE_NONE = 1,
        CURSOR_DBEDITMODE_UPDATE = 2,
        CURSOR_DBEDITMODE_ADD = 3
    }
CURSOR_DBEDITMODE;


#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursorUpdateARow;

interface ICursorUpdateARow : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE BeginUpdate
    (
	DWORD dwFlags
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetColumn
    (
	CURSOR_DBCOLUMNID *pcid,
	CURSOR_DBBINDPARAMS *pBindParams
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetColumn
    (
	CURSOR_DBCOLUMNID *pcid,
	CURSOR_DBBINDPARAMS *pBindParams,
	DWORD *pdwFlags
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetEditMode
    (
	DWORD *pdwState
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Update
    (
	CURSOR_DBCOLUMNID *pBookmarkType,
	ULONG *pcbBookmark,
	void **ppBookmark
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Cancel
    (
        void
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Delete
    (
	void
    ) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_ICursorUpdateARow;

typedef struct ICursorUpdateARowVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        ICursorUpdateARow FAR *this,
	REFIID riid,
	void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        ICursorUpdateARow FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        ICursorUpdateARow FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *BeginUpdate)
    (
        ICursorUpdateARow FAR *this,
	DWORD dwFlags
    );

    HRESULT (STDMETHODCALLTYPE FAR *SetColumn)
    (
        ICursorUpdateARow FAR *this,
	CURSOR_DBCOLUMNID *pcid,
	CURSOR_DBBINDPARAMS *pBindParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetColumn)
    (
        ICursorUpdateARow FAR *this,
	CURSOR_DBCOLUMNID *pcid,
	CURSOR_DBBINDPARAMS *pBindParams,
	DWORD *pdwFlags
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetEditMode)
    (
        ICursorUpdateARow FAR *this,
	DWORD *pdwState
    );

    HRESULT (STDMETHODCALLTYPE FAR *Update)
    (
        ICursorUpdateARow FAR *this,
	CURSOR_DBCOLUMNID *pBookmarkType,
	ULONG *pcbBookmark,
	void **ppBookmark
    );

    HRESULT (STDMETHODCALLTYPE FAR *Cancel)
    (
        ICursorUpdateARow FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *Delete)
    (
        ICursorUpdateARow FAR *this
    );

} ICursorUpdateARowVtbl;

interface ICursorUpdateARow
{
    ICursorUpdateARowVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursorUpdateARow_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursorUpdateARow_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define ICursorUpdateARow_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define ICursorUpdateARow_BeginUpdate(pI, dwFlags) \
    (*(pI)->lpVtbl->BeginUpdate)((pI), dwFlags)

#define ICursorUpdateARow_SetColumn(pI, pcid, pBindParams) \
    (*(pI)->lpVtbl->SetColumn)((pI), pcid, pBindParams)

#define ICursorUpdateARow_GetColumn(pI, pcid, pBindParams, pdwFlags) \
    (*(pI)->lpVtbl->GetColumn)((pI), pcid, pBindParams, pdwFlags)

#define ICursorUpdateARow_GetEditMode(pI, pdwState) \
    (*(pI)->lpVtbl->GetEditMode)((pI), pdwState)

#define ICursorUpdateARow_Update(pI, pBookmarkType, pcbBookmark, ppBookmark) \
    (*(pI)->lpVtbl->Update)((pI), pBookmarkType, pcbBookmark, ppBookmark)

#define ICursorUpdateARow_Cancel(pI) \
    (*(pI)->lpVtbl->Cancel)((pI))

#define ICursorUpdateARow_Delete(pI) \
    (*(pI)->lpVtbl->Delete)((pI))


#endif /* COBJMACROS */

#endif

/*----------------------------------------------------------------------------
 *
 *	ICursorFind
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursorFind ICursorFind;

typedef enum tagCURSOR_DBFINDFLAGS
    {
        CURSOR_DBFINDFLAGS_FINDNEXT = 1,
        CURSOR_DBFINDFLAGS_FINDPRIOR = 2,
        CURSOR_DBFINDFLAGS_INCLUDECURRENT = 4
    }
CURSOR_DBFINDFLAGS;


typedef enum tagCURSOR_DBSEEKFLAGS
    {
        CURSOR_DBSEEK_LT	 = 1,
        CURSOR_DBSEEK_LE	 = 2,
        CURSOR_DBSEEK_EQ	 = 3,		// EXACT EQUALITY
        CURSOR_DBSEEK_GT	 = 4,
        CURSOR_DBSEEK_GE	 = 5,
        CURSOR_DBSEEK_PARTIALEQ = 6             // only for strings
    }
CURSOR_DBSEEKFLAGS;

#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursorFind;

interface ICursorFind : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE FindByValues
    (
	ULONG                       cbBookmark,
	LPVOID                      pBookmark,
	DWORD                       dwFindFlags,
	ULONG                       cValues,
    CURSOR_DBCOLUMNID           rgColumns[],
	CURSOR_DBVARIANT            rgValues[],
	DWORD                       rgdwSeekFlags[],
    CURSOR_DBFETCHROWS FAR *    pFetchParams
    ) = 0;
};

#else

/* C Language Binding */
//extern const IID IID_ICursorFind;

typedef struct ICursorFindVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        ICursorFind FAR *this,
	REFIID riid,
	void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        ICursorFind FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        ICursorFind FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *FindByValues)
    (
        ICursorFind FAR *this,
	ULONG                       cbBookmark,
	LPVOID                      pBookmark,
	DWORD                       dwFindFlags,
	ULONG                       cValues,
    CURSOR_DBCOLUMNID           rgColumns[],
	CURSOR_DBVARIANT            rgValues[],
	DWORD                       rgdwSeekFlags[],
    CURSOR_DBFETCHROWS FAR *    pFetchParams
    );


} ICursorFindVtbl;

interface ICursorFind
{
    ICursorFindVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursorFind_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursorFind_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define ICursorFind_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define ICursorFind_FindByValues(pI, cbB, pB, dwFF, cV, rgC, rgV, rgSF, pF) \
    (*(pI)->lpVtbl->FindByValues)((pI), cbB, pB, dwFF, cB, rgC, rgV, rgSF, pF)

#endif /* COBJMACROS */

#endif


/*----------------------------------------------------------------------------
 *
 *	IEntryID
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface IEntryID IEntryID;

#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_IEntryID;

interface IEntryID : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE GetInterface
    (
	ULONG cbEntryID,
	void *pEntryID,
        DWORD dwFlags,
        REFIID riid,
	IUnknown **ppvObj
    ) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_IEntryID;

typedef struct IEntryIDVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        IEntryID FAR *this,
	REFIID riid,
	void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        IEntryID FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        IEntryID FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetInterface)
    (
        IEntryID FAR *this,
	ULONG cbEntryID,
	void *pEntryID,
        REFIID riid,
	IUnknown **ppvObj
    );

} IEntryIDVtbl;

interface IEntryID
{
    IEntryIDVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define IEntryID_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define IEntryID_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define IEntryID_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define IEntryID_GetInterface(pI, cbEntryID, pEntryID, riid, ppvObj) \
    (*(pI)->lpVtbl->GetInterface)((pI), cbEntryID, pEntryID, riid, ppvObj)
#endif /* COBJMACROS */

#endif


/*----------------------------------------------------------------------------
 *
 *	INotifyDBEvents
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface INotifyDBEvents INotifyDBEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_INotifyDBEvents;

interface INotifyDBEvents : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE OKToDo
    (
	DWORD dwEventWhat,
	ULONG cReasons,
	CURSOR_DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Cancelled
    (
	DWORD dwEventWhat,
	ULONG cReasons,
	CURSOR_DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE SyncBefore
    (
	DWORD dwEventWhat,
	ULONG cReasons,
	CURSOR_DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE AboutToDo
    (
	DWORD dwEventWhat,
	ULONG cReasons,
	CURSOR_DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE FailedToDo
    (
	DWORD dwEventWhat,
	ULONG cReasons,
	CURSOR_DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE SyncAfter
    (
	DWORD dwEventWhat,
	ULONG cReasons,
	CURSOR_DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE DidEvent
    (
	DWORD dwEventWhat,
	ULONG cReasons,
	CURSOR_DBNOTIFYREASON rgReasons[]
    ) = 0;

};

#else

/* C Language Binding */
extern const IID IID_INotifyDBEvents;

typedef struct INotifyDBEventsVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        INotifyDBEvents FAR *this,
	REFIID riid,
	void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        INotifyDBEvents FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        INotifyDBEvents FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *OKToDo)
    (
        INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	CURSOR_DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *Cancelled)
    (
        INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	CURSOR_DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *SyncBefore)
    (
        INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	CURSOR_DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *AboutToDo)
    (
        INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	CURSOR_DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *FailedToDo)
    (
        INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	CURSOR_DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *SyncAfter)
    (
        INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	CURSOR_DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *DidEvent)
    (
        INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	CURSOR_DBNOTIFYREASON rgReasons[]
    );

} INotifyDBEventsVtbl;

interface INotifyDBEvents
{
    INotifyDBEventsVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define INotifyDBEvents_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define INotifyDBEvents_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define INotifyDBEvents_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define INotifyDBEvents_OKToDo(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->OKToDo)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_Cancelled(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->Cancelled)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_SyncBefore(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->SyncBefore)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_AboutToDo(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->AboutToDo)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_FailedToDo(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->FailedToDo)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_SyncAfter(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->SyncAfter)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_DidEvent(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->DidEvent)((pI), dwEventWhat, cReasons, rgReasons)
#endif /* COBJMACROS */

#endif


#ifdef __cplusplus
}
#endif

#define __OCDB_H_
#endif // __OCDB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\notifier.h ===
//---------------------------------------------------------------------------
// Notifier.h : CVDNotifier header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------


#ifndef __CVDNOTIFIER__
#define __CVDNOTIFIER__


class CVDNotifier : public IUnknown
{
protected:
// Construction/Destruction
    CVDNotifier();
	virtual ~CVDNotifier();

protected:
// Data members
    DWORD           m_dwRefCount;   // reference count
    CVDNotifier *   m_pParent;      // pointer to CVDNotifier derived parent
    CPtrArray		m_Children;     // pointer array of CVDNotifier derived children

public:
    //=--------------------------------------------------------------------------=
    // IUnknown methods implemented
    //
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);
	
	HRESULT			JoinFamily (CVDNotifier* pParent);
	HRESULT			LeaveFamily();

	CVDNotifier* GetParent () const { return m_pParent; }

	virtual HRESULT	NotifyBefore(DWORD, ULONG, CURSOR_DBNOTIFYREASON[]);
	virtual HRESULT NotifyAfter (DWORD, ULONG, CURSOR_DBNOTIFYREASON[]);
	virtual HRESULT NotifyFail  (DWORD, ULONG, CURSOR_DBNOTIFYREASON[]);

protected:
	// helper functions
	HRESULT			AddChild   (CVDNotifier* pChild);
	HRESULT			DeleteChild(CVDNotifier* pChild);

	virtual HRESULT	NotifyOKToDo    (DWORD, ULONG, CURSOR_DBNOTIFYREASON[]);
	virtual HRESULT NotifySyncBefore(DWORD, ULONG, CURSOR_DBNOTIFYREASON[]);
	virtual HRESULT NotifyAboutToDo (DWORD, ULONG, CURSOR_DBNOTIFYREASON[]);
	virtual HRESULT NotifySyncAfter (DWORD, ULONG, CURSOR_DBNOTIFYREASON[]);
	virtual HRESULT NotifyDidEvent  (DWORD, ULONG, CURSOR_DBNOTIFYREASON[]);
	virtual HRESULT NotifyCancel    (DWORD, ULONG, CURSOR_DBNOTIFYREASON[]);
};


#endif //__CVDNOTIFIER__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\ocdbid.h ===
/*=--------------------------------------------------------------------------=
 * ocdbid.h
 *=--------------------------------------------------------------------------=
 * defines all the guids for OLE Controls Data Binding Interfaces interfaces.
 *
 * Copyright (c) 1994-1995 Microsoft Corporation, All Rights Reserved.
 *
 *
 * Note: This header file has been modified by Sheridan Software to resolve
 *       name conflicts with other Microsoft header files.  Some GUIDs have
 *       prefixed with "_CURSOR".
 *
 */

/* {9F6AA700-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursor,
0x9f6aa700, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {ACFF0690-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursorMove,
0xacff0690, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {BB87E420-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursorScroll,
0xbb87e420, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {D14216A0-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursorUpdateARow,
0xd14216a0, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {DB526CC0-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_INotifyDBEvents,
0xdb526cc0, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {E01D7850-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursorFind,
0xe01d7850, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {E4D19810-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_IEntryID,
0xe4d19810, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {E8BF1170-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(_CURSOR_GUID_NAMEONLY,
0xe8bf1170, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {F6304BB0-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(_CURSOR_DBBMKGUID,
0xf6304bb0, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {FE284700-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(_CURSOR_DBCIDGUID,
0xfe284700, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\notifier.cpp ===
//---------------------------------------------------------------------------
// Notifier.cpp : Notifier implementation
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "Notifier.h"

SZTHISFILE

#include "array_p.inl"

//=--------------------------------------------------------------------------=
// CVDNotifier - Constructor
//
CVDNotifier::CVDNotifier()
{
    m_dwRefCount    = 1;
    m_pParent       = NULL;

#ifdef _DEBUG
    g_cVDNotifierCreated++;
#endif
}

//=--------------------------------------------------------------------------=
// ~CVDNotifier - Destructor
//
CVDNotifier::~CVDNotifier()
{
#ifdef _DEBUG
    g_cVDNotifierDestroyed++;
#endif
}

//=--------------------------------------------------------------------------=
// IUnknown QueryInterface 	 - stub implemntation - does nothing
//
HRESULT CVDNotifier::QueryInterface(REFIID riid, void **ppvObjOut)
{
	return E_NOINTERFACE;

}

//=--------------------------------------------------------------------------=
// AddRef
//
ULONG CVDNotifier::AddRef(void)
{
   return ++m_dwRefCount;
}

//=--------------------------------------------------------------------------=
// Release
//
ULONG CVDNotifier::Release(void)
{
    if (1 > --m_dwRefCount)
    {
        delete this;
        return 0;
    }

    return m_dwRefCount;
}

/////////////////////////////////////////////////////////////////////
// family maintenance
/////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
// Member:		Join Family (public)
//
// Synopsis:	add myself to the family of the given parent
//
// Arguments:	pParent		[in] parent of family I should join
//
// Returns:		S_OK		it worked
//				other		it didn't

HRESULT
CVDNotifier::JoinFamily(CVDNotifier* pParent)
{
	ASSERT_POINTER(pParent, CVDNotifier);
	m_pParent = pParent;
	return m_pParent->AddChild(this);
}


//+-------------------------------------------------------------------------
// Member:		Leave Family (public)
//
// Synopsis:	remove myself from my parent's family
//
// Arguments:	none
//
// Returns:		S_OK		it worked
//				other		it didn't

HRESULT
CVDNotifier::LeaveFamily()
{
	if (m_pParent)
		return m_pParent->DeleteChild(this);
	return S_OK;
}


//+-------------------------------------------------------------------------
// Member:		Add Child (public)
//
// Synopsis:	add a notifier to my child list
//
// Arguments:	pChild	[in] notifier to add as a child
//
// Returns:		S_OK		it worked
//				other		error while appending to dynamic array

HRESULT
CVDNotifier::AddChild(CVDNotifier *pChild)
{
	return m_Children.Add(pChild);
}


//+-------------------------------------------------------------------------
// Member:		Delete Child (public)
//
// Synopsis:	delete a notifier from my child list.  When the last
//				notifier is deleted, delete myself from my parent's
//				child list.
//
// Arguments:	pChild		[in] notifier to delete
//
// Returns:		S_OK		it worked
//				E_FAIL		error while deleting from dynamic array
//				other		error while deleting from parent's child list

HRESULT
CVDNotifier::DeleteChild(CVDNotifier *pChild)
{

	int k;

	for (k=0; k<m_Children.GetSize(); k++)
	{
		if (((CVDNotifier*)m_Children[k]) == pChild)
		{
			m_Children.RemoveAt(k);
			return S_OK;
		}
	}

	return E_FAIL;
}



/////////////////////////////////////////////////////////////////////
// notification
/////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
// Member:		Notify Before (public)
//
// Synopsis:	send OKToDo, SyncBefore, and AboutToDo notifications
//				before doing an event.  Send FailedToDo notification
//				if anything goes wrong during the process.
//
// Arguments:	dwEventWhat	[in] what event is causing the notification
//				cReasons	[in] how many reasons
//				rgReasons	[in] list of reasons for the event
//
// Returns:		S_OK			everything is OK so far
//				other			some client indicated failure

HRESULT
CVDNotifier::NotifyBefore(DWORD dwEventWhat, ULONG cReasons,
						 	 CURSOR_DBNOTIFYREASON rgReasons[])
{
	HRESULT hr;

	// phase 1:  send OKToDo, and Cancelled if anyone objects
	hr = NotifyOKToDo(dwEventWhat, cReasons, rgReasons);
	if (hr)
		return hr;

	// phase 2:  send SyncBefore, and send FailedToDo if anything goes wrong
	hr = NotifySyncBefore(dwEventWhat, cReasons, rgReasons);
	if (hr) {
		NotifyFail(dwEventWhat, cReasons, rgReasons);
		return hr;
	}

	// phase 3:  send AboutToDo, and send FailedToDo if anything goes wrong
	hr = NotifyAboutToDo(dwEventWhat, cReasons, rgReasons);
	if (hr) {
		NotifyFail(dwEventWhat, cReasons, rgReasons);
		return hr;
	}
	
	return S_OK;
}


//+-------------------------------------------------------------------------
// Member:		Notify After (public)
//
// Synopsis:	send SyncAfter and DidEvent notifications after an event
//
// Arguments:	dwEventWhat	[in] what event is causing the notification
//				cReasons	[in] how many reasons
//				rgReasons	[in] list of reasons for the event
//
// Returns:		S_OK		it worked

HRESULT
CVDNotifier::NotifyAfter(DWORD dwEventWhat, ULONG cReasons,
						CURSOR_DBNOTIFYREASON rgReasons[])
{
	// phase 5: send SyncAfter.  Ignore errors - all clients need to hear this
	NotifySyncAfter(dwEventWhat, cReasons, rgReasons);

	// phase 6: send DidEvent.  Ignore errors - all clients need to hear this
	NotifyDidEvent(dwEventWhat, cReasons, rgReasons);

	return S_OK;
}


//+-------------------------------------------------------------------------
// Member:		Notify Fail (public)
//
// Synopsis:	send FailedToDo notification
//
// Arguments:	dwEventWhat	[in] what event is causing the notification
//				cReasons	[in] how many reasons
//				rgReasons	[in] list of reasons for the event
//
// Returns:		S_OK		it worked

HRESULT
CVDNotifier::NotifyFail(DWORD dwEventWhat, ULONG cReasons,
					   CURSOR_DBNOTIFYREASON rgReasons[])
{
	int k;

	// send FailedToDo to all clients, ignoring errors
	for (k=0; k<m_Children.GetSize(); k++) {
		((CVDNotifier*)m_Children[k])->NotifyFail(dwEventWhat, cReasons, rgReasons);
	}
	
	return S_OK;
}



/////////////////////////////////////////////////////////////////////////
// helper functions
/////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
// Member:		Notify OK To Do (protected)
//
// Synopsis:	Send OKToDo notification.  If a client objects (by
//				returning a non-zero HR), send Cancelled to notified
//				clients to cancel the event.
//
// Arguments:	dwEventWhat	[in] what event is causing the notification
//				cReasons	[in] how many reasons
//				rgReasons	[in] list of reasons for the event
//
// Returns:		S_OK		all clients agree it's OK to do the event
//				other		some client disagrees

HRESULT
CVDNotifier::NotifyOKToDo(DWORD dwEventWhat, ULONG cReasons,
						 CURSOR_DBNOTIFYREASON rgReasons[])
{
	HRESULT hr = S_OK;
	int j, k;

	// poll all clients, see if they think it's OKToDo the event
	for (k=0; k<m_Children.GetSize(); k++) {
		hr = ((CVDNotifier*)m_Children[k])->NotifyOKToDo(dwEventWhat, cReasons, rgReasons);
		if (hr) {			// somone objects, inform polled clients it's cancelled
			for (j=0; j<=k; j++) {
				((CVDNotifier*)m_Children[j])->NotifyCancel(dwEventWhat, cReasons, rgReasons);
			}
			break;
		}
	}

	return hr;
}


//+-------------------------------------------------------------------------
// Member:		Notify Sync Before (public)
//
// Synopsis:	Send SyncBefore notification
//
// Arguments:	dwEventWhat	[in] what event is causing the notification
//				cReasons	[in] how many reasons
//				rgReasons	[in] list of reasons for the event
//
// Returns:		S_OK		all clients received notification
//				other		some client returned an error

HRESULT
CVDNotifier::NotifySyncBefore(DWORD dwEventWhat, ULONG cReasons,
							 CURSOR_DBNOTIFYREASON rgReasons[])
{
	HRESULT hr = S_OK;
	int k;

	for (k=0; k<m_Children.GetSize(); k++) {
		hr = ((CVDNotifier*)m_Children[k])->NotifySyncBefore(dwEventWhat, cReasons, rgReasons);
		if (hr)
			break;
	}
	return hr;
}


//+-------------------------------------------------------------------------
// Member:		Notify About To Do (protected)
//
// Synopsis:	Send AboutToDo notification
//
// Arguments:	dwEventWhat	[in] what event is causing the notification
//				cReasons	[in] how many reasons
//				rgReasons	[in] list of reasons for the event
//
// Returns:		S_OK		all clients notified
//				other		some client returned an error

HRESULT
CVDNotifier::NotifyAboutToDo(DWORD dwEventWhat, ULONG cReasons,
							CURSOR_DBNOTIFYREASON rgReasons[])
{
	HRESULT hr = S_OK;
	int k;

	for (k=0; k<m_Children.GetSize(); k++) {
		hr = ((CVDNotifier*)m_Children[k])->NotifyAboutToDo(dwEventWhat, cReasons, rgReasons);
		if (hr)
			break;
	}
	return hr;
}


//+-------------------------------------------------------------------------
// Member:		Notify Sync After (protected)
//
// Synopsis:	Send SyncAfter notification.
//
// Arguments:	dwEventWhat	[in] what event is causing the notification
//				cReasons	[in] how many reasons
//				rgReasons	[in] list of reasons for the event
//
// Returns:		S_OK		all clients notified

HRESULT
CVDNotifier::NotifySyncAfter(DWORD dwEventWhat, ULONG cReasons,
								CURSOR_DBNOTIFYREASON rgReasons[])
{
	int k;

	// send SyncAfter to all clients, ignoring errors
	for (k=0; k<m_Children.GetSize(); k++) {
		((CVDNotifier*)m_Children[k])->NotifySyncAfter(dwEventWhat, cReasons, rgReasons);
	}
	
	return S_OK;
}


//+-------------------------------------------------------------------------
// Member:		Notify Did Event (protected)
//
// Synopsis:	Send DidEvent notification
//
// Arguments:	dwEventWhat	[in] what event is causing the notification
//				cReasons	[in] how many reasons
//				rgReasons	[in] list of reasons for the event
//
// Returns:		S_OK		all clients notified

HRESULT
CVDNotifier::NotifyDidEvent(DWORD dwEventWhat, ULONG cReasons,
							   CURSOR_DBNOTIFYREASON rgReasons[])
{
	int k;

	// send DidEvent to all clients, ignoring errors
	for (k=0; k<m_Children.GetSize(); k++) {
		((CVDNotifier*)m_Children[k])->NotifyDidEvent(dwEventWhat, cReasons, rgReasons);
	}
	
	return S_OK;
}


//+-------------------------------------------------------------------------
// Member:		Notify Cancel (protected)
//
// Synopsis:	Send Cancelled notification
//
// Arguments:	dwEventWhat	[in] what event is causing the notification
//				cReasons	[in] how many reasons
//				rgReasons	[in] list of reasons for the event
//
// Returns:		S_OK		all clients notified

HRESULT
CVDNotifier::NotifyCancel(DWORD dwEventWhat, ULONG cReasons,
						 	 CURSOR_DBNOTIFYREASON rgReasons[])
{
	int k;

	// send Cancelled to all clients, ignoring errors
	for (k=0; k<m_Children.GetSize(); k++) {
		((CVDNotifier*)m_Children[k])->NotifyCancel(dwEventWhat, cReasons, rgReasons);
	}
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\nconnptc.cpp ===
//---------------------------------------------------------------------------
// NotifyConnPtCn.cpp : CVDNotifyDBEventsConnPtCont implementation file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"         
#include "NConnPt.h"         
#include "NConnPtC.h"         
#include "enumcnpt.h"         
#include "Notifier.h"         
#include "RSSource.h"         

// needed for ASSERTs and FAIL
//
SZTHISFILE

//=--------------------------------------------------------------------------=
// CVDNotifyDBEventsConnPtCont constructor
//
CVDNotifyDBEventsConnPtCont::CVDNotifyDBEventsConnPtCont()
{
	m_pNotifier = NULL;

#ifdef _DEBUG
    g_cVDNotifyDBEventsConnPtContCreated++;
#endif			
}

//=--------------------------------------------------------------------------=
// CVDNotifyDBEventsConnPtCont destructor
//
CVDNotifyDBEventsConnPtCont::~CVDNotifyDBEventsConnPtCont()
{
	RELEASE_OBJECT(m_pNotifyDBEventsConnPt)

#ifdef _DEBUG
    g_cVDNotifyDBEventsConnPtContDestroyed++;
#endif			
}

//=--------------------------------------------------------------------------=
// Create - Create connection point container object
//=--------------------------------------------------------------------------=
// This function creates a new connection point container object
//
// Parameters:
//    pConnPtContainer      - [in]  a pointer to rowset object
//    ppNotifyDBEventsConnPt  - [out] a pointer in which to return pointer to 
//                                  connection point container object
//
// Output:
//    HRESULT - S_OK if successful
//              E_OUTOFMEMORY not enough memory to create object
//
// Notes:
//
HRESULT CVDNotifyDBEventsConnPtCont::Create(CVDNotifier * pNotifier, CVDNotifyDBEventsConnPtCont ** ppConnPtContainer)
{
    *ppConnPtContainer = NULL;

    CVDNotifyDBEventsConnPtCont * pConnPtContainer = new CVDNotifyDBEventsConnPtCont();

    if (!pConnPtContainer)
        return E_OUTOFMEMORY;

    pConnPtContainer->m_pNotifier = pNotifier;

    CVDNotifyDBEventsConnPt::Create(pConnPtContainer, &pConnPtContainer->m_pNotifyDBEventsConnPt);

    if (!pConnPtContainer->m_pNotifyDBEventsConnPt)
    {
        delete pConnPtContainer;
        return E_OUTOFMEMORY;
    }

    *ppConnPtContainer = pConnPtContainer;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// Destroy - Destroy this connection point container object
//
void CVDNotifyDBEventsConnPtCont::Destroy()
{
    delete this;
}

//=--------------------------------------------------------------------------=
// IUnknown QueryInterface 
//
HRESULT CVDNotifyDBEventsConnPtCont::QueryInterface(REFIID riid, void **ppvObjOut)
{

	return ((CVDNotifier*)m_pNotifier)->QueryInterface(riid, ppvObjOut); // logically part of CVDNotifier derived object;

}

//=--------------------------------------------------------------------------=
// IUnknown AddRef
//
ULONG CVDNotifyDBEventsConnPtCont::AddRef(void)
{
	return ((CVDNotifier*)m_pNotifier)->AddRef(); // logically part of CVDNotifier derived object
}

//=--------------------------------------------------------------------------=
// IUnknown Release
//
ULONG CVDNotifyDBEventsConnPtCont::Release(void)
{
	return ((CVDNotifier*)m_pNotifier)->Release(); // logically part of CVDNotifier derived object
}

//=--------------------------------------------------------------------------=
// IConnectionPointContainer Methods
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// IConnectionPointContainer EnumConnectionPoints
//
HRESULT CVDNotifyDBEventsConnPtCont::EnumConnectionPoints(LPENUMCONNECTIONPOINTS FAR* ppEnum)
{
	ASSERT_POINTER(ppEnum, LPENUMCONNECTIONPOINTS)

	CVDEnumConnPoints* pEnum = NULL;

	if (m_pNotifyDBEventsConnPt)
	{
		pEnum = new CVDEnumConnPoints(m_pNotifyDBEventsConnPt);
		if (!pEnum)
		{
			*ppEnum = NULL;
			return E_OUTOFMEMORY;
		}
	}

	*ppEnum = pEnum;

	return (pEnum != NULL) ? S_OK : CONNECT_E_NOCONNECTION;
}

//=--------------------------------------------------------------------------=
// IConnectionPointContainer FindConnectionPoint
//
HRESULT CVDNotifyDBEventsConnPtCont::FindConnectionPoint(REFIID iid, LPCONNECTIONPOINT FAR* ppCP)
{
	ASSERT_POINTER(ppCP, LPCONNECTIONPOINT)

	if (m_pNotifyDBEventsConnPt)
		{
		// there is only one connection point supported - IID_INotifyDBEvents
		if (DO_GUIDS_MATCH(iid, IID_INotifyDBEvents))
			{
			m_pNotifyDBEventsConnPt->AddRef();
			*ppCP = m_pNotifyDBEventsConnPt;
			return S_OK;
			}
		}

	return E_NOINTERFACE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\olebind.h ===
/*****************************************************************************\
*                                                                             *
* olebind.h     Data binding interfaces for OLE                               *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1994, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

#if !defined( _OLEBIND_H_ )
#define _OLEBIND_H_

#if !defined( INITGUID )
#include <olectlid.h>
#endif

DEFINE_GUID(IID_IBoundObject,
	0x9BFBBC00,0xEFF1,0x101A,0x84,0xED,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IBoundObjectSite,
	0x9BFBBC01,0xEFF1,0x101A,0x84,0xED,0x00,0xAA,0x00,0x34,0x1D,0x07);

typedef interface IBoundObject FAR* LPBOUNDOBJECT;
typedef interface ICursor FAR* LPCURSOR;

//#ifndef RUNTIME
typedef interface IBoundObjectSite FAR* LPBOUNDOBJECTSITE;
typedef interface ICursor FAR* FAR* LPLPCURSOR;
//#endif


//////////////////////////////////////////////////////////////////////////////
//
//  IBoundObject interface
//
//////////////////////////////////////////////////////////////////////////////

#undef  INTERFACE
#define INTERFACE IBoundObject

DECLARE_INTERFACE_(IBoundObject, IUnknown)
{
    //
    //  IUnknown methods
    //

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //
    //  IBoundObject methods
    //

	STDMETHOD(OnSourceChanged)(THIS_ DISPID dispid, BOOL fBound, BOOL FAR* lpfOwnXferOut) PURE;
	STDMETHOD(IsDirty)(THIS_ DISPID dispid) PURE;
};
//#ifndef RUNTIME
//////////////////////////////////////////////////////////////////////////////
//
//  IBoundObjectSite interface
//
//////////////////////////////////////////////////////////////////////////////

#undef  INTERFACE
#define INTERFACE IBoundObjectSite

DECLARE_INTERFACE_(IBoundObjectSite, IUnknown)
{
    //
    //  IUnknown methods
    //

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //
    //  IBoundObjectSite methods
    //

	STDMETHOD(GetCursor)(THIS_ DISPID dispid, LPLPCURSOR ppCursor, LPVOID FAR* ppcidOut) PURE;
};
//#endif //RUNTIME

#endif // !defined( _OLEBIND_H_ )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MSR2C.rc
//
#include "..\\MSR2CENU\\resource.h" // strings are kept in a separate project

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        132
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\rscolumn.cpp ===
//---------------------------------------------------------------------------
// RowsetColumn.cpp : RowsetColumn implementation
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"         
#include "RSColumn.h"         

SZTHISFILE


//=--------------------------------------------------------------------------=
// CVDRowsetColumn - Constructor
//
CVDRowsetColumn::CVDRowsetColumn()
{
    m_ulOrdinal             = 0;

    m_wType                 = 0;
    
    m_pwszBaseColumnName    = NULL;
    m_pwszBaseName          = NULL;      
    m_dwBindType            = 0;        
    m_lcidCollatingOrder    = 0;
    m_pwszDefaultValue      = NULL;  
    m_cbEntryIDMaxLength    = 0;
    m_cbMaxLength           = 0;       
    m_pwszName              = NULL;          
    m_dwNumber              = 0;          
    m_dwScale               = 0;           
    m_dwCursorType          = 0;
    m_dwUpdatable           = 0;      
    m_dwVersion             = 0;         
    m_dwStatus              = 0;          

    m_bool.fInitialized     = FALSE;   
    m_bool.fAutoIncrement   = FALSE; 
    m_bool.fCaseSensitive   = TRUE;
    m_bool.fDataColumn      = FALSE;
    m_bool.fFixed           = FALSE;
    m_bool.fHasDefault      = FALSE;
    m_bool.fMultiValued     = FALSE;
    m_bool.fNullable        = FALSE;
    m_bool.fSearchable      = FALSE;
    m_bool.fUnique          = FALSE;

    m_ulMaxStrLen           = 0;

    memset(&m_columnID, 0, sizeof(DBID));
    memset(&m_cursorColumnID, 0, sizeof(CURSOR_DBCOLUMNID));

#ifdef _DEBUG
    g_cVDRowsetColumnCreated++;
#endif         
}

//=--------------------------------------------------------------------------=
// ~CVDRowsetColumn - Destructor
//
CVDRowsetColumn::~CVDRowsetColumn()
{
    delete [] m_pwszBaseColumnName;
    delete [] m_pwszBaseName;
    delete [] m_pwszDefaultValue;
    delete [] m_pwszName;

    if (m_columnID.eKind == DBKIND_PGUID_NAME || m_columnID.eKind == DBKIND_PGUID_PROPID)
        delete m_columnID.uGuid.pguid;

    if (m_columnID.eKind == DBKIND_GUID_NAME || m_columnID.eKind == DBKIND_NAME || m_columnID.eKind == DBKIND_PGUID_NAME)
        delete [] m_columnID.uName.pwszName;

    if (m_cursorColumnID.dwKind == CURSOR_DBCOLKIND_GUID_NAME || m_cursorColumnID.dwKind == CURSOR_DBCOLKIND_NAME)
        delete [] m_cursorColumnID.lpdbsz;

#ifdef _DEBUG
    g_cVDRowsetColumnDestroyed++;
#endif         
}

//=--------------------------------------------------------------------------=
// Initialize - Initialize rowset column object from IRowset metadata (#1)
//=--------------------------------------------------------------------------=
// This function converts and stores IRowset metadata in ICursor format
//
// Parameters:
//    ulOrdinal         - [in] original IRowset ordinal of column
//    ulCursorOrdinal   - [in] newly assigned ICursor ordinal of column
//    pColumnInfo       - [in] a pointer to an IRowset DBCOLUMNINFO structure 
//                             where to retrieve metadata
//    cbMaxBookmark     - [in] maximum size of an IRowset bookmark
//    pBookmarkColumnID - [in] a pointer to bookmark column identifier if this
//                             is a bookmark column, otherwise NULL
//
// Output:
//    BOOL  - TRUE if successful
//
// Notes:
//    This function should only be called once
//
BOOL CVDRowsetColumn::Initialize(ULONG ulOrdinal, 
								 ULONG ulCursorOrdinal, 
								 DBCOLUMNINFO * pColumnInfo, 
								 ULONG cbMaxBookmark,
								 CURSOR_DBCOLUMNID * pBookmarkColumnID)
{
    if (m_bool.fInitialized)
	{
		ASSERT(FALSE, VD_ASSERTMSG_COLALREADYINITIALIZED)
		return FALSE;
	}

    m_ulOrdinal = ulOrdinal;

// Store IRowset metadata
    m_wType     = pColumnInfo->wType;
    m_columnID  = pColumnInfo->columnid;

    // make copy of guid if necessary
    if (m_columnID.eKind == DBKIND_PGUID_NAME || m_columnID.eKind == DBKIND_PGUID_PROPID)
    {
        m_columnID.uGuid.pguid = new GUID;

		if (!m_columnID.uGuid.pguid)
			return E_OUTOFMEMORY;

        memcpy(m_columnID.uGuid.pguid, pColumnInfo->columnid.uGuid.pguid, sizeof(GUID));
    }

    // make copy of name if necessary
    if (m_columnID.eKind == DBKIND_GUID_NAME || m_columnID.eKind == DBKIND_NAME || m_columnID.eKind == DBKIND_PGUID_NAME)
    {
        const int nLength = lstrlenW(pColumnInfo->columnid.uName.pwszName);

        m_columnID.uName.pwszName = new WCHAR[nLength + 1];

		if (!m_columnID.uName.pwszName)
			return E_OUTOFMEMORY;

        memcpy(m_columnID.uName.pwszName, pColumnInfo->columnid.uName.pwszName, (nLength + 1) * sizeof(WCHAR));
    }

// Store ICursor metadata
    if (pColumnInfo->dwFlags & DBCOLUMNFLAGS_MAYDEFER)
        m_dwBindType = CURSOR_DBBINDTYPE_BOTH;
    else
        m_dwBindType = CURSOR_DBBINDTYPE_DATA;

    if (!pBookmarkColumnID)
        m_cursorColumnID = ColumnIDToCursorColumnID(pColumnInfo->columnid, ulCursorOrdinal);
    else
        m_cursorColumnID = *pBookmarkColumnID;  // use supplied bookmark column identifier
    
    if (m_dwBindType == CURSOR_DBBINDTYPE_BOTH)
        m_cbEntryIDMaxLength = sizeof(ULONG) + sizeof(ULONG) + cbMaxBookmark;
    else
        m_cbEntryIDMaxLength = 0;

// rowset types DBTYPE_GUID and DBTYPE_DBTIMESTAMP are returned as CURSOR_DBTYPE_LPWSTRs

	if (pColumnInfo->wType == DBTYPE_GUID || pColumnInfo->wType == DBTYPE_DBTIMESTAMP)
	    m_cbMaxLength = 64;
	else
	    m_cbMaxLength = pColumnInfo->ulColumnSize;

    if (pColumnInfo->pwszName)
    {
        const int nLength = lstrlenW(pColumnInfo->pwszName);

        m_pwszName = new WCHAR[nLength + 1];

		if (!m_pwszName)
			return E_OUTOFMEMORY;

        memcpy(m_pwszName, pColumnInfo->pwszName, (nLength + 1) * sizeof(WCHAR));
    }

    m_dwNumber = ulCursorOrdinal;

    m_dwScale = pColumnInfo->bScale;

    m_dwCursorType = TypeToCursorType(pColumnInfo->wType);

    if (pColumnInfo->dwFlags & DBCOLUMNFLAGS_WRITE)
        m_dwUpdatable = CURSOR_DBUPDATEABLE_UPDATEABLE;

    if (!(pColumnInfo->dwFlags & DBCOLUMNFLAGS_ISBOOKMARK))
        m_bool.fDataColumn = TRUE;

    if (pColumnInfo->dwFlags & DBCOLUMNFLAGS_ISFIXEDLENGTH)
    {
        m_bool.fFixed = TRUE;
        m_ulMaxStrLen = GetCursorTypeMaxStrLen(m_dwCursorType, m_cbMaxLength);
    }

    if (pColumnInfo->dwFlags & DBCOLUMNFLAGS_MAYBENULL)
        m_bool.fNullable = TRUE;

    m_bool.fInitialized = TRUE;

    return TRUE;
}

//=--------------------------------------------------------------------------=
// Initialize - Initialize rowset column object from meta-metadata (#2)
//=--------------------------------------------------------------------------=
// The function stores ICursor meta-metadata
//
// Parameters:
//    cursorColumnID    - [in] ICursor column identifier
//    fDataColumn       - [in] is data column?
//    cbMaxLength       - [in] maximum length of this datatype
//    pszName           - [in] column name
//    dwCursorType      - [in] datatype
//    dwNumber          - [in] ordinal position
//
// Output:
//    BOOL  - TRUE if successful
//
// Notes:
//    This function should only be called once
//
BOOL CVDRowsetColumn::Initialize(const CURSOR_DBCOLUMNID * pCursorColumnID, 
								 BOOL fDataColumn, 
								 ULONG cbMaxLength, 
								 CHAR * pszName, 
								 DWORD dwCursorType,
								 DWORD dwNumber) 
{
    if (m_bool.fInitialized)
	{
		ASSERT(FALSE, VD_ASSERTMSG_COLALREADYINITIALIZED)
		return FALSE;
	}

// Store ICursor meta-metadata
    m_dwBindType = CURSOR_DBBINDTYPE_DATA;

    m_cursorColumnID = *pCursorColumnID;

    m_cbEntryIDMaxLength = 0;

    m_cbMaxLength = cbMaxLength;

    if (pszName)
    {
        MAKE_WIDEPTR_FROMANSI(pwszName, pszName);

        const int nLength = lstrlenW(pwszName);

        m_pwszName = new WCHAR[nLength + 1];

		if (!m_pwszName)
			return E_OUTOFMEMORY;

        memcpy(m_pwszName, pwszName, (nLength + 1) * sizeof(WCHAR));
    }

    m_dwNumber = dwNumber;

    m_dwScale = 0;

    m_dwCursorType = dwCursorType;

    m_dwUpdatable = CURSOR_DBUPDATEABLE_NOTUPDATEABLE;

    m_bool.fDataColumn  = fDataColumn;
    m_bool.fFixed       = TRUE;
    m_bool.fNullable    = FALSE;

    m_bool.fInitialized = TRUE;

    return TRUE;
}

//=--------------------------------------------------------------------------=
// SetStringProperty
//=--------------------------------------------------------------------------=
// The function is called from SetBaseColumnName, SetBaseName and SetDefaultValue
//
// Parameters:
//    ppStringProp	    - [in] A ptr to the ptr that holds the string value
//    pNewString	    - [in] A pointer to the new string value
//    ulLength			- [in] the length of the string in bytes
//
// Notes:
//

void CVDRowsetColumn::SetStringProperty(WCHAR ** ppStringProp,
										WCHAR * pNewString, 
										ULONG ulLength)
{
	// free old string prop if any
    delete [] *ppStringProp;

	// if ulLength = zero then just return
	if (!ulLength)
	{
		*ppStringProp = NULL;
		return;
	}

	ASSERT_POINTER_LEN(pNewString, ulLength);
	*ppStringProp = new WCHAR[ulLength + sizeof(WCHAR)];

	if (*ppStringProp)
	{
		// init null terminator
		(*ppStringProp)[ulLength] = 0;
		// copy string over
		memcpy(*ppStringProp, pNewString, ulLength);
	}
}

//=--------------------------------------------------------------------------=
// ColumnIDToCursorColumnID - Convert rowset column ID to cursor column ID
//=--------------------------------------------------------------------------=
// Converts an IRowset DBID structure into its ICursor DBCOLUMNID equivalent 
//
// Parameters:
//    columnID          - [in] the IRowset column identifier
//    ulCursorOrdinal   - [in] the column's ordinal position in ICursor
//
// Output:
//    CURSOR_DBCOLUMNID - The ICursor CURSOR_DBCOLUMNID equivalent of columnID
//
// Notes:
//

CURSOR_DBCOLUMNID CVDRowsetColumn::ColumnIDToCursorColumnID(const DBID& columnID, ULONG ulCursorOrdinal)
{ 
    CURSOR_DBCOLUMNID cursorColumnID;

    GUID guidNumberOnly = CURSOR_GUID_NUMBERONLY;

    cursorColumnID.guid     = guidNumberOnly;
    cursorColumnID.dwKind   = CURSOR_DBCOLKIND_GUID_NUMBER;
    cursorColumnID.lNumber  = ulCursorOrdinal;

    return cursorColumnID;

// The following code is the old implementation of this function.  It caused problems with some
// cursor consumers because it tried to create a cursor column identifier as close as possible 
// to the rowset column identifier, thus utilized the problematic lpdbsz member.

/*
    CURSOR_DBCOLUMNID ID;

    switch (columnID.eKind)
    {
	    case DBKIND_GUID_NAME:
            ID.guid         = columnID.uGuid.guid;
            ID.dwKind       = CURSOR_DBCOLKIND_GUID_NAME;
            ID.lpdbsz       = columnID.uName.pwszName;
            break;

	    case DBKIND_GUID_PROPID:
            ID.guid         = columnID.uGuid.guid;
            ID.dwKind       = CURSOR_DBCOLKIND_GUID_NUMBER;
            ID.lNumber      = ulCursorOrdinal;
            break;
            
	    case DBKIND_NAME:
            ID.dwKind       = CURSOR_DBCOLKIND_NAME;
            ID.lpdbsz       = columnID.uName.pwszName;
            break;

	    case DBKIND_PGUID_NAME:
            ID.guid         = *columnID.uGuid.pguid;
            ID.dwKind       = CURSOR_DBCOLKIND_GUID_NAME;
            ID.lpdbsz       = columnID.uName.pwszName;
            break;

	    case DBKIND_PGUID_PROPID:
            ID.guid         = *columnID.uGuid.pguid;
            ID.dwKind       = CURSOR_DBCOLKIND_GUID_NUMBER;
            ID.lNumber      = ulCursorOrdinal;
            break;

	    case DBKIND_GUID:
            ID.guid         = columnID.uGuid.guid;
            ID.dwKind       = CURSOR_DBCOLKIND_GUID_NUMBER;
            ID.lNumber      = ulCursorOrdinal;
            break;

	    case DBKIND_PROPID:
            memset(&ID.guid, 0, sizeof(GUID));  // encode ordinal in guid
            ID.guid.Data1   = ulCursorOrdinal;
            ID.dwKind       = CURSOR_DBCOLKIND_GUID_NUMBER;
            ID.lNumber      = ulCursorOrdinal;
            break;
    }

    // make copy of name if necessary
    if (ID.dwKind == CURSOR_DBCOLKIND_GUID_NAME || ID.dwKind == CURSOR_DBCOLKIND_NAME)
    {
        const int nLength = lstrlenW(columnID.uName.pwszName);

        ID.lpdbsz = new WCHAR[nLength + 1];

		if (ID.lpdbsz)
			memcpy(ID.lpdbsz, columnID.uName.pwszName, (nLength + 1) * sizeof(WCHAR));
    }

    return ID;
*/
}

//=--------------------------------------------------------------------------=
// TypeToCursorType - Convert rowset datatype to cursor datatype
//=--------------------------------------------------------------------------=
// Converts a IRowset DBTYPE value into its ICursor DBVARENUM equivalent 
//
// Parameters:
//    wType     - [in] the IRowset datatype
//
// Output:
//    CURSOR_DBVARENUM - The ICursor DBVARENUM equivalent of DBTYPE
//
// Notes:
//
CURSOR_DBVARENUM CVDRowsetColumn::TypeToCursorType(DBTYPE wType)
{
    DWORD dwType = 0;

    switch (wType)
    {
        case DBTYPE_ERROR:
            dwType = CURSOR_DBTYPE_HRESULT;
            break;

        case DBTYPE_VARIANT:
            dwType = CURSOR_DBTYPE_ANYVARIANT;
            break;

        case DBTYPE_UI2:
            dwType = CURSOR_DBTYPE_UI2;
            break;

        case DBTYPE_UI4:
            dwType = CURSOR_DBTYPE_UI4;
            break;

        case DBTYPE_UI8:
            dwType = CURSOR_DBTYPE_UI8;
            break;

        case DBTYPE_BYTES:
            dwType = CURSOR_DBTYPE_BLOB;
            break;

        case DBTYPE_STR:
            dwType = VT_BSTR;
            break;

        case DBTYPE_WSTR:
            dwType = CURSOR_DBTYPE_LPWSTR;
            break;

        case DBTYPE_NUMERIC:
            dwType = CURSOR_DBTYPE_R8;
            break;

        //case DBTYPE_HCHAPTER:             <- doesn't exist in new spec
        //    break;  // no equivalent

        case DBTYPE_UDT:
            break;  // no equivalent

        case DBTYPE_DBDATE:
            dwType = CURSOR_DBTYPE_DATE;
            break;

        case DBTYPE_DBTIME:
            dwType = CURSOR_DBTYPE_DATE;
            break;

// rowset types DBTYPE_GUID and DBTYPE_DBTIMESTAMP are returned as CURSOR_DBTYPE_LPWSTRs

		case DBTYPE_GUID:
        case DBTYPE_DBTIMESTAMP:
            dwType = CURSOR_DBTYPE_LPWSTR;
            break;

        default:
            dwType = wType;
    }

    return (CURSOR_DBVARENUM)dwType;
}

//=--------------------------------------------------------------------------=
// CursorTypeToType - Convert cursor datatype to rowset datatype
//=--------------------------------------------------------------------------=
// Converts a ICursor DBVARENUM value into its IRowset DBTYPE equivalent 
//
// Parameters:
//    CURSOR_DBVARENUM - [in] the ICursor value
//
// Output:
//    DBTYPE - The IRowset DBTYPE equivalent of DBVARENUM
//
// Notes:
//
DBTYPE CVDRowsetColumn::CursorTypeToType(CURSOR_DBVARENUM dwCursorType)
{
    DBTYPE wType = 0;
    
    switch (dwCursorType)
    {
        case CURSOR_DBTYPE_HRESULT:
            wType = DBTYPE_ERROR;
            break;
        
        case CURSOR_DBTYPE_LPSTR:
            wType = DBTYPE_STR;
            break;
        
        case CURSOR_DBTYPE_LPWSTR:
            wType = DBTYPE_WSTR;
            break;
        
        case CURSOR_DBTYPE_FILETIME:
            wType = DBTYPE_DBTIMESTAMP;
            break;
        
        case CURSOR_DBTYPE_BLOB:
			wType = DBTYPE_BYTES;
            break;
        
        case CURSOR_DBTYPE_DBEXPR:
            break;  // no equivalent
        
        case CURSOR_DBTYPE_UI2:
            wType = DBTYPE_UI2;
            break;
        
        case CURSOR_DBTYPE_UI4:
            wType = DBTYPE_UI4;
            break;
        
        case CURSOR_DBTYPE_UI8:
            wType = DBTYPE_UI8;
            break;
        
        case CURSOR_DBTYPE_COLUMNID:
			wType = DBTYPE_GUID;
            break;  
        
        case CURSOR_DBTYPE_BYTES:
            wType = DBTYPE_BYTES;
            break;
        
        case CURSOR_DBTYPE_CHARS:
			wType = DBTYPE_STR;
            break;  
        
        case CURSOR_DBTYPE_WCHARS:
			wType = DBTYPE_WSTR;
            break;
        
        case CURSOR_DBTYPE_ANYVARIANT:
            wType = DBTYPE_VARIANT;
            break;

        default:
            wType = (WORD)dwCursorType;
    }

    return wType; 
}

//=--------------------------------------------------------------------------=
// GetCursorTypeMaxStrLen - Get the buffer size in characters required by 
//                          cursor data type when represented as a string
//                          (doesn't include NULL terminator)
//
// Notes:
//
//  The way these values where computed is as follows:
//
//	  (1) the maximum precision for each datatype was taken from "Precision of Numeric Data Types" in
//        appendix A of the "OLE DB Programmer's Reference, Volume 2".
//    (2) the precision was then divided by two and added to the original precision to allow space for 
//	  	  numberic symbols, like negative signs, dollar signs, commas, etc., that might be present.
//    (3) the sum was then doubled to allow for multibyte character sets.
//
//	Since this table is not appropriate for floating point datatypes, their values where computed based 
//  on the string length of the minimum/maximum possible values for these datatypes, then doubled.
//
//    datatype       minimum value			  maximum value		length
//	  --------	     -------------		      -------------		------
//	   float        1.175494351e-38		     3.402823466e+38	  15
//	   double   2.2250738585072014e-308  1.7976931348623158e+308  23
//
ULONG CVDRowsetColumn::GetCursorTypeMaxStrLen(DWORD dwCursorType, ULONG cbMaxLength)
{
    ULONG ulMaxStrLen = cbMaxLength;    // default for fixed length strings

    switch (dwCursorType)
    {
        case VT_I1:
            ulMaxStrLen = (3 + 1) * 2;
            break;

        case CURSOR_DBTYPE_I2:
            ulMaxStrLen = (5 + 2) * 2;
            break;

        case CURSOR_DBTYPE_I4:
            ulMaxStrLen = (10 + 5) * 2;
            break;

        case CURSOR_DBTYPE_I8:
            ulMaxStrLen = (19 + 9) * 2;
            break;

        case CURSOR_DBTYPE_R4:
            ulMaxStrLen = (15) * 2;
            break;

        case CURSOR_DBTYPE_R8:
            ulMaxStrLen = (23) * 2;
            break;

        case CURSOR_DBTYPE_CY:
            ulMaxStrLen = (19 + 9) * 2;
            break;

        case CURSOR_DBTYPE_DATE:
            ulMaxStrLen = (32 + 16) * 2;
            break;

        case CURSOR_DBTYPE_FILETIME:
            ulMaxStrLen = (32 + 16) * 2;
            break;

        case CURSOR_DBTYPE_BOOL:
            ulMaxStrLen = (5 + 2) * 2;
            break;

        case VT_UI1:
            ulMaxStrLen = (3 + 1) * 2;
            break;

        case CURSOR_DBTYPE_UI2:
            ulMaxStrLen = (5 + 2) * 2;
            break;

        case CURSOR_DBTYPE_UI4:
            ulMaxStrLen = (10 + 5) * 2;
            break;

        case CURSOR_DBTYPE_UI8:
            ulMaxStrLen = (20 + 10) * 2;
            break;
    }

    return ulMaxStrLen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\rssource.cpp ===
//---------------------------------------------------------------------------
// RowsetSource.cpp : RowsetSource implementation
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"         
#include "Notifier.h"         
#include "RSSource.h"         
#include "MSR2C.h"         

SZTHISFILE

//=--------------------------------------------------------------------------=
// CVDRowsetSource - Constructor
//
CVDRowsetSource::CVDRowsetSource()
{
	m_bool.fRowsetReleased	= FALSE;
    m_bool.fInitialized		= FALSE;

    m_pRowset				= NULL;
    m_pAccessor				= NULL;
    m_pRowsetLocate			= NULL;
    m_pRowsetScroll			= NULL;
    m_pRowsetChange			= NULL;
    m_pRowsetUpdate			= NULL;
    m_pRowsetFind			= NULL;
	m_pRowsetInfo			= NULL;
	m_pRowsetIdentity		= NULL;

#ifdef _DEBUG
    g_cVDRowsetSourceCreated++;
#endif         
}

//=--------------------------------------------------------------------------=
// ~CVDRowsetSource - Destructor
//
CVDRowsetSource::~CVDRowsetSource()
{
    if (IsRowsetValid())
    {
        RELEASE_OBJECT(m_pAccessor)
        RELEASE_OBJECT(m_pRowsetLocate)
        RELEASE_OBJECT(m_pRowsetScroll)
        RELEASE_OBJECT(m_pRowsetChange)
        RELEASE_OBJECT(m_pRowsetUpdate)
        RELEASE_OBJECT(m_pRowsetFind)
        RELEASE_OBJECT(m_pRowsetInfo)
        RELEASE_OBJECT(m_pRowsetIdentity)
        
        m_pRowset->Release();
    }

#ifdef _DEBUG
    g_cVDRowsetSourceDestroyed++;
#endif         
}

//=--------------------------------------------------------------------------=
// Initialize - Initialize rowset source object
//=--------------------------------------------------------------------------=
// This function QI's and store the IRowset pointers
//
// Parameters:
//    pRowset   - [in] original IRowset pointer
//
// Output:
//    HRESULT   - S_OK if successful
//                E_INVALIDARG bad parameter
//                E_FAIL if already initialized
//                VD_E_CANNOTGETMANDATORYINTERFACE unable to get required interface  
//
// Notes:
//    This function should only be called once
//
HRESULT CVDRowsetSource::Initialize(IRowset * pRowset)
{
    ASSERT_POINTER(pRowset, IRowset)

    if (!pRowset)
        return E_INVALIDARG;
        
    if (m_bool.fInitialized)
	{
		ASSERT(FALSE, VD_ASSERTMSG_ROWSRCALREADYINITIALIZED)
		return E_FAIL;
	}
    
    // mandatory interfaces (IAccessor is required for us)
    HRESULT hr = pRowset->QueryInterface(IID_IAccessor, (void**)&m_pAccessor);

    if (FAILED(hr))
        return VD_E_CANNOTGETMANDATORYINTERFACE;

    // mandatory interfaces (IRowsetLocate is required for us)
    hr = pRowset->QueryInterface(IID_IRowsetLocate, (void**)&m_pRowsetLocate);

    if (FAILED(hr))
    {
        m_pAccessor->Release();
        m_pAccessor = NULL;

        return VD_E_CANNOTGETMANDATORYINTERFACE;
    }

    // optional interfaces
    pRowset->QueryInterface(IID_IRowsetScroll, (void**)&m_pRowsetScroll);
    pRowset->QueryInterface(IID_IRowsetChange, (void**)&m_pRowsetChange);
    pRowset->QueryInterface(IID_IRowsetUpdate, (void**)&m_pRowsetUpdate);
    pRowset->QueryInterface(IID_IRowsetFind, (void**)&m_pRowsetFind);
    pRowset->QueryInterface(IID_IRowsetInfo, (void**)&m_pRowsetInfo);
    pRowset->QueryInterface(IID_IRowsetIdentity, (void**)&m_pRowsetIdentity);

    m_pRowset = pRowset;
    m_pRowset->AddRef();

    m_bool.fInitialized = TRUE;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\rscolumn.h ===
//---------------------------------------------------------------------------
// RowsetColumn.h : CVDRowsetColumn header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------


#ifndef __CVDROWSETCOLUMN__
#define __CVDROWSETCOLUMN__

#define VD_COLUMNSROWSET_MAX_OPT_COLUMNS 8

class CVDRowsetColumn
{
public:
// Construction/Destruction
	CVDRowsetColumn();
	virtual ~CVDRowsetColumn();

// Initialization
    BOOL Initialize(ULONG ulOrdinal, 
					ULONG ulCursorOrdinal, 
					DBCOLUMNINFO * pColumnInfo, 
					ULONG cbMaxBookmark,
					CURSOR_DBCOLUMNID * pBookmarkColumnID = NULL);
    
// Initialization of metadata metadata columns
	BOOL Initialize(const CURSOR_DBCOLUMNID * pCursorColumnID, 
					BOOL fDataColumn, 
					ULONG cbMaxLength, 
					CHAR * pszName, 
			        DWORD dwCursorType,
					DWORD dwNumber); 

// Position
    ULONG GetOrdinal() const {return m_ulOrdinal;}

// IRowset metadata
    DBID GetColumnID() const {return m_columnID;}
    DBTYPE GetType() const {return (DBTYPE)m_wType;}

// ICursor metadata
    BOOL GetAutoIncrement() const {return m_bool.fAutoIncrement;}
    void SetAutoIncrement(VARIANT_BOOL fAutoIncrement) {m_bool.fAutoIncrement = fAutoIncrement;}

    WCHAR * GetBaseColumnName() const {return m_pwszBaseColumnName;}
    void SetBaseColumnName(WCHAR * pBaseColumnName, ULONG ulLength)
				{ SetStringProperty(&m_pwszBaseColumnName, pBaseColumnName, ulLength); }

    WCHAR * GetBaseName() const {return m_pwszBaseName;}
    void SetBaseName(WCHAR * pBaseName, ULONG ulLength) 
				{ SetStringProperty(&m_pwszBaseName, pBaseName, ulLength); }

    DWORD GetBindType() const {return m_dwBindType;}

    BOOL GetCaseSensitive() const {return m_bool.fCaseSensitive;}
    void SetCaseSensitive(VARIANT_BOOL fCaseSensitive) {m_bool.fCaseSensitive = fCaseSensitive;}

    LCID GetCollatingOrder() const {return m_lcidCollatingOrder;}
    void SetCollatingOrder(LCID lcidCollatingOrder) {m_lcidCollatingOrder = lcidCollatingOrder;}

    CURSOR_DBCOLUMNID GetCursorColumnID() const {return m_cursorColumnID;}
    BOOL GetDataColumn() const {return m_bool.fDataColumn;}

    WCHAR * GetDefaultValue() const {return m_pwszDefaultValue;}
    void SetDefaultValue(WCHAR * pDefaultValue, ULONG ulLength)
				{ SetStringProperty(&m_pwszDefaultValue, pDefaultValue, ulLength); }

    ULONG GetEntryIDMaxLength() const {return m_cbEntryIDMaxLength;}
    BOOL GetFixed() const {return m_bool.fFixed;}

    BOOL GetHasDefault() const {return m_bool.fHasDefault;}
    void SetHasDefault(VARIANT_BOOL fHasDefault) {m_bool.fHasDefault = fHasDefault;}
    
	ULONG GetMaxLength() const {return m_cbMaxLength;}
    BOOL GetMultiValued() const {return m_bool.fMultiValued;}
    WCHAR * GetName() const {return m_pwszName;}
    BOOL GetNullable() const {return m_bool.fNullable;}
    DWORD GetNumber() const {return m_dwNumber;}
    DWORD GetScale() const {return m_dwScale;}
    BOOL GetSearchable() const {return m_bool.fSearchable;}
    DWORD GetCursorType() const {return m_dwCursorType;}
    
	BOOL GetUnique() const {return m_bool.fUnique;}
    void SetUnique(VARIANT_BOOL fUnique) {m_bool.fUnique = fUnique;}
    
	DWORD GetUpdatable() const {return m_dwUpdatable;}
    DWORD GetVersion() const {return m_dwVersion;}
    DWORD GetStatus() const {return m_dwStatus;}

// Fetching
    DWORD GetMaxStrLen() const {return m_ulMaxStrLen;}
    
public:
// Conversions
    static CURSOR_DBCOLUMNID ColumnIDToCursorColumnID(const DBID& columnID, ULONG ulCursorOrdinal);
    static CURSOR_DBVARENUM TypeToCursorType(DBTYPE wType);
    static DBTYPE CursorTypeToType(CURSOR_DBVARENUM dwCursorType);

// Fetching
    static ULONG GetCursorTypeMaxStrLen(DWORD dwCursorType, ULONG cbMaxLength);

protected:

	void SetStringProperty(WCHAR ** ppStringProp,
						   WCHAR * pNewString, 
						   ULONG ulLength);
// Position
    ULONG               m_ulOrdinal;            // IRowset ordinal position

// IRowset metadata
    DBID                m_columnID;             // column identifier
    DWORD               m_wType;                // datatype
    
// ICursor metadata
    WCHAR *             m_pwszBaseColumnName;   // base column name
    WCHAR *             m_pwszBaseName;         // base name
    DWORD               m_dwBindType;           // bind type
    LCID                m_lcidCollatingOrder;   // collating order
    CURSOR_DBCOLUMNID   m_cursorColumnID;       // column identifier
    WCHAR *             m_pwszDefaultValue;     // default value
    ULONG               m_cbEntryIDMaxLength;   // entryID maximum length
    ULONG               m_cbMaxLength;          // data maximum length
    WCHAR *             m_pwszName;             // name
    DWORD               m_dwNumber;             // number
    DWORD               m_dwScale;              // scale
    DWORD               m_dwCursorType;         // datatype
    DWORD               m_dwUpdatable;          // updateablity
    DWORD               m_dwVersion;            // version
    DWORD               m_dwStatus;             // status

// Booleans
    struct
    {
        WORD fInitialized       : 1;            // is column initialized?
        WORD fAutoIncrement     : 1;            // auto increment?
        WORD fCaseSensitive     : 1;            // case sensitive?
        WORD fDataColumn        : 1;            // data column?
        WORD fFixed             : 1;            // fixed length?
        WORD fHasDefault        : 1;            // has default value?
        WORD fMultiValued       : 1;            // multivalued?
        WORD fNullable          : 1;            // accepts NULLs?
        WORD fSearchable        : 1;            // searchable?
        WORD fUnique            : 1;            // unique?
    } m_bool;

// Fetching
    DWORD m_ulMaxStrLen;    // maximum string length for fixed data types
};


#endif //__CVDROWSETCOLUMN__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\oledbtyp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1994.
//
//  File:       oledbtyp.h
//
//  Contents:   Necessary type definitions for OLD-DB interfaces
//
//  Notes:	This file works around the fact that not everyone yet
//		has oleaut.h.
//		We just conditionally include the right type definitions
//		for whatever platform we're running on.
//
//  History:    25 Aug 94   Alanw	Created
//
//+---------------------------------------------------------------------------

#if !defined( _tagVARIANT_DEFINED )
//#include <oleaut.h>
#endif //!defined( _tagVARIANT_DEFINED )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\rssource.h ===
//---------------------------------------------------------------------------
// RowsetSource.h : CVDRowsetSource header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------


#ifndef __CVDROWSETSOURCE__
#define __CVDROWSETSOURCE__

class CVDNotifyDBEventsConnPtCont;

class CVDRowsetSource : public CVDNotifier
{
protected:
// Construction/Destruction
    CVDRowsetSource();
	virtual ~CVDRowsetSource();

// Initialization
    HRESULT Initialize(IRowset * pRowset);

public:
	BOOL IsRowsetValid(){return (m_pRowset && !m_bool.fRowsetReleased);}

	void SetRowsetReleasedFlag(){m_bool.fRowsetReleased = TRUE;}

    IRowset *           GetRowset() const {return m_pRowset;}     
    IAccessor *         GetAccessor() const {return m_pAccessor;}
    IRowsetLocate *     GetRowsetLocate() const {return m_pRowsetLocate;}
    IRowsetScroll *     GetRowsetScroll() const {return m_pRowsetScroll;}
    IRowsetChange *     GetRowsetChange() const {return m_pRowsetChange;}
    IRowsetUpdate *     GetRowsetUpdate() const {return m_pRowsetUpdate;}
    IRowsetFind *       GetRowsetFind() const {return m_pRowsetFind;}
    IRowsetInfo *       GetRowsetInfo() const {return m_pRowsetInfo;}
    IRowsetIdentity *   GetRowsetIdentity() const {return m_pRowsetIdentity;}

protected:
// Data members

    struct 
    {
		WORD fInitialized		    : 1;    // is rowset source initialized?
        WORD fRowsetReleased	    : 1;    // have we received a rowset release notification
    } m_bool;

    IRowset *       m_pRowset;          // [mandatory] interface IRowset
    IAccessor *     m_pAccessor;        // [mandatory] interface IAccessor
    IRowsetLocate * m_pRowsetLocate;    // [mandatory] interface IRowsetLocate
    IRowsetScroll * m_pRowsetScroll;    // [optional]  interface IRowsetScroll
    IRowsetChange * m_pRowsetChange;    // [optional]  interface IRowsetChange
    IRowsetUpdate * m_pRowsetUpdate;    // [optional]  interface IRowsetUpdate
    IRowsetFind *   m_pRowsetFind;      // [optional]  interface IRowsetFind
    IRowsetInfo *   m_pRowsetInfo;      // [optional]  interface IRowsetInfo
    IRowsetIdentity * m_pRowsetIdentity;// [optional]  interface IRowsetIdentity
};


#endif //__CVDROWSETSOURCE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\stdafx.cpp ===
//---------------------------------------------------------------------------
// Stdafx.cpp : Source file that includes just the standard includes
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\timeconv.h ===
//---------------------------------------------------------------------------
// TimeConv.h : Date time conversion routines
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#ifndef __TIMECONV_H__
#define __TIMECONV_H__

//-----------------------------------------------------------------------
// The following routines convert between differnt data/time formats
// they return TRUE if successful otherwise they return FALSE
//-----------------------------------------------------------------------

BOOL VDConvertToFileTime(DBTIMESTAMP * pDBTimeStamp, FILETIME *	pFileTime);
BOOL VDConvertToFileTime(DBDATE * pDBDate, FILETIME *	pFileTime);
BOOL VDConvertToFileTime(DATE * pDate, FILETIME * pFileTime);
BOOL VDConvertToFileTime(DBTIME * pDBTime, FILETIME * pFileTime);

BOOL VDConvertToDBTimeStamp(FILETIME *	pFileTime, DBTIMESTAMP * pDBTimeStamp);
BOOL VDConvertToDBTimeStamp(DATE * pDate, DBTIMESTAMP * pDBTimeStamp);

BOOL VDConvertToDBDate(FILETIME * pFileTime, DBDATE * pDBDate);
BOOL VDConvertToDBDate(DATE * pDate, DBDATE * pDBDate);

BOOL VDConvertToDBTime(FILETIME * pFileTime, DBTIME * pDBTime);
BOOL VDConvertToDBTime(DATE * pDate, DBTIME * pDBTime);

BOOL VDConvertToDate(FILETIME * pFileTime, DATE * pDate);
BOOL VDConvertToDate(DBTIMESTAMP * pDBTimeStamp, DATE * pDate);
BOOL VDConvertToDate(DBTIME * pDBTime, DATE * pDate);
BOOL VDConvertToDate(DBDATE * pDBDate, DATE * pDate);

#endif //__TIMECONV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\stream.cpp ===
//---------------------------------------------------------------------------
// Stream.cpp : Stream implementation
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"         

#ifndef VD_DONT_IMPLEMENT_ISTREAM

#include "Notifier.h"        
#include "RSColumn.h"
#include "RSSource.h"
#include "CursMain.h"        
#include "ColUpdat.h"
#include "CursPos.h"        
#include "EntryID.h"         
#include "fastguid.h"      
#include "Stream.h" 
#include "resource.h"         

SZTHISFILE

static const GUID IID_IStreamEx = {0xf74e27fc, 0x5a3, 0x11d0, {0x91, 0x95, 0x0, 0xa0, 0x24, 0x7b, 0x73, 0x5b}};


//=--------------------------------------------------------------------------=
// CVDStream - Constructor
//
CVDStream::CVDStream()
{
    m_dwRefCount    = 1;
    m_pEntryIDData  = NULL;
    m_pStream       = NULL;
	m_pResourceDLL  = NULL;

#ifdef _DEBUG
    g_cVDStreamCreated++;
#endif         
}

//=--------------------------------------------------------------------------=
// ~CVDStream - Destructor
//
CVDStream::~CVDStream()
{
    m_pEntryIDData->Release();

    if (m_pStream)
        m_pStream->Release();

#ifdef _DEBUG
    g_cVDStreamDestroyed++;
#endif         
}

//=--------------------------------------------------------------------------=
// Create - Create stream object
//=--------------------------------------------------------------------------=
// This function creates and initializes a new stream object
//
// Parameters:
//    pEntryIDData      - [in]  backwards pointer to CVDEntryIDData object
//    pStream           - [in]  data stream pointer
//    ppVDStream        - [out] a pointer in which to return pointer to 
//                              viaduct stream object
//    pResourceDLL      - [in]  a pointer which keeps track of resource DLL
//
// Output:
//    HRESULT - S_OK if successful
//              E_OUTOFMEMORY not enough memory to create object
//
// Notes:
//
HRESULT CVDStream::Create(CVDEntryIDData * pEntryIDData, IStream * pStream, CVDStream ** ppVDStream, 
    CVDResourceDLL * pResourceDLL)
{
    ASSERT_POINTER(pEntryIDData, CVDEntryIDData)
    ASSERT_POINTER(pStream, IStream*)
    ASSERT_POINTER(ppVDStream, CVDStream*)

    if (!pStream || !ppVDStream)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_IEntryID, pResourceDLL);
        return E_INVALIDARG;
    }

    *ppVDStream = NULL;

    CVDStream * pVDStream = new CVDStream();

    if (!pStream)
    {
        VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_IEntryID, pResourceDLL);
        return E_OUTOFMEMORY;
    }

    pEntryIDData->AddRef();
    pStream->AddRef();

    pVDStream->m_pEntryIDData   = pEntryIDData;
    pVDStream->m_pStream        = pStream;
    pVDStream->m_pResourceDLL   = pResourceDLL;

    *ppVDStream = pVDStream;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// IUnknown Methods
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// IUnknown QueryInterface
//
HRESULT CVDStream::QueryInterface(REFIID riid, void **ppvObjOut)
{
    ASSERT_POINTER(ppvObjOut, IUnknown*)

    if (!ppvObjOut)
        return E_INVALIDARG;

    *ppvObjOut = NULL;

    switch (riid.Data1) 
    {
        QI_INTERFACE_SUPPORTED(this, IUnknown);
        QI_INTERFACE_SUPPORTED(this, IStream);
        QI_INTERFACE_SUPPORTED(this, IStreamEx);
    }                   

    if (NULL == *ppvObjOut)
        return E_NOINTERFACE;

    AddRef();

    return S_OK;
}

//=--------------------------------------------------------------------------=
// IUnknown AddRef
//
ULONG CVDStream::AddRef(void)
{
   return ++m_dwRefCount;
}

//=--------------------------------------------------------------------------=
// IUnknown Release
//
ULONG CVDStream::Release(void)
{
   if (1 > --m_dwRefCount)
   {
      delete this;
      return 0;
   }

   return m_dwRefCount;
}

//=--------------------------------------------------------------------------=
// IStream Methods
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// IStream Read
//
HRESULT CVDStream::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
	return m_pStream->Read(pv, cb, pcbRead);
}

//=--------------------------------------------------------------------------=
// IStream Write
//
HRESULT CVDStream::Write(const void *pv, ULONG cb, ULONG *pcbWritten)
{
	HRESULT hr = m_pStream->Write(pv, cb, pcbWritten);

    if (SUCCEEDED(hr))
        m_pEntryIDData->SetDirty(TRUE);

    return hr;
}

//=--------------------------------------------------------------------------=
// IStream Seek
//
HRESULT CVDStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
    return m_pStream->Seek(dlibMove, dwOrigin, plibNewPosition);
}

//=--------------------------------------------------------------------------=
// IStream SetSize
//
HRESULT CVDStream::SetSize(ULARGE_INTEGER libNewSize)
{
    return m_pStream->SetSize(libNewSize);
}

//=--------------------------------------------------------------------------=
// IStream CopyTo
//
HRESULT CVDStream::CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
{
    IStreamEx * pStreamEx;

    HRESULT hr = pstm->QueryInterface(IID_IStreamEx, (void**)&pStreamEx);

    if (SUCCEEDED(hr))
    {
        hr = pStreamEx->CopyFrom(m_pStream, cb, pcbWritten, pcbRead);
        pStreamEx->Release();
    }
    else
        hr = m_pStream->CopyTo(pstm, cb, pcbRead, pcbWritten);

    return hr;
}

//=--------------------------------------------------------------------------=
// IStream Commit
//
HRESULT CVDStream::Commit(DWORD grfCommitFlags)
{
    return m_pEntryIDData->Commit();
}

//=--------------------------------------------------------------------------=
// IStream Revert
//
HRESULT CVDStream::Revert(void)
{
    return m_pStream->Revert();
}

//=--------------------------------------------------------------------------=
// IStream LockRegion
//
HRESULT CVDStream::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return m_pStream->LockRegion(libOffset, cb, dwLockType);
}

//=--------------------------------------------------------------------------=
// IStream UnlockRegion
//
HRESULT CVDStream::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return m_pStream->UnlockRegion(libOffset, cb, dwLockType);
}

//=--------------------------------------------------------------------------=
// IStream Stat
//
HRESULT CVDStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    return m_pStream->Stat(pstatstg, grfStatFlag);
}

//=--------------------------------------------------------------------------=
// IStream Clone
//
HRESULT CVDStream::Clone(IStream **ppstm)
{
    ASSERT_POINTER(ppstm, IStream*)

    // check pointer
    if (!ppstm)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_IEntryID, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // init out parameter
    *ppstm = NULL;

    IStream * pStream;

    // clone stream
    HRESULT hr = m_pStream->Clone(&pStream);

    if (FAILED(hr))
    {
        VDSetErrorInfo(IDS_ERR_CLONEFAILED, IID_IEntryID, m_pResourceDLL);
        return hr;
    }

    CVDStream * pVDStream;

    // create viaduct stream object
    hr = CVDStream::Create(m_pEntryIDData, pStream, &pVDStream, m_pResourceDLL);

    // release reference on clone
    pStream->Release();

    if (FAILED(hr))
        return hr;

    *ppstm = pVDStream;

	return S_OK;
}

//=--------------------------------------------------------------------------=
// IStreamEx CopyFrom
//
HRESULT CVDStream::CopyFrom(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbWritten, ULARGE_INTEGER *pcbRead)
{
    HRESULT hr = pstm->CopyTo(m_pStream, cb, pcbRead, pcbWritten);

    if (SUCCEEDED(hr))
        m_pEntryIDData->SetDirty(TRUE);

    return hr;
}


#endif //VD_DONT_IMPLEMENT_ISTREAM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\stdafx.h ===
//---------------------------------------------------------------------------
// Stdafx.h : Include file for standard system include files
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "ipserver.h"       // Inprocess server header

#include "ARRAY_P.h"

#include "ocdb.h"           // OLE controls data bindings interfaces
#include "ocdbid.h"

#define OLEDBVER 0x0200

#include "oledb.h"          // OLE DB interfaces
#include "oledberr.h"

#include "util.h"           // useful utilities
#include "ErrorInf.h"       // for format error messages

#define VD_DLL_PREFIX		"MSR2C"

#define VD_INCLUDE_ROWPOSITION

//=--------------------------------------------------------------------------=
// object construction/destruction counters (debug only)
//
#ifdef _DEBUG
extern int g_cVDNotifierCreated;                    // CVDNotifier
extern int g_cVDNotifierDestroyed;
extern int g_cVDNotifyDBEventsConnPtCreated;        // CVDNotifyDBEventsConnPt
extern int g_cVDNotifyDBEventsConnPtDestroyed;
extern int g_cVDNotifyDBEventsConnPtContCreated;    // CVDNotifyDBEventsConnPtCont
extern int g_cVDNotifyDBEventsConnPtContDestroyed;
extern int g_cVDEnumConnPointsCreated;              // CVDEnumConnPoints
extern int g_cVDEnumConnPointsDestroyed;
extern int g_cVDRowsetColumnCreated;                // CVDRowsetColumn
extern int g_cVDRowsetColumnDestroyed;
extern int g_cVDRowsetSourceCreated;                // CVDRowsetSource
extern int g_cVDRowsetSourceDestroyed;
extern int g_cVDCursorMainCreated;                  // CVDCursorMain
extern int g_cVDCursorMainDestroyed;
extern int g_cVDCursorPositionCreated;              // CVDCursorPosition
extern int g_cVDCursorPositionDestroyed;
extern int g_cVDCursorBaseCreated;                  // CVDCursorBase
extern int g_cVDCursorBaseDestroyed;
extern int g_cVDCursorCreated;                      // CVDCursor
extern int g_cVDCursorDestroyed;
extern int g_cVDMetadataCursorCreated;              // CVDMetadataCursor
extern int g_cVDMetadataCursorDestroyed;
extern int g_cVDEntryIDDataCreated;                 // CVDEntryIDData
extern int g_cVDEntryIDDataDestroyed;
extern int g_cVDStreamCreated;                      // CVDStream
extern int g_cVDStreamDestroyed;
extern int g_cVDColumnUpdateCreated;                // CVDColumnUpdate
extern int g_cVDColumnUpdateDestroyed;
#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\stream.h ===
//---------------------------------------------------------------------------
// Stream.h : CVDStream header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------


#ifndef __CVDSTREAM__
#define __CVDSTREAM__

#ifndef VD_DONT_IMPLEMENT_ISTREAM


interface IStreamEx : public IStream
{
public:
    virtual /* [local] */ HRESULT __stdcall CopyFrom(
        /* [unique][in] */ IStream __RPC_FAR *pstm,
        /* [in] */ ULARGE_INTEGER cb,
        /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbWritten,
        /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbRead) = 0;
};


class CVDStream : public IStreamEx
{
protected:
// Construction/Destruction
	CVDStream();
	virtual ~CVDStream();

public:
    static HRESULT Create(CVDEntryIDData * pEntryIDData, IStream * pStream, CVDStream ** ppVDStream, 
        CVDResourceDLL * pResourceDLL);
        
protected:
// Data members
    DWORD               m_dwRefCount;       // reference count
    CVDEntryIDData *    m_pEntryIDData;     // backwards pointer to CVDEntryIDData
    IStream *           m_pStream;          // data stream pointer
	CVDResourceDLL *	m_pResourceDLL;     // resource DLL

public:
    //=--------------------------------------------------------------------------=
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    //=--------------------------------------------------------------------------=
    // IStream methods
    //
    STDMETHOD(Read)(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHOD(Write)(const void *pv, ULONG cb, ULONG *pcbWritten);
    STDMETHOD(Seek)(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHOD(SetSize)(ULARGE_INTEGER libNewSize);
    STDMETHOD(CopyTo)(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHOD(Commit)(DWORD grfCommitFlags);
    STDMETHOD(Revert)(void);
    STDMETHOD(LockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHOD(UnlockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHOD(Stat)(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHOD(Clone)(IStream **ppstm);

    //=--------------------------------------------------------------------------=
    // IStreamEx method
    //
    STDMETHOD(CopyFrom)(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbWritten, ULARGE_INTEGER *pcbRead);
};
         

#endif //VD_DONT_IMPLEMENT_ISTREAM

#endif //__CVDSTREAM__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\util.cpp ===
//=--------------------------------------------------------------------------=
// Util.C
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains routines that we will find useful.
//
#include "stdafx.h"   // not really used here, but NT Build env. doesn't like
                      // some files in a dir to have pre-comp hdrs & some not

#include "IPServer.H"

#include "Globals.H"
#include "Util.H"


SZTHISFILE


//=---------------------------------------------------------------------------=
// overloaded new
//=---------------------------------------------------------------------------=
// for the retail case, we'll just use the win32 Local* heap management
// routines for speed and size
//
// Parameters:
//    size_t         - [in] what size do we alloc
//
// Output:
//    VOID *         - new memoery.
//
// Notes:
//
void * _cdecl operator new
(
    size_t    size
)
{
    return malloc(size);
}


//=---------------------------------------------------------------------------=
// overloaded delete
//=---------------------------------------------------------------------------=
// retail case just uses win32 Local* heap mgmt functions
//
// Parameters:
//    void *        - [in] free me!
//
// Notes:
//
void _cdecl operator delete ( void *ptr)
{

    free(ptr);
}

//=--------------------------------------------------------------------------=
// MakeWideFromAnsi
//=--------------------------------------------------------------------------=
// given a string, make a BSTR out of it.
//
// Parameters:
//    LPSTR         - [in]
//    BYTE          - [in]
//
// Output:
//    LPWSTR        - needs to be cast to final desired result
//
// Notes:
//
LPWSTR MakeWideStrFromAnsi
(
    LPSTR psz,
    BYTE  bType
)
{
    LPWSTR pwsz;
    int i;

    // arg checking.
    //
    if (!psz)
        return NULL;

    // compute the length of the required BSTR
    //
    i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    if (i <= 0) return NULL;

    // allocate the widestr, +1 for terminating null
    //
    switch (bType) {
      case STR_BSTR:
        pwsz = (LPWSTR) SysAllocStringLen(NULL, i);
        break;
      case STR_OLESTR:
        pwsz = (LPWSTR) g_pMalloc->Alloc(i * sizeof(WCHAR));
        break;
      default:
        FAIL("Bogus String Type.  Somebody needs to learn how to program");
    }

    if (!pwsz) return NULL;
    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i);
    pwsz[i - 1] = 0;
    return pwsz;
}

//=--------------------------------------------------------------------------=
// MakeWideStrFromResId
//=--------------------------------------------------------------------------=
// given a resource ID, load it, and allocate a wide string for it.
//
// Parameters:
//    WORD            - [in] resource id.
//    BYTE            - [in] type of string desired.
//
// Output:
//    LPWSTR          - needs to be cast to desired string type.
//
// Notes:
//
/*LPWSTR MakeWideStrFromResourceId
(
    WORD    wId,
    BYTE    bType
)
{
    int i;

    char szTmp[512];

    // load the string from the resources.
    //
    i = LoadString(GetResourceHandle(), wId, szTmp, 512);
    if (!i) return NULL;

    return MakeWideStrFromAnsi(szTmp, bType);
}
*/
//=--------------------------------------------------------------------------=
// MakeWideStrFromWide
//=--------------------------------------------------------------------------=
// given a wide string, make a new wide string with it of the given type.
//
// Parameters:
//    LPWSTR            - [in]  current wide str.
//    BYTE              - [in]  desired type of string.
//
// Output:
//    LPWSTR
//
// Notes:
//
LPWSTR MakeWideStrFromWide
(
    LPWSTR pwsz,
    BYTE   bType
)
{
    LPWSTR pwszTmp;
    int i;

    if (!pwsz) return NULL;

    // just copy the string, depending on what type they want.
    //
    switch (bType) {
      case STR_OLESTR:
        i = lstrlenW(pwsz);
        pwszTmp = (LPWSTR)g_pMalloc->Alloc((i * sizeof(WCHAR)) + 1);
        if (!pwszTmp) return NULL;
        memcpy(pwszTmp, pwsz, (sizeof(WCHAR) * i) + 1);
        break;

      case STR_BSTR:
        pwszTmp = (LPWSTR)SysAllocString(pwsz);
        break;
    }

    return pwszTmp;
}

//=--------------------------------------------------------------------------=
// StringFromGuidA
//=--------------------------------------------------------------------------=
// returns an ANSI string from a CLSID or GUID
//
// Parameters:
//    REFIID               - [in]  clsid to make string out of.
//    LPSTR                - [in]  buffer in which to place resultant GUID.
//
// Output:
//    int                  - number of chars written out.
//
// Notes:
//
int StringFromGuidA
(
    REFIID   riid,
    LPSTR    pszBuf
)
{
    return wsprintf((char *)pszBuf, "{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}", riid.Data1, 
            riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], 
            riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7]);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\timeconv.cpp ===
//---------------------------------------------------------------------------
// TimeConv.cpp : Date time conversion routines
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "timeconv.h"
#include <math.h>
#include <limits.h>

// needed for ASSERTs and FAIL
//
SZTHISFILE

//-----------------------------------------------------------------------
// The following routines convert between differnt data/time formats
// they return TRUE if successful otherwise they return FALSE
//-----------------------------------------------------------------------

BOOL VDConvertToFileTime(DBTIMESTAMP * pDBTimeStamp, FILETIME *	pFileTime)
{
	ASSERT_POINTER(pFileTime, FILETIME);
	ASSERT_POINTER(pDBTimeStamp, DBTIMESTAMP);

	if (pFileTime		&& 
		pDBTimeStamp)
	{
		SYSTEMTIME st;
		st.wYear			= pDBTimeStamp->year;  
		st.wMonth			= pDBTimeStamp->month; 
		st.wDay				= pDBTimeStamp->day;          
		st.wDayOfWeek		= 0;   // ?       
		st.wHour			= pDBTimeStamp->hour;         
		st.wMinute			= pDBTimeStamp->minute;       
		st.wSecond			= pDBTimeStamp->second;       
		st.wMilliseconds	= (USHORT)(pDBTimeStamp->fraction / 1000000);
		return SystemTimeToFileTime(&st, pFileTime);
	}

	return FALSE;
}

BOOL VDConvertToFileTime(DBDATE * pDBDate, FILETIME *	pFileTime)
{
	ASSERT_POINTER(pFileTime, FILETIME);
	ASSERT_POINTER(pDBDate, DBDATE);

	if (pFileTime		&& 
		pDBDate)
	{
		SYSTEMTIME st;
		st.wYear			= pDBDate->year;  
		st.wMonth			= pDBDate->month; 
		st.wDay				= pDBDate->day;          
		st.wDayOfWeek		= 0;
		st.wHour			= 0;         
		st.wMinute			= 0;       
		st.wSecond			= 0;       
		st.wMilliseconds	= 0;
		return SystemTimeToFileTime(&st, pFileTime);
	}

	return FALSE;
}

BOOL VDConvertToFileTime(DBTIME * pDBTime, FILETIME * pFileTime)
{
	ASSERT_POINTER(pFileTime, FILETIME);
	ASSERT_POINTER(pDBTime, DBTIME);

	if (pFileTime		&& 
		pDBTime)
	{
		SYSTEMTIME st;
		st.wYear			= 1996; // any date will do since we
		st.wMonth			= 07; 	// are only interested in the time
		st.wDay				= 30;          
		st.wDayOfWeek		= 2;
		st.wHour			= pDBTime->hour;         
		st.wMinute			= pDBTime->minute;       
		st.wSecond			= pDBTime->second;       
		st.wMilliseconds	= 0;
		return SystemTimeToFileTime(&st, pFileTime);
	}

	return FALSE;
}

BOOL VDConvertToFileTime(DATE * pDate, FILETIME * pFileTime)
{
	ASSERT_POINTER(pDate, DATE);
	ASSERT_POINTER(pFileTime, FILETIME);

	if (pDate		&& 
		pFileTime)
	{
		WORD wFatDate;
		WORD wFatTime;
		if (VariantTimeToDosDateTime(*pDate, &wFatDate, &wFatTime))
			return DosDateTimeToFileTime(wFatDate, wFatTime, pFileTime);
	}

	return FALSE;
}

BOOL VDConvertToDBTimeStamp(FILETIME * pFileTime, DBTIMESTAMP * pDBTimeStamp)
{
	SYSTEMTIME st;
	ASSERT_POINTER(pFileTime, FILETIME);
	ASSERT_POINTER(pDBTimeStamp, DBTIMESTAMP);

	if (pFileTime		&& 
		pDBTimeStamp	&&
		FileTimeToSystemTime(pFileTime, &st))
	{
		pDBTimeStamp->year		= st.wYear;  
		pDBTimeStamp->month		= st.wMonth; 
		pDBTimeStamp->day		= st.wDay;          
		pDBTimeStamp->hour		= st.wHour;         
		pDBTimeStamp->minute	= st.wMinute;       
		pDBTimeStamp->second	= st.wSecond;       
		pDBTimeStamp->fraction	= (ULONG)st.wMilliseconds * 1000000;
		return TRUE;
	}

	return FALSE;

}

BOOL VDConvertToDBTimeStamp(DATE * pDate, DBTIMESTAMP * pDBTimeStamp)
{
	ASSERT_POINTER(pDate, DATE);
	ASSERT_POINTER(pDBTimeStamp, DBTIMESTAMP);

	if (pDate		&& 
		pDBTimeStamp)
	{
		FILETIME filetime;
		if (VDConvertToFileTime(pDate, &filetime))
			return VDConvertToDBTimeStamp(&filetime, pDBTimeStamp);
	}

	return FALSE;
}

BOOL VDConvertToDBDate(FILETIME * pFileTime, DBDATE * pDBDate)
{
	SYSTEMTIME st;
	ASSERT_POINTER(pFileTime, FILETIME);
	ASSERT_POINTER(pDBDate, DBDATE);

	if (pFileTime		&& 
		pDBDate			&&
		FileTimeToSystemTime(pFileTime, &st))
	{
		pDBDate->year		= st.wYear;  
		pDBDate->month		= st.wMonth; 
		pDBDate->day		= st.wDay;          
		return TRUE;
	}

	return FALSE;
}

BOOL VDConvertToDBDate(DATE * pDate, DBDATE * pDBDate)
{
	ASSERT_POINTER(pDate, DATE);
	ASSERT_POINTER(pDBDate, DBDATE);

	if (pDate		&& 
		pDBDate)
	{
		FILETIME filetime;
		if (VDConvertToFileTime(pDate, &filetime))
			return VDConvertToDBDate(&filetime, pDBDate);
	}

	return FALSE;
}

BOOL VDConvertToDBTime(FILETIME * pFileTime, DBTIME * pDBTime)
{
	SYSTEMTIME st;
	ASSERT_POINTER(pFileTime, FILETIME);
	ASSERT_POINTER(pDBTime, DBTIME);

	if (pFileTime		&& 
		pDBTime			&&
		FileTimeToSystemTime(pFileTime, &st))
	{
		pDBTime->hour		= st.wHour;         
		pDBTime->minute		= st.wMinute;       
		pDBTime->second		= st.wSecond;       
		return TRUE;
	}
	
	return FALSE;
}

BOOL VDConvertToDBTime(DATE * pDate, DBTIME * pDBTime)
{
	ASSERT_POINTER(pDate, DATE);
	ASSERT_POINTER(pDBTime, DBTIME);

	if (pDate		&& 
		pDBTime)
	{
		FILETIME filetime;
		if (VDConvertToFileTime(pDate, &filetime))
			return VDConvertToDBTime(&filetime, pDBTime);
	}

	return FALSE;
}

BOOL VDConvertToDate(FILETIME * pFileTime, DATE * pDate)
{
	ASSERT_POINTER(pDate, DATE);
	ASSERT_POINTER(pFileTime, FILETIME);

	if (pDate		&& 
		pFileTime)
	{
		WORD wFatDate;
		WORD wFatTime;
		if (FileTimeToDosDateTime(pFileTime, &wFatDate, &wFatTime))
			return DosDateTimeToVariantTime(wFatDate, wFatTime, pDate);
	}

	return FALSE;
}

BOOL VDConvertToDate(DBTIMESTAMP * pDBTimeStamp, DATE * pDate)
{
	ASSERT_POINTER(pDate, DATE);
	ASSERT_POINTER(pDBTimeStamp, DBTIMESTAMP);

	if (pDate		&& 
		pDBTimeStamp)
	{
		FILETIME fileTime;
		if (VDConvertToFileTime(pDBTimeStamp, &fileTime))
			return VDConvertToDate(&fileTime, pDate);
	}

	return FALSE;
}

BOOL VDConvertToDate(DBTIME * pDBTime, DATE * pDate)
{
	ASSERT_POINTER(pDate, DATE);
	ASSERT_POINTER(pDBTime, DBTIME);

	if (pDate		&& 
		pDBTime)
	{
		FILETIME fileTime;
		if (VDConvertToFileTime(pDBTime, &fileTime))
		{
			DATE date;
			if (VDConvertToDate(&fileTime, &date))
			{
				DATE dateIntegerPart;
				// return only the time (fractional part of double)
				*pDate = modf(date, &dateIntegerPart);
			}
		}
	}

	return FALSE;
}

BOOL VDConvertToDate(DBDATE * pDBDate, DATE * pDate)
{
	ASSERT_POINTER(pDate, DATE);
	ASSERT_POINTER(pDBDate, DBDATE);

	if (pDate		&& 
		pDBDate)
	{
		FILETIME fileTime;
		if (VDConvertToFileTime(pDBDate, &fileTime))
			return VDConvertToDate(&fileTime, pDate);
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\transact.h ===
//.-------------------------------------------------------------------------
//.
//.  Microsoft Windows
//.  Copyright (C) Microsoft Corporation, 1995.
//.
//.  File: transact.idl
//.
//.  Contents: The basic transaction interfaces and types.
//.
//.--------------------------------------------------------------------------


/* File created by MIDL compiler version 2.00.0102 */
/* at Tue Nov 21 16:54:32 1995
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __transact_h__
#define __transact_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ITransaction_FWD_DEFINED__
#define __ITransaction_FWD_DEFINED__
typedef interface ITransaction ITransaction;
#endif 	/* __ITransaction_FWD_DEFINED__ */


#ifndef __ITransactionDispenser_FWD_DEFINED__
#define __ITransactionDispenser_FWD_DEFINED__
typedef interface ITransactionDispenser ITransactionDispenser;
#endif 	/* __ITransactionDispenser_FWD_DEFINED__ */


#ifndef __ITransactionOptions_FWD_DEFINED__
#define __ITransactionOptions_FWD_DEFINED__
typedef interface ITransactionOptions ITransactionOptions;
#endif 	/* __ITransactionOptions_FWD_DEFINED__ */


#ifndef __ITransactionOutcomeEvents_FWD_DEFINED__
#define __ITransactionOutcomeEvents_FWD_DEFINED__
typedef interface ITransactionOutcomeEvents ITransactionOutcomeEvents;
#endif 	/* __ITransactionOutcomeEvents_FWD_DEFINED__ */


#ifndef __ITransactionCompletionEvents_FWD_DEFINED__
#define __ITransactionCompletionEvents_FWD_DEFINED__
typedef interface ITransactionCompletionEvents ITransactionCompletionEvents;
#endif 	/* __ITransactionCompletionEvents_FWD_DEFINED__ */


/* header files for imported files */

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Tue Nov 21 16:54:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */



extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __BasicTransactionTypes_INTERFACE_DEFINED__
#define __BasicTransactionTypes_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: BasicTransactionTypes
 * at Tue Nov 21 16:54:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][local] */ 


			/* size is 16 */
typedef struct  BOID
    {
    BYTE rgb[ 16 ];
    }	BOID;

#define BOID_NULL (*((BOID*)(&IID_NULL)))

#define MAX_TRAN_DESC 40		// used by XACTOPT via midl - see transact.idl 
			/* size is 16 */
typedef BOID XACTUOW;

			/* size is 4 */
typedef LONG ISOLEVEL;

#if defined(_WIN32)
			/* size is 2 */
typedef 
enum ISOLATIONLEVEL
    {	ISOLATIONLEVEL_UNSPECIFIED	= 0xffffffff,
	ISOLATIONLEVEL_CHAOS	= 0x10,
	ISOLATIONLEVEL_READUNCOMMITTED	= 0x100,
	ISOLATIONLEVEL_BROWSE	= 0x100,
	ISOLATIONLEVEL_CURSORSTABILITY	= 0x1000,
	ISOLATIONLEVEL_READCOMMITTED	= 0x1000,
	ISOLATIONLEVEL_REPEATABLEREAD	= 0x10000,
	ISOLATIONLEVEL_SERIALIZABLE	= 0x100000,
	ISOLATIONLEVEL_ISOLATED	= 0x100000
    }	ISOLATIONLEVEL;

#else
#define ISOLATIONLEVEL_UNSPECIFIED      0xFFFFFFFF
#define ISOLATIONLEVEL_CHAOS            0x00000010
#define ISOLATIONLEVEL_READUNCOMMITTED  0x00000100
#define ISOLATIONLEVEL_BROWSE           0x00000100
#define ISOLATIONLEVEL_CURSORSTABILITY  0x00001000
#define ISOLATIONLEVEL_READCOMMITTED    0x00001000
#define ISOLATIONLEVEL_REPEATABLEREAD   0x00010000
#define ISOLATIONLEVEL_SERIALIZABLE     0x00100000
#define ISOLATIONLEVEL_ISOLATED         0x00100000
#endif
			/* size is 40 */
typedef struct  XACTTRANSINFO
    {
    XACTUOW uow;
    ISOLEVEL isoLevel;
    ULONG isoFlags;
    DWORD grfTCSupported;
    DWORD grfRMSupported;
    DWORD grfTCSupportedRetaining;
    DWORD grfRMSupportedRetaining;
    }	XACTTRANSINFO;

			/* size is 36 */
typedef struct  XACTSTATS
    {
    ULONG cOpen;
    ULONG cCommitting;
    ULONG cCommitted;
    ULONG cAborting;
    ULONG cAborted;
    ULONG cInDoubt;
    ULONG cHeuristicDecision;
    FILETIME timeTransactionsUp;
    }	XACTSTATS;

			/* size is 2 */
typedef 
enum ISOFLAG
    {	ISOFLAG_RETAIN_COMMIT_DC	= 1,
	ISOFLAG_RETAIN_COMMIT	= 2,
	ISOFLAG_RETAIN_COMMIT_NO	= 3,
	ISOFLAG_RETAIN_ABORT_DC	= 4,
	ISOFLAG_RETAIN_ABORT	= 8,
	ISOFLAG_RETAIN_ABORT_NO	= 12,
	ISOFLAG_RETAIN_DONTCARE	= ISOFLAG_RETAIN_COMMIT_DC | ISOFLAG_RETAIN_ABORT_DC,
	ISOFLAG_RETAIN_BOTH	= ISOFLAG_RETAIN_COMMIT | ISOFLAG_RETAIN_ABORT,
	ISOFLAG_RETAIN_NONE	= ISOFLAG_RETAIN_COMMIT_NO | ISOFLAG_RETAIN_ABORT_NO,
	ISOFLAG_OPTIMISTIC	= 16
    }	ISOFLAG;

			/* size is 2 */
typedef 
enum XACTTC
    {	XACTTC_SYNC_PHASEONE	= 1,
	XACTTC_SYNC_PHASETWO	= 2,
	XACTTC_SYNC	= 2,
	XACTTC_ASYNC_PHASEONE	= 4
    }	XACTTC;

			/* size is 2 */
typedef 
enum XACTRM
    {	XACTRM_OPTIMISTICLASTWINS	= 1,
	XACTRM_NOREADONLYPREPARES	= 2
    }	XACTRM;

			/* size is 2 */
typedef 
enum XACTCONST
    {	XACTCONST_TIMEOUTINFINITE	= 0
    }	XACTCONST;

			/* size is 2 */
typedef 
enum XACTHEURISTIC
    {	XACTHEURISTIC_ABORT	= 1,
	XACTHEURISTIC_COMMIT	= 2,
	XACTHEURISTIC_DAMAGE	= 3,
	XACTHEURISTIC_DANGER	= 4
    }	XACTHEURISTIC;

#if defined(_WIN32)
			/* size is 2 */
typedef 
enum XACTSTAT
    {	XACTSTAT_NONE	= 0,
	XACTSTAT_OPENNORMAL	= 0x1,
	XACTSTAT_OPENREFUSED	= 0x2,
	XACTSTAT_PREPARING	= 0x4,
	XACTSTAT_PREPARED	= 0x8,
	XACTSTAT_PREPARERETAINING	= 0x10,
	XACTSTAT_PREPARERETAINED	= 0x20,
	XACTSTAT_COMMITTING	= 0x40,
	XACTSTAT_COMMITRETAINING	= 0x80,
	XACTSTAT_ABORTING	= 0x100,
	XACTSTAT_ABORTED	= 0x200,
	XACTSTAT_COMMITTED	= 0x400,
	XACTSTAT_HEURISTIC_ABORT	= 0x800,
	XACTSTAT_HEURISTIC_COMMIT	= 0x1000,
	XACTSTAT_HEURISTIC_DAMAGE	= 0x2000,
	XACTSTAT_HEURISTIC_DANGER	= 0x4000,
	XACTSTAT_FORCED_ABORT	= 0x8000,
	XACTSTAT_FORCED_COMMIT	= 0x10000,
	XACTSTAT_INDOUBT	= 0x20000,
	XACTSTAT_CLOSED	= 0x40000,
	XACTSTAT_OPEN	= 0x3,
	XACTSTAT_NOTPREPARED	= 0x7ffc3,
	XACTSTAT_ALL	= 0x7ffff
    }	XACTSTAT;

#else
#define XACTSTAT_NONE               0x00000000
#define XACTSTAT_OPENNORMAL         0x00000001
#define XACTSTAT_OPENREFUSED        0x00000002
#define XACTSTAT_PREPARING          0x00000004
#define XACTSTAT_PREPARED           0x00000008
#define XACTSTAT_PREPARERETAINING   0x00000010
#define XACTSTAT_PREPARERETAINED    0x00000020
#define XACTSTAT_COMMITTING         0x00000040
#define XACTSTAT_COMMITRETAINING    0x00000080
#define XACTSTAT_ABORTING           0x00000100
#define XACTSTAT_ABORTED            0x00000200
#define XACTSTAT_COMMITTED          0x00000400
#define XACTSTAT_HEURISTIC_ABORT    0x00000800
#define XACTSTAT_HEURISTIC_COMMIT   0x00001000
#define XACTSTAT_HEURISTIC_DAMAGE   0x00002000
#define XACTSTAT_HEURISTIC_DANGER   0x00004000
#define XACTSTAT_FORCED_ABORT       0x00008000
#define XACTSTAT_FORCED_COMMIT      0x00010000
#define XACTSTAT_INDOUBT            0x00020000
#define XACTSTAT_CLOSED             0x00040000
#define XACTSTAT_OPEN               0x00000003
#define XACTSTAT_NOTPREPARED        0x0007FFC3
#define XACTSTAT_ALL                0x0007FFFF
#endif
			/* size is 44 */
typedef struct  XACTOPT
    {
    ULONG ulTimeout;
    unsigned char szDescription[ 40 ];
    }	XACTOPT;



extern RPC_IF_HANDLE BasicTransactionTypes_v0_0_c_ifspec;
extern RPC_IF_HANDLE BasicTransactionTypes_v0_0_s_ifspec;
#endif /* __BasicTransactionTypes_INTERFACE_DEFINED__ */

#ifndef __ITransaction_INTERFACE_DEFINED__
#define __ITransaction_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITransaction
 * at Tue Nov 21 16:54:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ITransaction;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITransaction : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Commit( 
            /* [in] */ BOOL fRetaining,
            /* [in] */ DWORD grfTC,
            /* [in] */ DWORD grfRM) = 0;
        
        virtual HRESULT __stdcall Abort( 
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ BOOL fAsync) = 0;
        
        virtual HRESULT __stdcall GetTransactionInfo( 
            /* [out] */ XACTTRANSINFO __RPC_FAR *pinfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ITransaction __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ITransaction __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ITransaction __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Commit )( 
            ITransaction __RPC_FAR * This,
            /* [in] */ BOOL fRetaining,
            /* [in] */ DWORD grfTC,
            /* [in] */ DWORD grfRM);
        
        HRESULT ( __stdcall __RPC_FAR *Abort )( 
            ITransaction __RPC_FAR * This,
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ BOOL fAsync);
        
        HRESULT ( __stdcall __RPC_FAR *GetTransactionInfo )( 
            ITransaction __RPC_FAR * This,
            /* [out] */ XACTTRANSINFO __RPC_FAR *pinfo);
        
    } ITransactionVtbl;

    interface ITransaction
    {
        CONST_VTBL struct ITransactionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransaction_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransaction_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransaction_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransaction_Commit(This,fRetaining,grfTC,grfRM)	\
    (This)->lpVtbl -> Commit(This,fRetaining,grfTC,grfRM)

#define ITransaction_Abort(This,pboidReason,fRetaining,fAsync)	\
    (This)->lpVtbl -> Abort(This,pboidReason,fRetaining,fAsync)

#define ITransaction_GetTransactionInfo(This,pinfo)	\
    (This)->lpVtbl -> GetTransactionInfo(This,pinfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ITransaction_Commit_Proxy( 
    ITransaction __RPC_FAR * This,
    /* [in] */ BOOL fRetaining,
    /* [in] */ DWORD grfTC,
    /* [in] */ DWORD grfRM);


void __RPC_STUB ITransaction_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITransaction_Abort_Proxy( 
    ITransaction __RPC_FAR * This,
    /* [in] */ BOID __RPC_FAR *pboidReason,
    /* [in] */ BOOL fRetaining,
    /* [in] */ BOOL fAsync);


void __RPC_STUB ITransaction_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITransaction_GetTransactionInfo_Proxy( 
    ITransaction __RPC_FAR * This,
    /* [out] */ XACTTRANSINFO __RPC_FAR *pinfo);


void __RPC_STUB ITransaction_GetTransactionInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransaction_INTERFACE_DEFINED__ */


#ifndef __ITransactionDispenser_INTERFACE_DEFINED__
#define __ITransactionDispenser_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITransactionDispenser
 * at Tue Nov 21 16:54:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ITransactionDispenser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITransactionDispenser : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetOptionsObject( 
            /* [out] */ ITransactionOptions __RPC_FAR *__RPC_FAR *ppOptions) = 0;
        
        virtual HRESULT __stdcall BeginTransaction( 
            /* [in] */ IUnknown __RPC_FAR *punkOuter,
            /* [in] */ ISOLEVEL isoLevel,
            /* [in] */ ULONG isoFlags,
            /* [in] */ ITransactionOptions __RPC_FAR *pOptions,
            /* [out] */ ITransaction __RPC_FAR *__RPC_FAR *ppTransaction) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionDispenserVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ITransactionDispenser __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ITransactionDispenser __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ITransactionDispenser __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetOptionsObject )( 
            ITransactionDispenser __RPC_FAR * This,
            /* [out] */ ITransactionOptions __RPC_FAR *__RPC_FAR *ppOptions);
        
        HRESULT ( __stdcall __RPC_FAR *BeginTransaction )( 
            ITransactionDispenser __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *punkOuter,
            /* [in] */ ISOLEVEL isoLevel,
            /* [in] */ ULONG isoFlags,
            /* [in] */ ITransactionOptions __RPC_FAR *pOptions,
            /* [out] */ ITransaction __RPC_FAR *__RPC_FAR *ppTransaction);
        
    } ITransactionDispenserVtbl;

    interface ITransactionDispenser
    {
        CONST_VTBL struct ITransactionDispenserVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionDispenser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionDispenser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionDispenser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionDispenser_GetOptionsObject(This,ppOptions)	\
    (This)->lpVtbl -> GetOptionsObject(This,ppOptions)

#define ITransactionDispenser_BeginTransaction(This,punkOuter,isoLevel,isoFlags,pOptions,ppTransaction)	\
    (This)->lpVtbl -> BeginTransaction(This,punkOuter,isoLevel,isoFlags,pOptions,ppTransaction)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ITransactionDispenser_GetOptionsObject_Proxy( 
    ITransactionDispenser __RPC_FAR * This,
    /* [out] */ ITransactionOptions __RPC_FAR *__RPC_FAR *ppOptions);


void __RPC_STUB ITransactionDispenser_GetOptionsObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITransactionDispenser_BeginTransaction_Proxy( 
    ITransactionDispenser __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *punkOuter,
    /* [in] */ ISOLEVEL isoLevel,
    /* [in] */ ULONG isoFlags,
    /* [in] */ ITransactionOptions __RPC_FAR *pOptions,
    /* [out] */ ITransaction __RPC_FAR *__RPC_FAR *ppTransaction);


void __RPC_STUB ITransactionDispenser_BeginTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionDispenser_INTERFACE_DEFINED__ */


#ifndef __ITransactionOptions_INTERFACE_DEFINED__
#define __ITransactionOptions_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITransactionOptions
 * at Tue Nov 21 16:54:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ITransactionOptions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITransactionOptions : public IUnknown
    {
    public:
        virtual HRESULT __stdcall SetOptions( 
            /* [in] */ XACTOPT __RPC_FAR *pOptions) = 0;
        
        virtual HRESULT __stdcall GetOptions( 
            /* [out][in] */ XACTOPT __RPC_FAR *pOptions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionOptionsVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ITransactionOptions __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ITransactionOptions __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ITransactionOptions __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *SetOptions )( 
            ITransactionOptions __RPC_FAR * This,
            /* [in] */ XACTOPT __RPC_FAR *pOptions);
        
        HRESULT ( __stdcall __RPC_FAR *GetOptions )( 
            ITransactionOptions __RPC_FAR * This,
            /* [out][in] */ XACTOPT __RPC_FAR *pOptions);
        
    } ITransactionOptionsVtbl;

    interface ITransactionOptions
    {
        CONST_VTBL struct ITransactionOptionsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionOptions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionOptions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionOptions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionOptions_SetOptions(This,pOptions)	\
    (This)->lpVtbl -> SetOptions(This,pOptions)

#define ITransactionOptions_GetOptions(This,pOptions)	\
    (This)->lpVtbl -> GetOptions(This,pOptions)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ITransactionOptions_SetOptions_Proxy( 
    ITransactionOptions __RPC_FAR * This,
    /* [in] */ XACTOPT __RPC_FAR *pOptions);


void __RPC_STUB ITransactionOptions_SetOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITransactionOptions_GetOptions_Proxy( 
    ITransactionOptions __RPC_FAR * This,
    /* [out][in] */ XACTOPT __RPC_FAR *pOptions);


void __RPC_STUB ITransactionOptions_GetOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionOptions_INTERFACE_DEFINED__ */


#ifndef __ITransactionOutcomeEvents_INTERFACE_DEFINED__
#define __ITransactionOutcomeEvents_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITransactionOutcomeEvents
 * at Tue Nov 21 16:54:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ITransactionOutcomeEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITransactionOutcomeEvents : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Committed( 
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT __stdcall Aborted( 
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT __stdcall HeuristicDecision( 
            /* [in] */ DWORD dwDecision,
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT __stdcall Indoubt( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionOutcomeEventsVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ITransactionOutcomeEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ITransactionOutcomeEvents __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ITransactionOutcomeEvents __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Committed )( 
            ITransactionOutcomeEvents __RPC_FAR * This,
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr);
        
        HRESULT ( __stdcall __RPC_FAR *Aborted )( 
            ITransactionOutcomeEvents __RPC_FAR * This,
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr);
        
        HRESULT ( __stdcall __RPC_FAR *HeuristicDecision )( 
            ITransactionOutcomeEvents __RPC_FAR * This,
            /* [in] */ DWORD dwDecision,
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ HRESULT hr);
        
        HRESULT ( __stdcall __RPC_FAR *Indoubt )( 
            ITransactionOutcomeEvents __RPC_FAR * This);
        
    } ITransactionOutcomeEventsVtbl;

    interface ITransactionOutcomeEvents
    {
        CONST_VTBL struct ITransactionOutcomeEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionOutcomeEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionOutcomeEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionOutcomeEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionOutcomeEvents_Committed(This,fRetaining,pNewUOW,hr)	\
    (This)->lpVtbl -> Committed(This,fRetaining,pNewUOW,hr)

#define ITransactionOutcomeEvents_Aborted(This,pboidReason,fRetaining,pNewUOW,hr)	\
    (This)->lpVtbl -> Aborted(This,pboidReason,fRetaining,pNewUOW,hr)

#define ITransactionOutcomeEvents_HeuristicDecision(This,dwDecision,pboidReason,hr)	\
    (This)->lpVtbl -> HeuristicDecision(This,dwDecision,pboidReason,hr)

#define ITransactionOutcomeEvents_Indoubt(This)	\
    (This)->lpVtbl -> Indoubt(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ITransactionOutcomeEvents_Committed_Proxy( 
    ITransactionOutcomeEvents __RPC_FAR * This,
    /* [in] */ BOOL fRetaining,
    /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
    /* [in] */ HRESULT hr);


void __RPC_STUB ITransactionOutcomeEvents_Committed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITransactionOutcomeEvents_Aborted_Proxy( 
    ITransactionOutcomeEvents __RPC_FAR * This,
    /* [in] */ BOID __RPC_FAR *pboidReason,
    /* [in] */ BOOL fRetaining,
    /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
    /* [in] */ HRESULT hr);


void __RPC_STUB ITransactionOutcomeEvents_Aborted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITransactionOutcomeEvents_HeuristicDecision_Proxy( 
    ITransactionOutcomeEvents __RPC_FAR * This,
    /* [in] */ DWORD dwDecision,
    /* [in] */ BOID __RPC_FAR *pboidReason,
    /* [in] */ HRESULT hr);


void __RPC_STUB ITransactionOutcomeEvents_HeuristicDecision_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITransactionOutcomeEvents_Indoubt_Proxy( 
    ITransactionOutcomeEvents __RPC_FAR * This);


void __RPC_STUB ITransactionOutcomeEvents_Indoubt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionOutcomeEvents_INTERFACE_DEFINED__ */


#ifndef __ITransactionCompletionEvents_INTERFACE_DEFINED__
#define __ITransactionCompletionEvents_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITransactionCompletionEvents
 * at Tue Nov 21 16:54:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ITransactionCompletionEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITransactionCompletionEvents : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Committed( 
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT __stdcall Aborted( 
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT __stdcall HeuristicDecision( 
            /* [in] */ DWORD dwDecision,
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT __stdcall Indoubt( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionCompletionEventsVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ITransactionCompletionEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ITransactionCompletionEvents __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ITransactionCompletionEvents __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Committed )( 
            ITransactionCompletionEvents __RPC_FAR * This,
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr);
        
        HRESULT ( __stdcall __RPC_FAR *Aborted )( 
            ITransactionCompletionEvents __RPC_FAR * This,
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr);
        
        HRESULT ( __stdcall __RPC_FAR *HeuristicDecision )( 
            ITransactionCompletionEvents __RPC_FAR * This,
            /* [in] */ DWORD dwDecision,
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ HRESULT hr);
        
        HRESULT ( __stdcall __RPC_FAR *Indoubt )( 
            ITransactionCompletionEvents __RPC_FAR * This);
        
    } ITransactionCompletionEventsVtbl;

    interface ITransactionCompletionEvents
    {
        CONST_VTBL struct ITransactionCompletionEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionCompletionEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionCompletionEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionCompletionEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionCompletionEvents_Committed(This,fRetaining,pNewUOW,hr)	\
    (This)->lpVtbl -> Committed(This,fRetaining,pNewUOW,hr)

#define ITransactionCompletionEvents_Aborted(This,pboidReason,fRetaining,pNewUOW,hr)	\
    (This)->lpVtbl -> Aborted(This,pboidReason,fRetaining,pNewUOW,hr)

#define ITransactionCompletionEvents_HeuristicDecision(This,dwDecision,pboidReason,hr)	\
    (This)->lpVtbl -> HeuristicDecision(This,dwDecision,pboidReason,hr)

#define ITransactionCompletionEvents_Indoubt(This)	\
    (This)->lpVtbl -> Indoubt(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ITransactionCompletionEvents_Committed_Proxy( 
    ITransactionCompletionEvents __RPC_FAR * This,
    /* [in] */ BOOL fRetaining,
    /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
    /* [in] */ HRESULT hr);


void __RPC_STUB ITransactionCompletionEvents_Committed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITransactionCompletionEvents_Aborted_Proxy( 
    ITransactionCompletionEvents __RPC_FAR * This,
    /* [in] */ BOID __RPC_FAR *pboidReason,
    /* [in] */ BOOL fRetaining,
    /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
    /* [in] */ HRESULT hr);


void __RPC_STUB ITransactionCompletionEvents_Aborted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITransactionCompletionEvents_HeuristicDecision_Proxy( 
    ITransactionCompletionEvents __RPC_FAR * This,
    /* [in] */ DWORD dwDecision,
    /* [in] */ BOID __RPC_FAR *pboidReason,
    /* [in] */ HRESULT hr);


void __RPC_STUB ITransactionCompletionEvents_HeuristicDecision_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITransactionCompletionEvents_Indoubt_Proxy( 
    ITransactionCompletionEvents __RPC_FAR * This);


void __RPC_STUB ITransactionCompletionEvents_Indoubt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionCompletionEvents_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0011
 * at Tue Nov 21 16:54:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


#define XACT_E_FIRST                    0x8004D000
#define XACT_E_LAST                     0x8004D01E
#define XACT_S_FIRST                    0x0004D000
#define XACT_S_LAST                     0x0004D009

#define XACT_E_ABORTED                  0x8004D019
#define XACT_E_ALREADYOTHERSINGLEPHASE  0x8004D000
#define XACT_E_ALREADYINPROGRESS        0x8004D018
#define XACT_E_CANTRETAIN               0x8004D001
#define XACT_E_COMMITFAILED             0x8004D002
#define XACT_E_COMMITPREVENTED          0x8004D003
#define XACT_E_CONNECTION_DENIED        0x8004D01D
#define XACT_E_CONNECTION_DOWN          0x8004D01C
#define XACT_E_HEURISTICABORT           0x8004D004
#define XACT_E_HEURISTICCOMMIT          0x8004D005
#define XACT_E_HEURISTICDAMAGE          0x8004D006
#define XACT_E_HEURISTICDANGER          0x8004D007
#define XACT_E_INDOUBT                  0x8004D016
#define XACT_E_INVALIDCOOKIE            0x8004D015
#define XACT_E_ISOLATIONLEVEL           0x8004D008
#define XACT_E_LOGFULL                  0x8004D01A
#define XACT_E_NOASYNC                  0x8004D009
#define XACT_E_NOENLIST                 0x8004D00A
#define XACT_E_NOIMPORTOBJECT           0x8004D014
#define XACT_E_NOISORETAIN              0x8004D00B
#define XACT_E_NORESOURCE               0x8004D00C
#define XACT_E_NOTCURRENT               0x8004D00D
#define XACT_E_NOTIMEOUT                0x8004D017
#define XACT_E_NOTRANSACTION            0x8004D00E
#define XACT_E_NOTSUPPORTED             0x8004D00F
#define XACT_E_REENLISTTIMEOUT          0x8004D01E
#define XACT_E_TMNOTAVAILABLE           0x8004D01B
#define XACT_E_UNKNOWNRMGRID            0x8004D010
#define XACT_E_WRONGSTATE               0x8004D011
#define XACT_E_WRONGUOW                 0x8004D012
#define XACT_E_XTIONEXISTS              0x8004D013

#define XACT_S_ABORTING                 0x0004D008
#define XACT_S_ALLNORETAIN              0x0004D007
#define XACT_S_ASYNC                    0x0004D000
#define XACT_S_DEFECT                   0x0004D001
#define XACT_S_OKINFORM                 0x0004D004
#define XACT_S_MADECHANGESCONTENT       0x0004D005
#define XACT_S_MADECHANGESINFORM        0x0004D006
#define XACT_S_READONLY                 0x0004D002
#define XACT_S_SINGLEPHASE              0x0004D009
#define XACT_S_SOMENORETAIN             0x0004D003


extern RPC_IF_HANDLE __MIDL__intf_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0011_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif

///////////////////////////////////////////////////////////////////////
//
// IID definitions for interfaces defined in this header file
//

#if !defined(_transact_iid_) && defined(INITGUID)
#define      _transact_iid_
const IID IID_ITransaction = {0x0fb15084,0xaf41,0x11ce,{0xbd,0x2b,0x20,0x4c,0x4f,0x4f,0x50,0x20}};
const IID IID_ITransactionDispenser = {0x3A6AD9E1,0x23B9,0x11cf,{0xAD,0x60,0x00,0xAA,0x00,0xA7,0x4C,0xCD}};
const IID IID_ITransactionOptions = {0x3A6AD9E0,0x23B9,0x11cf,{0xAD,0x60,0x00,0xAA,0x00,0xA7,0x4C,0xCD}};
const IID IID_ITransactionOutcomeEvents = {0x3A6AD9E2,0x23B9,0x11cf,{0xAD,0x60,0x00,0xAA,0x00,0xA7,0x4C,0xCD}};
const IID IID_ITransactionCompletionEvents = {0xB38D5220,0x23CE,0x11cf,{0xAD,0x60,0x00,0xAA,0x00,0xA7,0x4C,0xCD}};
#endif

///////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\version.h ===
#define rmj		1
#define rmm		4212	// 1st 2 digits for month (e.g. July/96 = 31)
						// last 2 digits for day of month 
						// e.g. August 12, 1996 = 3212
#define rup		0		// zero unless multiple builds on same day
#define szVerName	""
#define szVerUser	"SHERIDAN"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\util.h ===
//=--------------------------------------------------------------------------=
// Util.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains utilities that we will find useful.
//
#ifndef _UTIL_H_

#include "globals.h"
//=--------------------------------------------------------------------------=
// miscellaneous [useful] numerical constants
//=--------------------------------------------------------------------------=
// the length of a guid once printed out with -'s, leading and trailing bracket,
// plus 1 for NULL
//
#define GUID_STR_LEN    40


//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(g_hHeap, 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(g_hHeap, 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given and ANSI String, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPSTR pszA;
//  pszA = MyGetAnsiStringRoutine();
//  MAKE_WIDEPTR_FROMANSI(pwsz, pszA);
//  MyUseWideStringRoutine(pwsz);
//  ...
//
// similarily for MAKE_ANSIPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
#define MAKE_WIDEPTR_FROMANSI(ptrname, ansistr) \
    long __l##ptrname = (lstrlen(ansistr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, ansistr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()

#define MAKE_MBCSPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (lstrlenW(widestr) + 1) * sizeof(char); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname * 2); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname * 2, NULL, NULL); \
    LPSTR ptrname = (LPSTR)__TempBuffer##ptrname.GetBuffer()

#define GET_MBCSLEN_FROMWIDE(widestr) \
	WideCharToMultiByte(CP_ACP, 0, widestr, -1, NULL, 0, NULL, NULL)

#define STR_BSTR   0
#define STR_OLESTR 1
#define BSTRFROMANSI(x)    (BSTR)MakeWideStrFromAnsi((LPSTR)(x), STR_BSTR)
#define OLESTRFROMANSI(x)  (LPOLESTR)MakeWideStrFromAnsi((LPSTR)(x), STR_OLESTR)
#define BSTRFROMRESID(x)   (BSTR)MakeWideStrFromResourceId(x, STR_BSTR)
#define OLESTRFROMRESID(x) (LPOLESTR)MakeWideStrFromResourceId(x, STR_OLESTR)
#define COPYOLESTR(x)      (LPOLESTR)MakeWideStrFromWide(x, STR_OLESTR)
#define COPYBSTR(x)        (BSTR)MakeWideStrFromWide(x, STR_BSTR)

LPWSTR MakeWideStrFromAnsi(LPSTR, BYTE bType);
LPWSTR MakeWideStrFromResourceId(WORD, BYTE bType);
LPWSTR MakeWideStrFromWide(LPWSTR, BYTE bType);

// takes a GUID, and a pointer to a buffer, and places the string form of the
// GUID in said buffer.
//
int StringFromGuidA(REFIID, LPSTR);

#define _UTIL_H_
#endif // _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2cenu\common.inc ===
SOURCES_USED=$(ROOT)\common.inc

!if $(ALPHA)
MSC_WARNING_LEVEL = /W3 /WX
!endif

!ifndef MSC_WARNING_LEVEL
MSC_WARNING_LEVEL = /W3 /WX
!endif

C_DEFINES = \
    /D_WCTYPE_INLINE_DEFINED \
!if $(FREEBUILD)
    /D_ATL_MIN_CRT \
!else
    /D_DEBUG \
!endif
    /DSTRICT

!if !$(FREEBUILD)
USE_RTTI=1
MSC_OPTIMIZATION=/Od
#USER_CPP_FLAGS=/zmf
WATCOM_OPTS=/ei /zt16 /zm /zff /zgf
LINKER_NOICF=1      # ICF is s-l-o-w
!else
MSC_OPTIMIZATION=/Oxs
#USER_CPP_FLAGS=/zmf
WATCOM_OPTS=/ei /zt16 /ox /oe /zm /zff /zgf
!endif

MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /Ob1 /Oi

NOT_LEAN_AND_MEAN=1

USE_NOLIBS=1
UMTYPE=windows

# Use NT 4.0/Win95 functionality only

WIN32_IE_VERSION=0x0400
WIN32_WINNT_VERSION=0x0400
WIN32_WIN95_VERSION=0x0400
SUBSYSTEM_VERSION=4.00

!ifdef WIN16

# Win 16 Specific Environment.
!ifndef __MSVC_ENV__
__WATCOM_ENV__=1
!endif
C_DEFINES = $(C_DEFINES) /DINC_WIN16X /DWRAP_RECTL /DFULL_DEBUG

FULL_DEBUG=1

!else

!if !$(FREEBUILD)
DEBUG_CRTS=1
!endif

# Win 32 Environment.
C_DEFINES = $(C_DEFINES) /D_MT



!endif

!if $(386)
NO_NTDLL=1
!else
# USE_NTDLL=1
!endif

CHECKED_ALT_DIR=1

#
# The IE build lab sets this flag for debug builds so we get full debug
#   on IE drops. The NT build lab wants debug lite builds and therefore
#   does not set it.
#
!ifdef MSHTML_FULL_DEBUG
!message MSHTML_FULL_DEBUG was defined. Building full debug.
FULL_DEBUG=1
!endif

!ifdef USE_ICECAP
C_DEFINES = $(C_DEFINES) /DPRODUCT_PROF
!endif

!ifdef USE_PERFTEST
C_DEFINES = $(C_DEFINES) /DPRODUCT_PERFTEST
!endif

!ifdef USE_PERFBUG
C_DEFINES = $(C_DEFINES) /DPRODUCT_PERFBUG
!endif

!ifdef USE_PERFTAGS
!if $(FREEBUILD)
C_DEFINES = $(C_DEFINES) /DPERFTAGS
!message PERFTAGS was defined
!endif
!endif

!ifdef USE_MSHTML_INCREMENTAL_LINKING
!if !$(FREEBUILD) && $(USE_MSHTML_INCREMENTAL_LINKING)
NTDEBUG=ntsd
NTDEBUGTYPE=windbg
NTDBGFILES=1
!undef USE_MAPSYM
USE_INCREMENTAL_LINKING=1
LINKER_FLAGS=$(LINKER_FLAGS) -INCREMENTAL:YES
USE_PDB_TO_COMPILE=1
TARGETPDB=TDC
!message USE_MSHTML_INCREMENTAL_LINKING was defined
!message $(TARGETPDB) was defined
!endif
!else
# Compatibility with existing usage before use_mshtml_incremental_linking
!ifdef USE_INCREMENTAL_LINKING
!message DOING IT THE OLD WAY
LINKER_FLAGS = -INCREMENTAL:YES
USE_PDB_TO_COMPILE=1
!else
USE_MAPSYM=1
!endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2cenu\msr2cenu.cpp ===
//---------------------------------------------------------------------------
// MSR2CENU.cpp	implements DllMain
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "windows.h"

// DllMain
//
BOOL WINAPI DllMain(HINSTANCE hinstDll, DWORD dwReason, LPVOID lpvReserved)
{

	switch (dwReason)
	{
		case DLL_PROCESS_ATTACH:
		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		case DLL_PROCESS_DETACH:
			break;
	}

	return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2cenu\version.h ===
#define rmj		1
#define rmm		4212	// 1st 2 digits for month (e.g. July/96 = 31)
						// last 2 digits for day of month 
						// e.g. August 12, 1996 = 3212
#define rup		0		// zero unless multiple builds on same day
#define szVerName	""
#define szVerUser	"SHERIDAN"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2cenu\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Viaduct2.rc
//
#define IDS_ERR_SOURCE                  900
#define IDS_ERR_INVALIDARG              1000
#define IDS_ERR_OUTOFMEMORY             1003
#define IDS_ERR_CANTCOERCE              1007
#define IDS_ERR_BADBOOKMARK             1015

// Viaduct2 additions
#define IDS_ERR_NOINTERFACE             2000
#define IDS_ERR_CANTCREATEMETACURSOR    2001
#define IDS_ERR_BUFFERTOOSMALL          2002
#define IDS_ERR_BADCOLUMNID             2003
#define IDS_ERR_COLUMNUNAVAILABLE       2004
#define IDS_ERR_BADCURSORBINDINFO       2005
#define IDS_ERR_ROWTOOSHORT             2006
#define IDS_ERR_ROWSETRELEASED          2007
#define IDS_ERR_RESTARTPOSFAILED        2008
#define IDS_ERR_CREATEACCESSORFAILED    2009
#define IDS_ERR_GETNEXTROWSFAILED       2010
#define IDS_ERR_GETDATAFAILED           2011
#define IDS_ERR_RESYNCHFAILED           2012
#define IDS_ERR_INVALIDBMSTATUS			2013
#define IDS_ERR_BADFETCHINFO			2014
#define IDS_ERR_GETROWSATFAILED			2015
#define IDS_ERR_UPDATEINPROGRESS        2016
#define IDS_ERR_SCROLLFAILED            2017
#define IDS_ERR_GETAPPROXPOSFAILED      2018
#define IDS_ERR_INVALIDSEEKFLAGS		2019
#define IDS_ERR_FINDFAILED              2020
#define IDS_ERR_BADFRACTION             2021
#define IDS_ERR_DELETEDROW              2022
#define IDS_ERR_ACTIONCANCELLED         2023
#define IDS_ERR_DELETEROWSFAILED        2024
#define IDS_ERR_STATEERROR              2025
#define IDS_ERR_INSERTROWFAILED         2026
#define IDS_ERR_UNDOFAILED              2027
#define IDS_ERR_SETDATAFAILED           2028
#define IDS_ERR_BADENTRYID              2029
#define IDS_ERR_GETROWSBYBOOKMARKFAILED 2030
#define IDS_ERR_CLONEFAILED             2031
#define IDS_ERR_STATFAILED              2032

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        132
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2c\versstr.h ===
//----------------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       versstr.h
//
//  Contents:   Defines required for Mac & Win Version resource for Forms3 components.
//
//----------------------------------------------------------------------------

#include "version.h"

// The following hack to build both the file version stamps
// from the same data was stolen from DART,
#if (rmm < 10)
#define rmmpad "0"
#else
#define rmmpad
#endif

#define _RELEASE_BUILD 1

#if defined(_RELEASE_BUILD) && DBG == 0
#define VER_STR1(a,b,c)     #a ".0"
#else
#  if defined(VER_ASYCPICT_FORMAT)
#define VER_STR1(a,b,c)     #a "." rmmpad #b "." #c ".0"
#  else
#define VER_STR1(a,b,c)     #a ".00." rmmpad #b "." #c
#  endif
#endif

#if defined(VER_ASYCPICT_FORMAT)
#define VER_VERSION         rmj, rmm, rup, 0
#else
#define VER_VERSION         rmj, 0, rmm, rup
#endif

#define VER_STR2(a,b,c)     VER_STR1(a,b,c)

#define VER_VERSION_STR     VER_STR2(rmj,rmm,rup)
#define VER_COMMENT         szVerName

#ifdef VER_PRIVATE_BUILD_STR
#define VER_PRIVATE_BUILD_FLG   VS_FF_PRIVATEBUILD | VS_FF_SPECIALBUILD
#else
#define VER_PRIVATE_BUILD_FLG   0
#endif

#if DBG==1
#define VER_DEBUG_BUILD_FLG     VS_FF_DEBUG
#else
#define VER_DEBUG_BUILD_FLG     0
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\datacab\viaduct\msr2cenu\versstr.h ===
//----------------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       versstr.h
//
//  Contents:   Defines required for Mac & Win Version resource for Forms3 components.
//
//----------------------------------------------------------------------------

#include "version.h"

// The following hack to build both the file version stamps
// from the same data was stolen from DART,
#if (rmm < 10)
#define rmmpad "0"
#else
#define rmmpad
#endif

#define _RELEASE_BUILD 1

#if defined(_RELEASE_BUILD) && DBG == 0
#define VER_STR1(a,b,c)     #a ".0"
#else
#  if defined(VER_ASYCPICT_FORMAT)
#define VER_STR1(a,b,c)     #a "." rmmpad #b "." #c ".0"
#  else
#define VER_STR1(a,b,c)     #a ".00." rmmpad #b "." #c
#  endif
#endif

#if defined(VER_ASYCPICT_FORMAT)
#define VER_VERSION         rmj, rmm, rup, 0
#else
#define VER_VERSION         rmj, 0, rmm, rup
#endif

#define VER_STR2(a,b,c)     VER_STR1(a,b,c)

#define VER_VERSION_STR     VER_STR2(rmj,rmm,rup)
#define VER_COMMENT         szVerName

#ifdef VER_PRIVATE_BUILD_STR
#define VER_PRIVATE_BUILD_FLG   VS_FF_PRIVATEBUILD | VS_FF_SPECIALBUILD
#else
#define VER_PRIVATE_BUILD_FLG   0
#endif

#if DBG==1
#define VER_DEBUG_BUILD_FLG     VS_FF_DEBUG
#else
#define VER_DEBUG_BUILD_FLG     0
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\digest\afxres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRES_H__
#define __AFXRES_H__

#ifdef REZ  // Mac resource compiler (mrc) defines REZ
#define RC_INVOKED
#endif

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS
	#include "winres.h"           // extract from windows header
#endif
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// MFC resource types (see Technical note TN024 for implementation details)

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCE(240)
#define RT_TOOLBAR  MAKEINTRESOURCE(241)
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// General style bits etc

// Tab Control styles
#ifndef TCS_MULTILINE // new in later versions of Win32
#define TCS_MULTILINE       0x0200
#endif

// ControlBar styles
#define CBRS_ALIGN_LEFT     0x1000L
#define CBRS_ALIGN_TOP      0x2000L
#define CBRS_ALIGN_RIGHT    0x4000L
#define CBRS_ALIGN_BOTTOM   0x8000L
#define CBRS_ALIGN_ANY      0xF000L

#define CBRS_BORDER_LEFT    0x0100L
#define CBRS_BORDER_TOP     0x0200L
#define CBRS_BORDER_RIGHT   0x0400L
#define CBRS_BORDER_BOTTOM  0x0800L
#define CBRS_BORDER_ANY     0x0F00L

#define CBRS_TOOLTIPS       0x0010L
#define CBRS_FLYBY          0x0020L
#define CBRS_FLOAT_MULTI    0x0040L
#define CBRS_BORDER_3D      0x0080L
#define CBRS_HIDE_INPLACE   0x0008L
#define CBRS_SIZE_DYNAMIC   0x0004L
#define CBRS_SIZE_FIXED     0x0002L
#define CBRS_FLOATING       0x0001L

#define CBRS_ORIENT_HORZ    (CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM)
#define CBRS_ORIENT_VERT    (CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT)
#define CBRS_ORIENT_ANY     (CBRS_ORIENT_HORZ|CBRS_ORIENT_VERT)

#define CBRS_ALL            0xFFFFL


// the CBRS_ style is made up of an alignment style and a draw border style
//  the alignment styles are mutually exclusive
//  the draw border styles may be combined
#define CBRS_NOALIGN        0x00000000L
#define CBRS_LEFT           (CBRS_ALIGN_LEFT|CBRS_BORDER_RIGHT)
#define CBRS_TOP            (CBRS_ALIGN_TOP|CBRS_BORDER_BOTTOM)
#define CBRS_RIGHT          (CBRS_ALIGN_RIGHT|CBRS_BORDER_LEFT)
#define CBRS_BOTTOM         (CBRS_ALIGN_BOTTOM|CBRS_BORDER_TOP)

/////////////////////////////////////////////////////////////////////////////
// Standard window components

// Mode indicators in status bar - these are routed like commands
#define ID_INDICATOR_EXT                0xE700  // extended selection indicator
#define ID_INDICATOR_CAPS               0xE701  // cap lock indicator
#define ID_INDICATOR_NUM                0xE702  // num lock indicator
#define ID_INDICATOR_SCRL               0xE703  // scroll lock indicator
#define ID_INDICATOR_OVR                0xE704  // overtype mode indicator
#define ID_INDICATOR_REC                0xE705  // record mode indicator
#define ID_INDICATOR_KANA               0xE706  // kana lock indicator

#define ID_SEPARATOR                    0   // special separator value

#ifndef RC_INVOKED  // code only
// Standard control bars (IDW = window ID)
#define AFX_IDW_CONTROLBAR_FIRST        0xE800
#define AFX_IDW_CONTROLBAR_LAST         0xE8FF

#define AFX_IDW_TOOLBAR                 0xE800  // main Toolbar for window
#define AFX_IDW_STATUS_BAR              0xE801  // Status bar window
#define AFX_IDW_PREVIEW_BAR             0xE802  // PrintPreview Dialog Bar
#define AFX_IDW_RESIZE_BAR              0xE803  // OLE in-place resize bar

// Note: If your application supports docking toolbars, you should
//  not use the following IDs for your own toolbars.  The IDs chosen
//  are at the top of the first 32 such that the bars will be hidden
//  while in print preview mode, and are not likely to conflict with
//  IDs your application may have used succesfully in the past.

#define AFX_IDW_DOCKBAR_TOP             0xE81B
#define AFX_IDW_DOCKBAR_LEFT            0xE81C
#define AFX_IDW_DOCKBAR_RIGHT           0xE81D
#define AFX_IDW_DOCKBAR_BOTTOM          0xE81E
#define AFX_IDW_DOCKBAR_FLOAT           0xE81F

// Macro for mapping standard control bars to bitmask (limit of 32)
#define AFX_CONTROLBAR_MASK(nIDC)   (1L << (nIDC - AFX_IDW_CONTROLBAR_FIRST))

// parts of Main Frame
#define AFX_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define AFX_IDW_PANE_LAST               0xE9ff
#define AFX_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define AFX_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define AFX_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define AFX_IDW_PANE_SAVE               0xEA21  // to shift AFX_IDW_PANE_FIRST
#endif //!RC_INVOKED

#ifndef APSTUDIO_INVOKED

// common style for form views
#define AFX_WS_DEFAULT_VIEW             (WS_CHILD | WS_VISIBLE | WS_BORDER)

#endif //!APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard app configurable strings

// for application title (defaults to EXE name or name in constructor)
#define AFX_IDS_APP_TITLE               0xE000
// idle message bar line
#define AFX_IDS_IDLEMESSAGE             0xE001
// message bar line when in shift-F1 help mode
#define AFX_IDS_HELPMODEMESSAGE         0xE002
// document title when editing OLE embedding
#define AFX_IDS_APP_TITLE_EMBEDDING     0xE003
// company name
#define AFX_IDS_COMPANY_NAME            0xE004
// object name when server is inplace
#define AFX_IDS_OBJ_TITLE_INPLACE       0xE005

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C

#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define AFX_IDM_WINDOW_FIRST            0xE130
#define AFX_IDM_WINDOW_LAST             0xE13F
#define AFX_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151

// Format
#define ID_FORMAT_FONT                  0xE160

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

// for print preview dialog bar
#define AFX_ID_PREVIEW_CLOSE            0xE300
#define AFX_ID_PREVIEW_NUMPAGE          0xE301      // One/Two Page button
#define AFX_ID_PREVIEW_NEXT             0xE302
#define AFX_ID_PREVIEW_PREV             0xE303
#define AFX_ID_PREVIEW_PRINT            0xE304
#define AFX_ID_PREVIEW_ZOOMIN           0xE305
#define AFX_ID_PREVIEW_ZOOMOUT          0xE306

// View commands (same number used as IDW used for control bar)
#define ID_VIEW_TOOLBAR                 0xE800
#define ID_VIEW_STATUS_BAR              0xE801
	// -> E8FF reserved for other control bar commands

// RecordForm commands
#define ID_RECORD_FIRST                 0xE900
#define ID_RECORD_LAST                  0xE901
#define ID_RECORD_NEXT                  0xE902
#define ID_RECORD_PREV                  0xE903

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

#ifndef RC_INVOKED      // code only
#define AFX_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define AFX_IDS_SCSIZE                  0xEF00
#define AFX_IDS_SCMOVE                  0xEF01
#define AFX_IDS_SCMINIMIZE              0xEF02
#define AFX_IDS_SCMAXIMIZE              0xEF03
#define AFX_IDS_SCNEXTWINDOW            0xEF04
#define AFX_IDS_SCPREVWINDOW            0xEF05
#define AFX_IDS_SCCLOSE                 0xEF06
#define AFX_IDS_SCRESTORE               0xEF12
#define AFX_IDS_SCTASKLIST              0xEF13

#define AFX_IDS_MDICHILD                0xEF1F

#define AFX_IDS_DESKACCESSORY           0xEFDA

// General strings
#define AFX_IDS_OPENFILE                0xF000
#define AFX_IDS_SAVEFILE                0xF001
#define AFX_IDS_ALLFILTER               0xF002
#define AFX_IDS_UNTITLED                0xF003
#define AFX_IDS_SAVEFILECOPY            0xF004
#define AFX_IDS_PREVIEW_CLOSE           0xF005
#define AFX_IDS_UNNAMED_FILE            0xF006
#ifdef _MAC
#define AFX_IDS_ABOUT                   0xF010
#endif
#define AFX_IDS_HIDE                    0xF011

// MFC Standard Exception Error messages
#define AFX_IDP_NO_ERROR_AVAILABLE      0xF020
#define AFX_IDS_NOT_SUPPORTED_EXCEPTION 0xF021
#define AFX_IDS_RESOURCE_EXCEPTION      0xF022
#define AFX_IDS_MEMORY_EXCEPTION        0xF023
#define AFX_IDS_USER_EXCEPTION          0xF024

// Printing and print preview strings
#define AFX_IDS_PRINTONPORT             0xF040
#define AFX_IDS_ONEPAGE                 0xF041
#define AFX_IDS_TWOPAGE                 0xF042
#define AFX_IDS_PRINTPAGENUM            0xF043
#define AFX_IDS_PREVIEWPAGEDESC         0xF044
#define AFX_IDS_PRINTDEFAULTEXT         0xF045
#define AFX_IDS_PRINTDEFAULT            0xF046
#define AFX_IDS_PRINTFILTER             0xF047
#define AFX_IDS_PRINTCAPTION            0xF048
#define AFX_IDS_PRINTTOFILE             0xF049


// OLE strings
#define AFX_IDS_OBJECT_MENUITEM         0xF080
#define AFX_IDS_EDIT_VERB               0xF081
#define AFX_IDS_ACTIVATE_VERB           0xF082
#define AFX_IDS_CHANGE_LINK             0xF083
#define AFX_IDS_AUTO                    0xF084
#define AFX_IDS_MANUAL                  0xF085
#define AFX_IDS_FROZEN                  0xF086
#define AFX_IDS_ALL_FILES               0xF087
// dynamically changing menu items
#define AFX_IDS_SAVE_MENU               0xF088
#define AFX_IDS_UPDATE_MENU             0xF089
#define AFX_IDS_SAVE_AS_MENU            0xF08A
#define AFX_IDS_SAVE_COPY_AS_MENU       0xF08B
#define AFX_IDS_EXIT_MENU               0xF08C
#define AFX_IDS_UPDATING_ITEMS          0xF08D
// COlePasteSpecialDialog defines
#define AFX_IDS_METAFILE_FORMAT         0xF08E
#define AFX_IDS_DIB_FORMAT              0xF08F
#define AFX_IDS_BITMAP_FORMAT           0xF090
#define AFX_IDS_LINKSOURCE_FORMAT       0xF091
#define AFX_IDS_EMBED_FORMAT            0xF092
// other OLE utility strings
#define AFX_IDS_PASTELINKEDTYPE         0xF094
#define AFX_IDS_UNKNOWNTYPE             0xF095
#define AFX_IDS_RTF_FORMAT              0xF096
#define AFX_IDS_TEXT_FORMAT             0xF097
// OLE datatype format error strings
#define AFX_IDS_INVALID_CURRENCY        0xF098
#define AFX_IDS_INVALID_DATETIME        0xF099
#define AFX_IDS_INVALID_DATETIMESPAN    0xF09A

// General error / prompt strings
#define AFX_IDP_INVALID_FILENAME        0xF100
#define AFX_IDP_FAILED_TO_OPEN_DOC      0xF101
#define AFX_IDP_FAILED_TO_SAVE_DOC      0xF102
#define AFX_IDP_ASK_TO_SAVE             0xF103
#define AFX_IDP_FAILED_TO_CREATE_DOC    0xF104
#define AFX_IDP_FILE_TOO_LARGE          0xF105
#define AFX_IDP_FAILED_TO_START_PRINT   0xF106
#define AFX_IDP_FAILED_TO_LAUNCH_HELP   0xF107
#define AFX_IDP_INTERNAL_FAILURE        0xF108      // general failure
#define AFX_IDP_COMMAND_FAILURE         0xF109      // command failure
#define AFX_IDP_FAILED_MEMORY_ALLOC     0xF10A

// DDV parse errors
#define AFX_IDP_PARSE_INT               0xF110
#define AFX_IDP_PARSE_REAL              0xF111
#define AFX_IDP_PARSE_INT_RANGE         0xF112
#define AFX_IDP_PARSE_REAL_RANGE        0xF113
#define AFX_IDP_PARSE_STRING_SIZE       0xF114
#define AFX_IDP_PARSE_RADIO_BUTTON      0xF115
#define AFX_IDP_PARSE_BYTE              0xF116
#define AFX_IDP_PARSE_UINT              0xF117
#define AFX_IDP_PARSE_DATETIME          0xF118
#define AFX_IDP_PARSE_CURRENCY          0xF119

// CFile/CArchive error strings for user failure
#define AFX_IDP_FAILED_INVALID_FORMAT   0xF120
#define AFX_IDP_FAILED_INVALID_PATH     0xF121
#define AFX_IDP_FAILED_DISK_FULL        0xF122
#define AFX_IDP_FAILED_ACCESS_READ      0xF123
#define AFX_IDP_FAILED_ACCESS_WRITE     0xF124
#define AFX_IDP_FAILED_IO_ERROR_READ    0xF125
#define AFX_IDP_FAILED_IO_ERROR_WRITE   0xF126

// OLE errors / prompt strings
#define AFX_IDP_STATIC_OBJECT           0xF180
#define AFX_IDP_FAILED_TO_CONNECT       0xF181
#define AFX_IDP_SERVER_BUSY             0xF182
#define AFX_IDP_BAD_VERB                0xF183
#define AFX_IDP_FAILED_TO_NOTIFY        0xF185
#define AFX_IDP_FAILED_TO_LAUNCH        0xF186
#define AFX_IDP_ASK_TO_UPDATE           0xF187
#define AFX_IDP_FAILED_TO_UPDATE        0xF188
#define AFX_IDP_FAILED_TO_REGISTER      0xF189
#define AFX_IDP_FAILED_TO_AUTO_REGISTER 0xF18A
#define AFX_IDP_FAILED_TO_CONVERT       0xF18B
#define AFX_IDP_GET_NOT_SUPPORTED       0xF18C
#define AFX_IDP_SET_NOT_SUPPORTED       0xF18D
#define AFX_IDP_ASK_TO_DISCARD          0xF18E
#define AFX_IDP_FAILED_TO_CREATE        0xF18F

// MAPI errors / prompt strings
#define AFX_IDP_FAILED_MAPI_LOAD        0xF190
#define AFX_IDP_INVALID_MAPI_DLL        0xF191
#define AFX_IDP_FAILED_MAPI_SEND        0xF192

#define AFX_IDP_FILE_NONE               0xF1A0
#define AFX_IDP_FILE_GENERIC            0xF1A1
#define AFX_IDP_FILE_NOT_FOUND          0xF1A2
#define AFX_IDP_FILE_BAD_PATH           0xF1A3
#define AFX_IDP_FILE_TOO_MANY_OPEN      0xF1A4
#define AFX_IDP_FILE_ACCESS_DENIED      0xF1A5
#define AFX_IDP_FILE_INVALID_FILE       0xF1A6
#define AFX_IDP_FILE_REMOVE_CURRENT     0xF1A7
#define AFX_IDP_FILE_DIR_FULL           0xF1A8
#define AFX_IDP_FILE_BAD_SEEK           0xF1A9
#define AFX_IDP_FILE_HARD_IO            0xF1AA
#define AFX_IDP_FILE_SHARING            0xF1AB
#define AFX_IDP_FILE_LOCKING            0xF1AC
#define AFX_IDP_FILE_DISKFULL           0xF1AD
#define AFX_IDP_FILE_EOF                0xF1AE

#define AFX_IDP_ARCH_NONE               0xF1B0
#define AFX_IDP_ARCH_GENERIC            0xF1B1
#define AFX_IDP_ARCH_READONLY           0xF1B2
#define AFX_IDP_ARCH_ENDOFFILE          0xF1B3
#define AFX_IDP_ARCH_WRITEONLY          0xF1B4
#define AFX_IDP_ARCH_BADINDEX           0xF1B5
#define AFX_IDP_ARCH_BADCLASS           0xF1B6
#define AFX_IDP_ARCH_BADSCHEMA          0xF1B7

#define AFX_IDS_OCC_SCALEUNITS_PIXELS   0xF1C0

// 0xf200-0xf20f reserved

// font names and point sizes
#define AFX_IDS_STATUS_FONT             0xF230
#define AFX_IDS_TOOLTIP_FONT            0xF231
#define AFX_IDS_UNICODE_FONT            0xF232
#define AFX_IDS_MINI_FONT               0xF233

// ODBC Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_SQL_FIRST                       0xF280
#endif //!RC_INVOKED
#define AFX_IDP_SQL_CONNECT_FAIL                0xF281
#define AFX_IDP_SQL_RECORDSET_FORWARD_ONLY      0xF282
#define AFX_IDP_SQL_EMPTY_COLUMN_LIST           0xF283
#define AFX_IDP_SQL_FIELD_SCHEMA_MISMATCH       0xF284
#define AFX_IDP_SQL_ILLEGAL_MODE                0xF285
#define AFX_IDP_SQL_MULTIPLE_ROWS_AFFECTED      0xF286
#define AFX_IDP_SQL_NO_CURRENT_RECORD           0xF287
#define AFX_IDP_SQL_NO_ROWS_AFFECTED            0xF288
#define AFX_IDP_SQL_RECORDSET_READONLY          0xF289
#define AFX_IDP_SQL_SQL_NO_TOTAL                0xF28A
#define AFX_IDP_SQL_ODBC_LOAD_FAILED            0xF28B
#define AFX_IDP_SQL_DYNASET_NOT_SUPPORTED       0xF28C
#define AFX_IDP_SQL_SNAPSHOT_NOT_SUPPORTED      0xF28D
#define AFX_IDP_SQL_API_CONFORMANCE             0xF28E
#define AFX_IDP_SQL_SQL_CONFORMANCE             0xF28F
#define AFX_IDP_SQL_NO_DATA_FOUND               0xF290
#define AFX_IDP_SQL_ROW_UPDATE_NOT_SUPPORTED    0xF291
#define AFX_IDP_SQL_ODBC_V2_REQUIRED            0xF292
#define AFX_IDP_SQL_NO_POSITIONED_UPDATES       0xF293
#define AFX_IDP_SQL_LOCK_MODE_NOT_SUPPORTED     0xF294
#define AFX_IDP_SQL_DATA_TRUNCATED              0xF295
#define AFX_IDP_SQL_ROW_FETCH                   0xF296
#define AFX_IDP_SQL_INCORRECT_ODBC              0xF297
#define AFX_IDP_SQL_UPDATE_DELETE_FAILED        0xF298
#define AFX_IDP_SQL_DYNAMIC_CURSOR_NOT_SUPPORTED    0xF299

// DAO Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_DAO_FIRST                       0xF2A0
#endif //!RC_INVOKED
#define AFX_IDP_DAO_ENGINE_INITIALIZATION       0xF2A0
#define AFX_IDP_DAO_DFX_BIND                    0xF2A1
#define AFX_IDP_DAO_OBJECT_NOT_OPEN             0xF2A2

// ICDAORecordset::GetRows Errors
//  These are not placed in DAO Errors collection
//  and must be handled directly by MFC.
#define AFX_IDP_DAO_ROWTOOSHORT                 0xF2A3
#define AFX_IDP_DAO_BADBINDINFO                 0xF2A4
#define AFX_IDP_DAO_COLUMNUNAVAILABLE           0xF2A5

/////////////////////////////////////////////////////////////////////////////
// AFX implementation - control IDs (AFX_IDC)

// Parts of dialogs
#define AFX_IDC_LISTBOX                 100
#define AFX_IDC_CHANGE                  101

// for print dialog
#define AFX_IDC_PRINT_DOCNAME           201
#define AFX_IDC_PRINT_PRINTERNAME       202
#define AFX_IDC_PRINT_PORTNAME          203
#define AFX_IDC_PRINT_PAGENUM           204

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define AFX_IDC_TAB_CONTROL             0x3020

/////////////////////////////////////////////////////////////////////////////
// IDRs for standard components

#ifndef RC_INVOKED  // code only
// These are really COMMDLG dialogs, so there usually isn't a resource
// for them, but these IDs are used as help IDs.
#define AFX_IDD_FILEOPEN                28676
#define AFX_IDD_FILESAVE                28677
#define AFX_IDD_FONT                    28678
#define AFX_IDD_COLOR                   28679
#define AFX_IDD_PRINT                   28680
#define AFX_IDD_PRINTSETUP              28681
#define AFX_IDD_FIND                    28682
#define AFX_IDD_REPLACE                 28683
#endif //!RC_INVOKED

// Standard dialogs app should leave alone (0x7801->)
#define AFX_IDD_NEWTYPEDLG              30721
#define AFX_IDD_PRINTDLG                30722
#define AFX_IDD_PREVIEW_TOOLBAR         30723
#ifdef _MAC
#define AFX_IDD_PREVIEW_SHORTTOOLBAR    30731
#endif

// Dialogs defined for OLE2UI library
#define AFX_IDD_INSERTOBJECT            30724
#define AFX_IDD_CHANGEICON              30725
#define AFX_IDD_CONVERT                 30726
#define AFX_IDD_PASTESPECIAL            30727
#define AFX_IDD_EDITLINKS               30728
#define AFX_IDD_FILEBROWSE              30729
#define AFX_IDD_BUSY                    30730

#define AFX_IDD_OBJECTPROPERTIES        30732
#define AFX_IDD_CHANGESOURCE            30733

// Standard cursors (0x7901->)
	// AFX_IDC = Cursor resources
#define AFX_IDC_CONTEXTHELP             30977       // context sensitive help
#define AFX_IDC_MAGNIFY                 30978       // print preview zoom
#define AFX_IDC_SMALLARROWS             30979       // splitter
#define AFX_IDC_HSPLITBAR               30980       // splitter
#define AFX_IDC_VSPLITBAR               30981       // splitter
#define AFX_IDC_NODROPCRSR              30982       // No Drop Cursor
#define AFX_IDC_TRACKNWSE               30983       // tracker
#define AFX_IDC_TRACKNESW               30984       // tracker
#define AFX_IDC_TRACKNS                 30985       // tracker
#define AFX_IDC_TRACKWE                 30986       // tracker
#define AFX_IDC_TRACK4WAY               30987       // tracker
#define AFX_IDC_MOVE4WAY                30988       // resize bar (server only)

// Mini frame window bitmap ID
#define AFX_IDB_MINIFRAME_MENU          30994

// CheckListBox checks bitmap ID
#define AFX_IDB_CHECKLISTBOX_NT         30995
#define AFX_IDB_CHECKLISTBOX_95         30996

// AFX standard accelerator resources
#define AFX_IDR_PREVIEW_ACCEL           30997

// AFX standard ICON IDs (for MFC V1 apps) (0x7A01->)
#define AFX_IDI_STD_MDIFRAME            31233
#define AFX_IDI_STD_FRAME               31234

/////////////////////////////////////////////////////////////////////////////
// AFX OLE control implementation - control IDs (AFX_IDC)

// Font property page
#define AFX_IDC_FONTPROP                1000
#define AFX_IDC_FONTNAMES               1001
#define AFX_IDC_FONTSTYLES              1002
#define AFX_IDC_FONTSIZES               1003
#define AFX_IDC_STRIKEOUT               1004
#define AFX_IDC_UNDERLINE               1005
#define AFX_IDC_SAMPLEBOX               1006

// Color property page
#define AFX_IDC_COLOR_BLACK             1100
#define AFX_IDC_COLOR_WHITE             1101
#define AFX_IDC_COLOR_RED               1102
#define AFX_IDC_COLOR_GREEN             1103
#define AFX_IDC_COLOR_BLUE              1104
#define AFX_IDC_COLOR_YELLOW            1105
#define AFX_IDC_COLOR_MAGENTA           1106
#define AFX_IDC_COLOR_CYAN              1107
#define AFX_IDC_COLOR_GRAY              1108
#define AFX_IDC_COLOR_LIGHTGRAY         1109
#define AFX_IDC_COLOR_DARKRED           1110
#define AFX_IDC_COLOR_DARKGREEN         1111
#define AFX_IDC_COLOR_DARKBLUE          1112
#define AFX_IDC_COLOR_LIGHTBROWN        1113
#define AFX_IDC_COLOR_DARKMAGENTA       1114
#define AFX_IDC_COLOR_DARKCYAN          1115
#define AFX_IDC_COLORPROP               1116
#define AFX_IDC_SYSTEMCOLORS            1117

// Picture porperty page
#define AFX_IDC_PROPNAME                1201
#define AFX_IDC_PICTURE                 1202
#define AFX_IDC_BROWSE                  1203
#define AFX_IDC_CLEAR                   1204

/////////////////////////////////////////////////////////////////////////////
// IDRs for OLE control standard components

// Standard propery page dialogs app should leave alone (0x7E01->)
#define AFX_IDD_PROPPAGE_COLOR         32257
#define AFX_IDD_PROPPAGE_FONT          32258
#define AFX_IDD_PROPPAGE_PICTURE       32259

#define AFX_IDB_TRUETYPE               32384

/////////////////////////////////////////////////////////////////////////////
// Standard OLE control strings

// OLE Control page strings
#define AFX_IDS_PROPPAGE_UNKNOWN        0xFE01
#define AFX_IDS_COLOR_DESKTOP           0xFE04
#define AFX_IDS_COLOR_APPWORKSPACE      0xFE05
#define AFX_IDS_COLOR_WNDBACKGND        0xFE06
#define AFX_IDS_COLOR_WNDTEXT           0xFE07
#define AFX_IDS_COLOR_MENUBAR           0xFE08
#define AFX_IDS_COLOR_MENUTEXT          0xFE09
#define AFX_IDS_COLOR_ACTIVEBAR         0xFE0A
#define AFX_IDS_COLOR_INACTIVEBAR       0xFE0B
#define AFX_IDS_COLOR_ACTIVETEXT        0xFE0C
#define AFX_IDS_COLOR_INACTIVETEXT      0xFE0D
#define AFX_IDS_COLOR_ACTIVEBORDER      0xFE0E
#define AFX_IDS_COLOR_INACTIVEBORDER    0xFE0F
#define AFX_IDS_COLOR_WNDFRAME          0xFE10
#define AFX_IDS_COLOR_SCROLLBARS        0xFE11
#define AFX_IDS_COLOR_BTNFACE           0xFE12
#define AFX_IDS_COLOR_BTNSHADOW         0xFE13
#define AFX_IDS_COLOR_BTNTEXT           0xFE14
#define AFX_IDS_COLOR_BTNHIGHLIGHT      0xFE15
#define AFX_IDS_COLOR_DISABLEDTEXT      0xFE16
#define AFX_IDS_COLOR_HIGHLIGHT         0xFE17
#define AFX_IDS_COLOR_HIGHLIGHTTEXT     0xFE18
#define AFX_IDS_REGULAR                 0xFE19
#define AFX_IDS_BOLD                    0xFE1A
#define AFX_IDS_ITALIC                  0xFE1B
#define AFX_IDS_BOLDITALIC              0xFE1C
#define AFX_IDS_SAMPLETEXT              0xFE1D
#define AFX_IDS_DISPLAYSTRING_FONT      0xFE1E
#define AFX_IDS_DISPLAYSTRING_COLOR     0xFE1F
#define AFX_IDS_DISPLAYSTRING_PICTURE   0xFE20
#define AFX_IDS_PICTUREFILTER           0xFE21
#define AFX_IDS_PICTYPE_UNKNOWN         0xFE22
#define AFX_IDS_PICTYPE_NONE            0xFE23
#define AFX_IDS_PICTYPE_BITMAP          0xFE24
#define AFX_IDS_PICTYPE_METAFILE        0xFE25
#define AFX_IDS_PICTYPE_ICON            0xFE26
#define AFX_IDS_COLOR_PPG               0xFE28
#define AFX_IDS_COLOR_PPG_CAPTION       0xFE29
#define AFX_IDS_FONT_PPG                0xFE2A
#define AFX_IDS_FONT_PPG_CAPTION        0xFE2B
#define AFX_IDS_PICTURE_PPG             0xFE2C
#define AFX_IDS_PICTURE_PPG_CAPTION     0xFE2D
#define AFX_IDS_PICTUREBROWSETITLE      0xFE30
#define AFX_IDS_BORDERSTYLE_0           0xFE31
#define AFX_IDS_BORDERSTYLE_1           0xFE32

// OLE Control verb names
#define AFX_IDS_VERB_EDIT               0xFE40
#define AFX_IDS_VERB_PROPERTIES         0xFE41

// OLE Control internal error messages
#define AFX_IDP_PICTURECANTOPEN         0xFE83
#define AFX_IDP_PICTURECANTLOAD         0xFE84
#define AFX_IDP_PICTURETOOLARGE         0xFE85
#define AFX_IDP_PICTUREREADFAILED       0xFE86

// Standard OLE Control error strings
#define AFX_IDP_E_ILLEGALFUNCTIONCALL       0xFEA0
#define AFX_IDP_E_OVERFLOW                  0xFEA1
#define AFX_IDP_E_OUTOFMEMORY               0xFEA2
#define AFX_IDP_E_DIVISIONBYZERO            0xFEA3
#define AFX_IDP_E_OUTOFSTRINGSPACE          0xFEA4
#define AFX_IDP_E_OUTOFSTACKSPACE           0xFEA5
#define AFX_IDP_E_BADFILENAMEORNUMBER       0xFEA6
#define AFX_IDP_E_FILENOTFOUND              0xFEA7
#define AFX_IDP_E_BADFILEMODE               0xFEA8
#define AFX_IDP_E_FILEALREADYOPEN           0xFEA9
#define AFX_IDP_E_DEVICEIOERROR             0xFEAA
#define AFX_IDP_E_FILEALREADYEXISTS         0xFEAB
#define AFX_IDP_E_BADRECORDLENGTH           0xFEAC
#define AFX_IDP_E_DISKFULL                  0xFEAD
#define AFX_IDP_E_BADRECORDNUMBER           0xFEAE
#define AFX_IDP_E_BADFILENAME               0xFEAF
#define AFX_IDP_E_TOOMANYFILES              0xFEB0
#define AFX_IDP_E_DEVICEUNAVAILABLE         0xFEB1
#define AFX_IDP_E_PERMISSIONDENIED          0xFEB2
#define AFX_IDP_E_DISKNOTREADY              0xFEB3
#define AFX_IDP_E_PATHFILEACCESSERROR       0xFEB4
#define AFX_IDP_E_PATHNOTFOUND              0xFEB5
#define AFX_IDP_E_INVALIDPATTERNSTRING      0xFEB6
#define AFX_IDP_E_INVALIDUSEOFNULL          0xFEB7
#define AFX_IDP_E_INVALIDFILEFORMAT         0xFEB8
#define AFX_IDP_E_INVALIDPROPERTYVALUE      0xFEB9
#define AFX_IDP_E_INVALIDPROPERTYARRAYINDEX 0xFEBA
#define AFX_IDP_E_SETNOTSUPPORTEDATRUNTIME  0xFEBB
#define AFX_IDP_E_SETNOTSUPPORTED           0xFEBC
#define AFX_IDP_E_NEEDPROPERTYARRAYINDEX    0xFEBD
#define AFX_IDP_E_SETNOTPERMITTED           0xFEBE
#define AFX_IDP_E_GETNOTSUPPORTEDATRUNTIME  0xFEBF
#define AFX_IDP_E_GETNOTSUPPORTED           0xFEC0
#define AFX_IDP_E_PROPERTYNOTFOUND          0xFEC1
#define AFX_IDP_E_INVALIDCLIPBOARDFORMAT    0xFEC2
#define AFX_IDP_E_INVALIDPICTURE            0xFEC3
#define AFX_IDP_E_PRINTERERROR              0xFEC4
#define AFX_IDP_E_CANTSAVEFILETOTEMP        0xFEC5
#define AFX_IDP_E_SEARCHTEXTNOTFOUND        0xFEC6
#define AFX_IDP_E_REPLACEMENTSTOOLONG       0xFEC7

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\digest\digest.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    digest.cxx

Abstract:

    Parses http digest challenges and generates http digest
    authorization headers for digest sspi package.

Author:

    Adriaan Canter (adriaanc) 01-Aug-1998

--*/
#include "include.hxx"


// HTTP related defines
#define HEADER_IDX          0
#define REALM_IDX           1
#define HOST_IDX            2
#define URL_IDX             3
#define METHOD_IDX          4
#define USER_IDX            5
#define PASS_IDX            6
#define NONCE_IDX           7
#define NC_IDX              8
#define HWND_IDX            9
#define NUM_BUFF            10

// POP related defines.
#define POP_USER_IDX             1
#define POP_PASS_IDX             2
#define NUM_EXTENDED_POP_BUFFERS 3

// Used for generating response line.
#define FLAG_QUOTE          0x1
#define FLAG_TERMINATE      0x2

//--------------------------------------------------------------------
// CDigest:: ToHex
//
// Routine Description:
// 
// Convert binary data to ASCII hex representation
//
// Arguments:
//
//  pSrc - binary data to convert
//  cSrc - length of binary data
//  pDst - buffer receiving ASCII representation of pSrc
//
//--------------------------------------------------------------------
VOID CDigest::ToHex(LPBYTE pSrc, UINT   cSrc, LPSTR  pDst)
{
    UINT x;
    UINT y;

// BUGBUG - character case issue ?
#define TOHEX(a) ((a)>=10 ? 'a'+(a)-10 : '0'+(a))

    for ( x = 0, y = 0 ; x < cSrc ; ++x )
    {
        UINT v;
        v = pSrc[x]>>4;
        pDst[y++] = TOHEX( v );
        v = pSrc[x]&0x0f;
        pDst[y++] = TOHEX( v );
    }
    pDst[y] = '\0';
}

//--------------------------------------------------------------------
// AddDigestHeader
//--------------------------------------------------------------------
BOOL AddDigestHeader(LPSTR szHeader, LPDWORD pcbHeader, 
                     LPSTR szValue, LPSTR szData,  
                     DWORD cbAlloced, DWORD dwFlags)
{
    DWORD cbValue, cbData, cbRequired;
    
    cbValue = strlen(szValue);
    cbData = strlen(szData);

    cbRequired = *pcbHeader 
        + cbValue + cbData + sizeof('=') + 2 * sizeof('\"') + sizeof(", ") - 1;

    if (cbRequired > cbAlloced)
        return FALSE;

    memcpy(szHeader + *pcbHeader, szValue, cbValue);
    (*pcbHeader) += cbValue;

    memcpy(szHeader + *pcbHeader, "=", sizeof('='));
    (*pcbHeader) += sizeof('=');

    if (dwFlags & FLAG_QUOTE)
    {
        memcpy(szHeader + *pcbHeader, "\"", sizeof('\"'));
        (*pcbHeader) += sizeof('\"');
    }

    memcpy(szHeader + *pcbHeader, szData, cbData);
    (*pcbHeader) += cbData;

    if (dwFlags & FLAG_QUOTE)
    {
        memcpy(szHeader + *pcbHeader, "\"", sizeof('\"'));
        (*pcbHeader) += sizeof('\"');
    }

    if (!(dwFlags & FLAG_TERMINATE))
    {
         memcpy(szHeader + *pcbHeader, ", ", sizeof(", "));
        (*pcbHeader) += (sizeof(", ") - 1);
    }
    else     
    {
        *(szHeader + *pcbHeader) = '\0';
    }
    return TRUE;
}




//--------------------------------------------------------------------
// CDigest::CDigest()
//--------------------------------------------------------------------
CDigest::CDigest()
{}


//--------------------------------------------------------------------
// CDigest::MakeCNonce
//--------------------------------------------------------------------
LPSTR CDigest::MakeCNonce()
{
    DWORD        dwRand;
    static DWORD dwCounter;
    LPSTR        szCNonce; 

    szCNonce = new CHAR[SIZE_MD5_DIGEST+1];
    if (!szCNonce)
    {
        DIGEST_ASSERT(FALSE);
        return NULL;
    }

    dwRand = (GetTickCount() * rand()) + dwCounter++;

    MD5_CTX md5ctx;
    MD5Init  (&md5ctx);
    MD5Update(&md5ctx, (LPBYTE) &dwRand, sizeof(DWORD));
    MD5Final (&md5ctx);    

    ToHex(md5ctx.digest, sizeof(md5ctx.digest), szCNonce);

    return szCNonce;
}


//--------------------------------------------------------------------
// CDigest::ParseChallenge
//--------------------------------------------------------------------
DWORD CDigest::ParseChallenge(CSess * pSess, PSecBufferDesc pSecBufDesc, 
    CParams **ppParams, DWORD fContextReq)
{
    // SecBufferDesc looks like
    //
    // [ulversion][cbuffers][pbuffers]
    //                             |
    //  --------------------------
    //  |
    //  |--> [cbBuffer][buffertype][lpvoid][cbBuffer]...
    //

    DWORD cbQop, cbAlgo, dwError = ERROR_SUCCESS;
    CHAR *szQop, *szAlgo, *ptr;

    HWND *phWnd;
    LPDWORD pcNC;
    LPSTR szHeader, szRealm, szHost, szUrl,
          szMethod, szUser,  szPass, szNonce;
    
    BOOL fPreAuth = FALSE, fCredsSupplied = FALSE;

    // Identify buffer components.

    // Legacy client.
    if (!pSess->fHTTP)
    {
        szHeader    = (LPSTR) pSecBufDesc->pBuffers[HEADER_IDX].pvBuffer;
        szRealm     = NULL;
        szHost      = "";
        szUrl       = "";
        szMethod    = "AUTHENTICATE";

        if (pSecBufDesc->cBuffers == NUM_EXTENDED_POP_BUFFERS)
            szUser = (LPSTR) pSecBufDesc->pBuffers[POP_USER_IDX].pvBuffer;
        else
            szUser = NULL;

        if (pSecBufDesc->cBuffers == NUM_EXTENDED_POP_BUFFERS)
            szPass = (LPSTR) pSecBufDesc->pBuffers  [POP_PASS_IDX].pvBuffer;
        else
            szPass = NULL;
            
        szNonce     = NULL;
        phWnd       = NULL;        
    }
    // Current client. Leave room for extra
    // param (pRequest).
    else if (pSess->fHTTP 
        && (pSecBufDesc->cBuffers == NUM_BUFF
            || pSecBufDesc->cBuffers == NUM_BUFF+1))
    {
        szHeader    = (LPSTR) pSecBufDesc->pBuffers[HEADER_IDX].pvBuffer;
        szRealm     = (LPSTR) pSecBufDesc->pBuffers [REALM_IDX].pvBuffer;
        szHost      = (LPSTR) pSecBufDesc->pBuffers  [HOST_IDX].pvBuffer;
        szUrl       = (LPSTR) pSecBufDesc->pBuffers   [URL_IDX].pvBuffer;
        szMethod    = (LPSTR) pSecBufDesc->pBuffers[METHOD_IDX].pvBuffer;
        szUser      = (LPSTR) pSecBufDesc->pBuffers  [USER_IDX].pvBuffer;
        szPass      = (LPSTR) pSecBufDesc->pBuffers  [PASS_IDX].pvBuffer;
        szNonce     = (LPSTR) pSecBufDesc->pBuffers [NONCE_IDX].pvBuffer;
        pcNC        =(DWORD*) pSecBufDesc->pBuffers [   NC_IDX].pvBuffer;
        phWnd       = (HWND*) pSecBufDesc->pBuffers  [HWND_IDX].pvBuffer; 
    }
    else
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    // Validate parameters.
    dwError = ERROR_INVALID_PARAMETER;
    if (szHost && szUrl && szMethod)
    {
        // Auth or UI prompt to challenge for any user.
        if (szHeader && !szRealm && !szUser && !szPass && !szNonce)
            dwError = ERROR_SUCCESS;

        // Auth or UI prompt to challenge for particular user.
        else if (szHeader && !szRealm && szUser && !szPass && !szNonce)
            dwError = ERROR_SUCCESS;

        // Auth to challenge with creds supplied.
        else if (szHeader && !szRealm && szUser 
            && szPass && !szNonce && (fContextReq & ISC_REQ_USE_SUPPLIED_CREDS))
        {
            fCredsSupplied = TRUE;
            dwError = ERROR_SUCCESS;
        }
        // Preauth with realm supplied for any user.
        else if (!szHeader && szRealm && !szUser && !szPass && !szNonce)
        {
            fPreAuth = TRUE;
            dwError = ERROR_SUCCESS;
        }
        
        // Preauth with realm supplied for a particular user.
        else if (!szHeader && szRealm && szUser && !szPass && !szNonce)
        {
            fPreAuth = TRUE;
            dwError = ERROR_SUCCESS;
        }
        
        // Preauth with realm and creds supplied.
        else if (!szHeader && szRealm && szUser && 
            szPass && szNonce && pcNC && (fContextReq & ISC_REQ_USE_SUPPLIED_CREDS))
        {
            fPreAuth = TRUE;
            fCredsSupplied = TRUE;
            dwError = ERROR_SUCCESS;
        }
    }

    // Fail if buffers did not fall into one
    // of the acceptable formats.
    if (dwError != ERROR_SUCCESS)
        goto exit;

    // Construct the params object.
    *ppParams = new CParams(szHeader);
    if (!*ppParams)
    {
        DIGEST_ASSERT(FALSE);
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }
        

    // Flag if this is preauth and/or if 
    // credentials are supplied.
    (*ppParams)->SetPreAuth(fPreAuth);
    (*ppParams)->SetCredsSupplied(fCredsSupplied);

    // Only set algorithm if auth to challenge or UI prompting.
    if (!(*ppParams)->IsPreAuth())
    {
        // Algorithm should be MD5 or MD5-sess, default to MD5 if not specified.
        if (!(*ppParams)->GetParam(CParams::ALGORITHM, &szAlgo, &cbAlgo))
        {
            (*ppParams)->SetParam(CParams::ALGORITHM, "MD5", sizeof("MD5") - 1);
            (*ppParams)->SetMd5Sess(FALSE);
        }
        else if (szAlgo && !lstrcmpi(szAlgo, "Md5-sess"))
        {
            (*ppParams)->SetMd5Sess(TRUE);
        }        
        else if (szAlgo && !lstrcmpi(szAlgo, "MD5"))
        {
            (*ppParams)->SetMd5Sess(FALSE);
        }
        else
        {
            // Not md5 or md5-sess
            // DIGEST_ASSERT(FALSE);
            dwError = ERROR_INVALID_PARAMETER;
            goto exit;
        }
    }

    // If this is an imap/pop client we require
    // md5-sess specified in the challenge.
    if (!pSess->fHTTP && !(*ppParams)->IsMd5Sess())
    {
        DIGEST_ASSERT(FALSE);
        dwError = ERROR_INVALID_PARAMETER;
        goto exit;
    }        

    // Always set host, url, method (required). User and pass optional.
    if (!   (*ppParams)->SetParam(CParams::HOST,   szHost,   szHost   ? strlen(szHost)   : 0)
        || !(*ppParams)->SetParam(CParams::URL,    szUrl,    szUrl    ? strlen(szUrl)    : 0)
        || !(*ppParams)->SetParam(CParams::METHOD, szMethod, szMethod ? strlen(szMethod) : 0)
        || !(*ppParams)->SetParam(CParams::USER,   szUser,   szUser   ? strlen(szUser)   : 0)
        || !(*ppParams)->SetParam(CParams::PASS,   szPass,   szPass   ? strlen(szPass)   : 0))
    {
        DIGEST_ASSERT(FALSE);
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    // BUGBUG - do cleanup locally on failure.
    
    // If not preauthenticating we are authenticating in response
    // to a challenge or prompting for UI.
    if (!(*ppParams)->IsPreAuth())
    {
        // Check to see that qop=auth is specified
        (*ppParams)->GetParam(CParams::QOP, &szQop, &cbQop);
        if (!(szQop && (*ppParams)->FindToken(szQop, cbQop+1, AUTH_SZ, AUTH_LEN, NULL)))
        {
            DIGEST_ASSERT(FALSE);
            dwError = ERROR_INVALID_PARAMETER;
            goto exit;
        }
        
        // Save off any hWnd for UI (only needed for challenges).
        if (fContextReq & ISC_REQ_PROMPT_FOR_CREDS)
        {
            (*ppParams)->SetHwnd(phWnd);
        }
    }
    // Otherwise we are attempting to preauthenticate.
    else
    {
        // Set the realm for preauth.
        if (!(*ppParams)->SetParam(CParams::REALM, szRealm, strlen(szRealm)))
        {
            DIGEST_ASSERT(FALSE);
            dwError = ERROR_INVALID_PARAMETER;
            goto exit;
        }

        // Also set the nonce if preauth + use supplied creds.
        if (fContextReq & ISC_REQ_USE_SUPPLIED_CREDS)
        {
            (*ppParams)->SetNC(pcNC);
            if (!(*ppParams)->SetParam(CParams::NONCE, szNonce, strlen(szNonce)))
            {
                DIGEST_ASSERT(FALSE);
                dwError = ERROR_INVALID_PARAMETER;
                goto exit;
            }
        }
    }

exit:
    return dwError;
}



//--------------------------------------------------------------------
// CDigest::GenerateResponse
//--------------------------------------------------------------------
DWORD CDigest::GenerateResponse(CSess *pSess, CParams *pParams, 
    CCredInfo *pInfo, PSecBufferDesc pSecBufDesc)
{
    // bugbug - psz's on these.
    LPSTR   szBuf, szMethod, szUrl, szNonce, szCNonce, szCNonceSess, szOpaque;
    DWORD *pcbBuf, cbMethod, cbUrl, cbNonce, cbCNonce, cbCNonceSess, cbOpaque;
    DWORD dwError, cbAlloced;
    BOOL fSess = FALSE;
    
    szBuf = (LPSTR) pSecBufDesc->pBuffers[0].pvBuffer;
    pcbBuf = &(pSecBufDesc->pBuffers[0].cbBuffer);

    cbAlloced = *pcbBuf;
    *pcbBuf = 0;

    szCNonce = NULL;
    
    if (!cbAlloced)
    {
        // Modern clients better pass in
        // the size of the output buffer.
        if (pSess->fHTTP)
        {
            DIGEST_ASSERT(FALSE);
            dwError = ERROR_INVALID_PARAMETER;
            goto quit;
        }
        else
            // Legacy clients like OE don't, so
            // we allow up to 64k.
            cbAlloced = PACKAGE_MAXTOKEN;
    }

    CHAR szA1[SIZE_MD5_DIGEST + 1],
         szA2[SIZE_MD5_DIGEST + 1],
         szH [SIZE_MD5_DIGEST + 1];


    MD5_CTX md5a1, md5a2, md5h;

    // Get method and request-uri.
    pParams->GetParam(CParams::METHOD, &szMethod, &cbMethod);
    if (pSess->fHTTP)
        pParams->GetParam(CParams::URL,    &szUrl,    &cbUrl);
    else
    {
        // request-uri is empty string for legacy clients.
        szUrl = "";
        cbUrl = 0;
    }


    // Must have both method and request-uri.
    if (!szMethod || !szUrl)
    {
        DIGEST_ASSERT(FALSE);
        dwError = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    // Opaque is optional.
    pParams->GetParam(CParams::_OPAQUE, &szOpaque, &cbOpaque);

    // Unless we are preauthenticating it is possible that
    // the credential does not have a nonce value if the
    // credential was established via ApplyControlToken.
    // In this case we use the nonce received in the challenge.
    if (pInfo->szNonce)
    {
        szNonce = pInfo->szNonce;
        cbNonce = strlen(szNonce);
    }
    else if (!pParams->GetParam(CParams::NONCE, &szNonce, &cbNonce))
    {
        DIGEST_ASSERT(FALSE);
        dwError = ERROR_INVALID_PARAMETER;
        goto quit;
    }    

    // Existance of a client nonce in the credential
    // implies md5-sess. Otherwise we need to create one.
    if (pInfo->szCNonce)
    {
        szCNonceSess = pInfo->szCNonce;
        cbCNonceSess = SIZE_MD5_DIGEST;

        if (pInfo->cCount == 1)
            szCNonce = pInfo->szCNonce;
        else
            szCNonce = MakeCNonce();

        cbCNonce = SIZE_MD5_DIGEST;
        fSess = TRUE;
    }
    // No client nonce means we simply
    // generate one now.
    else
    {
        szCNonce = MakeCNonce();
        cbCNonce = SIZE_MD5_DIGEST;
        szCNonceSess = NULL;
        cbCNonceSess = 0;
        fSess = FALSE;
    }
        
    // Encode nonce count.
    // BUGBUG - wsprintf returns strlen
    // and are any cruntime deps.
    CHAR szNC[16];
    DWORD cbNC;    
    wsprintf(szNC, "%08x", pInfo->cCount);
    cbNC = strlen(szNC);    
    
    LPSTR szPass = pInfo->GetPass();

    // 1) Md5(user:realm:pass) or
    //    Md5(Md5(user:realm:pass):nonce:cnoncesess)
    MD5Init  (&md5a1);
    MD5Update(&md5a1, (LPBYTE) pInfo->szUser, strlen(pInfo->szUser));
    MD5Update(&md5a1, (LPBYTE) ":", 1);
    MD5Update(&md5a1, (LPBYTE) pInfo->szRealm, strlen(pInfo->szRealm));
    MD5Update(&md5a1, (LPBYTE) ":", 1);
    MD5Update(&md5a1, (LPBYTE) szPass, (szPass ? strlen(szPass) : 0));

    if (szPass)
    {
        SecureZeroMemory(szPass, strlen(szPass));
        delete [] szPass;
        szPass = NULL;
    }

    if (fSess)
    {
        // Md5(Md5(user:realm:pass):nonce:cnoncesess)
        MD5Final (&md5a1);
        ToHex(md5a1.digest, sizeof(md5a1.digest), szA1);
        MD5Init  (&md5a1);
        MD5Update(&md5a1, (LPBYTE) szA1, SIZE_MD5_DIGEST);
        MD5Update(&md5a1, (LPBYTE) ":", 1);
        MD5Update(&md5a1, (LPBYTE) szNonce, cbNonce);
        MD5Update(&md5a1, (LPBYTE) ":", 1);
        MD5Update(&md5a1, (LPBYTE) szCNonceSess, cbCNonceSess);
    }

    MD5Final (&md5a1);

    ToHex(md5a1.digest, sizeof(md5a1.digest), szA1);

    // 2) Md5(method:url)
    MD5Init  (&md5a2);
    MD5Update(&md5a2, (LPBYTE) szMethod, cbMethod);
    MD5Update(&md5a2, (LPBYTE) ":", 1);
    MD5Update(&md5a2, (LPBYTE) szUrl, cbUrl);
    MD5Final (&md5a2);

    ToHex(md5a2.digest, sizeof(md5a2.digest), szA2);

    // 3) Md5(A1:nonce:nc:cnonce:qop:A2)
    MD5Init  (&md5h);
    MD5Update(&md5h, (LPBYTE) szA1, SIZE_MD5_DIGEST);
    MD5Update(&md5h, (LPBYTE)  ":",    1);
    MD5Update(&md5h, (LPBYTE) szNonce, cbNonce);
    MD5Update(&md5h, (LPBYTE)  ":",    1);
    MD5Update(&md5h, (LPBYTE) szNC,    cbNC);
    MD5Update(&md5h, (LPBYTE)  ":",    1);
    MD5Update(&md5h, (LPBYTE) szCNonce, cbCNonce);
    MD5Update(&md5h, (LPBYTE)  ":",    1);
    MD5Update(&md5h, (LPBYTE) AUTH_SZ, AUTH_LEN);
    MD5Update(&md5h, (LPBYTE)  ":",    1);
    MD5Update(&md5h, (LPBYTE) szA2, SIZE_MD5_DIGEST);
    MD5Final (&md5h);
    
    ToHex(md5h.digest, sizeof(md5h.digest), szH);

    
    // http digest.
    if (pSess->fHTTP)
    {
        if (   AddDigestHeader(szBuf, pcbBuf, "Digest username", 
               pInfo->szUser, cbAlloced, FLAG_QUOTE)

            && AddDigestHeader(szBuf, pcbBuf, "realm", 
               pInfo->szRealm, cbAlloced, FLAG_QUOTE)

            && AddDigestHeader(szBuf, pcbBuf, "qop", 
               "auth", cbAlloced, FLAG_QUOTE)

            && AddDigestHeader(szBuf, pcbBuf, 
               "algorithm", (pInfo->szCNonce ? "MD5-sess" : "MD5"), cbAlloced, FLAG_QUOTE)

            && AddDigestHeader(szBuf, pcbBuf, "uri", szUrl, cbAlloced, FLAG_QUOTE)

            && AddDigestHeader(szBuf, pcbBuf, "nonce", szNonce, cbAlloced, FLAG_QUOTE)

            && AddDigestHeader(szBuf, pcbBuf, "nc", szNC, cbAlloced, 0)
        
            && AddDigestHeader(szBuf, pcbBuf, "cnonce", szCNonce, cbAlloced, FLAG_QUOTE)

            && (!szOpaque || AddDigestHeader(szBuf, pcbBuf, "opaque", szOpaque, cbAlloced, FLAG_QUOTE))

            && AddDigestHeader(szBuf, pcbBuf, 
                "response", szH, cbAlloced, FLAG_QUOTE | FLAG_TERMINATE)
           )
        {
            dwError = ERROR_SUCCESS;
        }
        else
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            *pcbBuf = 0;
        }
    }
    else
    {
        if (   AddDigestHeader(szBuf, pcbBuf, "Digest username", 
               pInfo->szUser, cbAlloced, FLAG_QUOTE)

            && AddDigestHeader(szBuf, pcbBuf, "realm", 
               pInfo->szRealm, cbAlloced, FLAG_QUOTE)

            && AddDigestHeader(szBuf, pcbBuf, "qop", 
               "auth", cbAlloced, FLAG_QUOTE)

            && AddDigestHeader(szBuf, pcbBuf, 
               "algorithm", (pInfo->szCNonce ? "MD5-sess" : "MD5"), cbAlloced, FLAG_QUOTE)

            && AddDigestHeader(szBuf, pcbBuf, "nonce", szNonce, cbAlloced, FLAG_QUOTE)
        
            && AddDigestHeader(szBuf, pcbBuf, "cnonce", szCNonce, cbAlloced, FLAG_QUOTE)

            && AddDigestHeader(szBuf, pcbBuf, 
                "response", szH, cbAlloced, FLAG_QUOTE | FLAG_TERMINATE)
            )
        {
            dwError = ERROR_SUCCESS;
        }
        else
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            *pcbBuf = 0;
        }
    }        

quit:
    if (szCNonce && szCNonce != pInfo->szCNonce)
        delete szCNonce;
        
    return dwError;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\digest\cred.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    cred.cxx

Abstract:

    Shared memory data structures for digest sspi package.


Author:

    Adriaan Canter (adriaanc) 01-Aug-1998

--*/

#include "include.hxx"


//////////////////////////////////////////////////////////////////////
//
//                      CEntry Functions
//
//////////////////////////////////////////////////////////////////////


//--------------------------------------------------------------------
// CEntry::Free 
// BUGBUG - inline this.
//--------------------------------------------------------------------
DWORD CEntry::Free(CMMFile *pMMFile, CEntry *pEntry)
{
    BOOL bFree = pMMFile->FreeEntry(pEntry);
    return (bFree ? ERROR_SUCCESS : ERROR_INTERNAL_ERROR);
}

//--------------------------------------------------------------------
// CEntry::GetNext
//--------------------------------------------------------------------
CEntry* CEntry::GetNext(CEntry *pEntry)
{
    if (pEntry->dwNext)
        return (CEntry*) OFFSET_TO_POINTER(g_pHeap, pEntry->dwNext);
    return NULL;
}

//--------------------------------------------------------------------
// CEntry::GetPrev
//--------------------------------------------------------------------
CEntry* CEntry::GetPrev(CEntry *pEntry)
{
    if (pEntry->dwPrev)
        return (CEntry*) OFFSET_TO_POINTER(g_pHeap, pEntry->dwPrev);
    return NULL;
}


//////////////////////////////////////////////////////////////////////
//
//                      CSess Functions
//
//////////////////////////////////////////////////////////////////////



//--------------------------------------------------------------------
// CSess::Create
//--------------------------------------------------------------------
CSess* CSess::Create(CMMFile *pMMFile, 
    LPSTR szAppCtx, LPSTR szUserCtx, BOOL fHTTP)
{
    DIGEST_ASSERT(pMMFile);

    // Unaligned Sess lengths.
    DWORD cbAppCtx  = szAppCtx  ?  strlen(szAppCtx)  + 1 : 0;
    DWORD cbUserCtx = szUserCtx ?  strlen(szUserCtx) + 1 : 0;

    // Aligned Sess lengths.
    DWORD cbStructAligned  = ROUNDUPDWORD(sizeof(CSess));
    DWORD cbAppCtxAligned  = ROUNDUPDWORD(cbAppCtx);
    DWORD cbUserCtxAligned = ROUNDUPDWORD(cbUserCtx);

    // Total number of required bytes (aligned).
    DWORD cbEntryAligned = cbStructAligned 
        + cbAppCtxAligned + cbUserCtxAligned;

    // Allocate from mem map.
    CSess *pSess = (CSess*) pMMFile->AllocateEntry(cbEntryAligned);

    if (!pSess)
    {
        DIGEST_ASSERT(FALSE);
        goto exit;
    }
    
    DWORD cbCurrentOffset;
    cbCurrentOffset = cbStructAligned;

    pSess->dwAppCtx = pSess->dwUserCtx = 0;
    
    // AppCtx
    if (szAppCtx)
    {
        memcpy(OFFSET_TO_POINTER(pSess, cbCurrentOffset), szAppCtx, cbAppCtx);
        pSess->dwAppCtx = cbCurrentOffset;
        cbCurrentOffset += cbAppCtxAligned;
    }
        
    // UserCtx
    if (szUserCtx)
    {
        memcpy(OFFSET_TO_POINTER(pSess, cbCurrentOffset), szUserCtx, cbUserCtx);
        pSess->dwUserCtx = cbCurrentOffset;
    }

    // No need to advance cbCurrentOffset.
    
    pSess->cbSess = cbEntryAligned;
    pSess->dwCred = 0;
    pSess->dwSig = SIG_SESS;
    pSess->fHTTP = fHTTP;
    pSess->dwPrev = 0;
    pSess->dwNext = 0;

exit:

    return pSess;
}

//--------------------------------------------------------------------
// CSess::GetAppCtx
//--------------------------------------------------------------------
LPSTR CSess::GetAppCtx(CSess *pSess)
{
    if (pSess->dwAppCtx)
        return (LPSTR) OFFSET_TO_POINTER(pSess, pSess->dwAppCtx);
    else
        return NULL;
}
 
//--------------------------------------------------------------------
// CSess::GetUserCtx
//--------------------------------------------------------------------
LPSTR CSess::GetUserCtx(CSess *pSess)
{
    if (pSess->dwUserCtx)
        return (LPSTR) OFFSET_TO_POINTER(pSess, pSess->dwUserCtx);
    else
        return NULL;
}
        
//--------------------------------------------------------------------
// CSess::GetCtx
// Allocates a context string in local heap.
//--------------------------------------------------------------------
LPSTR CSess::GetCtx(CSess *pSess)
{
    DIGEST_ASSERT(pSess);

    LPSTR szAppCtx, szUserCtx, szCtx;
    DWORD cbAppCtx, cbUserCtx, cbCtx;

    szAppCtx  = GetAppCtx(pSess);
    szUserCtx = GetUserCtx(pSess);
    
    cbAppCtx  = szAppCtx  ? strlen(szAppCtx) : 0;
    cbUserCtx = szUserCtx ? strlen(szUserCtx) : 0;

    cbCtx = cbAppCtx + sizeof(':') + cbUserCtx + sizeof('\0');

    szCtx = new CHAR[cbCtx];
    if (!szCtx)
    {
        DIGEST_ASSERT(FALSE);
        return NULL;
    }
    
    // "appctx:userctx\0"
    // bugbug - macro for sizeof -1
    memcpy(szCtx, szAppCtx, cbAppCtx);
    memcpy(szCtx + cbAppCtx, ":", sizeof(":") - 1);
    memcpy(szCtx + cbAppCtx + sizeof(":") - 1, szUserCtx, cbUserCtx);
    memcpy(szCtx + cbAppCtx + sizeof(":") - 1 + cbUserCtx, "\0", sizeof("\0") - 1);

    return szCtx;
}

//--------------------------------------------------------------------
// CSess::CtxMatch
//--------------------------------------------------------------------
BOOL CSess::CtxMatch(CSess *pSess1, CSess *pSess2)
{
    DIGEST_ASSERT(pSess1 && pSess2);
    
    LPSTR szAppCtx1, szAppCtx2, szUserCtx1, szUserCtx2;
    
    szAppCtx1   = CSess::GetAppCtx(pSess1);
    szAppCtx2   = CSess::GetAppCtx(pSess2);
    szUserCtx1  = CSess::GetUserCtx(pSess1);
    szUserCtx2  = CSess::GetUserCtx(pSess2);

    // If both AppCtx values are NULL or
    // are equal to same string.
    if ((!szAppCtx1 && !szAppCtx2)
        || ((szAppCtx1 && szAppCtx2) 
            && !strcmp(szAppCtx1, szAppCtx2)))
    {
        // And both UserCtx values are NULL or
        // are equal to same string.
        if ((!szUserCtx1 && !szUserCtx2)
            || ((szUserCtx1 && szUserCtx2) 
                && !strcmp(szUserCtx1, szUserCtx2)))
        
        {
            // Credentials are shareable.
            return TRUE;
        }
    }
    // Otherwise creds are not shareable.
    return FALSE;
}

//--------------------------------------------------------------------
// CSess::GetCred
//--------------------------------------------------------------------
CCred *CSess::GetCred(CSess* pSess)
{
    if (!pSess->dwCred)
        return NULL;
    return (CCred*) OFFSET_TO_POINTER(g_pHeap, pSess->dwCred);
}

//--------------------------------------------------------------------
// CSess::SetCred
//--------------------------------------------------------------------
CCred *CSess::SetCred(CSess* pSess, CCred* pCred)
{
    if (!pCred)
        pSess->dwCred = 0;
    else
        pSess->dwCred = POINTER_TO_OFFSET(g_pHeap, pCred);

    return pCred;
}


//////////////////////////////////////////////////////////////////////
//
//                      CList Functions
//
//////////////////////////////////////////////////////////////////////


//--------------------------------------------------------------------
// CList::CList
//--------------------------------------------------------------------
CList::CList()
{
    _pHead = NULL;
    _pCur = NULL;
    _pdwOffset = NULL;
}


//--------------------------------------------------------------------
// CList::Init
//--------------------------------------------------------------------
CEntry* CList::Init(LPDWORD pdwOffset)
{
    DIGEST_ASSERT(pdwOffset)

    _pdwOffset = pdwOffset;

    if (*pdwOffset)
    {    
        _pHead = (CEntry*) OFFSET_TO_POINTER(g_pHeap, *pdwOffset);
        _pCur = _pHead;
    }
    return _pHead;
}


//--------------------------------------------------------------------
// CList::Seek
//--------------------------------------------------------------------
CEntry* CList::Seek()
{
//    DIGEST_ASSERT(_pHead);
    _pHead = (CEntry*) OFFSET_TO_POINTER(g_pHeap, *_pdwOffset);
    _pCur = _pHead;
    return _pCur;
}

//--------------------------------------------------------------------
// CList::GetNext
//--------------------------------------------------------------------
CEntry* CList::GetNext()
{
    if (! *_pdwOffset)
        return NULL;

    CEntry *pEntry = _pCur;

    if (_pCur)
        _pCur = _pCur->dwNext ? 
            (CEntry*) OFFSET_TO_POINTER(g_pHeap, _pCur->dwNext) : NULL;

    return pEntry;
}

//--------------------------------------------------------------------
// CList::GetPrev
//--------------------------------------------------------------------
CEntry* CList::GetPrev()
{
    if (! *_pdwOffset)
        return NULL;

    CEntry *pEntry = _pCur;

    if (_pCur)
        _pCur = _pCur->dwPrev ?
            (CEntry*) OFFSET_TO_POINTER(g_pHeap, _pCur->dwPrev) : NULL;

    return pEntry;
}

//--------------------------------------------------------------------
// CList::Insert
//--------------------------------------------------------------------
CEntry* CList::Insert(CEntry *pEntry)
{
    // BUGBUG - assert pnext pprev are null
    DIGEST_ASSERT(pEntry 
        && (pEntry->dwPrev == pEntry->dwNext == 0));

    if (!_pHead)
    {
        _pHead = pEntry;
    }
    else
    {
        pEntry->dwNext = POINTER_TO_OFFSET(g_pHeap, _pHead);        
        _pHead->dwPrev = POINTER_TO_OFFSET(g_pHeap, pEntry);
        _pHead = pEntry;
    }

    *_pdwOffset = POINTER_TO_OFFSET(g_pHeap, pEntry);

    return pEntry;
}

//--------------------------------------------------------------------
// CList::DeLink
//--------------------------------------------------------------------
CEntry* CList::DeLink(CEntry *pEntry)
{        
    DIGEST_ASSERT(pEntry);

    if (pEntry == _pHead)
    {
        _pHead = (CEntry*) OFFSET_TO_POINTER(g_pHeap, pEntry->dwNext);
        *_pdwOffset = POINTER_TO_OFFSET(g_pHeap, _pHead);
    }
    else
    {
        CEntry *pPrev;
        pPrev = (CEntry*) OFFSET_TO_POINTER(g_pHeap, pEntry->dwPrev);
        pPrev->dwNext = pEntry->dwNext;
    }

    if (pEntry->dwNext)
    {
        CEntry *pNext;
        pNext = (CEntry*) OFFSET_TO_POINTER(g_pHeap, pEntry->dwNext);
        pNext->dwPrev = pEntry->dwPrev;
    }

    if (_pCur == pEntry)
    {
        _pCur = (CEntry*) OFFSET_TO_POINTER(g_pHeap, pEntry->dwNext);
    }


    return pEntry;
}


//////////////////////////////////////////////////////////////////////
//
//                      CCred Functions
//
//////////////////////////////////////////////////////////////////////


//--------------------------------------------------------------------
// CCred::Create
//--------------------------------------------------------------------
CCred* CCred::Create(CMMFile *pMMFile,
    LPSTR szHost, LPSTR szRealm, LPSTR szUser, 
    LPSTR szPass, LPSTR szNonce, LPSTR szCNonce)
{
    // BUGBUG - assert strings non-null. Nonce can be NULL.
    DIGEST_ASSERT(pMMFile && szRealm && szUser && szPass);

    CSecureStr EncryptedPassword;

    if (szPass && !EncryptedPassword.SetData(szPass))
        return NULL;

    // Unaligned string sizes.
    DWORD cbRealm = szRealm ?  strlen(szRealm)  + 1 : 0;
    DWORD cbUser  = szUser  ?  strlen(szUser)   + 1 : 0;
    DWORD cbPass  = szPass  ?  EncryptedPassword.GetStrLen() : 0;

    
    // Aligned string sizes.
    DWORD cbStructAligned   = ROUNDUPDWORD(sizeof(CCred));
    DWORD cbRealmAligned    = ROUNDUPDWORD(cbRealm);
    DWORD cbUserAligned     = ROUNDUPDWORD(cbUser);
    DWORD cbPassAligned     = ROUNDUPDWORD(cbPass);

    // Total number of required bytes (aligned).
    DWORD cbEntryAligned = cbStructAligned 
        + cbRealmAligned 
        + cbUserAligned 
        + cbPassAligned;

    // Allocate cred and nonce from memmap
    // BUGBUG - MASKING PNONCE
    // BUGBUG - no, I'm not.
    CCred  *pCred;
    CNonce *pNonce, *pCNonce;
    pNonce = pCNonce = NULL;
    
    // Allocate a credential.
    pCred = (CCred*) pMMFile->AllocateEntry(cbEntryAligned);
    if (!pCred)
    {
        DIGEST_ASSERT(FALSE);
        goto exit;
    }
    
        
    DWORD cbCurrentOffset;
    cbCurrentOffset = cbStructAligned;
   
    // Realm.
    memcpy(OFFSET_TO_POINTER(pCred, cbCurrentOffset), szRealm, cbRealm);
    pCred->dwRealm = cbCurrentOffset;
    cbCurrentOffset += cbRealmAligned;
    
    // User
    memcpy(OFFSET_TO_POINTER(pCred, cbCurrentOffset), szUser, cbUser);
    pCred->dwUser = cbCurrentOffset;
    cbCurrentOffset += cbUserAligned;

    // Pass
    memcpy(OFFSET_TO_POINTER(pCred, cbCurrentOffset), EncryptedPassword.GetPtr(), cbPass);
    pCred->dwPass = cbCurrentOffset;
    pCred->cbPass = cbPass;
        
    pCred->cbCred = cbEntryAligned;
    pCred->tStamp = GetTickCount();
    pCred->dwSig = SIG_CRED;
    pCred->dwPrev = NULL;
    pCred->dwNext = NULL;

    pCred->dwNonce = 0;
    pCred->dwCNonce = 0;

    // Allocate nonce and client nonce if specified.
    if (szNonce)
        CCred::SetNonce(pMMFile, pCred, szHost, szNonce, SERVER_NONCE);
        
    if (szCNonce)
        CCred::SetNonce(pMMFile, pCred, szHost, szCNonce, CLIENT_NONCE);
exit:

    return pCred;
}

//--------------------------------------------------------------------
// CCred::GetRealm
//--------------------------------------------------------------------
LPSTR CCred::GetRealm(CCred* pCred)
{
    DIGEST_ASSERT(pCred);
    if (pCred->dwRealm)
        return (LPSTR) OFFSET_TO_POINTER(pCred, pCred->dwRealm);
    else
        return NULL;
}
        
//--------------------------------------------------------------------
// CCred::GetUser
//--------------------------------------------------------------------
LPSTR CCred::GetUser(CCred* pCred)
{
    DIGEST_ASSERT(pCred);
    if (pCred->dwUser)
        return (LPSTR) OFFSET_TO_POINTER(pCred, pCred->dwUser);
    else
        return NULL;
}

//--------------------------------------------------------------------
// CCred::GetPass
//--------------------------------------------------------------------
LPSTR CCred::GetPass(CCred* pCred)
{
    DIGEST_ASSERT(pCred);
    if (pCred->dwPass)
    {
        CSecureStr EncryptedPassword(
                        (LPSTR) OFFSET_TO_POINTER(pCred, pCred->dwPass),
                        pCred->cbPass,
                        false);
        return EncryptedPassword.GetUnencryptedString();
    }
    else
        return NULL;
}

//--------------------------------------------------------------------
// CCred::SetNonce
//--------------------------------------------------------------------
VOID CCred::SetNonce(CMMFile *pMMFile, CCred* pCred, 
    LPSTR szHost, LPSTR szNonce, DWORD dwType)
{
    DIGEST_ASSERT(pCred && szNonce);

    // First determine if a nonce for the specified host
    // already exists and delete it if it does.
    CList NonceList;
    NonceList.Init(dwType == SERVER_NONCE ? 
        &pCred->dwNonce : &pCred->dwCNonce);

    CNonce *pNonce;
    while (pNonce = (CNonce*) NonceList.GetNext())
    {
        if (CNonce::IsHostMatch(pNonce, szHost))
        {
            NonceList.DeLink(pNonce);
            CEntry::Free(pMMFile, pNonce);
            break;
        }        
    }
        
    // Create a CNonce object and insert it into the list.
    pNonce = CNonce::Create(pMMFile, szHost, szNonce);
    if (pNonce)
    {
        NonceList.Seek();
        NonceList.Insert(pNonce);    
    }
    else
    {
        DIGEST_ASSERT(FALSE);
    }
    
}


//--------------------------------------------------------------------
// CCred::GetNonce
//--------------------------------------------------------------------
CNonce *CCred::GetNonce(CCred* pCred, LPSTR szHost, DWORD dwType)
{
    CNonce *pNonce;
    CList NonceList;
    NonceList.Init(dwType == SERVER_NONCE ? 
        &pCred->dwNonce : &pCred->dwCNonce);

    while (pNonce = (CNonce*) NonceList.GetNext())
    {
        if (CNonce::IsHostMatch(pNonce, szHost))
            break;
    }
    return pNonce;
}

//--------------------------------------------------------------------
// CCred::Free
//--------------------------------------------------------------------
VOID CCred::Free(CMMFile *pMMFile, CSess *pSess, CCred *pCred)
{
    CNonce *pNonce;
    CList NonceList;

    // Free up server nonce.
    NonceList.Init(&pCred->dwNonce);
    while (pNonce = (CNonce*) NonceList.GetNext())
    {
        NonceList.DeLink(pNonce);
        CEntry::Free(pMMFile, pNonce);
    }

    // Free up client nonce.
    NonceList.Init(&pCred->dwCNonce);
    while (pNonce = (CNonce*) NonceList.GetNext())
    {
        NonceList.DeLink(pNonce);
        CEntry::Free(pMMFile, pNonce);
    }

    // Remove credential from session's list.
    CList CredList;
    CredList.Init(&pSess->dwCred);
    CredList.DeLink(pCred);
    CEntry::Free(pMMFile, pCred);
}


//////////////////////////////////////////////////////////////////////
//
//                      CNonce Functions
//
//////////////////////////////////////////////////////////////////////


//--------------------------------------------------------------------
// CNonce::Create
//--------------------------------------------------------------------
CNonce* CNonce::Create(CMMFile *pMMFile, LPSTR szHost, LPSTR szNonce)
{
    DIGEST_ASSERT(pMMFile && szNonce);

    // Unaligned string sizes.
    DWORD cbNonce = szNonce ?  strlen(szNonce)  + 1 : 0;
    DWORD cbHost = szHost ?  strlen(szHost)  + 1 : 0;
    
    // Aligned string sizes.
    DWORD cbStructAligned   = ROUNDUPDWORD(sizeof(CNonce));
    DWORD cbNonceAligned    = ROUNDUPDWORD(cbNonce);
    DWORD cbHostAligned    = ROUNDUPDWORD(cbHost);

    // Total number of required bytes (aligned).
    DWORD cbEntryAligned = cbStructAligned 
        + cbHostAligned
        + cbNonceAligned;

    // Allocate from mem map.
    CNonce *pNonce = (CNonce*) pMMFile->AllocateEntry(cbEntryAligned);

    // Failed to allocate. 
    if (!pNonce)
    {
        DIGEST_ASSERT(FALSE);
        goto exit;
    }
    
    DWORD cbCurrentOffset;
    cbCurrentOffset = cbStructAligned;
   
    // Host.
    if (szHost)
    {
        memcpy(OFFSET_TO_POINTER(pNonce, cbCurrentOffset), szHost, cbHost);
        pNonce->dwHost = cbCurrentOffset;
        cbCurrentOffset += cbHostAligned;
    }
    else
    {
        pNonce->dwHost = 0;
    }

    // Nonce.
    memcpy(OFFSET_TO_POINTER(pNonce, cbCurrentOffset), szNonce, cbNonce);
    pNonce->dwNonce = cbCurrentOffset;
    cbCurrentOffset += cbNonceAligned;
    
    pNonce->cbNonce = cbEntryAligned;
    pNonce->cCount  = 0;

    pNonce->dwSig = SIG_NONC;
    pNonce->dwPrev = 0;
    pNonce->dwNext = 0;

exit:

    return pNonce;
}


//--------------------------------------------------------------------
// CNonce::GetNonce
//--------------------------------------------------------------------
LPSTR CNonce::GetNonce(CNonce* pNonce)
{
    if (pNonce && pNonce->dwNonce)
        return (LPSTR) OFFSET_TO_POINTER(pNonce, pNonce->dwNonce);
    else
        return NULL;
}

//--------------------------------------------------------------------
// CNonce::GetCount
// bugbug - what if no nonce?
//--------------------------------------------------------------------
DWORD CNonce::GetCount(CNonce* pNonce)
{
    DIGEST_ASSERT(pNonce);
    return pNonce->cCount;
}


//--------------------------------------------------------------------
// CNonce::IsHostMatch
//--------------------------------------------------------------------
BOOL CNonce::IsHostMatch(CNonce *pNonce, LPSTR szHost)
{
    if (szHost)
    {
        if (pNonce->dwHost 
            && !strcmp(szHost, (LPSTR) OFFSET_TO_POINTER(pNonce, pNonce->dwHost)))
            return TRUE;
        return FALSE;
    }

    if (!pNonce->dwHost)
        return TRUE;
    return FALSE;
}


//////////////////////////////////////////////////////////////////////
//
//                  CCredInfo Functions
//
//////////////////////////////////////////////////////////////////////


//--------------------------------------------------------------------
// CCredInfo::CCredInfo
//--------------------------------------------------------------------
CCredInfo::CCredInfo(CCred* pCred, LPSTR szHost)
{
    DIGEST_ASSERT(pCred 
        && (pCred->dwPass > pCred->dwUser) 
        && (pCred->dwUser > pCred->dwRealm));
    
    CCredInfo::szHost   = NewString(szHost);
    szRealm   = NewString(CCred::GetRealm(pCred));
    szUser    = NewString(CCred::GetUser(pCred));
    
    LPSTR szPass  = CCred::GetPass(pCred);

    if (szPass)
    {
        BOOL fSetDataSuccess = Password.SetData(szPass);

        SecureZeroMemory(szPass, strlen(szPass));
        delete [] szPass;

        if (!fSetDataSuccess)
        {
            dwStatus = ERROR_NOT_ENOUGH_MEMORY;
            return;
        }
    }

    // Get server nonce. This is always required.
    // BUGBUG - what about pre-loading?
    CNonce *pNonce;
    pNonce = CCred::GetNonce(pCred, szHost, SERVER_NONCE);
    if (!pNonce)
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        return;
    }
    szNonce = NewString(CNonce::GetNonce(pNonce));
    cCount = pNonce->cCount;
    
    pNonce = CCred::GetNonce(pCred, szHost, CLIENT_NONCE);
    if (pNonce)
        szCNonce = NewString(CNonce::GetNonce(pNonce));
    else
        szCNonce = NULL;

    tStamp = pCred->tStamp;
    pPrev = NULL;
    pNext = NULL;
    dwStatus = ERROR_SUCCESS;

}    

//--------------------------------------------------------------------
// CCredInfo::CCredInfo
// BUGBUG - special casing for NULLs, especially szNonce.
//--------------------------------------------------------------------
CCredInfo::CCredInfo(LPSTR szHost, LPSTR szRealm, LPSTR szUser, 
    LPSTR szPass, LPSTR szNonce, LPSTR szCNonce)
{       
    CCredInfo::szHost    = NewString(szHost);
    CCredInfo::szRealm   = NewString(szRealm);
    CCredInfo::szUser    = NewString(szUser);
    CCredInfo::Password.SetData(szPass);
    CCredInfo::szNonce   = NewString(szNonce);
    CCredInfo::szCNonce  = NewString(szCNonce);

    cCount = 0;
    tStamp = 0;
    pPrev = NULL;
    pNext = NULL;
    
    dwStatus = ERROR_SUCCESS;
}

//--------------------------------------------------------------------
// CCredInfo::~CCredInfo
//--------------------------------------------------------------------
CCredInfo::~CCredInfo()
{       
    if (szHost)
        delete [] szHost;
    if (szRealm)
        delete [] szRealm;
    if (szUser)
        delete [] szUser;
    Password.Free();
    if (szNonce)
        delete [] szNonce;
    if (szCNonce)
        delete [] szCNonce;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\digest\digestw.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    digestw.cxx

Abstract:

    sspi wide char interface for digest package.
    
Author:

    Adriaan Canter (adriaanc) 01-Aug-1998

--*/
#include "include.hxx"

static SecurityFunctionTableW

    SecTableW = 
    {
        SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION,
        EnumerateSecurityPackagesW,
        NULL,                          // QueryCredentialsAttributesA
        AcquireCredentialsHandleW,
        FreeCredentialsHandle,
        NULL,                          // SspiLogonUserA
        InitializeSecurityContextW,
        AcceptSecurityContext,
        CompleteAuthToken,
        DeleteSecurityContext,
        ApplyControlToken,
        QueryContextAttributesW,
        ImpersonateSecurityContext,
        RevertSecurityContext,
        MakeSignature,
        VerifySignature,
        FreeContextBuffer,
        QuerySecurityPackageInfoW,
        NULL,                          // Reserved3
        NULL,                          // Reserved4
        NULL,                          // ExportSecurityContext
        NULL,                          // ImportSecurityContextA
        NULL,                          // Reserved7
        NULL,                          // Reserved8
        NULL,                          // QuerySecurityContextToken
        NULL,                          // EncryptMessage
        NULL                           // DecryptMessage
    };

//--------------------------------------------------------------------------
//
//  Function:   InitSecurityInterfaceW
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
extern "C" PSecurityFunctionTableW SEC_ENTRY
InitSecurityInterfaceW(VOID)
{
    PSecurityFunctionTableW pSecTableW = &SecTableW;
    return pSecTableW;
}

//--------------------------------------------------------------------------
//
//  Function:   AcquireCredentialsHandleW
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
// HEINOUS SSPI HACK here: AcquireCredentialsHandle is called with the package
// name ("Digest") as the package identifier. When AcquireCredentialsHandle returns
// to the caller PCredHandle->dwLower is set by security.dll to be the index of
// the package returned. EnumerateSecurityPackages. This is how SSPI resolves the 
// correct provider dll when subsequent calls are made through the dispatch table 
// (PSecurityFunctionTale). Any credential *or* context handle handed out by the 
// package must have the dwLower member set to this index so that subsequent calls 
// can resolve the dll from the handle.
//
//--------------------------------------------------------------------------
extern "C" SECURITY_STATUS SEC_ENTRY
AcquireCredentialsHandleW(
    LPWSTR                      wszPrincipal,       // Name of principal
    LPWSTR                      wszPackageName,     // Name of package
    DWORD                       dwCredentialUse,    // Flags indicating use
    VOID SEC_FAR *              pvLogonId,          // Pointer to logon ID
    VOID SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    VOID SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    )
{
    return SEC_E_UNSUPPORTED_FUNCTION;

#if 0
    SECURITY_STATUS ssResult;

    DWORD wcbPrincipal, cbPrincipal, wcbPackageName, cbPackageName;
    
    wcbPrincipal = wszPrincipal ? wcslen(wszPrincipal) : 0;
    cbPrincipal = wcbPrincipal / sizeof(WCHAR);

    wcbPackageName = wszPackageName ? wcslen(wszPackageName) : 0;
    cbPackageName = wcbPackageName / sizeof(WCHAR);
    
    LPSTR szPrincipal;
    LPSTR szPackageName;

    szPrincipal = new CHAR[cbPrincipal]; 
    szPackageName = new CHAR[cbPackageName]; 
    
    WideCharToMultiByte(CP_ACP,0, wszPrincipal, wcbPrincipal, 
        szPrincipal, cbPrincipal, NULL,NULL);

    WideCharToMultiByte(CP_ACP,0, wszPackageName, wcbPackageName, 
        szPackageName, cbPackageName, NULL,NULL);

    ssResult = AcquireCredentialsHandleA(
        szPrincipal,       // Name of principal
        szPackageName,     // Name of package
        dwCredentialUse,    // Flags indicating use
        pvLogonId,          // Pointer to logon ID
        pAuthData,          // Package specific data
        pGetKeyFn,          // Pointer to GetKey() func
        pvGetKeyArgument,   // Value to pass to GetKey()
        phCredential,       // (out) Cred Handle
        ptsExpiry           // (out) Lifetime (optional)
        );

    delete szPrincipal;
    delete szPackageName;
    
    return ssResult;
#endif // 0
}

//--------------------------------------------------------------------------
//
//  Function:   InitializeSecurityContextA
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
extern "C" SECURITY_STATUS SEC_ENTRY
InitializeSecurityContextW(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    LPWSTR                      wszTargetName,      // Name of target
    DWORD                       fContextReq,        // Context Requirements
    DWORD                       Reserved1,          // Reserved, MBZ
    DWORD                       TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    DWORD                       Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    DWORD         SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    return SEC_E_UNSUPPORTED_FUNCTION;

#if 0
    SECURITY_STATUS ssResult;

    DWORD wcbTargetName, cbTargetName;    
    wcbTargetName = wszTargetName ? wcslen(wszTargetName) : 0;
    cbTargetName = wcbTargetName / sizeof(WCHAR);

    
    LPSTR szTargetName;

    szTargetName = new CHAR[cbTargetName]; 
    
    WideCharToMultiByte(CP_ACP,0, wszTargetName, wcbTargetName, 
        szTargetName, cbTargetName, NULL,NULL);


    ssResult = InitializeSecurityContextA(
        phCredential,       // Cred to base context
        phContext,          // Existing context (OPT)
        szTargetName,      // Name of target
        fContextReq,        // Context Requirements
        Reserved1,          // Reserved, MBZ
        TargetDataRep,      // Data rep of target
        pInput,             // Input Buffers
        Reserved2,          // Reserved, MBZ
        phNewContext,       // (out) New Context handle
        pOutput,            // (inout) Output Buffers
        pfContextAttr,      // (out) Context attrs
        ptsExpiry           // (out) Life span (OPT)
    );

    delete szTargetName;
    return ssResult;

#endif // 0
}


//--------------------------------------------------------------------------
//
//  Function:   EnumerateSecurityPackagesW
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
EnumerateSecurityPackagesW(DWORD SEC_FAR *pcPackages, 
    PSecPkgInfoW SEC_FAR *ppSecPkgInfo)
{
    SECURITY_STATUS ssResult;

    ssResult = QuerySecurityPackageInfoW(PACKAGE_NAMEW, ppSecPkgInfo);
    if (ssResult == SEC_E_OK)
    {
        *pcPackages = 1;
    }

    return ssResult;
}



//--------------------------------------------------------------------------
//
//  Function:   QuerySecurityPackageInfoW
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
QuerySecurityPackageInfoW(LPWSTR wszPackageName, 
    PSecPkgInfoW SEC_FAR *ppSecPkgInfo)
{
    PSecPkgInfoW pSecPkgInfo;
    SECURITY_STATUS ssResult;
    LPWSTR pwCur;

    if (wcscmp(wszPackageName, PACKAGE_NAMEW))
    {
        ssResult = SEC_E_SECPKG_NOT_FOUND;
        goto exit;
    }

    DWORD wcbSecPkgInfo, wcbstruct, wcbname, wcbcomment;
    
    wcbstruct = sizeof(SecPkgInfoW);
    wcbname = sizeof(PACKAGE_NAMEW);
    wcbcomment = sizeof(PACKAGE_COMMENTW);
    wcbSecPkgInfo = wcbstruct + wcbname + wcbcomment;
    
    pSecPkgInfo = (PSecPkgInfoW) LocalAlloc(0,wcbSecPkgInfo);

    if (!pSecPkgInfo)
    {
        ssResult = SEC_E_INSUFFICIENT_MEMORY;
        goto exit;
    }
    
    pSecPkgInfo->fCapabilities = PACKAGE_CAPABILITIES;
    pSecPkgInfo->wVersion      = PACKAGE_VERSION;
    pSecPkgInfo->wRPCID        = PACKAGE_RPCID;
    pSecPkgInfo->cbMaxToken    = PACKAGE_MAXTOKEN;

    pwCur  = (LPWSTR) ((LPBYTE) (pSecPkgInfo) + sizeof(SecPkgInfoW));

    pSecPkgInfo->Name = pwCur;
    memcpy(pSecPkgInfo->Name, PACKAGE_NAMEW, sizeof(PACKAGE_NAMEW));
    pwCur = (LPWSTR) ((LPBYTE) (pwCur) + sizeof(PACKAGE_NAMEW));

    pSecPkgInfo->Comment = pwCur;
    memcpy(pSecPkgInfo->Comment, PACKAGE_COMMENTW, sizeof(PACKAGE_COMMENTW));
    
    *ppSecPkgInfo = pSecPkgInfo;

    ssResult = SEC_E_OK;

exit:
    return ssResult;
}


//--------------------------------------------------------------------------
//
//  Function:   QueryContextAttributesW
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
extern "C" SECURITY_STATUS SEC_ENTRY
QueryContextAttributesW(
    PCtxtHandle                 phContext,          // Context to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    )
{
    return SEC_E_UNSUPPORTED_FUNCTION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\digest\cache.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    cache.cxx

Abstract:

    Credential cache object for digest sspi package.

Author:

    Adriaan Canter (adriaanc) 01-Aug-1998

--*/

#include "include.hxx"


//-----------------CCredCache Private Functions --------------------------------


//--------------------------------------------------------------------
// CCredCache::Lock
//--------------------------------------------------------------------
BOOL CCredCache::Lock()
{
    BOOL  bRet;
    DWORD dwError;

    dwError = WaitForSingleObject(_hMutex, INFINITE);

    switch (dwError)
    {
        // Mutex is signalled. We own the mutex. Fall through.
        case WAIT_OBJECT_0:

        // The thread owning the mutex failed to release it
        // before terminating. We still own the mutex.
        case WAIT_ABANDONED:
            bRet = TRUE;
            break;

        // Fall through.
        case WAIT_FAILED:

        // Fail.
        default:
            bRet = FALSE;
    }
    return bRet;
}


//--------------------------------------------------------------------
// CCredCache::Unlock
//--------------------------------------------------------------------
BOOL CCredCache::Unlock()
{
    BOOL  bRet;

    bRet = ReleaseMutex(_hMutex);

    return bRet;
}


//--------------------------------------------------------------------
// CCredCache::GetPtrToObject
//--------------------------------------------------------------------
LPDWORD CCredCache::GetPtrToObject(DWORD dwObject)
{
    return _pMMFile->GetHeaderData(dwObject);
}



//--------------------------------------------------------------------
// CCredCache::SearchCredList
//--------------------------------------------------------------------
CCred* CCredCache::SearchCredList(CSess *pSess, LPSTR szHost,
    LPSTR szRealm, LPSTR szUser, BOOL fMatchHost)
{
    CList CredList;
    CCred *pMatch = NULL;

    if (!pSess->dwCred)
        goto exit;

    CredList.Init(&pSess->dwCred);
    while (pMatch = (CCred*) CredList.GetNext())
    {
        if ((!szRealm || !lstrcmpi(szRealm, CCred::GetRealm(pMatch)))
            && (!szUser  || !lstrcmpi(szUser, CCred::GetUser(pMatch))))
        {
            if (!fMatchHost)
                break;

            CNonce *pNonce;
            CList NonceList;
            NonceList.Init(&pMatch->dwNonce);
            while (pNonce = (CNonce*) NonceList.GetNext())
            {
                if (CNonce::IsHostMatch(pNonce, szHost))
                    goto exit;
            }

            pMatch = NULL;
            break;
        }
    }
exit:
    return pMatch;
}

//--------------------------------------------------------------------
// CCredCache::UpdateInfoList
//--------------------------------------------------------------------
CCredInfo* CCredCache::UpdateInfoList(CCredInfo *pInfo, CCredInfo *pHead)
{
    CCredInfo *pList, *pCur;
    BOOL fUpdate = TRUE;

    if (!pHead)
        return (pInfo);

    pList = pCur = pHead;

    while (pCur)
    {
        // Do entry usernames match ?
        if (!strcmp(pInfo->szUser, pCur->szUser))
        {
            // Is the new entry timestamp greater?
            if (pInfo->tStamp > pCur->tStamp)
            {
                // De-link existing entry.
                if (pCur->pPrev)
                    pCur->pPrev->pNext = pCur->pNext;
                else
                    pList = pCur->pNext;

                if (pCur->pNext)
                    pCur->pNext->pPrev = pCur->pPrev;

                // Delete existing entry.
                delete pCur;
            }
            else
            {
                // Found a match but time stamp
                // of existing entry was greater.
                fUpdate = FALSE;
            }
            break;
        }
        pCur = pCur->pNext;
    }

    // If we superceded an existing matching entry
    // or found no matching entries, prepend to list.
    if (fUpdate)
    {
        pInfo->pNext = pList;
        if (pList)
            pList->pPrev = pInfo;
        pList = pInfo;
    }

    return pList;
}

//-----------------CCredCache Public Functions --------------------------------


//--------------------------------------------------------------------
// CCredCache::GetHeapPtr
//--------------------------------------------------------------------
DWORD_PTR CCredCache::GetHeapPtr()
{
    return _pMMFile->GetMapPtr();
}

//--------------------------------------------------------------------
// CCredCache::IsTrustedHost
// BUGBUG - no limits on szCtx
//--------------------------------------------------------------------
BOOL CCredCache::IsTrustedHost(LPSTR szCtx, LPSTR szHost)
{
    CHAR szBuf[MAX_PATH];
    CHAR szRegPath[MAX_PATH];

    DWORD dwType, dwError, cbBuf = MAX_PATH;
    BOOL fRet = FALSE;
    HKEY hHosts = (HKEY) INVALID_HANDLE_VALUE;

    memcpy(szRegPath, DIGEST_HOSTS_REG_KEY, sizeof(DIGEST_HOSTS_REG_KEY) - 1);
    memcpy(szRegPath + sizeof(DIGEST_HOSTS_REG_KEY) - 1, szCtx, strlen(szCtx) + 1);


    if ((dwError = RegCreateKey(HKEY_CURRENT_USER, szRegPath, &hHosts)) == ERROR_SUCCESS)
    {
        if ((dwError = RegQueryValueEx(hHosts, szHost, NULL, &dwType, (LPBYTE) szBuf, &cbBuf)) == ERROR_SUCCESS)
        {
            fRet = TRUE;
        }
    }

    if (hHosts != INVALID_HANDLE_VALUE)
        RegCloseKey(hHosts);

    return fRet;
}

//--------------------------------------------------------------------
// CCredCache::SetTrustedHostInfo
//--------------------------------------------------------------------
BOOL CCredCache::SetTrustedHostInfo(LPSTR szCtx, CParams *pParams)
{
    CHAR szRegPath[MAX_PATH], *szUrlBuf = NULL, *szHostBuf = NULL;
    DWORD dwZero = 0, dwError = ERROR_SUCCESS, cbUrlBuf, cbHostBuf;
    BOOL fRet = FALSE;
    HKEY hHosts = (HKEY) INVALID_HANDLE_VALUE;

    // Form path to trusted host reg key.
    memcpy(szRegPath, DIGEST_HOSTS_REG_KEY, sizeof(DIGEST_HOSTS_REG_KEY) - 1);
    memcpy(szRegPath + sizeof(DIGEST_HOSTS_REG_KEY) - 1, szCtx, strlen(szCtx) + 1);

    // Open top-level reg key.
    if ((dwError = RegCreateKey(HKEY_CURRENT_USER, szRegPath, &hHosts)) != ERROR_SUCCESS)
        goto exit;

    // First set authenticating host in registry.
    LPSTR szHost;
    szHost = pParams->GetParam(CParams::HOST);
    DIGEST_ASSERT(szHost);

    if ((dwError = RegSetValueEx(hHosts, szHost, NULL, REG_DWORD,
        (LPBYTE) &dwZero, sizeof(DWORD))) != ERROR_SUCCESS)
        goto exit;

    // Now check the domain header for any additional trusted hosts.
    LPSTR szDomain, pszUrl;
    DWORD cbDomain, cbUrl;
    pszUrl = NULL;
    pParams->GetParam(CParams::DOMAIN, &szDomain, &cbDomain);
    if (!szDomain)
    {
        fRet = TRUE;
        goto exit;
    }

    // Parse the domain header for urls. Crack each url to get the
    // host and set the host value in the registry.

    // First attempt to load shlwapi. If this fails then we simply do not have
    // domain header support.
    if (!g_hShlwapi)
    {
        g_hShlwapi = LoadLibrary(SHLWAPI_DLL_SZ);
        if (!g_hShlwapi)
        {
            dwError = ERROR_DLL_INIT_FAILED;
            goto exit;
        }
    }

    // Attempt to get addresses of UrlUnescape and UrlGetPart
    PFNURLUNESCAPE pfnUrlUnescape;
    PFNURLGETPART  pfnUrlGetPart;
    pfnUrlUnescape = (PFNURLUNESCAPE) GetProcAddress(g_hShlwapi, "UrlUnescapeA");
    pfnUrlGetPart  = (PFNURLGETPART)  GetProcAddress(g_hShlwapi, "UrlGetPartA");
    if (!(pfnUrlUnescape && pfnUrlGetPart))
    {
        dwError = ERROR_INVALID_FUNCTION;
        goto exit;
    }

    // Strtok through string to get each url (ws and tab delimiters)
    pszUrl = NULL;
    while (pszUrl = strtok((pszUrl ? NULL : szDomain), " \t"))
    {
        // Allocate a buffer for the url since we will first unescape it.
        // Also allocate buffer for host which will be returned from
        // call to shlwapi. Unescaped url and host buffer sizes are
        // bounded by length of original url.
        cbUrl        = strlen(pszUrl) + 1;
        cbUrlBuf     = cbHostBuf = cbUrl;
        szUrlBuf     = new CHAR[cbUrlBuf];
        szHostBuf    = new CHAR[cbHostBuf];
        if (!(szUrlBuf && szHostBuf))
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        // Copy strtoked url to buffer.
        memcpy(szUrlBuf, pszUrl, cbUrl);

        // Unescape the url
        if (S_OK == pfnUrlUnescape(szUrlBuf, NULL, NULL, URL_UNESCAPE_INPLACE))
        {
            // If unescape is successful, parse host from url.
            if (S_OK == pfnUrlGetPart(szUrlBuf, szHostBuf, &cbHostBuf, URL_PART_HOSTNAME, 0))
            {
                // If parse is successful, set host in registry.
                if ((dwError = RegSetValueEx(hHosts, szHostBuf, NULL, REG_DWORD,
                    (LPBYTE) &dwZero, sizeof(DWORD))) != ERROR_SUCCESS)
                    goto exit;
            }
        }
        delete [] szUrlBuf;
        delete [] szHostBuf;
        szUrlBuf = szHostBuf = NULL;
    }

    fRet = TRUE;

// Cleanup.
exit:

    DIGEST_ASSERT(dwError == ERROR_SUCCESS);

    if (hHosts != INVALID_HANDLE_VALUE)
        RegCloseKey(hHosts);

    if (szUrlBuf)
        delete [] szUrlBuf;

    if (szHostBuf)
        delete [] szHostBuf;

    return fRet;
}


//--------------------------------------------------------------------
// CCredCache::MapHandleToSession
//--------------------------------------------------------------------
// BUGBUG - don't walk the sessionlist, just obfuscate the ptr in handle.
CSess *CCredCache::MapHandleToSession(DWORD_PTR dwSess)
{
    // BUGBUG - if locking fails, return error directly,
    // no last error.
    CSess *pSess = NULL;
    if (!Lock())
    {
        DIGEST_ASSERT(FALSE);
        _dwStatus = GetLastError();
        goto exit;
    }

    _pSessList->Seek();

    while (pSess = (CSess*) _pSessList->GetNext())
    {
        if ((CSess*) (dwSess + (DWORD_PTR) _pMMFile->GetMapPtr()) == pSess)
            break;
    }

    Unlock();
exit:
    return pSess;
}

//--------------------------------------------------------------------
// CCredCache::MapSessionToHandle
//--------------------------------------------------------------------
DWORD CCredCache::MapSessionToHandle(CSess* pSess)
{
    DWORD dwSess = 0;

    if (!Lock())
    {
        DIGEST_ASSERT(FALSE);
        _dwStatus = GetLastError();
        goto exit;
    }

    dwSess = (DWORD) ((DWORD_PTR) pSess - _pMMFile->GetMapPtr());
    Unlock();

exit:
    return dwSess;
}



// BUGBUG - init mutex issues.
//--------------------------------------------------------------------
// CCredCache::CCredCache
//--------------------------------------------------------------------
CCredCache::CCredCache()
{
    Init();
}

//--------------------------------------------------------------------
// CCredCache::~CCredCache
//--------------------------------------------------------------------
CCredCache::~CCredCache()
{
    DeInit();
}

//--------------------------------------------------------------------
// CCredCache::Init
//--------------------------------------------------------------------
DWORD CCredCache::Init()
{
    BOOL fFirstProc;
    CHAR szMutexName[MAX_PATH];
    DWORD cbMutexName = MAX_PATH;

    _dwSig = SIG_CACH;

    // IE5# 89288
    // Get mutex name based on user
    if ((_dwStatus = CMMFile::MakeUserObjectName(szMutexName, 
        &cbMutexName, MAKE_MUTEX_NAME)) != ERROR_SUCCESS)
        return _dwStatus;
        
    // Create/Open mutex.
    _hMutex = CreateMutex(NULL, FALSE, szMutexName);

    // BUGBUG - this goes at a higher level.
    // BUGBUG - also watch out for failure to create mutex
    // and then unlocking it.
    if (_hMutex)
    {
        // Created/opened mutex. Flag if we're first process.
        fFirstProc = (GetLastError() != ERROR_ALREADY_EXISTS);
    }
    else
    {
        // Failed to create/open mutex.
        DIGEST_ASSERT(FALSE);
        _dwStatus = GetLastError();
        goto exit;
    }

    // Acquire mutex.
    if (!Lock())
    {
        DIGEST_ASSERT(FALSE);
        _dwStatus = GetLastError();
        return _dwStatus;
    }

    // Open or create memory map.
    _pMMFile = new CMMFile(CRED_CACHE_HEAP_SIZE,
        CRED_CACHE_ENTRY_SIZE);

    if (!_pMMFile)
    {
        DIGEST_ASSERT(FALSE);
        _dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    _dwStatus = _pMMFile->Init();
    if (_dwStatus != ERROR_SUCCESS)
    {
        DIGEST_ASSERT(FALSE);
        goto exit;
    }

    g_pHeap = GetHeapPtr();

    // Initialize session list.
    // BUGBUG - check return codes on failure.
    _pSessList     = new CList();

    DIGEST_ASSERT(_pSessList);
    _pSessList->Init(GetPtrToObject(CRED_CACHE_SESSION_LIST));


exit:

    // Relase mutex.
    Unlock();

    return _dwStatus;
}

//--------------------------------------------------------------------
// CCredCache::DeInit
//--------------------------------------------------------------------
DWORD CCredCache::DeInit()
{
    // bugbug - assert session list is null and destroy.
    // bugbug - release lock before closing handle.
    if (!Lock())
    {
        DIGEST_ASSERT(FALSE);
        _dwStatus = GetLastError();
        goto exit;
    }

    delete _pMMFile;
    _dwStatus = CloseHandle(_hMutex);
    Unlock();

exit:
    return _dwStatus;
}


//--------------------------------------------------------------------
// CCredCache::LogOnToCache
//--------------------------------------------------------------------
CSess *CCredCache::LogOnToCache(LPSTR szAppCtx, LPSTR szUserCtx, BOOL fHTTP)
{
    CSess *pSessNew = NULL;
    BOOL fLocked = FALSE;

    // Obtain mutex.
    if (!Lock())
    {
        DIGEST_ASSERT(FALSE);
        _dwStatus = GetLastError();
        goto exit;
    }

    fLocked = TRUE;

    // For non-http clients, find or create the single
    // global session which all non-http clients use.
    if (!fHTTP)
    {
        CSess * pSess;
        pSess = NULL;
        _pSessList->Seek();
        while (pSess = (CSess*) _pSessList->GetNext())
        {
            if (!pSess->fHTTP)
            {
                // Found the session.
                pSessNew = pSess;
                _dwStatus = ERROR_SUCCESS;
                goto exit;
            }
        }
        if (!pSessNew)
        {
            // Create the non-http gobal session.
            pSessNew = CSess::Create(_pMMFile, NULL, NULL, FALSE);
        }
    }
    else
    {
        // Create a session context; add to list.
        pSessNew = CSess::Create(_pMMFile, szAppCtx, szUserCtx, TRUE);
    }

    if (!pSessNew)
    {
        // This reflects running out of space in the memmap
        // file. Shouldn't happen in practice.
        DIGEST_ASSERT(FALSE);
        _dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }


    // Push this session on to the session list.
    _pSessList->Insert(pSessNew);

    _dwStatus = ERROR_SUCCESS;

exit:

    // Release mutex.
    if(fLocked)
        Unlock();
    return pSessNew;
}

//--------------------------------------------------------------------
// CCredCache::LogOffFromCache
//--------------------------------------------------------------------
DWORD CCredCache::LogOffFromCache(CSess *pSess)
{
    CList CredList;
    CCred *pCred;

    // Obtain mutex.
    if (!Lock())
    {
        DIGEST_ASSERT(FALSE);
        _dwStatus = GetLastError();
        goto exit;
    }

    if (pSess->fHTTP)
    {
        // Purge all credentials for this session.
        // BUGBUG - not needed.
        // CredList.Init((CEntry **) &pSess->pCred);

        // Flush all credentials for this session
        // This will also delete nonces.
        FlushCreds(pSess, NULL);

        // Finally, free the session.
        _pSessList->DeLink(pSess);
        CEntry::Free(_pMMFile, pSess);
    }

    _dwStatus = ERROR_SUCCESS;
    // Release mutex.
    Unlock();

exit:
    return _dwStatus;
}



//--------------------------------------------------------------------
// CCredCache::CreateCred
//--------------------------------------------------------------------
CCred* CCredCache::CreateCred(CSess *pSess, CCredInfo *pInfo)
{
    CCred* pCred = NULL, *pCredList;
    CList CredList;
    LPSTR szPass = NULL;

    // Obtain mutex.
    if (!Lock())
    {
        _dwStatus = GetLastError();
        goto exit;
    }

    // First check to see if any credential in this session matches realm.
    pCred = SearchCredList(pSess, NULL, pInfo->szRealm, NULL, FALSE);
    if (pCred)
    {
        CredList.Init(&pSess->dwCred);
        CredList.DeLink(pCred);
        CCred::Free(_pMMFile, pSess, pCred);
    }

    // Create a credential.
    // BUGBUG - this could fail, transact any cred update.
    pCred = CCred::Create(_pMMFile, pInfo->szHost, pInfo->szRealm,
        pInfo->szUser, (szPass = pInfo->GetPass()),
        pInfo->szNonce, pInfo->szCNonce);

    DIGEST_ASSERT(pCred);

    // Insert into head of session's credential list.
    if (!CSess::GetCred(pSess))
        CSess::SetCred(pSess, pCred);
    else
    {
        CredList.Init(&pSess->dwCred);
        CredList.Insert(pCred);
    }

    _dwStatus = ERROR_SUCCESS;

    // Relase mutex.
    Unlock();

exit:
    if (szPass)
    {
        SecureZeroMemory(szPass, strlen(szPass));
        delete [] szPass;
    }
    return pCred;
}

//--------------------------------------------------------------------
// CCredCache::FindCred
//--------------------------------------------------------------------
CCredInfo* CCredCache::FindCred(CSess *pSessIn, LPSTR szHost,
    LPSTR szRealm, LPSTR szUser, LPSTR szNonce,
    LPSTR szCNonce, DWORD dwFlags)
{
    CCred *pCred;
    CCredInfo *pInfo = NULL;
    BOOL fLocked = FALSE;

    // Obtain mutex.
    if (!Lock())
    {
        DIGEST_ASSERT(FALSE);
        _dwStatus = GetLastError();
        goto exit;
    }

    fLocked = TRUE;

    // If finding a credential for preauthentication.
    if (dwFlags & FIND_CRED_PREAUTH)
    {
        // First search this session's credential list for a match,
        // filtering on the host field in available nonces.
        pCred = SearchCredList(pSessIn, szHost, szRealm, szUser, TRUE);

        // If a credential is found the nonce is also required.
        // We do not attempt to search other sessions for a nonce
        // because nonce counts must remain in sync. See note below.
        if (pCred)
        {
            // Increment this credential's nonce count.
            CNonce *pNonce;
            pNonce = CCred::GetNonce(pCred, szHost, SERVER_NONCE);
            if (pNonce)
            {
                pNonce->cCount++;
                pInfo = new CCredInfo(pCred, szHost);
                if (!pInfo || pInfo->dwStatus != ERROR_SUCCESS)
                {
                    DIGEST_ASSERT(FALSE);
                    _dwStatus = ERROR_NOT_ENOUGH_MEMORY;
                    goto exit;
                }
            }
        }
    }

    // Otherwise if finding a credential for response to challenge.
    else if (dwFlags & FIND_CRED_AUTH)
    {
        // First search this session's credential list for a match,
        // ignoring the host field in available nonces.
        pCred = SearchCredList(pSessIn, NULL, szRealm, szUser, FALSE);

        // If a credential was found.
        if (pCred)
        {
            // Update the credential's nonce value if extant.
            // SetNonce will update any existing nonce entry
            // or create a new one if necessary.
            CCred::SetNonce(_pMMFile, pCred, szHost, szNonce, SERVER_NONCE);

            // BUGBUG - if credential contains a client nonce for a host,
            // (for MD5-sess) and is challenged for MD5, we don't revert
            // the credential's client nonce to null, so that on subsequent
            // auths we will default to MD5. Fix is to delete client nonce
            // in this case. Not serious problem though since we don't expect this.
            if (szCNonce)
                CCred::SetNonce(_pMMFile, pCred, szHost, szCNonce, CLIENT_NONCE);

            // Increment this credential's nonce count.
            CNonce *pNonce;
            pNonce = CCred::GetNonce(pCred, szHost, SERVER_NONCE);
            pNonce->cCount++;

            // Create and return the found credential.
            pInfo = new CCredInfo(pCred, szHost);
            if (!pInfo || pInfo->dwStatus != ERROR_SUCCESS)
            {
                DIGEST_ASSERT(FALSE);
                _dwStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto exit;
            }
        }

        // If no credential was found and the username has been specified
        // also search other sessions for the latest matching credential.
        else if (szUser)
        {
            CSess* pSessCur;
            _pSessList->Seek();
            CCred* pMatch;
            while (pSessCur = (CSess*) _pSessList->GetNext())
            {
                // We've already searched the session passed in.
                if (pSessIn == pSessCur)
                    continue;

                // Are this session's credentials shareable?
                if (CSess::CtxMatch(pSessIn, pSessCur))
                {
                    // Find latest credential based on time stamp.
                    CCred *pCredList;
                    pMatch = SearchCredList(pSessCur, NULL, szRealm, szUser, FALSE);
                    if (pMatch && ((!pCred || (pMatch->tStamp > pCred->tStamp))))
                    {
                        pCred = pMatch;
                    }
                }
            }

            // If we found a credential in another session, duplicate it
            // and add it to the passed in session's credential list.
            // NOTE : WHEN CREATING THE CREDENTIAL DO NOT DUPLICATE
            // THE NONCE, OTHERWISE NONCE COUNTS WILL BE INCORRECT.
            // USE THE NONCE SUPPLIED IN THE CHALLENGE.
            if (pCred)
            {
                LPSTR szPass = NULL;

                // Create a cred info from the found credential
                // and the nonce received from the challenge.
                pInfo = new CCredInfo(szHost, CCred::GetRealm(pCred),
                    CCred::GetUser(pCred), (szPass = CCred::GetPass(pCred)),
                    szNonce, szCNonce);

                if (szPass)
                {
                    SecureZeroMemory(szPass, strlen(szPass));
                    delete [] szPass;
                    szPass = NULL;
                }

                if (!pInfo || pInfo->dwStatus != ERROR_SUCCESS)
                {
                    DIGEST_ASSERT(FALSE);
                    _dwStatus = ERROR_NOT_ENOUGH_MEMORY;
                    goto exit;
                }

                // Create the credential in the session list.
                pCred = CreateCred(pSessIn, pInfo);

                // Increment this credential's nonce count
                CNonce *pNonce;
                pNonce = CCred::GetNonce(pCred, szHost, SERVER_NONCE);
                pNonce->cCount++;
            }
        }
    }

    // Otherwise we are prompting for UI.
    else if (dwFlags & FIND_CRED_UI)
    {
        // First search this session's credential list for a match,
        // ignoring the host field in available nonces.
        pCred = SearchCredList(pSessIn, NULL, szRealm, szUser, FALSE);

        if (pCred)
        {
            LPSTR szPass = NULL;

            // Create and return the found credential.
            pInfo = new CCredInfo(szHost, CCred::GetRealm(pCred),
                CCred::GetUser(pCred), (szPass = CCred::GetPass(pCred)),
                szNonce, szCNonce);

            if (szPass)
            {
                SecureZeroMemory(szPass, strlen(szPass));
                delete [] szPass;
                szPass = NULL;
            }

            if (!pInfo || pInfo->dwStatus != ERROR_SUCCESS)
            {
                DIGEST_ASSERT(FALSE);
                _dwStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto exit;
            }
        }
        else
        {
            // No credential found in this session's list. Search
            // the credentials in other sessions and assemble a list
            // of available credentials. If multiple credentials
            // are found for a user, select the latest based on
            // time stamp.
            CSess* pSessCur;
            _pSessList->Seek();
            while (pSessCur = (CSess*) _pSessList->GetNext())
            {
                // We've already searched the session passed in.
                if (pSessIn == pSessCur)
                    continue;

                // Are this session's credentials shareable?
                if (CSess::CtxMatch(pSessIn, pSessCur))
                {
                    pCred = SearchCredList(pSessCur, NULL, szRealm, szUser, FALSE);

                    if (pCred)
                    {
                        LPSTR szPass = NULL;

                        // Found a valid credential.
                        CCredInfo *pNew;
                        pNew = new CCredInfo(szHost, CCred::GetRealm(pCred),
                            CCred::GetUser(pCred), (szPass = CCred::GetPass(pCred)),
                            szNonce, szCNonce);

                        if (szPass)
                        {
                            SecureZeroMemory(szPass, strlen(szPass));
                            delete [] szPass;
                            szPass = NULL;
                        }

                        if (!pNew || pNew->dwStatus != ERROR_SUCCESS)
                        {
                            DIGEST_ASSERT(FALSE);
                            _dwStatus = ERROR_NOT_ENOUGH_MEMORY;
                            goto exit;
                        }

                        // Update list based on timestamps.
                        pInfo = UpdateInfoList(pNew, pInfo);

                    }
                }
            }
        }
    }

    _dwStatus = ERROR_SUCCESS;

exit:

    // Clean up allocated cred infos if
    // we failed for some reason.
    // bugbug - clean this up.
    if (_dwStatus != ERROR_SUCCESS)
    {
        CCredInfo *pNext;
        while (pInfo)
        {
            pNext = pInfo->pNext;
            delete pInfo;
            pInfo = pNext;
        }
        pInfo = NULL;
    }

    // Relase mutex.
    if(fLocked)
        Unlock();

    // Return any CCredInfo found, possibly a list or NULL.
    return pInfo;
}

//--------------------------------------------------------------------
// CCredCache::FlushCreds
//--------------------------------------------------------------------
VOID CCredCache::FlushCreds(CSess *pSess, LPSTR szRealm)
{
    CSess    *pSessCur;
    CCred    *pCred;
    CList    CredList;

    // Obtain mutex.
    if (!Lock())
    {
        DIGEST_ASSERT(FALSE);
        _dwStatus = GetLastError();
        return;
    }

    // BUGBUG - don't scan through all sessions.
    // BUGBUG - abstract cred deletion.
    // Flush all credentials if no session specified
    // or only the credentials of the indicated session.
    _pSessList->Seek();
    while (pSessCur = (CSess*) _pSessList->GetNext())
    {
        if (pSess && (pSessCur != pSess))
            continue;

        CredList.Init(&pSessCur->dwCred);
        while (pCred = (CCred*) CredList.GetNext())
        {
            // If a realm is specified, only delete
            // credentials with that realm.
            if (!szRealm || (!strcmp(szRealm, CCred::GetRealm(pCred))))
                CCred::Free(_pMMFile, pSessCur, pCred);
        }
    }

    // Release mutex.
    Unlock();
}


//--------------------------------------------------------------------
// CCredCache::GetStatus
//--------------------------------------------------------------------
DWORD CCredCache::GetStatus()
{
    return _dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\digest\digestui.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    digestui.cxx

Abstract:

    Authentication UI for digest sspi package.

Author:

    Adriaan Canter (adriaanc) 01-Aug-1998

History

    Sudeep Bharati (sudeepb) 24-Sep-1998
    Added support for ms specific header additions for Trustmarks
    Added support for Passport specific header additions for custom text,
    Trustmarks support and Register me button. Passport specific support
    also adds some rules on the typed in username.

    Adriaan Canter (adriaanc) 16-Dec-1998
    Expunged all Passport code.

--*/
#include "include.hxx"
#include "resource.h"
#include "exdisp.h"

HANDLE		    hDigest;

// BUGBUG - DISABLE DROP DOWN IF NO CREDS.
//--------------------------------------------------------------------
// DigestErrorDlg
//--------------------------------------------------------------------
DWORD DigestErrorDlg(LPSTR szCtx, LPSTR szHost, LPSTR szRealm,
   LPSTR szUser, LPSTR szNonce, LPSTR szCNonce, CCredInfo *pInfoIn,
   CCredInfo **ppInfoOut, HWND hWnd)
{
    INT nResult = 0;
    DWORD dwError = ERROR_SUCCESS;
    LPTSTR  lpRes;
    DigestDlgParams DlgPrms;

    // Parameters to be passed to DigestAuthDialogProc.
    DlgPrms.szCtx   = szCtx;
    DlgPrms.szHost  = szHost;
    DlgPrms.szRealm = szRealm;
    DlgPrms.szUser  = szUser;
    DlgPrms.szNonce = szNonce;
    DlgPrms.szCNonce = szCNonce;
    DlgPrms.pInfoIn = pInfoIn;


    LPARAM lpParam = (LPARAM) &DlgPrms;
    if (WaitForSingleObject (hDigest, INFINITE) != WAIT_OBJECT_0) {
	    dwError = ERROR_NOT_READY;
	    goto quit;
    }

    lpRes = MAKEINTRESOURCE(IDD_DIGEST);


    nResult = (INT)DialogBoxParam(g_hModule,
			     lpRes,
                             hWnd,
                             DigestAuthDialogProc,
                             (LPARAM) lpParam);


    if (nResult == FALSE || nResult == -1)
    {
        dwError = ERROR_CANCELLED;
        *ppInfoOut = NULL;
        goto quit;
    }

    // *ppInfoOut points to a CCredInfo created in the
    // DigestAuthDialog proc.
    *ppInfoOut = DlgPrms.pInfoOut;

quit:
    // delete DlgPrms.szCtx; biaow: we should NOT delete here; the caller will take care of this
    return dwError;
}



//--------------------------------------------------------------------
// DigestAuthDialogProc
//--------------------------------------------------------------------
INT_PTR CALLBACK DigestAuthDialogProc(HWND hwnd, UINT msg,
    WPARAM wparam, LPARAM lparam)
{
    static CCredInfo *pList = NULL;
    static HWND hCtrlText,hCtrlVerify;

    PDigestDlgParams pDlgPrms;
    USHORT len;
    LPSTR   p,q;

    CHAR szUser[MAX_USERNAME_LEN + 1];
    CHAR szPass[MAX_PASSWORD_LEN + 1];

    BOOL fCreated    = FALSE;
    BOOL fPersisted = FALSE;

    BSTR bstr;
    CHAR szTextTemp [MAX_LOGIN_TEXT];
    CHAR szText [MAX_LOGIN_TEXT];

    switch (msg)
    {
        // Dialog is being initialized.
        case WM_INITDIALOG:
        {
            ReleaseMutex (hDigest);

            // pDlgPrms->pInfoIn can be NULL or point
            // to one or more CCredInfo structs.
            pDlgPrms = (DigestDlgParams *) lparam;
            DIGEST_ASSERT(pDlgPrms);

            SetWindowLongPtr(hwnd, DWLP_USER, lparam);

            SetForegroundWindow(hwnd);

	    // Take Care of Host field

	    hCtrlText = GetDlgItem (hwnd, IDD_LOGIN_TEXT1);
	    len = (USHORT)GetWindowText (hCtrlText,szTextTemp,MAX_LOGIN_TEXT);
	    if (len == 0) {
		DIGEST_ASSERT(FALSE);
		EndDialog (hwnd, FALSE);
		return TRUE;
	    }
	    if ((p = strchr (szTextTemp, '%')) == NULL) {
		DIGEST_ASSERT(FALSE);
		EndDialog (hwnd, FALSE);
		return TRUE;
	    }
	    *p++ = '\0';
	    strcpy (szText, szTextTemp);
	    if (pDlgPrms->szHost)
		strncat (szText,pDlgPrms->szHost, sizeof(szText) / sizeof(szText[0]) - (strlen(szText) + strlen(p) + 1));
	    else {
		if (len = (USHORT)LoadString (g_hModule,IDS_STRING_UDOMAIN,
				     szUser,MAX_USERNAME_LEN))
		    strcat (szText,szUser);
	    }
	    strcat (szText, p);
	    if (!SetWindowText (hCtrlText,szText)) {
		DIGEST_ASSERT(FALSE);
		EndDialog (hwnd, FALSE);
		return TRUE;
	    }


	    // Take care of Realm and Hint fields. Remember Passport has
	    // hard coded text for this second line.
		hCtrlText = GetDlgItem (hwnd, IDD_LOGIN_TEXT2);
		len = (USHORT)GetWindowText (hCtrlText,szTextTemp,MAX_LOGIN_TEXT);
		if (len == 0) {
		    DIGEST_ASSERT(FALSE);
		    EndDialog (hwnd, FALSE);
		    return TRUE;
		}
		if ((p = strchr (szTextTemp, '%')) == NULL) {
			DIGEST_ASSERT(FALSE);
			EndDialog (hwnd, FALSE);
			return TRUE;
		}
		*p++ = '\0';
		strcpy (szText, szTextTemp);
		if (pDlgPrms->szRealm)
        {
			DWORD dwAvailBuf = MAX_LOGIN_TEXT - strlen(szText);
            strncpy(szText + strlen(szText), pDlgPrms->szRealm, dwAvailBuf - 1);
            szText[MAX_LOGIN_TEXT - 1] = 0;
            // strcat (szText,pDlgPrms->szRealm);
        }
		else {
		    if (len = (USHORT)LoadString (g_hModule,IDS_STRING_UREALM,
					 szUser,MAX_USERNAME_LEN))
			strcat (szText,szUser);
		}

		strcat (szText,p);

		if (!SetWindowText (hCtrlText,szText)) {
			DIGEST_ASSERT(FALSE);
			EndDialog (hwnd, FALSE);
			return TRUE;
		}

            // Determine if credential persistence is available.
            if (g_dwCredPersistAvail == CRED_PERSIST_UNKNOWN)
                g_dwCredPersistAvail = InetInitCredentialPersist();

            // If credential persist not available, hide checkbox.
            if (g_dwCredPersistAvail == CRED_PERSIST_NOT_AVAIL)
                ShowWindow(GetDlgItem(hwnd, IDC_SAVE_PASSWORD), SW_HIDE);


            // Find any persisted credential.
            if (g_dwCredPersistAvail
                && ((InetGetCachedCredentials(pDlgPrms->szCtx, pDlgPrms->szRealm,
                    szUser, szPass) == ERROR_SUCCESS)))
            {
                // Retrieved a set of credentials. If a username was passed
                // in check to see that the persisted username matches.
                if (!pDlgPrms->szUser || !strcmp(pDlgPrms->szUser, szUser))
                {
                    // No username passed in or usernames match.
                    // Create a CCredInfo and insert it into head of list.
                    pList = new CCredInfo(pDlgPrms->szHost, pDlgPrms->szRealm, szUser, szPass,
                        pDlgPrms->szNonce, pDlgPrms->szCNonce);
                    if (!pList || pList->dwStatus != ERROR_SUCCESS)
                    {
                        DIGEST_ASSERT(FALSE);
                        return FALSE;
                    }
                    // Insert it at the beginning of the list.
                    pList->pNext = pDlgPrms->pInfoIn;
                    if (pDlgPrms->pInfoIn)
                        pDlgPrms->pInfoIn->pPrev = pList;

                    fPersisted = TRUE;
                    fCreated = TRUE;
                }
            }

            // If we did not retrieve a persisted credential, check to see
            // if we need to create a dummy credential.
            if (!fPersisted)
            {
                // Create a dummy credential if a username was passed in
                // but a credential was not retrieved from memory.
                if (pDlgPrms->szUser && !pDlgPrms->pInfoIn)
                {
                    pList = new CCredInfo(pDlgPrms->szHost, pDlgPrms->szRealm, pDlgPrms->szUser, NULL,
                        pDlgPrms->szNonce, pDlgPrms->szCNonce);
                    fCreated = TRUE;
                }
                else
                {
                    // Otherwise, just point to the creds
                    // retrieved from memory.
                    pList = pDlgPrms->pInfoIn;
                }

            }
            else
            {
                // A persisted credential was created and inserted
                // into the beginning of the list. The list may
                // contain a CCredInfo with a matching user.
                // remove any (at most one) duplicate entry.
                CCredInfo *pCur;
                pCur = pList->pNext;
                while (pCur)
                {
                    if (!strcmp(pCur->szUser, pList->szUser))
                    {
                        pCur->pPrev->pNext = pCur->pNext;
                        if (pCur->pNext)
                            pCur->pNext->pPrev = pCur->pPrev;

                        break;
                    }
                    pCur = pCur->pNext;
                }
            }

            // The list is now in the correct format:
            // 1) pList may be NULL
            // 2) pList may have a dummy credential for username with no password.
            // 3) pList may have one credential for username with password.
            // 4) pList may have one or more credentials for different usernames.

            // Limit drop-down if no items in list.
            if (!pList)
            {
                SendMessage(GetDlgItem(hwnd, IDC_COMBO1), CB_ADDSTRING, 0, (LPARAM) (LPCSTR) "");
            }

            // Populate the combo box with the list contents.
            CCredInfo *pCur;
            pCur = pList;
            while (pCur)
            {
                SendMessage(GetDlgItem(hwnd, IDC_COMBO1), CB_ADDSTRING, 0, (LPARAM) (LPCSTR) pCur->szUser);
                pCur = pCur->pNext;
            }

            // If the first item in the combo box was created (user given or persisted)
            // set it as the default and set it's password in the password control.
            // Indicate if credentials are from persisted store.

            // Default to 0th item.
            SendMessage(GetDlgItem(hwnd, IDC_COMBO1), CB_SETCURSEL, 0, 0);

            // Set password field if extant.
            if (pList)
            {
                LPSTR szPassTmp = pList->GetPass();
                SetWindowText (GetDlgItem(hwnd,IDC_PASSWORD_FIELD), szPassTmp ? szPassTmp : "");
                if (szPassTmp)
                {
                    SecureZeroMemory(szPassTmp, strlen(szPassTmp));
                    delete [] szPassTmp;
                }
            }

            // Indicate if credentials from persisted store.
            if (fPersisted)
                CheckDlgButton(hwnd, IDC_SAVE_PASSWORD, BST_CHECKED);

            SetFocus(GetDlgItem(hwnd, IDC_COMBO1));

            // Return FALSE since we are always setting the keyboard focus.
            return FALSE;
        }

        // WM comands from action on dialog.
        case WM_COMMAND:
        {
            WORD wID               = LOWORD(wparam);
            WORD wNotificationCode = HIWORD(wparam);
            HWND hWndCtrl          = (HWND) lparam;

            pDlgPrms = (DigestDlgParams*) GetWindowLongPtr(hwnd, DWLP_USER);
            DIGEST_ASSERT(pDlgPrms);

            // User has selected something on the combo-box.
            switch(wNotificationCode)
            {
                // User has selected a drop-down item.
                case CBN_SELCHANGE:
                {
                    // Get the index of the selected item.
                    DWORD nIndex;
                    nIndex = (DWORD)SendMessage(GetDlgItem(hwnd, IDC_COMBO1), CB_GETCURSEL, 0, 0);
                    if (nIndex == -1)
                    {
                        SendMessage(GetDlgItem(hwnd, IDC_COMBO1), CB_SETCURSEL, 0, 0);
                        return FALSE;
                    }

                    // Point to the indexed CCredInfo entry
                    CCredInfo *pCur;
                    pCur = pList;
                    for (DWORD i = 0; i < nIndex ; i++)
                        pCur = pCur->pNext;

                    // Set password of the indexed CCredInfo struct.
                    {
                        LPSTR szPassTmp = pCur ? pCur->GetPass() : NULL;
                        SetWindowText (GetDlgItem(hwnd,IDC_PASSWORD_FIELD), szPassTmp ? szPassTmp : "");
                        if (szPassTmp)
                        {
                            SecureZeroMemory(szPassTmp, strlen(szPassTmp));
                            delete [] szPassTmp;
                        }
                    }

                    // User may have selected username with persisted credentials.
                    if (g_dwCredPersistAvail)
                    {
                        // If selected CCredInfo has a user with persisted credentials
                        if ((InetGetCachedCredentials(pDlgPrms->szCtx, pDlgPrms->szRealm,
                            szUser, szPass) == ERROR_SUCCESS)
                            && !strcmp(pCur->szUser, szUser))
                        {
                            // Indicate that this user has persisted creds for the realm.
                            CheckDlgButton(hwnd, IDC_SAVE_PASSWORD, BST_CHECKED);
                        }
                        else
                        {
                            // Otherwise Indicate that this user does not have persisted
                            // creds for the realm.
                            CheckDlgButton(hwnd, IDC_SAVE_PASSWORD, BST_UNCHECKED);
                        }
                    }
                }
                return FALSE;
            }

            // User has clicked OK or Cancel button.
            switch (wID)
            {
                case IDOK:
                {
                    CCredInfo *pOut;

                    // User has clicked on OK button.

                    // Get the username and password into the output CCredInfo.
                    GetWindowText(GetDlgItem(hwnd,IDC_COMBO1), szUser, MAX_USERNAME_LEN);
                    GetWindowText(GetDlgItem(hwnd,IDC_PASSWORD_FIELD), szPass, MAX_PASSWORD_LEN);


                    // If save box checked, persist credentials.
                    if (IsDlgButtonChecked(hwnd, IDC_SAVE_PASSWORD) == BST_CHECKED)
                    {
                        InetSetCachedCredentials(pDlgPrms->szCtx, pDlgPrms->szRealm,
                            szUser, szPass);
                    }
                    else
                    {
                        // Otherwise the button is not checked. Check to see if we should
                        // remove the credentials from persisted store.
                        if (g_dwCredPersistAvail)
                        {
                            // If current and original credentials are for same user,
                            // remove the credentials.
                            CHAR szUserPersist[MAX_USERNAME_LEN], szPassPersist[MAX_PASSWORD_LEN];
                            if ((InetGetCachedCredentials(pDlgPrms->szCtx, pDlgPrms->szRealm,
                                szUserPersist, szPassPersist) == ERROR_SUCCESS)
                                && !strcmp(szUser, szUserPersist))
                            {
                                InetRemoveCachedCredentials(pDlgPrms->szCtx, pDlgPrms->szRealm);
                            }
                        }
                    }

                    // Allocate a new CCredInfo struct to return.
                    pOut = new CCredInfo(pDlgPrms->szHost, pDlgPrms->szRealm, szUser, szPass,
                        pDlgPrms->szNonce, pDlgPrms->szCNonce);
                    if (!pOut)
                    {
                        DIGEST_ASSERT(FALSE);
                    }
                    pDlgPrms->pInfoOut = pOut;
                    EndDialog(hwnd, TRUE);
                    break;
                }
                case IDCANCEL:
                {
                    // User has canceled dialog - no action.
                    EndDialog(hwnd, FALSE);
                    break;
                }
            }
            return FALSE;
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\digest\digesta.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    digesta.cxx

Abstract:

    sspi ansi interface for digest package.

Author:

    Adriaan Canter (adriaanc) 01-Aug-1998

--*/
#include "include.hxx"


static SecurityFunctionTableA

    SecTableA =
    {
        SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION,
        EnumerateSecurityPackagesA,
        NULL,                          // QueryCredentialsAttributesA
        AcquireCredentialsHandleA,
        FreeCredentialsHandle,
        NULL,                          // SspiLogonUserA
        InitializeSecurityContextA,
        AcceptSecurityContext,
        CompleteAuthToken,
        DeleteSecurityContext,
        ApplyControlToken,
        QueryContextAttributesA,
        ImpersonateSecurityContext,
        RevertSecurityContext,
        MakeSignature,
        VerifySignature,
        FreeContextBuffer,
        QuerySecurityPackageInfoA,
        NULL,                          // Reserved3
        NULL,                          // Reserved4
        NULL,                          // ExportSecurityContext
        NULL,                          // ImportSecurityContextA
        NULL,                          // Reserved7
        NULL,                          // Reserved8
        NULL,                          // QuerySecurityContextToken
        NULL,                          // EncryptMessage
        NULL                           // DecryptMessage
    };



//--------------------------------------------------------------------------
//
//  Function:   InitSecurityInterfaceA
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
extern "C" PSecurityFunctionTableA SEC_ENTRY
InitSecurityInterfaceA(VOID)
{
    PSecurityFunctionTableA pSecTableA = &SecTableA;
    return pSecTableA;
}


//--------------------------------------------------------------------------
//
//  Function:   AcquireCredentialsHandleA
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
// HEINOUS SSPI HACK here: AcquireCredentialsHandle is called with the package
// name ("Digest") as the package identifier. When AcquireCredentialsHandle returns
// to the caller PCredHandle->dwLower is set by security.dll to be the index of
// the package returned. EnumerateSecurityPackages. This is how SSPI resolves the
// correct provider dll when subsequent calls are made through the dispatch table
// (PSecurityFunctionTale). Any credential *or* context handle handed out by the
// package must have the dwLower member set to this index so that subsequent calls
// can resolve the dll from the handle.
//
//--------------------------------------------------------------------------
extern "C" SECURITY_STATUS SEC_ENTRY
AcquireCredentialsHandleA(
    LPSTR                       pszPrincipal,       // Name of principal
    LPSTR                       pszPackageName,     // Name of package
    DWORD                       dwCredentialUse,    // Flags indicating use
    VOID SEC_FAR *              pvLogonId,          // Pointer to logon ID
    VOID SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    VOID SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    )
{
    if (!InitGlobals())
        return SEC_E_INTERNAL_ERROR;

    SECURITY_STATUS ssResult;

    // Outbound credentials only.
    if (!(dwCredentialUse & SECPKG_CRED_OUTBOUND)
        || (dwCredentialUse & SECPKG_CRED_INBOUND))
    {
        DIGEST_ASSERT(FALSE);
        ssResult = SEC_E_UNKNOWN_CREDENTIALS;
        goto exit;
    }

    // Logon to cache.

    // Logon to the cache and get the session context.
    CSess *pSess;
    PSEC_WINNT_AUTH_IDENTITY_EXA pSecIdExA;
    PSEC_WINNT_AUTH_IDENTITY     pSecId;

    // HTTP clients will pass in this structure.
    pSecIdExA = (PSEC_WINNT_AUTH_IDENTITY_EXA) pAuthData;

    // Non-HTTP clients (OE4, OE5) will pass in this structure.
    pSecId    = (PSEC_WINNT_AUTH_IDENTITY)     pAuthData;

    // Check for HTTP client application logon.
    if (pAuthData
        && (pSecIdExA->Version == sizeof(SEC_WINNT_AUTH_IDENTITY_EXA))
        && pSecIdExA->User
        && pSecIdExA->UserLength == sizeof(DIGEST_PKG_DATA))
    {
        DIGEST_PKG_DATA *pPkgData;
        pPkgData = (DIGEST_PKG_DATA*) pSecIdExA->User;
        pSess = g_pCache->LogOnToCache(pPkgData->szAppCtx,
            pPkgData->szUserCtx, TRUE);
    }
    // Check for non-HTTP client application logon.
    else
    {
        // Find or create the single non-HTTP session.
        pSess = g_pCache->LogOnToCache(NULL, NULL, FALSE);

        // If user+pass+realm (domain) is passed in, create and
        // attach a matching credential to this session.
        if (pAuthData
            && pSecId->User
            && pSecId->UserLength
            && pSecId->Domain
            && pSecId->DomainLength
            && pSecId->Password
            && pSecId->PasswordLength)
        {
            // Create a credential with the information passed in.
            CCred *pCred;
            CCredInfo *pInfo;
            pInfo = new CCredInfo(NULL, (LPSTR) pSecId->Domain,
                (LPSTR) pSecId->User, (LPSTR) pSecId->Password, NULL, NULL);
            if (pInfo)
            {
                pCred = g_pCache->CreateCred(pSess, pInfo);
                delete pInfo;
            }
        }
    }

    // BUGBUG - return better error codes.
    if (!pSess)
    {
        DIGEST_ASSERT(FALSE);
        ssResult = SEC_E_INTERNAL_ERROR;
        goto exit;
    }

    // Hand out the session handle.
    phCredential->dwUpper = g_pCache->MapSessionToHandle(pSess);

    // ***** phCredential->dwLower will be set by security.dll *****

    ssResult = SEC_E_OK;

exit:
    return ssResult;
}



//--------------------------------------------------------------------------
//
//  Function:   FreeCredentialsHandle
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
extern "C" SECURITY_STATUS SEC_ENTRY
FreeCredentialsHandle(PCredHandle phCredential)
{
    // bugbug - asserted.
    if (!InitGlobals())
        return SEC_E_INTERNAL_ERROR;

    SECURITY_STATUS ssResult;

    // Get the session context from the handle.
    CSess *pSess;

    pSess = g_pCache->MapHandleToSession(phCredential->dwUpper);
    if (!pSess)
    {
        DIGEST_ASSERT(FALSE);
        ssResult = SEC_E_UNKNOWN_CREDENTIALS;
        goto exit;
    }

    // Logoff from the cache.
    if (g_pCache->LogOffFromCache(pSess) != ERROR_SUCCESS)
    {
        DIGEST_ASSERT(FALSE);
        ssResult = SEC_E_INTERNAL_ERROR;
        goto exit;
    }
        ssResult = SEC_E_OK;
exit:
    return ssResult;
}


//--------------------------------------------------------------------------
//
//  Function:   InitializeSecurityContextA
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
extern "C" SECURITY_STATUS SEC_ENTRY
InitializeSecurityContextA(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    LPSTR                       pszTargetName,      // Name of target
    DWORD                       fContextReq,        // Context Requirements
    DWORD                       Reserved1,          // Reserved, MBZ
    DWORD                       TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    DWORD                       Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    DWORD         SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    if (!InitGlobals())
        return SEC_E_INTERNAL_ERROR;

    LPSTR szHost, szRealm, szUser, szPass, szNonce;
    DWORD cbHost, cbRealm, cbUser, cbPass, cbNonce;

    LPSTR szCtx = NULL;
    SECURITY_STATUS ssResult = SEC_E_OK;

    // Client nonce NULL except for md5-sess.
    LPSTR szCNonce = NULL;

    CSess       *pSess;
    CCred       *pCred;
    CParams     *pParams  = NULL;
    CCredInfo   *pInfo = NULL;

    // Rude credential flush for all apps.
    if (!phCredential && (fContextReq & ISC_REQ_NULL_SESSION))
    {
        g_pCache->FlushCreds(NULL, NULL);
        ssResult = SEC_E_OK;
        goto exit;
    }

    // Get the session pointer from the handle.
    pSess = g_pCache->MapHandleToSession(phCredential->dwUpper);
    if (!pSess)
    {
        DIGEST_ASSERT(FALSE);
        ssResult = SEC_E_UNKNOWN_CREDENTIALS;
        goto exit;
    }

    // Legacy conn. oriented client may require a continue
    // message on null buffer input.
    if (!pSess->fHTTP && !pInput && pOutput)
    {
        *((LPDWORD) (pOutput->pBuffers[0].pvBuffer)) = 0;
        pOutput->pBuffers[0].cbBuffer = sizeof(DWORD);
        ssResult = SEC_I_CONTINUE_NEEDED;
        goto exit;
    }

    // Flush creds for indicated session.
    if (fContextReq & ISC_REQ_NULL_SESSION)
    {
        g_pCache->FlushCreds(pSess, NULL);
        ssResult = SEC_E_OK;
        goto exit;
    }

    DIGEST_ASSERT(phCredential && pInput && pOutput);

    // Parse the challenge to a params object.
    if (CDigest::ParseChallenge(pSess, pInput,
        &pParams, fContextReq) != ERROR_SUCCESS)
    {
        // DIGEST_ASSERT(FALSE);
        ssResult = SEC_E_INVALID_TOKEN;
        goto exit;
    }

    // Get host, realm (required) and any nonce, user & pass.
    pParams->GetParam(CParams::HOST,  &szHost, &cbHost);
    pParams->GetParam(CParams::REALM, &szRealm, &cbRealm);
    pParams->GetParam(CParams::NONCE,  &szNonce, &cbNonce);
    pParams->GetParam(CParams::USER,  &szUser, &cbUser);
    pParams->GetParam(CParams::PASS,  &szPass, &cbPass);


    // If prompting UI is indicated.
    if (fContextReq & ISC_REQ_PROMPT_FOR_CREDS)
    {
        CCredInfo *pInfoIn, *pInfoOut;

        // Attempt to get one or more cred infos
        pInfoIn = g_pCache->FindCred(pSess, szHost, szRealm,
            szUser, NULL, NULL, FIND_CRED_UI);

        // Get the persistence key from pSess
        szCtx = CSess::GetCtx(pSess);
        DIGEST_ASSERT(szCtx);

        // If this is prompting for UI specifying md5-sess,
        // create a client nonce to associate with cred.
        if (pParams->IsMd5Sess())
            szCNonce = CDigest::MakeCNonce();

        pParams->GetParam(CParams::HOST,  &szHost, &cbHost);

        // Prompt with authentication dialog.
        if (DigestErrorDlg(szCtx, szHost, szRealm,
            szUser, szNonce, szCNonce,
            pInfoIn, &pInfoOut, pParams->GetHwnd()) == ERROR_SUCCESS)
        {
            DIGEST_ASSERT(pInfoOut);

            // Create the credential.
            pCred = g_pCache->CreateCred(pSess, pInfoOut);

            // Record that the host is trusted.
            if (pSess->fHTTP)
                CCredCache::SetTrustedHostInfo(szCtx, pParams);

        }
        else
        {
            ssResult = SEC_E_NO_CREDENTIALS;
            goto exit;
        }

        // Retrieve the credentials just created.
        pInfo = g_pCache->FindCred(pSess, szHost, szRealm,
            pInfoOut->szUser, szNonce, szCNonce, FIND_CRED_AUTH);

        // Clean up one or more cred infos.
        // BUGBUG - null out pointers after freeing.
        while (pInfoIn)
        {
            CCredInfo *pNext;
            pNext = pInfoIn->pNext;
            delete pInfoIn;
            pInfoIn = pNext;
        }

        if (pInfoOut)
            delete pInfoOut;

        if (szCNonce)
            delete szCNonce;

        if (!pInfo)
        {
            ssResult = SEC_E_NO_CREDENTIALS;
            goto exit;
        }

    }

    // Otherwise we are attempting to authenticate. We may be either
    // authenticating in response to a challenge or pre-authenticating.
    else
    {
        // Get the persistence key from pSess
        szCtx = CSess::GetCtx(pSess);
        DIGEST_ASSERT(szCtx);

        // For HTTP sessions we check the trusted host list unless
        // 1) credentials are supplied, or 2) a context has been passed
        // in which specifically instructs to ignore the host list.
        if (pSess->fHTTP && !pParams->IsPreAuth() && !pParams->AreCredsSupplied())
        {
            if (!phContext || !(phContext->dwUpper & DIGEST_PKG_FLAGS_IGNORE_TRUSTED_HOST_LIST))
            {
                if (!CCredCache::IsTrustedHost(szCtx, szHost))
                {
                    ssResult = SEC_E_NO_CREDENTIALS;
                    goto exit;
                }
            }
        }

        // If preauthenticating.
        if (pParams->IsPreAuth())
        {
            // If using supplied credentials.
            if (pParams->AreCredsSupplied())
            {
                // Create a cred info using supplied values. Include passed-in NC.
                pInfo = new CCredInfo(szHost, szRealm, szUser, szPass, szNonce, szCNonce);
                pInfo->cCount = pParams->GetNC();

                if (!(pInfo && pInfo->dwStatus == ERROR_SUCCESS))
                {
                    DIGEST_ASSERT(FALSE);
                    ssResult = SEC_E_INTERNAL_ERROR;
                    goto exit;
                }
            }
            // Otherwise attempt to find cred info in cache.
            else
            {
                // Attempt to find the credentials from realm and any user.
                pInfo = g_pCache->FindCred(pSess, szHost, szRealm,
                    szUser, NULL, NULL, FIND_CRED_PREAUTH);
            }

            // Return if no credentials exist.
            if (!pInfo)
            {
                ssResult = SEC_E_NO_CREDENTIALS;
                goto exit;
            }
        }
        // Otherwise auth in response to challenge.
        else
        {
            // Check if logoff is requested.
            CHAR* szLogoff;
            szLogoff = pParams->GetParam(CParams::LOGOFF);
            if (szLogoff && !lstrcmpi(szLogoff, "TRUE"))
            {
                g_pCache->FlushCreds(NULL, szRealm);
                ssResult = SEC_E_CONTEXT_EXPIRED;
                goto exit;
            }

            // If a context is passed in examine the stale header unless specifically
            // directed not to.
            if (pSess->fHTTP
                && phContext
                && !pParams->AreCredsSupplied()
                && !(phContext->dwUpper & DIGEST_PKG_FLAGS_IGNORE_STALE_HEADER))
            {
                CHAR* szStale;
                DWORD cbStale;
                pParams->GetParam(CParams::STALE, &szStale, &cbStale);
                if (!szStale || !lstrcmpi(szStale, "FALSE"))
                {
                    ssResult = SEC_E_NO_CREDENTIALS;
                    goto exit;
                }
            }

            // If this is authenticating specifying md5-sess,
            // create a client nonce to associate with cred.
            if (pParams->IsMd5Sess())
                szCNonce = CDigest::MakeCNonce();

            // If credentials are supplied, create an entry in
            // the credential cache. We search as usual subsequently.
            if (pParams->AreCredsSupplied())
            {
                // Create a cred info using supplied values.
                pInfo = new CCredInfo(szHost, szRealm, szUser, szPass, szNonce, szCNonce);

                if (!(pInfo && pInfo->dwStatus == ERROR_SUCCESS))
                {
                    DIGEST_ASSERT(FALSE);
                    ssResult = SEC_E_INTERNAL_ERROR;
                    goto exit;
                }

                pCred = g_pCache->CreateCred(pSess, pInfo);
                delete pInfo;
            }

            // Attempt to find the credentials from realm and any user.
            pInfo = g_pCache->FindCred(pSess, szHost, szRealm,
                szUser, szNonce, szCNonce, FIND_CRED_AUTH);

            // Return if no credentials exist.
            if (!pInfo)
            {
                ssResult = SEC_E_NO_CREDENTIALS;
                goto exit;
            }
        }
    }

    // We should now have the appropriate cred info. Generate the response.
    DIGEST_ASSERT(pInfo);
    if (CDigest::GenerateResponse(pSess, pParams,
        pInfo, pOutput) != ERROR_SUCCESS)
    {
        DIGEST_ASSERT(FALSE);
        ssResult = SEC_E_INTERNAL_ERROR;
        goto exit;
    }

    // Delete cred info if allocated.
    // bugbug - move further down.
    if (pInfo)
        delete pInfo;

    ssResult = SEC_E_OK;

exit:

    if ((ssResult != SEC_E_OK) &&
        (ssResult != SEC_I_CONTINUE_NEEDED))
        pOutput->pBuffers[0].cbBuffer = 0;

    // BUGBUG - delete pInfo if not NULL.
    // Delete persistence key if allocated.
    if (szCtx)
        delete szCtx;

    // Identify the new context.
    if (phNewContext && phCredential)
        phNewContext->dwLower = phCredential->dwLower;

    // Delete the params object.
    if (pParams)
        delete pParams;

    return ssResult;
}



//--------------------------------------------------------------------------
//
//  Function:   AcceptSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
extern "C" SECURITY_STATUS SEC_ENTRY
AcceptSecurityContext(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    PSecBufferDesc              pInput,             // Input buffer
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               TargetDataRep,      // Target Data Rep
    PCtxtHandle                 phNewContext,       // (out) New context handle
    PSecBufferDesc              pOutput,            // (inout) Output buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attributes
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    // BUGBUG - don't need initglobals.
    if (!InitGlobals())
        return SEC_E_INTERNAL_ERROR;

    return(SEC_E_UNSUPPORTED_FUNCTION);
}






//--------------------------------------------------------------------------
//
//  Function:   DeleteSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
extern "C" SECURITY_STATUS SEC_ENTRY
DeleteSecurityContext(
    PCtxtHandle                 phContext           // Context to delete
    )
{
    if (!InitGlobals())
        return SEC_E_INTERNAL_ERROR;

    return SEC_E_UNSUPPORTED_FUNCTION;
}



//--------------------------------------------------------------------------
//
//  Function:   ApplyControlToken
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
extern "C" SECURITY_STATUS SEC_ENTRY
ApplyControlToken(
    PCtxtHandle                 phContext,          // Context to modify
    PSecBufferDesc              pInput              // Input token to apply
    )
{
    if (!InitGlobals())
        return SEC_E_INTERNAL_ERROR;

    SECURITY_STATUS ssResult;

    // Current flags used are
    // DIGEST_PKG_FLAG_IGNORE_TRUSTED_HOST_LIST
    // DIGEST_PKG_FLAG_IGNORE_STALE_HEADER
    phContext->dwUpper |= *((LPDWORD) (pInput->pBuffers[0].pvBuffer));

    ssResult = SEC_E_OK;
    return ssResult;
}




//--------------------------------------------------------------------------
//
//  Function:   EnumerateSecurityPackagesA
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
EnumerateSecurityPackagesA(DWORD SEC_FAR *pcPackages,
    PSecPkgInfoA SEC_FAR *ppSecPkgInfo)
{

    SECURITY_STATUS ssResult;
    // BUGBUG - ALLOW ASSERTS?
    ssResult = QuerySecurityPackageInfoA(PACKAGE_NAME, ppSecPkgInfo);
    if (ssResult == SEC_E_OK)
    {
        *pcPackages = 1;
    }
    return ssResult;
}



//--------------------------------------------------------------------------
//
//  Function:   QuerySecurityPackageInfoA
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
QuerySecurityPackageInfoA(LPSTR szPackageName,
    PSecPkgInfoA SEC_FAR *ppSecPkgInfo)
{
    // BUGBUG - ALLOW ASSERTS?
    PSecPkgInfoA pSecPkgInfo;
    DWORD cbSecPkgInfo;
    SECURITY_STATUS ssResult;
    LPSTR pCur;


    if (strcmp(szPackageName, PACKAGE_NAME))
    {
        ssResult = SEC_E_SECPKG_NOT_FOUND;
        goto exit;
    }

    cbSecPkgInfo = sizeof(SecPkgInfoA)
        + sizeof(PACKAGE_NAME)
        + sizeof(PACKAGE_COMMENT);

    pSecPkgInfo = (PSecPkgInfoA) LocalAlloc(0,cbSecPkgInfo);

    if (!pSecPkgInfo)
    {
        ssResult = SEC_E_INSUFFICIENT_MEMORY;
        goto exit;
    }

    pSecPkgInfo->fCapabilities = PACKAGE_CAPABILITIES;
    pSecPkgInfo->wVersion      = PACKAGE_VERSION;
    pSecPkgInfo->wRPCID        = PACKAGE_RPCID;
    pSecPkgInfo->cbMaxToken    = PACKAGE_MAXTOKEN;

    pCur  = (LPSTR) (pSecPkgInfo) + sizeof(SecPkgInfoA);

    pSecPkgInfo->Name = pCur;
    memcpy(pSecPkgInfo->Name, PACKAGE_NAME, sizeof(PACKAGE_NAME));
    pCur += sizeof(PACKAGE_NAME);

    pSecPkgInfo->Comment = pCur;
    memcpy(pSecPkgInfo->Comment, PACKAGE_COMMENT, sizeof(PACKAGE_COMMENT));

    *ppSecPkgInfo = pSecPkgInfo;

    ssResult = SEC_E_OK;

exit:
    return ssResult;
}



//--------------------------------------------------------------------------
//
//  Function:   FreeContextBuffer
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
extern "C" SECURITY_STATUS SEC_ENTRY
FreeContextBuffer(void SEC_FAR *pvContextBuffer)
{
    if (!InitGlobals())
        return SEC_E_INTERNAL_ERROR;

    LocalFree(pvContextBuffer);
    return SEC_E_OK;
}



//--------------------------------------------------------------------------
//
//  Function:   CompleteAuthToken
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
extern "C" SECURITY_STATUS SEC_ENTRY
CompleteAuthToken(
    PCtxtHandle                 phContext,          // Context to complete
    PSecBufferDesc              pToken              // Token to complete
    )
{
    if (!InitGlobals())
        return SEC_E_INTERNAL_ERROR;

    return SEC_E_UNSUPPORTED_FUNCTION;
}



//--------------------------------------------------------------------------
//
//  Function:   ImpersonateSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
extern "C" SECURITY_STATUS SEC_ENTRY
ImpersonateSecurityContext(
    PCtxtHandle                 phContext           // Context to impersonate
    )
{
    if (!InitGlobals())
        return SEC_E_INTERNAL_ERROR;

    return SEC_E_UNSUPPORTED_FUNCTION;
}



//--------------------------------------------------------------------------
//
//  Function:   RevertSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
extern "C" SECURITY_STATUS SEC_ENTRY
RevertSecurityContext(
    PCtxtHandle                 phContext           // Context from which to re
    )
{
    if (!InitGlobals())
        return SEC_E_INTERNAL_ERROR;

    return SEC_E_UNSUPPORTED_FUNCTION;
}


//--------------------------------------------------------------------------
//
//  Function:   QueryContextAttributesA
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
extern "C" SECURITY_STATUS SEC_ENTRY
QueryContextAttributesA(
    PCtxtHandle                 phContext,          // Context to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    )
{
    if (!InitGlobals())
        return SEC_E_INTERNAL_ERROR;

    return SEC_E_UNSUPPORTED_FUNCTION;
}


//--------------------------------------------------------------------------
//
//  Function:   MakeSignature
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [phContext]     -- context to use
//              [fQOP]          -- quality of protection to use
//              [pMessage]      -- message
//              [MessageSeqNo]  -- sequence number of message
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
extern "C" SECURITY_STATUS SEC_ENTRY
MakeSignature(  PCtxtHandle         phContext,
                ULONG               fQOP,
                PSecBufferDesc      pMessage,
                ULONG               MessageSeqNo)
{
    if (!InitGlobals())
        return SEC_E_INTERNAL_ERROR;

    return SEC_E_UNSUPPORTED_FUNCTION;
}


//--------------------------------------------------------------------------
//
//  Function:   VerifySignature
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [phContext]     -- Context performing the unseal
//              [pMessage]      -- Message to verify
//              [MessageSeqNo]  -- Sequence number of this message
//              [pfQOPUsed]     -- quality of protection used
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
extern "C" SECURITY_STATUS SEC_ENTRY
VerifySignature(PCtxtHandle     phContext,
                PSecBufferDesc  pMessage,
                ULONG           MessageSeqNo,
                ULONG *         pfQOP)
{
    if (!InitGlobals())
        return SEC_E_INTERNAL_ERROR;

    return SEC_E_UNSUPPORTED_FUNCTION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\digest\mmfile.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    mmfile.cxx

Abstract:

    Generic shared memory allocator.

Author:

    Adriaan Canter (adriaanc) 01-Aug-1998

--*/
#include "include.hxx"

//--------------------------------------------------------------------
// CMMFile::CMMFile()
//--------------------------------------------------------------------
CMMFile::CMMFile(DWORD cbHeap, DWORD cbEntry)
    : _cbHeap(cbHeap), _cbEntry(cbEntry)
{
    // BUGBUG - assert this.
    // Heap size must be multiple of entry size
    // and entry size must be multiple of 2.
    if ((_cbHeap % _cbEntry) || _cbEntry % 2)
    {
        DIGEST_ASSERT(FALSE);
        _dwStatus = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    // Max entries and total bytes in bitmap.
    _nMaxEntries = _cbHeap / _cbEntry;
    _cbBitMap = _nMaxEntries / NUM_BITS_IN_BYTE;

    // Total DWORDs in bitmap and total
    // bytes in shared memory.
    _nBitMapDwords = _cbBitMap / sizeof(DWORD);
    _cbTotal = sizeof(MEMMAP_HEADER) + _cbBitMap + _cbHeap;

    _pHeader  = NULL;
    _pBitMap  = NULL;
    _pHeap    = NULL;

    // BUGBUG - _hFile -> INVALID_HANDLE_VALUE
    _hFile    = NULL;
    _dwSig    = SIG_CMMF;
    _dwStatus = ERROR_SUCCESS;

exit:
    return;
}

//--------------------------------------------------------------------
// CMMFile::~CMMFile
//--------------------------------------------------------------------
CMMFile::~CMMFile()
{
    // BUGBUG - protected
    DeInit();
}

//--------------------------------------------------------------------
// Init
//--------------------------------------------------------------------
DWORD CMMFile::Init()
{
    BOOL fFirstProc = FALSE;
    LPVOID pv;
    HANDLE hHandle = (HANDLE) -1;
    CHAR szMapName[MAX_PATH];
    DWORD cbMapName = MAX_PATH;

    // IE5# 89288 
    // Get map name based on user
    if ((_dwStatus = MakeUserObjectName(szMapName, 
        &cbMapName, MAKE_MAP_NAME)) != ERROR_SUCCESS)
        return _dwStatus;

    // BUGBUG - security attributes and -1->INVALID_HANDLE_VALUE
    // Create the file mapping handle.
    _hFile = CreateFileMapping(
        hHandle,               // 0xffffffff file handle -> backed by paging file.
        NULL,                  // Security attributes.
        PAGE_READWRITE         // Generic read+write.
        | SEC_RESERVE,         // Reserve only, don't commit.
        0,                     // dwMaximumSizeHigh
        _cbTotal,              // dwMaximumSizeLow
        szMapName              // Map name.
        );

    // BUGBUG -> COMMENT HERE
    _dwStatus = GetLastError();

    // Check for success (can already exist) or failure.
    if (_dwStatus == ERROR_SUCCESS)
        fFirstProc = TRUE;
    else if (_dwStatus != ERROR_ALREADY_EXISTS)
    {
        DIGEST_ASSERT(FALSE);
        goto exit;
    }

    // bugbug - file_map_write logic.
    // Create file mapping view.
    pv = MapViewOfFileEx(
        _hFile,               // File mapping handle.
        FILE_MAP_WRITE,       // Read and write access.
        0,                    // High 32 bit offset
        0,                    // Low 32 bit offset
        0,                    // Map entire file.
        NULL                  // System chooses base addr.
        );

    if(!pv)
    {
        _dwStatus = GetLastError();
        DIGEST_ASSERT(FALSE);
        goto exit;
    }

    // Calculate pointers to bitmap and heap.
    _pHeader = (LPMEMMAP_HEADER) pv;
    _pBitMap = (LPDWORD) ((LPBYTE) pv + sizeof(MEMMAP_HEADER));
    _pHeap   = ((LPBYTE) _pBitMap + _cbBitMap);

    // Initialize MM file if first process.
    if (fFirstProc)
    {
        // Commit header + bitmap.
        if (!VirtualAlloc(_pHeader, sizeof(MEMMAP_HEADER) + _cbBitMap,
            MEM_COMMIT, PAGE_READWRITE))
        {
            _dwStatus = GetLastError();
            goto exit;
        }

        //BUGBUG - zero out first.
        // Set signature.
        memcpy(_pHeader->szSig, MMF_SIG_SZ, MMF_SIG_SIZE);

        // Zero out the rest of the header + bitmap.
        memset((LPBYTE) _pHeader + MMF_SIG_SIZE, 0,
            sizeof(MEMMAP_HEADER) - MMF_SIG_SIZE + _cbBitMap);
    }

    _dwStatus = ERROR_SUCCESS;

exit:

    return _dwStatus;
}

//--------------------------------------------------------------------
// DeInit
//--------------------------------------------------------------------
DWORD CMMFile::DeInit()
{
    // BUGBUG - should always close _hFile
    if (!UnmapViewOfFile((LPVOID) _pHeader))
    {
        DIGEST_ASSERT(FALSE);
        _dwStatus = GetLastError();
        goto exit;
    }

    if (!CloseHandle(_hFile))
    {
        DIGEST_ASSERT(FALSE);
        _dwStatus = GetLastError();
        goto exit;
    }

    _dwStatus = ERROR_SUCCESS;

    exit:

    return _dwStatus;
}



//--------------------------------------------------------------------
// CMMFile::CheckNextNBits
//
//    Determines if the next N bits are unset.
//
// Arguments:
//
//     [IN/OUT]
//     DWORD &nArrayIndex, DWORD &dwMask
//
//     [IN]
//     DWORD nBitsRequired
//
//     [OUT]
//     DWORD &nBitsFound
//
// Return Value:
//
//     TRUE if the next N bits were found unset.
//     FALSE otherwise.
//
// Notes:
//    This function assumes that the range of bits to be checked lie
//    within a valid area of the bit map.
//--------------------------------------------------------------------
BOOL CMMFile::CheckNextNBits(DWORD& nArrayIndex,   DWORD& dwStartMask,
                             DWORD  nBitsRequired, DWORD& nBitsFound)
{
    DWORD i;
    DWORD nIdx = nArrayIndex;
    DWORD dwMask = dwStartMask;
    BOOL fFound = FALSE;
    LPDWORD BitMap = &_pBitMap[nIdx];

    nBitsFound = 0;

    // Check if the next nBitsRequired bits are unset
    for (i = 0; i < nBitsRequired; i++)
    {
        // Is this bit unset?
        if ((*BitMap & dwMask) == 0)
        {
            // Have sufficient unset bits been found?
            if (++nBitsFound == nBitsRequired)
            {
                // Found sufficient bits. Success.
                fFound = TRUE;
                goto exit;
            }
        }

        // Ran into a set bit. Fail.
        else
        {
            // Indicate the array and bit index
            // of the set bit encountered.
            nArrayIndex = nIdx;
            dwStartMask = dwMask;
            goto exit;
        }

        // Left rotate the bit mask.
        dwMask <<= 1;
        if (dwMask == 0x0)
        {
            dwMask = 0x1;
            BitMap = &_pBitMap[++nIdx];
        }

    } // Loop nBitsRequired times.


exit:
    return fFound;
}


//--------------------------------------------------------------------
// CMMFile::SetNextNBits
//
//    Given an array index and bit mask, sets the next N bits.
//
// Arguments:
//    [IN]
//    DWORD nIdx, DWORD dwMask, DWORD nBitsRequired
//
// Return Value:
//
//    TRUE if the next N bits were found unset, and successfully set.
//    FALSE if unable to set all the required bits.
//
// Notes:
//    This function assumes that the range of bits to be set lie
//    within a valid area of the bit map. If the function returns
//    false, no bits are set.
//--------------------------------------------------------------------
BOOL CMMFile::SetNextNBits(DWORD nIdx, DWORD dwMask,
                           DWORD nBitsRequired)
{
    DWORD i, j, nBitsSet = 0;
    LPDWORD BitMap = &_pBitMap[nIdx];

    for (i = 0; i < nBitsRequired; i++)
    {
        // Check that this bit is not already set.
        if (*BitMap & dwMask)
        {
            // Fail. Unset the bits we just set and exit.
            for (j = nBitsSet; j > 0; j--)
            {
                DIGEST_ASSERT((*BitMap & dwMask) == 0);

                // Right rotate the bit mask.
                dwMask >>= 1;
                if (dwMask == 0x0)
                {
                    dwMask = 0x80000000;
                    BitMap = &_pBitMap[--nIdx];
                }
                *BitMap &= ~dwMask;
            }
            return FALSE;
        }

        *BitMap |= dwMask;
        nBitsSet++;

        // Left rotate the bit mask.
        dwMask <<= 1;
        if (dwMask == 0x0)
        {
            dwMask = 0x1;
            BitMap = &_pBitMap[++nIdx];
        }

    }

    // Success.
    return TRUE;
}


//--------------------------------------------------------------------
// CMMFile::GetAndSetNextFreeEntry
//
//    Computes the first available free entry index.
//
// Arguments:
//
//    DWORD nBitsRequired
//
// Return Value:
//
//   Next available free entry Index.
//--------------------------------------------------------------------
DWORD CMMFile::GetAndSetNextFreeEntry(DWORD nBitsRequired)
{
    DWORD nReturnBit = 0xFFFFFFFF;

    // Align if 4k or greater
    BOOL fAlign = (nBitsRequired >= NUM_BITS_IN_DWORD ? TRUE : FALSE);

    // Scan DWORDS from the beginning of the byte array.
    DWORD nArrayIndex = 0;
    while (nArrayIndex < _nBitMapDwords)
    {
        // Process starting from this DWORD if alignment is not required
        // and there are free bits, or alignment is required and all bits
        // are free.
        if (_pBitMap[nArrayIndex] !=  0xFFFFFFFF
            && (!fAlign || (fAlign && _pBitMap[nArrayIndex] == 0)))
        {
            DWORD nBitIndex = 0;
            DWORD dwMask = 0x1;
            LPDWORD BitMap = &_pBitMap[nArrayIndex];

            // Find a candidate slot.
            while (nBitIndex < NUM_BITS_IN_DWORD)
            {
                // Found first bit of a candidate slot.
                if ((*BitMap & dwMask) == 0)
                {
                    // Calculate leading bit value.
                    DWORD nLeadingBit = NUM_BITS_IN_DWORD * nArrayIndex + nBitIndex;

                    // Don't exceed max number of entries.
                    if (nLeadingBit + nBitsRequired > _nMaxEntries)
                    {
                        // Overstepped last internal entry
                        goto exit;
                    }

                    // If we just need one bit, then we're done.
                    if (nBitsRequired == 1)
                    {
                        *BitMap |= dwMask;
                        nReturnBit = nLeadingBit;
                        _pHeader->nEntries += 1;
                        goto exit;
                    }

                    // Additional bits required.
                    DWORD nBitsFound;
                    DWORD nIdx = nArrayIndex;

                    // Check the next nBitsRequired bits. Set them if free.
                    if (CheckNextNBits(nIdx, dwMask, nBitsRequired, nBitsFound))
                    {
                        if (SetNextNBits(nIdx, dwMask, nBitsRequired))
                        {
                            // Return the offset of the leading bit.
                            _pHeader->nEntries += nBitsRequired;
                            nReturnBit = nLeadingBit;
                            goto exit;
                        }
                        // Bad news.
                        else
                        {
                            // The bits are free, but we couldn't set them. Fail.
                            DIGEST_ASSERT(FALSE);
                            goto exit;
                        }
                    }
                    else
                    {
                        // This slot has insufficient contiguous free bits.
                        // Update the array index. We break back to looping
                        // over the bits in the DWORD where the interrupting
                        // bit was found.
                        nArrayIndex = nIdx;
                        nBitIndex = (nBitIndex + nBitsFound) % NUM_BITS_IN_DWORD;
                        break;
                    }

                } // Found a free leading bit.
                else
                {
                    // Continue looking at bits in this DWORD.
                    nBitIndex++;
                    dwMask <<= 1;
                }

            } // Loop over bits in DWORD.

        } // If we found a candidate DWORD.

        nArrayIndex++;

    } // Loop through all DWORDS.
exit:
    return nReturnBit;
}

//--------------------------------------------------------------------
// CMMFile::AllocateEntry
//
// Routine Description:
//
//    Member function that returns an free entry from the cache list. If
//    none is available free, it grows the map file, makes more free
//    entries.
//
// Arguments:
//
//    DWORD cbBytes : Number of bytes requested
//    DWORD cbOffset: Offset from beginning of bit map where allocation is
//                    requested.
//
// Return Value:
//
//
//--------------------------------------------------------------------
LPMAP_ENTRY CMMFile::AllocateEntry(DWORD cbBytes)
{
    LPMAP_ENTRY NewEntry;

    // BUGBUG - ASSERT THIS.
    // Validate cbBytes
    if (cbBytes > MAX_ENTRY_SIZE)
    {
        return NULL;
    }

    // Find and mark off a set of contiguous bits
    // spanning the requested number of bytes.
    DWORD nBlocksRequired = NUMBLOCKS(ROUNDUPBLOCKS(cbBytes), _cbEntry);
    DWORD FreeEntryIndex = GetAndSetNextFreeEntry(nBlocksRequired);

    // Failed to find space.
    if( FreeEntryIndex == 0xFFFFFFFF )
    {
        DIGEST_ASSERT(FALSE);
        return NULL;
    }

    // Cast the memory.
    NewEntry = (LPMAP_ENTRY)
        (_pHeap + _cbEntry * FreeEntryIndex);

    if (!VirtualAlloc(NewEntry, nBlocksRequired * _cbEntry,
        MEM_COMMIT, PAGE_READWRITE))
    {
        DIGEST_ASSERT(FALSE);
        _dwStatus = GetLastError();
        return NULL;
    }

    // Mark the allocated space.
    NewEntry->dwSig = SIG_ALLOC;

    // Set the number of blocks in the entry.
    NewEntry->nBlocks = nBlocksRequired;

    return NewEntry;
}

//--------------------------------------------------------------------
// Routine Description:
//
//    Attempts to reallocate an entry at the location given.
//
// Arguments:
//
//    LPMAP_ENTRY pEntry: Pointer to location in file map.
//    DWORD cbBytes : Number of bytes requested
//
// Return Value:
//
//    Original value of pEntry if successful. pEntry->nBlocks is set to
//    the new value, but all other fields in the entry are unmodified.
//    If insufficient contiguous bits are found at the end of the original
//    entry, NULL is returned, indicating failure. In this case the entry
//    remains unmodified.
//
//--------------------------------------------------------------------
// BUGBUG -> remove ?
BOOL CMMFile::ReAllocateEntry(LPMAP_ENTRY pEntry, DWORD cbBytes)
{
    // Validate cbBytes
    if (cbBytes > MAX_ENTRY_SIZE)
    {
        DIGEST_ASSERT(FALSE);
        return FALSE;
    }

    // Validate pEntry.
    DWORD cbEntryOffset = (DWORD)((DWORD_PTR) pEntry - (DWORD_PTR) _pBitMap);
    if ((cbEntryOffset == 0)
        || (cbEntryOffset & (_cbEntry-1))
        || (cbEntryOffset >= _cbTotal))
    {
        DIGEST_ASSERT(FALSE);
        return FALSE;
    }

    // Calculate number of blocks required for this entry.
    DWORD nBlocksRequired = NUMBLOCKS(ROUNDUPBLOCKS(cbBytes), _cbEntry);

    // Sufficient space in current slot?
    if (nBlocksRequired <= pEntry->nBlocks)
    {
        // We're done.
        return TRUE;
    }
    else
    {
        // Determine if additional free bits are
        // available at the end of this entry.
        // If not, return NULL.

        // Determine the array and bit indicese of the first
        // free bit immediately following the last set bit of
        // the entry.
        DWORD nTrailingIndex = cbEntryOffset / _cbEntry + pEntry->nBlocks;
        DWORD nArrayIndex = nTrailingIndex / NUM_BITS_IN_DWORD;
        DWORD nBitIndex = nTrailingIndex % NUM_BITS_IN_DWORD;
        DWORD dwMask = 0x1 << nBitIndex;
        DWORD nAdditionalBlocksRequired = nBlocksRequired - pEntry->nBlocks;
        DWORD nBlocksFound;

        // Don't exceed the number of internal entries.
        if (nTrailingIndex + nAdditionalBlocksRequired
            > _nMaxEntries)
        {
            // Overstepped last internal entry. Here we should fail
            // by returning NULL. Note - DO NOT attempt to grow the
            // map file at this point. The caller does not expect this.
            return FALSE;
        }

        if (CheckNextNBits(nArrayIndex, dwMask,
            nAdditionalBlocksRequired, nBlocksFound))
        {
            // We were able to grow the entry.
            SetNextNBits(nArrayIndex, dwMask, nAdditionalBlocksRequired);
            pEntry->nBlocks = nBlocksRequired;
            _pHeader->nEntries += nAdditionalBlocksRequired;
            return TRUE;
        }
        else
            // Couldn't grow the entry.
            return FALSE;
    }
}


//--------------------------------------------------------------------
// CMMFile::FreeEntry
//    This public member function frees up a file cache entry.
//
// Arguments:
//
//    UrlEntry : pointer to the entry that being freed.
//
// Return Value:
//
//    TRUE - if the entry is successfully removed from the cache.
//    FALSE - otherwise.
//
//--------------------------------------------------------------------
BOOL CMMFile::FreeEntry(LPMAP_ENTRY Entry)
{
    DWORD nIndex, nArrayIndex,
        nOffset, nBlocks, BitMask;

    LPDWORD BitMap;

    // Validate the pointer passed in.
    if(((LPBYTE) Entry < _pHeap)
        || ((LPBYTE) Entry >= (_pHeap + _cbEntry * _nMaxEntries)))
    {
        DIGEST_ASSERT(FALSE);
        return FALSE;
    }

    // Compute and check offset (number of bytes from start).
    nOffset = (DWORD)((DWORD_PTR)Entry - (DWORD_PTR)_pHeap);
    if( nOffset % _cbEntry )
    {
        // Pointer does not point to a valid entry.
        DIGEST_ASSERT(FALSE);
        return FALSE;
    }

    nBlocks = Entry->nBlocks;

    if (nBlocks > (MAX_ENTRY_SIZE / _cbEntry))
    {
        DIGEST_ASSERT(FALSE);
        return FALSE;
    }

    // Compute indicese
    nIndex = nOffset / _cbEntry;
    nArrayIndex = nIndex / NUM_BITS_IN_DWORD;

    // Unmark the index bits in the map.
    BitMap = &_pBitMap[nArrayIndex];
    BitMask = 0x1 << (nIndex % NUM_BITS_IN_DWORD);
    for (DWORD i = 0; i < nBlocks; i++)
    {
        // Check we don't free unset bits
        if (!(*BitMap & BitMask))
        {
            DIGEST_ASSERT(FALSE);
            return FALSE;
        }

        *BitMap &= ~BitMask;
        BitMask <<= 1;
        if (BitMask == 0x0)
        {
            BitMask = 0x1;
            BitMap = &_pBitMap[++nArrayIndex];
        }
    }

    // Mark the freed space.
    ResetEntryData(Entry, SIG_FREE, nBlocks);

    // Reduce the count of allocated entries.
    // INET_ASSERT (_HeaderInfo->NumUrlEntriesAlloced  > 0);
    _pHeader->nEntries -= nBlocks;

    return TRUE;
}

//--------------------------------------------------------------------
// CMMFile::SetHeaderData
//--------------------------------------------------------------------
VOID CMMFile::SetHeaderData(DWORD dwHeaderIndex, DWORD dwHeaderValue)
{
    _pHeader->dwHeaderData[dwHeaderIndex] = dwHeaderValue;
}

//--------------------------------------------------------------------
// CMMFile::GetHeaderData
//--------------------------------------------------------------------
LPDWORD CMMFile::GetHeaderData(DWORD dwHeaderIndex)
{
    return &_pHeader->dwHeaderData[dwHeaderIndex];
}

//--------------------------------------------------------------------
// CMMFile::ResetEntryData
//--------------------------------------------------------------------
VOID CMMFile::ResetEntryData(LPMAP_ENTRY Entry,
    DWORD dwResetValue, DWORD nBlocks)
{
    for (DWORD i = 0; i < (_cbEntry * nBlocks) / sizeof(DWORD); i++)
    {
        *((DWORD*) Entry + i) = dwResetValue;
    }
}

//--------------------------------------------------------------------
// CMMFile::GetMapPtr
//--------------------------------------------------------------------
DWORD_PTR CMMFile::GetMapPtr()
{
    return (DWORD_PTR) _pHeader;
}


//--------------------------------------------------------------------
// CMMFile::GetStatus
//--------------------------------------------------------------------
DWORD CMMFile::GetStatus()
{
    return _dwStatus;
}

//--------------------------------------------------------------------
// CMMFile::MakeUserObjectName
// Added in fix for IE5# 89288 
// (inet\digest\init.cxx:MakeFullAccessSA:  NULL DACL is no protection)
// 
// Generates either of the names
// <Local\>SSPIDIGESTMMMAP:username
// <Local\>SSPIDIGESTMUTEX:username 
// where Local\ is prepended on NT, username from GetUserName
//--------------------------------------------------------------------
DWORD CMMFile::MakeUserObjectName(LPSTR szName, LPDWORD pcbName, 
    DWORD dwFlags)
{
    DWORD cbLocal, cbRequired, 
        cbUserName = MAX_PATH, dwError = ERROR_SUCCESS;
    CHAR szUserName[MAX_PATH];
        
    DWORD cbNameFixed = (DWORD)((dwFlags == MAKE_MUTEX_NAME ? 
        sizeof(SZ_MUTEXNAME) - 1 :  sizeof(SZ_MAPNAME) - 1));

    // Get platform info.
    OSVERSIONINFO osInfo;
    osInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osInfo))
    {
        dwError = GetLastError();
        goto exit;
    }

    // Prepend "Local\" if on >= NT5
    if ((osInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
        && (osInfo.dwMajorVersion >= 5))
    {
        // We will prepend "Local\"
        cbLocal = sizeof("Local\\") - 1;
    }
    else
    {
        // We will not prepend "Local\"
        cbLocal = 0;
    }

    // Get username. Default to "anyuser" if not present.
    if (!GetUserName(szUserName, &cbUserName))
    {
        cbUserName = sizeof("anyuser");
        memcpy(szUserName, "anyuser", cbUserName);
    }
    
    // Required size for name
    // eg <Local\>SSPIDIGESTMUTEX:username
    cbRequired = cbLocal + cbNameFixed + cbUserName;
    if (cbRequired > *pcbName)
    {
        *pcbName = cbRequired;
        dwError = ERROR_INSUFFICIENT_BUFFER;
        goto exit;
    }
    
    // <Local\> 
    // (cbLocal may be 0)
    memcpy(szName, "Local\\", cbLocal);
        
    // <Local\>SSPIDIGESTMUTEX:
    memcpy(szName + cbLocal, 
        (dwFlags == MAKE_MUTEX_NAME ? SZ_MUTEXNAME : SZ_MAPNAME), 
        cbNameFixed);

    // <Local\> SSPIDIGESTMUTEX:username
    // cbUsername includes null terminator.
    memcpy(szName + cbLocal + cbNameFixed,
        szUserName, cbUserName);

    *pcbName = cbRequired;

exit:
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\digest\init.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    init.c

Abstract:

    Dll initialization for sspi digest package.

Author:

    Adriaan Canter (adriaanc) 01-Aug-1998

--*/

#include "include.hxx"
#include "digestui.hxx"
#include "resource.h"

//
// Downlevel delay load support (we forward to shlwapi)
//
#include <delayimp.h>

PfnDliHook __pfnDliFailureHook;

// Serializes access to all globals in module
CRITICAL_SECTION DllCritSect;

// Per process credential cache.
CCredCache *g_pCache = NULL;

// Per process cache init flag
BOOL g_fCredCacheInit = FALSE;

// Global module handle.
HMODULE g_hModule = NULL;

// Global handle to shlwapi.
HMODULE g_hShlwapi = NULL;

// Status of cred persist services on machine.
DWORD g_dwCredPersistAvail = CRED_PERSIST_UNKNOWN;

DWORD_PTR g_pHeap = NULL;

//--------------------------------------------------------------------
// DigestServicesExist
//--------------------------------------------------------------------
BOOL DigestServicesExist()
{
    INIT_SECURITY_INTERFACE addrProcISI = NULL;
    PSecurityFunctionTable pFuncTbl     = NULL;

    PSecPkgInfoA    pSecPkgInfo;
    SECURITY_STATUS ssResult;
    DWORD           cPackages;

    OSVERSIONINFO   VerInfo;
    CHAR            szDLL[MAX_PATH];
    HINSTANCE       hSecLib;

    BOOL fDigest = FALSE;

    // Get the OS version.
    VerInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    GetVersionEx (&VerInfo);

    // Load the appropriate dll.
    if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
        lstrcpy (szDLL, SSP_SPM_NT_DLL);
    else if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
        lstrcpy (szDLL, SSP_SPM_WIN95_DLL);
    else
        goto exit;

    hSecLib = LoadLibrary (szDLL);
    if (!hSecLib)
        goto exit;

    // Get the dispatch table.
    addrProcISI = (INIT_SECURITY_INTERFACE) GetProcAddress( hSecLib,
                    SECURITY_ENTRYPOINT_ANSI);
    pFuncTbl = (*addrProcISI)();

    if (!pFuncTbl)
        goto exit;

    // Enumerate security pkgs and determine if digest is installed.
    ssResult = (*(pFuncTbl->EnumerateSecurityPackagesA))(&cPackages, &pSecPkgInfo);

    if (ssResult == SEC_E_OK)
    {
        for (DWORD i = 0; i < cPackages; i++)
        {
            if (lstrcmpi(pSecPkgInfo[i].Name, "Digest") == 0)
            {
                fDigest = TRUE;
                break;
            }
        }
    }
exit:
    return fDigest;
}


//--------------------------------------------------------------------
// DLLInstall
//--------------------------------------------------------------------
STDAPI
DllInstall
(
    IN BOOL      bInstall,   // Install or Uninstall
    IN LPCWSTR   pwStr
)
{
    HKEY hKey;
    DWORD dwError, dwRegDisp, cbSP = MAX_PATH;
    CHAR *ptr, *ptrNext, szSP[MAX_PATH];
    BOOL bHKLM = FALSE;

    // Determine if full install (provide client digest sspi svcs)
    // or just passport install (server pkg delegating to client)
    if (!pwStr || !*pwStr || (!wcscmp(pwStr, L"HKLM")))
    {
        bHKLM = TRUE;
    }

    // Add "digest.dll" to comma delimited Service Providers list in
    // HKLM\System\CurrentControlSet\Control\SecurityProviders only if
    // no digest security providers currently exist.
    if (bInstall && bHKLM && !DigestServicesExist())
    {
        // Open or create SecurityProviders key.
        dwError =  RegCreateKeyEx(HKEY_LOCAL_MACHINE,
            SECURITY_PROVIDERS_REG_KEY, 0, NULL,
                0, KEY_READ | KEY_WRITE, NULL, &hKey, &dwRegDisp);

        // Successfully opened/created key.
        if (dwError == ERROR_SUCCESS)
        {
            cbSP = MAX_PATH;
            dwError = RegQueryValueEx(hKey, SECURITY_PROVIDERS_SZ,
                NULL, NULL, (LPBYTE) szSP, &cbSP);

            // SecurityProviders value might not be
            // found which is ok since we will create it.
            if (dwError == ERROR_SUCCESS || dwError == ERROR_FILE_NOT_FOUND)
            {
                // Value not found same as value existed but no string.
                if (dwError == ERROR_FILE_NOT_FOUND)
                {
                    ptr = NULL;
                    cbSP = 0;
                }
                // Otherwise if value found -> check if "digest.dll" exists.
                else
                {
                    // We can use the handy FindToken from the CParams object
                    // to determine if a token occurs in a comma delmited list.
                    if (!CParams::FindToken(szSP, cbSP, "digest.dll",
                        sizeof("digest.dll") - 1, &ptr))
                    {
                        ptr = NULL;
                    }
                }

                // Only add "digest.dll" if doesn't already exist.
                if (!ptr)
                {
                    // If we found value/data append "digest.dll"
                    if (cbSP > 1)
                        strcat(szSP, ", digest.dll");

                    // Otherwise "digest.dll" is only data
                    else
                        memcpy(szSP, "digest.dll", sizeof("digest.dll"));

                    // Write the value back.
                    dwError = RegSetValueEx(hKey, SECURITY_PROVIDERS_SZ, 0,
                        REG_SZ, (LPBYTE) szSP, strlen(szSP));
                }
            }

            // Close SecurityProviders reg key.
            RegCloseKey(hKey);
        }
    }

    // Remove "digest.dll" from the comma delimited Service Providers list in
    // HKLM\System\CurrentControlSet\Control\SecurityProviders
    if (!bInstall && bHKLM)
    {
        // Open the Security Providers reg key.
        dwError =  RegOpenKeyEx(HKEY_LOCAL_MACHINE,
            SECURITY_PROVIDERS_REG_KEY, NULL, KEY_READ | KEY_WRITE, &hKey);
        if (dwError == ERROR_SUCCESS)
        {
            // Get the SecurityProviders value data string.
            dwError = RegQueryValueEx(hKey, SECURITY_PROVIDERS_SZ,
                NULL, NULL, (LPBYTE) szSP, &cbSP);

            if (dwError == ERROR_SUCCESS)
            {
                // Only remove "digest.dll" if exists.
                if (!CParams::FindToken(szSP, cbSP, "digest.dll",
                    sizeof("digest.dll") - 1, &ptr))
                {
                    ptr = NULL;
                }

                if (ptr)
                {
                    // Point to next item in list, might be '\0'
                    ptrNext = ptr + sizeof("digest.dll") - 1;

                    // Digest.dll is only entry.
                    if ((ptr == szSP) && cbSP == sizeof("digest.dll"))
                    {
                        *szSP = '\0';
                    }
                    // "digest.dll" is last entry.
                    else if (*ptrNext == '\0')
                    {
                        *(ptr - (sizeof (", ") - 1)) = '\0';
                    }
                    else if (*ptrNext == ',' && *(ptrNext+1) == ' ')
                    {
                        ptrNext+=2;
                        memcpy(ptr, ptrNext, (size_t)(cbSP - (ptrNext - szSP)));
                    }

                    dwError = RegSetValueEx(hKey, SECURITY_PROVIDERS_SZ, 0,
                        REG_SZ, (LPBYTE) szSP, *szSP ? strlen(szSP) : 1);
                }
            }
            RegCloseKey(hKey);
        }
    }

    return S_OK;
}

//--------------------------------------------------------------------
// MakeFullAccessSA
//--------------------------------------------------------------------

//Commenting this function as it doesn't seem to be used anywhere in the sources
/*
SECURITY_ATTRIBUTES *MakeFullAccessSA (void)
{
    static SECURITY_ATTRIBUTES sa;
    static BYTE SDBuf[SECURITY_DESCRIPTOR_MIN_LENGTH];

    // Don't bother on Win95/Win98 which don't support security.
    OSVERSIONINFO versionInfo;
    versionInfo.dwOSVersionInfoSize = sizeof(versionInfo);
    if (!GetVersionEx(&versionInfo)
        || (versionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS))
        return NULL;

    // Create a security descriptor with ACE to allow full access to all.
    SECURITY_DESCRIPTOR* pSD = (SECURITY_DESCRIPTOR*) SDBuf;
    if (!InitializeSecurityDescriptor (pSD, SECURITY_DESCRIPTOR_REVISION))
        return NULL;
    if (!SetSecurityDescriptorDacl (pSD, TRUE, NULL, FALSE))
        return NULL;

    // Initialize the security attributes.
    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = pSD;
    sa.bInheritHandle = TRUE;
    return &sa;
}*/
//--------------------------------------------------------------------
// NewString
//--------------------------------------------------------------------
LPSTR NewString(LPSTR szString)
{
    if (!szString)
        return NULL;
    DWORD cbString = strlen(szString);

    LPSTR szNew = new CHAR[cbString+1];
    if (!szNew)
    {
        DIGEST_ASSERT(FALSE);
        return NULL;
    }

    memcpy(szNew, szString, cbString+1);
    return szNew;
}

//--------------------------------------------------------------------
// InitGlobals
//--------------------------------------------------------------------
BOOL InitGlobals()
{
    // Return success if we've already
    // initialized.
    if (g_fCredCacheInit)
        return TRUE;

    // Serialize per-process calls.
    LOCK_GLOBALS();

    // Recheck global flag in the case
    // the cache was initialized while
    // this thread was descheduled.
    if (g_fCredCacheInit)
    {
        goto exit;
    }

    // Global cred persist status.
    g_dwCredPersistAvail = CRED_PERSIST_UNKNOWN;

    // Create the credential cache.
    g_pCache = new CCredCache();

    if (!g_pCache || g_pCache->GetStatus() != ERROR_SUCCESS)
    {
        g_fCredCacheInit = FALSE;
        goto exit;
    }

    g_fCredCacheInit = TRUE;

exit:
    UNLOCK_GLOBALS();

    return g_fCredCacheInit;
}

void SetupDelayloadErrorHandler()
{
    __pfnDliFailureHook = (PfnDliHook)GetProcAddress(GetModuleHandleA("shlwapi.dll"), "DelayLoadFailureHook");
}


//--------------------------------------------------------------------
// DllMain
//--------------------------------------------------------------------
#if defined(__cplusplus)
extern "C"
#endif
BOOL
WINAPI
DllMain(
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )

{
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(DllHandle );

    switch (Reason)
    {
        // Process attach.
        case DLL_PROCESS_ATTACH:
        {

            // BUGBUG - DislableThreadLibraryCalls and
            // don't do any work.
            g_hModule = (HMODULE) DllHandle;
            InitializeCriticalSection( &DllCritSect );
            SetupDelayloadErrorHandler();

            if ((hDigest = CreateMutex (NULL,
                FALSE,
                NULL)) == NULL)

                return FALSE;

            break;
        }

        // Process detatch.
        // Deinitialize the credential cache.
        // Delete the critical section.
        case DLL_PROCESS_DETACH:
        {
            if (g_pCache)
                delete g_pCache;

            DeleteCriticalSection( &DllCritSect );
            CloseHandle (hDigest);
            break;

        }
    }
    return TRUE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\digest\params.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    params.cxx

Abstract:

    Header and parameter parser for digest sspi package.

Author:

    Adriaan Canter (adriaanc) 01-Aug-1998

--*/
#include "include.hxx"


// Static parameter map - this must
// agree with PARAM_INDEX.
// BUGBUG - declare const.
LPSTR CParams::szParamMap[] =
{
    HOST_SZ,
    USER_SZ,
    PASS_SZ,
    URL_SZ,
    METHOD_SZ,
    NONCE_SZ,
    OPAQUE_SZ,
    REALM_SZ,
    DOMAIN_SZ,
    STALE_SZ,
    ALGORITHM_SZ,
    QOP_SZ,
    MS_LOGOFF_SZ
};

//--------------------------------------------------------------------
// CParams::TrimQuotes
// Inplace trim of one leading and one trailing quote.
// BUGBUG -ppsz
//--------------------------------------------------------------------
VOID CParams::TrimQuotes(LPSTR *psz, LPDWORD pcb)
{
    if (*pcb && (**psz == '"'))
    {
        (*psz)++;
        (*pcb)--;
    }
    if (*pcb && (*(*psz + *pcb - 1) == '"'))
        (*pcb)--;
}

//--------------------------------------------------------------------
// CParams::TrimWhiteSpace
//   Inplace trim of leading and trailing whitespace.
//--------------------------------------------------------------------
VOID CParams::TrimWhiteSpace(LPSTR *psz, LPDWORD pcb)
{
    DWORD cb = *pcb;
    CHAR* beg = *psz;
    CHAR* end = beg + cb - 1;

    while ((cb != 0) && ((*beg == ' ') || (*beg == '\t')))
    {
        beg++;
        cb--;
    }

    while ((cb != 0) && ((*end == ' ') || (*end == '\t')))
    {
        end--;
        cb--;
    }

    *psz = beg;
    *pcb = cb;
}

//--------------------------------------------------------------------
// CParams::GetDelimitedToken
// Inplace strtok based on one delimiter. Ignores delimiter scoped by quotes.
// bugbug - IN/OUT
//--------------------------------------------------------------------
BOOL CParams::GetDelimitedToken(LPSTR* pszBuf,   LPDWORD pcbBuf,
                                LPSTR* pszTok,   LPDWORD pcbTok,
                                CHAR   cDelim)
{
    CHAR *pEnd;
    BOOL fQuote = FALSE,
         fRet   = FALSE;

    *pcbTok = 0;
    *pszTok = *pszBuf;

    pEnd = *pszBuf + *pcbBuf - 1;

    while (*pcbBuf)
    {
        if ( ((**pszBuf == cDelim) && !fQuote)
            || (**pszBuf =='\r')
            || (**pszBuf =='\n')
            || (**pszBuf =='\0'))
        {
            fRet = TRUE;
            break;
        }

        if (**pszBuf == '"')
            fQuote = !fQuote;

        (*pszBuf)++;
        (*pcbBuf)--;
    }

    // bugbug - OFF BY ONE WHEN NOT TERMINATING WITH A COMMA.
    if (fRet)
    {
        *pcbBuf = (DWORD)(pEnd - *pszBuf);
        *pcbTok = (DWORD)(*pszBuf - *pszTok);

        if (**pszBuf == cDelim)
            (*pszBuf)++;
    }

    return fRet;
}


//--------------------------------------------------------------------
// CParams::GetKeyValuePair
// Inplace retrieval of key and value from a buffer of form key = <">value<">
//--------------------------------------------------------------------
BOOL CParams::GetKeyValuePair(LPSTR  szB,    DWORD cbB,
                              LPSTR* pszK,   LPDWORD pcbK,
                              LPSTR* pszV,   LPDWORD pcbV)
{
    if (GetDelimitedToken(&szB, &cbB, pszK, pcbK, '='))
    {
        TrimWhiteSpace(pszK, pcbK);

        if (cbB)
        {
            *pszV = szB;
            *pcbV = cbB;
            TrimWhiteSpace(pszV, pcbV);
        }
        else
        {
            *pszV = NULL;
            *pcbV = 0;
        }
        return TRUE;
    }

    else
    {
        *pszK  = *pszV  = NULL;
        *pcbK  = *pcbV = 0;
    }
    return FALSE;
}


//--------------------------------------------------------------------
// CParams::CParams
// BUGBUG - SET A dwstatus variable.
//--------------------------------------------------------------------
CParams::CParams(LPSTR szBuffer)
{
    LPSTR szData, szTok, szKey, szValue;
    DWORD cbData, cbTok, cbKey, cbValue;

    // Zero set the entry array.
    memset(_Entry, 0, sizeof(_Entry));

    _hWnd = 0;
    _cNC  = 0;
    _fPreAuth       = FALSE;
    _fCredsSupplied = FALSE;

    // May be created with NULL buffer.
    if (!szBuffer)
    {
        _szBuffer = 0;
        _cbBuffer = 0;
        return;
    }

    _cbBuffer = strlen(szBuffer) + 1;
    _szBuffer = new CHAR[_cbBuffer];
    if (_szBuffer)
    {
        memcpy(_szBuffer, szBuffer, _cbBuffer);
    }
    else
    {
        DIGEST_ASSERT(FALSE);
        return;
    }

    szData = _szBuffer;
    cbData  = _cbBuffer;

    DWORD Idx;
    while (GetDelimitedToken(&szData, &cbData, &szTok, &cbTok, ','))
    {
        if (GetKeyValuePair(szTok, cbTok, &szKey, &cbKey, &szValue, &cbValue))
        {
            TrimQuotes(&szValue, &cbValue);

            for (Idx = METHOD; Idx < MAX_PARAMS; Idx++)
            {
                if (!_strnicmp(szKey, szParamMap[Idx], cbKey)
                    && !szParamMap[Idx][cbKey])
                {
                    if (szValue)
                    {
                        *(szValue + cbValue) = '\0';
                    }

                    _Entry[Idx].szParam = szParamMap[Idx];
                    _Entry[Idx].szValue = szValue;
                    _Entry[Idx].cbValue = cbValue;
                }
            }
        }
    }
}

//--------------------------------------------------------------------
// CParams::~CParams
// BUGBUG [] for deletes
//--------------------------------------------------------------------
CParams::~CParams()
{

    for (DWORD Idx = 0; Idx < MAX_PARAMS; Idx++)
    {
        if (_Entry[Idx].fAllocated)
            delete _Entry[Idx].szValue;
    }
    if (_szBuffer)
        delete _szBuffer;
}

//--------------------------------------------------------------------
// CParams::GetParam
//--------------------------------------------------------------------
LPSTR CParams::GetParam(PARAM_INDEX Idx)
{
    return _Entry[Idx].szValue;

}

//--------------------------------------------------------------------
// CParams::GetParam
//--------------------------------------------------------------------
BOOL CParams::GetParam(PARAM_INDEX Idx, LPSTR *pszValue, LPDWORD pcbValue)
{
    *pszValue = _Entry[Idx].szValue;

    if (!*pszValue)
        return FALSE;

    *pcbValue = _Entry[Idx].cbValue;

    return TRUE;
}


//--------------------------------------------------------------------
// CParams::SetParam
// BUGBUG - []
// AND FIGURE OUT IF EVER CALLED WITH null, 0
//--------------------------------------------------------------------
BOOL CParams::SetParam(PARAM_INDEX Idx, LPSTR szValue, DWORD cbValue)
{
    if (_Entry[Idx].fAllocated && _Entry[Idx].szValue)
        delete _Entry[Idx].szValue;

    if (szValue && cbValue)
    {
        _Entry[Idx].szValue = new CHAR[cbValue + 1];

        if (!_Entry[Idx].szValue)
        {
            DIGEST_ASSERT(FALSE);
            return FALSE;
        }

        memcpy(_Entry[Idx].szValue, szValue, cbValue);
        *(_Entry[Idx].szValue + cbValue) = '\0';
    }

    _Entry[Idx].cbValue = cbValue;
    _Entry[Idx].szParam = szParamMap[Idx];
    _Entry[Idx].fAllocated = TRUE;

    return TRUE;
}

//--------------------------------------------------------------------
// CParams::GetHwnd
//--------------------------------------------------------------------
HWND CParams::GetHwnd()
{
    return _hWnd;
}

//--------------------------------------------------------------------
// CParams::SetHwnd
//--------------------------------------------------------------------
BOOL CParams::SetHwnd(HWND* phWnd)
{
    _hWnd = phWnd ? *phWnd : GetActiveWindow();
    return TRUE;
}

//--------------------------------------------------------------------
// CParams::SetNC
//--------------------------------------------------------------------
VOID CParams::SetNC(DWORD* pcNC)
{
    _cNC = *pcNC;
}

//--------------------------------------------------------------------
// CParams::GetNC
//--------------------------------------------------------------------
DWORD CParams::GetNC()
{
    return _cNC;
}

//--------------------------------------------------------------------
// CParams::SetPreAuth
//--------------------------------------------------------------------
VOID CParams::SetPreAuth(BOOL fPreAuth)
{
    _fPreAuth = fPreAuth;
}

//--------------------------------------------------------------------
// CParams::IsPreAuth
//--------------------------------------------------------------------
BOOL CParams::IsPreAuth()
{
    return _fPreAuth;
}

//--------------------------------------------------------------------
// CParams::SetMd5Sess
//--------------------------------------------------------------------
VOID CParams::SetMd5Sess(BOOL fMd5Sess)
{
    _fMd5Sess = fMd5Sess;
}

//--------------------------------------------------------------------
// CParams::IsMd5Sess
//--------------------------------------------------------------------
BOOL CParams::IsMd5Sess()
{
    return _fMd5Sess;
}

//--------------------------------------------------------------------
// CParams::SetCredsSupplied
//--------------------------------------------------------------------
VOID CParams::SetCredsSupplied(BOOL fCredsSupplied)
{
    _fCredsSupplied = fCredsSupplied;
}

//--------------------------------------------------------------------
// CParams::AreCredsSupplied
//--------------------------------------------------------------------
BOOL CParams::AreCredsSupplied()
{
    return _fCredsSupplied;
}


//--------------------------------------------------------------------
// CParams::FindToken
// Returns TRUE if non-ws token is found in comma delmited string.
//--------------------------------------------------------------------
BOOL CParams::FindToken(LPSTR szBuf, DWORD cbBuf, LPSTR szMatch, DWORD cbMatch, LPSTR *pszPtr)
{
    LPSTR ptr = szBuf, szTok;
    DWORD cb  = cbBuf, cbTok;

    while (GetDelimitedToken(&ptr, &cb, &szTok, &cbTok, ','))
    {
        TrimWhiteSpace(&szTok, &cbTok);
        if (!_strnicmp(szTok, szMatch, cbMatch) && (cbTok == cbMatch))
        {
            if (pszPtr)
                *pszPtr = szTok;
            return TRUE;
        }
    }
    return FALSE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\digest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by digest.rc
//
#define IDS_STRING_UDOMAIN              1
#define IDS_STRING_UREALM		2
#define IDD_DIGEST                      101
#define IDI_SECURITY                    110
#define IDC_USERNAME_FIELD              1000
#define IDC_PASSWORD_FIELD              1001
#define IDC_URL_FIELD                   1002
#define IDC_HOST_FIELD                  1002
#define IDC_REALM_FIELD                 1003
#define IDC_COMBO1                      1006
#define IDC_HOST                        1008
#define IDC_SAVE_PASSWORD               1024
#define IDD_LOGIN_TEXT1                 1048
#define IDD_LOGIN_TEXT2                 1049


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        116
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1011
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\digest\persist.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    persist.cxx

Abstract:

Author:

    Adriaan Canter (adriaanc) 13-Jan-1998

Revision History:

    13-Jan-1998 adriaanc
        Created
    01-Aug-1998 adriaanc
        revised for digest.

--*/

#include "include.hxx"

typedef HRESULT (*PFNPSTORECREATEINSTANCE)(IPStore**, PST_PROVIDERID*, VOID*, DWORD);

// Globals

// PWL related variables.
static HMODULE MhmodWNET                                     = NULL;
static PFWNETGETCACHEDPASSWORD pfWNetGetCachedPassword       = NULL;
static PFWNETCACHEPASSWORD pfWNetCachePassword               = NULL;
static PFWNETREMOVECACHEDPASSWORD pfWNetRemoveCachedPassword = NULL;

// Pstore related variables.
static WCHAR c_szDigestCacheCredentials[]            = L"DigestCacheCredentials";
static PFNPSTORECREATEINSTANCE pPStoreCreateInstance = NULL;


// Webcheck is currently using this GUID for pstore:
// {14D96C20-255B-11d1-898F-00C04FB6BFC4}
// static const GUID GUID_PStoreType = { 0x14d96c20, 0x255b, 0x11d1, { 0x89, 0x8f, 0x0, 0xc0, 0x4f, 0xb6, 0xbf, 0xc4 } };

// Wininet and digest use this GUID for pstore:
// {5E7E8100-9138-11d1-945A-00C04FC308FF}
static const GUID GUID_PStoreType =
{ 0x5e7e8100, 0x9138, 0x11d1, { 0x94, 0x5a, 0x0, 0xc0, 0x4f, 0xc3, 0x8, 0xff } };


// Private function prototypes.

// PWL private function prototypes.
DWORD PWLSetCachedCredentials(LPSTR szKey, DWORD cbKey, LPSTR szCred, DWORD cbCred);
DWORD PWLGetCachedCredentials  (LPSTR szKey, DWORD cbKey, LPSTR cbCred, LPDWORD pcbCred);
DWORD PWLRemoveCachedCredentials  (LPSTR szKey, DWORD cbKey);

BOOL LoadWNet(VOID);


// PStore private function prototypes.
DWORD PStoreSetCachedCredentials(LPSTR szKey, DWORD cbKey, LPSTR szCred, DWORD cbCred, BOOL fRemove=FALSE);
DWORD PStoreGetCachedCredentials(LPSTR szKey, DWORD cbKey, LPSTR szCred, LPDWORD pcbCred);
DWORD PStoreRemoveCachedCredentials(LPSTR szKey, DWORD cbKey);

STDAPI CreatePStore (IPStore **ppIPStore);
STDAPI ReleasePStore(IPStore  *pIPStore);

// Find platform type.
DWORD PlatformType()
{
    OSVERSIONINFO versionInfo;
    versionInfo.dwOSVersionInfoSize = sizeof(versionInfo);
    if (GetVersionEx(&versionInfo))
        return versionInfo.dwPlatformId;

    return VER_PLATFORM_WIN32_WINDOWS;
}


//--------------------------------------------------------------------
// IsPersistenceDisabled
//--------------------------------------------------------------------
BOOL IsPersistenceDisabled()
{
    CHAR szBuf[MAX_PATH];

    DWORD dwType, dwError, dwOut = MAX_PATH, cbBuf = MAX_PATH;
    BOOL fRet = FALSE;
    HKEY hSettings = (HKEY) INVALID_HANDLE_VALUE;

    if ((dwError = RegCreateKey(HKEY_CURRENT_USER, INTERNET_SETTINGS_KEY, &hSettings)) == ERROR_SUCCESS)
    {
        if ((dwError = RegQueryValueEx(hSettings, DISABLE_PASSWORD_CACHE_VALUE, NULL, &dwType, (LPBYTE) szBuf, &cbBuf)) == ERROR_SUCCESS)
        {
            fRet = TRUE;
        }
    }

    if (hSettings != INVALID_HANDLE_VALUE)
        RegCloseKey(hSettings);

    return fRet;
}




/*--------------------------- Top Level APIs ---------------------------------*/



//--------------------------------------------------------------------
//  InetInitCredentialPersist
//--------------------------------------------------------------------
DWORD InetInitCredentialPersist()
{
    HRESULT hr;
    IPStore *pIPStore = NULL;
    DWORD dwDisable, dwAvail;
    HINSTANCE hInstPStoreC = 0;
    BOOL fPersistDisabled = FALSE;

    // we should have the digest lock at this point.
    // AuthLock();

    // First check to see if persistence is disabled via registry.
    if (IsPersistenceDisabled())
    {
        // Persistence disabled via registry.
        dwAvail= CRED_PERSIST_NOT_AVAIL;
        goto quit;
    }

    // We use PWL for Win95; this should be available.
    if (PlatformType() == VER_PLATFORM_WIN32_WINDOWS)
    {
        dwAvail = CRED_PERSIST_AVAIL;
        goto quit;
    }

    // If is WinNt, check if PStore is installed.
    hInstPStoreC = LoadLibrary(PSTORE_MODULE);
    if (!hInstPStoreC)
    {
        dwAvail = CRED_PERSIST_NOT_AVAIL;
        goto quit;
    }
    else
    {
        // Get CreatePStoreInstance function pointer.
        pPStoreCreateInstance = (PFNPSTORECREATEINSTANCE)
            GetProcAddress(hInstPStoreC, "PStoreCreateInstance");

        if (!pPStoreCreateInstance)
        {
            dwAvail = CRED_PERSIST_NOT_AVAIL;
            goto quit;
        }
    }

    // Create an IPStore.
    hr = CreatePStore(&pIPStore);

    // Succeeded in creating an IPStore.
    if (SUCCEEDED(hr) && pIPStore)
    {
        ReleasePStore(pIPStore);
        dwAvail = CRED_PERSIST_AVAIL;
    }
    else
    {
        // Failed to create an IPStore.
        dwAvail = CRED_PERSIST_NOT_AVAIL;
    }

quit:
    g_dwCredPersistAvail = dwAvail;

    //AuthUnlock();

    return g_dwCredPersistAvail;
}


//--------------------------------------------------------------------
// InetSetCachedCredentials
//--------------------------------------------------------------------
DWORD InetSetCachedCredentials  (LPSTR szCtx,
                                 LPSTR szRealm,
                                 LPSTR szUser,
                                 LPSTR szPass)
{
    DWORD cbKey, cbCred, dwError;

    CHAR szKey [MAX_AUTH_FIELD_LENGTH],
         szCred[MAX_AUTH_FIELD_LENGTH];


    DIGEST_ASSERT(szCtx && *szCtx && szRealm
        && szUser && *szUser && szPass);

    // Check if credential persistence is available.
    if ((g_dwCredPersistAvail == CRED_PERSIST_UNKNOWN)
        && (InetInitCredentialPersist() == CRED_PERSIST_NOT_AVAIL))
    {
        dwError = ERROR_OPEN_FAILED;
        goto quit;
    }


    // Form key and credential strings.
    strcpy(szKey, szCtx);
    strcat(szKey, "/");
    DWORD dwAvailBuf = MAX_AUTH_FIELD_LENGTH - strlen(szKey);
    strncpy(szKey + strlen(szKey), szRealm, dwAvailBuf - 1);
    szKey[MAX_AUTH_FIELD_LENGTH-1]= 0;
    cbKey = strlen(szKey) + 1;
//    cbKey  = wsprintf(szKey, "%s/%s", szCtx, szRealm) + 1;
    cbCred = wsprintf(szCred,"%s:%s", szUser, szPass) + 1;

    // Store credentials.
    if (PlatformType() == VER_PLATFORM_WIN32_WINDOWS)
    {
        // Store credentials using PWL.
        dwError = PWLSetCachedCredentials(szKey, cbKey, szCred, cbCred);
    }
    else
    {
        // Store credentials using PStore.
        dwError = PStoreSetCachedCredentials(szKey, cbKey, szCred, cbCred);
    }

quit:

    return dwError;
}


//--------------------------------------------------------------------
//  InetGetCachedCredentials
//--------------------------------------------------------------------
DWORD InetGetCachedCredentials  (LPSTR szCtx,
                                 LPSTR szRealm,
                                 LPSTR szUser,
                                 LPSTR szPass)

{
    DWORD cbKey, cbCred, nUser, dwError;

    CHAR szKey [MAX_AUTH_FIELD_LENGTH],
         szCred[MAX_AUTH_FIELD_LENGTH],
         *ptr;

    DIGEST_ASSERT(szCtx && *szCtx && szRealm && szUser && szPass);

    // Check if credential persistence is available.
    if ((g_dwCredPersistAvail == CRED_PERSIST_UNKNOWN)
        && (InetInitCredentialPersist() == CRED_PERSIST_NOT_AVAIL))
    {
        dwError = ERROR_OPEN_FAILED;
        goto quit;
    }


    // Key string is host/realm
    strcpy(szKey, szCtx);
    strcat(szKey, "/");
    DWORD dwAvailBuf = MAX_AUTH_FIELD_LENGTH - strlen(szKey);
    strncpy(szKey + strlen(szKey), szRealm, dwAvailBuf - 1);
    szKey[MAX_AUTH_FIELD_LENGTH-1]= 0;
    cbKey = strlen(szKey) + 1;
    // cbKey  = wsprintf(szKey, "%s/%s", szCtx, szRealm) + 1;
    cbCred = MAX_AUTH_FIELD_LENGTH;

    if (PlatformType() == VER_PLATFORM_WIN32_WINDOWS)
    {
        // Store credentials using PWL.
        if ((dwError = PWLGetCachedCredentials(szKey, cbKey,
            szCred, &cbCred)) != WN_SUCCESS)
            goto quit;
    }
    else
    {
        // Store credentials using PStore.
        if ((dwError = PStoreGetCachedCredentials(szKey, cbKey,
            szCred, &cbCred)) != ERROR_SUCCESS)
            goto quit;
    }

    // Should have retrieved credentials in form of username:password.
    ptr = strchr(szCred, ':');

    // Should never happen since username & password are required.
    if (!ptr || (ptr == szCred))
    {
        dwError = ERROR_OPEN_FAILED;
        goto quit;
    }

    // Copy username & null terminate.
    nUser = (DWORD)(ptr - szCred);
    memcpy(szUser, szCred, nUser);
    szUser[nUser] = '\0';

    // Copy password with null terminator.
    memcpy(szPass, ptr+1, cbCred - nUser);

quit:

    return dwError;
}


//--------------------------------------------------------------------
//  InetRemoveCachedCredentials
//--------------------------------------------------------------------
DWORD InetRemoveCachedCredentials (LPSTR szCtx, LPSTR szRealm)
{
    DWORD cbKey, dwError;
    CHAR szKey[MAX_AUTH_FIELD_LENGTH];

    DIGEST_ASSERT(szCtx && *szCtx && szRealm);

    // Check if credential persistence is available.
    if ((g_dwCredPersistAvail == CRED_PERSIST_UNKNOWN)
        && (InetInitCredentialPersist() == CRED_PERSIST_NOT_AVAIL))
    {
        dwError = ERROR_OPEN_FAILED;
        goto quit;
    }

    // Form key string.
    strcpy(szKey, szCtx);
    strcat(szKey, "/");
    DWORD dwAvailBuf = MAX_AUTH_FIELD_LENGTH - strlen(szKey);
    strncpy(szKey + strlen(szKey), szRealm, dwAvailBuf - 1);
    szKey[MAX_AUTH_FIELD_LENGTH-1]= 0;
    cbKey = strlen(szKey) + 1;
//    cbKey  = wsprintf(szKey, "%s/%s", szCtx, szRealm) + 1;

    if (PlatformType() == VER_PLATFORM_WIN32_WINDOWS)
    {
        // Remove credentials from PWL.
        dwError = PWLRemoveCachedCredentials(szKey, cbKey);
    }
    else
    {
        // Remove credentials from PStore.
        dwError =  PStoreRemoveCachedCredentials(szKey, cbKey);
    }

quit:
    return dwError;
}


/*--------------------------- PWL Functions ---------------------------------*/



//--------------------------------------------------------------------
//  PWLSetCachedCredentials
//--------------------------------------------------------------------
DWORD PWLSetCachedCredentials(LPSTR szKey, DWORD cbKey,
                              LPSTR szCred, DWORD cbCred)
{
    DWORD dwError;

    // Load WNet.
    if (!LoadWNet())
        return ERROR_OPEN_FAILED;

    // Store credentials.
    dwError =  (*pfWNetCachePassword)(szKey, (WORD) cbKey, szCred, (WORD) cbCred, PCE_WWW_BASIC, 0);

    return dwError;
}




//--------------------------------------------------------------------
// PWLGetCachedCredentials
//--------------------------------------------------------------------
DWORD PWLGetCachedCredentials  (LPSTR szKey, DWORD cbKey,
                                LPSTR szCred, LPDWORD pcbCred)
{
    DWORD dwError;

    // Load WNet.
    if (!LoadWNet())
        return ERROR_OPEN_FAILED;

    // Retrieve credentials.
    dwError = (*pfWNetGetCachedPassword) (szKey, (WORD) cbKey, szCred,
                                          (LPWORD) pcbCred, PCE_WWW_BASIC);

    return dwError;
}



//--------------------------------------------------------------------
// PWLRemoveCachedCredentials
//--------------------------------------------------------------------
DWORD PWLRemoveCachedCredentials  (LPSTR szKey, DWORD cbKey)
{
    DWORD dwError;

    // Load WNet.
    if (!LoadWNet())
        return ERROR_OPEN_FAILED;

    dwError = (*pfWNetRemoveCachedPassword) (szKey, (WORD) cbKey, PCE_WWW_BASIC);

    return dwError;
}


// PWL utility functions.


//--------------------------------------------------------------------
//  LoadWNet
//--------------------------------------------------------------------
BOOL LoadWNet(VOID)
{
    BOOL fReturn;

    // we should have the digest lock at this point.
    //AuthLock();

    // MPR.DLL already loaded.
    if (MhmodWNET)
    {
        fReturn = TRUE;
        goto quit;
    }

    // Load MPR.DLL
    MhmodWNET = LoadLibrary(WNETDLL_MODULE);

    // Fail if not loaded.
    if (MhmodWNET)
    {
        fReturn = TRUE;
    }
    else
    {
        fReturn = FALSE;
        goto quit;
    }

    pfWNetGetCachedPassword    = (PFWNETGETCACHEDPASSWORD)    GetProcAddress(MhmodWNET, WNETGETCACHEDPASS);
    pfWNetCachePassword        = (PFWNETCACHEPASSWORD)        GetProcAddress(MhmodWNET, WNETCACHEPASS);
    pfWNetRemoveCachedPassword = (PFWNETREMOVECACHEDPASSWORD) GetProcAddress(MhmodWNET, WNETREMOVECACHEDPASS);

    // Ensure we have all function pointers.
    if (!(pfWNetGetCachedPassword
          && pfWNetCachePassword
          && pfWNetRemoveCachedPassword))
    {
        fReturn = FALSE;
    }

quit:
    //AuthUnlock();

    return fReturn;
}



/*------------------------- PStore Functions -------------------------------*/



//--------------------------------------------------------------------
// PStoreSetCachedCredentials
//--------------------------------------------------------------------
DWORD PStoreSetCachedCredentials(LPSTR szKey, DWORD cbKey,
                                 LPSTR szCred, DWORD cbCred,
                                 BOOL fRemove)
{
    DIGEST_ASSERT(pPStoreCreateInstance);

    HRESULT         hr;
    DWORD           dwError;

    PST_TYPEINFO    typeInfo;
    PST_PROMPTINFO  promptInfo = {0};

    GUID itemType    = GUID_PStoreType;
    GUID itemSubtype = GUID_NULL;

    WCHAR wszKey[MAX_AUTH_FIELD_LENGTH];

    IPStore *       pStore = NULL;

    // PST_TYPEINFO data.
    typeInfo.cbSize = sizeof(typeInfo);
    typeInfo.szDisplayName = c_szDigestCacheCredentials;

    // PST_PROMPTINFO data (no prompting desired).
    promptInfo.cbSize        = sizeof(promptInfo);
    promptInfo.dwPromptFlags = 0;
    promptInfo.hwndApp       = NULL;
    promptInfo.szPrompt      = NULL;

    // Create a PStore interface.
    hr = CreatePStore(&pStore);
    if (!SUCCEEDED(hr))
        goto quit;

    DIGEST_ASSERT(pStore != NULL);

    // Create a type in HKCU.
    hr = pStore->CreateType(PST_KEY_CURRENT_USER, &itemType, &typeInfo, 0);
    if (!((SUCCEEDED(hr)) || (hr == PST_E_TYPE_EXISTS)))
        goto quit;

    // Create subtype.
    hr = pStore->CreateSubtype(PST_KEY_CURRENT_USER, &itemType,
                               &itemSubtype, &typeInfo, NULL, 0);

    if (!((SUCCEEDED(hr)) || (hr == PST_E_TYPE_EXISTS)))
        goto quit;

    // Convert key to wide char.
    MultiByteToWideChar(CP_ACP, 0, szKey, -1, wszKey, MAX_AUTH_FIELD_LENGTH);

    // Valid credentials are written; No credentials imples
    // that the key and credentials are to be deleted.
    if (szCred && cbCred && !fRemove)
    {
        // Write key and credentials to PStore.
        hr = pStore->WriteItem(PST_KEY_CURRENT_USER,
                               &itemType,
                               &itemSubtype,
                               wszKey,
                               cbCred,
                               (LPBYTE) szCred,
                               &promptInfo,
                               PST_CF_NONE,
                               0);
    }
    else
    {
        // Delete key and credentials from PStore.
        hr = pStore->DeleteItem(PST_KEY_CURRENT_USER,
                                &itemType,
                                &itemSubtype,
                                wszKey,
                                &promptInfo,
                                0);

    }

quit:

    // Release the interface, convert error and return.
    ReleasePStore(pStore);

    if (SUCCEEDED(hr))
        dwError = ERROR_SUCCESS;
    else
        dwError = ERROR_OPEN_FAILED;

    return dwError;
}


//--------------------------------------------------------------------
//  PStoreGetCachedCredentials
//--------------------------------------------------------------------
DWORD PStoreGetCachedCredentials(LPSTR szKey, DWORD cbKey,
                                 LPSTR szCred, LPDWORD pcbCred)
{
    DIGEST_ASSERT(pPStoreCreateInstance);

    HRESULT          hr ;
    DWORD            dwError;
    LPBYTE           pbData;

    PST_PROMPTINFO   promptInfo  = {0};

    GUID             itemType    = GUID_PStoreType;
    GUID             itemSubtype = GUID_NULL;

    IPStore*         pStore      = NULL;

    WCHAR wszKey[MAX_AUTH_FIELD_LENGTH];


    // PST_PROMPTINFO data (no prompting desired).
    promptInfo.cbSize        = sizeof(promptInfo);
    promptInfo.dwPromptFlags = 0;
    promptInfo.hwndApp       = NULL;
    promptInfo.szPrompt      = NULL;

    // Create a PStore interface.
    hr = CreatePStore(&pStore);
    if (!SUCCEEDED(hr))
        goto quit;

    DIGEST_ASSERT(pStore != NULL);

    // Convert key to wide char.
    MultiByteToWideChar(CP_ACP, 0, szKey, -1, wszKey, MAX_AUTH_FIELD_LENGTH);

    // Read the credentials from PStore.
    hr = pStore->ReadItem(PST_KEY_CURRENT_USER,
                          &itemType,
                          &itemSubtype,
                          wszKey,
                          pcbCred,
                          (LPBYTE*) &pbData,
                          &promptInfo,
                          0);

    // Copy credentials and free buffer allocated by ReadItem.
    if (SUCCEEDED(hr))
    {
        memcpy(szCred, pbData, *pcbCred);
        CoTaskMemFree(pbData);
        //hr = S_OK;
    }

quit:

    // Release the interface, convert error and return.
    ReleasePStore(pStore);

    if (SUCCEEDED(hr))
        dwError = ERROR_SUCCESS;
    else
        dwError = ERROR_OPEN_FAILED;

    return dwError;
}

//--------------------------------------------------------------------
//  PStoreRemoveCachedCredentials
//--------------------------------------------------------------------
DWORD PStoreRemoveCachedCredentials(LPSTR szKey, DWORD cbKey)
{
    // Pass in TRUE to remove credentials.
    return PStoreSetCachedCredentials(szKey, cbKey, NULL, 0, TRUE);
}

// PStore utility functions

//--------------------------------------------------------------------
//  CreatePStore
//--------------------------------------------------------------------
STDAPI CreatePStore(IPStore **ppIPStore)
{
    HRESULT hr;
    DWORD dwError;


    hr = pPStoreCreateInstance (ppIPStore,
                                  NULL,
                                  NULL,
                                  0);

  if (SUCCEEDED(hr))
        dwError = ERROR_SUCCESS;
    else
        dwError = ERROR_OPEN_FAILED;

    return dwError;
}


//--------------------------------------------------------------------
//  ReleasePStore
//--------------------------------------------------------------------
STDAPI ReleasePStore(IPStore *pIPStore)
{
    HRESULT hr;

    if (pIPStore)
    {
        pIPStore->Release();
        hr = S_OK;
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\digest\test\poptest.cxx ===
#include <windows.h>

#define SECURITY_WIN32

#include <sspi.h>
#include <issperr.h>
#include <security.h>

#define SSP_SPM_NT_DLL      "security.dll"
#define SSP_SPM_WIN95_DLL   "secur32.dll"

#define MAX_OUTPUT_BUFFER   4096

SEC_WINNT_AUTH_IDENTITY SecId;
HINSTANCE hSecLib;
PSecurityFunctionTable pFuncTbl = NULL;

// Preliminary func calls.
VOID InitializeSecurityInterface(BOOL fDirect);
BOOL HaveDigest();

// 3 Main SSPI calls.

// AcquireCredentialsHandle
SECURITY_STATUS ACH(PCredHandle phCred);

// InitializeSecurityContext
SECURITY_STATUS ISC(PCredHandle phCred, 
                    PCtxtHandle phCtxt, 
                    PCtxtHandle phNewCtxt, 
                    DWORD fContextReq,
                    LPSTR szChallenge,
                    LPSTR szResponse,
                    LPSTR szUser,
                    LPSTR szPass);

// FreeCredentialsHandle
SECURITY_STATUS FCH(PCredHandle phCred);

//--------------------------------------
// main
//--------------------------------------
INT main()
{        
    DWORD dwReturn = 0;
    SECURITY_STATUS ssResult;

    // Get (global) dispatch table.
    InitializeSecurityInterface(FALSE);
 
    // Check to see if we have digest.
    if (!HaveDigest())
    {
        dwReturn = 1;
        goto exit;
    }
    
    // Credential handle and pointer.
    CredHandle  hCred;
    CtxtHandle  hCtxt;
    
    // **** Call AcquireCredentialsHandle with no credential ***
    ACH(&hCred);

    // Challenge and response buffers. As usual, we dump into an
    // output buffer allocated on the stack.
    LPSTR szChallenge;
    CHAR szResponse[MAX_OUTPUT_BUFFER];

    
    // First call to ISC is with zero input, expecting a 0 DWORD output buffer, as 
    // we expect with POP clients
    szChallenge = NULL;

    // Make first call to ISC with null input - expect DWORD 0 output.
    ssResult = ISC( &hCred,                     // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt,                     // Output context.
                    0,                          // flags auth from cache, but not meaningful here.
                    szChallenge,                // NULL Server challenge header.
                    szResponse,                 // Response buffer.
                    NULL,                       // No user needed.
                    NULL);                      // No pass needed.
    
    
    // Expect 0 DWORD output and SEC_I_CONTINUE_NEEDED.
    if (ssResult != SEC_I_CONTINUE_NEEDED)
    {
        DebugBreak();
    }


    // Free cred handle.
    FCH(&hCred);
    
    // Re-acquire cred handle.
    ACH(&hCred);    

    // Now setup challenge from server for realm "Microsoft Passport" which will use the 
    // credentials user="jpoley@microsoft.com", pass = "jpoley"
    szChallenge = "realm=\"Microsoft Passport\", algorithm = \"MD5-sess\", qop=\"auth\", nonce=\"0123456789abcdef\"";
               
    // Authenticate using user = "jpoley@microsoft.com", pass = "jpoley"
    ssResult = ISC( &hCred,                     // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt,                     // Output context.
                    ISC_REQ_USE_SUPPLIED_CREDS, // Use the credentials supplied.
                    szChallenge,                // Server challenge header.
                    szResponse,                 // Response buffer,
                    "jpoley@microsoft.com",     // user
                    "jpoley"                    // pass
                    );
        

    // We have just successfully authenticated for jpoley@microsoft.com. In doing so,
    // we have created a credential for jpoley@microsoft.com in the digest cred cache.
    if (ssResult != SEC_E_OK)
    {
        DebugBreak();
    }
                    
                    
    // Free cred handle.
    FCH(&hCred);
    
    // Re-acquire cred handle.
    ACH(&hCred);    


    // Quick confirmation that we have a credential for "jpoley@microsoft.com,
    // we'll attempt to auth to a "Microsoft Passport" challenge without supplying
    // any creds - this should pull jpoley creds from 
    // the cache and authomatically generate an auth header.
    ssResult = ISC( &hCred,                     // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt,                     // Output context.
                    0,                          // auth from cache
                    szChallenge,                // Server challenge header.
                    szResponse,                 // Response buffer,
                    NULL,                       // Not passing user
                    NULL                        // Not passing in pass
                    );
    
    
    // Should have authed successfully.
    if (ssResult != SEC_E_OK)
    {
        DebugBreak();
    }
    
    
    // Free cred handle.
    FCH(&hCred);
    
    // Re-acquire cred handle.
    ACH(&hCred);    

    // Now setup a challange from server for realm "Microsoft Passport (we'll use
    // the previouse one but this time we wish to authyenticate on behalf of a new
    // user "alex@microsoft.com" and we DON'T HAVE A PASSWORD.

    szChallenge = "realm=\"Microsoft Passport\", algorithm = \"MD5-sess\", qop=\"auth\", nonce=\"0123456789abcdef\"";
               
    // Authenticate
    ssResult = ISC( &hCred,                     // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt,                     // Output context.
                    0,                          // Auth from cache.
                    szChallenge,                // Server challenge header.
                    szResponse,                 // Response buffer,
                    "alex@microsoft.com",       // user
                    NULL                        // No password!
                    );
        
    // We didn't have any credentials, so we better not have succeeded.
    if (ssResult != SEC_E_NO_CREDENTIALS)
    {
        DebugBreak();
    }
    
    // Free cred handle.
    FCH(&hCred);
    
    // Re-acquire cred handle.
    ACH(&hCred);    

    // Prompt for credentials for alex@microsoft.com. Since the challenge contains the
    // realm "Microsoft Passport", the credential created here will overwrite the
    // credential created for jpoley@microsoft.com, and generate the authorization string.
    ssResult = ISC( &hCred,                     // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt,                     // Output context.
                    ISC_REQ_PROMPT_FOR_CREDS,   // prompt for creds for alex@microsoft.com
                    szChallenge,                // Server challenge header.
                    szResponse,                 // Response buffer.
                    "alex@microsoft.com",       // user to prompt for.
                    NULL                        // Again, no password, we're prompting.
                    );


    // We should have succeeded in collecting creds for alex@microsoft.com and
    // generating the authorization string.
    if (ssResult != SEC_E_OK)
    {
        DebugBreak();
    }

    
    // Free cred handle.
    FCH(&hCred);
    
    // Re-acquire cred handle.
    ACH(&hCred);    
    
    
    // Quick confirmation that we have a credential for "alex@microsoft.com"
    // we'll attempt to auth to a "Microsoft Passport" challenge without supplying
    // any creds - this should pull alex creds from 
    // the cache and authomatically generate an auth header.
    ssResult = ISC( &hCred,                     // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt,                     // Output context.
                    0,                          // auth from cache
                    szChallenge,                // Server challenge header.
                    szResponse,                 // Response buffer,
                    NULL,                       // Not passing user
                    NULL                        // Not passing in pass
                    );
   
    
    // Should have authed successfully.
    if (ssResult != SEC_E_OK)
    {
        DebugBreak();
    }
    
    
    // Free cred handle.
    FCH(&hCred);
    
    if (hSecLib)
        FreeLibrary(hSecLib);

exit:
    return dwReturn;
}


// Main SSPI calls.


//--------------------------------------
// ACH
//--------------------------------------
SECURITY_STATUS ACH(PCredHandle phCred)
{
    SECURITY_STATUS ssResult;
   
    // ***** SSPI CALL *****
    ssResult = (*(pFuncTbl->AcquireCredentialsHandleA))
        (NULL,                 // pszPrinciple         NULL
        "Digest",              // pszPackageName       (Package name)
        SECPKG_CRED_OUTBOUND,  // dwCredentialUse      (client call)
        NULL,                  // pvLogonID            (not used)
        NULL,                  // pAuthData            (not used)
        NULL,                  // pGetKeyFn            (not used)
        0,                     // pvGetKeyArgument     (not used)
        phCred,                // phCredential         (credential returned)
        NULL);                 // PTimeStamp           (not used)
    
    return ssResult;
}

//--------------------------------------
// ISC
//--------------------------------------
SECURITY_STATUS ISC(PCredHandle phCred, 
               PCtxtHandle phCtxt, 
               PCtxtHandle phNewCtxt, 
               DWORD fContextReq,
               LPSTR szChallenge,
               LPSTR szResponse,
               LPSTR szUser,
               LPSTR szPass)

{


// If the client is not passing in user/pass
// (ie, normal operation) then the count of 
// buffers passed in is always 1.
#define SEC_BUFFER_NUM_NORMAL_BUFFERS       1

// These are the indicese specifically expected
// by the digest package 
#define SEC_BUFFER_CHALLENGE_INDEX          0
#define SEC_BUFFER_USERNAME_INDEX           1
#define SEC_BUFFER_PASSWORD_INDEX           2
#define SEC_BUFFER_NUM_EXTENDED_BUFFERS     3

    SECURITY_STATUS ssResult;    
    
    // Input buffers and descriptor.
    SecBuffer sbIn[SEC_BUFFER_NUM_EXTENDED_BUFFERS];    
    SecBufferDesc sbdIn;
    PSecBufferDesc psbdIn;

    // Calling with challenge; expect SEC_E_OK or SEC_E_NO_CREDENTIALS
    if (szChallenge)
    {        
        // Setup the challenge input buffer always (0th buffer)
        sbIn[SEC_BUFFER_CHALLENGE_INDEX].pvBuffer = szChallenge;
        sbIn[SEC_BUFFER_CHALLENGE_INDEX].cbBuffer = strlen(szChallenge);
        sbIn[SEC_BUFFER_CHALLENGE_INDEX].BufferType   = SECBUFFER_TOKEN;

        // If we have a user, setup the user buffer (1st buffer)
        sbIn[SEC_BUFFER_USERNAME_INDEX].pvBuffer = szUser ? szUser : NULL;
        sbIn[SEC_BUFFER_USERNAME_INDEX].cbBuffer = szUser ? strlen(szUser) : NULL;
        sbIn[SEC_BUFFER_USERNAME_INDEX].BufferType   = SECBUFFER_TOKEN;
        
        // If we have a password, setup the password buffer (2nd buffer for
        // a total of 3 buffers passed in (challenge + user + pass)
        sbIn[SEC_BUFFER_PASSWORD_INDEX].pvBuffer = szPass ? szPass : NULL;
        sbIn[SEC_BUFFER_PASSWORD_INDEX].cbBuffer = szPass ? strlen(szPass) : NULL;
        sbIn[SEC_BUFFER_PASSWORD_INDEX].BufferType   = SECBUFFER_TOKEN;
                
        sbdIn.pBuffers = sbIn;
    
        // If either or both user and pass passed in, set num input buffers to 3
        // (SEC_BUFFER_NUM_EXTENDED_BUFFERS)
        if (szUser || szPass)
            sbdIn.cBuffers = SEC_BUFFER_NUM_EXTENDED_BUFFERS;

        // else we're just passing in the one challenge buffer (0th buffer as usual)
        else
            sbdIn.cBuffers = SEC_BUFFER_NUM_NORMAL_BUFFERS;

        psbdIn = &sbdIn;

    }
    else
    {
        // Calling withOUT challenge; expect SEC_I_CONTINUE_NEEDED;
        psbdIn = NULL;
    }

    // Output buffer and descriptor.
    SecBuffer sbOut[1];    
    SecBufferDesc sbdOut;
    
    sbOut[0].pvBuffer = szResponse;
    sbOut[0].cbBuffer = MAX_OUTPUT_BUFFER;
    sbOut[0].BufferType   = SECBUFFER_TOKEN;
    sbdOut.pBuffers = sbOut;
    sbdOut.cBuffers = 1;

    // ***** SSPI CALL *****
    ssResult = (*(pFuncTbl->InitializeSecurityContextA))
        (phCred,            // phCredential    (from AcquireCredentialsHandle)
         phCtxt,            // phContext       (NULL on first call, phNewCtxt on subsequent calls).
         NULL,              // pszTargetName   (not used)
         fContextReq,       // fContextReq     (auth from cache, prompt or auth using supplied creds)
         0,                 // Reserved1       (not used)
         0,                 // TargetDataRep   (not used)
         psbdIn,            // PSecBufDesc     (input buffer descriptor)
         0,                 // Reserved2       (not used)
         phNewCtxt,         // phNewContext    (should be passed back as phCtxt on subsequent calls)
         &sbdOut,           // pOutput         (output buffer descriptor)
         NULL,              // pfContextAttr   (pfContextAttr, not used)
         NULL);             // ptsExpiry       (not used)

    return ssResult;
}



//--------------------------------------
// FCH
//--------------------------------------
SECURITY_STATUS FCH(PCredHandle phCred)
{
    SECURITY_STATUS ssResult;
   
    // ***** SSPI CALL *****
    ssResult = (*(pFuncTbl->FreeCredentialsHandle))(phCred);
    
    return ssResult;
}


// Utility calls.



//--------------------------------------
// InitializeSecurityInterface
//--------------------------------------
VOID InitializeSecurityInterface(BOOL fDirect)
{
    INIT_SECURITY_INTERFACE	addrProcISI = NULL;
    OSVERSIONINFO   VerInfo;
    CHAR szDLL[MAX_PATH];

    if (!fDirect)
    {
        VerInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

        GetVersionEx (&VerInfo);
        if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
            lstrcpy (szDLL, SSP_SPM_NT_DLL);
        }
        else if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
        {
            lstrcpy (szDLL, SSP_SPM_WIN95_DLL);
        }
    }
    else
    {
        strcpy(szDLL, "d:\\nt\\private\\inet\\digest\\objd\\i386\\digest.dll");
    }
    
    hSecLib = LoadLibrary (szDLL);
    
    addrProcISI = (INIT_SECURITY_INTERFACE) GetProcAddress( hSecLib, 
                    SECURITY_ENTRYPOINT_ANSI);       
        
    pFuncTbl = (*addrProcISI)();
}


//--------------------------------------
// HaveDigest
//--------------------------------------
BOOL HaveDigest()
{    
    SECURITY_STATUS ssResult;
    DWORD cPackages;
    PSecPkgInfoA pSecPkgInfo;
    BOOL fHaveDigest;

    // ***** SSPI call *****
    ssResult = (*(pFuncTbl->EnumerateSecurityPackagesA))(&cPackages, &pSecPkgInfo);

    // Check if we have digest.
    fHaveDigest = FALSE;
    if (ssResult == SEC_E_OK)
    {
        for (DWORD i = 0; i < cPackages; i++)
        {
            if (strcmp(pSecPkgInfo[i].Name, "Digest") == 0)
            {
                fHaveDigest = TRUE;
                break;
            }
        }
    }
    return fHaveDigest;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\digest\test\stress\library.cxx ===
#include <windows.h>
#include <stdio.h>
#include <process.h>

#define SECURITY_WIN32
#include <security.h>
#include <sspi.h>
#include <issperr.h>

#include "main.hxx"

#define SSP_SPM_NT_DLL      "security.dll"
#define SSP_SPM_WIN95_DLL   "secur32.dll"

PSecurityFunctionTable	g_pFuncTbl = NULL;

HINSTANCE hSecLib;

LPSTR
issperr2str( SECURITY_STATUS error );

struct DIGEST_PKG_DATA
{
    LPSTR szAppCtx;
    LPSTR szUserCtx;
};

#define SIG_DIGEST 'HTUA'

DIGEST_PKG_DATA PkgData;
SEC_WINNT_AUTH_IDENTITY_EXA SecIdExA;

//----------------------------------------------------------------------------
// InitializeSecurityInterface
//----------------------------------------------------------------------------
VOID InitializeSecurityInterface(BOOL fDirect)
{
    INIT_SECURITY_INTERFACE	addrProcISI = NULL;
    OSVERSIONINFO   VerInfo;
    CHAR szDLL[MAX_PATH];

    if (!fDirect)
    {
        VerInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

        GetVersionEx (&VerInfo);
        if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
            lstrcpy (szDLL, SSP_SPM_NT_DLL);
        }
        else if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
        {
            lstrcpy (szDLL, SSP_SPM_WIN95_DLL);
        }
    }
    else
    {
        strcpy(szDLL, "digest.dll");
    }
    
    hSecLib = LoadLibrary (szDLL);
    
    addrProcISI = (INIT_SECURITY_INTERFACE) GetProcAddress( hSecLib, 
                    SECURITY_ENTRYPOINT_ANSI);       
        
    g_pFuncTbl = (*addrProcISI)();
}


//----------------------------------------------------------------------------
// HaveDigest
//----------------------------------------------------------------------------
BOOL HaveDigest()
{    
    SECURITY_STATUS ssResult;
    DWORD cPackages;
    PSecPkgInfoA pSecPkgInfo;
    BOOL fHaveDigest;

    // ***** SSPI call *****
    ssResult = (*(g_pFuncTbl->EnumerateSecurityPackagesA))(&cPackages, &pSecPkgInfo);

    // Check if we have digest.
    fHaveDigest = FALSE;
    if (ssResult == SEC_E_OK)
    {
        for (DWORD i = 0; i < cPackages; i++)
        {
            if (strcmp(pSecPkgInfo[i].Name, "Digest") == 0)
            {
                fHaveDigest = TRUE;
                break;
            }
        }
    }
    return fHaveDigest;
}

//----------------------------------------------------------------------------
// LogonToDigestPkg
//----------------------------------------------------------------------------
SECURITY_STATUS LogonToDigestPkg(LPSTR szAppCtx, LPSTR szUserCtx, PCredHandle phCred)
{
    SECURITY_STATUS ssResult;
   
    // Logon with szAppCtx = szUserCtx = NULL.
    PkgData.szAppCtx = PkgData.szUserCtx = NULL;
    memset(&SecIdExA, 0, sizeof(SEC_WINNT_AUTH_IDENTITY_EXA));

    PkgData.szAppCtx = szAppCtx;
    PkgData.szUserCtx = szUserCtx;

    SecIdExA.Version = sizeof(SEC_WINNT_AUTH_IDENTITY_EXA);
    SecIdExA.User = (unsigned char*) &PkgData;
    SecIdExA.UserLength = sizeof(DIGEST_PKG_DATA);


    // ***** SSPI CALL *****
    dprintf(API,"AcquireCredentialsHandleA(\n"
				"PackageName: %s\n"
				"dwCredentialUse: %s\n"
				"pAuthData: %#x\n"
				"phCredential: %#x\n",
				"Digest",             // pszPackageName       (Package name)
				"OUTBOUND",  // dwCredentialUse      (Credentials aren't pulled from OS)
				&SecIdExA,            // pAuthData            ptr to g_PkgData
				phCred               // phCredential         (credential returned)
				);

    ssResult = (*(g_pFuncTbl->AcquireCredentialsHandleA))
        (NULL,                // pszPrinciple         NULL
        "Digest",             // pszPackageName       (Package name)
        SECPKG_CRED_OUTBOUND,  // dwCredentialUse      (Credentials aren't pulled from OS)
        NULL,                 // pvLogonID            (not used)
        &SecIdExA,            // pAuthData            ptr to g_PkgData
        NULL,                 // pGetKeyFn            (not used)
        0,                    // pvGetKeyArgument     (not used)
        phCred,               // phCredential         (credential returned)
        NULL);                // PTimeStamp           (not used)
    
	dprintf(API,"AcquireCredentialHandle(%s,%s) returns [%d,%d]\n",
				szAppCtx,
				szUserCtx,
				phCred->dwUpper,
				phCred->dwLower);

    return ssResult;
}


//----------------------------------------------------------------------------
// LogoffOfDigestPkg
//----------------------------------------------------------------------------
SECURITY_STATUS LogoffOfDigestPkg(PCredHandle phCred)
{
    SECURITY_STATUS ssResult;
   
    // ***** SSPI CALL *****
    ssResult = (*(g_pFuncTbl->FreeCredentialsHandle))(phCred);
    
	dprintf(API,"FreeCredentialsHandle([%d,%d]) returns %s\n", 
				phCred->dwUpper,
				phCred->dwLower,
				issperr2str(ssResult));
    return ssResult;
}


//----------------------------------------------------------------------------
// Authenticate
//----------------------------------------------------------------------------
SECURITY_STATUS
DoAuthenticate(PCredHandle phCred, 
               PCtxtHandle phCtxt, 
               PCtxtHandle phNewCtxt, 
               DWORD fContextReq,
               LPSTR szHeader,
               LPSTR szRealm,
               LPSTR szHost, 
               LPSTR szUrl, 
               LPSTR szMethod,    
               LPSTR szUser, 
               LPSTR szPass, 
               LPSTR szNonce,
               HWND  hWnd,
               LPSTR szResponse,
               DWORD cbResponse)
{
    SECURITY_STATUS ssResult;    
    
	ISC_PARAMS	ISC_Params;
	HANDLE hThread = NULL;
	DWORD dwRet;
	int i,j;

	BOOL fPersist = FALSE;

	TCHAR szUsername[256];
	TCHAR szPassword[256];

	dprintf(ENTRY_EXIT, "ENTER: DoAuthenticate ...\n");
	dprintf(INFO,
			"DoAuthenticate(\n"
			"szHeader %s \n"
			"szRealm %s \n"
			"szHost %s \n"
			"szUrl %s \n"
			"szMethod %s \n"
			"szUser %s \n"
			"szPass %s \n"
			"szNonce %s \n"
			,
           szHeader,
           szRealm,
           szHost, 
           szUrl, 
           szMethod,    
           szUser, 
           szPass, 
           szNonce);


	memset( (LPVOID)&ISC_Params, 0, sizeof(ISC_PARAMS) );

	ISC_Params.phCred = phCred;
	ISC_Params.phCtxt = phCtxt;
	ISC_Params.phNewCtxt = phNewCtxt;
	ISC_Params.fContextReq = fContextReq;
	ISC_Params.szHeader = szHeader;
	ISC_Params.szRealm = szRealm;
	ISC_Params.szHost = szHost;
	ISC_Params.szUrl = szUrl;
	ISC_Params.szMethod = szMethod;
	ISC_Params.szUser = szUser;
	ISC_Params.szPass = szPass;
	ISC_Params.szNonce = szNonce;
	ISC_Params.hWnd = hWnd;
	ISC_Params.szResponse = szResponse;
	ISC_Params.cbResponse = cbResponse;

	i = rand() % 10;

	j = rand() % 10;

	sprintf(szUsername,"user%d_%d@msn.com",i,j);
	sprintf(szPassword,"pass%d_%d",i,j);

	if( ( rand() % 100 ) > 50 )
		fPersist = TRUE;

	if( ISC_Params.fContextReq & ISC_REQ_PROMPT_FOR_CREDS ) {
		//
		// we need to start the UI thread
		//
		hThread = (HANDLE) _beginthread(fnUiThread,0,(LPVOID)&ISC_Params);
		//fnUiThread((LPVOID)&ISC_Params);

		SetUIUserNameAndPassword(szUsername,szPassword, fPersist);

		printf("Waiting for UI thread to complete\n");
		dwRet = WaitForSingleObject( hThread, INFINITE );
	} else {
		fnUiThread((LPVOID)&ISC_Params);
	}

	ssResult = ISC_Params.ss;
    // ***** SSPI CALL *****
//    ssResult = (*(g_pFuncTbl->InitializeSecurityContextA))
//        (phCred,            // phCredential    (from AcquireCredentialsHandle)
//         phCtxt,            // phContext       (NULL on first call, phNewCtxt on subsequent calls).
//         NULL,              // pszTargetName   (not used)
//         NULL,              // fContextReq     (not used)
//         0,                 // Reserved1       (not used)
//         0,                 // TargetDataRep   (not used)
//         &sbdIn,            // PSecBufDesc     (input buffer descriptor)
//         0,                 // Reserved2       (not used)
//         phNewCtxt,         // phNewContext    (should be passed back as phCtxt on subsequent calls)
//         &sbdOut,           // pOutput         (output buffer descriptor)
//         &fContextAttr,     // pfContextAttr   (auth from cache, prompt or auth using supplied creds)
//         NULL);             // ptsExpiry       (not used)

    return ssResult;
}

void __cdecl fnUiThread( LPVOID lpData )
{
	LPISC_PARAMS lpIscParams = (LPISC_PARAMS) lpData;


	lpIscParams -> ss =
	_InitializeSecurityContext(
				   lpIscParams -> phCred, 
				   lpIscParams -> phCtxt, 
				   lpIscParams -> phNewCtxt, 
				   lpIscParams -> fContextReq,
				   lpIscParams -> szHeader,
				   lpIscParams -> szRealm,
				   lpIscParams -> szHost, 
				   lpIscParams -> szUrl, 
				   lpIscParams -> szMethod,    
				   lpIscParams -> szUser, 
				   lpIscParams -> szPass, 
				   lpIscParams -> szNonce,
				   lpIscParams -> hWnd,
				   lpIscParams -> szResponse,
				   lpIscParams -> cbResponse);

	return;

}

SECURITY_STATUS
_InitializeSecurityContext(PCredHandle phCred, 
               PCtxtHandle phCtxt, 
               PCtxtHandle phNewCtxt, 
               DWORD fContextReq,
               LPSTR szHeader,
               LPSTR szRealm,
               LPSTR szHost, 
               LPSTR szUrl, 
               LPSTR szMethod,    
               LPSTR szUser, 
               LPSTR szPass, 
               LPSTR szNonce,
               HWND  hWnd,
               LPSTR szResponse,
               DWORD cbResponse)
{
    SECURITY_STATUS ssResult;    
    
    // Input buffers and descriptor.
    SecBuffer sbIn[10];    
    SecBufferDesc sbdIn;
    sbdIn.pBuffers = sbIn;
    sbdIn.cBuffers = 10;
    
	dprintf(API,"InitializeSecurityContext(\n"
				"Cred: [%d(%#x),%d(%#x)]\n"
				"Ctxt: [%d(%#x),%d(%#x)]\n"
				"New Ctxt: [%d(%#x),%d(%#x)]\n",
				(phCred?(phCred->dwUpper):0), 
				(phCred?(phCred->dwUpper):0), 
				   (phCred?(phCred->dwLower):0), 
				   (phCred?(phCred->dwLower):0), 
				   (phCtxt?(phCtxt->dwUpper):0), 
				   (phCtxt?(phCtxt->dwUpper):0), 
				   (phCtxt?(phCtxt->dwLower):0), 
				   (phCtxt?(phCtxt->dwLower):0), 
				   (phNewCtxt?(phNewCtxt->dwUpper):0), 
				   (phNewCtxt?(phNewCtxt->dwUpper):0), 
				   (phNewCtxt?(phNewCtxt->dwLower):0),
				   (phNewCtxt?(phNewCtxt->dwLower):0));

    sbIn[0].pvBuffer    = szHeader;           // Challenge header
    sbIn[1].pvBuffer    = szRealm;            // realm if preauth
    sbIn[2].pvBuffer    = szHost;             // host
    sbIn[3].pvBuffer    = szUrl;              // url
    sbIn[4].pvBuffer    = szMethod;           // http method
    sbIn[5].pvBuffer    = szUser;             // username (optional)
    sbIn[6].pvBuffer    = szPass;             // password (optional, not used currently)    
    sbIn[7].pvBuffer    = szNonce;            // nonce
    sbIn[8].pvBuffer    = NULL;               // nonce count not passed in.
    sbIn[9].pvBuffer    = &hWnd;              // window handle.


    // Output buffer and descriptor.
    SecBuffer sbOut[1];
    SecBufferDesc sbdOut;
    sbdOut.pBuffers = sbOut;
    sbdOut.cBuffers = 1;
        
    // Set output buffer.
    sbOut[0].pvBuffer = szResponse;
    sbOut[0].cbBuffer = cbResponse;

    // ***** SSPI CALL *****
    ssResult = (*(g_pFuncTbl->InitializeSecurityContextA))
        (phCred,            // phCredential    (from AcquireCredentialsHandle)
         phCtxt,            // phContext       (NULL on first call, phNewCtxt on subsequent calls).
         NULL,              // pszTargetName   (not used)
         fContextReq ,      // fContextReq     (auth from cache, prompt or auth using supplied creds)(not used)
         0,                 // Reserved1       (not used)
         0,                 // TargetDataRep   (not used)
         &sbdIn,            // PSecBufDesc     (input buffer descriptor)
         0,                 // Reserved2       (not used)
         phNewCtxt,         // phNewContext    (should be passed back as phCtxt on subsequent calls)
         &sbdOut,           // pOutput         (output buffer descriptor)
         NULL,				// pfContextAttr   (not used)
         NULL);             // ptsExpiry       (not used)

#ifdef _DEBUG
	fprintf(stderr,"ISC returned result : %s(%d), buffer : \n %s \n", 
					issperr2str(ssResult),ssResult,sbOut[0].pvBuffer );
#endif

    return ssResult;
}

VOID PrimeCredCache(CredHandle CredHandle, LPSTR szRealm, LPSTR szUser, LPSTR szPass)
{
    DWORD ssResult;
    CtxtHandle hCtxt;

    SecBufferDesc sbdIn;
    SecBuffer     sbIn[3];
    
    hCtxt.dwLower = CredHandle.dwLower;
    hCtxt.dwUpper = CredHandle.dwUpper;

    sbIn[0].pvBuffer = szRealm;
    sbIn[0].cbBuffer = strlen(szRealm);
    sbIn[1].pvBuffer = szUser;
    sbIn[1].cbBuffer = strlen(szUser);
    sbIn[2].pvBuffer = szPass;
    sbIn[2].cbBuffer = strlen(szPass);

    sbdIn.cBuffers = 3;
    sbdIn.pBuffers = sbIn;

    ssResult = (*(g_pFuncTbl->ApplyControlToken))(&hCtxt, &sbdIn);

}

//----------------------------------------------------------------------------
// main
//----------------------------------------------------------------------------
#ifdef UNIX
#define main prog_main

int _main(int argc, char **argv);

int _WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR pszCmdLine, int nCmdShow) {
    extern int __argc;
    extern char **__argv;
    return main(__argc, __argv);
}
int _main(int argc, char **argv)
#else
INT _main()
#endif
{        

#define IDENTITY_1 "Alice"
#define IDENTITY_2 "Bob"

    DWORD dwReturn = 0;
    SECURITY_STATUS ssResult;

    // Get (global) dispatch table.
    InitializeSecurityInterface(TRUE);
 
    // Check to see if we have digest.
    if (!HaveDigest())
    {
        dwReturn = 1;
        goto exit;
    }
    
    // Credential handle and pointer.
    CredHandle  hCred1, hCred2, hCred3; 
    CtxtHandle  hCtxt1, hCtxt2, hCtxt3;

    // Three apps logon using the same keys (appctx, userctx, both NULL);
    // These sessions will be used for authentication.
    LogonToDigestPkg(NULL, IDENTITY_1, &hCred1);
    LogonToDigestPkg(NULL, IDENTITY_1, &hCred2);
    LogonToDigestPkg(NULL, IDENTITY_1, &hCred3);

    // Three more apps also logon using the same keys.
    // we will prime the password cache with credentials for these apps
    // and expect to be able to share the credentials via the auth dialog.
    CredHandle hCred4, hCred5, hCred6;

    LogonToDigestPkg(NULL, IDENTITY_1, &hCred4);
    LogonToDigestPkg(NULL, IDENTITY_1, &hCred5);
    LogonToDigestPkg(NULL, IDENTITY_1, &hCred6);
    
    PrimeCredCache(hCred4, "testrealm@foo.com", "Wilma", "password");
    PrimeCredCache(hCred5, "testrealm@foo.com", "Betty", "passwordxxxx");
    PrimeCredCache(hCred6, "testrealm@foo.com", "Pebbles", "passwordxxxxx");

    // Finally, three more apps also logon using a different logon key (identity)
    // we will prime the password cache with credentials for these apps
    // Because of the different logon key we should never see these creds.
    CredHandle hCred7, hCred8, hCred9;
    
    LogonToDigestPkg(NULL, IDENTITY_2, &hCred7);
    LogonToDigestPkg(NULL, IDENTITY_2, &hCred8);
    LogonToDigestPkg(NULL, IDENTITY_2, &hCred9);
    
    PrimeCredCache(hCred7, "testrealm@foo.com", "Fred", "password");
    PrimeCredCache(hCred8, "testrealm@foo.com", "Barney",  "passwordxxxx");
    PrimeCredCache(hCred9, "testrealm@foo.com", "Bam Bam", "passwordxxxxxxxx");
    
    
    
    //------------------------------------------------------------------------------------------------------------- 
    // App 1 makes a request from a server, does not have credentials and must prompt
    // before finally succeeding.
    
    // Challenge from server.
    LPSTR szChallenge;
    szChallenge = "realm=\"testrealm@foo.com\", stale = FALSE, qop=\"auth,auth-int\", nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"";

    // Package will dump response into this buffer.
    CHAR szResponse[4096];
                
    // First try at authenticating.
    ssResult = 
    DoAuthenticate( &hCred1,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt1,                    // Output context.
                    0,                          // auth from cache.
                    szChallenge,                // Server challenge header.
                    NULL,                       // no realm since not preauth.
                    "www.foo.com",              // Host.
                    "/bar/baz/boz/bif.html",    // Url.
                    "GET",                      // Method.
                    NULL,                       // no Username
                    NULL,                       // no Password.
                    NULL,                       // no nonce
                    NULL,                       // don't need hwnd for auth.
                    szResponse,                // Response buffer.
                    4096);
        
    // Expect to not have credentials the first time - prompt.
    if (ssResult == SEC_E_NO_CREDENTIALS)
    {
        ssResult = 
        DoAuthenticate( &hCred1,                    // Cred from logging on.
                        &hCtxt1,                    // Ctxt from previous call
                        &hCtxt1,                    // Output context (same as from previous).
                        ISC_REQ_PROMPT_FOR_CREDS,   // prompt
                        szChallenge,                // Server challenge
                        NULL,                       // No realm
                        "www.foo.com",              // Host
                        "/bar/baz/boz/bif.html",    // Url
                        "GET",                      // Method
                        NULL,                       // no username
                        NULL,                       // no password
                        NULL,                       // no nonce
                        GetDesktopWindow(),         // desktop window
                        szResponse,                // Response buffer
                        4096);

    }

    // We now have credentials and this will generate the output string.
    if (ssResult == SEC_E_OK)
    {
        ssResult = 
        DoAuthenticate( &hCred1,                    // Cred from logging on.
                        &hCtxt1,                    // Ctxt not specified first time.
                        &hCtxt1,                    // Output context.
                        0,                          // auth
                        szChallenge,                // Server challenge.
                        NULL,                       // no realm
                        "www.foo.com",              // Host.
                        "/bar/baz/boz/bif.html",    // Url.
                        "GET",                      // Method.
                        NULL,                       // no username
                        NULL,                       // no password
                        NULL,                       // no nonce
                        NULL,                       // no hwnd
                        szResponse,                // Should have the response buffer now.
                        4096);
    }          

    //------------------------------------------------------------------------------------------------------------- 
    // App 2 makes a request to the same server and gets challenged for the same realm. First auth attempt will
    // not be successful since this is the first challenge this session, so it will have to prompt for credentials.
    // When prompting, because it shares credentials with App1, the drop-down will contain App1's credentials.
    ssResult = 
    DoAuthenticate( &hCred2,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt2,                    // Output context.
                    0,                          // auth from cache.
                    szChallenge,                // Server challenge header.
                    NULL,                       // no realm since not preauth.
                    "www.foo.com",              // Host.
                    "/bar/baz/boz/bif.html",    // Url.
                    "GET",                      // Method.
                    NULL,                       // no Username
                    NULL,                       // no Password.
                    NULL,                       // no nonce
                    NULL,                       // don't need hwnd for auth.
                    szResponse,                // Response buffer.
                    4096);
    
    // Generate the confirmation dialog. User can choose App1's creds or enter new credentials.
    if (ssResult == SEC_E_NO_CREDENTIALS)
    {
        ssResult = 
        DoAuthenticate( &hCred2,                    // Cred from logging on.
                        &hCtxt2,                    // Ctxt from previous call
                        &hCtxt2,                    // Output context (same as from previous).
                        ISC_REQ_PROMPT_FOR_CREDS,   // prompt
                        szChallenge,                // Server challenge
                        NULL ,                      // No realm
                        "www.foo.com",              // Host
                        "/bar/baz/boz/bif.html",    // Url
                        "GET",                      // Method
                        NULL,                       // no username
                        NULL,                       // no password
                        NULL,                       // no nonce
                        GetDesktopWindow(),         // desktop window
                        szResponse,                // Response buffer
                        4096);

    }
    

    // App 2 now has credentials and can authenticate successfully.
    if (ssResult == SEC_E_OK)
    {
        ssResult = 
        DoAuthenticate( &hCred2,                    // Cred from logging on.
                        &hCtxt2,                    // Ctxt not specified first time.
                        &hCtxt2,                    // Output context.
                        0,                          // auth
                        szChallenge,                // Server challenge.
                        NULL,                       // no realm
                        "www.foo.com",              // Host.
                        "/bar/baz/boz/bif.html",    // Url.
                        "GET",                      // Method.
                        NULL,                       // no username
                        NULL,                       // no password
                        NULL,                       // no nonce
                        NULL,                       // no hwnd
                        szResponse,                // Should have the response buffer now.
                        4096);
    }          

    //------------------------------------------------------------------------------------------------------------- 
    // App 3 makes a request to the same server and gets challenged for the same realm. First auth attempt will
    // not be successful since this is the first challenge this session, so it will have to prompt for credentials.
    // When prompting, because it shares credentials with App1 and App2 the drop-down could show two choices if
    // App2 entered new credentials (or just one if App2 chose to use App1's credential).
    ssResult = 
    DoAuthenticate( &hCred3,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt3,                    // Output context.
                    0,                          // auth from cache.
                    szChallenge,                // Server challenge header.
                    NULL,                       // no realm since not preauth.
                    "www.foo.com",              // Host.
                    "/bar/baz/boz/bif.html",    // Url.
                    "GET",                      // Method.
                    NULL,                       // no Username
                    NULL,                       // no Password.
                    NULL,                       // no nonce
                    NULL,                       // don't need hwnd for auth.
                    szResponse,                // Response buffer.
                    4096);
    
    // Generate the confirmation dialog. User can choose App1's creds or enter new credentials.
    if (ssResult == SEC_E_NO_CREDENTIALS)
    {
        ssResult = 
        DoAuthenticate( &hCred3,                    // Cred from logging on.
                        &hCtxt3,                    // Ctxt from previous call
                        &hCtxt3,                    // Output context (same as from previous).
                        ISC_REQ_PROMPT_FOR_CREDS,   // prompt
                        szChallenge,                // Server challenge
                        NULL ,                      // No realm
                        "www.foo.com",              // Host
                        "/bar/baz/boz/bif.html",    // Url
                        "GET",                      // Method
                        NULL,                       // no username
                        NULL,                       // no password
                        NULL,                       // no nonce
                        GetDesktopWindow(),         // desktop window
                        szResponse,                // Response buffer
                        4096);

    }
    

    // App 3 now has credentials and can authenticate successfully.
    if (ssResult == SEC_E_OK)
    {
        ssResult = 
        DoAuthenticate( &hCred3,                    // Cred from logging on.
                        &hCtxt3,                    // Ctxt not specified first time.
                        &hCtxt3,                    // Output context.
                        0,                          // auth
                        szChallenge,                // Server challenge.
                        NULL,                       // no realm
                        "www.foo.com",              // Host.
                        "/bar/baz/boz/bif.html",    // Url.
                        "GET",                      // Method.
                        NULL,                       // no username
                        NULL,                       // no password
                        NULL,                       // no nonce
                        NULL,                       // no hwnd
                        szResponse,                // Should have the response buffer now.
                        4096);
    }          
    
    
    //------------------------------------------------------------------------------------------------------------- 
    // App2 preauthenticates to "testrealm@foo.com" for a new url. Note that the credential that will be used
    // for preauthentication is whatever App2 chose or entered previously. The same would be true for 
    // App1 or App3.
    ssResult = 
    DoAuthenticate( &hCred2,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt2,                    // Output context.
                    0,                          // auth (preauth)
                    NULL,                       // No challenge header
                    "testrealm@foo.com",        // Realm for preauth.
                    "www.foo.com",              // Host.
                    "/bar/baz.gif",             // Url
                    "GET",                      // Method.
                    NULL,                       // no sername
                    NULL,                       // no password.
                    NULL,                       // no nonce
                    NULL,                       // no hwnd
                    szResponse,                // Response buffer.
                    4096);
    
    //------------------------------------------------------------------------------------------------------------- 
    // App3 made another request to the same server but did not preauthenticate. It got challenged for the
    // same realm and can authenticate without prompting because it has credentials for that realm.
    szChallenge = "realm=\"testrealm@foo.com\", stale = TRUE, qop=\"auth,auth-int\", nonce=\"abcdefge8b11d0f600bfb0c093\", opaque=\"efghijklmnopc403ebaf9f0171e9517f40e41\"";

    ssResult = 
    DoAuthenticate( &hCred3,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt3,                    // Output context.
                    0,                          // auth
                    szChallenge,                // Challenge from server.
                    NULL,                       // no realm
                    "www.foo.com",              // Host.
                    "/bar/baz.htm",             // Url
                    "GET",                      // Method.
                    NULL,                       // no username
                    NULL,                       // no password
                    NULL,                       // no nonce
                    NULL,                       // no hwnd
                    szResponse,                // Response buffer.
                    4096);
    
    
    
    
    // Logoff all three sessions
    ssResult = LogoffOfDigestPkg(&hCred1);
    ssResult = LogoffOfDigestPkg(&hCred2);
    ssResult = LogoffOfDigestPkg(&hCred3);
    ssResult = LogoffOfDigestPkg(&hCred4);
    ssResult = LogoffOfDigestPkg(&hCred5);
    ssResult = LogoffOfDigestPkg(&hCred6);
    ssResult = LogoffOfDigestPkg(&hCred7);
    ssResult = LogoffOfDigestPkg(&hCred8);
    ssResult = LogoffOfDigestPkg(&hCred9);
    
    if (hSecLib)
        FreeLibrary(hSecLib);

exit:
    return dwReturn;
}
    
LPSTR
issperr2str( SECURITY_STATUS error )
{

#define CASE(x) if( x == error ) \
						return #x;


//	switch( error ) {

		CASE ( SEC_E_INSUFFICIENT_MEMORY )

		//
		// MessageId: SEC_E_INVALID_HANDLE
		//
		// MessageText:
		//
		//  The handle specified is invalid
		//
		CASE ( SEC_E_INVALID_HANDLE )

		//
		// MessageId: SEC_E_UNSUPPORTED_FUNCTION
		//
		// MessageText:
		//
		//  The function requested is not supported
		//
		CASE ( SEC_E_UNSUPPORTED_FUNCTION )

		//
		// MessageId: SEC_E_TARGET_UNKNOWN
		//
		// MessageText:
		//
		//  The specified target is unknown or unreachable
		//
		CASE ( SEC_E_TARGET_UNKNOWN )

		//
		// MessageId: SEC_E_INTERNAL_ERROR
		//
		// MessageText:
		//
		//  The Local Security Authority cannot be contacted
		//
		CASE ( SEC_E_INTERNAL_ERROR )

		//
		// MessageId: SEC_E_SECPKG_NOT_FOUND
		//
		// MessageText:
		//
		//  The requested security package does not exist
		//
		CASE ( SEC_E_SECPKG_NOT_FOUND )

		//
		// MessageId: SEC_E_NOT_OWNER
		//
		// MessageText:
		//
		//  The caller is not the owner of the desired credentials
		//
		CASE ( SEC_E_NOT_OWNER )

		//
		// MessageId: SEC_E_CANNOT_INSTALL
		//
		// MessageText:
		//
		//  The security package failed to initialize, and cannot be installed
		//
		CASE ( SEC_E_CANNOT_INSTALL )

		//
		// MessageId: SEC_E_INVALID_TOKEN
		//
		// MessageText:
		//
		//  The token supplied to the function is invalid
		//
		CASE ( SEC_E_INVALID_TOKEN )

		//
		// MessageId: SEC_E_CANNOT_PACK
		//
		// MessageText:
		//
		//  The security package is not able to marshall the logon buffer,
		//  so the logon attempt has failed
		//
		CASE ( SEC_E_CANNOT_PACK )

		//
		// MessageId: SEC_E_QOP_NOT_SUPPORTED
		//
		// MessageText:
		//
		//  The per-message Quality of Protection is not supported by the
		//  security package
		//
		CASE ( SEC_E_QOP_NOT_SUPPORTED )

		//
		// MessageId: SEC_E_NO_IMPERSONATION
		//
		// MessageText:
		//
		//  The security context does not allow impersonation of the client
		//
		CASE ( SEC_E_NO_IMPERSONATION )

		//
		// MessageId: SEC_E_LOGON_DENIED
		//
		// MessageText:
		//
		//  The logon attempt failed
		//
		CASE ( SEC_E_LOGON_DENIED )

		//
		// MessageId: SEC_E_UNKNOWN_CREDENTIALS
		//
		// MessageText:
		//
		//  The credentials supplied to the package were not
		//  recognized
		//
		CASE ( SEC_E_UNKNOWN_CREDENTIALS )

		//
		// MessageId: SEC_E_NO_CREDENTIALS
		//
		// MessageText:
		//
		//  No credentials are available in the security package
		//
		CASE ( SEC_E_NO_CREDENTIALS )

		//
		// MessageId: SEC_E_MESSAGE_ALTERED
		//
		// MessageText:
		//
		//  The message supplied for verification has been altered
		//
		CASE ( SEC_E_MESSAGE_ALTERED )

		//
		// MessageId: SEC_E_OUT_OF_SEQUENCE
		//
		// MessageText:
		//
		//  The message supplied for verification is out of sequence
		//
		CASE ( SEC_E_OUT_OF_SEQUENCE )

		//
		// MessageId: SEC_E_NO_AUTHENTICATING_AUTHORITY
		//
		// MessageText:
		//
		//  No authority could be contacted for authentication.
		//
		CASE ( SEC_E_NO_AUTHENTICATING_AUTHORITY )

		//
		// MessageId: SEC_I_CONTINUE_NEEDED
		//
		// MessageText:
		//
		//  The function completed successfully, but must be called
		//  again to complete the context
		//
		CASE ( SEC_I_CONTINUE_NEEDED )

		//
		// MessageId: SEC_I_COMPLETE_NEEDED
		//
		// MessageText:
		//
		//  The function completed successfully, but CompleteToken
		//  must be called
		//
		CASE ( SEC_I_COMPLETE_NEEDED )

		//
		// MessageId: SEC_I_COMPLETE_AND_CONTINUE
		//
		// MessageText:
		//
		//  The function completed successfully, but both CompleteToken
		//  and this function must be called to complete the context
		//
		CASE ( SEC_I_COMPLETE_AND_CONTINUE )

		//
		// MessageId: SEC_I_LOCAL_LOGON
		//
		// MessageText:
		//
		//  The logon was completed, but no network authority was
		//  available.  The logon was made using locally known information
		//
		CASE ( SEC_I_LOCAL_LOGON )

		//
		// MessageId: SEC_E_BAD_PKGID
		//
		// MessageText:
		//
		//  The requested security package does not exist
		//
		CASE ( SEC_E_BAD_PKGID )

		//
		// MessageId: SEC_E_CONTEXT_EXPIRED
		//
		// MessageText:
		//
		//  The context has expired and can no longer be used.
		//
		CASE ( SEC_E_CONTEXT_EXPIRED )

		//
		// MessageId: SEC_E_INCOMPLETE_MESSAGE
		//
		// MessageText:
		//
		//  The supplied message is incomplete.  The signature was not verified.
		//
		CASE ( SEC_E_INCOMPLETE_MESSAGE )

		//
		// Provided for backwards compatibility
		//

		CASE ( SEC_E_NO_SPM )
		CASE ( SEC_E_NOT_SUPPORTED )

//		default:

			return "Unknown SSPI Error ";
//			break;

//	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\digest\test\stress\monkey.cpp ===
#include <process.h>
#include <windows.h>
//#include <winbase.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <assert.h>
#include <shlwapi.h>
#include <conio.h>
//#include <shlwapip.h>
#include "resource.h"
#include "lists.hxx"

//#define DBG
#define DEBUG
#define _DEBUG


#include "main.hxx"

#define MAX_HANDLES 255
////////////////////////////////////////
//
//      G L O B A L S
//
//
////////////////////////////////////////
CSessionAttributeList * g_pSessionAttributeList = NULL;
CSessionList * g_pSessionList = NULL;


DWORD   dwThreads = 0;
int             iNumIterations = 0;
unsigned uSeed = 0;

DWORD dwDebugLogCategory;
DWORD dwConsoleLogCategory;
DWORD dwDebugBreakCategory;
DWORD dwUIDialogMode = MODE_ALL;
BOOL fLogToDebugTerminal = FALSE;
BOOL fLogToConsole = TRUE;
BOOL fDebugBreak = FALSE;

#define MALLOC( x ) malloc(sizeof(x))

#define FIND_FUNCTION_KERNEL( x, y ) ( x##_P = (FN##x) GetProcAddress( hModule, #x ));
#define FIND_FUNCTION( x , y ) ( x##_P = (FN##x) GetProcAddress( hModule, y ));
#define IS_ARG(c) ( c == '-' )

//
// ACTION
//              A routine which takes a LPVOID as input, 
//              performs some action
//              and returns another LPVOID
//
typedef LPVOID ( WINAPI * ACTION)(LPVOID);

BOOL Test();

////////////////////////////////////////////////////////////////////////////////////
//
//		D E C L A R A T I O N S
//
////////////////////////////////////////////////////////////////////////////////////
typedef enum {
	MODE_NONE = -1,
	MODE_BUSY,
	MODE_FREE,
	MODE_CAPTURED
} MODE;

/*
CONTEXT_RECORD CAPTURED_CTX = { { 0xcabdcabd, 0xcabdcabd };
CONTEXT_RECORD FREE_CTX =	{{ 0, 0 };
CONTEXT_RECORD BUSY_CTX =	{{ 0xb00bb00b, 0xb00bb00b };
*/

CredHandle CAPTURED_CRED = { 0xcabdcabd, 0xcabdcabd };
CredHandle FREE_CRED =	{ 0, 0 };
CredHandle BUSY_CRED =	{ 0xb00bb00b, 0xb00bb00b };


typedef struct _CONTEXT_RECORD {

	// handle to the credential
	CredHandle hCred;

	// App ctx associated with this credential
	LPSTR		szAppCtx;

	// User Ctx associated with this credential
	LPSTR		szUserCtx;

	// Timestamp
	DWORD		dwTickCount;

	// MODE
	MODE		Mode;

} CONTEXT_RECORD, * LPCONTEXT_RECORD;

// forward declarations
class CSessionAttribute;

#define MAX_APP_CONTEXT_LENGTH	32
#define MAX_USER_CONTEXT_LENGTH MAX_APP_CONTEXT_LENGTH
typedef struct _CREDENTIAL_STRUCT {

	// username
	LPSTR szUserName;

	// password
	LPSTR szPassword;

	// realm
	LPSTR szRealm;

} CREDENTIAL_STRUCT, *LPCREDENTIAL_STRUCT;

typedef struct _HANDLE_RECORD {
	
	DWORD dwSignature;
	
	CONTEXT_RECORD hCredArray[MAX_HANDLES];

	int Count; // count of handles in use.
	
	CRITICAL_SECTION Lock;

} HANDLE_RECORD, *LPHANDLE_RECORD;

#define CTXHANDLE_ARRAY_SIGNATURE		'xtch' // 'hctx'

#define IS_VALID_CTXHANDLE_ARRAY(x)	{ assert( x -> dwSignature == CTXHANDLE_ARRAY_SIGNATURE ); }

#define IDENTITY_1		"Application_1"

// bugbug: The values of the CredHandles in these structures should match
// the corresponding *_CRED structure values.
//
#ifdef NEW_LOOKUP

    MODE ModeCaptured = MODE_CAPTURED;
    MODE ModeFree = MODE_FREE;
    MODE ModeBusy = MODE_BUSY;

    #define CAPTURED_CTX_REC	ModeCaptured

    #define FREE_CTX_REC	ModeFree

    #define BUSY_CTX_REC	ModeBusy

#else
    CONTEXT_RECORD CAPTURED_CTX_REC = {
									    { 0xcabdcabd, 0xcabdcabd },
									    NULL, 
									    NULL};

    CONTEXT_RECORD FREE_CTX_REC =	{
									    { 0, 0 }, 
									    NULL, 
									    NULL};

    CONTEXT_RECORD BUSY_CTX_REC =	{
									    { 0xb00bb00b, 0xb00bb00b }, 
									    NULL, 
									    NULL};
#endif // ifdef NEW_LOOKUP

BOOL operator==(const CredHandle op1, const CredHandle op2)
{
	return (( op1.dwUpper == op2.dwUpper ) && ( op1.dwUpper == op2.dwUpper ));
}

BOOL operator!=(const CredHandle op1, const CredHandle op2)
{
	return (( op1.dwUpper != op2.dwUpper ) || ( op1.dwUpper != op2.dwUpper ));
}

BOOL operator==(const CONTEXT_RECORD op1, const CONTEXT_RECORD op2)
{
	// we only compare the CredHandle
	return (op1.hCred == op2.hCred );
}

BOOL operator!=(const CONTEXT_RECORD op1, const CONTEXT_RECORD op2)
{
	// we only compare the CredHandle
	return (op1.hCred != op2.hCred );
}

typedef struct {

	// a string in the DWORD
	DWORD   dwSignature;

	// handles to contexts
	HANDLE_RECORD  * hCredentialHandles;

	// count of iterations
	int iCount;

} CONTEXT_DATA, * LPCONTEXT_DATA;

#define CONTEXT_SIGNATURE       'tnoc'
#define IS_VALID_CONTEXT(s) { assert ( s -> dwSignature == CONTEXT_SIGNATURE ); }
#define SET_CONTEXT_SIGNATURE(s) { s -> dwSignature = CONTEXT_SIGNATURE; }

//
// contexts passed to threads, and RegisterWaits() etc.
//

typedef struct _CALLBACK_CONTEXT {
	
	DWORD dwSignature;
	LPCONTEXT_DATA lpContext;
	LPHANDLE lpThreadHandle;
	LPHANDLE lpHandle;

} CALLBACK_CONTEXT, * LPCALLBACK_CONTEXT;

#define CALLBACK_CONTEXT_SIGNATURE	'kblc' // clbk
#define IS_VALID_CALLBACK_CONTEXT(x) ( assert( s -> dwSignature ) == CALLBACK_CONTEXT_SIGNATURE )

#ifdef NEW_LOOKUP
LPCONTEXT_RECORD
FindFreeSlot( 
			 HANDLE_RECORD * hArray, 
			 LPCONTEXT_RECORD hMode);
#else
LPCONTEXT_RECORD
FindFreeSlot( 
			 HANDLE_RECORD * hArray, 
			 LPCONTEXT_RECORD hMode);
#endif

LPHANDLE_RECORD
new_handle_record(DWORD dwSignature);

LPCALLBACK_CONTEXT
new_callback_context();

LPVOID
WINAPI fnAppLogon(
			LPVOID lpvData);

LPVOID
WINAPI fnAppLogonExclusive(
			LPVOID lpvData);

LPVOID
WINAPI fnAppLogonShared(
			LPVOID lpvData);

LPVOID
WINAPI fnAppLogoff(
			LPVOID lpvData);

LPVOID
WINAPI fnInit(
			LPVOID lpvData);

LPVOID
WINAPI fnPopulateCredentials(
			LPVOID lpvData);

LPVOID
WINAPI fnAuthChallenge(
			LPVOID lpvData);

LPVOID
WINAPI fnAuthChallengeAny(
			LPVOID lpvData);

LPVOID
WINAPI fnAuthChallengeUser(
			LPVOID lpvData);

LPVOID
WINAPI fnAuthChallengeUserPassword(
			LPVOID lpvData);

LPVOID
WINAPI fnUiPrompt(
			LPVOID lpvData);

LPVOID
WINAPI fnUiPromptAny(
			LPVOID lpvData);

LPVOID
WINAPI fnUiPromptUser(
			LPVOID lpvData);

LPVOID
WINAPI fnFlushCredentials(
			LPVOID lpvData);

LPVOID
WINAPI fnFlushCredentialsGlobal(
			LPVOID lpvData);

LPVOID
WINAPI fnFlushCredentialsSession(
			LPVOID lpvData);

BOOL
SetUIUserNameAndPassword(
						 LPSTR szUsername,
						 LPSTR szPassword,
						 BOOL fPersist);

//DWORD WINAPI fnRegisterWaitCallback( PVOID pvData );

//
//      Enum Type for STATE
//
typedef enum _State 
			{
				STATE_INVALID,

				STATE_NONE,

				STATE_INIT,

				STATE_APP_LOGON,

				    STATE_APP_LOGON_EXCLUSIVE,

				    STATE_APP_LOGON_SHARED,

				STATE_APP_LOGOFF,

				STATE_POPULATE_CREDENTIALS,

				STATE_AUTH_CHALLENGE,

				    STATE_AUTH_CHALLENGE_ANY,

				    STATE_AUTH_CHALLENGE_USER,

				    STATE_AUTH_CHALLENGE_USER_PASS,

				STATE_PREAUTH_CHALLENGE_ANY,

				STATE_PREAUTH_CHALLENGE_USER,

				STATE_PREAUTH_CHALLENGE_USER_PASS,

				STATE_UI_PROMPT,

				    STATE_UI_PROMPT_ANY,

				    STATE_UI_PROMPT_USER,

				STATE_FLUSH_CREDENTIALS,

				    STATE_FLUSH_CREDENTIALS_GLOBAL,

				    STATE_FLUSH_CREDENTIALS_SESSION,

                STATE_NUKE_TRUSTED_HOSTS,

				STATE_STATISTICS,

				STATE_STALL,

				STATE_DONE

			 }  STATE;


//
//      STATE Table definition
//
typedef struct _STATE_TABLE {

	//
	// The current state we are in
	//
	STATE CurrentState;
	
	//
	// THe next state which we will transition to
	//
	STATE NextState;

	//
	// Action ( function ) to be performed in the "CurrentState"
	//
	ACTION  Action;

	//
	// prob of going from CurrentState to NextState if there 
	// are two or more such transitions from the same state
	// present in the table
	//
	DWORD   dwProbability; 

} STATE_TABLE, *LPSTATE_TABLE;

STATE_TABLE TRANSITION_TABLE[] =
	{
		// transitions out of STATE_INIT
		{
			STATE_INIT, STATE_APP_LOGON,
			fnInit,
			50
		},
		// transitions out of STATE_INIT
		{
			STATE_INIT, STATE_FLUSH_CREDENTIALS,
			fnInit,
			100
		},
		// transitions out of STATE_APP_LOGON
		{
			STATE_APP_LOGON, STATE_UI_PROMPT,
			fnAppLogon,
			60
		},
		{
			STATE_APP_LOGON, STATE_POPULATE_CREDENTIALS,
			fnAppLogon,
			70
		},
		{
			STATE_APP_LOGON, STATE_AUTH_CHALLENGE,
			fnAppLogon,
			100
		},
		// transitions out of STATE_POPULATE_CREDENTIALS
		{
			STATE_POPULATE_CREDENTIALS, STATE_INIT,
			fnPopulateCredentials,
			30
		},
		{
			STATE_POPULATE_CREDENTIALS, STATE_APP_LOGOFF,
			fnPopulateCredentials,
			60
		},
		{
			STATE_POPULATE_CREDENTIALS, STATE_UI_PROMPT,
			fnPopulateCredentials,
			100
		},
		// transitions out of STATE_AUTH_CHALLENGE
		{
			STATE_AUTH_CHALLENGE, STATE_APP_LOGON,
			fnAuthChallenge,
			100
		},
		// transitions out of STATE_UI_PROMPT
		{
			STATE_UI_PROMPT, STATE_INIT,
			fnUiPrompt,
			100
		},
		// transitions out of STATE_FLUSH_CREDENTIALS
		{
			STATE_FLUSH_CREDENTIALS, STATE_APP_LOGON,
			fnFlushCredentials,
			100
		},
		// transitions out of STATE_APP_LOGOFF
		{
			STATE_APP_LOGOFF, STATE_APP_LOGON,
			fnAppLogoff,
			100
		},
		// transitions out of STATE_INVALID
		{
			STATE_INVALID, STATE_INVALID,
			NULL,
			100
		},
		// transitions out of STATE_DONE
		{
			STATE_DONE, STATE_INVALID,
			NULL,
			100
		}
	};

STATE_TABLE	APP_LOGON_TRANSITION_TABLE[] =
{

		// transitions out of STATE_INIT
		{
			STATE_INIT, STATE_APP_LOGON_SHARED,
			fnInit,
			50
		},
		{
			STATE_INIT, STATE_APP_LOGON_EXCLUSIVE,
			fnInit,
			100
		},
		// transitions out of STATE_APP_LOGON_EXCLUSIVE
		{
			STATE_APP_LOGON_EXCLUSIVE, STATE_DONE,
			fnAppLogonExclusive,
			50
		},
		{
			STATE_APP_LOGON_SHARED, STATE_DONE,
			fnAppLogonShared,
			100
		},
		// transitions out of STATE_DONE
		{
			STATE_DONE, STATE_DONE,
			NULL,
			100
		}
};

STATE_TABLE	AUTH_CHALLENGE_TRANSITION_TABLE[] =
{

		// transitions out of STATE_INIT
		{
			STATE_INIT, STATE_AUTH_CHALLENGE_ANY,
			fnInit,
			30
		},
		{
			STATE_INIT, STATE_AUTH_CHALLENGE_USER,
			fnInit,
			70
		},
		{
			STATE_INIT, STATE_AUTH_CHALLENGE_USER_PASS,
			fnInit,
			100
		},
		// transitions out of STATE_AUTH_CHALLENGE_ANY
		{
			STATE_AUTH_CHALLENGE_ANY, STATE_DONE,
			fnAuthChallengeAny,
			50
		},
		// transitions out of STATE_AUTH_CHALLENGE_USER
		{
			STATE_AUTH_CHALLENGE_USER, STATE_DONE,
			fnAuthChallengeUser,
			100
		},
		// transitions out of STATE_AUTH_CHALLENGE_USER_PASS
		{
			STATE_AUTH_CHALLENGE_USER_PASS, STATE_DONE,
			fnAuthChallengeUserPassword,
			100
		},
		// transitions out of STATE_DONE
		{
			STATE_DONE, STATE_DONE,
			NULL,
			100
		}
};

STATE_TABLE	UI_PROMPT_TRANSITION_TABLE[] =
{

		// transitions out of STATE_INIT
		{
			STATE_INIT, STATE_UI_PROMPT_ANY,
			fnInit,
			50
		},
		{
			STATE_INIT, STATE_UI_PROMPT_USER,
			fnInit,
			100
		},
		// transitions out of STATE_UI_PROMPT_ANY
		{
			STATE_UI_PROMPT_ANY, STATE_DONE,
			fnUiPromptAny,
			100
		},
		// transitions out of STATE_UI_PROMPT_USER
		{
			STATE_UI_PROMPT_USER, STATE_DONE,
			fnUiPromptUser,
			100
		},
		// transitions out of STATE_DONE
		{
			STATE_DONE, STATE_DONE,
			NULL,
			100
		}
};

STATE_TABLE	FLUSH_CREDENTIALS_TRANSITION_TABLE[] =
{

		// transitions out of STATE_INIT
		{
			STATE_INIT, STATE_FLUSH_CREDENTIALS_SESSION,
			fnInit,
			50
		},
		{
			STATE_INIT, STATE_FLUSH_CREDENTIALS_GLOBAL,
			fnInit,
			100
		},
		// transitions out of STATE_FLUSH_CREDENTIALS_SESSION
		{
			STATE_FLUSH_CREDENTIALS_SESSION, STATE_DONE,
			fnFlushCredentialsSession,
			100
		},
		// transitions out of STATE_FLUSH_CREDENTIALS_GLOBAL
		{
			STATE_FLUSH_CREDENTIALS_GLOBAL, STATE_DONE,
			fnFlushCredentialsGlobal,
			100
		},
		// transitions out of STATE_DONE
		{
			STATE_DONE, STATE_DONE,
			NULL,
			100
		}
};

VOID WINAPI fnRegisterWaitCallback(
					PVOID pvData,
					BOOLEAN  fAlertable);

VOID WINAPI fnTimerCallback(
					PVOID pvData,
					BOOLEAN  fAlertable);


LPCONTEXT_DATA
new_context();

DWORD
TuringMachine(
	STATE_TABLE     StateTable[],
	STATE           InitialState,
	LPVOID          lpvData);

//WAITORTIMERCALLBACKFUNC fnRegisterWaitCallback;

//extern HANDLE RegisterWaitForSingleObject( HANDLE, WAITORTIMERCALLBACKFUNC, PVOID, DWORD);
STATE
NEXT_STATE( STATE_TABLE Table[], STATE CurrentState );

ACTION
GET_STATE_ACTION( STATE_TABLE Table[], STATE CurrentState );

LPSTR
MapState( STATE State );

void
usage(void);

int __cdecl _sprintf( char * buffer, char * format, va_list );

LPVOID
WINAPI DefaultAction(
			LPVOID lpvData);

#ifdef NEW_LOOKUP
LPCONTEXT_RECORD
FindFreeSlot( HANDLE_RECORD * hArray, MODE * Mode )
{
	// hMode is for doing a context-sensitive search
	//
	// If hMode == FREE_CTX, 
	//	begin
	//			find a free-slot;
	//			mark it busy
	//			return the slot;
	//	end
	// else
	//	if hMode == BUSY_CTX
	//		begin
	//			find a busy-slot
	//			return slot
	//		end
	//	else
	//		/* this means that a search is being requested */
	//		find a record corresponding to hMode
	//		return it
	//

	int i;
	HANDLE hTemp = NULL, hOrig = NULL;
	LPCONTEXT_RECORD phRet = NULL;
	int Cnt=0;


	dprintf( ENTRY_EXIT, "Enter: FindFreeSlot( %#X, %s )\n",
				hArray, 
				((*Mode == MODE_FREE)
					?"FREE"
					:((*Mode == MODE_BUSY)
					?"BUSY"
					:"CAPTURED")));

	EnterCriticalSection( &hArray -> Lock );

	for( i = 0; (i < MAX_HANDLES) && (Cnt <= hArray -> Count); i ++, Cnt++ ) {


		if(		// requesting a free slot
			(
				( *Mode == MODE_FREE )
			&&	( hArray -> hCredArray[i].Mode == MODE_FREE ) 
			) 
		||		// requesting any slot having valid credentials
			(
				( *Mode == MODE_BUSY ) 
			&&	( hArray -> hCredArray[i].Mode == MODE_BUSY ) 
			//&&	( hArray -> hCredArray[i].Mode != MODE_FREE ) 
			//&&	( hArray -> hCredArray[i].Mode != MODE_CAPTURED )
			)
		//||		// doing a context sensitive search
		//	(	// bugbug: what happens when szAppCtx stored is zero ?
		//		//( hArray -> hCredArray[i].Mode != MODE_FREE )
		//		( hArray -> hCredArray[i].Mode == MODE_BUSY )
		//	&&	( hMode -> szAppCtx && *hMode -> szAppCtx )
		//	&&	!strcmp( hArray -> hCredArray[i].szAppCtx, hMode -> szAppCtx )
		//	)
		) {
			// capture the handle if the handle requested is a free handle
			if( *Mode == MODE_FREE )
				hArray -> hCredArray[i].Mode = MODE_CAPTURED;

			phRet = &hArray -> hCredArray[i];
			break;
		}
	}

	LeaveCriticalSection( &hArray -> Lock );

	if(( i == MAX_HANDLES ) || (Cnt > hArray -> Count) )
		phRet = NULL;
	else {
		++ hArray -> Count;
	}
	
	
	if( phRet != NULL ) {
		dprintf( ENTRY_EXIT, "Exit: FindFreeSlot returns [%#x,%#x]\n",
			phRet->hCred.dwUpper,
			phRet->hCred.dwLower);
	} else {
		dprintf( ENTRY_EXIT, "Exit: FindFreeSlot returns %#x\n",phRet);
	}

	return phRet;
}
#else
LPCONTEXT_RECORD
FindFreeSlot( HANDLE_RECORD * hArray, LPCONTEXT_RECORD hMode )
{
	// hMode is for doing a context-sensitive search
	//
	// If hMode == FREE_CTX, 
	//	begin
	//			find a free-slot;
	//			mark it busy
	//			return the slot;
	//	end
	// else
	//	if hMode == BUSY_CTX
	//		begin
	//			find a busy-slot
	//			return slot
	//		end
	//	else
	//		/* this means that a search is being requested */
	//		find a record corresponding to hMode
	//		return it
	//

	int i;
	HANDLE hTemp = NULL, hOrig = NULL;
	LPCONTEXT_RECORD phRet = NULL;
	int Cnt=0;


	dprintf( ENTRY_EXIT, "Enter: FindFreeSlot( %#X, %#X )\n",hArray, hMode );

	EnterCriticalSection( &hArray -> Lock );

	for( i = 0; (i < MAX_HANDLES) && (Cnt <= hArray -> Count); i ++, Cnt++ ) {


		if(		// requesting a free slot
			(
				( hMode -> hCred == FREE_CRED )
			&&	( hArray -> hCredArray[i].hCred == hMode -> hCred ) 
			) 
		||		// requesting any slot having valid credentials
			(
				( hMode -> hCred == BUSY_CRED ) 
			&&	( hArray -> hCredArray[i].hCred != FREE_CRED ) 
			&&	( hArray -> hCredArray[i].hCred != CAPTURED_CRED )
			)
		||		// doing a context sensitive search
			(	// bugbug: what happens when szAppCtx stored is zero ?
				( hArray -> hCredArray[i].hCred != FREE_CRED )
			&&	( hMode -> szAppCtx && *hMode -> szAppCtx )
			&&	!strcmp( hArray -> hCredArray[i].szAppCtx, hMode -> szAppCtx )
			)
		) {
			// capture the handle if the handle requested is a free handle
			if( hMode->hCred == FREE_CRED )
				hArray -> hCredArray[i].hCred = CAPTURED_CRED;

			phRet = &hArray -> hCredArray[i];
			break;
		}
	}

	LeaveCriticalSection( &hArray -> Lock );

	if(( i == MAX_HANDLES ) || (Cnt > hArray -> Count) )
		phRet = NULL;
	else {
		++ hArray -> Count;
	}
	
	
	if( phRet != NULL ) {
		dprintf( ENTRY_EXIT, "Exit: FindFreeSlot returns %#x(%#x)\n",phRet,*phRet);
	} else {
		dprintf( ENTRY_EXIT, "Exit: FindFreeSlot returns %#x\n",phRet);
	}

	return phRet;
}
#endif

int __cdecl dprintf(DWORD dwCategory, char * format, ...) {

    va_list args;
    char buf[1024];
    char * ptr = buf;
	DWORD dwThreadId = GetCurrentThreadId();
    int n;

    ptr += sprintf(buf,"< %d:%#x > ", uSeed, dwThreadId );
    va_start(args, format);
    n = vsprintf(ptr, format, args);
    va_end(args);

	if(
			(fLogToDebugTerminal ) 
		&&	(dwCategory >= dwDebugLogCategory)
	)
	    OutputDebugString(buf);

	if(
		( fLogToConsole)
		&& ( dwCategory >= dwConsoleLogCategory)
	)
		printf("%s", buf );

	if(
			fDebugBreak
		&& ( dwCategory >= dwDebugBreakCategory ) 
	) {
		DebugBreak();
	}
    return n;
}

void
usage()
{
	dprintf( INFO, "thrdtest \n"
			" -n<number-of-iterations> \n"
			" -s: Directly Load the DLL \n"
			" -d<Level>: What to log to debug terminal (default: NO logging)\n"
			" -c<Level>: What to log to console (Default: INFO)\n"
			"		<Level>:	INFO %d\n"
			"					ENTRY_EXIT %d\n"
			"					STATISTICS %d\n"
			"					API %d\n"
			"					ERROR %d\n"
			"					FATAL %d\n",
			INFO,
			ENTRY_EXIT,
			STATISTICS,
			API,
			ERROR,
			FATAL
		);

	exit(0);
}

LPVOID
WINAPI fnEndMonkey(
			LPVOID lpvData)
{

	LPCONTEXT_DATA lpContext = (LPCONTEXT_DATA) lpvData;

    dprintf( ENTRY_EXIT, "ENTER: fnEndMonkey : %X\n", lpvData );

	dprintf( INFO, "\n\n\n Statistics ...................................\n");
    dprintf( ENTRY_EXIT, "EXIT: fnEndMonkey : %X\n", lpvData );

	return lpvData;
}
LPCONTEXT_DATA
new_context()
{
	LPCONTEXT_DATA lpContext;

	lpContext = (LPCONTEXT_DATA) MALLOC( CONTEXT_DATA );

	if( !lpContext ) {
		dprintf( ERROR, "Error allocating context \n");
		exit(0);
	}

	ZeroMemory( lpContext, sizeof(CONTEXT_DATA) );

	lpContext -> dwSignature = CONTEXT_SIGNATURE;

	return lpContext;
}

LPHANDLE_RECORD
new_handle_record(DWORD dwSignature)
{
	LPHANDLE_RECORD lpContext;

	dprintf( ENTRY_EXIT, "Enter: new_handle_record \n");
	lpContext = (LPHANDLE_RECORD) MALLOC( HANDLE_RECORD );

	if( !lpContext ) {
		dprintf( ERROR, "Error allocating handle record \n");
		exit(0);
	}

	ZeroMemory( lpContext, sizeof(HANDLE_RECORD) );

	for(int i=0; i < MAX_HANDLES; i++ ) {
		lpContext->hCredArray[i].Mode = MODE_FREE;
		lpContext->hCredArray[i].dwTickCount = 0;
		lpContext->hCredArray[i].hCred.dwUpper = 0;
		lpContext->hCredArray[i].hCred.dwLower = 0;
		lpContext->hCredArray[i].szAppCtx = NULL;
		lpContext->hCredArray[i].szUserCtx = NULL;
	}		
	lpContext -> dwSignature = dwSignature;

	InitializeCriticalSection( &lpContext->Lock);
	//lpContext -> dwSignature = CONTEXT_SIGNATURE;

	dprintf( ENTRY_EXIT, "Exit: new_handle_record \n");

	return lpContext;
}

LPCALLBACK_CONTEXT
new_callback_context()
{
	LPCALLBACK_CONTEXT lpContext;

	dprintf( ENTRY_EXIT, "Enter: new_callback_context \n");
	lpContext = (LPCALLBACK_CONTEXT) MALLOC( CALLBACK_CONTEXT );

	if( !lpContext ) {
		dprintf( ERROR, "Error allocating callback context \n");
		exit(0);
	}

	ZeroMemory( lpContext, sizeof(CALLBACK_CONTEXT) );
	lpContext -> dwSignature = CALLBACK_CONTEXT_SIGNATURE;

	dprintf( ENTRY_EXIT, "Exit: new_callback_context \n");

	return lpContext;
}

int
__cdecl main( int ac, char * av[] )
{
	DWORD dwError;


	LPCONTEXT_DATA lpContext;
	//ZeroMemory( (LPVOID)&_Context, sizeof(CONTEXT_DATA) );
	HMODULE hModule = NULL;
	BOOL fExpectingIterations = FALSE;
	BOOL fUseDigestDllOnly = FALSE;
	BOOL fExpectingSeedValue = FALSE;
	BOOL fTest = FALSE;

	dwDebugLogCategory = ERROR;
	dwConsoleLogCategory = INFO;

	uSeed = (unsigned )time(NULL)	;

	for( ac--, av++; ac; ac--, av++) {

		  if(IS_ARG(**av)) {
				switch(*++*av) {

				case 'n' : 
					if( *++*av) {
						iNumIterations = atoi(*av);
					} else
						fExpectingIterations = TRUE;
					break;

				case 's' :
						fUseDigestDllOnly = TRUE;
						break;

				case 'd' :
						fLogToDebugTerminal = TRUE;
						if( *++*av) {
							dwDebugLogCategory = (DWORD)atoi(*av);
						} else
							dwDebugLogCategory = ERROR;
						break;

				case 'c' :
						if( *++*av) {
							dwConsoleLogCategory = (DWORD)atoi(*av);
						} else
							dwConsoleLogCategory = INFO;
						break;

				case 'b' :
						fDebugBreak = TRUE;
						if( *++*av) {
							dwDebugBreakCategory = (DWORD)atoi(*av);
						} else
							dwDebugBreakCategory = ERROR;
						break;

				case 'r' :
					if( *++*av) {
						uSeed = atol(*av);
					} else
						fExpectingSeedValue = TRUE;
					break;

				case 't' :
					fTest = TRUE;
					break;

				case 'i' :
					dwUIDialogMode = MODE_IE_ONLY;

					break;

				case '?':
				case 'h':
				default:
						usage();
						exit(0);
						break;

				} // switch
		} else {
			if( fExpectingIterations ) {
				 if( *av ) {
					iNumIterations = atoi(*av);
					fExpectingIterations = FALSE;
				 }  
			} else
			if( fExpectingSeedValue ) {
				 if( *av ) {
					uSeed = atol(*av);
					fExpectingSeedValue = FALSE;
				 }  
			} else
				usage();

		} // if IS_ARG
   } // for



	if( fExpectingIterations )
		iNumIterations = -1; // infinite

	dprintf( INFO, "Monkey Circus Starts ... \n");

	    // Get (global) dispatch table.
    InitializeSecurityInterface(fUseDigestDllOnly );
 
    // Check to see if we have digest.
    if (!HaveDigest())
    {
        goto cleanup;
    }

	if( fTest ) {
		Test();
		goto cleanup;
	}

	//
	// initialize global session lists
	//
#ifdef AI
	g_pSessionAttributeList = new CSessionAttributeList();
	g_pSessionList = new CSessionList();
#endif

	lpContext = new_context();
	
	lpContext -> hCredentialHandles = new_handle_record( CTXHANDLE_ARRAY_SIGNATURE );

	srand( uSeed );

	dwError = TuringMachine(
					TRANSITION_TABLE,
					STATE_INIT,
					(LPVOID) lpContext
				 );

cleanup:

	dprintf( INFO, "Monkey circus ending ...\n");

	if( hModule )
		FreeLibrary( hModule );

	return 0;
}

DWORD
TuringMachine(
	STATE_TABLE     StateTable[],                           
	STATE           InitialState,
	LPVOID          lpvData)
{                                                                               

	LPCONTEXT_DATA lpContext = ( LPCONTEXT_DATA ) lpvData;
	BOOL fDone = FALSE;
	STATE CurrentState;
	STATE NextState;
	ACTION Action;
	LPVOID  lpNewContext;



	CurrentState = InitialState;

#define MAP_STATE(s) MapState(s)

	
	while(
			( !fDone ) 
		&&      ( lpContext -> iCount != iNumIterations)
	) {

		//fnStatistics( lpvData );

		NextState = NEXT_STATE( StateTable, CurrentState );

#ifdef DEBUG
		dprintf( INFO, "Current State : %s, Next : %s\n", MAP_STATE( CurrentState ), MAP_STATE( NextState ) );
#endif

		// increment the count of iterations thru the monkey

		++ lpContext -> iCount;
		

		
		switch(  CurrentState ) {

			case STATE_INIT : 
			case STATE_STATISTICS:
			case STATE_STALL:

			case STATE_APP_LOGON:
			case STATE_APP_LOGON_EXCLUSIVE:
			case STATE_APP_LOGON_SHARED:

			case STATE_APP_LOGOFF:

			case STATE_POPULATE_CREDENTIALS:

			case STATE_AUTH_CHALLENGE:

			case STATE_AUTH_CHALLENGE_ANY:

			case STATE_AUTH_CHALLENGE_USER:

			case STATE_AUTH_CHALLENGE_USER_PASS:

			case STATE_PREAUTH_CHALLENGE_ANY:

			case STATE_PREAUTH_CHALLENGE_USER:

			case STATE_PREAUTH_CHALLENGE_USER_PASS:
			
			case STATE_UI_PROMPT:
			case STATE_UI_PROMPT_ANY:
			case STATE_UI_PROMPT_USER:

			case STATE_FLUSH_CREDENTIALS:
			case STATE_FLUSH_CREDENTIALS_GLOBAL:
			case STATE_FLUSH_CREDENTIALS_SESSION:
				Action = GET_STATE_ACTION( StateTable, CurrentState );
				lpNewContext = (LPVOID) Action((LPVOID)lpContext);
				break;

			case STATE_INVALID :
			case STATE_DONE :
				fDone = TRUE;
				goto finish;
				break;

			default:
				dprintf( INFO, "BUGBUG: Reached default state \n");
				break;
				//break;
				;

		}

		CurrentState = NextState;
		NextState = STATE_INVALID;
		
	}

	//scanf("%d",&i);
finish:

	return ERROR_SUCCESS;
}

STATE
NEXT_STATE( STATE_TABLE Table[], STATE CurrentState )
{
	STATE NextState = STATE_INVALID;
	
	int i;
	DWORD   dwRand, 
			dwPreviousStateProbability = 0,
			dwProbability = 0;
	BOOL fFound = FALSE;

	// first generate a random number between 0 & 100 ( 0 .. 99 )
	i = (int)(rand() % 100);
	dwRand = (DWORD) i;

#ifdef _DEBUGG
	for( i=0; Table[i].Action; i++ ) {
		dprintf( INFO, "--- \t %s %s %X %d\n",
			MAP_STATE( Table[i].CurrentState ),
			MAP_STATE( Table[i].NextState ),
			Table[i].Action,
			Table[i].dwProbability );
	}
#endif

	//
	// BUGBUG: We assume that the transition table entries are ordered in the ascending order of probabilities
	for( i = 0; Table[i].Action; i++ ) {

		if( Table[i].CurrentState != CurrentState )
			continue;

		dwProbability = Table[i].dwProbability;
		NextState = Table[i].NextState;

#ifdef _DEBUGG
		dprintf( INFO, "RAND: %d CurrentState: %s Considering Next State %s, prob %d\n",
					dwRand, MAP_STATE( CurrentState ), MAP_STATE( NextState ), Table[i].dwProbability );
#endif

		if( 
				( Table[i].CurrentState == CurrentState )
			&&      (
					( Table[i].dwProbability == 100 )
				||      ( 
						( dwRand <= Table[i].dwProbability )
					&&      ( dwRand > dwPreviousStateProbability )
					)
				)
		) {
			fFound = TRUE;
#ifdef _DEBUGG
		dprintf( INFO, ">> RAND: %d Selected Next State %s, prob %d\n",
					dwRand, MAP_STATE( NextState ), Table[i].dwProbability );
#endif
			break;
		}

		dwPreviousStateProbability = Table[i].dwProbability;
	}

	return fFound?NextState:STATE_INVALID;
}


ACTION
GET_STATE_ACTION( STATE_TABLE Table[], STATE CurrentState )
{
	STATE NextState = STATE_INVALID;
	ACTION Action = DefaultAction;
	int i;

	for( i = 0; Table[i].Action; i++ ) {
		if( Table[i].CurrentState == CurrentState )
			Action = Table[i].Action;
	}

	return Action;
}


LPSTR
MapState( STATE State )
{
#define MAP_STRING( x ) case x : return #x; break;

	switch( State )
	{
				MAP_STRING( STATE_INVALID )
				
				MAP_STRING( STATE_NONE )
				
				MAP_STRING( STATE_INIT )
				
				MAP_STRING( STATE_STATISTICS )
				
				MAP_STRING( STATE_STALL )
				
				MAP_STRING( STATE_DONE )

				MAP_STRING( STATE_APP_LOGON )

				MAP_STRING( STATE_APP_LOGON_EXCLUSIVE )

				MAP_STRING( STATE_APP_LOGON_SHARED )

				MAP_STRING( STATE_APP_LOGOFF )

				MAP_STRING( STATE_POPULATE_CREDENTIALS )

				MAP_STRING( STATE_AUTH_CHALLENGE )

				MAP_STRING( STATE_AUTH_CHALLENGE_ANY )

				MAP_STRING( STATE_AUTH_CHALLENGE_USER )

				MAP_STRING( STATE_AUTH_CHALLENGE_USER_PASS )

				MAP_STRING( STATE_PREAUTH_CHALLENGE_ANY )

				MAP_STRING( STATE_PREAUTH_CHALLENGE_USER )

				MAP_STRING( STATE_PREAUTH_CHALLENGE_USER_PASS )

				MAP_STRING( STATE_UI_PROMPT )

				MAP_STRING( STATE_UI_PROMPT_USER )

				MAP_STRING( STATE_UI_PROMPT_ANY )
				
				MAP_STRING( STATE_FLUSH_CREDENTIALS )

				MAP_STRING( STATE_FLUSH_CREDENTIALS_GLOBAL )

				MAP_STRING( STATE_FLUSH_CREDENTIALS_SESSION )

				default:
					return "???"; 
					break;
	}

}

LPVOID
WINAPI DefaultAction(
			LPVOID lpvData)
{

    dprintf( ENTRY_EXIT, "DefaultAction : %X\n", lpvData );

	return lpvData;
}

LPVOID
WINAPI fnInit(
			LPVOID lpvData)
{
	LPCONTEXT_DATA lpContext = (LPCONTEXT_DATA) lpvData;

	dprintf( ENTRY_EXIT, "Enter: fnInit %#x \n", lpvData );


	dprintf( ENTRY_EXIT, "Exit: fnInit %#x \n", lpvData );

	return lpvData;
}

LPVOID
WINAPI fnAppLogoff(
			LPVOID lpvData)
{
	LPCONTEXT_DATA lpContext = (LPCONTEXT_DATA) lpvData;

	LPCONTEXT_RECORD lpCtxRecord = NULL;
	DWORD dwError = ERROR_SUCCESS;
	SECURITY_STATUS ss;

	dprintf( ENTRY_EXIT, "Enter: fnAppLogoff %#x \n", lpvData );

	lpCtxRecord = FindFreeSlot( lpContext -> hCredentialHandles, &BUSY_CTX_REC );

	if( lpCtxRecord != NULL ) {

		ss = LogoffOfDigestPkg(&lpCtxRecord -> hCred);
		if(!SEC_SUCCESS(ss) ) {
			dprintf(ERROR,"FreeCredentialHandle failed %s\n",
								issperr2str(ss));
		}

		lpCtxRecord -> hCred = FREE_CRED;
		lpCtxRecord ->szAppCtx = NULL;
		lpCtxRecord ->szUserCtx = NULL;
		lpCtxRecord->Mode = MODE_FREE;
	}


	dprintf( ENTRY_EXIT, "Exit: fnAppLogoff %#x \n", lpvData );

	return lpvData;
}

LPVOID
WINAPI fnAppLogon(
			LPVOID lpvData)
{
	LPCONTEXT_DATA lpContext = (LPCONTEXT_DATA) lpvData;

	LPCONTEXT_RECORD lpCtxRecord = NULL;
	DWORD dwError = ERROR_SUCCESS;

	dprintf( ENTRY_EXIT, "Enter: fnAppLogon %#x \n", lpvData );

	dwError = TuringMachine(
					APP_LOGON_TRANSITION_TABLE,
					STATE_INIT,
					lpvData
				 );

	dprintf( ENTRY_EXIT, "Exit: fnAppLogon %#x \n", lpvData );

	return lpvData;
}

LPVOID
WINAPI fnAppLogonExclusive(
			LPVOID lpvData)
{
	LPCONTEXT_DATA lpContext = (LPCONTEXT_DATA) lpvData;

	LPCONTEXT_RECORD lpCtxRecord = NULL;
	SECURITY_STATUS ss;

	dprintf( ENTRY_EXIT, "Enter: fnAppLogonExclusive %#x \n", lpvData );

	lpCtxRecord = FindFreeSlot( lpContext -> hCredentialHandles, &FREE_CTX_REC );

	if( lpCtxRecord != NULL ) {
		lpCtxRecord -> szAppCtx = NULL;
		lpCtxRecord -> szUserCtx = IDENTITY_1;

		//
		// BUGBUG: Need to ensure new usernames every time
		//
		ss = LogonToDigestPkg(NULL, IDENTITY_1, &lpCtxRecord -> hCred);
		if(!SEC_SUCCESS(ss) ) {
			dprintf(ERROR,"AcquireCredentialHandle(%s,%s) failed (%s)\n",
					lpCtxRecord -> szAppCtx,
					lpCtxRecord -> szUserCtx,
					issperr2str(ss));
			//
			// Since we failed, Release the slot
			//
			lpCtxRecord->Mode = MODE_FREE;
		} else {
			lpCtxRecord->Mode = MODE_BUSY;
		}
	}

	dprintf( ENTRY_EXIT, "Exit: fnAppLogonExclusive %#x \n", lpvData );

	return lpvData;
}

LPVOID
WINAPI fnAppLogonShared(
			LPVOID lpvData)
{
	LPCONTEXT_DATA lpContext = (LPCONTEXT_DATA) lpvData;

	LPCONTEXT_RECORD lpCtxRecord = NULL;

	SECURITY_STATUS ss;

	dprintf( ENTRY_EXIT, "Enter: fnAppLogonShared %#x \n", lpvData );

	lpCtxRecord = FindFreeSlot( lpContext -> hCredentialHandles, &FREE_CTX_REC );

	if( lpCtxRecord != NULL ) {
		lpCtxRecord -> szAppCtx = NULL;
		lpCtxRecord -> szUserCtx = NULL;

		ss = LogonToDigestPkg(NULL, NULL, &lpCtxRecord -> hCred);
		if(!SEC_SUCCESS(ss) ) {
			dprintf(ERROR,"AcquireCredentialHandle(%s,%s) failed (%s)\n",
					lpCtxRecord -> szAppCtx,
					lpCtxRecord -> szUserCtx,
					issperr2str(ss));
			//
			// Since we failed, Release the slot
			//
			lpCtxRecord->Mode = MODE_FREE;
		} else {
			lpCtxRecord->Mode = MODE_BUSY;
		}
	}

	dprintf( ENTRY_EXIT, "Exit: fnAppLogonShared %#x \n", lpvData );

	return lpvData;
}

LPVOID
WINAPI fnPopulateCredentials(
			LPVOID lpvData)
{
	LPCONTEXT_DATA lpContext = (LPCONTEXT_DATA) lpvData;

	LPCONTEXT_RECORD lpCtxRecord = NULL;

	dprintf( ENTRY_EXIT, "Enter: fnPopulateCredentials %#x \n", lpvData );

	lpCtxRecord = FindFreeSlot( lpContext -> hCredentialHandles, &BUSY_CTX_REC );

	if( lpCtxRecord != NULL ) {
		// realm 1
		PrimeCredCache(lpCtxRecord -> hCred, "testrealm1@foo.com", "user1_1@msn.com", "pass1_1");
		PrimeCredCache(lpCtxRecord -> hCred, "testrealm1@foo.com", "user2_1@msn.com", "pass2_1");
		PrimeCredCache(lpCtxRecord -> hCred, "testrealm1@foo.com", "user3_1@msn.com", "pass3_1");

		// realm 2
		PrimeCredCache(lpCtxRecord -> hCred, "testrealm2@foo.com", "user1_2@msn.com", "pass1_2");

		// realm 3
		PrimeCredCache(lpCtxRecord -> hCred, "testrealm3@foo.com", "user1_3@msn.com", "pass1_3");
	}

	dprintf( ENTRY_EXIT, "Exit: fnPopulateCredentials %#x \n", lpvData );

	return lpvData;
}

LPVOID
WINAPI fnAuthChallenge(
			LPVOID lpvData)
{
	LPCONTEXT_DATA lpContext = (LPCONTEXT_DATA) lpvData;

	LPCONTEXT_RECORD lpCtxRecord = NULL;
	DWORD dwError = ERROR_SUCCESS;

	dprintf( ENTRY_EXIT, "Enter: fnAuthChallenge %#x \n", lpvData );

	dwError = TuringMachine(
					AUTH_CHALLENGE_TRANSITION_TABLE,
					STATE_INIT,
					lpvData
				 );

	dprintf( ENTRY_EXIT, "Exit: fnAuthChallenge %#x \n", lpvData );

	return lpvData;
}

LPVOID
WINAPI fnAuthChallengeAny(
			LPVOID lpvData)
{
	LPCONTEXT_DATA lpContext = (LPCONTEXT_DATA) lpvData;

	LPCONTEXT_RECORD lpCtxRecord = NULL;

	dprintf( ENTRY_EXIT, "Enter: fnAuthChallengeAny %#x \n", lpvData );

	lpCtxRecord = FindFreeSlot( lpContext -> hCredentialHandles, &BUSY_CTX_REC );
	SECURITY_STATUS ss;

	if( lpCtxRecord != NULL ) {
		//LPSTR szChallenge;
		//szChallenge = "realm=\"testrealm@foo.com\", stale = FALSE, qop=\"auth,auth-int\", nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"";
		TCHAR szChallenge[512];
		DWORD cbChallenge=512;
		GenerateServerChallenge(szChallenge,cbChallenge);

		// Package will dump response into this buffer.
		CHAR szResponse[4096];
		CtxtHandle hCtxt = {0,0};
		
		memset((LPVOID)szResponse,0,4096);
		// First try at authenticating.
		ss = DoAuthenticate( &lpCtxRecord -> hCred,                    // Cred from logging on.
						NULL,                       // Ctxt not specified first time.
						&hCtxt,                    // Output context.
						ISC_REQ_USE_SUPPLIED_CREDS, // auth from cache.
						szChallenge,                // Server challenge header.
						NULL,                       // no realm since not preauth.
						"www.foo.com",              // Host.
						"/bar/baz/boz/bif.html",    // Url.
						"GET",                      // Method.
						NULL,                       // no Username
						NULL,                       // no Password.
						NULL,                       // no nonce
						NULL,                       // don't need hdlg for auth.
						szResponse,                // Response buffer.
                        4096);
	}

	if(!SEC_SUCCESS(ss) ) {
		dprintf(ERROR,"ISC(use-supplied-cred) Failed %s \n", issperr2str(ss) );
	}

	dprintf( ENTRY_EXIT, "Exit: fnAuthChallengeAny %#x \n", lpvData );

	return lpvData;
}

LPVOID
WINAPI fnAuthChallengeUser(
			LPVOID lpvData)
{
	LPCONTEXT_DATA lpContext = (LPCONTEXT_DATA) lpvData;

	LPCONTEXT_RECORD lpCtxRecord = NULL;

	dprintf( ENTRY_EXIT, "Enter: fnAuthChallengeUser %#x \n", lpvData );

	lpCtxRecord = FindFreeSlot( lpContext -> hCredentialHandles, &BUSY_CTX_REC );
	
	SECURITY_STATUS ss;

	if( lpCtxRecord != NULL ) {
		//LPSTR szChallenge;
		//szChallenge = "realm=\"testrealm@foo.com\", stale = FALSE, qop=\"auth,auth-int\", nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"";
		TCHAR szChallenge[512];
		DWORD cbChallenge=512;
		GenerateServerChallenge(szChallenge,cbChallenge);

		// Package will dump response into this buffer.
		CHAR szResponse[4096];
                
		CtxtHandle hCtxt = {0,0};
		
		memset((LPVOID)szResponse,0,4096);
		// First try at authenticating.
		ss = DoAuthenticate( &lpCtxRecord -> hCred,  // Cred from logging on.
						NULL,                       // Ctxt not specified first time.
						&hCtxt,                    // Output context.
						ISC_REQ_USE_SUPPLIED_CREDS,  // auth from cache.
						szChallenge,                // Server challenge header.
						NULL,                       // no realm since not preauth.
						"www.foo.com",              // Host.
						"/bar/baz/boz/bif.html",    // Url.
						"GET",                      // Method.
						"user1_1@msn.com",                       // no Username
						NULL,                       // no Password.
						NULL,                       // no nonce
						NULL,                       // don't need hdlg for auth.
						szResponse,                // Response buffer.
                        4096);
	}

	if(!SEC_SUCCESS(ss) ) {
		dprintf(ERROR,"ISC(use-supplied-cred) Failed %s \n", issperr2str(ss) );
	}

	dprintf( ENTRY_EXIT, "Exit: fnAuthChallengeUser %#x \n", lpvData );

	return lpvData;
}

LPVOID
WINAPI fnAuthChallengeUserPassword(
			LPVOID lpvData)
{
	LPCONTEXT_DATA lpContext = (LPCONTEXT_DATA) lpvData;

	LPCONTEXT_RECORD lpCtxRecord = NULL;

	dprintf( ENTRY_EXIT, "Enter: fnAuthChallengeUserPassword %#x \n", lpvData );

	lpCtxRecord = FindFreeSlot( lpContext -> hCredentialHandles, &BUSY_CTX_REC );

	SECURITY_STATUS ss;

	if( lpCtxRecord != NULL ) {
		//LPSTR szChallenge;
		//szChallenge = "realm=\"testrealm@foo.com\", stale = FALSE, qop=\"auth,auth-int\", nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"";
		TCHAR szChallenge[512];
		DWORD cbChallenge=512;
		GenerateServerChallenge(szChallenge,cbChallenge);

		// Package will dump response into this buffer.
		CHAR szResponse[4096];
                
		CtxtHandle hCtxt = {0,0};
		
		memset((LPVOID)szResponse,0,4096);
		// First try at authenticating.
		ss =
		DoAuthenticate( &lpCtxRecord -> hCred,                    // Cred from logging on.
						NULL,                       // Ctxt not specified first time.
						&hCtxt,                    // Output context.
						ISC_REQ_USE_SUPPLIED_CREDS, // auth from cache.
						szChallenge,                // Server challenge header.
						NULL,                       // no realm since not preauth.
						"www.foo.com",              // Host.
						"/bar/baz/boz/bif.html",    // Url.
						"GET",                      // Method.
						"user1_1@msn.com",                       // no Username
						"pass1_1",                       // no Password.
						NULL,                       // no nonce
						NULL,                       // don't need hdlg for auth.
						szResponse,                // Response buffer.
                        4096);
	}

	if(!SEC_SUCCESS(ss) ) {
		dprintf(ERROR,"ISC(use-supplied-cred) Failed %s \n", issperr2str(ss) );
        DebugBreak();
	}

	dprintf( ENTRY_EXIT, "Exit: fnAuthChallengeUserPassword %#x \n", lpvData );

	return lpvData;
}

BOOL
SetUIUserNameAndPassword(
						 LPSTR szUsername,
						 LPSTR szPassword,
						 BOOL fPersist)
{

#define DIALOGCLASS	32770
#define IDB_OK_BUTTON 1
#define ODS(s) dprintf(FATAL,s);

	LPSTR m_szMainCaption = "Enter Network Password";
	HWND hdlg;
	DWORD dwTime;
	DWORD dwCount=0;
	dwTime = GetTickCount();
	//Use this to get the hdlg for the dialog window

	hdlg =::FindWindow(MAKEINTATOM(32770),(LPCTSTR)m_szMainCaption);
	while ((NULL==hdlg) && (GetTickCount() - dwTime <= 10000)) {
		//dprintf(FATAL,"Cannot find dialog window: %d\n",GetLastError());
		// return FALSE;
		hdlg =::FindWindow(MAKEINTATOM(32770),(LPCTSTR)m_szMainCaption);
	}

	if( hdlg == NULL ) {
		dprintf(FATAL,"Cannot find dialog window: %d\n",GetLastError());
		//DebugBreak();
		 return FALSE;
	}


	dprintf(INFO,"Found window.....\n");
	//Use this after you've got the handle to the main dialog window.
	//This will look for the edit control and enter text.


	if( fPersist ) {
		dprintf(INFO,"************ PASSWORD WILL BE PERSISTED ****************\n");
	}

	HWND	hwnd = NULL;
	int	iEditId = 0;

	UI_CONTROL uiControl;

	uiControl.szUserName = szUsername;
	uiControl.szPassword = szPassword;
	uiControl.fPersist = fPersist;
	uiControl.dwCount = 0;
	uiControl.hOK = NULL;
	uiControl.hPassword = NULL;
	uiControl.hPasswordSave = NULL;
	uiControl.hUserName = NULL;

	Sleep(3000);
#if 1
	uiControl.hOK = GetDlgItem(hdlg,IDB_OK_BUTTON);
	uiControl.hPassword = GetDlgItem(hdlg,IDC_PASSWORD_FIELD);
	uiControl.hPasswordSave = GetDlgItem(hdlg,IDC_SAVE_PASSWORD);
	uiControl.hUserName = GetDlgItem(hdlg,IDC_COMBO1);
#else
		EnumChildWindows(hdlg, EnumerateWindowCallback, (LPARAM)&uiControl);
#endif
	dprintf(INFO,"EnumWindows Returned :\n");
	dprintf(INFO,"hUsername %#x, hPassword %#x, hPasswordSave %#x, hOK %#x\n",
		uiControl.hUserName,
		uiControl.hPassword,
		uiControl.hPasswordSave,
		uiControl.hOK);

	//getch();

	

	if (uiControl.hPasswordSave != NULL) {
		hdlg = uiControl.hPasswordSave;
		printf("\n");
		dprintf(INFO,"=============== Found SAVE_PASSWORD check box field\n");

		if(!(uiControl.fPersist)) {
			dprintf(INFO,"DONT WANNA PERSIST @@@@@ !\n");
		} else {
			//Sleep(2000);//not required remove later
			if(!::PostMessage(hdlg, BM_CLICK, (WPARAM)0, (LPARAM)0)) {
				ODS("FAILED: to send message to SAVE_PASSWORD check Box");
				//DebugBreak();
			} else {
				ODS("sent message successfullly to SAVE_PASSWORD Edit Control\n");
			}
		//	Sleep(2000);
		}
		++ uiControl.dwCount;
	} 

	//getch();

	if (uiControl.hUserName != NULL) {
		hdlg = uiControl.hUserName;
		dprintf(INFO,"Sending Message To USERNAME field (%#x)\n",hdlg);

#if 0
		SendMessage(
				hdlg,
				CB_SHOWDROPDOWN,
				(WPARAM) TRUE, 
				(LPARAM) 0);
#endif
		//Sleep(2000);//not required remove later
		if(!::SendMessage(hdlg, WM_SETTEXT, (WPARAM) 0, (LPARAM)(LPCTSTR) szUsername)) {
			ODS("FAILED: to send message to Edit Box\n");
			//DebugBreak();
		} else {
			ODS("sent message successfullly to USERNAME Edit Control\n");
		}
		++ uiControl.dwCount;
	}

	//getch();

	if (uiControl.hPassword != NULL) {
		hdlg = uiControl.hPassword;
		printf("\n");
		dprintf(INFO,"Sending Message To PASSWORD field (%#X)\n",hdlg);
		//Sleep(2000);//not required remove later

		if(!::SendMessage(hdlg, WM_SETTEXT, 0, (LPARAM)(LPCTSTR) szPassword)) {
			ODS("FAILED: to send message to Edit Box");
			//DebugBreak();
		} else {
			ODS("sent message successfullly to PASSWORD Edit Control\n");
		}
		++ uiControl.dwCount;
	}

	dprintf(INFO,"Clicking on OK button (%#X) in dialog \n",uiControl.hOK );
	Sleep(2000);

	SendMessage(uiControl.hOK, BM_CLICK, 0, 0);
	//PostMessage(hdlg, 
	//			WM_COMMAND, 
	//			MAKEWPARAM(IDB_OK_BUTTON,BN_CLICKED), 
	//			MAKELPARAM(,0));


	return TRUE;
}

LPVOID
WINAPI fnUiPrompt(
			LPVOID lpvData)
{
	LPCONTEXT_DATA lpContext = (LPCONTEXT_DATA) lpvData;

	LPCONTEXT_RECORD lpCtxRecord = NULL;
	DWORD dwError = ERROR_SUCCESS;

	dprintf( ENTRY_EXIT, "Enter: fnUiPrompt %#x \n", lpvData );

	dwError = TuringMachine(
					UI_PROMPT_TRANSITION_TABLE,
					STATE_INIT,
					lpvData
				 );

	dprintf( ENTRY_EXIT, "Exit: fnUiPrompt %#x \n", lpvData );

	return lpvData;
}

LPVOID
WINAPI fnUiPromptUser(
			LPVOID lpvData)
{
		//LPSTR szChallenge;
		//szChallenge = "realm=\"testrealm@foo.com\", stale = FALSE, qop=\"auth,auth-int\", nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"";
		TCHAR szChallenge[512];
		DWORD cbChallenge=512;
		GenerateServerChallenge(szChallenge,cbChallenge);

    // Package will dump response into this buffer.
    CHAR szResponse[4096];
                
	LPCONTEXT_DATA lpContext = (LPCONTEXT_DATA) lpvData;

	LPCONTEXT_RECORD lpCtxRecord = NULL;

	dprintf( ENTRY_EXIT, "Enter: fnUiPromptUser %#x \n", lpvData );

	lpCtxRecord = FindFreeSlot( lpContext -> hCredentialHandles, &BUSY_CTX_REC );

	CtxtHandle hCtxt = {0,0};

	SECURITY_STATUS ssResult;

	memset((LPVOID)szResponse,0,4096);
    // First try at authenticating.
    ssResult = 
    DoAuthenticate( &lpCtxRecord -> hCred,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt,                    // Output context.
                    0,                          // auth from cache.
                    szChallenge,                // Server challenge header.
                    NULL,                       // no realm since not preauth.
                    "www.foo.com",              // Host.
                    "/bar/baz/boz/bif.html",    // Url.
                    "GET",                      // Method.
                    "user1_1@msn.com",                       //  Username
                    NULL,                       // no Password.
                    NULL,                       // no nonce
                    NULL,                       // don't need hdlg for auth.
					szResponse,                // Response buffer.
                    4096);
        
    // Expect to not have credentials the first time - prompt.
    if (ssResult == SEC_E_NO_CREDENTIALS)
    {
		memset((LPVOID)szResponse,0,4096);
        ssResult = 
        DoAuthenticate( &lpCtxRecord -> hCred,                    // Cred from logging on.
                        &hCtxt,                    // Ctxt from previous call
                        &hCtxt,                    // Output context (same as from previous).
                        ISC_REQ_PROMPT_FOR_CREDS,   // prompt
                        szChallenge,                // Server challenge
                        NULL,                       // No realm
                        "www.foo.com",              // Host
                        "/bar/baz/boz/bif.html",    // Url
                        "GET",                      // Method
                        NULL,                       // no username
                        NULL,                       // no password
                        NULL,                       // no nonce
                        GetDesktopWindow(),         // desktop window
						szResponse,                // Response buffer.
                        4096);

    }

    // We now have credentials and this will generate the output string.
	//
	// BUGBUG: 
	//		THis has just been fixed by AdriaanC, so we put in a hack here
	//		We will only prompt if the string has not been generated yet.	
	// 
    if (
			(ssResult == SEC_E_OK)
		&&	(!*szResponse)
    ) {
		memset((LPVOID)szResponse,0,4096);
        ssResult = 
        DoAuthenticate( &lpCtxRecord -> hCred,                    // Cred from logging on.
                        &hCtxt,                    // Ctxt not specified first time.
                        &hCtxt,                    // Output context.
                        0,                          // auth
                        szChallenge,                // Server challenge.
                        NULL,                       // no realm
                        "www.foo.com",              // Host.
                        "/bar/baz/boz/bif.html",    // Url.
                        "GET",                      // Method.
                        NULL,                       // no username
                        NULL,                       // no password
                        NULL,                       // no nonce
                        NULL,                       // no hdlg
						szResponse,                // Response buffer.
                        4096);
    }          

	return lpvData;
}



LPVOID
WINAPI fnUiPromptAny(
			LPVOID lpvData)
{
		//LPSTR szChallenge;
		//szChallenge = "realm=\"testrealm@foo.com\", stale = FALSE, qop=\"auth,auth-int\", nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"";
		TCHAR szChallenge[512];
		DWORD cbChallenge=512;
		GenerateServerChallenge(szChallenge,cbChallenge);

    // Package will dump response into this buffer.
    CHAR szResponse[4096];
                
	LPCONTEXT_DATA lpContext = (LPCONTEXT_DATA) lpvData;

	LPCONTEXT_RECORD lpCtxRecord = NULL;

	dprintf( ENTRY_EXIT, "Enter: fnUiPromptAny %#x \n", lpvData );

	lpCtxRecord = FindFreeSlot( lpContext -> hCredentialHandles, &BUSY_CTX_REC );

	CtxtHandle hCtxt = {0,0};

	SECURITY_STATUS ssResult;

	memset((LPVOID)szResponse,0,4096);
    // First try at authenticating.
    ssResult = 
    DoAuthenticate( &lpCtxRecord -> hCred,       // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt,                    // Output context.
                    0,                          // auth from cache.
                    szChallenge,                // Server challenge header.
                    NULL,                       // no realm since not preauth.
                    "www.foo.com",              // Host.
                    "/bar/baz/boz/bif.html",    // Url.
                    "GET",                      // Method.
                    NULL,                       // no Username
                    NULL,                       // no Password.
                    NULL,                       // no nonce
                    NULL,                       // don't need hdlg for auth.
					szResponse,                // Response buffer.
                    4096);
        
    // Expect to not have credentials the first time - prompt.
    if (ssResult == SEC_E_NO_CREDENTIALS)
    {
		memset((LPVOID)szResponse,0,4096);
        ssResult = 
        DoAuthenticate( &lpCtxRecord -> hCred,                    // Cred from logging on.
                        &hCtxt,                    // Ctxt from previous call
                        &hCtxt,                    // Output context (same as from previous).
                        ISC_REQ_PROMPT_FOR_CREDS,   // prompt
                        szChallenge,                // Server challenge
                        NULL,                       // No realm
                        "www.foo.com",              // Host
                        "/bar/baz/boz/bif.html",    // Url
                        "GET",                      // Method
                        NULL,                       // no username
                        NULL,                       // no password
                        NULL,                       // no nonce
                        GetDesktopWindow(),         // desktop window
						szResponse,                // Response buffer.
                        4096);

    }


    // We now have credentials and this will generate the output string.

	//
	// BUGBUG: 
	//		THis has just been fixed by AdriaanC, so we put in a hack here
	//		We will only prompt if the string has not been generated yet.	
	// 
    if (
			(ssResult == SEC_E_OK)
		&&	(!*szResponse)
    ) {
		memset((LPVOID)szResponse,0,4096);
        ssResult = 
        DoAuthenticate( &lpCtxRecord -> hCred,                    // Cred from logging on.
                        &hCtxt,                    // Ctxt not specified first time.
                        &hCtxt,                    // Output context.
                        0,                          // auth
                        szChallenge,                // Server challenge.
                        NULL,                       // no realm
                        "www.foo.com",              // Host.
                        "/bar/baz/boz/bif.html",    // Url.
                        "GET",                      // Method.
                        NULL,                       // no username
                        NULL,                       // no password
                        NULL,                       // no nonce
                        NULL,                       // no hdlg
						szResponse,                // Response buffer.
                        4096);
    }          

	return lpvData;
}

LPVOID
WINAPI fnFlushCredentials(
			LPVOID lpvData)
{
	LPCONTEXT_DATA lpContext = (LPCONTEXT_DATA) lpvData;

	LPCONTEXT_RECORD lpCtxRecord = NULL;
	DWORD dwError = ERROR_SUCCESS;

	dprintf( ENTRY_EXIT, "Enter: fnFlushCredentials %#x \n", lpvData );

	dwError = TuringMachine(
					FLUSH_CREDENTIALS_TRANSITION_TABLE,
					STATE_INIT,
					lpvData
				 );

	dprintf( ENTRY_EXIT, "Exit: fnFlushCredentials %#x \n", lpvData );

	return lpvData;
}

LPVOID
WINAPI fnFlushCredentialsGlobal(
			LPVOID lpvData)
{
	dprintf( ENTRY_EXIT, "Enter: fnFlushCredentialsGlobal %#x \n", lpvData );

	SECURITY_STATUS ssResult;

    ssResult = 
    DoAuthenticate( NULL,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    NULL,                    // Output context.
                    ISC_REQ_NULL_SESSION,                          // auth from cache.
                    NULL,//szChallenge,                // Server challenge header.
                    NULL,                       // no realm since not preauth.
                    NULL,//"www.foo.com",              // Host.
                    NULL,//"/bar/baz/boz/bif.html",    // Url.
                    NULL,//"GET",                      // Method.
                    NULL,//"user1",                       // no Username
                    NULL,                       // no Password.
                    NULL,                       // no nonce
                    NULL,                       // don't need hdlg for auth.
						NULL,                // Response buffer.
                        0);
        
	dprintf( ENTRY_EXIT, "Exit: fnFlushCredentialsGlobal %#x \n", lpvData );

	return lpvData;
}



LPVOID
WINAPI fnFlushCredentialsSession(
			LPVOID lpvData)
{
	LPCONTEXT_DATA lpContext = (LPCONTEXT_DATA) lpvData;

	LPCONTEXT_RECORD lpCtxRecord = NULL;

	dprintf( ENTRY_EXIT, "Enter: fnFlushCredentialsSession %#x \n", lpvData );

	lpCtxRecord = FindFreeSlot( lpContext -> hCredentialHandles, &BUSY_CTX_REC );



	SECURITY_STATUS ssResult;

    ssResult = 
    DoAuthenticate( &lpCtxRecord->hCred,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    NULL,//&hCtxt,                    // Output context.
                    ISC_REQ_NULL_SESSION,                          // auth from cache.
                    NULL,//szChallenge,                // Server challenge header.
                    NULL,                       // no realm since not preauth.
                    NULL,//"www.foo.com",              // Host.
                    NULL,//"/bar/baz/boz/bif.html",    // Url.
                    NULL,//"GET",                      // Method.
                    NULL,//"user1",                       // no Username
                    NULL,                       // no Password.
                    NULL,                       // no nonce
                    NULL,                       // don't need hdlg for auth.
                    NULL,
                    0);//szResponse);                // Response buffer.
        
	return lpvData;
}


BOOL
GenerateServerChallenge(
						LPSTR szChallenge,
						DWORD cbChallenge)
{
	int i;
	TCHAR *	szAlgorithm = NULL,
			* szQop = NULL,
			* szNonce = NULL,
			* szOpaque = NULL,
			* szRealm = NULL,
			* szPtr = NULL,
			* szMs_message = NULL,
			* szMs_reserved = NULL,
			* szMs_trustmark = NULL;

	//
	// BUGBUG: we want to make sure that this generates a string which will fit
	// in the given buffer.
	//

	dprintf(ENTRY_EXIT,"ENTER: GenerateServerChallenge\n" );

	i = rand() % 100;

	if( i < 50 ) {
		szAlgorithm = _T("MD5");
	} else {
		szAlgorithm = _T("MD5-Sess");
	}

	i = rand() % 100;

	if((i >= 0) && ( i < 20 )) {
		szRealm = _T("testrealm1@foo.com");
	} else
	if(( i >= 20 ) && ( i < 40)) {
		szRealm = _T("testrealm2@foo.com");
	} else
	if(( i >= 40 ) && ( i < 60)) {
		szRealm = _T("testrealm3@foo.com");
	} else {
		szRealm = _T("testrealm@foo.com");
	}
#if 0
	i = rand() % 100;

	if( i < 50 ) {
		szMs_message = _T("\"This is a test microsoft message\"");
	} else {
		szMs_message = NULL;
	}

	i = rand() % 100;

	if( i < 30 ) {
		szMs_trustmark = _T("\"http://www.bbbonline.org\"");
	} else
	if(( i >= 30 ) && (i < 80)) {
		szMs_trustmark = _T("\"http://www.truste.org\"");
	} else {
		szMs_trustmark = NULL;
	}

	i = rand() % 100;

	if( i < 30 ) {
		szMs_reserved = _T("\"MSEXT::CAPTION=%Enter Network Password%REGISTER=%http://www.microsoft.com%\"");
	} 
	 //else
	 //if(( i >= 30 ) && (i < 80)) {
		 //szMs_trustmark = _T("\"http://www.truste.org\"");
	 //} else {
		 //szMs_trustmark = NULL;
	 //}

#endif

	szQop = _T("auth");
	szOpaque = _T("101010101010");
	szNonce = _T("abcdef0123456789");

	szPtr = szChallenge;

	szPtr += sprintf(szChallenge,"realm=\"%s\", qop=\"%s\", algorithm=\"%s\", nonce=\"%s\", opaque=\"%s\"",
								szRealm,
								szQop,
								szAlgorithm,
								szNonce,
								szOpaque);

#if 0
	if( szMs_message && *szMs_message ) {
		szPtr += sprintf(szPtr,", ms-message=%s, ms-message-lang=\"EN\"",
									szMs_message);
	}
		
	if( szMs_trustmark && *szMs_trustmark ) {
		szPtr += sprintf(szPtr,", ms-trustmark=%s",
									szMs_trustmark);
	}

	if( szMs_reserved && *szMs_reserved ) {
		szPtr += sprintf(szPtr,", ms-reserved=%s",
									szMs_reserved);
	}

	i = rand() % 100;

	if( i < 50 ) {
		szPtr += sprintf( szPtr,", MS-Logoff=\"TRUE\"");
	}

#endif
	dprintf(ENTRY_EXIT,"EXIT: GenerateServerChallenge returns \n%s\n", szChallenge );
		
	return TRUE;
}

#define IDENTITY_1 "app1"
#define IDENTITY_2	"app2"

BOOL Test()
{
 	CSessionAttributeList * g_pSessionAttributeList = NULL;
	CSessionList * g_pSessionList = NULL;
	CSession * pSession = NULL;
	CSessionAttribute * pSessionAttribute = NULL;

    CredHandle  hCred1, hCred2, hCred3; 

	SECURITY_STATUS ssResult;

	g_pSessionAttributeList = new CSessionAttributeList();
	g_pSessionList = new CSessionList();

	pSessionAttribute = g_pSessionAttributeList -> getNewSession( FALSE );

	if( !pSessionAttribute ) {
		goto cleanup;
	}


	LogonToDigestPkg( 
					pSessionAttribute ->getAppCtx() , 
					pSessionAttribute->getUserCtx(), 
					&hCred1);

	pSession = new CSession( hCred1 );
	pSession -> setAttribute( pSessionAttribute );


	g_pSessionList->put( pSession );

	pSession = NULL;
	pSessionAttribute = NULL;

	//
	// now get shared SessionAttribute
	//
	pSessionAttribute = g_pSessionAttributeList -> getNewSession( TRUE );

	LogonToDigestPkg( 
					pSessionAttribute ->getAppCtx() , 
					pSessionAttribute->getUserCtx(), 
					&hCred2);

	pSession = new CSession( hCred2 );
	pSession -> setAttribute( pSessionAttribute );
	g_pSessionList -> put( pSession);

	LogonToDigestPkg( 
					pSessionAttribute ->getAppCtx() , 
					pSessionAttribute->getUserCtx(), 
					&hCred3);

	pSession = new CSession( hCred3 );
	pSession -> setAttribute( pSessionAttribute );
	g_pSessionList -> put( pSession);

	//
	// lets add a credential to this session
	//
	pSession -> addCredential( "testrealm@foo.com", "user1", "pass1" );
	pSession -> addCredential( "testrealm@foo.com", "user1", "pass11" );
	// add one more
	pSession -> addCredential( "testrealm@foo.com", "user2", "pass2" );

	// add one more
	pSession -> addCredential( "testrealm@foo.com", "user3", "pass3" );

	// replace
	pSession -> addCredential( "testrealm@foo.com", "user3", "pass31" );
	// replace
	pSession -> addCredential( "testrealm@foo.com", "user2", "pass21" );
	pSession -> addCredential( "testrealm@foo.com", "user2", "pass22" );

cleanup:
	return FALSE;
}

BOOL CALLBACK EnumerateWindowCallback1(HWND hdlg, LPARAM lParam)
{
	int iEditId = 0;
	BOOL fRet = TRUE;

	LPUI_CONTROL lpuiControl = (LPUI_CONTROL) lParam;

	LPTSTR szUsername = lpuiControl->szUserName;
	LPTSTR szPassword = lpuiControl->szPassword;

	dprintf(ENTRY_EXIT,"ENTER: EnumChildProc(hdlg=%#x,lParam=%#x)\n",hdlg,lParam);

	dprintf(ENTRY_EXIT,"UI_CONTROL( %s %s %d %s %#x ) \n",
						szUsername,
						szPassword,
						lpuiControl->dwCount,
						(lpuiControl->fPersist?"TRUE":"FALSE"),
						lpuiControl->hOK);


	iEditId =::GetDlgCtrlID(hdlg);
	dprintf(INFO,"The iEditId is %d!\n", iEditId);

	if (iEditId == IDC_SAVE_PASSWORD) {
		printf("\n");
		dprintf(INFO,"=============== Found SAVE_PASSWORD check box field\n");

		if(lpuiControl->dwCount == 3) {
			dprintf(INFO,"Already sent message to this control\n");
			goto done;;
		}

		if(!(lpuiControl -> fPersist)) {
			dprintf(INFO,"DONT WANNA PERSIST @@@@@ !\n");
		} else {
			//Sleep(2000);//not required remove later
			if(!::PostMessage(hdlg, BM_CLICK, (WPARAM)0, (LPARAM)0)) {
				ODS("FAILED: to send message to SAVE_PASSWORD check Box");
				DebugBreak();
			} else {
				ODS("sent message successfullly to SAVE_PASSWORD Edit Control\n");
			}
		//	Sleep(2000);
		}
		++ lpuiControl->dwCount;
	} else
	if (iEditId == IDC_COMBO1)	{
		printf("\n");
		dprintf(INFO,"Found USERNAME field\n");

		if(lpuiControl->dwCount == 3) {
			dprintf(INFO,"Already sent message to this control\n");
			goto done;;
		}
#if 0
		SendMessage(
				hdlg,
				CB_SHOWDROPDOWN,
				(WPARAM) TRUE, 
				(LPARAM) 0);
#endif
		//Sleep(2000);//not required remove later
		if(!::SendMessage(hdlg, WM_SETTEXT, (WPARAM) 0, (LPARAM)(LPCTSTR) szUsername)) {
			ODS("FAILED: to send message to Edit Box\n");
			DebugBreak();
		} else {
			ODS("sent message successfullly to USERNAME Edit Control\n");
		}
		++ lpuiControl->dwCount;
	} else
	if (iEditId == IDC_PASSWORD_FIELD) {
		printf("\n");
		dprintf(INFO,"Found PASSWORD field\n");
		//Sleep(2000);//not required remove later

		if(lpuiControl->dwCount == 3) {
			dprintf(INFO,"Already sent message to this control\n");
			goto done;;
		}

		if(!::SendMessage(hdlg, WM_SETTEXT, 0, (LPARAM)(LPCTSTR) szPassword)) {
			ODS("FAILED: to send message to Edit Box");
			DebugBreak();
		} else {
			ODS("sent message successfullly to PASSWORD Edit Control\n");
		}
		++ lpuiControl->dwCount;
	} else 
	if( iEditId == IDB_OK_BUTTON ) {
		lpuiControl->hOK = hdlg;
	}


	if( lpuiControl -> dwCount == 3 ) {

		if( lpuiControl->hOK ) {
			dprintf(INFO,"ALL WINDOWS FOUND, OK BUTTON FOUND, ABORT\n");
			fRet = FALSE;
			goto done;;
		} 
	}

done:

	dprintf(ENTRY_EXIT,"EXIT: EnumChileProc() returning %s\n",fRet?"TRUE":"FALSE");

	return fRet;
}

BOOL CALLBACK EnumerateWindowCallback(HWND hdlg, LPARAM lParam)
{
	int iEditId = 0;
	BOOL fRet = TRUE;

	LPUI_CONTROL lpuiControl = (LPUI_CONTROL) lParam;
	

	dprintf(ENTRY_EXIT,"ENTER: EnumChildProc(hdlg=%#x,lParam=%#x)\n",hdlg,lParam);

	dprintf(ENTRY_EXIT,"UI_CONTROL( %s %s %d %s %#x ) \n",
						lpuiControl->szUserName,
						lpuiControl->szPassword,
						lpuiControl->dwCount,
						(lpuiControl->fPersist?"TRUE":"FALSE"),
						lpuiControl->hOK);


	if ( (iEditId =::GetDlgCtrlID(hdlg)) == 0)
	{
		dprintf(INFO,"GetDlgCtrlID(hdlg) failed. GetLastError returned %d!\n", GetLastError());
		return FALSE;
	}

	dprintf(INFO,"The iEditId is %d!\n", iEditId);

	if (iEditId == IDC_SAVE_PASSWORD) {
		printf("\n");
		dprintf(INFO,"=============== Found SAVE_PASSWORD check box field\n");

		if(lpuiControl->hPasswordSave != NULL) {
			dprintf(INFO,"Already found window to this control\n");
			goto done;;
		}


		lpuiControl->hPasswordSave = hdlg;
		++ lpuiControl->dwCount;
	} else
	if (iEditId == IDC_COMBO1)	{
		printf("\n");
		dprintf(INFO,"Found USERNAME field\n");

		if(lpuiControl->hUserName != NULL) {
			dprintf(INFO,"Already found window to this control\n");
			goto done;;
		}

		lpuiControl->hUserName = hdlg;
		++ lpuiControl->dwCount;
	} else
	if (iEditId == IDC_PASSWORD_FIELD) {
		printf("\n");
		dprintf(INFO,"Found PASSWORD field\n");
		//Sleep(2000);//not required remove later

		if(lpuiControl->hPassword != NULL) {
			dprintf(INFO,"Already found window to this control\n");
			goto done;;
		}

		lpuiControl->hPassword = hdlg;

		++ lpuiControl->dwCount;
	} else 
	if( iEditId == IDB_OK_BUTTON ) {
		lpuiControl->hOK = hdlg;
		++ lpuiControl->dwCount;
	}


	if( lpuiControl -> dwCount == 4 ) {

		//if( lpuiControl->hOK ) {
			dprintf(INFO,"ALL WINDOWS FOUND, OK BUTTON FOUND, ABORT\n");
			fRet = FALSE;
			goto done;
		//} 
	}

done:

	dprintf(ENTRY_EXIT,"EXIT: EnumChileProc() returning %s\n",fRet?"TRUE":"FALSE");

	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\commonmk.inc ===
.SUFFIXES: .hdl .pdl

.pdl{$O}.hdl:
    $(C_PREPROCESSOR) $< | pdlparse - $(MAKEDIR)\$O\$(@B) $< $(MAKEDIR)\$O

!if 0
#
# .pdl -> .hdl
#
.pdl.hdl:
        $(CC) $(NOLOGO) @<< | $(PDLPARSE) <<
/I$(INCLUDEPATH:;=
/I)
$(CFLAGS: =
)
$(PCHCXXFLAGS: =
)
/c
/E
$<
<<$(KEEPFLAGS)
- $(TYPEDIR)\$(@B) $(@B).pdl $(TYPEDIR)
<<$(KEEPFLAGS)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\digest\test\test.cxx ===
#include <windows.h>

#define SECURITY_WIN32

#include <sspi.h>
#include <issperr.h>
#include <security.h>

#define SSP_SPM_NT_DLL      "security.dll"
#define SSP_SPM_WIN95_DLL   "secur32.dll"


struct DIGEST_PKG_DATA
{
    LPSTR szAppCtx;
    LPSTR szUserCtx;
};

#define SIG_DIGEST 'HTUA'

DIGEST_PKG_DATA PkgData;
SEC_WINNT_AUTH_IDENTITY_EXA SecIdExA;




PSecurityFunctionTable	g_pFuncTbl = NULL;

HINSTANCE hSecLib;

//----------------------------------------------------------------------------
// InitializeSecurityInterface
//----------------------------------------------------------------------------
VOID InitializeSecurityInterface(BOOL fDirect)
{
    INIT_SECURITY_INTERFACE	addrProcISI = NULL;
    OSVERSIONINFO   VerInfo;
    CHAR szDLL[MAX_PATH];

    if (!fDirect)
    {
        VerInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

        GetVersionEx (&VerInfo);
        if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
            lstrcpy (szDLL, SSP_SPM_NT_DLL);
        }
        else if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
        {
            lstrcpy (szDLL, SSP_SPM_WIN95_DLL);
        }
    }
    else
    {
        strcpy(szDLL, "digest.dll");
    }
    
    hSecLib = LoadLibrary (szDLL);
    
    addrProcISI = (INIT_SECURITY_INTERFACE) GetProcAddress( hSecLib, 
                    SECURITY_ENTRYPOINT_ANSI);       
        
    g_pFuncTbl = (*addrProcISI)();
}


//----------------------------------------------------------------------------
// HaveDigest
//----------------------------------------------------------------------------
BOOL HaveDigest()
{    
    SECURITY_STATUS ssResult;
    DWORD cPackages;
    PSecPkgInfoA pSecPkgInfo;
    BOOL fHaveDigest;

    // ***** SSPI call *****
    ssResult = (*(g_pFuncTbl->EnumerateSecurityPackagesA))(&cPackages, &pSecPkgInfo);

    // Check if we have digest.
    fHaveDigest = FALSE;
    if (ssResult == SEC_E_OK)
    {
        for (DWORD i = 0; i < cPackages; i++)
        {
            if (strcmp(pSecPkgInfo[i].Name, "Digest") == 0)
            {
                fHaveDigest = TRUE;
                break;
            }
        }
    }
    return fHaveDigest;
}

//----------------------------------------------------------------------------
// LogonToDigestPkg
//----------------------------------------------------------------------------
SECURITY_STATUS LogonToDigestPkg(LPSTR szAppCtx, LPSTR szUserCtx, PCredHandle phCred)
{
    SECURITY_STATUS ssResult;
   
    // Logon with szAppCtx = szUserCtx = NULL.
    PkgData.szAppCtx = PkgData.szUserCtx = NULL;
    memset(&SecIdExA, 0, sizeof(SEC_WINNT_AUTH_IDENTITY_EXA));

    PkgData.szAppCtx = szAppCtx;
    PkgData.szUserCtx = szUserCtx;

    SecIdExA.Version = sizeof(SEC_WINNT_AUTH_IDENTITY_EXA);
    SecIdExA.User = (unsigned char*) &PkgData;
    SecIdExA.UserLength = sizeof(DIGEST_PKG_DATA);


    // ***** SSPI CALL *****
    ssResult = (*(g_pFuncTbl->AcquireCredentialsHandleA))
        (NULL,                // pszPrinciple         NULL
        "Digest",             // pszPackageName       (Package name)
        SECPKG_CRED_OUTBOUND,  // dwCredentialUse      (Credentials aren't pulled from OS)
        NULL,                 // pvLogonID            (not used)
        &SecIdExA,            // pAuthData            ptr to g_PkgData
        NULL,                 // pGetKeyFn            (not used)
        0,                    // pvGetKeyArgument     (not used)
        phCred,               // phCredential         (credential returned)
        NULL);                // PTimeStamp           (not used)
    
    return ssResult;
}


//----------------------------------------------------------------------------
// LogoffOfDigestPkg
//----------------------------------------------------------------------------
SECURITY_STATUS LogoffOfDigestPkg(PCredHandle phCred)
{
    SECURITY_STATUS ssResult;
   
    // ***** SSPI CALL *****
    ssResult = (*(g_pFuncTbl->FreeCredentialsHandle))(phCred);
    
    return ssResult;
}


//----------------------------------------------------------------------------
// Authenticate
//----------------------------------------------------------------------------
SECURITY_STATUS
DoAuthenticate(PCredHandle phCred, 
               PCtxtHandle phCtxt, 
               PCtxtHandle phNewCtxt, 
               DWORD fContextReq,
               LPSTR szHeader,
               LPSTR szRealm,
               LPSTR szHost, 
               LPSTR szUrl, 
               LPSTR szMethod,    
               LPSTR szUser, 
               LPSTR szPass, 
               LPSTR szNonce,
               HWND  hWnd,
               LPSTR szResponse)
{
    SECURITY_STATUS ssResult;    
    
    // Input buffers and descriptor.
    SecBuffer sbIn[10];    
    SecBufferDesc sbdIn;
    sbdIn.pBuffers = sbIn;
    sbdIn.cBuffers = 10;
    
    sbIn[0].pvBuffer    = szHeader;           // Challenge header
    sbIn[1].pvBuffer    = szRealm;            // realm if preauth
    sbIn[2].pvBuffer    = szHost;             // host
    sbIn[3].pvBuffer    = szUrl;              // url
    sbIn[4].pvBuffer    = szMethod;           // http method
    sbIn[5].pvBuffer    = szUser;             // username (optional)
    sbIn[6].pvBuffer    = szPass;             // password (optional, not used currently)    
    sbIn[7].pvBuffer    = szNonce;            // nonce
    sbIn[8].pvBuffer    = NULL;               // nonce count not passed in.
    sbIn[9].pvBuffer    = &hWnd;              // window handle.


    // Output buffer and descriptor.
    SecBuffer sbOut[1];
    SecBufferDesc sbdOut;
    sbdOut.pBuffers = sbOut;
    sbdOut.cBuffers = 1;
        
    // Set output buffer.
    sbOut[0].pvBuffer = szResponse;

    // ***** SSPI CALL *****
    ssResult = (*(g_pFuncTbl->InitializeSecurityContextA))
        (phCred,            // phCredential    (from AcquireCredentialsHandle)
         phCtxt,            // phContext       (NULL on first call, phNewCtxt on subsequent calls).
         NULL,              // pszTargetName   (not used)
         fContextReq,       // fContextReq     (auth from cache, prompt or auth using supplied creds)
         0,                 // Reserved1       (not used)
         0,                 // TargetDataRep   (not used)
         &sbdIn,            // PSecBufDesc     (input buffer descriptor)
         0,                 // Reserved2       (not used)
         phNewCtxt,         // phNewContext    (should be passed back as phCtxt on subsequent calls)
         &sbdOut,           // pOutput         (output buffer descriptor)
         NULL,              // pfContextAttr   (pfContextAttr, not used)
         NULL);             // ptsExpiry       (not used)

    return ssResult;
}

VOID PrimeCredCache(CredHandle CredHandle, LPSTR szRealm, LPSTR szUser, LPSTR szPass)
{
    DWORD ssResult;
    CtxtHandle hCtxt;

    SecBufferDesc sbdIn;
    SecBuffer     sbIn[3];
    
    hCtxt.dwLower = CredHandle.dwLower;
    hCtxt.dwUpper = CredHandle.dwUpper;

    sbIn[0].pvBuffer = szRealm;
    sbIn[0].cbBuffer = strlen(szRealm);
    sbIn[1].pvBuffer = szUser;
    sbIn[1].cbBuffer = strlen(szUser);
    sbIn[2].pvBuffer = szPass;
    sbIn[2].cbBuffer = strlen(szPass);

    sbdIn.cBuffers = 3;
    sbdIn.pBuffers = sbIn;

    ssResult = (*(g_pFuncTbl->ApplyControlToken))(&hCtxt, &sbdIn);

}

//----------------------------------------------------------------------------
// main
//----------------------------------------------------------------------------
#ifdef UNIX
#define main prog_main

int main(int argc, char **argv);

int WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR pszCmdLine, int nCmdShow) {
    extern int __argc;
    extern char **__argv;
    return main(__argc, __argv);
}
int main(int argc, char **argv)
#else
INT main()
#endif
{        

#define IDENTITY_1 "Alice"
#define IDENTITY_2 "Bob"

    DWORD dwReturn = 0;
    SECURITY_STATUS ssResult;

    // Get (global) dispatch table.
    InitializeSecurityInterface(TRUE);
 
    // Check to see if we have digest.
    if (!HaveDigest())
    {
        dwReturn = 1;
        goto exit;
    }
    
    // Credential handle and pointer.
    CredHandle  hCred1, hCred2, hCred3; 
    CtxtHandle  hCtxt1, hCtxt2, hCtxt3;

    // Three apps logon using the same keys (appctx, userctx, both NULL);
    // These sessions will be used for authentication.
    LogonToDigestPkg(NULL, IDENTITY_1, &hCred1);
    LogonToDigestPkg(NULL, IDENTITY_1, &hCred2);
    LogonToDigestPkg(NULL, IDENTITY_1, &hCred3);

    // Three more apps also logon using the same keys.
    // we will prime the password cache with credentials for these apps
    // and expect to be able to share the credentials via the auth dialog.
    CredHandle hCred4, hCred5, hCred6;

    LogonToDigestPkg(NULL, IDENTITY_1, &hCred4);
    LogonToDigestPkg(NULL, IDENTITY_1, &hCred5);
    LogonToDigestPkg(NULL, IDENTITY_1, &hCred6);
    
    PrimeCredCache(hCred4, "testrealm@foo.com", "Wilma", "password");
    PrimeCredCache(hCred5, "testrealm@foo.com", "Betty", "passwordxxxx");
    PrimeCredCache(hCred6, "testrealm@foo.com", "Pebbles", "passwordxxxxx");

    // Finally, three more apps also logon using a different logon key (identity)
    // we will prime the password cache with credentials for these apps
    // Because of the different logon key we should never see these creds.
    CredHandle hCred7, hCred8, hCred9;
    
    LogonToDigestPkg(NULL, IDENTITY_2, &hCred7);
    LogonToDigestPkg(NULL, IDENTITY_2, &hCred8);
    LogonToDigestPkg(NULL, IDENTITY_2, &hCred9);
    
    PrimeCredCache(hCred7, "testrealm@foo.com", "Fred", "password");
    PrimeCredCache(hCred8, "testrealm@foo.com", "Barney",  "passwordxxxx");
    PrimeCredCache(hCred9, "testrealm@foo.com", "Bam Bam", "passwordxxxxxxxx");
    
    
    
    //------------------------------------------------------------------------------------------------------------- 
    // App 1 makes a request from a server, does not have credentials and must prompt
    // before finally succeeding.
    
    // Challenge from server.
    LPSTR szChallenge;
//    szChallenge = "realm=\"testrealm@foo.com\", ms-message = \"foo\", ms-message-lang = \"bar\", ms-trustmark = \"baz\", stale = FALSE, qop=\"auth,auth-int\", nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"";
    szChallenge = "realm=\"testrealm@foo.com\",  stale = FALSE, qop=\"auth,auth-int\", nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"";

    // Package will dump response into this buffer.
    CHAR szResponse[4096];
                
    // First try at authenticating.
    ssResult = 
    DoAuthenticate( &hCred1,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt1,                    // Output context.
                    0,                          // auth from cache.
                    szChallenge,                // Server challenge header.
                    NULL,                       // no realm since not preauth.
                    "www.foo.com",              // Host.
                    "/bar/baz/boz/bif.html",    // Url.
                    "GET",                      // Method.
                    NULL,                       // no Username
                    NULL,                       // no Password.
                    NULL,                       // no nonce
                    NULL,                       // don't need hwnd for auth.
                    szResponse);                // Response buffer.
        
    // Expect to not have credentials the first time - prompt.
    if (ssResult == SEC_E_NO_CREDENTIALS)
    {
        ssResult = 
        DoAuthenticate( &hCred1,                    // Cred from logging on.
                        &hCtxt1,                    // Ctxt from previous call
                        &hCtxt1,                    // Output context (same as from previous).
                        ISC_REQ_PROMPT_FOR_CREDS,   // prompt
                        szChallenge,                // Server challenge
                        NULL,                       // No realm
                        "www.foo.com",              // Host
                        "/bar/baz/boz/bif.html",    // Url
                        "GET",                      // Method
                        NULL,                       // no username
                        NULL,                       // no password
                        NULL,                       // no nonce
                        GetDesktopWindow(),         // desktop window
                        szResponse);                // Response buffer

    }


    //------------------------------------------------------------------------------------------------------------- 
    // App 2 makes a request to the same server and gets challenged for the same realm. First auth attempt will
    // not be successful since this is the first challenge this session, so it will have to prompt for credentials.
    // When prompting, because it shares credentials with App1, the drop-down will contain App1's credentials.
    ssResult = 
    DoAuthenticate( &hCred2,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt2,                    // Output context.
                    0,                          // auth from cache.
                    szChallenge,                // Server challenge header.
                    NULL,                       // no realm since not preauth.
                    "www.foo.com",              // Host.
                    "/bar/baz/boz/bif.html",    // Url.
                    "GET",                      // Method.
                    NULL,                       // no Username
                    NULL,                       // no Password.
                    NULL,                       // no nonce
                    NULL,                       // don't need hwnd for auth.
                    szResponse);                // Response buffer.
    
    // Generate the confirmation dialog and auth. User can choose App1's creds or enter new credentials.
    if (ssResult == SEC_E_NO_CREDENTIALS)
    {
        ssResult = 
        DoAuthenticate( &hCred2,                    // Cred from logging on.
                        &hCtxt2,                    // Ctxt from previous call
                        &hCtxt2,                    // Output context (same as from previous).
                        ISC_REQ_PROMPT_FOR_CREDS,   // prompt
                        szChallenge,                // Server challenge
                        NULL ,                      // No realm
                        "www.foo.com",              // Host
                        "/bar/baz/boz/bif.html",    // Url
                        "GET",                      // Method
                        NULL,                       // no username
                        NULL,                       // no password
                        NULL,                       // no nonce
                        GetDesktopWindow(),         // desktop window
                        szResponse);                // Response buffer

    }
    

    //------------------------------------------------------------------------------------------------------------- 
    // App 3 makes a request to the same server and gets challenged for the same realm. First auth attempt will
    // not be successful since this is the first challenge this session, so it will have to prompt for credentials.
    // When prompting, because it shares credentials with App1 and App2 the drop-down could show two choices if
    // App2 entered new credentials (or just one if App2 chose to use App1's credential).
    ssResult = 
    DoAuthenticate( &hCred3,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt3,                    // Output context.
                    0,                          // auth from cache.
                    szChallenge,                // Server challenge header.
                    NULL,                       // no realm since not preauth.
                    "www.foo.com",              // Host.
                    "/bar/baz/boz/bif.html",    // Url.
                    "GET",                      // Method.
                    NULL,                       // no Username
                    NULL,                       // no Password.
                    NULL,                       // no nonce
                    NULL,                       // don't need hwnd for auth.
                    szResponse);                // Response buffer.
    
    // Generate the confirmation dialog and auth. User can choose App1's creds or enter new credentials.
    if (ssResult == SEC_E_NO_CREDENTIALS)
    {
        ssResult = 
        DoAuthenticate( &hCred3,                    // Cred from logging on.
                        &hCtxt3,                    // Ctxt from previous call
                        &hCtxt3,                    // Output context (same as from previous).
                        ISC_REQ_PROMPT_FOR_CREDS,   // prompt
                        szChallenge,                // Server challenge
                        NULL ,                      // No realm
                        "www.foo.com",              // Host
                        "/bar/baz/boz/bif.html",    // Url
                        "GET",                      // Method
                        NULL,                       // no username
                        NULL,                       // no password
                        NULL,                       // no nonce
                        GetDesktopWindow(),         // desktop window
                        szResponse);                // Response buffer

    }
    

    
    
    //------------------------------------------------------------------------------------------------------------- 
    // App2 preauthenticates to "testrealm@foo.com" for a new url. Note that the credential that will be used
    // for preauthentication is whatever App2 chose or entered previously. The same would be true for 
    // App1 or App3.
    ssResult = 
    DoAuthenticate( &hCred2,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt2,                    // Output context.
                    0,                          // auth (preauth)
                    NULL,                       // No challenge header
                    "testrealm@foo.com",        // Realm for preauth.
                    "www.foo.com",              // Host.
                    "/bar/baz.gif",             // Url
                    "GET",                      // Method.
                    NULL,                       // no sername
                    NULL,                       // no password.
                    NULL,                       // no nonce
                    NULL,                       // no hwnd
                    szResponse);                // Response buffer.
    
    //------------------------------------------------------------------------------------------------------------- 
    // App3 made another request to the same server but did not preauthenticate. It got challenged for the
    // same realm and can authenticate without prompting because it has credentials for that realm.
    szChallenge = "realm=\"testrealm@foo.com\", stale = TRUE, qop=\"auth,auth-int\", nonce=\"abcdefge8b11d0f600bfb0c093\", opaque=\"efghijklmnopc403ebaf9f0171e9517f40e41\"";

    ssResult = 
    DoAuthenticate( &hCred3,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt3,                    // Output context.
                    0,                          // auth
                    szChallenge,                // Challenge from server.
                    NULL,                       // no realm
                    "www.foo.com",              // Host.
                    "/bar/baz.htm",             // Url
                    "GET",                      // Method.
                    NULL,                       // no username
                    NULL,                       // no password
                    NULL,                       // no nonce
                    NULL,                       // no hwnd
                    szResponse);                // Response buffer.
    
    
    //------------------------------------------------------------------------------------------------------------- 
    // App1 authenticates for an md5-sess challenge.

    szChallenge = "realm=\"testrealm@foo.com\", algorithm=\"md5-sess\", stale = TRUE, qop=\"auth,auth-int\", nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"";

    ssResult = 
    DoAuthenticate( &hCred1,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt1,                    // Output context.
                    0,                          // auth from cache.
                    szChallenge,                // Server challenge header.
                    NULL,                       // no realm since not preauth.
                    "www.foo.com",              // Host.
                    "/bar/baz/boz/bif.html",    // Url.
                    "GET",                      // Method.
                    NULL,                       // no Username
                    NULL,                       // no Password.
                    NULL,                       // no nonce
                    NULL,                       // don't need hwnd for auth.
                    szResponse);                // Response buffer.



    //------------------------------------------------------------------------------------------------------------- 
    // App1 preauthenticates for 10 documents using md5-sess


    DWORD i;
    CHAR szBuf[1024];
    for (i = 0; i < 10; i++)
    {
        wsprintf(szBuf, "/bar/baz/boz/%x.html", i);
        ssResult = 
        DoAuthenticate( &hCred1,                    // Cred from logging on.
                        NULL,                       // Ctxt not specified first time.
                        &hCtxt1,                    // Output context.
                        0,                          // auth from cache.
                        NULL,                       // Server challenge header.
                        "testrealm@foo.com",        // realm.
                        "www.foo.com",              // Host.
                        szBuf,                      // Url.
                        "GET",                      // Method.
                        NULL,                       // no Username
                        NULL,                       // no Password.
                        NULL,                       // no nonce
                        NULL,                       // don't need hwnd for auth.
                        szResponse);                // Response buffer.

    }

    //------------------------------------------------------------------------------------------------------------- 
    // App1 received a new md5-sess challenge.

    szChallenge = "realm=\"testrealm@foo.com\", algorithm=\"md5-sess\", stale = TRUE, qop=\"auth,auth-int\", nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"";

    ssResult = 
    DoAuthenticate( &hCred1,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt1,                    // Output context.
                    0,                          // auth from cache.
                    szChallenge,                // Server challenge header.
                    NULL,                       // no realm since not preauth.
                    "www.foo.com",              // Host.
                    "/bar/baz/boz/bif.html",    // Url.
                    "GET",                      // Method.
                    NULL,                       // no Username
                    NULL,                       // no Password.
                    NULL,                       // no nonce
                    NULL,                       // don't need hwnd for auth.
                    szResponse);                // Response buffer.


    //------------------------------------------------------------------------------------------------------------- 
    // App1 preauths using new md5-sess

    for (i = 0; i < 10; i++)
    {
        wsprintf(szBuf, "/bar/baz/boz/%x.html", i);
        ssResult = 
        DoAuthenticate( &hCred1,                    // Cred from logging on.
                        NULL,                       // Ctxt not specified first time.
                        &hCtxt1,                    // Output context.
                        0,                          // auth from cache.
                        NULL,                       // Server challenge header.
                        "testrealm@foo.com",        // realm.
                        "www.foo.com",              // Host.
                        szBuf,                      // Url.
                        "GET",                      // Method.
                        NULL,                       // no Username
                        NULL,                       // no Password.
                        NULL,                       // no nonce
                        NULL,                       // don't need hwnd for auth.
                        szResponse);                // Response buffer.

    }

    
szChallenge = "realm=\"Microsoft.Passport\", algorithm=MD5-sess, qop=\"auth\", nonce=ykjOzYDMxMzY4kjOEFkUSVkTB5kM6QUQSJVROFkTyojM6QzY0QGNhJmNjVDNhFGZiZjM3I2MiFWO3MDZyQTNyY2M";

    ssResult = 
    DoAuthenticate( &hCred1,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt1,                    // Output context.
                    0,                          // auth from cache.
                    szChallenge,                // Server challenge header.
                    NULL,                       // no realm since not preauth.
                    "darrenan2",              // Host.
                    "/passport/protected/test.asp",    // Url.
                    "GET",                      // Method.
                    "darrenan2",                // Given Username
                    NULL,                       // no Password.
                    NULL,                       // no nonce
                    NULL,                       // don't need hwnd for auth.
                    szResponse);                // Response buffer.

    ssResult = 
    DoAuthenticate( &hCred1,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt1,                    // Output context.
                    ISC_REQ_PROMPT_FOR_CREDS,                          // auth from cache.
                    szChallenge,                // Server challenge header.
                    NULL,                       // no realm since not preauth.
                    "darrenan2",              // Host.
                    "/passport/protected/test.asp",    // Url.
                    "GET",                      // Method.
                    "darrenan2",                // Given username.
                    NULL,                       // no Password.
                    NULL,                       // no nonce
                    NULL,                       // don't need hwnd for auth.
                    szResponse);                // Response buffer.



    
    
    // Logoff all three sessions
    ssResult = LogoffOfDigestPkg(&hCred1);
    ssResult = LogoffOfDigestPkg(&hCred2);
    ssResult = LogoffOfDigestPkg(&hCred3);
    ssResult = LogoffOfDigestPkg(&hCred4);
    ssResult = LogoffOfDigestPkg(&hCred5);
    ssResult = LogoffOfDigestPkg(&hCred6);
    ssResult = LogoffOfDigestPkg(&hCred7);
    ssResult = LogoffOfDigestPkg(&hCred8);
    ssResult = LogoffOfDigestPkg(&hCred9);
    
    if (hSecLib)
        FreeLibrary(hSecLib);

exit:
    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\common.inc ===
#
SOURCES_USED=$(ROOT)\common.inc

TREE_SYNC=1
NDHACKS=1
ACCURATEZOOM=1
#IE6_WYSIWYG_OM=1
#DLOAD1=1

NO_DEBUG_HOOK=1
ADORNERS=1
FOCUS_ADORNER=1
#FOCUS_BEHAVIOR=1
#EDIT_BEHAVIOR=1
#VIEW_SERVICES=1
#MULTI_FORMAT=1
MULTI_LAYOUT=1
#HTML_LAYOUT=1
#VSTUDIO7EDIT=1
#ND_ASSERT=1
#CICERO=1
FORMSMODE=0
#SLOWALLOC=1
#MARKCODE=1

CONDITIONAL_INCLUDES= \
    winwlm.h \
    rpcerr.h \
    rpcmac.h \
    macname1.h \
    macpub.h \
    macapi.h \
    macname2.h \
    macocidl.h \
    maccontrols.h \
    mainwin.h \
    w16toff.hxx \
    print.h \
    regmsg16.h \
    urlmki.h \
    help.h \
    pgstup16.hxx \
    page.h \
    icapexp.h \
    ccolorsync.h \
    folders.h \
    pixmap.h \
    pngfilt.ic \

COREINCLUDES=\
    $(ROOT)\src\f3\include; \
    $(ROOT)\src\core\include; \
    $(ROOT)\src\core\cdutil; \
    $(ROOT)\src\site\display; \
    $(ROOT)\src\intl\include; \
    $(ROOT)\external\inc; \
    $(ROOT)\types\$(O); \
    $(SHELL_INC_PATH);

SITEINCLUDES=\
    $(ROOT)\src\f3\include; \
    $(ROOT)\src\site\include; \
    $(ROOT)\src\site\base; \
    $(ROOT)\src\site\builtin; \
    $(ROOT)\src\site\dbind; \
    $(ROOT)\src\site\display; \
    $(ROOT)\src\site\download; \
    $(ROOT)\src\site\layout; \
    $(ROOT)\src\site\miscelem; \
    $(ROOT)\src\site\miscsite; \
    $(ROOT)\src\site\ole; \
    $(ROOT)\src\site\print; \
    $(ROOT)\src\site\style; \
    $(ROOT)\src\site\table; \
    $(ROOT)\src\site\text; \
    $(ROOT)\src\site\util; \
    $(ROOT)\src\site\view; \
    $(ROOT)\src\site\acc; \
    $(ROOT)\src\other\include; \
    $(ROOT)\src\other\htmldlg; \
    $(ROOT)\src\other\htmlapp; \
    $(ROOT)\src\dlay\dl; \
    $(ROOT)\src\core\include; \
    $(ROOT)\src\core\cdutil; \
    $(ROOT)\src\intl\include; \
    $(ROOT)\src\intl\idl\$(O); \
    $(ROOT)\external\inc; \
    $(ROOT)\external\inc\msls; \
    $(ROOT)\types\$(O); \
    $(ROOT)\imgfilt; \
    $(SHELL_INC_PATH);

!if !defined(WARNING_LEVEL)
WARNING_LEVEL=W4
!endif

MSC_WARNING_LEVEL=-$(WARNING_LEVEL) -WX
IA64_WARNING_LEVEL=-$(WARNING_LEVEL:W4=W3) -WX
AMD64_WARNING_LEVEL=-$(WARNING_LEVEL:W4=W3) -WX -D_M_AMD64

C_DEFINES = $(C_DEFINES) \
    /D_WCTYPE_INLINE_DEFINED \
    /DNASHVILLE \
    /DSTRICT \
    /DUNICODE \
    /D_UNICODE \
    /DOLEDBVER=0x0200 \

!if !$(FREEBUILD)
USE_RTTI=1
MSC_OPTIMIZATION=/Od
#USER_CPP_FLAGS=/zmf
WATCOM_OPTS=/ei /zt16 /zm /zff /zgf
LINKER_NOICF=1      # ICF is s-l-o-w
USE_DEBUGLIB=1
!if $(386) && !defined(UNIX)
USE_STACK_SPEW=1
!endif
!else
MSC_OPTIMIZATION=/Oxs
#USER_CPP_FLAGS=/zmf
WATCOM_OPTS=/ei /zt16 /ox /oe /zm /zff /zgf
!endif

!if defined(MSHTML_COD_FILES)
USER_C_FLAGS=$(USER_C_FLAGS) /Fc
!endif

!if !$(FREEBUILD) && defined(MSHTML_NO_INLINE)
MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /Ob0 /Oi
!else
MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /Ob1 /Oi
!endif

NOT_LEAN_AND_MEAN=1

UMTYPE=windows

USE_NOLIBS=1
USE_MSVCRT=1

# Use NT 4.0/Win95 functionality only

WIN32_IE_VERSION=0x0400
WIN32_WINNT_VERSION=0x0400
WIN32_WIN95_VERSION=0x0400
SUBSYSTEM_VERSION=4.00

!if $(386)
NO_NTDLL=1
!else
# USE_NTDLL=1
!endif

# By default, don't generate a .bsc file
NO_BROWSER_FILE=1

!ifdef MSHTML_BROWSER_INFO
USER_ENV_BROWSER_INFO=1
BROWSER_INFO = 1;
!endif

!ifdef HTML_LAYOUT
C_DEFINES = $(C_DEFINES) /DHTML_LAYOUT
!endif

!ifdef NDHACKS
C_DEFINES = $(C_DEFINES) /DNDHACKS
!endif

!ifdef ND_ASSERT
C_DEFINES = $(C_DEFINES) /DND_ASSERT
!endif

!ifdef TREE_SYNC
C_DEFINES = $(C_DEFINES) /DTREE_SYNC
!endif

!ifdef IE6_WYSIWYG_OM
C_DEFINES = $(C_DEFINES) /DIE6_WYSIWYG_OM
!endif

!ifdef DLOAD1
C_DEFINES = $(C_DEFINES) /DDLOAD1
!endif

!ifdef ACCURATEZOOM
C_DEFINES = $(C_DEFINES) /DACCURATEZOOM
!endif


!ifdef MULTI_FORMAT
C_DEFINES = $(C_DEFINES) /DMULTI_FORMAT
!endif

!ifdef MULTI_LAYOUT
C_DEFINES = $(C_DEFINES) /DMULTI_LAYOUT
!endif

!ifdef VIEW_SERVICES
C_DEFINES = $(C_DEFINES) /DVIEW_SERVICES
!endif

!ifdef DISABLE_MEASURING
C_DEFINES = $(C_DEFINES) /DDISABLE_MEASURING
!endif

!ifdef NEW_FILTERS
C_DEFINES = $(C_DEFINES) /DNEW_FILTERS
!endif

!ifdef ADORNERS
C_DEFINES = $(C_DEFINES) /DADORNERS
!endif

!ifdef FOCUS_ADORNER
C_DEFINES = $(C_DEFINES) /DFOCUS_ADORNER
!endif

!ifdef FOCUS_BEHAVIOR
C_DEFINES = $(C_DEFINES) /DFOCUS_BEHAVIOR
!endif

!ifdef EDIT_BEHAVIOR
C_DEFINES = $(C_DEFINES) /DEDIT_BEHAVIOR
!endif

!ifdef SLOWALLOC
!message SLOWALLOC was defined
C_DEFINES = $(C_DEFINES) /DSLOWALLOC
!endif

!ifdef MARKCODE
!message MARKCODE was defined
C_DEFINES = $(C_DEFINES) /DMARKCODE
!endif

!if defined(USE_ICECAP) || defined(USING_ICECAP4_ICEPICK)
C_DEFINES = $(C_DEFINES) /DPRODUCT_PROF
!if defined(USING_ICECAP4_ICEPICK)
C_DEFINES = $(C_DEFINES) /DICECAP4
PERFLIBS=$(ROOT)\external\lib\icecap.lib
!endif
!endif

!ifdef USE_PERFTAGS
!if $(FREEBUILD)
C_DEFINES = $(C_DEFINES) /DPERFTAGS
!message PERFTAGS was defined
USE_DEBUGLIB=1
!endif
!endif

!if !$(FREEBUILD) && !defined(UNIX)
C_DEFINES = $(C_DEFINES) /DPERFMETER
!message PERFMETER was defined
USE_DEBUGLIB=1
!endif

!ifdef USE_STACK_SPEW
C_DEFINES = $(C_DEFINES) /DUSE_STACK_SPEW
!message USE_STACK_SPEW was defined
!endif

!if "$(BUILD_ALT_DIR)"=="m" && "$(USE_PERFTAGS_IN_METER_BUILD)"=="1"
C_DEFINES = $(C_DEFINES:PERFMETER=PERFMETER /DPERFTAGS)
!message PERFTAGS was defined in METER build
USE_DEBUGLIB=1
!endif

!if "$(BUILD_ALT_DIR)"=="m"
USE_DEBUGLIB=1
!endif

!if $(FREEBUILD) && "$(BUILD_ALT_DIR)"!="m" && "$(USE_SWITCHES_IN_RETAIL_BUILD)"=="1"
C_DEFINES = $(C_DEFINES) /DUSESWITCHES
!message USESWITCHES was defined in RETAIL build
!endif

!if !$(FREEBUILD) || "$(OBJCNTCHK)"=="1"
C_DEFINES = $(C_DEFINES) /DOBJCNTCHK
!message OBJCNTCHK was defined
!endif

TRIRTMAIN=_DllMainStartup

!if defined(USE_STACK_SPEW) && defined(USE_DEBUGLIB)
TRIRTMAIN=_DllMainStartupDebugChkStk
!endif

!if defined(USE_STACK_SPEW) && !defined(USE_DEBUGLIB)
TRIRTMAIN=_DllMainStartupChkStk
!endif

!if !defined(USE_STACK_SPEW) && defined(USE_DEBUGLIB)
TRIRTMAIN=_DllMainStartupDebug
!endif

!ifdef USE_MSHTML_INCREMENTAL_LINKING
!if !$(FREEBUILD) && $(USE_MSHTML_INCREMENTAL_LINKING)
NTDEBUG=ntsd
NTDEBUGTYPE=windbg
NTDBGFILES=1
!undef USE_MAPSYM
USE_INCREMENTAL_LINKING=1
LINKER_FLAGS=$(LINKER_FLAGS) -INCREMENTAL:YES
USE_PDB_TO_COMPILE=1
TARGETPDB=MSHTML
!message USE_MSHTML_INCREMENTAL_LINKING was defined
!message $(TARGETPDB) was defined
!endif
!else
# Compatibility with existing usage before use_mshtml_incremental_linking
!ifdef USE_INCREMENTAL_LINKING
!message DOING IT THE OLD WAY
LINKER_FLAGS = -INCREMENTAL:YES
USE_PDB_TO_COMPILE=1
!else
USE_MAPSYM=1
!endif
!endif

#
# Linker flags
#

!if "$(BUILD_PRODUCT)" == "IE"
USE_WIN98OPT=1
!endif

# Emit LTCG codegen
!if $(IA64)
LTCG_WKS=1
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\digest\xstring.cxx ===
/*++

Copyright (c) 2003  Microsoft Corporation

Module Name:

    CSecureStr.h

Abstract:


Author:

    Stephen A Sulzer (ssulzer) 16-Jan-2003

--*/

//
// class implementation of CSecureStr
//

#include "include.hxx"

typedef LONG    NTSTATUS;

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

typedef NTSTATUS (WINAPI * ENCRYPTIONFUNCTION)(PVOID, ULONG, ULONG);

NTSTATUS
(WINAPI * _I_EncryptMemory)(
    IN OUT  PVOID Memory,
    IN      ULONG MemoryLength,
    IN      ULONG OptionFlags
    );

NTSTATUS
(WINAPI * _I_DecryptMemory)(
    IN OUT  PVOID Memory,
    IN      ULONG MemoryLength,
    IN      ULONG OptionFlags
    );


HMODULE hAdvApi32Dll;

// From <crypt.h> .....

//
// The buffer passed into RtlEncryptMemory and RtlDecryptMemory
// must be a multiple of this length.
//

#define RTL_ENCRYPT_MEMORY_SIZE             8

//
// Allow Encrypt/Decrypt across process boundaries.
// eg: encrypted buffer passed across LPC to another process which calls RtlDecryptMemory.
//

#define RTL_ENCRYPT_OPTION_CROSS_PROCESS    0x01

//
// Allow Encrypt/Decrypt across callers with same LogonId.
// eg: encrypted buffer passed across LPC to another process which calls RtlDecryptMemory whilst impersonating.
//

#define RTL_ENCRYPT_OPTION_SAME_LOGON       0x02


//
// methods
//

BOOL LoadEncryptionFunctions()
{
    if (NULL == hAdvApi32Dll)
    {
        hAdvApi32Dll = LoadLibrary("ADVAPI32.DLL");

        if (hAdvApi32Dll)
        {
            _I_EncryptMemory = (ENCRYPTIONFUNCTION) GetProcAddress(hAdvApi32Dll, "SystemFunction040");
            _I_DecryptMemory = (ENCRYPTIONFUNCTION) GetProcAddress(hAdvApi32Dll, "SystemFunction041");
        }
    }

    return (_I_EncryptMemory != NULL && _I_DecryptMemory != NULL);
}


LPSTR CSecureStr::GetUnencryptedString()
{
    if (NULL == _lpsz)
        return NULL;

    LPSTR lpszUnencryptedString = new CHAR[_stringLength];
    
    if (lpszUnencryptedString != NULL)
    {
        memcpy(lpszUnencryptedString, _lpsz, _stringLength);

        if (_fEncryptString && LoadEncryptionFunctions())
        {
            _I_DecryptMemory(lpszUnencryptedString, _stringLength, RTL_ENCRYPT_OPTION_SAME_LOGON);
        }
    }

    return lpszUnencryptedString;
}


BOOL CSecureStr::SetData(LPSTR lpszIn)
{
    DIGEST_ASSERT(lpszIn != NULL);

    if (_fEncryptString && LoadEncryptionFunctions())
    {
        DWORD dwStrLen = strlen(lpszIn) + 1;
        DWORD dwLen = 0;
        LPSTR lpszTemp;

        dwLen = dwStrLen + (RTL_ENCRYPT_MEMORY_SIZE - dwStrLen % RTL_ENCRYPT_MEMORY_SIZE);

        DIGEST_ASSERT((dwLen % 8) == 0);

        lpszTemp = new CHAR[dwLen + 1];

        if (!lpszTemp)
            return FALSE;

        ZeroMemory(lpszTemp, dwLen);

        memcpy(lpszTemp, lpszIn, dwStrLen);

        NTSTATUS status = _I_EncryptMemory(lpszTemp, dwLen, RTL_ENCRYPT_OPTION_SAME_LOGON);
        
        if (! NT_SUCCESS(status))
        {
            _fEncryptString = FALSE;
            memcpy(lpszTemp, lpszIn, dwStrLen);
            dwLen = dwStrLen;
        }

        Free();  // release current buffer if it exists

        _lpsz         = lpszTemp;
        _stringLength = dwLen;
        _fOwnString   = true;
        return TRUE;
    }
    else
    {
        // Make a copy of the data passed in.

        LPSTR lpszTemp = NewString(lpszIn);
        if (!lpszTemp)
            return FALSE;

        Free();  // release current buffer if it exists

        _lpsz           = lpszTemp;
        _stringLength   = strlen(_lpsz) + 1;
        _fEncryptString = false;
        _fOwnString     = true;
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\browseinfo\makefile.inc ===
# We want to do this so that our rule for createing the bsc file
# will win over the makefile.def rule.  We do much funkier things
NO_BROWSER_FILE=1

!ifdef MSHTML_BROWSER_INFO 
!  if "$(NOLINK)" == ""

# this is a wild nmake hack to always run a command
# I picked this up from makefile.def where the do a 
# build -O to make _objects.mac.
!if [-perl gensbrlists.pl .. $O]
!endif

!include $O\sbrlist.inc

..\$O\mshtml.bsc: $(SBRLIST) 
    -bscmake -nologo -o $@ @<<
$(SBRLIST: =
)
<<NOKEEP

!  else

..\$O\mshtml.bsc: 

!  endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\btools\nfparse\nfinit.cxx ===
#include "../pdlparse/headers.hxx"

extern "C"
HINSTANCE MwMainwinInitLite(int argc, char *argv[], void *lParam);

extern "C" 
HINSTANCE mainwin_init(int argc, char *argv[])
{ 
    return MwMainwinInitLite( argc, argv, NULL ); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\btools\ascparse\ascinit.cxx ===
#include "headers.hxx"

extern "C"
HINSTANCE MwMainwinInitLite(int argc, char *argv[], void *lParam);

extern "C" 
HINSTANCE mainwin_init(int argc, char *argv[])
{ 
    return MwMainwinInitLite( argc, argv, NULL ); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\btools\ascparse\ascparse.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1997
//
//  File:       ascparse.cxx
//
//  Contents:   Tool to build .hsc files from .asc files.
//
//              Does the work of precomputing hash tables for associative
//              arrays of strings.
//
//----------------------------------------------------------------------------

#define INCMSG(x)
#include "headers.hxx"

#ifndef X_LIMITS_H_
#define X_LIMITS_H_
#include <limits.h>
#endif

#ifndef X_PLATFORM_H_
#define X_PLATFORM_H_
#include <platform.h>
#endif

#ifndef X_MSHTMDBG_H_
#define X_MSHTMDBG_H_
#undef PERFMETER
#include <mshtmdbg.h>
#endif

#define ASCPARSE

// The following macro definitions allow us to use assoc.cxx
// without bringing in the whole CORE directory

#ifndef X_TCHAR_H_
#define X_TCHAR_H_
#include "tchar.h"
#endif

#define THR(x) (x)
#define RRETURN(x) return(x)
#define _MemAlloc(cb) malloc(cb)
#define _MemAllocClear(cb) calloc(1,cb)
#define _MemFree(x) free(x)
#define MemAlloc(mt,cb) _MemAlloc(cb)
#define MemAllocClear(mt,cb) _MemAllocClear(cb)
#define MemFree(x) _MemFree(x)
#define MemRealloc(mt, ppv, cb) _MemRealloc(ppv, cb)
#define _tcsequal(x,y) (!_tcscmp(x,y))
#define Assert(x) if (!(x)) { fprintf(stderr, "%s", #x); exit(1); }
#define Verify(x) if (!(x)) { fprintf(stderr, "%s", #x); exit(1); }
#define ARRAY_SIZE(x)   (sizeof(x) / sizeof(x[0]))

HRESULT 
_MemRealloc(void **ppv, size_t cb)
{
    void *pv;

    if (*ppv == NULL)
    {
        *ppv = _MemAlloc(cb);
        if (*ppv == NULL)
            return E_OUTOFMEMORY;
    }
    else
    {       
        pv = realloc(*ppv, cb);
        if (pv == NULL)
            return E_OUTOFMEMORY;
        *ppv = pv;
    }
    return S_OK;
};

void GetSuffix(LPCSTR pAssocString, LPSTR pSuffix, int nNumber)
{
    pSuffix[0] = '\0'; // NULL terminate the suffix
    // check if the First Character is a Captial letter.
    if ( islower(pAssocString[0]) )
        return;

    _itoa(nNumber, pSuffix, 10);
}

#include "assoc.cxx"

// end of stubs


#define MAX_WORD 64
#define MAX_LINE 4096

class CAscParser
{
public:
    CAscParser() { memset(this, 0, sizeof(*this)); }
    
    class CAscEntry {
    public:
        CAscEntry() { memset(this, 0, sizeof(*this)); }
        CAscEntry *_pEntryNext;
        char _achString[MAX_WORD];
        int  _number;
        char _achNumber[MAX_WORD];
        char _achStringName[MAX_WORD];
        char _achAssoc[MAX_WORD];
        char _achEnum[MAX_WORD];
        BOOL _fNoassoc;
        BOOL _fNostring;
        BOOL _fNoenum;
        const CAssoc *_pAssoc;
    };

    HRESULT ProcessAscFile(char *pchInputFile, char *pchOutputFile);
    char _achAssocArray[MAX_WORD];
    char _achAssocPrefix[MAX_WORD];
    char _achEnumType[MAX_WORD];
    char _achEnumPrefix[MAX_WORD];
    char _achStringNamePrefix[MAX_WORD];
    BOOL _fInsensitive;
    BOOL _fReversible;
    CAscEntry *_pEntryFirst;
    CAscEntry *_pEntryLast;
};
    
static BOOL ReadLine(FILE *fp, char *pchBuf, int cchBuf, int *pcchRead);
static void SkipSpace(char **ppch);
static void SkipNonspace(char **ppch);
static void ChopComment(char *pch);
static void GetWord(char **ppch, char **ppchWord);


int __cdecl
main  ( int argc, char *argv[] )
{
    HRESULT hr = E_FAIL;
    CAscParser np;
    
    if (argc != 3)
        goto Cleanup;

    hr = np.ProcessAscFile(argv[1], argv[2]);

Cleanup:

    if (hr)
        printf ( "Error %lx building ASC file\n", hr);
    exit(hr);
}

HRESULT
CAscParser::ProcessAscFile(char *pchInputFile, char *pchOutputFile)
{
    HRESULT hr;
    FILE   *fpInput = NULL;
    FILE   *fpOutput = NULL;
    char    achBuf[MAX_LINE];
    char   *pch;
    char   *pchWord;
    CAscEntry *pEntryNew;
    CAscEntry *pEntry;
    CAssocArray nt;

    nt.Init();
    _fReversible = FALSE;

    // open input file
    fpInput = fopen(pchInputFile, "r");
    if (!fpInput)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // open output file
    fpOutput = fopen(pchOutputFile, "w");
    if (!fpOutput)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // phase 1: read the header section
    hr = E_FAIL;
    
    for (;;)
    {
        if (!ReadLine(fpInput, achBuf, MAX_LINE, NULL))
            goto Cleanup;
        pch = achBuf;
        ChopComment(pch);
        GetWord(&pch, &pchWord);
        if (!*pchWord)
            continue;
        if (!strcmp(pchWord, "assocarray"))
        {
            GetWord(&pch, &pchWord);
            strcpy(_achAssocArray, pchWord);
            GetWord(&pch, &pchWord);
            strcpy(_achAssocPrefix, pchWord);
        }
        else
        if (!strcmp(pchWord, "enum"))
        {
            GetWord(&pch, &pchWord);
            strcpy(_achEnumType, pchWord);
            GetWord(&pch, &pchWord);
            strcpy(_achEnumPrefix, pchWord);
        }
        else
        if (!strcmp(pchWord, "string"))
        {
            GetWord(&pch, &pchWord);
            strcpy(_achStringNamePrefix, pchWord);
        }
        else
        if (!strcmp(pchWord, "case-insensitive"))
        {
            _fInsensitive = TRUE;
        }
        else
        if (!strcmp(pchWord, "case-sensitive"))
        {
            _fInsensitive = FALSE;
        }
        else
        if (!strcmp(pchWord, "reversible"))
        {
            _fReversible = TRUE;
        }
        else
        if (!strcmp(pchWord, "start"))
            break;
    }
    
    // phase 2: read the assoc table section
    hr = S_OK;
    
    while (ReadLine(fpInput, achBuf, MAX_LINE, NULL))
    {
        pch = achBuf;
        
        ChopComment(pch);
        GetWord(&pch, &pchWord);
        if (!*pchWord)
            continue;

        // allocate
        pEntryNew = new CAscEntry;
        if (!pEntryNew)
            return E_OUTOFMEMORY;

        // link up
        if (!_pEntryLast)
        {
            pEntryNew->_number = 0;
            _pEntryLast = _pEntryFirst = pEntryNew;
        }
        else
        {
            pEntryNew->_number = _pEntryLast->_number+1;
            _pEntryLast->_pEntryNext = pEntryNew;
            _pEntryLast = pEntryNew;
        }

        // fill in assoc
        strcpy(pEntryNew->_achString, pchWord);

        // fill in other fields
        for (;;)
        {
            GetWord(&pch, &pchWord);
            if (!*pchWord)
                break;

            if (!strcmp(pchWord, "number"))
            {
                GetWord(&pch, &pchWord);
                if (*pchWord == '=')
                {
                    for (pEntry = _pEntryFirst; pEntry; pEntry = pEntry->_pEntryNext)
                    {
                        if (!strcmp(pchWord+1, pEntry->_achString))
                        {
                            break;
                        }
                    }
                    
                    if (!pEntry)
                    {
                        hr = E_FAIL;
                        goto Cleanup;
                    }
                    
                    pEntryNew->_number = pEntry->_number;
                    strcpy(pEntryNew->_achNumber, pEntry->_achNumber);
                }
                else if (*pchWord >= '0' && *pchWord <= '9' || *pchWord == '-')
                {
                    pEntryNew->_number = atol(pchWord);
                    *pEntryNew->_achNumber = '\0';
                }
                else
                {
                    pEntryNew->_number = 0;
                    strcpy(pEntryNew->_achNumber, pchWord);
                }
            }
            else
            if (!strcmp(pchWord, "string"))
            {
                GetWord(&pch, &pchWord);
                strcpy(pEntryNew->_achStringName, pchWord);
            }
            else
            if (!strcmp(pchWord, "enum"))
            {
                GetWord(&pch, &pchWord);
                strcpy(pEntryNew->_achEnum, pchWord);
            }
            else
            if (!strcmp(pchWord, "assoc"))
            {
                GetWord(&pch, &pchWord);
                strcpy(pEntryNew->_achAssoc, pchWord);
            }
            else
            if (!strcmp(pchWord, "noassoc"))
            {
                pEntryNew->_fNoassoc = TRUE;
            }
            else
            if (!strcmp(pchWord, "nostring"))
            {
                pEntryNew->_fNostring = TRUE;
            }
            else
            if (!strcmp(pchWord, "noenum"))
            {
                pEntryNew->_fNoenum = TRUE;
            }
        }
    }

    // compute assocs
    for (pEntry = _pEntryFirst; pEntry; pEntry = pEntry->_pEntryNext)
    {
        if (!pEntry->_fNoassoc)
        {
            WCHAR awch[MAX_WORD];
            WCHAR *pwch = awch;
            char *pch = pEntry->_achString;
            DWORD len;
            DWORD hash;
            const CAssoc *passoc;
            
            do { *pwch++ = *pch; } while (*pch++);

            len = _tcslen(awch);
            
            if (_fInsensitive)
                hash = HashStringCi(awch, len, 0);
            else
                hash = HashString(awch, len, 0);

            passoc = nt.AddAssoc((DWORD_PTR)pEntry, awch, len, hash);
            if (!passoc)
            {
                hr = E_FAIL;
                goto Cleanup;
            }
            pEntry->_pAssoc = passoc;
        }
    }
            
    // phase 3: output header decls enums
    fprintf(fpOutput, "// %s\n", pchOutputFile);
    fprintf(fpOutput, "// Generated by ascparse.exe from %s\n", pchInputFile);
    fprintf(fpOutput, "// Do not modify by hand!\n");
    fprintf(fpOutput, "\n#ifndef _cxx_\n\n");

    // assocarray and hash
    fprintf(fpOutput, "class CAssoc;\n");
    fprintf(fpOutput, "class CAssocArray;\n\n");
    
    fprintf(fpOutput, "extern const CAssoc * const %s_HashTable[%d];\n", _achAssocArray, nt._mHash);
    if (_fReversible)
    {
        fprintf(fpOutput, "extern const CAssoc * const %s_RevSearch[];\n", _achAssocArray);
    }
    fprintf(fpOutput, "extern const CAssocArray %s;\n\n", _achAssocArray);
    
    // enums
    if (*_achEnumType)
    {
        fprintf(fpOutput, "enum %s\n{\n", _achEnumType);
        for (pEntry = _pEntryFirst; pEntry; pEntry = pEntry->_pEntryNext)
        {
            if (!pEntry->_fNoenum)
            {
                if (*pEntry->_achEnum)
                {
                    fprintf(fpOutput, "    %s = %d,\n", pEntry->_achEnum, pEntry->_number);
                }
                else
                {
                    fprintf(fpOutput, "    %s%s = %d,\n", _achEnumPrefix, pEntry->_achString, pEntry->_number);
                }
            }
        }
        fprintf(fpOutput, "    %s_FORCE_LONG = LONG_MAX\n", _achEnumType);
        fprintf(fpOutput, "};\n\n");
    }
    
    // assocs
    for (pEntry = _pEntryFirst; pEntry; pEntry = pEntry->_pEntryNext)
    {
        if (!pEntry->_fNoassoc)
        {
            if (!*pEntry->_achAssoc)
            {
                char suffix[32];
                GetSuffix(pEntry->_achString, suffix, pEntry->_number); 
                fprintf(fpOutput, "extern const CAssoc %s%s%s;\n",
                    _achAssocPrefix, pEntry->_achString, suffix);
            }
            else
            {
                fprintf(fpOutput, "extern const CAssoc %s;\n",
                    pEntry->_achAssoc);
            }
        }
    }
    
    fprintf(fpOutput, "\n\n");

    // strings
    for (pEntry = _pEntryFirst; pEntry; pEntry = pEntry->_pEntryNext)
    {
        if (!pEntry->_fNostring)
        {
            if (!pEntry->_fNoassoc && (*_achStringNamePrefix || *pEntry->_achStringName))
            {
                if (*pEntry->_achStringName)
                {
                    fprintf(fpOutput, "#define %s ",
                        pEntry->_achStringName);
                }
                else
                {
                    fprintf(fpOutput, "#define %s%s ",
                        _achStringNamePrefix, pEntry->_achString);
                }
                
                if (!*pEntry->_achAssoc)
                {
                    char suffix[32];
                    GetSuffix(pEntry->_achString, suffix, pEntry->_number); 
                    fprintf(fpOutput, "(%s%s%s._ach)\n",
                        _achAssocPrefix, pEntry->_achString, suffix);
                }
                else
                {
                    fprintf(fpOutput, "(%s._ach)\n",
                        pEntry->_achAssoc);
                }
            }
            else
            {
                if (*pEntry->_achStringName)
                {
                    fprintf(fpOutput, "#define %s (_T(\"%s\"))\n",
                        pEntry->_achStringName, pEntry->_achString);
                }
                else if (*_achStringNamePrefix)
                {
                    fprintf(fpOutput, "#define *%s%s (_T(\"%s\"))\n",
                        _achStringNamePrefix, pEntry->_achString, pEntry->_achString);
                }
            }
        }
    }

    // end of header section; start of cxx section
    fprintf(fpOutput, "\n#else _cxx_\n\n");
    fprintf(fpOutput, "\n#undef _cxx_\n\n");

    
    // phase 4: output assocs
    for (pEntry = _pEntryFirst; pEntry; pEntry = pEntry->_pEntryNext)
    {
        if (!pEntry->_fNoassoc)
        {
            if (!*pEntry->_achAssoc)
            {
                char suffix[32];
                GetSuffix(pEntry->_achString, suffix, pEntry->_number); 
                fprintf(fpOutput, "const CAssoc %s%s%s\t\t\t= ",
                    _achAssocPrefix, pEntry->_achString, suffix);
            }
            else
            {
                fprintf(fpOutput, "const CAssoc %s = ",
                    pEntry->_achAssoc);
            }
            if (*pEntry->_achNumber)
            {
                fprintf(fpOutput, "{ %12s, 0x%08x, _T(\"%s\") };\n",
                    pEntry->_achNumber, pEntry->_pAssoc->_hash, pEntry->_achString);
            }
            else
            {
                fprintf(fpOutput, "{ %5d, 0x%08x, _T(\"%s\") };\n",
                    pEntry->_number, pEntry->_pAssoc->_hash, pEntry->_achString);
            }
        }
    }

    // phase 5: output table
    // output hash table
    fprintf(fpOutput, "\n\nconst CAssoc * const %s_HashTable[%d] =\n{\n", _achAssocArray, nt._mHash);
    {
        int i;
        int c;
        int s;
        int d;
        
        const CAssoc * const *ppAssoc;
        for (ppAssoc = nt._pHashTable, c=nt._mHash; c; ppAssoc++, c--)
        {
            if (!*ppAssoc)
            {
                fprintf(fpOutput, "        NULL,\n");
            }
            else
            {
                i = (*ppAssoc)->Hash() % nt._mHash;
                s = ((*ppAssoc)->Hash() & nt._sHash) + 1;
                d = 0;
                while (nt._pHashTable + i != ppAssoc)
                {
                    if (i < s)
                        i += nt._mHash;
                    i -= s;
                    d++;
                }
                    
                fprintf(fpOutput, "/*%2d */ ",d);
                
                pEntry = (CAscEntry*)(*ppAssoc)->Number();
                
                if (!*pEntry->_achAssoc)
                {
                    char suffix[32];
                    GetSuffix(pEntry->_achString, suffix, pEntry->_number); 
                    fprintf(fpOutput, "&%s%s%s,\n",
                        _achAssocPrefix, pEntry->_achString, suffix);
                }
                else
                {
                    char suffix[32];
                    GetSuffix(pEntry->_achAssoc, suffix, pEntry->_number); 
                    fprintf(fpOutput, "&%s%s,\n",
                        pEntry->_achAssoc, suffix);
                }

            }
        }
    }

    fprintf(fpOutput, "};\n\n");

    // phase 6: output table for reverse search (if requested)
    if (_fReversible)
    {
        CAscParser::CAscEntry *    pFound;
        CAscParser::CAscEntry *    pEntry;
        int nCurrMin;
        int nPrevMin;
        int nCurrVal;

        fprintf(fpOutput, "const CAssoc * const %s_RevSearch[] =\n{\n", _achAssocArray);

        // find and print the entries in order from numeric min to max
        nPrevMin = 0;
        for(;;)
        {
            // find the next entry

            nCurrMin = INT_MAX;
            pFound = NULL;

            for (pEntry = _pEntryFirst; pEntry; pEntry = pEntry->_pEntryNext)
            {
                if (*pEntry->_achNumber)
                {
                    nCurrVal = atol(pEntry->_achNumber);
                }
                else
                {
                    nCurrVal = pEntry->_number;
                }

                if (nCurrVal > nPrevMin && nCurrVal < nCurrMin)
                {
                    nCurrMin = nCurrVal;
                    pFound = pEntry;
                }
            }

            // break out once we've done everything
            if (pFound == NULL)
            {
                break;
            }

            // output a pointer to the assoc
            if (!*pFound->_achAssoc)
            {
                char suffix[32];
                GetSuffix(pFound->_achString, suffix, pFound->_number); 
                fprintf(fpOutput, "\t&%s%s%s,\n",
                    _achAssocPrefix, pFound->_achString, suffix);
            }
            else
            {
                fprintf(fpOutput, "\t%s,\n", pFound->_achAssoc);
            }

            nPrevMin = nCurrMin;
        }

        fprintf(fpOutput, "};\n\n");
    }

    // output assoc table struct itself
    fprintf(fpOutput, "const CAssocArray %s = {\n", _achAssocArray);
    fprintf(fpOutput, "    %s_HashTable,\n", _achAssocArray);
    fprintf(fpOutput, "    %d,\n", nt._cHash);
    fprintf(fpOutput, "    %d,\n", nt._mHash);
    fprintf(fpOutput, "    %d,\n", nt._sHash);
    fprintf(fpOutput, "    %d,\n", nt._cHash);
    fprintf(fpOutput, "    %d,\n", nt._iSize);
    fprintf(fpOutput, "    TRUE,\n");
    fprintf(fpOutput, "};\n\n");
        
    fprintf(fpOutput, "\n#endif _cxx_\n\n");
    
    
Cleanup:
    nt.Deinit();
    
    if (fpInput)
        fclose(fpInput);
    if (fpOutput)
        fclose(fpOutput);

    return hr;
}

static
BOOL
ReadLine(FILE *fp, char *pchBuf, int cchBuf, int *pcchRead)
{
    int cchRead;
    
    if (!fgets(pchBuf, cchBuf, fp))
        return FALSE;

    cchRead = strlen(pchBuf);
    if (!cchRead)
        return FALSE;

    if (pcchRead)
        *pcchRead = cchRead;
        
    return TRUE;
}

static
void
SkipSpace(char **ppch)
{
    char *pch = *ppch;
    while (*pch && (*pch == ' ' || *pch == '\t' || *pch == '\r' || *pch == '\n'))
        pch++;
    *ppch = pch;
}


static
void
SkipNonspace(char **ppch)
{
    char *pch = *ppch;
    while (*pch && (*pch != ' ' && *pch != '\t' && *pch != '\r' && *pch != '\n'))
        pch++;
    *ppch = pch;
}

static
void
ChopComment(char *pch)
{
    while (*pch)
    {
        if (*pch == '/' && *(pch+1) == '/')
        {
            *pch = '\0';
            return;
        }
        pch++;
    }
}

static
void
GetWord(char **ppch, char **ppchWord)
{
    SkipSpace(ppch);
    *ppchWord = *ppch;
    SkipNonspace(ppch);
    if (**ppch)
    {
        **ppch = '\0';
        if (*ppch - *ppchWord > MAX_WORD)
            *(*ppchWord + MAX_WORD-1) = '\0';
        (*ppch)++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\btools\nfparse\nfparse.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1997
//
//  File:       nfparse.cxx
//
//  Contents:   Tool to build .nfh files from .nfi files.
//
//----------------------------------------------------------------------------

#ifndef X_STDLIB_H_
#define X_STDLIB_H_
#include <stdlib.h>
#endif

#ifndef X_STDIO_H_
#define X_STDIO_H_
#include <stdio.h>
#endif

#ifndef X_STDDEF_H_
#define X_STDDEF_H_
#include <stddef.h>
#endif

#ifndef X_SEARCH_H_
#define X_SEARCH_H_
#include <search.h>
#endif

#ifndef X_STRING_H_
#define X_STRING_H_
#include <string.h>
#endif

#ifndef X_CTYPE_H_
#define X_CTYPE_H_
#include <ctype.h>
#endif

#ifndef X_LIMITS_H_
#define X_LIMITS_H_
#include <limits.h>
#endif

#ifndef X_STDARG_H_
#define X_STDARG_H_
#include <stdarg.h>
#endif

//  Allow assignment within conditional
#pragma warning ( disable : 4706 )


#define MAX_WORD 256
#define MAX_LINE 4096
#define TRUE     1
#define FALSE    0
#define BOOL     int
#define ERROR    int
#define E_FAIL   1
#define S_OK     0

char achBlanks[] = "                                                                                    "
                   "                                                                                    "
                   "                                                                                    "
                   "                                                                                    "
                   "                                                                                    ";

class CNotificationParser
{
public:
    CNotificationParser() { memset(this, 0, sizeof(*this)); }
    
    class CNotification {
    public:
        CNotification() { memset(this, 0, sizeof(*this)); }
        void MakeSC( CNotification *pN );
        void MarkFirstChance();

        CNotification * _pNextN;

        char            _achType[MAX_WORD];

        //
        //  Targets
        //

        unsigned        _fSelf:1;
        unsigned        _fAncestors:1;
        unsigned        _fDescendents:1;
        unsigned        _fTree:1;

        //
        //  Categories
        //

        unsigned        _fTextChange:1;
        unsigned        _fTreeChange:1;
        unsigned        _fLayoutChange:1;
        unsigned        _fActiveX:1;
        unsigned        _fLayoutElements:1;
        unsigned        _fPositionedElements:1;
        unsigned        _fBubbleUpViewTree:1;
        unsigned        _fAllElements:1;
        unsigned        _fFrameSites:1;

        //
        //  Properties
        //

        unsigned        _fSendUntilHandled:1;
        unsigned        _fLazyRange:1;
        unsigned        _fCleanChange:1;
        unsigned        _fSynchronousOnly:1;
        unsigned        _fDoNotBlock:1;
        unsigned        _fAutoOnly:1;
        unsigned        _fZParentsOnly:1;
        unsigned        _fSecondChanceAvail:1;
        unsigned        _fSecondChance:1;
        
        //
        //  Arguments
        //

        unsigned        _fElement:1;
        unsigned        _fSI:1;
        unsigned        _fCElements:1;
        unsigned        _fCp:1;
        unsigned        _fCch:1;
        unsigned        _fTreeNode:1;
        unsigned        _fData:1;
        unsigned        _fFlags:1;
    };

    char *  _pchInput;
    char *  _pchOutput;

    FILE *  _fpOutput;
    FILE *  _fpInput;
    FILE *  _fpLog;

    ERROR  Parse();
    BOOL   Validate(CNotification * pN);
    BOOL   ReadLine(char *pchBuf, int cchBuf, int *pcchRead);
    void   SkipSpace(char **ppch);
    void   SkipNonspace(char **ppch);
    void   ChopComment(char *pch);
    BOOL   GetWord(char **ppch, char **ppchWord);
    char * NameOf(char * pchInput, char * pchOutput);
    void   WriteArg(unsigned fFlag, char * pchArg, char * pchPad, int * pcArgs);
    void   WriteFlag(unsigned fFlag, char * pchFlag, int * pcFlags);
    void   ReportError(const char * pchError, ...);
};


ERROR __cdecl
main  ( int argc, char *argv[] )
{
    CNotificationParser np;
    ERROR               err = E_FAIL;
    
    if (argc != 3)
    {
        printf("nfparse: Usage <Notification File> <HeaderFile>\n");
        goto Cleanup;
    }


    np._pchInput  = argv[1];
    np._pchOutput = argv[2];

    err = np.Parse();

Cleanup:

    exit(err);
}


ERROR
CNotificationParser::Parse()
{
    char                achBuf[MAX_LINE];
    char                achTemp[MAX_WORD];
    char *              pch;
    char *              pchWord  = NULL;
    CNotification *     pFirstN  = NULL;
    CNotification **    ppN      = &pFirstN;
    CNotification *     pN       = NULL;
    int                 i;
    int                 cch;
    ERROR               err;

    // open input file
    _fpInput = fopen(_pchInput, "r");
    if (!_fpInput)
    {
        err = E_FAIL;
        goto Cleanup;
    }

    // open output file
    _fpOutput = fopen(_pchOutput, "w");
    if (!_fpOutput)
    {
        err = E_FAIL;
        goto Cleanup;
    }

    // open log file
    strcpy(achBuf, _pchOutput);
    strcat(achBuf, "LOG");
    _fpLog = fopen(achBuf, "w");
    if (!_fpLog)
    {
        err = E_FAIL;
        goto Cleanup;
    }

    // phase 1: read the file
    err = E_FAIL;

    while (ReadLine(achBuf, MAX_LINE, NULL))
    {
        pch = achBuf;

        ChopComment(pch);

        while (GetWord(&pch, &pchWord))
        {
            if (!strcmp(pchWord, "type"))
            {
                if (*ppN == NULL)
                {
                    *ppN = new CNotification();
                    if (!*ppN)
                        goto Cleanup;
                    pN  = *ppN;
                    ppN = &pN->_pNextN;
                }

                if (!GetWord(&pch, &pchWord))
                {
                    ReportError("Missing notification type");
                    goto Cleanup;
                }
                strncpy(pN->_achType, pchWord, MAX_WORD-1);
            }

            else
            if (!strcmp(pchWord, "targets"))
            {
                if (!pN)
                {
                    ReportError("Notification does not start with 'type:'");
                    goto Cleanup;
                }

                while (GetWord(&pch, &pchWord))
                {
                    if (!strcmp(pchWord, "self"))
                    {
                        pN->_fSelf = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "ancestors"))
                    {
                        pN->_fAncestors = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "descendents"))
                    {
                        pN->_fDescendents = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "tree-level"))
                    {
                        pN->_fTree = TRUE;
                    }
                }
            }

            else
            if (!strcmp(pchWord, "categories"))
            {
                if (!pN)
                {
                    ReportError("Notification does not start with 'type:'");
                    goto Cleanup;
                }

                while (GetWord(&pch, &pchWord))
                {
                    if (!strcmp(pchWord, "text-change"))
                    {
                        pN->_fTextChange = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "tree-change"))
                    {
                        pN->_fTreeChange = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "layout-change"))
                    {
                        pN->_fLayoutChange = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "activex"))
                    {
                        pN->_fActiveX = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "layout-elements"))
                    {
                        pN->_fLayoutElements = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "positioned-elements"))
                    {
                        pN->_fPositionedElements = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "bubble-up-view-tree"))
                    {
                        pN->_fBubbleUpViewTree = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "all-elements"))
                    {
                        pN->_fAllElements = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "frame-sites"))
                    {
                        pN->_fFrameSites = TRUE;
                    }
                }
            }

            else
            if (!strcmp(pchWord, "properties"))
            {
                if (!pN)
                {
                    ReportError("Notification does not start with 'type:'");
                    goto Cleanup;
                }

                while (GetWord(&pch, &pchWord))
                {
                    if (!strcmp(pchWord, "send-until-handled"))
                    {
                        pN->_fSendUntilHandled = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "lazy-range"))
                    {
                        pN->_fLazyRange = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "clean-change"))
                    {
                        pN->_fCleanChange = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "synchronous-only"))
                    {
                        pN->_fSynchronousOnly = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "dont-block"))
                    {
                        pN->_fDoNotBlock = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "auto-only"))
                    {
                        pN->_fAutoOnly = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "zparents-only"))
                    {
                        pN->_fZParentsOnly = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "second-chance"))
                    {
                        pN->_fSecondChanceAvail = TRUE;
                    }
                }
            }

            else
            if (!strcmp(pchWord, "arguments"))
            {
                if (!pN)
                {
                    ReportError("Notification does not start with 'type:'");
                    goto Cleanup;
                }

                while (GetWord(&pch, &pchWord))
                {
                    if (!strcmp(pchWord, "element"))
                        pN->_fElement = 1;
                    else
                    if (!strcmp(pchWord, "si"))
                        pN->_fSI = 1;
                    else
                    if (!strcmp(pchWord, "celements"))
                        pN->_fCElements = 1;
                    else
                    if (!strcmp(pchWord, "cp"))
                        pN->_fCp = 1;
                    else
                    if (!strcmp(pchWord, "cch"))
                        pN->_fCch = 1;
                    else
                    if (!strcmp(pchWord, "tree-node"))
                        pN->_fTreeNode = 1;
                    else
                    if (!strcmp(pchWord, "data"))
                        pN->_fData = 1;
                    else
                    if (!strcmp(pchWord, "flags"))
                        pN->_fFlags = 1;
                }
            }

            else
            {
                ReportError("Unknown keyword (%s)", pchWord);
                goto Cleanup;
            }
        }
    }


    // phase 2: validate the notifications
    for (pN = pFirstN; pN; pN = pN->_pNextN)
    {
        if (!Validate(pN))
        {
            ReportError("Notification %s is invalid", pN->_achType);
            goto Cleanup;
        }
    }

    // phase 3: expand second chance notifications
    for (pN = pFirstN; pN; pN = pN->_pNextN)
    {
        if (pN->_fSecondChanceAvail)
        {
            CNotification *     pNNew = new CNotification();
            if (!pNNew)
                goto Cleanup;

            pNNew->MakeSC( pN );

            pN->MarkFirstChance();

            pNNew->_pNextN = pN->_pNextN;
            pN->_pNextN = pNNew;
            pN = pNNew;
        }
    }
    
            
    // phase 4: output the file
    fprintf(_fpOutput, "//-----------------------------------------------------------------------------\n");
    fprintf(_fpOutput, "//\n");
    fprintf(_fpOutput, "// WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING\n");
    fprintf(_fpOutput, "//\n");
    fprintf(_fpOutput, "// %s\n", _pchOutput);
    fprintf(_fpOutput, "// Generated by NFPARSE.EXE from %s\n", _pchInput);
    fprintf(_fpOutput, "// DO NOT MODIFY BY HAND\n");
    fprintf(_fpOutput, "//\n");
    fprintf(_fpOutput, "// WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING\n");
    fprintf(_fpOutput, "//\n");
    fprintf(_fpOutput, "//-----------------------------------------------------------------------------\n\n");

    // generate the enums
    fprintf(_fpOutput, "#if defined(_NOTIFYTYPE_ENUM_)\n\n");

    for (i=0, pN = pFirstN; pN; pN = pN->_pNextN, i++)
    {
        sprintf(achTemp, "    NTYPE_%s", _strupr(pN->_achType));
        cch = 32 - strlen(achTemp);
        if (cch < 0)
            cch = 0;

        fprintf(_fpOutput, "%s", achTemp);

        strncpy(achTemp, achBlanks, cch);
        achTemp[cch] = '\0';

        fprintf(_fpOutput, "%s = 0x%08X,\n", achTemp, (long)i);
    }

    fprintf(_fpOutput, "#undef _NOTIFYTYPE_ENUM_\n\n");

    fprintf(_fpOutput, "\n");

    // generate the flag table
    fprintf(_fpOutput, "#elif defined(_NOTIFYTYPE_TABLE_)\n\n");

    for (pN = pFirstN; pN; pN = pN->_pNextN)
    {
        int cFlags = 0;

        sprintf(achTemp, "/* NTYPE_%s", _strupr(pN->_achType));
        cch = 32 - strlen(achTemp);
        if (cch < 0)
            cch = 0;

        fprintf(_fpOutput, "%s", achTemp);

        strncpy(achTemp, achBlanks, cch);
        achTemp[cch] = '\0';

        fprintf(_fpOutput, "%s*/", achTemp);

        WriteFlag(pN->_fSelf,               "NFLAGS_SELF",              &cFlags);
        WriteFlag(pN->_fAncestors,          "NFLAGS_ANCESTORS",         &cFlags);
        WriteFlag(pN->_fDescendents,        "NFLAGS_DESCENDENTS",       &cFlags);
        WriteFlag(pN->_fTree,               "NFLAGS_TREELEVEL",         &cFlags);

        WriteFlag(pN->_fTextChange,         "NFLAGS_TEXTCHANGE",        &cFlags);
        WriteFlag(pN->_fTreeChange,         "NFLAGS_TREECHANGE",        &cFlags);
        WriteFlag(pN->_fLayoutChange,       "NFLAGS_LAYOUTCHANGE",      &cFlags);
        WriteFlag(pN->_fActiveX,            "NFLAGS_FOR_ACTIVEX",       &cFlags);
        WriteFlag(pN->_fLayoutElements,     "NFLAGS_FOR_LAYOUTS",       &cFlags);
        WriteFlag(pN->_fPositionedElements, "NFLAGS_FOR_POSITIONED",    &cFlags);
        WriteFlag(pN->_fBubbleUpViewTree,   "NFLAGS_BUBBLE_UP_VIEW_TREE", &cFlags);
        WriteFlag(pN->_fAllElements,        "NFLAGS_FOR_ALLELEMENTS",   &cFlags);
        WriteFlag(pN->_fFrameSites,         "NFLAGS_FOR_FRAMESITES",    &cFlags);
        
        WriteFlag(pN->_fSendUntilHandled,   "NFLAGS_SENDUNTILHANDLED",  &cFlags);
        WriteFlag(pN->_fLazyRange,          "NFLAGS_LAZYRANGE",         &cFlags);
        WriteFlag(pN->_fCleanChange,        "NFLAGS_CLEANCHANGE",       &cFlags);
        WriteFlag(pN->_fSynchronousOnly,    "NFLAGS_SYNCHRONOUSONLY",   &cFlags);
        WriteFlag(pN->_fDoNotBlock,         "NFLAGS_DONOTBLOCK",        &cFlags);
        WriteFlag(pN->_fAutoOnly,           "NFLAGS_AUTOONLY",          &cFlags);
        WriteFlag(pN->_fZParentsOnly,       "NFLAGS_ZPARENTSONLY",      &cFlags);
        WriteFlag(pN->_fSecondChance,       "NFLAGS_SC",                &cFlags);
        WriteFlag(pN->_fSecondChanceAvail,  "NFLAGS_SC_AVAILABLE",      &cFlags);

        fprintf(_fpOutput, ",\n");
    }

    fprintf(_fpOutput, "#undef _NOTIFYTYPE_TABLE_\n\n");

    fprintf(_fpOutput, "\n");

    // generate the names
    fprintf(_fpOutput, "#elif defined(_NOTIFYTYPE_NAMES_)\n\n");

    for (pN = pFirstN; pN; pN = pN->_pNextN)
    {
        fprintf(_fpOutput, "        case NTYPE_%s:\n", _strupr(pN->_achType));
        fprintf(_fpOutput, "            pch = _T(\"%s\");\n", _strupr(pN->_achType));
        fprintf(_fpOutput, "            break;\n");
    }

    fprintf(_fpOutput, "#undef _NOTIFYTYPE_NAMES_\n\n");

    fprintf(_fpOutput, "\n");

    // generate the prototypes
    fprintf(_fpOutput, "#elif defined(_NOTIFYTYPE_PROTO_)\n\n");

    for (pN = pFirstN; pN; pN = pN->_pNextN)
    {
        int cArgs = 0;

        fprintf(_fpOutput, "        void %s(\n", NameOf(pN->_achType, achTemp));

        WriteArg(pN->_fElement,   "CElement *  pElement",      "             ", &cArgs);
        WriteArg(pN->_fSI,        "long        siElement",     "             ", &cArgs);
        WriteArg(pN->_fCElements, "long        cElements",     "             ", &cArgs);
        WriteArg(pN->_fCp,        "long        cp",            "             ", &cArgs);
        WriteArg(pN->_fCch,       "long        cch",           "             ", &cArgs);
        WriteArg(pN->_fTreeNode,  "CTreeNode * pNode  = NULL", "             ", &cArgs);
        WriteArg(pN->_fData,      "void *      pvData = NULL", "             ", &cArgs);
        WriteArg(pN->_fFlags,     "DWORD       grfFlags = 0",  "             ", &cArgs);

        fprintf(_fpOutput, ");\n\n");
    }

    fprintf(_fpOutput, "#undef _NOTIFYTYPE_PROTO_\n\n");

    fprintf(_fpOutput, "\n");

    // generate the inlines
    fprintf(_fpOutput, "#elif defined(_NOTIFYTYPE_INLINE_)\n\n");

    for (pN = pFirstN; pN; pN = pN->_pNextN)
    {
        int cArgs = 0;

        fprintf(_fpOutput, "inline void\nCNotification::%s(\n", NameOf(pN->_achType, achTemp));
        WriteArg(pN->_fElement,   "CElement *  pElement",  "    ", &cArgs);
        WriteArg(pN->_fSI,        "long        siElement", "    ", &cArgs);
        WriteArg(pN->_fCElements, "long        cElements", "    ", &cArgs);
        WriteArg(pN->_fCp,        "long        cp",        "    ", &cArgs);
        WriteArg(pN->_fCch,       "long        cch",       "    ", &cArgs);
        WriteArg(pN->_fTreeNode,  "CTreeNode * pNode",     "    ", &cArgs);
        WriteArg(pN->_fData,      "void *      pvData",    "    ", &cArgs);
        WriteArg(pN->_fFlags,     "DWORD       grfFlags",  "    ", &cArgs);
        fprintf(_fpOutput, ")\n{\n");

        if (    pN->_fElement
            &&  !pN->_fSI
            &&  !pN->_fCp
            &&  !pN->_fTreeChange)
            fprintf(_fpOutput, "    Assert(pElement);\n");

        cArgs = 0;

        fprintf(_fpOutput, "    Initialize%s%s(NTYPE_%s,\n",
                            pN->_fSI
                                ? "Si"
                                : "",
                            pN->_fCp
                                ? "Cp"
                                : "",
                            _strupr(pN->_achType));

        WriteArg(pN->_fElement, "pElement", "               ", &cArgs);

        if (pN->_fSI)
        {
            WriteArg(pN->_fSI,        "siElement", "               ", &cArgs);
            WriteArg(pN->_fCElements, "cElements", "               ", &cArgs);
        }

        if (pN->_fCp)
        {
            WriteArg(1, (pN->_fCp
                              ? "cp"
                              : "-1"),      "               ", &cArgs);
            WriteArg(1, (pN->_fCch
                              ? "cch"
                              : "-1"),      "               ", &cArgs);
        }

        WriteArg(1, (pN->_fTreeNode
                          ? "pNode"
                          : "NULL"),   "               ", &cArgs);
        WriteArg(1, (pN->_fData
                          ? "pvData"
                          : "NULL"),   "               ", &cArgs);
        WriteArg(1, (pN->_fFlags
                          ? "grfFlags"
                          : "0"),      "               ", &cArgs);

        fprintf(_fpOutput, ");\n");
        fprintf(_fpOutput, "}\n\n");
    }

    fprintf(_fpOutput, "#undef _NOTIFYTYPE_INLINE_\n\n");

    fprintf(_fpOutput, "\n");

    fprintf(_fpOutput, "#endif\n\n");

    err = S_OK;

Cleanup:

    if (err)
        ReportError("Could not build %s\n", _pchOutput);

    if (_fpInput)
        fclose(_fpInput);
    if (_fpOutput)
        fclose(_fpOutput);
    if (_fpLog)
        fclose(_fpLog);

    return err;
}

BOOL
CNotificationParser::Validate(CNotification * pN)
{
    ERROR err = E_FAIL;

    if (!*pN->_achType)
    {
        ReportError("Notification is missing 'type:'");
        goto Cleanup;
    }

    if (    !pN->_fSelf
        &&  !pN->_fAncestors
        &&  !pN->_fDescendents
        &&  !pN->_fTree)
    {
        ReportError("Notification is missing targets");
        goto Cleanup;
    }

    if (    pN->_fAncestors
        &&  pN->_fDescendents)
    {
        ReportError("Notification is sent to both ancestors and descendents");
        goto Cleanup;
    }

    if (    !pN->_fTextChange
        &&  !pN->_fTreeChange
        &&  !pN->_fLayoutChange
        &&  !pN->_fActiveX
        &&  !pN->_fLayoutElements
        &&  !pN->_fBubbleUpViewTree
        &&  !pN->_fPositionedElements
        &&  !pN->_fAllElements
        &&  !pN->_fFrameSites)
    {
        ReportError("Notification is missing categories");
        goto Cleanup;
    }

    if (    !pN->_fElement
        &&  !pN->_fSI
        &&  !pN->_fCp
        &&  !pN->_fTreeNode)
    {
        ReportError("Notification requires either 'element', 'si', 'cp', or 'tree-node'");
        goto Cleanup;
    }

    if (    pN->_fCElements
        &&  !pN->_fSI)
    {
        ReportError("Notification has 'celement' without 'si'");
        goto Cleanup;
    }

    if (    pN->_fCch
        &&  !pN->_fCp)
    {
        ReportError("Notification has 'cch' without 'cp'");
        goto Cleanup;
    }

    if (    pN->_fSecondChanceAvail
        &&  (   pN->_fSelf && strcmp( pN->_achType, "ELEMENT_EXITTREE" )
            ||  pN->_fAncestors
            ||  pN->_fTree))
    {
        ReportError("Second chance only implemented for descendents and ELEMENT_EXITTREE");
        goto Cleanup;
    }

    err = S_OK;

Cleanup:
    return (err == S_OK);
}

char *
CNotificationParser::NameOf(char * pchInput, char * pchOutput)
{
    char *  pch = pchOutput;
    int     fMakeUpper = 1;

    while (*pchInput)
    {
        if (*pchInput == '_')
        {
            fMakeUpper = 1;
        }
        else
        {
            *pchOutput++ = (fMakeUpper
                                ? (char)toupper(*pchInput)
                                : (char)tolower(*pchInput));
            fMakeUpper = 0;
        }

        pchInput++;
    }

    *pchOutput = '\0';
    return pch;
}

void
CNotificationParser::WriteArg(unsigned fFlag, char * pchArg, char * pchPad, int * pcArgs)
{
    if (fFlag)
    {
        if (*pcArgs)
            fprintf(_fpOutput, ",\n");

        fprintf(_fpOutput, "%s", pchPad);

        (*pcArgs)++;

        fprintf(_fpOutput, "%s", pchArg);
    }
}

void
CNotificationParser::WriteFlag(unsigned fFlag, char * pchFlag, int * pcFlags)
{
    char    ach[MAX_WORD];
    int     cch = strlen(pchFlag);

    if (fFlag)
    {
        fprintf(_fpOutput, (*pcFlags
                                ? " | "
                                : "   "));

        fprintf(_fpOutput, "%s", pchFlag);
        (*pcFlags)++;
    }
    else
    {
        strncpy(ach, achBlanks, cch);
        ach[cch] = '\0';
        fprintf(_fpOutput, "   ");
        fprintf(_fpOutput, "%s", ach);
    }
}

BOOL
CNotificationParser::ReadLine(char *pchBuf, int cchBuf, int *pcchRead)
{
    int cchRead;
    
    if (!fgets(pchBuf, cchBuf, _fpInput))
        return FALSE;

    cchRead = strlen(pchBuf);
    if (!cchRead)
        return FALSE;

    if (pcchRead)
        *pcchRead = cchRead;
        
    return TRUE;
}

inline BOOL
IsDelim(char ch)
{
    return (    ch == ' '
            ||  ch == '\t'
            ||  ch == '\r'
            ||  ch == '\n'
            ||  ch == ','
            ||  ch == ':'
            ||  ch == ';');
}

void
CNotificationParser::SkipSpace(char **ppch)
{
    char *pch = *ppch;
    while (*pch && IsDelim(*pch))
        pch++;
    *ppch = pch;
}


void
CNotificationParser::SkipNonspace(char **ppch)
{
    char *pch = *ppch;
    while (*pch && !IsDelim(*pch))
        pch++;
    *ppch = pch;
}

void
CNotificationParser::ChopComment(char *pch)
{
    while (*pch)
    {
        if (*pch == '/' && *(pch+1) == '/')
        {
            *pch = '\0';
            return;
        }
        pch++;
    }
}

BOOL
CNotificationParser::GetWord(char **ppch, char **ppchWord)
{
    SkipSpace(ppch);
    *ppchWord = *ppch;
    SkipNonspace(ppch);
    if (**ppch)
    {
        if (*ppch - *ppchWord > MAX_WORD)
            *ppch = *ppchWord + MAX_WORD - 1;
        **ppch = '\0';
        (*ppch)++;
    }

    return **ppchWord;
}

void
CNotificationParser::ReportError(const char * pchError, ...)
{
    char    ach[MAX_LINE];
    va_list ap;

    va_start(ap, pchError);
    vsprintf(ach, pchError, ap);
    va_end(ap);

    printf("%s(0) : error NF0000: %s\n", _pchInput, ach);
    if (_fpLog)
        fprintf(_fpLog, "%s(0) : error NF0000: %s\n", _pchInput, ach);
}

void 
CNotificationParser::CNotification::MakeSC( CNotification *pN ) 
{ 
    memcpy( this, pN, sizeof(CNotification) );

    strncat(_achType, "_2", MAX_WORD-1);

    _fSecondChanceAvail = FALSE;
    _fSecondChance = TRUE;
}

void 
CNotificationParser::CNotification::MarkFirstChance() 
{ 
    strncat(_achType, "_1", MAX_WORD-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\btools\pdlparse\pdlinit.cxx ===
#include "headers.hxx"

extern "C"
HINSTANCE MwMainwinInitLite(int argc, char *argv[], void *lParam);

extern "C" 
HINSTANCE mainwin_init(int argc, char *argv[])
{ 
    return MwMainwinInitLite( argc, argv, NULL ); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\btools\pdlparse\main.cxx ===
#include "headers.hxx"

// COM+ shim.  Uncomment below line to build the COM+ shim.
//#define COMPLUS_SHIM

#ifndef X_PDLPARSE_HXX_
#define X_PDLPARSE_HXX_
#include "pdlparse.hxx"
#endif

#ifndef X_DATA_HXX_
#define X_DATA_HXX_
#include "data.hxx"
#endif

#ifndef X_VTABLE_HXX_
#define X_VTABLE_HXX_
#include <vtable.hxx>
#endif

#ifndef X_ASSERT_H_
#define X_ASSERT_H_
#include <assert.h>
#endif

// Win16 needs the old typelibs. Old Typelib can't cope
// with default parameters. So if this flag is set we
// ignore all the default parameters in the PDL files.
// This flag is set based on run-time argument "win16"
BOOL gbWin16Mode = FALSE;


//
// TO deal with the LONG_PTR problem : we need to translate it to different
// automation type for Win32 and Win64
//
BOOL gfWin64 = FALSE;

static 
BOOL
GetALine ( FILE *fp, char *szLineBuffer, int nMaxLen, int &nLenRead );


void PDLError (char *szTextError)
{
    printf ( "PDLParse (0) : error PDL0001: /G  %s", szTextError);
}


BOOL TagArray::CompareTag ( INT nIndex, char *szWith )
{
    if ( szValues [ nIndex ] == NULL )
        return FALSE;
    else
        return _stricmp ( szValues [ nIndex ], szWith ) == 0 ? TRUE : FALSE;
}

char *TagArray::GetTagValue ( INT nIndex )
{
    // If the string is null always return an empty string
    if ( szValues [ nIndex ] == NULL )
        return szEmptyString;
    else
        return szValues [ nIndex ];
}

BOOL TagArray::AddTag ( int iTag, LPCSTR szStr, int nLen )
{
    if ( szValues [ iTag ] )
        delete [] ( szValues [ iTag ] );
    if ( nLen == -1 )
        nLen = strlen ( szStr );
    if ( szStr == NULL )
    {
        szValues [ iTag ] = NULL;
        return TRUE;
    }
    szValues [ iTag ] = new char [ nLen + 1 ];
    if ( !szValues [ iTag ] )
        return FALSE;
    strncpy ( szValues [ iTag ], szStr, nLen );
    szValues [ iTag ][ nLen ] = '\0';
    return TRUE;
}


Token::~Token()
{
    if ( _pChildList )
        _pChildList -> Release();
}

void CTokenListWalker::Reset ( void )
{
    _pCurrentToken = NULL;
    if ( _pszFileName )
        _fInCurrentFile = FALSE;
    else
        _fInCurrentFile = TRUE;
    _fAtEnd = FALSE;
}


UINT CString::Lookup ( Associate *pArray, LPCSTR pStr )
{
    UINT uIndex =0;
    while ( pArray->szKey )
    {
        if ( strcmp ( pArray->szKey, pStr ) == 0 )
        {
            strcpy ( szString, pArray->szValue );
            return uIndex;
        }
        pArray++; uIndex++;
    }
    return (UINT)-1;
}

UINT CString::Lookup ( AssociateDataType *pArray, LPCSTR pStr )
{
    UINT uIndex =0;
    while ( pArray->szKey )
    {
        if ( strcmp ( pArray->szKey, pStr ) == 0 )
        {
            strcpy ( szString, pArray->szValue );
            return uIndex;
        }
        pArray++; uIndex++;
    }
    return (UINT)-1;
}


/* static */
char *TagArray::szEmptyString = "";

BOOL
GetStdInLine ( char *szLineBuffer, int nMaxLen )
{
    int nLenRead,i;
    int nTotalRead = 0;

    do
    {
        if ( !GetALine ( NULL, szLineBuffer+nTotalRead, 
            nMaxLen, nLenRead ) )
        {
            return FALSE;
        }
        nTotalRead += nLenRead;
        for ( i = nTotalRead-1 ; i >= 0 ; i-- )
        {
            if ( !isspace ( szLineBuffer [ i ] ) )
            {
                break;
            }
        }
        if ( i > 0 )
        {
            if ( szLineBuffer [ i ] == '\\' )
            {
                szLineBuffer [ i ] = ' ';
                szLineBuffer [ i+1 ] = '\0';
                // we'll go on to the next line
                nTotalRead = i+1; 
                // Don't break, so we append the next line
            }
            else
            {
                // Regular line
                szLineBuffer [ i+1 ] = '\0';
                nTotalRead = i+1;
                // Not continuing - break so we process this line
                break;
            }
        }
        else
        {
            // Completly blank line - ignore it...
            nTotalRead = 0;
        }
    } while ( nTotalRead < nMaxLen );
    return TRUE;
}

static
BOOL
GetALine (  FILE *fp,char *szLineBuffer, int nMaxLen, int &nLenRead )
{
    nLenRead = 0;
    // Keep reading in data until we blow the buffer size, or hit a real
    // EOL. If we have a trailing \ character, go on to the next line
    if ( fp )
    {
        if ( !fgets ( szLineBuffer, nMaxLen, fp )  )
        {
            return FALSE;
        }
    }
    else
    {
        if ( !gets ( szLineBuffer )  )
        {
            return FALSE;
        }
    }

    nLenRead = strlen ( szLineBuffer );
    if ( szLineBuffer [ 0 ] && szLineBuffer [ nLenRead-1 ] == '\n' )
    {
        szLineBuffer [ --nLenRead ] = '\0';
    }
    return TRUE;
}

Token *CTokenList::FindToken ( char *pTokenName, DESCRIPTOR_TYPE nType )  const
{
    Token *pToken;

    for ( pToken = _pFirstToken ;
        pToken != NULL ; pToken = pToken-> GetNextToken() )
    {
        // Token 0 is always the name
        // Case sensitive match
        if ( strcmp ( pToken->GetTagValue ( 0 ), pTokenName ) == 0 )
        {
            return pToken->GetType() ? pToken : NULL;
        }
    }
    return NULL;
}


Token *CTokenList::AddNewToken ( DESCRIPTOR_TYPE nTokenDescriptor )
{
    Token *pNewToken = new Token ( nTokenDescriptor );

    if ( !pNewToken )
        return NULL;

    if ( !_pFirstToken )
    {
        _pFirstToken = pNewToken;
    }
    else
    {
        _pLastToken->SetNextToken ( pNewToken );
    }
    _pLastToken = pNewToken;
    _uTokens++;
    return pNewToken;
}




/*
 Scan the input file and extract the 4 build arguments
    Do this to be compatible with previous version of mkprop
*/
//--------------------------------------------------
//TODO: Modify this to accept flags for ia64/i386!
//--------------------------------------------------
static
BOOL
ScanBuildFile ( char *szBuildFileName,
    char *szInputFile, 
    char *szOutputFileRoot, 
    char *szPDLFileName, 
    char *szOutputPath )
{
    FILE   *fp = NULL;
    char    szLineBuffer [ MAX_LINE_LEN+1 ]; 
    BOOL    fReturn = FALSE;
    int     nRead;

    fp = fopen ( szBuildFileName, "r" );
    if ( !fp )
    {
        printf ( "Cannot open %s\n", szBuildFileName );
        goto cleanup;
    }
    if ( !GetALine ( fp, szLineBuffer, sizeof ( szLineBuffer ), nRead ) )
    {
        printf ( "Cannot read %s\n", szBuildFileName );
        goto cleanup;
    }

    // Old input file used to support "-<flags>" - which was never used
    // so I just skip them
    if (sscanf ( szLineBuffer, "- %s %s %s",
                     (LPCSTR)szOutputFileRoot,
                     (LPCSTR)szInputFile,
                     (LPCSTR)szOutputPath ) != 3)
    {
        printf ( "Cannot read params from %s\n", szBuildFileName );
        goto cleanup;
    }

    while ( GetALine ( fp, szLineBuffer, sizeof ( szLineBuffer ), nRead ) )
        printf ( "Build file Line:%s\n",szLineBuffer ); 

    strcpy ( szPDLFileName, szInputFile );

    fReturn = TRUE;
    goto cleanup;

cleanup:
    if ( fp )
        fclose ( fp );
    return fReturn;
}

CTokenList::~CTokenList()
{
    Token *pNextToken;
    Token *pToken;
    // Tidy up the list
    for ( pToken = _pFirstToken ; pToken != NULL ; pToken = pNextToken )
    {
        pNextToken = pToken -> _pNextToken;
        delete pToken;
    }
}


Token *CTokenListWalker::GetNext ( void )
{
    Token *pToken;
    while ( pToken = GetNextToken() )
    {
        if ( _pszFileName )
        {
            if ( _pCurrentToken->nType == TYPE_FILE )
            {
                if ( _fInCurrentFile && _pszFileName )
                {
                    _fInCurrentFile = FALSE;
                }
                else
                {
                    _fInCurrentFile = pToken->CompareTag ( FILE_TAG, _pszFileName );
                }
            }
            else if ( _fInCurrentFile )
            {
                break;
            }
        }
        else
        {
            break;
        }
    }
    return pToken;
}

Token *CTokenListWalker::GetNext ( DESCRIPTOR_TYPE Type, LPCSTR pName )
{
    Token *pToken;
    while ( pToken = GetNext() )
    {
        if ( pToken -> nType == Type && 
            ( pName == NULL || _stricmp ( pName, pToken -> GetTagValue ( NAME_TAG ) ) == 0 ) ) 
        {
            return pToken;
        }
    }
    return NULL;
}



Token *Token::AddChildToken ( DESCRIPTOR_TYPE nType )
{
    Token *pNewToken;

    if ( _pChildList == NULL )
    {
        if ( ( _pChildList = new CTokenList() ) == NULL )
        {
            return NULL;
        }
    }

    // Created the new arg token
    if ( ! ( pNewToken = _pChildList->AddNewToken ( nType ) ) )
    {
        return NULL;
    }
    return pNewToken;
}

void Token::CalculateEnumMask ( Token *pParentToken )
{
    INT nValue;
    if ( IsSet ( EVAL_VALUE ) )
    {
        nValue = atoi ( GetTagValue ( EVAL_VALUE ) );
    }
    else
    {
        char szText [ MAX_LINE_LEN+1 ];
        nValue = pParentToken -> nNextEnumValue;
        // Plug the new value into the tag
        sprintf ( szText, "%d", nValue );
        AddTag ( EVAL_VALUE, szText );

    }
    if ( nValue >=0 && nValue < 32 )
    {
        pParentToken -> uEnumMask |= (1 << (UINT)nValue);
    }
    pParentToken -> nNextEnumValue = ++nValue;
}

UINT Token::GetChildTokenCount ( void )
{
    return _pChildList ? _pChildList -> GetTokenCount() : 0;
}

// Helper for building comma sperarated arg lists
// if the arg is set add the corresponding text to
// the arg string
void Token::AddParam ( CString &szArg, INT nTag, LPCSTR szText )
{
    if ( IsSet ( nTag ) )
    {
        if ( szArg [ 0 ] != '\0' )
            szArg += ", ";

        szArg += szText;
    }
}

// Helper for building comma sperarated arg lists
// if the arg is set add the corresponding text to
// the arg string. With the current arg value replacing the %s
// szArg must contain one and only one %s
void Token::AddParamStr ( CString &szArg, INT nTag, LPCSTR szText )
{
    char szTemp [ MAX_LINE_LEN+1 ];
    if ( IsSet ( nTag ) )
    {
        sprintf ( szTemp, (LPCSTR)szText, (LPCSTR)GetTagValue ( nTag ) );
        if ( szArg [ 0 ] != '\0' )
            szArg += ", ";
        szArg += szTemp;
    }
}

void Token::Clone ( Token *pFrom )
{
    UINT i;
    INT nLen;

    for ( i = 0 ; i < MAX_TAGS ; i++ )
    {
        nLen = pFrom -> TagValues.GetInternalValue ( i ) ?  strlen ( pFrom -> TagValues.GetInternalValue ( i ) ) : 0;
        TagValues.AddTag ( i, pFrom -> TagValues.GetInternalValue ( i ), nLen );
    }
    nType = pFrom -> nType;

    // Now clone the child arg list if there is one
    // Implemented an Addref/Release to simplify the process
    if ( _pChildList )
    {
        _pChildList -> Release();
        _pChildList = NULL;
    }
    if ( pFrom -> _pChildList )
    {
        // Point ourselves at the child list & AddRef it
        _pChildList = pFrom -> _pChildList;
        _pChildList -> AddRef();
    }
}


struct METH_PARAMS  {
        BOOL        fOptional;
        BOOL        fDefaultValue;
        CString     szVTParamType;
        CString     szCParamType;
        VARTYPE     vtParam;
};

#define ATYPE_Undefined         0
#define ATYPE_Method            1
#define ATYPE_GetProperty       2
#define ATYPE_SetProperty       4
#define ATYPE_ReturnValue       8
#define ATYPE_ParametersOnly   16

struct DispatchHandler {
    CString     szRawString;
    WORD        invokeType;
    CString     szDispName;
    CString     szVTResult;
    CString     szCResult;
    VARTYPE     vtResult;
    METH_PARAMS params[8];
};


#define MAX_HANDLERS    130
#define MAX_IIDS        330

int             _cHandlers;
DispatchHandler _allHandlers[MAX_HANDLERS];
int             _cIID;
LPSTR           _allIIDs[MAX_IIDS];

#ifdef COMPLUS_SHIM

//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////
//                                    Beginning of COM+ code                                //
//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////


enum CODETYPE {CT_managed, CT_unmanaged, CT_managedNDirect};

typedef void (__stdcall * NDBodyFunc)(FILE *, DispatchHandler *, CODETYPE, int);

#define PARAM_NAME_PREFIX	"param"
#define PARAM_RESULT_PREFIX	"resultParam"


// When we have a setter or getter only we look to see if there were any properties with the same type that supported 
// getting/setting if so use that entry.
BOOL AnyGSHandler(DispatchHandler & handler)
{
    if (handler.invokeType & (ATYPE_GetProperty | ATYPE_SetProperty))
    {
        for (int i = 0; i < _cHandlers; i++)
        {
            if ((_allHandlers[i].invokeType & (ATYPE_GetProperty | ATYPE_SetProperty)) == (ATYPE_GetProperty | ATYPE_SetProperty))
            {
                if (_allHandlers[i].vtResult == handler.vtResult)
                {
                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}


LPCSTR ResultType(DispatchHandler *pHandler, CODETYPE codeType, BOOL *pfAllocate)
{
    BOOL	tempBool;

    if (!pfAllocate)
    {
        pfAllocate = &tempBool;
    }
    *pfAllocate = FALSE;

    VARTYPE vtResult = pHandler->vtResult & VT_TYPEMASK;

    if (codeType == CT_managedNDirect)
    {
        if (vtResult == VT_BSTR)
        {
            return "wchar_t*";
        }
        else if (vtResult == VT_DISPATCH || vtResult == VT_UNKNOWN)
        {
            return "unsigned int";
        }
        else if (vtResult == VT_VARIANT)
        {
            return "unsigned int";
        }
        else if (vtResult == VT_BOOL)
        {
            return "short";
        }
        else if (vtResult == VT_I4)
        {
            return "long";
        }
        else if (vtResult == VT_I2)
        {
            return "short";
        }
        else if (pHandler->vtResult == VT_ARRAY)
        {
            return "wchar_t*";			// ***TLL*** COM+: Need something different here for now it's a string.
        }
        else
        {
            return (LPCSTR)pHandler->szCResult;
        }
    }
    else if (codeType == CT_managed)
    {
        if (vtResult != VT_EMPTY)
        {
            if (vtResult == VT_BSTR)
            {
                return "String";
            }
            else if (vtResult == VT_DISPATCH || vtResult == VT_UNKNOWN)
            {
                return "unsigned int";
            }
            else if (vtResult == VT_VARIANT)
            {
                return "Variant";
            }
            else if (vtResult == VT_BOOL)
            {
                return "Boolean";
            }
            else if (vtResult == VT_I4)
            {
                return "long";
            }
            else if (vtResult == VT_I2)
            {
                return "short";
            }
            else if (pHandler->vtResult == VT_ARRAY)
            {
                return "String";			// ***TLL*** COM+: Need something different here for now it's a string.
            }
            else
            {
                LPCSTR pFoundSpace = strchr((LPCSTR)pHandler->szCResult, ' ');
                LPSTR pString;

                if (pFoundSpace)
                {
                    UINT	cLen = pFoundSpace - (LPCSTR)pHandler->szCResult;
                    pString = new char[cLen + 1];
                    if (pString)
                    {
                        *pfAllocate = TRUE;
                        strncpy(pString, (LPCSTR)pHandler->szCResult, cLen);
                        pString[cLen] = '\0';
                        return pString;
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return (LPCSTR)pHandler->szCResult;
                }
            }
        }
        else
        {
            return "void";
        }
    }
    else
    {
        return (LPCSTR)pHandler->szCResult;
    }
}


void
OutputParameters(FILE *fpOut, DispatchHandler *pHandler, CODETYPE codeType, int invokeType)
{
    BOOL	fAllocate = FALSE;
    LPCSTR	mappedParamType = ResultType(pHandler, codeType, &fAllocate);

    if (invokeType & ATYPE_GetProperty)
    {
        if (codeType != CT_managed)
        {
            fprintf(fpOut, ", %s* " PARAM_RESULT_PREFIX ")", mappedParamType);
        }
        else
        {
            fprintf(fpOut, ")");
        }
    }
    else if (invokeType & ATYPE_SetProperty)
    {
        fprintf(fpOut, ", %s " PARAM_NAME_PREFIX "1)", mappedParamType);
    }
    else if (invokeType & ATYPE_ReturnValue)
    {
        fprintf(fpOut, "%s ", mappedParamType);
    }
    else
    {
        int j = 0;
        int cArgs = 0;

        if (fAllocate)
        {
            delete [] (LPSTR)mappedParamType;
            fAllocate = FALSE;
        }

        while (pHandler->params[j].szVTParamType.Length())
        {
            VARTYPE vtParam = pHandler->params[j].vtParam & VT_TYPEMASK;

            if (codeType == CT_managedNDirect)
            {
                if (vtParam == VT_BSTR)
                {
                    mappedParamType = "wchar_t*";
                }
                else if (vtParam == VT_DISPATCH || vtParam == VT_UNKNOWN)
                {
                    mappedParamType = "unsigned int";
                }
                else if (vtParam == VT_VARIANT)
                {
                    mappedParamType = "unsigned int";
                }
                else if (vtParam == VT_BOOL)
                {
                    mappedParamType = "short";
                }
                else if (vtParam == VT_I4)
                {
                    mappedParamType = "long";
                }
                else if (vtParam == VT_I2)
                {
                    mappedParamType = "short";
                }
                else if (pHandler->params[j].vtParam == VT_ARRAY)
                {
                    mappedParamType = "wchar_t*";			// ***TLL*** COM+: Need something different here for now it's a string.
                }
                else
                {
                    mappedParamType = (LPCSTR)pHandler->params[j].szCParamType;
                }
            }
            else if (codeType == CT_managed)
            {
                if (vtParam == VT_BSTR)
                {
                    mappedParamType = "String";
                }
                else if (vtParam == VT_DISPATCH || vtParam == VT_UNKNOWN)
                {
                    mappedParamType = "unsigned int";
                }
                else if (vtParam == VT_VARIANT)
                {
                    mappedParamType = "Variant";
                }
                else if (vtParam == VT_BOOL)
                {
                    mappedParamType = "Boolean";
                }
                else if (vtParam == VT_I4)
                {
                    mappedParamType = "long";
                }
                else if (vtParam == VT_I2)
                {
                    mappedParamType = "short";
                }
                else if (pHandler->params[j].vtParam == VT_ARRAY)
                {
                    mappedParamType = "String";			// ***TLL*** COM+: Need something different here for now it's a string.
                }
                else
                {
                    mappedParamType = (LPCSTR)pHandler->params[j].szCParamType;
                }
            }
            else
            {
                mappedParamType = (LPCSTR)pHandler->params[j].szCParamType;
            }

            fprintf (fpOut, ", %s " PARAM_NAME_PREFIX "%i", mappedParamType, j + 1);
            j++;
            cArgs++;
        }

        if (!(invokeType & ATYPE_ParametersOnly))
        {
            if (pHandler->vtResult != VT_EMPTY)
            {
                mappedParamType = ResultType(pHandler, codeType, &fAllocate);
                fprintf(fpOut, ", %s " PARAM_RESULT_PREFIX, mappedParamType);
            }
        }
        
        fprintf(fpOut, ")");
    }

    if (fAllocate)
    {
        delete [] (LPSTR)mappedParamType;
    }
}


void
OutputNDSignature(FILE *fpOut, DispatchHandler *pHandler, LPCSTR pPreHeader, CODETYPE codeType, NDBodyFunc pNDBodyFunc)
{
    BOOL	fSetDone = FALSE;
    int		invokeType = pHandler->invokeType;
    BOOL	fGetAndSet = ((invokeType & ATYPE_GetProperty) && (invokeType & ATYPE_SetProperty));		
    CString	funcName;

    if (!fGetAndSet)
    {
        if (AnyGSHandler(*pHandler))
            return;		
        
        if (codeType == CT_managedNDirect || codeType == CT_unmanaged)
        {
            fprintf(fpOut, "%s NDCP_%s (unsigned int myThis, unsigned int idxIID, unsigned int wVTblOffset", pPreHeader, (LPCSTR)(pHandler->szRawString));
        }
        else if (codeType == CT_managed)
        {
            if (!pNDBodyFunc)
                fprintf(fpOut, "\tstatic ");
            OutputParameters(fpOut, pHandler, codeType, ATYPE_ReturnValue);

            if (pNDBodyFunc)
                fprintf(fpOut, "\nCPThunks::");

            if (pHandler->szRawString[0] == 'G' || pHandler->szRawString[0] == 'S')
            {
                funcName = pHandler->szRawString[0] == 'G' ? "G_" : "S_";

                if (strcmp((LPCSTR)(pHandler->szRawString) + 2, "BSTR") == 0)
                {
                    funcName += "String";
                }
                else if (strcmp((LPCSTR)(pHandler->szRawString) + 2, "VARIANT") == 0)
                {
                    funcName += "Variant";
                }
                else if (strcmp((LPCSTR)(pHandler->szRawString) + 2, "VARIANTBOOL") == 0)
                {
                    funcName += "Boolean";
                }
                else if (strcmp((LPCSTR)(pHandler->szRawString) + 2, "IDispatchp") == 0 ||
                         strcmp((LPCSTR)(pHandler->szRawString) + 2, "IUnknownp") == 0)
                {
                    funcName += "Object";
                }
                else
                {
                    funcName = (LPCSTR)(pHandler->szRawString);
                }
            }
            else
            {
                funcName = (LPCSTR)(pHandler->szRawString);
            }

            fprintf(fpOut, "COMPLUS_%s (unsigned int myThis, unsigned int idxIID, unsigned int wVTblOffset", (LPCSTR)funcName);
            
            invokeType |= (~ATYPE_ReturnValue & ATYPE_ParametersOnly);
        }

        OutputParameters(fpOut, pHandler, codeType, invokeType);

        if (pNDBodyFunc)
        {
            fprintf(fpOut, "\n");

            (*pNDBodyFunc)(fpOut, pHandler, codeType, invokeType);

            fprintf(fpOut, "\n\n");
        }
        else
        {
            fprintf(fpOut, ";\n");
        }
    }
    else
    {
        if (codeType == CT_managed)
        {
            if (strcmp((LPCSTR)(pHandler->szRawString) + 3, "BSTR") == 0)
            {
                funcName = "_String";
            }
            else if (strcmp((LPCSTR)(pHandler->szRawString) + 3, "VARIANT") == 0)
            {
                funcName = "_Variant";
            }
            else if (strcmp((LPCSTR)(pHandler->szRawString) + 3, "VARIANTBOOL") == 0)
            {
                funcName = "_Boolean";
            }
            else
            {
                funcName = (LPCSTR)((pHandler->szRawString)) + 2;
            }
        }
        else
        {
            funcName = pHandler->szRawString;
        }
                
SpitOutAgain:
        if (!fSetDone && (pHandler->invokeType & ATYPE_GetProperty))
        {
            if (codeType == CT_managedNDirect || codeType == CT_unmanaged)
            {
                fprintf(fpOut, "%s NDCP_G%s (unsigned int myThis, unsigned int idxIID, unsigned int wVTblOffset", pPreHeader, (LPCSTR)((pHandler->szRawString)) + 2);
                OutputParameters(fpOut, pHandler, codeType, ATYPE_GetProperty);
            }
            else if (codeType == CT_managed)
            {
                if (!pNDBodyFunc)
                    fprintf(fpOut, "\tstatic ");

                OutputParameters(fpOut, pHandler, codeType, ATYPE_ReturnValue);

                if (pNDBodyFunc)
                    fprintf(fpOut, "\nCPThunks::");

                fprintf(fpOut, "COMPLUS_G%s (unsigned int myThis, unsigned int idxIID, unsigned int wVTblOffset)", (LPCSTR)funcName);
            }

            fSetDone = TRUE;

            if (pNDBodyFunc)
            {
                fprintf(fpOut, "\n");

                (*pNDBodyFunc)(fpOut, pHandler, codeType, ATYPE_GetProperty);

                fprintf(fpOut, "\n\n");
            }
            else
            {
                fprintf(fpOut, ";\n");
            }
            
            goto SpitOutAgain;
        }
        else if (pHandler->invokeType & ATYPE_SetProperty)
        {
            if (codeType == CT_managedNDirect || codeType == CT_unmanaged)
            {
                fprintf(fpOut, "%s NDCP_S%s (unsigned int myThis, unsigned int idxIID, unsigned int wVTblOffset", pPreHeader, (LPCSTR)((pHandler->szRawString)) + 2);
            }
            else if (codeType == CT_managed)
            {
                if (!pNDBodyFunc)
                {
                    fprintf(fpOut, "\tstatic void ");
                }
                else
                {
                    fprintf(fpOut, "void\nCPThunks::");
                }

                fprintf(fpOut, "COMPLUS_S%s (unsigned int myThis, unsigned int idxIID, unsigned int wVTblOffset", (LPCSTR)funcName);
            }

            OutputParameters(fpOut, pHandler, codeType, ATYPE_SetProperty);

            if (pNDBodyFunc)
            {
                fprintf(fpOut, "\n");

                (*pNDBodyFunc)(fpOut, pHandler, codeType, ATYPE_SetProperty);

                fprintf(fpOut, "\n\n");
            }
            else
            {
                fprintf(fpOut, ";\n");
            }
            
        }
    }
}


BOOL GenerateNDirectHeader (LPCSTR pszOutputPath)
{
    char    chNDDefFileName[255];
    FILE   *fpNDDefFile;

    strcpy(chNDDefFileName, pszOutputPath);
    strcat(chNDDefFileName, FILENAME_SEPARATOR_STR "ComPlsND.def");

    fpNDDefFile = fopen(chNDDefFileName, "w");
    if (!fpNDDefFile)
    {
        return FALSE;
    }

    fprintf(fpNDDefFile, "// Trident Def file NDirect functions.\n\n\n");

    // Spit out function signatures for NDirect functions.
    for (int i = 0; i < _cHandlers; i++)
    {
        BOOL	fSetDone = FALSE;
        BOOL	fGetAndSet = ((_allHandlers[i].invokeType & ATYPE_GetProperty) && (_allHandlers[i].invokeType & ATYPE_SetProperty));		

        if (!fGetAndSet)
        {
            if (!AnyGSHandler(_allHandlers[i]))
            {			
                fprintf(fpNDDefFile, "NDCP_%s\t\tPRIVATE\n", (LPCSTR)(_allHandlers[i].szRawString));
            }
        }
        else
        {
SpitOutAgain:
            if (!fSetDone && (_allHandlers[i].invokeType & ATYPE_GetProperty))
            {
                fprintf(fpNDDefFile, "NDCP_G%s\t\tPRIVATE\n", (LPCSTR)((_allHandlers[i].szRawString)) + 2);
                fSetDone = TRUE;		
                goto SpitOutAgain;
            }
            else if (_allHandlers[i].invokeType & ATYPE_SetProperty)
            {
                fprintf(fpNDDefFile, "NDCP_S%s\t\tPRIVATE\n", (LPCSTR)((_allHandlers[i].szRawString)) + 2);
            }
        }

    }

    fclose(fpNDDefFile);

    return TRUE;
}


void GenerateNDBody(FILE *fpOut, DispatchHandler *pHandler, CODETYPE codeType, int invokeType)
{
    fprintf(fpOut, "{\n");

    fprintf(fpOut, "\ttypedef HRESULT (STDMETHODCALLTYPE *OLEVTblPropFunc)(IDispatch *");
    OutputParameters(fpOut, pHandler, codeType, invokeType);
    fprintf(fpOut, ";\n\n");

    fprintf(fpOut, "\tHRESULT\t\t\thr;\n\tIUnknown\t\t*pUnknownInstance;\n\tIDispatch\t\t*pInstance = 0;\n\tVTABLE_ENTRY\t*pVTbl;\n\n");

    fprintf(fpOut, "\tAssert(myThis);\n\n");

    fprintf(fpOut, "\tpUnknownInstance = (IUnknown *)myThis;\n\n");

    fprintf(fpOut, "\tAssert(idxIID <= MAX_IIDS);\n");
    fprintf(fpOut, "\thr = pUnknownInstance->QueryInterface(*_IIDTable[idxIID], (void **)&pInstance);\n");
    fprintf(fpOut, "\tif (hr)\n");
    fprintf(fpOut, "\t\tgoto Cleanup;\n\n");
    fprintf(fpOut, "\tpVTbl = (VTABLE_ENTRY *)(((BYTE *)(*(DWORD_PTR *)pInstance)) + (wVTblOffset*sizeof(VTABLE_ENTRY)/sizeof(DWORD_PTR) + FIRST_VTABLE_OFFSET));\n");

    fprintf(fpOut, "\thr = (*(OLEVTblPropFunc)VTBL_PFN(pVTbl))((IDispatch*) VTBL_THIS(pVTbl,pInstance)");
    if (invokeType & ATYPE_GetProperty)
    {
        fprintf(fpOut, ", resultParam");
    }
    else if (invokeType & ATYPE_SetProperty)
    {
        fprintf(fpOut, ", param1");
    }
    else
    {
        int i = 0;

        while (pHandler->params[i++].szVTParamType.Length())
        {
            fprintf (fpOut, ", param%i", i);
        }

        if (pHandler->vtResult != VT_EMPTY)
        {
            fprintf(fpOut, ", resultParam");
        }
    }
    
    fprintf(fpOut, ");\n\n");

    fprintf(fpOut, "\tpInstance->Release();\n\n");

    fprintf(fpOut, "Cleanup:\n\treturn hr;\n");

    fprintf(fpOut, "}\n");
}


BOOL GenerateNDirectCXX (LPCSTR pszOutputPath)
{
    char    chNDCXXFileName[255];
    FILE   *fpNDCXXFile;

    strcpy(chNDCXXFileName, pszOutputPath);
    strcat(chNDCXXFileName, FILENAME_SEPARATOR_STR "funcND.cpp");

    fpNDCXXFile = fopen(chNDCXXFileName, "w");
    if (!fpNDCXXFile)
    {
        return FALSE;
    }

    fprintf(fpNDCXXFile, "// Trident NDirect functions source file.\n\n\n");

    // Spit out function signatures for NDirect functions.
    for (int i = 0; i < _cHandlers; i++)
    {
        OutputNDSignature(fpNDCXXFile, &(_allHandlers[i]), "STDAPI ", CT_unmanaged, GenerateNDBody);
    }

    fclose(fpNDCXXFile);

    return TRUE;
}


void GenerateManagedThunkBody(FILE *fpOut, DispatchHandler *pHandler, CODETYPE codeType, int invokeType)
{
    CString		szAfterBlock;
    CString		szResult;

    fprintf(fpOut, "{\n");

    fprintf(fpOut, "\tif (myThis)\n");
    fprintf(fpOut, "\t{\n");
    fprintf(fpOut, "\t\tHRESULT\thr;\n");

    // Spit out the getter body.
    if (invokeType & ATYPE_GetProperty)
    {
        if ((pHandler->vtResult & VT_TYPEMASK) == VT_BSTR)
        {
            fprintf(fpOut, "\t\twchar_t\t*bstrString = 0;\n\n");
            fprintf(fpOut, "\t\thr = CustomInvoke::NDCP_G_BSTR(myThis, idxIID, wVTblOffset, &bstrString);\n\n");
            fprintf(fpOut, "\t\tString pString = CustomInvoke::BSTRToString(bstrString, 1);\n\n");
            fprintf(fpOut, "\t\treturn pString;\n");

            szAfterBlock = "\treturn 0;\n";
        }
        else if ((pHandler->vtResult & VT_TYPEMASK) == VT_DISPATCH)
        {
            fprintf(fpOut, "\t\tunsigned int\tmyPDispatch = 0;\n\n");
            fprintf(fpOut, "\t\thr = CustomInvoke::NDCP_G_IDispatchp(myThis, idxIID, wVTblOffset, &myPDispatch);\n\n");
            fprintf(fpOut, "\t\treturn myPDispatch;\n");

            szAfterBlock = "\treturn 0;\n";
        }
        else if ((pHandler->vtResult & VT_TYPEMASK) == VT_UNKNOWN)
        {
            fprintf(fpOut, "\t\tunsigned int\tmyPUnknown = 0;\n\n");
            fprintf(fpOut, "\t\thr = CustomInvoke::NDCP_G_IUnknownp(myThis, idxIID, wVTblOffset, &myPUnknown);\n\n");
            fprintf(fpOut, "\t\treturn myPUnknown;\n");

            szAfterBlock = "\treturn 0;\n";
        }
        else if ((pHandler->vtResult & VT_TYPEMASK) == VT_BOOL)
        {
            fprintf(fpOut, "\t\tshort\tmyCOMBool = 0;\n");
            fprintf(fpOut, "\t\tBoolean\tmyCPBool = 0;\n\n");
            fprintf(fpOut, "\t\thr = CustomInvoke::NDCP_G_VARIANTBOOL(myThis, idxIID, wVTblOffset, &myCOMBool);\n\n");
            fprintf(fpOut, "\t\treturn myCPBool;\n");

            szAfterBlock = "\treturn 0;\n";
        }
        else if ((pHandler->vtResult & VT_TYPEMASK) == VT_VARIANT)
        {
//
// COM+ Need to fix dispatch getter to return this as unsigned int and have the actual COM+ function create the
//      COM+ Variant.
//
            fprintf(fpOut, "\t\tunsigned int myPDispatch;\n");
            fprintf(fpOut, "\t\tVariant myVariant;\n");

            fprintf(fpOut, "\t\thr = CustomInvoke::NDCP_G_VARIANT(myThis, idxIID, wVTblOffset, &myPDispatch);\n\n");
            fprintf(fpOut, "\t\treturn myVariant;\n");

            szAfterBlock = "\treturn 0;\n";
        }
        else
        {
            if (pHandler->szCResult == "LONG")
            {
                szResult = "long";
            }
            else if (pHandler->szCResult == "SHORT")
            {
                szResult = "short";
            }
            else
            {
                szResult = pHandler->szCResult;
            }

            fprintf(fpOut, "\t\t%s\treturnValue = 0;\n\n", (LPCSTR)szResult);
            fprintf(fpOut, "\t\thr = CustomInvoke::NDCP_G_%s(myThis, idxIID, wVTblOffset, &returnValue);\n\n", (LPCSTR)szResult);
            fprintf(fpOut, "\t\treturn returnValue;\n");

            szAfterBlock = "\treturn 0;\n";
        }
    }

    // Spit out the setter body.
    if (invokeType & ATYPE_SetProperty)
    {
        if ((pHandler->vtResult & VT_TYPEMASK) == VT_BSTR)
        {
            fprintf(fpOut, "\t\twchar_t\t*bstrString = 0;\n\n");
            fprintf(fpOut, "\t\tbstrString = CustomInvoke::StringToBSTR(param1);\n");
            fprintf(fpOut, "\t\thr = CustomInvoke::NDCP_S_BSTR(myThis, idxIID, wVTblOffset, bstrString);\n\n");
            fprintf(fpOut, "\t\tCustomInvoke::SysFreeString(bstrString);\n");
        }
        else if ((pHandler->vtResult & VT_TYPEMASK) == VT_DISPATCH)
        {
            fprintf(fpOut, "\t\thr = CustomInvoke::NDCP_S_IDispatchp(myThis, idxIID, wVTblOffset, param1);\n\n");
        }
        else if ((pHandler->vtResult & VT_TYPEMASK) == VT_UNKNOWN)
        {
            fprintf(fpOut, "\t\thr = CustomInvoke::NDCP_S_IUnknownpp(myThis, idxIID, wVTblOffset, param1);\n\n");
        }
        else if ((pHandler->vtResult & VT_TYPEMASK) == VT_VARIANT)
        {
            fprintf(fpOut, "\t\tunsigned myCOMVariant = 0;\n\n");
            fprintf(fpOut, "\t\thr = CustomInvoke::NDCP_S_VARIANT(myThis, idxIID, wVTblOffset, myCOMVariant);\n\n");
        }
        else if ((pHandler->vtResult & VT_TYPEMASK) == VT_BOOL)
        {
            fprintf(fpOut, "\t\tshort myCOMBool = 0;\n\n");
            fprintf(fpOut, "\t\thr = CustomInvoke::NDCP_S_VARIANTBOOL(myThis, idxIID, wVTblOffset, myCOMBool);\n\n");
        }
        else
        {
            if (pHandler->szCResult == "LONG")
            {
                szResult = "long";
            }
            else if (pHandler->szCResult == "SHORT")
            {
                szResult = "short";
            }
            else
            {
                szResult = pHandler->szCResult;
            }

            fprintf(fpOut, "\t\thr = CustomInvoke::NDCP_S_%s(myThis, idxIID, wVTblOffset, param1);\n\n", (LPCSTR)szResult);
        }
    }

    // Spit out the method body.
    if (invokeType & ATYPE_Method)
    {
		// ***TLL*** COM+: Just look for one parameter BSTR
        if (pHandler->params[0].szVTParamType.Length() && !pHandler->params[1].szVTParamType.Length())
		{
			if (pHandler->params[0].vtParam == VT_BSTR)
			{
				fprintf(fpOut, "\t\twchar_t	*bstrString = 0;\n\n");

				fprintf(fpOut, "\t\tbstrString = CustomInvoke::StringToBSTR(param1);\n");
				fprintf(fpOut, "\t\thr = CustomInvoke::NDCP_Method_void_BSTR(myThis, idxIID, wVTblOffset, bstrString);\n\n");

				fprintf(fpOut, "\t\tCustomInvoke::SysFreeString(bstrString);\n");
			}
		}

		//  ***TLL*** COM+: Need to do.
        // If no void result then return 0 for now.
        if ((pHandler->vtResult & VT_TYPEMASK) != VT_EMPTY)
            szAfterBlock = "\treturn 0;\n";
    }	
    
    fprintf(fpOut, "\t}\n");

    fprintf(fpOut, (LPCSTR)szAfterBlock);

    fprintf(fpOut, "}\n");
}


BOOL GenerateComPlusHeader (LPCSTR pszOutputPath)
{
    char    chCPHeaderFileName[255];
    FILE   *fpCPHeaderFile;
    int     i;

    strcpy(chCPHeaderFileName, pszOutputPath);
    strcat(chCPHeaderFileName, FILENAME_SEPARATOR_STR "TComPlus.hxx");

    fpCPHeaderFile = fopen(chCPHeaderFileName, "w");
    if (!fpCPHeaderFile)
    {
        return FALSE;
    }

    fprintf(fpCPHeaderFile, "// Trident COM+ Header file.\n\n\n");

    fprintf(fpCPHeaderFile, "[managed,coclass] class CustomInvoke {\n");
    fprintf(fpCPHeaderFile, "public:\n");
    fprintf(fpCPHeaderFile, "\t// Function signatures:\n");


    // Spit out COM+ NDirect signatures
    for (i = 0; i < _cHandlers; i++)
    {
        OutputNDSignature(fpCPHeaderFile, &(_allHandlers[i]), "\t[sysimport(dll=\"mshtml.dll\")]\n\tstatic HRESULT ", CT_managedNDirect, NULL);
    }

    fprintf(fpCPHeaderFile, "\n");

    // Output misc. conversion routines:
    fprintf(fpCPHeaderFile, "\t// Conversion routines:\n");
    fprintf(fpCPHeaderFile, "\tstatic String BSTRToString(wchar_t* myBSTR, int fFreeBSTR);\n");
    fprintf(fpCPHeaderFile, "\tstatic wchar_t* StringToBSTR(String myString);\n");
    fprintf(fpCPHeaderFile, "\tstatic unsigned int VariantToVARIANT(Variant myVariant);\n");
    fprintf(fpCPHeaderFile, "\tstatic void VariantClear(unsigned int myCOMVariant);\n\n");
    fprintf(fpCPHeaderFile, "\t// Misc BSTR routines:\n");
    fprintf(fpCPHeaderFile, "\t[sysimport(dll=\"oleaut32.dll\")]\n");
    fprintf(fpCPHeaderFile, "\tstatic wchar_t* SysAllocStringLen(wchar_t *pch, unsigned int cch);\n\n");
    fprintf(fpCPHeaderFile, "\t[sysimport(dll=\"oleaut32.dll\")]\n");
    fprintf(fpCPHeaderFile, "\tstatic void SysFreeString(wchar_t *myBSTR);\n\n");
    fprintf(fpCPHeaderFile, "\t// Misc VARIANT routines:\n");
    fprintf(fpCPHeaderFile, "\t[sysimport(dll=\"oleaut32.dll\", name=\"SysAllocStringLen\")]\n");
    fprintf(fpCPHeaderFile, "\tstatic unsigned int AllocVariant(wchar_t *pch, unsigned int cch);\n\n");
    fprintf(fpCPHeaderFile, "\t[sysimport(dll=\"oleaut32.dll\")]\n");
    fprintf(fpCPHeaderFile, "\tstatic void VariantInit(unsigned int);\n\n");
    fprintf(fpCPHeaderFile, "\t[sysimport(dll=\"oleaut32.dll\", name=\"SysFreeString\")]\n");
    fprintf(fpCPHeaderFile, "\tstatic void FreeVariant(wchar_t *myBSTR);\n");

    fprintf(fpCPHeaderFile, "};\n\n");

    fprintf(fpCPHeaderFile, "[managed,coclass] class CPThunks {\n");
    fprintf(fpCPHeaderFile, "public:\n");
    fprintf(fpCPHeaderFile, "\t// Function signatures:\n");

    // Spit out COM+ thunks for each signature type
    for (i = 0; i < _cHandlers; i++)
    {
        OutputNDSignature(fpCPHeaderFile, &(_allHandlers[i]), "", CT_managed, NULL);
    }

    fprintf(fpCPHeaderFile, "};\n\n");

    fclose(fpCPHeaderFile);

    return TRUE;
}


BOOL GenerateComPlusCXX (LPCSTR pszOutputPath)
{
    char    chCPCXXFileName[255];
    FILE   *fpCPCXXFile;

    strcpy(chCPCXXFileName, pszOutputPath);
    strcat(chCPCXXFileName, FILENAME_SEPARATOR_STR "TComPlus.cpp");

    fpCPCXXFile = fopen(chCPCXXFileName, "w");
    if (!fpCPCXXFile)
    {
        return FALSE;
    }

    fprintf(fpCPCXXFile, "// Trident COM+ source file.\n\n\n");

    fprintf(fpCPCXXFile, "#import <mscorlib.dll>\n");
    fprintf(fpCPCXXFile, "#include <crt.h>\n");
    fprintf(fpCPCXXFile, "#include \"TComPlus.hxx\"\n\n\n");

    // Spit out COM+ thunks for each signature type
    for (int i = 0; i < _cHandlers; i++)
    {
        OutputNDSignature(fpCPCXXFile, &(_allHandlers[i]), "", CT_managed, GenerateManagedThunkBody);
    }

    // Output conversion routines:
    fprintf(fpCPCXXFile, "\n\n");
    fprintf(fpCPCXXFile, "//////////////////////////////////////////////////////////////////////////\n");
    fprintf(fpCPCXXFile, "//////////////////////////////////////////////////////////////////////////\n");
    fprintf(fpCPCXXFile, "//																		//\n");
    fprintf(fpCPCXXFile, "//																		//\n");
    fprintf(fpCPCXXFile, "//	Conversion routines:												//\n");
    fprintf(fpCPCXXFile, "//																		//\n");
    fprintf(fpCPCXXFile, "//																		//\n");
    fprintf(fpCPCXXFile, "//////////////////////////////////////////////////////////////////////////\n");
    fprintf(fpCPCXXFile, "//////////////////////////////////////////////////////////////////////////\n\n\n");

    fprintf(fpCPCXXFile, "String\n");
    fprintf(fpCPCXXFile, "CustomInvoke::BSTRToString(wchar_t *myBSTR, int fFreeBSTR)\n");
    fprintf(fpCPCXXFile, "{\n");
    fprintf(fpCPCXXFile, "\tString pString(\"\");\n\n");
    fprintf(fpCPCXXFile, "\tif (myBSTR)\n");
    fprintf(fpCPCXXFile, "\t{\n");
    fprintf(fpCPCXXFile, "\t\tpString = Interop.PInvoke.PtrToStringAuto((int)myBSTR);\n");
    fprintf(fpCPCXXFile, "\t\tif (fFreeBSTR)\n");
    fprintf(fpCPCXXFile, "\t\t{\n");
    fprintf(fpCPCXXFile, "\t\t\tSysFreeString(myBSTR);\n");
    fprintf(fpCPCXXFile, "\t\t}\n");
    fprintf(fpCPCXXFile, "\t}\n\n");
    fprintf(fpCPCXXFile, "\treturn pString;\n");
    fprintf(fpCPCXXFile, "}\n\n\n");


    fprintf(fpCPCXXFile, "wchar_t*\n");
    fprintf(fpCPCXXFile, "CustomInvoke::StringToBSTR(String myString)\n");
    fprintf(fpCPCXXFile, "{\n");
    fprintf(fpCPCXXFile, "\twchar_t *myBSTR = 0;\n");
    fprintf(fpCPCXXFile, "\tint	cch;\n\n");

    fprintf(fpCPCXXFile, "\tcch = myString.GetLength();\n");
    
    fprintf(fpCPCXXFile, "\tmyBSTR = CustomInvoke::SysAllocStringLen(0, cch);\n");
    fprintf(fpCPCXXFile, "\tif (myBSTR)\n");
    fprintf(fpCPCXXFile, "\t{\n");
    fprintf(fpCPCXXFile, "\t\tunsigned int	i = 0;\n\n");

    fprintf(fpCPCXXFile, "\t\twhile (cch-- > 0)\n");
    fprintf(fpCPCXXFile, "\t\t{\n");
    fprintf(fpCPCXXFile, "\t\t\t*(myBSTR + i) = myString.GetChar(i);\n");
    fprintf(fpCPCXXFile, "\t\t\ti++;\n");
    fprintf(fpCPCXXFile, "\t\t};\n");
    fprintf(fpCPCXXFile, "\t}\n\n");

    fprintf(fpCPCXXFile, "\treturn myBSTR;\n");
    fprintf(fpCPCXXFile, "}\n\n");

    fprintf(fpCPCXXFile, "unsigned int\n");
    fprintf(fpCPCXXFile, "CustomInvoke::VariantToVARIANT(Variant myVariant)\n");
    fprintf(fpCPCXXFile, "{\n");
    fprintf(fpCPCXXFile, "\treturn 0;\n");
    fprintf(fpCPCXXFile, "}\n\n");

    fprintf(fpCPCXXFile, "void\n");
    fprintf(fpCPCXXFile, "CustomInvoke::VariantClear(unsigned int myCOMVariant)\n");
    fprintf(fpCPCXXFile, "{\n");
    fprintf(fpCPCXXFile, "\n\n");
    fprintf(fpCPCXXFile, "}\n\n");

    // Close file.
    fclose(fpCPCXXFile);

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////
//                                     End of COM+ code                                     //
//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////


#endif // COMPLUS_SHIM


BOOL GenerateVTableHeader  ( LPCSTR pszOutputPath )
{
    char    chHeaderFileName[255];
    FILE   *fpHeaderFile;
    int     i;

    strcpy(chHeaderFileName, pszOutputPath);
    strcat(chHeaderFileName, FILENAME_SEPARATOR_STR "funcsig.hxx");

    fpHeaderFile = fopen ( chHeaderFileName, "w" );
    if ( !fpHeaderFile )
    {
        return FALSE;
    }

    fprintf ( fpHeaderFile, "BOOL DispNonDualDIID(IID iid);\n" );

    fprintf ( fpHeaderFile, "typedef HRESULT (*CustomHandler)(CBase *pBase,\n" );
    fprintf ( fpHeaderFile, "                                 IServiceProvider *pSrvProvider,\n" );
    fprintf ( fpHeaderFile, "                                 IDispatch *pInstance,\n" );
    fprintf ( fpHeaderFile, "                                 WORD wVTblOffset,\n" );
    fprintf ( fpHeaderFile, "                                 PROPERTYDESC_BASIC_ABSTRACT *pDesc,\n" );
    fprintf ( fpHeaderFile, "                                 WORD wFlags,\n" );
    fprintf ( fpHeaderFile, "                                 DISPPARAMS *pdispparams,\n" );
    fprintf ( fpHeaderFile, "                                 VARIANT *pvarResult);\n\n\n" );

    // Spit out function signatures for handlers.
    for (i = 0; i < _cHandlers; i++)
    {
        fprintf ( fpHeaderFile, "HRESULT %s (CBase *pBase,\n", (LPCSTR)(_allHandlers[i].szRawString) );
        fprintf ( fpHeaderFile, "            IServiceProvider *pSrvProvider,\n" );
        fprintf ( fpHeaderFile, "            IDispatch *pInstance,\n" );
        fprintf ( fpHeaderFile, "            WORD wVTblOffset,\n" );
        fprintf ( fpHeaderFile, "            PROPERTYDESC_BASIC_ABSTRACT *pDesc,\n" );
        fprintf ( fpHeaderFile, "            WORD wFlags,\n" );
        fprintf ( fpHeaderFile, "            DISPPARAMS *pdispparams,\n" );
        fprintf ( fpHeaderFile, "            VARIANT *pvarResult);\n\n" );
    }

    fprintf ( fpHeaderFile, "\n" );

    // Spit out indexes into handler table.
    for (i = 0; i < _cHandlers; i++)
    {
        fprintf ( fpHeaderFile, "#define \tIDX_%s \t%i\n", (LPCSTR)(_allHandlers[i].szRawString), i );
    }

    fclose ( fpHeaderFile );

    return TRUE;
}


void GenerateFunctionBody ( FILE * fpCXXFile, DispatchHandler *pHandler)
{
    if ((pHandler->invokeType & ATYPE_GetProperty) || (pHandler->invokeType & ATYPE_SetProperty))
    {
        BOOL    fObjectRet = FALSE;
        BOOL    fBSTRParam = FALSE;
        BOOL    fGetAndSet = (pHandler->invokeType & ATYPE_GetProperty) &&
                             (pHandler->invokeType & ATYPE_SetProperty);
        BOOL    fGS_BSTR    = pHandler->szRawString == "GS_BSTR";
        BOOL    fGS_VARIANT = pHandler->szRawString == "GS_VARIANT";
        BOOL    fGS_PropEnum = pHandler->szRawString == "GS_PropEnum";
        char    chIdent[16];

        chIdent[0] = '\0';

        // Does the property muck with an object?
        fObjectRet = ((pHandler->vtResult & VT_TYPEMASK) == VT_UNKNOWN) ||
                      ((pHandler->vtResult & VT_TYPEMASK) == VT_DISPATCH);
        fBSTRParam = ((pHandler->vtResult & VT_TYPEMASK) == VT_BSTR);

        if (pHandler->invokeType & ATYPE_GetProperty)
        {
            fprintf ( fpCXXFile, "    typedef HRESULT (STDMETHODCALLTYPE *OLEVTbl%sPropFunc)(IDispatch *, %s *);\n", fGetAndSet ? "Get" : "", (LPCSTR)pHandler->szCResult );
        }
        if (pHandler->invokeType & ATYPE_SetProperty)
        {
            fprintf ( fpCXXFile, "    typedef HRESULT (STDMETHODCALLTYPE *OLEVTbl%sPropFunc)(IDispatch *, %s);\n", fGetAndSet ? "Set" : "", (LPCSTR)pHandler->szCResult );
        }
        fprintf ( fpCXXFile, "\n" );

        fprintf ( fpCXXFile, "    HRESULT         hr;\n" );

        // Any IDispatch* or IUnknown* arguments?  If so then possible
        // creation of BSTR/object needs to be handled.
        if ((pHandler->invokeType & ATYPE_SetProperty) && (fObjectRet || fBSTRParam || fGS_VARIANT))
        {
            fprintf ( fpCXXFile, "    ULONG   ulAlloc = 0;\n" );
        }

        if (pHandler->invokeType & ATYPE_GetProperty)
        {
            fprintf ( fpCXXFile, "    VTABLE_ENTRY *pVTbl;\n");
        }
        else if (pHandler->invokeType & ATYPE_SetProperty)
        {
            fprintf ( fpCXXFile, "    VTABLE_ENTRY *pVTbl;\n");
        }
        fprintf ( fpCXXFile, "    VARTYPE         argTypes[] = { %s };\n", (LPCSTR)pHandler->szVTResult );

        if (pHandler->invokeType & ATYPE_SetProperty && pHandler->szCResult.Length() > 0)
        {
            fprintf ( fpCXXFile, "    %s    param1;\n", (LPCSTR)pHandler->szCResult );
        }

        fprintf ( fpCXXFile, "\n    Assert(pInstance || pDesc || pdispparams);\n\n" );

        if (pHandler->invokeType & ATYPE_GetProperty)
        {
            fprintf ( fpCXXFile, "    pVTbl = (VTABLE_ENTRY *)(((BYTE *)(*(DWORD_PTR *)pInstance)) + (wVTblOffset*sizeof(VTABLE_ENTRY)/sizeof(DWORD_PTR) + FIRST_VTABLE_OFFSET));\n\n");
        }
        else if (pHandler->invokeType & ATYPE_SetProperty)
        {
            fprintf ( fpCXXFile, "    pVTbl = (VTABLE_ENTRY *)(((BYTE *)(*(DWORD_PTR *)pInstance)) + (wVTblOffset*sizeof(VTABLE_ENTRY)/sizeof(DWORD_PTR) + FIRST_VTABLE_OFFSET));\n\n");
        }

        if ((pHandler->invokeType & ATYPE_GetProperty) && (pHandler->invokeType & ATYPE_SetProperty))
        {
            fprintf ( fpCXXFile, "    if (wFlags & INVOKE_PROPERTYGET)\n" );
            fprintf ( fpCXXFile, "    {\n" );
            strcpy( chIdent, "    " );
        }

        if (pHandler->invokeType & ATYPE_GetProperty)
        {
            if ((pHandler->szCResult.Length() > 0) && (pHandler->vtResult != VT_VARIANT))
            {
                fprintf ( fpCXXFile, "%s    hr = (*(OLEVTbl%sPropFunc)VTBL_PFN(pVTbl))((IDispatch*) VTBL_THIS(pVTbl,pInstance), (%s *)&pvarResult->iVal);\n", chIdent, fGetAndSet ? "Get" : "", (LPCSTR)pHandler->szCResult);
                fprintf ( fpCXXFile, "%s    if (!hr)\n", chIdent );
                fprintf ( fpCXXFile, "%s        V_VT(pvarResult) = argTypes[0];\n", chIdent );
            }
            else
            {
                fprintf ( fpCXXFile, "%s    hr = (*(OLEVTbl%sPropFunc)VTBL_PFN(pVTbl))((IDispatch*)VTBL_THIS(pVTbl, pInstance), pvarResult);\n", chIdent, fGetAndSet ? "Get" : "");
            }
        }

        if ((pHandler->invokeType & ATYPE_GetProperty) && (pHandler->invokeType & ATYPE_SetProperty))
        {
            fprintf ( fpCXXFile, "    }\n" );
            fprintf ( fpCXXFile, "    else\n" );
            fprintf ( fpCXXFile, "    {\n" );
        }

        if (pHandler->invokeType & ATYPE_SetProperty)
        {
            if (pHandler->szCResult.Length() > 0)
            {
                fprintf ( fpCXXFile, "%s     // Convert dispatch params to C params.\n", chIdent );
                fprintf ( fpCXXFile, "%s     hr = DispParamsToCParams(pSrvProvider, pdispparams, ", chIdent);
                if (fObjectRet || fBSTRParam || fGS_VARIANT)
                    fprintf ( fpCXXFile, "&ulAlloc, " );    // Keep track of all allocation.
                else
                    fprintf ( fpCXXFile, "0L, " );

                if (fGS_BSTR || fGS_VARIANT || fGS_PropEnum)
                    fprintf ( fpCXXFile, "((PROPERTYDESC_BASIC_ABSTRACT *)pDesc)->b.wMaxstrlen, " );
                else
                    fprintf ( fpCXXFile, "0, " );
                
                fprintf ( fpCXXFile, "argTypes, &param1, -1);\n" );

                fprintf ( fpCXXFile, "%s     if (hr)\n", chIdent );
                fprintf ( fpCXXFile, "%s         pBase->SetErrorInfo(hr);\n", chIdent );
                fprintf ( fpCXXFile, "%s     else\n", chIdent );
                if (fGetAndSet)
                {
                    fprintf ( fpCXXFile, "%s         hr = (*(OLEVTblSetPropFunc)VTBL_PFN(pVTbl))((IDispatch*)VTBL_THIS(pVTbl,pInstance), (%s)param1);\n", chIdent, (LPCSTR)pHandler->szCResult);
                }
                else
                {
                    fprintf ( fpCXXFile, "%s         hr = (*(OLEVTblPropFunc)VTBL_PFN(pVTbl))((IDispatch*)VTBL_THIS(pVTbl,pInstance), (%s)param1);\n", chIdent, (LPCSTR)pHandler->szCResult);
                }
            }
            else
            {
                fprintf ( fpCXXFile, "%s     hr = (*(OLEVTblPropFunc)VTBL_PFN(pVTbl))((IDispatch*)VTBL_THIS(pVTbl,pInstance), pdispparams[0]);\n", chIdent );
            }
        }

        if ((pHandler->invokeType & ATYPE_GetProperty) && (pHandler->invokeType & ATYPE_SetProperty))
        {
            fprintf ( fpCXXFile, "    }\n" );
        }

        if ((pHandler->invokeType & ATYPE_SetProperty) && (fObjectRet || fBSTRParam || fGS_VARIANT))
        {
            if (fGS_VARIANT)
                fprintf ( fpCXXFile, "    if (ulAlloc)\n" );
            else 
                fprintf ( fpCXXFile, "    if (ulAlloc && param1)\n" );

            if (fObjectRet)
            {
                fprintf ( fpCXXFile, "        param1->Release();\n");
            }
            else if (fBSTRParam)
            {
                fprintf ( fpCXXFile, "        SysFreeString(param1);\n");
            }
            else if (fGS_VARIANT)
            {
                fprintf ( fpCXXFile, "    {\n" );
                fprintf ( fpCXXFile, "        Assert(V_VT(&param1) == VT_BSTR);\n" );
                fprintf ( fpCXXFile, "        SysFreeString(V_BSTR(&param1));\n" );
                fprintf ( fpCXXFile, "    }\n" );
            }
        }

        fprintf ( fpCXXFile, "\n    return hr;\n" );
    }
    else if ( pHandler->invokeType & ATYPE_Method )
    {
        // We've got a method to spit out.
        char    chVARMacro[16];
        int     i;
        BOOL    fParamConvert;
        BOOL    fBSTRParam = FALSE;
        BOOL    fObjectParam = FALSE;
        BOOL    fVariantParam = FALSE;
        int     cArgs;

        if (pHandler->vtResult & VT_BYREF)
        {
            strcpy(chVARMacro, "V_BYREF");
        }
        else
        {
            switch (pHandler->vtResult & VT_TYPEMASK) {
            case VT_EMPTY:
                strcpy(chVARMacro, "");
                break;
            case VT_I2:
                strcpy(chVARMacro, "V_I2");
                break;
            case VT_I4:
                strcpy(chVARMacro, "V_I4");
                break;
            case VT_R4:
                strcpy(chVARMacro, "V_R4");
                break;
            case VT_R8:
                strcpy(chVARMacro, "V_R8");
                break;
            case VT_CY:
                strcpy(chVARMacro, "V_CY");
                break;
            case VT_BSTR:
                strcpy(chVARMacro, "V_BSTR");
                break;
            case VT_DISPATCH:
            case VT_VARIANT:
            case VT_UNKNOWN:
                strcpy(chVARMacro, "V_BYREF");
                break;
            case VT_BOOL:
                strcpy(chVARMacro, "V_BOOL");
                break;
            default:
                strcpy(chVARMacro, "Unsupported");
            }
        }

        fprintf ( fpCXXFile, "    typedef HRESULT (STDMETHODCALLTYPE *MethodOLEVTblFunc)(IDispatch *" );

        i = 0;
        cArgs = 0;
        while ( pHandler->params[i].szVTParamType.Length() )
        {
            fprintf ( fpCXXFile, ", %s", (LPCSTR)pHandler->params[i].szCParamType );
            i++;
            cArgs++;
        }

        if ( pHandler->vtResult != VT_EMPTY )
        {
            fprintf ( fpCXXFile, ", %s", (LPCSTR)pHandler->szCResult );
        }

        fprintf ( fpCXXFile, ");\n\n" );

        fprintf ( fpCXXFile, "    HRESULT               hr;\n" );
        fprintf ( fpCXXFile, "    VTABLE_ENTRY     *pVTbl;\n" );

        fParamConvert = cArgs;

        // Any paramters?
        if (fParamConvert)
        {
            int     iDefIndex;

            fprintf ( fpCXXFile, "    VARTYPE               argTypes[] = {\n" );

            i = 0;
            while ( pHandler->params[i].szVTParamType.Length() )
            {
                fprintf ( fpCXXFile, "                                %s,\n",
                          (LPCSTR)pHandler->params[i].szVTParamType );
                i++;
            }

            fprintf ( fpCXXFile, "                          };\n" );

            i = 0;
            iDefIndex = 0;
            while ( pHandler->params[i].szVTParamType.Length() )
            {
                fBSTRParam |= ((pHandler->params[i].vtParam & VT_TYPEMASK) == VT_BSTR);
                fVariantParam |= ((pHandler->params[i].vtParam & VT_TYPEMASK) == VT_VARIANT);
                fObjectParam |= ((pHandler->params[i].vtParam & VT_TYPEMASK) == VT_UNKNOWN) ||
                                ((pHandler->params[i].vtParam & VT_TYPEMASK) == VT_DISPATCH);

                if (pHandler->params[i].fOptional)
                {
                    if (pHandler->params[i].vtParam == (VT_VARIANT | VT_BYREF))
                    {
                        fprintf ( fpCXXFile, "    CVariant   param%iopt(VT_ERROR);      // optional variant\n", i + 1 );
                        fprintf ( fpCXXFile, "    VARIANT   *param%i = &param%iopt;      // optional arg.\n", i + 1, i + 1 );
                    }
                    else if (pHandler->params[i].vtParam == VT_VARIANT)
                    {
                        fprintf ( fpCXXFile, "    VARIANT    param%i;    // optional arg.\n", i + 1 );
                    }
                    else
                    {
                        // error, only VARIANT and VARIANT * can be optional.
                        PDLError("optional only allowed for VARIANT and VARIANT *");
                        return;
                    }
                }
                else if (pHandler->params[i].fDefaultValue)
                {
                    if (pHandler->params[i].vtParam == VT_BSTR)
                    {
                        fprintf ( fpCXXFile, "    %s    paramDef%i = SysAllocString((TCHAR *)(((PROPERTYDESC_METHOD *)pDesc)->c->defargs[%i]));\n",
                                  (LPCSTR)pHandler->params[i].szCParamType,
                                  i + 1,
                                  iDefIndex );
                        fprintf ( fpCXXFile, "    %s    param%i = paramDef%i;\n",
                                  (LPCSTR)pHandler->params[i].szCParamType,
                                  i + 1,
                                  i + 1);
                    }
                    else
                    {
                        fprintf ( fpCXXFile, "    %s    param%i = (%s)(((PROPERTYDESC_METHOD *)pDesc)->c->defargs[%i]);\n",
                                  (LPCSTR)pHandler->params[i].szCParamType,
                                  i + 1,
                                  (LPCSTR)pHandler->params[i].szCParamType,
                                  iDefIndex );
                    }

                    iDefIndex++;
                }
                else
                {
                    // Non optional variants need conversion if they contain a string that it longer than maxlen
                    fprintf ( fpCXXFile, "    %s    param%i;\n", (LPCSTR)pHandler->params[i].szCParamType, i + 1 );
                }
                i++;
            }

            // Any BSTR or IDispatch* or IUnknown* arguments?  If so then possible
            // creation of BSTR/object needs to be handled.
            if (fBSTRParam || fObjectParam || fVariantParam)
            {
                fprintf ( fpCXXFile, "    ULONG   ulAlloc = 0;\n" );
            }

            fprintf ( fpCXXFile, "\n" );
        }

        i = 0;
        while ( pHandler->params[i].szVTParamType.Length() )
        {
            if ( pHandler->params[i].fOptional &&
                 pHandler->params[i].vtParam == VT_VARIANT )
            {
                fprintf ( fpCXXFile, "    V_VT(&param%i) = VT_ERROR;\n", i + 1 );
            }

            i++;
        };
        fprintf ( fpCXXFile, "\n" );

        fprintf ( fpCXXFile, "    Assert(pInstance || pDesc || pdispparams);\n\n" );
        fprintf ( fpCXXFile, "    pVTbl = (VTABLE_ENTRY*)(((BYTE *)(*(DWORD_PTR *)pInstance)) + wVTblOffset * sizeof(VTABLE_ENTRY)/sizeof(DWORD_PTR) + FIRST_VTABLE_OFFSET);\n\n" );

        if ( pHandler->params[0].vtParam == VT_ARRAY )
        {
            fprintf ( fpCXXFile, "    // Convert dispatch params to safearray.\n" );
            fprintf ( fpCXXFile, "    param1 = DispParamsToSAFEARRAY(pdispparams);\n" );
        }
        else if ( fParamConvert )
        {
            // Any parameters?
            fprintf ( fpCXXFile, "    // Convert dispatch params to C params.\n" );
            fprintf ( fpCXXFile, "    hr = DispParamsToCParams(pSrvProvider, pdispparams, " );
            if (fBSTRParam || fObjectParam || fVariantParam)
                fprintf ( fpCXXFile, "&ulAlloc, " );
            else
                fprintf ( fpCXXFile, "NULL, " );
            
            if (fBSTRParam || fVariantParam)
                fprintf ( fpCXXFile, "((PROPERTYDESC_BASIC_ABSTRACT *)pDesc)->b.wMaxstrlen" );
            else
                fprintf ( fpCXXFile, "0" );

            fprintf ( fpCXXFile, ", argTypes" );
          
            i = 0;
            while ( pHandler->params[i].szVTParamType.Length() )
            {
                fprintf ( fpCXXFile, ", &param%i", i + 1 );
                i++;
            }

            fprintf ( fpCXXFile, ", -1L);\n" );

            fprintf ( fpCXXFile, "    if (hr)\n" );
            fprintf ( fpCXXFile, "    {\n" );
            fprintf ( fpCXXFile, "        pBase->SetErrorInfo(hr);\n" );
            fprintf ( fpCXXFile, "        goto Cleanup;\n" );
            fprintf ( fpCXXFile, "    }\n\n" );
        }

        fprintf ( fpCXXFile, "    hr = (*(MethodOLEVTblFunc)VTBL_PFN(pVTbl))((IDispatch*)VTBL_THIS(pVTbl,pInstance)", chVARMacro );

        i = 0;
        while ( pHandler->params[i].szVTParamType.Length() )
        {
            fprintf ( fpCXXFile, ", param%i", i + 1 );
            i++;
        }

        // Do we have a result type?
        if ( pHandler->vtResult != VT_EMPTY )
        {
            if (((pHandler->vtResult & VT_BYREF) == VT_BYREF) && ((pHandler->vtResult & VT_TYPEMASK) != VT_VARIANT))
            {
                fprintf ( fpCXXFile, ", (%s)(&(pvarResult->pdispVal))", (LPCSTR)pHandler->szCResult );
            }
            else
            {
                fprintf ( fpCXXFile, ", pvarResult" );
            }
        }

        fprintf ( fpCXXFile, ");\n" );

        if (((pHandler->vtResult & VT_BYREF) == VT_BYREF) && ((pHandler->vtResult & VT_TYPEMASK) != VT_VARIANT))
        {
            fprintf ( fpCXXFile, "    if (!hr)\n");
            fprintf ( fpCXXFile, "        V_VT(pvarResult) = (%s) & ~VT_BYREF;\n", (LPCSTR)pHandler->szVTResult );
        }

        if ( pHandler->params[0].vtParam == VT_ARRAY )
        {
            fprintf ( fpCXXFile, "    if (param1)\n" );
            fprintf ( fpCXXFile, "    {\n" );
            fprintf ( fpCXXFile, "        HRESULT hr1 = SafeArrayDestroy(param1);\n" );
            fprintf ( fpCXXFile, "        if (hr1)\n");
            fprintf ( fpCXXFile, "            hr = hr1;\n");
            fprintf ( fpCXXFile, "    }\n" );
        }
        else if ( fParamConvert )
        {
            // Any parameters then we'll need a cleanup routine.
            fprintf ( fpCXXFile, "\nCleanup:\n" );
        }


        // Deallocate any default BSTR parameters.
        i = 0;
        while ( pHandler->params[i].szVTParamType.Length() )
        {
            if (pHandler->params[i].fDefaultValue && pHandler->params[i].vtParam == VT_BSTR)
            {
                fprintf ( fpCXXFile, "    SysFreeString(paramDef%i);\n", i + 1);
            }
            i++;
        }

        if (fBSTRParam || fObjectParam || fVariantParam)
        {
            i = 0;
            while ( pHandler->params[i].szVTParamType.Length() )
            {
                // Variants don't need conversion.
                if ((pHandler->params[i].vtParam & VT_TYPEMASK) == VT_BSTR)
                {
                    fprintf ( fpCXXFile, "    if (ulAlloc & %i)\n",  (1 << i) );
                    fprintf ( fpCXXFile, "        SysFreeString(param%i);\n", i + 1);
                }
                if ((pHandler->params[i].vtParam & VT_TYPEMASK) == VT_UNKNOWN ||
                    (pHandler->params[i].vtParam & VT_TYPEMASK) == VT_DISPATCH)
                {
                    if (!(pHandler->params[i].vtParam & VT_BYREF))
                    {
                        fprintf ( fpCXXFile, "    if ((ulAlloc & %i) && param%i)\n",  (1 << i), i + 1 );
                        fprintf ( fpCXXFile, "        param%i->Release();\n", i + 1);
                    }
                    else
                    {
                        fprintf ( fpCXXFile, "    if ((ulAlloc & %i) && *param%i)\n",  (1 << i), i + 1 );
                        fprintf ( fpCXXFile, "        (*param%i)->Release();\n", i + 1);
                    }
                }
                if ((pHandler->params[i].vtParam & VT_TYPEMASK) == VT_VARIANT)
                {
                    fprintf ( fpCXXFile, "    if (ulAlloc & %i)\n",  (1 << i) );
                    fprintf ( fpCXXFile, "    {\n" );
                    fprintf ( fpCXXFile, "        Assert(V_VT(%sparam%i) == VT_BSTR);\n",
                                        pHandler->params[i].vtParam & VT_BYREF ? "" : "&", i + 1);
                    fprintf ( fpCXXFile, "        SysFreeString(V_BSTR(%sparam%i));\n", 
                                        pHandler->params[i].vtParam & VT_BYREF ? "" : "&", i + 1);
                    fprintf ( fpCXXFile, "    }\n" );
                }
                i++;
            }
        }

        fprintf ( fpCXXFile, "    return hr;\n" );
    }
}


BOOL GenerateVTableCXX  ( LPCSTR pszOutputPath )
{
    char    chCXXFileName[255];
    FILE   *fpCXXFile;
    int     i;

    strcpy(chCXXFileName, pszOutputPath);
    strcat(chCXXFileName, FILENAME_SEPARATOR_STR "funcsig.cxx");

    fpCXXFile = fopen ( chCXXFileName, "w" );
    if ( !fpCXXFile )
    {
        return FALSE;
    }

    //
    // Generate CXX file.
    //

    // Spit out handler table.
    fprintf ( fpCXXFile, "\n\nstatic const CustomHandler  _HandlerTable[] = {\n" );

    for (i = 0; i < _cHandlers; i++)
    {
        fprintf ( fpCXXFile, "   %s,\n", (LPCSTR)(_allHandlers[i].szRawString));
    }

    fprintf ( fpCXXFile, "   NULL\n" );
    fprintf ( fpCXXFile, "};\n\n" );

    // Spit out function signatures for handlers.
    for (i = 0; i < _cHandlers; i++)
    {
        fprintf ( fpCXXFile, "HRESULT %s (CBase *pBase,\n", (LPCSTR)(_allHandlers[i].szRawString) );
        fprintf ( fpCXXFile, "            IServiceProvider *pSrvProvider,\n" );
        fprintf ( fpCXXFile, "            IDispatch *pInstance,\n" );
        fprintf ( fpCXXFile, "            WORD wVTblOffset,\n" );
        fprintf ( fpCXXFile, "            PROPERTYDESC_BASIC_ABSTRACT *pDesc,\n" );
        fprintf ( fpCXXFile, "            WORD wFlags,\n" );
        fprintf ( fpCXXFile, "            DISPPARAMS *pdispparams,\n" );
        fprintf ( fpCXXFile, "            VARIANT *pvarResult)\n" );
        fprintf ( fpCXXFile, "{\n" );

        GenerateFunctionBody ( fpCXXFile, &(_allHandlers[i]) );

        fprintf ( fpCXXFile, "}\n" );
    }

    fprintf ( fpCXXFile, "\n" );

    for (i = 0; i < _cIID; i++)
    {
        fprintf ( fpCXXFile, "EXTERN_C const IID IID_%s;\n", _allIIDs[i] );
    }

    fprintf ( fpCXXFile, "\n\n" );

    fprintf ( fpCXXFile, "#define MAX_IIDS %i\n", _cIID + 1);   // The null entry at index 0.

    fprintf ( fpCXXFile, "static const IID * _IIDTable[MAX_IIDS] = {\n" );
    fprintf ( fpCXXFile, "\tNULL,\n" );     // Index 0 is reserved for primary dispatch interface.
    // Spit out indexes into IID table.
    for (i = 0; i < _cIID; i++)
    {
        fprintf ( fpCXXFile, "\t&IID_%s,\n", _allIIDs[i] );
    }
    fprintf ( fpCXXFile, "};\n");

    fprintf ( fpCXXFile, "\n" );

    // Helper function for mapping DISP_IHTMLxxxxx
    fprintf ( fpCXXFile, "#define DIID_DispBase   0x3050f500\n" );
    fprintf ( fpCXXFile, "#define DIID_DispMax    0x3050f5a0\n" );
    fprintf ( fpCXXFile, "\n" );
    fprintf ( fpCXXFile, "const GUID DIID_Low12Bytes = { 0x00000000, 0x98b5, 0x11cf, { 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b } };\n" );
    fprintf ( fpCXXFile, "\n\n" );
    fprintf ( fpCXXFile, "BOOL DispNonDualDIID(IID iid)\n" );
    fprintf ( fpCXXFile, "{\n" );
    fprintf ( fpCXXFile, "\tBOOL    fRetVal = FALSE;\n" );
    fprintf ( fpCXXFile, "\n" );
    fprintf ( fpCXXFile, "\tif (iid.Data1 >= DIID_DispBase && iid.Data1 <= DIID_DispMax)\n" );
    fprintf ( fpCXXFile, "\t{\n" );
    fprintf ( fpCXXFile, "\t\tfRetVal = memcmp(&iid.Data2,\n" );
    fprintf ( fpCXXFile, "\t\t\t\t&DIID_Low12Bytes.Data2,\n" );
    fprintf ( fpCXXFile, "\t\t\t\tsizeof(IID) - sizeof(DWORD)) == 0;\n" );
    fprintf ( fpCXXFile, "\t}\n" );
    fprintf ( fpCXXFile, "\n" );
    fprintf ( fpCXXFile, "\treturn fRetVal;\n" );
    fprintf ( fpCXXFile, "}\n\n" );

    fclose ( fpCXXFile );

    return TRUE;
}


struct TypeMap {
    char    chType[32];
    char    chAutomationType[32];
    char    chCType[32];
    VARTYPE vtResult;
};

static TypeMap  _mapper[] = {
    { "IDispatchp"          ,   "VT_DISPATCH"               , "IDispatch *"     ,   VT_DISPATCH             },  // Entry 0 is VT_DISPATCH
    { "IDispatchpp"         ,   "VT_DISPATCH | VT_BYREF"    , "IDispatch **"    ,   VT_DISPATCH | VT_BYREF  },  // Entry 1 is VT_DISPATCH | VT_BYREF
    { "DWORD"               ,   "VT_I4"                     , "DWORD"           ,   VT_I4                   },
    { "long"                ,   "VT_I4"                     , "LONG"            ,   VT_I4                   },
    { "LONG"                ,   "VT_I4"                     , "LONG"            ,   VT_I4                   },
    //************************************************************************************************
    // Warning Warning Warning:
    // This only works for abstract properies. To use it for non-abstract property, please modify corresponding Trident code
    //
    { "LONGPTR"             ,   "VT_I4"         , "LONG_PTR"            ,   VT_I4},
    { "LONGPTR"             ,   "VT_I8"         , "LONG_PTR"            ,   VT_I8},
     //
    //************************************************************************************************
    { "short"               ,   "VT_I2"                     , "SHORT"           ,   VT_I2                   },
    { "VARIANT"             ,   "VT_VARIANT"                , "VARIANT"         ,   VT_VARIANT              },
    { "BSTR"                ,   "VT_BSTR"                   , "BSTR"            ,   VT_BSTR                 },
    { "BOOL"                ,   "VT_BOOL"                   , "VARIANT_BOOL"    ,   VT_BOOL                 },
    { "BOOLp"               ,   "VT_BOOL | VT_BYREF"        , "VARIANT_BOOL *"  ,   VT_BOOL | VT_BYREF      },
    { "VARIANTp"            ,   "VT_VARIANT | VT_BYREF"     , "VARIANT *"       ,   VT_VARIANT | VT_BYREF   },
    { "IUnknownp"           ,   "VT_UNKNOWN"                , "IUnknown *"      ,   VT_UNKNOWN              },
    { "IUnknownpp"          ,   "VT_UNKNOWN | VT_BYREF"     , "IUnknown **"     ,   VT_UNKNOWN | VT_BYREF   },
    { "float"               ,   "VT_R4"                     , "float"           ,   VT_R4                   },
    { "longp"               ,   "VT_I4 | VT_BYREF"          , "LONG *"          ,   VT_I4 | VT_BYREF        },
    { "BSTRp"               ,   "VT_BSTR | VT_BYREF"        , "BSTR *"          ,   VT_BSTR | VT_BYREF      },
    { "int"                 ,   "VT_I4"                     , "LONG"            ,   VT_I4                   },
    { "VARIANTBOOL"         ,   "VT_BOOL"                   , "VARIANT_BOOL"    ,   VT_BOOL                 },
    { "VARIANTBOOLp"        ,   "VT_BOOL | VT_BYREF"        , "VARIANT_BOOL *"  ,   VT_BOOL | VT_BYREF      },
    { "SAFEARRAYPVARIANTP"  ,   "VT_ARRAY"                  , "SAFEARRAY *"     ,   VT_ARRAY                },
    { "void"                ,   ""                          , ""                ,   VT_EMPTY                },
    { "PropEnum"            ,   "VT_BSTR"                   , "BSTR"            ,   VT_BSTR                 },  // TODO: Remove and fix.
    { "IHTMLControlElementp",   "VT_DISPATCH"               , "IDispatch *"     ,   VT_DISPATCH             },  // TODO: Not converted to IDispatch
    { "IHTMLElementpp"      ,   "VT_DISPATCH | VT_BYREF"    , "IDispatch **"    ,   VT_DISPATCH | VT_BYREF  },  // TODO: Not converted to IDispatch
    { "IHTMLElementCollectionpp"      ,   "VT_DISPATCH | VT_BYREF"    , "IDispatch **"    ,   VT_DISPATCH | VT_BYREF  },  // TODO: Not converted to IDispatch
    { ""                    ,   ""                          , ""                ,   VT_EMPTY                }
};

BOOL MapTypeToAutomationType (char *pTypeStr, char **ppAutomationType, char **ppCType, VARTYPE *pVTType)
{
    int     i = 0;
    int     win64offset = 0;
    VARTYPE vtTemp;

    if (!pVTType)
        pVTType = &vtTemp;

    if (gfWin64)
        win64offset = 1;
    
    while (_mapper[i].chType[0])
    {
        if (strcmp(_mapper[i].chType, pTypeStr) == 0)
        {
            //
            // special handling for LONGPTR is required since it will be 
            // resolved to two diffferent types depending on arch!
            //
            if (strcmp(_mapper[i].chType, "LONGPTR") == 0)
            {
                i += win64offset;
            }
            
            *ppAutomationType = _mapper[i].chAutomationType;
            *ppCType = _mapper[i].chCType;
            *pVTType = _mapper[i].vtResult;
             return TRUE;
        }

        i++;
    }
    return FALSE;
}


BOOL ProcessDatFile ( LPCSTR pszOutputPath )
{
    char   *buffer;
    FILE   *fpDatFile;
    char    chDatFileName[255];
    char    szTextError[MAX_LINE_LEN+1];
    char   *pATypeStr;
    char   *pCTypeStr;
    int     cLines;

    if ( !pszOutputPath )
        return FALSE;

    strcpy(chDatFileName, pszOutputPath);
    strcat(chDatFileName, FILENAME_SEPARATOR_STR "funcsig.dat");

    fpDatFile = fopen ( chDatFileName, "rb");

    if ( !fpDatFile )
    {
        return FALSE;
    }

    if ( fseek( fpDatFile, 0, SEEK_END ) == 0 )
    {
        fpos_t  pos;

        if ( fgetpos( fpDatFile, &pos ) == 0 )
        {
            int     i = 0;

            buffer = new char[pos];
            if (buffer == NULL)
                return FALSE;

            fseek( fpDatFile, 0, SEEK_SET );

            if ( (unsigned) fread ( buffer, 1, pos, fpDatFile ) != pos )
                return FALSE;

            // Create the header file from the .dat file.
            _cHandlers = buffer[0];     // Number of signatures
            _cHandlers &= 0x000000ff;
            _cIID = buffer[1];          // Number of IIDs
            _cIID &= 0x000000ff;

            if (_cHandlers >= MAX_HANDLERS)
            {
                PDLError("To many handlers increase MAX_HANDLERS\n");
                goto Error;
            }

            if (_cIID >= MAX_IIDS)
            {
                PDLError("To many handlers increase MAX_IIDS\n");
                goto Error;
            }

            i = 4;                      // Skip 4 byte header.
            cLines = 0;
            while ( cLines < _cHandlers )
            {
                char   *pStrWork;
                char   *pStrWork2;
                int     cStr = strlen ( buffer + i );

                // Copy raw function signature.
                _allHandlers[cLines].szRawString = (buffer + i);

                pStrWork = buffer + i;

                // Get type
                pStrWork2 = strchr(pStrWork, '_');
                if (!pStrWork2)
                    goto Error;
                *pStrWork2 = '\0';

                _allHandlers[cLines].invokeType = ATYPE_Undefined;
                if (strchr(pStrWork, 'G'))
                    _allHandlers[cLines].invokeType |= ATYPE_GetProperty;
                if (strchr(pStrWork, 'S'))
                    _allHandlers[cLines].invokeType |= ATYPE_SetProperty;
                if (strchr(pStrWork, 'M'))
                    _allHandlers[cLines].invokeType = ATYPE_Method;

                // Point pass the G, S, GS or Method
                pStrWork = pStrWork2 + 1;

                if (_allHandlers[cLines].invokeType == ATYPE_Method)
                {
                    // Do method parsing:
                    int     iArg;

                    pStrWork2 = strchr(pStrWork, '_');
                    if (!pStrWork2)
                    {
                        PDLError("bad method result");
                        return FALSE;
                    }

                    *pStrWork2 = '\0';

                    // Get result type
                    if (MapTypeToAutomationType(pStrWork, &pATypeStr, &pCTypeStr, &(_allHandlers[cLines].vtResult)))
                    {
                        _allHandlers[cLines].szVTResult = pATypeStr;
                        _allHandlers[cLines].szCResult = pCTypeStr;
                    }
                    else
                    {
                        sprintf(szTextError, "result type '%s' not found.", pStrWork);
                        PDLError(szTextError);
                        return FALSE;
                    }

                    pStrWork = pStrWork2 + 1;

                    // arg parsing:
                    iArg = 0;
                    while (*pStrWork)
                    {
                        pStrWork2 = strchr(pStrWork, '_');
                        if (pStrWork2)
                        {
                            *pStrWork2 = '\0';
                        }

                        // optional argument?
                        _allHandlers[cLines].params[iArg].fOptional = 
                                            (pStrWork[0] == 'o' &&
                                             pStrWork[1] == '0' &&
                                             pStrWork[2] == 'o');
                        _allHandlers[cLines].params[iArg].fDefaultValue = 
                                            (pStrWork[0] == 'o' &&
                                             pStrWork[1] == 'D' &&
                                             pStrWork[2] == 'o');

                        if (_allHandlers[cLines].params[iArg].fOptional ||
                            _allHandlers[cLines].params[iArg].fDefaultValue)
                        {
                            pStrWork += 3;  // Skip o0o or oDo which signals optional (litle o zero little o) or defaultValue.
                        }

                        if (MapTypeToAutomationType(pStrWork, &pATypeStr, &pCTypeStr, &(_allHandlers[cLines].params[iArg].vtParam)))
                        {
                            _allHandlers[cLines].params[iArg].szVTParamType = pATypeStr;
                            _allHandlers[cLines].params[iArg].szCParamType = pCTypeStr;
                        }
                        else
                        {
                            sprintf(szTextError, "argument type '%s' not found.", pStrWork);
                            PDLError(szTextError);
                            return FALSE;
                        }

                        pStrWork += strlen(pStrWork);
                        // More args to parse?
                        if (pStrWork2)
                            pStrWork++;         // Point at next arg.

                        iArg++;
                    }
                }
                else
                {
                    // Do property parsing
                    if (MapTypeToAutomationType(pStrWork, &pATypeStr, &pCTypeStr, &(_allHandlers[cLines].vtResult)))
                    {
                        _allHandlers[cLines].szVTResult = pATypeStr;
                        _allHandlers[cLines].szCResult = pCTypeStr;
                    }
                    else
                    {
                        sprintf(szTextError, "type '%s' not found.", pStrWork);
                        PDLError(szTextError);
                        return FALSE;
                    }
                }

                cLines++;
                i += cStr + 1;
            }

            // Load up the IIDs.
            cLines = 0;
            while ( cLines < _cIID )
            {
                int     cStr = strlen ( buffer + i );

                _allIIDs[cLines] = buffer + i;

                cLines++;
                i += cStr + 1;
            }

            fclose ( fpDatFile );

            return TRUE;
        }
    }

Error:
    return FALSE;
}


int __cdecl
main  ( int argc, char *argv[] )
{
    int nReturnCode;
    char szInputFile [ MAX_PATH+1 ];
    char szOutputFileRoot [ MAX_PATH+1 ];
    char szPDLFileName [ MAX_PATH+1 ];
    char szOutputPath [ MAX_PATH+1 ];
    BOOL fDebugging = FALSE;

    {
    CPDLParser Parser;

    
    // argv[1] is the name of a file containing build args
    // arg1 of this file is the full path/filename of the input file
    // arg2 is the full name of the output file, minus the file extension
    // arg3 is the 8.3 pdl file name
    // arg4 is a log file name
    if ( argc == 5 )
    {
        strcpy ( szInputFile, argv [ 1] );
        strcpy ( szOutputFileRoot, argv [ 2 ] );
        strcpy ( szPDLFileName, argv [ 3 ] );
        strcpy ( szOutputPath, argv [ 4 ] );
        fDebugging = TRUE;
    }
    else if ( argc == 4 && _stricmp( argv[1], "/g") == 0 ||
                           _stricmp( argv[1], "-g") == 0 )
    {
        if (_stricmp(argv[2], "win64") == 0)
        {
            gfWin64 = TRUE;
        }
        else if (_stricmp(argv[2], "i386") ==0)
        {
            gfWin64 = FALSE;
        }
        else
        {
            printf ( "Invalid command line params\n" );
            nReturnCode = 3;
            goto Cleanup;
        }
    
        // Process the funcsig.dat file and produce custsig.hxx file:
        if (!ProcessDatFile ( argv [ 3 ] ))
        {
            nReturnCode = 4;
            goto Cleanup;
        }

        if (!GenerateVTableHeader ( argv [ 3 ] ))
        {
            nReturnCode = 4;
            goto Cleanup;
        }

        if (!GenerateVTableCXX ( argv [ 3 ] ))
        {
            nReturnCode = 4;
            goto Cleanup;
        }

        FILE *fpMaxLenFile = NULL;

        strcpy(szOutputPath, argv [ 3 ]);
        strcat(szOutputPath, FILENAME_SEPARATOR_STR "maxlen.txt");

        fpMaxLenFile = fopen(szOutputPath, "r+");
        if (fpMaxLenFile)
        {
            char chMarker[6];
            strcpy(chMarker, "Const");
            fwrite(chMarker, sizeof(char), 5, fpMaxLenFile);
            fclose(fpMaxLenFile);
        }

#ifdef COMPLUS_SHIM

        if (!GenerateNDirectHeader ( argv [ 3 ] ))
        {
            nReturnCode = 4;
            goto Cleanup;
        }

        if (!GenerateNDirectCXX ( argv [ 3 ] ))
        {
            nReturnCode = 4;
            goto Cleanup;
        }

        if (!GenerateComPlusHeader ( argv [ 3] ))
        {
            nReturnCode = 4;
            goto Cleanup;
        }

        if (!GenerateComPlusCXX ( argv [ 3 ] ))
        {
            nReturnCode = 4;
            goto Cleanup;
        }

#endif    // COMPLUS_SHIM

        nReturnCode = 0;
        goto Cleanup;
    }
    else if ( argc > 1 )
    {
        if ( !ScanBuildFile ( argv[ 1 ],
                              szInputFile,
                              szOutputFileRoot,
                              szPDLFileName,
                              szOutputPath ) )
        {
            printf ( "Cant scan build file\n" );
            nReturnCode = 2;
            goto Cleanup;
        }
    }
    else
    {
        printf ( "Invalid command line params\n" );
        nReturnCode = 3;
        goto Cleanup;
    }

    nReturnCode = Parser.Parse ( szInputFile, szOutputFileRoot, 
        szPDLFileName, szOutputPath, fDebugging  );

    }

Cleanup:
    if ( nReturnCode != 0 )
        printf ( "Error %d building PDL file\n", nReturnCode );
    exit ( nReturnCode );
}

#ifndef X_DATA_CXX_
#define X_DATA_CXX_
#include "data.cxx"
#endif

#ifndef X_ASSOC_CXX_
#define X_ASSOC_CXX_
#include "assoc.cxx"
#endif

#ifndef X_PARSER_CXX_
#define X_PARSER_CXX_
#include "parser.cxx"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\btools\tldiff\cocomp.cxx ===
#include <assert.h>
#include <iostream.h>
#include "CoComp.Hxx"

bool CompareBuffer( char* pBuff1, char* pBuff2, unsigned long nLen);
void WriteLine(HANDLE file, char* pBuff, int nLen);
extern unsigned long g_ulAppRetVal;

CCompareCoClass::CCompareCoClass(char* pCurBuf, char* pRefBuf, HANDLE fileDiff, char* pszClassName )
{
	_pCurBuf = pCurBuf;
	_pRefBuf = pRefBuf;
	_fileDiff = fileDiff;
	_pszClassName = pszClassName;

	_pCurList = new CAutoArray<LINEINFO>;
	_pRefList = new CAutoArray<LINEINFO>;

	CreateLineIndex(_pCurList, _pCurBuf);
	CreateLineIndex(_pRefList, _pRefBuf);

	_bFirstTime = true;
}

CCompareCoClass::~CCompareCoClass()
{
	delete _pCurList;
	delete _pRefList;
}

void CCompareCoClass::FindAdditionsAndChanges()
{
	long lIdx;
	long lTmp;
	LINEINFO lineCur;
	LINEINFO lineRef;

	char* szBuff = new char[128];
	
	//check for additions and alterations
	for ( lIdx = 0; lIdx< (int)_pCurList->Size(); lIdx++ )
	{
		_pCurList->GetAt( lIdx, &lineCur );

		for ( lTmp=0; lTmp<_pRefList->Size(); lTmp++ )
		{
			_pRefList->GetAt( lTmp, &lineRef );
			
			//compare the names of two methods to find if they are comparable
			//in respect to other aspects of their declarations.
			if (( !lineRef.fUsed ) && 
				( CompareBuffer(&_pCurBuf[lineCur.ulNameStart], 
								&_pRefBuf[lineRef.ulNameStart], 
								max(lineCur.ulNameEnd-lineCur.ulNameStart, 
								lineRef.ulNameEnd-lineRef.ulNameStart)+ 1)))
			{
				//we have found a match. Mark it so that we don't compare anymore
				lineRef.fUsed = true;
				_pRefList->Set( lTmp, lineRef );
				break;
			}

			lineRef.fUsed = false;
		}

		//did we find a match.
		if ( lTmp == _pRefList->Size() )
		{
			char* pszName = new char[lineCur.ulNameEnd-lineCur.ulNameStart+1];
			for (lTmp=lineCur.ulNameStart; lTmp<(long)lineCur.ulNameEnd; lTmp++)
			{
				pszName[lTmp-lineCur.ulNameStart] = _pCurBuf[lTmp];
			}
			pszName[lTmp-lineCur.ulNameStart] = 0;

			//if it is the first time, put the banner in.
			if ( _bFirstTime )
			{
				lstrcpy( szBuff, "\ncoclass ");
				lstrcat( szBuff, _pszClassName);
				lstrcat( szBuff, "\n-----------------------------\n" );
				lstrcat( szBuff, "Additions and changes:" );
				WriteLine( _fileDiff, szBuff, -1 );
				_bFirstTime = false;
			}

			//this either has changed, or it's a new line.
			lstrcpy( szBuff, _pszClassName);
			lstrcat( szBuff, " : " );
			lstrcat( szBuff, pszName );
			lstrcat( szBuff, " added");

			WriteLine( _fileDiff, szBuff, -1);

// ferhane: Although this is a change, it does not break COM rules.
//          We need to return a success code but report anyway.            
//			g_ulAppRetVal |= CHANGE_ADDTOCOCLASS;

			delete pszName;
		}
	}

	delete [] szBuff;
}

void CCompareCoClass::FindRemovals()
{
	long lIdx;
	long lTmp;
	LINEINFO	lineRef;
	char* szBuff = new char[128];
	bool bFirstRemoval= true;

	for ( lIdx=0; lIdx< (int)_pRefList->Size(); lIdx++ )
	{
		//get the record
		_pRefList->GetAt( lIdx, &lineRef);

		//is the record marked ?
		if (!lineRef.fUsed)
		{
			//get the real name of the interface
			char* pszName = new char[lineRef.ulNameEnd-lineRef.ulNameStart+1];
			
			for (lTmp=lineRef.ulNameStart; lTmp<(long)lineRef.ulNameEnd; lTmp++)
			{
				pszName[lTmp-lineRef.ulNameStart] = _pRefBuf[lTmp];
			}
			pszName[lTmp-lineRef.ulNameStart] = 0;		//terminate the string

			//if it is the first time, put the banner in.
			if ( _bFirstTime )
			{
				lstrcpy( szBuff, "coclass ");
				lstrcat( szBuff, _pszClassName);
				lstrcat( szBuff, "\n-----------------------------" );
				WriteLine( _fileDiff, szBuff, -1 );
				_bFirstTime = false;
			}

			if ( bFirstRemoval )
			{
				WriteLine( _fileDiff, "Removals:", -1);
				bFirstRemoval = false;
			}

			lstrcpy( szBuff, _pszClassName );
			lstrcat( szBuff, " : ");
			lstrcat( szBuff, pszName );
			lstrcat( szBuff, " has been removed." );
			WriteLine( _fileDiff, szBuff, -1);

			g_ulAppRetVal |= CHANGE_REMOVEFROMCOCLASS;

			delete [] pszName;

			WriteLine( _fileDiff, " ", -1 );
		}
	}

	delete [] szBuff;
}

//
//
//
void CCompareCoClass::CreateLineIndex( CAutoArray<LINEINFO>* pList, char* pBuf)
{
	LINEINFO lineinfo = {0};

	unsigned long ulIdx = 0;
	unsigned long ulLastSpace = 0;	
	char chSearch = '{';			//look for the start of the declaration
	
	while ( pBuf[ulIdx] != 0 )
	{
		if ( pBuf[ulIdx] == chSearch )
		{
			switch (chSearch)
			{
				case '{':
					ulIdx+=2;		//skip over the CR/LF

					//these values are not used and there is no need to use 
					//CPU time to set them.
					//					lineinfo.ulAttrStart = 0;
					//					lineinfo.ulAttrEnd = 0;
					//					lineinfo.ulParamStart=0;
					//					lineinfo.ulParamEnd=0;

					lineinfo.ulNameStart = ulIdx+1;
					chSearch = ';';
					break;

				case ';':
					//finish logging this line
					lineinfo.ulNameEnd = ulIdx;
					pList->Append(lineinfo);

					//prepare for the next line
					ulIdx+=2;
					lineinfo.ulNameStart = ulIdx+1;
					break;
			}
		}
		ulIdx++;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\btools\tldiff\icomp.cxx ===
#include <assert.h>
#include <iostream.h>
#include "IComp.Hxx"

extern bool fgMethodAttribute;
extern bool fgMethodParameter;

bool CompareBuffer( char* pBuff1, char* pBuff2, unsigned long nLen);
bool CompareBufferNoCase( char* pBuff1, char* pBuff2, unsigned long nLen);
void WriteLine(HANDLE file, char* pBuff, int nLen);
void TokenizeAttributes( char* pBuf, unsigned long nCnt, CAutoArray<ATTRINFO>* pList );

extern unsigned long g_ulAppRetVal;
extern bool fgParamNames;
extern bool fgParamTypes;
extern bool fgParamNameCase;
extern bool fgParamTypeCase;

CCompareInterface::CCompareInterface( char* pCurBuf, 
                                      char* pRefBuf, 
                                      HANDLE fileDiff, 
                                      char* pszIntName, 
                                      BLOCK_TYPE blockType, 
                                      char* pszMethodAttr)
{
	_pCurBuf = pCurBuf;
	_pRefBuf = pRefBuf;
	_fileDiff = fileDiff;
	_pszIntName = pszIntName;
	_blockType = blockType;
    _pszMethodAttr = pszMethodAttr;

	_pCurList = new CAutoArray<LINEINFO>;
	_pRefList = new CAutoArray<LINEINFO>;


	CreateLineIndex(_pCurList, _pCurBuf);
	CreateLineIndex(_pRefList, _pRefBuf);

	_bFirstTime = true;
}

CCompareInterface::~CCompareInterface()
{
	delete _pCurList;
	delete _pRefList;
}

void CCompareInterface::FindAdditionsAndChanges( )
{
	long lIdx;
	long lTmp;
	LINEINFO lineCur;
	LINEINFO lineRef;

    bool bRetVal = false;
	
	//check for additions and alterations
	for ( lIdx = 0; lIdx< (int)_pCurList->Size(); lIdx++)
	{
		_pCurList->GetAt( lIdx, &lineCur );

		//get the real name of the method or property
		char* pszMethodName = new char[lineCur.ulParamStart-lineCur.ulMethodNameStart+1];

		for (lTmp=lineCur.ulMethodNameStart; lTmp<(long)lineCur.ulParamStart; lTmp++)
		{
			pszMethodName[lTmp-lineCur.ulMethodNameStart] = _pCurBuf[lTmp];
		}
		pszMethodName[lTmp-lineCur.ulMethodNameStart] = 0;

		lstrcpy( _szLogBuff, _pszIntName);
		lstrcat( _szLogBuff, "::" );
		lstrcat( _szLogBuff, pszMethodName );

		for ( lTmp=0; lTmp<_pRefList->Size(); lTmp++ )
		{
			_pRefList->GetAt( lTmp, &lineRef );
			
			//compare the names of two methods to find if they are comparable
			//in respect to other aspects of their declarations.
			if ((!lineRef.fUsed)&&
                ( CompareBuffer( pszMethodName, 
                                    &_pRefBuf[lineRef.ulMethodNameStart], 
                                    max( lineCur.ulParamStart-lineCur.ulMethodNameStart, lineRef.ulParamStart-lineRef.ulMethodNameStart) )))
			{
                // if the names are the same, now compare the return values. If they are not the same, then the method is
                // modified from its original version.
                if ( !CompareBuffer( &_pCurBuf[lineCur.ulNameStart], 
                                     &_pRefBuf[lineRef.ulNameStart], 
                                     max( lineCur.ulMethodNameStart-lineCur.ulNameStart, lineRef.ulMethodNameStart-lineRef.ulNameStart) ))
                {
                    bRetVal = true;
                }

				//compare attribute block 
				if (( fgMethodAttribute ) && 
                    ((lineCur.ulAttrEnd-lineCur.ulAttrStart != lineRef.ulAttrEnd-lineRef.ulAttrStart) || 
					 ( !CompareBuffer(	&_pCurBuf[lineCur.ulAttrStart], &_pRefBuf[lineRef.ulAttrStart], 							
					    				max(lineCur.ulAttrEnd-lineCur.ulAttrStart, lineRef.ulAttrEnd-lineRef.ulAttrStart))))  )
				{
                    // since we know the attributes have changed, analyze the type of change
                    CompareMethodAttributes( &lineRef, &lineCur );
				}

				//compare parameter block 
				if (( fgMethodParameter ) && 
                    ((lineCur.ulParamEnd-lineCur.ulParamStart != lineRef.ulParamEnd-lineRef.ulParamStart) ||
                     ( !CompareBuffer(	&_pCurBuf[lineCur.ulParamStart], &_pRefBuf[lineRef.ulParamStart], 
										max(lineCur.ulParamEnd-lineCur.ulParamStart, lineRef.ulParamEnd-lineRef.ulParamStart)))) )
				{
                    CompareMethodParameters( &lineRef, &lineCur );
				}

				//we have found the method that matches, move on to the next
				//method name on the current block.
				lineRef.fUsed = true;
				_pRefList->Set( lTmp, lineRef );
				break;
			}
		}

		//write the results that were found from this comparison, 
		//if this was a different line
		if ( bRetVal || (lTmp == _pRefList->Size()) )
		{
			char* pszBuff = new char[128];

            EnsureTitle( TRUE );

            if ( bRetVal )
            {
                lstrcpy( pszBuff, _szLogBuff );
                lstrcat( pszBuff, " - Return value or call type has changed " );
                WriteLine( _fileDiff, pszBuff, -1);
                bRetVal = false;
                g_ulAppRetVal |= CHANGE_RETVALCHANGE;
            }
	
			if (lTmp == _pRefList->Size())	//this is a new nethod
			{
				lstrcpy( pszBuff, _szLogBuff );
				lstrcat( pszBuff, " - Is a new method " );
				WriteLine(_fileDiff, pszBuff,-1);

				if ( _blockType== BLK_DISPINT )
					g_ulAppRetVal |= CHANGE_METHODONDISPINT;
				else
					g_ulAppRetVal |= CHANGE_METHODONINT;
			}
			delete [] pszBuff;
		}
		
		delete [] pszMethodName;
	}
}

//----------------------------------------------------------------------------
//  bMode == TRUE  --> Addition / Change
//----------------------------------------------------------------------------
void
CCompareInterface::EnsureTitle( BOOL bAddition )
{
    char szBuff[256];

    if ( _bFirstTime )
    {
        //write the header.
        if ( _blockType== BLK_DISPINT )
            lstrcpy( szBuff, "\nDispinterface " );
        else
            lstrcpy( szBuff, "\nInterface " );
        
        lstrcat( szBuff, _pszIntName );
        lstrcat( szBuff, "\n------------------------------------\n");
        if ( bAddition )
        {
            lstrcat( szBuff, "Additions / Changes:" );
        }
        
        WriteLine( _fileDiff, szBuff, -1);
        
        _bFirstTime = false;
    }
}
//
//	Walk through the unmarked elements of the reference block index. These are the
//	entries that do not exist in the current block.
//
void CCompareInterface::FindRemovals( )
{
	long lIdx;
	long lTmp;
	LINEINFO	lineRef;
	char* szBuff = new char[128];
	bool bFirstRemoval = true;

	for ( lIdx=0; lIdx< (int)_pRefList->Size(); lIdx++ )
	{
		//get the record
		_pRefList->GetAt( lIdx, &lineRef);

		//is the record marked ?
		if (!lineRef.fUsed)
		{
			//get the real name of the interface
			char* pszMethodName = new char[lineRef.ulParamStart-lineRef.ulMethodNameStart+1];
			int nIdx;
			
			for (lTmp=lineRef.ulMethodNameStart, nIdx=0; lTmp<(long)lineRef.ulParamStart; lTmp++, nIdx++)
			{
				pszMethodName[nIdx] = _pRefBuf[lTmp];
			}

            pszMethodName[nIdx] = 0;		//terminate the string

            // if this is the first removal, then add the word Removals
            EnsureTitle( FALSE );

			//write the header.
			if ( _blockType== BLK_DISPINT )
				g_ulAppRetVal |= CHANGE_REMOVEFROMDISPINT;
			else
				g_ulAppRetVal |= CHANGE_REMOVEFROMINT;

			if ( bFirstRemoval)
			{
				WriteLine( _fileDiff, "Removals : ", -1);
				bFirstRemoval = false;
			}

			lstrcpy( szBuff, _pszIntName);
			lstrcat( szBuff, "::");
			lstrcat( szBuff, pszMethodName);
			lstrcat( szBuff, " has been removed.");
			WriteLine( _fileDiff, szBuff, -1);

			delete [] pszMethodName;
		}
	}

	delete [] szBuff;
}

void CCompareInterface::CreateLineIndex( CAutoArray<LINEINFO>* pList, char* pBuf )
{
	LINEINFO lineinfo = {0};

	unsigned long ulIdx=0;
	unsigned long ulLastSpace = 0;
	char chSearch = '[';				//initially look for the opening attribute char.
	unsigned int uBrCnt = 0;
	unsigned int uParCnt = 0;

	//go until the end of the buffer, it is null terminated.
	while ( pBuf[ulIdx] != 0)
	{
		if ( pBuf[ulIdx] == chSearch )
		{
			//depending on what we were looking for, 
			//we can decide what to look for next.
			switch (chSearch)
			{
				case '[':
					uBrCnt++;
					if ( uBrCnt == 1 )
					{
						lineinfo.ulAttrStart = ulIdx;
						chSearch = ']';
					}
					break;

				case ']':
					uBrCnt --;
					if ( uBrCnt == 0 )
					{
						lineinfo.ulAttrEnd = ulIdx;
						lineinfo.ulNameStart = ulIdx+2;
						chSearch = '(';
					}
					break;

				case '(':
					uParCnt++;
					if (uParCnt==1)
					{
						lineinfo.ulNameEnd = ulIdx-1;
						lineinfo.ulParamStart = ulIdx;
						lineinfo.ulMethodNameStart = ulLastSpace+1;
						chSearch = ')';
					}
					break;

				case ')':
					uParCnt--;
					if ( uParCnt == 0 )
					{
						lineinfo.ulParamEnd = ulIdx;
						chSearch = '[';
						
						//completed the cycle, add this record to the list
						pList->Append(lineinfo);
					}
					break;
			}
		}
		else
		{
			switch ( pBuf[ulIdx] )
			{
				case '(':
					uParCnt++;
					break;

				case ')':
					uParCnt--;
					break;

				case '[':
					uBrCnt++;
					break;

				case ']':
					uBrCnt--;
					break;
	
				case ' ':
					ulLastSpace = ulIdx;
					break;
			}
		}

		ulIdx++;
	}
}

/*----------------------------------------------------------------------------

  ----------------------------------------------------------------------------*/
void 
CCompareInterface::CompareMethodAttributes( LINEINFO* pRef, 
                                            LINEINFO* pCur )
{
    long                    l, 
                            k;
    long                    curBase = (pCur->ulAttrStart)+1;
    long                    refBase = (pRef->ulAttrStart)+1;
    ATTRINFO                attrRef; 
    ATTRINFO                attrCur;

    CAutoArray<ATTRINFO>*   pCurList = new CAutoArray<ATTRINFO>;
	CAutoArray<ATTRINFO>*   pRefList = new CAutoArray<ATTRINFO>;

    TokenizeAttributes( &_pRefBuf[refBase], pRef->ulAttrEnd-refBase, pRefList );
    TokenizeAttributes( &_pCurBuf[curBase], pCur->ulAttrEnd-curBase, pCurList );

    //let's find the ones that are new
    for ( l=0; l < pCurList->Size(); l++ )      
    {
        pCurList->GetAt( l, &attrCur);

        for ( k=0; k < pRefList->Size(); k++ )
        {
            pRefList->GetAt( k, &attrRef );

            if ( (!attrRef.fUsed ) && 
                  CompareBuffer( &_pCurBuf[curBase + attrCur.ulAttrStart], 
                                &_pRefBuf[refBase + attrRef.ulAttrStart],
                                max( attrCur.ulAttrLength, attrRef.ulAttrLength)) )
            {
                // found the same attribute in the reference attributes, it is not a new
                // attribute
                attrRef.fUsed = true;
                pRefList->Set( k, attrRef );

                attrCur.fUsed = true;
                pCurList->Set( l, attrCur );
                break;
            }
        }
        
        if ( k == pRefList->Size() )
        {
            // this is a new attribute. 
            // if we find this attribute name in the list, then we are breaking the compat
            if ( IsAttributeBreaker( _pszMethodAttr,
                                        _pCurBuf+curBase+attrCur.ulAttrStart, 
                                        attrCur.ulAttrLength ) )
            {
                EnsureTitle(TRUE);
                WriteAttrChangeString( _pCurBuf, 
                                        curBase+attrCur.ulAttrStart, 
                                        attrCur.ulAttrLength, 
                                        "' attribute was added"); 
            }
        }
    }

    // Whatever is left in the reference array as not used are removals.
    for ( l=0; l < pRefList->Size(); l++ )      
    {
        pRefList->GetAt( l, &attrRef);

        if ( !attrRef.fUsed )
        {
            // if we find this attribute name in the list, then we are breaking the compat
            if ( IsAttributeBreaker( _pszMethodAttr, 
                                        _pRefBuf+refBase+attrRef.ulAttrStart, 
                                        attrRef.ulAttrLength ) )
            {
                // breaker attribute
                EnsureTitle(TRUE);
                WriteAttrChangeString( _pRefBuf, 
                                        refBase+attrRef.ulAttrStart, 
                                        attrRef.ulAttrLength, 
                                        "' attribute was removed");
            }
        }
    }

    delete pCurList;
    delete pRefList;
}

//----------------------------------------------------------------------------
// The attribute list contains the buffer that is read from the INI file.
// Each attribute name is a string that is terminated by a NULL character. At 
// the very end, after the last attribute, there is an additional NULL.
//----------------------------------------------------------------------------
BOOL 
CCompareInterface::IsAttributeBreaker( char * pszAttrList, char * pszAttr, unsigned long ulAttrLen )
{
    unsigned long   ulStrLen;
    unsigned long   ulIdx = 0;    // index to the big buffer.

    // until we reach the very end.
    // if we can not get into the loop below, it means that there are no 
    // attributes that are considered breaking
    while (pszAttrList[ulIdx] != NULL)
    {
        ulStrLen = lstrlen(&pszAttrList[ulIdx]);

        // if the lengths and the contents are the same, then this attribute
        // is a breaker attribute
        if ((ulStrLen == ulAttrLen) && 
             (CompareBuffer(&pszAttrList[ulIdx], pszAttr, ulStrLen)))
        {
            return TRUE;
        }

        // increment the index, to point to the next string in the buffer
        ulIdx += ulStrLen + 1;
    }

    // if we reach here, it means that we could not find the attribute in the list
    // this is NOT a breaker attribute
    return FALSE;
}

void 
CCompareInterface::WriteAttrChangeString(char* pBuf,
                                         unsigned long ulAttrStart, 
                                         unsigned long ulAttrLength, 
                                         char* szChangeType)
{
    unsigned long   k;
    char            szBuff[256];
    char *          pszAttrName = new char[ulAttrLength+1];

    //copy the attribute name into the buffer
    for (k = 0; k < ulAttrLength; k++)
        pszAttrName[k] = *(pBuf + ulAttrStart + k);

    pszAttrName[k] = 0; //terminate

    lstrcpy(szBuff, _szLogBuff);
    lstrcat(szBuff, " - '");
    lstrcat(szBuff, pszAttrName);
    lstrcat(szBuff, szChangeType);

    WriteLine(_fileDiff, szBuff, -1);
    g_ulAppRetVal |= CHANGE_ATTRCHANGE;
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
void 
CCompareInterface::CompareMethodParameters( LINEINFO* pRef, LINEINFO* pCur)
{
    long                    l;
    long                    k;
    long                    curBase = (pCur->ulParamStart)+1;
    long                    refBase = (pRef->ulParamStart)+1;

    PARAMINFO               paramRef;
    PARAMINFO               paramCur;

    CAutoArray<PARAMINFO>*  pCurList = NULL; 
	CAutoArray<PARAMINFO>*  pRefList = NULL; 

    bool                    bNameChange, 
                            bTypeChange,
                            bReplaced;
    char                    szBuff[512] = {0};
    char                    szType[64] = {0};
    char                    szName[64] = {0};


    pCurList = new CAutoArray<PARAMINFO>;
    pRefList = new CAutoArray<PARAMINFO>;

    assert( pCurList );
    assert( pRefList );

    // start by tokenizing the parameters
    TokenizeParameters( &_pRefBuf[refBase], pRef->ulParamEnd-refBase, pRefList);
    TokenizeParameters( &_pCurBuf[curBase], pCur->ulParamEnd-curBase, pCurList);

    // parameters have to match one to one.
    for ( l=0; l<pRefList->Size(); l++ )
    {
        bTypeChange = bNameChange = bReplaced = false;

        pCurList->GetAt( l, &paramCur);
        pRefList->GetAt( l, &paramRef);

        // is this parameter touched before, because of a replacement catch?
        // if that is the case we should only check if the reference parameter was replaced
        if ( paramCur.fUsed )
        {
            bTypeChange = bNameChange = true;
            goto ReplaceCheck;
        }

        // compare the types
        if ( fgParamTypes )
        {
            //
            // Only go through comparison if the type does not contain a _MIDL_ word in it.
            //
            char szTypeRef[64] = {0};
            lstrcpyn( szTypeRef, 
                        _pRefBuf+refBase+paramRef.ulTypeStart, 
                        max(63, paramRef.ulTypeLength));
            
            if ( !strstr(szTypeRef, "_MIDL_") )
            {
                // if the lengths are different bail out immediately, without text comparison.
                if ( paramRef.ulTypeLength == paramCur.ulTypeLength ) 
                {
                    //compare the contents, check if we want case sensitive or not.            
                    if ( fgParamTypeCase )
                        bTypeChange = !CompareBuffer(   _pRefBuf+refBase+paramRef.ulTypeStart, 
                                                        _pCurBuf+curBase+paramCur.ulTypeStart,
                                                        max( paramRef.ulTypeLength, paramCur.ulTypeLength) );
                    else
                        bTypeChange = !CompareBufferNoCase( _pRefBuf+refBase+paramRef.ulTypeStart, 
                                                            _pCurBuf+curBase+paramCur.ulTypeStart,
                                                            max( paramRef.ulTypeLength, paramCur.ulTypeLength) );
                }
                else 
                    bTypeChange = true;
            }
            else
            {
                // if one of the types contains a _MIDL_, then the other MUST too.
                char szTypeCur[64] = {0};
                lstrcpyn( szTypeCur, 
                            _pCurBuf+curBase+paramCur.ulTypeStart, 
                            max(63, paramCur.ulTypeLength));

                // if the string does NOT contain _MIDL_ than there was a change.
                if ( !strstr(szTypeCur, "_MIDL_") )
                {
                    bTypeChange = true;
                }
            }
        }


        if ( fgParamNames )
        {
            char szNameRef[64] = {0};
            
            //
            // If the name of one parameter contains a _MIDL_ keyword, then only make sure the
            // other name contains the _MIDL_ too. No need to match strings.
            //
            lstrcpyn( szNameRef, _pRefBuf+refBase+paramRef.ulNameStart, max(63, paramRef.ulNameLength));

            if (!strstr(szNameRef, "_MIDL_"))
            {
                // if the lengths are different bail out immediately, without text comparison.
                if ( paramRef.ulNameLength == paramCur.ulNameLength ) 
                {
                    //compare the contents, check if we want case sensitive or not.            
                    if ( fgParamNameCase )
                        bNameChange = !CompareBuffer(   _pRefBuf+refBase+paramRef.ulNameStart, 
                                                        _pCurBuf+curBase+paramCur.ulNameStart,
                                                        max( paramRef.ulNameLength, paramCur.ulNameLength) );
                    else
                        bNameChange = !CompareBuffer(   _pRefBuf+refBase+paramRef.ulNameStart, 
                                                        _pCurBuf+curBase+paramCur.ulNameStart,
                                                        max( paramRef.ulNameLength, paramCur.ulNameLength) );
                }
                else 
                    bNameChange = true;
            }
            else
            {
                char szNameCur[64] = {0};

                // only make sure the current name also has the _MIDL_ keyword.
                lstrcpyn( szNameCur, _pCurBuf+curBase+paramCur.ulNameStart, max(63, paramCur.ulNameLength));

                if (!strstr( szNameCur, "_MIDL_"))
                {
                    bNameChange = true;
                }
            }
        }

ReplaceCheck:
        // if there was a change in the parameter, find out if this parameter is moved to another location
        // in the parameter list. We look for an exact match in this case, since this is only additional 
        // information
        if ( bNameChange || bTypeChange )
        {
            PARAMINFO   paramTmp;

            for ( k=0; k< pCurList->Size(); k++ )
            {
                pCurList->GetAt( k, &paramTmp );

                if ( ( !paramTmp.fUsed ) && 
                     ( paramTmp.ulParamLength == paramCur.ulParamLength ) &&
                     ( CompareBuffer( _pRefBuf+refBase+paramRef.ulTypeStart, 
                                        _pCurBuf+curBase+paramTmp.ulTypeStart, 
                                            paramTmp.ulParamLength) ) )
                {
                    // we have found the parameter at another location.
                    bReplaced = true;

                    // we will only report the replacement, to simplify
                    bTypeChange = false;
                    bNameChange = false;

                    // mark the parameter in the current list as touched, so that 
                    // whatever parameter we check in the reference list does not get
                    // processed against this. ( perf. )
                    paramTmp.fUsed = true;
                    pCurList->Set( k, paramTmp );
                }
            }
        }
    
        // if we found the parameter  at the same location 
        if ( bReplaced || bNameChange || bTypeChange )
        {
            EnsureTitle(TRUE);

            g_ulAppRetVal |= CHANGE_PARAMCHANGE;

            // we copy the type and the name. The lengths are +1 since the function requires
            // us to calculate the NULL character too.

            lstrcpyn( szType, _pRefBuf+refBase+paramRef.ulTypeStart, paramRef.ulTypeLength+1 );

            if ( paramRef.ulNameStart )
                lstrcpyn( szName, _pRefBuf+refBase+paramRef.ulNameStart, paramRef.ulNameLength+1 );

            // fill the string with ' - Parameter xx', so that we can add the change type
            lstrcpy( szBuff, _szLogBuff);
            lstrcat( szBuff, " - Parameter " );
            lstrcat( szBuff, szType );
            lstrcat( szBuff, " ");
            lstrcat( szBuff, szName );

            // if replaced, then name and type change flags are false.
            if ( bReplaced  )
            {
                // output replacement information
                lstrcat( szBuff, " has been replaced" );
            }
            else 
            {
                // was this parameter removed
                if ( bNameChange && bTypeChange )
                {
                    // output information that shows the name change
                    lstrcat( szBuff, " has been removed");
                }
                else
                {
                    if ( bNameChange )
                    {
                        // output information that shows the name change
                        lstrcat( szBuff, " name has been modified");

                        // for name only changes, mark the parameter as used.
                        paramCur.fUsed = true;
                        pCurList->Set( l, paramCur );
                    }
            
                    if ( bTypeChange )
                    {
                        // output information that shows the type change.
                        lstrcat( szBuff, " type has been modified");
                    }
                }
            }

            WriteLine(_fileDiff, szBuff, -1);
        }
        else
        {
            // mark the parameter, everything is OK, move on.
            paramCur.fUsed = true;
            pCurList->Set( l, paramCur );
        }
    }

    // find the parameters that were added.
    for ( l=0; l<pCurList->Size(); l++ )
    {
        pCurList->GetAt( l, &paramCur);

        // if this parameter was not used, then it means that it was added.
        if ( !paramCur.fUsed )
        {
            EnsureTitle(TRUE);

            g_ulAppRetVal |= CHANGE_PARAMCHANGE;

            // copy the parameter name as a whole
            lstrcpyn( szName, _pCurBuf+curBase+paramCur.ulTypeStart, paramCur.ulParamLength+1 );

            // fill the string with ' - Parameter xx', so that we can add the change type
            lstrcpy( szBuff, _szLogBuff);
            lstrcat( szBuff, " - Parameter " );
            lstrcat( szBuff, szName );
            lstrcat( szBuff, " was added");
            WriteLine( _fileDiff, szBuff, -1);

        }
    }

    delete pCurList;
    delete pRefList;
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
void 
CCompareInterface::TokenizeParameters(  char* pBuf, 
                                        unsigned long nCnt, 
                                        CAutoArray<PARAMINFO>* pList )
{
    unsigned long   i,j;
    PARAMINFO       paramInfo;
    bool            bInBracket = false;

    paramInfo.ulTypeStart = 0;

    for( i=0; i<=nCnt ; i++ )
    {
        // since we are coming from left, and going right, we will first see the 
        // opening and then the closing bracket
        if ( pBuf[i] == '[' ) 
            bInBracket = true;
        if ( pBuf[i] == ']' )
            bInBracket = false;

        // if we reached a comma that was not inside a bracket, or reached the end
        // and the end is an opening parenthesis
        if ( ((pBuf[i] == ',') && !bInBracket ) || ( i == nCnt ) )
        {
            paramInfo.ulParamLength = i - paramInfo.ulTypeStart;
            paramInfo.fUsed = false;

            // digest the type and name here ! ! !
            for ( j = paramInfo.ulTypeStart+paramInfo.ulParamLength-1; j > 0 ; j-- )
            {
                // go from the end of the parameter, towards the beginning, 
                // searching for a space character, or the beginning of the parameter block
                if ( *(pBuf + j) == ' ') 
                {
                    paramInfo.ulNameStart = j + 1;
                    paramInfo.ulTypeLength = j - paramInfo.ulTypeStart;
                    paramInfo.ulNameLength = paramInfo.ulTypeStart + paramInfo.ulParamLength - paramInfo.ulNameStart;
                    break;
                }
            }

            // we could not find a parameter when we parsed through, it means a void..
            // double check for void 
            if (( j==0 ) && ( *pBuf == 'v' ) && (*(pBuf+1) == 'o'))
            {
                paramInfo.ulTypeStart = 0;
                paramInfo.ulTypeLength = 4;
                paramInfo.ulParamLength = 4;
                paramInfo.ulNameStart = 0;
                paramInfo.ulNameLength = 0;

                pList->Append( paramInfo );
            }
            else
            {
                // we should never ever reach zero.
                if ( j==0 )
                    assert( false );

                pList->Append( paramInfo );
    
                // skip over the comma
                i++;

                // the name starts next to the space
                paramInfo.ulTypeStart = i+1;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\btools\tldiff\tldiff.cxx ===
#include <windows.h>
#include <iostream.h>
#include <iomanip.h>
#include <assert.h>
#include <stdio.h>
#include "array.hxx"
#include "types.h"
#include "icomp.hxx"
#include "CoComp.hxx"
#include "errors.hxx"


//
// PROTOTYPES
//
void WriteLine(HANDLE file, char* pBuff, int nLen);
unsigned long FindEndOfLine(char* pBuff );
BLOCK_TYPE GetBlockType(char* pchData, char* pchTerm );
bool GetBlock(HANDLE file, INDEX* pIdx, char** ppTarget = NULL, unsigned long* pulBlockBase=NULL );
void DisplayError(UINT uError, UINT uLineNum, ostream& out = cerr);
extern void TokenizeAttributes( char* pBuf, unsigned long nCnt, CAutoArray<ATTRINFO>* pList );
extern long CompareAttributeBlock(  char * pRefBuf, CAutoArray<ATTRINFO>* pRefList, char * pCurBuf, 
                                                    CAutoArray<ATTRINFO>* pCurList);
//
// GLOBALS
//
bool fgCoClass;
bool fgInterface;
bool fgDispInterface;
bool fgMethodAttribute;
bool fgMethodParameter;
bool fgInterfaceAttr;
bool fgFlush;

bool fgParamNames;
bool fgParamTypes;
bool fgParamNameCase;
bool fgParamTypeCase;

unsigned long g_ulAppRetVal;
bool g_fWriteToStdOut = false;

char g_szDiffFileName[14] = {0};   // Will contain differences 
char g_szNewFileName[14]  = {0};   // Will contain added interfaces, etc.
char g_szCurFileName[256] = {0};   // Contains tlviewer output for current tlb
char g_szRefFileName[256] = {0};   // Contains tlviewer output for new tlb

char* g_pszMethodAttr = NULL;

#define BUFFER_SIZE(buf) (sizeof(buf)/sizeof(buf[0]))


//
// Test function to test the index structure on the original MSHTML.OUT
// without debugging the system. The mirror file and the original fileCur
// should only be different with their blanks.
//
void CreateTestMirror(HANDLE fileCur, CAutoArray<INDEX>* rgFileIdx)
{
    INDEX    idxTmp;
    char*    pTmp;
    DWORD    dwRead;
    
    HANDLE  fileData = CreateFile("mirror", GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL, NULL);
    
    if (INVALID_HANDLE_VALUE == fileData)
    {
        DisplayError(ERR_OPENINGMIRROR, __LINE__);
        return;
    }
    
    // Write this stuff to a file.
    for (int i = 0; i < rgFileIdx->Size(); i++)
    {
        long nLen;
        
        //get records
        rgFileIdx->GetAt(i, &idxTmp);
        
        nLen = idxTmp.ulEndPos - idxTmp.ulAttrStartPos;

        //allocate memory to read
        pTmp = new char[nLen+1];
        
        if (!pTmp)  // Hopefully will never happen but just in case.
        {
            DisplayError(ERR_OUTOFMEMORY, __LINE__);
            return;
        }
        
        // Read data
        SetFilePointer( (HANDLE)fileCur, idxTmp.ulAttrStartPos, NULL, FILE_BEGIN);
        ReadFile( (HANDLE)fileCur, pTmp, nLen, &dwRead, NULL);
        
        // Terminate string
        pTmp[ nLen ]=0;
        
        // Write to file
        WriteLine(fileData, pTmp, nLen);
        
        // Release mem.
        delete [] pTmp;
    }
    
    CloseHandle(fileData);
}

//
//
//
void MarkAttrChanges(HANDLE fileCur, CAutoArray<INDEX>* rgFileIdx, char* pszDiffFileName)
{
   INDEX   idxTmp1, idxTmp2;
   DWORD   dwRead;
   HANDLE  fileLocal = INVALID_HANDLE_VALUE;
   char   szEntry[160];
   char   szTmp[80];

   // First, add the modified ATTR tags to the difference file.
   if (g_fWriteToStdOut)
   {
       fileLocal = GetStdHandle(STD_OUTPUT_HANDLE);
   }
   else
   {
      fileLocal = CreateFile(pszDiffFileName, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL, NULL);
   }

   if (INVALID_HANDLE_VALUE == fileLocal)
   {
       DisplayError(ERR_OPENINGDIFF, __LINE__);
       return;
   }

   SetFilePointer(fileLocal, 0, NULL, FILE_END);

   // An attribute cannot be the last block in a file, so we
   // can go until size - 1
   for ( int i = 0; i < rgFileIdx->Size() - 1; i++)
   {
      // Get record 
      rgFileIdx->GetAt(i, &idxTmp1);

      // If it is an unmatched attribute, analyze
      if ((!idxTmp1.fCopied) && (idxTmp1.blockType == BLK_ATTR))
      {
         // Get the next block
         rgFileIdx->GetAt(i + 1, &idxTmp2);

         // If the next block is valid and it is matched, then the attributes
         // for it must have changed.
            //
         if ((idxTmp2.blockType != BLK_NONE) && 
            (idxTmp2.fCopied))
         {
            // Take a note of this in the differences file
            lstrcpy(szEntry, "Attributes for ");

            // Read the data
            SetFilePointer((HANDLE)fileCur, idxTmp2.ulStartPos, NULL, FILE_BEGIN);
            ReadFile((HANDLE)fileCur, szTmp, 79, &dwRead, NULL);

            // Add the type and the name of the block here.
            unsigned int j = 0;
            int nSpaceCnt = 0;

            while (j < min(79, dwRead))
            {
               if (szTmp[j] == ' ') 
                  nSpaceCnt++;

               if (nSpaceCnt == 2)
                  break;

               j++;
            }

            if (nSpaceCnt!=2)
               break;

            szTmp[j] = 0;

            lstrcat(szEntry, szTmp);
            lstrcat(szEntry, " changed ");

            WriteLine(fileLocal, szEntry, -1);

            idxTmp1.fCopied = true;
            rgFileIdx->Set(i, idxTmp1);
         }
      }
   }

    // Don't want to close the stdout. Otherwise, write
    // operations go nowhere. We will close stdout
    // at the end of this program.
    //
    if (!g_fWriteToStdOut)
        CloseHandle(fileLocal);
}

//
//
//
void FlushDifferences(HANDLE fileCur, CAutoArray<INDEX>* rgFileIdx)
{
    INDEX   idxTmp;
    DWORD   dwRead;
    char*   pTmp;
    bool    fCheck;
    HANDLE  fileDiff = INVALID_HANDLE_VALUE;

    if (g_fWriteToStdOut)
    {
        fileDiff = GetStdHandle(STD_OUTPUT_HANDLE);
    }
    else
    {
       fileDiff = CreateFile(g_szNewFileName, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL, NULL);
    }

    if (INVALID_HANDLE_VALUE == fileDiff)
    {
        DisplayError(ERR_OPENINGNEW, __LINE__);
        return;
    }
    
    // Write this stuff to a file.
    bool fFirst = true;

    for (int i = 0; i < rgFileIdx->Size(); i++)
    {
        // Get records
        rgFileIdx->GetAt(i, &idxTmp);

        switch ( idxTmp.blockType )
        {
             case BLK_INTERFACE:
                if (!fgInterface)
                   fCheck = false;
                break;

             case BLK_DISPINT:
                if (!fgDispInterface)
                   fCheck = false;
                break;

             case BLK_COCLASS:
                if (!fgCoClass)
                   fCheck = false;

             default:
                fCheck = true;
        }

        if ((!idxTmp.fCopied) && (fCheck))
        {
            // Allocate memory to read
            pTmp = new char[idxTmp.ulEndPos - idxTmp.ulStartPos+1];
         
            // Read data
            SetFilePointer((HANDLE)fileCur, idxTmp.ulStartPos, NULL, FILE_BEGIN);
            ReadFile((HANDLE)fileCur, pTmp, idxTmp.ulEndPos - idxTmp.ulStartPos, &dwRead, NULL);
         
            // Terminate string
            pTmp[idxTmp.ulEndPos - idxTmp.ulStartPos ]=0;
         
            if (fFirst)
            {
                fFirst = false;
            
                // Write out a blank line if writing to stdout
                //
                if (g_fWriteToStdOut)
                    WriteLine(fileDiff, "", -1);
            
                WriteLine(fileDiff, "------------------------------------------", -1);
                WriteLine(fileDiff, "NEW BLOCKS", -1);
                WriteLine(fileDiff, "------------------------------------------", -1);
                WriteLine(fileDiff, "", -1);
            }

            // Write the block
            WriteLine(fileDiff, pTmp, idxTmp.ulEndPos - idxTmp.ulStartPos);
         
            // Put some empty lines after the block to make it easier to read
            WriteLine(fileDiff, "", -1);
         
         // ScotRobe: only want to set g_ulAppRetVal to an error 
         // code if something was changed. We don't want to stop the
         // build process if something was added. Adding is okay,
         // change is bad.
         //
/*       switch (idxTmp.blockType)
         {
            case BLK_INTERFACE:
               ulTmp |= CHANGE_ADDINTERFACE;
               break;

            case BLK_DISPINT:
               ulTmp |= CHANGE_ADDDISPINT;
               break;

            case BLK_COCLASS:
               ulTmp |= CHANGE_ADDCOCLASS;
               break;

            case BLK_ATTR:
               ulTmp |= CHANGE_ADDATTRIBUTE;
               break;

            default:
               break;
         }
*/

            // Release memory.
            delete [] pTmp;
        }
    }

    // Don't want to close the stdout if we are writing to it.
    // Otherwise, write operations go nowhere. We will close
    // stdout at the end of main.
    //
    if (!g_fWriteToStdOut)
        CloseHandle(fileDiff);

    // Uncomment this line if you uncomment the above switch statement.
    //
    //g_ulAppRetVal |= ulTmp;  
}

//----------------------------------------------------------------------------
// Function :  PrepareIndex
// Description :  Prepare the index for a given file by creating an array of
//             INDEX structures.
// Parameters  :  
//       fileCur              : handle of current file
//       CAutoArray<INDEX>*   : pointer to the index array
// 
// Returns     :  void
//----------------------------------------------------------------------------
void PrepareIndex (HANDLE fileCur, CAutoArray<INDEX>* rgFileIdx)
{
    INDEX    idxCurr = {BLK_NONE, 0};
    INDEX    idxAttr;
    
    bool    fContinue = true;
    
    // Create an index for the file that is to be analyzed.
    while (fContinue)
    {
        fContinue = GetBlock(fileCur, &idxCurr);
        
        if (fContinue)
        {
            switch (idxCurr.blockType)
            {
            case BLK_ATTR:
                idxAttr = idxCurr;
                break;
                
            case BLK_DISPINT:
            case BLK_INTERFACE:
            case BLK_COCLASS:
                assert(idxAttr.blockType == BLK_ATTR);
                
                // copy the attribute start and end positions to the current block's
                // index structure.
                idxCurr.ulAttrStartPos = idxAttr.ulStartPos;
                idxCurr.ulAttrEndPos = idxAttr.ulEndPos;
                
                //add the data to the index 
                rgFileIdx->Append(idxCurr);

                // reset
                idxAttr.blockType = BLK_NONE;
                idxAttr.ulStartPos = idxAttr.ulEndPos = 0;
                
                break;

/* LEAVE TYPEDEFs out of this for now, since there are problems with them.
                The end of the typedef block is coded as it should be a semicolon. However, the semicolon could be
                used for anything inside the typedef when the typedef is a structure. This causes a false termination
                of the typedef.
    Solution:
                Find the '}', however, end the block at the end of the line that contains the '}'

            case BLK_TYPEDEF:
                // copy the block as it is. However, for the mirror file use, make sure the
                // attribute information starts and ends with the actual buffer.
                idxCurr.ulAttrStartPos = idxCurr.ulStartPos;
                
                //add the data to the index 
                rgFileIdx->Append(idxCurr);

                // reset
                idxAttr.blockType = BLK_NONE;
                idxAttr.ulStartPos = idxAttr.ulEndPos = 0;
                break;
*/

            }
        }
    }
}

//
//
//
bool 
CompareCoClass( char* pCurBuf, char* pRefBuf, 
               char * pAttrCur, char * pAttrRef, HANDLE fileDiff)
{
    bool                    bRes = true;
    char                    szClassName[64] = {0};
    CCompareCoClass *       pCompareCoClass = NULL;
    CAutoArray<ATTRINFO>*   pCurList = new CAutoArray<ATTRINFO>;
    CAutoArray<ATTRINFO>*   pRefList = new CAutoArray<ATTRINFO>;
    long                    lRes;
    
    // compare the names of the coclasses. The comparison is done until we reach the 
    // end of the longer name
    for ( unsigned long ulIdx = LEN_COCLASS+1; 
    (pCurBuf[ulIdx] != 0x20) || (pRefBuf[ulIdx] != 0x20); 
    ulIdx++ )
    {
        if ( pCurBuf[ulIdx] != pRefBuf[ulIdx] )
            goto Fail;        //if the names don't match, these are not the coclasses that we
        //want to compare.
        
        szClassName[ulIdx-LEN_COCLASS-1] = pCurBuf[ulIdx]; //get the coclass name 
        
        //OVERFLOW check
        assert( ulIdx<64 );              //sanity check to stop a corrupt file from killing us.
        if ( ulIdx==64 )
            goto Fail;
    }
    
    TokenizeAttributes( pAttrRef+1, lstrlen(pAttrRef) - 2, pRefList );
    TokenizeAttributes( pAttrCur+1, lstrlen(pAttrCur) - 2, pCurList );

    lRes = CompareAttributeBlock( pAttrRef+1, pRefList, pAttrCur+1, pCurList);

    if (lRes != 0)
    {
        char    szBuf[MAX_PATH];

        if (lRes == CHANGE_UUIDHASCHANGED)
        {
            sprintf(szBuf, "\nGUID was modified for the coclass %s", szClassName);
        }
        else
        {
            sprintf(szBuf, "\nUnexpected error when comparing attributes for coclass %s", szClassName);
        }

        WriteLine(fileDiff, szBuf, -1);

        g_ulAppRetVal |= CHANGE_BLOCKREMOVED;

        goto Fail;
    }

    pCompareCoClass = new CCompareCoClass( pCurBuf, pRefBuf, fileDiff, szClassName );
    
    pCompareCoClass->FindAdditionsAndChanges();
    pCompareCoClass->FindRemovals();
    
Cleanup:
    if (pCompareCoClass)
        delete pCompareCoClass;
    return bRes;
    
Fail:
    bRes= false;
    goto Cleanup;
}

//
//
//
bool 
CompareInterface( BLOCK_TYPE blockType, char* pCurBuf, char* pRefBuf, 
                      char * pAttrCur, char * pAttrRef, HANDLE fileDiff)
{
    bool                    bRes = true;
    unsigned long           ulNameOffset=0; //offset to start reading for the name of the interface on both blocks.
    char                    szIntName[64] = {0};    //initialize to zero so we don't deal with termination later.
    CCompareInterface *     pCompareInterface = NULL;
    CAutoArray<ATTRINFO>*   pCurList = new CAutoArray<ATTRINFO>;
    CAutoArray<ATTRINFO>*   pRefList = new CAutoArray<ATTRINFO>;
    long                    lRes;

    //assign the offset for the first space
    ulNameOffset = ( blockType==BLK_DISPINT ) ? LEN_DISPINT+1 : LEN_INTERFACE+1;
 
    // The format of the name is: interface/dispinterface_name_{
    // Compare until the space character is reached for either of the names. 
    for (unsigned long ulIdx = ulNameOffset; 
    (pCurBuf[ulIdx] != 0x20) || (pRefBuf[ulIdx] != 0x20); 
    ulIdx++ )
    {
        if ( pCurBuf[ulIdx] != pRefBuf[ulIdx] )
            goto Fail;                     //if the name does not match, this is not 
        //the interface we are looking to compare with
        
        szIntName[ulIdx-ulNameOffset] = pCurBuf[ulIdx]; //get the interface name simultaneously
        
        //OVERFLOW CHECK
        assert( ulIdx<64 );              //sanity check to stop a corrupt file from killing us.
        if ( ulIdx==64 )
            goto Fail;
    }
    
    TokenizeAttributes( pAttrRef+1, lstrlen(pAttrRef) - 2, pRefList );
    TokenizeAttributes( pAttrCur+1, lstrlen(pAttrCur) - 2, pCurList );

    lRes = CompareAttributeBlock( pAttrRef+1, pRefList, pAttrCur+1, pCurList);

    if (lRes != 0)
    {
        char    szBuf[MAX_PATH];

        switch(lRes)
        {
        case CHANGE_DUALATTRADDED:
            sprintf(szBuf, "\nDual attribute was added to the interface %s", szIntName);
            break;

        case CHANGE_DUALATTRREMOVED:
            sprintf(szBuf, "\nDual attribute was removed from the interface %s", szIntName);
            break;

        case CHANGE_UUIDHASCHANGED:
            sprintf(szBuf, "\nIID was changed for the interface %s", szIntName);
            break;

        default:
            break;
        }

        WriteLine(fileDiff, szBuf, -1);

        g_ulAppRetVal |= CHANGE_BLOCKREMOVED;

        goto Fail;
    }

    pCompareInterface = new CCompareInterface(pCurBuf, pRefBuf, fileDiff, szIntName, blockType, g_pszMethodAttr);

    pCompareInterface->FindAdditionsAndChanges();
    pCompareInterface->FindRemovals();
    
Cleanup:
    if ( pCompareInterface )
        delete pCompareInterface;
    return bRes;
    
Fail:
    bRes= false;
    goto Cleanup;
}

//
//
//
bool CompareBlocks(HANDLE fileCur, CAutoArray<INDEX>* rgFileIdx, INDEX* pIdxRef, 
                   char* pRefBuf, char * pAttrRef, HANDLE fileDiff)
{
    INDEX   idxCur  = {BLK_NONE, 0}; // Index record for the current file's block
    char *  pCurBuf = NULL;
    char *  pAttrCur = NULL;
    DWORD   dwRead;
    BOOL    bRes = FALSE;
    int     nRes = 1;
    
    //we have index information about the reference file block
    //use it to narrow down the possibilities
    //
    //walk through the index and find the matching block types
    //with matching lengths.
    for (int i = 0; i < rgFileIdx->Size(); i++)
    {
        rgFileIdx->GetAt(i, &idxCur);
        
        //if the block we read from the reference file matches this
        //block's type 
        if ((idxCur.blockType == pIdxRef->blockType) &&
            (!idxCur.fCopied))
        {
            //read the block from the current file, using the
            //index record
            int nLen = idxCur.ulEndPos - idxCur.ulStartPos;
            pCurBuf = new char[nLen+1];
            
            int nAttrLen = idxCur.ulAttrEndPos - idxCur.ulAttrStartPos;
            pAttrCur = new char[nAttrLen+1];
            
            SetFilePointer((HANDLE)fileCur, idxCur.ulStartPos, NULL, FILE_BEGIN);
            bRes = ReadFile((HANDLE)fileCur, pCurBuf, nLen, &dwRead, NULL);
            
            SetFilePointer((HANDLE)fileCur, idxCur.ulAttrStartPos, NULL, FILE_BEGIN);
            bRes = ReadFile((HANDLE)fileCur, pAttrCur, nAttrLen, &dwRead, NULL);
            
            // Terminate the string that was just read from the current file.
            pCurBuf[nLen] = 0;
            pAttrCur[nAttrLen] = 0;
            
            //comparison behavior may change by the type of the block to be
            //compared
            switch ( pIdxRef->blockType )
            {
            case BLK_COCLASS:
                if (fgCoClass)
                    nRes = !CompareCoClass(pCurBuf, pRefBuf, pAttrCur, pAttrRef, fileDiff);
                else
                    nRes = 0;
                break;
                
            case BLK_DISPINT:
                if (fgDispInterface)
                {
                    //if the length of two blocks is the same, there is a chance that 
                    //they are the same block. So, compare the memory before going into
                    //a long and detailed analysis
                    nRes = 1;
                    if (( pIdxRef->ulEndPos - pIdxRef->ulStartPos) == (unsigned long)nLen )
                    {
                        nRes = memcmp(pCurBuf, pRefBuf, nLen);
                    }

                    if (!nRes)
                        nRes = memcmp( pAttrCur, pAttrRef, max(lstrlen(pAttrCur), lstrlen(pAttrRef)));
                    
                    // The memory comparison failed. Go into details.
                    if ( nRes )
                        nRes = !CompareInterface(pIdxRef->blockType, pCurBuf, pRefBuf, pAttrCur, pAttrRef, fileDiff);
                }
                else
                {
                    // although we did not compare, set the flag so that 
                    // we mark the index as if we did compare to avoid false errors.
                    nRes = 0;
                }
                break;
                
            case BLK_INTERFACE:
                if (fgInterface)
                {
                    //if the length of two blocks is the same, there is a chance that 
                    //they are the same block. So, compare the memory before going into
                    //a long and detailed analysis
                    nRes = 1;
                    if ((pIdxRef->ulEndPos - pIdxRef->ulStartPos) == (unsigned long)nLen)
                    {
                        nRes = memcmp(pCurBuf, pRefBuf, nLen);
                    }
                    
                    if (!nRes)
                        nRes = memcmp( pAttrCur, pAttrRef, max(lstrlen(pAttrCur), lstrlen(pAttrRef)));

                    //the memory comparison failed. Go into details.
                    if ( nRes )
                        nRes = !CompareInterface(pIdxRef->blockType, pCurBuf, pRefBuf, pAttrCur, pAttrRef, fileDiff);
                }
                else
                {
                    // although we did not compare, set the flag so that 
                    // we mark the index as if we did compare to avoid false errors.
                    nRes = 0;
                }
                break;
                
            default:
                nRes = memcmp(pCurBuf, pRefBuf, nLen);
                break;
            }
            
            if (nRes == 0)
            {
                // Mark the current index record, so it's not used anymore.
                // This is true if the block name is found, regardless of the content 
                // comparison results.
                idxCur.fCopied = true;
                rgFileIdx->Set(i, idxCur);
                break;
            }
            
            
            delete [] pCurBuf;
            pCurBuf = NULL;
        }
    }
    
    if (pCurBuf)
    {
        delete [] pCurBuf;
        pCurBuf = NULL;
    }
    
    return (nRes ? false : true);
}

//
// Compare two files, by walking through the reference file and using the index
// to read the current file.
//
void CompareFiles(HANDLE fileCur, HANDLE fileRef, 
                  CAutoArray<INDEX>* rgFileIdx, HANDLE fileDiff)
{
    INDEX           idxRef = {BLK_NONE, 0};        // index record for the reference file block
    INDEX           idxAttr = {BLK_NONE, 0};
    
    bool            fContinue = true;
    unsigned long   ulOffset;
    char *          pRefBuf = NULL;
    char *          pAttrBuf = NULL;
    bool            fFound = false;
    
    
    //create an index for the file that is to be analyzed.
    while ( fContinue )
    {
        ulOffset = 0;
        fContinue = GetBlock(fileRef, &idxRef, &pRefBuf, &ulOffset);
        
        if (fContinue)
        {
            switch (idxRef.blockType)
            {
            case BLK_ATTR:
                int nLen;

                idxAttr = idxRef;   // the last attribute block is remembered, to be used with the 
                                    // interface, dispinteface and coclass comparison.
                // if we currently have a block, release it
                if (pAttrBuf)
                {
                    delete [] pAttrBuf;
                    pAttrBuf = NULL;
                }

                nLen = idxAttr.ulEndPos - idxAttr.ulStartPos;
                
                pAttrBuf = new char[nLen+1];

                memcpy( pAttrBuf, pRefBuf+ulOffset, nLen);

                pAttrBuf[nLen] = 0;

                break;
                
            case BLK_DISPINT:
            case BLK_INTERFACE:
            case BLK_COCLASS:
                
                assert(idxAttr.blockType == BLK_ATTR);

                idxRef.ulAttrStartPos = idxAttr.ulStartPos;
                idxRef.ulAttrEndPos = idxAttr.ulEndPos;

                fFound = CompareBlocks( fileCur, rgFileIdx, &idxRef, &pRefBuf[ulOffset], pAttrBuf, fileDiff);
                
                if (!fFound)
                {
                    char szBuf[MAX_PATH];
                    
                    sprintf(szBuf, "\n%s- Removed", strtok(&pRefBuf[ulOffset], "{"));
                    WriteLine(fileDiff, szBuf, -1);
                    g_ulAppRetVal |= CHANGE_BLOCKREMOVED;
                }
                
                //release the memory allocated by the GetBlock function
                delete [] pRefBuf;
                pRefBuf = NULL;

                delete [] pAttrBuf;
                pAttrBuf = NULL;

                idxAttr.blockType = BLK_NONE;
                break;
                
/* ferhane: see comments in PrepareIndex
                case BLK_TYPEDEF:
                break;
*/ 
            }
        }
    }
}

void DisplayError(UINT uError, UINT uLineNum /* = __LINE__ */, ostream& out /* = cerr*/)
{
    assert(uError < BUFFER_SIZE(pszErrors));

    out.fill('0');
    out << "TlDiff.exe(" << uLineNum << ") : error E9"
        << setw(3) << uError << ": " << pszErrors[uError] << endl;
}

/*----------------------------------------------------------------------------
 -----------------------------------------------------------------------------*/
bool ProcessINIFile(char* lpszIniFile)
{
    bool    fRet = true;
    char    szFileNames[] = {"FileNames"};
    char    szCheckRules[] = {"CheckRules"};
    char    szMethodAttr[] = {"BreakingMethodAttributes"};
    DWORD   dwBuffSize = 256;
    DWORD   dwBuffSizeOld;

    char*  pszDirectory = new char[dwBuffSize + 13];

    dwBuffSize = GetCurrentDirectory(dwBuffSize, pszDirectory);
    if (dwBuffSize > 256)
    {
        // we need a larger buffer for path.
        delete pszDirectory;
        pszDirectory = NULL;

        pszDirectory = new char[dwBuffSize+13];
        if (!pszDirectory)
        {
            DisplayError(ERR_OUTOFMEMORY, __LINE__);
            fRet = false;
            goto Error;
        }

        GetCurrentDirectory( dwBuffSize, pszDirectory );
    }

    lstrcat(pszDirectory, "\\");
    lstrcat(pszDirectory, lpszIniFile);

    // Make sure the INI file exists
    // GetFileAttributes returns 0xFFFFFFFF if the 
    // file doesn't exist.
    //
    if (0xFFFFFFFF == GetFileAttributes(pszDirectory))
    {
        DisplayError(ERR_INIFILENOTFOUND, __LINE__);
        fRet = false;
        goto Error;
    }

/*
    if (!GetPrivateProfileString(szFileNames, "CurrentFile", "cur.out", g_szCurFileName, 255, pszDirectory))
    {
        DisplayError( ERR_CURRFILENAME );
        bRet = FALSE;
        goto Error;
    }

    if (!GetPrivateProfileString(szFileNames, "ReferenceFile", "ref.out", g_szRefFileName, 255, pszDirectory))
    {
        DisplayError( ERR_REFFILENAME );
        bRet = FALSE;
        goto Error;
    }
*/

    if (!g_fWriteToStdOut)
    {
        // Specify a NULL default name so that we can check to see
        // if the file name wasn't specified in the INI file.
        //
        // If either the difference file or new file name is missing
        // from the INI, we write to stdout.
        //
        GetPrivateProfileString(szFileNames, "DifferenceFile", NULL, g_szDiffFileName,
                                BUFFER_SIZE(g_szDiffFileName) - 1, pszDirectory);

        if (NULL == g_szDiffFileName[0])
        {
            g_fWriteToStdOut = true;
        }
        else  
        {
            GetPrivateProfileString(szFileNames, "AdditionsFile", NULL, g_szNewFileName, 
                                    BUFFER_SIZE(g_szNewFileName) - 1, pszDirectory);

            if (NULL == g_szNewFileName[0])
            {
                g_fWriteToStdOut = true;
            }
        }
    }

    fgCoClass = !!(GetPrivateProfileInt(szCheckRules, "Coclass", 1, pszDirectory));

    fgInterface = !!(GetPrivateProfileInt(szCheckRules, "Interface", 1, pszDirectory));

    fgDispInterface = !!(GetPrivateProfileInt(szCheckRules, "Dispinterface", 1, pszDirectory));

    fgMethodParameter = !!(GetPrivateProfileInt(szCheckRules, "MethodParameter", 1, pszDirectory));

    fgMethodAttribute = !!(GetPrivateProfileInt(szCheckRules, "MethodAttribute", 1, pszDirectory));

    fgInterfaceAttr = !!(GetPrivateProfileInt(szCheckRules, "InterfaceAttribute", 1, pszDirectory));

    fgFlush = !!(GetPrivateProfileInt(szCheckRules, "GenerateAdditionsFile", 1, pszDirectory));

    fgParamNames = !!(GetPrivateProfileInt(szCheckRules, "ParameterName", 1, pszDirectory));
    fgParamTypes = !!(GetPrivateProfileInt(szCheckRules, "ParameterType", 1, pszDirectory));
    fgParamNameCase= !!(GetPrivateProfileInt(szCheckRules, "ParameterNameCase", 1, pszDirectory));
    fgParamTypeCase= !!(GetPrivateProfileInt(szCheckRules, "ParameterTypeCase", 1, pszDirectory));

    // get breaking method attributes.
    g_pszMethodAttr = new char[dwBuffSize];
    dwBuffSizeOld = 0;

    // down side of the APIs... It won't tell it needs more, it returns size - 1 or
    // size - 2 to indicate that it does not have enough buffer.
    //
    while (dwBuffSize < dwBuffSizeOld - 2)
    {
        dwBuffSizeOld = dwBuffSize;     // reset the condition.

        // Read into the buffer.
        dwBuffSize = GetPrivateProfileString(szMethodAttr, NULL, "none", g_pszMethodAttr,
                                             dwBuffSize, pszDirectory);

        // Did we have enough buffer size? 
        //
        if  (dwBuffSize < dwBuffSizeOld - 2)
        {
            break;
        }

        // Reallocate and try again.
        //
        delete g_pszMethodAttr;
        dwBuffSize = dwBuffSize * 2;
        g_pszMethodAttr = new char[dwBuffSize];
    }

Error:
    if (pszDirectory)
        delete pszDirectory;

    return fRet;
}

void ShowUsage()
{
    cout << endl 
         << "Usage: tldiff [-?|h] [-s] -f SettingsFile CurFile.out RefFile.out" << endl << endl
         << "Where: -?|h = Show usage. (These arguments are exclusive from the rest)" << endl
         << "       -s = write output to stdout." << endl
         << "       -f = use SettingsFile for initialization data." << endl
         << "       CurFile.out = Tlviewer file containing data for current tlb" << endl
         << "       RefFile.out = Tlviewer file containing data for new tlb"     << endl
         << endl;
}

bool ProcessArgs(int argc, char* argv[])
{
    char*  pszIniFile = NULL;
    bool    fSuccess   = true;
    int     i;

    // Check for "Show usage" request.
    //
    if ((argc >= 2) && ('-' == argv[1][0]) && ('?' == argv[1][1] || 'h' == argv[1][1]))
    {
        ShowUsage();
        return false;
    }

    if (argc < 5)
    {
        DisplayError(ERR_MISSINGARGS, __LINE__);
        goto Error;
    }

    // Note: i is initialized up top.
    //
    for (i=1; i < argc; i++)
    {
        if ('-' == argv[i][0])
        {
            switch(argv[i][1])
            {
            case 'f': 
                {
                    // The file is the next argument
                    i++;
                    if (i >= argc)
                    {
                        DisplayError(ERR_INIFILENAME, __LINE__);
                        goto Error;
                    }

                    int nBufSize = lstrlen(argv[i]) + 1;
                    pszIniFile = new char[nBufSize];

                    if (!pszIniFile)
                    {
                        DisplayError(ERR_OUTOFMEMORY, __LINE__);
                        goto Error;
                    }

                    lstrcpyn(pszIniFile, argv[i], nBufSize);

                    break;
                }

            case 's':
                g_fWriteToStdOut = true;
                break;

            // Stop the build process for invalid arguments.
            // This ensures that somebody didn't make a typo.
            // 
            default:
                DisplayError(ERR_INVALIDARG, __LINE__);
                goto Error;
            }
        }
        else
        {
            // Retrieve the current and new tlviewer output files.
            // These files must be in order. Therefore, I assume that
            // if the current file name variable is not set, then it's time
            // to set the current file name variable. If it is set, it's time
            // to set the new file name variable.
            //
            if (NULL == g_szCurFileName[0])
            {
                lstrcpyn(g_szCurFileName, argv[i], BUFFER_SIZE(g_szCurFileName));
            }
            else
            {
                lstrcpyn(g_szRefFileName, argv[i], BUFFER_SIZE(g_szRefFileName));
            }
        }
    }

    // This should never happen because the current file name
    // is the first file name in the arg list. I check anyway just
    // in case. If this every happens, that means there's a 
    // nasty bug somewhere in the code.
    //
    if (NULL == g_szCurFileName[0])
    {
        DisplayError(ERR_CURFILENAME, __LINE__);
        goto Error;
    }

    if (NULL == g_szRefFileName[0]) 
    {
        DisplayError(ERR_REFFILENAME, __LINE__);
        goto Error;
    }

    if (pszIniFile)
    {
        fSuccess = ProcessINIFile(pszIniFile);
    }
    else
    {
        DisplayError(ERR_INIFILENAME, __LINE__);
        goto Error;
    }

Cleanup:
    if (pszIniFile)
        delete pszIniFile;

    return fSuccess;

Error:
    ShowUsage();
    fSuccess = false;
    goto Cleanup;
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
int __cdecl main(int argc, char* argv[])
{
    
    HANDLE fileRef  = INVALID_HANDLE_VALUE;
    HANDLE fileCur  = INVALID_HANDLE_VALUE;
    HANDLE fileDiff = INVALID_HANDLE_VALUE;
    
    CAutoArray<INDEX>* rgFileIdx = NULL;
    
    //initialize global variables
    fgCoClass = fgInterface = fgDispInterface = fgMethodAttribute = fgMethodParameter
              = fgFlush = fgInterfaceAttr = true;
    
    g_ulAppRetVal = 0;
    
    //
    // Get and process the input arguments
    //
    if (!ProcessArgs(argc, argv))
    {
        goto Cleanup;
    }
    
    rgFileIdx = new CAutoArray<INDEX>;
    
    // Open the reference file and the current file
    //
    fileCur = CreateFile(g_szCurFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL, NULL);
    
    if (INVALID_HANDLE_VALUE == fileCur)
    {
        DisplayError(ERR_OPENINGCUR, __LINE__);
        goto Cleanup;
    }
    
    fileRef = CreateFile(g_szRefFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL, NULL);
    
    if (INVALID_HANDLE_VALUE == fileRef)
    {
        DisplayError(ERR_OPENINGREF, __LINE__);
        goto Cleanup;
    }
    
    // Prepare the index for the current file.
    cout << "Preparing index" << endl;
    PrepareIndex(fileCur, rgFileIdx);
    
    /* This was to test if the index algorithm would work on different files. 
    The mirror file should only be different from the file passed in as the
    current file, by its blanks and new lines.
    */

    //create a test mirror file using the index information we have.
    /*cout << "Creating test mirror file" << endl;
    CreateTestMirror( fileCur, rgFileIdx );
    */
    
    // Compare files.
    //
    if (g_fWriteToStdOut)
    {
        fileDiff = GetStdHandle(STD_OUTPUT_HANDLE);
    }
    else
    {
        fileDiff = CreateFile(g_szDiffFileName, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL, NULL);
    }
    
    if (INVALID_HANDLE_VALUE == fileDiff)
    {
        DisplayError(ERR_OPENINGDIFF, __LINE__);
        goto Cleanup;
    }
    
    cout << "Comparing Files" << endl;
    
    CompareFiles(fileCur, fileRef, rgFileIdx, fileDiff);
    
    // Only close here if we aren't writing to stdout.
    // Otherwise, we won't be able to write to stdout anymore.
    //
    if ((!g_fWriteToStdOut) && (INVALID_HANDLE_VALUE != fileDiff))
    {
        CloseHandle(fileDiff);
        fileDiff = INVALID_HANDLE_VALUE;
    }
    
    // Compare the attributes of interfaces. 
    // These contain the GUIDs of interfaces too.
    //
    if (fgInterfaceAttr)
        MarkAttrChanges(fileCur, rgFileIdx, g_szDiffFileName);
    
    // Flush out the blocks that are completely new for the current file 
    // and do not exist on the reference file.
    if (fgFlush)
        FlushDifferences(fileCur, rgFileIdx);
    
    if (g_ulAppRetVal)
    {
        DisplayError(ERR_DIFFERENCES, __LINE__);
    }
    else
    {
        cout << "Comparison Complete: No Errors" << endl;
    }
    
Cleanup:
    
    if (INVALID_HANDLE_VALUE != fileCur)
        CloseHandle(fileCur);
    
    if (INVALID_HANDLE_VALUE != fileRef)
        CloseHandle(fileRef);
    
    // Due to the fact that we may be writing to 
    // stdout, we should only close it once at the
    // very end of this program. It is not specified
    // if closing the console is actually necessary.
    //
    if (INVALID_HANDLE_VALUE != fileDiff)
        CloseHandle(fileDiff);
    
    // Release the memory allocated for the index array
    if (rgFileIdx)
        delete [] rgFileIdx;
    
    if (g_pszMethodAttr)
        delete g_pszMethodAttr;
    
    return g_ulAppRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\btools\pdlparse\data.cxx ===
// The names of these strings must correspond to the
// enum CACHED_CAA_STORAGE_STRUCT that is defined in cfpf.hxx
const char *rgszCcssString[]=
{
    "CCSS_EXPAND",
    "CCSS_CUSTOMAPPLY",
    "CCSS_NONE",
    "CCSS_CCHARFORMAT",
    "CCSS_CPARAFORMAT",
    "CCSS_CFANCYFORMAT"
};



// This needs to be ordered by DISPID
CCachedAttrArrayInfo rgCachedAttrArrayInfo[] =
{
    {"STDPROPID_XOBJ_LEFT",                 CCSSF_CLEARFF },
    {"STDPROPID_XOBJ_TOP",                  CCSSF_CLEARFF },
    {"STDPROPID_XOBJ_WIDTH",                CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"STDPROPID_XOBJ_HEIGHT",               CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"STDPROPID_XOBJ_BLOCKALIGN",           CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS },
    {"STDPROPID_XOBJ_CONTROLALIGN",         CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS },
    {"STDPROPID_XOBJ_DISABLED",             CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS },
    {"STDPROPID_XOBJ_RIGHT",                CCSSF_CLEARFF },
    {"STDPROPID_XOBJ_BOTTOM",               CCSSF_CLEARFF },
    {"DISPID_A_WORDSPACING",                CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },
    {"DISPID_A_VERTICALALIGN",              CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"DISPID_A_COLOR",                      CCSSF_CLEARCACHES },
    {"DISPID_A_TEXTTRANSFORM",              CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },
    {"DISPID_A_NOWRAP",                     CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },
    {"DISPID_A_LINEHEIGHT",                 CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },
    {"DISPID_A_TEXTINDENT",                 CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },
    {"DISPID_A_LETTERSPACING",              CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },
    {"DISPID_A_OVERFLOW",                   CCSSF_CLEARFF     | CCSSF_SIZECHANGED },
    {"DISPID_A_PADDINGTOP",                 CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS },
    {"DISPID_A_PADDINGRIGHT",               CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS },
    {"DISPID_A_PADDINGBOTTOM",              CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS },
    {"DISPID_A_PADDINGLEFT",                CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS },
    {"DISPID_A_CLEAR",                      CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"DISPID_A_FONTFACE",                   CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },
    {"DISPID_A_TEXTDECORATION",             CCSSF_CLEARCACHES },
    {"DISPID_A_ACCELERATOR",                CCSSF_CLEARCACHES },
    {"DISPID_A_FONTSIZE",                   CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },
    {"DISPID_A_FONTSTYLE",                  CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },
    {"DISPID_A_FONTVARIANT",                CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },
    {"DISPID_A_BASEFONT",                   CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },
    {"DISPID_A_FONTWEIGHT",                 CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },

    {"DISPID_A_TABLEBORDERCOLOR",           CCSSF_CLEARFF     },
    {"DISPID_A_TABLEBORDERCOLORLIGHT",      CCSSF_CLEARFF     },
    {"DISPID_A_TABLEBORDERCOLORDARK",       CCSSF_CLEARFF     },
    {"DISPID_A_TABLEVALIGN",                CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS },

    {"DISPID_BACKCOLOR",                    CCSSF_CLEARCACHES },
    {"DISPID_A_MARGINTOP",                  CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"DISPID_A_MARGINRIGHT",                CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"DISPID_A_MARGINBOTTOM",               CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"DISPID_A_MARGINLEFT",                 CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },

    {"DISPID_A_FONT",                       CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },

    {"DISPID_A_BORDERTOPCOLOR",             CCSSF_CLEARCACHES },
    {"DISPID_A_BORDERRIGHTCOLOR",           CCSSF_CLEARCACHES },
    {"DISPID_A_BORDERBOTTOMCOLOR",          CCSSF_CLEARCACHES },
    {"DISPID_A_BORDERLEFTCOLOR",            CCSSF_CLEARCACHES },
    {"DISPID_A_BORDERTOPWIDTH",             CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"DISPID_A_BORDERRIGHTWIDTH",           CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"DISPID_A_BORDERBOTTOMWIDTH",          CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"DISPID_A_BORDERLEFTWIDTH",            CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"DISPID_A_BORDERTOPSTYLE",             CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"DISPID_A_BORDERRIGHTSTYLE",           CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"DISPID_A_BORDERBOTTOMSTYLE",          CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"DISPID_A_BORDERLEFTSTYLE",            CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },

    {"DISPID_A_FLOAT",                      CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"DISPID_A_DISPLAY",                    CCSSF_CLEARCACHES | CCSSF_REMEASUREINPARENT },
    {"DISPID_A_LISTTYPE",                   CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"DISPID_A_LISTSTYLETYPE",              CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"DISPID_A_LISTSTYLEPOSITION",          CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS | CCSSF_SIZECHANGED },
    {"DISPID_A_LISTSTYLEIMAGE",             CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"DISPID_A_WHITESPACE",                 CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },
    {"DISPID_A_VISIBILITY",                 CCSSF_CLEARCACHES },
    {"DISPID_A_POSITION",                   CCSSF_CLEARCACHES | CCSSF_REMEASUREINPARENT },
    {"DISPID_A_ZINDEX",                     CCSSF_CLEARFF     },
    {"DISPID_A_CLIP",                       CCSSF_CLEARFF     },
    {"DISPID_A_CLIPRECTTOP",                CCSSF_CLEARFF     },
    {"DISPID_A_CLIPRECTRIGHT",              CCSSF_CLEARFF     },
    {"DISPID_A_CLIPRECTBOTTOM",             CCSSF_CLEARFF     },
    {"DISPID_A_CLIPRECTLEFT",               CCSSF_CLEARFF     },
    {"DISPID_A_PAGEBREAKBEFORE",            CCSSF_CLEARCACHES },
    {"DISPID_A_PAGEBREAKAFTER",             CCSSF_CLEARCACHES },
    {"DISPID_A_CURSOR",                     CCSSF_CLEARCACHES },
    {"DISPID_A_FILTER",                     CCSSF_CLEARCACHES },
    {"DISPID_A_BACKGROUNDIMAGE",            CCSSF_CLEARCACHES },
    {"DISPID_A_BACKGROUNDPOSX",             CCSSF_CLEARFF     },
    {"DISPID_A_BACKGROUNDPOSY",             CCSSF_CLEARFF     },
    {"DISPID_A_BACKGROUNDREPEAT",           CCSSF_CLEARFF     },
    {"DISPID_A_BACKGROUNDATTACHMENT",       CCSSF_CLEARFF     | CCSSF_SIZECHANGED },
    {"DISPID_A_LANG",                       CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },
    {"DISPID_A_TABLELAYOUT",                CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },
    {"DISPID_A_BORDERCOLLAPSE",             CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },

    {"DISPID_A_BEHAVIOR",                   CCSSF_CLEARCACHES },
    {"DISPID_A_DIR",                        CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_UNICODEBIDI",                CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_DIRECTION",                  CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_RUBYPOSITION",               CCSSF_CLEARCACHES }, 
    {"DISPID_A_IMEMODE",                    CCSSF_NONE }, 
    {"DISPID_A_RUBYALIGN",                  CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_RUBYPOSITION",               CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_RUBYOVERHANG",               CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_LAYOUTGRIDCHAR",             CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_LAYOUTGRIDLINE",             CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_LAYOUTGRIDMODE",             CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_LAYOUTGRIDTYPE",             CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_LAYOUTGRID",                 CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_TEXTAUTOSPACE",              CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_WORDBREAK",                  CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_LINEBREAK",                  CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_TEXTJUSTIFY",                CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_TEXTJUSTIFYTRIM",            CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_TEXTKASHIDA",                CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_OVERFLOWX",                  CCSSF_CLEARFF     | CCSSF_SIZECHANGED },
    {"DISPID_A_OVERFLOWY",                  CCSSF_CLEARFF     | CCSSF_SIZECHANGED },
#ifdef IE6_WYSIWYG_OM
    {"DISPID_A_ROTATE",                     CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },
#endif
    {"DISPID_A_ZOOM",                       CCSSF_CLEARCACHES | CCSSF_CLEARFF },
    {"DISPID_A_LAYOUTFLOW",                 CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_WORDWRAP",                   CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_TEXTUNDERLINEPOSITION",      CCSSF_CLEARCACHES }, 
    {"DISPID_A_WRAP",                       CCSSF_REMEASURECONTENTS | CCSSF_REMEASUREINPARENT },
    {"DISPID_A_VIEW",                       CCSSF_CLEARCACHES | CCSSF_REMEASUREINPARENT },
    {"DISPID_A_EDITABLE",                   CCSSF_CLEARCACHES },
    {"DISPID_A_SCROLLBARBASECOLOR",         CCSSF_CLEARCACHES },
    {"DISPID_A_SCROLLBARTRACKCOLOR",        CCSSF_CLEARCACHES },
    {"DISPID_A_SCROLLBARFACECOLOR",         CCSSF_CLEARCACHES },
    {"DISPID_A_SCROLLBAR3DLIGHTCOLOR",      CCSSF_CLEARCACHES },
    {"DISPID_A_SCROLLBARSHADOWCOLOR",       CCSSF_CLEARCACHES },
    {"DISPID_A_SCROLLBARHIGHLIGHTCOLOR",    CCSSF_CLEARCACHES },
    {"DISPID_A_SCROLLBARDARKSHADOWCOLOR",   CCSSF_CLEARCACHES },
    {"DISPID_A_SCROLLBARARROWCOLOR",        CCSSF_CLEARCACHES },
    {"DISPID_A_WRITINGMODE",                CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS | CCSSF_SIZECHANGED },
    {"DISPID_A_FROZEN",                     CCSSF_CLEARCACHES },     
    {"DISPID_A_VIEWINHERITSTYLE",           CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS | CCSSF_SIZECHANGED},
    {"DISPID_A_TEXTALIGNLAST",              CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_TEXTKASHIDASPACE",           CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_ALLOWTRANSPARENCY",          CCSSF_CLEARCACHES | CCSSF_SIZECHANGED | CCSSF_REMEASURECONTENTS },
    {"DISPID_A_TEXTOVERFLOW",               CCSSF_CLEARCACHES }, 
    {"DISPID_A_MINHEIGHT",                  CCSSF_CLEARCACHES | CCSSF_SIZECHANGED }, 
    {NULL,                                  CCSSF_NONE },
};

AssociateDataType DataTypes[] =
{
    { "void*",                 "Num" ,      "NUM",          STORAGETYPE_NUMBER},
    { "DWORD",                 "Num" ,      "NUM",          STORAGETYPE_NUMBER},
    { "DISPID",                "Num" ,      "NUM",          STORAGETYPE_NUMBER},
    { "SIZEL*",                "Num" ,      "NUM",          STORAGETYPE_NUMBER},
    { "CStr",                  "String" ,   "CSTR",         STORAGETYPE_STRING},
    { "BSTR",                  "String" ,   "CSTR",         STORAGETYPE_STRING},
    { "long",                  "Num" ,      "NUM",          STORAGETYPE_NUMBER},
    { "int",                   "Num" ,      "NUM",          STORAGETYPE_NUMBER},
    { "short",                 "Num" ,      "NUM",          STORAGETYPE_NUMBER},
    { "char",                  "Num" ,      "NUM",          STORAGETYPE_NUMBER},
    { "enum",                  "Enum" ,     "ENUM",         STORAGETYPE_NUMBER},
    { "ULONG",                 "Num" ,      "NUM",          STORAGETYPE_NUMBER},
    { "CStyleComponent",    "StyleComponent" , "CSTR",          STORAGETYPE_STRING},
    { "CStyle",                "Style" ,    "CSTR",         STORAGETYPE_OTHER},
    { "CColorValue",           "Color" ,    "COLOR",        STORAGETYPE_NUMBER},
    { "CUnitValue",            "UnitValue" , "UNITVALUE",   STORAGETYPE_NUMBER},
    { "VARIANT_BOOL",          "Num" ,       "NUM",         STORAGETYPE_NUMBER},
    { "OLE_XPOS_PIXELS",       "Num" ,       "NUM",         STORAGETYPE_NUMBER},
    { "OLE_YPOS_PIXELS",       "Num" ,       "NUM",         STORAGETYPE_NUMBER},
    { "OLE_XSIZE_PIXELS",      "Num" ,       "NUM",         STORAGETYPE_NUMBER},
    { "OLE_YSIZE_PIXELS",      "Num" ,       "NUM",         STORAGETYPE_NUMBER},
    { "OLE_XPOS_HIMETRIC",     "Num" ,       "NUM",         STORAGETYPE_NUMBER},
    { "OLE_YPOS_HIMETRIC",     "Num" ,       "NUM",         STORAGETYPE_NUMBER},
    { "OLE_XSIZE_HIMETRIC",    "Num" ,       "NUM",         STORAGETYPE_NUMBER},
    { "OLE_YSIZE_HIMETRIC",    "Num" ,       "NUM",         STORAGETYPE_NUMBER},
    { "OLE_XPOS_CONTAINER",    "Float" ,     "FLOAT",       STORAGETYPE_NUMBER},
    { "OLE_YPOS_CONTAINER",    "Float" ,     "FLOAT",       STORAGETYPE_NUMBER},
    { "OLE_XSIZE_CONTAINER",   "Float" ,     "FLOAT",       STORAGETYPE_NUMBER},
    { "OLE_YSIZE_CONTAINER",   "Float" ,     "FLOAT",       STORAGETYPE_NUMBER},
    { "OLE_CANCELBOOL",        "Num" ,       "NUM",         STORAGETYPE_NUMBER},
    { "OLE_ENABLEDEFAULTBOOL", "Num" ,       "NUM",         STORAGETYPE_NUMBER},
    { "IDispatch*",            "Object" ,    "OBJECT",      STORAGETYPE_OTHER},
    { "IUnknown*",             "Object"  ,   "OBJECT",      STORAGETYPE_OTHER},
    { "VARIANT",               "Variant"   , "VARIANT",     STORAGETYPE_OTHER},
    { "BYTE",                  "Num" ,       "NUM",         STORAGETYPE_NUMBER},
    { "BOOL",                  "Boolean" ,   "BOOLEAN",     STORAGETYPE_NUMBER},
    { "float",                 "Float" ,     "FLOAT",       STORAGETYPE_NUMBER},
    { "url",                   "Url",        "CSTR",        STORAGETYPE_STRING},
    { "code",                  "Code",       "CSTR",        STORAGETYPE_STRING},
    { NULL,                    NULL ,        NULL,          STORAGETYPE_NUMBER},
};


    //# { ]
    //#   index is argument type
    //#   value is VTS type

Associate vt[] =
{
    { "void*", "VTS_PI4" },
    { "DWORD", "VTS_I4" },
    { "DISPID", "VTS_I4" },
    { "SIZEL*", "VTS_PI4" },
    { "short", "VTS_I2" },
    { "long", "VTS_I4" },
    { "ULONG", "VTS_I4" },
    { "ULONG*", "VTS_PI4" },
    { "int", "VTS_I4" },
    { "float", "VTS_R4" },
    { "double", "VTS_R8" },
    { "CY*", "VTS_CY" },
    { "DATE", "VTS_DATE" },
    { "BSTR", "VTS_BSTR" },
    { "LPCTSTR", "VTS_BSTR" },
    { "IDispatch*", "VTS_DISPATCH" },
    { "SCODE", "VTS_ERROR" },
    { "VARIANT_BOOL", "VTS_BOOL" },
    { "boolean", "VTS_BOOL" },
    { "ERROR", "VTS_ERROR" },
    { "BOOL", "VTS_BOOL" },
    { "VARIANT", "VTS_VARIANT" },
    { "IUnknown*", "VTS_UNKNOWN" },
    { "unsigned char", "VTS_UI1" },
    { "short*", "VTS_PI2" },
    { "long*", "VTS_PI4" },
    { "int*", "VTS_PI4" },
    { "float*", "VTS_PR4" },
    { "double*", "VTS_PR8" },
    { "CY*", "VTS_PCY" },
    { "DATE*", "VTS_PDATE" },
    { "BSTR*", "VTS_PBSTR" },
    { "IDispatch**", "VTS_PDISPATCH" },
    { "SCODE*", "VTS_PERROR" },
    { "VARIANT_BOOL*", "VTS_PBOOL" },
    { "boolean*", "VTS_PBOOL" },
    { "VARIANT*", "VTS_PVARIANT" },
    { "IUnknown**", "VTS_PUNKNOWN" },
    { "unsigned char *", "VTS_PUI1" },
    { "", "VTS_NONE" },
    { "OLE_COLOR", "VTS_COLOR" },
    { "OLE_XPOS_PIXELS", "VTS_XPOS_PIXELS" },
    { "OLE_YPOS_PIXELS", "VTS_YPOS_PIXELS" },
    { "OLE_XSIZE_PIXELS", "VTS_XSIZE_PIXELS" },
    { "OLE_YSIZE_PIXELS", "VTS_YSIZE_PIXELS" },
    { "OLE_XPOS_HIMETRIC", "VTS_XPOS_HIMETRIC" },
    { "OLE_YPOS_HIMETRIC", "VTS_YPOS_HIMETRIC" },
    { "OLE_XSIZE_HIMETRIC", "VTS_XSIZE_HIMETRIC" },
    { "OLE_YSIZE_HIMETRIC", "VTS_YSIZE_HIMETRIC" },
    { "OLE_XPOS_CONTAINER", "VTS_R4" },
    { "OLE_YPOS_CONTAINER", "VTS_R4" },
    { "OLE_XSIZE_CONTAINER", "VTS_R4" },
    { "OLE_YSIZE_CONTAINER", "VTS_R4" },
    { "OLE_TRISTATE", "VTS_TRISTATE" },
    { "OLE_OPTEXCLUSIVE", "VTS_OPTEXCLUSIVE" },
    { "OLE_COLOR*", "VTS_PCOLOR" },
    { "OLE_XPOS_PIXELS*", "VTS_PXPOS_PIXELS" },
    { "OLE_YPOS_PIXELS*", "VTS_PYPOS_PIXELS" },
    { "OLE_XSIZE_PIXELS*", "VTS_PXSIZE_PIXELS" },
    { "OLE_YSIZE_PIXELS*", "VTS_PYSIZE_PIXELS" },
    { "OLE_XPOS_HIMETRIC*", "VTS_PXPOS_HIMETRIC" },
    { "OLE_YPOS_HIMETRIC*", "VTS_PYPOS_HIMETRIC" },
    { "OLE_XSIZE_HIMETRIC*", "VTS_PXSIZE_HIMETRIC" },
    { "OLE_YSIZE_HIMETRIC*", "VTS_PYSIZE_HIMETRIC" },
    { "OLE_TRISTATE*", "VTS_PTRISTATE" },
    { "OLE_OPTEXCLUSIVE*", "VTS_POPTEXCLUSIVE" },
    { "IFontDispatch*", "VTS_FONT" },
    { "IPictureDispatch*", "VTS_PICTURE" },
    { "OLE_HANDLE", "VTS_HANDLE" },
    { "OLE_HANDLE*", "VTS_PHANDLE" },
    { "BYTE", "VTS_BOOL" },
    // Internal Types
    { "CStr", "VTS_BSTR" },
    { "CUnitValue", "VTS_I4" },
    { "CStyleComponent", "VTS_BSTR" },
    { "CStyle", "VTS_BSTR" },
    { "CColorValue", "VTS_BSTR" },
    { NULL, NULL },
};


TokenDescriptor FileDescriptor =
{
    "file", TRUE,
    {
        END_OF_ARG_ARRAY
    }
};


TokenDescriptor InterfaceDescriptor =
{
    "interface", TRUE,
    {
        {
            "super", FALSE, TRUE    // Mandatory
        },
        {
            "guid", FALSE, FALSE
        },
        {
            "abstract", TRUE, FALSE
        },
        {
            "custom", TRUE, FALSE
        },
        {
            "<noprimary>", TRUE, FALSE  // Not settable from pdl, set internally.
        },
        END_OF_ARG_ARRAY
    }
};


TokenDescriptor EvalDescriptor =
{
    "eval", FALSE,
    {
        {
            "value", FALSE, FALSE
        },
        {
            "string", FALSE, FALSE
        },
        {
            "name", FALSE, FALSE
        },
        END_OF_ARG_ARRAY
    }
};


TokenDescriptor EnumDescriptor =
{
    "enum", TRUE,
    {
        {
            "prefix", FALSE, FALSE
        },
        {
            "guid", FALSE, FALSE
        },
        {
            "hidden", TRUE, FALSE
        },
        END_OF_ARG_ARRAY
    },
};


TokenDescriptor ClassDescriptor =
{
    "class", TRUE,
    {

        {
            "super", FALSE, FALSE
        },
        {
            "primaryinterface", FALSE, FALSE
        },
        {
            "guid", FALSE, FALSE
        },
        {
            "abstract", TRUE, FALSE
        },
        {
            "name", FALSE, FALSE
        },
        {
            "events", FALSE, FALSE
        },
        {
            "cascadedmethods", TRUE, FALSE
        },
        {
            "noaamethods", TRUE, FALSE
        },
        {
            "keepnopersist", TRUE, FALSE
        },
        {
            "noconnectionpoints", TRUE, FALSE
        },
        {
            "control", TRUE, FALSE
        },
        {
            "mondoguid", FALSE, FALSE
        },
        {
            "nonprimaryevents", FALSE, FALSE
        },
        {
            "nonprimaryevents2", FALSE, FALSE
        },
        {
            "nonprimaryevents3", FALSE, FALSE
        },
        {
            "nonprimaryevents4", FALSE, FALSE
        },
        END_OF_ARG_ARRAY
    }
};


TokenDescriptor ImplementsDescriptor =
{
    "implements", FALSE,
    {
        {
            "guid", FALSE, FALSE
        },
        END_OF_ARG_ARRAY
    }
};


TokenDescriptor PropertyDescriptor =
{
    "property", FALSE,
    {
        {
            "atype", FALSE, FALSE
        },
        {
            "dispid", FALSE, FALSE
        },
        {
            "type", FALSE, FALSE
        },
        {
            "member", FALSE, FALSE
        },
        {
            "get", TRUE, FALSE
        },
        {
            "set", TRUE, FALSE
        },
        {
            "bindable", TRUE, FALSE
        },
        {
            "displaybind", TRUE, FALSE
        },
        {
            "dwflags", FALSE, FALSE
        },
        {
            "abstract", TRUE, FALSE
        },
        {
            "ppflags", FALSE, FALSE
        },
        {
            "default", FALSE, FALSE
        },
        {
            "noassigndefault", FALSE, FALSE
        },
        {
            "min", FALSE, FALSE
        },
        {
            "max", FALSE, FALSE
        },
        {
            "method", TRUE, FALSE
        },
        {
            "help", FALSE, FALSE
        },
        {
            "vt", FALSE, FALSE
        },
        {
            "caa", FALSE, FALSE
        },
        {
            "object", FALSE, FALSE
        },
/*  I'm creating bizarre names these out for now because currently JScript cannot deal with
    Properties that have parameters */
        {
            "<<index>>", FALSE, FALSE
        },
        {
            "<<index1>>", FALSE, FALSE
        },
        {
            "<<indextype>>", FALSE, FALSE
        },
        {
            "<<indextype1>>", FALSE, FALSE
        },
        {
            "szattribute", FALSE, FALSE
        },
        {
            "hidden", TRUE, FALSE
        },
        {
            "nonbrowsable", TRUE, FALSE
        },
        {
            "restricted", TRUE, FALSE
        },
        {
            "subobject", FALSE, FALSE
        },
        {
            "param1", FALSE, FALSE
        },
        {
            "precallfn", FALSE, FALSE
        },
        {
            "enumref", FALSE, FALSE
        },
        {
            "virtual", TRUE, FALSE
        },
        {
            "getaa", FALSE, FALSE
        },
        {
            "setaahr", FALSE, FALSE
        },
        {
            "source", TRUE, FALSE
        },
        {
            "minout", TRUE, FALSE
        },
        {
            "<cascaded>", TRUE,FALSE
        },
        {
            "updatecollection", TRUE, FALSE
        },
        {
            "scriptlet", TRUE, FALSE
        },
        {
            "clearcaches", TRUE, FALSE
        },
        {
            "stylesheetproperty", TRUE, FALSE
        },
        {
            "noassigntypeonly", TRUE, FALSE
        },
        {
            "resize", TRUE, FALSE
        },
        {
            "remeasure", TRUE, FALSE
        },
        {
            "remeasureall", TRUE, FALSE
        },
        {
            "siteredraw", TRUE, FALSE
        },
        {
            "set_designtime", TRUE, FALSE
        },
        {
            "invalid=noassigndefault", TRUE, FALSE
        },
        {
            "notpresent=default", TRUE, FALSE
        },
        {
            "contextual", TRUE, FALSE
        },
        {
            "nodecontextual", TRUE, FALSE
        },
        {
            "baseimplementation", TRUE, FALSE
        },
        {
            "nopersist", TRUE, FALSE
        },
        {
            "internal", TRUE, FALSE
        },
        {
            "<refdclass>", TRUE, FALSE
        },
        {
            "maxstrlen", FALSE, FALSE
        },
        {
            "nopropdesc", TRUE, FALSE
        },
        {
            "exclusivetoscript", TRUE, FALSE
        },
        {
            "szInterfaceExpose", TRUE, FALSE
        },
        {
            "dataevent", TRUE, FALSE
        },
        {
            "accessibilitystate", FALSE, FALSE
        },
        {
            "customenum", TRUE, FALSE
        },
        
        END_OF_ARG_ARRAY
    }
};


TokenDescriptor MethodArgDescriptor =
{
    "<methodarg>" /* Implied */, FALSE,
    {
        {
            "atype", FALSE, FALSE
        },
        {
            "type", FALSE, FALSE
        },
        {
            "in", TRUE, FALSE
        },
        {
            "out", TRUE, FALSE
        },
        {
            "arg", FALSE, FALSE
        },
        {
            "retval", FALSE, FALSE
        },
        {
            "defaultvalue", FALSE, FALSE
        },
        {
            "optional", TRUE, FALSE
        },
        END_OF_ARG_ARRAY
    }
};


// These are just the tokens for the method, there is a separate descriptor for a method arg
TokenDescriptor MethodDescriptor =
{
    "method", FALSE,
    {
        {
            "<ReturnType>", FALSE, FALSE // Un-Tagged
        },
        {
            "dispid", FALSE, FALSE
        },
        {
            "abstract", TRUE, FALSE
        },
        {
            "virtual", TRUE, FALSE
        },
        {
            "<RefdToClassFlag>", TRUE, FALSE
        },
        {
            "vararg", TRUE, FALSE
        },
        {
            "cancelable", TRUE, FALSE
        },
        {
            "bubbling", TRUE, FALSE
        },
        {
            "restricted", TRUE, FALSE
        },
        {   
            "contextual", TRUE, FALSE
        },
        {   
            "nodecontextual", TRUE, FALSE
        },
        {   
            "maxstrlen", FALSE, FALSE
        },
        {
            "nopropdesc", TRUE, FALSE
        },
        {
            "exclusivetoscript", TRUE, FALSE
        },
        {
            "szInterfaceExpose", TRUE, FALSE
        },
        END_OF_ARG_ARRAY
    }
};


TokenDescriptor RefPropDescriptor =
{
    "refprop", FALSE,
    {
        {
            "<ClassName>", FALSE, FALSE // Un-Tagged
        },
        {
            "<PropertyName>", FALSE, FALSE // Untagged
        },
        END_OF_ARG_ARRAY
    }
};


TokenDescriptor RefMethodDescriptor =
{
    "refmethod", FALSE,
    {
        {
            "<ClassName>", FALSE, FALSE // Un-Tagged
        },
        {
            "<PropertyName>", FALSE, FALSE // Untagged
        },
        END_OF_ARG_ARRAY
    }
};


TokenDescriptor EventDescriptor =
{
    "event", TRUE,
    {
        {
            "super", FALSE, TRUE    // Mandatory
        },
        {
            "guid", FALSE, FALSE
        },
        {
            "abstract", TRUE, FALSE
        },
        END_OF_ARG_ARRAY
    }
};


TokenDescriptor ImportDescriptor =
{
    "import", TRUE, // import just has a name
    {
        END_OF_ARG_ARRAY
    }
};


TokenDescriptor TearoffDescriptor =
{
    "tearoff", TRUE,
    {
        {
            "interface", FALSE, FALSE
        },
        {
            "BaseImpl", FALSE, FALSE
        },
        END_OF_ARG_ARRAY
    }
};


TokenDescriptor TearoffMethod =
{
    "tearmethod", FALSE,
    {
        {
            "mapto", FALSE, TRUE    // mandatory
        },
        END_OF_ARG_ARRAY
    }
};

TokenDescriptor StructDescriptor =
{
    "struct", TRUE,
    {
        END_OF_ARG_ARRAY
    }
};

TokenDescriptor StructMemberDescriptor =
{
    "member", FALSE,
    {
        {
            "type", FALSE, FALSE
        },
        END_OF_ARG_ARRAY
    }
};


TokenDescriptor *AllDescriptors[ NUM_DESCRIPTOR_TYPES ] =
{
    &FileDescriptor,
    &InterfaceDescriptor,
    &EvalDescriptor,
    &EnumDescriptor,
    &ClassDescriptor,
    &ImplementsDescriptor,
    &PropertyDescriptor,
    &MethodDescriptor,
    &MethodArgDescriptor,
    &RefPropDescriptor,
    &RefMethodDescriptor,
    &EventDescriptor,
    &ImportDescriptor,
    &TearoffDescriptor,
    &TearoffMethod,
    &StructDescriptor,
    &StructMemberDescriptor
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\btools\pdlparse\parser.cxx ===
extern BOOL gbWin16Mode;

UINT CPDLParser::CountTags ( TokenDescriptor *tokdesc )
{
    UINT uCount;
    TagDescriptor *pTagDescriptor;
    for ( uCount = 0, pTagDescriptor = tokdesc -> Tags ; pTagDescriptor -> szTag != NULL;
        uCount++, pTagDescriptor++ );
    return uCount;
}

CPDLParser::CPDLParser()
{
    fpHComPlusFile = NULL;
    fpCComPlusFile = NULL;
    fpHDLFile = NULL;
    fpHeaderFile = NULL;
    fpIDLFile = NULL;
    fpLOGFile = NULL;
    fpHTMFile = NULL;
    fpHTMIndexFile = NULL;
    fpDISPIDFile = NULL;
    fpMaxLenFile = NULL;
    pRuntimeList = new CTokenList;
    pDynamicTypeList = new CTokenList;
    pDynamicEventTypeList = new CTokenList;
    Init();
}
                  

void
CPDLParser::SplitTag ( char *pStr, int nLen, char **pTag, int *pnTagLen,
    char **pValue, int *pnValueLen )
{
    *pTag = pStr;
    for ( *pnTagLen = 0 ; *pnTagLen < nLen ; pStr++, (*pnTagLen)++ )
    {
        if ( *pStr == ':' )
        {
            *pValue = pStr + 1;
            *pnValueLen = nLen - *pnTagLen -1;
            return;
        }
    }
    *pnValueLen = 0;
}



BOOL
CPDLParser::LookupToken ( LPCSTR pTokenName, int nTokenLen,
    TokenDescriptor **ppTokenDescriptor, DESCRIPTOR_TYPE *pnTokenDes )
{
    INT i;
    for ( i = 0 ;
        i < NUM_DESCRIPTOR_TYPES ; i++ )
    {
        if (strlen(AllDescriptors[i]->szTokenName) == (UINT)nTokenLen &&
            !_strnicmp(AllDescriptors[i]->szTokenName, pTokenName, nTokenLen))
        {
            *ppTokenDescriptor = AllDescriptors [ i ];
            *pnTokenDes = (DESCRIPTOR_TYPE)i;
            return TRUE;
        }
    }
    return FALSE;
}

BOOL CPDLParser::GetElem ( char **pStr,
                          char **pElem,
                          int *pnLen,
                          BOOL fBreakOnOpenParenthesis, /* = FALSE */
                          BOOL fBreakOnCloseParenthesis, /* = FALSE */
                          BOOL fBreakOnCommas /* = FALSE */ )
{
    *pnLen = 0;

    while ( isspace ( **pStr ) )
    {
        (*pStr)++;
    }
    *pElem = *pStr;
    if (( fBreakOnOpenParenthesis && **pStr == ')' ) ||
        ( fBreakOnCloseParenthesis &&  **pStr == '('  ) ||
        (fBreakOnCommas &&  **pStr == ',' ))
    {
        (*pnLen)++;
        (*pStr)++;
        goto Cleanup;
    }
    while ( **pStr && !isspace ( **pStr ))
    {
        if (( fBreakOnOpenParenthesis && **pStr == ')' ) ||
            ( fBreakOnCloseParenthesis &&  **pStr == '('  ) ||
            (fBreakOnCommas &&  **pStr == ',' ))
        {
            // Break but leave the pStr pointing at the bracket - we'll pick it up in the
            // next call
            break;
        }

        // Convert curly braces to parens

        if (**pStr == '{')
            **pStr = '(';
        else if (**pStr == '}')
            **pStr = ')';

        (*pnLen)++;
        (*pStr)++;
    }
Cleanup:
    return *pnLen == 0 ? FALSE : TRUE;
}

BOOL CPDLParser::ParseInputFile ( BOOL fDebugging )
{
    BOOL fReturn = TRUE;
    DESCRIPTOR_TYPE nThisDescriptor;
    char szLineBuffer [ MAX_LINE_LEN+1 ];
    char szErrorText [ MAX_LINE_LEN+1 ];
    char *pStr = szLineBuffer;
    char *pElem; int nElemLen;
    TokenDescriptor *pThisDescriptor;
    Token *pNewToken;
    Token *pParentToken = NULL;
    BOOL fGotParentToken = FALSE;
    CString szType;

    fprintf ( fpLOGFile, "Parsing input file\n" );

    for(;;)
    {
        if ( !GetStdInLine ( szLineBuffer, sizeof ( szLineBuffer  ) ) )
            break;

        pStr = szLineBuffer;

        fprintf ( fpLOGFile, "Read Line:%s\n", szLineBuffer );
        // Get the type e..g. enum, eval etc.
        if ( !GetElem ( &pStr, &pElem, &nElemLen ) )
        {
            // Couldn't get the name
            fprintf ( fpLOGFile, "Skipping\n" );
            continue;
        }


        if ( !LookupToken ( pElem, nElemLen, &pThisDescriptor, &nThisDescriptor ) )
        {
            fprintf ( fpLOGFile, "Unknown token\n" );
            continue;
        }

        fprintf ( fpLOGFile, "Processing a %s declaration\n",
            (LPCSTR)AllDescriptors [ nThisDescriptor ] -> szTokenName );

        // If it's a child token and we haven't got a parent
        if ( !pThisDescriptor->fIsParentToken &&
            !fGotParentToken )
        {
            ReportError ( "Child Token Without Parent\n" );
            goto error;
        }

        if ( pThisDescriptor->fIsParentToken )
        {
            fGotParentToken = TRUE;
        }


        INT nTag;
        char *pTag; char *pValue;
        int nTagLen; int nValueLen;
        BOOL fVarArg = FALSE;

        if ( nThisDescriptor == TYPE_METHOD )
        {
            // Look for optional vararg first

            if ( !GetElem ( &pStr, &pElem, &nElemLen ) )
            {
                // Couldn't get the return type
                continue;
            }

            if ( ! ( pNewToken = pParentToken -> AddChildToken ( nThisDescriptor ) ) )
            {
                ReportError ( "Memory Allocation Error\n" );
                goto error;
            }

            if ( !pNewToken->TagValues.AddTag ( METHOD_RETURNTYPE, pElem, nElemLen ) )
            {
                ReportError ( "Memory Allocation Error\n" );
                goto error;
            }

            // Name is next
            if ( !GetElem ( &pStr, &pElem, &nElemLen ) )
            {
                // Couldn't get the name
                continue;
            }

            if ( !pNewToken->TagValues.AddTag ( METHOD_NAME, pElem, nElemLen ) )
            {
                ReportError ( "Memory Allocation Error\n" );
                goto error;
            }

            // Methods need special handling due to the parameter list
            // Put all tokens before the "(" in the TagValues
            // Treat each arg in the param list as a unique token and add
            // to the pArgList for this token
            // Put all the tokens after the ")" in the TagValues
            // We allow either a comma-seperated arg list, but if we
            // don't get commas we break the arg intelligently
            //
            UINT bInParams = FALSE;
            BOOL bCreatedArgToken = FALSE;

            Token *pCurrentToken;

            TokenDescriptor *pDescriptor = pThisDescriptor;
            pCurrentToken = pNewToken;
            fVarArg = FALSE;

            // Set the fBreakOnParenthesis Flag to make parenthis stop GetElem
            while ( GetElem ( &pStr, &pElem, &nElemLen, TRUE, TRUE, TRUE ) )
            {
                if ( nElemLen == 1 && *pElem == '(' )
                {
                    if ( bInParams )
                    {
                        sprintf ( szErrorText, "Syntax Error %s On %s\n", pStr, szLineBuffer );
                        ReportError ( szErrorText );
                        goto error;
                    }
                    bInParams = TRUE;
                    // Switch to method arg descriptor
                    pDescriptor = &MethodArgDescriptor;
                }
                else if ( nElemLen == 1 && *pElem == ')' )
                {
                    if ( !bInParams )
                    {
                        sprintf ( szErrorText, "Syntax Error %s On %s\n", pStr, szLineBuffer );
                        ReportError ( szErrorText );
                        goto error;
                    }
                    bInParams = FALSE;
                    // Switch back to method descriptor
                    pDescriptor = pThisDescriptor;
                    pCurrentToken = pNewToken;
                }
                else if ( nElemLen == 1 && *pElem == ',' )
                {
                    // Reset flag so new arg token gets created for next arg
                    bCreatedArgToken = FALSE;
                }
                else
                {

                    // Split out the prefix:value
                    SplitTag ( pElem, nElemLen, &pTag, &nTagLen,
                        &pValue, &nValueLen );

                    // Match the tag
                    if ( !pDescriptor->LookupTagName ( pTag, nTagLen, &nTag ) )
                    {
                        pTag [ nTagLen ] = '\0';
                        sprintf ( szErrorText, "Unknown tag: %s On %s\n", pTag, szLineBuffer );
                        ReportError ( szErrorText );
                        goto error;
                    }

                    // If we've already got an entry for this tag, and we've seen
                    // at least the arg tag, start a new arg
                    if ( bInParams && pCurrentToken -> IsSet ( METHODARG_ARGNAME ) &&
                        ( nTag == METHODARG_IN || nTag == METHODARG_OUT ) &&
                        ( pCurrentToken -> IsSet ( METHODARG_IN ) ||
                        pCurrentToken -> IsSet ( METHODARG_IN ) ) )
                    {
                        // Start a new arg
                        bCreatedArgToken = FALSE;
                    }
                    if ( bInParams && bCreatedArgToken == FALSE )
                    {
                        // Create the arg list if needed
                        pCurrentToken = pNewToken -> AddChildToken ( TYPE_METHOD_ARG );
                        if ( pCurrentToken == NULL )
                        {
                            ReportError ( "Memory allocation error\n" );
                            goto error;
                        }
                        bCreatedArgToken = TRUE;
                    }

                    // Add the tag either to the main method token array or to the current
                    // arg 's array
                    if ( !pCurrentToken->TagValues.AddTag ( nTag, pValue, nValueLen ) )
                    {
                        ReportError ( "Memory allocation error\n" );
                        goto error;
                    }

                    // Last argument a SAFEARRAY, if so then vararg
                    fVarArg = (strncmp(pValue, "SAFEARRAY(VARIANT)", 18) == 0);
                }

                // method is a vararg because last parameter is a safearray.
                if ( fVarArg && !pNewToken->TagValues.AddTag ( METHOD_VARARG, "vararg", 6 ) )
                {
                    ReportError ( "Memory allocation error\n" );
                    goto error;
                }
            }
        }
        else if ( nThisDescriptor == TYPE_REFPROP ||  nThisDescriptor == TYPE_REFMETHOD )
        {
            // Now get the Class::Name & split it out
            if ( !GetElem ( &pStr, &pElem, &nElemLen ) )
            {
                // Couldn't get the name
                continue;
            }

            // Split out the prefix:value
            SplitTag ( pElem, nElemLen, &pTag, &nTagLen,
                &pValue, &nValueLen );

            pNewToken = pParentToken -> AddChildToken ( nThisDescriptor );

            if ( pNewToken == NULL )
            {
                ReportError ( "Memory Allocation Error\n" );
                goto error;
            }

            if ( !pNewToken->TagValues.AddTag (
                (nThisDescriptor == TYPE_REFPROP) ? (INT)REFPROP_CLASSNAME : (INT)REFMETHOD_CLASSNAME,
                pTag, nTagLen ) )
            {
                ReportError ( "Memory Allocation Error\n" );
                goto error;
            }
            if ( !pNewToken->TagValues.AddTag (
                nThisDescriptor == TYPE_REFPROP ? (INT)REFPROP_PROPERTYNAME : (INT)REFMETHOD_METHODNAME,
                pValue, nValueLen ) )
            {
                ReportError ( "Memory Allocation Error\n" );
                goto error;
            }

        }
        else
        {
            // Now get the name
            if ( !GetElem ( &pStr, &pElem, &nElemLen ) )
            {
                // Couldn't get the name
                continue;
            }

            // If it's a child token, add it to the runtime list, else add it as a child
            // of the current parent
            if ( pThisDescriptor->fIsParentToken )
            {
                pNewToken = pRuntimeList -> AddNewToken ( nThisDescriptor );
                pParentToken = pNewToken;
            }
            else
            {
                pNewToken = pParentToken -> AddChildToken ( nThisDescriptor );
            }

            if ( pNewToken == NULL )
            {
                ReportError ( "Memory Allocation Error\n" );
                goto error;
            }

            // First tag is always the name
            if ( !pNewToken->TagValues.AddTag ( NAME_TAG, pElem, nElemLen ) )
            {
                ReportError ( "Memory Allocation Error\n" );
                goto error;
            }

            // Split out all the token:value pairs
            while ( GetElem ( &pStr, &pElem, &nElemLen ) )
            {
                // Split out the prefix:value
                SplitTag ( pElem, nElemLen, &pTag, &nTagLen,
                    &pValue, &nValueLen );

                // Match the tag
                if ( !pThisDescriptor->LookupTagName ( pTag, nTagLen, &nTag ) )
                {
                    pTag [ nTagLen ] = '\0';
                    sprintf ( szErrorText, "Unknown tag: %s On %s\n", pTag, szLineBuffer );
                    ReportError ( szErrorText );
                    goto error;
                }

                if ( !pNewToken->TagValues.AddTag ( nTag, pValue, nValueLen ) )
                {
                    ReportError ( "Memory Allocation Error\n" );
                    goto error;
                }
            }
        }
        // Perform any cleanup
        switch ( nThisDescriptor )
        {
        case TYPE_EVAL:
            // For enums we calculate and store in the token the enum mask
            // We also number the enum values sequentialy
            pNewToken -> CalculateEnumMask ( pParentToken );
            break;

        case TYPE_ENUM:
            // Add data types to the dynamic type array
            szType = pNewToken -> GetTagValue ( ENUM_NAME );
            AddType ( szType, "Enum" );
            AddEventType ( szType, "VTS_I4" );
            szType += "*";
            AddEventType ( szType, "VTS_PI4" );
            break;

        case TYPE_CLASS:
        case TYPE_INTERFACE:
        case TYPE_EVENT:
            szType = pNewToken -> GetTagValue ( NAME_TAG );
            szType += "*";
            AddType ( szType, "object" );
            AddEventType ( szType, "VTS_DISPATCH" );
            szType += "*";
            AddType ( szType, "object" );
            AddEventType ( szType, "VTS_DISPATCH" );
            break;
            
        }
    }

    // Add an IUnknown to make implicit ref's match up
    pNewToken = pRuntimeList -> AddNewToken ( TYPE_INTERFACE );
    pNewToken->TagValues.AddTag ( INTERFACE_NAME, "IUnknown", -1 );

    // Add an IDispatch to make implicit ref's match up
    pNewToken = pRuntimeList -> AddNewToken ( TYPE_INTERFACE );
    pNewToken->TagValues.AddTag ( INTERFACE_NAME, "IDispatch", -1 );

    pNewToken = pRuntimeList -> AddNewToken ( TYPE_EVENT );
    pNewToken->TagValues.AddTag ( EVENT_NAME, "IDispatch", -1 );

    // Patch up the refprops & refmethods
    if ( !PatchInterfaceRefTypes() )
    {
        goto error;
    }

    // Patch Properties that are of object type
    if ( !PatchPropertyTypes() )
    {
        goto error;
    }

    if ( !PatchInterfaces() )
    {
        goto error;
    }

    goto cleanup;

error:
    fReturn = FALSE;

cleanup:
    return fReturn;
}


BOOL CPDLParser::PatchInterfaceRefTypes ( void )
{
    CTokenListWalker WholeTree ( pRuntimeList );
    Token *pChildToken;
    Token *pInterfaceToken;
    CString szClassName;

    // For each RefProp or Refmethod, we replace the arg list with a copy of the referenced property/method
    // and change the type of the ref'd item appropriatly
    while ( pInterfaceToken = WholeTree.GetNext( TYPE_INTERFACE ) )
    {
        CTokenListWalker ChildList ( pInterfaceToken );
        while ( pChildToken = ChildList.GetNext() )
        {
            if ( pChildToken -> GetType() == TYPE_REFPROP )
            {
                szClassName = pChildToken -> GetTagValue ( REFPROP_CLASSNAME );

                if ( !CloneToken ( pChildToken, TYPE_PROPERTY,
                    REFPROP_CLASSNAME, REFPROP_PROPERTYNAME ) )
                {
                    char szErrorText [ MAX_LINE_LEN+1 ];

                    sprintf ( szErrorText, "Interface %s Invalid RefProp %s:%s\n" ,
                        pInterfaceToken -> GetTagValue ( INTERFACE_NAME ),
                        pChildToken -> GetTagValue ( REFPROP_CLASSNAME ),
                        pChildToken -> GetTagValue ( REFPROP_PROPERTYNAME ) );
                    ReportError ( szErrorText );

                    return FALSE;
                }

                // Remember the class that was refprop'd.
                pChildToken -> AddTag ( PROPERTY_REFDTOCLASS, (LPCSTR)szClassName );
            }
            else if ( pChildToken -> GetType() == TYPE_REFMETHOD )
            {
                szClassName = pChildToken -> GetTagValue ( REFMETHOD_CLASSNAME );

                if ( !CloneToken ( pChildToken, TYPE_METHOD,
                    REFMETHOD_CLASSNAME, REFMETHOD_METHODNAME ) )
                {
                    char szErrorText [ MAX_LINE_LEN+1 ];

                    sprintf ( szErrorText, "Interface %s Invalid RefMethod %s:%s\n" ,
                        pInterfaceToken -> GetTagValue ( INTERFACE_NAME ),
                        pChildToken -> GetTagValue ( REFMETHOD_CLASSNAME ),
                        pChildToken -> GetTagValue ( REFMETHOD_METHODNAME ) );
                    ReportError ( szErrorText );

                    return FALSE;
                }

                // Remember the class that was refprop'd.
                pChildToken -> AddTag ( METHOD_REFDTOCLASS, (LPCSTR)szClassName );
            }
        }
    }
    return TRUE;
}


BOOL CPDLParser::CloneToken ( Token *pChildToken, DESCRIPTOR_TYPE Type, INT nClassName, INT nTagName )
{
    CTokenListWalker SubTree ( pRuntimeList );
    Token *pRefdClassToken;
    Token *pRefdChild;

    pRefdClassToken = SubTree.GetNext( TYPE_CLASS, pChildToken -> GetTagValue ( nClassName ) );
    if ( pRefdClassToken == NULL )
    {
        // Couldn't find the refd class
        return FALSE;
    }
    // Found the refd class, find the refd property
    CTokenListWalker RefdChildList ( pRefdClassToken );
    pRefdChild = RefdChildList.GetNext ( Type,
        pChildToken -> GetTagValue ( nTagName ) );
    if ( pRefdChild == NULL )
    {
        // Couldn't find the refd property
        return FALSE;
    }
    else
    {
        pChildToken -> Clone ( pRefdChild );
    }
    return TRUE;
}



BOOL CPDLParser::GetTypeDetails ( char *szTypeName, CString& szHandler, CString &szFnPrefix,
    StorageType *pStorageType /* = NULL */ )
{
    if ( !LookupType ( szTypeName, szHandler, szFnPrefix, pStorageType ) )
        return FALSE;
    return TRUE;
}

BOOL CPDLParser::IsSpecialProperty(Token *pClassToken)
{
    CString szInterf;
    Token *pInterf;

    szInterf = pClassToken->GetTagValue(CLASS_INTERFACE);
    pInterf = FindInterface(szInterf);
    if (pInterf)
        return (PrimaryTearoff(pInterf) || pInterf->IsSet(INTERFACE_ABSTRACT));
    else
        return TRUE;
}

BOOL CPDLParser::GeneratePropMethodImplementation ( void )
{
    Token *pClassToken;
    Token *pChildToken;
    CString szFnPrefix;
    CString szHandler;
    CString szOffsetOf;
    CString szAType;
    CString szHandlerArgs;
    char szErrorText [ MAX_LINE_LEN+1 ];

    // Only generate def's for this file
    CTokenListWalker TokenList ( pRuntimeList, _pszPDLFileName );

    // Generate propdescs for every property token in every class ( in this file )
    while ( pClassToken = TokenList.GetNext( TYPE_CLASS ) )
    {
        if (!IsSpecialProperty(pClassToken))
        {
            fprintf ( fpHDLFile, "\n//    Property get/set method implementation for class %s\n", (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ) );
            fprintf ( fpHDLFile, "\n" );

            CTokenListWalker ChildList ( pClassToken );
            while ( pChildToken = ChildList.GetNext() )
            {
                if ( pChildToken->nType == TYPE_METHOD ||
                    pChildToken->nType == TYPE_IMPLEMENTS ||
                    pChildToken -> IsSet ( PROPERTY_ABSTRACT ) ||
                    pChildToken -> IsSet ( PROPERTY_BASEIMPLEMENTATION ) )
                {
                    continue;
                }

                // If propdesc for nameOnly then we wont need a handler for this property
                // another property that matches this will do the handling.
                if ( _stricmp(pChildToken->GetTagValue(PROPERTY_NOPROPDESC), "nameonly") == 0 )
                    continue;

                if ( !GetTypeDetails ( pChildToken->GetTagValue ( PROPERTY_TYPE ),
                    szHandler, szFnPrefix ) )
                {
                    sprintf ( szErrorText ,"Invalid Type:%s in Class:%s Property:%s\n",
                        (LPCSTR)pChildToken->GetTagValue ( PROPERTY_TYPE ),
                        (LPCSTR)pClassToken->GetTagValue(CLASS_NAME),
                        (LPCSTR)pChildToken->GetTagValue ( PROPERTY_NAME ) );
                    ReportError ( szErrorText );
                    return FALSE;
                }

                if ( pChildToken -> IsSet ( PROPERTY_CAA ) )
                {
                    szOffsetOf = "(GetAttrArray())";
                }
                else
                {
                    szOffsetOf = "(this)";
                }
                szAType = pChildToken->GetTagValue ( PROPERTY_ATYPE );
                // Generate set implementation
                if ( pChildToken -> IsSet ( PROPERTY_SET ) )
                {
                    szHandlerArgs = "HANDLEPROP_SET | HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16)";
                    GenerateMethodImp ( pClassToken, pChildToken, TRUE,
                        szHandler, szHandlerArgs, szOffsetOf, szAType );
                }
                // Generate Get implementation
                if ( pChildToken -> IsSet ( PROPERTY_GET )  )
                {
                    szHandlerArgs = "HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16)";
                    GenerateMethodImp ( pClassToken, pChildToken, FALSE,
                        szHandler, szHandlerArgs, szOffsetOf, szAType );
                }
            }
        }

        fprintf ( fpHDLFile, "\n" );

        // Whip thru all tearoffs.
        Token  *pLastTearoff = NULL;
        BOOL    fMostDerivedOnly;
        while ((pLastTearoff = NextTearoff((LPCSTR)pClassToken->GetTagValue(CLASS_NAME), pLastTearoff)))
        {
            LPSTR       szInterface = (LPSTR)pLastTearoff->GetTagValue(TEAROFF_INTERFACE);

            // If the tearoff is the primary interface of the coclass then we'll
            // not stack the derived interfaces but generate separate 
            fMostDerivedOnly = (_stricmp(szInterface, (LPSTR)pClassToken->GetTagValue(CLASS_INTERFACE)) == 0 &&
                                _stricmp(szInterface, "IHTMLDocument2"));

            if ( !GenerateTearoffTable(pClassToken, pLastTearoff, szInterface, fMostDerivedOnly))
                return FALSE;
        }
    }
    return TRUE;
}


BOOL CPDLParser::FindTearoffMethod(Token *pTearoff, LPCSTR pszTearoffMethod, LPSTR pszUseTearoff)
{
    Token *pChildToken;

    CTokenListWalker ChildList(pTearoff);
    while (pChildToken = ChildList.GetNext())
    {
        if (pChildToken->GetType() == TYPE_TEAROFFMETHOD)
        {
            if (strcmp((LPCSTR)pChildToken->GetTagValue(TEAROFFMETHOD_NAME),
                       pszTearoffMethod) == 0)
            {
                // Check if there is a class name in the method, if it is then
                // extract it explicity.
              	strcpy(pszUseTearoff, (LPCSTR)pChildToken->GetTagValue(TEAROFFMETHOD_MAPTO));

                return TRUE;
            }
        }
    }

    // Call the super:: implementation except for the primary tearoff the base
    // implementation of each method if not specified is the current class.
    strcpy(pszUseTearoff, pTearoff->IsSet(TEAROFF_BASEIMPL) ?
                            (LPCSTR)pTearoff->GetTagValue(TEAROFF_BASEIMPL) : "");
    strcat(pszUseTearoff, pszTearoffMethod);

    return FALSE;
}

// We exploit the Linker's Case insensitive feature to do Tearoffs in Win16.
// This function takes a Tearoff Method and generates a name that is different
// in case from the Real Tearoff Method. We have to follow certain rules so that
// the compiler doesn't complain about undefined symbols and the linker puts in
// the correct address anyhow.
void GenerateWin16TearoffName(LPSTR szWin16Name, LPSTR pszTearoffMethod, LPSTR szClassName = NULL)
{
    strcpy(szWin16Name, pszTearoffMethod);
    // if the Tearoff has a put_ or get_ prefix then we capitalize the PUT_
    // or GET_
    if ( !strncmp(szWin16Name, "put_", 4) )
    {
        strncpy(szWin16Name, "PUT_", 4);
        return;
    }
    if ( !strncmp(szWin16Name, "get_", 4) )
    {
        strncpy(szWin16Name, "GET_", 4);
        return;
    }

    // Check if there is a class name in the method, if it is super
    // then let it be else extract that and copy it to szClassName.
    char *p = strstr(szWin16Name, "::");

    if ( p && strncmp(szWin16Name, "super::",7) )
    {
        strcpy(pszTearoffMethod, p+2);
        if ( szClassName )
        {
            *p = '\0';
            strcpy(szClassName, szWin16Name);
        }
        strcpy(szWin16Name, pszTearoffMethod);
    }

    // lower case the name.
    _strlwr(szWin16Name);
    // make sure the generated name is different from the original one.
    if ( !strcmp( pszTearoffMethod, szWin16Name) )
    {
        char *p = strstr(szWin16Name, "::");

        // Ok, the Method name is all lower case, so we upper case the
        // name after the First char. We also need to skip past the Class Name
        // if any. Upper casing the whole name gave some other problems.
        if ( p != NULL )
            _strupr(p+2);
        else
            _strupr(szWin16Name+1);
    }

}

BOOL CPDLParser::GenerateTearoffTable ( Token *pClassToken, Token *pTearoff, LPCSTR pszInterface, BOOL fMostDerived )
{
    fprintf ( fpHDLFile, "//    Tear-off table for class %s\n",
        pClassToken -> GetTagValue ( CLASS_NAME ) );

    if (IsSpecialTearoff(pTearoff))
    {
        fprintf ( fpHDLFile, "BEGIN_TEAROFF_TABLE_PROPDESC(%s, %s)\n",
            pClassToken -> GetTagValue ( CLASS_NAME ),
            pszInterface );
    }
    else
    {
        fprintf ( fpHDLFile, "BEGIN_TEAROFF_TABLE(%s, %s)\n",
            pClassToken -> GetTagValue ( CLASS_NAME ),
            pszInterface );
    }

    // Walk the interface heirarchy, starting at this classes primary
    // interface, generate a fn table for each interface encountered
    // started with IDispatch methods above. Generate methods in interface order - deepest
    // first

    if ( !GenerateTearOffMethods ( pClassToken -> GetTagValue ( CLASS_NAME ), pTearoff, pszInterface, fMostDerived) )
        return FALSE;

    fprintf ( fpHDLFile, "END_TEAROFF_TABLE()\n\n" );

    return TRUE;
}


Token *CPDLParser::GetSuperClassTokenPtr ( Token *pClassToken )
{
    Token *pSuperToken = NULL;
    if ( pClassToken -> IsSet ( CLASS_SUPER ) )
    {
        CTokenListWalker WholeList ( pRuntimeList );
        pSuperToken = WholeList.GetNext ( TYPE_CLASS,
            pClassToken -> GetTagValue ( CLASS_SUPER ) );
    }
    return pSuperToken;
}

BOOL CPDLParser::HasClassGotProperties ( Token *pClassToken )
{
    Token *pSuperClass;
    CTokenListWalker PropList ( pClassToken );

    if ( PropList.GetNext ( TYPE_PROPERTY ) )
        return TRUE;
    else
    {
        pSuperClass = GetSuperClassTokenPtr ( pClassToken );
        if ( pSuperClass )
            return HasClassGotProperties ( pSuperClass );
        else
            return FALSE;
    }
}


BOOL CPDLParser::PrimaryTearoff (Token *pInterface)
{
    return !pInterface->IsSet(INTERFACE_NOPRIMARYTEAROFF);
}


Token * CPDLParser::NextTearoff (LPCSTR szClassname, Token *pLastTearoff /*= NULL*/)
{
    CTokenListWalker    ThisFilesList(pRuntimeList, _pszPDLFileName);
    Token              *pTearoffToken;
    BOOL                fNextOne = FALSE;

    while (pTearoffToken = ThisFilesList.GetNext(TYPE_TEAROFF))
    {
        if (_stricmp(szClassname, (LPSTR)pTearoffToken->GetTagValue(TEAROFF_NAME)) == 0)
        {
            // The correct class.
            if (pLastTearoff)
            {
                // Return this one.
                if (!fNextOne)
                {
                    fNextOne = pLastTearoff == pTearoffToken;
                    continue;                   // Get the next and then stop.
                }
            }

            break;
        }
    }

    return pTearoffToken;
}


Token* CPDLParser::FindTearoff (LPCSTR szClassname, LPCSTR szInterface)
{
    Token  *pLastTearoff = NULL;

    while (pLastTearoff = NextTearoff(szClassname, pLastTearoff))
    {
        if (!_stricmp(szInterface, (LPSTR)pLastTearoff->GetTagValue(TEAROFF_INTERFACE)))
        {
            break;
        }
    }

    return pLastTearoff;
}


BOOL CPDLParser::GenerateClassIncludes (void)
{
    Token              *pClassToken;
    CTokenListWalker    ThisFilesList(pRuntimeList, _pszPDLFileName);

    // Walk the class statments for this file only
    fprintf(fpLOGFile, "*** Looking for \"%s\"\n",_pszPDLFileName);

    while (pClassToken = ThisFilesList.GetNext(TYPE_CLASS))
    {
        LPCSTR   szClassname = (LPCSTR)pClassToken->GetTagValue(CLASS_NAME);

        fprintf(fpHDLFile, "#ifdef _%s_\n\n", szClassname);

        // Write out inline cached get helpers
        fprintf(fpHDLFile,
                "\n//  Cascaded Property get method prototypes for class %s\n\npublic:\n",
                szClassname);

        GenerateGetAAXPrototypes(pClassToken);

        fprintf(fpHDLFile,
                "\n//    Property get/set method declarations for class %s\n",
                szClassname);

        // Always add a propdesc declaration for non-abstract classes, remember
        // abstract class haven't got a propertydesc array.

        // TODO: TerryLu - Need to add code here to handle the shared keyword
        if ((!pClassToken->IsSet(CLASS_ABSTRACT)) || 
            (_stricmp(pClassToken->GetTagValue(CLASS_NAME), "CElement") == 0))
        {
            if(_stricmp(pClassToken->GetTagValue(CLASS_NAME), "CElement") != 0)
            {
                fprintf(fpHDLFile, 
                        "    static const HDLDESC %s::s_apHdlDescs;\n",
                        szClassname);
            }
            fprintf(fpHDLFile, 
                    "    static const CAssocVTable * const s_AssocVTablePtr[];\n");
            fprintf(fpHDLFile,
                    "    static const CAssocArrayVTable s_StringTable;\n");
            fprintf(fpHDLFile,
                    "    static const CPtrBagVTableAggregate s_StringTableAggregate;\n");
            if(_stricmp(pClassToken->GetTagValue(CLASS_NAME), "COmWindowProxy") == 0)
            {
                fprintf(fpHDLFile, "static const VTABLEDESC * const COmWindowProxy::s_COmWindowProxyDocument;\n");
            }

        }

        CString szInterface;
        Token *pInterface;
        BOOL fOk;

        Token *pTearoff = NULL;
        while ((pTearoff = NextTearoff(szClassname, pTearoff)))
        {
            szInterface = pTearoff->GetTagValue(TEAROFF_INTERFACE);
            pInterface = FindInterface(szInterface);

            if (pInterface)
            {
                CTokenListWalker    ChildList(pInterface);
                Token *pChildToken = ChildList.GetNext();
                if (pChildToken)
                {
                    fOk = FALSE;

                    do
                    {
                        if (pChildToken->GetType() == TYPE_PROPERTY && !pChildToken->IsSet(PROPERTY_ABSTRACT) && !pChildToken->IsSet(PROPERTY_BASEIMPLEMENTATION))
                        {
                            fOk = TRUE;
                            break;
                        }
                    } while (pChildToken = ChildList.GetNext());

                    if (fOk)
                    {
                        fprintf(fpHDLFile, "    static const PROPERTYDESC * const %s::s_ppropdescsInVtblOrder%s [];\n",
                            szClassname, (LPSTR)pTearoff->GetTagValue(TEAROFF_INTERFACE));
                    }
                }
            }
        }

        // Generate a CPC if, we have an eventset && it is unique to us
        if ( IsUniqueCPC ( pClassToken ) )
        {
            fprintf(fpHDLFile,
                    "    static const CONNECTION_POINT_INFO %s::s_acpi[];\n",
                    szClassname);
        }

        GeneratePropMethodDecl(pClassToken);

        if (pClassToken->IsSet(CLASS_EVENTS))
        {
            if (!GenerateEventFireDecl(pClassToken))
            {
                return FALSE;
            }
        }

        // Whip thru all tearoffs.
        Token  *pLastTearoff = NULL;
        while ((pLastTearoff = NextTearoff(szClassname, pLastTearoff)))
        {
            // Need static tearoff table decl
            if (IsSpecialTearoff(pLastTearoff))
            {
                fprintf(fpHDLFile, "    DECLARE_TEAROFF_TABLE_PROPDESC(%s)\n",
                        pLastTearoff->GetTagValue(TEAROFF_INTERFACE));
            }
            else
            {
                fprintf(fpHDLFile, "    DECLARE_TEAROFF_TABLE(%s)\n",
                        pLastTearoff->GetTagValue(TEAROFF_INTERFACE));
            }
        }

        GenerateThunkContext(pClassToken);

        fprintf(fpHDLFile, "\n#endif // _%s_\n\n", szClassname);
        fprintf(fpHDLFile, "#undef _%s_\n\n", szClassname);
    }

    return TRUE;
}

// Work out if this class has a unique connection point info structure - 
// or can we use its super ??
BOOL CPDLParser::IsUniqueCPC ( Token *pClassToken )
{
    BOOL                fDoIt = FALSE;
    Token               *pClass;
    CString             szSuperClass, szThisEvents, szThatEvents;

    if ( !pClassToken->IsSet(CLASS_NOCPC) && pClassToken->IsSet ( CLASS_EVENTS ) )
    {
        szThisEvents = pClassToken->GetTagValue(CLASS_EVENTS);
        fDoIt = TRUE;
        for ( pClass = pClassToken ; pClass ; )
        {
            if ( pClass->IsSet ( CLASS_SUPER ) )
            {
                szSuperClass = pClass -> GetTagValue ( CLASS_SUPER );
                pClass = FindClass ( szSuperClass );
                if ( pClass && pClass->IsSet ( CLASS_EVENTS ) && !pClass->IsSet(CLASS_NOCPC) )
                {
                    szThatEvents = pClass->GetTagValue(CLASS_EVENTS);
                    if ( szThatEvents == szThisEvents )
                    {
                        // Do we have non-primary events #1 and is the super non-primary events
                        // the same as ours?  If not, then we are unique.
                        if (pClassToken->IsSet(CLASS_NONPRIMARYEVENTS1))
                        {
                            szThisEvents = pClassToken->GetTagValue(CLASS_NONPRIMARYEVENTS1);
                            szThatEvents = pClass->GetTagValue(CLASS_NONPRIMARYEVENTS1);
                            if (szThatEvents != szThisEvents)
                            {
                                // We're unique.
                                break;
                            }
                            // Do we have non-primary events #2 and is the super non-primary events
                            // the same as ours?  If not, then we are unique.
                            if (pClassToken->IsSet(CLASS_NONPRIMARYEVENTS2))
                            {
                                szThisEvents = pClassToken->GetTagValue(CLASS_NONPRIMARYEVENTS2);
                                szThatEvents = pClass->GetTagValue(CLASS_NONPRIMARYEVENTS2);
                                if (szThatEvents != szThisEvents)
                                {
                                    // We're unique.
                                    break;
                                }
                                // Do we have non-primary events #3 and is the super non-primary events
                                // the same as ours?  If not, then we are unique.
                                if (pClassToken->IsSet(CLASS_NONPRIMARYEVENTS3))
                                {
                                    szThisEvents = pClassToken->GetTagValue(CLASS_NONPRIMARYEVENTS3);
                                    szThatEvents = pClass->GetTagValue(CLASS_NONPRIMARYEVENTS3);
                                    if (szThatEvents != szThisEvents)
                                    {
                                        // We're unique.
                                        break;
                                    }
                                    // Do we have non-primary events #4 and is the super non-primary events
                                    // the same as ours?  If not, then we are unique.
                                    if (pClassToken->IsSet(CLASS_NONPRIMARYEVENTS4))
                                    {
                                        szThisEvents = pClassToken->GetTagValue(CLASS_NONPRIMARYEVENTS4);
                                        szThatEvents = pClass->GetTagValue(CLASS_NONPRIMARYEVENTS4);
                                        if (szThatEvents != szThisEvents)
                                        {
                                            // We're unique.
                                            break;
                                        }
                                    }
                                }
                            }
                            // else fall through to below which set's fDoIt to FALSE.
                        }                        
                        
                        fDoIt = FALSE;
                        break;
                    }
                    break;
                }
            }
            else
                break;
        }
    }
    return fDoIt;
}

BOOL CPDLParser::GenerateEventFireDecl ( Token *pClassToken )
{
    Token *pEventToken;

    fprintf ( fpHDLFile, "//    Event fire method declarations for events %s\n",
        pClassToken -> GetTagValue ( CLASS_EVENTS ) );

    // Find the event declaration
    CTokenListWalker WholeList ( pRuntimeList ) ;
    pEventToken = WholeList.GetNext ( TYPE_EVENT, pClassToken -> GetTagValue ( CLASS_EVENTS ) );
    if ( pEventToken == NULL )
    {
        return FALSE;
    }

    return GenerateEventDecl ( pClassToken, pEventToken );
}

BOOL CPDLParser::IsElementEvent(Token *pEventInterface)
{
    CTokenListWalker WholeList(pRuntimeList);
    CString szEvent;
    CString szElementEvent;

    if (!pEventInterface)
        return FALSE;

    szEvent = pEventInterface->GetTagValue(EVENT_NAME);
    if (_stricmp((LPCSTR)szEvent, "HTMLObjectElementEvents") == 0)
        return TRUE;

    szElementEvent = "HTMLElementEvents";
    while (pEventInterface)
    {
        if (szElementEvent == szEvent)
            return TRUE;

        szEvent = pEventInterface->GetTagValue(EVENT_SUPER);
        WholeList.Reset();
        pEventInterface = WholeList.GetNext(TYPE_EVENT, szEvent);
    }

    return FALSE;
}

BOOL CPDLParser::GenerateEventDecl ( Token *pClassToken, Token *pEventToken )
{
/* TLL: Don't spit out any arguments.  Currently the only argument for event is eventObject which is computed
    Token *pArgToken;
*/
    Token *pChildToken;
    char szErrorText [ MAX_LINE_LEN+1 ];
    CTokenListWalker ChildList ( pEventToken );
    CString szNameUpper;
    CString szNameLower;
    BOOL fDocEvents = (_stricmp(pClassToken->GetTagValue(CLASS_EVENTS), "HTMLDocumentEvents") == 0) ||
                      (_stricmp(pClassToken->GetTagValue(CLASS_EVENTS), "HTMLProtectedElementEvents") == 0) ||
                      (_stricmp(pClassToken->GetTagValue(CLASS_EVENTS), "HTMLNamespaceEvents") == 0);
    BOOL fWindowEvents = _stricmp(pClassToken->GetTagValue(CLASS_EVENTS), "HTMLWindowEvents") == 0;
    BOOL fElementEvents = !fDocEvents && !fWindowEvents && IsElementEvent(pEventToken); 

    while ( pChildToken = ChildList.GetNext() )
    {
        if (!fElementEvents && !fDocEvents && !fWindowEvents &&
            (_stricmp(pClassToken->GetTagValue(CLASS_EVENTS), "DWebBridgeEvents") != 0))
        {
            sprintf ( szErrorText, "Need to modify GenerateEventDecl() in parser.cpp to pass in Doc ptr to FireEvent for class:%s\n",
                (LPCSTR)pClassToken->GetTagValue(CLASS_NAME) );
            ReportError ( szErrorText );
            return FALSE;
        }
        if ( pChildToken -> GetType() == TYPE_METHOD &&
            !pChildToken -> IsSet ( METHOD_ABSTRACT ) )
        {
            szNameUpper = pChildToken -> GetTagValue ( METHOD_NAME );
            szNameLower = szNameUpper;
            szNameUpper.ToUpper();

            if (!FindEventProp(pClassToken, (LPCSTR)szNameLower))
                continue;

            // Method
            
            fprintf ( fpHDLFile, "    %s Fire_%s(",
                pChildToken->IsSet(METHOD_CANCELABLE) ? "BOOL" : "void",
                pChildToken -> GetTagValue ( METHOD_NAME ) );

            CTokenListWalker ArgListWalker ( pChildToken );
            BOOL fFirst = TRUE;

/* TLL: Don't spit out any arguments.  Currently the only argument for event is eventObject which is computed
            while ( pArgToken = ArgListWalker.GetNext() )
            {
                if ( !fFirst )
                    fprintf ( fpHDLFile, "," );
                fprintf ( fpHDLFile, "%s %s",
                    (LPCSTR)pArgToken -> GetTagValue ( METHODARG_TYPE ),
                    (LPCSTR)pArgToken -> GetTagValue ( METHODARG_ARGNAME ));
                fFirst = FALSE;
            }
*/
            if ( pChildToken->IsSet(METHOD_BUBBLING) )
            {
                if ( !fFirst )
                    fprintf ( fpHDLFile, "," );
                fprintf ( fpHDLFile, "CTreeNode * pNodeContext = NULL");
                fprintf ( fpHDLFile, ", long lSubDivision = -1");
            }

            fprintf ( fpHDLFile, ")\n    {\n        " );

            if ( pChildToken->IsSet(METHOD_CANCELABLE) )
            {
                fprintf ( fpHDLFile, "return !!" );
            }

            if (fElementEvents)
            {
                fprintf(fpHDLFile, "FireEvent(&s_propdesc%s%s%s",
                    (LPCSTR)pClassToken->GetTagValue(CLASS_NAME),
                    (LPCSTR)szNameLower,
                    pChildToken->IsSet(METHOD_BUBBLING) ? ", TRUE, pNodeContext, lSubDivision" : "");
            }
            else
            {
                fprintf(fpHDLFile, "FireEvent(%sDISPID_EVMETH_%s, DISPID_EVPROP_%s, _T(\"%s\")",
                    fDocEvents ? "Doc(), " : (fWindowEvents ? "_pDoc, " : ""),
                    (LPCSTR)szNameUpper,
                    (LPCSTR)szNameUpper,
                    (LPCSTR)szNameLower+2);
            }

/* TLL: Don't spit out any arguments.  Currently the only argument for event is eventObject which is computed
            ArgListWalker.Reset();
            if ( ArgListWalker.GetTokenCount() > 0 )
            {
                while ( pArgToken = ArgListWalker.GetNext() )
                {
                    // Locate the vts type for this type
                    CString szVTSType;

                    if ( !LookupEventType ( szVTSType, pArgToken -> GetTagValue ( METHODARG_TYPE ) ) )
                    {
                        sprintf ( szErrorText, "Unknown Type %s in %s::Fire%s event declaration\n",
                            (LPCSTR) pArgToken -> GetTagValue ( METHODARG_TYPE ),
                            pEventToken -> GetTagValue ( EVENT_NAME ),
                            pChildToken -> GetTagValue ( METHOD_NAME ) );
                        ReportError ( szErrorText );
                        return FALSE;
                    }
                    fprintf ( fpHDLFile, " %s", (LPCSTR)szVTSType );
                    fFirst = FALSE;
                }
                ArgListWalker.Reset();
                while ( pArgToken = ArgListWalker.GetNext() )
                {
                    fprintf ( fpHDLFile, ", %s",
                        pArgToken -> GetTagValue ( METHODARG_ARGNAME ) );
                }
            }
            else
            {
                fprintf ( fpHDLFile, " VTS_NONE" );
            }
*/
            fprintf ( fpHDLFile, ");\n    }\n" );
        }
        else if ( pChildToken -> GetType() == TYPE_PROPERTY )
        {
            // Property in event set - should never happen if we
            // check the child/parent relationships at parse time
            sprintf ( szErrorText, "events %s - invalid to have a property in event set\n",
                (LPCSTR)pClassToken -> GetTagValue ( EVENT_NAME ) );
            ReportError ( szErrorText );
            return FALSE;
        }
    }
    return TRUE;
}


LPCSTR CPDLParser::ConvertType(LPCSTR szType, BOOL fComPlus /* = FALSE*/, LPSTR pCPString /* = 0*/, BOOL *pfInterfaceFound /* = 0*/)
{
    if (!fComPlus)
    {
        if (_stricmp(szType, "SAFEARRAY(VARIANT)") == 0)
            return("SAFEARRAY*");
        else
            return(szType);
    }
    else
    {
        BOOL	fInterfFound;

        if (!pfInterfaceFound)
        {
            pfInterfaceFound = &fInterfFound;
        }

        *pfInterfaceFound = FALSE;

        if (_stricmp(szType, "BSTR") == 0)
            return("String");
        else if (_stricmp(szType, "VARIANT_BOOL") == 0)
            return("Boolean");
        else if (_stricmp(szType, "VARIANT") == 0)
            return("Variant");
        else if (_stricmp(szType, "IDispatch") == 0 || _stricmp(szType, "IUnknown") == 0)
            return("Object");
        else if (_stricmp(szType, "SAFEARRAY(VARIANT)") == 0)
            return("String");		// ***TLL*** COM+: Need to make it a safearray
        else if (pCPString)
        {
            CString pInterf;
            
            pInterf = szType;

            if (FindInterface(pInterf))
            {
                strcpy(pCPString, szType);
                strcat(pCPString, "COMPLUS");
                *pfInterfaceFound = TRUE;
                return 0;
            }
            else
            {
                return(szType);
            }
        }
        else
            return(szType);
    }
}

void CPDLParser::GeneratePropMethodDecl ( Token *pClassToken )
{
    CTokenListWalker ChildList ( pClassToken );

    CString szProp;
    Token *pArgToken;
    Token *pChildToken;
    char szContextThunk[] = "ContextThunk_";
    LPCSTR   pCtxt;

    while ( pChildToken = ChildList.GetNext() )
    {
        char    szTemp[256];
        LPSTR   pMethodName;
        BOOL    fNameOnly;

        fNameOnly = _stricmp(pChildToken->GetTagValue(METHOD_NOPROPDESC), "nameonly") == 0;

        if ( pChildToken -> GetType() == TYPE_METHOD  && !fNameOnly )
        {
            // Method
            fprintf ( fpHDLFile, "    " );
            if ( pChildToken -> IsSet ( METHOD_VIRTUAL ) )
            {
                //fprintf ( fpHDLFile, "virtual " );
                fprintf ( fpHDLFile, "DECLARE_TEAROFF_METHOD_(" );
            }
            else
                fprintf ( fpHDLFile, "NV_DECLARE_TEAROFF_METHOD_(" );

           	pMethodName = pChildToken->IsSet(METHOD_SZINTERFACEEXPOSE) ?
                            (LPSTR)pChildToken->GetTagValue(METHOD_SZINTERFACEEXPOSE) :
                            (LPSTR)pChildToken->GetTagValue(METHOD_NAME);

            GenerateWin16TearoffName(szTemp, pMethodName);

            pCtxt = pChildToken->IsSet(METHOD_THUNKCONTEXT) ||
                    pChildToken->IsSet(METHOD_THUNKNODECONTEXT)
                      ? szContextThunk : "";

            //fprintf ( fpHDLFile, "%s STDMETHODCALLTYPE %s(",
            fprintf ( fpHDLFile, "%s, %s%s, %s, (",
                pChildToken -> GetTagValue ( METHOD_RETURNTYPE ),
                pCtxt, pMethodName, szTemp );

            CTokenListWalker ArgListWalker ( pChildToken );
            BOOL fFirst = TRUE;
            while ( pArgToken = ArgListWalker.GetNext() )
            {
                if ( !fFirst )
                    fprintf ( fpHDLFile, "," );
                fprintf ( fpHDLFile, "%s %s",
                    ConvertType((LPCSTR)pArgToken -> GetTagValue ( METHODARG_TYPE )),
                    (LPCSTR)pArgToken -> GetTagValue ( METHODARG_ARGNAME ) );
                fFirst = FALSE;
            }
            fprintf ( fpHDLFile, "));\n" );
        }
        else
        {
            fNameOnly = _stricmp(pChildToken->GetTagValue(PROPERTY_NOPROPDESC), "nameonly") == 0;

            // Base has provided prototoype
            if ( pChildToken -> IsSet ( PROPERTY_BASEIMPLEMENTATION )
                || (!pChildToken->IsSet(PROPERTY_ABSTRACT) && IsSpecialProperty(pClassToken))
                )
            {
                continue;
            }
            // Property
            szProp = "";
            // Through the index/indextype & index1/indextype1 pdl tags
            // you can provide up to two additional args for the property definition
            if ( pChildToken -> IsSet ( PROPERTY_INDEX ) )
            {
                szProp += pChildToken -> GetTagValue ( PROPERTY_INDEXTYPE );
                szProp += " ";
                szProp += pChildToken -> GetTagValue ( PROPERTY_INDEX );
            }
            if ( pChildToken -> IsSet ( PROPERTY_INDEX1 ) )
            {
                if ( szProp [ 0 ] != '\0' )
                    szProp += ",";
                szProp += pChildToken -> GetTagValue ( PROPERTY_INDEXTYPE1 );
                szProp += " ";
                szProp += pChildToken -> GetTagValue ( PROPERTY_INDEX1 );
            }
            if ( szProp [ 0 ] != '\0' )
                szProp += ",";

           	pMethodName = pChildToken->IsSet(PROPERTY_SZINTERFACEEXPOSE) ?
                            (LPSTR)pChildToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE) :
                            (LPSTR)pChildToken->GetTagValue(PROPERTY_NAME);

            pCtxt = pChildToken->IsSet(PROPERTY_THUNKCONTEXT) ||
                    pChildToken->IsSet(PROPERTY_THUNKNODECONTEXT) 
                    ? szContextThunk : "";

            if ( pChildToken -> IsSet ( PROPERTY_SET ) && !fNameOnly )
            {
                fprintf ( fpHDLFile, "    " );
                if ( pChildToken -> IsSet ( PROPERTY_VIRTUAL ) )
                {
                    fprintf ( fpHDLFile, "DECLARE_TEAROFF_METHOD(%sput_%s, PUT_%s, (%s%s v));\n",
                        pCtxt,
                        pMethodName,
                        pMethodName,
                        (LPCSTR)szProp,
                        (LPCSTR)pChildToken -> GetTagValue ( PROPERTY_ATYPE ));
                }
                else
                {
                    fprintf ( fpHDLFile, "NV_DECLARE_TEAROFF_METHOD(%sput_%s, PUT_%s, (%s%s v));\n",
                        pCtxt,
                        pMethodName,
                        pMethodName,
                        (LPCSTR)szProp,
                        (LPCSTR)pChildToken -> GetTagValue ( PROPERTY_ATYPE ));
                }

            }
            if ( pChildToken -> IsSet ( PROPERTY_GET ) && !fNameOnly)
            {
                fprintf ( fpHDLFile, "    " );
                if ( pChildToken -> IsSet ( PROPERTY_VIRTUAL ) )
                {
                    fprintf ( fpHDLFile, "DECLARE_TEAROFF_METHOD(%sget_%s, GET_%s, (%s%s*p));\n",
                        pCtxt,
                        pMethodName,
                        pMethodName,
                        (LPCSTR)szProp,
                        (LPCSTR)pChildToken -> GetTagValue ( PROPERTY_ATYPE ));
                }
                else
                {
                    fprintf ( fpHDLFile, "NV_DECLARE_TEAROFF_METHOD(%sget_%s, GET_%s, (%s%s*p));\n",
                        pCtxt,
                        pMethodName,
                        pMethodName,
                        (LPCSTR)szProp,
                        (LPCSTR)pChildToken -> GetTagValue ( PROPERTY_ATYPE ));
                }
            }
        }
    }

}

BOOL CPDLParser::IsStoredAsString( Token *pChildToken )
{
    CString szJunk1, szJunk2;
    StorageType stHowStored;

    GetTypeDetails ( pChildToken->GetTagValue ( PROPERTY_TYPE ),
        szJunk1, szJunk2, &stHowStored );

    return stHowStored == STORAGETYPE_STRING ? TRUE : FALSE;
}


void CPDLParser::GenerateGetAAXPrototypes ( Token *pClassToken )
{
    CTokenListWalker ChildList ( pClassToken );

    Token *pChildToken;

    if (  pClassToken -> IsSet ( CLASS_NOAAMETHODS ) )
        return;

    while ( pChildToken = ChildList.GetNext() )
    {
        // Generate a GetAA prototype even if the automation Get method is not generated
        if ( pChildToken -> GetType() != TYPE_METHOD &&
             pChildToken -> IsSet ( PROPERTY_CAA ) &&
             _stricmp(pChildToken->GetTagValue(PROPERTY_NOPROPDESC), "nameonly"))
        {
            BOOL fIsString = IsStoredAsString(pChildToken);

            //setaahr method
            if (pChildToken -> IsSet ( PROPERTY_SETAAHR ) )
            {
                fprintf ( fpHDLFile, "    HRESULT SetAA%s(%s);\n",
                    (LPCSTR)pChildToken -> GetTagValue ( PROPERTY_NAME ),
                    (LPCSTR)(fIsString?"LPCTSTR": (LPCSTR)pChildToken -> GetTagValue ( PROPERTY_TYPE ) )
                    );
            }

            //get method. If the property refers to a cascaded format - don't generate a GetAA - this would just
            // encourage mis-use. Always want to force use of GetCascadedXX variant
            if ( !pChildToken -> IsSet ( PROPERTY_CASCADED ) ||
                pChildToken -> IsSet ( PROPERTY_GETAA ) )
            {
                fprintf ( fpHDLFile, "    %s GetAA%s() const;\n",
                    (LPCSTR)(fIsString?"LPCTSTR":(LPCSTR)pChildToken -> GetTagValue ( PROPERTY_TYPE )),
                    (LPCSTR)(pChildToken->GetTagValue ( PROPERTY_NAME )) );
            }
        }
    }
}


void CPDLParser::GenerateGetAAXImplementations( Token *pClassToken )
{
    CTokenListWalker ChildList ( pClassToken );

    Token *pChildToken;

    if (  pClassToken -> IsSet ( CLASS_NOAAMETHODS ) )
        return;

    while ( pChildToken = ChildList.GetNext() )
    {
        // Generate a GetAA prototype even if the automation Get method is not generated
        if ( pChildToken -> GetType() != TYPE_METHOD &&
             pChildToken -> IsSet ( PROPERTY_CAA ) &&
             _stricmp(pChildToken->GetTagValue(PROPERTY_NOPROPDESC), "nameonly"))
        {
            BOOL fIsString = IsStoredAsString(pChildToken);

            //setaahr method
            if (pChildToken -> IsSet ( PROPERTY_SETAAHR ) )
            {
                if (!strcmp((LPCSTR)pChildToken ->GetTagValue(PROPERTY_TYPE), "VARIANT_BOOL"))
                {
                    fprintf ( fpHDLFile, "HRESULT %s::SetAA%s(VARIANT_BOOL pv)\n{\n    DWORD  dwTemp = pv;\n    RRETURN( THR( CAttrArray::SetSimple(GetAttrArray(), &s_propdesc%s%s.a, dwTemp) ) );\n}\n",
                        (LPCSTR)pClassToken -> GetTagValue ( CLASS_NAME ),
                        (LPCSTR)pChildToken -> GetTagValue ( PROPERTY_NAME ),
                        (LPCSTR)pClassToken -> GetTagValue ( CLASS_NAME ),
                        (LPCSTR)pChildToken -> GetTagValue ( PROPERTY_NAME )
                        );
                }
                else
                {
                    fprintf ( fpHDLFile, "HRESULT %s::SetAA%s(%s pv)\n{\n    RRETURN( THR( CAttrArray::Set%s(GetAttrArray(), &s_propdesc%s%s.a, %spv) ) );\n}\n",
                        (LPCSTR)pClassToken -> GetTagValue ( CLASS_NAME ),
                        (LPCSTR)pChildToken -> GetTagValue ( PROPERTY_NAME ),
                        (LPCSTR)( fIsString?"LPCTSTR":(LPCSTR)pChildToken ->GetTagValue(PROPERTY_TYPE) ),
                        (LPCSTR)(fIsString?"String":"Simple"),
                        (LPCSTR)pClassToken -> GetTagValue ( CLASS_NAME ),
                        (LPCSTR)pChildToken -> GetTagValue ( PROPERTY_NAME ),
                        (LPCSTR)(fIsString?"":"*(DWORD*) &")
                        );
                }
            }

            //get method. Don't generate a GetAA - they already have a GetCascadedX
            if ( !pChildToken -> IsSet ( PROPERTY_CASCADED ) ||
                pChildToken -> IsSet ( PROPERTY_GETAA ) )
            {
                Token      *pExposeToken = NULL;
                CString     szClass;

                if (pChildToken -> IsSet ( PROPERTY_NOPROPDESC ))
                {
                    pExposeToken = FindMatchingEntryWOPropDesc(pClassToken, pChildToken);
                }

                if (!pExposeToken)
                    pExposeToken = pChildToken;

                if (strlen( pExposeToken -> GetTagValue ( PROPERTY_REFDTOCLASS )))
                    szClass = pExposeToken -> GetTagValue ( PROPERTY_REFDTOCLASS );
                else
                    szClass = (LPCSTR)pClassToken -> GetTagValue ( CLASS_NAME );

#ifdef UNIX // IEUNIX: On Unix, converting DWORD* to short* would cause value changed. So we cast it from DWORD to short. 
                if (!fIsString)
                {
                    LPCSTR pPropType = (LPCSTR)pChildToken->GetTagValue( PROPERTY_TYPE);
                    if ( !_stricmp(pPropType , "short") || !_stricmp(pPropType, "WORD") || !_stricmp(pPropType, "BYTE") )
                    {
                        fprintf ( fpHDLFile, "%s %s::GetAA%s() const \n{\n    DWORD v;\n    CAttrArray::FindSimple( *GetAttrArray(), &s_propdesc%s%s.a, &v);\n    return (%s)v;\n}\n",
                            pPropType,
                            (LPCSTR)pClassToken -> GetTagValue ( CLASS_NAME ),
                            (LPCSTR)(pChildToken->GetTagValue ( PROPERTY_NAME )),
                            (LPCSTR)szClass,
                            (LPCSTR)pChildToken -> GetTagValue ( PROPERTY_NAME ),
                            pPropType );
                        continue;
                    }
                }
#endif
                fprintf ( fpHDLFile, "%s %s::GetAA%s() const \n{\n    %s v;\n    CAttrArray::Find%s( *GetAttrArray(), &s_propdesc%s%s.a, &v);\n    return *(%s*)&v;\n}\n",
                    (LPCSTR)(fIsString?"LPCTSTR":(LPCSTR)pChildToken -> GetTagValue ( PROPERTY_TYPE )),
                    (LPCSTR)pClassToken -> GetTagValue ( CLASS_NAME ),
                    (LPCSTR)(pChildToken->GetTagValue ( PROPERTY_NAME )) ,
                    (LPCSTR)(fIsString?"LPCTSTR":"DWORD" ),
                    (LPCSTR)(fIsString?"String":"Simple"),
                    (LPCSTR)szClass,
                    (LPCSTR)pChildToken -> GetTagValue ( PROPERTY_NAME ),
                    (LPCSTR)(fIsString?"LPCTSTR":(LPCSTR)pChildToken -> GetTagValue ( PROPERTY_TYPE ) ) );
            }
        }
    }
}

BOOL CPDLParser::GenerateIDispatchTearoff ( LPCSTR szClassName, Token *pTearoff, LPCSTR pszInterface, BOOL fMostDerived)
{
    char    szTearoffMethod[128];
    char    szTemp[128];

    fprintf ( fpHDLFile, "    //  IDispatch methods\n");

    FindTearoffMethod(pTearoff, "GetTypeInfoCount", szTearoffMethod);
    GenerateWin16TearoffName(szTemp, szTearoffMethod);
    fprintf ( fpHDLFile, "    TEAROFF_METHOD(%s, %s, %s, (unsigned int *))\n", 
        szClassName, szTearoffMethod, szTemp);

    FindTearoffMethod(pTearoff, "GetTypeInfo", szTearoffMethod);
    GenerateWin16TearoffName(szTemp, szTearoffMethod);
    fprintf ( fpHDLFile, "    TEAROFF_METHOD(%s, %s, %s, (unsigned int, unsigned long, ITypeInfo **))\n", 
        szClassName, szTearoffMethod, szTemp);

    FindTearoffMethod(pTearoff, "GetIDsOfNames", szTearoffMethod);
    GenerateWin16TearoffName(szTemp, szTearoffMethod);
    fprintf ( fpHDLFile, "    TEAROFF_METHOD(%s, %s, %s, (REFIID, LPOLESTR *, unsigned int, LCID, DISPID *))\n", 
        szClassName, szTearoffMethod, szTemp);

    {
        CString szIHTMLElement, szInterface;
        szIHTMLElement = "IHTMLElement";
        szInterface = pszInterface;

        if(!FindTearoffMethod(pTearoff, "Invoke", szTearoffMethod) &&
           IsSuperInterface(szIHTMLElement, FindInterface(szInterface)))
        {
            strcpy(szTearoffMethod, pTearoff->IsSet(TEAROFF_BASEIMPL) ?
                            (LPCSTR)pTearoff->GetTagValue(TEAROFF_BASEIMPL) : "");
            strcat(szTearoffMethod, "ContextThunk_Invoke");
        }
    }

    GenerateWin16TearoffName(szTemp, szTearoffMethod);
    fprintf ( fpHDLFile, "    TEAROFF_METHOD(%s, %s, %s, (DISPID, REFIID, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, unsigned int *))\n", 
        szClassName, szTearoffMethod, szTemp);

    return TRUE;

}

BOOL CPDLParser::IsSpecialTearoff(Token *pTearoff)
{
    CString szInterface;
    Token *pInterface;
    Token *pChildToken;

    szInterface = pTearoff->GetTagValue(TEAROFF_INTERFACE);
    pInterface = FindInterface(szInterface);
    
    if (!pInterface || pInterface->IsSet(INTERFACE_ABSTRACT))
        return FALSE;

    CTokenListWalker    ChildList(pInterface);
    pChildToken = ChildList.GetNext();

    if (pChildToken)
    {
        do
        {
            if (pChildToken->GetType() == TYPE_PROPERTY && !pChildToken->IsSet(PROPERTY_ABSTRACT) && !pChildToken->IsSet(PROPERTY_BASEIMPLEMENTATION))
            {
                return TRUE;
            }
        } while (pChildToken = ChildList.GetNext());
    }

    return FALSE;
}

BOOL CPDLParser::FindTearoffProperty(Token *pPropertyToken, LPSTR szTearoffMethod, 
                                     LPSTR szTearOffClassName, LPSTR szPropArgs, BOOL fPropGet)
{
    if (pPropertyToken->IsSet(PROPERTY_ABSTRACT) || pPropertyToken->IsSet(PROPERTY_BASEIMPLEMENTATION))
        return FALSE;

    strcpy(szTearoffMethod, fPropGet ? "get_" : "put_");
    strcpy(szPropArgs, fPropGet ? "void" : (LPCSTR)pPropertyToken->GetTagValue(PROPERTY_ATYPE));
    strcpy(szTearOffClassName, "CBase");

    if (!strcmp(pPropertyToken->GetTagValue(PROPERTY_ATYPE), "VARIANT"))
    {
        if (fPropGet)
        {
            strcat(szTearoffMethod, "Property");
        }
        else if (pPropertyToken->IsSet(PROPERTY_DATAEVENT))
            strcat(szTearoffMethod, "DataEvent");
        else
            strcat(szTearoffMethod, "Variant");
    }
    else if (!strcmp(pPropertyToken->GetTagValue(PROPERTY_ATYPE), "BSTR"))
    {
        if (!strcmp(pPropertyToken->GetTagValue(PROPERTY_TYPE), "url"))
        {
            strcat(szTearoffMethod, "Url");
            strcpy(szPropArgs, (LPCSTR)pPropertyToken->GetTagValue(PROPERTY_ATYPE));
        }
        else if (!strcmp(pPropertyToken->GetTagValue(PROPERTY_TYPE), "CStyleComponent"))
        {
            strcat(szTearoffMethod, "StyleComponent");
            strcpy(szPropArgs, (LPCSTR)pPropertyToken->GetTagValue(PROPERTY_ATYPE));
        }
        else
            strcat(szTearoffMethod, (fPropGet ? "Property" : "String"));
    }
    else if (!strcmp(pPropertyToken->GetTagValue(PROPERTY_ATYPE), "VARIANT_BOOL"))
        strcat(szTearoffMethod, (fPropGet ? "Property" : "Bool"));
    else if (!strcmp(pPropertyToken->GetTagValue(PROPERTY_ATYPE), "long"))
        strcat(szTearoffMethod, fPropGet ? "Property" : "Long");
    else if (!strcmp(pPropertyToken->GetTagValue(PROPERTY_ATYPE), "short"))
        strcat(szTearoffMethod, fPropGet ? "Property" : "Short");
    else
    {
        char szError[124];
        sprintf(szError, "%s: This property of new type needs a function prototype (in cdbase.hxx) and a body defn. in (baseprop.cxx)",
                (LPCSTR)pPropertyToken->GetTagValue(PROPERTY_NAME));
        ReportError (szError);
        return FALSE;
    }

    return TRUE;
}

BOOL CPDLParser::GeneratePropDescsInVtblOrder(Token *pClassToken, int *pNumVtblPropDescs)
{
    CString szPrimaryInterf;
    CString szInterface;
    LPCSTR  szClassName = pClassToken->GetTagValue(CLASS_NAME);
    BOOL    fOk;
    BOOL    fNameOnly;
    int i = 0, j;

    szPrimaryInterf = pClassToken->GetTagValue(CLASS_INTERFACE);
    Token *pPrimaryInterf = FindInterface(szPrimaryInterf);
    Token *pInterface;
    Token *pChildToken;
    Token *apInterface[5];
    
    *pNumVtblPropDescs = 0;
    Token *pTearoff = NULL;

    while ((pTearoff = NextTearoff(szClassName, pTearoff)))
    {
        szInterface = pTearoff->GetTagValue(TEAROFF_INTERFACE);
        pInterface = FindInterface(szInterface);
        
        if (!pInterface || pInterface->IsSet(INTERFACE_ABSTRACT))
            continue;

        i = 0;
        apInterface[i++] = pInterface;
        while (i < 5 && apInterface[i-1]->IsSet(INTERFACE_SUPER) && 
               _stricmp(apInterface[i-1]->GetTagValue(INTERFACE_SUPER), "IDispatch") &&
               _stricmp(apInterface[i-1]->GetTagValue(INTERFACE_SUPER), "IUnknown"))
        {
            szInterface = apInterface[i-1]->GetTagValue(INTERFACE_SUPER);
            apInterface[i++] = FindInterface(szInterface);
        }

        if (i >= 5)
        {
            ReportError("Super Chain More than 5, Need to increase limit in PdlParser");
            return FALSE;
        }

        fOk = FALSE;

        CTokenListWalker    ChildList(pInterface);
        pChildToken = ChildList.GetNext();

        if (pChildToken)
        {
            do
            {
                if (pChildToken->GetType() == TYPE_PROPERTY && !pChildToken->IsSet(PROPERTY_ABSTRACT) && !pChildToken->IsSet(PROPERTY_BASEIMPLEMENTATION))
                {
                    fOk = TRUE;
                    break;
                }
            } while (pChildToken = ChildList.GetNext());

            if (fOk)
            {
                fprintf(fpHDLFile, "\nconst PROPERTYDESC * const %s::s_ppropdescsInVtblOrder%s[] = {\n", szClassName,
                        (LPSTR)pTearoff->GetTagValue(TEAROFF_INTERFACE));

                for (j = i-1; j >= 0; j--)
                {
                    pInterface = apInterface[j];
                    CTokenListWalker    ChildLst(pInterface);
                    pChildToken = ChildLst.GetNext();

                    do
                    {
                        char    szErrorText[MAX_LINE_LEN + 1];
                        Token  *pExposeToken = NULL;

                        if (pChildToken->GetType() == TYPE_METHOD)
                        {
                            if (pChildToken->IsSet(METHOD_NOPROPDESC))
                            {
                                fNameOnly = _stricmp(pChildToken->GetTagValue(METHOD_NOPROPDESC), "nameonly") == 0;

                                pExposeToken = FindMatchingEntryWOPropDesc(pClassToken, pChildToken, fNameOnly);
                                if (!pExposeToken)
                                {
                                    sprintf(szErrorText,
                                            "Function member marked as nopropdesc can not find exact signature match in new interface:%s in Class:%s\n",
                                            (LPCSTR)pChildToken->GetTagValue(METHOD_NAME),
                                            szClassName);
                                    ReportError(szErrorText);
                                    return FALSE;
                                }
                            }
                            else
                                pExposeToken = pChildToken;

                            fprintf(fpHDLFile, "    (PROPERTYDESC *)&s_methdesc%s%s,\n", pExposeToken->GetTagValue((int)METHOD_REFDTOCLASS), pExposeToken->GetTagValue(METHOD_NAME));
                            if (pPrimaryInterf == pInterface)
                                (*pNumVtblPropDescs)++;
                        }
                        else
                        {
                            if (pChildToken->IsSet(PROPERTY_SET) || pChildToken->IsSet(PROPERTY_GET))
                            {
                                BOOL    fDoAgain = TRUE;

    DoAgain:
                                if (pChildToken->IsSet(PROPERTY_NOPROPDESC))
                                {
                                    fNameOnly = _stricmp(pChildToken->GetTagValue(PROPERTY_NOPROPDESC), "nameonly") == 0;

                                    pExposeToken = FindMatchingEntryWOPropDesc(pClassToken, pChildToken, fNameOnly);
                                    if (!pExposeToken)
                                    {
                                        sprintf(szErrorText,
                                                "Function member marked as nopropdesc can not find exact signature match in new interface:%s in Class:%s\n",
                                                (LPCSTR)pChildToken->GetTagValue(PROPERTY_NAME),
                                                szClassName);
                                        ReportError(szErrorText);
                                        return FALSE;
                                    }
                                }
                                else
                                    pExposeToken = pChildToken;

                                pExposeToken = pExposeToken ? pExposeToken : pChildToken;

                                fprintf(fpHDLFile, "    (const PROPERTYDESC *)&s_propdesc%s%s,\n",
                                        pExposeToken->GetTagValue((int)PROPERTY_REFDTOCLASS),
                                        pExposeToken->GetTagValue(PROPERTY_NAME));
                                if (pPrimaryInterf == pInterface)
                                    (*pNumVtblPropDescs)++;

                                // If property is getter and setter both then generate another propdesc (but just once).
                                if (fDoAgain && pChildToken->IsSet(PROPERTY_SET) && pChildToken->IsSet(PROPERTY_GET))
                                {
                                    fDoAgain = FALSE;
                                    goto DoAgain;
                                }
                            }
                        }

                    } while (pChildToken = ChildLst.GetNext());
                }

                fprintf(fpHDLFile, "};\n\n");
            }
        }
    }

    return TRUE;
}

BOOL CPDLParser::GenerateTearOffMethods (LPCSTR szClassName, Token *pTearoff, LPCSTR szInterfaceName, BOOL fMostDerived)
{
    Token              *pInterfaceToken;
    Token              *pChildToken;
    char                szText[MAX_LINE_LEN+1];
    CTokenListWalker    WholeList(pRuntimeList);
#if 0
if (strcmp(_pszPDLFileName, "div.pdl") == 0 || strcmp(szInterfaceName, "IHTMLDivElement") == 0)
__asm { int 3 };
#endif

    // Find the interface decl
    do
    {
        pInterfaceToken = WholeList.GetNext(TYPE_INTERFACE, szInterfaceName);

        if (pInterfaceToken == NULL)
        {
            // if the deepest is IDispatch output that tearoff
            if (_stricmp(szInterfaceName, "IDispatch"))
            {
                // but IUnknowns are OK so return true
                if (_stricmp(szInterfaceName, "IUnknown"))
                {
                    // its something we don't recognise so output error msg
                    sprintf(szText, "interface:%s unknown\n", (LPCSTR)szInterfaceName);
                    ReportError(szText);
                    return FALSE;
                }
                else
                    return TRUE;
            }
            else
            {
                return GenerateIDispatchTearoff(szClassName, pTearoff, szInterfaceName, fMostDerived);
            }
       }
    } while (!pInterfaceToken->IsSet(INTERFACE_GUID));

    // If we only want most derived then we're done otherwise continue recursing.
    if (!fMostDerived)
    {
        // Generate the interfaces super tear off methods first
        if (pInterfaceToken->IsSet(INTERFACE_SUPER))
        {
            GenerateTearOffMethods(szClassName, pTearoff, pInterfaceToken->GetTagValue(INTERFACE_SUPER));
        }
    }
    else
    {
        // fMostDerived is only set for the primary interface, which we don't want stacked ontop of its
        // derivations. so all we want to do is dump in the dispatch and go on.
        GenerateIDispatchTearoff(szClassName, pTearoff, szInterfaceName, fMostDerived);
    }

       // generate the fn prototypes cast to generic fn pts in the
    // tearoff table
    CTokenListWalker    ChildList(pInterfaceToken);
    CString             szProp;
    Token              *pArgToken;

    fprintf ( fpHDLFile, "    //  %s methods\n", szInterfaceName);

    while (pChildToken = ChildList.GetNext())
    {
        char szTemp[256];
        char szTearOffClassName[256];
        char szContextThunk[] = "ContextThunk_";
        LPCSTR   pCtxt;

        if (pChildToken->GetType() == TYPE_METHOD)
        {
            CTokenListWalker    ArgListWalker(pChildToken);
            BOOL                fFirstArg = TRUE;
            char                szTearoffMethod[128];
            LPCSTR              pMethodName;

            pMethodName = pChildToken->IsSet(METHOD_SZINTERFACEEXPOSE) ?
                            (LPSTR)pChildToken->GetTagValue(METHOD_SZINTERFACEEXPOSE) :
                            (LPSTR)pChildToken->GetTagValue(METHOD_NAME);

            FindTearoffMethod(pTearoff,
                              pMethodName,
                              szTearoffMethod);

            strcpy(szTearOffClassName, szClassName);
            GenerateWin16TearoffName(szTemp, szTearoffMethod, szTearOffClassName);


            pCtxt = pChildToken->IsSet(METHOD_THUNKCONTEXT) ||
                    pChildToken->IsSet(METHOD_THUNKNODECONTEXT)
                      ? szContextThunk : "";


            // Method
            fprintf(fpHDLFile, "    TEAROFF_METHOD(%s, %s%s, %s, (", szTearOffClassName, pCtxt, szTearoffMethod, szTemp);

            // All automated methods MUST have an HRESULT for the return type.
            if (_stricmp("HRESULT", (LPCSTR)pChildToken->GetTagValue(METHOD_RETURNTYPE)))
            {
                ReportError("Automated method must have HRESULT for return value\n");
                return FALSE;
            }

            // Output each argument.
            while (pArgToken = ArgListWalker.GetNext())
            {
                if (!fFirstArg)
                    fprintf(fpHDLFile, ",");

                fprintf(fpHDLFile, "%s", ConvertType((LPCSTR)pArgToken->GetTagValue(METHODARG_TYPE)));

                fFirstArg = FALSE;
            }

            fprintf(fpHDLFile, "))\n");
        }
        else
        {
            char    szPropName[128];
            char    szTearoffMethod[128];
            char    szPropArgs[64];
            LPCSTR  pMethodName;

            // Property
            szProp = "";

            pMethodName = pChildToken->IsSet(PROPERTY_SZINTERFACEEXPOSE) ?
                            (LPSTR)pChildToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE) :
                            (LPSTR)pChildToken->GetTagValue(PROPERTY_NAME);

            // Through the index/indextype & index1/indextype1 pdl tags
            // you can provide up to two additional args for the property definition
            pChildToken->AddParam(szProp, PROPERTY_INDEX, pChildToken->GetTagValue(PROPERTY_INDEXTYPE));
            pChildToken->AddParam(szProp, PROPERTY_INDEX1, pChildToken->GetTagValue(PROPERTY_INDEXTYPE1));
            if (szProp[0] != '\0')
                szProp += ",";

            pCtxt = pChildToken->IsSet(PROPERTY_THUNKCONTEXT) ||
                    pChildToken->IsSet(PROPERTY_THUNKNODECONTEXT) 
                    ? szContextThunk : "";

            if ( pChildToken->IsSet(PROPERTY_SET))
            {
                strcpy(szPropName, "put_");
                strcat(szPropName, pMethodName);

                if (FindTearoffMethod(pTearoff, szPropName, szTearoffMethod))
                {
                    strcpy(szPropArgs, (LPCSTR)pChildToken->GetTagValue(PROPERTY_ATYPE));
                    strcpy(szTearOffClassName, szClassName);
                }
                else if (!FindTearoffProperty(pChildToken, szTearoffMethod, szTearOffClassName, szPropArgs, FALSE))
                {
                    FindTearoffMethod(pTearoff, szPropName, szTearoffMethod);
                    strcpy(szPropArgs, (LPCSTR)pChildToken->GetTagValue(PROPERTY_ATYPE));
                    strcpy(szTearOffClassName, szClassName);
                }

                GenerateWin16TearoffName(szTemp, szTearoffMethod, szTearOffClassName);

                fprintf(fpHDLFile, "    TEAROFF_METHOD(%s, %s%s, %s, (%s%s))    // property set_%s\n",
                        szTearOffClassName,
                        pCtxt,
                        szTearoffMethod,
                        szTemp,
                        (LPCSTR)szProp,
                        (LPCSTR)szPropArgs,
                        (LPCSTR)pChildToken->GetTagValue(PROPERTY_NAME));
            }
            if (pChildToken->IsSet(PROPERTY_GET))
            {
                strcpy(szPropName, "get_");
                strcat(szPropName, pMethodName);
                if (FindTearoffMethod(pTearoff, szPropName, szTearoffMethod))
                {
                    strcpy(szPropArgs, (LPCSTR)pChildToken->GetTagValue(PROPERTY_ATYPE));
                    strcpy(szTearOffClassName, szClassName);
                }
                else if (!FindTearoffProperty(pChildToken, szTearoffMethod, szTearOffClassName, szPropArgs, TRUE))
                {
                    FindTearoffMethod(pTearoff, szPropName, szTearoffMethod);
                    strcpy(szPropArgs, (LPCSTR)pChildToken->GetTagValue(PROPERTY_ATYPE));
                    strcpy(szTearOffClassName, szClassName);
                }

                GenerateWin16TearoffName(szTemp, szTearoffMethod, szTearOffClassName);
                fprintf(fpHDLFile, "    TEAROFF_METHOD(%s, %s%s, %s, (%s%s *))    // property get_%s\n",
                        szTearOffClassName,
                        pCtxt,
                        szTearoffMethod,
                        szTemp,
                        (LPCSTR)szProp,
                        (LPCSTR)szPropArgs,
                        (LPCSTR)pChildToken->GetTagValue(PROPERTY_NAME));
            }
        }
    }

    return TRUE;
}

void CPDLParser::GenerateMethodImp ( Token *pClassToken,
    Token *pChildToken, BOOL fIsSet, CString &szHandler,
    CString &szHandlerArgs, CString &szOffsetOf, CString &szAType )
{
#if COLLECT_STATISTICS==1
    // Collect statistics on total property code turds.
    CollectStatistic(NUM_PROPTURDS, GetStatistic(NUM_PROPTURDS) + 1);
#endif

    char *szHandlerMethodPrefix;
    char *szAutomationMethodPrefix;
    if ( fIsSet )
    {
        szHandlerMethodPrefix = "Set";
        szAutomationMethodPrefix = "put_";
    }
    else
    {
        szHandlerMethodPrefix = "Get";
        szAutomationMethodPrefix = "get_";
    }


    // Allow enums with an ATYPE of BSTR to be automated with the string handler
    if ( szHandler == "Enum" && szAType == "BSTR" )
    {
        szHandler = "EnumString";

#if COLLECT_STATISTICS==1
    // Collect statistics on number of enum code turds.
    CollectStatistic(NUM_EMUMTURDS, GetStatistic(NUM_EMUMTURDS) + 1);
#endif
    }

    fprintf ( fpHDLFile,
        "STDMETHODIMP %s::%s%s(%s%s)\n{\n",
        (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
        (LPCSTR)szAutomationMethodPrefix,
        (LPCSTR)pChildToken->GetTagValue ( PROPERTY_NAME ),
        (LPCSTR)szAType,
        fIsSet ? " v" : " * p" );


    if ( pChildToken -> IsSet ( PROPERTY_PRECALLFUNCTION ) )
    {
        CString szfn;
        szfn = pChildToken -> GetTagValue ( PROPERTY_PRECALLFUNCTION ) ;
        // Give the super a chance to reject the call
        fprintf ( fpHDLFile, "    HRESULT hr;\n" );
        if ( szfn == "super" )
        {
            fprintf ( fpHDLFile, "    hr = super::%s%s(%s);\n",
                szAutomationMethodPrefix,
                (LPCSTR)pChildToken->GetTagValue ( PROPERTY_PRECALLFUNCTION ),
                fIsSet ? "v" : "p" );
        }
        else
        {
            fprintf ( fpHDLFile, "    hr = %s%s(%s);\n",
                szAutomationMethodPrefix,
                (LPCSTR)szfn,
                fIsSet ? "v" : "p" );
        }
        fprintf ( fpHDLFile, "    if ( hr )\n        return hr;\n" );
    }

    if ( fIsSet && pChildToken -> IsSet ( PROPERTY_SETDESIGNMODE ) )
    {
        fprintf ( fpHDLFile, "    if ( !IsDesignMode() )\n        return SetErrorInfo(CTL_E_SETNOTSUPPORTEDATRUNTIME);\n" );
    }

    if ( szAType == "VARIANT" )
    {
        fprintf ( fpHDLFile, "    return SetErrorInfo(s_propdesc%s%s.a.Handle%sProperty(%s, %s, this, CVOID_CAST%s));\n}\n",
            (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
            (LPCSTR)pChildToken->GetTagValue ( PROPERTY_NAME ),
            (LPCSTR)szHandler,
            (LPCSTR)szHandlerArgs,
            fIsSet ? "&v" : "p",
            (LPCSTR)szOffsetOf );
    }
    else if ( pChildToken -> IsSet ( PROPERTY_SUBOBJECT ) )
    {
        fprintf ( fpHDLFile, "    return %s::CreateSubObject ( GetElementPtr(), (PROPERTYDESC *)&s_propdesc%s%s,\n        ",
            (LPCSTR)pChildToken->GetTagValue ( PROPERTY_SUBOBJECT ),
            (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
            (LPCSTR)pChildToken->GetTagValue ( PROPERTY_NAME ));
        if ( pChildToken -> IsSet ( PROPERTY_PARAM1 ) )
        {
            fprintf ( fpHDLFile, "%s, ",
                (LPCSTR)pChildToken->GetTagValue ( PROPERTY_PARAM1 ) );
        }

        fprintf ( fpHDLFile, "p );\n}\n" );
    }
    else
    {
        if ( szHandler == "Num" || szHandler == "Enum" )
        {
            fprintf ( fpHDLFile,"    return s_propdesc%s%s.b.%sNumberProperty(%s, this, CVOID_CAST%s);\n}\n",
                (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                (LPCSTR)pChildToken->GetTagValue ( PROPERTY_NAME ),
                (LPCSTR)szHandlerMethodPrefix,
                fIsSet ? "v" : "p",
                (LPCSTR)szOffsetOf );
        }
        else
        {
            fprintf ( fpHDLFile, "    return s_propdesc%s%s.b.%s%sProperty(%s, this, CVOID_CAST%s);\n}\n",
                (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                (LPCSTR)pChildToken->GetTagValue ( PROPERTY_NAME ),
                (LPCSTR)szHandlerMethodPrefix,
                (LPCSTR)szHandler,
                fIsSet ? "v" : "p",
                (LPCSTR)szOffsetOf );
        }
    }
}


void CPDLParser::GenerateCPPEnumDefs ( void )
{
    Token *pToken;
    char *pEValText;

    // Only generate def's for this file
    CTokenListWalker TokenList ( pRuntimeList, _pszPDLFileName );

    fprintf ( fpHDLFile, "\n#ifndef _PROPDESCS_EXTERNAL\n\n" );

    // Generate propdescs for every property token in every class ( in this file )
    while ( pToken = TokenList.GetNext( TYPE_ENUM ) )
    {
        fprintf ( fpHDLFile, "EXTERN_C const ENUMDESC s_enumdesc%s = \n{ %u, %u, {\n",
            pToken->GetTagValue ( ENUM_NAME ) ,
            pToken->GetChildTokenCount(),
            pToken->uEnumMask );

        CTokenListWalker ChildList ( pToken );

        while ( pToken = ChildList.GetNext() )
        {
            // If a string is specified use it
            if ( pToken->IsSet ( EVAL_STRING ) )
            {
                pEValText = pToken->GetTagValue ( EVAL_STRING );
            }
            else
            {
                pEValText = pToken->GetTagValue ( EVAL_NAME );
            }
            fprintf ( fpHDLFile, "    { _T(\"%s\"),%s},\n",
                pEValText,
                pToken->GetTagValue ( EVAL_VALUE ) );
        }
        fprintf ( fpHDLFile, "} };\n\n" );
    }

    fprintf ( fpHDLFile, "#endif     // _PROPDESCS_EXTERNAL\n" );
}

void CPDLParser::GenerateInterfaceDISPIDs ( void )
{
    Token *pInterfaceToken;
    Token *pChildToken;
    CString szName;

    // Generate DISPID's for all interface methods that are not
    // ref'd to a class
    // Only generate def's for this file
    CTokenListWalker TokenList ( pRuntimeList, _pszPDLFileName );
    while ( pInterfaceToken = TokenList.GetNext( TYPE_INTERFACE ) )
    {
        szName = pInterfaceToken->GetTagValue ( INTERFACE_NAME );
        if ( szName == "IDispatch" )
            continue;
        fprintf ( fpHDLFile, "//    DISPIDs for class%s\n\n",
            (LPCSTR)pInterfaceToken->GetTagValue ( INTERFACE_NAME ) );
        CTokenListWalker ChildList ( pInterfaceToken );
        while ( pChildToken = ChildList.GetNext() )
        {
            if ( pChildToken -> GetType() == TYPE_METHOD &&
                !strlen( pChildToken -> GetTagValue ( METHOD_REFDTOCLASS ) ) &&
                pChildToken -> IsSet ( METHOD_DISPID ) )
            {
                Token   *pChildMatch = NULL;
                CString  szClassName;
                Token   *pClass;

                szClassName = pInterfaceToken -> GetTagValue( METHOD_REFDTOCLASS );
                pClass = FindClass ( szClassName );

                if (pClass)
                {
                    if (pChildToken->IsSet(METHOD_NOPROPDESC))
                    {
                        pChildMatch = FindMatchingEntryWOPropDesc(pClass, pChildToken);
                    }
                }

                if (!pChildMatch)
                    pChildMatch = pChildToken;

                fprintf ( fpHDLFile, "#define DISPID_%s_%s     %s\n",
                    (LPCSTR)pInterfaceToken->GetTagValue ( INTERFACE_NAME ),
                    (LPCSTR)pChildMatch->GetTagValue ( METHOD_NAME ),
                    (LPCSTR)pChildMatch->GetTagValue ( METHOD_DISPID ) );
            }
        }
    }

}

void CPDLParser::GenerateEventDISPIDs ( FILE *fp, BOOL fPutDIID )
{
    Token *pEventToken;
    Token *pChildToken;
    CString szName,szDISPName;
    int i,nLength;
    BOOL fPutComment;

    // Generate DISPID's for all interface methods that are not
    // ref'd to a class
    // Only generate def's for this file
    CTokenListWalker TokenList ( pRuntimeList, _pszPDLFileName );
    while ( pEventToken = TokenList.GetNext( TYPE_EVENT ) )
    {
        szName = pEventToken->GetTagValue ( EVENT_NAME );
        if ( szName == "IDispatch" || szName == "IUnknown" )
            continue;
        szName.ToUpper();

        fPutComment = FALSE;

        CTokenListWalker ChildList ( pEventToken );
        while ( pChildToken = ChildList.GetNext() )
        {
            if ( pChildToken -> GetType() == TYPE_METHOD &&
                !strlen( pChildToken -> GetTagValue ( METHOD_REFDTOCLASS ) ) &&
                pChildToken -> IsSet ( METHOD_DISPID ) )
            {
                if ( !fPutComment )
                {
                    fprintf ( fp, "//    DISPIDs for event set %s\n\n",
                        (LPCSTR)pEventToken->GetTagValue ( EVENT_NAME ) );
                    fPutComment = TRUE;
                }
                szDISPName = pChildToken->GetTagValue ( METHOD_NAME );
                szDISPName.ToUpper();
                fprintf ( fp, "#define DISPID_%s_%s ",
                    (LPCSTR)szName,
                    (LPCSTR)szDISPName );

                for ( i = 0, nLength = max ( 0, 49-szDISPName.Length()-szName.Length() ); i < nLength ; i++ )
                {
                    fprintf ( fp, " " );
                }

                fprintf ( fp, "%s\n",
                    (LPCSTR)pChildToken->GetTagValue ( METHOD_DISPID ) );
            }
        }
        if ( fPutDIID )
        {
            fprintf ( fp, "\nEXTERN_C const GUID DIID_%s;\n",
                pEventToken->GetTagValue ( EVENT_NAME ));
        }
        if ( fPutComment )
           fprintf ( fp, "\n" );
    }
}

void CPDLParser::GenerateExternalInterfaceDISPIDs ( void )
{
    Token *pInterfaceToken;
    Token *pChildToken;
    CString szName,szDISPName;
    int i,nLength;
    BOOL fPutComment;

    // Generate DISPID's for all interface methods that are not
    // ref'd to a class
    // Only generate def's for this file
    CTokenListWalker TokenList ( pRuntimeList, _pszPDLFileName );
    while ( pInterfaceToken = TokenList.GetNext( TYPE_INTERFACE ) )
    {
        szName = pInterfaceToken->GetTagValue ( INTERFACE_NAME );
        if ( szName == "IDispatch" || szName == "IUnknown" )
            continue;
        szName.ToUpper();

        fPutComment = FALSE;

        CTokenListWalker ChildList ( pInterfaceToken );
        while ( pChildToken = ChildList.GetNext() )
        {
            Token      *pChildMatch = NULL;
            CString     szClassName;
            Token      *pClass;

            if ( !fPutComment )
            {
                fprintf ( fpDISPIDFile, "//    DISPIDs for interface %s\n\n",
                    (LPCSTR)pInterfaceToken->GetTagValue ( INTERFACE_NAME ) );
                fPutComment = TRUE;
            }
            if ( pChildToken -> GetType() == TYPE_METHOD )
            {
                szDISPName = pChildToken->GetTagValue ( METHOD_NAME );

                szClassName = pChildToken -> GetTagValue( METHOD_REFDTOCLASS );
                pClass = FindClass ( szClassName );
                if (pClass)
                {
                    if (pChildToken->IsSet(METHOD_NOPROPDESC))
                    {
                        if (pChildToken->IsSet(METHOD_SZINTERFACEEXPOSE))
                            szDISPName = pChildToken->GetTagValue(METHOD_SZINTERFACEEXPOSE);

                        pChildMatch = FindMatchingEntryWOPropDesc(pClass, pChildToken);
                    }
                }

                if (!pChildMatch)
                    pChildMatch = pChildToken;
            }
            else
            {
                // Property

                szDISPName = pChildToken->GetTagValue ( PROPERTY_NAME );

                szClassName = pChildToken -> GetTagValue( PROPERTY_REFDTOCLASS );
                pClass = FindClass ( szClassName );
                if (pClass)
                {
                    if (pChildToken->IsSet(PROPERTY_NOPROPDESC))
                    {
                        if (pChildToken->IsSet(PROPERTY_SZINTERFACEEXPOSE))
                            szDISPName = pChildToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE);

                        pChildMatch = FindMatchingEntryWOPropDesc(pClass, pChildToken);
                    }
                }

                if (!pChildMatch)
                    pChildMatch = pChildToken;
            }
            szDISPName.ToUpper();
            
            fprintf ( fpDISPIDFile, "#define DISPID_%s_%s ",
                (LPCSTR)szName,
                (LPCSTR)szDISPName );

            for ( i = 0, nLength = max ( 0, 49-szDISPName.Length()-szName.Length() ); i < nLength ; i++ )
            {
                fprintf ( fpDISPIDFile, " " );
            }

            fprintf ( fpDISPIDFile, "%s\n",
                (LPCSTR)pChildMatch->GetTagValue ( PROPERTY_DISPID ) );
        }
        if ( fPutComment )
            fprintf ( fpDISPIDFile, "\n" );
    }
}



void CPDLParser::GenerateClassDISPIDs ( void )
{
    Token *pClassToken;
    Token *pChildToken;
    CString szCoClassName;

    // Only generate def's for this file
    CTokenListWalker TokenList ( pRuntimeList, _pszPDLFileName );

    // Generate propdescs for every property token in every class ( in this file )
    while ( pClassToken = TokenList.GetNext( TYPE_CLASS ) )
    {
        fprintf ( fpHDLFile, "//    DISPIDs for class %s\n\n", (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ) );

        if ( pClassToken -> IsSet ( CLASS_GUID ) )
        {
            pClassToken -> GetTagValueOrDefault ( szCoClassName,
                CLASS_COCLASSNAME, pClassToken -> GetTagValue ( CLASS_NAME ) );
            fprintf ( fpHDLFile, "EXTERN_C const GUID CLSID_%s;\n",
                (LPCSTR)szCoClassName );
        }
        CTokenListWalker ChildList ( pClassToken );
        while ( pChildToken = ChildList.GetNext() )
        {
            Token *pChildMatch = pChildToken;

            if ( pChildMatch->nType == TYPE_PROPERTY && pChildMatch->IsSet ( PROPERTY_DISPID ) )
            {
                if (pChildMatch->IsSet(PROPERTY_NOPROPDESC))
                {
                    pChildMatch = FindMatchingEntryWOPropDesc(pClassToken, pChildMatch);
                    if (!pChildMatch)
                        pChildMatch = pChildToken;
                }

                fprintf ( fpHDLFile, "#define DISPID_%s_%s     %s\n",
                    (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                    (LPCSTR)pChildMatch->GetTagValue ( PROPERTY_NAME ),
                    (LPCSTR)pChildMatch->GetTagValue ( PROPERTY_DISPID ) );

            }
            else if ( pChildMatch->nType == TYPE_METHOD && pChildMatch->IsSet ( METHOD_DISPID ) )
            {
                if (pChildMatch->IsSet(METHOD_NOPROPDESC))
                {
                    pChildMatch = FindMatchingEntryWOPropDesc(pClassToken, pChildMatch);
                    if (!pChildMatch)
                        pChildMatch = pChildToken;
                }

                fprintf ( fpHDLFile, "#define DISPID_%s_%s     %s\n",
                    (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                    (LPCSTR)pChildMatch->GetTagValue ( METHOD_NAME ),
                    (LPCSTR)pChildMatch->GetTagValue ( METHOD_DISPID ) );
            }
        }
    }
}

void CPDLParser::GeneratePropdescExtern ( Token *pClassToken, BOOL fRecurse )
{
    Token *pChild;
    Token *pSuperClassToken;
    CTokenListWalker ChildList ( pClassToken );

    // Add the supers definitions first.  Recurse to the super of this super!!
    // Notice that the fRecurse if used by abstract classes to only extern the
    // PropertyDesc which are generated for the actual class.
    pSuperClassToken = fRecurse ? GetSuperClassTokenPtr ( pClassToken ) : NULL;
    if ( pSuperClassToken )
        GeneratePropdescExtern ( pSuperClassToken );

    // Don't generate any EXTERN_C for abstract class reference.  The EXTERN_C
    // is only in the hdl that contains both the PROPERTYDESC the EXTERN_C for
    // the abstract class (e.g., bodyroot.hdl).
    if ( fRecurse && pClassToken -> IsSet ( CLASS_ABSTRACT ) )
        return;

    fprintf ( fpHeaderFile, "\n#ifndef _%s_PROPDESCS_\n", pClassToken -> GetTagValue ( CLASS_NAME ) );
    // Walk the super class propdescs looking for properties

    while ( pChild = ChildList.GetNext() )
    {
        if ( pChild->GetType() == TYPE_PROPERTY )
        {
            StorageType stHowStored;
            CString szHandler;
            CString szFnPrefix;


            szHandler = "";
            szFnPrefix = "";
            // Check for missing handler later
            GetTypeDetails ( pChild->GetTagValue ( PROPERTY_TYPE ),
                szHandler, szFnPrefix, &stHowStored );

            if ( !ComputePROPDESC_STRUCT ( fpHeaderFile, pClassToken, pChild, szHandler, szFnPrefix ) )
                return;       // Bad error reported...leave

            fprintf ( fpHeaderFile, " s_propdesc%s%s;\n",
                pClassToken -> GetTagValue ( CLASS_NAME ),
                pChild -> GetTagValue ( PROPERTY_NAME ) );
        }
        else if ( pChild->GetType() == TYPE_METHOD )
        {
            fprintf ( fpHeaderFile, "EXTERN_C const PROPERTYDESC_METHOD s_methdesc%s%s;\n",
                pClassToken -> GetTagValue ( CLASS_NAME ),
                pChild -> GetTagValue ( METHOD_NAME ) );
        }
    }

    fprintf ( fpHeaderFile, "\n#endif\n" );
}

BOOL CPDLParser::GeneratePropdescReference ( Token *pClassToken, 
                                            BOOL fDerivedClass, 
                                            PropdescInfo *pPI, 
                                            int *pnPI, 
                                            BOOL &bHookToCElement,
                                            int *pnSharedEntries )
{
    Token          *pChild;

    if (!pClassToken)
        return TRUE;

    CTokenListWalker ChildList ( pClassToken );

    // If the class superclass if CElement, we want to hook to CElement's hash table
    // If this is not the case, we want to do what we used to do and repeat
    // the super class properties in the subclasses.
    if(GetSuperClassTokenPtr ( pClassToken ) && 
       (strcmp(GetSuperClassTokenPtr ( pClassToken ) ->GetTagValue ( CLASS_NAME ),
               "CElement") == 0))
    {
        bHookToCElement = TRUE;
    }

    if ( !GeneratePropdescReference ( GetSuperClassTokenPtr ( pClassToken ), 
                                       FALSE, pPI, pnPI, 
                                       bHookToCElement, pnSharedEntries ) )
    {
        return FALSE;
    }
        
    if (fDerivedClass)
    {
        ChildList.Reset();
    }

    // Walk the super class propdescs looking for properties
    while ( pChild = ChildList.GetNext() )
    {
        if ( pChild->GetType() == TYPE_PROPERTY )
        {
            if ( !pChild->IsSet ( PROPERTY_INTERNAL ) && !pChild->IsSet ( PROPERTY_ABSTRACT ) &&
                     !pChild->IsSet( PROPERTY_NOPROPDESC ) &&
                    (!pChild->IsSet ( PROPERTY_NOPERSIST ) || 
                        ( pChild->IsSet ( PROPERTY_NOPERSIST ) && pClassToken->IsSet( CLASS_KEEPNOPERSIST ) ) ) )
            {
                if(bHookToCElement && (strcmp(pClassToken -> GetTagValue ( CLASS_NAME ), "CElement") == 0))
                {
                    *pnSharedEntries += 1;
                }
                else
                {
                    pPI[*pnPI].Set(pClassToken -> GetTagValue ( CLASS_NAME ),            
                                   pChild -> GetTagValue ( PROPERTY_NAME )  ,
                                   fDerivedClass,
                                   pChild->GetTagValue ( PROPERTY_SZATTRIBUTE ),
                                   PDLPARSE_BELONGSTOPARSE);
                    *pnPI += 1;
                }
            }
        }
    }

    return TRUE;
}

BOOL CPDLParser::GenerateCPC ( Token *pThisClassToken)
{
    if ( IsUniqueCPC ( pThisClassToken ) )
    {
        fprintf ( fpHDLFile, "\nconst CONNECTION_POINT_INFO %s::s_acpi[] = {\n",
           pThisClassToken -> GetTagValue ( CLASS_NAME ) );

        fprintf ( fpHDLFile, "    CPI_ENTRY(IID_IPropertyNotifySink, DISPID_A_PROPNOTIFYSINK)\n" );
        fprintf ( fpHDLFile, "    CPI_ENTRY(DIID_%s, DISPID_A_EVENTSINK)\n",
            pThisClassToken->GetTagValue( CLASS_EVENTS ) );
        if (pThisClassToken->IsSet(CLASS_NONPRIMARYEVENTS1))
        {
            fprintf(fpHDLFile, "    CPI_ENTRY(DIID_%s, DISPID_A_EVENTSINK)\n",
                    pThisClassToken->GetTagValue(CLASS_NONPRIMARYEVENTS1));
        }
        if (pThisClassToken->IsSet(CLASS_NONPRIMARYEVENTS2))
        {
            fprintf(fpHDLFile, "    CPI_ENTRY(DIID_%s, DISPID_A_EVENTSINK)\n",
                    pThisClassToken->GetTagValue(CLASS_NONPRIMARYEVENTS2));
        }
        if (pThisClassToken->IsSet(CLASS_NONPRIMARYEVENTS3))
        {
            fprintf(fpHDLFile, "    CPI_ENTRY(DIID_%s, DISPID_A_EVENTSINK)\n",
                    pThisClassToken->GetTagValue(CLASS_NONPRIMARYEVENTS3));
        }
        if (pThisClassToken->IsSet(CLASS_NONPRIMARYEVENTS4))
        {
            fprintf(fpHDLFile, "    CPI_ENTRY(DIID_%s, DISPID_A_EVENTSINK)\n",
                    pThisClassToken->GetTagValue(CLASS_NONPRIMARYEVENTS4));
        }
        fprintf ( fpHDLFile, "    CPI_ENTRY(IID_ITridentEventSink, DISPID_A_EVENTSINK)\n" );
        fprintf ( fpHDLFile, "    CPI_ENTRY(IID_IDispatch, DISPID_A_EVENTSINK)\n" );
        fprintf ( fpHDLFile, "    CPI_ENTRY_NULL\n};\n" );
    }

    return TRUE;
}


#ifdef COMPLUS_SHIM

void
CPDLParser::GenComPlusInheritance (Token *pClass, CString & inheritanceCStr)
{
    // Any other interface to expose in the coclass which is part of the primary
    // interface?
    CString				primaryInterfCStr;
    CTokenListWalker    ChildWalker(pClass);
    Token              *pChildToken;
    BOOL				fFirstInterf;

    // Get the primary interface, if one exists.
    if (pClass->IsSet(CLASS_INTERFACE))
    {
        primaryInterfCStr = pClass->GetTagValue(CLASS_INTERFACE);
        inheritanceCStr = "public ICOMCookie, public ";
        inheritanceCStr += primaryInterfCStr;
        inheritanceCStr += "COMPLUS";
        fFirstInterf = FALSE;
    }
    else
    {
        inheritanceCStr = "";
        fFirstInterf = TRUE;
    }

    while (pChildToken = ChildWalker.GetNext())
    {
        if (pChildToken->GetType() == TYPE_IMPLEMENTS)
        {
            Token      *pInterf;
            CString     szInterface;

            szInterface = pChildToken->GetTagValue(IMPLEMENTS_NAME);
            pInterf = FindInterface(szInterface);
            if (pInterf)
            {
                // Is the interface a local one if not then don't check, we
                // only need to check where interfaces are actually used.
                if (FindInterfaceLocally(szInterface))
                {
                    // If the super isn't specified and it's not a primary interface
                    // then error the super is required for non-primary interfaces.
                    if (_stricmp((LPSTR)pClass->GetTagValue(CLASS_INTERFACE),
                                 (LPSTR)pInterf->GetTagValue(INTERFACE_NAME)) &&
                        !pInterf->IsSet(INTERFACE_SUPER) &&
                        !IsPrimaryInterface(szInterface))
                    {
                        char szErrorText [ MAX_LINE_LEN+1 ];

                        sprintf(szErrorText, "Interface %s missing super key.\n",
                                (LPSTR)pInterf->GetTagValue(INTERFACE_NAME));
                        ReportError(szErrorText);

                        return;
                    }
                }

                // If an implements is a primary interface then don't inherit again we did that at the beginning.
                if (primaryInterfCStr != szInterface)
                {
                    if (fFirstInterf)
                    {
                        fFirstInterf = FALSE;
                    }
                    else
                    {
                        inheritanceCStr += ",";
                    }

                    inheritanceCStr += " public ";
                    inheritanceCStr += pInterf->GetTagValue(INTERFACE_NAME);
                    inheritanceCStr += "COMPLUS";
                }
            }
        }
    }
}
#endif    // COMPLUS_SHIM

void
CPDLParser::GenerateVTableArray (Token *pThisClassToken, BOOL *pbHashTableExists )
{
    Token          *pDerivedClass;
    PropdescInfo    rgPI[400];          // Max. number of method/prop for interface.
    int             nPI = 0;
    UINT            uVTblIndex = 0;
    CString         szInterf;
    Token          *pInterf;
    BOOL            bHookToCElement = FALSE;
    int             nSharedEntries = 0;

    *pbHashTableExists = FALSE;

    // Abstract classes don't need the vtable unless they name is CElement
    // TODO: Terry, Implement the shared keywork here.
    if ( (pThisClassToken->IsSet ( CLASS_ABSTRACT )) && 
         (_stricmp(pThisClassToken->GetTagValue(CLASS_NAME), "CElement") != 0))
        return;

    pDerivedClass = pThisClassToken;

GetInterf:
    szInterf = pDerivedClass->GetTagValue(CLASS_INTERFACE);
    // If no interface then use the super to find an interface.
    if (!szInterf.Length())
    {
        CString     szClass;

        szClass = pDerivedClass -> GetTagValue ( CLASS_SUPER );
        pDerivedClass = FindClass(szClass);
        if (!pDerivedClass)
            ReportError ( "Unknown class\n" );

        goto GetInterf;
    }

    pInterf = FindInterface(szInterf);
    if (pInterf || strcmp((LPCSTR)szInterf, "IDispatch") == 0)
    {
#ifdef COMPLUS_SHIM

        // ***TLL*** COM+: Not spitting COM+ proxies for internal.pdl and mshtmext.pdl need to do, shouldn't special case.
        BOOL fInternalPDL = (_stricmp(_pszPDLFileName, "internal.pdl") == 0) || (_stricmp(_pszPDLFileName, "mshtmext.pdl") == 0);

        // Do we have a real coclass w/ a real GUID?
        if (pThisClassToken->IsSet(CLASS_GUID) &&
            pThisClassToken->IsSet(CLASS_INTERFACE) && !fInternalPDL)
        {
            // Then let's do some COM+ work...
            CString		inheritDecl;
            CString		szClassName;

            if (pThisClassToken->IsSet(CLASS_COCLASSNAME))
                szClassName = pThisClassToken->GetTagValue(CLASS_COCLASSNAME);
            else
                szClassName = pThisClassToken->GetTagValue(CLASS_NAME);

			// Window needs some special processing as this is how unmanaged code hooks to
			// managed code.
			if (szClassName == "HTMLWindow2")
			{
				fprintf(fpHComPlusFile, "[managed, com, uuid={FF6BF9BB-FF1B-348D-8C21-CE642A866E7F}] __interface ICOMPLUSHookWindow\n");
				fprintf(fpHComPlusFile, "{\n");
				fprintf(fpHComPlusFile, "public:\n");
	            fprintf(fpHComPlusFile, "\tvoid Init(unsigned int myThis);\n");
				fprintf(fpHComPlusFile, "};\n\n");
			}

            // COM+ managed code:
            fprintf(fpHComPlusFile, "[managed, coclass");
			if (szClassName == "HTMLWindow2")
			{
				fprintf(fpHComPlusFile, " , uuid={D66BF9BF-FF1B-348D-8C21-CE642A866E7F}");
			}
            fprintf(fpHComPlusFile, "] class %sCOMPLUS", (LPCSTR)szClassName);

            GenComPlusInheritance(pThisClassToken, inheritDecl);
            if (inheritDecl.Length())
            {
                fprintf(fpHComPlusFile, " : %s", (LPCSTR)inheritDecl);
				if (szClassName == "HTMLWindow2")
				{
					fprintf(fpHComPlusFile, ", private ICOMPLUSHookWindow");
				}

				fprintf(fpHComPlusFile, "\n{\n");
            }
            else
            {
                fprintf(fpHComPlusFile, "\n{\n");
            }			

            fprintf(fpHComPlusFile, "private:\n");
            fprintf(fpHComPlusFile, "\tunsigned int\t_myThis;\n\n");

            fprintf(fpHComPlusFile, "public:\n");
            fprintf(fpHComPlusFile, "\t%sCOMPLUS (unsigned int myThis)\n\t\t{ _myThis = myThis; }\n\n", (LPCSTR)szClassName);
            fprintf(fpHComPlusFile, "\tunsigned int getCOMCookie()\n\t\t{ return _myThis; }\n\n");

			if (szClassName == "HTMLWindow2")
			{
				fprintf(fpHComPlusFile, "\tHTMLWindow2COMPLUS ()\n");
				fprintf(fpHComPlusFile, "\t\t{ _myThis = 0; }\n\n");
				fprintf(fpHComPlusFile, "\tvoid Init(unsigned int myThis)\n\t\t{ _myThis = myThis; }\n\n");
			}
		}

#endif   // COMPLUS_SHIM
        CVTableHash VTableHash; // Special hashtable that aids in spitting out the hash table

        // Add the parser properties to the PropdescInfo array
        if(!GeneratePropdescReference(pThisClassToken, TRUE, rgPI, &nPI, bHookToCElement, &nSharedEntries ))
            ReportError("Error Storing PropDescs in PROPDESC array in HashTable");

        // Add the OM properties and methods to the PropdescInfo array
        if (pInterf)
        {
            ComputeVTable( pThisClassToken, 
                           pInterf, 
                           FALSE, 
                           rgPI, 
                           &nPI, 
                           &uVTblIndex,
                           &VTableHash,
                           bHookToCElement);

        }


#ifdef COMPLUS_SHIM
        if (pThisClassToken->IsSet(CLASS_GUID) &&
            pThisClassToken->IsSet(CLASS_INTERFACE) && !fInternalPDL)
        {
            fprintf(fpHComPlusFile, "};\n\n\n");
        }
#endif   // COMPLUS_SHIM
            
        // Number of entries in vtable array.
        *pbHashTableExists = bHookToCElement || (nPI > 0);

        // Write out the "style" mini-propdesc array if we are dealing with
        // the element class.  The reason we do this is because a parser and OM
        // propdesc (both of which are different) resolve to the same entry in 
        // the hash table.  Hence, we have to make a hack and have the name resolve 
        // to an array of propdescs.
        if(strcmp(pThisClassToken->GetTagValue(CLASS_NAME), "CElement") == 0)
        {
            fprintf(fpHDLFile, "static const PROPERTYDESC *s_propdescCElementStyleArray [ ] = \n"
                              "{\n"
                              "    (PROPERTYDESC *)&s_propdescCElementstyle,\n"
                              "    (PROPERTYDESC *)&s_propdescCElementstyle_Str\n"
                              "};\n");
        } 
        else if(strcmp(pThisClassToken->GetTagValue(CLASS_NAME), "CInput") == 0)
        {
            fprintf(fpHDLFile, "static const PROPERTYDESC *s_propdescCInputCheckedArray [ ] = \n"
                              "{\n"
                              "    (PROPERTYDESC *)&s_propdescCInputchecked,\n"
                              "    (PROPERTYDESC *)&s_propdescCInputdefaultChecked\n"
                              "};\n");
        }

        // Write out the hash table
        // Convert the class to a Unicode string so that it works correctly
        // with the hash table, which is Unicode.
        WCHAR strUnicode[256];
        int retVal = 
            MultiByteToWideChar(CP_ACP, 0, pThisClassToken->GetTagValue(CLASS_NAME),
                                256,
                                strUnicode, 256);
        if(retVal == 0)
        {
            ReportError("Error: Unable to convert classname to a Unicode string");
            return;
        }

        if(VTableHash.GetHashTableLength() > 1024)
        {
            ReportError("Error: Hash table size has grown beyond 10K. Find more bits!");
            return;
        }
        if(VTableHash.ToFile(fpHDLFile, 
                             strUnicode,
                             nSharedEntries) != S_OK)
        {
            ReportError("Error: Unable to write out hashtable");
            return;
        }

        // Write out the Hash Table Aggregate
        fprintf(fpHDLFile, 
                "const CPtrBagVTableAggregate %s::s_StringTableAggregate = {\n"
                "    {\n", pThisClassToken->GetTagValue(CLASS_NAME));
        if(bHookToCElement)
            fprintf(fpHDLFile, "        (CPtrBagVTable *)&CElement::s_StringTable,\n");

        // Every class aggregates to itself.
        fprintf(fpHDLFile, 
                "        (CPtrBagVTable *)&%s::s_StringTable,\n"
                "        NULL\n"
                "    }\n"
                "};\n", pThisClassToken->GetTagValue(CLASS_NAME));

        // Store away a special cache for the document
        if(_stricmp(pThisClassToken->GetTagValue(CLASS_NAME), "COmWindowProxy") == 0)
        {
            DWORD index;

            if(!VTableHash.GetIndex(_T("document"), &index))
            {
                ReportError("The document must exist in the COmWindowProxy");
                return;
            }

            fprintf(fpHDLFile, "const VTABLEDESC * const COmWindowProxy::s_COmWindowProxyDocument = &s_AssocVTableCOmWindowProxy%d._VTableDesc;\n", index);
        }
    }
    else
    {
        char szErrorText [ MAX_LINE_LEN+1 ];

        sprintf( szErrorText, "Unknown interface %s\n", (LPCSTR) szInterf );
        ReportError ( szErrorText );
    }
}


void
CPDLParser::SortPropDescInfo (PropdescInfo *pPI, int cPDI)
{
    int             x, y, cc;        
    PropdescInfo    pd;

    //sort em
    for (x = 0; x < cPDI - 1; ++x)
    {
        for (y = x; y < cPDI; ++y)
        {
            cc = _stricmp( pPI[x]._szSortKey, pPI[y]._szSortKey );  // API caveat
            if (cc > 0)
            {
                memcpy(&pd, pPI + x, sizeof(pd));
                memcpy(pPI + x, pPI + y, sizeof(pd));
                memcpy(pPI + y, &pd, sizeof(pd));
            }
        }
    }
}
BOOL
CPDLParser::ComputeVTable ( Token *pClass, 
                            Token *pInterface, 
                            BOOL fDerived, 
                            PropdescInfo *pPI, 
                            int *piPI, 
                            UINT *pUVTblIdx, 
                            CVTableHash *pVTableHash,
                            BOOL &bHookToCElement,
                            BOOL fNonPrimaryTearoff/*= FALSE*/ )
{
    CString         szSuperInterf;
    Token          *pChildToken;
    int             cFuncs = 0;
    BOOL            fProperty = FALSE;
    int             idxIIDPrimaryTearoff = -1;
    int				idxIID;
    CString			szInterface;
    // Compute if this interface on the class is a primary interface tearoff.
    if (!fNonPrimaryTearoff)
    {
        Token      *pTearoff;

        pTearoff = FindTearoff(pClass->GetTagValue(CLASS_NAME), pInterface->GetTagValue(INTERFACE_NAME));

        if (pTearoff)
        {
            CString     szInterface;
            Token      *pInterfaceToken;

            szInterface = pTearoff->GetTagValue(TEAROFF_INTERFACE);
            pInterfaceToken = FindInterface(szInterface);

            // If primary interface is not derived from IDispatch then this
            // interface and all derived interfaces (vtable layout) are separated
            // not concatenated.
            LPSTR szSuperPrimaryInterf = pInterfaceToken->GetTagValue(INTERFACE_SUPER);

            if (szSuperPrimaryInterf && *szSuperPrimaryInterf)
                fNonPrimaryTearoff = ((_stricmp(szSuperPrimaryInterf, "IDispatch") ||
                                      (_stricmp(pClass->GetTagValue(CLASS_NAME), "CElement") == 0)));
            else
            {
                fNonPrimaryTearoff = FALSE;
            }
        }
    }

    szInterface = pInterface->GetTagValue(INTERFACE_NAME);
    // We want classes which have their primary interface IHTMLElement
    // and are derived from CElement to hook to CElement
    if((szInterface == "IHTMLElement") &&
       (_stricmp(pClass->GetTagValue(CLASS_NAME), "CElement") != 0))
    {
        bHookToCElement = TRUE;
    }
    else
    {
        idxIID = FindAndAddIIDs(szInterface);
        if (idxIID == -1)
        {
            ReportError("Problem with IID adding.\n");
            return FALSE;
        }

        if (fNonPrimaryTearoff)
            idxIIDPrimaryTearoff = idxIID;

        szSuperInterf = pInterface->GetTagValue(INTERFACE_SUPER);
        if (szSuperInterf && *szSuperInterf && szSuperInterf != "IDispatch")
        {
            Token  *pSuperInterf;

            pSuperInterf = FindInterface(szSuperInterf);
            if (!pSuperInterf)
                return FALSE;

            if (!ComputeVTable(pClass, 
                               pSuperInterf, 
                               TRUE, 
                               pPI, 
                               piPI, 
                               pUVTblIdx, 
                               pVTableHash,
                               bHookToCElement,
                               fNonPrimaryTearoff))
                return FALSE;
        }

        CTokenListWalker ChildList ( pInterface );
        while ( pChildToken = ChildList.GetNext() )
        {
            UINT    uIIDnVTbl;

            cFuncs = 0;

            if ( pChildToken -> GetType() == TYPE_PROPERTY )
            {
                fProperty = TRUE;
                cFuncs = pChildToken -> IsSet ( PROPERTY_GET ) ? 1 : 0;
                cFuncs += (pChildToken -> IsSet ( PROPERTY_SET ) ? 1 : 0);
        
                if (pChildToken->IsSet(PROPERTY_NOPROPDESC))
                    goto AddInVTable;
            }
            else if ( pChildToken -> GetType() == TYPE_METHOD )
            {
                fProperty = FALSE;
                cFuncs = 1;

                if (pChildToken->IsSet(METHOD_NOPROPDESC))
                    goto AddInVTable;
            }
            else
            {
                ReportError ( "Unknown token type in ComputeVTable.\n" );
                return FALSE;
            }

            // Compute vtable offset.  If primary interface is a tearoff then set
            // the offset and the idx into the IID table.  Note, all indexes start
            // at 1 (zero is reserved to imply classdesc primary interface).
            uIIDnVTbl = fNonPrimaryTearoff ? (((idxIIDPrimaryTearoff + 1) << 8) | *pUVTblIdx) : *pUVTblIdx;

            pPI[*piPI].SetVTable(pChildToken -> GetTagValue ( fProperty ? (int)PROPERTY_REFDTOCLASS : (int)METHOD_REFDTOCLASS ),
                   pChildToken -> GetTagValue ( fProperty ? (int)PROPERTY_NAME : (int)METHOD_NAME ),
                   FALSE,			// Unused.
                   pChildToken -> GetTagValue ( PROPERTY_SZATTRIBUTE ),
                   uIIDnVTbl | PDLPARSE_BELONGSTOOM,		// Computed IID/VTable where iidIdx might be zero for the primary interface.
                   fProperty,
                   idxIID,			// Index of interface
                   pChildToken);

            (*piPI)++;

    AddInVTable:
            (*pUVTblIdx) += cFuncs;
        }
    }

    // Each derived interface of the primary tearoff is separated not a straight
    // derivation.
    if (fNonPrimaryTearoff && _stricmp(szInterface, "IHTMLDocument"))
        *pUVTblIdx = 0;

    // Top most interface?
    if ( !fDerived )
    {
        // Now check for any other interfaces mentioned in the as implements in
        // the class it is exposed in the coclass, that interface is a
        // separately supported interface.

        CTokenListWalker    ChildWalker(pClass);
        Token              *pChildToken;
        CString             szInterface;
        Token              *pInterfToken;

        while (pChildToken = ChildWalker.GetNext())
        {
            if (pChildToken->GetType() == TYPE_IMPLEMENTS)
            {
                *pUVTblIdx = 0;         // implements always starts at 0 vtable offset.

                szInterface = pChildToken->GetTagValue(IMPLEMENTS_NAME);
                if(_stricmp(pInterface->GetTagValue(INTERFACE_NAME), szInterface) == 0)
                    continue;
                // TODO: TerryLu - Need to add code here to recongize and handle
                // shares.  Currently, we hardcode the following interfaces
                // as once which are shared and implemented by CElement directly
        
                if (szInterface == "IHTMLElement6")
                {
                    ReportError ( "Need to Add IHTMLElement6 in parser.cxx(ComputeVTable())" );
                    return FALSE;
                }

                if  ( ((szInterface == "IHTMLElement") ||
                       (szInterface == "IHTMLElement2") ||
                       (szInterface == "IHTMLElement3") ||
                       (szInterface == "IHTMLElement4") ||
                       (szInterface == "IHTMLElement5") ) && 
                    ((_stricmp(pClass->GetTagValue(CLASS_NAME), "CElement") != 0)) )
                {
                    bHookToCElement = TRUE;
                    continue;
                }

                pInterfToken = FindInterface(szInterface);
                if (pInterfToken)
                {
                    if (!ComputeVTable(pClass, 
                                       pInterfToken, 
                                       TRUE, 
                                       pPI, 
                                       piPI, 
                                       pUVTblIdx, 
                                       pVTableHash,
                                       bHookToCElement,
                                       TRUE))
                        return FALSE;
                }
            }
        }

        // Output the vtable interface sorted by name.
        for (int iVTbl = 0; iVTbl < *piPI; iVTbl++)
        {
            PropdescInfo *pPrevPropdescInfo;
            // Convert the sort key to unicode since the HashTable is in Unicode
            WCHAR strUnicode[256];
            int retVal = 
                MultiByteToWideChar(CP_ACP, 0, pPI[iVTbl]._szSortKey,
                                    256,
                                    strUnicode, 256);
            if(retVal == 0)
            {
                ReportError("Unable to convert class name to Unicode");
                return FALSE;
            }

            // Change the style property to point to a special array
            // of PropertyDescs if we are dealing with the CElement class
            if((_stricmp(pPI[iVTbl]._szSortKey, "style") == 0) &&
               (_stricmp(pClass->GetTagValue(CLASS_NAME), "CElement") == 0))
            {
                pPI[iVTbl]._szPropName = "StyleArray";
                pPI[iVTbl]._uVTblIndex |= PDLPARSE_PROPDESCARRAY;
                pPI[iVTbl]._uVTblIndex |= PDLPARSE_BELONGSTOBOTH;
            } 
            else if((_stricmp(pPI[iVTbl]._szSortKey, "checked") == 0) &&
                    (_stricmp(pClass->GetTagValue(CLASS_NAME), "CInput") == 0))
            // Change the checked property to point to a special array
            // of PropertyDescs if we are dealing with the CInput class
            {
                pPI[iVTbl]._szPropName = "CheckedArray";
                pPI[iVTbl]._uVTblIndex |= PDLPARSE_PROPDESCARRAY;
                pPI[iVTbl]._uVTblIndex |= PDLPARSE_BELONGSTOBOTH;
            }

            // If the hash table entry was already set by the parser,
            // make it a shared entry by the parser and OM.
            pPrevPropdescInfo = (PropdescInfo *)pVTableHash->GetCi(strUnicode);
            if(pPrevPropdescInfo)
            {
                // We cannot have two different properties map to the same name
                // unless they are ones we already know about
                if((_stricmp(pPrevPropdescInfo->_szPropName, pPI[iVTbl]._szPropName) != 0) &&
                   (_stricmp(pPI[iVTbl]._szSortKey, "checked") != 0) &&
                   (_stricmp(pPI[iVTbl]._szSortKey, "style") != 0))
                {
                    ReportError("We cannot have two different properties map to the same name");
                    return FALSE;
                }
                pPI[iVTbl]._uVTblIndex |= PDLPARSE_BELONGSTOBOTH;
            }

            // Set the entry in the hash table
            if(pVTableHash->SetCi(strUnicode, 
                                  &pPI[iVTbl]) != S_OK)
            {
                ReportError("Error: Unable to add Hash entry to table");
                return FALSE;
            }

#ifdef COMPLUS_SHIM

            //  ***TLL*** COM+: Not spitting COM+ proxies for internal.pdl and mshtmext.pdl need to do, shouldn't special case.
            BOOL fInternalPDL = (_stricmp(_pszPDLFileName, "internal.pdl") == 0) || (_stricmp(_pszPDLFileName, "mshtmext.pdl") == 0);

            // Output COM+ code, only real classes are exposed.
            if (pClass->IsSet(CLASS_GUID) && pClass->IsSet(CLASS_INTERFACE) && !fInternalPDL)
            {
                GenComPlusDeclarations(pClass, pPI + iVTbl);
            }

#endif    // COMPLUS_SHIM
        }
    }

    return TRUE;
}


#ifdef COMPLUS_SHIM

void
CPDLParser::GenComPlusMethodsInInterfaces(Token *pInterfaceToken, Token *pClass /* =NULL */)
{
    Token *pChildToken;
    CString szMethodName;
    CString szPropertyName;
    CString argCStr;
    CString resultCStr;

    CTokenListWalker ChildWalker(pInterfaceToken);

    while (pChildToken = ChildWalker.GetNext())
    {
        if (pChildToken->GetType() == TYPE_METHOD)
        {
// ***TLL*** Need to handle vararg arguments. [METHOD_VARARG]

            if (pChildToken->IsSet(METHOD_NOPROPDESC) &&
                pChildToken->IsSet(METHOD_SZINTERFACEEXPOSE))
            {
                szMethodName = pChildToken->GetTagValue(METHOD_SZINTERFACEEXPOSE);
            }
            else
            {
                szMethodName = pChildToken->GetTagValue(METHOD_NAME);
            }

            if (GenComPlusArgumentSignature(pChildToken, resultCStr, argCStr))
            {
                fprintf(fpHComPlusFile, "\t%s %s %s;\n",
                        (LPCSTR)resultCStr,
                        (LPCSTR)szMethodName,
                        (LPCSTR)argCStr);
            }
        }
        else // Property
        {
            if (pChildToken->IsSet(PROPERTY_NOPROPDESC) &&
                pChildToken->IsSet(PROPERTY_SZINTERFACEEXPOSE))
            {
                szPropertyName = pChildToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE);
            }
            else
            {
                szPropertyName = pChildToken->GetTagValue(PROPERTY_NAME);
            }

            if (pChildToken->IsSet(PROPERTY_SET))
            {
// ***TLL*** COM+: What happens to displaybind, bindable, hidden, restricted, nonbrowsable, source.

                if (GenComPlusArgumentSignature(pChildToken, resultCStr, argCStr, SetProperty))
                {
                    fprintf(fpHComPlusFile, "\t%s %s %s;\n",
                            (LPCSTR)resultCStr,
                            (LPCSTR)szPropertyName,
                            (LPCSTR)argCStr);
                }
            }

            if (pChildToken->IsSet(PROPERTY_GET))
            {
// ***TLL*** COM+: What happens to displaybind, bindable, hidden, restricted, nonbrowsable, source.

                if (GenComPlusArgumentSignature(pChildToken, resultCStr, argCStr, GetProperty))
                {
                    fprintf(fpHComPlusFile, "\t%s %s %s;\n",
                            (LPCSTR)resultCStr,
                            (LPCSTR)szPropertyName,
                            (LPCSTR)argCStr);
                }
            }
        }
    }
}

void
CPDLParser::GenComPlusInterfaces(Token *pInterfaceToken, char* pszSuper)
{
    CString		szInterf;
    Token		*pSuperInterf;

#if 0
if (_stricmp("IHTMLStyle", pInterfaceToken->GetTagValue(NAME_TAG)) == 0)
__asm { int 3 };
#endif

    if (!PrimaryTearoff(pInterfaceToken) && (!pszSuper || !*pszSuper))
        ReportError("COM+: Interfaces w/o tearoff need super:IDispatch\n");

    // ***TLL*** COM+: For now don't expose any IUnknown derived classes.
    if (_stricmp(pszSuper, "IUnknown") == 0)
        return;

    // Is the super derived from IUnknown?

    szInterf = pszSuper;
    pSuperInterf = FindInterface(szInterf);
    if (pSuperInterf)
    {
        if (_stricmp(pSuperInterf->GetTagValue(INTERFACE_SUPER), "IUnknown") == 0)
            return;
    }
    // ***TLL*** End of comment section

    if (pInterfaceToken->IsSet(INTERFACE_CUSTOM) && pszSuper && *pszSuper)
    {
        fprintf(fpHComPlusFile, "[managed, com] interface %sCOMPLUS : public ICOMCookie, public %sCOMPLUS\n{\npublic:\n",
                pInterfaceToken->GetTagValue(NAME_TAG),
                pszSuper);
    }
    else
    {
        if (PrimaryTearoff(pInterfaceToken))
        {
            fprintf(fpHComPlusFile, "[managed, com] interface %sCOMPLUS : public ICOMCookie \n{\npublic:\n",
                    pInterfaceToken->GetTagValue(NAME_TAG));
        }
        else
        {
            if (strcmp("IDispatch", pszSuper) == 0)
            {
                fprintf(fpHComPlusFile, "[managed, com] interface %sCOMPLUS : public ICOMCookie \n{\npublic:\n",
                        pInterfaceToken->GetTagValue(NAME_TAG));
            }
            else
            {
                fprintf(fpHComPlusFile, "[managed, com] interface %sCOMPLUS : public ICOMCookie, public %sCOMPLUS \n{\npublic:\n",
                        pInterfaceToken->GetTagValue(NAME_TAG), pszSuper);
            }
        }
    }

    // Fill in methods of interface:
    GenComPlusMethodsInInterfaces(pInterfaceToken);

    fprintf(fpHComPlusFile, "};\n\n");
}


void
CPDLParser::GenComPlusESI()
{
    CTokenListWalker ThisFileList(pRuntimeList, _pszPDLFileName);
    Token * pInterfaceToken;
    Token * pEnumToken;
    Token * pStructToken;

    //
    // Generate all the event interfaces
    //
    ThisFileList.Reset();
    while (pInterfaceToken = ThisFileList.GetNext(TYPE_EVENT))
    {
        if (!pInterfaceToken->IsSet(EVENT_ABSTRACT) &&
            pInterfaceToken->IsSet(EVENT_GUID))
        {
// TODO: ***TLL*** Need to spit out event interfaces.
        }
    }

    //
    // Generate all the enumerators.
    //
    ThisFileList.Reset();
    while (pEnumToken = ThisFileList.GetNext(TYPE_ENUM))
    {
// TODO: ***TLL*** Need to spit out enums.
    }
    
    //
    // Generate all the structs
    //
    ThisFileList.Reset();
    while (pStructToken = ThisFileList.GetNext(TYPE_STRUCT))
    {
// TODO: ***TLL*** Need to spit out structs.
    }
    
    //
    // Generate all the non-abstract interfaces.
    //
    ThisFileList.Reset();
    while ( pInterfaceToken = ThisFileList.GetNext(TYPE_INTERFACE))
    {
        if (!pInterfaceToken->IsSet(INTERFACE_ABSTRACT) &&
            pInterfaceToken->IsSet(INTERFACE_GUID))
        {
            GenComPlusInterfaces(pInterfaceToken, pInterfaceToken->GetTagValue(INTERFACE_SUPER));
        }
        else if (!pInterfaceToken->IsSet(INTERFACE_ABSTRACT) &&
                 !pInterfaceToken->IsSet(INTERFACE_GUID))
        {
            // Generate a forward declare
            CString szInterfaceName;
            
            szInterfaceName = pInterfaceToken->GetTagValue(INTERFACE_NAME);
            if (szInterfaceName != "IDispatch" && szInterfaceName != "IUnknown")
            {
                fprintf(fpHComPlusFile, "interface %sCOMPLUS;\n", pInterfaceToken->GetTagValue(NAME_TAG));
            }
        }
    }
}


BOOL
CPDLParser::GenComPlusArgumentSignature(Token *pMethod, CString & resultCStr, CString & argCStr, PropertyType propType /* = NotProperty */)
{
    BOOL    fNameOnly;
    LPCSTR	pSimpleType;
    char	pComPlusType[128];
    BOOL	fRet = FALSE;			// Assume don't want to expose method/property

    resultCStr = "";
    argCStr = "";

    fNameOnly = _stricmp(pMethod->GetTagValue(METHOD_NOPROPDESC), "nameonly") == 0;

    if (pMethod->GetType() == TYPE_METHOD && !fNameOnly)
    {
        CTokenListWalker	ArgListWalker(pMethod);
        BOOL				fResultFound = FALSE;
        CString				szAutomationType;
        Token				*pArgToken;
        int					cAType;

        while (pArgToken = ArgListWalker.GetNext())
        {
            if (pArgToken->IsSet(METHODARG_RETURNVALUE))
            {
                szAutomationType = pArgToken->IsSet(METHODARG_ATYPE) ?
                                        pArgToken->GetTagValue(METHODARG_ATYPE) :
                                        pArgToken->GetTagValue(METHODARG_TYPE);

                cAType = szAutomationType.Length();
                if (cAType && szAutomationType[cAType - 2] == '*')
                {
                    szAutomationType.PutChar(cAType - 2, '\0');
                }
                else if (cAType && szAutomationType[cAType - 1] == '*')
                {
                    szAutomationType.PutChar(cAType - 1, '\0');
                }

#if 0
if (szAutomationType == "IHTMLControlElement")
__asm {int 3};
#endif

                pSimpleType = ConvertType(szAutomationType, TRUE, &pComPlusType[0]);

                resultCStr = pSimpleType ? pSimpleType : pComPlusType;

                fResultFound = TRUE;
            }
        }

        if (!fResultFound)
        {
            resultCStr = "void";
        }

        BOOL				fFirst = TRUE;
        int					idx = 1;
        char				buffer[40];

        argCStr = "(";
        ArgListWalker.Reset();

        while (pArgToken = ArgListWalker.GetNext())
        {
            if (!pArgToken->IsSet(METHODARG_RETURNVALUE))
            {
                if (!fFirst)
                {
                    argCStr += ", ";
                }

                szAutomationType = pArgToken->GetTagValue(METHODARG_TYPE);

                cAType = szAutomationType.Length();
                if (cAType && szAutomationType[cAType - 1] == '*')
                {
                    szAutomationType.PutChar(cAType - 1, '\0');
                }

                pSimpleType = ConvertType(szAutomationType, TRUE, &pComPlusType[0]);
                argCStr += pSimpleType ? pSimpleType : pComPlusType;
                argCStr += " param";
                _itoa(idx++, buffer, 10);
                argCStr += buffer;
            }

            fFirst = FALSE;
        }

        argCStr += ")";

        fRet = TRUE;
    }
    else
    {
        // Property
        CString		szAutomationType;
        int			cAType;

        fNameOnly = _stricmp(pMethod->GetTagValue(PROPERTY_NOPROPDESC), "nameonly") == 0;

        szAutomationType = pMethod->GetTagValue(PROPERTY_ATYPE);

        cAType = szAutomationType.Length();
        if (szAutomationType[cAType - 1] == '*')
        {
            szAutomationType.PutChar(cAType - 1, '\0');
        }

        pSimpleType = ConvertType(szAutomationType, TRUE, &pComPlusType[0]);

        if (propType == SetProperty && !fNameOnly )
        {
            resultCStr = "void";
            argCStr = "(";
            argCStr += pSimpleType ? pSimpleType : pComPlusType;
            argCStr += " param1)";

            fRet = TRUE;
        }

        if (propType == GetProperty && !fNameOnly)
        {
            resultCStr = pSimpleType ? pSimpleType : pComPlusType;
            argCStr = "()";

            fRet = TRUE;
        }
    }

    return fRet;
}


void
CPDLParser::GenComPlusDeclarations(Token *pClass, PropdescInfo *pPI)
{
    BOOL    fNameOnly;
    LPCSTR	pSimpleType;
    char	pComPlusType[128];
    int		uIIDIdx;
    int		uVTblIdx;
    CString	szClassName;

    szClassName = pClass->IsSet(CLASS_COCLASSNAME) ? pClass->GetTagValue(CLASS_COCLASSNAME) : pClass->GetTagValue(CLASS_NAME);

#if 0
//if (pPI->_pToken->GetType() == TYPE_METHOD && _stricmp("fireEvent", (LPSTR)pPI->_pToken->GetTagValue(METHOD_NAME)) == 0)
if (pPI->_pToken->GetType() == TYPE_PROPERTY && _stricmp("bookmarks", (LPSTR)pPI->_pToken->GetTagValue(PROPERTY_NAME)) == 0)
__asm {int 3};
#endif

    uIIDIdx = pPI->_uIIDIndex + 1;	// zero is reserved for error.
    uVTblIdx = (((pPI->_uVTblIndex & 0x00ff) + 7) * 4);

    fNameOnly = _stricmp(pPI->_pToken->GetTagValue(METHOD_NOPROPDESC), "nameonly") == 0;

    if (pPI->_pToken->GetType() == TYPE_METHOD && !fNameOnly)
    {
        CTokenListWalker	ArgListWalker(pPI->_pToken);
        BOOL				fResultFound = FALSE;
        CString				szAutomationType;
        Token				*pArgToken;
        int					cAType;
        CString             szTypesSig;
        CString             szArgsType;
        int                 cArgs = 0;
        int                 cRequiredArgs = 0;
        char               *pDefaultParams[MAX_ARGS]    = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
        char               *pDefaultStrParams[MAX_ARGS] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
        BOOL                fBSTRArg;
        BOOL                fVARIANTArg;
        BOOL				fObjectReturn = FALSE;
        ParamType			objectParam[MAX_ARGS] = { CPDLParser::None, CPDLParser::None, CPDLParser::None, CPDLParser::None, CPDLParser::None, CPDLParser::None, CPDLParser::None, CPDLParser::None };

        while (pArgToken = ArgListWalker.GetNext())
        {
            if (pArgToken->IsSet(METHODARG_RETURNVALUE))
            {
                szAutomationType = pArgToken->IsSet(METHODARG_ATYPE) ?
                                        pArgToken->GetTagValue(METHODARG_ATYPE) :
                                        pArgToken->GetTagValue(METHODARG_TYPE);

                cAType = szAutomationType.Length();
                if (cAType && szAutomationType[cAType - 2] == '*')
                {
                    szAutomationType.PutChar(cAType - 2, '\0');
                    fObjectReturn = szAutomationType != "Variant";
                }
                else if (cAType && szAutomationType[cAType - 1] == '*')
                {
                    szAutomationType.PutChar(cAType - 1, '\0');
                    fObjectReturn = szAutomationType != "Variant";
                }

                pSimpleType = ConvertType(szAutomationType, TRUE, &pComPlusType[0]);
                if (pSimpleType)
                {
                    // IUknown or IDispatch return value is an unsigned int from CPThunks
                    if (_stricmp(pSimpleType, "Object") != 0)
                    {
                        // VARIANT_BOOL, int's, etc. returned are not objects.
                        fObjectReturn = FALSE;
                    }
                }

                fprintf(fpCComPlusFile, "%s\n", pSimpleType ? pSimpleType : pComPlusType);
                if (!pSimpleType)
                {
                    if (_stricmp(pComPlusType, "Object") == 0)
                    {
                        strcpy(pComPlusType, "unsigned int");
                    }
                }
                fprintf(fpHComPlusFile, "\t%s ", pSimpleType ? pSimpleType : pComPlusType);

                fResultFound = TRUE;
            }
        }

        if (!fResultFound)
        {
            fprintf(fpHComPlusFile, "\tvoid ");
            fprintf(fpCComPlusFile, "void\n");
        }

        fprintf(fpCComPlusFile, "%sCOMPLUS::", (LPCSTR)szClassName);

        // Method
        fprintf(fpHComPlusFile, "\t%s (", pPI->_pToken->IsSet(METHOD_SZINTERFACEEXPOSE) ?
                                            (LPSTR)pPI->_pToken->GetTagValue(METHOD_SZINTERFACEEXPOSE) :
                                            (LPSTR)pPI->_pToken->GetTagValue(METHOD_NAME));
        fprintf(fpCComPlusFile, "%s (", pPI->_pToken->IsSet(METHOD_SZINTERFACEEXPOSE) ?
                                            (LPSTR)pPI->_pToken->GetTagValue(METHOD_SZINTERFACEEXPOSE) :
                                            (LPSTR)pPI->_pToken->GetTagValue(METHOD_NAME));

        BOOL				fFirst = TRUE;
        int					idx = 1;
        BOOL				fAnyDynamicCasts = FALSE;

        ArgListWalker.Reset();
        while (pArgToken = ArgListWalker.GetNext())
        {
            if (!pArgToken->IsSet(METHODARG_RETURNVALUE))
            {
                if (!fFirst)
                {
                    fprintf(fpHComPlusFile, ", ");
                    fprintf(fpCComPlusFile, ", ");
                }

                szAutomationType = pArgToken->GetTagValue(METHODARG_TYPE);

                cAType = szAutomationType.Length();
                if (cAType && szAutomationType[cAType - 1] == '*')
                {
                    szAutomationType.PutChar(cAType - 1, '\0');
                    if (szAutomationType == "IUnknown" || szAutomationType == "IDispatch")
                    {
                        objectParam[idx - 1] = CPDLParser::AnyObject;
                    }
                    else if (szAutomationType != "Variant")
                    {
                        objectParam[idx - 1] = CPDLParser::Object;
                    }
                }

                pSimpleType = ConvertType(szAutomationType, TRUE, &pComPlusType[0]);
                if (pSimpleType)
                {
                    // IUknown or IDispatch return value is an unsigned int from CPThunks
                    if (_stricmp(pSimpleType, "Object") != 0)
                    {
                        // VARIANT_BOOL, int's, etc. returned are not objects.
                        objectParam[idx - 1] = CPDLParser::None;
                    }
                }

                fprintf(fpHComPlusFile, "%s param%i", pSimpleType ? pSimpleType : pComPlusType, idx);
                fprintf(fpCComPlusFile, "%s param%i", pSimpleType ? pSimpleType : pComPlusType, idx++);
            }

            fFirst = FALSE;
        }

        fprintf(fpHComPlusFile, ");\n");
        fprintf(fpCComPlusFile, ")\n");
        fprintf(fpCComPlusFile, "{\n");

        if (BuildMethodSignature(pPI->_pToken,
                                 szTypesSig,
                                 szArgsType,
                                 fBSTRArg,
                                 fVARIANTArg,
                                 cArgs,
                                 cRequiredArgs,
                                 pDefaultParams,
                                 pDefaultStrParams))
        {
            CString		szFullSignature;
            BOOL		fAtLeastOne = FALSE;
            int			i;

            if (fObjectReturn)
            {
                fprintf(fpCComPlusFile, "\tunsigned int	myPDispatch;\n\n");
            }

            for (i = 0; i < cArgs; i++)
            {
                if (objectParam[i] & CPDLParser::GenericObject)
                {
                    fprintf(fpCComPlusFile, "\tICOMCookie	tempParam%i = dynamic_cast<ICOMCookie>(param%i);\n", i + 1, i + 1);
                    fAtLeastOne = TRUE;
                }
            }
            if (fAtLeastOne)
            {
                fprintf(fpCComPlusFile, "\n");
            }

            // If no return value then set the retVal to void.
            if (!szTypesSig[0])
            {
                szTypesSig = "void";
            }

            // If no arguments then set the argList to void.
            if (!szArgsType[0])
            {
                szArgsType = "_void";
            }

            szTypesSig += szArgsType;

            MakeSignature("Method", szTypesSig, szFullSignature);

            if (fResultFound)
            {
                fprintf(fpCComPlusFile, "\t%s", fObjectReturn ? "myPDispatch = " : "return ");
            }
            else
            {
                fprintf(fpCComPlusFile, "\t");
            }

            fprintf(fpCComPlusFile, "CPThunks::COMPLUS_%s(_myThis, %i, %i", (LPCSTR)szFullSignature, uIIDIdx, uVTblIdx);

            for (i = 0; i < cArgs; i++)
            {
                if (objectParam[i] & CPDLParser::GenericObject)
                {
                    fprintf(fpCComPlusFile, ", tempParam%i.getCOMCookie()", i + 1);
                }
                else if (objectParam[i] & CPDLParser::Object)
                {
                    fprintf(fpCComPlusFile, ", param%i.getCOMCookie()", i + 1);
                }
                else
                {
                    fprintf(fpCComPlusFile, ", param%i", i + 1);
                }
            }

            fprintf(fpCComPlusFile, ");\n");
        }

        if (fObjectReturn)
        {
//  ***TLL*** COM+: Need to create class for return value.  For now just return 0.
//  Should be something like "return new HTMLDOMNodeCOMPLUS(myPDispatch)" where HTMLDOMNodeCOMPLUS
//  is a COM+ class.
            if (fObjectReturn)
            {
                fprintf(fpCComPlusFile, "\n");
            }

			fprintf(fpCComPlusFile, "\treturn 0;\n");
        }

        fprintf(fpCComPlusFile, "}\n\n");
    }
    else
    {
        // Property
        CString		szAutomationType;
        int			cAType;
        ParamType	propertyParam = CPDLParser::None;
        BOOL		fInterfaceFound;

        fNameOnly = _stricmp(pPI->_pToken->GetTagValue(PROPERTY_NOPROPDESC), "nameonly") == 0;

        szAutomationType = pPI->_pToken->GetTagValue(PROPERTY_ATYPE);

        cAType = szAutomationType.Length();
        if (szAutomationType[cAType - 1] == '*')
        {
            szAutomationType.PutChar(cAType - 1, '\0');
        }

        if (cAType && szAutomationType[cAType - 1] == '*')
        {
            szAutomationType.PutChar(cAType - 1, '\0');
            if (szAutomationType == "IUnknown" || szAutomationType == "IDispatch")
            {
                propertyParam = CPDLParser::AnyObject;
            }
            else if (szAutomationType != "Variant")
            {
                propertyParam = CPDLParser::Object;
            }
        }

        pSimpleType = ConvertType(szAutomationType, TRUE, &pComPlusType[0], &fInterfaceFound);
        if (pSimpleType)
        {
            // IUknown or IDispatch return value is an unsigned int from CPThunks
            if (_stricmp(pSimpleType, "Object") != 0)
            {
                // VARIANT_BOOL, int's, etc. returned are not objects.
                propertyParam = CPDLParser::None;
            }
        }

        if (pPI->_pToken->IsSet(PROPERTY_SET) && !fNameOnly )
        {
            fprintf(fpHComPlusFile, "\tvoid\t%s (%s param1);\n",
                    pPI->_pToken->IsSet(PROPERTY_SZINTERFACEEXPOSE) ?
                                        (LPSTR)pPI->_pToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE) :
                                        (LPSTR)pPI->_pToken->GetTagValue(PROPERTY_NAME),
                    pSimpleType ? pSimpleType : pComPlusType);
            fprintf(fpCComPlusFile, "void\n%sCOMPLUS::%s (%s param1)\n",
                    (LPCSTR)szClassName,
                    pPI->_pToken->IsSet(PROPERTY_SZINTERFACEEXPOSE) ?
                                        (LPSTR)pPI->_pToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE) :
                                        (LPSTR)pPI->_pToken->GetTagValue(PROPERTY_NAME),
                    pSimpleType ? pSimpleType : pComPlusType);
            fprintf(fpCComPlusFile, "{\n");

            if (pSimpleType)
            {
                if (_stricmp(pSimpleType, "String") == 0)
                {
                    fprintf(fpCComPlusFile, "\tCPThunks::COMPLUS_S_String(_myThis, %i, %i, param1);\n", uIIDIdx, uVTblIdx); 
                }
                else if (_stricmp(pSimpleType, "Object") == 0 )
                {
                    fprintf(fpCComPlusFile, "\tunsigned int tempParam1 = dynamic_cast<ICOMCookie>(param1).getCOMCookie();\n");
                    fprintf(fpCComPlusFile, "\tCPThunks::COMPLUS_S_IDispatchp(_myThis, %i, %i, tempParam1);\n", pSimpleType, uIIDIdx, uVTblIdx);
                }
                else
                {
                    fprintf(fpCComPlusFile, "\tCPThunks::COMPLUS_S_%s(_myThis, %i, %i, param1);\n", pSimpleType, uIIDIdx, uVTblIdx);
                }
            }
            else if (fInterfaceFound)
            {
                fprintf(fpCComPlusFile, "\tCPThunks::COMPLUS_S_IDispatchp(_myThis, %i, %i, param1.getCOMCookie());\n", uIIDIdx, uVTblIdx);
            }
            else
            {
                fprintf(fpCComPlusFile, "\tCPThunks::COMPLUS_S_%s(_myThis, %i, %i, param1);\n", pComPlusType, uIIDIdx, uVTblIdx);
            }

            fprintf(fpCComPlusFile, "}\n\n");
        }
        if (pPI->_pToken->IsSet(PROPERTY_GET) && !fNameOnly)
        {
            fprintf(fpHComPlusFile, "\t%s\t%s ();\n",
                pSimpleType ? pSimpleType : pComPlusType,
                pPI->_pToken->IsSet(PROPERTY_SZINTERFACEEXPOSE) ?
                                    (LPSTR)pPI->_pToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE) :
                                    (LPSTR)pPI->_pToken->GetTagValue(PROPERTY_NAME));
            fprintf(fpCComPlusFile, "%s\n%sCOMPLUS::%s ()\n",
                pSimpleType ? pSimpleType : pComPlusType,
                (LPCSTR)szClassName,
                pPI->_pToken->IsSet(PROPERTY_SZINTERFACEEXPOSE) ?
                                    (LPSTR)pPI->_pToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE) :
                                    (LPSTR)pPI->_pToken->GetTagValue(PROPERTY_NAME));
            fprintf(fpCComPlusFile, "{\n");
            if (pSimpleType)
            {
                if (_stricmp(pSimpleType, "String") == 0)
                {
                    fprintf(fpCComPlusFile, "\treturn CPThunks::COMPLUS_G_String(_myThis, %i, %i);\n", uIIDIdx, uVTblIdx + 1); 
                }
                else if (_stricmp(pSimpleType, "Object") == 0)
                {
                    // return IUnknown or IDispatch (not a qualified interface like IHTMLnnnnn).
                    fprintf(fpCComPlusFile, "\tunsigned int\tmyPDispatch;\n\n");
                    fprintf(fpCComPlusFile, "\tmyPDispatch = CPThunks::COMPLUS_G_%s(_myThis, %i, %i);\n", pSimpleType, uIIDIdx, uVTblIdx + 1);

//TODO: ***TLL*** COM+: Hook up document property of Window.  Need generic mechanism here.
					if (_stricmp((LPCSTR)szClassName, "HTMLWindow2") == 0)
					{
						if (_stricmp(pPI->_pToken->IsSet(PROPERTY_SZINTERFACEEXPOSE) ?
										(LPSTR)pPI->_pToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE) :
										(LPSTR)pPI->_pToken->GetTagValue(PROPERTY_NAME),
									 "document") == 0)
						{
							fprintf(fpCComPlusFile, "return new HTMLDocumentCOMPLUS(myPDispatch);\n");
							fprintf(fpCComPlusFile, "//");		// comment the next return spit out
						}
					}

// TODO:	***TLL*** COM+: Need to return (coclass) object stuffed myPDispatch.  Remove return 0; and used below commented out line.
                    fprintf(fpCComPlusFile, "\treturn 0;\n");
//					fprintf(fpCComPlusFile, "\treturn new %s(myPDispatch);\n", pComPlusType);
                }
                else
                {
                    fprintf(fpCComPlusFile, "\treturn CPThunks::COMPLUS_G_%s(_myThis, %i, %i);\n", pSimpleType, uIIDIdx, uVTblIdx + 1);
                }
            }
            else if (_stricmp(pComPlusType, "Variant") == 0)
            {
                fprintf(fpCComPlusFile, "\tunsigned int\tmyPVariant;\n\n");
                fprintf(fpCComPlusFile, "\tmyPVariant = CPThunks::COMPLUS_G_%s(_myThis, %i, %i);\n\n", "VARIANT", uIIDIdx, uVTblIdx + 1);
                fprintf(fpCComPlusFile, "\treturn new Variant(myPVariant);\n");
            }
            else
            {
                fprintf(fpCComPlusFile, "\tunsigned int\tmyPDispatch;\n\n");
                fprintf(fpCComPlusFile, "\tmyPDispatch = CPThunks::COMPLUS_G_%s(_myThis, %i, %i);\n\n", "Object", uIIDIdx, uVTblIdx + 1);

//TODO: ***TLL*** COM+: Hook up document property of Window.  Need generic mechanism here.
				if (_stricmp((LPCSTR)szClassName, "HTMLWindow2") == 0)
				{
					if (_stricmp(pPI->_pToken->IsSet(PROPERTY_SZINTERFACEEXPOSE) ?
									(LPSTR)pPI->_pToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE) :
									(LPSTR)pPI->_pToken->GetTagValue(PROPERTY_NAME),
								 "document") == 0)
					{
						fprintf(fpCComPlusFile, "return new HTMLDocumentCOMPLUS(myPDispatch);\n");
						fprintf(fpCComPlusFile, "//");		// comment the next return spit out
					}
				}

// ***TLL*** COM+: Need to return (coclass) object stuffed myPDispatch.  Remove return 0; and used below commented out line.
                fprintf(fpCComPlusFile, "\treturn 0;\n");
//				fprintf(fpCComPlusFile, "\treturn new %s(myPDispatch);\n", pComPlusType);
            }

            fprintf(fpCComPlusFile, "}\n\n");
        }
    }
}

#endif   // COMPLUS_SHIM


BOOL
CPDLParser::ComputePROPDESC_STRUCT ( FILE *fp, Token *pClassToken, Token *pChild, CString & szHandler, CString & szFnPrefix )
{
    char szErrorText [ MAX_LINE_LEN+1 ];

    fprintf ( fp, "EXTERN_C const " );

    if ( !pChild->IsSet ( PROPERTY_ABSTRACT ) && szHandler == "Num" || szHandler == "Enum"  || szHandler == "UnitValue" )
    {
        // Numeric Handlers
        if ( pChild->IsSet ( PROPERTY_GETSETMETHODS ) )
        {
             fprintf ( fp, "PROPERTYDESC_NUMPROP_GETSET" );
        }
        else if ( pChild->IsSet ( PROPERTY_ABSTRACT ) )
        {
            fprintf ( fp, "PROPERTYDESC_NUMPROP_ABSTRACT" );
        }
        else if ( pChild->IsSet ( PROPERTY_ENUMREF ) )
        {
            fprintf ( fp, "PROPERTYDESC_NUMPROP_ENUMREF" );
        }
        else
        {
            fprintf ( fp, "PROPERTYDESC_NUMPROP" );
        }
    }
    else
    {
        // BASIC PROP PARAM Structure
        if ( pChild->IsSet ( PROPERTY_GETSETMETHODS ) )
        {
            if ( szFnPrefix == "" )
            {
                sprintf ( szErrorText, "Invalid Type:%s in Class:%s Property:%s\n",
                    (LPCSTR)pChild->GetTagValue ( PROPERTY_TYPE ),
                    (LPCSTR)pClassToken->GetTagValue(CLASS_NAME),
                    (LPCSTR)pChild->GetTagValue ( PROPERTY_NAME ) );
                ReportError ( szErrorText );
                return FALSE;
            }
            fprintf ( fp, "PROPERTYDESC_%s_GETSET", (LPCSTR)szFnPrefix );
        }
        else if ( pChild->IsSet ( PROPERTY_ABSTRACT ) )
        {
            fprintf ( fp, "PROPERTYDESC_BASIC_ABSTRACT" );
        }
        else
        {
            fprintf ( fp, "PROPERTYDESC_BASIC" );
        }
    }

    return TRUE;
}


Token * CPDLParser::FindEnum ( Token *pChild )
{
    // Get the enum mask from the enum named by  PROPERTY_TYPE
    CTokenListWalker WholeList ( pRuntimeList );

    return WholeList.GetNext ( TYPE_ENUM, pChild->GetTagValue ( PROPERTY_TYPE ) );
}


char * CPDLParser::MapTypeToIDispatch ( CString & szType )
{
    CString szHandler;
    CString szFnPrefix;
    char    szStrType[255];

    strcpy(szStrType, (LPCSTR)szType);
    if (GetTypeDetails (szStrType, szHandler, szFnPrefix, NULL) && (szHandler == "object"))
    {
        int cSz = szType.Length();

        if (szType[cSz - 1] == '*' && szType[cSz - 2] == '*')
        {
            // is it an IUnknown or an IDispatch?
            if (_strnicmp(szType, "IUnknown", cSz-2)==0)
                return "IUnknownpp";
            else
                return "IDispatchpp";
        }
        else if (szType[cSz - 1] == '*')
        {
            // is it an IUnknown or an IDispatch?
            if (_strnicmp(szType, "IUnknown",cSz-1)==0)
                return "IUnknownp";
            else
                return "IDispatchp";
        }
    }

    return NULL;
}

Token * CPDLParser::FindEventMethod(Token *pClassToken, LPCSTR szEvent)
{
    Token *pChildToken;
    CTokenListWalker WholeList(pRuntimeList);

    WholeList.Reset();
    Token *pEventToken = WholeList.GetNext(TYPE_EVENT, pClassToken->GetTagValue(CLASS_EVENTS));
    if (pEventToken)
    {
        CTokenListWalker ChildList(pEventToken);

        while (pChildToken = ChildList.GetNext())
        {
            if (_stricmp(pChildToken->GetTagValue(METHOD_NAME), szEvent) == 0)
                return pChildToken;
        }
    }

    WholeList.Reset();
    pEventToken = WholeList.GetNext(TYPE_EVENT, pClassToken->GetTagValue(CLASS_NONPRIMARYEVENTS1));
    if (!pEventToken)
        return NULL;

    {
        CTokenListWalker ChildList(pEventToken);

        while (pChildToken = ChildList.GetNext())
        {
            if (_stricmp(pChildToken->GetTagValue(METHOD_NAME), szEvent) == 0)
                return pChildToken;
        }
    }

    WholeList.Reset();
    pEventToken = WholeList.GetNext(TYPE_EVENT, pClassToken->GetTagValue(CLASS_NONPRIMARYEVENTS2));
    if (!pEventToken)
        return NULL;

    {
        CTokenListWalker ChildList(pEventToken);

        while (pChildToken = ChildList.GetNext())
        {
            if (_stricmp(pChildToken->GetTagValue(METHOD_NAME), szEvent) == 0)
                return pChildToken;
        }
    }
    
    WholeList.Reset();
    pEventToken = WholeList.GetNext(TYPE_EVENT, pClassToken->GetTagValue(CLASS_NONPRIMARYEVENTS3));
    if (!pEventToken)
        return NULL;

    {
        CTokenListWalker ChildList(pEventToken);

        while (pChildToken = ChildList.GetNext())
        {
            if (_stricmp(pChildToken->GetTagValue(METHOD_NAME), szEvent) == 0)
                return pChildToken;
        }
    }

    WholeList.Reset();
    pEventToken = WholeList.GetNext(TYPE_EVENT, pClassToken->GetTagValue(CLASS_NONPRIMARYEVENTS4));
    if (!pEventToken)
        return NULL;

    {
        CTokenListWalker ChildList(pEventToken);

        while (pChildToken = ChildList.GetNext())
        {
            if (_stricmp(pChildToken->GetTagValue(METHOD_NAME), szEvent) == 0)
                return pChildToken;
        }
    }
    
    return NULL;
}

Token * CPDLParser::FindEventProp(Token *pClassToken, LPCSTR szEvent)
{
    Token *pChild;
    CTokenListWalker ChildList ( pClassToken );

    while ( pChild = ChildList.GetNext() )
    {
        if ( pChild->nType == TYPE_PROPERTY &&
             pChild->IsSet(PROPERTY_SCRIPTLET) &&
             _stricmp(pChild->GetTagValue(PROPERTY_NAME), szEvent) == 0 )
            return pChild;
    }

    return NULL;
}

BOOL CPDLParser::ComputeProperty ( Token *pClassToken, Token *pChild )
{
    CString                     szClass;
    CString                     szHandler;
    CString                     szFnPrefix;
    CString                     szHTMLName;
    char                        szExposedName [ MAX_LINE_LEN+1 ];
    CString                     szdwFlags;
    CString                     szNotPresentDefault;
    CString                     szNotAssignedDefault;
    CString                     szUpperName;
    CString                     szDispid;
    char                        szErrorText [ MAX_LINE_LEN+1 ];
    StorageType                 stHowStored;
    const CCachedAttrArrayInfo *pCAAI = NULL;
    BOOL                        fNumericHandler;
    CString                     szVTDef;
    CString                     szPropSignature;
    CString                     szPropVT;
    Token                      *pEnumType;
    Token                      *pEventChild = NULL;
    char                        chCustomInvokeIdx[128];
    char                       *pDispatchType;
    CString szPreText,szPostText;
    CString szMemberDesc;
    
    szPreText = "_T(";
    szPostText = ")";

    pEnumType = FindEnum ( pChild );
    if ( pEnumType )
    {
        // Generic enumerator property handler, the propDesc has the enumerator
        // type.
        szPropVT = "PropEnum";
    }
    else
    {
        char *pWS;

        szPropVT = pChild->GetTagValue ( PROPERTY_ATYPE );

        // Remove any underscores in the type name.
        while ((pWS = szPropVT.FindChar('_')))
        {
            while (*pWS = *(pWS + 1))
                pWS++;
            *pWS = '\0';
        }
    }

    // Should this type be mapped to IDispatch?
    pDispatchType = MapTypeToIDispatch ( szPropVT );
    if (pDispatchType)
    {
        szPropVT = pDispatchType;
    }

    szClass = pClassToken->GetTagValue ( CLASS_NAME );

    szUpperName = pChild->GetTagValue ( PROPERTY_NAME );
    szUpperName.ToUpper();

    szHandler = "";
    szFnPrefix = "";
    // Check for missing handler later
    GetTypeDetails ( pChild->GetTagValue ( PROPERTY_TYPE ),
        szHandler, szFnPrefix, &stHowStored );

    CString szPropParamDesc;

    szdwFlags = pChild->GetTagValue ( PROPERTY_DWFLAGS );

    if ( pChild->IsSet ( PROPERTY_GETSETMETHODS ) )
    {
        szPropParamDesc = "PROPPARAM_GETMFHandler | PROPPARAM_SETMFHandler";
        szPropSignature = "GS";
    }
    else if ( pChild->IsSet ( PROPERTY_MEMBER ) )
    {
        szPropParamDesc = "PROPPARAM_MEMBER";
    }
    else
    {
        szPropParamDesc = "";
    }

    if ( pChild->IsSet ( PROPERTY_GET ) )
    {
        szPropSignature = "G";
        if ( szPropParamDesc [ 0 ] )
            szPropParamDesc += " | ";
        szPropParamDesc += "PROPPARAM_INVOKEGet";
    }
    if ( pChild->IsSet ( PROPERTY_SET ) )
    {
        szPropSignature += "S";
        if ( szPropParamDesc [ 0 ] )
            szPropParamDesc += " | ";
        szPropParamDesc += "PROPPARAM_INVOKESet";
    }

    if (!szPropSignature[0])
    {
        szPropSignature = "GS";
        if ( szPropParamDesc [ 0 ] )
            szPropParamDesc += " | ";
        szPropParamDesc += "PROPPARAM_INVOKEGet | PROPPARAM_INVOKESet";
    }

    // Write out the function signature for this property.
    if ( !FindAndAddSignature ( szPropSignature, szPropVT, &chCustomInvokeIdx[0] ) )
        return FALSE;

    if ( pChild->IsSet ( PROPERTY_PPFLAGS ))
    {
        szPropParamDesc += " | ";
        szPropParamDesc += pChild->GetTagValue ( PROPERTY_PPFLAGS );
    }
    if ( pChild->IsSet ( PROPERTY_NOPERSIST ) )
    {
        szPropParamDesc += " | PROPPARAM_NOPERSIST";
    }
    if ( pChild->IsSet ( PROPERTY_INVALIDASNOASSIGN ) )
    {
        szPropParamDesc += " | PROPPARAM_INVALIDASNOASSIGN";
    }
    if ( pChild->IsSet ( PROPERTY_CUSTOMENUM ) )
    {
        szPropParamDesc += " | PROPPARAM_CUSTOMENUM ";
    }    
    if ( pChild->IsSet ( PROPERTY_NOTPRESENTASDEFAULT ) )
    {
        szPropParamDesc += " | PROPPARAM_NOTPRESENTASDEFAULT";
    }
    if ( pChild->IsSet ( PROPERTY_HIDDEN ) )
    {
        szPropParamDesc += " | PROPPARAM_HIDDEN";
    }
    if ( pChild->IsSet ( PROPERTY_RESTRICTED ) )
    {
        szPropParamDesc += " | PROPPARAM_RESTRICTED";
    }
    if ( pChild->IsSet ( PROPERTY_CAA ) )
    {
        szDispid = pChild->GetTagValue( PROPERTY_DISPID );
        pCAAI = GetCachedAttrArrayInfo(szDispid);

        szPropParamDesc += " | PROPPARAM_ATTRARRAY ";
#if 0
        if (pCAAI->szPPFlags)
        {
            szPropParamDesc += " | ";
            szPropParamDesc += pCAAI->szPPFlags;
        }
        if (pCAAI->szLMinBitMask)
        {
            pChild->AddTag( PROPERTY_MIN , pCAAI->szLMinBitMask );
        }
#endif
    }

    if ( pChild->IsSet ( PROPERTY_MINOUT ) )
    {
        szPropParamDesc += " | PROPPARAM_MINOUT";
    }

    if ( pChild->IsSet ( PROPERTY_SETDESIGNMODE ) )
    {
        szPropParamDesc += " | PROPPARAM_READONLYATRUNTIME";
    }

    // If we're processing a property that applies to a CF/PF/SF/FF, mark it here
    // this helps us optimize the apply process. Only properties with a DISPID that
    // matches our apply table, can be applied
    if ( pCAAI && pCAAI->szDispId != NULL )
    {
        szPropParamDesc += " | PROPPARAM_STYLISTIC_PROPERTY";
    }

    if ( pChild -> IsSet ( PROPERTY_SCRIPTLET ) )
    {
        szPropParamDesc += " | PROPPARAM_SCRIPTLET";

        pEventChild = FindEventMethod(pClassToken, pChild->GetTagValue(PROPERTY_NAME));

        if (pEventChild)
        {
            if (pEventChild->IsSet(METHOD_CANCELABLE))
            {
                szPropParamDesc += " | PROPPARAM_CANCELABLE";
            }
            if (pEventChild->IsSet(METHOD_BUBBLING))
            {
                szPropParamDesc += " | PROPPARAM_BUBBLING";
            }
        }
        else if (!pChild->IsSet(PROPERTY_NOPROPDESC) && !pChild->IsSet(PROPERTY_BASEIMPLEMENTATION))
        {
            sprintf ( szErrorText, "Unexpected Error:Event prop:%s in Class:%s not found in any Events interface defn.\n",
                (LPCSTR)pChild->GetTagValue ( PROPERTY_NAME ),
                (LPCSTR)pClassToken->GetTagValue(CLASS_NAME) );
            ReportError ( szErrorText );
            return FALSE;
        }
    }

    szMemberDesc = "";

    if ( pChild->IsSet ( PROPERTY_CAA ) )
    {
        if ( pCAAI->dwFlags & CCSSF_CLEARCACHES )
        {
            // Always add dwFlags:ELEMCHNG_CLEARCACHES for these properties
            if ( szdwFlags [0] )
            {
                szdwFlags += "|";
            }
            else
            {
                szdwFlags = "";
            }
            szdwFlags+="ELEMCHNG_CLEARCACHES";
        }

        if ( pCAAI->dwFlags & CCSSF_CLEARFF )
        {
            // Always add dwFlags:ELEMCHNG_CLEARFF for these properties
            if ( szdwFlags [0] )
            {
                szdwFlags += "|";
            }
            else
            {
                szdwFlags = "";
            }
            szdwFlags+="ELEMCHNG_CLEARFF";
        }
        
        if ( pCAAI->dwFlags & CCSSF_REMEASURECONTENTS )
        {
            // Always add dwFlags:ELEMCHNG_REMEASURECONTENTS for these properties
            if ( szdwFlags [0] )
            {
                szdwFlags += "|";
            }
            else
            {
                szdwFlags = "";
            }
            szdwFlags+="ELEMCHNG_REMEASURECONTENTS";
        }

        if ( pCAAI->dwFlags & CCSSF_REMEASUREALLCONTENTS )
        {
            // Always add dwFlags:ELEMCHNG_REMEASURECONTENTS for these properties
            if ( szdwFlags [0] )
            {
                szdwFlags += "|";
            }
            else
            {
                szdwFlags = "";
            }
            szdwFlags+="ELEMCHNG_REMEASUREALLCONTENTS";
        }

        if ( pCAAI->dwFlags & CCSSF_REMEASUREINPARENT )
        {
            // Always add dwFlags:ELEMCHNG_REMEASUREINPARENT for these properties
            if ( szdwFlags [0] )
            {
                szdwFlags += "|";
            }
            else
            {
                szdwFlags = "";
            }
            szdwFlags+="ELEMCHNG_REMEASUREINPARENT";
        }

        if ( pCAAI->dwFlags & CCSSF_SIZECHANGED )
        {
            // Always add dwFlags:ELEMCHNG_SIZECHANGED for these properties
            if ( szdwFlags [0] )
            {
                szdwFlags += "|";
            }
            else
            {
                szdwFlags = "";
            }
            szdwFlags+="ELEMCHNG_SIZECHANGED";
        }

    }
    else if ( pChild->IsSet ( PROPERTY_MEMBER ) )
    {
        // On the object
        szMemberDesc = szClass;
        szMemberDesc += ", ";
        szMemberDesc += pChild->GetTagValue ( PROPERTY_MEMBER );
    }
    
    if ( pChild -> IsSet ( PROPERTY_ACCESSIBILITYSTATE) )
    {
        // we should only allow this on properties that can be set,
        if ( ! ( pChild->IsSet ( PROPERTY_SET ) ) )
        {
            ReportError ( "Accessibility State can only be applied to r/w properties\n" );
            return FALSE;
        }
        
        if ( szdwFlags [ 0 ] )
        {
            szdwFlags += "|";
        }
        szdwFlags += "ELEMCHNG_ACCESSIBILITY";
    }

    if ( pChild -> IsSet ( PROPERTY_UPDATECOLLECTION ) )
    {
        if ( szdwFlags [ 0 ] )
        {
            szdwFlags += "|";
        }
        szdwFlags += "ELEMCHNG_UPDATECOLLECTION";
    }
    if ( pChild -> IsSet ( PROPERTY_CLEARCACHES ) )
    {
        if ( szdwFlags [ 0 ] )
        {
            szdwFlags += "|";
        }
        szdwFlags += "ELEMCHNG_CLEARCACHES";
    }
    if ( pChild -> IsSet ( PROPERTY_STYLEPROP ) )
    {
        if ( szPropParamDesc [ 0 ] )
            szPropParamDesc += " | ";
        szPropParamDesc += "PROPPARAM_STYLESHEET_PROPERTY";
    }
    if ( pChild -> IsSet ( PROPERTY_DONTUSENOTASSIGN ) )
    {
        if ( szPropParamDesc [ 0 ] )
            szPropParamDesc += " | ";
        szPropParamDesc += "PROPPARAM_DONTUSENOTASSIGNED";
    }
    if ( pChild -> IsSet ( PROPERTY_RESIZE ) )
    {
        if ( szdwFlags [ 0 ] )
        {
            szdwFlags += "|";
        }
        szdwFlags += "ELEMCHNG_SIZECHANGED";
    }
    if ( pChild -> IsSet ( PROPERTY_REMEASURE ) )
    {
        if ( szdwFlags [ 0 ] )
        {
            szdwFlags += "|";
        }
        szdwFlags += "ELEMCHNG_REMEASURECONTENTS";
    }
    if ( pChild -> IsSet ( PROPERTY_REMEASUREALL ) )
    {
        if ( szdwFlags [ 0 ] )
        {
            szdwFlags += "|";
        }
        szdwFlags += "ELEMCHNG_REMEASUREALLCONTENTS";
    }
    if ( pChild -> IsSet ( PROPERTY_SITEREDRAW ) )
    {
        if ( szdwFlags [ 0 ] )
        {
            szdwFlags += "|";
        }
        szdwFlags += "ELEMCHNG_SITEREDRAW";
    }

    char szPropertyDesc [ MAX_LINE_LEN+1 ] ;

    pChild -> GetTagValueOrDefault ( szNotPresentDefault, PROPERTY_NOTPRESENTDEFAULT, "0" );
    if ( pChild->IsSet( PROPERTY_NOTPRESENTDEFAULT ) && szHandler == "String")
    {
        szNotPresentDefault = szPreText + szNotPresentDefault;
        szNotPresentDefault += szPostText;
    }
    else if ( szHandler == "Color" &&  szNotPresentDefault == "0" )
    {
        // This is a nasty little hack to make for colors
        szNotPresentDefault = "-1";
    }
    // If there's a not assigned default, use it, else use the not present default
    pChild -> GetTagValueOrDefault ( szNotAssignedDefault, PROPERTY_NOTSETDEFAULT,
        (LPCSTR)szNotPresentDefault );
    if ( pChild->IsSet( PROPERTY_NOTSETDEFAULT ) && szHandler == "String")
    {
        szNotAssignedDefault = szPreText + szNotAssignedDefault;
        szNotAssignedDefault += szPostText;
    }
    else if ( szHandler == "Color" &&  szNotAssignedDefault == "0" )
    {
        szNotAssignedDefault = "-1";
    }

    // szAttribute spevcifies the html name of the property, if not specified the
    // property name itself is used.
    if ( pChild -> IsSet ( PROPERTY_SZATTRIBUTE ) )
    {
        szHTMLName = pChild -> GetTagValue ( PROPERTY_SZATTRIBUTE );
        sprintf ( (LPSTR) szExposedName,
                  "_T(\"%s\")", 
                  pChild->GetTagValue ( PROPERTY_NAME ) );
    }
    else
    {
        szHTMLName = pChild -> GetTagValue ( PROPERTY_NAME );
        strcpy(szExposedName, "NULL");
    }

    // If the propdesc has a member specified generate a full propdesc
    // By setting abstract: AND member: the propdesc can be used for validation
    // ( e.g. UnitMeasurement sub-object )
    if ( pChild->IsSet ( PROPERTY_ABSTRACT ) && !pChild->IsSet ( PROPERTY_MEMBER )  )
    {
        // Generate a minimal propdesc, this is how IDispatchEx traverses
        // attributes and properties.
        sprintf ( (LPSTR) szPropertyDesc,
            " s_propdesc%s%s = \n{\n    NULL, _T(\"%s\"), %s, (ULONG_PTR)%s, (ULONG_PTR)%s,\n    {",
            (LPCSTR)szClass,
            (LPCSTR)pChild->GetTagValue ( PROPERTY_NAME ),
            (LPCSTR)szHTMLName,
            (LPCSTR)szExposedName,
            (LPCSTR)szNotPresentDefault,
            (LPCSTR)szNotAssignedDefault);
    }
    else
    {
        // If you're gonna set up a handler, better be a valid one
        if ( szHandler == "" )
        {
            sprintf ( szErrorText, "Invalid Type:%s in Class:%s Property:%s\n",
                (LPCSTR)pChild->GetTagValue ( PROPERTY_TYPE ),
                (LPCSTR)pClassToken->GetTagValue(CLASS_NAME),
                (LPCSTR)pChild->GetTagValue ( PROPERTY_NAME ) );
            ReportError ( szErrorText );
            return FALSE;
        }
        char szTempBuf[MAX_LINE_LEN+1];
        sprintf ( (LPSTR) szTempBuf, " s_propdesc%s%s =\n{\n#ifdef WIN16\n    (PFN_HANDLEPROPERTY)&PROPERTYDESC::handle%sproperty, _T(\"%s\"), %s, (ULONG_PTR)%s, (ULONG_PTR)%s,\n#else\n",
            (LPCSTR)szClass,
            (LPCSTR)pChild->GetTagValue ( PROPERTY_NAME ),
            (LPCSTR)szHandler,
            (LPCSTR)szHTMLName,
            (LPCSTR)szExposedName,
            (LPCSTR)szNotPresentDefault,
            (LPCSTR)szNotAssignedDefault);
        sprintf ( (LPSTR) szPropertyDesc, "%s    PROPERTYDESC::Handle%sProperty, _T(\"%s\"), %s, (ULONG_PTR)%s,(ULONG_PTR)%s,\n#endif\n    {", szTempBuf,
            (LPCSTR)szHandler,
            (LPCSTR)szHTMLName,
            (LPCSTR)szExposedName,
            (LPCSTR)szNotPresentDefault,
            (LPCSTR)szNotAssignedDefault);
    }

    if ( !ComputePROPDESC_STRUCT ( fpHDLFile, pClassToken, pChild, szHandler, szFnPrefix) )
        return FALSE;       // Bad error reported...leave

    if ( !szdwFlags [ 0 ] )
        szdwFlags = "0";

    fNumericHandler = FALSE;
    if ( !pChild->IsSet ( PROPERTY_ABSTRACT ) && szHandler == "Num" || szHandler == "Enum"  || szHandler == "UnitValue" )
    {
        // Numeric Handlers
        fNumericHandler = TRUE;

        fprintf ( fpHDLFile, "%s\n        {", szPropertyDesc );

        if ( szHandler == "Enum" )
        {
            szPropParamDesc += " | PROPPARAM_ENUM";
        }
        else if ( pChild -> IsSet ( PROPERTY_ENUMREF ) )
        {
            // A number with one or more enums
            szPropParamDesc += " | PROPPARAM_ENUM | PROPPARAM_ANUMBER";
        }

        pChild -> GetTagValueOrDefault ( szDispid, PROPERTY_DISPID, "0" );

        if ((strcmp(pChild->GetTagValue(PROPERTY_ATYPE), "BSTR") == 0 || strcmp(pChild->GetTagValue(PROPERTY_ATYPE), "VARIANT") == 0) && 
            ((pChild->IsSet(PROPERTY_CAA) || pChild->IsSet(PROPERTY_SET)) && !pChild->IsSet(PROPERTY_INTERNAL)) ||
            (!pChild->IsSet(PROPERTY_CAA) && !pChild->IsSet(PROPERTY_SET) && !pChild->IsSet(PROPERTY_GET)))
        {
            if (!pChild->IsSet(PROPERTY_MAXSTRLEN))
            {
                char szErrorText [ MAX_LINE_LEN+1 ];

                // Dispid not specified this is an error all methods should be accessible
                // from automation.
                sprintf ( szErrorText, "maxstrlen required for property: %s::%s in %s.\n",
                          (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                          (LPCSTR)pChild->GetTagValue ( PROPERTY_NAME ),
                          _pszPDLFileName  );
                ReportError ( szErrorText );
                return FALSE;
            }
        }
        else if (pChild->IsSet(PROPERTY_MAXSTRLEN))
        {
            char szErrorText [ MAX_LINE_LEN+1 ];

            // Dispid not specified this is an error all methods should be accessible
            // from automation.
            sprintf ( szErrorText, "maxstrlen NOT required for property: %s::%s in %s.\n",
                      (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                      (LPCSTR)pChild->GetTagValue ( PROPERTY_NAME ),
                      _pszPDLFileName  );
            ReportError ( szErrorText );
            return FALSE;
        }

        fprintf ( fpHDLFile, "\n            %s, %s, %s, %s, %s \n        },",
            (LPCSTR)szPropParamDesc,
            (LPCSTR)szDispid,
            (LPCSTR)szdwFlags,
            (LPCSTR)&chCustomInvokeIdx[0],
            pChild->IsSet(PROPERTY_MAXSTRLEN) ? (LPCSTR)pChild->GetTagValue(PROPERTY_MAXSTRLEN) : "0");

        if (fpMaxLenFile && pChild->IsSet(PROPERTY_MAXSTRLEN))
        {
            fprintf ( fpMaxLenFile, "%s::%s    %s\n",
                      (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                      (LPCSTR)pChild->GetTagValue ( PROPERTY_NAME ),
                      (LPCSTR)pChild->GetTagValue(PROPERTY_MAXSTRLEN) );
        }

        if ( pChild->IsSet ( PROPERTY_ABSTRACT ) )
        {
            fprintf ( fpHDLFile, "\n        0, 0" );
        }
        else
        {
            if ( !pChild->IsSet ( PROPERTY_VT ) )
            {
                CString szAType;
                szAType = pChild->GetTagValue ( PROPERTY_ATYPE );
                if ( szAType == "short" || szAType == "VARIANT_BOOL" )
                    szVTDef = "VT_I2";
                else
                    szVTDef = "VT_I4";
            }
            else
            {
                szVTDef = pChild->GetTagValue ( PROPERTY_VT );
            }

            if ( pChild -> IsSet ( PROPERTY_GETSETMETHODS ) )
            {
                fprintf ( fpHDLFile, "\n        %s, 0",
                    (LPCSTR)szVTDef );
            }
            else if ( pChild -> IsSet ( PROPERTY_CAA ) )
            {
                fprintf ( fpHDLFile, "\n        %s, sizeof(DWORD)",
                    (LPCSTR)szVTDef );
            }
            else
            {
                fprintf ( fpHDLFile, "\n        %s, SIZE_OF(%s)",
                    (LPCSTR)szVTDef, (LPCSTR)szMemberDesc );
            }
        }

        // Fill in the min/max values
        // If it's an enum, the min value is a ptr to the enum desc structure
        if ( szHandler == "Enum" )
        {
            if ( pChild->IsSet ( PROPERTY_ABSTRACT ) )
            {
                fprintf ( fpHDLFile, ", 0, 0,\n" );
            }
            else
            {
                // Get the enum mask from the enum named by  PROPERTY_TYPE
                CTokenListWalker WholeList ( pRuntimeList );
                Token *pEnumToken = WholeList.GetNext ( TYPE_ENUM, pChild->GetTagValue ( PROPERTY_TYPE ) );
                CString szMin;
                pChild->GetTagValueOrDefault ( szMin, PROPERTY_MIN, "0" );

                if ( pEnumToken == NULL )
                {
                    sprintf ( szErrorText,
                        "unknown enum type %s\n",pChild->GetTagValue ( PROPERTY_TYPE ) );
                    ReportError ( szErrorText );
                    return FALSE;
                }
                fprintf ( fpHDLFile, ", %s, (LONG_PTR)&s_enumdesc%s,\n",
                    (LPCSTR)szMin, pChild->GetTagValue ( PROPERTY_TYPE ) );
            }
        }
        else
        {
            CString szMax;
            CString szMin;
            pChild->GetTagValueOrDefault ( szMin, PROPERTY_MIN, "LONG_MIN" );
            pChild->GetTagValueOrDefault ( szMax, PROPERTY_MAX, "LONG_MAX" );
            fprintf ( fpHDLFile, ", %s, %s,\n", (LPCSTR)szMin, (LPCSTR)szMax );
        }
    }
    else
    {
        fprintf ( fpHDLFile, "%s\n    ", szPropertyDesc );
        pChild -> GetTagValueOrDefault ( szDispid, PROPERTY_DISPID, "0" );

        if ((strcmp(pChild->GetTagValue(PROPERTY_ATYPE), "BSTR") == 0 || strcmp(pChild->GetTagValue(PROPERTY_ATYPE), "VARIANT") == 0) && 
            ((pChild->IsSet(PROPERTY_CAA) || pChild->IsSet(PROPERTY_SET)) && !pChild->IsSet(PROPERTY_INTERNAL)) ||
            (!pChild->IsSet(PROPERTY_CAA) && !pChild->IsSet(PROPERTY_SET) && !pChild->IsSet(PROPERTY_GET)))
        {
            if (!pChild->IsSet(PROPERTY_MAXSTRLEN))
            {
                char szErrorText [ MAX_LINE_LEN+1 ];

                // Dispid not specified this is an error all methods should be accessible
                // from automation.
                sprintf ( szErrorText, "maxstrlen required for property: %s::%s in %s.\n",
                          (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                          (LPCSTR)pChild->GetTagValue ( PROPERTY_NAME ),
                          _pszPDLFileName  );
                ReportError ( szErrorText );
                return FALSE;
            }
        }
        else if (pChild->IsSet(PROPERTY_MAXSTRLEN))
        {
            char szErrorText [ MAX_LINE_LEN+1 ];

            // Dispid not specified this is an error all methods should be accessible
            // from automation.
            sprintf ( szErrorText, "maxstrlen NOT required for property: %s::%s in %s.\n",
                      (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                      (LPCSTR)pChild->GetTagValue ( PROPERTY_NAME ),
                      _pszPDLFileName  );
            ReportError ( szErrorText );
            return FALSE;
        }

        fprintf ( fpHDLFile, "    %s, %s, %s, %s, %s \n",
            (LPCSTR)szPropParamDesc,
            (LPCSTR)szDispid,
            (LPCSTR)szdwFlags,
            (LPCSTR)&chCustomInvokeIdx[0],
            pChild->IsSet(PROPERTY_MAXSTRLEN) ? (LPCSTR)pChild->GetTagValue(PROPERTY_MAXSTRLEN) : "0");

        if (fpMaxLenFile && pChild->IsSet(PROPERTY_MAXSTRLEN))
        {
            fprintf ( fpMaxLenFile, "%s::%s    %s\n",
                      (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                      (LPCSTR)pChild->GetTagValue ( PROPERTY_NAME ),
                      (LPCSTR)pChild->GetTagValue(PROPERTY_MAXSTRLEN) );
        }

    }
    fprintf ( fpHDLFile, "    }," );
    if (pEventChild && pChild->IsSet(PROPERTY_SCRIPTLET))
    {
        fprintf(fpHDLFile, "\n    (DWORD_PTR)%s", pEventChild->GetTagValue(METHOD_DISPID));
    }
    else if ( pChild->IsSet ( PROPERTY_GETSETMETHODS ) )
    {
        fprintf ( fpHDLFile,  "\n    PROPERTY_METHOD(%s, GET, %s, Get%s, GET%s)," ,
            (LPCSTR)szFnPrefix, 
            (LPCSTR)szClass, (LPCSTR)pChild->GetTagValue ( PROPERTY_GETSETMETHODS ),
            (LPCSTR)pChild->GetTagValue ( PROPERTY_GETSETMETHODS ));
        fprintf ( fpHDLFile,  "\n    PROPERTY_METHOD(%s, SET, %s, Set%s, SET%s)" ,
            (LPCSTR)szFnPrefix, 
            (LPCSTR)szClass, (LPCSTR)pChild->GetTagValue ( PROPERTY_GETSETMETHODS ),
            (LPCSTR)pChild->GetTagValue ( PROPERTY_GETSETMETHODS ));
    }
    else if ( pChild->IsSet ( PROPERTY_ABSTRACT ) )
    {
    }
    else if ( szMemberDesc [ 0 ] )
    {
        fprintf ( fpHDLFile, "\n    offsetof(%s)",
            (LPCSTR)szMemberDesc );
    }

    if ( fNumericHandler && pChild->IsSet ( PROPERTY_ENUMREF ) &&
        !pChild->IsSet ( PROPERTY_ABSTRACT ) )
    {
        CTokenListWalker WholeList ( pRuntimeList );
        Token *pEnumToken = WholeList.GetNext ( TYPE_ENUM,
            pChild->GetTagValue ( PROPERTY_ENUMREF ) );
        if ( pEnumToken == NULL )
        {
            sprintf ( szErrorText,
                "unknown enum type %s\n",pChild->GetTagValue ( PROPERTY_ENUMREF ) );
            ReportError ( szErrorText );
            return FALSE;
        }
        if ( !szMemberDesc [ 0 ] )
        {
            fprintf ( fpHDLFile, "\n    0, &s_enumdesc%s",
                pChild->GetTagValue ( PROPERTY_ENUMREF ) );
        }
        else
        {
            fprintf ( fpHDLFile, "\n    &s_enumdesc%s",
                pChild->GetTagValue ( PROPERTY_ENUMREF ) );
        }
    }

    fprintf ( fpHDLFile, "\n};\n\n" );

    return TRUE;
}


BOOL CPDLParser::BuildMethodSignature(Token *pChild,
                                      CString &szTypesSig,
                                      CString &szArgsType,
                                      BOOL &fBSTRArg,
                                      BOOL &fVARIANTArg,
                                      int  &cArgs,
                                      int  &cRequiredArgs,
                                      char *pDefaultParams[MAX_ARGS],
                                      char *pDefaultStrParams[MAX_ARGS])
{
    Token              *pArgToken;
    CTokenListWalker    ArgListWalker(pChild);
    char               *pDispatchType;
    char                szErrorText [ MAX_LINE_LEN+1 ];

    cArgs = 0;
    cRequiredArgs = 0;
    fBSTRArg = FALSE;
    fVARIANTArg = FALSE;

    // Loop thru all arguments.
    while ( (pArgToken = ArgListWalker.GetNext()) != NULL &&
            pArgToken -> GetType () == TYPE_METHOD_ARG )
    {
        fBSTRArg |= (strcmp(pArgToken->GetTagValue(METHODARG_TYPE), "BSTR") == 0);
        fVARIANTArg |= (!pArgToken->IsSet(METHODARG_OUT) && (strcmp(pArgToken->GetTagValue(METHODARG_TYPE), "VARIANT") == 0 || strcmp(pArgToken->GetTagValue(METHODARG_TYPE), "VARIANT*") == 0));

        // Looking for a return value.
        if ( pArgToken -> IsSet ( METHODARG_RETURNVALUE ) )
        {
            char   *pWS;

            szTypesSig = pArgToken -> GetTagValue ( METHODARG_TYPE );

            // Remove any underscores in the type name.
            while ((pWS = szTypesSig.FindChar('_')))
            {
                while (*pWS = *(pWS + 1))
                    pWS++;
                *pWS = '\0';
            }

            // Should this type be mapped to IDispatch?
            pDispatchType = MapTypeToIDispatch ( szTypesSig );
            if (pDispatchType)
            {
                szTypesSig = pDispatchType;
            }
        }
        else
        {
            CString     szArg;
            char        *pWS;

            if ( pArgToken->IsSet ( METHODARG_OPTIONAL ) )
            {
                // little o + zero + little o, prepended to the type signals
                // the type is optional.
                szArg = "o0o";
            }

            if ( pArgToken -> IsSet ( METHODARG_DEFAULTVALUE ) )
            {
                // Signal default.
                szArg = "oDo";

                if (cArgs >= MAX_ARGS)
                {
                    sprintf ( szErrorText, "PDL parser can only handle upto 8 parameters (increase MAX_ARGS) %s in file %s.\n",
                                (LPCSTR)pChild->GetTagValue ( METHOD_NAME ),
                                _pszPDLFileName  );
                    ReportError ( szErrorText );
                    return FALSE;
                }

                // Currently I only handle 2 types of default values numbers and
                // strings.  If any other appear then I'll need to add those as
                // well.
                if ( strcmp (pArgToken -> GetTagValue ( METHODARG_TYPE ), "BSTR") == 0)
                {
                    if (pDefaultStrParams)
                        pDefaultStrParams[cArgs] = pArgToken -> GetTagValue ( METHODARG_DEFAULTVALUE );
                }
                else if (pDefaultParams)
                {
                    pDefaultParams[cArgs] = pArgToken -> GetTagValue ( METHODARG_DEFAULTVALUE );
                }
            }
            else
            {
                // If not optional and not defaultValue then the argument is
                // required and no defaults could have appeared in between.
                if ( !pArgToken->IsSet ( METHODARG_OPTIONAL ) )
                {
                    // Insure that once a default argument is hit all arguments from
                    // that point to the last argument im the function are either
                    // defaultValue or optional.
                    if (cRequiredArgs != cArgs)
                    {
                        sprintf ( szErrorText, "Default arguments must be contiguous to last argument %s in file %s.\n",
                                    (LPCSTR)pChild->GetTagValue ( METHOD_NAME ),
                                    _pszPDLFileName  );
                        ReportError ( szErrorText );
                        return FALSE;
                    }

                    // Arguments without a defaultValue/optional are required args.

                    // Unless the argument is a safe array than any number of
                    // arguments can be specified 0 to n arguments
                    if (strcmp((LPCSTR)(pArgToken -> GetTagValue(METHODARG_TYPE)), "SAFEARRAY(VARIANT)") != 0)
                        // Not a safearray so it's a required argument.
                        cRequiredArgs++;
                }
            }

            szArg += pArgToken -> GetTagValue ( METHODARG_TYPE );
            if (szArg == "oDoVARIANT")
            {
                sprintf ( szErrorText, "Default arguments cannot be VARIANT %s in file %s.\n",
                          (LPCSTR)pChild->GetTagValue ( METHOD_NAME ),
                          _pszPDLFileName  );
                ReportError ( szErrorText );
                return FALSE;
            }

            if ( pArgToken->IsSet ( METHODARG_OPTIONAL ) &&
                 !(szArg == "o0oVARIANT" || szArg == "o0oVARIANT*") )
            {
                sprintf ( szErrorText, "Optional arguments can ONLY be VARIANT or VARIANT* %s in file %s.\n",
                          (LPCSTR)pChild->GetTagValue ( METHOD_NAME ),
                          _pszPDLFileName  );
                ReportError ( szErrorText );
                return FALSE;
            }

            // Should this type be mapped to IDispatch?
            pDispatchType = MapTypeToIDispatch ( szArg );
            if (pDispatchType)
            {
                // Remap to IDispatch* or IDispatch**
                szArg = pDispatchType;
            }

            cArgs++;

            // Remove any underscores in the type name.
            while ((pWS = szArg.FindChar('_')))
            {
                while (*pWS = *(pWS + 1))
                    pWS++;
                *pWS = '\0';
            }

            szArgsType += "_";
            szArgsType += (LPCSTR)szArg;
        }
    }

    return TRUE;
}




BOOL CPDLParser::ComputeMethod ( Token *pClassToken, Token *pChild )
{
    CString             szTypesSig;
    CString             szArgsType;
    CString             szDispid;
    CTokenListWalker    ArgListWalker ( pChild );
    char                chCustomInvokeIdx[128];
    int                 cArgs = 0;
    int                 cRequiredArgs = 0;
    char                szErrorText [ MAX_LINE_LEN+1 ];
    char               *pDefaultParams[MAX_ARGS]    = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
    char               *pDefaultStrParams[MAX_ARGS] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
    BOOL                fBSTRArg;
    BOOL                fVARIANTArg;

    if (!BuildMethodSignature(pChild,
                              szTypesSig,
                              szArgsType,
                              fBSTRArg,
                              fVARIANTArg,
                              cArgs,
                              cRequiredArgs,
                              pDefaultParams,
                              pDefaultStrParams))
        return FALSE;

    // Any default values?
    if (cArgs != cRequiredArgs)
    {
        int     i;

        // Spit out any default string constants.
        for ( i = cRequiredArgs; i < cArgs; i++)
        {
            if ( pDefaultStrParams[i] )
            {
                fprintf ( fpHDLFile, "const TCHAR s_strDef%s%s%i[] = _T(%s);\n",
                          (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                          (LPCSTR)pChild->GetTagValue ( METHOD_NAME ),
                          i - cRequiredArgs,
                          pDefaultStrParams[i] );
                             
            }
        }

        fprintf ( fpHDLFile, "const DEFAULTARGDESC s_defArg%s%s =\n{\n",
                  (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                  (LPCSTR)pChild->GetTagValue ( METHOD_NAME ) );

        // Spit out the all of all default constants
        for ( i = cRequiredArgs; i < cArgs; i++)
        {
            if ( pDefaultStrParams[i] )
            {
                fprintf ( fpHDLFile, "    (DWORD_PTR)s_strDef%s%s%i,\n",
                          (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                          (LPCSTR)pChild->GetTagValue ( METHOD_NAME ),
                          i - cRequiredArgs );
            }
            else
            {
                fprintf ( fpHDLFile, "    (DWORD_PTR)%s,\n", pDefaultParams[i] ? pDefaultParams[i] : "\"\""  );
            }
        }

        fprintf ( fpHDLFile, "};\n" );
    }

    // If no return value then set the retVal to void.
    if (!szTypesSig[0])
    {
        szTypesSig = "void";
    }

    // If no arguments then set the argList to void.
    if (!szArgsType[0])
    {
        szArgsType = "_void";
    }

    szTypesSig += szArgsType;

    szDispid = pChild->GetTagValue(METHOD_DISPID);
    if (szDispid[0])
    {
        // Write out the function signature for this method
        // only do this if a dispid exists.  Methods without dispid
        // are not accessible through automation.
        if ( !FindAndAddSignature ( "Method", szTypesSig, &chCustomInvokeIdx[0] ) )
            return FALSE;
    }
    
    fprintf ( fpHDLFile, "EXTERN_C const PROPERTYDESC_METHOD s_methdesc%s%s = \n{\n",
              (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
              (LPCSTR)pChild->GetTagValue ( METHOD_NAME ));

    fprintf ( fpHDLFile, "    NULL, NULL, _T(\"%s\"), (ULONG)0, (ULONG)0,\n    {\n",
              (LPCSTR)pChild->GetTagValue ( METHOD_NAME ));

    if (!szDispid[0])
    {
        // Dispid not specified this is an error all methods should be accessible
        // from automation.
        sprintf ( szErrorText, "DISPID required for method: %s::%s in %s.\n",
                  (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                  (LPCSTR)pChild->GetTagValue ( METHOD_NAME ),
                  _pszPDLFileName  );
        ReportError ( szErrorText );
        return FALSE;
    }

    if (fBSTRArg || fVARIANTArg)
    {
        if (!pChild->IsSet(METHOD_MAXSTRLEN))
        {
            // Dispid not specified this is an error all methods should be accessible
            // from automation.
            sprintf ( szErrorText, "maxstrlen required for method: %s::%s in %s.\n",
                      (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                      (LPCSTR)pChild->GetTagValue ( METHOD_NAME ),
                      _pszPDLFileName  );
            ReportError ( szErrorText );
            return FALSE;
        }
    }
    else if (pChild->IsSet(METHOD_MAXSTRLEN))
    {
        // Dispid not specified this is an error all methods should be accessible
        // from automation.
        sprintf ( szErrorText, "maxstrlen NOT required for method: %s::%s in %s.\n",
                  (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                  (LPCSTR)pChild->GetTagValue ( METHOD_NAME ),
                  _pszPDLFileName  );
        ReportError ( szErrorText );
        return FALSE;
    }

    fprintf ( fpHDLFile, "        %s, %s, 0, %s, %s\n    },\n    ",
              pChild->IsSet(METHOD_RESTRICTED) ? "PROPPARAM_RESTRICTED" : "0",
              (LPCSTR)szDispid,
              (LPCSTR)&chCustomInvokeIdx[0],
              pChild->IsSet(METHOD_MAXSTRLEN) ? (LPCSTR)pChild->GetTagValue(METHOD_MAXSTRLEN) : "0");
    
    if (fpMaxLenFile && pChild->IsSet(METHOD_MAXSTRLEN))
    {
        fprintf ( fpMaxLenFile, "%s::%s    %s\n",
                  (LPCSTR)pClassToken->GetTagValue(CLASS_NAME),
                  (LPCSTR)pChild->GetTagValue(METHOD_NAME),
                  (LPCSTR)pChild->GetTagValue(METHOD_MAXSTRLEN) );
    }

    if ( cArgs != cRequiredArgs )
    {
        fprintf ( fpHDLFile, "&s_defArg%s%s, ", 
                  (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                  (LPCSTR)pChild->GetTagValue ( METHOD_NAME ) );
    }
    else
    {
        fprintf ( fpHDLFile, "NULL, " );
    }
    
    fprintf ( fpHDLFile, "%i, %i\n};\n\n",
              cArgs,
              cRequiredArgs );

    return TRUE;
}


BOOL CPDLParser::GeneratePROPDESCs ( void )
{
    Token *pClassToken;
    Token *pChild;

    // Only generate def's for this file
    CTokenListWalker TokenList ( pRuntimeList, _pszPDLFileName );

    // Generate propdescs for every property token in every class ( in this file )
    while ( pClassToken = TokenList.GetNext( TYPE_CLASS ) )
    {
        fprintf ( fpHDLFile, "\n" );
        CTokenListWalker ChildList ( pClassToken );

//        if ( pClassToken -> IsSet ( CLASS_ABSTRACT ) )
//        {
//            fprintf ( fpHDLFile, "\n#ifndef _PROPDESCS_EXTERNAL\n" );
//        }

        fprintf ( fpHDLFile, "\n#define _%s_PROPDESCS_\n", pClassToken -> GetTagValue ( CLASS_NAME ) );

        // Walk the super class propdescs looking for properties
        while ( pChild = ChildList.GetNext() )
        {
            if ( pChild->nType == TYPE_PROPERTY &&
                 _stricmp(pChild->GetTagValue(PROPERTY_NOPROPDESC), "nameonly") != 0 )
            {
                if ( !ComputeProperty ( pClassToken, pChild ) )
                    return FALSE;
            }
            else if ( pChild->nType == TYPE_METHOD && !pChild->IsSet(METHOD_NOPROPDESC))
            {
                if (!ComputeMethod(pClassToken, pChild) )
                    return FALSE;
            }
            else
            {
                continue;
            }
        }

        if (fpMaxLenFile)
            fprintf(fpMaxLenFile, "\n");
    }
    return TRUE;
}

void CPDLParser::GenerateThunkContext ( Token *pClassToken )
{
    CTokenListWalker ChildList (pClassToken);

    Token *pChildToken;

    while (pChildToken = ChildList.GetNext())
    {
        if( (pChildToken->GetType() == TYPE_METHOD && pChildToken->IsSet(METHOD_THUNKCONTEXT)) || 
            (pChildToken->GetType() == TYPE_PROPERTY && pChildToken->IsSet(PROPERTY_THUNKCONTEXT)) )
        {
            GenerateSingleThunkContextPrototype(pClassToken, pChildToken, FALSE);
        }
        if( (pChildToken->GetType() == TYPE_METHOD && pChildToken->IsSet(METHOD_THUNKNODECONTEXT)) || 
            (pChildToken->GetType() == TYPE_PROPERTY && pChildToken->IsSet(PROPERTY_THUNKNODECONTEXT)) )
        {
            GenerateSingleThunkContextPrototype(pClassToken, pChildToken, TRUE);
        }
    }

}

void CPDLParser::GenerateSingleThunkContextPrototype ( Token *pClassToken, Token * pChildToken, BOOL fNodeContext )
{
    CString szProp;
    Token *pArgToken;

    if (pChildToken->GetType() == TYPE_METHOD)
    {
        CTokenListWalker ArgListWalker(pChildToken);
        BOOL fFirst = TRUE;

        fprintf(fpHDLFile, "    STDMETHODIMP %s(", (LPCSTR)pChildToken->GetTagValue(METHOD_NAME));
        while (pArgToken = ArgListWalker.GetNext())
        {
            if (!fFirst)
                fprintf(fpHDLFile, ",");
            fprintf(fpHDLFile, "%s %s",
                ConvertType((LPCSTR)pArgToken->GetTagValue ( METHODARG_TYPE )),
                (LPCSTR)pArgToken -> GetTagValue ( METHODARG_ARGNAME ) );
            fFirst = FALSE;
        }

        if(fNodeContext)
        {
            fprintf(fpHDLFile, "%sCTreeNode *pNode);\n", fFirst?"":",");
        }
        else
        {
            fprintf(fpHDLFile, "%sTEAROFF_THUNK*ptt);\n", fFirst?"":",");
        }
    }
    else
    {
        if (pChildToken->IsSet(PROPERTY_SET))
        {
            fprintf(fpHDLFile, "    STDMETHODIMP set_%s(%s v, %s);\n",
                    (LPCSTR)pChildToken->GetTagValue(PROPERTY_NAME),
                    (LPCSTR)pChildToken -> GetTagValue(PROPERTY_ATYPE),
                    fNodeContext?"CTreeNode *pNode":"TEAROFF_THUNK *ptt");
        }
        if (pChildToken->IsSet(PROPERTY_GET))
        {
            fprintf(fpHDLFile, "    STDMETHODIMP get_%s(%s *p, %s);\n",
                    (LPCSTR)pChildToken->GetTagValue(PROPERTY_NAME),
                    (LPCSTR)pChildToken -> GetTagValue(PROPERTY_ATYPE),
                    fNodeContext?"CTreeNode *pNode":"TEAROFF_THUNK *ptt");
        }
    }
}

void CPDLParser::GenerateThunkContextImplemenation ( Token *pClassToken )
{
    CTokenListWalker ChildList (pClassToken);

    Token *pChildToken;

    while (pChildToken = ChildList.GetNext())
    {
        if( (pChildToken->GetType() == TYPE_METHOD && pChildToken->IsSet(METHOD_THUNKCONTEXT)) || 
            (pChildToken->GetType() == TYPE_PROPERTY && pChildToken->IsSet(PROPERTY_THUNKCONTEXT)) )
        {
            GenerateSingleThunkContextImplementation(pClassToken, pChildToken, FALSE);
        }
        if( (pChildToken->GetType() == TYPE_METHOD && pChildToken->IsSet(METHOD_THUNKNODECONTEXT)) || 
            (pChildToken->GetType() == TYPE_PROPERTY && pChildToken->IsSet(PROPERTY_THUNKNODECONTEXT)) )
        {
            GenerateSingleThunkContextImplementation(pClassToken, pChildToken, TRUE);
        }
    }
}

void CPDLParser::GenerateSingleThunkContextImplementation ( Token *pClassToken, Token * pChildToken, BOOL fNodeContext )
{
    CString szProp;
    Token *pArgToken;

    fprintf(fpHDLFile, "#ifdef USE_STACK_SPEW\n#pragma check_stack(off)\n#endif\n");

    if (pChildToken->GetType() == TYPE_METHOD)
    {
        CTokenListWalker ArgListWalker(pChildToken);
        BOOL fFirst = TRUE;

        fprintf(fpHDLFile, "STDMETHODIMP %s::ContextThunk_%s(", 
                (LPCSTR)pClassToken->GetTagValue(CLASS_NAME),
                (LPCSTR)pChildToken->GetTagValue(METHOD_NAME));

        while (pArgToken = ArgListWalker.GetNext())
        {
            if (!fFirst)
                fprintf(fpHDLFile, ",");
            fprintf(fpHDLFile, "%s %s",
                ConvertType((LPCSTR)pArgToken->GetTagValue ( METHODARG_TYPE )),
                (LPCSTR)pArgToken -> GetTagValue ( METHODARG_ARGNAME ) );
            fFirst = FALSE;
        }

        if(fNodeContext)
        {
            fprintf(fpHDLFile, ")\n"
                               "{\n"
                               "    CTreeNode* pNode;\n"
                               "    CONTEXTTHUNK_SETTREENODE\n"
                               "    return %s(", (LPCSTR)pChildToken->GetTagValue(METHOD_NAME));
        }
        else
        {
            fprintf(fpHDLFile, ")\n"
                               "{\n"
                               "    TEAROFF_THUNK* ptt;\n"
                               "    CONTEXTTHUNK_SETTEAROFFTHUNK\n"
                               "    return %s(", (LPCSTR)pChildToken->GetTagValue(METHOD_NAME));
        }

        fFirst = TRUE;
        ArgListWalker.Reset();
        while (pArgToken = ArgListWalker.GetNext())
        {
            if (!fFirst)
                fprintf(fpHDLFile, ",");
            fprintf(fpHDLFile, "%s",
                (LPCSTR)pArgToken -> GetTagValue(METHODARG_ARGNAME));
            fFirst = FALSE;
        }
        fprintf(fpHDLFile, "%s%s);\n}\n", fFirst?"":",", fNodeContext?"pNode":"ptt");
    }
    else
    {
        if (pChildToken->IsSet(PROPERTY_SET))
        {
            fprintf(fpHDLFile, 
                    "STDMETHODIMP %s::ContextThunk_set_%s(%s v)\n"
                    "{\n%s    return set_%s(v,%s);\n}\n",
                    (LPCSTR)pClassToken->GetTagValue(CLASS_NAME),
                    (LPCSTR)pChildToken->GetTagValue(PROPERTY_NAME),
                    (LPCSTR)pChildToken->GetTagValue(PROPERTY_ATYPE),
                    fNodeContext 
                      ? "    CTreeNode* pNode;\n"
                        "    CONTEXTTHUNK_SETTREENODE\n"
                      : "    TEAROFF_THUNK* ptt;\n"
                        "    CONTEXTTHUNK_SETCONTEXTTHUNK\n",
                    (LPCSTR)pChildToken->GetTagValue(PROPERTY_NAME),
                    fNodeContext ? "pNode" : "ptt");
        }
        if (pChildToken->IsSet(PROPERTY_GET))
        {
            fprintf(fpHDLFile, 
                    "STDMETHODIMP %s::ContextThunk_get_%s(%s *p)\n"
                    "{\n%s    return get_%s(p,%s);\n}\n",
                    (LPCSTR)pClassToken->GetTagValue(CLASS_NAME),
                    (LPCSTR)pChildToken->GetTagValue(PROPERTY_NAME),
                    (LPCSTR)pChildToken->GetTagValue(PROPERTY_ATYPE),
                    fNodeContext 
                      ? "    CTreeNode* pNode;\n"
                        "    CONTEXTTHUNK_SETTREENODE\n"
                      : "    TEAROFF_THUNK* ptt;\n"
                        "    CONTEXTTHUNK_SETCONTEXTTHUNK\n",
                    (LPCSTR)pChildToken->GetTagValue(PROPERTY_NAME),
                    fNodeContext ? "pNode" : "ptt");
        }
    }
    fprintf(fpHDLFile, "#ifdef USE_STACK_SPEW\n#pragma check_stack(on)\n#endif\n");
}


BOOL CPDLParser::GenerateHDLFile ( void )
{
    Token  *pClassToken;
    BOOL    bHashTableExists;
    int     numVTblPropDescs;

    CTokenListWalker ThisFilesList ( pRuntimeList, _pszPDLFileName );

    fprintf ( fpHDLFile, "\n" );
    fprintf ( fpHDLFile, "// %s.hdl\n",  _pszOutputFileRoot );
    fprintf ( fpHDLFile, "\n" );
    fprintf ( fpHDLFile, "#ifdef _hxx_\n" );
    fprintf ( fpHDLFile, "\n" );
    fprintf ( fpHDLFile, "#include \"%s.h\"\n",  _pszOutputFileRoot );
    fprintf ( fpHDLFile, "\n" );

    // Generate the DISPID's, one for each member of each class

    fprintf ( fpLOGFile, "Generating DISPID's...\n" );
    GenerateClassDISPIDs();
    GenerateInterfaceDISPIDs();
    GenerateEventDISPIDs( fpHDLFile, TRUE );

    fprintf ( fpHDLFile, "\n" );
    fprintf ( fpHDLFile, "#endif _hxx_\n" );
    fprintf ( fpHDLFile, "\n" );
    fprintf ( fpHDLFile, "#undef _hxx_\n" );
    fprintf ( fpHDLFile, "\n" );

    fprintf ( fpHDLFile, "#ifdef _cxx_\n" );
    fprintf ( fpHDLFile, "\n" );

    // Generate the enum definitions
    fprintf ( fpLOGFile, "Generating CPP Enum Defs...\n" );
    GenerateCPPEnumDefs();

    // Generate the property descriptors
    fprintf ( fpLOGFile, "Generating PROPDESC's...\n" );
    if ( !GeneratePROPDESCs() )
        goto Error;

#ifdef COMPLUS_SHIM

    // ***TLL*** COM+: Not spitting COM+ proxies for internal.pdl and mshtmext.pdl need to do, shouldn't special case.
    if ((_stricmp(_pszPDLFileName, "internal.pdl") != 0) && (_stricmp(_pszPDLFileName, "mshtmext.pdl") != 0))
    {
        GenComPlusESI();		// Output any local interfaces for COM+
    }

#endif    // COMPLUS_SHIM

    // For each TYPE_CLASS in this file generate a propdesc array and vtable
    // array for the class.
    while ( pClassToken = ThisFilesList.GetNext( TYPE_CLASS ) )
    {
        // Generate propdescs for every property token in every class ( in this file )
        fprintf ( fpLOGFile, "Generating PROPDESC Arrays...\n" );

        if ( !GenerateCPC( pClassToken ) )
            goto Error;

        // Generate the vtable array for classes in this file
        fprintf ( fpLOGFile, "Generating VTable Arrays...\n" );

        GenerateVTableArray(pClassToken, &bHashTableExists);

        // Generate the propdesc array in vtable order for classes in this file
        fprintf ( fpLOGFile, "Generating propdesc Arrays in vtbl order...\n" );

        GeneratePropDescsInVtblOrder(pClassToken, &numVTblPropDescs);

        // Abstract classes don't have propdesc arrays or vtable arrays.
        if ( !pClassToken -> IsSet ( CLASS_ABSTRACT ) )
        {
            fprintf ( fpHDLFile, "\nconst HDLDESC %s::s_apHdlDescs = { ",
                      pClassToken -> GetTagValue ( CLASS_NAME ) );

            // Store the Mondo DISPID int he HDLDesc so we can find it for GetTypeInfo
            if ( HasMondoDispInterface ( pClassToken ) )
            {
                CString szDispName;

                // Map to mondo dispinterface as default dispatch interface.
                szDispName = (pClassToken->IsSet(CLASS_COCLASSNAME)) ?
                                pClassToken->GetTagValue (CLASS_COCLASSNAME) :
                                pClassToken->GetTagValue(CLASS_NAME);
                fprintf ( fpHDLFile, " &DIID_Disp%s,", (LPCSTR)szDispName );
            }
            else
            {
                fprintf ( fpHDLFile, " NULL," );
            }

            if ( bHashTableExists )
            {
                fprintf ( fpHDLFile, "&%s::s_StringTableAggregate, ",
                          pClassToken -> GetTagValue ( CLASS_NAME ) );
            }
            else
            {
                fprintf ( fpHDLFile, "NULL, ");
            }

            if ( numVTblPropDescs )
            {
                fprintf ( fpHDLFile, "%s::s_ppropdescsInVtblOrder%s};\n",
                          pClassToken->GetTagValue(CLASS_NAME), pClassToken->GetTagValue(CLASS_INTERFACE) );
            }
            else
            {
                fprintf ( fpHDLFile, "NULL};\n" );
            }
        }
    }

    fprintf ( fpLOGFile, "Generating Property Methods...\n" );
    if ( !GeneratePropMethodImplementation() )
        goto Error;

    fprintf ( fpLOGFile, "Generating Cascaded Property Method Implementations...\n" );

    fprintf ( fpHDLFile, "//    Cascaded Property get method implementations\n\n" );

    ThisFilesList.Reset();
    while ( pClassToken = ThisFilesList.GetNext( TYPE_CLASS ) )
    {
        GenerateGetAAXImplementations(pClassToken);
        GenerateThunkContextImplemenation(pClassToken);
    }

    fprintf ( fpHDLFile, "\n" );
    fprintf ( fpHDLFile, "#endif _cxx_\n" );
    fprintf ( fpHDLFile, "\n" );
    fprintf ( fpHDLFile, "#undef _cxx_\n" );
    fprintf ( fpHDLFile, "\n" );

    fprintf ( fpLOGFile, "Generating Class Includes...\n" );

    if ( !GenerateClassIncludes() )
        goto Error;

    return TRUE;

Error:
    return FALSE;
}

FILE *OpenMaxlengthFile(LPCSTR pszPDLFileName, LPCSTR pszOutputPath)
{
    char  chMaxLenFileName[255];
    FILE *fpMaxLenFile = NULL;
    BOOL  fOpenNew = TRUE;

    strcpy(chMaxLenFileName, pszOutputPath);
    strcat(chMaxLenFileName, FILENAME_SEPARATOR_STR "maxlen.txt");

    fpMaxLenFile = fopen(chMaxLenFileName, "r");
    if (fpMaxLenFile)
    {
        char chMarker[6];
        if (fread(chMarker, sizeof(char), 5, fpMaxLenFile))
        {
            if (!_stricmp(chMarker, "XXXXX"))
            {
                fOpenNew = FALSE;
            }
        }

        fclose(fpMaxLenFile);
    }

    if (fOpenNew)
    {
        fpMaxLenFile = fopen(chMaxLenFileName, "w");
        if (fpMaxLenFile)
        {
            fprintf(fpMaxLenFile, "XXXXX Key Value Glossary:\n");
            fprintf(fpMaxLenFile, "-------------------------------\n");
            fprintf(fpMaxLenFile, "pdlUrlLen = 4096         // url strings\n");
            fprintf(fpMaxLenFile, "pdlToken = 128           // strings that really are some form of a token\n"); 
            fprintf(fpMaxLenFile, "pdlLength = 128          // strings that really are numeric lengths\n");
            fprintf(fpMaxLenFile, "pdlColor = 128           // strings that really are color values\n");
            fprintf(fpMaxLenFile, "pdlNoLimit = 0xFFFF      // strings that have no limit on their max lengths\n");
            fprintf(fpMaxLenFile, "pdlEvent = pdlNoLimit    // strings that could be assigned to onfoo event properties\n\n");
            fprintf(fpMaxLenFile, "MAX LENGTH CONSTANTS FOR OM PROPERTIES AND METHODS\n");
            fprintf(fpMaxLenFile, "-----------------------------------------------------------------------------------\n\n");
        }
    }
    else
    {
        fpMaxLenFile = fopen(chMaxLenFileName, "a");
    }

    return fpMaxLenFile;
}

int
CPDLParser::Parse ( char *szInputFile,
    char *szOutputFileRoot,
    char *szPDLFileName,
    char *szOutputPath,
    BOOL fDebugging )
{
#if 0
if (strcmp(szPDLFileName, "iframe.pdl") == 0)
    __asm {int 3};
#endif

    int		nReturnCode = 0;
    char	szFileName [ MAX_PATH+1 ];
    char	szErrorText [ MAX_LINE_LEN+1 ];
#ifdef COMPLUS_SHIM
    BOOL	fWriteHeader = FALSE;
#endif

    _pszPDLFileName = szPDLFileName;
    _pszOutputFileRoot = szOutputFileRoot;
    _pszInputFile = szInputFile;
    _pszOutputPath = szOutputPath;

    fpMaxLenFile = OpenMaxlengthFile(szPDLFileName, szOutputPath);

    // Read the input file a line at a time, for each line tokenise and
    // parse
    strcpy ( szFileName, szOutputPath );
    strcat ( szFileName, "LOG" );

    fpLOGFile = fopen ( szFileName, "w" );
    if ( !fpLOGFile )
    {
        printf ( szErrorText, "Can't open log file %s\n", szFileName );
        ReportError ( szErrorText );

        goto error;
    }

    fprintf ( fpLOGFile, "InputBuffer = %s\n", szInputFile );
    fprintf ( fpLOGFile, "OuputFileRoot = %s\n", szOutputFileRoot );
    fprintf ( fpLOGFile, "PDLFileName = %s\n", szPDLFileName );
    fprintf ( fpLOGFile, "LogFileName =% s\n", szFileName );

    // All files open and raring to go....
    if ( !ParseInputFile ( fDebugging ) )
    {
        goto error;
    }

    // Create the HDL File
    strcpy ( szFileName, szOutputFileRoot );
    strcat ( szFileName, ".hdl" );

    fpHDLFile = fopen ( szFileName, "w" );
    if ( !fpHDLFile )
    {
        printf ( szErrorText, "Can't open HDL output file %s\n", szFileName );
        ReportError ( szErrorText );

        goto error;
    }

#ifdef COMPLUS_SHIM

    // Create the COM+ header file
    strcpy ( szFileName, _pszOutputPath );
    strcat ( szFileName, "\\" );
    strcat ( szFileName, "MSProxy.h" );

    fpHComPlusFile = fopen ( szFileName, "r" );
    if (!fpHComPlusFile)
    {
        fWriteHeader = TRUE;
    }
    else
    {
        fclose(fpHComPlusFile);
    }

    fpHComPlusFile = fopen ( szFileName, "a" );
    if ( !fpHComPlusFile )
    {
        printf ( szErrorText, "Can't open COM+ output file %s\n", szFileName );
        ReportError ( szErrorText );

        goto error;
    }

    // Only write the header first time through not when each PDL is parsed.
    if (fWriteHeader)
    {
        fprintf(fpHComPlusFile, "[managed, com] __interface ICOMCookie\n");
        fprintf(fpHComPlusFile, "{\n");
        fprintf(fpHComPlusFile, "public:\n");
        fprintf(fpHComPlusFile, "\tunsigned int getCOMCookie();\n");
        fprintf(fpHComPlusFile, "};\n\n");
    }

    // Create the COM+ source file
    strcpy ( szFileName, _pszOutputPath );
    strcat ( szFileName, "\\" );
    strcat ( szFileName, "MSProxy.cpp" );

    fpCComPlusFile = fopen ( szFileName, "r" );
    if (!fpCComPlusFile)
    {
        fWriteHeader = TRUE;
    }
    else
    {
        fclose(fpCComPlusFile);
    }

    fpCComPlusFile = fopen ( szFileName, "a" );
    if ( !fpCComPlusFile )
    {
        printf ( szErrorText, "Can't open COM+ output file %s\n", szFileName );
        ReportError ( szErrorText );

        goto error;
    }

    // Only write the header first time through not when each PDL is parsed.
    if (fWriteHeader)
    {
        fprintf(fpCComPlusFile, "#import <MSCorLib.dll>\n\n");
        fprintf(fpCComPlusFile, "// Some types COM+ doesn't know remapped.\n");
        fprintf(fpCComPlusFile, "#define LONG	long\n\n");
        fprintf(fpCComPlusFile, "#include \"MSProxy.h\"\n");
        fprintf(fpCComPlusFile, "#include \"TComPlus.hxx\"\n\n\n");
    }

#endif    // COMPLUS_SHIM

    // Create the IDL File
    strcpy ( szFileName, szOutputFileRoot );
    strcat ( szFileName, ".idl" );

    fpIDLFile = fopen ( szFileName, "w" );
    if ( !fpIDLFile )
    {
        printf ( szErrorText, "Can't open IDL output file %s\n", szFileName );
        ReportError ( szErrorText );
        goto error;
    }

    // Create the external Header file for the SDK users
    // Create the HDL File
    strcpy ( szFileName, szOutputFileRoot );
    strcat ( szFileName, ".h" );    // For now

    fpHeaderFile = fopen ( szFileName, "w" );
    if ( !fpHeaderFile )
    {
        printf ( szErrorText, "Can't open Header output file %s\n", szFileName );
        ReportError ( szErrorText );
        goto error;
    }

    // Create the external DISPIDs file for the SDK users
    strcpy ( szFileName, szOutputFileRoot );
    strcat ( szFileName, ".dsp" );    // For now

    fpDISPIDFile = fopen ( szFileName, "w" );
    if ( !fpDISPIDFile )
    {
        printf ( szErrorText, "Can't open DISPID output file %s\n", szFileName );
        ReportError ( szErrorText );
        goto error;
    }

    // Create function signatures required for the custom OLEAutomation invoke.
    if ( !LoadSignatures (szOutputPath) )
    {
        ReportError ( "Signature file missing" );
        goto error;
    }

#if COLLECT_STATISTICS==1
    LoadStatistics (szOutputPath);
#endif

    // Parsed Successfully - generate HDL file
    if ( !GenerateHDLFile () )
    {
        printf ( szErrorText, "Can't create HDL output file %s%s.hdl\n",
                 szOutputFileRoot, szFileName );
        ReportError ( szErrorText );

        goto error;
    }

    strcpy ( szFileName, szOutputFileRoot );
    strcat ( szFileName, ".idl" ); // For now hxx
    if ( !GenerateIDLFile( szFileName ) )
    {
        printf ( szErrorText, "Can't create IDL file %s\n", szFileName );
        ReportError ( szErrorText );

        goto error;
    }

    // Generate the .H file with just enums & interface decls in
    GenerateHeaderFile();

    // Generate the external DISPID's file
    GenerateExternalInterfaceDISPIDs();
    GenerateEventDISPIDs ( fpDISPIDFile, FALSE );

    // Create/Open the HTML index file
    strcpy ( szFileName, szOutputPath );
    strcat ( szFileName, FILENAME_SEPARATOR_STR "AllIndex.htm" );
    fpHTMIndexFile = fopen ( szFileName, "a+" );

/* rgardner - commented out for now - not very up-to-date or useful any more
    // Create the HTM File
    strcpy ( szFileName, szOutputFileRoot );
    strcat ( szFileName, ".htm" );

    fpHTMFile = fopen ( szFileName, "w" );

    if ( !GenerateHTMFile( ) )
    {
        printf ( szErrorText, "Can't create HTM file %s\n", szFileName );
        ReportError ( szErrorText );

        goto error;
    }
*/

    // Update the signature file is any changes.
    if (!SaveSignatures( szOutputPath ))
    {
        ReportError ( "Signature file save problem." );
        goto error;
    }

#if COLLECT_STATISTICS==1
    SaveStatistics (szOutputPath);
#endif

    goto cleanup;

error:
    if ( nReturnCode == 0 )
        nReturnCode = 1;

cleanup:
    return nReturnCode;

}


#if COLLECT_STATISTICS==1

void CPDLParser::LoadStatistics ( char *pszOutputPath )
{
    BOOL        bRetVal;
    char       *buffer = NULL;
    CString     szFileName;
    FILE       *fpStatFile = NULL;

    szFileName = pszOutputPath;
    szFileName += FILENAME_SEPARATOR_STR "stats.dat";

    fpStatFile = fopen ( szFileName, "r" );
    if ( !fpStatFile )
    {
        char    chInitFuncSig[2] = { '\0', '\0' };

        fpStatFile = fopen ( szFileName, "w+");
        if ( !fpStatFile )
        {
            ReportError ( "Can't create statistics file" );
            goto error;
        }

        fwrite ( chInitFuncSig, 1, sizeof(chInitFuncSig), fpStatFile );
    }

    if ( fseek( fpStatFile, 0, SEEK_END ) == 0 )
    {
        fpos_t  pos;

        if ( fgetpos( fpStatFile, &pos ) == 0 )
        {
            int     i = 0;
            int     cLines;
            
            buffer = new char[pos];
            if (buffer == NULL)
                goto error;

            fseek( fpStatFile, 0, SEEK_SET );

            if ( fread ( buffer, 1, pos, fpStatFile ) != pos )
                goto error;

            // Intialize to 0.
            for (i = 0; i < MAX_STATS; i++)
                rgcStats[i] = 0;

            // Populate the statics array.
            i = 0;
            cLines = 0;
            while ( buffer[i] || buffer[i + 1] )
            {
                int     cStr = strlen(buffer + i);

                rgcStats[cLines] = atol(buffer + i);

                cLines ++;

                i += cStr + 1;
            }
        }
    }

    bRetVal = TRUE;

cleanup:
    delete buffer;

    fclose ( fpStatFile );

    return;

error:
    bRetVal = FALSE;
    goto cleanup;
}


void CPDLParser::SaveStatistics ( char *pszOutputPath )
{
//DebugBreak();
    BOOL        bRetVal = TRUE;
    if (rgcStats)
    {
        int         i;
        CString     szFileName;
        FILE       *fpStatFile = NULL;
        char        buffer[32];

        szFileName = pszOutputPath;
        szFileName += FILENAME_SEPARATOR_STR "stats.dat";

        fpStatFile = fopen ( szFileName, "w" );

        // Write array to file.
        if ( fseek( fpStatFile, 0, SEEK_SET ) != 0 )
            return;

        i = 0;
        while (i < MAX_STATS)
        {
            sprintf( buffer, "%i", rgcStats[i] );
            fwrite ( buffer, 1, strlen(buffer) + 1, fpStatFile );

            i++;
        }

        // Double NULL at the end.
        buffer[0] = '\0'; 
        buffer[1] = '\0'; 
        fwrite ( &buffer, 1, 2, fpStatFile );

        fclose(fpStatFile);
    }

    return;
}

#endif


void CPDLParser::RemoveSignatures()
{
    if (rgszSignatures)
    {
        int     i = cSignatures;

        while (i--)
            delete [] rgszSignatures[i];

        delete [] rgszSignatures;

        rgszSignatures = NULL;
    }

    if (rgszIIDs)
    {
        int     i = cIIDs;

        while (i--)
            delete [] rgszIIDs[i];

        delete [] rgszIIDs;

        rgszIIDs = NULL;
    }
}


BOOL CPDLParser::LoadSignatures ( char *pszOutputPath )
{
    BOOL        bRetVal;
    char       *buffer = NULL;
    CString     szFileName;
    FILE       *fpSigFile = NULL;

    rgszSignatures = NULL;
    cOnFileSignatures = 0;
    cOnFileIIDs = 0;
    cSignatures = 0;
    cIIDs = 0;

    szFileName = pszOutputPath;
    szFileName += FILENAME_SEPARATOR_STR "funcsig.dat";

/*
if (strcmp(_pszPDLFileName, "select.pdl") == 0 || strcmp(_pszPDLFileName, "header.pdl") == 0)
    __asm { int 3 };
*/

    fpSigFile = fopen ( szFileName, "rb" );
    if ( !fpSigFile )
    {
        char    chInitFuncSig[6] = { '\0', '\0', '\0', '\0', '\0', '\0' };

        fpSigFile = fopen ( szFileName, "w+");
        if ( !fpSigFile )
        {
            ReportError ( "Can't create function signature file" );
            goto error;
        }

        fwrite ( chInitFuncSig, 1, sizeof(chInitFuncSig), fpSigFile );
    }

    if ( fseek( fpSigFile, 0, SEEK_END ) == 0 )
    {
        fpos_t  pos;

        if ( fgetpos( fpSigFile, &pos ) == 0 )
        {
            int     i = 0;
            int     cLines;
            
            buffer = new char[pos];
            if (buffer == NULL)
                goto error;

            fseek( fpSigFile, 0, SEEK_SET );

            fread ( buffer, 1, pos, fpSigFile );

            // Number of entries for each signatures and IIDs
            cOnFileSignatures = buffer[0] & 0x000000ff;      // First byte is # signature
            cOnFileIIDs = buffer[1] & 0x000000ff;            // 2nd byte is # IIDs

            // Pre-allocate the signature array.
            rgszSignatures = new char *[cOnFileSignatures + 1];
            if ( !rgszSignatures )
                goto error;

            // Pre-allocate the IIDs array.
            rgszIIDs = new char *[cOnFileIIDs + 1];
            if ( !rgszIIDs )
                goto error;

            // Intialize to NULL for error handling.
            for (i = 0; i <= cOnFileSignatures; i++)
                rgszSignatures[i] = NULL;

            cSignatures = cOnFileSignatures;

            for (i = 0; i <= cOnFileIIDs; i++)
                rgszIIDs[i] = NULL;

            cIIDs = cOnFileIIDs;

            // Populate the signature array.
            i = 4;
            cLines = 0;
            while ( cLines != cSignatures )
            {
                int     cStr = strlen(buffer + i);

                rgszSignatures[cLines] = new char[cStr + 1];
                if (!rgszSignatures[cLines])
                    goto error;

                strcpy(rgszSignatures[cLines], buffer + i);

                cLines ++;

                i += cStr + 1;
            }

            // Populate the IIDs array.
            cLines = 0;
            while ( cLines != cIIDs )
            {
                int     cStr = strlen(buffer + i);

                rgszIIDs[cLines] = new char[cStr + 1];
                if (!rgszIIDs[cLines])
                    goto error;

                strcpy(rgszIIDs[cLines], buffer + i);

                cLines ++;

                i += cStr + 1;
            }
        }
    }

    bRetVal = TRUE;

cleanup:
    fclose ( fpSigFile );

    return bRetVal;

error:
    delete [] buffer;

    RemoveSignatures();

    bRetVal = FALSE;
    goto cleanup;
}


BOOL CPDLParser::SaveSignatures ( char *pszOutputPath )
{
    if (rgszSignatures || rgszIIDs)
    {
        if (cOnFileSignatures != cSignatures || cOnFileIIDs != cIIDs)
        {
            int         i;
            CString     szFileName;
            FILE       *fpSigFile = NULL;
            char        cHeaderFuncSig[4] = { '\0', '\0', '\0', '\0' };

            szFileName = pszOutputPath;
            szFileName += FILENAME_SEPARATOR_STR "funcsig.dat";

            fpSigFile = fopen ( szFileName, "wb" );

            // Write array to file.
            if ( fseek( fpSigFile, 0, SEEK_SET ) != 0 )
                return FALSE;

            // Write out the header on count of each type.
            cHeaderFuncSig[0] = (char)cSignatures;
            cHeaderFuncSig[1] = (char)cIIDs;
            fwrite ( cHeaderFuncSig, 1, sizeof(cHeaderFuncSig), fpSigFile );

            i = 0;
            while (i < cSignatures)
            {
                if ( rgszSignatures[i] )
                {
                    fwrite ( rgszSignatures[i], 1, strlen(rgszSignatures[i]) + 1, fpSigFile );
                }

                i++;
            }

            i = 0;
            while (i < cIIDs)
            {
                if ( rgszIIDs[i] )
                {
                    fwrite ( rgszIIDs[i], 1, strlen(rgszIIDs[i]) + 1, fpSigFile );
                }

                i++;
            }

            // Write out extra zero to mark end of file.
            cHeaderFuncSig[0] = '\0';
            fwrite ( cHeaderFuncSig, 1, 1, fpSigFile );

            fclose(fpSigFile);
        }

        // Dispose of signature array (IIDs is disposed of too).
        RemoveSignatures();
    }

    return TRUE;
}


void
CPDLParser::MakeSignature (LPCSTR szType, LPCSTR szSignature, CString & szLookup)
{
    char    *szWork;

    // Any empty string for type or signature is an error.
    if (!szType[0] || !szSignature[0])
    {
        return;
    }

    // Replace all * with p (e.g., BSTR * is BSTRP and long * is longP).
    while ((szWork = strchr(szSignature, '*')) != NULL)
        *szWork = 'p';        

    // Replace all ( with P.
    while ((szWork = strchr(szSignature, '(')) != NULL)
        *szWork = 'P';        

    // Replace all ) with P.
    while ((szWork = strchr(szSignature, ')')) != NULL)
        *szWork = 'P';        

    szLookup = szType;
    szLookup += "_";
    szLookup += szSignature;
}


BOOL CPDLParser::FindAndAddSignature ( LPCSTR szType, LPCSTR szSignature, LPSTR pszInvokeMethod )
{
    BOOL        bRetVal = NULL;
    CString     szLookup;
    char      **rgNewArray = NULL;

    if (pszInvokeMethod && rgszSignatures)
    {
        strcpy( pszInvokeMethod,  "ERROR in PDLParse: No custom invoke method");

        MakeSignature(szType, szSignature, szLookup);

        // Look for the signature
        for (int i = 0; i < cSignatures; i++)
        {
            if ( strcmp ( rgszSignatures[i], szLookup ) == 0 )
            {
                goto success;
            }
        }

        // If not found then add this signature.
        cSignatures++;

        rgNewArray = new char *[cSignatures + 1];   // Take into account the NULL at end.
        if (!rgNewArray)
            goto cleanup;

        memcpy(rgNewArray, rgszSignatures, sizeof(char *) * cSignatures);

        rgNewArray[cSignatures - 1] = new char[szLookup.Length() + 1];

        strcpy(rgNewArray[cSignatures - 1], szLookup);

        rgNewArray[cSignatures] = NULL;

        delete rgszSignatures;

        rgszSignatures = rgNewArray;

success:
        strcpy(pszInvokeMethod, "IDX_");
        strcat(pszInvokeMethod, (LPCSTR)szLookup);
        bRetVal = TRUE;
    }

cleanup:
    return bRetVal;
}


int CPDLParser::FindAndAddIIDs ( CString szInterface )
{
    char      **rgNewArray = NULL;

    // Any empty string interface name is an error.
    if (szInterface.Length() == 0)
        return -1;          // Error.

    // Look for the signature
    for (int i = 0; i < cIIDs; i++)
    {
        if ( strcmp ( rgszIIDs[i], (LPCSTR)szInterface ) == 0 )
        {
            goto success;
        }
    }

    // If not found then add this IID.
    cIIDs++;

    rgNewArray = new char *[cIIDs + 1];   // Take into account the NULL at end.
    if (!rgNewArray)
        return -1;

    memcpy(rgNewArray, rgszIIDs, sizeof(char *) * cIIDs);

    rgNewArray[cIIDs - 1] = new char[szInterface.Length() + 1];

    strcpy(rgNewArray[cIIDs - 1], (LPCSTR)szInterface);

    rgNewArray[cIIDs] = NULL;

    delete rgszIIDs;

    rgszIIDs = rgNewArray;

success:
    return i;
}


BOOL CPDLParser::GenerateIDLFile ( char *szFileName )
{
    CTokenListWalker ThisFileList ( pRuntimeList, _pszPDLFileName );
    Token * pInterfaceToken;
    Token * pClassToken;
    Token * pEnumToken;
    Token * pStructToken;
    
    ThisFileList.Reset();
    while ( pInterfaceToken = ThisFileList.GetNext ( TYPE_EVENT ) )
    {
        if ( !pInterfaceToken -> IsSet ( EVENT_ABSTRACT ) &&
            pInterfaceToken -> IsSet ( EVENT_GUID ) )
        {
            GenerateIDLInterfaceDecl ( pInterfaceToken,
                pInterfaceToken -> GetTagValue ( EVENT_GUID ),
                pInterfaceToken -> GetTagValue ( EVENT_SUPER ) );
        }
    }

    ThisFileList.Reset();
    while (pEnumToken = ThisFileList.GetNext(TYPE_ENUM))
    {
        GenerateIncludeEnum(pEnumToken, FALSE, fpIDLFile);
    }
    
    //
    // Generate all the structs
    //

    ThisFileList.Reset();
    while (pStructToken = ThisFileList.GetNext(TYPE_STRUCT))
    {
        GenerateStruct(pStructToken, fpIDLFile);
    }
    
    ThisFileList.Reset();
    while ( pInterfaceToken = ThisFileList.GetNext ( TYPE_INTERFACE ) )
    {
        if ( !pInterfaceToken -> IsSet ( INTERFACE_ABSTRACT ) &&
            pInterfaceToken -> IsSet ( INTERFACE_GUID ) )
        {
            GenerateIDLInterfaceDecl ( pInterfaceToken,
                pInterfaceToken -> GetTagValue ( INTERFACE_GUID ),
                pInterfaceToken -> GetTagValue ( INTERFACE_SUPER ) );
        }
        else  if ( !pInterfaceToken -> IsSet ( INTERFACE_ABSTRACT ) &&
            !pInterfaceToken -> IsSet ( INTERFACE_GUID ) )
        {
            // Generate a forward declare
            CString szInterfaceName;
            
            szInterfaceName = pInterfaceToken -> GetTagValue ( INTERFACE_NAME );
            if ( szInterfaceName != "IDispatch" &&
                szInterfaceName != "IUnknown" )
            {
                fprintf ( fpIDLFile, "interface %s;\n",
                    pInterfaceToken -> GetTagValue ( NAME_TAG ) );
            }
        }
    }

    ThisFileList.Reset();
    while (pClassToken = ThisFileList.GetNext(TYPE_CLASS))
    {
        CTokenListWalker    ChildWalker(pClassToken);
        Token              *pChildToken;
        int                 cImplements = 0;

        // Find out how many implements are in the class.
        while (pChildToken = ChildWalker.GetNext())
        {
            if (pChildToken->GetType() == TYPE_IMPLEMENTS)
            {
                cImplements++;
            }
        }

        // Any class with more than one implements needs a mondodispid to be specified.
        if (pClassToken->IsSet(CLASS_GUID) && cImplements && !pClassToken->IsSet(CLASS_MONDOGUID))
        {
            char szErrorText [ MAX_LINE_LEN+1 ];

            sprintf(szErrorText,
                    "class: %s needs a mondoguid when implements are specified for a coclass.\n",
                    pClassToken->GetTagValue(CLASS_NAME));
            ReportError(szErrorText);
            return FALSE;
        }

        // Generate non-dual dispinterface?  This is determined by the mondoguid
        // keyword being used int the class.  If this guid is specified then
        // we'll generate the mondodisp interface is use it as the default
        // dispatch interface for the coclass.
        if (pClassToken->IsSet(CLASS_MONDOGUID))
        {
            LPSTR   pMondoGUID;
            CString szInterface;

            szInterface = pClassToken->GetTagValue(CLASS_INTERFACE);
            pInterfaceToken = FindInterface(szInterface);
            pMondoGUID = pClassToken->GetTagValue(CLASS_MONDOGUID);

            // If we have a GUID then the dispinterface GUID must be in the
            // range 0x3050f500 to 0x3050f5a0
            if (pMondoGUID[0] != '3' ||
                pMondoGUID[1] != '0' ||
                pMondoGUID[2] != '5' ||
                pMondoGUID[3] != '0' ||
                pMondoGUID[4] != 'f' ||
                pMondoGUID[5] != '5' ||
                !((pMondoGUID[6] >= '0' &&
                   pMondoGUID[6] <= '9') ||
                   pMondoGUID[6] == 'a') ||
                !((pMondoGUID[7] >= '0' &&
                   pMondoGUID[7] <= '9') ||
                   (pMondoGUID[7] >= 'a' &&
                    pMondoGUID[7] <= 'f')))
            {
                char szErrorText [ MAX_LINE_LEN+1 ];

                sprintf(szErrorText,
                        "The mondoguid must be in the range 0x3050f500 to 0x3050f5a0 for class: %s\n",
                        pClassToken->GetTagValue(CLASS_NAME));
                ReportError(szErrorText);
                return FALSE;
            }

            // Generate the default dispinterface
            GenerateIDLInterfaceDecl(pInterfaceToken,
                                     pMondoGUID,
                                     pInterfaceToken->GetTagValue(INTERFACE_SUPER),
                                     TRUE,
                                     pClassToken);
        }

        if ( pClassToken-> IsSet(CLASS_GUID) &&
            pClassToken->IsSet(CLASS_INTERFACE))
        {
            GenerateCoClassDecl(pClassToken);
        }

    }

    return TRUE;
}


void CPDLParser::GenerateIDLInterfaceDecl (Token   *pInterfaceToken,
                                           char    *pszGUID,
                                           char    *pszSuper,
                                           BOOL     fDispInterface/*= FALSE*/,
                                           Token   *pClassToken/*= NULL*/)
{
    BOOL fImplements = FALSE;

    if ( pInterfaceToken -> GetType() == TYPE_EVENT )
    {
        fprintf ( fpIDLFile, "[\n    hidden,\n" );
        fprintf ( fpIDLFile, "    uuid(%s)\n]\ndispinterface %s\n{",
            pszGUID, pInterfaceToken -> GetTagValue ( NAME_TAG ) );
        fprintf ( fpIDLFile, "\nproperties:\nmethods:\n" );
    }
    else
    {
        if (fDispInterface)
        {
            fprintf ( fpIDLFile, "[\n    hidden,\n" );
            fprintf ( fpIDLFile, "    uuid(%s)\n]\ndispinterface Disp%s\n{\nproperties:\nmethods:\n",
                pszGUID,
                pClassToken->IsSet(CLASS_COCLASSNAME) ?
                        pClassToken->GetTagValue(CLASS_COCLASSNAME) :
                        pClassToken->GetTagValue(CLASS_NAME));
        }
        else
        {
            if (!PrimaryTearoff(pInterfaceToken) && (!pszSuper || !*pszSuper))
                ReportError ( "Interfaces w/o tearoff need super:IDispatch\n" );

            if (pInterfaceToken->IsSet(INTERFACE_CUSTOM) && 
                pszSuper && 
                *pszSuper)
            {
                fprintf(fpIDLFile, "[\n    object,\n    pointer_default(unique),\n" );
                fprintf ( fpIDLFile, "    uuid(%s)\n]\ninterface %s : %s\n{\n",
                    pszGUID,
                    pInterfaceToken -> GetTagValue ( NAME_TAG ),
                    pszSuper);
            }
            else
            {
                fprintf ( fpIDLFile, "[\n    odl,\n    oleautomation,\n    dual,\n" );
                fprintf ( fpIDLFile, "    uuid(%s)\n]\ninterface %s : %s\n{\n",
                    pszGUID,
                    pInterfaceToken -> GetTagValue ( NAME_TAG ),
                    (PrimaryTearoff(pInterfaceToken) && _stricmp(pszSuper, "IHTMLDocument")) ? "IDispatch" : pszSuper);
            }
        }
    }

    // Any implements in the class if so then we want the order of the mongo dispinterface to be decided
    // by the order of the implements and not the super chain.
    if (fDispInterface)
    {
        CTokenListWalker    ChildWalker(pClassToken);
        Token              *pChildToken;

        while (pChildToken = ChildWalker.GetNext())
        {
            fImplements = pChildToken->GetType() == TYPE_IMPLEMENTS;
            if (fImplements)
                break;
        }
    }

    // Use the super chain for mongo dispinterface?
    if (!fImplements)
        // Yes.
        GenerateMkTypelibDecl(pInterfaceToken, fDispInterface, pClassToken);

    // Any other interfaces exposed in the coclass which are not part of the
    // primary interface chain?  Look for implements keyword.
    if (fDispInterface)
    {
        CTokenListWalker    ChildWalker(pClassToken);
        Token              *pChildToken;
        CString             szInterface;
        Token              *pInterfToken;

        while (pChildToken = ChildWalker.GetNext())
        {
            if (pChildToken->GetType() == TYPE_IMPLEMENTS)
            {
                szInterface = pChildToken->GetTagValue(IMPLEMENTS_NAME);
                pInterfToken = FindInterface(szInterface);
                if (pInterfToken)
                {
                    GenerateMkTypelibDecl(pInterfToken, fDispInterface, pClassToken);
                }
            }
        }
    }

    fprintf(fpIDLFile, "};\n");
}


void CPDLParser::ComputePropType ( Token *pPropertyToken,
                                   CString &szProp, BOOL fComment )
{
    char szText [ MAX_LINE_LEN+1 ];

    szProp = "";

    // Through the index/indextype & index1/indextype1 pdl tags
    // you can provide up to two additional args for the property definition
    sprintf ( szText, fComment ? "/* [in] */ %s %s" : "[in] %s %s",
        pPropertyToken -> GetTagValue ( PROPERTY_INDEXTYPE ),
        pPropertyToken -> GetTagValue ( PROPERTY_INDEX ) );
    pPropertyToken -> AddParam ( szProp, PROPERTY_INDEX, szText );

    sprintf ( szText, fComment ? "/* [in] */ %s %s" : "[in] %s %s",
        pPropertyToken -> GetTagValue ( PROPERTY_INDEXTYPE1 ),
        pPropertyToken -> GetTagValue ( PROPERTY_INDEX1 ));
    pPropertyToken -> AddParam ( szProp, PROPERTY_INDEX1, szText );

    if ( szProp [ 0 ] != '\0' )
        szProp += ",";
}


void CPDLParser::GenerateMkTypelibDecl ( Token *pInterfaceToken, BOOL fDispInterface/* = FALSE*/, Token *pClass /* =NULL */)
{
    Token *pChildToken;
    Token *pArgToken;
    CString szArg;
    CString szProp;
    CString szAutomationType;
    BOOL fFirst;
    CString szInterfaceName,szMethodName,szPropertyName;

    CTokenListWalker ChildWalker ( pInterfaceToken );

    if ( pInterfaceToken -> GetType() == TYPE_EVENT &&
        pInterfaceToken -> IsSet ( EVENT_SUPER ) )
    {
        CTokenListWalker WholeList(pRuntimeList);

        Token *pSuperEvent = WholeList.GetNext ( TYPE_EVENT,
            pInterfaceToken -> GetTagValue ( EVENT_SUPER ) );
        if ( pSuperEvent )
            GenerateMkTypelibDecl ( pSuperEvent );
    }

    // Special non-dual dispinterface for the default when the primary interface
    // is a tearoff.
    if (fDispInterface)
    {
        Token  *pSuperIntf;
        CString szInterface;

        szInterface = pInterfaceToken->GetTagValue(INTERFACE_SUPER);
        pSuperIntf = FindInterface(szInterface);
        if (pSuperIntf)
            GenerateMkTypelibDecl(pSuperIntf, fDispInterface, pClass);
    }

    szInterfaceName = pInterfaceToken->GetTagValue ( INTERFACE_NAME );
    szInterfaceName.ToUpper();


    while ( pChildToken = ChildWalker.GetNext() )
    {
        if ( pChildToken -> GetType() == TYPE_METHOD )
        {
            // if nopropdesc is set, then this method doesn't
            // participate in the typelib/mondo interface. this happens
            // when the method exists in a base class/interface as well.
            if ( pChildToken->IsSet(METHOD_NOPROPDESC) && fDispInterface)
                continue;

            // Does the property name exist in another interface then the primary
            // interface had better have the override.  Otherwise, it's an error
            // MIDL will not allow overloading names.
            if (fDispInterface && pClass)
            {
                CString szPrimaryInterface;
                Token   *pPriInterf;
                Token   *pExclusiveMember;

                szPrimaryInterface = pClass->GetTagValue(CLASS_INTERFACE);
                pPriInterf = FindInterface(szPrimaryInterface);

                // If working on non-primary interface make sure the method isn't overloaded on
                // the primary, if so it better be marked exclusive.
                if (_strcmpi(szInterfaceName, szPrimaryInterface))
                {
                    pExclusiveMember = FindMethodInInterfaceWOPropDesc(pPriInterf, pChildToken, TRUE);
                    if (pExclusiveMember)
                    {
                        char szErrorText [ MAX_LINE_LEN+1 ];

                        if (pExclusiveMember->IsSet(METHOD_EXCLUSIVETOSCRIPT))
                            continue;

                        // Overloaded method -- illegal.
                        sprintf(szErrorText, "method %s:%s is overloaded - illegal.\n",
                                (LPCSTR)pClass->GetTagValue(CLASS_NAME),
                                (LPCSTR)pExclusiveMember->GetTagValue(METHOD_NAME));
                        ReportError(szErrorText);
                        return;
                    }
                }
            }

            if ( pChildToken -> IsSet ( METHOD_VARARG) )
            {
                fprintf ( fpIDLFile, "    [vararg");
            }
            else
            {
                fprintf ( fpIDLFile, "    [");
            }

            szMethodName = pChildToken -> GetTagValue ( METHOD_NAME );
            if (pChildToken->IsSet(METHOD_NOPROPDESC))
            {
                if (pChildToken->IsSet(METHOD_SZINTERFACEEXPOSE))
                    szMethodName = pChildToken->GetTagValue(METHOD_SZINTERFACEEXPOSE);
            }
            szMethodName.ToUpper();

            if ( pChildToken -> IsSet ( METHOD_DISPID ) )
            {
                fprintf ( fpIDLFile, "%sid(DISPID_%s_%s)",
                    pChildToken -> IsSet ( METHOD_VARARG ) ? "," : "",
                    (LPCSTR)szInterfaceName, (LPCSTR)szMethodName );
            }

            CTokenListWalker ArgListWalker ( pChildToken );

            if (pChildToken->IsSet(METHOD_NOPROPDESC) &&
                pChildToken->IsSet(METHOD_SZINTERFACEEXPOSE))
            {
                szMethodName = pChildToken->GetTagValue(METHOD_SZINTERFACEEXPOSE);
            }
            else
            {
                szMethodName = pChildToken->GetTagValue(METHOD_NAME);
            }

            if (fDispInterface)
            {
                szAutomationType = "void";
                while ( pArgToken = ArgListWalker.GetNext() )
                {
                    if (pArgToken->IsSet(METHODARG_RETURNVALUE))
                    {
                        szAutomationType = pArgToken->IsSet(METHODARG_ATYPE ) ?
                            pArgToken->GetTagValue(METHODARG_ATYPE) :
                            pArgToken->GetTagValue(METHODARG_TYPE);
                    }

                    // If the last character is a pointer then the pointer
                    // should be removed because that is for dual C++ style
                    // interface.  DispInterface doesn't need the retval
                    // specified as a parameter hence the need for
                    // HRESULT funcName(BOOL*) instead of BOOL funcName ().
                    int iSzLength = szAutomationType.Length();
                    if (iSzLength && szAutomationType[iSzLength - 1] == '*')
                    {
                        char    szTypeNoPtr[MAX_LINE_LEN+1];

                        strncpy(szTypeNoPtr, szAutomationType, iSzLength - 1);
                        szTypeNoPtr[iSzLength - 1] = '\0';
                        szAutomationType = szTypeNoPtr;
                    }
                }

                fprintf ( fpIDLFile, "] %s %s(",
                    (LPCSTR)szAutomationType,
                    (LPCSTR)szMethodName );

                ArgListWalker.Reset();
            }
            else
            {
                fprintf ( fpIDLFile, "] %s %s(",
                    pChildToken -> GetTagValue ( METHOD_RETURNTYPE ),
                    (LPCSTR)szMethodName );
            }

            fFirst = TRUE;
            while ( pArgToken = ArgListWalker.GetNext() )
            {
                if (!(fDispInterface && pArgToken->IsSet(METHODARG_RETURNVALUE)))
                {
                    szArg = "";
                    if ( !fFirst )
                        fprintf ( fpIDLFile, "," );

#ifndef WIN16_PARSER
                    pArgToken -> AddParamStr ( szArg, METHODARG_DEFAULTVALUE, "defaultvalue(%s)" );
#endif              
                    pArgToken -> AddParam ( szArg, METHODARG_OPTIONAL, "optional" );
                    pArgToken -> AddParam ( szArg, METHODARG_RETURNVALUE, "retval" );
                    pArgToken -> AddParam ( szArg, METHODARG_IN, "in" );
                    pArgToken -> AddParam ( szArg, METHODARG_OUT, "out" );
                    fprintf ( fpIDLFile, "[%s] %s %s",
                        (LPCSTR)szArg,
                        // Fixing a bug in the old code
                        // Should really get the atype - allow the type if atype not set
                        pArgToken -> IsSet ( METHODARG_ATYPE ) ?
                            pArgToken -> GetTagValue ( METHODARG_ATYPE ) :
                            pArgToken -> GetTagValue ( METHODARG_TYPE ),
                        pArgToken -> GetTagValue ( METHODARG_ARGNAME ) );
                    fFirst = FALSE;
                }
            }
            fprintf ( fpIDLFile, ");\n" );
        }
        else // Property
        {
            ComputePropType ( pChildToken, szProp, FALSE );
            szAutomationType = pChildToken -> GetTagValue ( PROPERTY_ATYPE );

            // if nopropdesc is set, then this property doesn't
            // participate in the typelib/mondo interface. this happens
            // when the property exists in a base class/interface as well.
            if (pChildToken->IsSet(PROPERTY_NOPROPDESC) && fDispInterface)
                continue;

            // Does the property name exist in another interface then the primary
            // interface had better have the override.  Otherwise, it's an error
            // MIDL will not allow overloading names.
            if (fDispInterface && pClass)
            {
                CString szPrimaryInterface;
                Token   *pPriInterf;
                Token   *pExclusiveMember;

                szPrimaryInterface = pClass->GetTagValue(CLASS_INTERFACE);
                pPriInterf = FindInterface(szPrimaryInterface);

                // If working on non-primary interface make sure the property isn't overloaded on
                // the primary, if so it better be marked exclusive.
                if (_strcmpi(szInterfaceName, szPrimaryInterface))
                {
                    pExclusiveMember = FindMethodInInterfaceWOPropDesc(pPriInterf, pChildToken, TRUE);
                    if (pExclusiveMember)
                    {
                        char szErrorText [ MAX_LINE_LEN+1 ];

                        if (pExclusiveMember->IsSet(PROPERTY_EXCLUSIVETOSCRIPT))
                            continue;

                        // Overloaded method -- illegal.
                        sprintf(szErrorText, "property %s:%s is overloaded - illegal.\n",
                                (LPCSTR)pClass->GetTagValue(CLASS_NAME),
                                (LPCSTR)pExclusiveMember->GetTagValue(PROPERTY_NAME));
                        ReportError(szErrorText);
                        return;
                    }
                }
            }

            if ( pChildToken -> IsSet ( PROPERTY_SET ) )
            {
#if COLLECT_STATISTICS==1
    // Collect statistics on total number of property sets.
    CollectStatistic(NUM_SETPROPERTY, GetStatistic(NUM_SETPROPERTY) + 1);
    if (FindEnum ( pChildToken ))
        CollectStatistic(NUM_SETENUMS, GetStatistic(NUM_SETENUMS) + 1);
#endif
                // If it's an object valued property, generate a propputref,
                // otherwise generate a propput
                //
                if ( pChildToken -> IsSet ( PROPERTY_OBJECT ) )
                {
                    szArg = "    [propputref";
                }
                else
                {
                    szArg = "    [propput";
                }
                if ( pChildToken -> IsSet ( PROPERTY_DISPID ) )
                {
                    szArg += ", id(DISPID_";

                    szPropertyName = pChildToken->GetTagValue(PROPERTY_NAME);
                    if (pChildToken->IsSet(PROPERTY_NOPROPDESC))
                    {
                        if (pChildToken->IsSet(PROPERTY_SZINTERFACEEXPOSE))
                            szPropertyName = pChildToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE);
                    }
                    szPropertyName.ToUpper();

                    szArg += (LPCSTR)szInterfaceName;
                    szArg += "_";
                    szArg += (LPCSTR)szPropertyName;
                    szArg += ")";
                }

                pChildToken -> AddParam ( szArg, PROPERTY_DISPLAYBIND, "displaybind" );
                pChildToken -> AddParam ( szArg, PROPERTY_BINDABLE, "bindable" );
                pChildToken -> AddParam ( szArg, PROPERTY_HIDDEN, "hidden" );
                pChildToken -> AddParam ( szArg, PROPERTY_RESTRICTED, "restricted" );
#ifndef WIN16_PARSER
                pChildToken -> AddParam ( szArg, PROPERTY_NONBROWSABLE, "nonbrowsable" );
#endif                
                pChildToken -> AddParam ( szArg, PROPERTY_SOURCE, "source" );

                if (pChildToken->IsSet(PROPERTY_NOPROPDESC) &&
                    pChildToken->IsSet(PROPERTY_SZINTERFACEEXPOSE))
                {
                    szPropertyName = pChildToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE);
                }
                else
                {
                    szPropertyName = pChildToken->GetTagValue(PROPERTY_NAME);
                }

                if (fDispInterface)
                {
                    fprintf ( fpIDLFile, "%s] void %s(%s%s v);\n",
                        (LPCSTR)szArg, (LPCSTR)szPropertyName,
                        (LPCSTR)szProp, (LPCSTR)szAutomationType );
                }
                else
                {
                    fprintf ( fpIDLFile, "%s] HRESULT %s(%s[in] %s v);\n",
                        (LPCSTR)szArg, (LPCSTR)szPropertyName,
                        (LPCSTR)szProp, (LPCSTR)szAutomationType );
                }
            }

            if ( pChildToken -> IsSet ( PROPERTY_GET ) )
            {
#if COLLECT_STATISTICS==1
    // Collect statistics on total number of property sets.
    CollectStatistic(NUM_GETPROPERTY, GetStatistic(NUM_GETPROPERTY) + 1);
    if (FindEnum ( pChildToken ))
        CollectStatistic(NUM_GETENUMS, GetStatistic(NUM_GETENUMS) + 1);
#endif
                szArg = "    [propget";
                    szArg += ", id(DISPID_";

                    szPropertyName = pChildToken->GetTagValue(PROPERTY_NAME);
                    if (pChildToken->IsSet(PROPERTY_NOPROPDESC))
                    {
                        if (pChildToken->IsSet(PROPERTY_SZINTERFACEEXPOSE))
                            szPropertyName = pChildToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE);
                    }
                    szPropertyName.ToUpper();

                    szArg += (LPCSTR)szInterfaceName;
                    szArg += "_";
                    szArg += (LPCSTR)szPropertyName;
                    szArg += ")";
                pChildToken -> AddParam ( szArg, PROPERTY_DISPLAYBIND, "displaybind" );
                pChildToken -> AddParam ( szArg, PROPERTY_BINDABLE, "bindable" );
                pChildToken -> AddParam ( szArg, PROPERTY_HIDDEN, "hidden" );
                pChildToken -> AddParam ( szArg, PROPERTY_RESTRICTED, "restricted" );
#ifndef WIN16_PARSER
                pChildToken -> AddParam ( szArg, PROPERTY_NONBROWSABLE, "nonbrowsable" );
#endif                
                pChildToken -> AddParam ( szArg, PROPERTY_SOURCE, "source" );

                if (pChildToken->IsSet(PROPERTY_NOPROPDESC) &&
                    pChildToken->IsSet(PROPERTY_SZINTERFACEEXPOSE))
                {
                    szPropertyName = pChildToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE);
                }
                else
                {
                    szPropertyName = pChildToken->GetTagValue(PROPERTY_NAME);
                }

                if (fDispInterface)
                {
                    fprintf ( fpIDLFile, "%s] %s %s();\n",
                        (LPCSTR)szArg,
                        (LPCSTR)szAutomationType,
                        (LPCSTR)szPropertyName);
                }
                else
                {
                    fprintf ( fpIDLFile, "%s] HRESULT %s(%s[retval, out] %s * p);\n",
                        (LPCSTR)szArg, (LPCSTR)szPropertyName,
                        (LPCSTR)szProp, (LPCSTR)szAutomationType );
                }
            }

        }
    }
}


void CPDLParser::GenerateMidlInterfaceDecl ( Token *pInterfaceToken, char *pszGUID,
    char *pszSuper )
{
    Token *pChildToken;
    Token *pArgToken;
    CString szArg;
    CString szProp;
    BOOL fFirst;

    if ( pInterfaceToken -> GetType() == TYPE_EVENT )
        return;

    fprintf ( fpIDLFile,  "[\n    local,\n    object,\n    pointer_default(unique),\n"  );
    fprintf ( fpIDLFile,  "    uuid(%s)\n]\ninterface %s : %s\n{\n",
        pInterfaceToken -> GetTagValue ( INTERFACE_GUID ),
        pInterfaceToken -> GetTagValue ( INTERFACE_NAME ),
        pInterfaceToken -> GetTagValue ( INTERFACE_SUPER ) );

    CTokenListWalker ChildWalker ( pInterfaceToken );

    while ( pChildToken = ChildWalker.GetNext() )
    {
        if ( pChildToken -> GetType() == TYPE_METHOD )
        {
            fprintf ( fpIDLFile, "    %s %s(",
                pChildToken -> GetTagValue ( METHOD_RETURNTYPE ),
                pChildToken -> GetTagValue ( METHOD_NAME ) );

            fFirst = TRUE;

            CTokenListWalker ArgListWalker ( pChildToken );
            while ( pArgToken = ArgListWalker.GetNext() )
            {
                szArg = "";
                if ( !fFirst )
                    fprintf ( fpIDLFile, "," );
                pArgToken -> AddParam ( szArg, METHODARG_IN, "in" );
                pArgToken -> AddParam ( szArg, METHODARG_OUT, "out" );
                fprintf ( fpIDLFile, "[%s] %s %s", (LPCSTR)szArg,
                    // Fixing a bug in the old code
                    // Should realy get the atype - allow the type if atype not set
                    pArgToken -> IsSet ( METHODARG_ATYPE ) ?
                        pArgToken -> GetTagValue ( METHODARG_ATYPE ) :
                        pArgToken -> GetTagValue ( METHODARG_TYPE ),
                    pArgToken -> GetTagValue ( METHODARG_ARGNAME ) );
                fFirst = FALSE;
            }
            fprintf ( fpIDLFile, ");\n" );
        }
        else
        {
            // Property
            ComputePropType ( pChildToken, szProp, FALSE );

            if ( pChildToken -> IsSet ( PROPERTY_SET ))
            {
                fprintf ( fpIDLFile, "    HRESULT put_%s(%s [in] %s v);\n",
                    (LPCSTR)pChildToken -> GetTagValue ( PROPERTY_NAME ),
                    (LPCSTR)szProp,
                    pChildToken -> GetTagValue ( PROPERTY_ATYPE) );
            }

            if ( pChildToken -> IsSet ( PROPERTY_GET ))
            {
                fprintf ( fpIDLFile,
                    "    HRESULT get_%s(%s[out] %s * p);\n",
                        pChildToken -> GetTagValue ( PROPERTY_NAME ),
                        (LPCSTR)szProp,
                        pChildToken -> GetTagValue ( PROPERTY_ATYPE));
            }
        }
    }
    fprintf ( fpIDLFile, "}\n" );
}

BOOL CPDLParser::HasMondoDispInterface ( Token *pClassToken )
{
    CTokenListWalker    ChildWalker(pClassToken);
    Token              *pChildToken;
    int                 cImplements = 0;

    // Find out how many implements are in the class.
    while (pChildToken = ChildWalker.GetNext())
    {
        if (pChildToken->GetType() == TYPE_IMPLEMENTS)
        {
            cImplements++;
        }
    }

    // Any class with more than one implements a guid and a mondoguid will have
    // a mondo dispinterface.
    return (pClassToken->IsSet(CLASS_GUID) && cImplements && pClassToken->IsSet(CLASS_MONDOGUID));
}


void CPDLParser::GenerateCoClassDecl ( Token *pClassToken )
{
    CString     szName;
    CString     szDispName;
    CString     szInterfSuper;
    BOOL        fHasMondoDispInterface;
    BOOL        fElement = FALSE;

    if (pClassToken->IsSet(CLASS_COCLASSNAME))
        szName = pClassToken->GetTagValue(CLASS_COCLASSNAME);
    else
        szName = pClassToken->GetTagValue(CLASS_NAME);

    fprintf(fpIDLFile, "[\n    %suuid(%s)\n]\n",
            pClassToken->IsSet(CLASS_CONTROL) ? "control,\n    " : "",
            pClassToken->GetTagValue(CLASS_GUID));
    fprintf(fpIDLFile, "coclass %s\n{\n", (LPCSTR)szName );

    fHasMondoDispInterface = HasMondoDispInterface(pClassToken);

    if (fHasMondoDispInterface)
    {
        // Map to mondo dispinterface as default dispatch interface.
        szDispName = (pClassToken->IsSet(CLASS_COCLASSNAME)) ?
                        pClassToken->GetTagValue (CLASS_COCLASSNAME) :
                        pClassToken->GetTagValue(CLASS_NAME);
    }
    else
    {
        // Map to the primary interface as default dispatch interface.
        szDispName = pClassToken->GetTagValue(CLASS_INTERFACE);
    }

    fprintf(fpIDLFile, "    [default]           %sinterface %s%s;\n",
            fHasMondoDispInterface ? "disp" : "",
            fHasMondoDispInterface ? "Disp" : "",
            (LPCSTR)szDispName);

    if (pClassToken->IsSet(CLASS_EVENTS))
    {
        fprintf(fpIDLFile, "    [source, default]   dispinterface %s;\n",
                pClassToken->GetTagValue(CLASS_EVENTS));
    }

    if (pClassToken->IsSet(CLASS_NONPRIMARYEVENTS1))
    {
        fprintf(fpIDLFile, "    [source]            dispinterface %s;\n",
                pClassToken->GetTagValue(CLASS_NONPRIMARYEVENTS1));
    }
    if (pClassToken->IsSet(CLASS_NONPRIMARYEVENTS2))
    {
        fprintf(fpIDLFile, "    [source]            dispinterface %s;\n",
                pClassToken->GetTagValue(CLASS_NONPRIMARYEVENTS2));
    }
    if (pClassToken->IsSet(CLASS_NONPRIMARYEVENTS3))
    {
        fprintf(fpIDLFile, "    [source]            dispinterface %s;\n",
                pClassToken->GetTagValue(CLASS_NONPRIMARYEVENTS3));
    }
    if (pClassToken->IsSet(CLASS_NONPRIMARYEVENTS4))
    {
        fprintf(fpIDLFile, "    [source]            dispinterface %s;\n",
                pClassToken->GetTagValue(CLASS_NONPRIMARYEVENTS4));
    }

    // Any other interface to expose in the coclass which is part of the primary
    // interface?
    CTokenListWalker    ChildWalker(pClassToken);
    Token              *pChildToken;

    while (pChildToken = ChildWalker.GetNext())
    {
        if (pChildToken->GetType() == TYPE_IMPLEMENTS)
        {
            Token      *pInterf;
            CString     szInterface;

            if (!fElement)
                fElement = !_stricmp((LPSTR)pChildToken->GetTagValue(IMPLEMENTS_NAME), "IHTMLElement");

            szInterface = pChildToken->GetTagValue(IMPLEMENTS_NAME);
            pInterf = FindInterface(szInterface);
            if (pInterf)
            {
                // Is the interface a local one if not then don't check, we
                // only need to check where interfaces are actually used.
                if (FindInterfaceLocally(szInterface))
                {
                    // If the super isn't specified and it's not a primary interface
                    // then error the super is required for non-primary interfaces.
                    if (_stricmp((LPSTR)pClassToken->GetTagValue(CLASS_INTERFACE),
                                 (LPSTR)pInterf->GetTagValue(INTERFACE_NAME)) &&
                        !pInterf->IsSet(INTERFACE_SUPER) &&
                        !IsPrimaryInterface(szInterface))
                    {
                        char szErrorText [ MAX_LINE_LEN+1 ];

                        sprintf(szErrorText, "Interface %s missing super key.\n",
                                (LPSTR)pInterf->GetTagValue(INTERFACE_NAME));
                        ReportError(szErrorText);

                        return;
                    }
                }

                fprintf(fpIDLFile, "                        interface %s;\n",
                        (LPCSTR)pInterf->GetTagValue(INTERFACE_NAME));
            }
        }
    }

    fprintf(fpIDLFile, "};\n");

    fprintf(fpIDLFile, "cpp_quote(\"EXTERN_C const GUID CLSID_%s;\")\n",
            pClassToken->GetTagValue(CLASS_NAME));

    if (!pClassToken->IsSet(CLASS_EVENTS) && fElement)
    {
        char szErrorText [ MAX_LINE_LEN+1 ];
        sprintf(szErrorText, "Class %s missing events key.\n", pClassToken->GetTagValue(CLASS_NAME));
        ReportError(szErrorText);
        return;
    }
}



void CPDLParser::GenerateEnumDescIDL ( Token *pEnumToken )
{
    Token *pEvalToken;
    CString szName;

    fprintf ( fpIDLFile, "\ntypedef [uuid(%s)] enum _%s {\n" ,
        pEnumToken -> GetTagValue ( ENUM_GUID ),
        pEnumToken -> GetTagValue ( ENUM_NAME ) );

    CTokenListWalker EvalChildList ( pEnumToken );

    while ( pEvalToken = EvalChildList.GetNext() )
    {
        if ( pEvalToken -> IsSet ( EVAL_ODLNAME ) )
        {
            szName = pEvalToken -> GetTagValue ( EVAL_ODLNAME );
        }
        else
        {
            szName = pEnumToken -> GetTagValue ( ENUM_NAME );
            szName += pEvalToken -> GetTagValue ( EVAL_NAME );
        }
        fprintf ( fpIDLFile, "    [helpstring(\"%s\")] %s = %s,\n",
            pEvalToken -> IsSet ( EVAL_STRING ) ?
                pEvalToken -> GetTagValue ( EVAL_STRING ) :
                pEvalToken -> GetTagValue ( EVAL_NAME ),
            (LPCSTR)szName,
            pEvalToken -> GetTagValue ( EVAL_VALUE ) );
    }
    fprintf ( fpIDLFile, "}%s;\n",
        pEnumToken -> GetTagValue ( ENUM_NAME ) );

}


void CPDLParser::ReportError ( LPCSTR szErrorString )
{
    printf ( "%s(0) : error PDL0000: %s", _pszPDLFileName, szErrorString);
    fprintf ( fpLOGFile, "%s(0) : error PDL0000: %s", _pszPDLFileName, szErrorString );
}

void CPDLParser::GenerateHeaderFile ( void )
{
    CTokenListWalker ThisFileList ( pRuntimeList, _pszPDLFileName );
    Token *pImportToken;
    Token *pInterfaceToken;
    Token *pClassToken;
    Token *pEnumToken;
    Token *pStructToken;
    char *pStr;
    CString szCoClassName;
    char szName [ MAX_LINE_LEN+1 ];
    CString szInterfaceName;

    strcpy ( szName, _pszPDLFileName );
    pStr = strstr ( szName, "." );
    if ( pStr )
        *pStr = '\0';
    _strlwr ( szName );


    fprintf ( fpHeaderFile, "#ifndef __%s_h__\n", szName );
    fprintf ( fpHeaderFile, "#define __%s_h__\n\n", szName );

    fprintf ( fpHeaderFile, "/* Forward Declarations */\n" );

    fprintf ( fpHeaderFile, "\nstruct ENUMDESC;\n" );
    // For each import, generate a .h include
    while ( pImportToken = ThisFileList.GetNext ( TYPE_IMPORT ) )
    {
        fprintf ( fpHeaderFile, "\n/* header files for imported files */\n" );
        GenerateIncludeStatement ( pImportToken );
    }

    ThisFileList.Reset();

    // Forward define all the interfaces so we can have defined them in any order
    while ( pInterfaceToken = ThisFileList.GetNext ( TYPE_INTERFACE ) )
    {
        szInterfaceName = pInterfaceToken -> GetTagValue ( INTERFACE_NAME );
        if ( szInterfaceName != "IDispatch" &&
            szInterfaceName != "IUnknown" )
        {
            fprintf ( fpHeaderFile, "\n#ifndef __%s_FWD_DEFINED__\n",
                pInterfaceToken -> GetTagValue ( INTERFACE_NAME ) );
            fprintf ( fpHeaderFile, "#define __%s_FWD_DEFINED__\n",
                pInterfaceToken -> GetTagValue ( INTERFACE_NAME ) );
            fprintf ( fpHeaderFile, "typedef interface %s %s;\n",
                pInterfaceToken -> GetTagValue ( INTERFACE_NAME ),
                pInterfaceToken -> GetTagValue ( INTERFACE_NAME ) ) ;
            fprintf ( fpHeaderFile, "#endif     /* __%s_FWD_DEFINED__ */\n",
                pInterfaceToken -> GetTagValue ( INTERFACE_NAME ) );
        }
    }   

    //
    // Generate all the enums
    //
    
    ThisFileList.Reset();
    while ( pEnumToken = ThisFileList.GetNext ( TYPE_ENUM ) )
    {
        GenerateIncludeEnum(pEnumToken, TRUE);
    }

    //
    // Generate all the structs
    //

    ThisFileList.Reset();
    while (pStructToken = ThisFileList.GetNext(TYPE_STRUCT))
    {
        GenerateStruct(pStructToken, fpHeaderFile);
    }


    ThisFileList.Reset();

    // For each interface generate an extern for the GUID &
    // an interface decl
    while ( pInterfaceToken = ThisFileList.GetNext ( TYPE_INTERFACE ) )
    {
        szInterfaceName = pInterfaceToken -> GetTagValue ( INTERFACE_NAME );
        if ( szInterfaceName != "IDispatch" &&
            szInterfaceName != "IUnknown" &&
            !pInterfaceToken -> IsSet ( INTERFACE_ABSTRACT ) && 
            pInterfaceToken -> IsSet ( INTERFACE_GUID ) )
        {
            GenerateIncludeInterface ( pInterfaceToken );
        }
    }

    ThisFileList.Reset();

    // For each class with a GUID, generate a GUID ref
    while ( pClassToken = ThisFileList.GetNext ( TYPE_CLASS ) )
    {
        if ( pClassToken -> IsSet ( CLASS_GUID ) &&
            !pClassToken -> IsSet ( CLASS_ABSTRACT ) )
        {
            pClassToken -> GetTagValueOrDefault ( szCoClassName,
                CLASS_COCLASSNAME, pClassToken -> GetTagValue ( CLASS_NAME ) );
            fprintf ( fpHeaderFile, "\n\nEXTERN_C const GUID GUID_%s;\n\n",
                pClassToken -> GetTagValue ( CLASS_COCLASSNAME ) );

            if ( HasMondoDispInterface ( pClassToken ) )
            {
                CString szDispName;

                // Map to mondo dispinterface as default dispatch interface.
                szDispName = (pClassToken->IsSet(CLASS_COCLASSNAME)) ?
                                pClassToken->GetTagValue (CLASS_COCLASSNAME) :
                                pClassToken->GetTagValue(CLASS_NAME);
                fprintf(fpHeaderFile, "\n\nEXTERN_C const GUID DIID_Disp%s;\n\n",
                        (LPCSTR)szDispName);
            }
        }
        // Also generate extern definitions for all propdescs in this file
        GeneratePropdescExtern ( pClassToken, FALSE /* Don't recurse */ );

    }



    fprintf ( fpHeaderFile, "\n\n#endif /*__%s_h__*/\n\n", szName );

}

void  CPDLParser::GenerateIncludeStatement ( Token *pImportToken )
{
    char szText [ MAX_LINE_LEN+1 ];
    char *pStr;

    strcpy ( szText, pImportToken -> GetTagValue ( IMPORT_NAME ) );

    if ( pStr = strstr ( szText, "." ) )
    {
        strcpy ( pStr, ".h" );
    }
    else
    {
        strcat ( szText, ".h" );
    }
    fprintf ( fpHeaderFile, "#include \"%s\"\n", szText );
}

void  CPDLParser::GenerateIncludeInterface ( Token *pInterfaceToken )
{
    // Only generate the C++ Form
    Token *pChildToken;
    Token *pArgToken;
    CString szArg;
    CString szProp;
    BOOL fFirst;
    CString szSuper;
    
    if ( pInterfaceToken -> GetType() == TYPE_EVENT )
        return;


    fprintf ( fpHeaderFile, "\n#ifndef __%s_INTERFACE_DEFINED__\n",
        pInterfaceToken -> GetTagValue ( INTERFACE_NAME ) );
    fprintf ( fpHeaderFile, "\n#define __%s_INTERFACE_DEFINED__\n",
        pInterfaceToken -> GetTagValue ( INTERFACE_NAME ) );


    fprintf ( fpHeaderFile,  "\nEXTERN_C const IID IID_%s;\n\n",
        pInterfaceToken -> GetTagValue ( INTERFACE_NAME ) );

    if (pInterfaceToken->IsSet(INTERFACE_CUSTOM) ||
        !PrimaryTearoff(pInterfaceToken) ||
        !_stricmp((LPCSTR)pInterfaceToken->GetTagValue(INTERFACE_NAME), "IHTMLDocument2"))
    {
        szSuper = pInterfaceToken->GetTagValue(INTERFACE_SUPER);
    }
    
    fprintf(fpHeaderFile, "\nMIDL_INTERFACE(\"%s\")\n%s : public %s\n{\npublic:\n",
        pInterfaceToken->GetTagValue(INTERFACE_GUID),
        pInterfaceToken->GetTagValue(INTERFACE_NAME),
        ((LPCSTR)szSuper && *(LPCSTR)szSuper) ? (LPCSTR)szSuper : "IDispatch");

    CTokenListWalker ChildWalker ( pInterfaceToken );

    while ( pChildToken = ChildWalker.GetNext() )
    {
        if ( pChildToken -> GetType() == TYPE_METHOD )
        {
            fprintf ( fpHeaderFile, "    virtual %s STDMETHODCALLTYPE %s(\n            ",
                pChildToken -> GetTagValue ( METHOD_RETURNTYPE ),
                   pChildToken->IsSet(METHOD_SZINTERFACEEXPOSE) ?
                    pChildToken->GetTagValue(METHOD_SZINTERFACEEXPOSE) :
                    pChildToken->GetTagValue(METHOD_NAME));

            fFirst = TRUE;

            CTokenListWalker ArgListWalker ( pChildToken );
            while ( pArgToken = ArgListWalker.GetNext() )
            {
                if ( !fFirst )
                    fprintf ( fpHeaderFile, "," );
                szArg = "";
                pArgToken -> AddParam ( szArg, METHODARG_IN, "in" );
                pArgToken -> AddParam ( szArg, METHODARG_OUT, "out" );

                fprintf ( fpHeaderFile, "/* [%s] */ %s %s", (LPCSTR)szArg,
                    // Fixing a bug in the old code
                    // Should realy get the atype - allow the type if atype not set
                    ConvertType(pArgToken -> IsSet ( METHODARG_ATYPE ) ?
                        pArgToken -> GetTagValue ( METHODARG_ATYPE ) :
                        pArgToken -> GetTagValue ( METHODARG_TYPE )),
                    pArgToken -> GetTagValue ( METHODARG_ARGNAME ) );
                fFirst = FALSE;
            }
            fprintf ( fpHeaderFile, ") = 0;\n\n" );
        }
        else
        {
            // Property
            ComputePropType(pChildToken, szProp, TRUE);

            if ( pChildToken -> IsSet ( PROPERTY_SET ))
            {
                fprintf ( fpHeaderFile, "    virtual HRESULT STDMETHODCALLTYPE put_%s(\n        %s /* [in] */ %s v) = 0;\n\n",
                   	pChildToken->IsSet(PROPERTY_SZINTERFACEEXPOSE) ?
                            (LPSTR)pChildToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE) :
                            (LPSTR)pChildToken->GetTagValue(PROPERTY_NAME),
                    (LPCSTR)szProp,
                    pChildToken -> GetTagValue ( PROPERTY_ATYPE));

            }

            if ( pChildToken -> IsSet ( PROPERTY_GET ))
            {
                fprintf ( fpHeaderFile,
                    "    virtual HRESULT STDMETHODCALLTYPE get_%s(\n        %s /* [out] */ %s * p) = 0;\n\n",
                           pChildToken->IsSet(PROPERTY_SZINTERFACEEXPOSE) ?
                            (LPSTR)pChildToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE) :
                            (LPSTR)pChildToken->GetTagValue(PROPERTY_NAME),
                        (LPCSTR)szProp,
                        pChildToken -> GetTagValue ( PROPERTY_ATYPE) );
            }
        }
    }
    fprintf ( fpHeaderFile, "};\n\n" );
    fprintf ( fpHeaderFile, "#endif     /* __%s_INTERFACE_DEFINED__ */\n\n",
        pInterfaceToken -> GetTagValue ( INTERFACE_NAME ) );
}

void CPDLParser::GenerateIncludeEnum(
    Token *pEnumToken, BOOL fSpitExtern, FILE *pFile)
{
    Token *pEvalToken;

    if (!pFile)
    {
        pFile = fpHeaderFile;
    }
    
    fprintf(pFile, "typedef enum _%s\n{\n" ,
        pEnumToken -> GetTagValue ( ENUM_NAME ) );

    CTokenListWalker EvalChildList ( pEnumToken );

    while ( pEvalToken = EvalChildList.GetNext() )
    {
        fprintf(pFile, "    %s%s = %s,\n",
            pEnumToken -> GetTagValue(ENUM_PREFIX),
            pEvalToken -> GetTagValue(EVAL_NAME),
            pEvalToken -> GetTagValue(EVAL_VALUE));
    }
    //  Add an _Max for the MAC build - apparently the mac needs
    // this to indicate that it's an integer
    fprintf(pFile, "    %s_Max = 2147483647L\n",
        pEnumToken -> GetTagValue ( ENUM_NAME ) );
    fprintf(pFile, "} %s;\n\n",
        pEnumToken -> GetTagValue ( ENUM_NAME ) );

    if (fSpitExtern)
    {
        // Generate an EXTERN from the enum descriptor so other hdls only have to include
        // the .h file.
        fprintf(pFile, "\nEXTERN_C const ENUMDESC s_enumdesc%s;\n\n",
            pEnumToken->GetTagValue ( ENUM_NAME ) );
    }
}


void 
CPDLParser::GenerateStruct(Token *pStructToken, FILE *pFile)
{
    Token *pMemberToken;

    fprintf(pFile, "typedef struct _%s\n{\n" ,
        pStructToken->GetTagValue(STRUCT_NAME));

    CTokenListWalker ChildList(pStructToken);

    while (pMemberToken = ChildList.GetNext())
    {
        fprintf(pFile, "    %s %s;\n",
            pMemberToken->GetTagValue(STRUCTMEMBER_TYPE),
            pMemberToken->GetTagValue(STRUCTMEMBER_NAME));
    }
    fprintf(pFile, "} %s;\n\n",
        pStructToken->GetTagValue(STRUCT_NAME));
}


BOOL CPDLParser::AddType ( LPCSTR szTypeName, LPCSTR szHandler )
{
    Token *pTypeToken = pDynamicTypeList->AddNewToken ( (DESCRIPTOR_TYPE)TYPE_DATATYPE );
    if ( pTypeToken == NULL )
        return FALSE;
    if ( !pTypeToken->AddTag ( DATATYPE_NAME, szTypeName ) )
        return FALSE;
    return pTypeToken->AddTag ( DATATYPE_HANDLER, szHandler );
}

BOOL CPDLParser::AddEventType ( LPCSTR szTypeName, LPCSTR szVTSType )
{
    Token *pTypeToken = pDynamicEventTypeList->AddNewToken ( (DESCRIPTOR_TYPE)TYPE_DATATYPE );
    if ( pTypeToken == NULL )
        return FALSE;
    if ( !pTypeToken->AddTag ( DATATYPE_NAME, szTypeName ) )
        return FALSE;
    return pTypeToken->AddTag ( DATATYPE_HANDLER, szVTSType );
}


BOOL CPDLParser::LookupType ( LPCSTR szTypeName, CString &szIntoString,
    CString &szFnPrefix, StorageType *pStorageType /* = NULL */ )
{
    Token *pTypeToken;
    UINT uIndex;
    // Look in the static array first
    if ( ( uIndex = szIntoString.Lookup ( DataTypes, szTypeName ) ) != (UINT)-1 )
    {
        if ( pStorageType )
        {
            *pStorageType = DataTypes [ uIndex ].stStorageType;
            szFnPrefix = DataTypes [ uIndex ].szMethodFnPrefix;
        }
        return TRUE;
    }

    // Look finaly in the dynamic array
    CTokenListWalker TypeList ( pDynamicTypeList );
    if ( pTypeToken = TypeList.GetNext ( (DESCRIPTOR_TYPE)TYPE_DATATYPE, szTypeName ) )
    {
        szIntoString = pTypeToken->GetTagValue ( DATATYPE_HANDLER );
        if ( pStorageType )
        {
            // In the dynamic array are either enums iface ptrs or class ptrs
            // All can be stored in a DWORD, so ...
            *pStorageType = STORAGETYPE_NUMBER;
        }
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

BOOL CPDLParser::LookupEventType ( CString &szIntoString, LPCSTR szTypeName )
{
    Token *pTypeToken;
    // Look in the static array first
    if ( szIntoString.Lookup ( vt, szTypeName ) != (UINT)-1 )
    {
        return TRUE;
    }
    // Look finaly in the dynamic array
    CTokenListWalker TypeList ( pDynamicEventTypeList );
    if ( pTypeToken = TypeList.GetNext ( (DESCRIPTOR_TYPE)TYPE_DATATYPE, szTypeName ) )
    {
        szIntoString = pTypeToken->GetTagValue ( DATATYPE_HANDLER );
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

UINT uProps [] =
{
    PROPERTY_MEMBER,
    PROPERTY_ABSTRACT,
    PROPERTY_GETSETMETHODS,
    PROPERTY_CAA,
    PROPERTY_SUBOBJECT
};

// Legal combinations of properties
static struct
{
    UINT uID1;
    UINT uID2;
    UINT uID3;
    UINT uMask;
} PropertyCheck [] =
{
    { PROPERTY_MEMBER, (UINT)-1,(UINT)-1 },
    { PROPERTY_SUBOBJECT, (UINT)-1 ,(UINT)-1 },
    { PROPERTY_SUBOBJECT, PROPERTY_MEMBER,(UINT)-1 },
    { PROPERTY_GETSETMETHODS, (UINT)-1,(UINT)-1 },
    { PROPERTY_ABSTRACT,  (UINT)-1,(UINT)-1},
    { PROPERTY_CAA, (UINT)-1,(UINT)-1 },
    { PROPERTY_SUBOBJECT, PROPERTY_CAA,(UINT)-1 },
};


void CPDLParser::Init ( void )
{
    UINT i,j;
    for ( i = 0 ; i < ARRAY_SIZE ( PropertyCheck ) ; i++ )
    {
        PropertyCheck [ i ].uMask = 0;
        for ( j = 0 ; j < ARRAY_SIZE ( uProps ) ; j++ )
        {
            if ( PropertyCheck [ i ].uID1 == uProps [ j ] )
            {
                PropertyCheck [ i ].uMask |= 1<<j;
            }
            else if ( PropertyCheck [ i ].uID2 == uProps [ j ] )
            {
                PropertyCheck [ i ].uMask |= 1<<j;
            }
            else if ( PropertyCheck [ i ].uID3 == uProps [ j ] )
            {
                PropertyCheck [ i ].uMask |= 1<<j;
            }
        }
    }
}

BOOL CPDLParser::PatchPropertyTypes ( void )
{
    // For each property declaration, set the object flag if the
    // Handler for the type is object
    CTokenListWalker WholeList ( pRuntimeList );
    Token *pToken;
    Token *pChildToken;
    CString szHandler;
    CString szFnPrefix;
    CString szAType;
    CString szName;
    BOOL fMatched;
    char szErrorText [ MAX_LINE_LEN+1 ];
    UINT i;
    UINT uMask;

    while ( pToken = WholeList.GetNext() )
    {
        if ( pToken -> GetType() == TYPE_EVENT ||
            pToken -> GetType() == TYPE_CLASS ||
            pToken -> GetType() == TYPE_INTERFACE )
        {
            if ( pToken -> GetType() == TYPE_CLASS )
            {
                // Has it got a super, if so is it referenced
                if ( pToken -> IsSet ( CLASS_SUPER ) )
                {
                    CTokenListWalker AllList ( pRuntimeList );
                    if ( !AllList.GetNext ( TYPE_CLASS, pToken -> GetTagValue ( CLASS_SUPER ) ) )
                    {
                        sprintf ( szErrorText, "Class %s References unknown super:%s\n",
                            (LPCSTR)pToken->GetTagValue ( CLASS_NAME ),
                            (LPCSTR)pToken->GetTagValue ( CLASS_SUPER ) );
                        ReportError ( szErrorText );
                        return FALSE;
                    }
                }
                if ( pToken -> IsSet ( CLASS_INTERFACE ) )
                {
                    CTokenListWalker AllList ( pRuntimeList );
                    if ( !AllList.GetNext ( TYPE_INTERFACE, pToken -> GetTagValue ( CLASS_INTERFACE ) ) )
                    {
                        sprintf ( szErrorText, "Class %s References unknown interface:%s\n",
                            (LPCSTR)pToken->GetTagValue ( CLASS_NAME ),
                            (LPCSTR)pToken->GetTagValue ( CLASS_INTERFACE ) );
                        ReportError ( szErrorText );
                        return FALSE;
                    }
                }
                if ( pToken -> IsSet ( CLASS_EVENTS ) )
                {
                    CTokenListWalker AllList ( pRuntimeList );
                    if ( !AllList.GetNext ( TYPE_EVENT, pToken -> GetTagValue ( CLASS_EVENTS ) ) )
                    {
                        sprintf ( szErrorText, "Class %s References unknown events:%s\n",
                            (LPCSTR)pToken->GetTagValue ( CLASS_NAME ),
                            (LPCSTR)pToken->GetTagValue ( CLASS_EVENTS ) );
                        ReportError ( szErrorText );
                        return FALSE;
                    }
                }
                // If you have an event set , you must have a coclass
                if ( pToken -> IsSet ( CLASS_EVENTS ) && !pToken -> IsSet ( CLASS_ABSTRACT ) &&
                    !pToken -> IsSet ( CLASS_GUID ) )
                {
                    sprintf ( szErrorText, "Non abstract class %s has an event set but no GUID\n",
                        (LPCSTR)pToken->GetTagValue ( CLASS_NAME ) );
                    ReportError ( szErrorText );
                    return FALSE;
                }
            }
            else if ( pToken -> GetType() == TYPE_INTERFACE )
            {
                if ( pToken -> IsSet ( INTERFACE_SUPER ) )
                {
                    CTokenListWalker AllList ( pRuntimeList );
                    if ( !AllList.GetNext ( TYPE_INTERFACE, pToken -> GetTagValue ( INTERFACE_SUPER ) ) )
                    {
                        sprintf ( szErrorText, "Interface %s References unknown super:%s\n",
                            (LPCSTR)pToken->GetTagValue ( INTERFACE_NAME ),
                            (LPCSTR)pToken->GetTagValue ( INTERFACE_SUPER ) );
                        ReportError ( szErrorText );
                        return FALSE;
                    }
                }
            }
            else if ( pToken -> GetType() == TYPE_EVENT )
            {
                if ( pToken -> IsSet ( EVENT_SUPER ) )
                {
                    CTokenListWalker AllList ( pRuntimeList );
                    if ( !AllList.GetNext ( TYPE_EVENT, pToken -> GetTagValue ( EVENT_SUPER ) ) )
                    {
                        sprintf ( szErrorText, "Events %s References unknown super:%s\n",
                            (LPCSTR)pToken->GetTagValue ( EVENT_NAME ),
                            (LPCSTR)pToken->GetTagValue ( EVENT_SUPER ) );
                        ReportError ( szErrorText );
                        return FALSE;
                    }
                }
            }
            CTokenListWalker ChildList ( pToken );
            while ( pChildToken = ChildList.GetNext() )
            {
                if ( pChildToken -> GetType() == TYPE_PROPERTY )
                {
                    // If the Type field is not set, which it won't be for many
                    // abstract properties, set it to the ATYPE. We still
                    // need the type to determine if the property is an object value
                    // property
                    if ( !pChildToken -> IsSet ( PROPERTY_TYPE ) )
                    {
                        pChildToken -> AddTag ( PROPERTY_TYPE,
                            pChildToken -> GetTagValue ( PROPERTY_ATYPE ) );
                    }
                    if ( !LookupType ( pChildToken -> GetTagValue ( PROPERTY_TYPE ),
                        szHandler, szFnPrefix ) )
                    {
                        // Seeing as we don't use the handler for abstract types, we
                        // allow the lookup to fail
                        if ( !pChildToken -> IsSet ( PROPERTY_ABSTRACT ) )
                        {
                            sprintf ( szErrorText, "Invalid Type:%s in %s Property:%s\n",
                                (LPCSTR)pChildToken->GetTagValue ( PROPERTY_TYPE ),
                                (LPCSTR)pToken->GetTagValue ( NAME_TAG ),
                                (LPCSTR)pChildToken->GetTagValue ( PROPERTY_NAME ) );
                            ReportError ( szErrorText );
                            return FALSE;
                        }
                    }

                    // Currently we insist that you automate enums as BSTR's
                    szAType = pChildToken->GetTagValue ( PROPERTY_ATYPE );

                    if ( szHandler == "Enum" && szAType != "BSTR" )
                    {
                        sprintf ( szErrorText, "You must set atype:BSTR for an enum property %s : Property:%s\n",
                            (LPCSTR)pToken->GetTagValue ( NAME_TAG ),
                            (LPCSTR)pChildToken->GetTagValue ( PROPERTY_NAME ) );
                        ReportError ( szErrorText );
                        return FALSE;
                    }

                    if ( szHandler == "Color" && szAType != "VARIANT" )
                    {
                        sprintf ( szErrorText, "You must set atype:VARIANT for an type:CColorValue property %s : Property:%s\n",
                            (LPCSTR)pToken->GetTagValue ( NAME_TAG ),
                            (LPCSTR)pChildToken->GetTagValue ( PROPERTY_NAME ) );
                        ReportError ( szErrorText );
                        return FALSE;
                    }

                    if ( szHandler == "object" &&
                        !pChildToken -> IsSet ( PROPERTY_OBJECT ) )
                    {
                        pChildToken -> Set ( PROPERTY_OBJECT );
                    }
                    // Object valued properties must always be abstract because we don't have
                    // the notion of an "ObjectHandler"
                    if ( pChildToken -> IsSet ( PROPERTY_OBJECT ) &&
                        !pChildToken -> IsSet ( PROPERTY_ABSTRACT ) )
                    {
                        sprintf ( szErrorText, "Object Type Property %s:%s MUST be abstract\n",
                            (LPCSTR)pToken->GetTagValue ( NAME_TAG ),
                            (LPCSTR)pChildToken->GetTagValue ( PROPERTY_NAME ) );
                        ReportError ( szErrorText );
                        return FALSE;
                    }

                    for ( i = 0, uMask = 0 ; i < ARRAY_SIZE ( uProps ) ; i++ )
                    {
                        if ( pChildToken -> IsSet ( uProps [ i ] ) )
                        {
                            uMask |= 1<<i;
                        }
                    }

                    for ( i = 0, fMatched = FALSE;
                        i < ARRAY_SIZE ( PropertyCheck ); i++ )
                    {
                        if ( PropertyCheck [ i ].uMask == uMask )
                        {
                            fMatched = TRUE;
                        }
                    }

                    if ( !fMatched )
                    {
                        sprintf ( szErrorText, "Invalid combination of member/method/abstract/caa on %s:%s\n",
                            (LPCSTR)pToken->GetTagValue ( NAME_TAG ),
                            (LPCSTR)pChildToken->GetTagValue ( PROPERTY_NAME ) );
                        ReportError ( szErrorText );
                        return FALSE;
                    }
                    // Subobject MUST have a GET and MUST NOT have a SET
                    if ( pChildToken -> IsSet ( PROPERTY_SUBOBJECT ) &&
                        ( !pChildToken -> IsSet ( PROPERTY_GET ) || pChildToken -> IsSet ( PROPERTY_SET ) ) )
                    {
                        sprintf ( szErrorText, "Invalid combination of subobject/get/set on %s:%s\n",
                            (LPCSTR)pToken->GetTagValue ( NAME_TAG ),
                            (LPCSTR)pChildToken->GetTagValue ( PROPERTY_NAME ) );
                        ReportError ( szErrorText );
                        return FALSE;
                    }

                    // DISPLAYBIND Always implies BINDABLE - so always set it
                    if ( pChildToken -> IsSet ( PROPERTY_DISPLAYBIND ) &&
                        !pChildToken -> IsSet ( PROPERTY_BINDABLE ) )
                    {
                        pChildToken -> Set ( PROPERTY_BINDABLE );
                    }

                    // For now we limit the enum: type to atypre:VARIANT,
                    if ( pChildToken -> IsSet ( PROPERTY_ENUMREF ) )
                    {
                        if ( szAType != "VARIANT" )
                        {
                            sprintf ( szErrorText, "Invalid combination of atype/enum on %s:%s\n",
                                (LPCSTR)pToken->GetTagValue ( NAME_TAG ),
                                (LPCSTR)pChildToken->GetTagValue ( PROPERTY_NAME ) );
                            ReportError ( szErrorText );
                            return FALSE;
                        }
                    }
                    // Set an internal flag if the property cascades - saves looking this up later
                    if ( pChildToken -> IsSet ( PROPERTY_CAA ) )
                    {
                        const CCachedAttrArrayInfo *pCCAAI = GetCachedAttrArrayInfo( (LPCSTR)pChildToken -> GetTagValue ( PROPERTY_DISPID ) );
                        if ( pCCAAI->szDispId != NULL )
                        {
                            pChildToken -> Set ( PROPERTY_CASCADED );
                        }
                    }
                    if ( !pChildToken -> IsSet ( PROPERTY_DISPID ) )
                    {
                        sprintf ( szErrorText, "Missing compulsory attribute 'dispid' on %s:%s\n",
                            (LPCSTR)pToken->GetTagValue ( NAME_TAG ),
                            (LPCSTR)pChildToken->GetTagValue ( PROPERTY_NAME ) );
                        ReportError ( szErrorText );
                    }
                    // SETATDESIGNTIME augments regular set
                    if ( pChildToken -> IsSet ( PROPERTY_SETDESIGNMODE ) )
                    {
                        pChildToken -> Set ( PROPERTY_SET );
                    }

                }
                else if ( pChildToken -> GetType() == TYPE_METHOD )
                {
                    Token *pArgToken;
                    // For each method arg check
                    // that type is VARIANT if a optional tag is specified
                    CTokenListWalker ArgListWalker ( pChildToken );
                    while ( pArgToken = ArgListWalker.GetNext() )
                    {
                        szAType = pArgToken->GetTagValue ( METHODARG_TYPE );
                        if ( pArgToken->IsSet ( METHODARG_OPTIONAL ) &&
                            !(szAType == "VARIANT" || szAType == "VARIANT*") )
                        {
                            // MIDL will let this through but you'd never be able to
                            // set the default
                            sprintf ( szErrorText, "Method arg type must be VARIANT with optional: tag on %s:%s\n",
                                (LPCSTR)pToken->GetTagValue ( NAME_TAG ),
                                (LPCSTR)pChildToken->GetTagValue ( METHOD_NAME ) );
                            ReportError ( szErrorText );
                            return FALSE;
                        }
                        if ( LookupType ( pArgToken -> GetTagValue ( METHODARG_TYPE ),
                            szHandler, szFnPrefix ) )
                        {
                            if (szHandler == "Enum" && 
                                !(pToken->GetType() == TYPE_INTERFACE && 
                                    pToken->IsSet(INTERFACE_CUSTOM)))
                            {
                                sprintf ( szErrorText, "You must set type:BSTR for an enum %s Method:%s arg:%s\n",
                                    (LPCSTR)pToken->GetTagValue ( NAME_TAG ),
                                    (LPCSTR)pChildToken->GetTagValue ( METHOD_NAME ),
                                    (LPCSTR)pArgToken->GetTagValue ( METHODARG_ARGNAME ) );
                                ReportError ( szErrorText );
                                return FALSE;
                            }
                        }
                    }
                }
            }
        }
    }
    return TRUE;
}


//
// Patch up all interfaces which are not a primary default interfaces tearoff
// and mark as such (NOPRIMARY).  Classes marked as NOPRIMARY will be derived
// from the inheritance chain instead of being derived from IDispatch.
//
BOOL
CPDLParser::PatchInterfaces ()
{
    CTokenListWalker    ThisFilesList(pRuntimeList, _pszPDLFileName);
    Token              *pClassToken;
    Token              *pInterf;

    while (pClassToken = ThisFilesList.GetNext(TYPE_CLASS))
    {
        CString     szInterface;

        szInterface = pClassToken->GetTagValue(CLASS_INTERFACE);

        if (!FindTearoff(pClassToken->GetTagValue(CLASS_NAME),
                         (LPCSTR)szInterface))
        {
            CString szInterfSuper;

            pInterf = FindInterface(szInterface);
            while (pInterf)
            {
                pInterf->Set(INTERFACE_NOPRIMARYTEAROFF);

                szInterfSuper = pInterf->GetTagValue(INTERFACE_SUPER);
                pInterf = FindInterface(szInterfSuper);
            }
        }
    }

    return TRUE;
}


const CCachedAttrArrayInfo*
CPDLParser::GetCachedAttrArrayInfo( LPCSTR szDispId )
{
    CCachedAttrArrayInfo *pCCAAI = rgCachedAttrArrayInfo;

    while (pCCAAI->szDispId)
    {
        if (0==strcmp(szDispId, pCCAAI->szDispId))
            return pCCAAI;
        ++pCCAAI;
    }
    //This is means it is not applied to a XF structure
    return pCCAAI;
}


BOOL CPDLParser::GenerateHTMFile ()
{
    Token *pToken;
    CTokenListWalker WholeList ( pRuntimeList );
    CTokenListWalker ThisFilesList ( pRuntimeList, _pszPDLFileName );

    fprintf ( fpHTMFile, "<HTML>\n" );
    fprintf ( fpHTMFile, "<HEAD>\n" );
    fprintf ( fpHTMFile, "<TITLE>Interface Documentation from %s</TITLE>\n", _pszPDLFileName );
    fprintf ( fpHTMFile, "</HEAD>\n" );
    fprintf ( fpHTMFile, "<BODY>\n" );
    fprintf ( fpHTMFile, "<P>\n" );

    while ( pToken = ThisFilesList.GetNext ( TYPE_ENUM ) )
    {
        if ( !pToken -> IsSet ( ENUM_HIDDEN ))
        {
            fprintf ( fpHTMFile, "<B><U>Enumerations:</U></B> %s\n",
                      pToken->GetTagValue ( ENUM_NAME ) );
            fprintf ( fpHTMFile, "<P>\n" );

            fprintf ( fpHTMFile, "<TABLE WIDTH=70%%>\n" );
            fprintf ( fpHTMFile, "<TR>\n" );
            fprintf ( fpHTMFile, "<TH WIDTH=50%% ALIGN=\"Left\">Name</TH>\n" );
            fprintf ( fpHTMFile, "<TH WIDTH=25%% ALIGN=\"Center\">String</TH>\n" );
            fprintf ( fpHTMFile, "</TR>\n" );

            GenerateEnumHTM ( pToken,
                              pToken -> IsSet ( ENUM_PREFIX ) ?
                                        pToken->GetTagValue ( ENUM_PREFIX ) :
                                        pToken->GetTagValue ( ENUM_NAME ) );  // sort enums

            fprintf ( fpHTMFile, "</TABLE>\n" );
            fprintf ( fpHTMFile, "<P>\n" );
        }
    }

    // Output interface documentation

    ThisFilesList.Reset();
    while ( (pToken = ThisFilesList.GetNext ( TYPE_INTERFACE )) )
    {
        if (_stricmp("IUnknown", pToken->GetTagValue ( INTERFACE_NAME )) &&
            _stricmp("IDispatch", pToken->GetTagValue ( INTERFACE_NAME )) )
        {
            char achFilePrefix[100];
          
            strcpy (achFilePrefix, _pszPDLFileName);
            char *pDot = strchr(achFilePrefix, '.');
            if (pDot) {
                *pDot = '\0';
            }
            else {
                strcpy(achFilePrefix, "badpdl");
            }

            fprintf ( fpHTMIndexFile, "<A NAME=\"Index_Interface_%s\">Interface: <A HREF=\"%s.htm#Interface_%s\">%s</A><BR>\n",
                        pToken->GetTagValue ( INTERFACE_NAME ),
                        achFilePrefix, pToken->GetTagValue ( INTERFACE_NAME ),
                        pToken->GetTagValue ( INTERFACE_NAME ));
      
            fprintf ( fpHTMFile, "<P>\n" );
            fprintf ( fpHTMFile, "<A NAME=\"Interface_%s\">\n", pToken->GetTagValue ( INTERFACE_NAME ) );
            fprintf ( fpHTMFile, "<TABLE>\n" );
            fprintf ( fpHTMFile, "<TR><TD><H1>Interface</H1></TD>"
                                 "<TR><TD><B>%s</B></TD><TD> GUID: </TD><TD>%s</TD></TR>"
                                 "<TR><TD>inherits from interface</TD></TR>"
                                 "<TR><TD><B><A HREF=\"AllIndex.htm#Index_Interface_%s\">%s</A></B></TD></TR>\n"
                                 "</TABLE>\n",
                                  pToken->GetTagValue ( INTERFACE_NAME ),
                                  pToken->GetTagValue ( INTERFACE_GUID ),
                                  pToken->GetTagValue ( INTERFACE_SUPER ),
                                  pToken->GetTagValue ( INTERFACE_SUPER ) );
            fprintf ( fpHTMFile, "<P>\n" );

            fprintf ( fpHTMFile, "<HR>\n" );

            fprintf ( fpHTMFile, "<H2>Properties</H2>\n" );
            fprintf ( fpHTMFile, "<TABLE>\n" );
            fprintf ( fpHTMFile, "<TR>" );
            fprintf ( fpHTMFile, "<TH>Name</TH>" );
            fprintf ( fpHTMFile, "<TH>AType</TH>" );
            fprintf ( fpHTMFile, "<TH>DISPID</TH>" );
            fprintf ( fpHTMFile, "<TH>G</TH>" );
            fprintf ( fpHTMFile, "<TH>S</TH>" );
            fprintf ( fpHTMFile, "<TH>DT</TH>" );
            fprintf ( fpHTMFile, "<TH>Default</TH>" );
            fprintf ( fpHTMFile, "<TH>Min</TH>" );
            fprintf ( fpHTMFile, "<TH>Max</TH>" );
            fprintf ( fpHTMFile, "</TR>\n" );
            GenerateInterfacePropertiesHTM ( pToken );     // sort attributes
            fprintf ( fpHTMFile, "</TABLE>" );

            fprintf ( fpHTMFile, "<H2>Methods</H2>\n" );
            fprintf ( fpHTMFile, "<TABLE BORDER=1>\n" );
            fprintf ( fpHTMFile, "<TR>" );
            fprintf ( fpHTMFile, "<TH>Ret. Name</TH>" );
            fprintf ( fpHTMFile, "<TH>Name</TH>" );
            fprintf ( fpHTMFile, "<TH>Param Dir</TH>" );
            fprintf ( fpHTMFile, "<TH>Param Type</TH>" );
            fprintf ( fpHTMFile, "<TH>Param Name</TH>" );
            fprintf ( fpHTMFile, "<TH>Default Value</TH>" );
            fprintf ( fpHTMFile, "<TH>Optional</TH>" );
            fprintf ( fpHTMFile, "<TH>Ret. Type</TH>" );
            fprintf ( fpHTMFile, "</TR>\n" );
            GenerateInterfaceMethodHTM ( pToken );     // sort attributes
            fprintf ( fpHTMFile, "</TABLE>" );
        }
    }

    // Output eventset documentation
    ThisFilesList.Reset();
    while ( (pToken = ThisFilesList.GetNext ( TYPE_EVENT )) )
    {
        if (_stricmp("IDispatch", pToken->GetTagValue ( INTERFACE_NAME )) )
        {
            char achFilePrefix[100];
          
            strcpy (achFilePrefix, _pszPDLFileName);
            char *pDot = strchr(achFilePrefix, '.');
            if (pDot) {
                *pDot = '\0';
            }
            else {
                strcpy(achFilePrefix, "badpdl");
            }

            fprintf ( fpHTMIndexFile, "<A NAME=\"Index_Eventset_%s\">Eventset: <A HREF=\"%s.htm#Eventset_%s\">%s</A><BR>\n",
                        pToken->GetTagValue ( EVENT_NAME ),
                        achFilePrefix, pToken->GetTagValue ( EVENT_NAME ),
                        pToken->GetTagValue ( EVENT_NAME ));
      
            fprintf ( fpHTMFile, "<BR><BR>\n" );
            fprintf ( fpHTMFile, "<A NAME=\"Eventset_%s\">\n", pToken->GetTagValue ( EVENT_NAME ) );
            fprintf ( fpHTMFile, "<TABLE>\n" );
            fprintf ( fpHTMFile, "<TR><TD><H1>Event Set</H1></TD>"
                                 "<TR><TD><B>%s</B></TD><TD> GUID: </TD><TD>%s</TD></TR>"
                                 "<TR><TD>inherits from event set</TD></TR>"
                                 "<TR><TD><B><A HREF=\"AllIndex.htm#Index_Eventset_%s\">%s</A></B></TD></TR>\n"
                                 "</TABLE>\n",
                                  pToken->GetTagValue ( EVENT_NAME ),
                                  pToken->GetTagValue ( EVENT_GUID ),
                                  pToken->GetTagValue ( EVENT_SUPER ),
                                  pToken->GetTagValue ( EVENT_SUPER ) );
            fprintf ( fpHTMFile, "<HR>\n" );
            fprintf ( fpHTMFile, "<H2>Methods</H2>\n" );
            fprintf ( fpHTMFile, "<TABLE BORDER=1>\n" );
            fprintf ( fpHTMFile, "<TR>" );
            fprintf ( fpHTMFile, "<TH>Ret. Name</TH>" );
            fprintf ( fpHTMFile, "<TH>Name</TH>" );
            fprintf ( fpHTMFile, "<TH>DISPID</TH>" );
            fprintf ( fpHTMFile, "<TH>Cancelable</TH>" );
            fprintf ( fpHTMFile, "<TH>Bubbling</TH>" );
            fprintf ( fpHTMFile, "<TH>Param Dir</TH>" );
            fprintf ( fpHTMFile, "<TH>Param Type</TH>" );
            fprintf ( fpHTMFile, "<TH>Param Name</TH>" );
            fprintf ( fpHTMFile, "<TH>Default Value</TH>" );
            fprintf ( fpHTMFile, "<TH>Optional</TH>" );
            fprintf ( fpHTMFile, "<TH>Ret. Type</TH>" );
            fprintf ( fpHTMFile, "</TR>\n" );
            GenerateEventMethodHTM ( pToken );     // sort attributes
            fprintf ( fpHTMFile, "</TABLE>" );
        }
    }

    fprintf ( fpHTMFile, "</BODY>\n");
    fprintf ( fpHTMFile, "</HTML>\n");

    return TRUE;
}


void CPDLParser::GenerateArg ( Token *pArgToken )
{
    if ( ! pArgToken -> IsSet ( METHODARG_RETURNVALUE ) )
    {
        fprintf ( fpHTMFile, "&nbsp[%s] %s %s",
                  pArgToken -> IsSet ( METHODARG_OUT ) ? "out" : "in",
                  pArgToken -> GetTagValue ( METHODARG_TYPE ),
                  pArgToken -> GetTagValue ( METHODARG_ARGNAME ) );

        if ( pArgToken -> IsSet ( METHODARG_DEFAULTVALUE ) )
        {
            fprintf ( fpHTMFile, "=%s",
                      pArgToken -> GetTagValue ( METHODARG_DEFAULTVALUE ) );
        }

        if ( pArgToken -> IsSet ( METHODARG_OPTIONAL ) )
        {
            fprintf ( fpHTMFile, " [optional]" );
        }
    }
}

void CPDLParser::GenerateInterfaceArg ( Token *pArgToken )
{
    if ( ! pArgToken -> IsSet ( METHODARG_RETURNVALUE ) )
    {
        fprintf ( fpHTMFile, "<TD>%s</TD><TD>%s</TD><TD>%s</TD>",
                  pArgToken -> IsSet ( METHODARG_OUT ) ? "out" : "in",
                  pArgToken -> GetTagValue ( METHODARG_TYPE ),
                  pArgToken -> GetTagValue ( METHODARG_ARGNAME ) );

        fprintf ( fpHTMFile, "<TD>%s</TD><TD>%s</TD>",
                  pArgToken -> IsSet ( METHODARG_DEFAULTVALUE ) ?
                    (pArgToken -> GetTagValue ( METHODARG_DEFAULTVALUE )) : "",
                  pArgToken -> IsSet ( METHODARG_OPTIONAL) ?
                    "Y" : "N" );
    
    }
}

void CPDLParser::GenerateMethodHTM ( Token *pIntfToken )
{
    CTokenListWalker   *pChildList;
    Token              *pChildToken;
    Token              *pArgToken;
    int                 cArgs;
    CString             szSuper;
    CTokenListWalker   *ptlw = NULL;

    pChildList = new CTokenListWalker ( pIntfToken );

    szSuper = pIntfToken->GetTagValue ( INTERFACE_SUPER );

    do
    {
        while ( pChildToken = pChildList -> GetNext() )
        {
            CString             szRetValArg;
            CString             szRetValType;
            CTokenListWalker    ArgListWalker ( pChildToken );

            cArgs = 0;

            // Loop thru all arguments.
            while ( (pArgToken = ArgListWalker.GetNext()) != NULL &&
                    pArgToken -> GetType () == TYPE_METHOD_ARG )
            {
                // Looking for a return value.
                if ( pArgToken -> IsSet ( METHODARG_RETURNVALUE ) )
                {
                    // If a return value exist then get the argument name.
                    szRetValArg = pArgToken -> GetTagValue (
                        pArgToken -> IsSet ( METHODARG_ARGNAME ) ?
                            METHODARG_ARGNAME : METHODARG_RETURNVALUE );

                    szRetValType = pArgToken -> GetTagValue ( METHODARG_TYPE );
                }
                else
                {
                    cArgs++;
                }
            }

            if ( strlen ( szRetValArg ) )
            {
                fprintf ( fpHTMFile, "<TR><TD>%s = <I>object.</I><B>%s</B>",
                          (LPCSTR)szRetValArg,
                          pChildToken -> GetTagValue ( METHOD_NAME ) );
            }
            else
            {
                fprintf ( fpHTMFile, "<TR><TD><I>object.</I><B>%s</B>",
                          pChildToken -> GetTagValue ( METHOD_NAME ) );
            }

            int cArgIndex = 0;
            ArgListWalker.Reset ( );
            while ( ( pArgToken = ArgListWalker.GetNext ( ) ) != NULL &&
                      pArgToken -> GetType () == TYPE_METHOD_ARG )
            {
                if ( ! pArgToken -> IsSet ( METHODARG_RETURNVALUE ) )
                {
                    if (cArgIndex == 0)
                    {
                        switch (cArgs)
                        {
                        case 0:
                            fprintf ( fpHTMFile, "<TD>( )</TD>\n" );
                            fprintf ( fpHTMFile, "<TD ALIGN=\"Center\">%s</TD>\n",
                                      (LPCSTR)szRetValType );
                            fprintf ( fpHTMFile, "</TR>\n" );
                           break;
                        case 1:
                            fprintf ( fpHTMFile, "<TD>(" );

                            GenerateArg( pArgToken );

                            fprintf ( fpHTMFile, "&nbsp)</TD>\n" );
                            fprintf ( fpHTMFile, "<TD ALIGN=\"Center\">%s</TD>\n",
                                      (LPCSTR)szRetValType );
                            fprintf ( fpHTMFile, "</TR>\n" );
                            break;
                        default:
                            fprintf ( fpHTMFile, "<TD>(" );

                            GenerateArg( pArgToken );

                            fprintf ( fpHTMFile, ",</TD>\n" );
                            fprintf ( fpHTMFile, "<TD ALIGN=\"Center\">%s</TD>\n",
                                      (LPCSTR)szRetValType );
                            fprintf ( fpHTMFile, "</TR>\n" );
                            break;
                        }
                    }
                    else
                    {
                        if (cArgIndex > 1)
                        {
                            fprintf ( fpHTMFile, ",</TD></TR>\n" );
                        }
                        fprintf ( fpHTMFile, "<TR><TD></TD><TD>&nbsp" );
                        GenerateArg( pArgToken );
                    }

                    cArgIndex++;
                }
            }

            if ( cArgIndex == 0 )
            {
                fprintf ( fpHTMFile, "<TD>( )</TD>\n" );
                fprintf ( fpHTMFile, "<TD ALIGN=\"Center\">%s</TD>\n",
                          (LPCSTR)szRetValType );
                fprintf ( fpHTMFile, "</TR>\n" );
            }
            else if ( cArgIndex > 1 )
            {
                fprintf ( fpHTMFile, ")</TD></TR>\n" );
            }

            fprintf ( fpHTMFile, "<TR>&nbsp</TR>" );
        }

        // Get inherited interface.
        if ( strlen ( szSuper ) )
        {
            if (ptlw == NULL)
            {
                ptlw = new CTokenListWalker ( pRuntimeList, _pszPDLFileName );
            }
            else
            {
                ptlw->Reset();
            }

TryAgain:
            pIntfToken = ptlw->GetNext ( TYPE_INTERFACE, szSuper );

            if (pIntfToken)
            {
                szSuper = pIntfToken->GetTagValue ( INTERFACE_SUPER );

                delete pChildList;
                pChildList = new CTokenListWalker ( pIntfToken );
            }
            else
            {
                if ( !ptlw->IsGenericWalker ( ) )
                {
                    delete ptlw;
                    ptlw = new CTokenListWalker ( pRuntimeList );
                    goto TryAgain;
                }
            }
        }
        else
        {
            break;
        }
    } while (pIntfToken);

    delete pChildList;
    delete ptlw;
}

void CPDLParser::GenerateInterfaceMethodHTM ( Token *pIntfToken )
{
    CTokenListWalker   *pChildList;
    Token              *pChildToken;
    Token              *pArgToken;
    int                 cArgs;
    CString             szSuper;

    pChildList = new CTokenListWalker ( pIntfToken );

    szSuper = pIntfToken->GetTagValue ( INTERFACE_SUPER );

    while ( pChildToken = pChildList -> GetNext() )
    {
        CString             szRetValArg;
        CString             szRetValType;
        CTokenListWalker    ArgListWalker ( pChildToken );

        cArgs = 0;

        // Loop thru all arguments.
        while ( (pArgToken = ArgListWalker.GetNext()) != NULL &&
                pArgToken -> GetType () == TYPE_METHOD_ARG )
        {
            // Looking for a return value.
            if ( pArgToken -> IsSet ( METHODARG_RETURNVALUE ) )
            {
                // If a return value exist then get the argument name.
                szRetValArg = pArgToken -> GetTagValue (
                    pArgToken -> IsSet ( METHODARG_ARGNAME ) ?
                        METHODARG_ARGNAME : METHODARG_RETURNVALUE );

                szRetValType = pArgToken -> GetTagValue ( METHODARG_TYPE );
            }
            else
            {
                cArgs++;
            }
        }

        if ( strlen ( szRetValArg ) )
        {
            fprintf ( fpHTMFile, "<TR><TD>%s</TD><TD><I>object.</I><B>%s</B></TD>",
                      (LPCSTR)szRetValArg,
                      pChildToken -> GetTagValue ( METHOD_NAME ) );
        }
        else
        {
            fprintf ( fpHTMFile, "<TR><TD></TD><TD><I>object.</I><B>%s</B></TD>",
                      pChildToken -> GetTagValue ( METHOD_NAME ) );
        }

        int cArgIndex = 0;
        ArgListWalker.Reset ( );
        while ( ( pArgToken = ArgListWalker.GetNext ( ) ) != NULL &&
                  pArgToken -> GetType () == TYPE_METHOD_ARG )
        {
            if ( ! pArgToken -> IsSet ( METHODARG_RETURNVALUE ) )
            {
                if (cArgIndex == 0)
                {
                    switch (cArgs)
                    {
                    case 0:
                        fprintf ( fpHTMFile, "<TD></TD><TD></TD><TD></TD><TD></TD><TD></TD> <!-- 1 -->" ); 
                        fprintf ( fpHTMFile, "<TD ALIGN=\"Center\">%s</TD>\n",
                                  (LPCSTR)szRetValType );
                        fprintf ( fpHTMFile, "</TR>\n" );
                       break;
                    default:
                        GenerateInterfaceArg( pArgToken );
                        fprintf ( fpHTMFile, "<TD ALIGN=\"Center\">%s</TD>\n",
                                  (LPCSTR)szRetValType );
                        fprintf ( fpHTMFile, "</TR>\n" );
                        break;
                    }
                }
                else
                {
                    if (cArgIndex > 1)
                    {
                        fprintf ( fpHTMFile, "</TR> <!-- Hello -->\n" );
                    }
                    fprintf ( fpHTMFile, "<TR><TD></TD><TD></TD>" );
                    GenerateInterfaceArg( pArgToken );
                }

                cArgIndex++;
            }
        }

        if ( cArgIndex == 0 )
        {
            fprintf ( fpHTMFile, "<TD></TD><TD></TD><TD></TD><TD></TD><TD></TD> <!-- 2 -->" );
            fprintf ( fpHTMFile, "<TD ALIGN=\"Center\">%s</TD>\n",
                      (LPCSTR)szRetValType );
            fprintf ( fpHTMFile, "</TR>\n" );
        }
        else if ( cArgIndex > 1 )
        {
            fprintf ( fpHTMFile, "</TR> <!-- 3 -->\n" );
        }

        fprintf ( fpHTMFile, "<TR></TR>" );
    }

    delete pChildList;
}

void CPDLParser::GenerateEventMethodHTM ( Token *pIntfToken )
{
    CTokenListWalker   *pChildList;
    Token              *pChildToken;
    Token              *pArgToken;
    int                 cArgs;
    CString             szSuper;

    pChildList = new CTokenListWalker ( pIntfToken );

    szSuper = pIntfToken->GetTagValue ( INTERFACE_SUPER );

    while ( pChildToken = pChildList -> GetNext() )
    {
        CString             szRetValArg;
        CString             szRetValType;
        CTokenListWalker    ArgListWalker ( pChildToken );

        cArgs = 0;

        // Loop thru all arguments.
        while ( (pArgToken = ArgListWalker.GetNext()) != NULL &&
                pArgToken -> GetType () == TYPE_METHOD_ARG )
        {
            // Looking for a return value.
            if ( pArgToken -> IsSet ( METHODARG_RETURNVALUE ) )
            {
                // If a return value exist then get the argument name.
                szRetValArg = pArgToken -> GetTagValue (
                    pArgToken -> IsSet ( METHODARG_ARGNAME ) ?
                        METHODARG_ARGNAME : METHODARG_RETURNVALUE );

                szRetValType = pArgToken -> GetTagValue ( METHODARG_TYPE );
            }
            else
            {
                cArgs++;
            }
        }

        if ( strlen ( szRetValArg ) )
        {
            fprintf ( fpHTMFile, "<TR><TD>%s</TD><TD><I>object.</I><B>%s</B></TD>",
                      (LPCSTR)szRetValArg,
                      pChildToken -> GetTagValue ( METHOD_NAME ) );
        }
        else
        {
            fprintf ( fpHTMFile, "<TR><TD></TD><TD><I>object.</I><B>%s</B></TD>",
                      pChildToken -> GetTagValue ( METHOD_NAME ) );
        }
        
        fprintf ( fpHTMFile, "<TD>%s</TD><TD>%s</TD><TD>%s</TD>",
                  pChildToken->IsSet(METHOD_DISPID) ? pChildToken->GetTagValue ( METHOD_DISPID ) : "",
                  pChildToken->IsSet(METHOD_CANCELABLE) ? "Y" : "N",
                  pChildToken->IsSet(METHOD_BUBBLING) ? "Y" : "N" );

        int cArgIndex = 0;
        ArgListWalker.Reset ( );
        while ( ( pArgToken = ArgListWalker.GetNext ( ) ) != NULL &&
                  pArgToken -> GetType () == TYPE_METHOD_ARG )
        {
            if ( ! pArgToken -> IsSet ( METHODARG_RETURNVALUE ) )
            {
                if (cArgIndex == 0)
                {
                    switch (cArgs)
                    {
                    case 0:
                        fprintf ( fpHTMFile, "<TD></TD><TD></TD><TD></TD><TD></TD><TD></TD> <!-- 1 -->" ); 
                        fprintf ( fpHTMFile, "<TD ALIGN=\"Center\">%s</TD>\n",
                                  (LPCSTR)szRetValType );
                        fprintf ( fpHTMFile, "</TR>\n" );
                       break;
                    default:
                        GenerateInterfaceArg( pArgToken );
                        fprintf ( fpHTMFile, "<TD ALIGN=\"Center\">%s</TD>\n",
                                  (LPCSTR)szRetValType );
                        fprintf ( fpHTMFile, "</TR>\n" );
                        break;
                    }
                }
                else
                {
                    if (cArgIndex > 1)
                    {
                        fprintf ( fpHTMFile, "</TR> <!-- Hello -->\n" );
                    }
                    fprintf ( fpHTMFile, "<TR><TD></TD><TD></TD><TD></TD><TD></TD><TD></TD>" );
                    GenerateInterfaceArg( pArgToken );
                }

                cArgIndex++;
            }
        }

        if ( cArgIndex == 0 )
        {
            fprintf ( fpHTMFile, "<TD></TD><TD></TD><TD></TD><TD></TD><TD></TD> <!-- 2 -->" );
            fprintf ( fpHTMFile, "<TD ALIGN=\"Center\">%s</TD>\n",
                      (LPCSTR)szRetValType );
            fprintf ( fpHTMFile, "</TR>\n" );
        }
        else if ( cArgIndex > 1 )
        {
            fprintf ( fpHTMFile, "</TR> <!-- 3 -->\n" );
        }

        fprintf ( fpHTMFile, "<TR></TR>" );
    }

    delete pChildList;
}


void CPDLParser::GenerateEnumHTM ( Token *pClassToken, char *pEnumPrefix )
{
    CTokenListWalker    ChildList ( pClassToken );
    Token              *pChildToken;
    CString             szStringValue;

    while ( pChildToken = ChildList.GetNext() )
    {
        if ( pChildToken -> GetType() == TYPE_EVAL )
        {

            fprintf ( fpHTMFile, "<TR>\n<TD>%s%s</TD><TD ALIGN=\"Center\">\"%s\"</TD>",
                      pEnumPrefix,
                      pChildToken -> GetTagValue ( EVAL_NAME ),
                      pChildToken ->  IsSet ( EVAL_STRING ) ?
                        pChildToken -> GetTagValue ( EVAL_STRING ) :
                        pChildToken -> GetTagValue ( EVAL_NAME ) );

            fprintf ( fpHTMFile, "</TR>\n");
        }
    }
}


void CPDLParser::GeneratePropertiesHTM ( Token *pIntfToken, BOOL fAttributes )
{
    CTokenListWalker   *pChildList;
    Token              *pChildToken;
    CString             szSuper;
    CTokenListWalker   *ptlw = NULL;

    pChildList = new CTokenListWalker ( pIntfToken );

    szSuper = pIntfToken->GetTagValue ( INTERFACE_SUPER );

    do
    {
        while ( pChildToken = pChildList->GetNext() )
        {
            // Attributes are only properties which are not abstract and the
            // ppflags is not PROPPARAM_NOTHTML.
            if ( pChildToken -> GetType () == TYPE_PROPERTY     &&
                 fAttributes == (
                      !pChildToken -> IsSet ( PROPERTY_ABSTRACT )             &&
                      pChildToken -> IsSet ( PROPERTY_NOPERSIST ) ) )
            {

                if (fAttributes)
                {
                    fprintf ( fpHTMFile, "<TR><TD>%s</TD><TD>%s</TD><TD>%s</TD>",
                              pChildToken -> GetTagValue (
                                    pChildToken -> IsSet ( PROPERTY_SZATTRIBUTE ) ?
                                        PROPERTY_SZATTRIBUTE : PROPERTY_NAME ),
                              pChildToken -> GetTagValue ( PROPERTY_NAME ),
                              pChildToken -> GetTagValue ( PROPERTY_ATYPE ) );
                }
                else
                {
                    fprintf ( fpHTMFile, "<TR><TD>%s</TD><TD>%s</TD>",
                              pChildToken -> GetTagValue ( PROPERTY_NAME ),
                              pChildToken -> GetTagValue ( PROPERTY_ATYPE ) );
                }

                fprintf ( fpHTMFile, "<TD>%s</TD>",
                          pChildToken -> IsSet ( PROPERTY_NOTPRESENTDEFAULT ) ?
                            pChildToken -> GetTagValue ( PROPERTY_NOTPRESENTDEFAULT ) :
                            "" );

                fprintf ( fpHTMFile, "<TD>%s</TD>",
                          pChildToken -> IsSet ( PROPERTY_MIN ) ?
                            pChildToken -> GetTagValue ( PROPERTY_MIN ) :
                            "" );

                fprintf ( fpHTMFile, "<TD>%s</TD>",
                          pChildToken -> IsSet ( PROPERTY_MAX ) ?
                            pChildToken -> GetTagValue ( PROPERTY_MAX ) :
                            "" );

                if ( pChildToken -> IsSet ( PROPERTY_SET )  &&
                     pChildToken -> IsSet ( PROPERTY_GET ) )
                {
                    fprintf ( fpHTMFile, "<TD>R/W</TD>" );
                }
                else if ( pChildToken -> IsSet ( PROPERTY_GET ) )
                {
                    fprintf ( fpHTMFile, "<TD>R/O</TD>" );
                }
                else
                {
                    fprintf ( fpHTMFile, "<TD>W/O</TD>" );
                }

                fprintf ( fpHTMFile,
                          pChildToken -> IsSet ( PROPERTY_SETDESIGNMODE ) ?
                            "<TD>R/W</TD>" : "<TD>R/O</TD>" );

                fprintf ( fpHTMFile, "</TR>\n" );
            }
        }

        // Get inherited interface.
        if ( strlen ( szSuper ) )
        {
            if (ptlw == NULL)
            {
                ptlw = new CTokenListWalker ( pRuntimeList, _pszPDLFileName );
            }
            else
            {
                ptlw->Reset();
            }

TryAgain:
            pIntfToken = ptlw->GetNext ( TYPE_INTERFACE, szSuper );

            if (pIntfToken)
            {
                szSuper = pIntfToken->GetTagValue ( INTERFACE_SUPER );

                delete pChildList;
                pChildList = new CTokenListWalker ( pIntfToken );
            }
            else
            {
                if ( !ptlw->IsGenericWalker ( ) )
                {
                    delete ptlw;
                    ptlw = new CTokenListWalker ( pRuntimeList );
                    goto TryAgain;
                }
            }
        }
        else
        {
            break;
        }
    } while (pIntfToken);

    delete pChildList;
    delete ptlw;
}

#define GET_TAG_VALUE(pToken, value) (pToken->IsSet(value) ? pToken->GetTagValue(value) : "")

void CPDLParser::GenerateInterfacePropertiesHTM ( Token *pIntfToken )
{
    CTokenListWalker   *pChildList;
    Token              *pChildToken;
    CString             szSuper;

    pChildList = new CTokenListWalker ( pIntfToken );

    szSuper = pIntfToken->GetTagValue ( INTERFACE_SUPER );

    while ( pChildToken = pChildList->GetNext() )
    {
        if ( pChildToken -> GetType () == TYPE_PROPERTY )
        {
            fprintf ( fpHTMFile, "<TR>" );
            fprintf ( fpHTMFile, "<TD>%s</TD>", GET_TAG_VALUE(pChildToken, PROPERTY_NAME) );
            fprintf ( fpHTMFile, "<TD>%s</TD>", GET_TAG_VALUE(pChildToken, PROPERTY_ATYPE) );
            fprintf ( fpHTMFile, "<TD>%s</TD>", GET_TAG_VALUE(pChildToken, PROPERTY_DISPID) );
            fprintf ( fpHTMFile, "<TD>%s</TD>", pChildToken->IsSet(PROPERTY_GET) ? "Y" : "N" );
            fprintf ( fpHTMFile, "<TD>%s</TD>", pChildToken->IsSet(PROPERTY_SET) ? "Y" : "N" );
            fprintf ( fpHTMFile, "<TD>%s</TD>", pChildToken->IsSet(PROPERTY_SETDESIGNMODE) ? "Y" : "N" );
            fprintf ( fpHTMFile, "<TD>%s</TD>", pChildToken->IsSet(PROPERTY_NOTPRESENTDEFAULT) ? pChildToken->GetTagValue(PROPERTY_NOTPRESENTDEFAULT) : "" );
            fprintf ( fpHTMFile, "<TD>%s</TD>", pChildToken->IsSet(PROPERTY_MIN) ? pChildToken->GetTagValue(PROPERTY_MIN) : "" );
            fprintf ( fpHTMFile, "<TD>%s</TD>", pChildToken->IsSet(PROPERTY_MAX) ? pChildToken->GetTagValue(PROPERTY_MAX) : "" );
            fprintf ( fpHTMFile, "</TR>\n" );
        }
    }
    delete pChildList;
}

#undef GET_TAG_VALUE

Token* CPDLParser::FindInterface (CString szInterfaceMatch)
{
    CTokenListWalker    WholeTree ( pRuntimeList );
    Token              *pInterfaceToken;

    WholeTree.Reset();
    while ( pInterfaceToken = WholeTree.GetNext ( TYPE_INTERFACE ) )
    {
        CString     szInterface;

        if ( !pInterfaceToken -> IsSet ( INTERFACE_ABSTRACT ) &&
            pInterfaceToken -> IsSet ( INTERFACE_GUID ) )
        {
            szInterface = pInterfaceToken -> GetTagValue ( INTERFACE_NAME );
            if (szInterface == szInterfaceMatch)
            {
                return pInterfaceToken;
            }
        }
    }

    return NULL;
}


// Only interfaces defined in this file.
Token* CPDLParser::FindInterfaceLocally (CString szInterfaceMatch)
{
    CTokenListWalker    TokenList ( pRuntimeList, _pszPDLFileName );
    Token              *pInterfaceToken;

    TokenList.Reset();
    while ( pInterfaceToken = TokenList.GetNext ( TYPE_INTERFACE ) )
    {
        CString     szInterface;

        if ( !pInterfaceToken -> IsSet ( INTERFACE_ABSTRACT ) &&
            pInterfaceToken -> IsSet ( INTERFACE_GUID ) )
        {
            szInterface = pInterfaceToken -> GetTagValue ( INTERFACE_NAME );
            if (szInterface == szInterfaceMatch)
            {
                return pInterfaceToken;
            }
        }
    }

    return NULL;
}


BOOL CPDLParser::IsPrimaryInterface(CString szInterface)
{
    CTokenListWalker    TokenList ( pRuntimeList, _pszPDLFileName );
    Token              *pClassToken;

    TokenList.Reset();
    while ( pClassToken = TokenList.GetNext ( TYPE_CLASS ) )
    {
        if (!_stricmp((LPSTR)pClassToken->GetTagValue(CLASS_INTERFACE),
                      szInterface))
            return TRUE;
    }

    return FALSE;
}


Token* CPDLParser::FindClass (CString szClassMatch)
{
    CTokenListWalker    WholeTree ( pRuntimeList );
    Token              *pClassToken;

    WholeTree.Reset();
    while ( pClassToken = WholeTree.GetNext ( TYPE_CLASS ) )
    {
        CString     szClass;

        szClass = pClassToken -> GetTagValue ( CLASS_NAME );
        if (szClass == szClassMatch)
        {
            return pClassToken;
        }
    }

    return NULL;
}

Token * CPDLParser::IsSuperInterface( CString szSuper, Token * pInterface )
{
    Token              *pInterfaceToken;
    CString             szInterface;

    if(!pInterface)
        return NULL;

    szInterface = pInterface->GetTagValue(INTERFACE_NAME);
    
    pInterfaceToken = pInterface;

    while ( pInterfaceToken )
    {
        if (szSuper == szInterface)
          return pInterfaceToken;

        szInterface = pInterfaceToken->GetTagValue(INTERFACE_SUPER);
        pInterfaceToken = FindInterface(szInterface);
    }

    return NULL;

}


Token *
CPDLParser::FindMatchingEntryWOPropDesc(Token *pClass, Token *pToFindToken, BOOL fNameMatchOnly)
{
    CTokenListWalker    ChildWalker(pClass);
    Token              *pChildToken;
    CString             szInterface;
    Token              *pInterfToken;
    Token              *pFuncToken = NULL;

    while (pChildToken = ChildWalker.GetNext())
    {
        if (pChildToken->GetType() == TYPE_IMPLEMENTS)
        {
            szInterface = pChildToken->GetTagValue(IMPLEMENTS_NAME);
            pInterfToken = FindInterface(szInterface);
            if (pInterfToken)
            {
                pFuncToken = FindMethodInInterfaceWOPropDesc(pInterfToken, pToFindToken, fNameMatchOnly);
                if (pFuncToken)
                    break;      // Found a match...
            }
        }
    }

    return pFuncToken;
}


Token*
CPDLParser::FindMethodInInterfaceWOPropDesc(Token *pInterface, Token *pToFindToken, BOOL fNameMatchOnly)
{
    CTokenListWalker    ChildList(pInterface);
    Token              *pChildToken = NULL;

    while (pChildToken = ChildList.GetNext())
    {
        if (pChildToken->GetType() == pToFindToken->GetType())
        {
            if (pChildToken->GetType() == TYPE_METHOD && !pChildToken->IsSet(METHOD_NOPROPDESC))
            {
                CString szMethodName;

                if (pToFindToken->IsSet(METHOD_NOPROPDESC) &&
                    pToFindToken->IsSet(METHOD_SZINTERFACEEXPOSE))
                {
                    szMethodName = pToFindToken->GetTagValue(METHOD_SZINTERFACEEXPOSE);
                }
                else
                {
                    szMethodName = pToFindToken->GetTagValue(METHOD_NAME);
                }

                if (!strcmp((LPCSTR)szMethodName,
                            (LPCSTR)pChildToken->GetTagValue(METHOD_NAME)))
                {
                   
                    CString     szTypesSig;
                    CString     szArgsType;
                    CString     szFindTypesSig;
                    CString     szFindArgsType;
                    BOOL        fIgnore;
                    int         cIgnore;


                    // If we only need a name match then we're done.
                    if (fNameMatchOnly)
                        break;

                    if (!BuildMethodSignature(pChildToken,
                                              szTypesSig,
                                              szArgsType,
                                              fIgnore,
                                              fIgnore,
                                              cIgnore,
                                              cIgnore))
                        return NULL;

                    if (!BuildMethodSignature(pToFindToken,
                                              szFindTypesSig,
                                              szFindArgsType,
                                              fIgnore,
                                              fIgnore,
                                              cIgnore,
                                              cIgnore))
                        return NULL;

                    // Exact signature match then use it.
                    if (!strcmp(szTypesSig, szFindTypesSig) &&
                        !strcmp(szArgsType, szFindArgsType))
                        break;
                }
            }
            else if (pChildToken->GetType() == TYPE_PROPERTY && !pChildToken->IsSet(PROPERTY_NOPROPDESC))
            {
                CString szPropertyName;

                if (pToFindToken->IsSet(PROPERTY_NOPROPDESC) &&
                    pToFindToken->IsSet(PROPERTY_SZINTERFACEEXPOSE))
                {
                    szPropertyName = pToFindToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE);
                }
                else
                {
                    szPropertyName = pToFindToken->GetTagValue(PROPERTY_NAME);
                }

                if (!strcmp((LPCSTR)szPropertyName,
                            (LPCSTR)pChildToken->GetTagValue(PROPERTY_NAME)))
                {
                    // If we only need a name match then we're done.
                    if (fNameMatchOnly)
                        break;

                    // If both are properties and the types are similar or an
                    // enum then the signature is the same we found a match.
                    if ((pChildToken->IsSet(PROPERTY_GETSETMETHODS) == pToFindToken->IsSet(PROPERTY_GETSETMETHODS)) &&
                        (pChildToken->IsSet(PROPERTY_MEMBER) == pToFindToken->IsSet(PROPERTY_MEMBER)) &&
                        (pChildToken->IsSet(PROPERTY_GET) == pToFindToken->IsSet(PROPERTY_GET)) &&
                        (pChildToken->IsSet(PROPERTY_SET) == pToFindToken->IsSet(PROPERTY_SET)))
                    {
                        if (!strcmp((LPCSTR)pChildToken->GetTagValue(PROPERTY_ATYPE),
                                    (LPCSTR)pToFindToken->GetTagValue(PROPERTY_ATYPE)))
                            break;

                        if (FindEnum(pChildToken) && FindEnum(pToFindToken))
                            break;
                    }
                }
            }
        }
    }

    return pChildToken;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\btools\tldiff\types.h ===
#ifndef types_h
#define types_h 1

//
//  Types of description blocks that can be hit.
//
enum BLOCK_TYPE
{
        BLK_NONE,       //single line information. comments, empty lines, [...] headers
        BLK_DISPINT,    //dispatch interface description block
        BLK_INTERFACE,  //interface description block
        BLK_COCLASS,    //coclass description block
        BLK_TYPEDEF,    //typedef description block
        BLK_ATTR        //attribute block for interface, coclass or typedef
};

//
//  The structure used for block index records.
//
typedef struct {
    BLOCK_TYPE  blockType;
    unsigned long ulStartPos;
    unsigned long ulEndPos;
    unsigned long ulAttrStartPos;
    unsigned long ulAttrEndPos;
    bool          fCopied;
}INDEX;

//
// The structure used for making it faster to access and compare 
// data about the methods in an interface.
//
typedef struct {
    unsigned long ulAttrStart;
    unsigned long ulAttrEnd;
    unsigned long ulNameStart;
    unsigned long ulNameEnd;
    unsigned long ulParamStart;
    unsigned long ulParamEnd;
    unsigned long ulMethodNameStart;
    bool          fUsed;
}LINEINFO;

typedef struct {
    unsigned long   ulAttrStart;
    unsigned long   ulAttrLength;
    bool            fUsed;
}ATTRINFO;

typedef struct {
    unsigned long   ulTypeStart;
    unsigned long   ulTypeLength;
    unsigned long   ulNameStart;
    unsigned long   ulNameLength;
    unsigned long   ulParamLength;
    bool            fUsed;
}PARAMINFO;

//
//  lengths of keywords that are used, to ease maintenance
//
#define LEN_DISPINT     13  //dispinterface
#define LEN_INTERFACE   9   //interface
#define LEN_COCLASS     7   //coclass
#define LEN_TYPEDEF     7   //typedef

//
//  Granularity for memory allocation.
//
#define SZ  512


//
//  Return value flags for the application
//
#define CHANGE_ADDINTERFACE         0x00000001  //  A new interface was added 
#define CHANGE_ADDDISPINT           0x00000002  //  A new dispinterface was added
#define CHANGE_ADDCOCLASS           0x00000004  //  A new coclass was added
#define CHANGE_ADDATTRIBUTE         0x00000008  //  A new attribute was added
#define CHANGE_REMOVEFROMINT        0x00000010  //  A method/property was removed from an interface
#define CHANGE_REMOVEFROMDISPINT    0x00000020  //  A method/property was removed from a dispinterface
#define CHANGE_METHODONINT          0x00000040  //  A method/property was added to an interface
#define CHANGE_METHODONDISPINT      0x00000080  //  A method/property was added to an dispinterface
#define CHANGE_PARAMCHANGE          0x00000100  //  A method's parameters were changed.
#define CHANGE_ATTRCHANGE           0x00000200  //  A method's attributes were changed
#define CHANGE_REMOVEFROMCOCLASS    0x00000400  //  An interface was removed from a coclass
#define CHANGE_ADDTOCOCLASS         0x00000800  //  An interface was added to a coclass
#define CHANGE_RETVALCHANGE         0x00001000  //  A  method's return value has been modified
#define CHANGE_BLOCKREMOVED         0x00002000  //  A coclass was removed
#define CHANGE_DUALATTRADDED        0x00004000  //  the attribute 'dual' was added to an interface/dispinterface
#define CHANGE_DUALATTRREMOVED      0x00008000  //  the attribute 'dual' was removed from an interface/dispinterface
#define CHANGE_UUIDHASCHANGED       0x00010000  //  GUID was changed for a coclass or an interface

#endif  // def types_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\btools\tlviewer\cmallspy.cpp ===
#include "hostenv.h"
#include "cmallspy.h"
#include "apglobal.h"

#define cbAlign 32

#define HEADERSIZE cbAlign		// # of bytes of block header					
#define TRAILERSIZE cbAlign		// # of bytes of block trailer
					

static XCHAR g_rgchHead[] = XSTR("OLEAuto Mem Head");	// beginning of block signature
static XCHAR g_rgchTail[] = XSTR("OLEAuto Mem Tail");	// end of block signature

#define MEMCMP(PV1, PV2, CB)	memcmp((PV1), (PV2), (CB))
#define MEMCPY(PV1, PV2, CB)	memcpy((PV1), (PV2), (CB))
#define MEMSET(PV,  VAL, CB)	memset((PV),  (VAL), (CB))

#define MALLOC(CB)		GlobalLock(GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, CB))


CMallocSpy myMallocSpy;		

UINT g_cHeapCheckInterval = 10; // only check full heap every 100 times.



//---------------------------------------------------------------------
//              implementation of the debug allocator
//---------------------------------------------------------------------

CAddrNode32 FAR* CAddrNode32::m_pnFreeList = NULL;

// AddrNodes are allocated in blocks to reduce the number of allocations
// we do for these. Note, we get away with this because the addr nodes
// are never freed, so we can just allocate a block, and thread them
// onto the freelist.
//
#define MEM_cAddrNodes 128
void FAR* CAddrNode32::operator new(size_t /*cb*/)
{
    CAddrNode32 FAR* pn;

    if(m_pnFreeList == NULL)
    {
        pn = (CAddrNode32 FAR*)MALLOC(sizeof(CAddrNode32) * MEM_cAddrNodes);

        for(int i = 1; i < MEM_cAddrNodes-1; ++i)
	        pn[i].m_pnNext = &pn[i+1];
        pn[MEM_cAddrNodes-1].m_pnNext = m_pnFreeList;
        m_pnFreeList = &pn[1];
    }
    else
    {
        pn = m_pnFreeList;
        m_pnFreeList = pn->m_pnNext;
    }
    return pn;
}

void CAddrNode32::operator delete(void FAR* pv)
{
    CAddrNode32 FAR *pn;

    pn = (CAddrNode32 FAR*)pv;
    pn->m_pnNext = m_pnFreeList;
    m_pnFreeList = pn;
}




//+---------------------------------------------------------------------
//
//  Member:     CMallocSpy::CMallocSpy
//
//  Synopsis:   Constructor
//
//  Returns:
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
CMallocSpy::CMallocSpy(void)
{
    m_cRef = 0;
    m_fWantTrueSize = FALSE;
    m_cAllocCalls = 0;
    m_cHeapChecks = 0;

    MEMSET(m_rganode, 0, sizeof(m_rganode));
}




//+---------------------------------------------------------------------
//
//  Member:     CMallocSpy::~CMallocSpy
//
//  Synopsis:   Destructor
//
//  Returns:
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
CMallocSpy::~CMallocSpy(void)
{
    CheckForLeaks();
}




//+---------------------------------------------------------------------
//
//  Member:     CMallocSpy::QueryInterface
//
//  Synopsis:   Only IUnknown and IMallocSpy are meaningful
//
//  Arguments:  [riid] --
//              [ppUnk] --
//
//  Returns:    S_OK or E_NOINTERFACE
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
HRESULT CMallocSpy::QueryInterface(REFIID riid, LPVOID *ppUnk)
{
    HRESULT hr = S_OK;

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppUnk = (IUnknown *) this;
    }
    else if (IsEqualIID(riid, IID_IMallocSpy))
    {
        *ppUnk =  (IMalloc *) this;
    }
    else
    {
        *ppUnk = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return hr;
}





//+---------------------------------------------------------------------
//
//  Member:     CMallocSpy::AddRef
//
//  Synopsis:   Add a reference
//
//  Returns:    New reference count
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
ULONG CMallocSpy::AddRef(void)
{
    return ++m_cRef;
}





//+---------------------------------------------------------------------
//
//  Member:     CMallocSpy::Release
//
//  Synopsis:   Remove a reference
//
//  Returns:    The new reference count
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
ULONG CMallocSpy::Release(void)
{
    ULONG cRef;

    cRef = --m_cRef;

    if (cRef == 0) 
    {
#if 0	// don't delete -- we're statically allocated
        delete this;
#endif 
    }
    return cRef;
}





//+---------------------------------------------------------------------
//
//  Member:     CMallocSpy::PreAlloc
//
//  Synopsis:   Called prior to OLE calling IMalloc::Alloc
//
//  Arguments:  [cbRequest] -- The number of bytes the caller of
//                             is requesting IMalloc::Alloc
//
//  Returns:    The count of bytes to actually allocate
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
SIZE_T CMallocSpy::PreAlloc(SIZE_T cbRequest)
{
    HeapCheck();

    return cbRequest + HEADERSIZE + TRAILERSIZE;
}




//+---------------------------------------------------------------------
//
//  Member:     CMallocSpy::PostAlloc
//
//  Synopsis:   Called after OLE calls IMalloc::Alloc
//
//  Arguments:  [pActual] -- The allocation returned by IMalloc::Alloc
//
//  Returns:    The allocation pointer to return to the caller of
//              IMalloc::Alloc
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
void *CMallocSpy::PostAlloc(void *pActual)
{
    IMalloc *pmalloc;
    SIZE_T cbRequest;
    HRESULT hresult;
    XCHAR sz[20];

    if (pActual == NULL)		// if real alloc failed, then
	    return NULL;			// propogate failure

    if (FAILED(hresult = CoGetMalloc(MEMCTX_TASK, &pmalloc))) 
    {
        apSPrintf(sz, XSTR("%lX"), hresult);
        apLogFailInfo(XSTR("ERROR:CoGetMalloc failed!!!"), XSTR("NOEEROR"), sz, XSTR(""));
        return(NULL);
    }

    m_fWantTrueSize = TRUE;
    cbRequest = pmalloc->GetSize(pActual) - HEADERSIZE - TRAILERSIZE;
    m_fWantTrueSize = FALSE;

    pmalloc->Release();

    // set header signature
    MEMCPY(pActual, g_rgchHead, HEADERSIZE);

    // set trailer signature
    MEMCPY((BYTE *)pActual+HEADERSIZE+cbRequest, g_rgchTail, TRAILERSIZE);

    // save info for leak detection
    AddInst((BYTE *)pActual+HEADERSIZE, cbRequest);

    // Return the allocation plus offset
    return (void *) (((BYTE *) pActual) + HEADERSIZE);
}





//+---------------------------------------------------------------------
//
//  Member:     CMallocSpy::PreFree
//
//  Synopsis:   Called prior to OLE calling IMalloc::Free
//
//  Arguments:  [pRequest] -- The allocation to be freed
//              [fSpyed]   -- Whether it was allocated with a spy active
//
//  Returns:
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
void *CMallocSpy::PreFree(void *pRequest, BOOL fSpyed)
{
    HeapCheck();

    if (pRequest == NULL)
    {
        return NULL;
    }

    // Undo the offset
    if (fSpyed)
    {
        CAddrNode32 FAR* pn;
        SIZE_T sizeToFree;

    	pn = FindInst(pRequest);

    	// check for attempt to operate on a pointer we didn't allocate
    	if(pn == NULL)
    	{
            apLogFailInfo(XSTR("Attempt to free memory not allocated by this 32-bit test!"), XSTR(""), XSTR(""), XSTR(""));
    	}

    	// check the block we're freeing
    	VerifyHeaderTrailer(pn);

        sizeToFree = pn->m_cb + HEADERSIZE + TRAILERSIZE;

        DelInst(pRequest);

    	// mark entire block as invalid
    	MEMSET((BYTE *) pRequest - HEADERSIZE, '~', sizeToFree);

        return (void *) (((BYTE *) pRequest) - HEADERSIZE);
    }
    else
    {
        return pRequest;
    }
}





//+---------------------------------------------------------------------
//
//  Member:     CMallocSpy::PostFree
//
//  Synopsis:   Called after OLE calls IMalloc::Free
//
//  Arguments:  [fSpyed]   -- Whether it was allocated with a spy active
//
//  Returns:
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
void CMallocSpy::PostFree(BOOL /*fSpyed*/)
{
    return;
}





//+---------------------------------------------------------------------
//
//  Member:     CMallocSpy::PreRealloc
//
//  Synopsis:   Called prior to OLE calling IMalloc::Realloc
//
//  Arguments:  [pRequest]     -- The buffer to be reallocated
//              [cbRequest]    -- The requested new size of the buffer
//              [ppNewRequest] -- Where to store the new buffer pointer
//                                to be reallocated
//              [fSpyed]       -- Whether it was allocated with a spy active
//
//  Returns:    The new size to actually be allocated
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
SIZE_T CMallocSpy::PreRealloc(void *pRequest, SIZE_T cbRequest, void **ppNewRequest, BOOL fSpyed)
{
    HeapCheck();

    if (fSpyed)
    {
        CAddrNode32 FAR* pn;
        SIZE_T sizeToFree;

	    pn = FindInst(pRequest);

	    // check for attempt to operate on a pointer we didn't allocate
	    if(pn == NULL)
	    {
            apLogFailInfo(XSTR("Attempt to reallocate memory not allocated by this 32-bit test!"), XSTR(""), XSTR(""), XSTR(""));
	    }

        sizeToFree = pn->m_cb;


        *ppNewRequest = (void *) (((BYTE *) pRequest) - HEADERSIZE);

        m_pvRealloc = pRequest;

        return cbRequest + HEADERSIZE + TRAILERSIZE;
    }
    else
    {
        *ppNewRequest = pRequest;
        return cbRequest;
    }
}





//+---------------------------------------------------------------------
//
//  Member:     CMallocSpy::PostRealloc
//
//  Synopsis:   Called after OLE calls IMalloc::Realloc
//
//  Arguments:  [pActual] -- Pointer to the reallocated buffer
//              [fSpyed]  -- Whether it was allocated with a spy active
//
//  Returns:    The buffer pointer to return
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
void *CMallocSpy::PostRealloc(void *pActual, BOOL fSpyed)
{
    IMalloc *pmalloc;
    SIZE_T cbRequest;
    HRESULT hresult;
    XCHAR sz[50];

    if (pActual == NULL) 
    {		
	    apLogFailInfo(XSTR("CMallocSpy::PostRealloc - Realloc of a block failed."), XSTR(""), XSTR(""), XSTR(""));
	    return NULL;			
    }

    // Return the buffer with the header offset
    if (fSpyed)
    {
	    DelInst(m_pvRealloc);

        if (FAILED(hresult = CoGetMalloc(MEMCTX_TASK, &pmalloc))) 
        {
        apSPrintf(sz, XSTR("%lX"), hresult);
        apLogFailInfo(XSTR("ERROR:CoGetMalloc failed!!!"), XSTR("NOEEROR"), sz, XSTR(""));
        }

        m_fWantTrueSize = TRUE;
        cbRequest = pmalloc->GetSize(pActual) - HEADERSIZE - TRAILERSIZE;
        m_fWantTrueSize = FALSE;

        pmalloc->Release();

	    if (MEMCMP(pActual, g_rgchHead, HEADERSIZE) != 0)
	    {
            MEMCPY(sz, pActual, HEADERSIZE);
            sz[HEADERSIZE] = 0;
            apLogFailInfo(XSTR("32-bit Memory header not intact!"), g_rgchHead, sz, XSTR(""));
	    }

        // set new trailer signature
        MEMCPY((BYTE *)pActual+HEADERSIZE+cbRequest, g_rgchTail, TRAILERSIZE);

        // save info for leak detection
        AddInst((BYTE *)pActual+HEADERSIZE, cbRequest);

        return (void *) (((BYTE *) pActual) + HEADERSIZE);
    }
    else
    {
        return pActual;
    }
}





//+---------------------------------------------------------------------
//
//  Member:     CMallocSpy::PreGetSize
//
//  Synopsis:   Called prior to OLE calling IMalloc::GetSize
//
//  Arguments:  [pRequest] -- The buffer whose size is to be returned
//              [fSpyed]   -- Whether it was allocated with a spy active
//
//  Returns:    The actual buffer with which to call IMalloc::GetSize
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
void *CMallocSpy::PreGetSize(void *pRequest, BOOL fSpyed)
{
    HeapCheck();

    if (fSpyed && !m_fWantTrueSize)
    {
        return (void *) (((BYTE *) pRequest) - HEADERSIZE);
    }
    else
    {
        return pRequest;
    }
}





//+---------------------------------------------------------------------
//
//  Member:     CMallocSpy::PostGetSize
//
//  Synopsis:   Called after OLE calls IMalloc::GetSize
//
//  Arguments:  [cbActual] -- The result of IMalloc::GetSize
//              [fSpyed]   -- Whether it was allocated with a spy active
//
//  Returns:    The size to return to the IMalloc::GetSize caller
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
SIZE_T CMallocSpy::PostGetSize(SIZE_T cbActual, BOOL fSpyed)
{
    if (fSpyed && !m_fWantTrueSize)
    {
        return cbActual - HEADERSIZE - TRAILERSIZE;
    }
    else
    {
        return cbActual;
    }
}





//+---------------------------------------------------------------------
//
//  Member:     CMallocSpy::PreDidAlloc
//
//  Synopsis:   Called prior to OLE calling IMalloc::DidAlloc
//
//  Arguments:  [pRequest] -- The buffer whose allocation is being tested
//              [fSpyed]   -- Whether it was allocated with a spy active
//
//  Returns:    The buffer whose allocation is actually to be tested
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
void *CMallocSpy::PreDidAlloc(void *pRequest, BOOL fSpyed)
{
    HeapCheck();

    if (fSpyed)
    {
        return (void *) (((BYTE *) pRequest) - HEADERSIZE);
    }
    else
    {
        return pRequest;
    }
}





//+---------------------------------------------------------------------
//
//  Function:   PostDidAlloc
//
//  Synopsis:   Called after OLE calls the IMalloc::DidAlloc
//
//  Arguments:  [pRequest] -- The passed allocation
//              [fSpyed]   -- Whether it was allocated with a spy active
//              [fActual]  -- The result of IMalloc::DidAlloc
//
//  Returns:    The result of IMalloc::DidAlloc
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
BOOL CMallocSpy::PostDidAlloc(void * /*pRequest*/, BOOL /*fSpyed*/, BOOL fActual)
{
    return fActual;
}





//+---------------------------------------------------------------------
//
//  Member:     CMallocSpy::PreHeapMinimize
//
//  Synopsis:   Called prior to OLE calling the IMalloc::HeapMinimize
//
//  Returns:
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
void CMallocSpy::PreHeapMinimize(void)
{
    HeapCheck();
    return;
}





//+---------------------------------------------------------------------
//
//  Member:     CMallocSpy::PostHeapMinimize
//
//  Synopsis:   Called after OLE calls the IMalloc::HeapMinimize
//
//  Returns:
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
void CMallocSpy::PostHeapMinimize(void)
{
    return;
}

//---------------------------------------------------------------------
//                     Instance table methods
//---------------------------------------------------------------------
VOID CMallocSpy::MemInstance()
{
    ++m_cAllocCalls;
}


/***
*PRIVATE CMallocSpy::AddInst
*Purpose:
*  Add the given instance to the address instance table.
*
*Entry:
*  pv = the instance to add
*  nAlloc = the allocation passcount of this instance
*
*Exit:
*  None
*
***********************************************************************/
void
CMallocSpy::AddInst(void FAR* pv, SIZE_T cb)
{
    ULONG nAlloc;
    UINT hash;
    CAddrNode32 FAR* pn;

    MemInstance();
    nAlloc = m_cAllocCalls;

    // DebAssert(pv != NULL, "");

    pn = (CAddrNode32 FAR*)new FAR CAddrNode32();

    // DebAssert(pn != NULL, "");

    pn->m_pv = pv;
    pn->m_cb = cb;
    pn->m_nAlloc = nAlloc;

    hash = HashInst(pv);
    pn->m_pnNext = m_rganode[hash];
    m_rganode[hash] = pn;
}


/***
*PRIVATE CMallocSpy::DelInst(void*)
*Purpose:
*  Remove the given instance from the address instance table.
*
*Entry:
*  pv = the instance to remove
*
*Exit:
*  None
*
***********************************************************************/
void
CMallocSpy::DelInst(void FAR* pv)
{
    CAddrNode32 FAR* FAR* ppn, FAR* pnDead;

    for(ppn = &m_rganode[HashInst(pv)]; *ppn != NULL; ppn = &(*ppn)->m_pnNext)
    {
        if((*ppn)->m_pv == pv)
        {
	        pnDead = *ppn;
	        *ppn = (*ppn)->m_pnNext;
	        delete pnDead;
	        return;
        }
    }
    // didnt find the instance
    // DebAssert(FALSE, "memory instance not found");
}


CAddrNode32 FAR*
CMallocSpy::FindInst(void FAR* pv)
{
    CAddrNode32 FAR* pn;

    for(pn = m_rganode[HashInst(pv)]; pn != NULL; pn = pn->m_pnNext)
    {
        if(pn->m_pv == pv)
            return pn;
    }
    return NULL;
}


void
CMallocSpy::DumpInst(CAddrNode32 FAR* pn)
{
    XCHAR     szActual[128];
    
    apSPrintf(szActual, XSTR("Block of %ld bytes leaked in test"), pn->m_cb);    
    apLogFailInfo(XSTR("Memory leaked on release of 32-bit test allocator!"), XSTR("no leak"), szActual, XSTR(""));

         
    // Printf("[%lp]  nAlloc=0x%lx  size=0x%lx\n", pn->m_pv, pn->m_nAlloc, pn->m_cb);
}


/***
*PRIVATE BOOL IsEmpty
*Purpose:
*  Answer if the address instance table is empty.
*
*Entry:
*  None
*
*Exit:
*  return value = BOOL, TRUE if empty, FALSE otherwise
*
***********************************************************************/
BOOL
CMallocSpy::IsEmpty()
{
    UINT u;

    for(u = 0; u < DIM(m_rganode); ++u)
    {
        if(m_rganode[u] != NULL) return FALSE;	// something leaked
    }

    return TRUE;
}

/***
*PRIVATE CMallocSpy::DumpInstTable()
*Purpose:
*  Print the current contents of the address instance table,
*
*Entry:
*  None
*
*Exit:
*  None
*
***********************************************************************/
void
CMallocSpy::DumpInstTable()
{
    UINT u;
    CAddrNode32 FAR* pn;

    for(u = 0; u < DIM(m_rganode); ++u)
    {
        for(pn = m_rganode[u]; pn != NULL; pn = pn->m_pnNext)
        {
	        VerifyHeaderTrailer(pn);
	        DumpInst(pn);
        }
    }
}

/***
*PRIVATE void CMallocSpy::VerifyHeaderTrailer()
*Purpose:
*  Inspect allocations for signature overwrites.
*
*Entry:
*  None
*
*Exit:
*  return value = None.
*
***********************************************************************/
VOID CMallocSpy::VerifyHeaderTrailer(CAddrNode32 FAR* pn)
{
    XCHAR sz[50];
    XCHAR sz2[100];
    
    if (MEMCMP((char FAR*)pn->m_pv + pn->m_cb, g_rgchTail, TRAILERSIZE) != 0) 
    {
        // DumpInst(pn);
        MEMCPY(sz, (char FAR*)pn->m_pv + pn->m_cb, TRAILERSIZE);
        sz[TRAILERSIZE] = 0;
        apSPrintf(sz2, XSTR("32-bit memory trailer corrupt on alloc of %ld bytes"), pn->m_cb);
        apLogFailInfo(sz2, g_rgchTail, sz, XSTR(""));
        apEndTest();
    }
  
    if (MEMCMP((char FAR*)pn->m_pv - HEADERSIZE, g_rgchHead, HEADERSIZE) != 0) 
    {
        // DumpInst(pn);
        MEMCPY(sz, (char FAR*)pn->m_pv - HEADERSIZE, HEADERSIZE);
        sz[HEADERSIZE] = 0;
        apSPrintf(sz2, XSTR("32-bit memory header corrupt on alloc of %ld bytes"), pn->m_cb);
        apLogFailInfo(sz2, g_rgchHead, sz, XSTR(""));
        apEndTest();
    }
}


/***
*PRIVATE void CMallocSpy::HeapCheck()
*Purpose:
*  Inspect allocations for signature overwrites.
*
*Entry:
*  None
*
*Exit:
*  return value = None.
*
***********************************************************************/
VOID CMallocSpy::HeapCheck()
{
    UINT u;
    CAddrNode32 FAR* pn;


    if (m_cHeapChecks++ < g_cHeapCheckInterval) 
    {
	    return;
    }
    m_cHeapChecks = 0;		// reset

    for (u = 0; u < DIM(m_rganode); ++u) 
    {
        for (pn = m_rganode[u]; pn != NULL; pn = pn->m_pnNext) 
        {
	        VerifyHeaderTrailer(pn);
        }
    }
}


void
CMallocSpy::CheckForLeaks()
{
    if (!IsEmpty()) 
    {
        DumpInstTable();
        apEndTest();        // make sure a failure get recorded
    }
}





//---------------------------------------------------------------------
//                     Helper routines
//---------------------------------------------------------------------
STDAPI GetMallocSpy(IMallocSpy FAR* FAR* ppmallocSpy)
{
    *ppmallocSpy = &myMallocSpy;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\btools\tldiff\utils.cxx ===
#include <iostream.h>
#include <assert.h>
#include <windows.h>
#include "types.h"
#include "array.hxx"

extern bool g_fWriteToStdOut;

//
//
//
bool 
CompareBuffer(char* pBuff1, char* pBuff2, unsigned long nLen)
{
    for ( unsigned long i=0; i<nLen; i++ )
        if (pBuff1[i] != pBuff2[i])
            return false;
    return true;
}

bool 
CompareBufferNoCase( char* pBuff1, char* pBuff2, unsigned long nLen)
{
    // or ing with 0x20 always gives the lower case for ASCII characters.
    // this way we can compare case insensitive.
    for ( unsigned long i=0; i<nLen; i++ )
        if ( (pBuff1[i]|0x20) != (pBuff2[i]|0x20)  )
            return false;
    return true;
}


//
//
//
void 
WriteLine(HANDLE file, char* pBuff, int nLen)
{
    DWORD   dwSize;
    char    szBuff[2] = {0x0d, 0x0a};
    
    if (-1 == nLen)
    {
        nLen = lstrlen( pBuff );
    }
    
    WriteFile(file, pBuff, nLen, &dwSize, NULL);
    WriteFile(file, &szBuff, 2, &dwSize, NULL);
}


//
//
//
unsigned long 
FindEndOfLine( char* pBuff )
{
    char* pWalk = pBuff;
    
    while ( *pWalk != 0x0d )
        pWalk++;
    
    return ((unsigned long)(pWalk-pBuff));
}

//
//
//
bool 
GetLine(HANDLE file, char** ppTarget)
{
    //buffer
    char* pchBuff;
    unsigned long ulBuffIdx;
    unsigned long ulBuffSize = SZ;
    
    // Read variables
    DWORD   dwRead=0;
    BOOL    bRes;
    
    //allocate the initial buffer
    pchBuff = new char[ulBuffSize];
    
    //if we are currently positioned at wherever the previous 
    //operation left us, skip the carriage returns and 
    //get to the real data.
    pchBuff[0] = 0x0d;
    while (( pchBuff[0] == 0x0d ) || ( pchBuff[0] == 0x0a ))
    {
        bRes = ReadFile( (HANDLE)file, pchBuff, 1, &dwRead, NULL);
        if ( !bRes || !dwRead )
            return false;
    }
    
    
    //get the buffer until you reach the terminating character.
    //the first character of the buffer is filled. ulBuffIdx always points
    //to the char. to be read.
    ulBuffIdx = 1;
    
    BOOL fContinue = true;
    
    while( fContinue )
    {
        bRes = ReadFile( (HANDLE)file, &pchBuff[ulBuffIdx], 1, &dwRead, NULL);
        
        if ( !bRes || !dwRead )
            return false;
        
        //was this the terminating character?
        if ( pchBuff[ulBuffIdx] == 0x0A )
        {
            fContinue = false;
        }
        
        ulBuffIdx++;    //always point to the character to be read.
        
        //did we reach the end of the buffer? If so, enlarge buffer
        if ( 0 == (ulBuffIdx % SZ) )
        {
            //allocate new memory chunk
            char* pTmp = new char[ulBuffSize+SZ];
            
            //copy data
            memcpy( pTmp, pchBuff, ulBuffSize);
            
            //release old memory
            delete [] pchBuff;
            
            //make the new chunk the current one
            pchBuff = pTmp;
            ulBuffSize += SZ;
        }
    }
    
    pchBuff[ulBuffIdx-2] = 0;
    
    //if there is a receiving pointer and it is 
    //initialized to NULL properly
    if ((ppTarget) && (*ppTarget==NULL))
    {
        *ppTarget = pchBuff;
    }
    else
    {
        //since there are no valid receivers of the buffer,
        //we can delete it.
        delete [] pchBuff;
    }
    
    return true;
}

//----------------------------------------------------------------------------
//  Function    :   GetBlockType
//  Description :   Get a block of memory that is the first line 
//                  of a block, and determine the block type, by 
//                  checking the first characters on the line
//  Parameters  :
//          char*   :   pointer to the buf. that contains the line
//
//  Returns     :   Returns the type of the block ( enumeration BLOCK_TYPE)
//----------------------------------------------------------------------------
BLOCK_TYPE 
GetBlockType( char* pchData, char* pchTerm )
{
    assert( pchData );
    assert( pchTerm );
    
    switch (*pchData)
    {
    case 'd':
        *pchTerm = '}';         //end of block
        return BLK_DISPINT;
        break;
        
    case 'i':
        *pchTerm = '}';         //end of block
        return BLK_INTERFACE;
        break;
        
    case 'c':
        *pchTerm = '}';         //end of block
        return BLK_COCLASS;
        break;
        
    case 't':
        *pchTerm = ';';         //end of type definition
        return BLK_TYPEDEF;
        break;
        
    case '[':
        *pchTerm = ']';         //end of attribute
        return BLK_ATTR;
        break;
        
    default:
        *pchTerm = 0x0a;        //end of line
        return BLK_NONE;
        break;
    }
}

//
//
//
bool 
GetBlock(HANDLE file, INDEX* pIdx, char** ppTarget = NULL, unsigned long* pulBlockBase = NULL )
{
    char *          pchBuff;          //buffer
    unsigned long   ulBuffIdx;        //walking pointer
    unsigned long   ulBuffBase;       //end of the last memory chunk.
    unsigned long   ulBlockBase;      //beginning of the actual block, 

    //after the funny characters are skipped
    unsigned long   ulBuffSize = SZ+1; // the extra character is for the NULL termination.
    unsigned long   ulLines = 0;
    BOOL            fContinue = TRUE;
    
    //read variables
    DWORD           dwRead=0;
    BOOL            bRes;
    char            chTerm;
    
    assert(pIdx);
    
    if ( ppTarget )
        *ppTarget = NULL;       //reset the pointer to be returned.
    
    //allocate the initial buffer
    pchBuff = new char[ulBuffSize];
    ulBuffBase = ulBuffIdx = ulBlockBase = 0;
    
    //we are currently positioned at wherever the previous 
    //operation left us. learn where we are and start to read.
    pIdx->ulStartPos = SetFilePointer( (HANDLE)file, 0, NULL, FILE_CURRENT);
    
    while( fContinue ) 
    {
        //read a block from the file.
        bRes = ReadFile( (HANDLE)file, &pchBuff[ulBuffIdx], SZ, &dwRead, NULL);
        
        //if there was a failure or we had reached the end of the file.
        if ( !bRes || !dwRead )
            return false;
        
        //skip the possible 0d 0a sequences at the beginning and process the rest of 
        //the message.
        if ( ulBuffIdx== 0 )
        {
            while((pchBuff[ulBuffIdx] == 0x0D ) || 
                ( pchBuff[ulBuffIdx] == 0x0A ) ||
                ( pchBuff[ulBuffIdx] == 0x20 ))
            {
                ulBuffIdx++;                    //read position in the buffer
                ulBlockBase++;                  //increment the buffer base position.
                pIdx->ulStartPos++;             //start position in the file.
            }
            
            //if we reached the end of file by doing this, return. There is nothing left.
            if (dwRead==ulBuffIdx)
                return false;
            
            //now we are pointing to the actual data, learn the terminating
            //character and terminate this loop.
            pIdx->blockType = GetBlockType(&pchBuff[ulBuffIdx], &chTerm);
        }
        
        //walk until you reach the terminating character or the end of the read buffer
        while ((ulBuffIdx<(ulBuffBase+dwRead)) && (pchBuff[ulBuffIdx] != chTerm))
        {
            //check for the 0x0A to determine the number of lines
            //the linefeed after the chTerm is found is taken care of
            //in the spin routine for the empty lines.
            if (pchBuff[ulBuffIdx] == 0x0A )
                ulLines++;
            
            ulBuffIdx++;
        }
        
        //did we reach the end of the buffer or found the chTerm character
        if (ulBuffIdx == ulBuffSize - 1)
        {
            char* pTmp = new char[ulBuffSize+SZ];   //allocate new memory chunk
            memcpy( pTmp, pchBuff, ulBuffSize);     //copy data
            delete [] pchBuff;                      //release old memory
            pchBuff = pTmp;                         //make the new chunk the current one
            ulBuffSize += SZ;                       //adjust the buffer size
            ulBuffBase = ulBuffIdx;                 //reset the base to the current limit
        }
        else
        {
            //we found the terminating character.
            ulBuffIdx++;        //always point to the character to be read next.
            break;
        }
    }
    
    // Subtract the block base, If there were 0d0a pairs, we incremented both
    // ulStartPos and ulBuffIdx, and doubled the effect of the skipping these
    // characters. Compensation is provided by -ulBlockBase ...
    pIdx->ulEndPos = pIdx->ulStartPos + ulBuffIdx - ulBlockBase;
    
    // If the terminating character was a line break, we don't want it to go 
    // into the record as a part of this line
    if ( chTerm == 0x0a )
    {
        pIdx->ulEndPos -= 2;
        ulBuffIdx -= 2;
    }
    
    // Reset the pointer to the end of this block.  
    SetFilePointer( (HANDLE)file, pIdx->ulEndPos, NULL, FILE_BEGIN);
    
    // Terminate the buffer, since the index always shows the next 
    // position available, subtract 1 from the index.
    pchBuff[ulBuffIdx] = 0;
    
    // If there is a receiving pointer and it is 
    // initialized to NULL properly
    if ((ppTarget) && (*ppTarget==NULL) && (pulBlockBase))
    {
        *ppTarget = pchBuff;
        *pulBlockBase = ulBlockBase;
    }
    else
    {
        // Since there are no valid receivers of the buffer,
        // we can delete it.
        delete [] pchBuff;
    }
    
    return true;
}

//
//  Compare two attribute blocks. Attribute blocks are placed before interface descriptions 
//  and coclass descriptions.
//  dual --> breaker for both coclass and interface if added/removed
//  uuid(...) --> breaker for interfaces of all kinds if the contents of the uuid is changed
//
//  Return Value:
//  The return value from this function 0 if there are no differences between these two blocks
//  otherwise an error code is returned.

long
CompareAttributeBlock(  char * pRefBuf, 
                        CAutoArray<ATTRINFO>*   pRefList, 
                        char * pCurBuf,
                        CAutoArray<ATTRINFO>*   pCurList)
{
    char        szDual[] = {"dual"};
    char        szUuid[] = {"uuid"};
    char *      pszAttr;
    ATTRINFO    attrCur, attrRef;
    int         i, j, k;
    long        lErr;


    // For all of the attributes that are in the reference list, if the attribute is one of 
    // the attributes that we care about, we will make sure that the current list contains 
    // the same attribute.
    for ( i=0; i < pRefList->Size(); i++ )
    {
        pRefList->GetAt(i, &attrRef);

        if (attrRef.ulAttrLength == 4)
        {
            pszAttr = szDual;
            lErr    = CHANGE_DUALATTRREMOVED;
        }
        else if (attrRef.ulAttrLength == 42)
        {
            pszAttr = szUuid;
            lErr    = CHANGE_UUIDHASCHANGED;
        }
        else
            continue;

        assert(pszAttr);

        // is this attribute one of those that we want to check for?
        for (j=0; j<4; j++)
            if( pszAttr[j] != pRefBuf[attrRef.ulAttrStart+j])
                break;

        // We don't want to compare this attribute.
        if (j != 4)
            continue;

        // we care about this attribute. It MUST be in the current attribute block 
        for (k=0; k < pCurList->Size(); k++)
        {
            pCurList->GetAt(k, &attrCur);

            if ((!attrCur.fUsed) && 
                (0 == memcmp( pRefBuf+attrRef.ulAttrStart, 
                                pCurBuf+attrCur.ulAttrStart, 
                                attrRef.ulAttrLength)))
            {
                // if the attribute is found, then mark the current list so we skip
                // over this one next time.
                attrCur.fUsed = true;
                pCurList->Set(k, attrCur);

                // shortcut...
                break;
            }
        }
        
        // if we did not find the same attribute, return the error code that is in lErr
        if (k == pCurList->Size())
            return lErr;
    }

    // check for things that are added to the current list, 
    // but don't exist in the reference list. If something we check for is added, this is a breaker.
    for ( i=0; i < pCurList->Size(); i++)
    {
        pCurList->GetAt(i, &attrCur);

        if (!attrCur.fUsed)
        {
            // only check for "dual" here.
            pszAttr = szDual;

            for (j=0; j<4; j++)
                if( pszAttr[j] != pCurBuf[attrCur.ulAttrStart+j])
                    break;

            if (j==4)
                return CHANGE_DUALATTRADDED;
        }
    }

    return 0;
}

void 
TokenizeAttributes( char* pBuf, unsigned long nCnt, CAutoArray<ATTRINFO>* pList )
{
    unsigned long i,j;
    ATTRINFO    attrInfo;

    attrInfo.ulAttrStart = 0;

    // the first attribute is always at 0
    for ( i=0, j=0; i<= nCnt; i++, j++ )
    {
        if ( ( pBuf[i] == ',' ) || (i==nCnt) )
        {
            attrInfo.ulAttrLength = i- attrInfo.ulAttrStart;
            attrInfo.fUsed = false;

            pList->Append( attrInfo );

            i += 2;

            attrInfo.ulAttrStart = i;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\btools\tlviewer\hostenv.h ===
/*** 
*hostenv.h
*
*  Copyright (C) 1992-93, Microsoft Corporation.  All Rights Reserved.
*
*Purpose:
*  Generic host specific includes.
*
*Implementation Notes:
*
*****************************************************************************/
#if defined(_MAC)

# include <values.h>
# include <types.h>
# include <strings.h>
# include <quickdraw.h>
# include <fonts.h>
# include <events.h>
# include <resources.h>
# include <windows.h>
# include <menus.h>
# include <textedit.h>
# include <dialogs.h>
# include <desk.h>
# include <toolutils.h>
# include <memory.h>
# include <files.h>
# include <osutils.h>
# include <osevents.h>
# include <diskinit.h>
# include <packages.h>
# include <traps.h>
# include <AppleEvents.h>

#include <stdio.h>

#define HINSTANCE long
#define HWND      long
#define ULONG unsigned long
#define LONG long
#define UINT unsigned int
#define NEARDATA
#define NEAR
#define EXPORT
#define FAR
#define LPVOID void FAR *
#define UNUSED(X) ((void)(void*)&(X))
#define WORD unsigned short
#define BOOL unsigned long
#define DWORD unsigned long
#define TRUE 1
#define FALSE 0
#define SHORT short

#ifndef _PPCMAC
#define PASCAL pascal
#define CDECL  
#else
#define PASCAL
#define CDECL 
#endif

#else
#include <windows.h>
#ifndef CDECL
#define CDECL _cdecl
#endif
#endif

#include <ole2.h>
#include <stdarg.h>
#include <stdio.h>
#if !defined(WIN32)
#include <olenls.h>
#include <dispatch.h>
#else
#include <oleauto.h>
#if defined(_ALPHA_)
//#include <cobjerr.h>
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\btools\tlviewer\apglobal.cpp ===
/*** 
*apglobal.cpp - Ffile for the C/C++ version of the apglobal functions 
*
*  Copyright (C) 1992, Microsoft Corporation.  All Rights Reserved.
*  Information Contained Herein Is Proprietary and Confidential.
*
*Purpose: This allows tests written in C to write debug info in the same manner 
*           as our Basic tests. 
*
*Revision History:
*
* [00]  25-Nov-92      chriskau : created
* [01]  13-Dec-92      Brandonb : changed to DLL, added apLogExtra
* [02]  26-Jan-93      ChrisK   : added exe.don support to apEndTest
* [03]  23-Feb-93      ChrisK   : reset iFailFlag and icErrorCount on apInitTest
* [04]  14-Jan-94      Mesfink  : Modified to enable 32bit compilation & unicode
*Implementation Notes:  
*
*****************************************************************************/
#include "hostenv.h"
#define _APGLOBAL_
#include "apglobal.h"
#define     wcsicmp     _wcsicmp


#define APLOGFAIL_MAX   254
#define AMAX            255

#define RESULTS_TXT     "results.txt" 
#define RESULTS_LOG     "results.log" 
#define OLEAUTO_PRF     "oleauto.prf" 
#define RESULTS_TXTX    SYSSTR("results.txt") 
#define RESULTS_LOGX    SYSSTR("results.log") 
#define OLEAUTO_PRFX    SYSSTR("oleauto.prf") 

#define RESULTS_DEB     "results.deb"       
#define RESULTS_DON     "exe.don"           
#define RES_PATH        "c:\\school\\"
#define PASS_STR        SYSSTR("PASSED       ")
#define FAIL_STR        SYSSTR("FAILED ***** ")
#define RUN_STR         SYSSTR("RUNNING **** ")



// vars for output of testing/failure info
SYSCHAR     szTest[255];
SYSCHAR     szScenario[255];
SYSCHAR     szLastTest[255]     = SYSSTR("");
SYSCHAR     szLastScen[255]     = SYSSTR("");
SYSCHAR     szBugNumber[255];
int         iFailFlag;

// vars for bookkeeping
int         icErrorCount;
long        icLogFileLocation;
long        icPrfFileLocation;
int         fInTest;


// vars for thread and process syncronization on win95/NT
#if defined(_MT)
HANDLE              hmutexTxt;
HANDLE              hmutexLog;
HANDLE              hmutexPrf;
#endif


/* -------------------------------------------------------------------------
   NAME: Unicode2Ansi lWriteAnsi lOpenAnsi lCreatAnsi

   Revision:

      [0]   19-01-94    MesfinK:     Created
   -------------------------------------------------------------------------*/

/*LPSTR Unicode2Ansi(SYSCHAR FAR * szString)
{
#if defined(UNICODE)
	char AnsiBuffer[AMAX];
	int iCount;

	iCount=lstrlen(szString);
	if(WideCharToMultiByte(CP_ACP,WC_COMPOSITECHECK, szString,iCount+1,(LPSTR)
		AnsiBuffer,AMAX,NULL,NULL))
		return (LPSTR)AnsiBuffer;
	else
		return NULL;
#else
	return (LPSTR)szString;
#endif
}*/

SIZE_T lWriteAnsi(FILETHING hfile, SYSCHAR FAR *szString, int iCount)
{
#if defined(UNICODE)
	char AnsiBuffer[AMAX];
	if(!WideCharToMultiByte(CP_ACP,WC_COMPOSITECHECK, szString, iCount+1, (LPSTR)
		AnsiBuffer, AMAX, NULL, NULL))
		return (SIZE_T)HFILE_ERROR;
	else
	    return fwrite(AnsiBuffer, 1, (short)iCount, hfile);
#elif defined(WIN16)
	return _lwrite(hfile,(LPSTR)szString,(short)iCount);
#else
	return fwrite(szString, 1, (short)iCount, hfile);
#endif
}

FILETHING lOpenAnsi(char FAR *szFileName)
{
    FILETHING hfTemp;
#if defined(WIN16)
    
    hfTemp = _lopen(szFileName, WRITE);

    if (hfTemp == HFILE_ERROR)
	    hfTemp = _lcreat(szFileName, 0);
    else
	_llseek(hfTemp, 0, 2);

    return hfTemp;
#else
    hfTemp = fopen(szFileName, "r+b");
    if (hfTemp == NULL)
        hfTemp = fopen(szFileName, "wb");
    else
        fseek(hfTemp, 0, SEEK_END); 
    return hfTemp;
#endif
}



int lCloseAnsi(FILETHING f)
{
#if defined(WIN16)
   return _lclose(f);
#else
    return fclose(f);
#endif
}

/* -------------------------------------------------------------------------
   NAME: FilePrintf

   Revision:

      [0]   12-07-92    BrandonB     Created
   -------------------------------------------------------------------------*/
int _cdecl 
FilePrintf(FILETHING hfile, SYSCHAR FAR * szFormat, ...)
{
    int x;
    SYSCHAR szBuf[1024];
#if defined(WIN16)
    char szLocal[256];
#endif

    
#if defined(_ALPHA_)
    va_list args;
    args.offset=4;
#else
    char FAR *args;
#endif    

    if (szFormat != NULL)
    {
#if defined(_ALPHA_)
	args.a0 = ((char FAR *)(&szFormat))+4;
#else
	args =((char FAR *)(&szFormat))+4;
#endif
#if defined(_NTWIN)
	x = vswprintf(szBuf, szFormat, args);
#else
#if defined(WIN16)
    x = wvsprintf(szBuf, szFormat, args);
#else    
	x = vsprintf(szBuf, szFormat, args);
#endif
#endif       
	if (lWriteAnsi(hfile, szBuf, lstrlen(szBuf)) == NULL)
	    return(-1);                                     
    }
    return (0);
}


#if 0

/* -------------------------------------------------------------------------
   NAME: apInitTest

   Description: This function initializes a testcase.  The name of the
		testcase is written to results.txt and a global variable
		is set to the same value.

   Input: szTestName - char * pointing to the name of the testcase

   Output: (return) - 0 if no error, -1 if there was an error

   Revision:

      [0]   11-24-92    ChrisKau     Created
      [1]   12-04-92    BrandonB     changed to use only windows call

   -------------------------------------------------------------------------*/
extern "C" int FAR  PASCAL
apInitTestCore (SYSCHAR FAR * szTestName)
{   
    FILETHING hfResultsTxt;
    char      szFullFileName[255];
    

    if (fInTest == TRUE)
    {
        // log error information
        FILETHING hfResultsLog;
        
        lstrcpyA(szFullFileName, RES_PATH);                      
        lstrcatA(szFullFileName, RESULTS_LOG);

#if defined(_MT)
        WaitForSingleObject(hmutexLog, INFINITE);
#endif                
        hfResultsLog = lOpenAnsi(szFullFileName);

        if (hfResultsLog == NULL)
    	    goto Done;

	    FilePrintf(hfResultsLog, SYSSTR("\r\n========================================\r\n") );
	    FilePrintf(hfResultsLog, SYSSTR(" Begin: %s\r\n\r\n"), (LPSYSSTR )szTest);							    
        FilePrintf(hfResultsLog, SYSSTR("\r\n ________________\r\n %s\r\n"), (LPSYSSTR )szScenario);
        FilePrintf (hfResultsLog, SYSSTR(" !!! apInitTest called before previous test ended!\r\n")); 
        iFailFlag++;                                             
        FilePrintf (hfResultsLog, SYSSTR(" ________________\r\n"));
        lCloseAnsi(hfResultsLog);
Done:;
#if defined(_MT)
        ReleaseMutex(hmutexLog);
#endif                
        apEndTest();
        return(-1);
    }
    else fInTest = TRUE;

    iFailFlag = 0;                                           
    icErrorCount = 0;                                        
    szBugNumber[0] = 0;
    
    wsprintf( szTest, SYSSTR("%-20s") , szTestName);
    if (!(szTestName))
        return(-1);                                           

    lstrcpyA(szFullFileName, RES_PATH);        
    lstrcatA(szFullFileName, RESULTS_TXT);

#if defined(_MT)
    WaitForSingleObject(hmutexTxt, INFINITE);
#endif                
    hfResultsTxt = lOpenAnsi(szFullFileName);

    if (hfResultsTxt == NULL)
    {
#if defined(_MT)
        ReleaseMutex(hmutexTxt);
#endif                
	    return(-1);
	}    
								   
    if (lWriteAnsi(hfResultsTxt, (SYSCHAR FAR * )szTest, lstrlen(szTest)) == NULL)
    {
#if defined(_MT)
        ReleaseMutex(hmutexTxt);
#endif                
	    return(-1);
	}    

#if defined(WIN32)
    if ((icLogFileLocation = ftell(hfResultsTxt)) == -1)
    {
#if defined(_MT)    
        ReleaseMutex(hmutexTxt);
#endif        
        lCloseAnsi(hfResultsTxt);                                   
	    return(-1);
    }
#else // win16
    if ((icLogFileLocation = _llseek(hfResultsTxt, 0, 1)) == HFILE_ERROR)
    {
        lCloseAnsi(hfResultsTxt);                                   
	    return(-1);
    }
#endif     
    else FilePrintf(hfResultsTxt,SYSSTR("%-70s\r\n") , RUN_STR);


    lCloseAnsi(hfResultsTxt);                                   
#if defined(_MT)
    ReleaseMutex(hmutexTxt);
#endif                

    apWriteDebugCore(SYSSTR("%s\n") , (SYSCHAR FAR * )szTest);                
 
    return(0);
}

/* -------------------------------------------------------------------------
   NAME: apInitScenario

   Description: This function initializes a scenario.  The name of the
		scenario is written to the debug window and a global
		variable is set to the same value.

   Input: szScenarioName - SYSCHAR  * pointing to the name of the scenario

   Output: (return) - 0 if no error, -1 if there was an error

   Revision:

      [0]   11-24-92    ChrisKau     Created
      [1]   12-04-92    BrandonB     changed to use only windows calls etc.
	  [2]   01-28-94        MesfinK          added API & NLS information.
   -------------------------------------------------------------------------*/
extern "C" int FAR  PASCAL 
apInitScenarioCore (SYSCHAR FAR * szScenarioName)
{
   
   lstrcpy((SYSCHAR FAR * )szScenario, (SYSCHAR FAR * )szScenarioName);       
   szLastScen[0] = 0;                                               

   apWriteDebugCore(SYSSTR("%s\n") , (SYSCHAR FAR * )szScenarioName);       
   return(0);
}


#endif //0
   
    
/* -------------------------------------------------------------------------
   NAME: apLogFailInfo

   Description: This call takes four strings, and writes out the error
		information to results.txt and results.log files.

   Input: szDescription - SYSCHAR  * describing what went wrong
	  szExpected - SYSCHAR  * expected value of testcase
	  szActual - SYSCHAR  * actual value of testcase
	  szBugNum - SYSCHAR  * bug number in RAID data base

   Output: (return) - 0 if no error, -1 if there was an error

   Revision:

      [0]   11-24-92    ChrisKau     Created
      [1]   12-04-92    BrandonB     changed to use only windows call
      [2]   02-03-94    ChrisK       Change to handle WIN16/WIN32/UNICODE
   -------------------------------------------------------------------------*/
extern "C" int FAR  PASCAL
apLogFailInfoCore (LPSYSSTR szDescription, LPSYSSTR szExpected, LPSYSSTR szActual, LPSYSSTR szBugNum)
{
    FILETHING hfResultsLog;
    char      szFullFileName[255];
    
    lstrcpyA(szFullFileName, RES_PATH);                      
    lstrcatA(szFullFileName, RESULTS_LOG);

#if defined(_MT)
    WaitForSingleObject(hmutexLog, INFINITE);
#endif                
    hfResultsLog = lOpenAnsi((char FAR *)szFullFileName);

    if (hfResultsLog == NULL)
    {
#if defined(_MT)
        ReleaseMutex(hmutexLog);
#endif // _MT               
	    return(-1);
	}    

	if (fInTest != TRUE)
	{
	    // log failure info or warn of mem leak
	}

    if (lstrcmp(szTest, szLastTest))                                                                                     
	{                                                       							    
	    FilePrintf(hfResultsLog, SYSSTR("\r\n========================================\r\n") );
	    FilePrintf(hfResultsLog, SYSSTR(" Begin: %s\r\n\r\n"), (LPSYSSTR)szTest);							    
	    apWriteDebugCore(SYSSTR("\n========================================\n\n"));
	    apWriteDebugCore(SYSSTR(" Begin: %s\n\n"), (LPSYSSTR)szTest);      
	    lstrcpy(szLastTest, szTest);                          
    }

    if (lstrcmp(szScenario, szLastScen))                                                                                  
    {                                                                                                                    
        FilePrintf(hfResultsLog, SYSSTR("\r\n ________________\r\n %s\r\n"), (LPSYSSTR)szScenario);
        apWriteDebugCore(SYSSTR("\n ________________\n %s\n"), (LPSYSSTR)szScenario);
        lstrcpy(szLastScen, szScenario);                      
    }

    iFailFlag++;                                             

    if (lstrlen(szDescription))                              
    {                                                        
        FilePrintf (hfResultsLog, SYSSTR(" !!! %s\r\n"), (LPSYSSTR)szDescription); 
        apWriteDebugCore (SYSSTR(" !!! %s\n"), (LPSYSSTR)szDescription);
    }

    if (lstrlen(szExpected)+lstrlen(szActual))               
    {
        FilePrintf(hfResultsLog, SYSSTR(" Expected: %s\r\n"), (LPSYSSTR)szExpected);
        FilePrintf(hfResultsLog, SYSSTR(" Actuals : %s\r\n"), (LPSYSSTR)szActual);
        apWriteDebugCore(SYSSTR(" Expected: %s\n"), (LPSYSSTR)szExpected);
        apWriteDebugCore(SYSSTR(" Actuals : %s\n"), (LPSYSSTR)szActual);
    }

    if (lstrlen(szBugNum))                                   
    {                                                                                                                    
        FilePrintf(hfResultsLog, SYSSTR(" BugNum  : %s\r\n"), (LPSYSSTR)szBugNum);
        apWriteDebugCore(SYSSTR(" BugNum  : %s\n"), (LPSYSSTR)szBugNum);
        lstrcpy(szBugNumber, szBugNum);
    }

    FilePrintf (hfResultsLog, SYSSTR(" ________________\r\n"));
    apWriteDebugCore( SYSSTR(" ________________\n"));

    lCloseAnsi(hfResultsLog);
#if defined(_MT)
    ReleaseMutex(hmutexLog);
#endif                

    return(0);
}


/* -------------------------------------------------------------------------
   NAME: apEndTest

   Description: This function writes out the final passed or failed for
		a particular testcase.

   Input: (none)

   Output: (none) - if there is an error we are already quitting

   Revision

      [0]   11-24-92    ChrisKau     Created
      [1]   12-04-92    BrandonB     changed to use only windows call
   -------------------------------------------------------------------------*/
extern "C" void FAR  PASCAL 
apEndTest()
{
    SYSCHAR     szMessage[25];
    SYSCHAR     szMTOut[255];
    FILETHING   hfResultsTxt;
    char        szFullFileName[255];
        
    if (iFailFlag)                                           
    {
        lstrcpy(szMessage, FAIL_STR);
    }
    else
    {
        lstrcpy(szMessage, PASS_STR);
    }
   
    fInTest = FALSE;
    lstrcpyA(szFullFileName, RES_PATH);
    lstrcatA(szFullFileName, RESULTS_TXT);                            

#if defined(_MT)
    WaitForSingleObject(hmutexTxt, INFINITE);
#endif                
    hfResultsTxt = lOpenAnsi(szFullFileName);

    if (hfResultsTxt == NULL)
    {
#if defined(_MT)
        ReleaseMutex(hmutexTxt);
#endif                
	    return;
	}    

// #if defined(_MT)
    if (!lstrlen(szBugNumber))
        wsprintf(szMTOut, SYSSTR("%s\t%d"), (SYSCHAR FAR * )szMessage, iFailFlag);
    else
        wsprintf(szMTOut, SYSSTR("%s\t%d Bug(s): %s"), (SYSCHAR FAR * )szMessage, iFailFlag, (SYSCHAR FAR * )szBugNumber);

#if defined(WIN32)                
    fseek(hfResultsTxt, icLogFileLocation, SEEK_SET); 
#else // win16
    _llseek(hfResultsTxt, icLogFileLocation, 0); 
#endif       
    FilePrintf(hfResultsTxt,SYSSTR("%-70s\r\n") , (SYSCHAR FAR * )szMTOut);
    apWriteDebugCore(SYSSTR("%-70s\r\n") , (SYSCHAR FAR * )szMTOut);
    lCloseAnsi(hfResultsTxt);
#if defined(_MT)
    ReleaseMutex(hmutexTxt);
#endif
                
    lstrcpyA(szFullFileName, RES_PATH);                
    lstrcatA(szFullFileName, RESULTS_DON);

    hfResultsTxt = lOpenAnsi(szFullFileName);                       
    lCloseAnsi(hfResultsTxt);

    return;
}




#if 0

extern "C" int FAR PASCAL  
apInitPerfCore(SYSCHAR FAR * szServerType, SYSCHAR FAR * szProcType, int bitness, int server_bitness)
{   
    FILETHING hfResultsPrf;
    char      szFullFileName[255];
    SYSCHAR   szMTOut[255];

    
    wsprintf(szMTOut, SYSSTR("*%-30s, %-8s, %d, %d\r\n"), szServerType, szProcType, bitness, server_bitness);

    lstrcpyA(szFullFileName, RES_PATH);        
    lstrcatA(szFullFileName, OLEAUTO_PRF);

#if defined(_MT)
    WaitForSingleObject(hmutexPrf, INFINITE);
#endif                
    hfResultsPrf = lOpenAnsi(szFullFileName);

    if (hfResultsPrf == NULL)
    {
#if defined(_MT)
        ReleaseMutex(hmutexPrf);
#endif                
	    return(-1);
	}    
								   
    if (lWriteAnsi(hfResultsPrf, szMTOut, lstrlen(szMTOut)) == NULL)
    {
#if defined(_MT)
        ReleaseMutex(hmutexPrf);
#endif                
	    return(-1);
	}    

#if defined(WIN32)
    if ((icPrfFileLocation = ftell(hfResultsPrf)) == -1)
    {
#if defined(_MT)    
        ReleaseMutex(hmutexPrf);
#endif        
        lCloseAnsi(hfResultsPrf);                                   
	    return(-1);
    }
#else // win16
    if ((icPrfFileLocation = _llseek(hfResultsPrf, 0, 1)) == HFILE_ERROR)
    {
        lCloseAnsi(hfResultsPrf);                                   
	    return(-1);
    }
#endif     
    else FilePrintf(hfResultsPrf, SYSSTR("%-31s, %8ld, %6.2f\r\n"), SYSSTR("UNKNOWN"), 0, 0.00);


    lCloseAnsi(hfResultsPrf);                                   
#if defined(_MT)
    ReleaseMutex(hmutexPrf);
#endif                

 
    return(0);
}




extern "C" int FAR PASCAL 
apLogPerfCore(SYSCHAR FAR *szTestType, DWORD microsecs, float std_deviation)
{
    FILETHING   hfResultsPrf;
    char        szFullFileName[255];
        
   
    lstrcpyA(szFullFileName, RES_PATH);
    lstrcatA(szFullFileName, OLEAUTO_PRF);                            

#if defined(_MT)
    WaitForSingleObject(hmutexPrf, INFINITE);
#endif                
    hfResultsPrf = lOpenAnsi(szFullFileName);

    if (hfResultsPrf == NULL)
    {
#if defined(_MT)
        ReleaseMutex(hmutexPrf);
#endif                
	    return(-1);
	}    


#if defined(WIN32)                
    fseek(hfResultsPrf, icPrfFileLocation, SEEK_SET); 
#else // win16
    _llseek(hfResultsPrf, icPrfFileLocation, 0); 
#endif       
    FilePrintf(hfResultsPrf, SYSSTR("%-31s, %8ld, %6.2f\r\n"), szTestType, microsecs, std_deviation);
#if defined(WIN32)
    if ((icPrfFileLocation = ftell(hfResultsPrf)) == -1)
    {
#if defined(_MT)    
        ReleaseMutex(hmutexPrf);
#endif        
        lCloseAnsi(hfResultsPrf);                                   
	    return(-1);
    }
#else // win16
    if ((icPrfFileLocation = _llseek(hfResultsPrf, 0, 1)) == HFILE_ERROR)
    {
        lCloseAnsi(hfResultsPrf);                                   
	    return(-1);
    }
#endif     
                
    lCloseAnsi(hfResultsPrf);                                   
#if defined(_MT)
    ReleaseMutex(hmutexPrf);
#endif                
    return(0);
}


#endif //0

/* -------------------------------------------------------------------------
   NAME: apWriteDebugCore

   Description: This function writes a string to the debug window or 
		monochrome monitor or to the results.deb file or to both

   Input: a format sting and a variable number of arguments

   Output: 0 if sucessful, -1 if not

   Revision:

      [0]   12-07-92    BrandonB     Created
   -------------------------------------------------------------------------*/
int FAR _cdecl 
apWriteDebugCore(SYSCHAR FAR * szFormat, ...)
{
    int     x;
    SYSCHAR szBuf[1024];    
//    char    szFullFileName[255];
//    FILETHING hfResultsExtra;
    
#if defined(_ALPHA_)
    va_list args;
    args.offset=4;
#else
    char FAR *args;
#endif    

    if (szFormat != NULL)
    {
#if defined(_ALPHA_)
	args.a0 = ((char FAR *)(&szFormat))+4;
#else
	args =((char FAR *)(&szFormat))+4;
#endif
	x = wvsprintf(szBuf, szFormat, args);
    }
    else return (-1);


    // if (fDebTrace == TRUE) 
        OutputDebugString(szBuf);
			    
/*
    if (fFileTrace == TRUE)
    {
	lstrcpyA(szFullFileName, RES_PATH);        // create full path name
	lstrcatA(szFullFileName, RESULTS_DEB);

	hfResultsExtra = lOpenAnsi(szFullFileName);

	if (hfResultsExtra == NULL)
	    return(-1);       
       
	if (lWriteAnsi(hfResultsExtra, szBuf, lstrlen(szBuf)) == NULL)
	    return(-1);                                     

	lCloseAnsi(hfResultsExtra);                                 // close results file
    }
*/    
    Yield();
    return(0);
}


#if 0


#if defined(UNICODE)
extern "C" int FAR PASCAL
apInitTestA (LPSTR szTestName)
{
	SYSCHAR szTestNameW[255];

	if (lstrlenA(szTestName) <= 126)
	{
		MultiByteToWideChar(CP_ACP,
				    MB_PRECOMPOSED,
				    szTestName,
				    -1,
				    szTestNameW,
				    255);

		return apInitTestCore (szTestNameW);
	}
	else
	{
		return -1;
	}
}


extern "C" int FAR  PASCAL
apInitScenarioA (LPSTR szScenarioName)
{
	SYSCHAR szScenarioNameW[255];

	if (lstrlenA(szScenarioName) <= 126)
	{
		MultiByteToWideChar(CP_ACP,
				    MB_PRECOMPOSED,
				    szScenarioName,
				    -1,
				    szScenarioNameW,
				    255);

		return apInitScenarioCore(szScenarioNameW);
	}
	else
	{
		return -1;
	}
}


// ANSI version that is exposed when the system is unicode version
/* -------------------------------------------------------------------------
   NAME: apLogFailInfoA

   Description: This call takes four ansi strings, converts them to
		unicode and calls the wide version of apLogFailInfo.

   Input: szDescription - LPSTR describing what went wrong
	  szExpected - LPSTR expected value of testcase
	  szActual - LPSTR actual value of testcase
	  szBugNum - LPSTR bug number in RAID data base

   Output: (return) - 0 if no error, -1 if there was an error

   Revision:

      [0]   11-24-92    ChrisKau     Created
      [1]   12-04-92    BrandonB     changed to use only windows call
	  [2]   01-18-94        Mesfink          modified to enable UNICODE.            
      [3]   02-03-94    ChrisK       Made apLogFailInfoA out of everything else
   -------------------------------------------------------------------------*/
// this should be an even number for 'nice' reasons

extern "C" int FAR PASCAL
apLogFailInfoA (LPSTR szDescription, LPSTR szExpected,
		LPSTR szActual, LPSTR szBugNum)
{
	SYSCHAR szDescriptionW[APLOGFAIL_MAX];
	SYSCHAR szExpectedW[APLOGFAIL_MAX];
	SYSCHAR szActualW[APLOGFAIL_MAX];
	SYSCHAR szBugNumW[APLOGFAIL_MAX];

	if (lstrlenA(szDescription) <= (APLOGFAIL_MAX))
	if (lstrlenA(szExpected) <= (APLOGFAIL_MAX))
	if (lstrlenA(szActual) <= (APLOGFAIL_MAX))
	if (lstrlenA(szBugNum) <= (APLOGFAIL_MAX)) {

		MultiByteToWideChar(CP_ACP,
				    MB_PRECOMPOSED,
				    szDescription,
				    -1,
				    szDescriptionW,
				    APLOGFAIL_MAX);

		MultiByteToWideChar(CP_ACP,
				    MB_PRECOMPOSED,
				    szExpected,
				    -1,
				    szExpectedW,
				    APLOGFAIL_MAX);

		MultiByteToWideChar(CP_ACP,
				    MB_PRECOMPOSED,
				    szActual,
				    -1,
				    szActualW,
				    APLOGFAIL_MAX);

		MultiByteToWideChar(CP_ACP,
				    MB_PRECOMPOSED,
				    szBugNum,
				    -1,
				    szBugNumW,
				    APLOGFAIL_MAX);

		return (apLogFailInfoCore(szDescriptionW, szExpectedW, szActualW, szBugNumW));
	}
	else
	{
		return (-1);
	}
	else
	{
		return (-1);
	}
	else
	{
		return (-1);
	}
	else
	{
		return (-1);
	}

}



/* -------------------------------------------------------------------------
   NAME: apWriteDebugA

   Description: This function writes a string to the debug window or 
		monochrome monitor or to the results.deb file or to both

   Input: a format sting and a variable number of arguments

   Output: 0 if sucessful, -1 if not

   Revision:

      [0]   02-04-94    BrandonB     Created
   -------------------------------------------------------------------------*/
extern "C" int FAR _cdecl 
apWriteDebugA(char FAR * szFormat, ...)
{
    int     x;
    char    szANSIBuf[1024];    
//    FILETHING hfResultsExtra;
//    char    szFullFileName[255];
        
#if defined(_ALPHA_)
    va_list args;
    args.offset=4;
#else
    char FAR *args;
#endif    

    if (szFormat != NULL)
    {
#if defined(_ALPHA_)
	args.a0 = ((char FAR *)(&szFormat))+4;
#else
	args =((char FAR *)(&szFormat))+4;
#endif
	x = wvsprintfA(szANSIBuf, szFormat, args);
    }
    else return (-1);


    // if (fDebTrace == TRUE) 
        OutputDebugStringA(szANSIBuf);
			    
/*
    if (fFileTrace == TRUE)
    {
	lstrcpyA((char FAR * )szFullFileName, (char FAR * )RES_PATH);        
	lstrcatA((char FAR * )szFullFileName, (char FAR * )RESULTS_DEB);

	hfResultsExtra = lOpenAnsi(szFullFileName);

       
	if (hfResultsExtra == NULL)
	    return(-1);                                          
       
	fwrite( (LPSTR)szANSIBuf, 1, lstrlenA(szANSIBuf), hfResultsExtra);

	lCloseAnsi(hfResultsExtra);                                 
    }
*/
    Yield();
    return(0);
}





extern "C" int FAR PASCAL  
apInitPerfA(char * szServerType, char * szProcType, int bitness, int server_bitness)
{
	SYSCHAR szServerTypeW[255];
	SYSCHAR szProcTypeW[255];

	if ((lstrlenA(szServerType) <= 254) && (lstrlenA(szProcType) <= 254))
	{
		MultiByteToWideChar(CP_ACP,
				    MB_PRECOMPOSED,
				    szServerType,
				    -1,
				    szServerTypeW,
				    255);
				    
		MultiByteToWideChar(CP_ACP,
				    MB_PRECOMPOSED,
				    szProcType,
				    -1,
				    szProcTypeW,
				    255);

		return apInitPerfCore(szServerTypeW, szProcTypeW, bitness, server_bitness);
	}
	else
	{
		return(-1);
	}
}




extern "C" int FAR PASCAL 
apLogPerfA(char *szTestType, DWORD microsecs, float std_deviation)
{
	SYSCHAR szTestTypeW[255];

	if (lstrlenA(szTestType) <= 254)
	{
		MultiByteToWideChar(CP_ACP,
				    MB_PRECOMPOSED,
				    szTestType,
				    -1,
				    szTestTypeW,
				    255);

		return apLogPerfCore(szTestTypeW, microsecs, std_deviation);
	}
	else
	{
		return(-1);
	}
}










#endif // UNICODE

#endif //0


#if defined(WIN32) && !defined(UNICODE)  // chicago and win32s
#include <wchar.h>

LPWSTR  FAR PASCAL  lstrcatWrap(LPWSTR sz1, LPWSTR sz2)
{
    return wcscat(sz1, sz2);
}


LPWSTR  FAR PASCAL  lstrcpyWrap(LPWSTR sz1, LPWSTR sz2)
{
    return wcscpy(sz1, sz2);
}


int     FAR PASCAL  lstrcmpWrap(LPWSTR sz1, LPWSTR sz2)
{
    return wcscmp(sz1, sz2);
}


int     FAR PASCAL  lstrcmpiWrap(LPWSTR sz1, LPWSTR sz2)
{
    return wcsicmp(sz1, sz2);
}


//int     FAR __cdecl wsprintfWrap(LPWSTR szDest, WCHAR FAR *szFormat, ...)
//{
//    return vswprintf(szDest, szFormat, ((char far *)(&szFormat))+4);
//}

SIZE_T     FAR PASCAL  lstrlenWrap(LPWSTR sz1)
{
    return wcslen(sz1);
}




#if 0

extern "C" int FAR PASCAL
apInitTestW (LPWSTR szTestName)
{
	SYSCHAR szTestNameA[255];

	if (lstrlenWrap(szTestName) <= 126)
	{
		WideCharToMultiByte(CP_ACP,
				    NULL,
				    szTestName,
				    -1,
				    szTestNameA,
				    255, NULL, NULL);

		return apInitTestCore(szTestNameA);
	}
	else
	{
		return -1;
	}
}


int     FAR PASCAL  apLogFailInfoW (LPWSTR szDescription, LPWSTR szExpected, LPWSTR szActual, LPWSTR szBugNum);
extern "C" int FAR PASCAL
apLogFailInfoW (LPWSTR szDescription, LPWSTR szExpected,
		LPWSTR szActual, LPWSTR szBugNum)
{
	SYSCHAR szDescriptionA[APLOGFAIL_MAX];
	SYSCHAR szExpectedA[APLOGFAIL_MAX];
	SYSCHAR szActualA[APLOGFAIL_MAX];
	SYSCHAR szBugNumA[APLOGFAIL_MAX];

	if (lstrlenWrap(szDescription) <= (APLOGFAIL_MAX))
	if (lstrlenWrap(szExpected) <= (APLOGFAIL_MAX))
	if (lstrlenWrap(szActual) <= (APLOGFAIL_MAX))
	if (lstrlenWrap(szBugNum) <= (APLOGFAIL_MAX)) 
	{

		WideCharToMultiByte(CP_ACP,
				    NULL,
				    szDescription,
				    -1,
				    szDescriptionA,
				    APLOGFAIL_MAX, NULL, NULL);

		WideCharToMultiByte(CP_ACP,
				    NULL,
				    szExpected,
				    -1,
				    szExpectedA,
				    APLOGFAIL_MAX, NULL, NULL);

		WideCharToMultiByte(CP_ACP,
				    NULL,
				    szActual,
				    -1,
				    szActualA,
				    APLOGFAIL_MAX, NULL, NULL);

		WideCharToMultiByte(CP_ACP,
				    NULL,
				    szBugNum,
				    -1,
				    szBugNumA,
				    APLOGFAIL_MAX, NULL, NULL);

		return (apLogFailInfoCore(szDescriptionA, szExpectedA, szActualA, szBugNumA));
	}
	else
	{
		return (-1);
	}
	else
	{
		return (-1);
	}
	else
	{
		return (-1);
	}
	else
	{
		return (-1);
	}

}




extern "C" int FAR  PASCAL
apInitScenarioW (LPWSTR szScenarioName)
{
	SYSCHAR szScenarioNameA[255];

	if (lstrlenWrap(szScenarioName) <= 126)
	{
		WideCharToMultiByte(CP_ACP,
				    NULL,
				    szScenarioName,
				    -1,
				    szScenarioNameA,
				    255, NULL, NULL);

		return apInitScenarioCore(szScenarioNameA);
	}
	else
	{
		return -1;
	}
}



extern "C" int FAR _cdecl 
apWriteDebugW(WCHAR FAR * szFormat, ...)
{
    int         x;
    SYSCHAR     szBuf[1024];    
    char        szANSIBuf[1024];    
    char FAR   *args;
//    FILETHING   hfResultsExtra;
//    char        szFullFileName[255];
    
    if (szFormat != NULL)
    {
	args =((char FAR *)(&szFormat))+4;
	x = vswprintf((unsigned short *)szBuf, szFormat, args);
    }
    else return (-1);

	WideCharToMultiByte(CP_ACP,
				NULL,
				(unsigned short *)szBuf,
				-1,
				szANSIBuf,
				1024, NULL, NULL);


    // if (fDebTrace == TRUE) 
        OutputDebugString(szANSIBuf);
			    
/*
    if (fFileTrace == TRUE)
    {
	lstrcpyA(szFullFileName, RES_PATH);        
	lstrcatA(szFullFileName, RESULTS_DEB);

	hfResultsExtra = lOpenAnsi(szFullFileName);
	    return(-1);
	     
	if (lWriteAnsi(hfResultsExtra, szANSIBuf, lstrlen(szANSIBuf)) == NULL)
	    return(-1);                                     

	lCloseAnsi(hfResultsExtra);                                 
    }
*/
    Yield();
    return(0);
}




extern "C" int FAR PASCAL
apInitPerfW (LPWSTR szServerType, LPWSTR szProcType, int bitness, int server_bitness)
{
	SYSCHAR szProcTypeA[255];
	SYSCHAR szServerTypeA[255];

		WideCharToMultiByte(CP_ACP,
				    NULL,
				    szServerType,
				    -1,
				    szServerTypeA,
				    255, NULL, NULL);

		WideCharToMultiByte(CP_ACP,
				    NULL,
				    szProcType,
				    -1,
				    szProcTypeA,
				    255, NULL, NULL);

		return apInitPerfCore(szServerTypeA, szProcTypeA, bitness, server_bitness);
}



extern "C" int FAR PASCAL
apLogPerfW (LPWSTR szTestType, DWORD microsecs, float std_deviation)
{
	SYSCHAR szTestTypeA[255];

		WideCharToMultiByte(CP_ACP,
				    NULL,
				    szTestType,
				    -1,
				    szTestTypeA,
				    255, NULL, NULL);

		return apLogPerfCore(szTestTypeA, microsecs, std_deviation);
}






#endif //chicago or win32s


#if defined(WIN16)
extern "C" DATE FAR PASCAL
apDateFromStr(char FAR *str, LCID lcid)
{
    DATE date;
    HRESULT hr;
    
    hr = VarDateFromStr(str, lcid, 0, &date);
    if (hr != NOERROR) return -1;
    else return date;   
}
#endif                   

#endif //0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\btools\tlviewer\cmallspy.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1994.
//
//  File:       cmallspy.hxx
//
//  Contents:   CMallocSpy definitions
//
//  Classes:    
//
//  Functions:  
//
//  History:    24-Oct-94   Created.
//
//----------------------------------------------------------------------
#ifdef __cplusplus
extern "C" {
#endif


#define DIM(X) (sizeof(X)/sizeof((X)[0]))

class FAR CAddrNode32
{
public:
    void FAR*           m_pv;	    // instance
    SIZE_T	            m_cb;	    // size of allocation in BYTES
    ULONG               m_nAlloc;	// the allocation pass count
    CAddrNode32 FAR    *m_pnNext;

    void FAR* operator new(size_t cb);
    void operator delete(void FAR* pv);

    static CAddrNode32 FAR* m_pnFreeList;
};




class CMallocSpy : public IMallocSpy
{
public:
    CMallocSpy(void);
    ~CMallocSpy(void);

    // IUnknown methods
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID *ppUnk);
    STDMETHOD_(ULONG, AddRef) (void);
    STDMETHOD_(ULONG, Release) (void);

    
    // IMallocSpy methods
    STDMETHOD_(SIZE_T, PreAlloc) (SIZE_T cbRequest);
    STDMETHOD_(void *, PostAlloc) (void *pActual);

    STDMETHOD_(void *, PreFree) (void *pRequest, BOOL fSpyed);
    STDMETHOD_(void, PostFree) (BOOL fSpyed);

    STDMETHOD_(SIZE_T, PreRealloc) (void *pRequest, SIZE_T cbRequest,
                                   void **ppNewRequest, BOOL fSpyed);
    STDMETHOD_(void *, PostRealloc) (void *pActual, BOOL fSpyed);

    STDMETHOD_(void *, PreGetSize) (void *pRequest, BOOL fSpyed);
    STDMETHOD_(SIZE_T, PostGetSize) (SIZE_T cbActual, BOOL fSpyed);

    STDMETHOD_(void *, PreDidAlloc) (void *pRequest, BOOL fSpyed);
    STDMETHOD_(BOOL, PostDidAlloc) (void *pRequest, BOOL fSpyed, BOOL fActual);

    STDMETHOD_(void, PreHeapMinimize) (void);
    STDMETHOD_(void, PostHeapMinimize) (void);


private:
    ULONG m_cRef;
    BOOL m_fWantTrueSize;
    UINT m_cHeapChecks;
    VOID * m_pvRealloc;			// block we are throwing away during
					            // a realloc

    ULONG m_cAllocCalls;		        // total count of allocation calls
    CAddrNode32 FAR* m_rganode[1024];	// address instance table

    // Instance table methods

    VOID MemInstance();
    VOID HeapCheck();
    void DelInst(void FAR* pv);
    CAddrNode32 FAR* FindInst(void FAR* pv);
    void AddInst(void FAR* pv, SIZE_T cb);
    void DumpInst(CAddrNode32 FAR* pn);
    void VerifyHeaderTrailer(CAddrNode32 FAR* pn);

    inline UINT HashInst(void FAR* pv) const 
    {
      return ((UINT)((ULONG_PTR)pv >> 4)) % DIM(m_rganode);
    }

    BOOL IsEmpty(void);
    void DumpInstTable(void);
    void CheckForLeaks();

};

STDAPI GetMallocSpy(IMallocSpy FAR* FAR* ppmallocSpy);


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\btools\tlviewer\osutil32.cpp ===
/*
  Related Files:
  [Section = Compile]
  	%OsUtilDir%:OsUtil.hxx
 [Section =End]

*/
/* -------------------------------------------------------------------------
  Project     : OB - Type Information Interface
  Platform    : Win32
  Module      : osutil.cpp

		Copyright (C) 1992-3, Microsoft Corporation
 ---------------------------------------------------------------------------
  Notes       : Library routines for programs that run under Win32
 ---------------------------------------------------------------------------
  Revision History:
 
	[ 0]	09-Mar-1993		     Angelach: Created Test
	[ 1]	10-Mar-1993		     Angelach: added support to Win32s
        [ 2]    06-Jul-1994                  Angelach: added support for remoting
                                                       typelib testing
	[ 3]	27-Oct-1994		     Angelach: added LCMapStringX
	[ 4]	06-Mar-1995		     Angelach: added osGetNetDrive
	[ 5]	07-Mar-1995		     Angelach: added Memory-leak detection
 --------------------------------------------------------------------------- */

#include "osutil32.hxx"

IMalloc FAR* ppmalloc ; 		       // need for memory allocation
IMallocSpy  FAR* g_IMallocSpy ; 	       // [7]

/*---------------------------------------------------------------------------
 NAME	    : osAllocSpaces

 PURPOSE    : obtains some spaces from the far heap

 INPUTS     : nSize - no of bytes to be allocated

 OUTPUT     : pointer to the allocated space

 NOTES	    : caller is responsible to free up the memory after used

---------------------------------------------------------------------------*/

VOID FAR * osAllocSpaces(WORD nSize)
  {
     return ( (VOID FAR *)malloc(nSize) ) ;
  }

/*---------------------------------------------------------------------------
 NAME	    : osGetRootDir

 PURPOSE    : Retrieves pathspec of the root directory

 INPUTS     : lpszRootDir - storage for the pathspec

 OUTPUT     : none


 NOTES	    :

---------------------------------------------------------------------------*/
VOID FAR osGetRootDir(LPXSTR lpszRootDir)
  {
     osStrCpy(lpszRootDir, XSTR("c:")) ;
     osStrCat(lpszRootDir, szPathSep) ;
  }

/*---------------------------------------------------------------------------
 NAME	    : osGetCurDir

 PURPOSE    : Retrieves pathspec of the current directory

 INPUTS     : lpszCurDir - storage for the pathspec

 OUTPUT     : True if information is retrieved successfully; otherwise, False
	      lpszCurDir contains the pathspec if True

 NOTES	    :

---------------------------------------------------------------------------*/

BOOL FAR osGetCurDir(LPXSTR lpszCurDir)
  {
      int  i ;
#if defined (OAU) && !defined (UNICODE)   // [1]
      char szBufferC[256];

      i = GetCurrentDirectory((DWORD)256, szBufferC) ;

      MultiByteToWideChar(CP_ACP,
			  MB_PRECOMPOSED,
                          szBufferC,
			  -1,
                          lpszCurDir,
                          256);
#else					  // if OAU && ! UNICODE
      i = GetCurrentDirectory((DWORD)256, lpszCurDir) ;
#endif					  // if OAU && ! UNICODE

      if ( i != 0 )
	return TRUE ;			  // info of the current directory
      else				  // is retrieved successfully
	return FALSE ;
  }

/*---------------------------------------------------------------------------
 NAME	    : osMkDir

 PURPOSE    : Creates a subdirectory

 INPUTS     : lpszSubDir - name of the subdirectory to be created

 OUTPUT     : True if subdirectory is created successfully; otherwise, False

 NOTES	    :

---------------------------------------------------------------------------*/

BOOL FAR osMkDir(LPXSTR lpszSubDir)
  {
     SECURITY_ATTRIBUTES sa ;
     BOOL		 rCode ;

     sa.nLength = sizeof(SECURITY_ATTRIBUTES) ;
     sa.lpSecurityDescriptor = NULL ;
     sa.bInheritHandle = FALSE ;

#if defined (OAU) && !defined (UNICODE)  // [1]
      char szBufferS[256];

      WideCharToMultiByte(CP_ACP,
			  0,
			  lpszSubDir,
			  -1,
			  szBufferS,
			  256,
			  NULL,
			  NULL);
     rCode = CreateDirectory(szBufferS, &sa) ;
#else					 // if OAU && ! UNICODE
     rCode = CreateDirectory(lpszSubDir, &sa) ;
#endif					 // if OAU && ! UNICODE

     return rCode;
  }

/*---------------------------------------------------------------------------
 NAME	    : osItoA

 PURPOSE    : Gets the string representation of an integer

 INPUTS     : inVal - the integer in concern
	      lpsz  - the string representation

 OUTPUT     : the string representation of inVal will be returned via lpsz

 NOTES	    :

---------------------------------------------------------------------------*/

VOID FAR  osItoA (int inVal, LPXSTR lpsz)
  {
     char   szlTmp[20] ;

     _itoa(inVal, szlTmp, 10) ;
#ifdef OAU
      MultiByteToWideChar(CP_ACP,
			  MB_PRECOMPOSED,
			  szlTmp,
			  -1,
			  lpsz,
			  20);
#else					 // OAU
     osStrCpy(lpsz, szlTmp) ;
#endif					 // OAU
  }

/*---------------------------------------------------------------------------
 NAME	    : osLtoA

 PURPOSE    : Gets the string representation of a long integer

 INPUTS     : inVal - the long integer in concern
	      lpsz  - the string representation

 OUTPUT     : the string representation of inVal will be returned via lpsz

 NOTES	    :

---------------------------------------------------------------------------*/

VOID FAR  osLtoA (long inVal, LPXSTR lpsz)
  {
     char szlTmp[20] ;

     _ltoa(inVal, szlTmp, 10) ;
#ifdef OAU
      MultiByteToWideChar(CP_ACP,
			  MB_PRECOMPOSED,
			  szlTmp,
			  -1,
			  lpsz,
			  20);
#else					  // OAU
     osStrCpy(lpsz, szlTmp) ;
#endif					  // OAU
  }

/*---------------------------------------------------------------------------
 NAME       : osAtoL

 PURPOSE    : Gets the long integer from a string representing that value

 INPUTS     : lpsz  - the string representation

 OUTPUT     