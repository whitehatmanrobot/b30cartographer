if(!FWriteFileHeaders(FALSE))
        return FALSE;

    /* Try to put the tape into our block size.  If it doesn't work, we'll
     * switch to a different size and write in variable mode */
    mp.BlockSize = m_cbBlkCur;
    if(!m_ptod && NO_ERROR != SetTapeParameters(m_hdev,
        SET_TAPE_MEDIA_INFORMATION, &mp))
    {
        /* This block size is not one the drive likes.  We'll put the drive
         * into variable block mode, but we'll still write out the data in
         * the user-requested block size -- except that the final block may be
         * incomplete if the user provides data which consists of a non-
         * integer number of blocks */
        mp.BlockSize = 0;
        if(!m_ptod && NO_ERROR != SetTapeParameters(m_hdev,
            SET_TAPE_MEDIA_INFORMATION, &mp))
        {
            m_fFatalError = TRUE;
            return FALSE;
        }
        m_fVarBlks = TRUE;
    }

    /* Allocate the write buffer and we're done */
    m_pbBufCur = new BYTE[m_cbBlkCur];
    m_ibBlkCur = 0;
    m_cBlkCur = 0;
    m_fAtEOF = FALSE;

    return TRUE;
}

BOOL CTapeDevice::FCopyEntire(CTapeDevice *ptap)
{
    BYTE rgb[8192];
    DWORD cb, cbT;
    int cMarks;
    TAPE_SET_MEDIA_PARAMETERS mp;

    if(!FRewindNoHdrs())
        return FALSE;
    if(!ptap->FRewindNoHdrs()) {
        FRewind();
        return FALSE;
    }

    /* Go into variable block mode on both devices */
    mp.BlockSize = 0;
    if(!m_ptod && NO_ERROR != SetTapeParameters(m_hdev,
            SET_TAPE_MEDIA_INFORMATION, &mp))
        goto error;
    if(!ptap->m_ptod && NO_ERROR != SetTapeParameters(ptap->m_hdev,
            SET_TAPE_MEDIA_INFORMATION, &mp))
        goto error;

    /* As long as we have data to copy, keep copying.  If we hit a filemark,
     * generate a filemark.  If we hit two filemarks in a row, we're done */

    cMarks = 0;
    while(cMarks < 2) {
        while(ReadFile(m_hdev, rgb, sizeof rgb, &cb, NULL) || cb) {
            cMarks = 0;
            if(!WriteFile(ptap->m_hdev, rgb, cb, &cbT, NULL) || cbT != cb) {
error:
                FRewind();
                ptap->FRewind();
                return FALSE;
            }
        }
        if(!ptap->FWriteFilemark())
            goto error;
        ++cMarks;
    }

    return TRUE;
}

BOOL CTapeDevice::FCopyToStm(CFileStmSeq *pstm, CCheckSum *pxsum)
{
    DWORD cb;

    if(!m_hdev || !m_pbBufCur || m_fWriteOnly || m_fAtEOF)
        return 0;

    /* If we have pending data in the read buffer, send it first */
    if(m_ibBlkCur) {
        cb = m_cbReadCur - m_ibBlkCur;
        if(pstm->CbWrite(cb, m_pbBufCur) != cb)
            return FALSE;
        m_xsum.SumBytes(m_pbBufCur, cb);
        if(pxsum)
            pxsum->SumBytes(m_pbBufCur, cb);
        m_ibBlkCur = 0;
    }

    /* We'll continue reading in one-block chunks until we're out of data */
    for(;;) {
        if(!ReadFile(m_hdev, m_pbBufCur, m_cbBlkCur, &cb, NULL) && cb == 0) {
            /* We hit a filemark, or a fatal error, so mark EOF */
            if(GetLastError() != ERROR_FILEMARK_DETECTED)
                m_fFatalError = TRUE;
            m_fAtEOF = TRUE;
            return !m_fFatalError;
        }
        m_xsum.SumBytes(m_pbBufCur, cb);
        if(pxsum)
            pxsum->SumBytes(m_pbBufCur, cb);
        if(pstm->CbWrite(cb, m_pbBufCur) != cb)
            return FALSE;
    }
}

BOOL CTapeDevice::FCopyFromStm(CFileStmSeq *pstm, CCheckSum *pxsum)
{
    DWORD cb;

    if(!m_hdev || !m_pbBufCur || !m_fWriteOnly || m_fAtEOF)
        return 0;

    /* We'll repeatedly read data into our write buffer; when we have a full
     * buffer, we'll do the write */
    for(;;) {
        while(m_ibBlkCur < m_cbBlkCur) {
            cb = pstm->CbRead(m_cbBlkCur - m_ibBlkCur, m_pbBufCur +
                m_ibBlkCur);
            if(cb == 0)
                /* There was no data to read, so we're done */
                return TRUE;
            m_xsum.SumBytes(m_pbBufCur + m_ibBlkCur, cb);
            if(pxsum)
                pxsum->SumBytes(m_pbBufCur + m_ibBlkCur, cb);
            m_ibBlkCur += cb;
        }
        /* We've filled up our block, so write it out */
        if(!WriteFile(m_hdev, m_pbBufCur, m_cbBlkCur, &cb, NULL) ||
            cb != m_cbBlkCur)
        {
            m_fFatalError = TRUE;
            return FALSE;
        }
        m_ibBlkCur = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\xbecert.cpp ===
/*
 *
 * xbecert.cpp
 *
 * CXBEFile certificate stuff
 *
 */

#include "precomp.h"

#define CERTFIELDDESC(field) \
    FIELD_OFFSET(XBEIMAGE_CERTIFICATE, field), \
        sizeof (((PXBEIMAGE_CERTIFICATE)0)->field)

#define CERTFIELD(field) \
    { #field, CERTFIELDDESC(field) }

static struct CFI {
    LPCSTR szKey;
    DWORD ibOffset;
    DWORD cbSize;
} rgcfi[] = {
    CERTFIELD(TitleID),
    CERTFIELD(AllowedMediaTypes),
    CERTFIELD(GameRatings),
    CERTFIELD(GameRegion),
    CERTFIELD(Version),
    CERTFIELD(DiskNumber),
    //{ "AltTitleCount", CERTFIELDDESC(Reserved2) },
    { NULL, 0, 0 }
};

BOOL CXBEFile::FUnpackCertificate(const CVarBag *pbag, PXBEIMAGE_CERTIFICATE pcert)
{
    CFI *pcfi;
    PBYTE pb;
    BYTE b;
    int ich;
    DWORD itid;
    DWORD ctid;
    DWORD dw;
    LPCSTR sz;
    char szT[64];

    if(!pbag)
        return FALSE;

    memset(pcert, 0, sizeof *pcert);
    pcert->SizeOfCertificate = sizeof *pcert;
    pcert->TimeDateStamp = time(NULL);

    /* Extract the title name, if present */
    /* TODO: allow unicode */
    sz = pbag->FindSzProp("TitleName");
    if(sz) {
        for(ich = 0; sz[ich] && ich < XBEIMAGE_TITLE_NAME_LENGTH; ++ich)
            pcert->TitleName[ich] = sz[ich];
    }

    /* Extract the fields we need */
    for(pcfi = rgcfi; pcfi->szKey; ++pcfi) {
        /* If the field is missing, we fail */
        if(!pbag->FFindDwProp(pcfi->szKey, &dw))
            return FALSE;
        /* If the data is too big for this field, we fail */
        b = 0;
        pb = (PBYTE)&dw + pcfi->cbSize;
        while(pb < (PBYTE)(&dw+1))
            b |= *pb++;
        if(b)
            return FALSE;

        /* Capture this data into this certificate */
        memcpy((PBYTE)pcert + pcfi->ibOffset, &dw, pcfi->cbSize);
    }

    if(!pbag->FFindDwProp("AltTitleCount", &ctid))
        ctid = 0;
    if(ctid > XBEIMAGE_ALTERNATE_TITLE_ID_COUNT)
        return FALSE;
    for(itid = 0; itid < ctid; ++itid) {
        sprintf(szT, "AltTitleID%d", itid);
        if(!pbag->FFindDwProp(szT, &pcert->AlternateTitleIDs[itid]))
            return FALSE;
    }

    return TRUE;
}

BOOL CXBEFile::FInjectNewCertificate(const CVarBag *pbag)
{
    XBEIMAGE_CERTIFICATE certNew;

    if(!m_pfs)
        return FALSE;

    if(!FUnpackCertificate(pbag, &certNew))
        return FALSE;

    /* Timestamp this injection */
    certNew.TimeDateStamp = time(NULL);

    /* Keep the old keys */
    memcpy(certNew.LANKey, m_pxcert->LANKey, sizeof certNew.LANKey);
    memcpy(certNew.SignatureKey, m_pxcert->SignatureKey,
        sizeof certNew.SignatureKey);
    
    return FInjectNewCertificate(&certNew);
}

BOOL CXBEFile::FInjectNewCertificate(const XBEIMAGE_CERTIFICATE *pcertNew)
{
    DWORD cb;

    if(!m_pfs)
        return FALSE;

    if(pcertNew->SizeOfCertificate != sizeof *m_pxcert)
        return FALSE;

    /* Allow old-style certificates */
    if(m_pxcert->SizeOfCertificate != pcertNew->SizeOfCertificate) {
        cb = m_pxcert->SizeOfCertificate;
        memcpy(m_pxcert, pcertNew, cb);
        m_pxcert->SizeOfCertificate = cb;
    } else
        memcpy(m_pxcert, pcertNew, sizeof *m_pxcert);
    m_fCertChanged = TRUE;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\xbefile.cpp ===
/*
 *
 * xbefile.cpp
 *
 * CXBEFile
 *
 */

#include "precomp.h"

CXBEFile::CXBEFile(CFileStmRand *pfs) : m_pfs(pfs), m_pcc(NULL), m_dwFlags(0)
{
    if(!FSetupHeaders())
        m_pfs = NULL;
}

CXBEFile::~CXBEFile()
{
    if(m_pfs)
        delete m_rgbHdr;
}

/* This is here just to make error cleanup easier */
class BytePtr
{
    PBYTE m_pb;
public:
    BytePtr(void) : m_pb(NULL) {}
    ~BytePtr() { if(m_pb) delete m_pb; }
    void Release(void) { m_pb = NULL; }
    void Set(PBYTE pb) { m_pb = pb; }
    operator BYTE *() { return m_pb; }
};

BOOL CXBEFile::FSetupHeaders(void)
{
    int cbHdrData;
    BytePtr pb;
    PXBEIMAGE_SECTION pxsh;
    DWORD cb;

    /* Read all of the header data */
    if(!m_pfs->FSeek(0))
        return FALSE;
    if(m_pfs->CbRead(sizeof m_xih, (PBYTE)&m_xih) != sizeof m_xih)
        return FALSE;
    if(m_xih.Signature != XBEIMAGE_SIGNATURE)
        return FALSE;
    cbHdrData = m_xih.SizeOfHeaders - sizeof m_xih;
    if(cbHdrData <= 0)
        return FALSE;
    /* We refuse to read anything that doesn't have the certificate and all of
     * the section headers as part of the full header */
    if((PBYTE)m_xih.Certificate < (PBYTE)m_xih.BaseAddress ||
            (PBYTE)m_xih.SectionHeaders < (PBYTE)m_xih.BaseAddress ||
            (PBYTE)(m_xih.Certificate + 1) - (PBYTE)m_xih.BaseAddress >
            (int)m_xih.SizeOfHeaders || (PBYTE)(m_xih.SectionHeaders +
            m_xih.NumberOfSections) - (PBYTE)m_xih.BaseAddress >
            (int)m_xih.SizeOfHeaders)
        return FALSE;
    m_rgbHdr = new BYTE[cbHdrData];
    pb.Set(m_rgbHdr);
    if(m_pfs->CbRead(cbHdrData, m_rgbHdr) != (DWORD)cbHdrData)
        return FALSE;
    m_pxcert = (PXBEIMAGE_CERTIFICATE)PvHeaderField(m_xih.Certificate);
    /* Allow for old-style (build 3803) certificates here */
    if(m_pxcert->SizeOfCertificate != 0xD0 &&
            m_pxcert->SizeOfCertificate != sizeof *m_pxcert)
        return FALSE;
    m_pxshFirst = (PXBEIMAGE_SECTION)PvHeaderField(m_xih.SectionHeaders);
    
    /* Calculate the file size */
    m_cbFileSize = 0;
    pxsh = m_pxshFirst + m_xih.NumberOfSections;
    while(--pxsh >= m_pxshFirst) {
        cb = pxsh->PointerToRawData + pxsh->SizeOfRawData;
        if(cb > m_cbFileSize)
            m_cbFileSize = cb;
    }

    pb.Release();
    return TRUE;
}

int CXBEFile::GetLibApprovalLevel(void)
{
    PXBEIMAGE_LIBRARY_VERSION pxlv;
    PXBEIMAGE_LIBRARY_VERSION pxlvXapi;

    if(!m_pfs)
        return 0;

    /* Non-xboxkrnl imports are unacceptable */
    if(m_xih.ImportDirectory)
        return 0;

    pxlv = (PXBEIMAGE_LIBRARY_VERSION)PvHeaderField(m_xih.LibraryVersions);
    if(m_xih.XapiLibraryVersion) {
        pxlvXapi =
            (PXBEIMAGE_LIBRARY_VERSION)PvHeaderField(m_xih.XapiLibraryVersion);
    } else
        pxlvXapi = NULL;

    return CheckLibraryApprovalStatus(pxlvXapi, pxlv,
        m_xih.NumberOfLibraryVersions, NULL);
}

BOOL CXBEFile::FVerifySectionDigest(int isec)
{
    PXBEIMAGE_SECTION pxsh;
    BYTE rgbDigest[XC_DIGEST_LEN];
    BytePtr pbSectionData;
    DWORD cbHead;
    DWORD cbTail;
    DWORD cbBody;
    DWORD ibHead;

    if(!m_pfs || !m_pcc)
        return FALSE;
    /* Make sure we have the right digest size */
    if(m_pcc->CbGetDigestSize() != sizeof pxsh->SectionDigest)
        return FALSE;
    pxsh = m_pxshFirst + isec;

    /* Make sure the section doesn't extend beyond where we think EOF is */
    if(pxsh->PointerToRawData + pxsh->SizeOfRawData < pxsh->PointerToRawData ||
            pxsh->PointerToRawData + pxsh->SizeOfRawData > m_cbFileSize)
        return FALSE;

    /* Make space to stick the section data */
    pbSectionData.Set(new BYTE[pxsh->SizeOfRawData]);

    /* Load the section data */
    if(!m_pfs->FSeek(pxsh->PointerToRawData))
        return FALSE;
    if(m_pfs->CbRead(pxsh->SizeOfRawData, pbSectionData) != pxsh->SizeOfRawData)
        return FALSE;

    /* Now that we have all of the section data, compute the digest */
    if(!m_pcc->FComputeDigest(pbSectionData, pxsh->SizeOfRawData, rgbDigest))
        return FALSE;

    /* Verify that the digest is correct */
    return memcmp(pxsh->SectionDigest, rgbDigest, XC_DIGEST_LEN) == 0;
}

BOOL CXBEFile::FVerifyAllSectionDigests(void)
{
    if(!m_pfs)
        return FALSE;

    if(!m_fVerifiedSectionDigests) {
        m_fVerifiedSectionDigests = TRUE;
        /* Loop over all of the sections and verify the section digest for each */
        for(int isec = m_xih.NumberOfSections; isec--; ) {
            if(!FVerifySectionDigest(isec))
                return FALSE;
        }
        m_fValidSectionDigests = TRUE;
    }

    return m_fValidSectionDigests;
}

BOOL CXBEFile::FVerifySignature(void)
{
    BytePtr pbHeader;
    PXBEIMAGE_HEADER pxih;
    PBYTE pbToSign;
    PULONG pulKey;

    if(!m_pfs || !m_pcc)
        return FALSE;

    if(m_pcc->CbGetEncryptedDigestSize() != sizeof m_xih.EncryptedDigest)
        return FALSE;

    if(!FVerifyAllSectionDigests())
        return FALSE;

    /* Put the headers back together */
    pbHeader.Set(new BYTE[m_xih.SizeOfHeaders]);
    pxih = (PXBEIMAGE_HEADER)(PBYTE)pbHeader;
    memcpy(pxih, &m_xih, sizeof m_xih);
    memcpy(pxih + 1, m_rgbHdr, m_xih.SizeOfHeaders - sizeof m_xih);
    pbToSign = &pxih->EncryptedDigest[sizeof pxih->EncryptedDigest];

    /* Verify the header digest */
    if(!m_pcc->FVerifyEncryptedDigest(pbToSign, pbHeader +
            m_xih.SizeOfHeaders - pbToSign, m_xih.EncryptedDigest))
        return FALSE;

    /* Grab the encrypted header fields */
    pulKey = (PULONG)&m_pcc->PbGetPublicKey()[128];
    m_ulEntryReal = (ULONG)m_xih.AddressOfEntryPoint ^ pulKey[0] ^ pulKey[4];
    m_ulKrnlReal = (ULONG)m_xih.XboxKernelThunkData ^ pulKey[1] ^ pulKey[2];
    m_fGotValidHdrFields = TRUE;
    return TRUE;
}

BOOL CXBEFile::FSignFile(void)
{
    BytePtr pbSignature;
    BytePtr pbHeader;
    PXBEIMAGE_HEADER pxih;
    PBYTE pbToSign;
    PULONG pulKey;

    if(!m_pfs || !m_pcc || !m_fGotValidHdrFields)
        return FALSE;

    /* We require that the encrypted digest hasn't changed size */
    if(m_pcc->CbGetEncryptedDigestSize() != sizeof m_xih.EncryptedDigest)
        return FALSE;

    if(!FVerifyAllSectionDigests())
        return FALSE;

    /* Reinsert the scrambled header fields */
    pulKey = (PULONG)&m_pcc->PbGetPublicKey()[128];
    *(PULONG)&m_xih.AddressOfEntryPoint = m_ulEntryReal ^ pulKey[0] ^ pulKey[4];
    *(PULONG)&m_xih.XboxKernelThunkData = m_ulKrnlReal ^ pulKey[1] ^ pulKey[2];

    /* Put the headers back together */
    pbHeader.Set(new BYTE[m_xih.SizeOfHeaders]);
    pxih = (PXBEIMAGE_HEADER)(PBYTE)pbHeader;
    memcpy(pxih, &m_xih, sizeof m_xih);
    memcpy(pxih + 1, m_rgbHdr, m_xih.SizeOfHeaders - sizeof m_xih);
    pbToSign = &pxih->EncryptedDigest[sizeof pxih->EncryptedDigest];

    /* Compute the encrypted header digest */
    pbSignature.Set(new BYTE[sizeof m_xih.EncryptedDigest]);
    if(!m_pcc->FComputeEncryptedDigest(pbToSign, pbHeader +
            m_xih.SizeOfHeaders - pbToSign, pbSignature))
        return FALSE;
    memcpy(m_xih.EncryptedDigest, pbSignature, sizeof m_xih.EncryptedDigest);
    m_fSignatureChanged = TRUE;
    return TRUE;
}

BOOL CXBEFile::FInjectNewHeader(const XBEIMAGE_HEADER *pxih)
{
    /* We'll act as if this data just came from the file, which means we'll
     * mark all state as initial.  We'll verify the signature when we're done
     * to signify whether we believe this header was good */
    if(!m_pfs || !m_pcc)
        return FALSE;

    memcpy(&m_xih, pxih, sizeof m_xih);
    m_fVerifiedSectionDigests = FALSE;
    m_fValidSectionDigests = FALSE;
    m_fSignatureChanged = TRUE;
    m_fGotValidHdrFields = FALSE;

    return FVerifySignature();
}

BOOL CXBEFile::FCommitChanges(void)
{
    if(!m_pfs)
        return FALSE;

    /* Don't commit an incomplete modification */
    if(m_fCertChanged && !m_fSignatureChanged)
        return FALSE;

    /* If we have a new certificate, write it out */
    if(m_fCertChanged) {
        if(!m_pfs->FSeek((PBYTE)m_xih.Certificate - (PBYTE)m_xih.BaseAddress))
            return FALSE;
        if(m_pfs->CbWrite(sizeof *m_pxcert, (PBYTE)m_pxcert) !=
                sizeof *m_pxcert)
            return FALSE;
        m_fCertChanged = FALSE;
    }

    /* If we have a new signature, write it out */
    if(m_fSignatureChanged) {
        /* We write out the whole base header since the scrambled header
         * fields have changed as well */
        if(!m_pfs->FSeek(0))
            return FALSE;
        if(m_pfs->CbWrite(sizeof m_xih, (PBYTE)&m_xih) != sizeof m_xih)
            return FALSE;
        m_fSignatureChanged = FALSE;
    }

    return TRUE;
}

BOOL CXBEFile::FWriteToStm(CFileStmSeq *pfs, DWORD cbToWrite, DWORD cbBlk) const
{
    BYTE rgbBuf[4096];
    DWORD cb, cbT;

    if(!m_pfs || !pfs->FIsOpen())
        return FALSE;

    /* Write out the header */
    if(pfs->CbWrite(sizeof m_xih, (PBYTE)&m_xih) != sizeof m_xih)
        return FALSE;
    if(pfs->CbWrite(m_xih.SizeOfHeaders - sizeof m_xih, m_rgbHdr) !=
            m_xih.SizeOfHeaders - sizeof m_xih)
        return FALSE;

    /* Copy the rest of the data from the file */
    if(cbToWrite == 0)
        cbToWrite = m_cbFileSize;
    cb = cbToWrite - m_xih.SizeOfHeaders;
    if(!m_pfs->FSeek(m_xih.SizeOfHeaders))
        return FALSE;
    while(cb) {
        cbT = min(cb, sizeof rgbBuf);
        if(m_pfs->CbRead(cbT, rgbBuf) != cbT)
            return FALSE;
        if(pfs->CbWrite(cbT, rgbBuf) != cbT)
            return FALSE;
        cb -= cbT;
    }

    if(cbBlk) {
        /* Need to pad out the write to a block size.  Pad out with zeroes */
        memset(rgbBuf, 0, sizeof rgbBuf);
        cbT = cbToWrite % cbBlk;
        cbBlk -= cbT ? cbT : cbBlk;
        while(cbBlk) {
            cbT = min(cbBlk, sizeof rgbBuf);
            if(pfs->CbWrite(cbT, rgbBuf) != cbT)
                return FALSE;
            cbBlk -= cbT;
        }
    }

    return TRUE;
}

BOOL CXBEFile::FCalcChecksums(CCheckSum *pxsumBlk, CCheckSum *pxsumRed,
    CCheckSum *pxsumGrn) const
{
    BYTE rgbBuf[4096];
    DWORD cb, cbT;
    PXBEIMAGE_HEADER pxihNew;
    PXBEIMAGE_CERTIFICATE pxcertNew;

    if(!m_pfs)
        return FALSE;

    /* Make a copy of the header to use */
    pxihNew = (PXBEIMAGE_HEADER)_alloca(m_xih.SizeOfHeaders);
    memcpy(pxihNew, &m_xih, sizeof m_xih);
    memcpy(pxihNew + 1, m_rgbHdr, m_xih.SizeOfHeaders - sizeof m_xih);

    /* The green checksum includes everything */
    if(pxsumGrn)
        pxsumGrn->SumBytes((PBYTE)pxihNew, m_xih.SizeOfHeaders);

    /* The red checksum excludes the signature, the certificate keys,
     * and the scrambled header fields */
    memset(pxihNew->EncryptedDigest, 0, sizeof pxihNew->EncryptedDigest);
    pxcertNew = (PXBEIMAGE_CERTIFICATE)
        ((PBYTE)(pxihNew + 1) + ((PBYTE)m_pxcert - m_rgbHdr));
    memset(pxcertNew->SignatureKey, 0, sizeof pxcertNew->SignatureKey);
    memset(pxcertNew->LANKey, 0, sizeof pxcertNew->LANKey);
    memset(pxcertNew->AlternateSignatureKeys, 0,
        sizeof pxcertNew->AlternateSignatureKeys);
    pxihNew->AddressOfEntryPoint = NULL;
    pxihNew->XboxKernelThunkData = NULL;
    if(pxsumRed)
        pxsumRed->SumBytes((PBYTE)pxihNew, m_xih.SizeOfHeaders);

    /* The black checksum also excludes the certificate */
    memset(pxcertNew, 0, sizeof *pxcertNew);
    if(pxsumBlk)
        pxsumBlk->SumBytes((PBYTE)pxihNew, m_xih.SizeOfHeaders);

    /* Checksum the rest of the data from the file */
    cb = m_cbFileSize - m_xih.SizeOfHeaders;
    if(!m_pfs->FSeek(m_xih.SizeOfHeaders))
        return FALSE;
    while(cb) {
        cbT = min(cb, sizeof rgbBuf);
        if(m_pfs->CbRead(cbT, rgbBuf) != cbT)
            return FALSE;
        if(pxsumBlk)
            pxsumBlk->SumBytes(rgbBuf, cbT);
        if(pxsumRed)
            pxsumRed->SumBytes(rgbBuf, cbT);
        if(pxsumGrn)
            pxsumGrn->SumBytes(rgbBuf, cbT);
        cb -= cbT;
    }

    /* The green checksum must include the remainder of file data */
    if(pxsumGrn)
        while(cb = m_pfs->CbRead(sizeof rgbBuf, rgbBuf))
            pxsumGrn->SumBytes(rgbBuf, cb);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\xbefile.h ===
/*
 *
 * xbefile.h
 *
 * CXBEFile
 *
 */

#ifndef _XBEFILE_H
#define _XBEFILE_H

#include <filestm.h>
#include <xbeimage.h>
#include <crypt.h>
#include <propbag.h>
#include <xsum.h>

class CXBEFile
{
public:
    CXBEFile(CFileStmRand *pfs);
    ~CXBEFile();

    BOOL FVerifySignature(void);
    int GetLibApprovalLevel(void);
    BOOL FInjectNewCertificate(const CVarBag *pbag);
    BOOL FInjectNewCertificate(const XBEIMAGE_CERTIFICATE *pcert);
    static BOOL FUnpackCertificate(const CVarBag *pbag,
        PXBEIMAGE_CERTIFICATE pcert);
    const XBEIMAGE_CERTIFICATE *GetCert(void) const
    {
        return m_pfs ? m_pxcert : NULL;
    }
    const XBEIMAGE_HEADER *GetHeader(void) const
    {
        return m_pfs ? &m_xih : NULL;
    }
    static BOOL FGenNewKeys(PXBEIMAGE_CERTIFICATE pcert, CCryptContainer *pcc,
        const BYTE *pbEntropy=NULL, DWORD cbEntropy=0);
    BOOL FGenNewKeys(const BYTE *pbEntropy=NULL, DWORD cbEntropy=0);
    BOOL FSignFile(void);
    BOOL FCommitChanges(void);
    BOOL FWriteToStm(CFileStmSeq *pfs, DWORD cbToWrite=0, DWORD cbBlk=0) const;
    BOOL FCalcChecksums(CCheckSum *pxsumBlk, CCheckSum *pxsumRed,
        CCheckSum *pxsumGrn) const;
    void UseCryptContainer(CCryptContainer *pcc)
    {
        m_pcc = pcc;
    }
    BOOL FInjectNewHeader(const XBEIMAGE_HEADER *pxih);

private:
    union {
        struct {
            BOOL m_fVerifiedSectionDigests:1,
                m_fValidSectionDigests:1,
                m_fCertChanged:1,
                m_fSignatureChanged:1,
                m_fGotValidHdrFields:1,
                unused:27;
        };
        DWORD m_dwFlags;
    };
    CFileStmRand *m_pfs;
    CCryptContainer *m_pcc;
    XBEIMAGE_HEADER m_xih;
    PBYTE m_rgbHdr;
    PXBEIMAGE_CERTIFICATE m_pxcert;
    PXBEIMAGE_SECTION m_pxshFirst;
    ULONG m_ulEntryReal;
    ULONG m_ulKrnlReal;
    DWORD m_cbFileSize;

    BOOL FSetupHeaders(void);
    BOOL FVerifySectionDigest(int);
    BOOL FVerifyAllSectionDigests(void);
    static BOOL FGenKey(DWORD dwTitleID, PBYTE pbSig, int cb,
        CCryptContainer *pcc, const BYTE *pbEntropy, DWORD cbEntropy);

    PVOID PvHeaderField(PVOID pvVA)
    {
        return (PVOID)((PBYTE)m_rgbHdr - sizeof m_xih +
            ((DWORD)pvVA - (DWORD)m_xih.BaseAddress));
    }
};

#endif // XBEFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\ximg.h ===
/*
 *
 * ximg.cpp
 *
 * ximage.dat processing
 *
 */

#ifndef _XIMG_H
#define _XIMG_H

typedef BOOL (*PFN_HANDLEXBE)(int ilyr, CXBEFile *pxbe, DWORD cblk,
    CTapeDevice *ptapDst);
typedef BOOL (*PFN_HANDLEAP)(int ilyr, int ixph, CTapeDevice *ptapDst);
BOOL FProcessXImage(int ilyr, DXL *pdxl, int idxr, CTapeDevice *ptapSrc,
    CTapeDevice *ptapDst, PFN_HANDLEXBE pfnXbe, PFN_HANDLEAP pfnAP=NULL);

/* The following are expected to be provided by the caller */
CDiskFile *PstmCreateTemp(LPCSTR szName, DWORD dwFlags);
extern CCheckSum xsumBlk, xsumRed, xsumGrn, xsumMediaIn;
void MsgOut(LPCSTR sz, ...);

#endif // _XIMG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\xbekeys.cpp ===
/*
 *
 * xbekeys.cpp
 *
 * CXBEFile key functions
 *
 */

#include "precomp.h"

static BYTE szTestKey[] = "TESTTESTTESTTEST";

BOOL CXBEFile::FGenKey(DWORD dwTitleID, PBYTE pbSig, int cb,
    CCryptContainer *pcc, const BYTE *pbEntropy, DWORD cbEntropy)
{
    BOOL fRet = FALSE;
    CSimpleCrypt *pccRand;
    BOOL fFinal = FALSE;
    PBYTE pbKeyData;
    int cbKeyData;

    /* We set the keys to zero and then generate an rc4 key to encrypt
     * the zero bytes.  The encrypted zero-bytes constitute random data.  If
     * we're doing a signature key, we use the title ID, convolved with a
     * portion of the XBE public key, as the rc4 key used to generate the
     * random data */
    if(dwTitleID) {
        if(!pcc) {
            /* For non-final TitleID-based keys, we need to use the same key
             * that imagebld uses */
            if(cb < 16)
                memcpy(pbSig, szTestKey, cb);
            else {
                memcpy(pbSig, szTestKey, 16);
                if(cb > 16)
                    memset(pbSig + 16, 0, cb - 16);
            }
            return TRUE;
        }
        pbKeyData = (PBYTE)_alloca(cbKeyData = 2 * sizeof (DWORD));
        ((PDWORD)pbKeyData)[0] = dwTitleID;
        ((PDWORD)pbKeyData)[1] = ((PDWORD)pcc->PbGetPublicKey())[16];
    } else {
        /* We'll use whatever caller-provided entropy we have, plus our own
         * random data and some key data if available */
        cbKeyData = cbEntropy + 4;
        if(pcc)
            cbKeyData += 4;
        pbKeyData = (PBYTE)_alloca(cbKeyData);
        g_rand.RandBytes(pbKeyData, 4);
        if(pcc)
            ((PDWORD)pbKeyData)[1] = ((PDWORD)pcc->PbGetPublicKey())[15];
        if(pbEntropy)
            memcpy(pbKeyData + cbKeyData - cbEntropy, pbEntropy, cbEntropy);
    }
    pccRand = new CSimpleCrypt;
    if(!pccRand->FComputeSessionKeyFromData(pbKeyData, cbKeyData))
        goto fatal;
    if(pccRand->FSessionEncrypt(pbSig, cb, pbSig))
        fRet = TRUE;
fatal:
    delete pccRand;
    return fRet;
}

BOOL CXBEFile::FGenNewKeys(PXBEIMAGE_CERTIFICATE pcert, CCryptContainer *pcc,
    const BYTE *pbEntropy, DWORD cbEntropy)
{
    int itid;

    /* Do the LAN and signature keys first */
    if(!FGenKey(0, pcert->LANKey, sizeof pcert->LANKey, pcc, pbEntropy,
            cbEntropy) || !FGenKey(pcert->TitleID, pcert->SignatureKey,
            sizeof pcert->SignatureKey, pcc, pbEntropy, cbEntropy))
        return FALSE;

    /* Now do the alt title ID keys */
    for(itid = 0; itid < XBEIMAGE_ALTERNATE_TITLE_ID_COUNT; ++itid) {
        if(!FGenKey(pcert->AlternateTitleIDs[itid],
                pcert->AlternateSignatureKeys[itid],
                sizeof pcert->AlternateSignatureKeys[itid], pcc, pbEntropy,
                cbEntropy))
            return FALSE;
    }

    return TRUE;
}

BOOL CXBEFile::FGenNewKeys(const BYTE *pbEntropy, DWORD cbEntropy)
{
    if(!m_pfs)
        return FALSE;

    m_fCertChanged = TRUE;
    return FGenNewKeys(m_pxcert, m_pcc, pbEntropy, cbEntropy);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\xctrl.h ===
/*
 *
 * xctrl.h
 *
 * CXControl
 *
 */

#ifndef _XCTRL_H
#define _XCTRL_H

#include <dx2ml.h>

class CControlStruct
{
protected:
    struct XCXC {
        WORD ibData;
        WORD ibStruct;
        BYTE cbSize;
        BYTE fSwapBytes;
    };

    static BOOL FValidateZero(const BYTE *pb, const XCXC *rgxcz, int cxcz);
    void Import(const BYTE *pb, const XCXC *rgxcxc, int cxcxc);
    void Export(BYTE *pb, const XCXC *rgxcxc, int cxcxc) const;
};

class CXControl : public CControlStruct {
public:
    CXControl(void)
    {
        memset(this, 0, sizeof *this);
    }

    BOOL FInit(CFileStmSeq *pstm, DWORD dwBlkSize=2048);
    BOOL FInit(const BYTE *pb, DWORD dwBlkSize=2048);

    BOOL FWriteToStm(CFileStmSeq *pstm, DWORD dwBlkSize=2048);
    BOOL FWriteAPData(int ilyr, int ixph, CTapeDevice *ptapDst);

    void SetPsns(ULONG psnStart0, ULONG psnEnd0, ULONG psnEnd1)
    {
        m_psnStart0 = psnStart0;
        m_psnEnd0 = psnEnd0;
        m_psnEnd1 = psnEnd1;
        m_fSigned = FALSE;
    }

    void GetPsns(PULONG ppsnStart0, PULONG ppsnEnd0, PULONG ppsnEnd1)
    {
        *ppsnStart0 = m_psnStart0;
        *ppsnEnd0 = m_psnEnd0;
        *ppsnEnd1 = m_psnEnd1;
    }

    BOOL FValidate(DXML *pxml, CCryptContainer *pcc);
    BOOL FSetupAP(DXML *pdxml);
    BOOL FSign(CCryptContainer *pcc);

	BOOL FChallengeResponse(UCHAR id, DWORD dwChallenge, LPDWORD pdwResponse);

    bool operator==(const CXControl &xc)
    {
        return 0 == memcmp(&xc, this, sizeof *this);
    }

    ~CXControl()
    {
        if(m_pccSHA)
            delete m_pccSHA;
    }

private:
#pragma pack(push, 1)
    struct HCRE {
        BYTE bLevel;
        BYTE bID;
        BYTE rgbChallenge[4];
        BYTE bModifier;
        BYTE rgbResponse[4];
    };

    struct HCRT {
        BYTE bVer;
        BYTE chcre;
        HCRE rghcre[23];
    };

    struct DARE {
        BYTE bType;
        BYTE bID;
        BYTE bModifier;
        BYTE rgbUpper[3];
        BYTE rgbLower[3];
    };

    struct DART {
        BYTE bVer;
        BYTE cdare;
        DARE rgdare[23];
    };
#pragma pack(pop)

    CSHACrypt *m_pccSHA;
    BOOL m_fSigned;
    /* These fields don't in any way line up with the actual xcontrol data
     * block */
    DWORD m_dwDAC;
    DWORD m_psnStart0;
    DWORD m_psnEnd1;
    DWORD m_psnEnd0;
    BYTE m_fBCA;
    FILETIME m_ftContent;
    GUID m_guidContent;
    FILETIME m_ftAuth;
    BYTE m_bAuthSys;
    GUID m_guidAuth;
    BYTE m_rgbAuthHash[20];
    BYTE m_rgbAuthSig[256];
    HCRT m_hcrt;
    DART m_dart;
    BYTE m_rgbDartIndex[207];

    /* This is the representation of the AP data that we keep around to
     * fill in the placeholder regions */
    enum { aptPlaceholder, aptMirror, aptGroove, aptVelocity };
    struct APD {
        int apt;
        DWORD psnStart;
        BYTE rgbChallenge[4];
        BYTE rgbResponse[4];
    };
    APD m_rgapd[2][8];

    BOOL FAssemble(BYTE *pb, BOOL fIncludeDart, BOOL fIncludeHcrt);

    const static XCXC g_rgxcxc[];
    const static XCXC g_rgxcz[];
};

class CECMAControl : public CControlStruct
{
public:
    CECMAControl(void)
    {
        memset(this, 0, sizeof *this);
    }

    BOOL FInit(CFileStmSeq *pstm);
    BOOL FInit(const BYTE *pb);

    BOOL FValidate(DXML *pxml) const;
    BOOL FWriteToStm(CFileStmSeq *pstm);

    void SetPsns(ULONG psnStart0, ULONG psnEnd0, ULONG psnEnd1)
    {
        m_psnStart0 = psnStart0;
        m_psnEnd0 = psnEnd0;
        m_psnEnd1 = psnEnd1;
    }

    void GetPsns(PULONG ppsnStart0, PULONG ppsnEnd0, PULONG ppsnEnd1)
    {
        *ppsnStart0 = m_psnStart0;
        *ppsnEnd0 = m_psnEnd0;
        *ppsnEnd1 = m_psnEnd1;
    }

    bool operator==(const CXControl &xc)
    {
        return 0 == memcmp(&xc, this, sizeof *this);
    }

private:
    DWORD m_psnStart0;
    DWORD m_psnEnd1;
    DWORD m_psnEnd0;
    BYTE m_fBCA;

    const static XCXC g_rgxcxc[];
    const static XCXC g_rgxcz[];
};

#endif // _XCTRL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\xctrl.cpp ===
/*
 *
 * xctrl.cpp
 *
 * CXControl
 *
 */

#include "precomp.h"

#define XCFIELD(field) (int)(&((CXControl*)0)->field)

/* XControl fields */
const CXControl::XCXC CXControl::g_rgxcxc[] = {
    { 5, XCFIELD(m_psnStart0), 3, TRUE },
    { 9, XCFIELD(m_psnEnd1), 3, TRUE },
    { 13, XCFIELD(m_psnEnd0), 3, TRUE },
    { 16, XCFIELD(m_fBCA), 1 },
    { 768, XCFIELD(m_hcrt), 2 },
    { 1055, XCFIELD(m_ftContent), 8 },
    { 1083, XCFIELD(m_guidContent), 16 },
    { 1183, XCFIELD(m_ftAuth), 8 },
    { 1210, XCFIELD(m_bAuthSys), 1 },
    { 1211, XCFIELD(m_guidAuth), 16 },
    { 1227, XCFIELD(m_rgbAuthHash), 20 },
    { 1247, XCFIELD(m_rgbAuthSig), 128 },
    { 1375, XCFIELD(m_rgbAuthSig)+128, 128 },
    // the DART has to be unscrambled, so we don't read it directly
};

/* XControl areas of required zero */
const CXControl::XCXC CXControl::g_rgxcz[] = {
    { 4, 0, 1 },
    { 8, 0, 1 },
    { 12, 0, 1 },
    { 17, 0, 258-17 },
    { 258, 0, 255 },
    { 513, 0, 255 },
    { 1023, 0, 32 },
    { 1063, 0, 20 },
    { 1099, 0, 84 },
    { 1191, 0, 19 },
    { 1503, 0, 1631-1503 },
    { 2047, 0, 1 }
};

#define ECFIELD(field) (int)(&((CECMAControl*)0)->field)

/* ECMAControl fields */
const CECMAControl::XCXC CECMAControl::g_rgxcxc[] = {
    { 5, ECFIELD(m_psnStart0), 3, TRUE },
    { 9, ECFIELD(m_psnEnd1), 3, TRUE },
    { 13, ECFIELD(m_psnEnd0), 3, TRUE },
    { 16, ECFIELD(m_fBCA), 1 },
};

/* ECMA areas of required zero */
const CECMAControl::XCXC CECMAControl::g_rgxcz[] = {
    { 17, 0, 15 },
    { 32, 0, 255 },
    { 287, 0, 255 },
    { 542, 0, 255 },
    { 797, 0, 255 },
    { 1052, 0, 255 },
    { 1307, 0, 255 },
    { 1562, 0, 255 },
    { 1817, 0, 231 },
};        

BOOL CControlStruct::FValidateZero(const BYTE *pb, const XCXC *rgxcz, int cxcz)
{
    BYTE b = 0;
    while(cxcz--) {
        for(int ib = 0; ib < rgxcz[cxcz].cbSize; ++ib)
            b |= pb[ib + rgxcz[cxcz].ibData];
    }
    return b == 0;
};

void CControlStruct::Import(const BYTE *pb, const XCXC *rgxcxc, int cxcxc)
{
    while(cxcxc--) {
        if(rgxcxc[cxcxc].fSwapBytes) {
            for(int ib = 0; ib < rgxcxc[cxcxc].cbSize; ++ib)
                ((PBYTE)this)[ib + rgxcxc[cxcxc].ibStruct] =
                    pb[rgxcxc[cxcxc].cbSize + rgxcxc[cxcxc].ibData - ib - 1];
        } else
            memcpy((PBYTE)this + rgxcxc[cxcxc].ibStruct,
                pb + rgxcxc[cxcxc].ibData, rgxcxc[cxcxc].cbSize);
    }
}

void CControlStruct::Export(BYTE *pb, const XCXC *rgxcxc, int cxcxc) const
{
    while(cxcxc--) {
        if(rgxcxc[cxcxc].fSwapBytes) {
            for(int ib = 0; ib < rgxcxc[cxcxc].cbSize; ++ib)
                pb[rgxcxc[cxcxc].cbSize + rgxcxc[cxcxc].ibData - ib - 1] =
                    ((const BYTE *)this)[ib + rgxcxc[cxcxc].ibStruct];
        } else
            memcpy(pb + rgxcxc[cxcxc].ibData, (PBYTE)this +
                rgxcxc[cxcxc].ibStruct, rgxcxc[cxcxc].cbSize);
    }
}

BOOL CXControl::FInit(CFileStmSeq *pstm, DWORD dwBlkSize)
{
    BYTE *pb;

    pb = (PBYTE)_alloca(dwBlkSize);
    if(pstm->CbRead(dwBlkSize, pb) != dwBlkSize)
        return FALSE;
    return FInit(pb, dwBlkSize);
}

BOOL CXControl::FInit(const BYTE *pb, DWORD dwBlkSize)
{
    BYTE b;
    int ib;
    CSHACrypt *pccSHA;

    /* Start clean */
    pccSHA = m_pccSHA;
    memset(this, 0, sizeof *this);
    m_pccSHA = pccSHA;

    if(dwBlkSize == 2054) {
        if(pb[0] != 0xd1 || pb[5] != 0xff)
            return FALSE;
        memcpy(&m_dwDAC, pb + 1, 4);
        dwBlkSize = 2048;
        pb += 6;
    } else
        m_dwDAC = 0;
    if(dwBlkSize != 2048)
        return FALSE;

    /* Make sure the constant data is right */
    if(pb[0] != 0xd1 || pb[1] != 0xf || pb[2] != 0x31 || pb[3] != 0x10)
        return 0;

    /* Ensure all areas of zero are actually zero */
    if(!FValidateZero(pb, g_rgxcz, sizeof g_rgxcz / sizeof g_rgxcz[0]))
        return FALSE;

    /* Extract the fields */
    Import(pb, g_rgxcxc, sizeof g_rgxcxc / sizeof g_rgxcxc[0]);

    /* Extract the DART, if we believe there's one present */
    if(m_dwDAC) {
        /* First extract and unscramble the index */
        for(ib = 0; ib < 207; ++ib)
            m_rgbDartIndex[ib] = pb[1840 + ib] ^ ((PBYTE)&m_dwDAC)[ib & 3];

        /* Now unscramble the DART */
        for(ib = 0; ib < 207; ++ib)
            ((PBYTE)&m_dart)[ib + 2] = pb[m_rgbDartIndex[ib] + 1633];
        m_dart.bVer = pb[1631];
        m_dart.cdare = pb[1632];

        /* And decrypt the HCRT */
        if(!m_pccSHA)
            m_pccSHA = new CSHACrypt;
        if(!m_pccSHA->FComputeSessionKeyFromData(pb + 1183, 44, 56) ||
                !m_pccSHA->FSessionDecrypt(pb + 770, sizeof
                m_hcrt.rghcre,(PBYTE)m_hcrt.rghcre))
            return FALSE;
    }

    return TRUE;
}

BOOL CXControl::FAssemble(BYTE *pb, BOOL fIncludeDart, BOOL fIncludeHcrt)
{
    int ib;

    /* Start clean */
    memset(pb, 0, 2048);

    /* Set the constant data */
    pb[0] = 0xd1;
    pb[1] = 0xf;
    pb[2] = 0x31;
    pb[3] = 0x10;

    /* Include the fields */
    Export(pb, g_rgxcxc, sizeof g_rgxcxc / sizeof g_rgxcxc[0]);

    if(fIncludeHcrt) {
        /* Encrypt the HCRT */
        if(!m_pccSHA)
            m_pccSHA = new CSHACrypt;
        if(!m_pccSHA->FComputeSessionKeyFromData(pb + 1183, 44, 56) ||
                !m_pccSHA->FSessionEncrypt((PBYTE)m_hcrt.rghcre, sizeof
                m_hcrt.rghcre, pb + 770))
            return FALSE;
    } else
        pb[768] = pb[769] = 0;

    if(fIncludeDart) {
        if(!m_dwDAC)
            /* If no auth code, we can't do anything */
            return FALSE;
        
        /* Scramble the DART */
        for(ib = 0; ib < 207; ++ib)
            pb[m_rgbDartIndex[ib] + 1633] = ((PBYTE)&m_dart)[ib + 2];
        pb[1631] = m_dart.bVer;
        pb[1632] = m_dart.cdare;

        /* And scramble the index */
        for(ib = 0; ib < 207; ++ib)
            pb[1840 + ib] = m_rgbDartIndex[ib] ^ ((PBYTE)&m_dwDAC)[ib & 3];
    }

    return TRUE;
}

BOOL CXControl::FWriteToStm(CFileStmSeq *pstm, DWORD dwBlkSize)
{
    BYTE rgb[2054];

    if(dwBlkSize == 2054) {
        if(!m_dwDAC || !m_fSigned)
            return FALSE;
        rgb[0] = 0xd1;
        rgb[5] = 0xff;
        memcpy(rgb + 1, &m_dwDAC, 4);
        return FAssemble(rgb + 6, TRUE, TRUE) && pstm->CbWrite(dwBlkSize, rgb) ==
            dwBlkSize;
    } else if(dwBlkSize == 2048)
        return FAssemble(rgb, FALSE, FALSE) && pstm->CbWrite(dwBlkSize, rgb) ==
            dwBlkSize;
    else
        return FALSE;
}

BOOL CXControl::FValidate(DXML *pxml, CCryptContainer *pcc)
{
    BYTE rgbHash[sizeof m_rgbAuthHash];
    BYTE rgbData[2048];

    /* If we have xml data, we make sure that the PSNs match */
    if(pxml) {
        if(m_psnStart0 != pxml->rgdxl[0].rgdxrAreas[idxrXData].psnStart)
            return FALSE;
        if(m_psnEnd0 != pxml->rgdxl[0].rgdxrAreas[idxrXData].psnStart +
                pxml->rgdxl[0].rgdxrAreas[idxrXData].cpsnSize - 1)
            return FALSE;
        if((m_psnEnd0 ^ 0xFFFFFF) !=
                pxml->rgdxl[1].rgdxrAreas[idxrXData].psnStart)
            return FALSE;
        if(m_psnEnd1 != pxml->rgdxl[1].rgdxrAreas[idxrXData].psnStart +
                pxml->rgdxl[1].rgdxrAreas[idxrXData].cpsnSize - 1)
            return FALSE;
    }

    /* If we have a signature container, make sure this is signed correctly */
    if(pcc) {
        /* Make sure we have an auth code */
        if(!m_dwDAC)
            return FALSE;

        if(pcc->CbGetDigestSize() != sizeof rgbHash)
            return FALSE;
        if(!FAssemble(rgbData, FALSE, TRUE))
            return FALSE;
        if(!pcc->FComputeDigest(rgbData, 1227, rgbHash))
            return FALSE;
        if(memcmp(rgbHash, m_rgbAuthHash, sizeof rgbHash))
            return FALSE;
        if(!pcc->FVerifyEncryptedDigest(rgbData, 1227, m_rgbAuthSig))
            return FALSE;
        m_fSigned = TRUE;
    }

    /* TODO: figure out whether there's anything else to authenticate */
    return TRUE;
}

static const BYTE mpaptph[] =
    { XPH::phNone, XPH::phMirror, XPH::phGroove, XPH::phVelocity };
static const BYTE mpaptchat[] = { 0xFF, 0x01, 0x02, 0x03 };
static const BYTE mpaptchal[] = { 0x02, 0x03, 0x03, 0x02 };
static const BYTE rgapt[16] =
    { 0, 0, 0, 0, 3, 2, 1, 3, 2, 1, 3, 2, 1, 3, 2, 1 };

BOOL CXControl::FSetupAP(DXML *pdxml)
{
    int i;
    int iT;
    int ilyr;
    int iapd;
    int iaptBase;
    DWORD psnBase;
    PBYTE pbPSN;
    DXL *pdxl;
    APD *papd;
    HCRE *phcre;
    DARE *pdare;
    CRandom rand;
    BYTE rgbBuf[2048];
    BYTE rgbIDs[23];
    BYTE rgbHcrtOrder[23];
    BYTE b;

    m_fSigned = FALSE;
    /* Stamp in a DAC */
    m_dwDAC = rand.Rand();

    /* Mark the HCRT and DART headers */
    m_hcrt.bVer = 1;
    m_dart.bVer = 1;
    m_hcrt.chcre = m_dart.cdare = 23;

    /* Set up the ID table */
    for(i = 0; i < 256; ++i)
        rgbBuf[i] = (BYTE)i;
    iT = 256;
    for(i = 23; i--; ) {
        b = (BYTE)(rand.Rand() % iT);
        rgbIDs[i] = rgbBuf[b];
        if(b != --iT)
            rgbBuf[b] = rgbBuf[iT];
    }

    /* Populate the AP descriptor table from the XML.  First count up the
     * disallowed regions and then change the types */
    iaptBase = 0;
    for(ilyr = 0; ilyr < 2; ++ilyr) {
        pdxl = &pdxml->rgdxl[ilyr];
        for(i = 0; i < pdxl->cxph; ++i) {
            if(pdxl->rgxph[i].fDisallow)
                ++iaptBase;
        }
    }
    for(ilyr = 0; ilyr < 2; ++ilyr) {
        pdxl = &pdxml->rgdxl[ilyr];
        psnBase = pdxl->rgdxrAreas[idxrXData].psnStart;
        for(i = 0; i < pdxl->cxph; ++i) {
            if(pdxl->rgxph[i].fDisallow)
                m_rgapd[ilyr][i].apt = 0;
            else 
                m_rgapd[ilyr][i].apt = rgapt[iaptBase + ((rand.Rand() >> 13) %
                    (16 - iaptBase))];
            pdxl->rgxph[i].ph = mpaptph[m_rgapd[ilyr][i].apt];
            m_rgapd[ilyr][i].psnStart = psnBase + pdxl->rgxph[i].lsnStart;
        }
        for(; i < 8; ++i) 
            m_rgapd[ilyr][i].psnStart = 0;
    }

    /* Set up the scrambling key for the HCRT and DART */
    for(i = 0; i < 23; ++i)
        rgbHcrtOrder[i] = (BYTE)i;

    papd = &m_rgapd[0][0];
    iapd = 0;
    pdare = &m_dart.rgdare[0];
    iT = 23;
    for(i = 0; i < 23; ++i, ++iapd, ++papd, ++pdare) {
        /* Pick an HCRT entry and DART entry at random */
        b = (BYTE)(rand.Rand() % iT);
        phcre = &m_hcrt.rghcre[rgbHcrtOrder[b]];
        if(b != --iT)
            rgbHcrtOrder[b] = rgbHcrtOrder[iT];

        /* Start with random data */
        rand.RandBytes((PBYTE)phcre, sizeof *phcre);
        rand.RandBytes((PBYTE)pdare, sizeof *pdare);

        /* Set the ID */
        phcre->bID = pdare->bID = rgbIDs[i];

        /* Find an AP entry that's not blank */
        while(iapd < 16 && papd->psnStart == 0)
            ++iapd, ++papd;

        /* The first 16 entries will be phase 2 challenges */
        if(iapd < 16) {
            /* Fill in the challenge type we computed earlier */
            phcre->bLevel = mpaptchal[papd->apt];
            pdare->bType = mpaptchat[papd->apt];
            phcre->bModifier = pdare->bModifier = (BYTE)(rand.Rand() & 3);

            /* Remember the challenge and response values we've calculated for
             * this entry */
            memcpy(papd->rgbChallenge, phcre->rgbChallenge, 4);
            memcpy(papd->rgbResponse, phcre->rgbResponse, 4);

            /* And mark the PSN of this entry */
            psnBase = papd->psnStart;
            pbPSN = (PBYTE)&psnBase;
            pdare->rgbUpper[0] = pbPSN[2];
            pdare->rgbUpper[1] = pbPSN[1];
            pdare->rgbUpper[2] = pbPSN[0];
            psnBase += 0xFFF;
            pdare->rgbLower[0] = pbPSN[2];
            pdare->rgbLower[1] = pbPSN[1];
            pdare->rgbLower[2] = pbPSN[0];
        } else if(i <= 16 || (rand.Rand() % 3)) {
            /* Generate a DAC challenge */
            phcre->bLevel = 1;
            pdare->bType = 0;
            phcre->bModifier = pdare->bModifier = 0;
            memcpy(phcre->rgbChallenge, &m_dwDAC, 4);
            pdare->rgbUpper[1] = phcre->rgbResponse[0];
            pdare->rgbUpper[2] = phcre->rgbResponse[1];
            pdare->rgbLower[1] = phcre->rgbResponse[2];
            pdare->rgbLower[2] = phcre->rgbResponse[3];
        } else {
            /* Unused */
            phcre->bLevel = 0xF0 + (BYTE)(rand.Rand() % 16);
            pdare->bType = 0xF0 + (BYTE)(rand.Rand() % 15);
        }
    }

    /* Generate the DART index key */
    for(i = 0; i < 207; ++i)
        m_rgbDartIndex[i] = (BYTE)i;
    while(i--) {
        iT = rand.Rand() % (i + 1);
        if(iT != i) {
            b = m_rgbDartIndex[i];
            m_rgbDartIndex[i] = m_rgbDartIndex[iT];
            m_rgbDartIndex[iT] = b;
        }
    }

    /* Stamp the authoring data */
    GetSystemTimeAsFileTime(&m_ftAuth);
    m_bAuthSys = 1;
    g_rand.RandBytes((PBYTE)&m_guidAuth, sizeof m_guidAuth);

    return TRUE;
#if 0
fatal:
    /* In case of failure, erase our work so we don't accidentally write out a
     * half-baked version */
    m_dwDAC = 0;
    memset(&m_hcrt, 0, sizeof m_hcrt);
    memset(&m_dart, 0, sizeof m_dart);
    memset(m_rgbDartIndex, 0, sizeof m_rgbDartIndex);
    return FALSE;
#endif
}

BOOL CXControl::FWriteAPData(int ilyr, int ixph, CTapeDevice *ptapDst)
{
    APD *papd = &m_rgapd[ilyr][ixph];
    BYTE rgb[32768];
    int iblkCur;
    int iblkCatch;
    PBYTE pb;
    int cb;
    CSimpleCrypt ccRand;

    if(papd->psnStart == 0)
        iblkCatch = 4096 / 16;
    else {
        /* Based on the AP type, we're going to have to insert our data in
         * various places */
        switch(papd->apt) {
        case aptPlaceholder:
            iblkCatch = 0;
            break;
        case aptMirror:
        case aptGroove:
            iblkCatch = (1280 - 128) / 16;
            break;
        case aptVelocity:
            iblkCatch = (1280 + 256) / 16;
            break;
        }
    }

    /* We're going to use a stream cypher for random number generation so we
     * can include more than 32 bits of entropy */
    cb = ccRand.CbGetDigestSize();
    if(cb < sizeof m_rgbAuthHash)
        cb = sizeof m_rgbAuthHash;
    pb = (PBYTE)_alloca(cb);
    memcpy(pb, m_rgbAuthHash, sizeof m_rgbAuthHash);
    *(DWORD *)pb ^= g_rand.Rand();

    for(iblkCur = 0; iblkCur < 4096 / 16; ++iblkCur) {
        if(!ccRand.FComputeSessionKeyFromData(pb, cb) ||
                !ccRand.FSessionEncrypt(rgb, sizeof rgb, rgb))
            g_rand.RandBytes(rgb, sizeof rgb);
        if(iblkCur == iblkCatch) {
            switch(papd->apt) {
            case aptVelocity:
            case aptPlaceholder:
                /* First four bytes are challenge, next four bytes are
                 * response */
                memcpy(rgb, papd->rgbChallenge, 4);
                memcpy(rgb + 4, papd->rgbResponse, 4);
                iblkCatch = 4096 / 16;
                break;
            case aptMirror:
            case aptGroove:
                if(iblkCatch == (1280 - 128) / 16) {
                    /* Lead end; the first two bytes are the first two bytes
                     * of challenge, and the next two bytes are the first
                     * two bytes of response */
                    memcpy(rgb, papd->rgbChallenge, 2);
                    memcpy(rgb + 2, papd->rgbResponse, 2);
                    iblkCatch = ((4096 - 2560) + 256) / 16;
                } else {
                    /* Tail end; the first two bytes are the second two bytes
                     * of challenge, and the next two bytes are the second
                     * two bytes of response */
                    memcpy(rgb, papd->rgbChallenge + 2, 2);
                    memcpy(rgb + 2, papd->rgbResponse + 2, 2);
                    iblkCatch = 4096 / 16;
                }
                break;
            }
        }
        if(ptapDst->CbWrite(sizeof rgb, rgb) != sizeof rgb) {
            fprintf(stderr, "error: writing to destination tape %d\n", ilyr);
            return FALSE;
        }
        if(!ccRand.FComputeDigest(rgb, sizeof rgb, pb))
            ++*(DWORD *)pb;
    }

    return TRUE;
}

BOOL CXControl::FSign(CCryptContainer *pcc)
{
    BYTE rgbData[2048];

    /* Don't sign anything without a DAC */
    if(!m_dwDAC)
        return FALSE;

    if(pcc->CbGetDigestSize() != sizeof m_rgbAuthHash ||
            pcc->CbGetEncryptedDigestSize() != sizeof m_rgbAuthSig)
        return FALSE;
    if(!FAssemble(rgbData, FALSE, TRUE))
        return FALSE;
    if(!pcc->FComputeDigest(rgbData, 1227, m_rgbAuthHash))
        return FALSE;
    if(!pcc->FComputeEncryptedDigest(rgbData, 1227, m_rgbAuthSig))
        return FALSE;
    m_fSigned = TRUE;
    return TRUE;
}

BOOL CECMAControl::FInit(CFileStmSeq *pstm)
{
    BYTE rgb[2048];

    if(pstm->CbRead(sizeof rgb, rgb) != sizeof rgb)
        return FALSE;
    return FInit(rgb);
}

BOOL CECMAControl::FInit(const BYTE *pb)
{
    /* Start clean */
    memset(this, 0, sizeof *this);

    /* Make sure the constant data is right */
    if(pb[0] != 0x01 || pb[1] != 0x02 || pb[2] != 0x31 || pb[3] != 0x10)
        return 0;

    /* Ensure all areas of zero are actually zero */
    if(!FValidateZero(pb, g_rgxcz, sizeof g_rgxcz / sizeof g_rgxcz[0]))
        return FALSE;

    /* Extract the fields */
    Import(pb, g_rgxcxc, sizeof g_rgxcxc / sizeof g_rgxcxc[0]);

    return TRUE;
}

BOOL CECMAControl::FWriteToStm(CFileStmSeq *pstm)
{
    BYTE rgb[2048];

    /* Start clean */
    memset(rgb, 0, sizeof rgb);

    /* Set the constant data */
    rgb[0] = 0x01;
    rgb[1] = 0x02;
    rgb[2] = 0x31;
    rgb[3] = 0x10;

    /* Include the fields */
    Export(rgb, g_rgxcxc, sizeof g_rgxcxc / sizeof g_rgxcxc[0]);

    return pstm->CbWrite(sizeof rgb, rgb) == sizeof rgb;
}

BOOL CECMAControl::FValidate(DXML *pxml) const
{
    DWORD psnEnd1;

    /* The disk regions are rounded to an ECC boundary, so we need to validate
     * by rounding up to an ECC boundary */
    psnEnd1 = ((m_psnEnd1 + 0x10) & ~0xF) - 1;

    return
        m_psnStart0 == pxml->rgdxl[0].dxrData.psnStart &&
        m_psnEnd0 == pxml->rgdxl[0].dxrData.psnStart +
            pxml->rgdxl[0].dxrData.cpsnSize - 1 &&
        (m_psnEnd0 ^ 0xFFFFFF) == pxml->rgdxl[1].dxrData.psnStart &&
        psnEnd1 == pxml->rgdxl[1].dxrData.psnStart +
            pxml->rgdxl[1].dxrData.cpsnSize - 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\certutil\precomp.h ===
#include <windows.h>
#include <winspool.h>
#include <wincrypt.h>
#include <stdio.h>
#include <atlbase.h>
#include <msxml.h>
#include <xsum.h>
#include <randm.h>
#include <propbag.h>
#include <ini.h>
#include <xcrypt.h>
#include <crypt.h>
#include <ncipher.h>
#include <flcrypt.h>
#include <filestm.h>
#include <tape.h>
#include <xbefile.h>
#include <dx2ml.h>
#include <gdfdir.h>
#include <ximg.h>
#include <xctrl.h>
#include <lblprint.h>
#include <malloc.h>
#include <conio.h>
#include <time.h>
#include <rsa.h>
#include <sha.h>
#include <xboxverp.h>
#include <cklibver.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\ximg.cpp ===
/*
 *
 * ximg.cpp
 *
 * ximage.dat processing
 *
 */

#include "precomp.h"

enum { mdDataBeforeImage, mdDataImage, mdDataBeforeAP, mdDataAP };

BOOL FProcessXImage(int ilyr, DXL *pdxl, int idxr, CTapeDevice *ptapSrc,
    CTapeDevice *ptapDst, PFN_HANDLEXBE pfnXbe, PFN_HANDLEAP pfnAP)
{
    int ixbi;
    int ixph;
    DWORD iblkCur;
    DWORD cblkCur;
    DWORD cblk;
    DWORD cblkRem;
    DWORD cb;
    DXR *pdxr = &pdxl->rgdxrAreas[idxr];
    CFileStmSeq *pstmTo;
    CDiskFile *pstmXBE = NULL;
    CXBEFile *pxbe = NULL;
    BYTE rgb[32768];
    int mdData = mdDataBeforeImage;

    /* We're going to loop over all of the data in the source.  For non-image
     * data, we'll just copy it.  For image data, we'll build an XBE on disk
     * and process it */
    ixph = ixbi = 0;
    iblkCur = 0;
    do {
        /* First figure out how much we're going to read from the tape */
        switch(mdData) {
        case mdDataImage:
            MsgOut("Reading XBE file\n");
            cblkCur = pdxl->pxbi[ixbi++].cpsnSize;
            pstmXBE = PstmCreateTemp("sign.xbe", GENERIC_WRITE);
            if(!pstmXBE->FIsOpen()) {
                fprintf(stderr, "error: could not open temporary XBE file\n");
                return FALSE;
            }
            pstmTo = pstmXBE;
            break;
        case mdDataAP:
            MsgOut("%s placeholder data\n", pfnAP ? "Reading" : "Copying");
            cblkCur = 4096;
            if(pfnAP) {
                if(!pfnAP(ilyr, ixph, ptapDst))
                    return FALSE;
                pstmTo = NULL;
            } else
                pstmTo = ptapDst;
            ++ixph;
            break;
        case mdDataBeforeAP:
            mdData = mdDataBeforeImage;
            // fall through
        case mdDataBeforeImage:
            /* Find the next image */
            cblkCur = (ixbi == pdxl->ixbiMac ? pdxr->cpsnSize :
                pdxl->pxbi[ixbi].lsnStart);
            /* If we have an AP region coming up before the next
             * image, we need to stop short */
            if(ixph < pdxl->cxph && cblkCur > pdxl->rgxph[ixph].lsnStart) {
                cblkCur = pdxl->rgxph[ixph].lsnStart;
                mdData = mdDataBeforeAP;
            }
            /* We don't need to verify that the images and placeholders
             * are nonoverlapping, since our dx2ml input data doesn't allow
             * for that possibility */
            cblkCur -= iblkCur;
            pstmTo = ptapDst;
            MsgOut("Copying %d blocks of data\n", cblkCur);
            break;
        }

        if(cblkCur) {
            /* Now read the tape data */
            cblkRem = cblkCur;
            while(cblkRem) {
                /* We'll try to read up to the next physical block */
                cblk = iblkCur & 15;
                if(cblk == 0)
                    cblk = sizeof rgb / 2048;
                else
                    cblk = sizeof rgb / 2048 - cblk;
                /* If this is more data than we want, cut down our data
                 * size */
                if(cblk > cblkRem)
                    cblk = cblkRem;
                cb = cblk * 2048;
                if(ptapSrc->CbRead(cb, rgb) != cb) {
                    fprintf(stderr, "error: reading source tape %d\n", ilyr);
                    goto fatal;
                }
                switch(mdData) {
                case mdDataBeforeImage:
                case mdDataBeforeAP:
                    /* Add these bytes into the media checksums */
                    xsumBlk.SumBytes(rgb, cb);
                    xsumRed.SumBytes(rgb, cb);
                    xsumGrn.SumBytes(rgb, cb);
                    // fall through
                case mdDataImage:
                    /* These go into the input media checksum */
                    xsumMediaIn.SumBytes(rgb, cb);
                    break;
                }
                if(pstmTo && pstmTo->CbWrite(cb, rgb) != cb) {
                    if(pstmTo != pstmXBE) {
                        fprintf(stderr, "error: writing destination tape %d\n",
                            ilyr);
                        goto fatal;
                    }
                    fprintf(stderr, "error: writing temporary XBE file\n");
                    goto fatal;
                }
                cblkRem -= cblk;
                iblkCur += cblk;
            }
        }

        switch(mdData) {
        case mdDataImage:
            /* We've read the image file; now we need to sign it and copy it
             * to the destination tape */
            if(!pstmXBE->FReopen(GENERIC_READ)) {
                fprintf(stderr, "error: reading temporary XBE file\n");
                goto fatal;
            }
            pxbe = new CXBEFile(pstmXBE);
            if(!pfnXbe(ilyr, pxbe, cblkCur, ptapDst))
                goto fatal;
            delete pxbe;
            pxbe = NULL;
            delete pstmXBE;
            pstmXBE = NULL;
            // fall through
        case mdDataAP:
            mdData = mdDataBeforeImage;
            break;
        case mdDataBeforeAP:
            mdData = mdDataAP;
            break;
        case mdDataBeforeImage:
            mdData = mdDataImage;
            break;
        }
    } while(iblkCur < pdxr->cpsnSize);

    /* If this file size doesn't actually match what we're expecting on the
     * tape, we're in trouble */
    if(iblkCur != pdxr->cpsnSize || ptapSrc->CbRead(sizeof rgb, rgb) != 0) {
        fprintf(stderr, "error: tape %d XImage file is the wrong size\n", ilyr);
        return FALSE;
    }

    return TRUE;

fatal:
    if(pxbe)
        delete pxbe;
    if(pstmXBE)
        delete pstmXBE;
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\xsum.h ===
/*
 *
 * xsum.h
 *
 * CCheckSum
 *
 */

#ifndef _XSUM_H
#define _XSUM_H

class CCheckSum {
public:
    CCheckSum(void) { Reset(); }
    CCheckSum(DWORD dw) : m_dwSum(dw) {}

    void Reset(DWORD dw = -1) { m_dwSum = dw; }
    DWORD DwRunningSum(void) const { return m_dwSum; }
    DWORD DwFinalSum(void) const { return m_dwSum ^ -1; }
    void SumBytes(const BYTE *lpb, DWORD cb)
    {
        while(cb--)
            m_dwSum = (m_dwSum >> 8) ^ m_CrcTable32[(BYTE)m_dwSum ^ *lpb++];
    }

private:
    DWORD m_dwSum;
    static const DWORD m_CrcTable32[256];
};

#endif // _XSUM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\xbeutil\precomp.h ===
#include <xtl.h>
#include <xbox.h>
#include <xsum.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\dvdemu\precomp.h ===
#include <windows.h>
#include <randm.h>
#include <xsum.h>
#include <filestm.h>
#include <tape.h>
#include <dx2ml.h>
#include <xbefile.h>
#include <stdio.h>
#include <malloc.h>
#include <xboxverp.h>
#include <cklibver.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\lib\xsum.cpp ===
/*
 *
 * xsum.cpp
 *
 * CCheckSum
 *
 */

#include "precomp.h"

const DWORD CCheckSum::m_CrcTable32[256] = { 
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D };
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\other\emutape\emutape.cpp ===
/*
 *
 * emutape.cpp
 *
 * Emulate from tape files
 *
 */

#include "emutape.h"

CBasedFile *pstmXL0, *pstmXL1;
CBasedFile *pstmL0, *pstmL1;
PHYSICAL_GEOMETRY geomECMA, geomX2;
CDX2MLFile g_xml;
DXML *pdxml;
CXControl xct;
CECMAControl ect;
BYTE rgbControl[2048];
BYTE rgbXControl[2048];
DWORD dwDAC;
HANDLE hevtDone;
BOOL fX2Session;

CBasedFile::CBasedFile(CTapeDevice2 *ptap) : CDiskFile((HANDLE)NULL)
{
    LARGE_INTEGER li;

    if(ptap->m_ptod) {
        li.QuadPart = 0;
        if(SetFilePointerEx(ptap->m_hdev, li, &m_liBase, FILE_CURRENT))
            m_hFile = ptap->m_hdev;
    }
}

CBasedFile::CBasedFile(CDiskFile *pstm) : CDiskFile(*pstm)
{
    m_liBase.QuadPart = 0;
}

BOOL CBasedFile::FSeek(LONG l)
{
    LARGE_INTEGER li;

    li.QuadPart = l + m_liBase.QuadPart;
    return CDiskFile::FSeek(li);
}

BOOL CBasedFile::FSeek(LARGE_INTEGER li)
{
    li.QuadPart += m_liBase.QuadPart;
    return CDiskFile::FSeek(li);
}

CDiskFile *PstmCreateTemp(LPCSTR szName, DWORD dwFlags)
{
    CDiskFile *pstm = new CDiskFile(szName, dwFlags);
    if(!pstm->FIsOpen()) {
        delete pstm;
        pstm = NULL;
    } else
        pstm->SetDeleteOnClose(TRUE);
    return pstm;
}

BOOL FSeekToFile(CTapeDevice *ptap, LPCSTR szFileName, LPDWORD lpdwDataBlkSize,
	LPDWORD lpdwDataPerPhy)
{
	char szName[64];

	while(ptap->FReadFile(szName, lpdwDataBlkSize, lpdwDataPerPhy)) {
		if(0 == strcmp(szName, szFileName))
			return TRUE;
	}

	return FALSE;
}

CBasedFile *PstmBasedTapeFile(CTapeDevice2 *ptap, LPCSTR szName)
{
	if(!FSeekToFile(ptap, szName, NULL, NULL))
		return FALSE;
	return new CBasedFile(ptap);
}

BOOL FValidStm(CFileStmSeq *pstm)
{
	return pstm && pstm->FIsOpen();
}

BOOL FGetXMLData(CTapeDevice *ptap)
{
    CDiskFile *pstmXdr;
    CDiskFile *pstmXml = NULL;
    DWORD cbRes;
    HRSRC hres;
    PBYTE pb;
	BOOL fRet = FALSE;

    /* Get the XDR file handy in case we need it */
    pstmXdr = PstmCreateTemp("dx2ml.xdr", GENERIC_WRITE);
    if(!pstmXdr) {
noxdr:
        fprintf(stderr, "error: unable to create temporary XDR file\n");
        goto fatal;
    }
    hres = FindResource(GetModuleHandle(NULL), MAKEINTRESOURCE(1), "FILE");
    if(!hres)
        goto noxdr;
    pb = (PBYTE)LockResource(LoadResource(GetModuleHandle(NULL), hres));
    if(!pb)
        goto noxdr;
    cbRes = SizeofResource(GetModuleHandle(NULL), hres);
    if(pstmXdr->CbWrite(cbRes, pb) != cbRes)
        goto noxdr;
    if(!pstmXdr->FReopen(GENERIC_READ))
        goto noxdr;

	/* Read the DX2ML data */
	pstmXml = PstmCreateTemp("dx2ml.xml", GENERIC_WRITE);
	if(!ptap->FCopyToStm(pstmXml)) {
badxml:
		fprintf(stderr, "error: processing DX2ML data\n");
		goto fatal;
	}
	if(!pstmXml->FReopen(GENERIC_READ))
		goto badxml;
    if(!g_xml.FReadFile(pstmXml->SzName(), FALSE))
        goto badxml;
	pdxml = g_xml.PdxmlGet();
	if(!pdxml)
		goto badxml;

	fRet = TRUE;

fatal:
	delete pstmXdr;
	if(pstmXml)
		delete pstmXml;
	return fRet;
}

BOOL FGetXctrl(CTapeDevice *ptap, ULONG dwBlkSize)
{
	BYTE rgb[2054];
	LPBYTE pb;
	int i;

	if(dwBlkSize == 2048)
		pb = rgbXControl;
	else if(dwBlkSize == 2054)
		pb = rgb;
	else
		return FALSE;

	/* Read the data from the tape */
	for(i = 0; i < 31; ++i) {
		if(ptap->CbRead(dwBlkSize, pb) != dwBlkSize)
			return FALSE;
	}

	/* Process the XControl data */
	if(!xct.FInit(pb, dwBlkSize))
		return FALSE;

	/* Retain the XControl data for the read structure */
	if(pb != rgbXControl)
		memcpy(rgbXControl, rgb + 6, 2048);

	return TRUE;
}

void FillGeomPsns(PHYSICAL_GEOMETRY *pgeom, DWORD dwStart0, DWORD dwEnd0,
	DWORD dwEnd1)
{
	pgeom->Layer0StartPSN = dwStart0;
	pgeom->Layer0SectorCount = dwEnd0 - dwStart0 + 1;
	pgeom->Layer1SectorCount = dwEnd1 - (dwEnd0 ^ 0xFFFFFF) + 1;
}

void SetupGeometry(BOOL fMultiSession)
{
	DWORD dwStart0;
	DWORD dwEnd0;
	DWORD dwEnd1;

	xct.GetPsns(&dwStart0, &dwEnd0, &dwEnd1);
	FillGeomPsns(&geomX2, dwStart0, dwEnd0, dwEnd1);
	geomX2.IsX2Disc = TRUE;
	if(fMultiSession) {
		geomX2.SupportsMultiplePartitions = TRUE;
		ect.GetPsns(&dwStart0, &dwEnd0, &dwEnd1);
		FillGeomPsns(&geomECMA, dwStart0, dwEnd0, dwEnd1);
		geomECMA.IsX2Disc = TRUE;
		geomECMA.SupportsMultiplePartitions = TRUE;
	} else {
		geomX2.SupportsMultiplePartitions = FALSE;
		geomECMA = geomX2;
	}
}

void CTapeEmulation::MountUnmount(BOOL fMount)
{
	fX2Session = !geomX2.SupportsMultiplePartitions;
	if(!fMount)
		SetEvent(hevtDone);
}

void CTapeEmulation::GetPhysicalGeometry(PHYSICAL_GEOMETRY *pgeom, BOOL fX2)
{
	memcpy(pgeom, fX2 ? &geomX2 : &geomECMA, sizeof *pgeom);
	if(fX2)
		fX2Session = TRUE;
}

int CTapeEmulation::NumberOfPlaceholders(int Layer)
{
	return pdxml->rgdxl[Layer].cxph;
}

void CTapeEmulation::GetPlaceholderInformation(int Layer,
	PLACEHOLDER *Placeholders)
{
}

ULONG CTapeEmulation::GetSectorData(ULONG lsn, ULONG cblk, PUCHAR rgbData)
{
	PHYSICAL_GEOMETRY *pgeomUse;
	CFileStmRand *pstm;
	int err;
	ULONG cblk0;
	BOOL fSuccess;
	LARGE_INTEGER li;

	pgeomUse = fX2Session ? &geomX2 : &geomECMA;
	if(lsn >= pgeomUse->Layer0SectorCount) {
		lsn -= pgeomUse->Layer0SectorCount;
		if(lsn >= pgeomUse->Layer1SectorCount || lsn + cblk >
				pgeomUse->Layer1SectorCount)
			return EMU_ERR_INVALID_LSN;
		pstm = fX2Session ? pstmXL1 : pstmL1;
	} else {
		if(lsn + cblk > pgeomUse->Layer0SectorCount) {
			/* This read spans the layer boundary.  Read the layer 1 data
			 * first. */
			cblk0 = pgeomUse->Layer0SectorCount - lsn;
			err = GetSectorData(lsn + cblk0, cblk - cblk0, rgbData + 2048 * cblk0);
			if(err)
				return err;
			cblk = cblk0;
		}
		pstm = fX2Session ? pstmXL0 : pstmL0;
	}

	li.QuadPart = lsn * 2048;
	fSuccess = pstm->FSeek(li) && pstm->CbRead(cblk * 2048, rgbData) ==
		cblk * 2048;
	err = fSuccess ? EMU_ERR_SUCCESS : EMU_ERR_UNEXPECTED_ERROR;

	return err;
}

BOOL CTapeEmulationDVDX2::GetControlData(BOOL fXControl, PUCHAR pb, ULONG cb,
	PULARGE_INTEGER Delay)
{
	PUCHAR pbSrc;
	ULONG cbMax;

	if(fXControl) {
		pbSrc = rgbXControl;
		cbMax = 1631;
	} else {
		pbSrc = rgbControl;
		cbMax = 2048;
	}

	if(!pbSrc[0])
		return FALSE;

	if(cb > cbMax) {
		memcpy(pb, pbSrc, cbMax);
		memset(pb + cbMax, 0, cb - cbMax);
	} else
		memcpy(pb, pbSrc, cb);
	return TRUE;
}

BOOL CTapeEmulationDVDX2::DiscChallengeResponse(UCHAR id,
	PULONG ChallengeValue, PULONG ResponseValue, PULARGE_INTEGER Delay)
{
	return FALSE;
}

int __cdecl main(int argc, char **argv)
{
    CTapeDevice2 tapSrc0, tapSrc1, *ptap;
	ULONG dwBlkSize;

	/* Mount the tape files.  If one tape file is present, we assume we're
	 * emulating a black tape.  If two are present, we're doing either
	 * red or green */

	if(argc < 2) {
		fprintf(stderr, "usage: emutape layer0.dat [layer1.dat]\n");
		return 1;
	}

	if(!tapSrc0.FMountAsTapeOrDisk(argv[1], FALSE)) {
notape0:
		fprintf(stderr, "error: reading %s\n", argv[1]);
		return 1;
	}

	if(argc == 2)
		ptap = &tapSrc0;
	else {
		if(!tapSrc1.FMountAsTapeOrDisk(argv[2], FALSE)) {
notape1:
			fprintf(stderr, "error: reading %s\n", argv[2]);
			return 1;
		}
		ptap = &tapSrc1;
	}

	/* Get the XML data */
	if(!FSeekToFile(&tapSrc0, "DX2ML.XML", NULL, NULL))
		goto notape0;
	if(!FGetXMLData(&tapSrc0))
		return 1;

	/* Load the control and xcontrol data */
	if(ptap != &tapSrc0) {
		if(!FSeekToFile(&tapSrc0, "CONTROL.DAT", NULL, NULL)) {
			fprintf(stderr, "error: could not find control data\n");
			return 1;
		}
		if(tapSrc0.CbRead(sizeof rgbControl, rgbControl) != sizeof rgbControl) {
badctrl:
			fprintf(stderr, "error: processing control data\n");
			return 1;
		}
		if(!ect.FInit(rgbControl))
			goto badctrl;
	}
	if(!FSeekToFile(ptap, "XCONTROL.DAT", &dwBlkSize, NULL)) {
		fprintf(stderr, "error: could not find xcontrol data\n");
		return 1;
	}
	if(!FGetXctrl(ptap, dwBlkSize))
		return 1;

	SetupGeometry(ptap != &tapSrc0);

	/* Get the layer files */
	if(ptap != &tapSrc0) {
		pstmL0 = PstmBasedTapeFile(&tapSrc0, "IMAGE0.DAT");
		pstmXL0 = PstmBasedTapeFile(&tapSrc0, "XIMAGE0.DAT");
		pstmXL1 = PstmBasedTapeFile(&tapSrc1, "XIMAGE1.DAT");
		pstmL1 = PstmBasedTapeFile(&tapSrc1, "IMAGE1.DAT");
		if(!FValidStm(pstmL0) || !FValidStm(pstmXL0))
			goto notape0;
		if(!FValidStm(pstmL1) || !FValidStm(pstmXL1))
			goto notape1;
	} else {
		pstmXL0 = PstmBasedTapeFile(&tapSrc0, "XIMAGE0.DAT");
		pstmXL1 = PstmBasedTapeFile(&tapSrc1, "XIMAGE1.DAT");
		if(!FValidStm(pstmXL0) || !FValidStm(pstmXL1))
			goto notape0;
	}

	/* Now begin emulation */
	if(FAILED(StartEmulating())) {
		fprintf(stderr, "error: starting DVD emulation session\n");
		return 1;
	}
	hevtDone = CreateEvent(NULL, FALSE, FALSE, NULL);
	EmulationOpenTray(TRUE);
	EmulationCloseTray(ptap == &tapSrc0 ? new CTapeEmulation :
		new CTapeEmulationDVDX2, TRUE);
	WaitForSingleObject(hevtDone, INFINITE);
	EmulationCloseTray(NULL, TRUE);
	StopEmulating();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\other\flkey\flkey.cpp ===
/*
 *
 * flkey.cpp
 *
 * Encrypt a key set
 *
 */

#include "precomp.h"

int __cdecl main(int argc, char **argv)
{
    CFloppyCrypt *pfk;
    int ch;
    BOOL fWritePub = FALSE;
    BOOL fNCipher = FALSE;
    CNCipherCrypt *pcc = NULL;
    int argcMin = 2;

    for(;;) {
        if(argc < argcMin) {
            fprintf(stderr, "usage: flkey keyid\n");
            return 1;
        }

        if(argc == 1)
            break;
        else if(0 == _stricmp(argv[1], "-pub")) {
            if(!fWritePub)
                --argcMin;
            ++fWritePub;
            --argc;
            ++argv;
        } else if(0 == _stricmp(argv[1], "-nc")) {
            ++fNCipher;
            --argc;
            ++argv;
            argcMin = 4;
        } else
            break;
    }

    if(fNCipher) {
        pcc = CNCipherCrypt::PccCreate(argv[1], argv[2]);
        if(!pcc) {
noncipher:
            fprintf(stderr, "error: unable to acquire nCipher context\n");
            return 1;
        }
        argv += 2;
        pfk = CFloppyCrypt::PccImportKey(pcc);
        if(!pfk)
            goto noncipher;
    } else {
        _cputs("Enter the source floppy and press <return>");
        for(;;) {
            ch = _getch();
            if(ch == 10 || ch == 13)
                break;
        }
        _putch(13);
        _putch(10);

        /* Acquire the crypt context */
        /* For now, allow unsecure keys */
        pfk = CFloppyCrypt::PccCreate(TRUE);
        if(!pfk)
            pfk = CFloppyCrypt::PccCreate();
        if(!pfk) {
            fprintf(stderr, "Unable to acquire signing keys\n");
            return 1;
        }
    }

    _cputs("Enter the destination floppy and press <return>");
    for(;;) {
        ch = _getch();
        if(ch == 10 || ch == 13)
            break;
    }
    _putch(13);
    _putch(10);

    if(fWritePub) {
        if(!pfk->FWritePub()) {
            fprintf(stderr, "Unable to write public key\n");
            return 1;
        }
    } else {
        if(!pfk->FWrite(argv[1])) {
            fprintf(stderr, "Unable to write encrypted key\n");
            return 1;
        }
    }

    fprintf(stderr, "Key written successfully\n");

    delete pfk;
    if(pcc)
        delete pcc;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\other\emutape\emutape.h ===
#include <windows.h>
#include <atlbase.h>
#include <xsum.h>
#include <tape.h>
#include <dx2ml.h>
#include <crypt.h>
#include <xctrl.h>
#include <emucore.h>

class CTapeDevice2 : public CTapeDevice
{
    friend class CBasedFile;
};

class CBasedFile : public CDiskFile
{
public:
    CBasedFile(CTapeDevice2 *ptap);
    CBasedFile(CDiskFile *pstm);
    virtual BOOL FSeek(LARGE_INTEGER li);
    virtual BOOL FSeek(LONG l);
private:
    LARGE_INTEGER m_liBase;
};

class CTapeEmulation : public CEmulationFilesystem
{
public:
    virtual void MountUnmount(BOOL fMount);
    virtual void GetPhysicalGeometry(PHYSICAL_GEOMETRY *, BOOL);
    virtual int NumberOfPlaceholders(int Layer);
    virtual void GetPlaceholderInformation(int Layer,
        PLACEHOLDER *Placeholders);
    virtual ULONG GetSectorData(ULONG lsn, ULONG cblk, PUCHAR rgbData);
};

class CTapeEmulationDVDX2 : public CTapeEmulation
{
public:
	virtual BOOL GetControlData(BOOL fXControl, PUCHAR pb, ULONG cb,
		PULARGE_INTEGER Delay);
    virtual BOOL DiscChallengeResponse(UCHAR id, PULONG ChallengeValue,
        PULONG ResponseValue, PULARGE_INTEGER Delay);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\other\flkey\precomp.h ===
#include <windows.h>
#include <wincrypt.h>
#include <xsum.h>
#include <crypt.h>
#include <flcrypt.h>
#include <ncipher.h>
#include <propbag.h>
#include <xbefile.h>
#include <stdio.h>
#include <time.h>
#include <malloc.h>
#include <conio.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\other\gdf2file\gdf2file.cpp ===
/*
 *
 * gdf2file.cpp
 *
 * Convert a GDF image to a file tree
 *
 */

#include "gdf2file.h"

BOOL g_fXbox;
PDM_CONNECTION g_pdcon;
CXboxFile *CXboxFile::g_pxfCur;

void GDQ::PushDir(GDIR *pgdir)
{
    GDQE *pgdqe = new GDQE;

    pgdqe->pgdir = pgdir;
    pgdqe->pgdqeNext = NULL;

    *m_ppgdqeLast = pgdqe;
    m_ppgdqeLast = &pgdqe->pgdqeNext;
}

GDIR *GDQ::PopDir(void)
{
    GDQE *pgdqe = m_pgdqeFirst;
    GDIR *pgdir;

    if(!pgdqe)
        return NULL;

    pgdir = pgdqe->pgdir;
    m_pgdqeFirst = pgdqe->pgdqeNext;
    delete pgdqe;
    if(!m_pgdqeFirst)
        m_ppgdqeLast = &m_pgdqeFirst;
    return pgdir;
}

CXboxFile::CXboxFile(LPCSTR szName, DWORD cb)
{
    char szCmd[MAX_PATH + 128];
    HRESULT hr;

    m_cbLeft = cb;
    if(!g_pxfCur) {
        if(!g_pdcon && FAILED(DmOpenConnection(&g_pdcon)))
            g_pdcon = NULL;
        if(g_pdcon) {
            sprintf(szCmd, "SENDFILE NAME=\"%s\" LENGTH=%lu", szName, cb);
            hr = DmSendCommand(g_pdcon, szCmd, NULL, 0);
            if(hr == XBDM_READYFORBIN)
                g_pxfCur = this;
            else if(SUCCEEDED(hr)) {
                DmCloseConnection(g_pdcon);
                g_pdcon = NULL;
            }
        }
    }
}

CXboxFile::~CXboxFile()
{
    DWORD cb;
    BYTE rgb[8192];

    if(g_pxfCur == this && g_pdcon) {
        if(m_cbLeft) {
            memset(rgb, 0, sizeof rgb);
            while(m_cbLeft) {
                cb = m_cbLeft;
                if(cb > sizeof rgb)
                    cb = sizeof rgb;
                if(FAILED(DmSendBinary(g_pdcon, rgb, cb))) {
                    DmCloseConnection(g_pdcon);
                    g_pdcon = NULL;
                    break;
                }
                m_cbLeft -= cb;
            }
        }
        DmReceiveStatusResponse(g_pdcon, NULL, 0);
        g_pxfCur = NULL;
    }
}

DWORD CXboxFile::CbWrite(DWORD cb, const BYTE *pbBuf)
{
    if(cb > m_cbLeft)
        cb = m_cbLeft;
    if(g_pxfCur != this || !g_pdcon || !cb)
        return 0;
    if(FAILED(DmSendBinary(g_pdcon, pbBuf, cb))) {
        DmCloseConnection(g_pdcon);
        g_pdcon = NULL;
        g_pxfCur = NULL;
        return 0;
    }
    m_cbLeft -= cb;
    return cb;
}

BOOL FCreateDirectory(LPCSTR szName)
{
    return g_fXbox ? SUCCEEDED(DmMkdir(szName)) : CreateDirectory(szName, NULL);
}

GDIR *PgdirCreate(CFileStmSeq *pstm, DWORD cb, LPCSTR szName)
{
    PBYTE pb;
    DWORD cbRead;

    /* Need to read in a multiple of sectors since we're doing unbuffered
     * I/O */
    cbRead = (cb + 2047) & ~2047;
    pb = (PBYTE)malloc(cbRead);
    if(!pstm->CbRead(cbRead, pb)) {
        free(pb);
        pb = NULL;
    }
    return new GDIR(pb, cb, szName);
}

int __cdecl main(int argc, char **argv)
{
    int i;
    CDiskFile *pstmIn;
    CFileStmSeq *pstmOut;
    GDF_VOLUME_DESCRIPTOR gvd;
    PGDF_DIRECTORY_ENTRY pgde;
    BYTE rgb[8192];
    GDIR *pgdir, *pgdirRoot, *pgdirT;
    GDQ gdq;
    char szFileName[MAX_PATH+1];
    DWORD dw;
    DWORD cb, cbCur, cbRead;
    LARGE_INTEGER liOffset;

    if(argc >= 2 && 0 == _stricmp(argv[1], "-xbox")) {
        --argc;
        ++argv;
        g_fXbox = TRUE;
    } else
        g_fXbox = FALSE;

    if(argc < 3) {
        fprintf(stderr, "usage: gdf2file iso tree\n");
        return 1;
    }

    /* Make sure the output dir tree exists */
    dw = GetFileAttributes(argv[2]);
    if(dw == -1) {
        if(!FCreateDirectory(argv[2])) {
            fprintf(stderr, "cannot create %s\n", argv[2]);
            return 1;
        }
    } else if(!(dw & FILE_ATTRIBUTE_DIRECTORY)) {
        fprintf(stderr, "%s exists and is not a directory\n", argv[2]);
        return 1;
    }
    pstmIn = new CDiskFile(argv[1], GENERIC_READ | (FILE_FLAG_NO_BUFFERING >>
        16));
    if(!pstmIn->FIsOpen()) {
        fprintf(stderr, "could not open %s\n", argv[1]);
        return 1;
    }

    /* Grab the GDF volume descriptor */
    if(!pstmIn->FSeek(GDF_VOLUME_DESCRIPTOR_SECTOR * 2048))
        goto badformat;
    if(pstmIn->CbRead(2048, (PBYTE)&gvd) != 2048) {
badformat:
        fprintf(stderr, "bad image format or read error\n");
        return 1;
    }
    if(memcmp(gvd.HeadSignature, GDF_VOLUME_DESCRIPTOR_SIGNATURE,
            GDF_VOLUME_DESCRIPTOR_SIGNATURE_LENGTH) ||
            memcmp(gvd.TailSignature, GDF_VOLUME_DESCRIPTOR_SIGNATURE,
            GDF_VOLUME_DESCRIPTOR_SIGNATURE_LENGTH))
        goto badformat;

    /* Read the root directory and push it on the dir stack */
    printf("Root dir at %d\n", gvd.RootDirectoryFirstSector);
    liOffset.QuadPart = gvd.RootDirectoryFirstSector;
    liOffset.QuadPart *= 2048;
    if(!pstmIn->FSeek(liOffset))
        goto badformat;
    pgdirRoot = PgdirCreate(pstmIn, gvd.RootDirectoryFileSize, argv[2]);
    if(!pgdirRoot->FGotData())
        goto badformat;
    gdq.PushDir(pgdirRoot);

    /* Now process all directories */
    while(pgdir = gdq.PopDir()) {
        pgdir->ResetWalk();
        while(pgde = pgdir->PgdeGetNextEntry()) {
            sprintf(szFileName, "%s\\%.*s", pgdir->SzName(),
                pgde->FileNameLength, pgde->FileName);
            printf("%s at %lu\n", szFileName, pgde->FirstSector);
            liOffset.QuadPart = pgde->FirstSector;
            liOffset.QuadPart *= 2048;
            if(!pstmIn->FSeek(liOffset))
                goto badformat;
            if(pgde->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                pgdirT = PgdirCreate(pstmIn, pgde->FileSize, szFileName);
                if(!pgdirT->FGotData())
                    goto badformat;
                if(!FCreateDirectory(szFileName)) {
writeerr:
                    fprintf(stderr, "could not create %s\n", szFileName);
                    return 1;
                }
                gdq.PushDir(pgdirT);
            } else {
                cb = pgde->FileSize;
                if(g_fXbox)
                    pstmOut = new CXboxFile(szFileName, cb);
                else
                    pstmOut = new CDiskFile(szFileName, GENERIC_WRITE);
                if(!pstmOut->FIsOpen())
                    goto writeerr;
                while(cb) {
                    cbCur = cb;
                    if(cbCur > sizeof rgb)
                        cbRead = cbCur = sizeof rgb;
                    else
                        cbRead = (cb + 2047) & ~2047;
                    if(pstmIn->CbRead(cbRead, rgb) != cbRead)
                        goto badformat;
                    if(pstmOut->CbWrite(cbCur, rgb) != cbCur)
                        goto writeerr;
                    cb -= cbCur;
                }
                delete pstmOut;
            }
        }
    }

    delete pstmIn;
    if(g_pdcon)
        DmCloseConnection(g_pdcon);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\other\gdf2file\gdf2file.h ===
/*
 *
 * tape2gdf.h
 *
 * Build a compacted GDF image from tape images
 *
 */

#include <windows.h>
#include <stdio.h>
#include <xsum.h>
#include <filestm.h>
#include <malloc.h>
#include <gdfdir.h>
#include <xboxdbg.h>

class GDQ {
public:
    GDQ(void) { m_pgdqeFirst = NULL; m_ppgdqeLast = &m_pgdqeFirst; }
    ~GDQ() { while(PopDir()); }

    void PushDir(GDIR *pgdir);
    GDIR *PopDir(void);

private:
    struct GDQE {
        GDQE *pgdqeNext;
        GDIR *pgdir;
    };

    GDQE *m_pgdqeFirst;
    GDQE **m_ppgdqeLast;
};

class CXboxFile : public CFileStmSeq
{
public:
    CXboxFile(LPCSTR szName, DWORD cb);
    virtual BOOL FIsOpen(void) { return g_pxfCur == this; }
    virtual DWORD CbRead(DWORD cb, PBYTE pbBuf) { return FALSE; }
    virtual DWORD CbWrite(DWORD cb, const BYTE *pbBuf);
    virtual BOOL FCopyToStm(CFileStmSeq *pstm, CCheckSum *pxsum=NULL) { return FALSE; }
    virtual ~CXboxFile();
protected:
    static CXboxFile *g_pxfCur;
    DWORD m_cbLeft;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\other\lbltest\lbltest.cpp ===
#include "precomp.h"

int __cdecl main(int argc, char **argv)
{
    CLabelPrinter *ppr;
    int n = 0;

    if(argc < 2)
        return 1;

    if(argc > 2) {
        if(argv[2][0] == '-') {
            sscanf(argv[2] + 1, "%d", &n);
            n = -n;
        } else
            sscanf(argv[2], "%d", &n);
    }
    ppr = CLabelPrinter::PprCreate(argv[1], n);
    if(ppr && ppr->FStartLabel()) {
        ppr->PrintLine("Line 1\nLine 2\nLine 3\nLine 4\nLine 5\nLine 6\n");
        ppr->EndLabel();
    }
        
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\other\signini\precomp.h ===
#include <windows.h>
#include <stdio.h>
#include <propbag.h>
#include <ini.h>
#include <malloc.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\other\lbltest\precomp.h ===
#include <windows.h>
#include <winspool.h>
#include <lblprint.h>
#include <stdio.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\other\signini\signini.cpp ===
#include "precomp.h"

extern "C" int __cdecl main(int argc, char **argv)
{
    CIniFile cif;

    if(argc < 2)
        return 1;

    if(!cif.FReadFile(argv[1], FALSE)) {
        fprintf(stderr, "Couldn't read %s\n", argv[1]);
        return 1;
    }

    if(!cif.FWriteFile(argv[2])) {
        fprintf(stderr, "Couldn't write %s\n", argv[1]);
        return 1;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\other\stampid\precomp.h ===
#include <windows.h>
#include <xsum.h>
#include <xbefile.h>
#include <stdio.h>
//#include <conio.h>
#include <xboxverp.h>
#include <time.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\signing\blkred\precomp.h ===
#include <windows.h>
#include <atlbase.h>
#include <msxml.h>
#include <stdio.h>
#include <xsum.h>
#include <propbag.h>
#include <ini.h>
#include <reg.h>
#include <tape.h>
#include <dx2ml.h>
#include <xbefile.h>
#include <ximg.h>
#include <xctrl.h>
#include <randm.h>
#include <lblprint.h>
#include <flcrypt.h>
#include <malloc.h>
#include <conio.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\signing\redgrn\precomp.h ===
#include <windows.h>
#include <wincrypt.h>
#include <atlbase.h>
#include <msxml.h>
#include <stdio.h>
#include <crypt.h>
#include <flcrypt.h>
#include <ncipher.h>
#include <xsum.h>
#include <propbag.h>
#include <ini.h>
#include <reg.h>
#include <tape.h>
#include <dx2ml.h>
#include <xbefile.h>
#include <ximg.h>
#include <xctrl.h>
#include <randm.h>
#include <lblprint.h>
#include <malloc.h>
#include <conio.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\signing\fsxbe\precomp.h ===
#include <windows.h>
#include <wincrypt.h>
#include <xsum.h>
#include <crypt.h>
#include <ini.h>
#include <flcrypt.h>
#include <ncipher.h>
#include <propbag.h>
#include <xbefile.h>
#include <randm.h>
#include <stdio.h>
#include <time.h>
#include <malloc.h>
#include <conio.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\signing\fsxbe\fsxbe.cpp ===
/*
 *
 * fsxbe.cpp
 *
 * Sign an XBE using a floppy key
 *
 */

#include "precomp.h"

CDevkitCrypt ccDev;
CCryptContainer *pccSign;
CFloppyCrypt *pfk;
CVarBag *pbagCert;
BOOL fRedKey;

BOOL FSignXBE(LPCSTR szIn, LPCSTR szOut, LPBYTE rgbID)
{
    CXBEFile *pxbe;
    XBEIMAGE_CERTIFICATE cert;
    const XBEIMAGE_CERTIFICATE *pcert;
    CDiskFile stmIn(szIn, GENERIC_READ);
    CDiskFile *pstmOut;

    if(0 == strcmp(szOut, "."))
        szOut = NULL;

    /* Load the input XBE */
    if(!(szOut ? stmIn.FIsOpen() : stmIn.FReopen(GENERIC_READ |
        GENERIC_WRITE)))
    {
        fprintf(stderr, "error: cannot open XBE file %s\n", szIn);
        return FALSE;
    }
    pxbe = new CXBEFile(&stmIn);

    /* Validate the input XBE */
    pxbe->UseCryptContainer(&ccDev);
    if(!pxbe->FVerifySignature()) {
badxbe:
        fprintf(stderr, "error: invalid XBE file %s\n", szIn);
        return FALSE;
    }

    /* Construct a new certificate */
    pcert = pxbe->GetCert();
    if(!pcert)
        goto badxbe;
    if(pbagCert) {
        if(!CXBEFile::FUnpackCertificate(pbagCert, &cert)) {
            fprintf(stderr, "error: illegal certificate data\n");
            return FALSE;
        }
        if(!cert.TitleName[0])
            memcpy(cert.TitleName, pcert->TitleName, sizeof cert.TitleName);
    } else {
        memset(&cert, 0, sizeof cert);
        memcpy(&cert, pcert, pcert->SizeOfCertificate);
        cert.SizeOfCertificate = sizeof cert;
    }
    if(!fRedKey && !CXBEFile::FGenNewKeys(&cert, pccSign)) {
        fprintf(stderr, "error: could not generate certificate keys\n");
        return FALSE;
    }
    if(pfk) {
        /* Use the key ID for the signature key */
        memset(cert.SignatureKey, 0, sizeof cert.SignatureKey - 4);
        pfk->FGetKeyId(cert.SignatureKey);
        /* Use the input ID for the LAN key */
        memcpy(cert.LANKey, rgbID, sizeof cert.SignatureKey - 4);
    }

    /* Inject the certificate */
    if(!pxbe->FInjectNewCertificate(&cert)) {
cantsign:
        fprintf(stderr, "error: could not sign XBE file\n");
        return FALSE;
    }

    /* Sign the XBE */
    pxbe->UseCryptContainer(pccSign);
    if(!pxbe->FSignFile() || !pxbe->FVerifySignature())
        goto cantsign;

    if(szOut) {
        pstmOut = new CDiskFile(szOut, GENERIC_WRITE);
        if(!pstmOut->FIsOpen()) {
writeerr:
            fprintf(stderr, "error: could not write file %s\n", szOut);
            return FALSE;
        }
        if(!pxbe->FWriteToStm(pstmOut))
            goto writeerr;
        delete pstmOut;
    } else {
        szOut = szIn;
        if(!pxbe->FCommitChanges())
            goto writeerr;
    }

    return TRUE;
}

int __cdecl main(int argc, char **argv)
{
    LPCSTR szOut;
    BYTE rgbID[16];
    FILE *pfl;
    CIniFile cif;
    char szLine[1024];
    char szXbeIn[512];
    char szXbeOut[512];
    char szID[512];
    BOOL f = FALSE;

    while(argc >= 2 && argv[1][0] == '-') {
        if(0 == _stricmp(argv[1], "-nc")) {
            if(argc < 4) {
                fprintf(stderr, "-nc option requires provider and container\n");
                return 1;
            }
            pccSign = CNCipherCrypt::PccCreate(argv[2], argv[3]);
            if(!pccSign) {
                fprintf(stderr, "error: could not acquire nCipher context\n");
                return 1;
            }
            argv += 3;
            argc -= 3;
        } else if(0 == _stricmp(argv[1], "-redkey")) {
            pccSign = new CDevkitCrypt;
            --argc;
            ++argv;
            ++fRedKey;
        } else if(0 == _stricmp(argv[1], "-cert")) {
            if(argc < 3) {
                fprintf(stderr, "-cert option requires certificate file name\n");
                return 1;
            }
            if(!cif.FReadFile(argv[2], FALSE)) {
badcert:
                fprintf(stderr, "error: could not process certificate %s\n",
                    argv[2]);
                return 1;
            }
            pbagCert = cif.PbagRoot()->FindProp("XBE Certificate");
            if(!pbagCert)
                goto badcert;
            argv += 2;
            argc -= 2;
        }
    }

    if(argc < 2) {
usage:
        fprintf(stderr, "usage: sign [-cert certfile] input-xbe output-xbe xbeID\n"
            "   or: sign @filelist\n");
        goto fatal;
    }

    if(argv[1][0] == '@') {
        pfl = fopen(&argv[1][1], "r");
        if(!pfl) {
            fprintf(stderr, "error: could not open input file %s\n",
                &argv[1][1]);
            goto fatal;
        }
    } else if(argc < 4)
        goto usage;
    else
        pfl = NULL;

    if(!pccSign) {
        /* Acquire the crypt context */
        pfk = CFloppyCrypt::PccCreate(TRUE);
        if(!pfk)
            pfk = CFloppyCrypt::PccCreate();
        if(!pfk) {
            fprintf(stderr, "Unable to acquire signing keys\n");
            return 1;
        }
        pccSign = pfk;
    }

    if(pfl) {
        f = TRUE;
        while(fgets(szLine, sizeof szLine, pfl)) {
            if(sscanf(szLine, "%s %s %s", szXbeIn, szXbeOut, szID) < 3)
                fprintf(stderr, "warning: unable to parse: %s\n", szLine);
            else if(*szXbeIn != '#') {
                fprintf(stderr, "from %s to %s, ID %s\n", szXbeIn, szXbeOut,
                    szID);
                memset(rgbID, 0, sizeof rgbID);
                strncpy((LPSTR)rgbID, szID, sizeof rgbID);
                if(!FSignXBE(szXbeIn, szXbeOut, rgbID)) {
                    fprintf(stderr, "..FAILED!\n");
                    f = FALSE;
                } else
                    fprintf(stderr, "..Succeeded!\n");
            }
        }
    } else {
        memset(rgbID, 0, sizeof rgbID);
        strncpy((LPSTR)rgbID, argv[3], sizeof rgbID);
        f = FSignXBE(argv[1], argv[2], rgbID);
    }

fatal:
    if(pfk != pccSign)
        delete pfk;
    if(pccSign)
        delete pccSign;

    return !f;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\signing\blkred\blkred.cpp ===
/*
 *
 * redgrn.cpp
 *
 * Red to Green signing tool
 *
 */

#include "precomp.h"

const char *rgszRSMKeys[] = { "Layer0CRC", "Layer1CRC", "XboxMediaCRC" };
LPCSTR szTempPath;
CTapeDevice tapSrc;
CTapeDevice tapDst0, tapDst1;
CDiskFile *pstmImage0, *pstmImage1;
CCryptContainer *pccRed;
CFloppyCrypt *pccSign;
CCryptContainer *pccXControl;
CCheckSum xsumBlk, xsumRed, xsumGrn, xsumMediaIn;
CCheckSum xsumDvd;
CIniBag *pbagInput;
CDX2MLFile xml;
CXControl xct;
CECMAControl ect;
DWORD cpsnDvd0, cpsnDvd1;
BYTE rgbDMI[2054];
BOOL fSetCertTitle;
BOOL fDemoMode;
XBEIMAGE_CERTIFICATE cert;
char szVideoPath[1024];

void MsgOut(LPCSTR szFormat, ...)
{
    va_list va;
    va_start(va, szFormat);
    vprintf(szFormat, va);
    va_end(va);
}

void DoneBeep(void)
{
    int i;

    _cputs("Press any key . . .");
    for(i = 0; !_kbhit(); ++i) {
        if(!(i & 0xF)) {
            _putch(7);
            MessageBeep(-1);
        } else
            Sleep(100);
    }
    _getch();
    _putch(13);
    _putch(10);
}

BOOL FMountTape(CTapeDevice *ptap, LPCSTR szName, BOOL fTOD, BOOL fWrite)
{
    HANDLE h;

    if(!szName)
        return FALSE;
    if(0 == strncmp(szName, "\\\\?", 3) || 0 == strncmp(szName, "\\\\.", 3))
        /* Tape device */
        return ptap->FMount(szName, fWrite);
    if(fWrite)
        h = CreateFile(szName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0,
            NULL);
    else
        h = CreateFile(szName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0,
            NULL);
    if(h == INVALID_HANDLE_VALUE)
        return FALSE;
    return ptap->FMount(h, fWrite);
}

CDiskFile *PstmCreateTemp(LPCSTR szName, DWORD dwFlags)
{
    char szFullName[MAX_PATH + 1];
    CDiskFile *pstm;

    if(!szTempPath)
        return NULL;

    sprintf(szFullName, "%s\\%s", szTempPath, szName);
    pstm = new CDiskFile(szFullName, dwFlags);
    if(!pstm->FIsOpen()) {
        delete pstm;
        pstm = NULL;
    } else
        pstm->SetDeleteOnClose(TRUE);
    return pstm;
}

BOOL FReadXMLFile(void)
{
    int idxi;
    int idxl;
    int idxr;
    DXML *pdxml;
    DXI *pdxi;
    DXR *pdxr;
    CDiskFile *pstmXML = NULL;
    DWORD dwDataBlkSize;
    DWORD dwDataPerPhy;
    BOOL fRet = FALSE;
    char szFileName[32];

    MsgOut("Reading input DX2ML.XML\n");
//#define WASBADXML
#ifdef WASBADXML
    pstmXML = PstmCreateTemp("dx2ml.xml", GENERIC_READ);
    if(!pstmXML) {
        fprintf(stderr, "error: no XML file to process\n");
        return FALSE;
    }
    pstmXML->SetDeleteOnClose(FALSE);
#else
    /* Get disk space for the files */
    pstmXML = PstmCreateTemp("dx2ml.xml", GENERIC_WRITE);
    if(!pstmXML) {
        fprintf(stderr, "error: cannot create temporary XML file\n");
        goto fatal;
    }
#endif

    if(!tapSrc.FReadFile(szFileName, &dwDataBlkSize, &dwDataPerPhy) ||
        strcmp(szFileName, "DX2ML.XML"))
    {
        fprintf(stderr, "error: source tape 0 missing XML file\n");
        goto fatal;
    }
#ifndef WASBADXML
    if(!tapSrc.FCopyToStm(pstmXML) || !tapSrc.FCloseFile()) {
        fprintf(stderr, "error: could not copy XML file from source tape\n");
        goto fatal;
    }
    if(!pstmXML->FReopen(GENERIC_READ))
        goto badxml;
#endif

    /* Process the DX2ML file */
    if(!xml.FReadFile(pstmXML->SzName(), FALSE)) {
badxml:
        fprintf(stderr, "error: could not process input DX2ML file\n");
        goto fatal;
    }

    if(!xml.FValidateForm())
        goto badxml;

    /* The only data that should be specified in this XML is the Xbox data
     * and the presence of the Xbox leadout stream */
    pdxml = xml.PdxmlGet();
    pdxi = &pdxml->rgdxi[0];
    for(idxi = 0; idxi < idxiMax; ++idxi, ++pdxi) {
        if(pdxi->f2054)
            goto badxml;
        if(idxi == idxiXControl && !pdxi->szNameOnTape)
            goto badxml;
        if(idxi == idxiControl && pdxi->szNameOnTape)
            goto badxml;
    }

    for(idxl = 0; idxl < 2; ++idxl) {
        pdxr = &pdxml->rgdxl[idxl].rgdxrAreas[0];
        for(idxr = 0; idxr < idxrMax; ++idxr, ++pdxr) {
            if(idxr == idxrXData) {
                if(pdxr->psnStart == 0)
                    goto badxml;
                if(pdxr->idxiImage < 0)
                    goto badxml;
                if(!pdxml->rgdxi[pdxr->idxiImage].szNameOnTape)
                    goto badxml;
            } else {
                if(pdxr->psnStart && pdxr->cpsnSize)
                    goto badxml;
                if(pdxr->idxiImage >= 0)
                    goto badxml;
            }
        }
    }

    fRet = TRUE;
fatal:
    if(pstmXML)
        delete pstmXML;
    return fRet;
}

BOOL FSetupXMLFile(void)
{
    int idxi;
    int ilyr;
    DXI dxiX0, dxiX1;
    DXML *pdxml;
    DXI *pdxi;
    DXL *pdxl;
    DXR *pdxr;
    DWORD psnStart0;
    DWORD psnEnd0;
    DWORD psnEnd1;

    MsgOut("Constructing output XML\n");
    pdxml = xml.PdxmlGet();

    /* Mark the xcontrol as being 2054 block mode */
    pdxml->rgdxi[idxiXControl].f2054 = TRUE;
    pdxml->rgdxl[1].dxrLead.idxiImage = idxiXControl;

    /* We need to make sure the input streams show up in the right order, so
     * move the XData streams */
    dxiX0 = pdxml->rgdxi[pdxml->rgdxl[0].dxrXData.idxiImage];
    dxiX1 = pdxml->rgdxi[pdxml->rgdxl[1].dxrXData.idxiImage];
    pdxml->rgdxi[3] = dxiX0;
    pdxml->rgdxi[4] = dxiX1;
    pdxml->rgdxl[0].dxrXData.idxiImage = 3;
    pdxml->rgdxl[1].dxrXData.idxiImage = 4;

    /* Configure the DVD input streams */
    pdxi = &pdxml->rgdxi[idxiControl];
    pdxi->szNameOnTape = _strdup("CONTROL.DAT");
    pdxi->szRefName = _strdup("Leadin0");
    pdxi->dwFlags = 0;
    pdxi->fUsedLyr0 = pdxi->fUsedLyr1 = TRUE;
    pdxml->rgdxl[0].dxrLead.idxiImage = idxiControl;
    pdxi = &pdxml->rgdxi[2];
    memset(pdxi, 0, sizeof *pdxi);
    pdxi->szRefName = _strdup("DvdLayer0Data");
    pdxi->szNameOnTape = _strdup("IMAGE0.DAT");
    pdxi->dwImageSize = cpsnDvd0;
    pdxi->fUsedLyr0 = TRUE;
    pdxml->rgdxl[0].dxrData.idxiImage = 2;
    pdxi = &pdxml->rgdxi[5];
    memset(pdxi, 0, sizeof *pdxi);
    pdxi->szRefName = _strdup("DvdLayer1Data");
    pdxi->szNameOnTape = _strdup("IMAGE1.DAT");
    pdxi->dwImageSize = cpsnDvd1;
    pdxi->fUsedLyr1 = TRUE;
    pdxml->rgdxl[1].dxrData.idxiImage = 5;
    ect.GetPsns(&psnStart0, &psnEnd0, &psnEnd1);

    /* Configure the layer 0 regions */
    pdxl = &pdxml->rgdxl[0];
    pdxr = &pdxl->rgdxrAreas[0];
    
    /* Layer0: leadin */
    pdxl->psnStart = 0x01F360;
    pdxr->psnStart = 0x02F000;
    pdxl->ipsnControlStart = 0x02F200 - pdxr->psnStart;
    pdxr->cpsnSize = psnStart0 - pdxr->psnStart;

    /* Layer0: data */
    ++pdxr;
    pdxr->psnStart = psnStart0;
    pdxr->cpsnSize = psnEnd0 - psnStart0 + 1;

    /* Layer0: middle */
    ++pdxr;
    pdxr->psnStart = psnEnd0 + 1;
    if(pdxr->psnStart > 0x050E00) {
baddata:
        fprintf(stderr, "error: failed to generate XML data\n");
        return FALSE;
    }
    pdxr->cpsnSize = 0x05B200 - pdxr->psnStart;

    /* Layer0: XLeadin */
    ++pdxr;
    pdxr->psnStart = 0x05B200;
    if(pdxr[1].psnStart < pdxr->psnStart + 0x005400)
        goto baddata;
    pdxr->cpsnSize = pdxr[1].psnStart - pdxr->psnStart;

    /* Layer0: XMiddle */
    ++pdxr;
    ++pdxr;
    /* start PSN is already correct from XML read */
    if(pdxr->psnStart + 0x14860 > 0x2377A0)
        goto baddata;
    pdxr->cpsnSize = 0x2377A0 - pdxr->psnStart;

    /* Now configure the layer1 regions */
    ++pdxl;
    pdxl->psnStart = 0xDC8860;
    pdxr = &pdxl->rgdxrAreas[idxrXMiddle];

    /* Layer1: XMiddle */
    pdxr->psnStart = pdxl->psnStart;
    pdxr->cpsnSize = pdxr[-1].psnStart - pdxr->psnStart;

    /* Layer1: XLeadin */
    --pdxr;
    --pdxr;
    pdxr->psnStart = pdxr[1].psnStart + pdxr[1].cpsnSize;
    if(pdxr->psnStart > 0xF9FA00)
        goto baddata;
    pdxr->cpsnSize = 0xFA4E00 - pdxr->psnStart;

    /* Layer1: middle */
    --pdxr;
    pdxr->psnStart = 0xFA4E00;
    psnEnd0 ^= 0xFFFFFF;
    if(psnEnd0 < pdxr->psnStart + 0x005400)
        goto baddata;
    pdxr->cpsnSize = psnEnd0 - pdxr->psnStart;

    /* Layer1: data */
    --pdxr;
    pdxr->psnStart = psnEnd0;
    pdxr->cpsnSize = cpsnDvd1;

    /* Layer1: leadout */
    --pdxr;
    pdxr->psnStart = psnEnd0 + cpsnDvd1;
    if(psnEnd1 > 0xFD0000)
        goto baddata;
    pdxr->cpsnSize = 0xFE0CA0 - pdxr->psnStart;
    pdxl->ipsnControlStart = 0xFD0200 - pdxr->psnStart;

    /* Make sure we did it all right */
    if(!xml.FValidateContent())
        goto baddata;

    return TRUE;
}

BOOL FSetupVideoFiles(void)
{
    LARGE_INTEGER li;
    ULONG cpsn1;
    ULONG psnStart0, psnEnd0, psnEnd1;
    BOOL fRet = FALSE;
    char szName[1024];
    CDiskFile *pstmControl;

    /* Find our DVD video control file */
    sprintf(szName, "%s\\control.dat", szVideoPath);
    pstmControl = new CDiskFile(szName, GENERIC_READ);
    if(!pstmControl->FIsOpen())
        goto readerr;
    if(!ect.FInit(pstmControl)) {
badcontrol:
        fprintf(stderr, "error: bad DVD video control data\n");
        return FALSE;
    }
    ect.GetPsns(&psnStart0, &psnEnd0, &psnEnd1);
    /* Data needs to start in a fixed location */
    if(psnStart0 != 0x030000)
        goto badcontrol;
    /* Layer 0 data needs to end on an ECC boundary and not be too big */
    if((psnEnd0 & 0xF) != 0xF || psnEnd0 >= 0x050E00)
        goto badcontrol;
    /* Layer 1 data can't exceed layer 0 in size */
    if((psnEnd1 ^ 0xFFFFFF) < psnStart0)
        goto badcontrol;

    /* Find our DVD video image files */
    sprintf(szName, "%s\\image0.dat", szVideoPath);
    pstmImage0 = new CDiskFile(szName, GENERIC_READ);
    sprintf(szName, "%s\\image1.dat", szVideoPath);
    pstmImage1 = new CDiskFile(szName, GENERIC_READ);

    if(!pstmImage0->FIsOpen() || !pstmImage1->FIsOpen()) {
readerr:
        fprintf(stderr, "error: could not read DVD video files\n");
        return FALSE;
    }

    /* Get their sizes and validate against the control data */
    if(!GetFileSizeEx(*pstmImage0, &li))
        goto readerr;
    /* Need to have an integral number of disk blocks (not necessarily ECC
     * blocks) */
    if(li.LowPart & 0x7FF)
        goto readerr;
    cpsnDvd0 = (ULONG)(li.QuadPart / 2048);
    if(cpsnDvd0 != psnEnd0 - psnStart0 + 1) {
baddata:
        fprintf(stderr, "DVD video data is of invalid size\n");
        return FALSE;
    }
    if(!GetFileSizeEx(*pstmImage1, &li))
        goto readerr;
    if(li.LowPart & 0x7FF)
        goto readerr;
    cpsnDvd1 = (ULONG)(li.QuadPart / 2048);
    cpsn1 = psnEnd1 - (psnEnd0 ^ 0xFFFFFF) + 1;
    cpsn1 = (cpsn1 + 0xF) & ~0xF;
    if(cpsnDvd1 != cpsn1)
        goto baddata;

    return TRUE;
}

BOOL FReadXControlFile(void)
{
    int i;
    int ib;
    DXR *pdxr0;
    DXR *pdxr1;
    DXML *pdxml;
    DWORD psnStart0;
    DWORD psnEnd0;
    DWORD psnEnd1;
    DWORD dwDataBlkSize;
    DWORD dwDataPerPhy;
    BYTE b;
    BYTE rgb[2048];
    char szFileName[32];

    MsgOut("Reading input XCONTROL.DAT\n");
    if(!tapSrc.FReadFile(szFileName, &dwDataBlkSize, &dwDataPerPhy) ||
        dwDataBlkSize != 2048 || strcmp(szFileName, "XCONTROL.DAT"))
    {
        fprintf(stderr, "error: source tape missing xcontrol.dat file\n");
        return FALSE;
    }
    /* First make sure that we have 30 blocks of zero */
    for(i = 0; i < 30; ++i) {
        if(tapSrc.CbRead(sizeof rgb, rgb) != sizeof rgb) {
readerr:
            fprintf(stderr, "error: could not read XControl from tape\n");
            return FALSE;
        }
        for(b = 0, ib = 0; ib < sizeof rgb; ++ib)
            b |= rgb[ib];
        if(b) {
baddata:
            fprintf(stderr, "error: invalid XControl data on tape\n");
            return FALSE;
        }
    }

    /* Now read the XControl frame */
    if(!xct.FInit(&tapSrc))
        goto baddata;

    /* Make sure that the XControl data matches the XML data */
    if(!xct.FValidate(xml.PdxmlGet(), NULL))
        goto baddata;

    /* We shouldn't have data in the DMI frame; make sure it's empty */
    if(tapSrc.CbRead(sizeof rgb, rgb) != sizeof rgb)
        goto readerr;
    for(b = 0, ib = 0; ib < sizeof rgb; ++ib)
        b |= rgb[ib];
    if(b)
        goto baddata;

    /* There should be no more data in the file */
    if(tapSrc.CbRead(1, rgb) != 0)
        goto baddata;

    return TRUE;
}

BOOL FWriteBaseTapeFiles(int ilyr, CTapeDevice *ptapDst, LPCSTR szMediaRef)
{
    int i;
    BYTE rgb[2054];
    CDX2MLFile *pxml = &xml;
    BOOL fRet = FALSE;
    DXML *pdxml;
    char szLayerRef[256];

    /* Stamp the layer ref into the XML file */
    sprintf(szLayerRef, "%s-L%d", szMediaRef, ilyr);
    pxml->SetMasteringRef(szLayerRef);

    /* First write the DX2ML file */
    MsgOut("Writing DX2ML.XML to layer %d\n", ilyr);
    if(!ptapDst->FWriteFile("DX2ML.XML", 32768, 1)) {
writeerr:
        fprintf(stderr, "error: writing to tape %d\n", ilyr);
        goto fatal;
    }
    pdxml = pxml->PdxmlGet();
    pdxml->iLayer = ilyr;
    if(!pxml->FWriteFile(ptapDst))
        goto writeerr;
    if(!ptapDst->FCloseFile())
        goto writeerr;

    /* Next comes CONTROL.DAT */
    MsgOut("Writing CONTROL.DAT to layer %d\n", ilyr);
    if(!ptapDst->FWriteFile("CONTROL.DAT", 2048, 16))
        goto writeerr;
    /* Control data is first */
    if(!ect.FWriteToStm(ptapDst))
        goto writeerr;
    /* Then the DMI */
    if(ptapDst->CbWrite(2048, rgbDMI + 6) != 2048)
        goto writeerr;
    /* Now 14 blocks of zero */
    memset(rgb, 0, sizeof rgb);
    for(i = 0; i < 14; ++i) {
        if(ptapDst->CbWrite(2048, rgb) != 2048)
            goto writeerr;
    }
    if(!ptapDst->FCloseFile())
        goto writeerr;

    /* Next comes XCONTROL.DAT, which we have to write in 2054-byte mode */
    MsgOut("Writing XCONTROL.DAT to layer %d\n", ilyr);
    if(!ptapDst->FWriteFile("XCONTROL.DAT", 2054, 16))
        goto writeerr;
    /* First we write 30 blocks of zero */
    for(i = 0; i < 30; ++i) {
        if(ptapDst->CbWrite(sizeof rgb, rgb) != sizeof rgb)
            goto writeerr;
    }
    /* Then the xcontrol data */
    if(!xct.FSign(pccXControl) || !xct.FWriteToStm(ptapDst, 2054))
        goto writeerr;
    /* Then the DMI */
    if(ptapDst->CbWrite(sizeof rgbDMI, rgbDMI) != sizeof rgbDMI)
        goto writeerr;
    if(!ptapDst->FCloseFile())
        goto writeerr;

    fRet = TRUE;
fatal:
    return fRet;
}

BOOL FWriteAPData(int ilyr, int ixph, CTapeDevice *ptapDst)
{
    MsgOut("Writing placeholder data\n");
    return xct.FWriteAPData(ilyr, ixph, ptapDst);
}

BOOL FRedsignXBE(int ilyr, CXBEFile *pxbe, DWORD cblk, CTapeDevice *ptapDst)
{
    const XBEIMAGE_CERTIFICATE *pcert;

    MsgOut("Processing XBE file\n");
    pxbe->UseCryptContainer(pccRed);
    if(!pxbe->FVerifySignature()) {
badxbe:
        fprintf(stderr, "error: found an invalid XBE file on tape %d\n", ilyr);
        return FALSE;
    }

    /* Fetch the old certificate data, if necessary */
    pcert = pxbe->GetCert();
    if(!pcert)
        goto badxbe;
    if(!fSetCertTitle)
        memcpy(cert.TitleName, pcert->TitleName, sizeof pcert->TitleName);
    if(fDemoMode)
        cert.GameRatings = pcert->GameRatings;

    /* Inject the new certificate */
    if(!pxbe->FInjectNewCertificate(&cert)) {
        fprintf(stderr, "error: could not inject XBE certificate\n");
        return FALSE;
    }

    if(pccSign)
        pxbe->UseCryptContainer(pccSign);
    if(!pxbe->FSignFile()) {
        fprintf(stderr, "error: unable to sign XBE file\n");
        return FALSE;
    }
    if(!pxbe->FWriteToStm(ptapDst, cblk * 2048)) {
        fprintf(stderr, "error: writing destination tape %d\n", ilyr);
        return FALSE;
    }
    if(!pxbe->FCalcChecksums(&xsumBlk, &xsumRed, &xsumGrn)) {
        fprintf(stderr, "error: reading temporary XBE file\n");
        return FALSE;
    }
    return TRUE;
}

BOOL FCopyTapeImages(void)
{
    int ilyr;
    int idxi;
    DXML *pdxml = xml.PdxmlGet();
    DXL *pdxl;
    CTapeDevice *ptapDst;
    DWORD dwDataBlkSize;
    DWORD dwDataPerPhy;
    char szFileName[32];

    /* We write DVD image 0 first */
    MsgOut("Writing layer 0 DVD video data\n");
    if(!pstmImage0->FSeek(0)) {
cantcopy:
        fprintf(stderr, "error: coyping DVD video to tape %d\n", ilyr);
        return FALSE;
    }
    if(!tapDst0.FWriteFile("IMAGE0.DAT", 2048, 16))
        goto writeerr;
    if(!pstmImage0->FCopyToStm(&tapDst0, &xsumDvd))
        goto cantcopy;
    if(!tapDst0.FCloseFile())
        goto writeerr;

    /* Now we process the tape images */
    while(tapSrc.FReadFile(szFileName, &dwDataBlkSize, &dwDataPerPhy)) {
        /* If this is the layer 0 file, process it */
        pdxl = &pdxml->rgdxl[0];
        for(ilyr = 0; ilyr < 2; ++ilyr, ++pdxl) {
            idxi = pdxl->dxrXData.idxiImage;
            if(0 == strcmp(szFileName, pdxml->rgdxi[idxi].szNameOnTape))
                break;
        }
        if(ilyr == 2) {
            fprintf(stderr, "error: unknown file %s on source tape\n",
                szFileName);
            return FALSE;
        }
        if(dwDataBlkSize != 2048) {
            fprintf(stderr, "error: %s has wrong block size\n", szFileName);
            return FALSE;
        }
        ptapDst = ilyr ? &tapDst1 : &tapDst0;
        MsgOut("Processing Xbox image data for layer %d\n", ilyr);
        if(!ptapDst->FWriteFile(szFileName, 2048, 16)) {
writeerr:
            fprintf(stderr, "error: writing to tape %d\n", ilyr);
            return FALSE;
        }
        if(!FProcessXImage(ilyr, pdxl, idxrXData, &tapSrc, ptapDst,
                FRedsignXBE, FWriteAPData))
            return FALSE;
        if(!ptapDst->FCloseFile())
            goto writeerr;
    }

    /* Finally we write the layer 1 video */
    MsgOut("Writing layer 1 DVD video data\n");
    if(!pstmImage1->FSeek(0))
        goto cantcopy;
    if(!tapDst1.FWriteFile("IMAGE1.DAT", 2048, 16))
        goto writeerr;
    if(!pstmImage1->FCopyToStm(&tapDst1, &xsumDvd))
        goto cantcopy;
    if(!tapDst1.FCloseFile())
        goto writeerr;

    return TRUE;
}

BOOL FSetupSecurity(void)
{
    MsgOut("Preparing xcontrol AP data\n");
    return xct.FSetupAP(xml.PdxmlGet());
}

BOOL FGetAsDword(CIniBag *pbag, LPCSTR szSection, LPCSTR szKey, PDWORD pdw)
{
    CVarBag *pbvp = pbag->FindProp(szSection);
    if(!pbvp)
        return FALSE;
    VPR *pvpValue = pbvp->FindProp(szKey);
    if(!pvpValue || pvpValue->vpType != vpDw)
        return FALSE;
    *pdw = pvpValue->dw;
    return TRUE;
}

int __cdecl main(int cArg, char **rgszArg)
{
    LPCSTR szInputName = "xbcert.ini";
    LPCSTR szOutputName = "xbvalidate.ini";
    LPCSTR szVideoName = NULL;
    BOOL fBeep = FALSE;
    BOOL fTOD = FALSE;
    BOOL fRedDVD = FALSE;
    BOOL fNoCheckPH = FALSE;
    CIniFile cifInput;
    CIniFile cifOutput;
    CDiskFile *pstmT;
    CVarBag *pbagMCR;
    CVarBag *pbagT;
    CLabelPrinter *ppr0 = NULL;
    CLabelPrinter *ppr1 = NULL;
    HKEY hkey;
    int i;
    DWORD dwXsumSrc;
    DWORD dwSubmission;
    FILETIME ftSign;
    DWORD dwOff;
    VPR *pvp;
    LPCSTR szSignKey = NULL;
    LPCSTR szT;
    char szMediaRef[16];

    /* Initial setup */
    while(++rgszArg, --cArg) {
        if(_stricmp(*rgszArg, "-video") == 0) {
            if(!--cArg) {
noarg:
                fprintf(stderr, "error: missing argument for %s\n", *rgszArg);
                exit(1);
            }
            szVideoName = *++rgszArg;
        } else if(_stricmp(*rgszArg, "-input") == 0) {
            if(!--cArg)
                goto noarg;
            szInputName = *++rgszArg;
        } else if(_stricmp(*rgszArg, "-output") == 0) {
            if(!--cArg)
                goto noarg;
            szOutputName = *++rgszArg;
        } else if(_stricmp(*rgszArg, "-beep") == 0) {
            ++fBeep;
        } else if(_stricmp(*rgszArg, "-tod") == 0) {
            ++fTOD;
        } else if(_stricmp(*rgszArg, "-nocheckph") == 0) {
            ++fNoCheckPH;
        } else if(_stricmp(*rgszArg, "-reddvd") == 0) {
            ++fRedDVD;
        } else if(_stricmp(*rgszArg, "-demodisk") == 0) {
            ++fDemoMode;
        } else if(_stricmp(*rgszArg, "-fksign") == 0) {
            /* We're going to be signing with a floppy key, so grab the
             * signing name */
            if(!--cArg || rgszArg[1][0] == '-')
                goto noarg;
            szSignKey = *++rgszArg;
        } else {
            fprintf(stderr, "error: unknown argument %s\n", *rgszArg);
            exit(1);
        }
    }

    if(!szVideoName) {
        fprintf(stderr, "error: missing DVD video name\n");
        exit(1);
    }

    if(ERROR_SUCCESS != RegOpenKey(HKEY_CURRENT_USER,
        "Software\\Microsoft\\Xbox Game Signing Tool\\Black2RedDLT", &hkey) ||
        !(pbagMCR = PbagFromRegKey(hkey)))
    {
        fprintf(stderr, "error: could not read machine configuration registry\n");
        exit(1);
    }

    /* Make sure we can read our input file */
    if(!cifInput.FReadFile(szInputName, TRUE)) {
        fprintf(stderr, "error: could not process input file %s\n",
            szInputName);
        exit(1);
    }
    pbagInput = cifInput.PbagRoot();

    /* Prepare the DVD video files */
    MsgOut("Processing DVD video files\n");
    sprintf(szVideoPath, "%s\\%s", pbagMCR->FindSzProp("DVDVideoPath"),
        szVideoName);
    if(!FSetupVideoFiles())
        goto fatal;

    /* Prepare the certificate data */
    if(!CXBEFile::FUnpackCertificate(pbagInput->FindProp("XBE Certificate"),
        &cert))
    {
        fprintf(stderr, "error: bad input certificate data\n");
        goto fatal;
    }
    fSetCertTitle = cert.TitleName[0];
    if(!CXBEFile::FGenNewKeys(&cert, NULL)) {
        fprintf(stderr, "error: could not generate XBE keys\n");
        goto fatal;
    }
    if(szSignKey) {
        /* Acquire the signing context before we do anything else */
        pccSign = CFloppyCrypt::PccCreate();
        if(!pccSign) {
            fprintf(stderr, "error: unable to acquire key context\n");
            exit(1);
        }

        /* We're going to use the input string as the LAN key */
        memset(cert.LANKey, 0, sizeof cert.LANKey - 4);
        strncpy((LPSTR)cert.LANKey, szSignKey, sizeof cert.LANKey - 4);
        /* And we're going to use the key ID as the signature key */
        memset(cert.SignatureKey, 0, sizeof cert.SignatureKey - 4);
        pccSign->FGetKeyId(cert.SignatureKey - 4);
    }

    /* Construct the DMI block */
    pbagT = pbagInput->FindProp("XBCERT");
    if(!pbagT) {
badinput:
        fprintf(stderr, "error: missing or incorrect data in input file\n");
        exit(1);
    }
    pvp = pbagT->FindProp("XMID");
    if(!pvp || pvp->vpType != vpSz || strlen(pvp->sz) != 8)
        goto badinput;
    rgbDMI[6] = 1;
    memcpy(rgbDMI + 6 + 8, pvp->sz, 8);
    GetSystemTimeAsFileTime(&ftSign);
    memcpy(rgbDMI + 6 + 16, &ftSign, sizeof ftSign);
    rgbDMI[6 + 24] = 1;

    /* Get other appropriate input data */
    if(!FGetAsDword(pbagInput, "XBCERT", "InputCRC", &dwXsumSrc) ||
            !FGetAsDword(pbagInput, "XBCERT", "Submission", &dwSubmission))
        goto badinput;
    if(dwSubmission)
        sprintf(szMediaRef, "%.*s-R%d", 8, rgbDMI + 6 + 8,
            dwSubmission);
    else
        sprintf(szMediaRef, "%.*s", 8, rgbDMI + 6 + 8);

    /* Make sure we have a place to stick temporary data */
    szTempPath = pbagMCR->FindSzProp("TemporaryPath");
    pstmT = PstmCreateTemp("test.tst", GENERIC_WRITE);
    if(!pstmT) {
        fprintf(stderr, "error: cannot create temporary files\n");
        exit(1);
    }
    delete pstmT;
    pstmT = NULL;

    /* Set up our devkit key */
    pccRed = new CDevkitCrypt;

    /* Set up our XControl signing key */
    if(pccSign && !fRedDVD)
        pccXControl = pccSign;
    else
        pccXControl = pccRed;

    /* Configure the label printers */
    szT = pbagMCR->FindSzProp("LabelPrinter0");
    if(szT) {
        MsgOut("Configuring label printers\n");
        if(!pbagMCR->FFindDwProp("PrinterOffset0", &dwOff))
            dwOff = 0;
        ppr0 = CLabelPrinter::PprCreate(szT, -(int)dwOff);
        if(!ppr0) {
            fprintf(stderr, "error: could not configure label printer 0\n");
            goto fatal;
        }
        szT = pbagMCR->FindSzProp("LabelPrinter1");
        if(szT) {
            if(!pbagMCR->FFindDwProp("PrinterOffset1", &dwOff))
                dwOff = 0;
            ppr1 = CLabelPrinter::PprCreate(szT, -(int)dwOff);
            if(!ppr1) {
                fprintf(stderr, "error: could not configure label printer 1\n");
                goto fatal;
            }
        } else
            ppr1 = ppr0;
    }

    /* Mount the source tape */
    MsgOut("Mounting source tape\n");
    if(!FMountTape(&tapSrc, pbagMCR->FindSzProp("SourceTape"), fTOD, FALSE)) {
        fprintf(stderr, "error: could not mount source tape\n");
        exit(1);
    }

    /* Mount the destination tapes */
    MsgOut("Mounting destination tape 0\n");
    if(!FMountTape(&tapDst0, pbagMCR->FindSzProp("DestinationTape0"), fTOD,
        TRUE))
    {
        fprintf(stderr, "error: could not mount destination tape 0\n");
        exit(1);
    }
    MsgOut("Mounting destination tape 1\n");
    if(!FMountTape(&tapDst1, pbagMCR->FindSzProp("DestinationTape1"), fTOD,
        TRUE))
    {
        fprintf(stderr, "error: could not mount destination tape 1\n");
        exit(1);
    }
    tapDst0.SetWritePadByte('\n');
    tapDst1.SetWritePadByte('\n');

    /* We need to process the DX2ML file and the XControl file first.  They
     * should appear on the tape in that order */
    if(!FReadXMLFile() || !FReadXControlFile())
        goto fatal;

    /* Make sure the placeholder locations are valid */
    if(fNoCheckPH) {
        if(!xml.FValidatePlaceholderLocations(TRUE, FALSE, TRUE))
            goto fatal;
    } else if(!xml.FValidatePlaceholderLocations(FALSE, FALSE, TRUE))
        goto fatal;

    /* Build our security data */
    if(!FSetupSecurity())
        goto fatal;

    /* Now go back and put our XML data together */
    if(!FSetupXMLFile())
        goto fatal;

    /* With that out of the way, we write the base files on each tape */
    if(!FWriteBaseTapeFiles(0, &tapDst0, szMediaRef))
        goto fatal;
    if(!FWriteBaseTapeFiles(1, &tapDst1, szMediaRef))
        goto fatal;

    /* Now we deal with the two image files */
    if(!FCopyTapeImages())
        goto fatal;

    /* Make sure the input CRCs matched */
    if(tapSrc.DwCheckSum() != dwXsumSrc) {
        fprintf(stderr, "error: input data has incorrect checksum\n");
        goto fatal;
    }

    /* Destroy the signing contexts */
    delete pccRed;
    pccRed = NULL;
    if(pccSign) {
        delete pccSign;
        pccSign = NULL;
    }

    /* Unmount the tapes */
    MsgOut("Unounting source tape\n");
    tapSrc.FUnmount();
    MsgOut("Unounting destination tape 0\n");
    if(!tapDst0.FUnmount()) {
        fprintf(stderr, "error: unmounting destination tape 0\n");
        goto fatal;
    }
    MsgOut("Unounting destination tape 1\n");
    if(!tapDst1.FUnmount()) {
        fprintf(stderr, "error: unmounting destination tape 1\n");
        goto fatal;
    }

    /* Output XBVALIDATE values */
    MsgOut("Writing output data\n");
    pbagT = new CVarBag;
    cifOutput.PbagRoot()->FAddProp("Disk Manufacturing Information", pbagT);
    rgbDMI[6 + 16] = 0;
    pbagT->FAddProp("XMID", (LPSTR)(rgbDMI + 6 + 8));
    pbagT->FAddProp("TimeStampLow", ftSign.dwLowDateTime);
    pbagT->FAddProp("TimeStampHigh", ftSign.dwHighDateTime);
    pbagT = new CVarBag;
    cifOutput.PbagRoot()->FAddProp("XBE Information", pbagT);
    pbagT->FAddProp("TitleID", cert.TitleID);
    pbagT->FAddProp("Version", cert.Version);
    pbagT = new CVarBag;
    cifOutput.PbagRoot()->FAddProp("Xbox", pbagT);
    pbagT->FAddProp("Submission", dwSubmission);
    pbagT = new CVarBag;
    cifOutput.PbagRoot()->FAddProp("CRC", pbagT);
    pbagT->FAddProp("Layer0CRC", tapDst0.DwCheckSum());
    pbagT->FAddProp("Layer1CRC", tapDst1.DwCheckSum());
    pbagT->FAddProp("XboxMediaCRC", xsumGrn.DwFinalSum());
    pbagT->FAddProp("XboxCRCRed", xsumRed.DwFinalSum());
    pbagT->FAddProp("XboxCRCBlack", xsumBlk.DwFinalSum());
    pbagT->FAddProp("VideoCRC", xsumDvd.DwFinalSum());

    if(!cifOutput.FWriteFile(szOutputName)) {
        fprintf(stderr, "error: could not write output file %s\n",
            szOutputName);
        exit(1);
        }

    if(ppr0) {
        MsgOut("Printing label 0\n");
        if(ppr0->FStartLabel()) {
            ppr0->PrintLine("XMID: %.*s\n", 8, rgbDMI + 6 + 8);
            ppr0->PrintLine("DLT P/N: %s-L0\n", szMediaRef);
            ppr0->PrintLine("Format: DVD-X2    Layer: 0\n");
            ppr0->PrintLine("DLT CRC: %08X\n", tapDst0.DwCheckSum());
            ppr0->PrintLine("Xbox Media CRC: %08X\n", xsumGrn.DwFinalSum());
            ppr0->PrintLine("DVD Video CRC: %08X\n", xsumDvd.DwFinalSum());
            ppr0->EndLabel();
        } else
            fprintf(stderr, "warning: could not print label 0\n");
    }

    if(ppr1) {
        MsgOut("Printing label 1\n");
        if(ppr1->FStartLabel()) {
            ppr1->PrintLine("XMID: %.*s\n", 8, rgbDMI + 6 + 8);
            ppr1->PrintLine("DLT P/N: %s-L1\n", szMediaRef);
            ppr1->PrintLine("Format: DVD-X2    Layer: 1\n");
            ppr1->PrintLine("DLT CRC: %08X\n", tapDst1.DwCheckSum());
            ppr1->PrintLine("Xbox Media CRC: %08X\n", xsumGrn.DwFinalSum());
            ppr1->PrintLine("DVD Video CRC: %08X\n", xsumDvd.DwFinalSum());
            ppr1->EndLabel();
        } else
            fprintf(stderr, "warning: could not print label 1\n");
    }

    /* Clean up the printers */
    if(ppr1 != ppr0)
        delete ppr1;
    if(ppr0)
        delete ppr0;
    ppr1 = ppr0 = NULL;

    if(fBeep)
        DoneBeep();
    return 0;
fatal:
    /* Clean up files */

    /* Destroy the signing contexts */
    if(pccRed)
        delete pccRed;
    if(pccSign)
        delete pccSign;

    /* Rewind all tapes */
    tapSrc.FRewind();
    tapDst0.FRewind();
    tapDst1.FRewind();

    /* Unmount the tapes */
    tapSrc.FUnmount();
    tapDst0.FUnmount();
    tapDst1.FUnmount();

    /* Clean up the printers */
    if(ppr1 != ppr0)
        delete ppr1;
    if(ppr0)
        delete ppr0;

    if(fBeep)
        DoneBeep();
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\other\stampid\stampid.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      stampid.cpp
// Contents:  Small utility to stamp a new titleid into an XBE file
// Revisions: 19-Sep-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#include "Precomp.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  DumpUsage
// Purpose:   Outputs usage information
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void DumpUsage()
{
    fprintf(stderr, "Microsoft (R) Xbox TITLE ID Stamp Utility "
                    VER_PRODUCTVERSION_STR "\n\n");
    fprintf(stderr, "Usage: STAMPID XBEfile TITLEID\n\n");
    fprintf(stderr, "  XBEfile          The XBE file to stamp the new ID into\n");
    fprintf(stderr, "  TITLEID          The new TITLEID to stamp into the XBE\n"
                    "                   file.  Must be of the form '%%08x'\n\n");
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ParseTITLEID
// Purpose:   Convert the specified string representation of the TITLE ID to
//            to concordant DWORD representation.  The string must be of the
//            form '%08X'.
// Arguments: szTITLEID     -- String to convert
//            pdwTITLEID    -- Location to store DWORD equivalent of string
// Return:    'false' if malformed string, 'true' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool ParseTITLEID(char *szTITLEID, DWORD *pdwTITLEID)
{
    char ch;
    
    if (!szTITLEID || strlen(szTITLEID) != 8)
        return false;

    *pdwTITLEID = 0;

    while ((ch = *szTITLEID++) != '\0')
    {
        if      (ch >= 'a' && ch <= 'f')    ch = ch - 'a' + 10;
        else if (ch >= 'A' && ch <= 'F')    ch = ch - 'A' + 10;
        else if (ch >= '0' && ch <= '9')    ch = ch - '0';
        else                                return false;
            
        *pdwTITLEID = ((*pdwTITLEID) << 4) + ch;
    }

    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  main
// Purpose:   Main entry point into the stampid utility.
// Arguments: argc      -- Number of arguments on the command line
//            argv      -- List of argument strings on command line
// Return:    Application result.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
int __cdecl main(int argc, char **argv)
{
    XBEIMAGE_CERTIFICATE cert;
    CCryptContainer      *pccSign = NULL;
    CDevkitCrypt         ccDev;
    CXBEFile             *pxbe;
    DWORD                dwOldTitleID, dwNewTitleID;
    
    // Verify command line arguments
    if (argc != 3)
    {
        DumpUsage();
        return -1;
    }

    if (!ParseTITLEID(argv[2], &dwNewTitleID))
    {
        fprintf(stderr, "Error: TITLEID must be of the form %%08X (ie 1AB4CE38).\n");
        return -1;
    }
    
    // Load the input XBE
    CDiskFile dfXBE(argv[1], GENERIC_READ);
    if(!dfXBE.FReopen(GENERIC_READ | GENERIC_WRITE))
    {
        fprintf(stderr, "Error: cannot open XBE file %s\n", argv[1]);
        return -1;
    }
    pxbe = new CXBEFile(&dfXBE);

    // Validate the input XBE
    pxbe->UseCryptContainer(&ccDev);
    if(!pxbe->FVerifySignature())
    {
        fprintf(stderr, "Error: invalid XBE file %s\n", argv[1]);
        return -1;
    }

    // Construct a new certificate
    memcpy(&cert, pxbe->GetCert(), sizeof cert);

    // Check if the user is trying to set the same title id.
    if (dwNewTitleID == cert.TitleID)
    {
        fprintf(stderr, "XBE file TITLEID is already set to %08X.\n",
                cert.TitleID);
        return -1;
    }

    // Set the TITLE ID
    dwOldTitleID = cert.TitleID;
    cert.TitleID = dwNewTitleID;

    // Set the time of the certificate update
    cert.TimeDateStamp = time(NULL);
    
    // Inject the modified certificate back into the XBE
    if(!pxbe->FInjectNewCertificate(&cert))
    {
cantsign:
        fprintf(stderr, "Error: could not sign XBE file\n");
        return -1;
    }

    // Sign the XBE
    if(!pxbe->FSignFile() || !pxbe->FVerifySignature())
        goto cantsign;

    // Commit the changes to disk
    if(!pxbe->FCommitChanges())
    {
        fprintf(stderr, "Error: Failed to write changes to XBE file\n");
        return -1;
    }

    // Output the results
    fprintf(stderr, "TITLEID successfully changed from %08X to %08X\n\n",
            dwOldTitleID, cert.TitleID);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\signing\romsign\precomp.h ===
#include <windows.h>
#include <wincrypt.h>
#include <bldr.h>
#include <crypt.h>
#include <flcrypt.h>
#include <ncipher.h>
#include <stdio.h>
#include <malloc.h>
#include <conio.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\signing\romsign\romsign.cpp ===
/*
 *
 * fsxbe.cpp
 *
 * Sign an XBE using a floppy key
 *
 */

#include "precomp.h"

CDevkitCrypt ccDev;
CCryptContainer *pccSign;
CFloppyCrypt *pfk;

class CMemFile
{
public:
    static CMemFile *PmfCreate(LPCSTR szName, BOOL fWrite,
        DWORD dwMaxCreateSize=0);
    operator unsigned char *()
    {
        return m_pb;
    }
    //unsigned char &operator[](int i) { return m_pb[i]; }
    DWORD CbSize(void) const { return m_cb; }
    void SetDeleteOnClose(BOOL f) { m_fDelete = f; }
    BOOL FClose(void);
    ~CMemFile()
    {
        if(m_pb)
            FClose();
    }

private:
    CMemFile(void) {}
    HANDLE m_hFile;
    HANDLE m_hMapping;
    PUCHAR m_pb;
    DWORD m_cb;
    LPCSTR m_szName;
    BOOL m_fDelete;
};

CMemFile *CMemFile::PmfCreate(LPCSTR szName, BOOL fWrite, DWORD dwMaxCreateSize)
{
    HANDLE hFile;
    HANDLE hMapping;
    PUCHAR pb;
    BYTE rgb[8192];
    DWORD cb;
    DWORD cbT;
    CMemFile *pmf;

    if(fWrite) {
        hFile = CreateFile(szName, GENERIC_READ | GENERIC_WRITE, 0, NULL, 
            dwMaxCreateSize ? CREATE_ALWAYS : OPEN_EXISTING, 0, NULL);
    } else {
        hFile = CreateFile(szName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0,
            NULL);
    }

    if(INVALID_HANDLE_VALUE == hFile) {
openerr:
        fprintf(stderr, "error: could not open %s\n", szName);
        return NULL;
    }

    if(dwMaxCreateSize) {
        /* First need to fill with zeroes */
        memset(rgb, 0, sizeof rgb);
        cb = dwMaxCreateSize;
        while(cb) {
            cbT = sizeof rgb;
            if(cb < cbT)
                cbT = cb;
            if(!WriteFile(hFile, rgb, cbT, &cbT, NULL)) {
                fprintf(stderr, "error: could not write to %s\n", szName);
                CloseHandle(hFile);
                return NULL;
            }
            cb -= cbT;
        }
    }

    hMapping = CreateFileMapping(hFile, NULL, fWrite ? PAGE_READWRITE :
        PAGE_READONLY, 0, dwMaxCreateSize, NULL);

    if(!hMapping) {
        CloseHandle(hFile);
        goto openerr;
    }

    pb = (PBYTE)MapViewOfFile(hMapping, fWrite ? FILE_MAP_WRITE : FILE_MAP_READ,
        0, 0, 0);

    if(!pb) {
        CloseHandle(hFile);
        CloseHandle(hMapping);
        goto openerr;
    }

    pmf = new CMemFile;
    pmf->m_hFile = hFile;
    pmf->m_hMapping = hMapping;
    pmf->m_pb = pb;
    pmf->m_cb = GetFileSize(hFile, NULL);
    pmf->m_szName = _strdup(szName);
    pmf->m_fDelete = FALSE;
    return pmf;
}

BOOL CMemFile::FClose(void)
{
    BOOL f;

    if(!m_pb)
        return TRUE;
    if(!UnmapViewOfFile(m_pb))
        fprintf(stderr, "error: could not write to %s\n", m_szName);
    else
        m_fDelete = FALSE;
    m_pb = NULL;
    CloseHandle(m_hMapping);
    CloseHandle(m_hFile);
    if(m_fDelete) {
        DeleteFile(m_szName);
        f = FALSE;
    } else
        f = TRUE;
    free((PVOID)m_szName);
    return f;
}

BOOL FComputeROMHash(CCryptContainer *pcc, PBYTE pbInitBase, PBYTE pbInitTop,
    PBYTE pbKernelBase, PBYTE pbSignature)
{
    return
        pcc->FStartProgressiveHash() &&
        pcc->FProgressiveHashData(pbSignature + 0x100, 0x80) &&
        pcc->FProgressiveHashData(pbInitBase, pbInitTop - pbInitBase) &&
        pcc->FProgressiveHashData(pbKernelBase, pbSignature - pbKernelBase);
};

BOOL FSignROM(LPCSTR szIn, LPCSTR szOut)
{
    CMemFile *pmfIn, *pmfOut;
    PBYTE pbNewBase;
    PBYTE pbInitBase;
    PBYTE pbInitTop;
    PBYTE pbKernelBase;
    PBYTE pbSignature;
    PDWORD pbRomSizes;
    DWORD dwRomBase;
    DWORD dwRomSize;
    int cCopies;

    if(0 == strcmp(szOut, "."))
        szOut = NULL;

    /* Map in the input ROM */
    pmfIn = CMemFile::PmfCreate(szIn, szOut == NULL);
    if(!pmfIn) {
        fprintf(stderr, "error: cannot open ROM file %s\n", szIn);
        return FALSE;
    }

    /* We can't do much validation on this ROM, so we'll just make sure the
     * sizes look reasonable and that it's correctly signed */
    pbRomSizes = (PULONG)(*pmfIn + pmfIn->CbSize() - ROM_DEC_SIZE - 0x80);
    dwRomBase = pbRomSizes[0];
    /* Ensure we're 256k aligned */
    if(dwRomBase & 0x3FFFF) {
badrom:
        fprintf(stderr, "error: invalid ROM file %s\n", szIn);
        delete pmfIn;
        return FALSE;
    }

    /* Ensure that we have an integral number of copies of this ROM */
    dwRomSize = (DWORD)-(int)dwRomBase;
    cCopies = pmfIn->CbSize() / dwRomSize;
    if(cCopies * dwRomSize != pmfIn->CbSize())
        goto badrom;

    /* Find the top of the inittbl, the base of the kernel, and the signature,
     * and make sure they're all in reasonable places */
    pbInitBase = &(*pmfIn)[pmfIn->CbSize() - dwRomSize];
    pbInitTop = pbInitBase + pbRomSizes[1];
    pbKernelBase = pbInitBase + (pbRomSizes[2] - dwRomBase);
    pbSignature = pbInitBase + (dwRomSize - ROM_DEC_SIZE - 0x180);

    if(pbInitTop < pbInitBase || pbKernelBase < pbInitTop || pbSignature <
            pbKernelBase)
        goto badrom;

    /* Hash the data to verify the signature */
    if(!FComputeROMHash(&ccDev, pbInitBase, pbInitTop, pbKernelBase,
            pbSignature))
        goto badrom;
    if(!ccDev.FVerifyEncryptedProgressiveHash(pbSignature))
        goto badrom;

    /* Now map in the output ROM */
    if(szOut) {
        pmfOut = CMemFile::PmfCreate(szOut, TRUE, dwRomSize * cCopies);
        if(!pmfOut)
            goto cantwrite;
        pmfOut->SetDeleteOnClose(TRUE);
        pbNewBase = &(*pmfOut)[dwRomSize * (cCopies - 1)];
        memcpy(pbNewBase, pbInitBase, dwRomSize);
        pbInitTop = &pbNewBase[pbInitTop - pbInitBase];
        pbKernelBase = &pbNewBase[pbKernelBase - pbInitBase];
        pbSignature = &pbNewBase[pbSignature - pbInitBase];
        pbInitBase = pbNewBase;
    } else {
        szOut = szIn;
        pmfOut = pmfIn;
    }

    /* We're going to need to ensure that the init table we see at runtime is
     * the same one that the romdec parsed, so we'll change its address */
    *(PULONG)(pbSignature + 0x100) = 0xFFF00000;

    /* Sign the ROM */
    if(!FComputeROMHash(pccSign, pbInitBase, pbInitTop, pbKernelBase,
        pbSignature))
    {
writeerr:
        delete pmfOut;
cantwrite:
        fprintf(stderr, "error: could not write to %s\n", szOut);
        delete pmfIn;
        return FALSE;
    }
    if(!pccSign->FEncryptProgressiveHash(pbSignature))
        goto writeerr;

    if(pmfOut != pmfIn) {
        /* We need to replicate the signed ROM */
        while(--cCopies) {
            pbInitBase -= dwRomSize;
            memcpy(pbInitBase, pbNewBase, dwRomSize);
        }
    } else {
        /* We need to replicate the signature */
        pbInitBase = pbSignature;
        while(--cCopies) {
            pbSignature -= dwRomSize;
            memcpy(pbSignature, pbInitBase, 0x100);
        }
    }

    /* Write out the final bits */
    if(!pmfOut->FClose())
        goto cantwrite;

    /* Now we're done! */
    if(pmfOut != pmfIn)
        delete pmfOut;
    delete pmfIn;
    return TRUE;
}

int __cdecl main(int argc, char **argv)
{
    LPCSTR szOut;
    char szLine[1024];
    char szXbeIn[512];
    char szXbeOut[512];
    char szID[512];
    FILE *pfl;
    BOOL f = FALSE;

    while(argc >= 2 && argv[1][0] == '-') {
        if(0 == _stricmp(argv[1], "-nc")) {
            if(argc < 4) {
                fprintf(stderr, "-nc option requires provider and container\n");
                return 1;
            }
            pccSign = CNCipherCrypt::PccCreate(argv[2], argv[3]);
            if(!pccSign) {
                fprintf(stderr, "error: could not acquire nCipher context\n");
                return 1;
            }
            argv += 3;
            argc -= 3;
        } else if(0 == _stricmp(argv[1], "-redkey")) {
            pccSign = new CDevkitCrypt;
            ++argv;
            --argc;
        }
    }

    if(argc < 2) {
usage:
        fprintf(stderr, "usage: romsign input-file output-file\n"
            "\tor romsign @filelist\n");
        goto fatal;
    }

    if(argv[1][0] == '@') {
        pfl = fopen(&argv[1][1], "r");
        if(!pfl) {
            fprintf(stderr, "error: could not open input file %s\n",
                &argv[1][1]);
            goto fatal;
        }
    } else if(argc < 3)
        goto usage;
    else
        pfl = NULL;

    if(!pccSign) {
        /* Acquire the crypt context */
#if 0
        pfk = CFloppyCrypt::PccCreate(TRUE);
        if(!pfk)
#endif
            pfk = CFloppyCrypt::PccCreate();
        if(!pfk) {
            fprintf(stderr, "Unable to acquire signing keys\n");
            return 1;
        }
        pccSign = pfk;
    }

    if(pfl) {
        f = TRUE;
        while(fgets(szLine, sizeof szLine, pfl)) {
            if(sscanf(szLine, "%s %s", szXbeIn, szXbeOut) < 2)
                fprintf(stderr, "warning: unable to parse: %s\n", szLine);
            else if(*szXbeIn != '#') {
                fprintf(stderr, "from %s to %s\n", szXbeIn, szXbeOut);
                if(!FSignROM(szXbeIn, szXbeOut)) {
                    fprintf(stderr, "..FAILED!\n");
                    f = FALSE;
                } else
                    fprintf(stderr, "..Succeeded!\n");
            }
        }
    } else
        f = FSignROM(argv[1], argv[2]);

fatal:
    if(pfk != pccSign)
        delete pfk;
    if(pccSign)
        delete pccSign;

    return !f;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\signing\signcode\precomp.h ===
#include <windows.h>
#include <wincrypt.h>
#include <xsum.h>
#include <filestm.h>
#include <xbefile.h>
#include <ncipher.h>
#include <stdio.h>
#include <time.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\signing\sip\precomp.h ===
#include <windows.h>
#include <wincrypt.h>
#include <mssip.h>
#include <xsum.h>
#include <filestm.h>
#include <xbefile.h>
#include <ncipher.h>
#include <time.h>

extern HINSTANCE g_hinstCrypt;

class CFunctestCrypt : public CSimpleCrypt
{
public:
    CFunctestCrypt(void) : CSimpleCrypt(rgbPublicKey, rgbPrivateKey) {}
private:
    static const BYTE rgbPrivateKey[];
    static const BYTE rgbPublicKey[];
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\signing\redgrn\redgrn.cpp ===
/*
 *
 * redgrn.cpp
 *
 * Red to Green signing tool
 *
 */

#include "precomp.h"

const char *rgszRSMKeys[] = { "Layer0CRC", "Layer1CRC", "XboxMediaCRC" };
LPCSTR szTempPath;
CTapeDevice tapSrc0, tapSrc1;
CTapeDevice tapDst0, tapDst1;
CDX2MLFile xml0, xml1;
CCryptContainer *pccRed, *pccGrn;
CCheckSum xsumBlk, xsumRed, xsumGrn, xsumMediaIn;
CCheckSum xsumDvd;
CIniBag *pbagInput;
BYTE rgbXControl[2054];
BYTE rgbDMIIn[2054];
BYTE rgbDMIOut[2054];
BYTE rgbControl[2048];
const char szCRC[] = "CRC";
const char szDMI[] = "Disk Manufacturing Information";
const char szXBE[] = "XBE Information";
XBEIMAGE_CERTIFICATE certKeys;

void MsgOut(LPCSTR szFormat, ...)
{
    va_list va;
    va_start(va, szFormat);
    vprintf(szFormat, va);
    va_end(va);
}

void DoneBeep(void)
{
    int i;

    _cputs("Press any key . . .");
    for(i = 0; !_kbhit(); ++i) {
        if(!(i & 0xF)) {
            _putch(7);
            MessageBeep(-1);
        } else
            Sleep(100);
    }
    _getch();
    _putch(13);
    _putch(10);
}

BOOL FMountTape(CTapeDevice *ptap, LPCSTR szName, BOOL fTOD, BOOL fWrite)
{
    HANDLE h;

    if(!szName)
        return FALSE;
    if(0 == strncmp(szName, "\\\\?", 3) || 0 == strncmp(szName, "\\\\.", 3))
        /* Tape device */
        return ptap->FMount(szName, fWrite);
    if(fWrite)
        h = CreateFile(szName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0,
            NULL);
    else
        h = CreateFile(szName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0,
            NULL);
    if(h == INVALID_HANDLE_VALUE)
        return FALSE;
    return ptap->FMount(h, fWrite);
}

CDiskFile *PstmCreateTemp(LPCSTR szName, DWORD dwFlags)
{
    char szFullName[MAX_PATH + 1];
    CDiskFile *pstm;

    if(!szTempPath)
        return NULL;

    sprintf(szFullName, "%s\\%s", szTempPath, szName);
    pstm = new CDiskFile(szFullName, dwFlags);
    if(!pstm->FIsOpen()) {
        delete pstm;
        pstm = NULL;
    } else
        pstm->SetDeleteOnClose(TRUE);
    return pstm;
}

BOOL FCopyXMLFiles(LPCSTR szMediaRef)
{
    CDiskFile *pstmXML0 = NULL, *pstmXML1 = NULL;
    CDiskFile *pstmXDR = NULL;
    DXML *pdxml;
    HRSRC hres;
    LPBYTE pb;
    DWORD cbRes;
    DWORD dwDataBlkSize;
    DWORD dwDataPerPhy;
    BOOL fRet = FALSE;
    char szFileName[32];
    char szLayerRef[256];

    /* Get disk space for the files */
    pstmXDR = PstmCreateTemp("dx2ml.xdr", GENERIC_WRITE);
    pstmXML0 = PstmCreateTemp("dx2ml0.xml", GENERIC_WRITE);
    pstmXML1 = PstmCreateTemp("dx2ml1.xml", GENERIC_WRITE);
    if(!pstmXDR || !pstmXML0|| !pstmXML1) {
notemp:
        fprintf(stderr, "error: cannot create temporary XML files\n");
        goto fatal;
    }

    /* Extract the XDR file */
    MsgOut("Preparing XDR file\n");
    hres = FindResource(GetModuleHandle(NULL), MAKEINTRESOURCE(1), "FILE");
    if(!hres)
        goto notemp;
    pb = (PBYTE)LockResource(LoadResource(GetModuleHandle(NULL), hres));
    if(!pb)
        goto notemp;
    cbRes = SizeofResource(GetModuleHandle(NULL), hres);
    if(pstmXDR->CbWrite(cbRes, pb) != cbRes)
        goto notemp;
    if(!pstmXDR->FReopen(GENERIC_READ))
        goto notemp;

    MsgOut("Reading DX2ML file from tape 0\n");
    if(!tapSrc0.FReadFile(szFileName, &dwDataBlkSize, &dwDataPerPhy) ||
        strcmp(szFileName, "DX2ML.XML"))
    {
        fprintf(stderr, "error: source tape 0 missing XML file\n");
        goto fatal;
    }
    if(!tapSrc0.FCopyToStm(pstmXML0) || !tapSrc0.FCloseFile()) {
        fprintf(stderr, "error: could not copy XML file from source tape 0\n");
        goto fatal;
    }
    MsgOut("Reading DX2ML file from tape 1\n");
    if(!tapSrc1.FReadFile(szFileName, &dwDataBlkSize, &dwDataPerPhy) ||
        strcmp(szFileName, "DX2ML.XML"))
    {
        fprintf(stderr, "error: source tape 0 missing XML file\n");
        goto fatal;
    }
    if(!tapSrc1.FCopyToStm(pstmXML1) || !tapSrc1.FCloseFile()) {
        fprintf(stderr, "error: could not copy XML file from source tape 1\n");
        goto fatal;
    }
    if(!pstmXML0->FReopen(GENERIC_READ))
        goto bad0;
    if(!pstmXML1->FReopen(GENERIC_READ))
        goto bad1;

    MsgOut("Validating XML files\n");
    /* Process the two DX2ML files */
    if(!xml0.FReadFile(pstmXML0->SzName(), TRUE)) {
bad0:
        fprintf(stderr, "error: could not process DX2ML from tape 0\n");
        goto fatal;
    }
    if(!xml1.FReadFile(pstmXML1->SzName(), TRUE)) {
bad1:
        fprintf(stderr, "error: could not process DX2ML from tape 1\n");
        goto fatal;
    }

    /* validate the XML files */
    if(!xml0.FValidateContent() || xml0.PdxmlGet()->iLayer != 0)
        goto bad0;
    if(!xml1.FValidateContent() || xml1.PdxmlGet()->iLayer != 1)
        goto bad1;
    if(!xml0.FValidatePlaceholderLocations(FALSE, TRUE, FALSE)) {
        fprintf(stderr, "error: DX2ML placeholder data is invalid\n");
        goto fatal;
    }

    /* Strip the previous mastering refs */
    xml0.SetMasteringRef(NULL);
    xml1.SetMasteringRef(NULL);

    /* Make sure they match */
    if(xml0 != xml1) {
        fprintf(stderr, "error: XML files on the two tapes do not match\n");
        goto fatal;
    }

    /* Update the mastering refs */
    sprintf(szLayerRef, "%s-L0", szMediaRef);
    xml0.SetMasteringRef(szMediaRef);
    sprintf(szLayerRef, "%s-L1", szMediaRef);
    xml1.SetMasteringRef(szMediaRef);

    /* Write out the two DX2ML files */
    MsgOut("Writing DX2ML file to tape 0\n");
    if(!tapDst0.FWriteFile("dx2ml.xml", 32768, 1) ||
        !xml0.FWriteFile(&tapDst0) || !tapDst0.FCloseFile())
    {
        fprintf(stderr, "error: could not write DX2ML to tape 0\n");
        goto fatal;
    }
    MsgOut("Writing DX2ML file to tape 1\n");
    if(!tapDst1.FWriteFile("dx2ml.xml", 32768, 1) ||
        !xml1.FWriteFile(&tapDst1) || !tapDst1.FCloseFile())
    {
        fprintf(stderr, "error: could not write DX2ML to tape 1\n");
        goto fatal;
    }
    fRet = TRUE;
fatal:
    if(pstmXML0)
        delete pstmXML0;
    if(pstmXML1)
        delete pstmXML1;
    if(pstmXDR)
        delete pstmXDR;
    return fRet;
}

BOOL FProcessXControl(int ilyr, DXML *pxml, CTapeDevice *ptapSrc,
    CTapeDevice *ptapDst)
{
    int i;
    int ib;
    BYTE b;
    BYTE rgb[2054];
    DWORD dw;
    CXControl xct;
    FILETIME ft;

    MsgOut("Processing XCONTROL.DAT on tape %d\n", ilyr);
    /* First make sure that we have 30 blocks of zero */
    for(i = 0; i < 30; ++i) {
        if(ptapSrc->CbRead(sizeof rgb, rgb) != sizeof rgb) {
readerr:
            fprintf(stderr, "error: could not read XControl from tape %d\n", ilyr);
            return FALSE;
        }
        for(b = 0, ib = 0; ib < sizeof rgb; ++ib)
            b |= rgb[ib];
        if(b) {
baddata:
            fprintf(stderr, "error: invalid XControl data on tape %d\n", ilyr);
            return FALSE;
        }
        if(ptapDst->CbWrite(sizeof rgb, rgb) != sizeof rgb) {
writeerr:
            fprintf(stderr, "error: could not write XControl on tape %d\n", ilyr);
            return FALSE;
        }
    }

    /* Now read the XControl frame.  If we're on layer 0, we just read it.
     * If we're on layer 1, we need to make sure it matches what was on
     * layer 0 */
    if(ilyr == 0) {
        if(ptapSrc->CbRead(sizeof rgbXControl, rgbXControl) !=
                sizeof rgbXControl)
            goto readerr;
    } else {
        if(ptapSrc->CbRead(sizeof rgb, rgb) != sizeof rgb)
            goto readerr;
        if(memcmp(rgb, rgbXControl, sizeof rgb))
            goto baddata;
    }

    /* Read the DMI frame */
    if(ptapSrc->CbRead(sizeof rgb, rgb) != sizeof rgb)
        goto readerr;

    /* Make sure the DMI frame matches the expected DMI */
    if(memcmp(rgb, rgbDMIIn, sizeof rgb))
        goto baddata;

    /* There should be no more data in the file */
    if(ptapSrc->CbRead(sizeof dw, (PBYTE)&dw) != 0)
        goto baddata;

    /* Stamp the XControl and write it */
    memcpy(rgb, rgbXControl, sizeof rgb);
    if(!xct.FInit(rgb, sizeof rgb) || !xct.FValidate(pxml, pccRed))
        goto baddata;
    if(!xct.FSign(pccGrn))
        goto writeerr;
    if(!xct.FWriteToStm(ptapDst, sizeof rgb))
        goto writeerr;

    /* Write out the DMI */
    if(ptapDst->CbWrite(sizeof rgbDMIOut, rgbDMIOut) != sizeof rgbDMIOut)
        goto writeerr;

    return TRUE;
}

BOOL FProcessControl(int ilyr, DXML *pxml, CTapeDevice *ptapSrc,
    CTapeDevice *ptapDst)
{
    int i;
    int ib;
    BYTE b;
    BYTE rgb[2048];
    CECMAControl ect;
    DWORD dw;

    MsgOut("Processing CONTROL.DAT on tape %d\n", ilyr);
    /* Now read the Control frame.  If we're on layer 0, we just read it.
     * If we're on layer 1, we need to make sure it matches what was on
     * layer 0 */
    if(ilyr == 0) {
        if(ptapSrc->CbRead(sizeof rgbControl, rgbControl) !=
            sizeof rgbControl)
        {
readerr:
            fprintf(stderr, "error: could not read Control from tape %d\n", ilyr);
            return FALSE;
        }
    } else {
        if(ptapSrc->CbRead(sizeof rgb, rgb) != sizeof rgb)
            goto readerr;
        if(memcmp(rgb, rgbControl, sizeof rgb)) {
baddata:
            fprintf(stderr, "error: Invalid Control data on tape %d\n", ilyr);
            return FALSE;
        }
    }

    /* Validate the control data */
    if(!ect.FInit(rgbControl) || !ect.FValidate(pxml))
        goto baddata;

    /* Write out the control data we've got */
    if(ptapDst->CbWrite(sizeof rgbControl, rgbControl) != sizeof rgbControl) {
writeerr:
        fprintf(stderr, "error: could not write Control on tape %d\n", ilyr);
        return FALSE;
    }

    /* Now read the DMI and validate it against what we expect */
    if(ptapSrc->CbRead(sizeof rgb, rgb) != sizeof rgb)
        goto readerr;
    if(memcmp(rgb, rgbDMIIn + 6, sizeof rgb))
        goto baddata;

    /* Write out the DMI */
    if(ptapDst->CbWrite(sizeof rgb, rgbDMIOut + 6) != sizeof rgb)
        goto writeerr;

    /* Now make sure that we have 14 blocks of zero */
    for(i = 0; i < 14; ++i) {
        if(ptapSrc->CbRead(sizeof rgb, rgb) != sizeof rgb)
            goto readerr;
        for(b = 0, ib = 0; ib < sizeof rgb; ++ib)
            b |= rgb[ib];
        if(b)
            goto baddata;
        if(ptapDst->CbWrite(sizeof rgb, rgb) != sizeof rgb)
            goto writeerr;
    }

    /* There should be no more data in the file */
    if(ptapSrc->CbRead(sizeof dw, (PBYTE)&dw) != 0)
        goto baddata;

    return TRUE;
}

BOOL FGreensignXBE(int ilyr, CXBEFile *pxbe, DWORD cblk, CTapeDevice *ptapDst)
{
    XBEIMAGE_CERTIFICATE certNew;
    const XBEIMAGE_CERTIFICATE *pcert;

    MsgOut("Processing XBE file\n");
    pxbe->UseCryptContainer(pccRed);
    if(!pxbe->FVerifySignature()) {
badxbe:
        fprintf(stderr, "error: found an invalid XBE file on tape %d\n", ilyr);
        return FALSE;
    }
    
    /* Make sure the certificate matches the data we expect */
    pcert = pxbe->GetCert();
    if(pcert->TitleID != certKeys.TitleID || pcert->Version != certKeys.Version)
        goto badxbe;
    
    /* Copy the certificate keys into the certificate */
    memcpy(&certNew, pcert, sizeof certNew);
    memcpy(certNew.SignatureKey, certKeys.SignatureKey,
        sizeof certKeys.SignatureKey);
    memcpy(certNew.LANKey, certKeys.LANKey, sizeof certKeys.LANKey);
    if(!pxbe->FInjectNewCertificate(&certNew)) {
        fprintf(stderr, "error: could not inject XBE certificate keys on tape %d\n",
            ilyr);
        return FALSE;
    }

    /* Sign and save */
    pxbe->UseCryptContainer(pccGrn);
    if(!pxbe->FSignFile()) {
        fprintf(stderr, "error: unable to sign XBE file\n");
        return FALSE;
    }
    if(!pxbe->FWriteToStm(ptapDst, cblk * 2048)) {
        fprintf(stderr, "error: writing destination tape %d\n", ilyr);
        return FALSE;
    }
    if(!pxbe->FCalcChecksums(&xsumBlk, &xsumRed, &xsumGrn)) {
        fprintf(stderr, "error: reading temporary XBE file\n");
        return FALSE;
    }
    return TRUE;
}

struct {
    int ilyr;
    int idxi;
    int idxr;
} rgfdFileOrder[] = {
    { 0, idxiControl },
    { 0, idxiXControl },
    { 0, -1, idxrData },
    { 0, -1, idxrXData },
    { 1, idxiControl },
    { 1, idxiXControl },
    { 1, -1, idxrXData },
    { 1, -1, idxrData },
    { -1 }
}, *pfd = rgfdFileOrder;

BOOL FGreensignTape(int ilyr, CTapeDevice *ptapSrc, CTapeDevice *ptapDst)
{
    DWORD dwBlkSize;
    DWORD dwDataPerPhy;
    char szFilename[32];
    int idxi, idxr;
    DXML *pdxml = (ilyr ? &xml0 : &xml1)->PdxmlGet();
    DXI *pdxi;
    DXR *pdxr;

    MsgOut("Processing tape %d\n", ilyr);
    /* We'll read only as many files as we expect from this tape; we'll
     * silently discard the rest */
    while(pfd->ilyr == ilyr && ptapSrc->FReadFile(szFilename, &dwBlkSize,
        &dwDataPerPhy))
    {
        /* Find out which file this is */
        for(idxi = 0; idxi < idxiMax; ++idxi) {
            if(0 == strcmp(pdxml->rgdxi[idxi].szNameOnTape, szFilename))
                break;
        }
        if(idxi == idxiMax) {
unkfile:
            /* Unrecognized file, fatal error */
            fprintf(stderr, "error: unknown file %s on tape %d\n", szFilename, ilyr);
            return FALSE;
        }
        pdxi = &pdxml->rgdxi[idxi];

        /* Make sure this file is of the right format */
        if(dwDataPerPhy != 16 || dwBlkSize != (pdxi->f2054 ? 2054U : 2048U)) {
            fprintf(stderr, "error: file %s on tape %d is of the wrong format\n",
                szFilename, ilyr);
            return FALSE;
        }

        /* Figure out which disc region this file corresponds to */
        for(idxr = 0; idxr < idxrMax; ++idxr) {
            if(pdxml->rgdxl[ilyr].rgdxrAreas[idxr].idxiImage == idxi)
                break;
        }

        /* Now what we know what file we're looking at, make sure it comes in
         * the sequence we expect */
        if(ilyr != pfd->ilyr) {
badorder:
            fprintf(stderr, "error: file %s on tape %d comes out of order\n");
            return FALSE;
        }
        if(pfd->idxi >= 0) {
            if(idxi != pfd->idxi)
                goto badorder;
        } else if(idxr != pfd->idxr)
            goto badorder;
        ++pfd;

        /* Set up the destination tape for writing */
        if(!ptapDst->FWriteFile(szFilename, dwBlkSize, dwDataPerPhy)) {
writeerr:
            fprintf(stderr, "error: writing destination tape %d\n", ilyr);
            return FALSE;
        }

        /* Process this file as appropriate */
        switch(idxi) {
        case idxiXControl:
            if(idxr != (ilyr ? idxrLead : idxrMax))
                goto unkfile;
            if(!FProcessXControl(ilyr, pdxml, ptapSrc, ptapDst))
                return FALSE;
            break;
        case idxiControl:
            if(idxr != (ilyr ? idxrMax : idxrLead))
                goto unkfile;
            if(!FProcessControl(ilyr, pdxml, ptapSrc, ptapDst))
                return FALSE;
            break;
        default:
            if(idxr == idxrXData) {
                /* This is an ximage file, so we need to process it */
                if(!FProcessXImage(ilyr, &pdxml->rgdxl[ilyr], idxr, ptapSrc,
                        ptapDst, FGreensignXBE))
                    return FALSE;
            } else if(idxr == idxrData) {
                /* Just copy the file */
                MsgOut("Coping DVD video\n");
                if(!ptapSrc->FCopyToStm(ptapDst, &xsumDvd)) {
                    fprintf(stderr, "error: could not copy file %s on tape %d\n",
                        szFilename, ilyr);
                    return FALSE;
                }
            } else
                goto unkfile;
            break;
        }
        if(!ptapSrc->FCloseFile()) {
            fprintf(stderr, "error: read error on tape %d\n", ilyr);
            return FALSE;
        }
        if(!ptapDst->FCloseFile())
            goto writeerr;
    }

    if(pfd->ilyr == ilyr) {
        fprintf(stderr, "error: files missing from tape %d\n", ilyr);
        return FALSE;
    }
    return TRUE;
}

BOOL FGetAsDword(CIniBag *pbag, LPCSTR szSection, LPCSTR szKey, PDWORD pdw)
{
    CVarBag *pbvp = pbag->FindProp(szSection);
    if(!pbvp)
        return FALSE;
    return pbvp->FFindDwProp(szKey, pdw);
}

#if 0
void AddAsDword(CStringBag *pbag, LPCSTR szKey, DWORD dw)
{
    char sz[16];
    sprintf(sz, "0x%08X", dw);
    pbag->FAddProp(szKey, sz);
}
#endif

int __cdecl main(int cArg, char **rgszArg)
{
    LPCSTR szInputName = "xbvalidate.ini";
    LPCSTR szOutputName = "output.ini";
    BOOL fBeep = FALSE;
    BOOL fTOD = FALSE;
    CIniFile cifInput;
    CIniFile cifOutput;
    CLabelPrinter *ppr0 = NULL;
    CLabelPrinter *ppr1 = NULL;
    CDiskFile *pstmT;
    CVarBag *pbagMCR;
    CVarBag *pbagT;
    CFloppyCrypt *pfk = NULL;
    HKEY hkey;
    int i;
    DWORD dwXsumBlk, dwXsumRed, dwXsumMediaIn;
    DWORD dwXsumSrc0, dwXsumSrc1;
    DWORD dwXsumDvd;
    FILETIME ftSign;
    DWORD dwOff;
    VPR *pvp;
    LPCSTR szT;
    LPCSTR szSignKey = NULL;
    char szMediaRef[256];
    struct {
        LPCSTR szSection;
        LPCSTR szKey;
        PDWORD pdw;
    } rginpf[] = {
        { szCRC, "Layer0CRC", &dwXsumSrc0 },
        { szCRC, "Layer1CRC", &dwXsumSrc1 },
        { szCRC, "XboxCRCRed", &dwXsumRed },
        { szCRC, "XboxCRCBlack", &dwXsumBlk },
        { szCRC, "XboxMediaCRC", &dwXsumMediaIn },
        { szCRC, "VideoCRC", &dwXsumDvd },
        { szDMI, "TimeStampHigh", &ftSign.dwHighDateTime },
        { szDMI, "TimeStampLow", &ftSign.dwLowDateTime },
        { szXBE, "TitleID", &certKeys.TitleID },
        { szXBE, "Version", &certKeys.Version },
    };

    /* Initial setup */
    while(++rgszArg, --cArg) {
        if(_stricmp(*rgszArg, "-input") == 0) {
            if(!--cArg) {
noarg:
                fprintf(stderr, "error: missing argument for %s\n", *rgszArg);
                exit(1);
            }
            szInputName = *++rgszArg;
        } else if(_stricmp(*rgszArg, "-output") == 0) {
            if(!--cArg)
                goto noarg;
            szOutputName = *++rgszArg;
        } else if(_stricmp(*rgszArg, "-beep") == 0) {
            ++fBeep;
        } else if(_stricmp(*rgszArg, "-tod") == 0) {
            ++fTOD;
        } else if(_stricmp(*rgszArg, "-fksign") == 0) {
            /* We're going to be signing with a floppy key, so grab the
             * signing name */
            if(!--cArg || rgszArg[1][0] == '-')
                goto noarg;
            szSignKey = *++rgszArg;
        } else {
            fprintf(stderr, "error: unknown argument %s\n", *rgszArg);
            exit(1);
        }
    }

    if(ERROR_SUCCESS != RegOpenKey(HKEY_CURRENT_USER,
        "Software\\Microsoft\\Xbox Game Signing Tool\\Red2GreenDLT", &hkey) ||
        !(pbagMCR = PbagFromRegKey(hkey)))
    {
        fprintf(stderr, "error: could not read machine configuration registry\n");
        exit(1);
    }

    /* Make sure we can read our input file */
    if(!cifInput.FReadFile(szInputName, TRUE)) {
        fprintf(stderr, "error: could not process input file %s\n",
            szInputName);
        exit(1);
    }
    pbagInput = cifInput.PbagRoot();

    /* Extract the appropriate values from the input file */
    for(i = sizeof rginpf / sizeof rginpf[0]; i--; ) {
        if(!FGetAsDword(pbagInput, rginpf[i].szSection, rginpf[i].szKey,
            rginpf[i].pdw))
        {
badinput:
            fprintf(stderr, "error: missing or incorrect data in input file\n");
            exit(1);
        }
    }

    /* Construct the input and output DMI blocks */
    pbagT = pbagInput->FindProp(szDMI);
    if(!pbagT)
        goto badinput;
    pvp = pbagT->FindProp("XMID");
    if(!pvp || pvp->vpType != vpSz || strlen(pvp->sz) != 8)
        goto badinput;
    rgbDMIIn[6] = 1;
    memcpy(rgbDMIIn + 6 + 8, pvp->sz, 8);
    memcpy(rgbDMIIn + 6 + 16, &ftSign, sizeof ftSign);
    rgbDMIIn[6 + 24] = 1;
    memcpy(rgbDMIOut, rgbDMIIn, sizeof rgbDMIIn);
    GetSystemTimeAsFileTime(&ftSign);
    memcpy(rgbDMIOut + 6 + 16, &ftSign, sizeof ftSign);
    rgbDMIOut[6 + 24] = 2;
    sprintf(szMediaRef, "%.8s", rgbDMIIn + 6 + 8);

    /* Make sure we have a place to stick temporary data */
    szTempPath = pbagMCR->FindSzProp("TemporaryPath");
    pstmT = PstmCreateTemp("test.tst", GENERIC_WRITE);
    if(!pstmT) {
        fprintf(stderr, "error: cannot create temporary files\n");
        exit(1);
    }
    delete pstmT;
    pstmT = NULL;

    /* Make sure we can get our signing keys */
    pccRed = new CDevkitCrypt;
    if(szSignKey) {
        pfk = CFloppyCrypt::PccCreate();
        pccGrn = pfk;
    } else
        pccGrn = CNCipherCrypt::PccCreate(pbagMCR->FindSzProp("MSCSPProvider"),
            pbagMCR->FindSzProp("MSCSPKeyContainer"));
    if(!pccRed || !pccGrn) {
        fprintf(stderr, "error: unable to acquire cryptographic contexts\n");
        exit(1);
    }

    /* Configure the label printers */
    szT = pbagMCR->FindSzProp("LabelPrinter0");
    if(szT) {
        MsgOut("Configuring label printers\n");
        if(!pbagMCR->FFindDwProp("PrinterOffset0", &dwOff))
            dwOff = 0;
        ppr0 = CLabelPrinter::PprCreate(szT, -(int)dwOff);
        if(!ppr0) {
            fprintf(stderr, "error: could not configure label printer 0\n");
            goto fatal;
        }
        szT = pbagMCR->FindSzProp("LabelPrinter1");
        if(szT) {
            if(!pbagMCR->FFindDwProp("PrinterOffset1", &dwOff))
                dwOff = 0;
            ppr1 = CLabelPrinter::PprCreate(szT, -(int)dwOff);
            if(!ppr1) {
                fprintf(stderr, "error: could not configure label printer 1\n");
                goto fatal;
            }
        } else
            ppr1 = ppr0;
    }

    /* Set up the certificate keys.  We need lots of entropy here, so we fill
     * in the LAN key with some entropic data and use that */
    g_rand.RandBytes(certKeys.LANKey, 8);
    ((DWORD *)certKeys.LANKey)[2] = dwXsumSrc0;
    ((DWORD *)certKeys.LANKey)[3] = dwXsumSrc1;
    if(!CXBEFile::FGenNewKeys(&certKeys, pccGrn, certKeys.LANKey, 16)) {
        fprintf(stderr, "error: could not generate XBE keys\n");
        exit(1);
    }
    if(szSignKey) {
        /* We're going to use the input string as the LAN key */
        memset(certKeys.LANKey, 0, sizeof certKeys.LANKey - 4);
        strncpy((LPSTR)certKeys.LANKey, szSignKey, sizeof certKeys.LANKey - 4);
        /* And we're going to use the key ID as the signature key */
        memset(certKeys.SignatureKey, 0, sizeof certKeys.SignatureKey - 4);
        pfk->FGetKeyId(certKeys.SignatureKey - 4);
    }

    /* Mount the source tapes */
    MsgOut("Mounting source tape 0\n");
    if(!FMountTape(&tapSrc0, pbagMCR->FindSzProp("SourceTape0"), fTOD, FALSE)) {
        fprintf(stderr, "error: could not mount source tape 0\n");
        exit(1);
    }
    MsgOut("Mounting source tape 1\n");
    if(!FMountTape(&tapSrc1, pbagMCR->FindSzProp("SourceTape1"), fTOD, FALSE)) {
        fprintf(stderr, "error: could not mount source tape 1\n");
        exit(1);
    }

    /* Mount the destination tapes */
    MsgOut("Mounting destination tape 0\n");
    if(!FMountTape(&tapDst0, pbagMCR->FindSzProp("DestinationTape0"), fTOD,
        TRUE))
    {
        fprintf(stderr, "error: could not mount destination tape 0\n");
        exit(1);
    }
    MsgOut("Mounting destination tape 1\n");
    if(!FMountTape(&tapDst1, pbagMCR->FindSzProp("DestinationTape1"), fTOD,
        TRUE))
    {
        fprintf(stderr, "error: could not mount destination tape 1\n");
        exit(1);
    }
    tapDst0.SetWritePadByte('\n');
    tapDst1.SetWritePadByte('\n');

    /* The first file on each source tape must be the DX2ML file.  Deal with
     * them first */
    if(!FCopyXMLFiles(szMediaRef))
        goto fatal;

    /* Cycle through the contents of each tape */
    if(!FGreensignTape(0, &tapSrc0, &tapDst0))
        goto fatal;
    if(!FGreensignTape(1, &tapSrc1, &tapDst1))
        goto fatal;

    /* Make sure the input CRCs matched */
    if(tapSrc0.DwCheckSum() != dwXsumSrc0 ||
        tapSrc1.DwCheckSum() != dwXsumSrc1 ||
        xsumMediaIn.DwFinalSum() != dwXsumMediaIn ||
        xsumBlk.DwFinalSum() != dwXsumBlk ||
        xsumRed.DwFinalSum() != dwXsumRed ||
        xsumDvd.DwFinalSum() != dwXsumDvd)
    {
        fprintf(stderr, "error: input data has incorrect checksum\n");
        goto fatal;
    }

    /* Destroy the signing contexts */
    delete pccRed;
    pccRed = NULL;
    delete pccGrn;
    pccGrn = NULL;

    /* Unmount the tapes */
    MsgOut("Unounting source tape 0\n");
    tapSrc0.FUnmount();
    MsgOut("Unounting source tape 1\n");
    tapSrc1.FUnmount();
    MsgOut("Unounting destination tape 0\n");
    if(!tapDst0.FUnmount()) {
        fprintf(stderr, "error: unmounting destination tape 0\n");
        goto fatal;
    }
    MsgOut("Unounting destination tape 1\n");
    if(!tapDst1.FUnmount()) {
        fprintf(stderr, "error: unmounting destination tape 1\n");
        goto fatal;
    }

    /* Output CRC values */
    MsgOut("Writing output data\n");
    pbagT = new CVarBag;
    cifOutput.PbagRoot()->FAddProp("RSM", pbagT);
    pbagT->FAddProp("Layer0CRC", &VPR(tapDst0.DwCheckSum()));
    pbagT->FAddProp("Layer1CRC", &VPR(tapDst1.DwCheckSum()));
    pbagT->FAddProp("XboxMediaCRC", &VPR(xsumGrn.DwFinalSum()));
    pbagT->FAddProp("VideoCRC", &VPR(xsumDvd.DwFinalSum()));
    pbagT = new CVarBag;
    cifOutput.PbagRoot()->FAddProp("Xbox", pbagT);
    rgbDMIOut[6 + 16] = 0;
    pbagT->FAddProp("XMID", (LPSTR)rgbDMIOut + 6 + 8);

    if(!cifOutput.FWriteFile(szOutputName)) {
        fprintf(stderr, "error: could not write output file %s\n",
            szOutputName);
        exit(1);
        }

    if(ppr0) {
        MsgOut("Printing label 0\n");
        if(ppr0->FStartLabel()) {
            ppr0->PrintLine("XMID: %.*s\n", 8, rgbDMIOut + 6 + 8);
            ppr0->PrintLine("DLT P/N: %s-L0\n", szMediaRef);
            ppr0->PrintLine("Format: DVD-X2    Layer: 0\n");
            ppr0->PrintLine("DLT CRC: %08X\n", tapDst0.DwCheckSum());
            ppr0->PrintLine("Xbox Media CRC: %08X\n", xsumGrn.DwFinalSum());
            ppr0->PrintLine("DVD Video CRC: %08X\n", xsumDvd.DwFinalSum());
            ppr0->EndLabel();
        } else
            fprintf(stderr, "warning: could not print label 0\n");
    }

    if(ppr1) {
        MsgOut("Printing label 1\n");
        if(ppr1->FStartLabel()) {
            ppr1->PrintLine("XMID: %.*s\n", 8, rgbDMIOut + 6 + 8);
            ppr1->PrintLine("DLT P/N: %s-L1\n", szMediaRef);
            ppr1->PrintLine("Format: DVD-X2    Layer: 1\n");
            ppr1->PrintLine("DLT CRC: %08X\n", tapDst1.DwCheckSum());
            ppr1->PrintLine("Xbox Media CRC: %08X\n", xsumGrn.DwFinalSum());
            ppr1->PrintLine("DVD Video CRC: %08X\n", xsumDvd.DwFinalSum());
            ppr1->EndLabel();
        } else
            fprintf(stderr, "warning: could not print label 1\n");
    }

    if(fBeep)
        DoneBeep();
    return 0;
fatal:
    /* Clean up files */

    /* Destroy the signing contexts */
    if(pccRed)
        delete pccRed;
    if(pccGrn)
        delete pccGrn;

    /* Rewind all tapes */
    tapSrc0.FRewind();
    tapSrc1.FRewind();
    tapDst0.FRewind();
    tapDst1.FRewind();

    /* Unmount the tapes */
    tapSrc0.FUnmount();
    tapSrc1.FUnmount();
    tapDst0.FUnmount();
    tapDst1.FUnmount();

    if(fBeep)
        DoneBeep();
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\signing\signcode\signcode.cpp ===
/*
 *
 * signcode.cpp
 *
 * Acts like PRS's signcode, but signs XBEs
 *
 */

#include "precomp.h"

XBEIMAGE_CERTIFICATE certDefault = {
    // size
    sizeof(XBEIMAGE_CERTIFICATE),
    // timestamp
    0,
    // title ID
    0xFFFD0001,
    // title name
    { 0 },
    // alternate title IDs
    { 0 },
    // allowed media
    XBEIMAGE_MEDIA_TYPE_HARD_DISK,
    // region
    XBEIMAGE_GAME_REGION_MANUFACTURING,
    // ratings
    0xFFFFFFFF,
    // the rest is zero
};

BOOL FReplaceCertificate(CXBEFile *pxbe, CCryptContainer *pcc)
{
    const XBEIMAGE_CERTIFICATE *pxcert;

    pxcert = pxbe->GetCert();
    if(!pxcert)
        return NULL;

    certDefault.TimeDateStamp = time(NULL);
    wcsncpy(certDefault.TitleName, pxcert->TitleName,
        XBEIMAGE_TITLE_NAME_LENGTH);
    return CXBEFile::FGenNewKeys(&certDefault, pcc) &&
        pxbe->FInjectNewCertificate(&certDefault);
}

int __cdecl main(int argc, char **argv)
{
    CCryptContainer *pccSign = NULL;
    CXBEFile *pxbe = NULL;
    CDiskFile *pstm = NULL;
    LPCSTR szProvider = NULL;
    LPCSTR szContainer = NULL;
    LPCSTR szFileName = NULL;
    int cskip;
    int nRet = 1;

    ++argv;
    --argc;
    while(argc) {
        if(argv[0][0] == '-') {
            /* Options that we'll ignore, which have 1 parameter */
            if(0 == _stricmp(argv[0], "-spc") ||
                0 == _stricmp(argv[0], "-v") ||
                0 == _stricmp(argv[0], "-n") ||
                0 == _stricmp(argv[0], "-i") ||
                0 == _stricmp(argv[0], "-y") ||
                0 == _stricmp(argv[0], "-ky") ||
                0 == _stricmp(argv[0], "-$") ||
                0 == _stricmp(argv[0], "-a") ||
                0 == _stricmp(argv[0], "-t") ||
                0 == _stricmp(argv[0], "-tr") ||
                0 == _stricmp(argv[0], "-tw") ||
                0 == _stricmp(argv[0], "-j") ||
                0 == _stricmp(argv[0], "-jp") ||
                0 == _stricmp(argv[0], "-c") ||
                0 == _stricmp(argv[0], "-s") ||
                0 == _stricmp(argv[0], "-r") ||
                0 == _stricmp(argv[0], "-sp") ||
                0 == _stricmp(argv[0], "-cn") ||
                0 == _stricmp(argv[0], "-sha1"))
            {
                cskip = 1;
            } else if(0 == _stricmp(argv[0], "-x"))
                cskip = 0;
            else if(0 == _stricmp(argv[0], "-k")) {
                szContainer = argv[1];
                cskip = 1;
            } else if(0 == _stricmp(argv[0], "-xbekey")) {
                cskip = 0;
                szProvider = "nCipher Enhanced Cryptographic Provider";
                szContainer = "XBE1";
            } else if(0 == _stricmp(argv[0], "-p")) {
                szProvider = argv[1];
                cskip = 1;
            } else
                cskip = -1;
        } else {
            szFileName = argv[0];
            cskip = 0;
        }
        if(cskip < 0 || argc < cskip + 1) {
usage:
            fprintf(stderr, "usage: signcode -p provider -k container name\n");
            return 1;
        }
        argv += cskip + 1;
        argc -= cskip + 1;
    }

    if(!szContainer || !szProvider || !szFileName)
        goto usage;

    pccSign = CNCipherCrypt::PccCreate(szProvider, szContainer);
    if(!pccSign) {
        fprintf(stderr, "could not acquire crypto context\n");
        goto fatal;
    }
    pstm = new CDiskFile(szFileName, GENERIC_READ | GENERIC_WRITE);
    if(!pstm->FIsOpen()) {
        fprintf(stderr, "could not open %s\n", szFileName);
        goto fatal;
    }
    pxbe = new CXBEFile(pstm);
    pxbe->UseCryptContainer(new CDevkitCrypt);
    if(!pxbe->FVerifySignature()) {
        fprintf(stderr, "%s is not a valid XBE file\n", szFileName);
        goto fatal;
    }
    if(!FReplaceCertificate(pxbe, pccSign)) {
nosign:
        fprintf(stderr, "Could not sign %s\n", szFileName);
        goto fatal;
    }
    pxbe->UseCryptContainer(pccSign);
    if(!pxbe->FSignFile())
        goto nosign;
    if(!pxbe->FVerifySignature())
        goto nosign;
    if(!pxbe->FCommitChanges()) {
        fprintf(stderr, "could not write to %s\n", szFileName);
        goto fatal;
    }
    nRet = 0;

fatal:
    if(pxbe)
        delete pxbe;
    if(pstm)
        delete pstm;
    if(pccSign)
        delete pccSign;
    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\signing\sip\sip.cpp ===
/*
 *
 * sip.cpp
 *
 * Xbox code signing package
 *
 */

#include "precomp.h"
#include <malloc.h>

#define TESTKEY

CNCipherCrypt *pccSign;
CDevkitCrypt *pccRed;
//HINSTANCE g_hinstCrypt;

// {5581CF39-A767-4a14-B9D7-FA6121327A5E}
static GUID guidXSIP = 
{ 0x5581cf39, 0xa767, 0x4a14, { 0xb9, 0xd7, 0xfa, 0x61, 0x21, 0x32, 0x7a, 0x5e } };

XBEIMAGE_CERTIFICATE certDefault = {
    // size
    sizeof(XBEIMAGE_CERTIFICATE),
    // timestamp
    0,
    // title ID
    0xFFFD0001,
    // title name
    { 0 },
    // alternate title IDs
    { 0 },
    // allowed media
    XBEIMAGE_MEDIA_TYPE_HARD_DISK,
    // region
    XBEIMAGE_GAME_REGION_MANUFACTURING,
    // ratings
    0xFFFFFFFF,
    // the rest is zero
};

BOOL FReplaceCertificate(CXBEFile *pxbe, CCryptContainer *pcc)
{
    const XBEIMAGE_CERTIFICATE *pxcert;

    pxcert = pxbe->GetCert();
    if(!pxcert)
        return NULL;

    certDefault.TimeDateStamp = time(NULL);
    wcsncpy(certDefault.TitleName, pxcert->TitleName,
        XBEIMAGE_TITLE_NAME_LENGTH);
    return CXBEFile::FGenNewKeys(&certDefault, pcc) &&
        pxbe->FInjectNewCertificate(&certDefault);
}

BOOL WINAPI DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID lpv)
{
    switch(dwReason) {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hinst);
        pccRed = new CDevkitCrypt;
        break;
    case DLL_PROCESS_DETACH:
        if(pccSign) {
            delete pccSign;
            pccSign = NULL;
        }
        delete pccRed;
#if 0
        if(g_hinstCrypt) {
            FreeLibrary(g_hinstCrypt);
            g_hinstCrypt = NULL;
        }
#endif
        break;
    }

    return TRUE;
}

STDAPI DllRegisterServer(void)
{
    SIP_ADD_NEWPROVIDER sProv;
    HRESULT hr = S_OK;

    // must first init struct to 0
    memset(&sProv, 0x00, sizeof(SIP_ADD_NEWPROVIDER));

    // add registration info
    sProv.cbStruct               = sizeof(SIP_ADD_NEWPROVIDER);
    sProv.pwszDLLFileName        = L"xboxsip.dll";
    sProv.pgSubject              = &guidXSIP;
    sProv.pwszGetFuncName        = L"XSIPGetSignedDataMsg";
    sProv.pwszPutFuncName        = L"XSIPPutSignedDataMsg";
    sProv.pwszCreateFuncName     = L"XSIPCreateIndirectData";
    sProv.pwszVerifyFuncName     = L"XSIPVerifyIndirectData";
    sProv.pwszRemoveFuncName     = L"XSIPRemoveSignedDataMsg";
    sProv.pwszIsFunctionNameFmt2 = L"XSIPIsMyTypeOfFile";
    
    // register SIP provider with crypto
    return CryptSIPAddProvider(&sProv);
}

STDAPI DllUnregisterServer(void)
{
    return CryptSIPRemoveProvider(&guidXSIP);
}

BOOL FEnsureCryptContainer(HCRYPTPROV hprov)
{
#ifndef TESTKEY
    if(hprov && pccSign && pccSign->HProvider() != hprov) {
        delete pccSign;
        pccSign = NULL;
    }
#endif
    if(!pccSign) {
#ifndef TESTKEY
        if(!hprov) {
            SetLastError(NTE_BAD_PROVIDER);
            return FALSE;
        }
        pccSign = CNCipherCrypt::PccCreate(hprov);
#else
        pccSign = (CNCipherCrypt *)new CFunctestCrypt;
#endif
    }
    return pccSign != NULL;
}

BOOL WINAPI XSIPIsMyTypeOfFile(
    IN WCHAR *pwszFileName,
    OUT GUID *pgSubject
    )
{
    CDiskFileW *pstm;
    CXBEFile *pxbe = NULL;
    BOOL fRet = FALSE;

    /* We claim this is our type of file if we can verify the XBE signature */
    pstm = new CDiskFileW(pwszFileName, GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE);
    if(!pstm->FIsOpen())
        goto done;
    pxbe = new CXBEFile(pstm);
    pxbe->UseCryptContainer(pccRed);
    if(!pxbe->FVerifySignature()) {
        SetLastError(ERROR_BAD_FORMAT);
        goto done;
    }

    fRet = TRUE;

done:
    if(pxbe)
        delete pxbe;
    delete pstm;
    return fRet;
}

BOOL WINAPI XSIPGetSignedDataMsg(
    IN SIP_SUBJECTINFO *pSubjectInfo,
    OUT DWORD *pdwEncodingType,
    IN DWORD dwIndex,
    IN OUT DWORD *pdwDataLen,
    OUT BYTE *pbData
    )
{
    OutputDebugString("Get");
    return FALSE;
}

BOOL WINAPI XSIPPutSignedDataMsg(
    IN SIP_SUBJECTINFO *pSubjectInfo,
    IN DWORD dwEncodingType,
    OUT DWORD *pdwIndex,
    IN DWORD cbSignedDataMsg,
    IN BYTE *pbSignedDataMsg
    )
{
    OutputDebugString("Put");
    return FALSE;
}

BOOL WINAPI XSIPCreateIndirectData(
    IN SIP_SUBJECTINFO *pSubjectInfo,
    IN OUT DWORD *pcbIndirectData,
    OUT SIP_INDIRECT_DATA *pIndirectData
    )
{
    CFileStmRand *pstm = NULL;
    CXBEFile *pxbe = NULL;
    BOOL fRet = FALSE;
    PXBEIMAGE_HEADER pxihNew;
    PXBEIMAGE_CERTIFICATE pxcertNew;

    /* We do all of the actual signing in here.  The indirect data contains
     * the complete XBE base header, so we can contain both the signature and
     * the confounded fields, plus the XBE certificate */
    if(!pIndirectData) {
        /* Just want the byte count */
        *pcbIndirectData = sizeof(XBEIMAGE_HEADER) +
            sizeof(XBEIMAGE_CERTIFICATE);
        return TRUE;
    }
    if(!FEnsureCryptContainer(pSubjectInfo->hProv))
        goto done;
    if(pSubjectInfo->hFile && pSubjectInfo->hFile != INVALID_HANDLE_VALUE)
        pstm = new CHandleFile(pSubjectInfo->hFile);
    else
        pstm = new CDiskFileW(pSubjectInfo->pwsFileName);
    if(!pstm->FIsOpen())
        goto done;
    pxbe = new CXBEFile(pstm);
    pxbe->UseCryptContainer(pccRed);
    if(!pxbe->FVerifySignature()) {
        SetLastError(ERROR_BAD_FORMAT);
        goto done;
    }
    if(!FReplaceCertificate(pxbe, pccSign)) {
        SetLastError(ERROR_BAD_FORMAT);
        goto done;
    }
    pxbe->UseCryptContainer(pccSign);
    if(!pxbe->FSignFile()) {
        SetLastError(CRYPT_E_MSG_ERROR);
        goto done;
    }
    pxihNew = (PXBEIMAGE_HEADER)pIndirectData;
    memcpy(pxihNew, pxbe->GetHeader(), sizeof *pxihNew);

    pxcertNew = (PXBEIMAGE_CERTIFICATE)(pxihNew + 1);
    memcpy(pxcertNew, pxbe->GetCert(), sizeof *pxcertNew);
    
    fRet = TRUE;

done:
    if(pxbe)
        delete pxbe;
    if(pstm)
        delete pstm;
    return fRet;
}

BOOL WINAPI XSIPVerifyIndirectData(
    IN SIP_SUBJECTINFO *pSubjectInfo,
    IN SIP_INDIRECT_DATA *pIndirectData
    )
{
    OutputDebugString("Verify");
    return FALSE;
}

BOOL WINAPI XSIPRemoveSignedDataMsg(
    IN SIP_SUBJECTINFO *pSubjectInfo,
    IN DWORD dwIndex
    )
{
    OutputDebugString("Remove");
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\utils\copytape\copytape.cpp ===
/*
 *
 * copytape.cpp
 *
 * Tape copy and labeling tool
 *
 */

#include "precomp.h"

BOOL FMountTape(CTapeDevice *ptap, LPCSTR szName, BOOL fTOD, BOOL fWrite)
{
    HANDLE h;

    if(!szName)
        return FALSE;
    if(0 == strncmp(szName, "\\\\?", 3) || 0 == strncmp(szName, "\\\\.", 3))
        /* Tape device */
        return ptap->FMount(szName, fWrite);
    if(fWrite)
        h = CreateFile(szName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0,
            NULL);
    else
        h = CreateFile(szName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0,
            NULL);
    if(h == INVALID_HANDLE_VALUE)
        return FALSE;
    return ptap->FMount(h, fWrite);
}

int __cdecl main(int cArg, char **rgszArg)
{
    LPCSTR szInputName = NULL;
    LPCSTR szPrinterName;
    CIniFile cifInput;
    CIniBag *pbagInput;
    CVarBag *pbagReg;
    CVarBag *pbagT;
    CLabelPrinter *ppr = NULL;
    CTapeDevice tapSrc;
    CTapeDevice *prgtapDst;
    HKEY hkey;
    int ilyr = -1;
    DWORD dwOff;
    BOOL fRedLabels = FALSE;
    DWORD dwTapeCRC, dwMediaCRC, dwVideoCRC;
    DWORD dwInputCRC;
    LPCSTR szXMID;
    char szSubmission[16];
    DWORD dwSubmission;
    int i;
    DWORD cb;
    DWORD dwBlkSize;
    DWORD dwDataPerPhy;
    BYTE rgb[32768];
    char szName[32];
    LPSTR *rgszTapeNames;

    /* First look for our reg data so we know whether we'll be able to find
     * any printers */
    if(ERROR_SUCCESS == RegOpenKey(HKEY_CURRENT_USER,
        "Software\\Microsoft\\Xbox DVD-X2 DLT Utility", &hkey))
    {
        pbagReg = PbagFromRegKey(hkey);
        RegCloseKey(hkey);
    } else
        pbagReg = NULL;

    while(++rgszArg, --cArg) {
        if(_stricmp(*rgszArg, "-input") == 0) {
            if(!--cArg) {
noarg:
                fprintf(stderr, "error: missing argument for %s\n", *rgszArg);
                return 1;
            }
            szInputName = *++rgszArg;
        } else if(0 == _stricmp(*rgszArg, "-layer")) {
            if(!--cArg)
                goto noarg;
            if(**++rgszArg == '-' || 0 == sscanf(*rgszArg, "%d", &ilyr)) {
                fprintf(stderr, "error: invalid parameter to -layer\n");
                return 1;
            }
        } else if(0 == _stricmp(*rgszArg, "-label")) {
            if(ppr) {
                fprintf(stderr, "error: -label can only be specified once\n");
                return 1;
            }
            /* First make sure we have a printer */
            if(!pbagReg || !(szPrinterName =
                pbagReg->FindSzProp("LabelPrinter")))
            {
                fprintf(stderr, "error: unable to get printer name\n");
                return 1;
            }
            if(!pbagReg->FFindDwProp("PrinterOffset", &dwOff))
                dwOff = 0;            
            ppr = CLabelPrinter::PprCreate(szPrinterName, -(int)dwOff);
            if(!ppr) {
                fprintf(stderr, "error: unable to access printer %s\n",
                    szPrinterName);
                return 1;
            }
            /* Now see if we can find a RED or GREEN */
            if(cArg > 1) {
                if(0 == _stricmp(rgszArg[1], "GREEN")) {
                    ++rgszArg;
                    --cArg;
                    if(!szInputName)
                        szInputName = "OUTPUT.INI";
                } else if(0 == _stricmp(rgszArg[1], "RED")) {
                    ++rgszArg;
                    --cArg;
                    ++fRedLabels;
                    if(!szInputName)
                        szInputName = "XBCERT.INI";
                }
            }
        } else if(**rgszArg == '-') {
            fprintf(stderr, "error: unknown argument %s\n", *rgszArg);
usage:
            fprintf(stderr, "usage: xboxcopytape [-input inifile] [-label [RED | GREEN] -layer [0 | 1] ] source dest...\n");
            return 1;
        } else
            break;
    }

    /* Make sure have all the data we think is necessary */
    if(ppr) {
        if(ilyr < 0) {
            fprintf(stderr, "error: -label requires -layer\n");
            return 1;
        }
        if(!szInputName) {
            fprintf(stderr, "error: -label requires input file name\n");
            return 1;
        }
        /* Make sure we can read our input file */
        if(!cifInput.FReadFile(szInputName, TRUE)) {
            fprintf(stderr, "error: could not process input file %s\n",
                szInputName);
            return 1;
        }

        pbagInput = cifInput.PbagRoot();
        /* Check for greensign output first */
        pbagT = pbagInput->FindProp("RSM");
        if(pbagT) {
            sprintf(szName, "Layer%dCRC", ilyr);
            if(!pbagT->FFindDwProp(szName, &dwTapeCRC) ||
                !pbagT->FFindDwProp("XboxMediaCRC", &dwMediaCRC) ||
                !pbagT->FFindDwProp("VideoCRC", &dwVideoCRC))
            {
badinput:
                fprintf(stderr, "error: unable to process input data\n");
                return 1;
            }
            pbagT = pbagInput->FindProp("Xbox");
            if(!pbagT)
                goto badinput;
            szXMID = pbagT->FindSzProp("XMID");
            if(!szXMID)
                goto badinput;
            dwSubmission = 0;
        } else {
            pbagT = pbagInput->FindProp("Xbox");
            if(!pbagT || !pbagT->FFindDwProp("Submission", &dwSubmission))
                dwSubmission = 0;
            pbagT = pbagInput->FindProp("CRC");
            sprintf(szName, "Layer%dCRC", ilyr);
            if(!pbagT->FFindDwProp(szName, &dwTapeCRC) ||
                    !pbagT->FFindDwProp("XboxMediaCRC", &dwMediaCRC) ||
                    !pbagT->FFindDwProp("VideoCRC", &dwVideoCRC))
                goto badinput;
            pbagT = pbagInput->FindProp("Disk Manufacturing Information");
            if(!pbagT)
                goto badinput;
            szXMID = pbagT->FindSzProp("XMID");
            if(!szXMID)
                goto badinput;
        }
        if(fRedLabels && dwSubmission)
            sprintf(szSubmission, "-R%d", dwSubmission);
        else
            szSubmission[0] = 0;
    }

    if(cArg < 2)
        goto usage;

    /* Mount the source tape */
    if(!FMountTape(&tapSrc, *rgszArg, TRUE, FALSE)) {
        fprintf(stderr, "error: could not mount %s\n", *rgszArg);
        return 1;
    }

    prgtapDst = new CTapeDevice[--cArg];
    rgszTapeNames = ++rgszArg;
    for(i = 0; i < cArg; ++i) {
        if(!FMountTape(&prgtapDst[i], rgszTapeNames[i], TRUE, TRUE)) {
            fprintf(stderr, "error: could not mount %s\n", rgszTapeNames[i]);
            goto fatal;
        }
    }

    /* Now copy all of the files */
    while(tapSrc.FReadFile(szName, &dwBlkSize, &dwDataPerPhy)) {
        for(i = 0; i < cArg; ++i) {
            if(!prgtapDst[i].FWriteFile(szName, dwBlkSize, dwDataPerPhy)) {
writeerr:
                fprintf(stderr, "error: could not write to %s\n",
                    rgszTapeNames[i]);
                goto fatal;
            }
        }

        while(cb = tapSrc.CbRead(sizeof rgb, rgb)) {
            for(i = 0; i < cArg; ++i) {
                if(prgtapDst[i].CbWrite(cb, rgb) != cb)
                    goto writeerr;
            }
        }

        tapSrc.FCloseFile();
        for(i = 0; i < cArg; ++i) {
            if(!prgtapDst[i].FCloseFile())
                goto writeerr;
        }
    }

    if(!tapSrc.FAtEnd()) {
        fprintf(stderr, "error: reading from source tape\n");
        goto fatal;
    }

    /* Grab the tape CRC and unmount the tapes */
    dwInputCRC = tapSrc.DwCheckSum();
    tapSrc.FUnmount();
    for(i = 0; i < cArg; ++i) {
        if(!prgtapDst[i].FUnmount())
            fprintf(stderr, "warning: failed to unmount %d\n", rgszTapeNames[i]);
    }

    printf("Tape checksum is 0x%08X\n", dwInputCRC);
    if(ilyr >= 0 && dwInputCRC != dwTapeCRC) {
        fprintf(stderr, "error: tape checksum (0x%08X) does not match expected value!\n",
            dwInputCRC);
        goto fatal;
    }

    /* Print one label per copy */
    if(ppr) {
        for(i = 0; i < cArg; ++i) {
            if(ppr->FStartLabel()) {
                ppr->PrintLine("XMID: %.*s\n", 8, szXMID);
                ppr->PrintLine("DLT P/N: %.*s%s-L%d\n", 8, szXMID,
                    szSubmission, ilyr);
                ppr->PrintLine("Format: DVD-X2    Layer: %d\n", ilyr);
                ppr->PrintLine("DLT CRC: %08X\n", dwTapeCRC);
                ppr->PrintLine("Xbox Media CRC: %08X\n", dwMediaCRC);
                ppr->PrintLine("DVD Video CRC: %08X\n", dwVideoCRC);
                ppr->EndLabel();
            } else
                fprintf(stderr, "warning: could not print label\n");
        }
    }

    /* Clean up the printer */
    if(ppr)
        delete ppr;

    return 0;
fatal:
    if(ppr)
        delete ppr;
    for(i = 0; i < cArg; ++i)
        prgtapDst[i].FRewind();
    delete[] prgtapDst;
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\spy\dxt\certspyp.h ===
/*++

Copyright (c) Microsoft Corporation.  All right reserved.

Module Name:

    certspyp.h.

Abstract:

    This is a pre-compiled header module for certspy.

--*/

#if !defined(_CERTSPYP_INCLUDED_)
#define _CERTSPYP_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef __cplusplus
extern "C" {
#endif

#include <ntos.h>
#include <mi.h>
#include <ldr.h>
#include <xbeimage.h>
#include <xtl.h>
#include <xbdm.h>
#include <xboxverp.h>

#ifndef ARRAYSIZE
#define ARRAYSIZE(a) (sizeof(a)/sizeof((a)[0]))
#endif

#ifndef CONSTANT_OBJECT_STRING
#define CONSTANT_OBJECT_STRING(s) { sizeof(s) - sizeof(OCHAR), sizeof(s), s }
#endif

//
// Define bit definition of kernel export flags
//

#define KEF_INTERCEPT_AT_STARTUP    1

#pragma pack(1)

//
// Define structure of ordinal thunk for Intel x86 processor
//
// Here is what the stub looks like
//
//      60          pushad
//      8d542432    lea     edx, [esp+32]
//      b9nnnnnnnn  mov     ecx, OridnalNumber
//      e8nnnnnnnn  call    @CertSpyLogOrdinalCall
//      61          popad
//      e9nnnnnnnn  jmp     OriginalFunction
//

typedef struct {

    BYTE   __pushad;
    DWORD  __lea_edx_esp_plus_32;
    BYTE   __mov_ecx_immediate;
    DWORD  ImmediateValue;
    BYTE   __call_LogFunction;
    DWORD  OffsetOfLogFunction;
    BYTE   __popad;
    BYTE   __jmp_far;
    DWORD  ImmediateJmpAddress;

} ORDINAL_THUNK, *PORDINAL_THUNK;

typedef enum {

    PT_NONE = 0,
    PT_LONG,
    PT_LONGLONG,
    PT_PSTR,
    PT_PWSTR,
    PT_POOLTAG,
    PT_PSTRING,
    PT_POBJATTR,
    PT_PUSTRING

} PARAMETER_TYPE;

//
// Define the structure of xboxkrnl export functions and their parameter
// encoding
//

typedef struct {

    PCSTR   FunctionName;
    UCHAR   Parameters[12];
    PORDINAL_THUNK Thunk;

} KERNEL_EXPORT_API, *PKERNEL_EXPORT_API;

#pragma pack()

//
// List of xboxkrnl.exe export functions and byte-encoded parameters
//

const KERNEL_EXPORT_API KernelExports[] = {

    {  NULL, PT_NONE },
    { "AvGetSavedDataAddress",              PT_NONE },
    { "AvSendTVEncoderOption",              PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "AvSetDisplayMode",                   PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "AvSetSavedDataAddress",              PT_NONE },
    { "DbgBreakPoint",                      PT_NONE },
    { "DbgBreakPointWithStatus",            PT_LONG },
    { "DbgLoadImageSymbols",                PT_PSTRING, PT_LONG, PT_LONG },
    { "DbgPrint",                           PT_PSTR },
    { "HalReadSMCTrayState",                PT_LONG, PT_LONG },
    { "DbgPrompt",                          PT_PSTR, PT_LONG, PT_LONG },
    { "DbgUnLoadImageSymbols",              PT_PSTRING, PT_LONG, PT_LONG },
    { "ExAcquireReadWriteLockExclusive",    PT_LONG },
    { "ExAcquireReadWriteLockShared",       PT_LONG },
    { "ExAllocatePool",                     PT_LONG },
    { "ExAllocatePoolWithTag",              PT_LONG, PT_POOLTAG },
    {  NULL, PT_NONE },                     // ExEventObjectType
    { "ExFreePool",                         PT_LONG },
    { "ExInitializeReadWriteLock",          PT_LONG },
    { "ExInterlockedAddLargeInteger",       PT_LONG, PT_LONGLONG },
    { "ExInterlockedAddLargeStatistic",     PT_LONG, PT_LONG },
    { "ExInterlockedCompareExchange64",     PT_LONG, PT_LONG, PT_LONG },
    {  NULL, PT_NONE },                     // ExMutantObjectType
    { "ExQueryPoolBlockSize",               PT_LONG },
    { "ExQueryNonVolatileSetting",          PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "ExReadWriteRefurbInfo",              PT_LONG, PT_LONG, PT_LONG },
    { "ExRaiseException",                   PT_LONG },
    { "ExRaiseStatus",                      PT_LONG },
    { "ExReleaseReadWriteLock",             PT_LONG },
    { "ExSaveNonVolatileSetting",           PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    {  NULL, PT_NONE },                     // ExSemaphoreObjectType
    {  NULL, PT_NONE },                     // ExTimerObjectType
    { "ExfInterlockedInsertHeadList",       PT_NONE },
    { "ExfInterlockedInsertTailList",       PT_NONE },
    { "ExfInterlockedRemoveHeadList",       PT_NONE },
    { "FscGetCacheSize",                    PT_NONE },
    { "FscInvalidateIdleBlocks",            PT_NONE },
    { "FscSetCacheSize",                    PT_LONG },
    { "HalClearSoftwareInterrupt",          PT_NONE },
    { "HalDisableSystemInterrupt",          PT_LONG },
    {  NULL, NULL },                        // HalDiskCachePartitionCount
    {  NULL, NULL },                        // HalDiskModelNumber
    {  NULL, NULL },                        // HalDiskSerialNumber
    { "HalEnableSystemInterrupt",           PT_LONG, PT_LONG },
    { "HalGetInterruptVector",              PT_LONG, PT_LONG },
    { "HalReadSMBusValue",                  PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "HalReadWritePCISpace",               PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "HalRegisterShutdownNotification",    PT_LONG, PT_LONG },
    { "HalRequestSoftwareInterrupt",        PT_LONG },
    { "HalReturnToFirmware",                PT_LONG },
    { "HalWriteSMBusValue",                 PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "InterlockedCompareExchange",         PT_LONG, PT_LONG, PT_LONG },
    { "InterlockedDecrement",               PT_LONG },
    { "InterlockedIncrement",               PT_LONG },
    { "InterlockedExchange",                PT_LONG, PT_LONG },
    { "InterlockedExchangeAdd",             PT_LONG, PT_LONG },
    { "InterlockedFlushSList",              PT_LONG },
    { "InterlockedPopEntrySList",           PT_LONG },
    { "InterlockedPushEntrySList",          PT_LONG, PT_LONG },
    { "IoAllocateIrp",                      PT_LONG },
    { "IoBuildAsynchronousFsdRequest",      PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "IoBuildDeviceIoControlRequest",      PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "IoBuildSynchronousFsdRequest",       PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "IoCheckShareAccess",                 PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    {  NULL, NULL },                        // IoCompletionObjectType
    { "IoCreateDevice",                     PT_LONG, PT_LONG, PT_PSTRING, PT_LONG, PT_LONG, PT_LONG },
    { "IoCreateFile",                       PT_LONG, PT_LONG, PT_POBJATTR, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "IoCreateSymbolicLink",               PT_PSTRING, PT_PSTRING },
    { "IoDeleteDevice",                     PT_LONG },
    { "IoDeleteSymbolicLink",               PT_PSTRING },
    {  NULL, NULL },                        // IoDeviceObjectType
    {  NULL, NULL },                        // IoFileObjectType
    { "IoFreeIrp",                          PT_LONG },
    { "IoInitializeIrp",                    PT_LONG, PT_LONG, PT_LONG },
    { "IoInvalidDeviceRequest",             PT_LONG, PT_LONG },
    { "IoQueryFileInformation",             PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "IoQueryVolumeInformation",           PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "IoQueueThreadIrp",                   PT_LONG },
    { "IoRemoveShareAccess",                PT_LONG, PT_LONG },
    { "IoSetIoCompletion",                  PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "IoSetShareAccess",                   PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "IoStartNextPacket",                  PT_LONG },
    { "IoStartNextPacketByKey",             PT_LONG, PT_LONG },
    { "IoStartPacket",                      PT_LONG, PT_LONG, PT_LONG },
    { "IoSynchronousDeviceIoControlRequest",PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "IoSynchronousFsdRequest",            PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "IofCallDriver",                      PT_NONE },
    { "IofCompleteRequest",                 PT_NONE },
    {  NULL, NULL },                        // KdDebuggerEnabled
    {  NULL, NULL },                        // KdDebuggerNotPresent
    { "IoDismountVolume",                   PT_LONG },
    { "IoDismountVolumeByName",             PT_PSTRING },
    { "KeAlertResumeThread",                PT_LONG },
    { "KeAlertThread",                      PT_LONG, PT_LONG },
    { "KeBoostPriorityThread",              PT_LONG, PT_LONG },
    { "KeBugCheck",                         PT_LONG },
    { "KeBugCheckEx",                       PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "KeCancelTimer",                      PT_LONG },
    { "KeConnectInterrupt",                 PT_LONG },
    { "KeDelayExecutionThread",             PT_LONG, PT_LONG, PT_LONG },
    { "KeDisconnectInterrupt",              PT_LONG },
    { "KeEnterCriticalRegion",              PT_NONE },
    {  NULL, NULL },                        // MmGlobalData
    { "KeGetCurrentIrql",                   PT_NONE },
    { "KeGetCurrentThread",                 PT_NONE },
    { "KeInitializeApc",                    PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "KeInitializeDeviceQueue",            PT_LONG },
    { "KeInitializeDpc",                    PT_LONG, PT_LONG, PT_LONG },
    { "KeInitializeEvent",                  PT_LONG, PT_LONG, PT_LONG },
    { "KeInitializeInterrupt",              PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "KeInitializeMutant",                 PT_LONG, PT_LONG },
    { "KeInitializeQueue",                  PT_LONG, PT_LONG },
    { "KeInitializeSemaphore",              PT_LONG, PT_LONG, PT_LONG },
    { "KeInitializeTimerEx",                PT_LONG, PT_LONG },
    { "KeInsertByKeyDeviceQueue",           PT_LONG, PT_LONG, PT_LONG },
    { "KeInsertDeviceQueue",                PT_LONG, PT_LONG },
    { "KeInsertHeadQueue",                  PT_LONG, PT_LONG },
    { "KeInsertQueue",                      PT_LONG, PT_LONG },
    { "KeInsertQueueApc",                   PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "KeInsertQueueDpc",                   PT_LONG, PT_LONG, PT_LONG },
    {  NULL, NULL },                        // KeInterruptTime}
    { "KeIsExecutingDpc",                   PT_NONE },
    { "KeLeaveCriticalRegion",              PT_NONE },
    { "KePulseEvent",                       PT_LONG, PT_LONG, PT_LONG },
    { "KeQueryBasePriorityThread",          PT_LONG },
    { "KeQueryInterruptTime",               PT_NONE },
    { "KeQueryPerformanceCounter",          PT_NONE },
    { "KeQueryPerformanceFrequency",        PT_NONE },
    { "KeQuerySystemTime",                  PT_LONG },
    { "KeRaiseIrqlToDpcLevel",              PT_NONE },
    { "KeRaiseIrqlToSynchLevel",            PT_NONE },
    { "KeReleaseMutant",                    PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "KeReleaseSemaphore",                 PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "KeRemoveByKeyDeviceQueue",           PT_LONG, PT_LONG },
    { "KeRemoveDeviceQueue",                PT_LONG },
    { "KeRemoveEntryDeviceQueue",           PT_LONG, PT_LONG },
    { "KeRemoveQueue",                      PT_LONG, PT_LONG, PT_LONG },
    { "KeRemoveQueueDpc",                   PT_LONG },
    { "KeResetEvent",                       PT_LONG },
    { "KeRestoreFloatingPointState",        PT_LONG },
    { "KeResumeThread",                     PT_LONG },
    { "KeRundownQueue",                     PT_LONG },
    { "KeSaveFloatingPointState",           PT_LONG },
    { "KeSetBasePriorityThread",            PT_LONG, PT_LONG },
    { "KeSetDisableBoostThread",            PT_LONG, PT_LONG },
    { "KeSetEvent",                         PT_LONG, PT_LONG, PT_LONG },
    { "KeSetEventBoostPriority",            PT_LONG, PT_LONG },
    { "KeSetPriorityProcess",               PT_LONG, PT_LONG },
    { "KeSetPriorityThread",                PT_LONG, PT_LONG },
    { "KeSetTimer",                         PT_LONG, PT_LONGLONG, PT_LONG },
    { "KeSetTimerEx",                       PT_LONG, PT_LONGLONG, PT_LONG, PT_LONG },
    { "KeStallExecutionProcessor",          PT_LONG },
    { "KeSuspendThread",                    PT_LONG },
    { "KeSynchronizeExecution",             PT_LONG, PT_LONG, PT_LONG },
    {  NULL, NULL },                        // KeSystemTime
    { "KeTestAlertThread",                  PT_LONG },
    {  NULL, NULL },                        // KeTickCount
    {  NULL, NULL },                        // KeTimeIncrement
    { "KeWaitForMultipleObjects",           PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "KeWaitForSingleObject",              PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "KfRaiseIrql",                        PT_NONE },
    { "KfLowerIrql",                        PT_NONE },
    {  NULL, NULL },                        // KiBugCheckData
    { "KiUnlockDispatcherDatabase",         PT_LONG },
    {  NULL, NULL },                        // LaunchDataPage
    { "MmAllocateContiguousMemory",         PT_LONG },
    { "MmAllocateContiguousMemoryEx",       PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "MmAllocateSystemMemory",             PT_LONG, PT_LONG },
    { "MmClaimGpuInstanceMemory",           PT_LONG, PT_LONG },
    { "MmCreateKernelStack",                PT_LONG, PT_LONG },
    { "MmDeleteKernelStack",                PT_LONG, PT_LONG },
    { "MmFreeContiguousMemory",             PT_LONG },
    { "MmFreeSystemMemory",                 PT_LONG, PT_LONG },
    { "MmGetPhysicalAddress",               PT_LONG },
    { "MmIsAddressValid",                   PT_LONG },
    { "MmLockUnlockBufferPages",            PT_LONG, PT_LONG, PT_LONG },
    { "MmLockUnlockPhysicalPage",           PT_LONG, PT_LONG },
    { "MmMapIoSpace",                       PT_LONG, PT_LONG, PT_LONG },
    { "MmPersistContiguousMemory",          PT_LONG, PT_LONG, PT_LONG },
    { "MmQueryAddressProtect",              PT_LONG },
    { "MmQueryAllocationSize",              PT_LONG },
    { "MmQueryStatistics",                  PT_LONG },
    { "MmSetAddressProtect",                PT_LONG, PT_LONG, PT_LONG },
    { "MmUnmapIoSpace",                     PT_LONG, PT_LONG },
    { "NtAllocateVirtualMemory",            PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "NtCancelTimer",                      PT_LONG, PT_LONG },
    { "NtClearEvent",                       PT_LONG },
    { "NtClose",                            PT_LONG },
    { "NtCreateDirectoryObject",            PT_LONG, PT_POBJATTR },
    { "NtCreateEvent",                      PT_LONG, PT_POBJATTR, PT_LONG, PT_LONG },
    { "NtCreateFile",                       PT_LONG, PT_LONG, PT_POBJATTR, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "NtCreateIoCompletion",               PT_LONG, PT_LONG, PT_POBJATTR, PT_LONG },
    { "NtCreateMutant",                     PT_LONG, PT_POBJATTR, PT_LONG },
    { "NtCreateSemaphore",                  PT_LONG, PT_POBJATTR, PT_LONG, PT_LONG },
    { "NtCreateTimer",                      PT_LONG, PT_POBJATTR, PT_LONG },
    { "NtDeleteFile",                       PT_POBJATTR },
    { "NtDeviceIoControlFile",              PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "NtDuplicateObject",                  PT_LONG, PT_LONG, PT_LONG },
    { "NtFlushBuffersFile",                 PT_LONG, PT_LONG },
    { "NtFreeVirtualMemory",                PT_LONG, PT_LONG, PT_LONG },
    { "NtFsControlFile",                    PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "NtOpenDirectoryObject",              PT_LONG, PT_POBJATTR },
    { "NtOpenFile",                         PT_LONG, PT_LONG, PT_POBJATTR, PT_LONG, PT_LONG, PT_LONG },
    { "NtOpenSymbolicLinkObject",           PT_LONG, PT_POBJATTR },
    { "NtProtectVirtualMemory",             PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "NtPulseEvent",                       PT_LONG, PT_LONG },
    { "NtQueueApcThread",                   PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "NtQueryDirectoryFile",               PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_PSTRING, PT_LONG },
    { "NtQueryDirectoryObject",             PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "NtQueryEvent",                       PT_LONG, PT_LONG },
    { "NtQueryFullAttributesFile",          PT_POBJATTR, PT_LONG },
    { "NtQueryInformationFile",             PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "NtQueryIoCompletion",                PT_LONG, PT_LONG },
    { "NtQueryMutant",                      PT_LONG, PT_LONG },
    { "NtQuerySemaphore",                   PT_LONG, PT_LONG },
    { "NtQuerySymbolicLinkObject",          PT_LONG, PT_PSTRING, PT_LONG },
    { "NtQueryTimer",                       PT_LONG, PT_LONG },
    { "NtQueryVirtualMemory",               PT_LONG, PT_LONG },
    { "NtQueryVolumeInformationFile",       PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "NtReadFile",                         PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "NtReadFileScatter",                  PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "NtReleaseMutant",                    PT_LONG, PT_LONG },
    { "NtReleaseSemaphore",                 PT_LONG, PT_LONG, PT_LONG },
    { "NtRemoveIoCompletion",               PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "NtResumeThread",                     PT_LONG, PT_LONG },
    { "NtSetEvent",                         PT_LONG, PT_LONG },
    { "NtSetInformationFile",               PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "NtSetIoCompletion",                  PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "NtSetSystemTime",                    PT_LONG, PT_LONG },
    { "NtSetTimerEx",                       PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "NtSignalAndWaitForSingleObjectEx",   PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "NtSuspendThread",                    PT_LONG, PT_LONG },
    { "NtUserIoApcDispatcher",              PT_LONG, PT_LONG, PT_LONG },
    { "NtWaitForSingleObject",              PT_LONG, PT_LONG, PT_LONG },
    { "NtWaitForSingleObjectEx",            PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "NtWaitForMultipleObjectsEx",         PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "NtWriteFile",                        PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "NtWriteFileGather",                  PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "NtYieldExecution",                   PT_NONE },
    { "ObCreateObject",                     PT_LONG, PT_POBJATTR, PT_LONG, PT_LONG },
    {  NULL, NULL },                        // ObDirectoryObjectType
    { "ObInsertObject",                     PT_LONG, PT_POBJATTR, PT_LONG, PT_LONG },
    { "ObMakeTemporaryObject",              PT_LONG },
    { "ObOpenObjectByName",                 PT_POBJATTR, PT_LONG, PT_LONG, PT_LONG },
    { "ObOpenObjectByPointer",              PT_LONG, PT_LONG, PT_LONG },
    {  NULL, NULL },                        // ObpObjectHandleTable
    { "ObReferenceObjectByHandle",          PT_LONG, PT_LONG, PT_LONG },
    { "ObReferenceObjectByName",            PT_PSTRING, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "ObReferenceObjectByPointer",         PT_LONG, PT_LONG },
    {  NULL, NULL },                        // ObSymbolicLinkObjectType
    { "ObfDereferenceObject",               PT_NONE },
    { "ObfReferenceObject",                 PT_NONE },
    { "PhyGetLinkState",                    PT_LONG },
    { "PhyInitialize",                      PT_LONG, PT_LONG },
    { "PsCreateSystemThread",               PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "PsCreateSystemThreadEx",             PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "PsQueryStatistics",                  PT_LONG },
    { "PsSetCreateThreadNotifyRoutine",     PT_LONG },
    { "PsTerminateSystemThread",            PT_LONG },
    {  NULL, NULL },                        // PsThreadObjectType
    { "RtlAnsiStringToUnicodeString",       PT_PUSTRING, PT_PSTRING, PT_LONG },
    { "RtlAppendStringToString",            PT_PSTRING, PT_PSTRING },
    { "RtlAppendUnicodeStringToString",     PT_PUSTRING, PT_PUSTRING },
    { "RtlAppendUnicodeToString",           PT_PUSTRING, PT_PWSTR },
    { "RtlAssert",                          PT_PSTR, PT_PSTR, PT_LONG, PT_PSTR },
    { "RtlCaptureContext",                  PT_LONG },
    { "RtlCaptureStackBackTrace",           PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "RtlCharToInteger",                   PT_PSTR, PT_LONG, PT_LONG },
    { "RtlCompareMemory",                   PT_LONG, PT_LONG, PT_LONG },
    { "RtlCompareMemoryUlong",              PT_LONG, PT_LONG, PT_LONG },
    { "RtlCompareString",                   PT_PSTRING, PT_PSTRING, PT_LONG },
    { "RtlCompareUnicodeString",            PT_PUSTRING, PT_PUSTRING, PT_LONG },
    { "RtlCopyString",                      PT_PSTRING, PT_PSTRING },
    { "RtlCopyUnicodeString",               PT_PUSTRING, PT_PUSTRING },
    { "RtlCreateUnicodeString",             PT_PUSTRING, PT_PWSTR },
    { "RtlDowncaseUnicodeChar",             PT_LONG },
    { "RtlDowncaseUnicodeString",           PT_PUSTRING, PT_PUSTRING, PT_LONG },
    { "RtlEnterCriticalSection",            PT_LONG },
    { "RtlEnterCriticalSectionAndRegion",   PT_LONG },
    { "RtlEqualString",                     PT_PSTRING, PT_PSTRING, PT_LONG },
    { "RtlEqualUnicodeString",              PT_PUSTRING, PT_PUSTRING, PT_LONG },
    { "RtlExtendedIntegerMultiply",         PT_LONGLONG, PT_LONG },
    { "RtlExtendedLargeIntegerDivide",      PT_LONGLONG, PT_LONG, PT_LONG },
    { "RtlExtendedMagicDivide",             PT_LONGLONG, PT_LONGLONG, PT_LONG },
    { "RtlFillMemory",                      PT_LONG, PT_LONG, PT_LONG },
    { "RtlFillMemoryUlong",                 PT_LONG, PT_LONG, PT_LONG },
    { "RtlFreeAnsiString",                  PT_PSTRING },
    { "RtlFreeUnicodeString",               PT_PUSTRING },
    { "RtlGetCallersAddress",               PT_LONG, PT_LONG },
    { "RtlInitAnsiString",                  PT_PSTRING, PT_PSTR },
    { "RtlInitUnicodeString",               PT_PUSTRING, PT_PWSTR },
    { "RtlInitializeCriticalSection",       PT_LONG },
    { "RtlIntegerToChar",                   PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "RtlIntegerToUnicodeString",          PT_LONG, PT_LONG, PT_PUSTRING },
    { "RtlLeaveCriticalSection",            PT_LONG },
    { "RtlLeaveCriticalSectionAndRegion",   PT_LONG },
    { "RtlLowerChar",                       PT_LONG },
    { "RtlMapGenericMask",                  PT_LONG, PT_LONG },
    { "RtlMoveMemory",                      PT_LONG, PT_LONG, PT_LONG },
    { "RtlMultiByteToUnicodeN",             PT_LONG, PT_LONG, PT_LONG, PT_PSTR, PT_LONG },
    { "RtlMultiByteToUnicodeSize",          PT_LONG, PT_PSTR, PT_LONG },
    { "RtlNtStatusToDosError",              PT_LONG },
    { "RtlRaiseException",                  PT_LONG },
    { "RtlRaiseStatus",                     PT_LONG },
    { "RtlTimeFieldsToTime",                PT_LONG, PT_LONG },
    { "RtlTimeToTimeFields",                PT_LONG, PT_LONG },
    { "RtlTryEnterCriticalSection",         PT_LONG },
    { "RtlUlongByteSwap",                   PT_LONG },
    { "RtlUnicodeStringToAnsiString",       PT_PSTRING, PT_PUSTRING, PT_LONG },
    { "RtlUnicodeStringToInteger",          PT_PUSTRING, PT_LONG, PT_LONG },
    { "RtlUnicodeToMultiByteN",             PT_LONG, PT_LONG, PT_LONG, PT_PWSTR, PT_LONG },
    { "RtlUnicodeToMultiByteSize",          PT_LONG, PT_PUSTRING, PT_LONG },
    { "RtlUnwind",                          PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "RtlUpcaseUnicodeChar",               PT_LONG },
    { "RtlUpcaseUnicodeString",             PT_PUSTRING, PT_PUSTRING, PT_LONG },
    { "RtlUpcaseUnicodeToMultiByteN",       PT_LONG, PT_LONG, PT_LONG, PT_PWSTR, PT_LONG },
    { "RtlUpperChar",                       PT_LONG },
    { "RtlUpperString",                     PT_PSTRING, PT_PSTRING },
    { "RtlUshortByteSwap",                  PT_LONG },
    { "RtlWalkFrameChain",                  PT_LONG, PT_LONG, PT_LONG },
    { "RtlZeroMemory",                      PT_LONG, PT_LONG },
    {  NULL, NULL },                        // XboxEEPROMKey
    {  NULL, NULL },                        // XboxHardwareInfo
    {  NULL, NULL },                        // XboxHDKey
    {  NULL, NULL },                        // XboxKrnlVersion
    {  NULL, NULL },                        // XboxSignatureKey
    {  NULL, NULL },                        // XeImageFileName
    { "XeLoadSection",                      PT_LONG },
    { "XeUnloadSection",                    PT_LONG },
    { "READ_PORT_BUFFER_UCHAR",             PT_LONG, PT_LONG, PT_LONG },
    { "READ_PORT_BUFFER_USHORT",            PT_LONG, PT_LONG, PT_LONG },
    { "READ_PORT_BUFFER_ULONG",             PT_LONG, PT_LONG, PT_LONG },
    { "WRITE_PORT_BUFFER_UCHAR",            PT_LONG, PT_LONG, PT_LONG },
    { "WRITE_PORT_BUFFER_USHORT",           PT_LONG, PT_LONG, PT_LONG },
    { "WRITE_PORT_BUFFER_ULONG",            PT_LONG, PT_LONG, PT_LONG },
    { "XcSHAInit",                          PT_LONG },
    { "XcSHAUpdate",                        PT_LONG, PT_LONG, PT_LONG },
    { "XcSHAFinal",                         PT_LONG, PT_LONG },
    { "XcRC4Key",                           PT_LONG, PT_LONG, PT_LONG },
    { "XcRC4Crypt",                         PT_LONG, PT_LONG, PT_LONG },
    { "XcHMAC",                             PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "XcPKEncPublic",                      PT_LONG, PT_LONG, PT_LONG },
    { "XcPKDecPrivate",                     PT_LONG, PT_LONG, PT_LONG },
    { "XcPKGetKeyLen",                      PT_LONG },
    { "XcVerifyPKCS1Signature",             PT_LONG, PT_LONG, PT_LONG },
    { "XcModExp",                           PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "XcDESKeyParity",                     PT_LONG, PT_LONG },
    { "XcKeyTable",                         PT_LONG, PT_LONG, PT_LONG },
    { "XcBlockCrypt",                       PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "XcBlockCryptCBC",                    PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG, PT_LONG },
    { "XcCryptService",                     PT_LONG, PT_LONG },
    { "XcUpdateCrypto",                     PT_LONG, PT_LONG },
    { "RtlRip",                             PT_PSTR, PT_PSTR, PT_PSTR },
    {  NULL, NULL },                        // XboxLANKey
    {  NULL, NULL },                        // XboxAlternateSignatureKeys
    {  NULL, NULL },                        // XePublicKeyData
    {  NULL, NULL },                        // HalBootSMCVideoMode
    {  NULL, NULL },                        // IdexChannelObject
    { "HalIsResetOrShutdownPending",        PT_NONE },
    { "IoMarkIrpMustComplete",              PT_LONG },
    { "HalInitiateShutdown",                PT_NONE },
    { "RtlSnprintf",                        PT_PSTR, PT_LONG, PT_PSTR },
    { "RtlSprintf",                         PT_PSTR, PT_PSTR },
    { "RtlVsnprintf",                       PT_PSTR, PT_LONG, PT_PSTR, PT_LONG },
    { "RtlVsprintf",                        PT_PSTR, PT_PSTR, PT_LONG },
    { "HalEnableSecureTrayEject",           PT_NONE },
    { "HalWriteSMCScratchRegister",         PT_LONG },
    {  NULL, NULL },                        // Unused
    {  NULL, NULL },                        // Unused
    {  NULL, NULL },                        // Unused
    { "XProfpControl",                      PT_LONG, PT_LONG },
    { "XProfpGetData",                      PT_NONE },
    { "IrtClientInitFast",                  PT_NONE },
    { "IrtSweep",                           PT_LONG },
    { "MmDbgAllocateMemory",                PT_LONG, PT_LONG },
    { "MmDbgFreeMemory",                    PT_LONG, PT_LONG },
    { "MmDbgQueryAvailablePages",           PT_NONE },
    { "MmDbgReleaseAddress",                PT_LONG, PT_LONG },
    { "MmDbgWriteCheck",                    PT_LONG, PT_LONG },
};

static const SIZE_T KernelExportSize = ARRAYSIZE(KernelExports);

extern BYTE KernelExportFlags[KernelExportSize];
extern PORDINAL_THUNK InterceptThunks[KernelExportSize];
extern PIMAGE_THUNK_DATA ImageThunks[KernelExportSize];

HRESULT
WINAPI
CertSpyCommandProcessor(
    IN  PCSTR  szCommand,
    OUT PSTR   szResponse,
    IN  SIZE_T cchResponse,
    IN  PDM_CMDCONT pdmcc
    );

__inline
VOID
CertSpyFlushICache(
    VOID
    )
{
    __asm {
        wbinvd
        push    ebx
        xor     eax, eax
        cpuid
        pop     ebx
    }
}

NTSTATUS
CertSpyHookKernelImportOrdinal(
    IN ULONG OrdinalNumber
    );

NTSTATUS
CertSpyUnhookKernelImportOrdinal(
    IN ULONG OrdinalNumber
    );

#ifdef __cplusplus
}
#endif

#endif // _CERTSPYP_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\spy\dxt\certspy.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All right reserved.

Module Name:

    certspy.cpp

Abstract:

    This module contains main entry-point of certspy debugger extension.

--*/

#include "certspyp.h"

//
// Global notification session for module load notification from xbdm
//

PDMN_SESSION DmSession;

//
// Define bitmap that contains flag to intercept kernel thunk during startup
//

BYTE KernelExportFlags[KernelExportSize];

//
// Define array that contains intercepted kernel thunk index by ordinal
//

PORDINAL_THUNK InterceptThunks[KernelExportSize];

//
// Define array that contains image thunk data index by ordinal
//

PIMAGE_THUNK_DATA ImageThunks[KernelExportSize];

//
// Flag indicates that the XBE has been loaded by the kernel
//

BOOLEAN CertSpyXbeHasBeenLoaded;

VOID
FASTCALL
CertSpyLogKernelCall(
    IN ULONG  OrdinalNumber,
    IN PULONG StackFrame
    )
{
    PUCHAR Params;
    BOOLEAN DecodeParams = FALSE;
    POBJECT_STRING ObjectString;
    const KERNEL_EXPORT_API* Api = &KernelExports[OrdinalNumber];

    Params = (PUCHAR)Api->Parameters;

    Params = (PUCHAR)Api->Parameters;
    StackFrame++; // Skip over return address

    const SIZE_T BufferSize = 1024;
    SIZE_T BytesLeft = BufferSize;
    SIZE_T CharCount;
    CHAR TextBuffer[BufferSize];
    CHAR* Buffer = TextBuffer;

    CharCount = _snprintf(Buffer, BytesLeft, "certspy!kcall %d", OrdinalNumber);

    Buffer += CharCount;
    BytesLeft -= CharCount;

    while (*Params && BytesLeft) {

        CharCount = 0;

        switch (*Params) {

        case PT_PSTRING:
            CharCount = _snprintf(Buffer, BytesLeft, " %Z", *StackFrame);
            break;

        case PT_POBJATTR:
            ObjectString = ((POBJECT_ATTRIBUTES)*StackFrame)->ObjectName;
            CharCount = _snprintf(Buffer, BytesLeft, " %Z", ObjectString);
            break;

        case PT_LONGLONG:
            CharCount = _snprintf(Buffer, BytesLeft, " 0x%I64X", *StackFrame);
            StackFrame++;
            break;

        default:
            CharCount = _snprintf(Buffer, BytesLeft, " 0x%X", *StackFrame);
        }

        Buffer += CharCount;
        StackFrame++;
        Params++;

        if (BytesLeft > CharCount) {
            BytesLeft -= CharCount;
        } else {
            BytesLeft = 0;
        }
    }

    TextBuffer[BufferSize - 1] = 0;
    DmSendNotificationString(TextBuffer);
}

PORDINAL_THUNK
CertSpyBuildKernelThunk(
    IN ULONG OrdinalNumber,
    IN ULONG_PTR FunctionAddress
    )
{
    PORDINAL_THUNK Thunk;

    //
    // Allocate memory out of executable region.  Note that executeable
    // region are only virtual address and debug region.
    //

    Thunk = (PORDINAL_THUNK)DmAllocatePool(sizeof(*Thunk));

    if (Thunk) {

        //
        // Build the thunk by manually writing x86 op-code
        //

        Thunk->__pushad = 0x60;
        Thunk->__lea_edx_esp_plus_32 = 0x2024548D;
        Thunk->__mov_ecx_immediate = 0xB9;
        Thunk->ImmediateValue = OrdinalNumber;
        Thunk->__call_LogFunction = 0xE8;
        Thunk->OffsetOfLogFunction = (ULONG_PTR)CertSpyLogKernelCall - \
            (ULONG_PTR)&Thunk->__popad;
        Thunk->__popad = 0x61;
        Thunk->__jmp_far = 0xE9;
        Thunk->ImmediateJmpAddress = (ULONG_PTR)FunctionAddress - \
            (ULONG_PTR)&Thunk->ImmediateJmpAddress - \
            sizeof(Thunk->ImmediateJmpAddress);
    }

    return Thunk;
}

ULONG
CertSpyLookupOrdinalFromExportDirectory(
    IN ULONG ImageBase,
    IN PIMAGE_EXPORT_DIRECTORY ExportDirectory,
    IN ULONG AddressOfFunction
    )
{
    ULONG Entry;
    PULONG AddressOfFunctions;

    AddressOfFunctions = (PULONG)(ImageBase + \
        (ULONG)ExportDirectory->AddressOfFunctions);

    for (Entry=0; Entry<ExportDirectory->NumberOfFunctions; Entry++) {
        if (AddressOfFunctions[Entry] == AddressOfFunction - \
            (ULONG_PTR)PsNtosImageBase) {
            return Entry + 1;
        }
    }

    return ~0UL;
}

NTSTATUS
CertSpyHookKernelImportOrdinal(
    IN ULONG OrdinalNumber
    )
{
    NTSTATUS Status;
    PIMAGE_THUNK_DATA ImageThunkData = NULL;
    PORDINAL_THUNK Thunk;

    if (OrdinalNumber < KernelExportSize) {
        ImageThunkData = ImageThunks[OrdinalNumber];
    }

    if (!ImageThunkData) {

        if (CertSpyXbeHasBeenLoaded) {
            return STATUS_ORDINAL_NOT_FOUND;
        }

        //
        // Add to defer list if image hasn't been loaded into memory
        //

        KernelExportFlags[OrdinalNumber] |= KEF_INTERCEPT_AT_STARTUP;
        return STATUS_PENDING;
    }

    if (InterceptThunks[OrdinalNumber]) {
        return STATUS_SUCCESS;
    }

    Thunk = CertSpyBuildKernelThunk(OrdinalNumber, ImageThunkData->u1.Function);

    if (!Thunk) {
        return STATUS_NO_MEMORY;
    }

    //
    // Mark image thunk data read/write
    //

    PVOID BaseAddress = (PVOID)&ImageThunkData->u1.Function;
    SIZE_T RegionSize = sizeof(ImageThunkData->u1.Function);
    ULONG OldProtect;

    Status = NtProtectVirtualMemory(&BaseAddress, &RegionSize,
                PAGE_READWRITE, &OldProtect);

    if (NT_SUCCESS(Status)) {
        ImageThunkData->u1.Function = (ULONG_PTR)Thunk;
        InterceptThunks[OrdinalNumber] = Thunk;
        CertSpyFlushICache();
    }

    return Status;
}

NTSTATUS
CertSpyUnhookKernelImportOrdinal(
    IN ULONG OrdinalNumber
    )
{
    NTSTATUS Status;
    PIMAGE_THUNK_DATA ImageThunkData = NULL;
    PORDINAL_THUNK Thunk;

    if (OrdinalNumber < KernelExportSize) {
        ImageThunkData = ImageThunks[OrdinalNumber];
    }

    if (!ImageThunkData) {
        return STATUS_ORDINAL_NOT_FOUND;
    }

    Thunk = InterceptThunks[OrdinalNumber];

    if (!Thunk) {
        return STATUS_SUCCESS;
    }

    //
    // Mark image thunk data read/write
    //

    PVOID BaseAddress = (PVOID)&ImageThunkData->u1.Function;
    SIZE_T RegionSize = sizeof(ImageThunkData->u1.Function);
    ULONG OldProtect;

    Status = NtProtectVirtualMemory(&BaseAddress, &RegionSize,
                PAGE_READWRITE, &OldProtect);

    if (NT_SUCCESS(Status)) {
        ImageThunkData->u1.Function = (ULONG_PTR)Thunk->ImmediateJmpAddress + \
            (ULONG_PTR)&Thunk->ImmediateJmpAddress + sizeof(Thunk->ImmediateJmpAddress);
        CertSpyFlushICache();
        InterceptThunks[OrdinalNumber] = NULL;
        DmFreePool(Thunk);
    }

    return Status;
}

NTSTATUS
CertSpyHookKernelImportThunks(
    IN PIMAGE_THUNK_DATA ImageThunkData
    )
{
    PIMAGE_EXPORT_DIRECTORY ExportDirectory;
    ULONG ExportDirectorySize;
    PULONG AddressOfFunctions;
    ULONG OrdinalNumber;
    PORDINAL_THUNK Thunk;

    //
    // Lookup the export directory from the export executable.
    //

    ExportDirectory =
        (PIMAGE_EXPORT_DIRECTORY)RtlImageDirectoryEntryToData(PsNtosImageBase,
        TRUE, IMAGE_DIRECTORY_ENTRY_EXPORT, &ExportDirectorySize);

    if (ExportDirectory == NULL) {
        return STATUS_ORDINAL_NOT_FOUND;
    }

    ASSERT(ExportDirectory->NumberOfFunctions == KernelExportSize-1);

    AddressOfFunctions = (PULONG)((ULONG)PsNtosImageBase +
        (ULONG)ExportDirectory->AddressOfFunctions);

    //
    // Loop over the image thunks and look up the ordinal number
    //

    while (ImageThunkData->u1.Function != 0) {

        OrdinalNumber = CertSpyLookupOrdinalFromExportDirectory(
                            (ULONG)PsNtosImageBase, ExportDirectory,
                            ImageThunkData->u1.Function);

        if (OrdinalNumber != ~0UL && \
            OrdinalNumber < KernelExportSize && \
            KernelExports[OrdinalNumber].FunctionName) {

            if (ImageThunks[OrdinalNumber] == NULL) {
                ImageThunks[OrdinalNumber] = ImageThunkData;
            }

            if ((KernelExportFlags[OrdinalNumber] & KEF_INTERCEPT_AT_STARTUP) && \
                InterceptThunks[OrdinalNumber] == NULL) {

                Thunk = CertSpyBuildKernelThunk(OrdinalNumber, ImageThunkData->u1.Function);

                if (Thunk) {
                    ImageThunkData->u1.Function = (ULONG_PTR)Thunk;
                    InterceptThunks[OrdinalNumber] = Thunk;
                }
            }
        }

        ImageThunkData++;
    }

    CertSpyFlushICache();

    return STATUS_SUCCESS;
}

DWORD
NTAPI
CertSpyNotificationCallback(
    ULONG Notification,
    DWORD Parameter
    )
{
    PDMN_MODLOAD Module = (PDMN_MODLOAD)Parameter;
    PXBEIMAGE_HEADER XbeImageHeader;

    if (Notification != DM_MODLOAD) {
        return 0;
    }

    //
    // There is no way to distinguish between XBE and DLL from module-load
    // notification.  One easy way to see if the XBE has just been loaded is
    // to look at XBEIMAGE_HEADER in memory but SEH isn't working at this
    // point because the interrupts are disabled. We have to check the XBE
    // file name first before trying to read the XBE image header.
    //

    if (XeImageFileName->Length == 0 || XeImageFileName->Buffer == NULL) {
        return 0;
    }

    //
    // Locate and validate XBE image header and check for kernel import thunks
    //

    XbeImageHeader = (PXBEIMAGE_HEADER)XBEIMAGE_STANDARD_BASE_ADDRESS;

    if (XbeImageHeader->Signature == XBEIMAGE_SIGNATURE &&
        XbeImageHeader->XboxKernelThunkData != NULL &&
        CertSpyXbeHasBeenLoaded == FALSE) {
        CertSpyXbeHasBeenLoaded = TRUE;
        CertSpyHookKernelImportThunks(XbeImageHeader->XboxKernelThunkData);
    }

    return 0;
}

VOID
NTAPI
DxtEntry(
    ULONG *pfUnload
    )
{
    ULONG Result;
    HRESULT hr;

    hr = DmOpenNotificationSession(DM_PERSISTENT, &DmSession);

    if (SUCCEEDED(hr)) {
        hr = DmNotify(DmSession, DM_MODLOAD,
                (PDM_NOTIFY_FUNCTION)CertSpyNotificationCallback);
    }

    if (SUCCEEDED(hr)) {
        hr = DmRegisterCommandProcessor("certspy", CertSpyCommandProcessor);
    }

    if (SUCCEEDED(hr)) {
        *pfUnload = FALSE;
    } else {
        *pfUnload = TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\utils\crctape\crctape.cpp ===
#include "precomp.h"

CCheckSum xsumBlk, xsumRed, xsumGrn, xsumMediaIn, xsumVideo;

void MsgOut(LPCSTR szFormat, ...)
{
}

CDiskFile *PstmCreateTemp(LPCSTR szName, DWORD dwFlags)
{
    CDiskFile *pstm = new CDiskFile(szName, dwFlags);
    if(!pstm->FIsOpen()) {
        delete pstm;
        pstm = NULL;
    } else
        pstm->SetDeleteOnClose(TRUE);
    return pstm;
}

BOOL FChecksumXBE(int ilyr, CXBEFile *pxbe, DWORD cblk, CTapeDevice *ptap)
{
    /* All we want to do is checksum this xbe file */
    if(!pxbe->FCalcChecksums(&xsumBlk, &xsumRed, &xsumGrn)) {
        fprintf(stderr, "error: could not process XBE file on tape %d\n", ilyr);
        return FALSE;
    }
    return TRUE;
}

BOOL FDoATape(CTapeDevice *ptap, int ilyr)
{
    CDX2MLFile xml;
    DXML *pdxml;
    CDiskFile *pstm;
    int idxr, idxi;
    DXL *pdxl;
    DWORD dwDataBlkSize;
    DWORD dwDataPerPhy;
    BOOL fRet = FALSE;
    char szName[256];
    BOOL fSawImage;
    BOOL fSawXImage;
    BYTE rgb[32768];
    int cb;

    /* Start with the XML */
    pstm = PstmCreateTemp("temp.xml", GENERIC_WRITE);
    if(!pstm) {
        fprintf(stderr, "error: could not create temp file\n");
        return FALSE;
    }
    if(!ptap->FReadFile(szName, &dwDataBlkSize, &dwDataPerPhy) ||
        0 != strcmp(szName, "DX2ML.XML") || !ptap->FCopyToStm(pstm))
    {
badxml:
        fprintf(stderr, "error: could not read read XML file from tape %d\n", ilyr);
        goto fatal;
    }
    ptap->FCloseFile();
    if(!pstm->FReopen(GENERIC_READ))
        goto badxml;
    if(!xml.FReadFile(pstm->SzName(), FALSE))
        goto badxml;
    /* TODO: validate the XML so we know we'll be able to use it */
    delete pstm;
    pstm = NULL;

    /* Now loop through the files and process the ximage when we get there */
    pdxml = xml.PdxmlGet();
    pdxl = &pdxml->rgdxl[ilyr];
    fSawImage = fSawXImage = FALSE;
    for(;ptap->FReadFile(szName, &dwDataBlkSize, &dwDataPerPhy); ptap->FCloseFile()) {
        for(idxi = 0; idxi < idxiMax; ++idxi) {
            if(pdxml->rgdxi[idxi].szNameOnTape &&
                    0 == strcmp(szName, pdxml->rgdxi[idxi].szNameOnTape))
                break;
        }
        if(idxi < idxiMax) {
            for(idxr = 0; idxr < idxrMax; ++idxr) {
                if(pdxl->rgdxrAreas[idxr].idxiImage == idxi)
                    break;
            }
            if(idxr == idxrXData) {
                fSawXImage = TRUE;
                if(!FProcessXImage(ilyr, pdxl, idxr, ptap, NULL, FChecksumXBE))
                    goto fatal;
                continue;
            } else if(idxr == idxrData) {
                fSawImage = TRUE;
                while(cb = ptap->CbRead(sizeof rgb, rgb))
                    xsumVideo.SumBytes(rgb, cb);
            }
        }
        /* This is an uninteresting file, but we need to read it anyway to make
         * sure we get the checksum right */
        while(ptap->CbRead(sizeof rgb, rgb));
    }

    if(!fSawXImage)
        fprintf(stderr, "error: never saw ximage.dat on tape %d\n", ilyr);
    else if(!fSawImage)
        fprintf(stderr, "error: never saw image.dat on tape %d\n", ilyr);
    else
        fRet = TRUE;
fatal:
    if(pstm)
        delete pstm;
    return fRet;
}

BOOL FDoBlackTape(CTapeDevice *ptap)
{
    CDX2MLFile xml;
    DXML *pdxml;
    CDiskFile *pstm;
    int ilyr, idxr, idxi;
    DXL *pdxl;
    DXR *pdxr;
    DWORD dwDataBlkSize;
    DWORD dwDataPerPhy;
    BOOL fRet = FALSE;
    char szName[256];
    BOOL fSawImage;
    BYTE rgb[32768];

    /* Start with the XML */
    pstm = PstmCreateTemp("temp.xml", GENERIC_WRITE);
    if(!pstm) {
        fprintf(stderr, "error: could not create temp file\n");
        return FALSE;
    }
    if(!ptap->FReadFile(szName, &dwDataBlkSize, &dwDataPerPhy) ||
        0 != strcmp(szName, "DX2ML.XML") || !ptap->FCopyToStm(pstm))
    {
badxml:
        fprintf(stderr, "error: could not read read XML file from tape\n");
        goto fatal;
    }
    ptap->FCloseFile();
    if(!pstm->FReopen(GENERIC_READ))
        goto badxml;
    if(!xml.FReadFile(pstm->SzName(), FALSE))
        goto badxml;
    /* TODO: validate the XML so we know we'll be able to use it */
    delete pstm;
    pstm = NULL;

    /* Now loop through the files and process the ximages when we get there */
    pdxml = xml.PdxmlGet();
    fSawImage = FALSE;
    for(;ptap->FReadFile(szName, &dwDataBlkSize, &dwDataPerPhy); ptap->FCloseFile()) {
        for(idxi = 0; idxi < idxiMax; ++idxi) {
            if(pdxml->rgdxi[idxi].szNameOnTape &&
                    0 == strcmp(szName, pdxml->rgdxi[idxi].szNameOnTape))
                break;
        }
        pdxr = NULL;
        for(ilyr = 0; !pdxr && ilyr < 2; ++ilyr) {
            pdxl = &pdxml->rgdxl[ilyr];
            for(idxr = 0; idxr < idxrMax; ++idxr) {
                if(pdxl->rgdxrAreas[idxr].idxiImage == idxi)
                    break;
            }
            if(idxr == idxrXData)
                pdxr = &pdxl->rgdxrAreas[idxr];
        }

        /* At this point, ilyr is one past the layer we actually matched */

        if(pdxr) {
            if(fSawImage > (1 << ilyr)) {
                fprintf(stderr, "error: XIMAGE0.DAT must come before XIMAGE1.DAT\n");
                goto fatal;
            }
            fSawImage |= 1 << ilyr;
            if(!FProcessXImage(ilyr - 1, pdxl, idxrXData, ptap, NULL,
                    FChecksumXBE))
                goto fatal;
        } else {
            /* This is an uninteresting file, but we need to read it anyway to make
             * sure we get the checksum right */
            while(ptap->CbRead(sizeof rgb, rgb));
        }
    }

    if(!(fSawImage & 2))
        fprintf(stderr, "error: never saw XIMAGE0.dat\n", ilyr);
    if(!(fSawImage & 4))
        fprintf(stderr, "error: never saw XIMAGE1.dat\n", ilyr);
    if(fSawImage == 6)
        fRet = TRUE;
fatal:
    if(pstm)
        delete pstm;
    return fRet;
}

int __cdecl main(int cArg, char **rgszArg)
{
    CTapeDevice tap0, tap1;
    BOOL fVerbose = FALSE;
    DWORD cb, cbRes;
    CDiskFile *pstmXdr;
    HRSRC hres;
    BOOL fSuccess = FALSE;
    PBYTE pb;

    while(++rgszArg, --cArg) {
        if(_stricmp(*rgszArg, "-verbose") == 0)
            ++fVerbose;
        else
            break;
    }

    if(cArg < 1 || cArg > 2) {
        fprintf(stderr, "usage: xboxcrctapes [-verbose] layer0-tape [layer1-tape]\n");
        return 1;
    }

    if(!tap0.FMountAsTapeOrDisk(rgszArg[0], FALSE)) {
        fprintf(stderr, "error: failed to mount %s\n", rgszArg[1]);
        return 1;
    }

    if(cArg == 2 && !tap1.FMountAsTapeOrDisk(rgszArg[1], FALSE)) {
        fprintf(stderr, "error: failed to mount %s\n", rgszArg[1]);
        return 1;
    }

    /* Get the XDR file handy in case we need it */
    pstmXdr = PstmCreateTemp("dx2ml.xdr", GENERIC_WRITE);
    if(!pstmXdr) {
noxdr:
        fprintf(stderr, "error: unable to create temporary XDR file\n");
        return 1;
    }
    hres = FindResource(GetModuleHandle(NULL), MAKEINTRESOURCE(1), "FILE");
    if(!hres)
        goto noxdr;
    pb = (PBYTE)LockResource(LoadResource(GetModuleHandle(NULL), hres));
    if(!pb)
        goto noxdr;
    cbRes = SizeofResource(GetModuleHandle(NULL), hres);
    if(pstmXdr->CbWrite(cbRes, pb) != cbRes)
        goto noxdr;
    if(!pstmXdr->FReopen(GENERIC_READ))
        goto noxdr;

    if(!tap1.FMounted()) {
        /* Black tape checksum */
        fSuccess = FDoBlackTape(&tap0);
    } else
        fSuccess = FDoATape(&tap0, 0) && FDoATape(&tap1, 1);

    delete pstmXdr;
    if(!fSuccess)
        return 1;

    /* Input media and final media checks should agree */
    if(xsumGrn.DwFinalSum() != xsumMediaIn.DwFinalSum()) {
        fprintf(stderr, "error: internal checksum error\n");
        return 1;
    }

    if(tap1.FMounted()) {
        printf("Tape 0 checksum is 0x%08X\n", tap0.DwCheckSum());
        printf("Tape 1 checksum is 0x%08X\n", tap1.DwCheckSum());
        printf("Final media checksum is 0x%08X\n", xsumGrn.DwFinalSum());
        if(fVerbose) {
            printf("Video checksum is 0x%08X\n", xsumVideo.DwFinalSum());
            printf("Black media checksum is 0x%08X\n", xsumBlk.DwFinalSum());
            printf("Red media checksum is 0x%08X\n", xsumRed.DwFinalSum());
        }
    } else {
        printf("Submission checksum is 0x%08X", tap0.DwCheckSum());
        printf("Media CRC is 0x%08X", xsumBlk.DwFinalSum());
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\utils\copytape\precomp.h ===
#include <windows.h>
#include <xsum.h>
#include <tape.h>
#include <ini.h>
#include <reg.h>
#include <lblprint.h>
#include <malloc.h>
#include <stdio.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\spy\dxt\command.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All right reserved.

Module Name:

    command.cpp

Abstract:

    This module contains routine to process external commands

--*/

#include "certspyp.h"

typedef struct {

    PCSTR Command;
    PDM_CMDPROC CommandProc;

} COMMAND_TABLE, *PCOMMAND_TABLE;

LPSTR _stristr(
    IN LPCSTR str1,
    IN LPCSTR str2
    )
{
    LPSTR cp = (LPSTR)str1;
    LPSTR s1, s2;

    if (!*str2) {
        return (LPSTR)str1;
    }

    while (*cp) {
        s1 = cp;
        s2 = (LPSTR)str2;

        while (*s1 && *s2 && _tolower(*s1) == _tolower(*s2)) {
            s1++, s2++;
        }

        if (!*s2) {
            return cp;
        }

        cp++;
    }

    return NULL;
}

LPSTR
GetParamPointer(
    IN LPCSTR szCmd,
    IN LPCSTR szName
    )
{
    if (!szCmd) {
        return NULL;
    }

    LPSTR p = _stristr(szCmd, szName);

    if (p && (p = strchr(p, '=')) != NULL) {
        p++;
        while (isspace(*p)) {
            p++;
        }
    }

    return p;
}

BOOL
GetDwordParam(
    IN LPCSTR szCmd,
    IN LPCSTR szName,
    IN LPDWORD pdwResult
    )
{
    LPSTR p = GetParamPointer(szCmd, szName);

    if (p) {
        *pdwResult = strtoul(p, NULL, 0);
    }

    return p != NULL;
}

BOOL
GetStringParam(
    IN LPCSTR szCmd,
    IN LPCSTR szName,
    OUT LPSTR* pszResult
    )
{
    *pszResult = GetParamPointer(szCmd, szName);
    return *pszResult != NULL;
}

HRESULT
WINAPI
CertSpyHookKernelImport(
    IN  PCSTR   szCommand,
    OUT PSTR    szResponse,
    IN  SIZE_T  cchResponse,
    IN  PDM_CMDCONT pdmcc
    )
{
    PSTR OrdinalList;
    ULONG OrdinalNumber;
    PSTR Token;
    HRESULT hr = S_OK;
    NTSTATUS Status;

    if (!GetStringParam(szCommand, "ordinal", &OrdinalList)) {
        return E_INVALIDARG;
    }

    Token = strtok(OrdinalList, ",");

    while (Token) {

        OrdinalNumber = strtoul(Token, NULL, 0);

        if (OrdinalNumber >= KernelExportSize) {
            hr = E_INVALIDARG;
            break;
        }

        Status = CertSpyHookKernelImportOrdinal(OrdinalNumber);

        if (!NT_SUCCESS(Status)) {
            hr = HRESULT_FROM_NT(Status);
            break;
        }

        Token = strtok(NULL, ",");
    }

    return hr;
}

HRESULT
WINAPI
CertSpyUnhookKernelImport(
    IN  PCSTR   szCommand,
    OUT PSTR    szResponse,
    IN  SIZE_T  cchResponse,
    IN  PDM_CMDCONT pdmcc
    )
{
    PSTR OrdinalList;
    ULONG OrdinalNumber;
    PSTR Token;
    HRESULT hr = S_OK;
    NTSTATUS Status;

    if (!GetStringParam(szCommand, "ordinal", &OrdinalList)) {
        return E_INVALIDARG;
    }

    Token = strtok(OrdinalList, ",");

    while (Token) {

        OrdinalNumber = strtoul(Token, NULL, 0);

        if (OrdinalNumber >= KernelExportSize) {
            hr = E_INVALIDARG;
            break;
        }

        Status = CertSpyUnhookKernelImportOrdinal(OrdinalNumber);

        if (!NT_SUCCESS(Status)) {
            hr = HRESULT_FROM_NT(Status);
            break;
        }

        Token = strtok(NULL, ",");
    }

    return hr;
}

HRESULT
WINAPI
CertSpyReportVersionInfo(
    IN PDM_CMDCONT pdmcc,
    IN PSTR szResponse,
    IN DWORD cchResponse
    )
{
    if (pdmcc->BytesRemaining++ == 1) {
        int n = _snprintf((char*)pdmcc->Buffer, pdmcc->BufferSize,
                    "version=%s maxordinal=%d",
                    VER_PRODUCTVERSION_STR, KernelExportSize);
        return n < 0 ? XBDM_BUFFER_TOO_SMALL : XBDM_NOERR;
    }

    return XBDM_ENDOFLIST;
}

HRESULT
WINAPI
CertSpyGetVersionInfo(
    IN  PCSTR   szCommand,
    OUT PSTR    szResponse,
    IN  SIZE_T  cchResponse,
    IN  PDM_CMDCONT pdmcc
    )
{
    pdmcc->HandlingFunction = CertSpyReportVersionInfo;
    pdmcc->BytesRemaining = 1;
    return XBDM_MULTIRESPONSE;
}

HRESULT
WINAPI
CertSpyReportHookList(
    IN PDM_CMDCONT pdmcc,
    IN PSTR szResponse,
    IN DWORD cchResponse
    )
{
    const size_t MaxOrdinalPerLine = 15;
    size_t NumberOfOrdinals = 0;
    size_t BufferSize = pdmcc->BufferSize;
    PORDINAL_THUNK Thunk;
    ULONG Ordinal;
    int n;

    ASSERT(pdmcc->BytesRemaining <= KernelExportSize);

    n = _snprintf((char*)pdmcc->Buffer, BufferSize, "ordinal=");

    if (n < 0) {
        return XBDM_BUFFER_TOO_SMALL;
    }

    BufferSize -= n;

    while (pdmcc->BytesRemaining) {

        pdmcc->BytesRemaining--;
        Ordinal = pdmcc->BytesRemaining;
        Thunk = InterceptThunks[Ordinal];

        if (Thunk) {

            n = _snprintf(&((char*)pdmcc->Buffer)[pdmcc->BufferSize-BufferSize],
                    BufferSize, "%s%d", NumberOfOrdinals ? "," : "", Ordinal);

            if (n < 0) {
                return XBDM_BUFFER_TOO_SMALL;
            }

            BufferSize -= n;

            if (++NumberOfOrdinals > MaxOrdinalPerLine) {
                break;
            }
        }
    }

    return NumberOfOrdinals ? XBDM_NOERR : XBDM_ENDOFLIST;
}

HRESULT
WINAPI
CertSpyGetHookList(
    IN  PCSTR   szCommand,
    OUT PSTR    szResponse,
    IN  SIZE_T  cchResponse,
    IN  PDM_CMDCONT pdmcc
    )
{
    pdmcc->HandlingFunction = CertSpyReportHookList;
    pdmcc->BytesRemaining = KernelExportSize;
    return XBDM_MULTIRESPONSE;
}

HRESULT
WINAPI
CertSpyReportImportList(
    IN PDM_CMDCONT pdmcc,
    IN PSTR szResponse,
    IN DWORD cchResponse
    )
{
    const size_t MaxOrdinalPerLine = 15;
    size_t NumberOfOrdinals = 0;
    size_t BufferSize = pdmcc->BufferSize;
    PIMAGE_THUNK_DATA Thunk;
    ULONG Ordinal;
    int n;

    ASSERT(pdmcc->BytesRemaining <= KernelExportSize);

    n = _snprintf((char*)pdmcc->Buffer, BufferSize, "ordinal=");

    if (n < 0) {
        return XBDM_BUFFER_TOO_SMALL;
    }

    BufferSize -= n;

    while (pdmcc->BytesRemaining) {

        pdmcc->BytesRemaining--;
        Ordinal = pdmcc->BytesRemaining;
        Thunk = ImageThunks[Ordinal];

        //
        // Only list function imports, won't list pointer imports
        //

        if (Thunk && KernelExports[Ordinal].FunctionName) {

            n = _snprintf(&((char*)pdmcc->Buffer)[pdmcc->BufferSize-BufferSize],
                    BufferSize, "%s%d", NumberOfOrdinals ? "," : "", Ordinal);

            if (n < 0) {
                return XBDM_BUFFER_TOO_SMALL;
            }

            BufferSize -= n;

            if (++NumberOfOrdinals > MaxOrdinalPerLine) {
                break;
            }
        }
    }

    return NumberOfOrdinals ? XBDM_NOERR : XBDM_ENDOFLIST;
}

HRESULT
WINAPI
CertSpyGetImportList(
    IN  PCSTR   szCommand,
    OUT PSTR    szResponse,
    IN  SIZE_T  cchResponse,
    IN  PDM_CMDCONT pdmcc
    )
{
    pdmcc->HandlingFunction = CertSpyReportImportList;
    pdmcc->BytesRemaining = KernelExportSize;
    return XBDM_MULTIRESPONSE;
}

//
// Command table lookup, this list must be sorted
//

const COMMAND_TABLE CertSpyCommandTable[] = {
    { "hookkernel",     CertSpyHookKernelImport     },
    { "hooklist",       CertSpyGetHookList          },
    { "importlist",     CertSpyGetImportList        },
    { "unhookkernel",   CertSpyUnhookKernelImport   },
    { "version",        CertSpyGetVersionInfo       },
};

HRESULT
WINAPI
CertSpyCommandProcessor(
    IN  PCSTR   szCommand,
    OUT PSTR    szResponse,
    IN  SIZE_T  cchResponse,
    IN  PDM_CMDCONT pdmcc
    )
{
    const COMMAND_TABLE* pCmdTable;
    int min, middle, max;

    PCSTR pCmd = strchr(szCommand, '!');

    if (!pCmd) {
        return E_UNEXPECTED;
    } else {
        pCmd++;
    }

    //
    // Binary search for command procedure from command table
    //

    min = 0;
    max = ARRAYSIZE(CertSpyCommandTable);

    while (min < max) {

        middle = (min + max) / 2;
        pCmdTable = &CertSpyCommandTable[middle];

        int n = _strnicmp(pCmdTable->Command, pCmd, strlen(pCmdTable->Command));

        if (n == 0) {
            break;
        } else if (n < 0) {
            min = middle + 1;
        } else {
            max = middle;
        }
    }

    if (min >= max) {
        return XBDM_INVALIDCMD;
    }

    return pCmdTable->CommandProc(szCommand, szResponse, cchResponse, pdmcc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\utils\crctape\precomp.h ===
#include <windows.h>
#include <stdio.h>
#include <atlbase.h>
#include <msxml.h>
#include <xsum.h>
#include <tape.h>
#include <xbefile.h>
#include <dx2ml.h>
#include <ximg.h>
#include <malloc.h>
#include <time.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\utils\xbeimport\xbeimportp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xbeimportp.h

Abstract:

    This is a pre-compiled header module for xbeimport utility.

--*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#include <xbeimage.h>

#ifndef ARRAYSIZE
#define ARRAYSIZE(a) (sizeof(a)/sizeof((a)[0]))
#endif

#ifndef PAGE_SIZE
#define PAGE_SIZE 0x1000
#endif

#ifndef ROUND_TO_PAGES
#define ROUND_TO_PAGES(Size) (((ULONG_PTR)(Size) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\utils\tape2gdf\tape2gdf.h ===
/*
 *
 * tape2gdf.h
 *
 * Build a compacted GDF image from tape images
 *
 */

#include <windows.h>
#include <atlbase.h>
#include <msxml.h>
#include <stdio.h>
#include <xsum.h>
#include <tape.h>
#include <malloc.h>
#include <dx2ml.h>
#include <xbefile.h>
#include <gdformat.h>
#include <gdfdir.h>
#include <time.h>
#include <xboxdbg.h>

class GDQ {
public:
    GDQ(void) { m_pgdqeFirst = NULL; m_ppgdqeLast = &m_pgdqeFirst; }
    ~GDQ() { while(PopDir()); }

    void PushDir(GDIR *pgdir);
    GDIR *PopDir(void);

private:
    struct GDQE {
        GDQE *pgdqeNext;
        GDIR *pgdir;
    };

    GDQE *m_pgdqeFirst;
    GDQE **m_ppgdqeLast;
};

class CTapeDevice2 : public CTapeDevice
{
    friend class CBasedFile;
};

class CBasedFile : public CDiskFile
{
public:
    CBasedFile(CTapeDevice2 *ptap);
    CBasedFile(CDiskFile *pstm);
    virtual BOOL FSeek(LARGE_INTEGER li);
    virtual BOOL FSeek(LONG l);
private:
    LARGE_INTEGER m_liBase;
};

class CXboxDVDFile : public CFileStmRandWithCopy
{
public:
    CXboxDVDFile(void);
    virtual BOOL FIsOpen(void) { return m_pdcon != NULL; }
    virtual DWORD CbRead(DWORD cb, PBYTE pbBuf);
    virtual DWORD CbWrite(DWORD cb, const BYTE *pbBuf) { return 0; }
    virtual ~CXboxDVDFile();
    virtual BOOL FSeek(LARGE_INTEGER li);
    virtual BOOL FSeek(LONG l);
private:
    PDM_CONNECTION m_pdcon;
    ULONG m_iblkCur;
    BYTE m_rgbCur[2048];
    ULONG m_ibCur;
};

struct FOBJ
{
    FOBJ(LPCSTR szName, DWORD dwBlk, PGDF_DIRECTORY_ENTRY pgdeIn,
        GDIR *pgdirIn=NULL, DWORD dwBinBlkIn=0)
    {
        memset(this, 0, sizeof *this);
        dwBlkOrig = dwBlk;
        pgde = pgdeIn;
        pgdir = pgdirIn;
        dwBinBlk = dwBinBlkIn;
        if(szName)
            szFullName = _strdup(szName);
    }
    FOBJ *pfobjNext;
    DWORD dwBlkOrig;
    DWORD cblk;
    LPSTR szFullName;
    PGDF_DIRECTORY_ENTRY pgde;
    GDIR *pgdir;
    BOOL fXbe;
    DWORD dwBlkNew;
    CDiskFile *pstmNew;
    DWORD dwBinBlk;

    BOOL FOverlapsWithPlaceholder(void);
};

class CFST : public CDiskFile
{
public:
    CFST(char *szFileName) : CDiskFile(szFileName, GENERIC_WRITE) {
        m_fInited = FIsOpen() ? true : false;
    }

    bool IsInited() {
        return m_fInited;
    }
    BOOL FFlush(CDiskFile *pfssBinFile, CDiskFile *pfssIsoFile);
    
private:
    bool m_fInited;
};

class CFunctestCrypt : public CSimpleCrypt
{
public:
    CFunctestCrypt(void) : CSimpleCrypt(rgbPublicKey, rgbPrivateKey) {}
private:
    static const BYTE rgbPrivateKey[];
    static const BYTE rgbPublicKey[];
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\crypto\sources.inc ===
TARGETPATH=$(BASEDIR)\private\lib
TARGETTYPE=LIBRARY

#USER_C_FLAGS=/P /C


INCLUDES=$(BASEDIR)\private\inc\crypto; \
         $(BASEDIR)\public\sdk\inc; \
         $(BASEDIR)\private\ntos\inc; \
         $(BASEDIR)\public\sdk\inc\crt 
          
SOURCES= xcbase.c  \
         umkm.c

UMTYPE=console
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\crypto\umkm.c ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    umkm.c

Abstract:

    Implements memory allocation functions required by RSA32K.LIB


--*/

#ifdef KMODE_RNG

#include <ntos.h>

void*
__stdcall
RSA32Alloc(unsigned long size)
{
    return (void*)ExAllocatePoolWithTag(size, 'yrCX');
}

void
__stdcall
RSA32Free(void* mem)
{
    ExFreePool(mem);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\crypto\umkm.h ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    umkm.h

Abstract:


--*/


#ifndef _UMKM_H
#define _UMKM_H

#ifdef KMODE_RNG

//#include <rsa_sys.h>

// 
// kernel mode
//
#define ALLOC(cb) RSA32Alloc(cb)
#define FREE(pv) RSA32Free(pv)

void* __stdcall RSA32Alloc(unsigned long cb);
void __stdcall RSA32Free(void* pv);


#else

// 
// user mode
//

#define ALLOC(cb) LocalAlloc(0, cb)
#define FREE(pv) LocalFree(pv)

#endif  // KMODE_RSA32

#endif  // _UMKM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\utils\tape2gdf\funcsign.cpp ===
/*
 *
 * funcsign.cpp
 *
 * Functional test kernel key
 *
 */

#include "tape2gdf.h"

const BYTE CFunctestCrypt::rgbPublicKey[284] = 
    {
           0x52,0x53,0x41,0x31,0x08,0x01,0x00,0x00,
           0x00,0x08,0x00,0x00,0xFF,0x00,0x00,0x00,
           0x01,0x00,0x01,0x00,0x05,0xBD,0x51,0xB1,
           0x80,0x1F,0x6D,0x8F,0x63,0xBE,0x4F,0xEE,
           0x70,0x2C,0xE3,0x5D,0x7A,0x85,0x40,0x24,
           0x48,0x04,0x2D,0xE0,0xA8,0xC2,0x2E,0x0B,
           0xF8,0xC7,0x8D,0x43,0xF4,0xF9,0x74,0xBA,
           0xD6,0xD9,0x61,0x90,0xC4,0xD5,0x73,0x7B,
           0xF2,0xD7,0x94,0xCE,0x07,0x24,0x9E,0xCF,
           0xC0,0x88,0x20,0xEC,0x96,0x22,0xDF,0x80,
           0x32,0xDB,0x0C,0x41,0x25,0xB8,0xB0,0x89,
           0x46,0x25,0xBB,0x67,0xD4,0xDF,0x5F,0x19,
           0xAB,0xB3,0x27,0xFA,0x55,0x19,0x1C,0x77,
           0xAB,0xB2,0xB5,0x42,0xE7,0xA7,0x30,0x03,
           0xA6,0xD6,0x9F,0x81,0x02,0x07,0x3C,0x81,
           0x3E,0x61,0xD2,0xF8,0x1A,0x75,0x8F,0x2B,
           0xC4,0xE9,0x92,0x8A,0x13,0xAD,0xC5,0x02,
           0xFE,0x00,0x88,0x52,0xEE,0x13,0xB0,0x54,
           0xB8,0x96,0x16,0x76,0xF0,0x1E,0x49,0x7D,
           0x02,0x78,0xF5,0x7C,0x97,0x80,0xC4,0xC3,
           0x17,0xB3,0x37,0x01,0x16,0x50,0x3C,0x50,
           0x8A,0xF5,0xBE,0x29,0x08,0xEA,0xDE,0x07,
           0x2C,0xA0,0xEA,0x20,0xFF,0x7F,0x8B,0x44,
           0xC1,0x2A,0x07,0x4C,0x50,0x8A,0xA6,0xFB,
           0x48,0xDA,0xBB,0xEB,0xE7,0xBC,0x3A,0xD2,
           0x25,0xBA,0x8F,0xF6,0xB2,0x76,0xD4,0x77,
           0x90,0x1A,0x94,0x5A,0xE4,0xB4,0x04,0x0F,
           0x4A,0x91,0x29,0x2B,0xA8,0x3E,0x14,0xB3,
           0x9A,0x90,0x57,0x2D,0x5F,0x31,0xC0,0xA2,
           0xBD,0xF8,0x98,0xBE,0xDA,0x81,0x17,0x6D,
           0x95,0x0E,0x13,0xE4,0x12,0x73,0x17,0x94,
           0x3B,0x2B,0x6B,0x21,0x61,0x00,0x1B,0x78,
           0xA0,0x69,0x1C,0x7F,0x77,0x39,0x27,0xF8,
           0x76,0xF2,0x73,0x84,0xB2,0x1A,0xB8,0x80,
           0x76,0xF1,0x8C,0xAF,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00
    };

const BYTE CFunctestCrypt::rgbPrivateKey[1340] =
    {
           0x52,0x53,0x41,0x32,0x08,0x01,0x00,0x00,
           0x00,0x08,0x00,0x00,0xFF,0x00,0x00,0x00,
           0x01,0x00,0x01,0x00,0x05,0xBD,0x51,0xB1,
           0x80,0x1F,0x6D,0x8F,0x63,0xBE,0x4F,0xEE,
           0x70,0x2C,0xE3,0x5D,0x7A,0x85,0x40,0x24,
           0x48,0x04,0x2D,0xE0,0xA8,0xC2,0x2E,0x0B,
           0xF8,0xC7,0x8D,0x43,0xF4,0xF9,0x74,0xBA,
           0xD6,0xD9,0x61,0x90,0xC4,0xD5,0x73,0x7B,
           0xF2,0xD7,0x94,0xCE,0x07,0x24,0x9E,0xCF,
           0xC0,0x88,0x20,0xEC,0x96,0x22,0xDF,0x80,
           0x32,0xDB,0x0C,0x41,0x25,0xB8,0xB0,0x89,
           0x46,0x25,0xBB,0x67,0xD4,0xDF,0x5F,0x19,
           0xAB,0xB3,0x27,0xFA,0x55,0x19,0x1C,0x77,
           0xAB,0xB2,0xB5,0x42,0xE7,0xA7,0x30,0x03,
           0xA6,0xD6,0x9F,0x81,0x02,0x07,0x3C,0x81,
           0x3E,0x61,0xD2,0xF8,0x1A,0x75,0x8F,0x2B,
           0xC4,0xE9,0x92,0x8A,0x13,0xAD,0xC5,0x02,
           0xFE,0x00,0x88,0x52,0xEE,0x13,0xB0,0x54,
           0xB8,0x96,0x16,0x76,0xF0,0x1E,0x49,0x7D,
           0x02,0x78,0xF5,0x7C,0x97,0x80,0xC4,0xC3,
           0x17,0xB3,0x37,0x01,0x16,0x50,0x3C,0x50,
           0x8A,0xF5,0xBE,0x29,0x08,0xEA,0xDE,0x07,
           0x2C,0xA0,0xEA,0x20,0xFF,0x7F,0x8B,0x44,
           0xC1,0x2A,0x07,0x4C,0x50,0x8A,0xA6,0xFB,
           0x48,0xDA,0xBB,0xEB,0xE7,0xBC,0x3A,0xD2,
           0x25,0xBA,0x8F,0xF6,0xB2,0x76,0xD4,0x77,
           0x90,0x1A,0x94,0x5A,0xE4,0xB4,0x04,0x0F,
           0x4A,0x91,0x29,0x2B,0xA8,0x3E,0x14,0xB3,
           0x9A,0x90,0x57,0x2D,0x5F,0x31,0xC0,0xA2,
           0xBD,0xF8,0x98,0xBE,0xDA,0x81,0x17,0x6D,
           0x95,0x0E,0x13,0xE4,0x12,0x73,0x17,0x94,
           0x3B,0x2B,0x6B,0x21,0x61,0x00,0x1B,0x78,
           0xA0,0x69,0x1C,0x7F,0x77,0x39,0x27,0xF8,
           0x76,0xF2,0x73,0x84,0xB2,0x1A,0xB8,0x80,
           0x76,0xF1,0x8C,0xAF,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0xC7,0x74,0x06,0xD1,
           0x46,0x71,0x92,0xC3,0x1D,0x01,0x51,0xBA,
           0xAF,0xB7,0x7C,0x0E,0x61,0xD6,0xB7,0x97,
           0x70,0xDB,0x3F,0xBA,0x38,0x32,0xB3,0x5F,
           0x7E,0x9A,0xB1,0x11,0x43,0x85,0x95,0x3B,
           0x2C,0xAB,0x21,0x48,0x91,0x18,0x1B,0x04,
           0xC1,0x04,0xDB,0xBE,0x28,0xCB,0xD0,0x81,
           0x29,0xDC,0x71,0x60,0xF4,0x9C,0x9A,0xE9,
           0x96,0x75,0x86,0xC9,0x61,0x73,0x39,0x85,
           0xBC,0x34,0xC7,0x18,0x6B,0x8A,0x5D,0x04,
           0x93,0x66,0x05,0xA8,0x7F,0xC3,0xF7,0x15,
           0xD9,0x4C,0x12,0x5A,0x78,0x67,0xC7,0x26,
           0x67,0x6B,0xE0,0x8F,0xF0,0xCE,0xB9,0x32,
           0xD3,0x60,0x1F,0x23,0x7D,0xFF,0xFB,0x75,
           0x08,0xA1,0x4E,0xF6,0x5A,0xDB,0x49,0x94,
           0x8C,0x22,0x0F,0x9F,0x51,0x6F,0x4B,0x52,
           0xC2,0x15,0x20,0xD8,0x00,0x00,0x00,0x00,
           0xD3,0x9B,0x5D,0x4C,0xF0,0x0B,0x66,0x2E,
           0xD0,0x91,0xEB,0xFC,0x11,0x7E,0xBD,0xB7,
           0xAB,0xDA,0x7A,0x9A,0x8F,0xCF,0x4B,0x28,
           0x26,0xB6,0x1E,0x6B,0x8A,0xE7,0xB5,0xC5,
           0xF6,0x92,0xE1,0x12,0x36,0x49,0x17,0x9A,
           0x39,0xE6,0x2C,0x36,0x34,0x3B,0x88,0xCC,
           0xBB,0xFE,0xC4,0xEC,0x03,0x0F,0x2C,0x1F,
           0x3F,0xDD,0xE7,0xF9,0x3B,0x16,0xC9,0xB4,
           0x6E,0xD7,0xE0,0x45,0x9D,0xFA,0x97,0x2A,
           0xEA,0xDC,0x9B,0x4B,0xEC,0x5B,0x92,0x2E,
           0x05,0xEC,0xEB,0xC1,0x9E,0xC1,0x66,0x60,
           0x35,0xC1,0x84,0x31,0xDD,0x63,0x10,0x92,
           0xB8,0x0B,0x0F,0xE2,0x32,0x44,0x1C,0xC0,
           0x28,0x41,0x30,0x29,0x85,0x4D,0xCD,0x93,
           0xBE,0xA2,0x57,0xBC,0x20,0xDE,0x09,0xFA,
           0xFF,0x0F,0x44,0xB1,0xD4,0x73,0xF0,0xCF,
           0x00,0x00,0x00,0x00,0xC1,0xE2,0x1F,0xAA,
           0x46,0xF8,0x29,0x77,0xCE,0xAB,0x41,0xA6,
           0x2F,0xE5,0xAB,0xA8,0xA0,0xA6,0x65,0xB5,
           0x18,0x48,0x2E,0xA1,0x54,0x4A,0x3F,0x2B,
           0xEC,0x46,0x07,0x18,0x37,0xE4,0x64,0x21,
           0x2D,0x6A,0xCA,0xE0,0xF2,0x34,0x12,0x10,
           0x81,0xA2,0xDD,0x29,0x84,0x73,0x34,0x21,
           0x02,0x40,0x20,0x6E,0x6B,0x6D,0xB9,0x9F,
           0x54,0xD1,0x3B,0x4C,0x3D,0x40,0xD8,0xA6,
           0x9B,0x44,0x95,0x21,0x9D,0x1D,0x54,0xFD,
           0xB6,0x4D,0x1B,0x3C,0xF6,0x69,0x32,0x6A,
           0x63,0x82,0x70,0x1E,0x40,0xE4,0x92,0x6C,
           0xE3,0xA1,0x5D,0xD4,0x89,0x12,0x7C,0x51,
           0x84,0x28,0xB9,0x95,0x6A,0x72,0xA7,0xF0,
           0x7D,0x4B,0x94,0x87,0xA6,0x48,0xCE,0x47,
           0x4E,0x1A,0x9A,0x7D,0x2F,0xF9,0xBB,0xAA,
           0xAB,0x40,0x9D,0xB5,0x00,0x00,0x00,0x00,
           0x65,0x39,0x11,0xC0,0x21,0x24,0x88,0x06,
           0xCF,0x5C,0x77,0xAA,0xB7,0x89,0x01,0x0A,
           0xCA,0x95,0x1B,0x75,0xC0,0xDF,0x7E,0x74,
           0x62,0x5D,0x0D,0x1E,0x25,0x87,0xF8,0x33,
           0xC7,0x74,0x4E,0x74,0xD4,0xF5,0x0C,0xE6,
           0xAB,0x12,0xC5,0x7B,0x29,0x8A,0xB6,0x0E,
           0xBB,0x42,0x7B,0x43,0x64,0x27,0xC6,0xA1,
           0x1E,0x74,0x6E,0xDF,0x28,0xCA,0x9B,0x90,
           0xB2,0x98,0x73,0xEE,0xE0,0xEF,0x52,0x5F,
           0xDC,0xA0,0x69,0xF7,0xD5,0x54,0x00,0x65,
           0x39,0xD2,0x0B,0x51,0xEA,0x0D,0x71,0xA5,
           0xC6,0x51,0xD6,0x83,0xB5,0x79,0xC3,0x7F,
           0xA0,0x81,0x1C,0x59,0x51,0xE2,0x32,0x48,
           0x96,0xAF,0xE6,0x40,0x57,0x86,0x99,0x08,
           0x0D,0x9B,0xF3,0xEE,0xAE,0x31,0x5F,0xFA,
           0x52,0x22,0x93,0xD8,0xD3,0x8E,0x3E,0x73,
           0x00,0x00,0x00,0x00,0x0A,0x16,0xA7,0x66,
           0x2A,0x6A,0x2C,0xF6,0xB8,0x15,0x13,0xEF,
           0xD1,0xB6,0x1E,0xB9,0x3F,0x77,0x86,0x1F,
           0xFF,0xA7,0xAD,0x59,0x0D,0xDE,0xE4,0xAB,
           0xB9,0x83,0x30,0x65,0xAD,0xBC,0x9F,0x61,
           0xAD,0x6D,0x2B,0xAA,0xEB,0x86,0x66,0xC4,
           0x11,0x2E,0xA6,0x11,0x27,0xE8,0x76,0xB5,
           0x40,0x1B,0x70,0xD1,0x3D,0xF0,0xD8,0x07,
           0xE9,0xAC,0x84,0xE0,0xE3,0x5E,0x94,0x06,
           0xAA,0x14,0xB8,0x19,0x30,0xB9,0xB1,0x57,
           0x4A,0x90,0x8B,0x97,0xEF,0xA5,0x01,0xEE,
           0xCB,0xC2,0xB7,0x22,0xF2,0xA8,0x1F,0xC3,
           0x31,0x0E,0x53,0xC2,0x4A,0x49,0x6D,0x5B,
           0xD4,0x91,0xE1,0xD1,0x48,0x10,0x9B,0x77,
           0x73,0x68,0xD0,0xF7,0x47,0x9B,0x55,0x69,
           0x76,0xE8,0x05,0xBF,0xDC,0x58,0x07,0xB6,
           0xE9,0x0F,0x27,0x68,0x00,0x00,0x00,0x00,
           0xE5,0x9D,0x16,0x87,0x6C,0x6B,0x8A,0x7B,
           0xEE,0x8D,0xED,0x1D,0xA3,0x46,0x70,0x2F,
           0xD3,0x1F,0x91,0xF3,0x1D,0xE9,0x62,0x82,
           0xF9,0xB9,0x4C,0xFA,0x9C,0x26,0x62,0x2B,
           0x19,0x02,0xEB,0xEB,0xC8,0x60,0xD7,0x14,
           0x84,0xDE,0xA5,0x71,0xBD,0x0B,0x00,0x8E,
           0x84,0x54,0xC4,0x81,0x2F,0xDB,0x24,0xF2,
           0x5E,0xCF,0xB5,0xE5,0x1A,0x12,0xAE,0x62,
           0xF3,0xF2,0x53,0x97,0x7D,0xC7,0x62,0xA5,
           0xCA,0xB4,0xC2,0x39,0xD6,0x99,0x9F,0xF6,
           0x36,0x96,0xA5,0x87,0xBF,0x0D,0x15,0x6D,
           0xEB,0x59,0x66,0xD9,0xE6,0x6C,0x83,0xBE,
           0x52,0x21,0x7C,0x60,0xD0,0x2E,0x7E,0xF1,
           0x34,0x6D,0x6B,0xAC,0x7B,0xEB,0xC2,0x38,
           0xC9,0x4E,0xFF,0xB5,0x58,0xFD,0xC6,0x26,
           0xD5,0x09,0x1D,0x8A,0x57,0x0C,0xB2,0x87,
           0x5F,0xF2,0xD5,0x4C,0x1A,0xA9,0x34,0x26,
           0x85,0x95,0xB0,0x82,0x15,0xFE,0xA0,0x8C,
           0x11,0x42,0xE5,0x02,0xAF,0x3D,0xE7,0xBA,
           0x95,0x41,0xB9,0xF5,0xB3,0xAC,0xFF,0xE4,
           0x7D,0xCC,0x47,0x02,0x67,0x14,0x0A,0x12,
           0xC7,0x90,0x04,0xB3,0x87,0x9A,0xE2,0xB3,
           0xD2,0x50,0xEA,0xF4,0xF8,0x6B,0x8D,0xD2,
           0x36,0x8A,0x86,0xD0,0x96,0x69,0x1C,0xEE,
           0x48,0xF1,0x16,0x1F,0x5E,0x9A,0x53,0x09,
           0x59,0x6D,0x43,0xD1,0x80,0x93,0xA8,0x9A,
           0x75,0x8B,0x7E,0x34,0x79,0x7F,0xD1,0x65,
           0x5C,0x93,0x65,0x0E,0xAE,0xFE,0x72,0x31,
           0x54,0x0C,0xBF,0xC4,0x30,0x8B,0xBD,0x04,
           0x4D,0xE5,0x85,0xC1,0x88,0xBD,0xB2,0x14,
           0xA5,0x6C,0xCA,0x0A,0x9F,0x5C,0x95,0x64,
           0x8D,0x5A,0x91,0x92,0x48,0x6B,0x81,0xA2,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00
    };
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\utils\tape2gdf\tape2gdf.cpp ===
/*
 *
 * tape2gdf.cpp
 *
 * Build a compacted GDF image from tape images
 *
 */

#include "tape2gdf.h"

CBasedFile *pstmL0, *pstmL1;
CXboxDVDFile *pxdvd;
FOBJ *g_pfobjFirst;
GDF_VOLUME_DESCRIPTOR gvd;
CDX2MLFile g_xml;
DXML *g_pdxml;
CCryptContainer *pccSign;
CDevkitCrypt ccDev;

BOOL FWriteDirTree(GDIR *pgdir, CFileStmSeq *pstm, int *piblkCur, int *piblkDir)
{
    GDIR *pgdirT;
    PGDF_DIRECTORY_ENTRY pgde;

    /* We enumerate all of our entries, and for each child directory, we
     * ask that child to write itself out.  Once that's done, we've got all
     * of the updated block numbers for all of our own entries, so we write
     * ourselves out */
    pgdir->ResetWalk();
    while(pgde = pgdir->PgdeGetNextEntry()) {
        if(pgde->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            pgdirT = (GDIR *)pgde->FirstSector;
            if(!FWriteDirTree(pgdirT, pstm, piblkCur, (int *)&pgde->FirstSector))
                return FALSE;
            delete pgdirT;
        }
    }

    *piblkDir = *piblkCur;
    *piblkCur += (pgdir->CbSize() + 2047) / 2048;
    return pgdir->FWriteToStm(pstm);
}

void GDQ::PushDir(GDIR *pgdir)
{
    GDQE *pgdqe = new GDQE;

    pgdqe->pgdir = pgdir;
    pgdqe->pgdqeNext = NULL;

    *m_ppgdqeLast = pgdqe;
    m_ppgdqeLast = &pgdqe->pgdqeNext;
}

GDIR *GDQ::PopDir(void)
{
    GDQE *pgdqe = m_pgdqeFirst;
    GDIR *pgdir;

    if(!pgdqe)
        return NULL;

    pgdir = pgdqe->pgdir;
    m_pgdqeFirst = pgdqe->pgdqeNext;
    delete pgdqe;
    if(!m_pgdqeFirst)
        m_ppgdqeLast = &m_pgdqeFirst;
    return pgdir;
}

void SortFobjList(FOBJ **ppfobj)
{
    FOBJ *pfobj1;
    FOBJ *pfobj2;
    FOBJ **ppfobj1;
    FOBJ **ppfobj2;

    pfobj1 = *ppfobj;
    if(!pfobj1 || !pfobj1->pfobjNext)
        return;

    ppfobj1 = ppfobj2 = &pfobj1;
    while(*ppfobj2) {
        ppfobj2 = &(*ppfobj2)->pfobjNext;
        if(*ppfobj2) {
            ppfobj1 = &(*ppfobj1)->pfobjNext;
            ppfobj2 = &(*ppfobj2)->pfobjNext;
        }
    }
    pfobj2 = *ppfobj1;
    *ppfobj1 = NULL;

    SortFobjList(&pfobj1);
    SortFobjList(&pfobj2);

    ppfobj1 = ppfobj;
    while(pfobj1 || pfobj2) {
        if(!pfobj1)
            ppfobj2 = &pfobj2;
        else if(!pfobj2)
            ppfobj2 = &pfobj1;
        else if(pfobj1->dwBlkOrig < pfobj2->dwBlkOrig)
            ppfobj2 = &pfobj1;
        else
            ppfobj2 = &pfobj2;
        *ppfobj1 = *ppfobj2;
        ppfobj1 = &(*ppfobj1)->pfobjNext;
        *ppfobj2 = (*ppfobj2)->pfobjNext;
    }
    *ppfobj1 = NULL;
}

void PushFobj(FOBJ *pfobj)
{
    /* Make sure this file doesn't overlap a placeholder */
    if(g_pdxml && pfobj->FOverlapsWithPlaceholder()) {
        fprintf(stderr, "warning: %s overlaps a placeholder\n",
            pfobj->szFullName);
    }
    pfobj->pfobjNext = g_pfobjFirst;
    g_pfobjFirst = pfobj;
}

CBasedFile::CBasedFile(CTapeDevice2 *ptap) : CDiskFile((HANDLE)NULL)
{
    LARGE_INTEGER li;

    if(ptap->m_ptod) {
        li.QuadPart = 0;
        if(SetFilePointerEx(ptap->m_hdev, li, &m_liBase, FILE_CURRENT))
            m_hFile = ptap->m_hdev;
    }
}

CBasedFile::CBasedFile(CDiskFile *pstm) : CDiskFile(*pstm)
{
    m_liBase.QuadPart = 0;
}

BOOL CBasedFile::FSeek(LONG l)
{
    LARGE_INTEGER li;

    li.QuadPart = l + m_liBase.QuadPart;
    return CDiskFile::FSeek(li);
}

BOOL CBasedFile::FSeek(LARGE_INTEGER li)
{
    li.QuadPart += m_liBase.QuadPart;
    return CDiskFile::FSeek(li);
}

CXboxDVDFile::CXboxDVDFile(void)
{
    if(FAILED(DmOpenConnection(&m_pdcon)))
        m_pdcon = NULL;
    m_iblkCur = 0;
    m_ibCur = sizeof m_rgbCur;
}

CXboxDVDFile::~CXboxDVDFile()
{
    if(m_pdcon)
        DmCloseConnection(m_pdcon);
}

DWORD CXboxDVDFile::CbRead(DWORD cb, PBYTE pb)
{
    HRESULT hr;
    DWORD cbT;
    char sz[64];
    DWORD cbRet = 0;

    while(cb) {
        if(m_ibCur < sizeof m_rgbCur) {
            cbT = sizeof m_rgbCur - m_ibCur;
            if(cbT > cb)
                cbT = cb;
            memcpy(pb, m_rgbCur + m_ibCur, cbT);
            m_ibCur += cbT;
            pb += cbT;
            cb -= cbT;
            cbRet += cbT;
            continue;
        }
        sprintf(sz, "DVDBLK BLOCK=%d", m_iblkCur++);
        hr = DmSendCommand(m_pdcon, sz, NULL, NULL);
        if(hr != XBDM_BINRESPONSE)
            hr = E_FAIL;
        else
            hr = DmReceiveBinary(m_pdcon, m_rgbCur, sizeof m_rgbCur, NULL);
        if(FAILED(hr)) {
            DmCloseConnection(m_pdcon);
            m_pdcon = NULL;
            break;
        }
        m_ibCur = 0;
    }

    return cbRet;
}

BOOL CXboxDVDFile::FSeek(LARGE_INTEGER li)
{
    if(li.LowPart % 2048 != 0)
        return FALSE;
    m_iblkCur = (ULONG)(li.QuadPart / 2048);
    m_ibCur = sizeof m_rgbCur;
    return TRUE;
}

BOOL CXboxDVDFile::FSeek(LONG l)
{
    if(l % 2048 != 0 || l < 0)
        return FALSE;
    m_iblkCur = l / 2048;
    m_ibCur = sizeof m_rgbCur;
    return TRUE;
}

CFileStmSeq *PstmSeekTo(DWORD lsn)
{
    CFileStmRand *pstm;
    LARGE_INTEGER li;

    if(pxdvd)
        pstm = pxdvd;
    else if(lsn < 1715632)
        pstm = pstmL0;
    else {
        lsn -= 1715632;
        pstm = pstmL1;
    }
    li.QuadPart = lsn;
	li.QuadPart *= 2048;
    return pstm->FSeek(li) ? pstm : NULL;
}

CDiskFile *PstmCreateTemp(LPCSTR szName, DWORD dwFlags)
{
    CDiskFile *pstm = new CDiskFile(szName, dwFlags);
    if(!pstm->FIsOpen()) {
        delete pstm;
        pstm = NULL;
    } else
        pstm->SetDeleteOnClose(TRUE);
    return pstm;
}

BOOL FGetXMLData(CFileStmSeq *pstm)
{
    CDiskFile *pstmXdr;
    CDiskFile *pstmXml;
    BOOL fRet = FALSE;
    DWORD cbRes;
    HRSRC hres;
    PBYTE pb;

    /* Get the XDR file handy in case we need it */
    pstmXdr = PstmCreateTemp("dx2ml.xdr", GENERIC_WRITE);
    if(!pstmXdr) {
noxdr:
        fprintf(stderr, "error: unable to create temporary XDR file\n");
        goto fatal;
    }
    hres = FindResource(GetModuleHandle(NULL), MAKEINTRESOURCE(1), "FILE");
    if(!hres)
        goto noxdr;
    pb = (PBYTE)LockResource(LoadResource(GetModuleHandle(NULL), hres));
    if(!pb)
        goto noxdr;
    cbRes = SizeofResource(GetModuleHandle(NULL), hres);
    if(pstmXdr->CbWrite(cbRes, pb) != cbRes)
        goto noxdr;
    if(!pstmXdr->FReopen(GENERIC_READ))
        goto noxdr;

    pstmXml = PstmCreateTemp("dx2ml.xml", GENERIC_WRITE);
    if(!pstm->FCopyToStm(pstmXml))
    {
badxml:
        fprintf(stderr, "warning: could not read read XML file from tape\n");
        goto fatal;
    }
    if(!pstmXml->FReopen(GENERIC_READ))
        goto badxml;
    if(!g_xml.FReadFile(pstmXml->SzName(), FALSE))
        goto badxml;
    g_pdxml = g_xml.PdxmlGet();
    if(g_pdxml->rgdxl[0].rgdxrAreas[idxrXData].cpsnSize != 1715632 ||
        g_pdxml->rgdxl[0].rgdxrAreas[idxrXData].cpsnSize != 1715632)
    {
        g_pdxml = NULL;
        goto badxml;
    }

    fRet = TRUE;

fatal:
    delete pstmXml;
    delete pstmXdr;
    return fRet;
}

BOOL FMarkXbeFiles(void)
{
    int ilyr;
    int ixbi;
    DXL *pdxl;
    FOBJ *pfobj;
    DWORD dwBlkXml;

    ixbi = 0;
    for(ilyr = 0; ilyr < 2; ++ilyr) {
        pdxl = &g_pdxml->rgdxl[ilyr];
        if(pdxl->ixbiMac)
            break;
    }
    if(ilyr == 2)
        dwBlkXml = 2 * 1715632;
    else
        dwBlkXml = ilyr * 1715632 + pdxl->pxbi[0].lsnStart;

    for(pfobj = g_pfobjFirst; pfobj; pfobj = pfobj->pfobjNext) {
        if(pfobj->dwBlkOrig == dwBlkXml) {
            pfobj->fXbe = TRUE;
            if(++ixbi == pdxl->ixbiMac) {
                ixbi = 0;
                if(!ilyr++) {
                    pdxl = &g_pdxml->rgdxl[ilyr];
                    if(!pdxl->ixbiMac) 
                        ++ilyr;
                }
            }
            if(ilyr == 2)
                dwBlkXml = 2 * 1715632;
            else
                dwBlkXml = ilyr * 1715632 + pdxl->pxbi[0].lsnStart;
        } else if(pfobj->dwBlkOrig > dwBlkXml) {
            fprintf(stderr, "error: XBE file at block %d not in filesystem\n",
                dwBlkXml);
            return FALSE;
        }
    }

    return TRUE;
}

BOOL FSignXBE(FOBJ *pfobj, CDiskFile *pstmIn, CDiskFile *pstmOut)
{
    CXBEFile *pxbe;
    BOOL fRet = FALSE;

    pxbe = new CXBEFile(pstmIn);
    pxbe->UseCryptContainer(&ccDev);
    if(!pxbe->FVerifySignature()) {
badxbe:
        fprintf(stderr, "error: %s is not a valid XBE file\n",
            pfobj->szFullName);
        goto fatal;
    }
    pxbe->UseCryptContainer(pccSign);
    if(!pxbe->FSignFile())
        goto badxbe;
    if(!pxbe->FWriteToStm(pstmOut, pfobj->cblk * 2048))
        fprintf(stderr, "error writing to %s\n", pstmOut->SzName());
    else
        fRet = TRUE;
fatal:
    delete pxbe;
    return fRet;
}

BOOL FOBJ::FOverlapsWithPlaceholder(void)
{
    int ixph;
    DXL *pdxl;
    ULONG lsnFileStart;

    /* Any file which spans the layer transition will be considered to over-
     * lap a placeholder */
    if(pgde->FirstSector < 1715632 && pgde->FirstSector +
            (pgde->FileSize + 2047) / 2048 > 1715632)
        return TRUE;

    /* Find the first placeholder that comes after the start block of this
     * file, or the placeholder that contains the start block of this
     * file */
    if(pgde->FirstSector >= 1715632) {
        pdxl = &g_pdxml->rgdxl[1];
        lsnFileStart = pgde->FirstSector - 1715632;
    } else {
        pdxl = &g_pdxml->rgdxl[0];
        lsnFileStart = pgde->FirstSector;
    }

    for(ixph = 0; ixph < pdxl->cxph; ++ixph) {
        if(lsnFileStart < pdxl->rgxph[ixph].lsnStart)
            break;
        if(lsnFileStart >= pdxl->rgxph[ixph].lsnStart &&
                lsnFileStart < pdxl->rgxph[ixph].lsnStart + 4096)
            /* File starts inside of a placeholder */
            return TRUE;
    }

    if(ixph == pdxl->cxph)
        /* File starts after the last placeholder on the layer */
        return FALSE;

    /* Now we just need to check whether the last sector of this file falls
     * before the start of the next placeholder */
    return lsnFileStart + (pgde->FileSize + 2047) / 2048 >
        pdxl->rgxph[ixph].lsnStart;
}

int __cdecl main(int argc, char **argv)
{
    int i;
    BOOL fDvdEmu = FALSE;
    BOOL fRawImages = FALSE;
    BOOL fResign = FALSE;
    CTapeDevice2 tapSrc0, tapSrc1, *ptap;
    CDiskFile *pstmT0, *pstmT1;
    CFileStmSeq *pstmCur;
    CDiskFile *pstmOut;
    CDiskFile *pstmBinOut;
    CDiskFile *pstmCurOut;
    CFST *pfst = NULL;
    char szName[32];
    GDF_DIRECTORY_ENTRY gdeRoot;
    PGDF_DIRECTORY_ENTRY pgde;
    BYTE rgb[8192];
    int iblkCur, iblkDir;
    int iblkBinCur;
    GDIR *pgdir, *pgdirRoot, *pgdirT;
    GDQ gdq;
    DWORD cblkCur, cblk;
    char szFileName[MAX_PATH+1];
    FOBJ *pfobj;

    while(++argv, --argc) {
        if(0 == _stricmp(*argv, "-dvdemu"))
            fDvdEmu = TRUE;
        else if(0 == _stricmp(*argv, "-xbdvd"))
            pxdvd = new CXboxDVDFile;
        else if(0 == _stricmp(*argv, "-raw"))
            fRawImages = TRUE;
        else if(0 == _stricmp(*argv, "-resign")) {
            fResign = TRUE;
            pccSign = new CFunctestCrypt;
        } else
            break;
    }

    if(pxdvd && (fRawImages || fResign)) {
        fprintf(stderr, "can't use -xbdvd with -raw or -resign\n");
        return 1;
    }

    if(fRawImages && fResign) {
        fprintf(stderr, "can't use -raw and -resign together\n");
        return 1;
    }

    if(argc < (pxdvd ? 1 : 2)) {
        fprintf(stderr, "usage: tape2gdf [-dvdemu] [-raw | -resign] <image | -s> tape0 [tape1]\n");
        return 1;
    }

    if(0 == strcmp(argv[0], "-s")) {
        pstmOut = NULL;
        pstmBinOut = NULL;
    } else {
        if(fDvdEmu) {
            sprintf(szFileName, "%s.bin", argv[0]);
            pstmBinOut = new CDiskFile(szFileName, GENERIC_WRITE);
            if(!pstmBinOut->FIsOpen())
                goto noopenwrite;
            sprintf(szFileName, "%s.fst", argv[0]);
            pfst = new CFST(szFileName);
            if (!pfst->IsInited())
                goto noopenwrite;
            sprintf(szFileName, "%s.iso", argv[0]);
        } else {
            pstmBinOut = NULL;
            strcpy(szFileName, argv[0]);
        }
        pstmOut = new CDiskFile(szFileName, GENERIC_WRITE);
        if(!pstmOut->FIsOpen() || !pstmOut->FReopen(GENERIC_READ | GENERIC_WRITE)) {
noopenwrite:
            fprintf(stderr, "could not open %s!\n", szFileName);
            return 1;
        }
    }

    if(pxdvd)
        goto gottapes;

    pstmT0 = new CDiskFile(argv[1], GENERIC_READ);
    if(!pstmT0->FIsOpen()) {
noopen:
        fprintf(stderr, "could not open %s!\n", argv[1]);
        return 1;
    }
    if(fRawImages)
        pstmL0 = new CBasedFile(pstmT0);
    else if(!tapSrc0.FMount(*pstmT0, FALSE))
        goto noopen;
    
    if(argc >= 3) {
        ++argv;
        pstmT1 = new CDiskFile(argv[1], GENERIC_READ);
        if(!pstmT1->FIsOpen())
            goto noopen;
        if(fRawImages)
            pstmL1 = new CBasedFile(pstmT1);
        else if(!tapSrc1.FMount(*pstmT1, FALSE))
            goto noopen;
    }

    /* Find ximage0.dat and ximage1.dat */
    if(!fRawImages) {
        for(i = 0; i < 2; ++i) {
            ptap = i ? &tapSrc1 : &tapSrc0;
            while(ptap->FReadFile(szName, NULL, NULL)) {
                if(0 == _stricmp(szName, "XIMAGE0.DAT"))
                    pstmL0 = new CBasedFile(ptap);
                else if(0 == _stricmp(szName, "XIMAGE1.DAT"))
                    pstmL1 = new CBasedFile(ptap);
                else if(i == 0 && 0 == _stricmp(szName, "DX2ML.XML"))
                    FGetXMLData(ptap);
            }
        }
        if(!pstmL0) {
            fprintf(stderr, "never saw XIMAGE0.dat\n");
            return 1;
        }
        if(!pstmL1) {
            fprintf(stderr, "never saw XIMAGE1.dat\n");
            return 1;
        }
    }

    if(!g_pdxml) {
        if(fResign) {
            fprintf(stderr, "error: never saw valid DX2ML.XML\n");
            return 1;
        }
        fprintf(stderr, "warning: no DX2ML.XML, can't validate placeholders\n");
    }

gottapes:
    
    /* Grab the GDF volume descriptor */
    pstmCur = PstmSeekTo(GDF_VOLUME_DESCRIPTOR_SECTOR);
    if(!pstmCur || pstmCur->CbRead(2048, (PBYTE)&gvd) != 2048) {
badformat:
        fprintf(stderr, "bad image format or read error\n");
        return 1;
    }
    if(memcmp(gvd.HeadSignature, GDF_VOLUME_DESCRIPTOR_SIGNATURE,
            GDF_VOLUME_DESCRIPTOR_SIGNATURE_LENGTH) ||
            memcmp(gvd.TailSignature, GDF_VOLUME_DESCRIPTOR_SIGNATURE,
            GDF_VOLUME_DESCRIPTOR_SIGNATURE_LENGTH))
        goto badformat;

    /* Copy the original volume descriptor to the bin file */
    iblkBinCur = 0;
    if(pstmBinOut) {
        if(pstmBinOut->CbWrite(sizeof gvd, (PBYTE)&gvd) != sizeof gvd) {
binwriteerr:
            fprintf(stderr, "write error: %s\n", pstmBinOut->SzName());
            return 1;
        }
        ++iblkBinCur;
    }

    /* Read the root directory and push it on the dir stack */
    if(!pstmOut)
        printf("Root dir at %d\n", gvd.RootDirectoryFirstSector);
    pgdirRoot = new GDIR(PstmSeekTo(gvd.RootDirectoryFirstSector),
        gvd.RootDirectoryFileSize);
    if(!pgdirRoot->FGotData())
        goto badformat;
    gdq.PushDir(pgdirRoot);
    /* We need to construct a fake dir entry for the root dir */
    memset(&gdeRoot, 0, sizeof gdeRoot);
    gdeRoot.FirstSector = gvd.RootDirectoryFirstSector;
    gdeRoot.FileSize = gvd.RootDirectoryFileSize;
    PushFobj(new FOBJ("\\.", gvd.RootDirectoryFirstSector, &gdeRoot, pgdirRoot,
        iblkBinCur));
    if(pstmBinOut) {
        if(!pgdirRoot->FWriteToStm(pstmBinOut))
            goto binwriteerr;
        iblkBinCur += (gvd.RootDirectoryFileSize + 2047) / 2048;
    }

    /* Step 1: process all directories and build up a file list */
    while(pgdir = gdq.PopDir()) {
        pgdir->ResetWalk();
        while(pgde = pgdir->PgdeGetNextEntry()) {
            sprintf((LPSTR)rgb, "%s\\%.*s", pgdir->SzName(),
                pgde->FileNameLength, pgde->FileName);
            if(!pstmOut)
                printf("%s at %d\n", rgb, pgde->FirstSector);
            if(pgde->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                pgdirT = new GDIR(PstmSeekTo(pgde->FirstSector),
                    pgde->FileSize, (LPSTR)rgb);
                if(!pgdirT->FGotData())
                    goto badformat;
                if(pstmBinOut) {
                    if(!pgdirT->FWriteToStm(pstmBinOut))
                        goto binwriteerr;
                    cblk = (pgde->FileSize + 2047) / 2048;
                    iblkBinCur += cblk;
                }
                gdq.PushDir(pgdirT);
            } else
                pgdirT = NULL;
            /* If this wasn't a directory, we'll end up pushing random garbage
             * for the bin blk number, but that's OK -- we'll ignore it
             * later */
            PushFobj(new FOBJ((LPSTR)rgb, pgde->FirstSector, pgde, pgdirT,
                iblkBinCur - cblk));
        }
    }

    /* TODO: make sure \default.xbe exists, is not a directory, and
     * shows up on the XBE list with the correct block count */

    if(!pstmOut)
        /* No file output, so we're done */
        return 0;

    /* Step 2: sort the file list */
    SortFobjList(&g_pfobjFirst);
    if(fResign && !FMarkXbeFiles())
        return 1;

    /* Step 3: compact the file list */
    iblkCur = GDF_VOLUME_DESCRIPTOR_SECTOR + 1;
    pstmCurOut = pstmOut;
    for(pfobj = g_pfobjFirst; pfobj; pfobj = pfobj->pfobjNext) {
        pfobj->cblk = (pfobj->pgde->FileSize + 2047) / 2048;
        if(iblkCur + pfobj->cblk > 0x200000) {
            /* We've overflowed our 4GB limit.  If not building an emulation
             * image, we error out.  If building an emulation image, we
             * roll over into the bin file and warn that the ISO is bad */
            if(!pfst) {
toobig:
                fprintf(stderr, "error: output image is too big\n");
                return 1;
            } else if(pstmOut == pstmBinOut)
                goto toobig;
            else {
                fprintf(stderr, "warning: output image is too big to be made into an ISO image\n");
                iblkCur = iblkBinCur;
                pstmCurOut = pstmBinOut;
            }
        }
        pfobj->dwBlkNew = iblkCur;
        iblkCur += pfobj->cblk;
        pfobj->pstmNew = pstmCurOut;
        pfobj->pgde->FirstSector = pfobj->dwBlkNew;
    }

    /* Step 4: write out the files */
    memset(rgb, 0, 2048);
    pstmCurOut = pstmOut;
    for(iblkCur = 0; iblkCur < GDF_VOLUME_DESCRIPTOR_SECTOR; ++iblkCur) {
        if(pstmCurOut->CbWrite(2048, rgb) != 2048) {
writeerr:
            fprintf(stderr, "write error: %s\n", pstmCurOut->SzName());
            delete pstmCurOut;
            return 1;
        }
    }

    gvd.RootDirectoryFirstSector = gdeRoot.FirstSector;
    if(pstmOut->CbWrite(sizeof gvd, (PBYTE)&gvd) != sizeof gvd)
        goto writeerr;

    for(pfobj = g_pfobjFirst; pfobj; pfobj = pfobj->pfobjNext) {
        if(pfobj->pgdir) {
            if(!pfobj->pgdir->FWriteToStm(pfobj->pstmNew))
                goto writeerr;
        } else {
            cblk = (pfobj->pgde->FileSize + 2047) / 2048;
            pstmCur = PstmSeekTo(pfobj->dwBlkOrig);
            if(!pstmCur)
                goto badformat;
            cblk = pfobj->cblk;
            if(pfobj->fXbe) {
               pstmCurOut = PstmCreateTemp("temp.xbe", GENERIC_WRITE);
               if(!pstmCurOut) {
                   fprintf(stderr, "error: could not create temporary XBE file\n");
                   return 1;
               }
            } else
                pstmCurOut = pfobj->pstmNew;
            while(cblk) {
                cblkCur = 4;
                if(cblk < cblkCur)
                    cblkCur = cblk;
                if(pstmCur->CbRead(cblkCur * 2048, rgb) != cblkCur * 2048)
                    goto badformat;
                if(pstmCurOut->CbWrite(cblkCur * 2048, rgb) != cblkCur * 2048)
                    goto writeerr;
                cblk -= cblkCur;
            }
            if(pfobj->fXbe) {
                if(!pstmCurOut->FReopen(GENERIC_READ))
                    goto writeerr;
                if(!FSignXBE(pfobj, pstmCurOut, pfobj->pstmNew)) {
                    delete pstmCurOut;
                    return 1;
                }
                delete pstmCurOut;
            }
        }
    }

    /* Force the output files to close so their timestamps are updated */
    pstmOut->FReopen(GENERIC_READ);
    if(pstmBinOut)
        pstmBinOut->FReopen(GENERIC_READ);

    if (pfst)
    {
        if(!pfst->FReopen(GENERIC_WRITE) || !pfst->FFlush(pstmBinOut,
            pstmOut))
        {
            fprintf(stderr, "error: could not write %s\n", pfst->SzName());
            delete pfst;
            return 1;
        }
        delete pfst;
    }

    delete pstmOut;
    if(pstmBinOut)
        delete pstmBinOut;

    return 0;
}

// sTableEntry  -- Contains information about a particular entry in the FST file
struct sTableEntry
{
    // m_dwStart    -- LSN that the entry starts on
    DWORD m_dwStart;
    
    // m_dwStop     -- LSN that the entry stops on
    DWORD m_dwStop;

    // m_iDir       -- String table index for the name of the directory for the entry 
    DWORD m_iDir;

    // m_iName      -- String table index for the name of the file for the entry
    DWORD m_iName;

    // m_dwOffset   -- Offset into the entry at which to begin reading data
    DWORD m_dwOffset;
};

// Taken from AMC's file "MediaBase.h"
struct TFileHeader
{
    char m_szFileType[32]; // FST, Error Map, etc
    char m_szMediaType[32]; // DVD, CD, etc
};

struct TMediaHeader
{
    DWORD uNumSectorsLayer0;
    DWORD uNumSectorsLayer1;
    BYTE m_ImpUseArea[120];       // total = 128 bytes
};
static char *g_szVirtualDvdHeaderString = "AMC Virtual Media";

BOOL CFST::FFlush(CDiskFile *pdfBinFile, CDiskFile *pdfIsoFile)
{
    // Populate the FST file header info
    DWORD dwDummy;
    WORD wDummy;
    int cFiles;
    FOBJ *pfobj;
    char szDrive[MAX_PATH + 1];
    char szDir[MAX_PATH + 1];
    char szFile[MAX_PATH + 1];
    char szExt[MAX_PATH + 1];
    char szT[MAX_PATH + 1];

    // Write out the AMC Header information
    TFileHeader tfh;
    memset(&tfh, 0, sizeof(TFileHeader));
    strcpy(tfh.m_szFileType, g_szVirtualDvdHeaderString);
    strcpy(tfh.m_szMediaType, "Xbox DVD-ROM");
    if (CbWrite(sizeof(TFileHeader), (BYTE*)&tfh) != sizeof(TFileHeader))
        return false;

    TMediaHeader tmh;
    memset(&tmh, 0, sizeof(TMediaHeader));
    tmh.uNumSectorsLayer0 = 1715632;
    tmh.uNumSectorsLayer1 = 1715632;
    if (CbWrite(sizeof(TMediaHeader), (BYTE*)&tmh) != sizeof(TMediaHeader))
        return false;

    // Write out the byte order.
    wDummy = 0xABCD;
    if (CbWrite(2, (BYTE*)&wDummy) != 2)
        return false;

    // Write out a timestamp.
    dwDummy = time(NULL);
    if (CbWrite(4, (BYTE*)&dwDummy) != 4)
        return false;
    
    // Create the entry table
    cFiles = 1;
    for(pfobj = g_pfobjFirst; pfobj; pfobj = pfobj->pfobjNext)
        ++cFiles;
    sTableEntry *rgte = new sTableEntry[cFiles];
    if (!rgte)
        return false;

    // Create the string table that contains the full path names of all the files
    char *rgStrings = new char[3*MAX_PATH];
    if (!rgStrings)
        return false;

    int iEntry = 0;

    // Add 3 elements to string table: (0) root folder, (1) bin name, (2) iso name
    _splitpath(pdfBinFile->SzName(), szDrive, szDir, szFile, szExt);
    if(szDir[0] != '\\') {
        /* Relative path name, so find the current dir */
        GetCurrentDirectory(MAX_PATH, szDrive);
        if(szDir[0]) {
            strcpy(szT, szDir);
            if(szDrive[3])
                sprintf(szDir, "%s\\%s", szDrive + 2, szT);
            else
                sprintf(szDir, "\\%s", szT);
        } else
            sprintf(szDir, "%s\\", szDrive + 2);
    }
    strcpy(rgStrings, szDir);
    int iStringLoc = strlen(szDir);
    rgStrings[iStringLoc - 1] = 0;
    sprintf(rgStrings + iStringLoc, "%s%s", szFile, szExt);
    int iBin = iStringLoc;
    iStringLoc += strlen(rgStrings + iStringLoc) + 1;
    _splitpath(pdfIsoFile->SzName(), NULL, NULL, szFile, szExt);
    sprintf(rgStrings + iStringLoc, "%s%s", szFile, szExt);
    int iIso = iStringLoc;
    iStringLoc += strlen(rgStrings + iStringLoc) + 1;

    // Populate the entry table with our file information
    sTableEntry *pteCur = rgte;
    sTableEntry teVol;
    teVol.m_dwStart  = GDF_VOLUME_DESCRIPTOR_SECTOR;
    teVol.m_dwStop   = GDF_VOLUME_DESCRIPTOR_SECTOR;
    teVol.m_dwOffset = 0;
    teVol.m_iDir     = 0;
    teVol.m_iName    = iBin;
    for(pfobj = g_pfobjFirst; pfobj || teVol.m_dwStart != -1; ++pteCur) {
        if(!pfobj || pfobj->dwBlkOrig > teVol.m_dwStart) {
			memcpy(pteCur, &teVol, sizeof teVol);
            teVol.m_dwStart = -1;
		} else {
			pteCur->m_dwStart  = pfobj->dwBlkOrig;
			pteCur->m_dwStop   = pfobj->dwBlkOrig + pfobj->cblk - 1;
			pteCur->m_iDir     = 0;
			if(pfobj->pgdir) {
				/* Directories always come from the bin file */
				pteCur->m_dwOffset = pfobj->dwBinBlk * 2048;
				pteCur->m_iName = iBin;
			} else {
				pteCur->m_dwOffset = pfobj->dwBlkNew * 2048;
				pteCur->m_iName    = (pfobj->pstmNew == pdfBinFile) ? iBin : iIso;
			}
			pfobj = pfobj->pfobjNext;
		}
    }

    // Write out the total number of objects in the project.
    if (CbWrite(4, (BYTE*)&cFiles) != 4)
        return false;

    // Write out the full size of the string table.
    if (CbWrite(4, (BYTE*)&iStringLoc) != 4)
        return false;

    // Write out the entry table
    if (CbWrite(sizeof(sTableEntry)*cFiles, (BYTE*)rgte) !=
                sizeof(sTableEntry)*cFiles)
        return false;

    // Write out the string table
    if (CbWrite(iStringLoc, (BYTE*)rgStrings) != (DWORD)iStringLoc)
        return false;
 
    delete rgte;

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\cert\utils\xbeimport\xbeimport.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xbeimport.cpp

Abstract:

    This module contains routine to dump kernel import in XBE file.

--*/

#include "xbeimportp.h"

const PCHAR KernelExports[] = {
    "Undefined",
    "AvGetSavedDataAddress",
    "AvSendTVEncoderOption",
    "AvSetDisplayMode",
    "AvSetSavedDataAddress",
    "DbgBreakPoint",
    "DbgBreakPointWithStatus",
    "DbgLoadImageSymbols",
    "DbgPrint",
    "HalReadSMCTrayState",
    "DbgPrompt",
    "DbgUnLoadImageSymbols",
    "ExAcquireReadWriteLockExclusive",
    "ExAcquireReadWriteLockShared",
    "ExAllocatePool",
    "ExAllocatePoolWithTag",
    "ExEventObjectType",
    "ExFreePool",
    "ExInitializeReadWriteLock",
    "ExInterlockedAddLargeInteger",
    "ExInterlockedAddLargeStatistic",
    "ExInterlockedCompareExchange64",
    "ExMutantObjectType",
    "ExQueryPoolBlockSize",
    "ExQueryNonVolatileSetting",
    "ExReadWriteRefurbInfo",
    "ExRaiseException",
    "ExRaiseStatus",
    "ExReleaseReadWriteLock",
    "ExSaveNonVolatileSetting",
    "ExSemaphoreObjectType",
    "ExTimerObjectType",
    "ExfInterlockedInsertHeadList",
    "ExfInterlockedInsertTailList",
    "ExfInterlockedRemoveHeadList",
    "FscGetCacheSize",
    "FscInvalidateIdleBlocks",
    "FscSetCacheSize",
    "HalClearSoftwareInterrupt",
    "HalDisableSystemInterrupt",
    "HalDiskCachePartitionCount",
    "HalDiskModelNumber",
    "HalDiskSerialNumber",
    "HalEnableSystemInterrupt",
    "HalGetInterruptVector",
    "HalReadSMBusValue",
    "HalReadWritePCISpace",
    "HalRegisterShutdownNotification",
    "HalRequestSoftwareInterrupt",
    "HalReturnToFirmware",
    "HalWriteSMBusValue",
    "InterlockedCompareExchange",
    "InterlockedDecrement",
    "InterlockedIncrement",
    "InterlockedExchange",
    "InterlockedExchangeAdd",
    "InterlockedFlushSList",
    "InterlockedPopEntrySList",
    "InterlockedPushEntrySList",
    "IoAllocateIrp",
    "IoBuildAsynchronousFsdRequest",
    "IoBuildDeviceIoControlRequest",
    "IoBuildSynchronousFsdRequest",
    "IoCheckShareAccess",
    "IoCompletionObjectType",
    "IoCreateDevice",
    "IoCreateFile",
    "IoCreateSymbolicLink",
    "IoDeleteDevice",
    "IoDeleteSymbolicLink",
    "IoDeviceObjectType",
    "IoFileObjectType",
    "IoFreeIrp",
    "IoInitializeIrp",
    "IoInvalidDeviceRequest",
    "IoQueryFileInformation",
    "IoQueryVolumeInformation",
    "IoQueueThreadIrp",
    "IoRemoveShareAccess",
    "IoSetIoCompletion",
    "IoSetShareAccess",
    "IoStartNextPacket",
    "IoStartNextPacketByKey",
    "IoStartPacket",
    "IoSynchronousDeviceIoControlRequest",
    "IoSynchronousFsdRequest",
    "IofCallDriver",
    "IofCompleteRequest",
    "KdDebuggerEnabled",
    "KdDebuggerNotPresent",
    "IoDismountVolume",
    "IoDismountVolumeByName",
    "KeAlertResumeThread",
    "KeAlertThread",
    "KeBoostPriorityThread",
    "KeBugCheck",
    "KeBugCheckEx",
    "KeCancelTimer",
    "KeConnectInterrupt",
    "KeDelayExecutionThread",
    "KeDisconnectInterrupt",
    "KeEnterCriticalRegion",
    "MmGlobalData",
    "KeGetCurrentIrql",
    "KeGetCurrentThread",
    "KeInitializeApc",
    "KeInitializeDeviceQueue",
    "KeInitializeDpc",
    "KeInitializeEvent",
    "KeInitializeInterrupt",
    "KeInitializeMutant",
    "KeInitializeQueue",
    "KeInitializeSemaphore",
    "KeInitializeTimerEx",
    "KeInsertByKeyDeviceQueue",
    "KeInsertDeviceQueue",
    "KeInsertHeadQueue",
    "KeInsertQueue",
    "KeInsertQueueApc",
    "KeInsertQueueDpc",
    "KeInterruptTime",
    "KeIsExecutingDpc",
    "KeLeaveCriticalRegion",
    "KePulseEvent",
    "KeQueryBasePriorityThread",
    "KeQueryInterruptTime",
    "KeQueryPerformanceCounter",
    "KeQueryPerformanceFrequency",
    "KeQuerySystemTime",
    "KeRaiseIrqlToDpcLevel",
    "KeRaiseIrqlToSynchLevel",
    "KeReleaseMutant",
    "KeReleaseSemaphore",
    "KeRemoveByKeyDeviceQueue",
    "KeRemoveDeviceQueue",
    "KeRemoveEntryDeviceQueue",
    "KeRemoveQueue",
    "KeRemoveQueueDpc",
    "KeResetEvent",
    "KeRestoreFloatingPointState",
    "KeResumeThread",
    "KeRundownQueue",
    "KeSaveFloatingPointState",
    "KeSetBasePriorityThread",
    "KeSetDisableBoostThread",
    "KeSetEvent",
    "KeSetEventBoostPriority",
    "KeSetPriorityProcess",
    "KeSetPriorityThread",
    "KeSetTimer",
    "KeSetTimerEx",
    "KeStallExecutionProcessor",
    "KeSuspendThread",
    "KeSynchronizeExecution",
    "KeSystemTime",
    "KeTestAlertThread",
    "KeTickCount",
    "KeTimeIncrement",
    "KeWaitForMultipleObjects",
    "KeWaitForSingleObject",
    "KfRaiseIrql",
    "KfLowerIrql",
    "KiBugCheckData",
    "KiUnlockDispatcherDatabase",
    "LaunchDataPage",
    "MmAllocateContiguousMemory",
    "MmAllocateContiguousMemoryEx",
    "MmAllocateSystemMemory",
    "MmClaimGpuInstanceMemory",
    "MmCreateKernelStack",
    "MmDeleteKernelStack",
    "MmFreeContiguousMemory",
    "MmFreeSystemMemory",
    "MmGetPhysicalAddress",
    "MmIsAddressValid",
    "MmLockUnlockBufferPages",
    "MmLockUnlockPhysicalPage",
    "MmMapIoSpace",
    "MmPersistContiguousMemory",
    "MmQueryAddressProtect",
    "MmQueryAllocationSize",
    "MmQueryStatistics",
    "MmSetAddressProtect",
    "MmUnmapIoSpace",
    "NtAllocateVirtualMemory",
    "NtCancelTimer",
    "NtClearEvent",
    "NtClose",
    "NtCreateDirectoryObject",
    "NtCreateEvent",
    "NtCreateFile",
    "NtCreateIoCompletion",
    "NtCreateMutant",
    "NtCreateSemaphore",
    "NtCreateTimer",
    "NtDeleteFile",
    "NtDeviceIoControlFile",
    "NtDuplicateObject",
    "NtFlushBuffersFile",
    "NtFreeVirtualMemory",
    "NtFsControlFile",
    "NtOpenDirectoryObject",
    "NtOpenFile",
    "NtOpenSymbolicLinkObject",
    "NtProtectVirtualMemory",
    "NtPulseEvent",
    "NtQueueApcThread",
    "NtQueryDirectoryFile",
    "NtQueryDirectoryObject",
    "NtQueryEvent",
    "NtQueryFullAttributesFile",
    "NtQueryInformationFile",
    "NtQueryIoCompletion",
    "NtQueryMutant",
    "NtQuerySemaphore",
    "NtQuerySymbolicLinkObject",
    "NtQueryTimer",
    "NtQueryVirtualMemory",
    "NtQueryVolumeInformationFile",
    "NtReadFile",
    "NtReadFileScatter",
    "NtReleaseMutant",
    "NtReleaseSemaphore",
    "NtRemoveIoCompletion",
    "NtResumeThread",
    "NtSetEvent",
    "NtSetInformationFile",
    "NtSetIoCompletion",
    "NtSetSystemTime",
    "NtSetTimerEx",
    "NtSignalAndWaitForSingleObjectEx",
    "NtSuspendThread",
    "NtUserIoApcDispatcher",
    "NtWaitForSingleObject",
    "NtWaitForSingleObjectEx",
    "NtWaitForMultipleObjectsEx",
    "NtWriteFile",
    "NtWriteFileGather",
    "NtYieldExecution",
    "ObCreateObject",
    "ObDirectoryObjectType",
    "ObInsertObject",
    "ObMakeTemporaryObject",
    "ObOpenObjectByName",
    "ObOpenObjectByPointer",
    "ObpObjectHandleTable",
    "ObReferenceObjectByHandle",
    "ObReferenceObjectByName",
    "ObReferenceObjectByPointer",
    "ObSymbolicLinkObjectType",
    "ObfDereferenceObject",
    "ObfReferenceObject",
    "PhyGetLinkState",
    "PhyInitialize",
    "PsCreateSystemThread",
    "PsCreateSystemThreadEx",
    "PsQueryStatistics",
    "PsSetCreateThreadNotifyRoutine",
    "PsTerminateSystemThread",
    "PsThreadObjectType",
    "RtlAnsiStringToUnicodeString",
    "RtlAppendStringToString",
    "RtlAppendUnicodeStringToString",
    "RtlAppendUnicodeToString",
    "RtlAssert",
    "RtlCaptureContext",
    "RtlCaptureStackBackTrace",
    "RtlCharToInteger",
    "RtlCompareMemory",
    "RtlCompareMemoryUlong",
    "RtlCompareString",
    "RtlCompareUnicodeString",
    "RtlCopyString",
    "RtlCopyUnicodeString",
    "RtlCreateUnicodeString",
    "RtlDowncaseUnicodeChar",
    "RtlDowncaseUnicodeString",
    "RtlEnterCriticalSection",
    "RtlEnterCriticalSectionAndRegion",
    "RtlEqualString",
    "RtlEqualUnicodeString",
    "RtlExtendedIntegerMultiply",
    "RtlExtendedLargeIntegerDivide",
    "RtlExtendedMagicDivide",
    "RtlFillMemory",
    "RtlFillMemoryUlong",
    "RtlFreeAnsiString",
    "RtlFreeUnicodeString",
    "RtlGetCallersAddress",
    "RtlInitAnsiString",
    "RtlInitUnicodeString",
    "RtlInitializeCriticalSection",
    "RtlIntegerToChar",
    "RtlIntegerToUnicodeString",
    "RtlLeaveCriticalSection",
    "RtlLeaveCriticalSectionAndRegion",
    "RtlLowerChar",
    "RtlMapGenericMask",
    "RtlMoveMemory",
    "RtlMultiByteToUnicodeN",
    "RtlMultiByteToUnicodeSize",
    "RtlNtStatusToDosError",
    "RtlRaiseException",
    "RtlRaiseStatus",
    "RtlTimeFieldsToTime",
    "RtlTimeToTimeFields",
    "RtlTryEnterCriticalSection",
    "RtlUlongByteSwap",
    "RtlUnicodeStringToAnsiString",
    "RtlUnicodeStringToInteger",
    "RtlUnicodeToMultiByteN",
    "RtlUnicodeToMultiByteSize",
    "RtlUnwind",
    "RtlUpcaseUnicodeChar",
    "RtlUpcaseUnicodeString",
    "RtlUpcaseUnicodeToMultiByteN",
    "RtlUpperChar",
    "RtlUpperString",
    "RtlUshortByteSwap",
    "RtlWalkFrameChain",
    "RtlZeroMemory",
    "XboxEEPROMKey",
    "XboxHardwareInfo",
    "XboxHDKey",
    "XboxKrnlVersion",
    "XboxSignatureKey",
    "XeImageFileName",
    "XeLoadSection",
    "XeUnloadSection",
    "READ_PORT_BUFFER_UCHAR",
    "READ_PORT_BUFFER_USHORT",
    "READ_PORT_BUFFER_ULONG",
    "WRITE_PORT_BUFFER_UCHAR",
    "WRITE_PORT_BUFFER_USHORT",
    "WRITE_PORT_BUFFER_ULONG",
    "XcSHAInit",
    "XcSHAUpdate",
    "XcSHAFinal",
    "XcRC4Key",
    "XcRC4Crypt",
    "XcHMAC",
    "XcPKEncPublic",
    "XcPKDecPrivate",
    "XcPKGetKeyLen",
    "XcVerifyPKCS1Signature",
    "XcModExp",
    "XcDESKeyParity",
    "XcKeyTable",
    "XcBlockCrypt",
    "XcBlockCryptCBC",
    "XcCryptService",
    "XcUpdateCrypto",
    "RtlRip",
    "XboxLANKey",
    "XboxAlternateSignatureKeys",
    "XePublicKeyData",
    "HalBootSMCVideoMode",
    "IdexChannelObject",
    "HalIsResetOrShutdownPending",
    "IoMarkIrpMustComplete",
    "HalInitiateShutdown",
    "RtlSnprintf",
    "RtlSprintf",
    "RtlVsnprintf",
    "RtlVsprintf",
    "HalEnableSecureTrayEject",
    "HalWriteSMCScratchRegister",
    "Undefined",
    "Undefined",
    "Undefined",
    "XProfpControl",
    "XProfpGetData",
    "IrtClientInitFast",
    "IrtSweep",
    "MmDbgAllocateMemory",
    "MmDbgFreeMemory",
    "MmDbgQueryAvailablePages",
    "MmDbgReleaseAddress",
    "MmDbgWriteCheck",
};

UCHAR XePublicKeyData[] = {
    0x52,0x53,0x41,0x31,0x08,0x01,0x00,0x00,
    0x00,0x08,0x00,0x00,0xFF,0x00,0x00,0x00,
    0x01,0x00,0x01,0x00,0x9B,0x83,0xD4,0xD5,
    0xDE,0x16,0x25,0x8E,0xE5,0x15,0xF2,0x18,
    0x9D,0x19,0x1C,0xF8,0xFE,0x91,0xA5,0x83,
    0xAE,0xA5,0xA8,0x95,0x3F,0x01,0xB2,0xC9,
    0x34,0xFB,0xC7,0x51,0x2D,0xAC,0xFF,0x38,
    0xE6,0xB6,0x7B,0x08,0x4A,0xDF,0x98,0xA3,
    0xFD,0x31,0x81,0xBF,0xAA,0xD1,0x62,0x58,
    0xC0,0x6C,0x8F,0x8E,0xCD,0x96,0xCE,0x6D,
    0x03,0x44,0x59,0x93,0xCE,0xEA,0x8D,0xF4,
    0xD4,0x6F,0x6F,0x34,0x5D,0x50,0xF1,0xAE,
    0x99,0x7F,0x1D,0x92,0x15,0xF3,0x6B,0xDB,
    0xF9,0x95,0x8B,0x3F,0x54,0xAD,0x37,0xB5,
    0x4F,0x0A,0x58,0x7B,0x48,0xA2,0x9F,0x9E,
    0xA3,0x16,0xC8,0xBD,0x37,0xDA,0x9A,0x37,
    0xE6,0x3F,0x10,0x1B,0xA8,0x4F,0xA3,0x14,
    0xFA,0xBE,0x12,0xFB,0xD7,0x19,0x4C,0xED,
    0xAD,0xA2,0x95,0x8F,0x39,0x8C,0xC4,0x69,
    0x0F,0x7D,0xB8,0x84,0x0A,0x99,0x5C,0x53,
    0x2F,0xDE,0xF2,0x1B,0xC5,0x1D,0x4C,0x43,
    0x3C,0x97,0xA7,0xBA,0x8F,0xC3,0x22,0x67,
    0x39,0xC2,0x62,0x74,0x3A,0x0C,0xB5,0x57,
    0x01,0x3A,0x67,0xC6,0xDE,0x0C,0x0B,0xF6,
    0x08,0x01,0x64,0xDB,0xBD,0x81,0xE4,0xDC,
    0x09,0x2E,0xD0,0xF1,0xD0,0xD6,0x1E,0xBA,
    0x38,0x36,0xF4,0x4A,0xDD,0xCA,0x39,0xEB,
    0x76,0xCF,0x95,0xDC,0x48,0x4C,0xF2,0x43,
    0x8C,0xD9,0x44,0x26,0x7A,0x9E,0xEB,0x99,
    0xA3,0xD8,0xFB,0x30,0xA8,0x14,0x42,0x82,
    0x8D,0xB4,0x31,0xB3,0x1A,0xD5,0x2B,0xF6,
    0x32,0xBC,0x62,0xC0,0xFE,0x81,0x20,0x49,
    0xE7,0xF7,0x58,0x2F,0x2D,0xA6,0x1B,0x41,
    0x62,0xC7,0xE0,0x32,0x02,0x5D,0x82,0xEC,
    0xA3,0xE4,0x6C,0x9B,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00
};

SIZE_T InputFileSize;

DWORD
VerifyImageHeaderEncryptedDigest(
    PXBEIMAGE_HEADER ImageHeader
    )
/*++

Routine Description:

    This routine verifies that the encrypted header digest stored in the image
    header matches the digest of the data in the rest of the image headers.

Arguments:

    ImageHeader - Pointer to XBE image header.

Return Value:

    Error code of operation.

--*/
{
    PUCHAR PublicKeyData;
    PUCHAR Workspace;
    ULONG HeaderDigestLength;
    UCHAR HeaderDigest[XC_DIGEST_LEN];
    BOOLEAN Verified;

    PublicKeyData = XePublicKeyData;

    //
    // Allocate a workspace to do the digest verification.
    //

    Workspace = (PUCHAR)LocalAlloc(LPTR, XCCalcKeyLen(PublicKeyData) * 2);

    if (Workspace == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // The encrypted header digest starts at the field after the encrypted
    // header field in the main image header.
    //

    HeaderDigestLength = ImageHeader->SizeOfHeaders -
        FIELD_OFFSET(XBEIMAGE_HEADER, BaseAddress);

    //
    // Calculate the SHA1 digest for the headers.
    //

    XCCalcDigest((PUCHAR)&ImageHeader->BaseAddress, HeaderDigestLength,
        HeaderDigest);

    //
    // Verify that the SHA1 digest matches the encrypted header digest.
    //

    Verified = XCVerifyDigest(ImageHeader->EncryptedDigest, PublicKeyData,
        Workspace, HeaderDigest);

    LocalFree(Workspace);

    if (Verified) {
        return ERROR_SUCCESS;
    } else {
        return ERROR_TRUST_FAILURE;
    }
}

LPVOID
GetDataFromVirtualAddress(
    PXBEIMAGE_HEADER ImageHeader,
    PVOID VirtualAddress,
    ULONG NumberOfBytes
    )
{
    PXBEIMAGE_SECTION ImageSection;
    ULONG FileByteOffset;
    ULONG Index;

    //
    // Return a pointer to data in the image header if the virtual address
    // resides in the image header.
    //

    if (((ULONG)ImageHeader->BaseAddress <= (ULONG)VirtualAddress) &&
        ((ULONG)VirtualAddress + NumberOfBytes <= (ULONG)ImageHeader->BaseAddress +
            ImageHeader->SizeOfHeaders)) {

        FileByteOffset = (ULONG)VirtualAddress - (ULONG)ImageHeader->BaseAddress;

        if (FileByteOffset >= InputFileSize) {
            return NULL;
        }

        return (LPBYTE)ImageHeader + FileByteOffset;
    }

    //
    // Verify that the image has sections.
    //

    if (ImageHeader->NumberOfSections == 0) {
        return NULL;
    }

    //
    // Don't return anything if the section headers start past the end of the
    // file.
    //

    if (((ULONG)ImageHeader->SectionHeaders - (ULONG)ImageHeader->BaseAddress) >=
        InputFileSize) {
        return NULL;
    }

    //
    // Don't return anything if the section headers end past the end of the
    // file.
    //

    if (((ULONG)ImageHeader->SectionHeaders - (ULONG)ImageHeader->BaseAddress +
        (ImageHeader->NumberOfSections * sizeof(XBEIMAGE_SECTION))) >= InputFileSize) {
        return NULL;
    }

    //
    // Loop over all of the sections and return the address of the data that
    // maps the requested virtual address and size.
    //

    ImageSection = (PXBEIMAGE_SECTION)((LPBYTE)ImageHeader +
        (ULONG)ImageHeader->SectionHeaders - (ULONG)ImageHeader->BaseAddress);

    for (Index = 0; Index < ImageHeader->NumberOfSections; Index++) {

        if ((ImageSection->VirtualAddress <= (ULONG)VirtualAddress) &&
            ((ULONG)VirtualAddress + NumberOfBytes <= ImageSection->VirtualAddress +
                ImageSection->SizeOfRawData)) {

            FileByteOffset = ImageSection->PointerToRawData +
                ((ULONG)VirtualAddress - ImageSection->VirtualAddress);

            if (FileByteOffset >= InputFileSize) {
                return NULL;
            }

            return (LPBYTE)ImageHeader + FileByteOffset;
        }

        ImageSection++;
    }

    return NULL;
}

void usage(void)
{
    fprintf(stderr, "Usage:\txbeimport <XBE file>\n");
    exit(-1);
}

void __cdecl main(int argc, char* argv[])
{
    DWORD ErrorCode;
    PCHAR pszFileName = NULL;
    HANDLE MapHandle = NULL;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    PXBEIMAGE_HEADER XbeHeader = NULL;
    ULONG_PTR XboxKernelThunkData;
    PIMAGE_THUNK_DATA ImageThunkData;
    ULONG OrdinalNumber;
    ULONG *Key;

    if (argc != 2) {
        usage();
    }

    pszFileName = argv[1];

    if (!pszFileName) {
        usage();
    }

    //
    // Open a input XBE file and create a memory-mapped file
    //

    FileHandle = CreateFile(pszFileName, GENERIC_READ, 0, NULL,
        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (FileHandle == INVALID_HANDLE_VALUE) {
        goto cleanup;
    }

    InputFileSize = GetFileSize(FileHandle, NULL);

    MapHandle = CreateFileMapping(FileHandle, NULL, PAGE_READONLY, 0, 0,
        NULL);

    if (MapHandle == NULL) {
        goto cleanup;
    }

    XbeHeader = (PXBEIMAGE_HEADER)MapViewOfFile(MapHandle, FILE_MAP_READ,
        0, 0, 0);

    if (XbeHeader == NULL) {
        goto cleanup;
    }

    //
    // Check for a valid XBE image signature
    //

    if ((XbeHeader->Signature != XBEIMAGE_SIGNATURE) ||
        (XbeHeader->SizeOfHeaders <= sizeof(XBEIMAGE_HEADER)) ||
        (XbeHeader->SizeOfHeaders > XbeHeader->SizeOfImage) ||
        (XbeHeader->BaseAddress != (PVOID)XBEIMAGE_STANDARD_BASE_ADDRESS)) {

        fprintf(stderr, "%s is not a valid XBE image\n", argv[1]);
        SetLastError(ERROR_SUCCESS);
        goto cleanup;
    }

    if (VerifyImageHeaderEncryptedDigest(XbeHeader) != ERROR_SUCCESS) {
        fprintf(stderr, "Error: \"%s\" is not signed with DEVKIT key\n", pszFileName);
        SetLastError(ERROR_SUCCESS);
        goto cleanup;
    }

    Key = (ULONG*)&XePublicKeyData[128];
    XboxKernelThunkData = (ULONG_PTR)XbeHeader->XboxKernelThunkData;
    XboxKernelThunkData ^= Key[1] ^ Key[2];
    XboxKernelThunkData = (ULONG_PTR)GetDataFromVirtualAddress(XbeHeader,
                                        (PVOID)XboxKernelThunkData, 4);

    fprintf(stdout, "%s:\n\n", pszFileName);
    fprintf(stdout, "Ordinal  Function Name\n");
    fprintf(stdout, "-------  -------------\n");

    ImageThunkData = (PIMAGE_THUNK_DATA)XboxKernelThunkData;

    while (ImageThunkData->u1.Ordinal != 0) {

        OrdinalNumber = IMAGE_ORDINAL(ImageThunkData->u1.Ordinal);

        if (OrdinalNumber >= ARRAYSIZE(KernelExports)) {
            fprintf(stderr, "Cannot find import ordinal %d\n", OrdinalNumber);
            break;
        }

        fprintf(stdout, "    %3d  %s\n", OrdinalNumber,
            KernelExports[OrdinalNumber]);
        ImageThunkData++;
    }

cleanup:

    ErrorCode = GetLastError();

    if (ErrorCode != ERROR_SUCCESS) {

        char MsgBuf[256];

        FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL, ErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            MsgBuf, sizeof(MsgBuf), NULL);
        fprintf(stderr, "%s\n", MsgBuf);
    }

    if (XbeHeader) {
        UnmapViewOfFile(XbeHeader);
    }

    if (MapHandle) {
        CloseHandle(MapHandle);
    }

    if (FileHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(FileHandle);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\ddk\inc\dmusbuff.h ===
/***************************************************************************
*                                                                          *
*   DMusBuff.h -- This module defines the buffer format for DirectMusic    *
*                 Shared file between user mode and kernel mode components *
*                                                                          *
*   Copyright (c) 1998, Microsoft Corp. All rights reserved.               *
*                                                                          *
***************************************************************************/

#ifndef _DMusBuff_
#define _DMusBuff_

/* Format of DirectMusic events in a buffer
 *
 * A buffer contains 1 or more events, each with the following header.
 * Immediately following the header is the event data. The header+data
 * size is rounded to the nearest quadword (8 bytes).
 */
 
#include <pshpack4.h>                       /* Do not pad at end - that's where the data is */ 
typedef struct _DMUS_EVENTHEADER *LPDMUS_EVENTHEADER;
typedef struct _DMUS_EVENTHEADER
{
    DWORD           cbEvent;                /* Unrounded bytes in event */
    DWORD           dwChannelGroup;         /* Channel group of event */
    REFERENCE_TIME  rtDelta;                /* Delta from start time of entire buffer */
    DWORD           dwFlags;                /* Flags DMUS_EVENT_xxx */
} DMUS_EVENTHEADER;
#include <poppack.h>

#define DMUS_EVENT_STRUCTURED   0x00000001  /* Unstructured data (SysEx, etc.) */

/* The number of bytes to allocate for an event with 'cb' data bytes.
 */ 
#define QWORD_ALIGN(x) (((x) + 7) & ~7)
#define DMUS_EVENT_SIZE(cb) QWORD_ALIGN(sizeof(DMUS_EVENTHEADER) + cb)


#endif /* _DMusBuff_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\ddk\inc\amtvuids.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//

//
//  We want to use this list for generating strings for debugging too
//  so we redefine OUR_GUID_ENTRY depending on what we want to do
//
//  It is imperative that all entries in this file are declared using
//  OUR_GUID_ENTRY as that macro might have been defined in advance of
//  including this file.  See wxdebug.cpp in sdk\classes\base.
//

#ifndef OUR_GUID_ENTRY
	#define OUR_GUID_ENTRY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
	DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8);
#endif

// -------------------------------------------------------------------------
// TVTuner GUIDS
// -------------------------------------------------------------------------

// {266EEE40-6C63-11cf-8A03-00AA006ECB65}
OUR_GUID_ENTRY(CLSID_CTVTunerFilter, 
0x266eee40, 0x6c63, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65);

// {266EEE41-6C63-11cf-8A03-00AA006ECB65}
OUR_GUID_ENTRY(CLSID_CTVTunerFilterPropertyPage, 
0x266eee41, 0x6c63, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65);

// {266EEE44-6C63-11cf-8A03-00AA006ECB65}
OUR_GUID_ENTRY(IID_AnalogVideoStandard, 
0x266eee44, 0x6c63, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65);

// {266EEE46-6C63-11cf-8A03-00AA006ECB65}
OUR_GUID_ENTRY(IID_TunerInputType, 
0x266eee46, 0x6c63, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65);


// -------------------------------------------------------------------------
// Crossbar (XBar) GUIDS
// -------------------------------------------------------------------------

// {71F96460-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_CrossbarFilter,
0x71f96460, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56);

// {71F96461-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_CrossbarFilterPropertyPage,
0x71f96461, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56);

// {71F96462-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_TVAudioFilter,
0x71f96462, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56);

// {71F96463-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_TVAudioFilterPropertyPage,
0x71f96463, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\ddk\inc\dmusicks.h ===
/***************************************************************************
*                                                                          *
*   DMusicKS.h -- This module defines the the DirectMusic WDM interface.   *
*                                                                          *
*   Copyright (c) 1998, Microsoft Corp. All rights reserved.               *
*                                                                          *
***************************************************************************/

#ifndef _DMUSICKS_
#define _DMUSICKS_

#include <dmusprop.h>

#define DONT_HOLD_FOR_SEQUENCING 0x8000000000000000

typedef struct _DMUS_KERNEL_EVENT
{                                           //  this    offset
    BYTE            bReserved;              //  1       0
    BYTE            cbStruct;               //  1       1
    USHORT          cbEvent;                //  2       2
    USHORT          usChannelGroup;         //  2       4
    USHORT          usFlags;                //  2       6
    REFERENCE_TIME  ullPresTime100ns;       //  8       8
    ULONGLONG       ullBytePosition;        //  8      16
    _DMUS_KERNEL_EVENT *pNextEvt;           //  4 (8)  24
    union
    {
        BYTE        abData[sizeof(PBYTE)];  //  4 (8)  28 (32)
        PBYTE       pbData;
        _DMUS_KERNEL_EVENT *pPackageEvt;
    } uData;
} DMUS_KERNEL_EVENT, *PDMUS_KERNEL_EVENT;   //         32 (40)

#define DMUS_KEF_EVENT_COMPLETE     0x0000
#define DMUS_KEF_EVENT_INCOMPLETE   0x0001  //  This event is an incomplete package or sysex.
                                            //  Do not use this data.

#define DMUS_KEF_PACKAGE_EVENT      0x0002  //  This event is a package. The uData.pPackageEvt
                                            //  field contains a pointer to a chain of events.

#define kBytePositionNone   (~(ULONGLONG)0) //  This message has no meaningful byte position

#define SHORT_EVT(evt)       ((evt)->cbEvent <= sizeof(PBYTE))
#define PACKAGE_EVT(evt)     ((evt)->usFlags & DMUS_KEF_PACKAGE_EVENT)
#define INCOMPLETE_EVT(evt)  ((evt)->usFlags & DMUS_KEF_EVENT_INCOMPLETE)
#define COMPLETE_EVT(evt)    ((evt)->usFlags & DMUS_KEF_EVENT_INCOMPLETE == 0)

#define SET_INCOMPLETE_EVT(evt) ((evt)->usFlags |= DMUS_KEF_EVENT_INCOMPLETE)
#define SET_COMPLETE_EVT(evt)   ((evt)->usFlags &= (~DMUS_KEF_EVENT_INCOMPLETE))
#define SET_PACKAGE_EVT(evt)    ((evt)->usFlags |= DMUS_KEF_PACKAGE_EVENT)
#define CLEAR_PACKAGE_EVT(evt)  ((evt)->usFlags &= (~DMUS_KEF_PACKAGE_EVENT))


#define STATIC_CLSID_PortDMus\
    0xb7902fe9, 0xfb0a, 0x11d1, 0x81, 0xb0, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1
DEFINE_GUIDSTRUCT("b7902fe9-fb0a-11d1-81b0-0060083316c1", CLSID_PortDMus);
#define CLSID_PortDMus DEFINE_GUIDNAMED(CLSID_PortDMus)

#define STATIC_CLSID_MiniportDriverDMusUART\
    0xd3f0ce1c, 0xfffc, 0x11d1, 0x81, 0xb0, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1
DEFINE_GUIDSTRUCT("d3f0ce1c-fffc-11d1-81b0-0060083316c1", CLSID_MiniportDriverDMusUART);
#define CLSID_MiniportDriverDMusUART DEFINE_GUIDNAMED(CLSID_MiniportDriverDMusUART)

#define STATIC_CLSID_MiniportDriverDMusUARTCapture\
    0xd3f0ce1d, 0xfffc, 0x11d1, 0x81, 0xb0, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1
DEFINE_GUIDSTRUCT("d3f0ce1d-fffc-11d1-81b0-0060083316c1", CLSID_MiniportDriverDMusUARTCapture);
#define CLSID_MiniportDriverDMusUARTCapture DEFINE_GUIDNAMED(CLSID_MiniportDriverDMusUARTCapture)

#define STATIC_IID_IPortDMus\
    0xc096df9c, 0xfb09, 0x11d1, 0x81, 0xb0, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1
DEFINE_GUIDSTRUCT("c096df9c-fb09-11d1-81b0-0060083316c1", IID_IPortDMus);
#define IID_IPortDMus DEFINE_GUIDNAMED(IID_IPortDMus)

#define STATIC_IID_IMiniportDMus\
    0xc096df9d, 0xfb09, 0x11d1, 0x81, 0xb0, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1
DEFINE_GUIDSTRUCT("c096df9d-fb09-11d1-81b0-0060083316c1", IID_IMiniportDMus);
#define IID_IMiniportDMus DEFINE_GUIDNAMED(IID_IMiniportDMus)

#define STATIC_IID_IMXF\
    0xc096df9e, 0xfb09, 0x11d1, 0x81, 0xb0, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1
DEFINE_GUIDSTRUCT("c096df9e-fb09-11d1-81b0-0060083316c1", IID_IMXF);
#define IID_IMXF DEFINE_GUIDNAMED(IID_IMXF)

#define STATIC_IID_IAllocatorMXF\
    0xa5f0d62c, 0xb30f, 0x11d2, 0xb7, 0xa3, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1
DEFINE_GUIDSTRUCT("a5f0d62c-b30f-11d2-b7a3-0060083316c1", IID_IAllocatorMXF);
#define IID_IAllocatorMXF DEFINE_GUIDNAMED(IID_IAllocatorMXF)

#define STATIC_IID_ISynthSinkDMus\
    0x1f476974, 0x679b, 0x11d2, 0x8f, 0x7d, 0x00, 0xc0, 0x4f, 0xbf, 0x8f, 0xef
DEFINE_GUIDSTRUCT("1f476974-679b-11d2-8f7d-00c04fbf8fef", IID_ISynthSinkDMus);
#define IID_ISynthSinkDMus DEFINE_GUIDNAMED(IID_ISynthSinkDMus)

#define STATIC_KSAUDFNAME_DMUSIC_MPU_OUT\
    0xA4DF0EB5, 0xBAC9, 0x11d2, 0xB7, 0xA8, 0x00, 0x60, 0x08, 0x33, 0x16, 0xC1
DEFINE_GUIDSTRUCT("A4DF0EB5-BAC9-11d2-B7A8-0060083316C1", KSAUDFNAME_DMUSIC_MPU_OUT);
#define KSAUDFNAME_DMUSIC_MPU_OUT DEFINE_GUIDNAMED(KSAUDFNAME_DMUSIC_MPU_OUT)

#define STATIC_KSAUDFNAME_DMUSIC_MPU_IN\
    0xB2EC0A7D, 0xBAC9, 0x11d2, 0xB7, 0xA8, 0x00, 0x60, 0x08, 0x33, 0x16, 0xC1
DEFINE_GUIDSTRUCT("B2EC0A7D-BAC9-11d2-B7A8-0060083316C1", KSAUDFNAME_DMUSIC_MPU_IN);
#define KSAUDFNAME_DMUSIC_MPU_IN DEFINE_GUIDNAMED(KSAUDFNAME_DMUSIC_MPU_IN)


/*****************************************************************************
 * IPortDMus
 *****************************************************************************
 * Interface for DMusic port lower edge.
 */
DECLARE_INTERFACE_(IPortDMus,IPort)
{
    STDMETHOD_(void,Notify)
    (   THIS_
        IN      PSERVICEGROUP   ServiceGroup    OPTIONAL
    )   PURE;

    STDMETHOD_(void,RegisterServiceGroup)
    (   THIS_
        IN      PSERVICEGROUP   ServiceGroup
    )   PURE;
};

typedef IPortDMus *PPORTDMUS;

#ifdef PC_IMPLEMENTATION
#define IMP_IPortDMus\
    IMP_IPort;\
    STDMETHODIMP_(void) Notify\
    (   IN      PSERVICEGROUP   ServiceGroup    OPTIONAL\
    );\
    STDMETHODIMP_(void) RegisterServiceGroup\
    (   IN      PSERVICEGROUP   ServiceGroup\
    )
#endif  /* PC_IMPLEMENTATION */


/*****************************************************************************
 * IMXF
 *****************************************************************************
 * Interface for DMusic miniport streams.
 */
struct  IMXF;
typedef IMXF *PMXF;

DECLARE_INTERFACE_(IMXF,IUnknown)
{
    STDMETHOD(SetState)
    (   THIS_
        IN      KSSTATE State
    )   PURE;

    STDMETHOD(PutMessage)
    (   THIS_
        IN      PDMUS_KERNEL_EVENT  pDMKEvt
    )   PURE;

    STDMETHOD(ConnectOutput)
    (   THIS_
        IN      PMXF    sinkMXF
    )   PURE;

    STDMETHOD(DisconnectOutput)
    (   THIS_
        IN      PMXF    sinkMXF
    )   PURE;
};

#define IMP_IMXF\
    STDMETHODIMP SetState\
    (   IN      KSSTATE State\
    );\
    STDMETHODIMP PutMessage\
    (   IN      PDMUS_KERNEL_EVENT  pDMKEvt\
    );\
    STDMETHODIMP ConnectOutput\
    (   IN      PMXF    sinkMXF\
    );\
    STDMETHODIMP DisconnectOutput\
    (   IN      PMXF    sinkMXF\
    );\

/*****************************************************************************
 * IAllocatorMXF
 *****************************************************************************
 * Interface for DMusic miniport streams.
 */
struct  IAllocatorMXF;
typedef IAllocatorMXF *PAllocatorMXF;

DECLARE_INTERFACE_(IAllocatorMXF,IMXF)
{
    STDMETHOD(GetMessage)
    (   THIS_
        OUT     PDMUS_KERNEL_EVENT * ppDMKEvt
    )   PURE;

    STDMETHOD_(USHORT,GetBufferSize)
    (   THIS
    )   PURE;

    STDMETHOD(GetBuffer)
    (   THIS_
        OUT     PBYTE * ppBuffer
    )   PURE;

    STDMETHOD(PutBuffer)
    (   THIS_
        IN      PBYTE   pBuffer
    )   PURE;
};

#define IMP_IAllocatorMXF\
    IMP_IMXF;\
    STDMETHODIMP GetMessage\
    (   OUT     PDMUS_KERNEL_EVENT * ppDMKEvt\
    );\
    STDMETHODIMP_(USHORT) GetBufferSize\
    (   void\
    );\
    STDMETHODIMP GetBuffer\
    (   OUT     PBYTE * ppBuffer\
    );\
    STDMETHODIMP PutBuffer\
    (   IN      PBYTE   pBuffer\
    );\


typedef enum
{
    DMUS_STREAM_MIDI_INVALID = -1,
    DMUS_STREAM_MIDI_RENDER = 0,
    DMUS_STREAM_MIDI_CAPTURE,
    DMUS_STREAM_WAVE_SINK
} DMUS_STREAM_TYPE;

/*****************************************************************************
 * ISynthSinkDMus
 *****************************************************************************
 * Interface for synth wave out.
 */
DECLARE_INTERFACE_(ISynthSinkDMus,IMXF)
{
    STDMETHOD_(void,Render)
    (   THIS_
        IN      PBYTE       pBuffer,
        IN      DWORD       dwLength,
        IN      LONGLONG    llPosition
    )   PURE;

    STDMETHOD(SyncToMaster)
    (   THIS_
        IN      REFERENCE_TIME  rfTime,
        IN      BOOL            fStart
    )   PURE;

    STDMETHOD(SampleToRefTime)
    (   THIS_
        IN      LONGLONG         llSampleTime,
        OUT     REFERENCE_TIME * prfTime
    )   PURE;

    STDMETHOD(RefTimeToSample)
    (   THIS_
        IN      REFERENCE_TIME  rfTime,
        OUT     LONGLONG *      pllSampleTime
    )   PURE;
};

typedef ISynthSinkDMus * PSYNTHSINKDMUS;

#define IMP_ISynthSinkDMus\
    IMP_IMXF;\
    STDMETHODIMP_(void) Render\
    (   IN      PBYTE       pBuffer,\
        IN      DWORD       dwLength,\
        IN      LONGLONG    llPosition\
    );\
    STDMETHODIMP SyncToMaster\
    (   IN      REFERENCE_TIME  rfTime,\
        IN      BOOL            fStart\
    );\
    STDMETHODIMP SampleToRefTime\
    (   IN      LONGLONG         llSampleTime,\
        OUT     REFERENCE_TIME * prfTime\
    );\
    STDMETHODIMP RefTimeToSample\
    (   IN      REFERENCE_TIME  rfTime,\
        OUT     LONGLONG *      pllSampleTime\
    )


/*****************************************************************************
 * IMasterClock
 *****************************************************************************
 * Master clock for MXF graph
 */
DECLARE_INTERFACE_(IMasterClock,IUnknown)    
{
    STDMETHOD(GetTime)                  
    (   THIS_ 
        OUT     REFERENCE_TIME  * pTime
    )   PURE;
};

typedef IMasterClock *PMASTERCLOCK;

#define IMP_IMasterClock               \
    STDMETHODIMP GetTime               \
    (   THIS_                          \
        OUT     REFERENCE_TIME * pTime \
    );                                 \

/*****************************************************************************
 * IPositionNotify
 *****************************************************************************
 * Byte position notify for MXF graph
 */
DECLARE_INTERFACE_(IPositionNotify,IUnknown)    
{
    STDMETHOD_(void,PositionNotify)
    (   THIS_ 
        IN      ULONGLONG   bytePosition
    )   PURE;
};

typedef IPositionNotify *PPOSITIONNOTIFY;

#define IMP_IPositionNotify                 \
    STDMETHODIMP_(void) PositionNotify      \
    (   THIS_                               \
        IN      ULONGLONG   bytePosition    \
    );                                      \

/*****************************************************************************
 * IMiniportDMus
 *****************************************************************************
 * Interface for DMusic miniports.
 */
DECLARE_INTERFACE_(IMiniportDMus,IMiniport)
{
    STDMETHOD(Init)
    (   THIS_
        IN      PUNKNOWN        UnknownAdapter,
        IN      PRESOURCELIST   ResourceList,
        IN      PPORTDMUS       Port,
        OUT     PSERVICEGROUP * ServiceGroup
    )   PURE;

    STDMETHOD_(void,Service)
    (   THIS
    )   PURE;

    STDMETHOD(NewStream)
    (   THIS_
        OUT     PMXF                  * MXF,
        IN      PUNKNOWN                OuterUnknown    OPTIONAL,
        IN      POOL_TYPE               PoolType,
        IN      ULONG                   PinID,
        IN      DMUS_STREAM_TYPE        StreamType,
        IN      PKSDATAFORMAT           DataFormat,
        OUT     PSERVICEGROUP         * ServiceGroup,
        IN      PAllocatorMXF           AllocatorMXF,
        IN      PMASTERCLOCK            MasterClock,
        OUT     PULONGLONG              SchedulePreFetch
    )   PURE;
};

typedef IMiniportDMus *PMINIPORTDMUS;

#define IMP_IMiniportDMus\
    IMP_IMiniport;\
    STDMETHODIMP Init\
    (   IN      PUNKNOWN        UnknownAdapter,\
        IN      PRESOURCELIST   ResourceList,\
        IN      PPORTDMUS       Port,\
        OUT     PSERVICEGROUP * ServiceGroup\
    );\
    STDMETHODIMP_(void) Service\
    (   void\
    );\
    STDMETHODIMP NewStream\
    (   OUT     PMXF                  * MXF,                        \
        IN      PUNKNOWN                OuterUnknown    OPTIONAL,   \
        IN      POOL_TYPE               PoolType,                   \
        IN      ULONG                   PinID,                      \
        IN      DMUS_STREAM_TYPE        StreamType,                 \
        IN      PKSDATAFORMAT           DataFormat,                 \
        OUT     PSERVICEGROUP         * ServiceGroup,               \
        IN      PAllocatorMXF           AllocatorMXF,               \
        IN      PMASTERCLOCK            MasterClock,                \
        OUT     PULONGLONG              SchedulePreFetch            \
    )

DEFINE_GUID(GUID_DMUS_PROP_GM_Hardware, 0x178f2f24, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_GS_Hardware, 0x178f2f25, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_XG_Hardware, 0x178f2f26, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_XG_Capable,  0x6496aba1, 0x61b0, 0x11d2, 0xaf, 0xa6, 0x00, 0xaa, 0x00, 0x24, 0xd8, 0xb6);
DEFINE_GUID(GUID_DMUS_PROP_GS_Capable,  0x6496aba2, 0x61b0, 0x11d2, 0xaf, 0xa6, 0x00, 0xaa, 0x00, 0x24, 0xd8, 0xb6);
DEFINE_GUID(GUID_DMUS_PROP_DLS1,        0x178f2f27, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_WavesReverb, 0x04cb5622, 0x32e5, 0x11d2, 0xaf, 0xa6, 0x00, 0xaa, 0x00, 0x24, 0xd8, 0xb6);
DEFINE_GUID(GUID_DMUS_PROP_Effects,     0xcda8d611, 0x684a, 0x11d2, 0x87, 0x1e, 0x00, 0x60, 0x08, 0x93, 0xb1, 0xbd);

#ifndef DMUS_EFFECT_NONE
#define DMUS_EFFECT_NONE    0x00000000
#endif

#ifndef DMUS_EFFECT_REVERB
#define DMUS_EFFECT_REVERB  0x00000001
#endif

#ifndef DMUS_EFFECT_CHORUS
#define DMUS_EFFECT_CHORUS  0x00000002
#endif


#endif  /* _DMUSICKS_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\ddk\inc\dmusprop.h ===
/***************************************************************************
*                                                                          *
*   DMusProp.h -- This module defines property items for DirectMusic WDM   *
*                                                                          *
*   Copyright (c) 1998, Microsoft Corp. All rights reserved.               *
*                                                                          *
***************************************************************************/

#ifndef _DMusProp_
#define _DMusProp_

#include "dmusbuff.h"

/* 
    Formats
*/
#define STATIC_KSDATAFORMAT_SUBTYPE_DIRECTMUSIC\
    0x1a82f8bc,  0x3f8b, 0x11d2, 0xb7, 0x74, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1
DEFINE_GUIDSTRUCT("1a82f8bc-3f8b-11d2-b774-0060083316c1", KSDATAFORMAT_SUBTYPE_DIRECTMUSIC);
#define KSDATAFORMAT_SUBTYPE_DIRECTMUSIC DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_DIRECTMUSIC)


/*
    Topology
*/
#define STATIC_KSNODETYPE_DMSYNTH\
    0x94824f88, 0x6183, 0x11d2, 0x8f, 0x7a, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef
DEFINE_GUIDSTRUCT("94824F88-6183-11d2-8F7A-00C04FBF8FEF", KSNODETYPE_DMSYNTH);
#define KSNODETYPE_DMSYNTH DEFINE_GUIDNAMED(KSNODETYPE_DMSYNTH)

/*
    Caps node (per pin)
*/    
#define STATIC_KSNODETYPE_DMSYNTH_CAPS\
    0xbca2a2f1, 0x93c6, 0x11d2, 0xba, 0x1d, 0x0, 0x0, 0xf8, 0x75, 0xac, 0x12
DEFINE_GUIDSTRUCT("bca2a2f1-93c6-11d2-ba1d-0000f875ac12", KSNODETYPE_DMSYNTH_CAPS);    
#define KSNODETYPE_DMSYNTH_CAPS DEFINE_GUIDNAMED(KSNODETYPE_DMSYNTH_CAPS)

/* 
    DDK Property sets and items
*/
#define STATIC_KSPROPSETID_Synth_Dls\
    0xd523fa2c, 0xdee3, 0x11d1, 0xa7, 0x89, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12
DEFINE_GUIDSTRUCT("d523fa2c-dee3-11d1-a789-0000f875ac12", KSPROPSETID_Synth_Dls);
#define KSPROPSETID_Synth_Dls DEFINE_GUIDNAMED(KSPROPSETID_Synth_Dls)

typedef enum
{
    KSPROPERTY_SYNTH_DLS_DOWNLOAD = 0,
    KSPROPERTY_SYNTH_DLS_UNLOAD,
    KSPROPERTY_SYNTH_DLS_COMPACT,
    KSPROPERTY_SYNTH_DLS_APPEND,
    KSPROPERTY_SYNTH_DLS_WAVEFORMAT
} KSPROPERTY_SYNTH_DLS;

typedef struct _SYNTH_BUFFER
{
    ULONG   BufferSize;
    PVOID   BufferAddress;
} SYNTH_BUFFER, *PSYNTH_BUFFER;

typedef struct _SYNTHDOWNLOAD
{
    HANDLE  DownloadHandle;
    BOOL    Free;               /* the client buffer can be freed */
} SYNTHDOWNLOAD, *PSYNTHDOWNLOAD;


#define STATIC_KSPROPSETID_Synth\
    0xfedfae25L, 0xe46e, 0x11d1, 0xaa, 0xce, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12
DEFINE_GUIDSTRUCT("fedfae25-e46e-11d1-aace-0000f875ac12", KSPROPSETID_Synth);
#define KSPROPSETID_Synth DEFINE_GUIDNAMED(KSPROPSETID_Synth)

typedef enum
{
    KSPROPERTY_SYNTH_VOLUME = 0,  /* must be first */
    KSPROPERTY_SYNTH_VOLUMEBOOST,
    KSPROPERTY_SYNTH_CAPS,
    KSPROPERTY_SYNTH_PORTPARAMETERS,
    KSPROPERTY_SYNTH_CHANNELGROUPS,
    KSPROPERTY_SYNTH_VOICEPRIORITY,
    KSPROPERTY_SYNTH_LATENCYCLOCK,
    KSPROPERTY_SYNTH_RUNNINGSTATS
} KSPROPERTY_SYNTH;

#define SYNTH_PC_DLS                (0x00000001)
#define SYNTH_PC_EXTERNAL           (0x00000002)
#define SYNTH_PC_SOFTWARESYNTH      (0x00000004)
#define SYNTH_PC_MEMORYSIZEFIXED    (0x00000008)
#define SYNTH_PC_GMINHARDWARE       (0x00000010)
#define SYNTH_PC_GSINHARDWARE       (0x00000020)
#define SYNTH_PC_REVERB             (0x00000040)
#define SYNTH_PC_DLS2               (0x00000080)

#define SYNTH_PC_SYSTEMMEMORY       (0x7fffffff)

typedef struct _SYNTHCAPS
{
    GUID    Guid;
    DWORD   Flags;
    DWORD   MemorySize;
    DWORD   MaxChannelGroups;
    DWORD   MaxVoices;
    DWORD   MaxAudioChannels;
    DWORD   EffectFlags;
    WCHAR   Description[128];
} SYNTHCAPS, *PSYNTHCAPS;


typedef struct _SYNTH_PORTPARAMS
{
    DWORD   ValidParams;
    DWORD   Voices;
    DWORD   ChannelGroups;
    DWORD   AudioChannels;
    DWORD   SampleRate;
    DWORD   EffectsFlags;
    DWORD   Share;
} SYNTH_PORTPARAMS, *PSYNTH_PORTPARAMS;

/*  These flags (set in ValidParams) indicate which 
 *  other members of the SYNTH_PORTPARAMS are valid
 */
#define SYNTH_PORTPARAMS_VOICES           0x00000001
#define SYNTH_PORTPARAMS_CHANNELGROUPS    0x00000002
#define SYNTH_PORTPARAMS_AUDIOCHANNELS    0x00000004
#define SYNTH_PORTPARAMS_SAMPLERATE       0x00000008
#define SYNTH_PORTPARAMS_EFFECTS          0x00000020
#define SYNTH_PORTPARAMS_SHARE            0x00000040

/* SYNTH_EFFECT_ flags are used in the 
 * EffectFlags fields of SYNTH_PORTPARAMS.
 */

#define SYNTH_EFFECT_NONE             0x00000000
#define SYNTH_EFFECT_REVERB           0x00000001
#define SYNTH_EFFECT_CHORUS           0x00000002
#define SYNTH_EFFECT_DELAY            0x00000004

/*
 * Instance data for KSPROPERTY_ITEM_SynthVoicePriority
 */
typedef struct _SYNTHVOICEPRIORITY_INSTANCE
{
    DWORD   ChannelGroup;
    DWORD   Channel;
} SYNTHVOICEPRIORITY_INSTANCE, *PSYNTHVOICEPRIORITY_INSTANCE;

/* 
 * Data returned by KSPROPERTY_SYNTH_RUNNINGSTATS
 */
typedef struct _SYNTH_STATS
{
    DWORD   ValidStats;       /* Flags indicating which fields below are valid. */
    DWORD   Voices;           /* Average number of voices playing. */
    DWORD   TotalCPU;         /* Total CPU usage as percent * 100. */
    DWORD   CPUPerVoice;      /* CPU per voice as percent * 100. */
    DWORD   LostNotes;        /* Number of notes lost in 1 second. */
    DWORD   FreeMemory;       /* Free memory in bytes */
    LONG    PeakVolume;       /* Decibel level * 100. */
} SYNTH_STATS, *PSYNTH_STATS; 


#define SYNTH_STATS_VOICES          (1 << 0)
#define SYNTH_STATS_TOTAL_CPU       (1 << 1)
#define SYNTH_STATS_CPU_PER_VOICE   (1 << 2)
#define SYNTH_STATS_LOST_NOTES      (1 << 3)
#define SYNTH_STATS_PEAK_VOLUME     (1 << 4)
#define SYNTH_STATS_FREE_MEMORY     (1 << 5)

#ifndef _DIRECTAUDIO_PRIORITIES_DEFINED_
#define _DIRECTAUDIO_PRIORITIES_DEFINED_

#define DAUD_CRITICAL_VOICE_PRIORITY    (0xF0000000)
#define DAUD_HIGH_VOICE_PRIORITY        (0xC0000000)
#define DAUD_STANDARD_VOICE_PRIORITY    (0x80000000)
#define DAUD_LOW_VOICE_PRIORITY         (0x40000000)
#define DAUD_PERSIST_VOICE_PRIORITY     (0x10000000) 

/* These are the default priorities assigned if not overridden. By default priorities are
 * equal across channel groups (e.g. channel 5 on channel group 1 has the same priority as
 * channel 5 on channel group 2).
 *
 * In accordance with DLS level 1, channel 10 has the highest priority, followed by 1 through 16
 * except for 10.
 */
#define DAUD_CHAN1_VOICE_PRIORITY_OFFSET    (0x0000000E)
#define DAUD_CHAN2_VOICE_PRIORITY_OFFSET    (0x0000000D)
#define DAUD_CHAN3_VOICE_PRIORITY_OFFSET    (0x0000000C)
#define DAUD_CHAN4_VOICE_PRIORITY_OFFSET    (0x0000000B)
#define DAUD_CHAN5_VOICE_PRIORITY_OFFSET    (0x0000000A)
#define DAUD_CHAN6_VOICE_PRIORITY_OFFSET    (0x00000009)
#define DAUD_CHAN7_VOICE_PRIORITY_OFFSET    (0x00000008)
#define DAUD_CHAN8_VOICE_PRIORITY_OFFSET    (0x00000007)
#define DAUD_CHAN9_VOICE_PRIORITY_OFFSET    (0x00000006)
#define DAUD_CHAN10_VOICE_PRIORITY_OFFSET   (0x0000000F)
#define DAUD_CHAN11_VOICE_PRIORITY_OFFSET   (0x00000005)
#define DAUD_CHAN12_VOICE_PRIORITY_OFFSET   (0x00000004)
#define DAUD_CHAN13_VOICE_PRIORITY_OFFSET   (0x00000003)
#define DAUD_CHAN14_VOICE_PRIORITY_OFFSET   (0x00000002)
#define DAUD_CHAN15_VOICE_PRIORITY_OFFSET   (0x00000001)
#define DAUD_CHAN16_VOICE_PRIORITY_OFFSET   (0x00000000)
 
 
#define DAUD_CHAN1_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN1_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN2_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN2_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN3_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN3_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN4_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN4_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN5_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN5_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN6_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN6_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN7_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN7_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN8_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN8_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN9_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN9_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN10_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN10_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN11_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN11_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN12_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN12_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN13_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN13_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN14_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN14_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN15_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN15_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN16_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN16_VOICE_PRIORITY_OFFSET)

#endif  /* _DIRECTAUDIO_PRIORITIES_DEFINED_ */

/* 
    SDK Property sets and items
*/
typedef struct _SYNTH_REVERB_PARAMS
{
    float   fInGain;            /* Input gain in dB (to avoid output overflows) */
    float   fReverbMix;         /* Reverb mix in dB. 0dB means 100% wet reverb (no direct signal).
                                   Negative values gives less wet signal.  The coeficients are
                                   calculated so that the overall output level stays (approximately)
                                   constant regardless of the ammount of reverb mix. */
    float   fReverbTime;        /* The reverb decay time, in milliseconds. */
    float   fHighFreqRTRatio;   /* The ratio of the high frequencies to the global reverb time. 
                                   Unless very 'splashy-bright' reverbs are wanted, this should be set to 
                                   a value < 1.0.  For example if dRevTime==1000ms and dHighFreqRTRatio=0.1
                                   than the decay time for high frequencies will be 100ms.*/
} SYNTH_REVERB_PARAMS, *PSYNTH_REVERB_PARAMS;


#define STATIC_KSPROPSETID_SynthClock \
    0xfedfae26L, 0xe46e, 0x11d1, 0xaa, 0xce, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12
DEFINE_GUIDSTRUCT("fedfae26-e46e-11d1-aace-0000f875ac12", KSPROPSETID_SynthClock);
#define KSPROPSETID_SynthClock DEFINE_GUIDNAMED(KSPROPSETID_SynthClock)

typedef enum
{
    KSPROPERTY_SYNTH_MASTERCLOCK
} KSPROPERTY_SYNTHCLOCK;
#endif /* _DMusProp_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\crypto\xcbase.c ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    xcbase.c

Abstract:

    Contains implementation of base level crypto function

--*/

#include "umkm.h"
#include <windows.h>
#include <assert.h>
#include <rsa.h>
#include <sha.h>
#include <rc4.h>
#include <xcrypt.h>
#include <benaloh.h>

#include "des.h"
#include "tripldes.h"
#include "modes.h"

//
// Reverse ASN.1 Encodings of possible hash identifiers.  
//
static PBYTE shaEncodings[] = {
            //      1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18
            "\x0f\x14\x04\x00\x05\x1a\x02\x03\x0e\x2b\x05\x06\x09\x30\x21\x30",
            "\x0d\x14\x04\x1a\x02\x03\x0e\x2b\x05\x06\x07\x30\x1f\x30",
            "\x00" };

VOID
XCCalcDigest(
    IN  PBYTE   pbMsgData,
    IN  DWORD   dwMsgDataLen,
    IN  PBYTE   pbDigest
    )
/*++

Routine Description:

    This function calculates a digest (hash) for the given daata

Arguments:

Return Value:

    None

--*/
{
    A_SHA_CTX   SHAHash;
    BYTE        abSHADigest[A_SHA_DIGEST_LEN];

    A_SHAInit(&SHAHash);
    A_SHAUpdate(&SHAHash, (PBYTE)&dwMsgDataLen, sizeof(DWORD));
    A_SHAUpdate(&SHAHash, pbMsgData, dwMsgDataLen);
    A_SHAFinal(&SHAHash, abSHADigest);

    memcpy(pbDigest, abSHADigest, A_SHA_DIGEST_LEN);
}



VOID
XCSymmetricEncDec(
    IN PBYTE  pbMsgData,
    IN DWORD  dwMsgDataLen,
    IN PBYTE  pbKey,
    IN DWORD  dwKeyBytes
    )
/*++

Routine Description:

    Encrypt or decrypt the given data buffer in-place using RC4 which is symmetric algorithm.

Arguments:


Return Value:

    None

--*/
{
    struct RC4_KEYSTRUCT rc4KeyCtl;

    rc4_key(&rc4KeyCtl, (UINT)dwKeyBytes, pbKey);

    rc4(&rc4KeyCtl, (UINT)dwMsgDataLen, pbMsgData);
}



VOID
XCApplyPKCS1SigningFmt(
    IN  PBYTE pbKey,
    IN  PBYTE pbDigest,
    OUT PBYTE pbPKCS1Format
    )
/*++

Routine Description:

    Formats a buffer with PKCS 1 for signing for SHA digests

Arguments:


Return Value:

    None

--*/
{
    PBYTE   pbStart;
    PBYTE   pbEnd;
    BYTE    bTmp;
    DWORD   i;
    LPBSAFE_PUB_KEY pPubKey = (LPBSAFE_PUB_KEY)pbKey;

    // 
    // insert the block type
    //
    pbPKCS1Format[pPubKey->datalen - 1] = 0x01;

    // 
    // insert the type I padding
    //
    memset(pbPKCS1Format, 0xff, pPubKey->datalen - 1);

    // 
    // reverse it
    //
    for (i = 0; i < A_SHA_DIGEST_LEN; i++) {
        pbPKCS1Format[i] = pbDigest[A_SHA_DIGEST_LEN - (i + 1)];
    }

    // 
    // PKCS delimit the hash value
    //
    pbEnd = (LPBYTE)shaEncodings[0];
    pbStart = pbPKCS1Format + A_SHA_DIGEST_LEN;
    bTmp = *pbEnd++;
    while (0 < bTmp--) {
        *pbStart++ = *pbEnd++;
    }
    *pbStart++ = 0;
}


BOOL XCVerifyPKCS1SigningFmt(
    IN  BSAFE_PUB_KEY* pKey,
    IN  BYTE* pbDigest,
    IN  BYTE* pbPKCS1Format
    )
{
    BYTE**    rgEncOptions;
    BYTE      rgbTmpHash[A_SHA_DIGEST_LEN + 16];
    DWORD     i;
    DWORD     cb;
    BYTE*     pbStart;
    DWORD     cbTmp;

    rgEncOptions = shaEncodings;

    // 
    // reverse the hash to match the signature.
    //
    for (i = 0; i < A_SHA_DIGEST_LEN; i++) {
        rgbTmpHash[i] = pbDigest[A_SHA_DIGEST_LEN - (i + 1)];
    }

    // 
    // see if it matches.
    //
    if (memcmp(rgbTmpHash, pbPKCS1Format, A_SHA_DIGEST_LEN)) {
        return FALSE;
    }

    cb = A_SHA_DIGEST_LEN;

    //
    // check for any signature type identifiers
    //
    for (i = 0; 0 != *rgEncOptions[i]; i += 1) {
        pbStart = (LPBYTE)rgEncOptions[i];
        cbTmp = *pbStart++;
        if (0 == memcmp(&pbPKCS1Format[cb], pbStart, cbTmp)) {
            // adjust the end of the hash data. 
            cb += cbTmp;   
            break;
        }
    }

    // 
    // check to make sure the rest of the PKCS #1 padding is correct
    //
    if ((0x00 != pbPKCS1Format[cb]) || (0x00 != pbPKCS1Format[pKey->datalen]) ||
         (0x1 != pbPKCS1Format[pKey->datalen - 1])) {
        return FALSE;
    }

    for (i = cb + 1; i < (DWORD)pKey->datalen - 1; i++) {
        if (0xff != pbPKCS1Format[i]) {
            return FALSE;
        }
    }

    return TRUE;
}



DWORD
XCCalcSigSize(
    IN  PBYTE  pbPrivateKey
    )
/*++

Routine Description:

    Calculates size of the signature based on the private key

Arguments:

Return Value:

    Size of the signature

--*/
{
    LPBSAFE_PRV_KEY pPrvKey = (LPBSAFE_PRV_KEY)pbPrivateKey;

    return (pPrvKey->bitlen + 7) / 8;
}


DWORD
XCCalcKeyLen(
    IN  PBYTE  pbPublicKey
    )
/*++

Routine Description:

    Calculates the keylen stored in the key

Arguments:

Return Value:

    Returns the value of keylen 

--*/
{
    LPBSAFE_PUB_KEY pPubKey = (LPBSAFE_PUB_KEY)pbPublicKey;

    return pPubKey->keylen;
}




BOOLEAN
XCSignDigest(
    IN   PBYTE    pbDigest,
    IN   PBYTE    pbPrivateKey,
    OUT  PBYTE    pbSig
    )
/*++

Routine Description:

    This function signs a digest (hash) with the given private key

Arguments:

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
    PBYTE           pbInput;
    PBYTE           pbOutput;
    LPBSAFE_PRV_KEY pPrvKey = (LPBSAFE_PRV_KEY)pbPrivateKey;
    DWORD           dwSigLen;

    dwSigLen = (pPrvKey->bitlen + 7) / 8;

    pbInput = ALLOC(pPrvKey->keylen);
    pbOutput = ALLOC(pPrvKey->keylen);

    memset(pbInput, 0, pPrvKey->keylen);
    memset(pbOutput, 0, pPrvKey->keylen);

    // 
    // initialize the input buffer to PKCS 1 signing format 
    //
    XCApplyPKCS1SigningFmt(pbPrivateKey, pbDigest, pbInput);

    //
    // encrypt it
    //
    BSafeDecPrivate(pPrvKey, pbInput, pbOutput);

    //
    // copy results
    //
    memcpy(pbSig, pbOutput, dwSigLen);

    FREE(pbOutput);
    FREE(pbInput);

    return TRUE;
}



BOOLEAN
XCVerifyDigest(
    IN   PBYTE   pbSig,
    IN   PBYTE   pbPublicKey,
    IN   PBYTE   pbWorkspace,
    IN   PBYTE   pbCompareDigest
    )
/*++

Routine Description:

    This function decrypts and verifies a digest (hash) with the given public key

Arguments:

    pbSig - Supplies the encrypted signature

    pbPublicKey - Supplies a pointer to the public key data

    pbWorkspace - Supplies a buffer to be used as workspace.  This
                  must be at least 2 * keylen

    pbCompareDigest - Supplies the digest to compare 


Return Value:

    TRUE if signature matches, FALSE otherwise

--*/
{
    LPBSAFE_PUB_KEY pPubKey = (LPBSAFE_PUB_KEY)pbPublicKey;
    PBYTE           pbOutput;
    PBYTE           pbInput;
    DWORD           dwSigLen;

    dwSigLen = (pPubKey->bitlen + 7) / 8;

    pbOutput = pbWorkspace;
    pbInput = (PBYTE)((ULONG_PTR)pbWorkspace + pPubKey->keylen);

    memset(pbInput, 0, pPubKey->keylen);
    memcpy(pbInput, pbSig, dwSigLen);

    if (!BSafeEncPublic(pPubKey, pbInput, pbOutput)) {
        return FALSE;
    }


    if (!XCVerifyPKCS1SigningFmt(pPubKey, pbCompareDigest, pbOutput)) {
        return FALSE;
    }

    return TRUE;
}

//
// Crypto APIs the ROM exports
//

void
XCryptSHAInit(
    IN PUCHAR pbSHAContext
    )
{
    A_SHAInit((A_SHA_CTX*)pbSHAContext);
}
   
void
XCryptSHAUpdate(
    IN PUCHAR pbSHAContext,
    IN PUCHAR pbInput,
    IN ULONG dwInputLength
    )
{
    A_SHAUpdate((A_SHA_CTX*)pbSHAContext, pbInput, dwInputLength);
}
   
void
XCryptSHAFinal(
    IN PUCHAR pbSHAContext,
    IN PUCHAR pbDigest
    )
{
    A_SHAFinal((A_SHA_CTX*)pbSHAContext, pbDigest);
}
   
void
XCryptRC4Key(
    IN PUCHAR pbKeyStruct,
    IN ULONG dwKeyLength,
    IN PUCHAR pbKey
    )
{
    rc4_key((RC4_KEYSTRUCT*)pbKeyStruct, dwKeyLength, pbKey);
}
   
void
XCryptRC4Crypt(
    IN PUCHAR pbKeyStruct,
    IN ULONG dwInputLength,
    IN PUCHAR pbInput
    )
{
    rc4((RC4_KEYSTRUCT*)pbKeyStruct, dwInputLength, pbInput);
}
   
void
XCryptHMAC(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE HmacData // length must be A_SHA_DIGEST_LEN
    )
{
#define HMAC_K_PADSIZE              64
    BYTE Kipad[HMAC_K_PADSIZE];
    BYTE Kopad[HMAC_K_PADSIZE];
    BYTE HMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];
    ULONG dwBlock;
    A_SHA_CTX shaHash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    RtlZeroMemory(Kipad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kipad, pbKeyMaterial, cbKeyMaterial);

    RtlZeroMemory(Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kopad, pbKeyMaterial, cbKeyMaterial);

    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //
    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)Kipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)Kopad)[dwBlock] ^= 0x5C5C5C5C;
    }

    //
    // prepend Kipad to data, Hash to get H1
    //

    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
    {
        A_SHAUpdate(&shaHash, pbData, cbData);
    }
    if (cbData2 != 0)
    {
        A_SHAUpdate(&shaHash, pbData2, cbData2);
    }

    // Finish off the hash
    A_SHAFinal(&shaHash,HMACTmp+HMAC_K_PADSIZE);

    // prepend Kopad to H1, hash to get HMAC
    RtlCopyMemory(HMACTmp, Kopad, HMAC_K_PADSIZE);

    // final hash: output value into passed-in buffer
    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash,HMACTmp, sizeof(HMACTmp));
    A_SHAFinal(&shaHash,HmacData);
}

ULONG
XCryptPKEncPublic(
    IN PUCHAR pbPubKey,
    IN PUCHAR pbInput,
    IN PUCHAR pbOutput
    )
{
    return BSafeEncPublic((LPBSAFE_PUB_KEY)pbPubKey, pbInput, pbOutput);
}
   
ULONG
XCryptPKDecPrivate(
    IN PUCHAR pbPrvKey,
    IN PUCHAR pbInput,
    IN PUCHAR pbOutput
    )
{
    return BSafeDecPrivate((LPBSAFE_PRV_KEY)pbPrvKey, pbInput, pbOutput);
}

ULONG
XCryptPKGetKeyLen(
    IN PUCHAR pbPubKey
    )
{
    return XCCalcKeyLen(pbPubKey);
}

BOOLEAN
XCryptVerifyPKCS1Signature(
    IN PUCHAR pbSig,
    IN PUCHAR pbPubKey,
    IN PUCHAR pbDigest
    )
{
    BYTE* pbWorkspace = _alloca( 2 * XCCalcKeyLen(pbPubKey) );
    if ( pbWorkspace == NULL )
    {
        return FALSE;
    }
    return XCVerifyDigest(pbSig, pbPubKey, pbWorkspace, pbDigest);
}
   
// compute A = B ^ C mod D, N = len of params in DWORDs
ULONG
XCryptModExp(
    IN LPDWORD pA,
    IN LPDWORD pB,
    IN LPDWORD pC,
    IN LPDWORD pD,
    IN ULONG dwN
    )
{
    //
    // compute A = B ^ C mod D
    //
    return BenalohModExp(pA, pB, pC, pD, dwN);
}
   
void
XCryptDESKeyParity(
    IN PUCHAR pbKey,
    IN ULONG dwKeyLength
    )
{
    desparityonkey(pbKey, dwKeyLength);
}
   
void
XCryptKeyTable(
    IN ULONG dwCipher,
    OUT PUCHAR pbKeyTable,
    IN PUCHAR pbKey
    )
{
    if (dwCipher == XC_SERVICE_DES_CIPHER)
    {
        deskey((DESTable*)pbKeyTable, pbKey);
    }
    else
    {
        // Assume XC_SERVICE_DES3_CIPHER:
        tripledes3key((PDES3TABLE)pbKeyTable, pbKey);
    }
}
   
void
XCryptBlockCrypt(
    IN ULONG dwCipher,
    IN PUCHAR pbOutput,
    IN PUCHAR pbInput,
    IN PUCHAR pbKeyTable,
    IN ULONG dwOp
    )
{
    void (RSA32API *pCipher)(BYTE *, BYTE *, void *, int) = (dwCipher == XC_SERVICE_DES_CIPHER) ? des : tripledes;
    (*pCipher)( pbOutput, pbInput, pbKeyTable, dwOp );
}
   
void
XCryptBlockCryptCBC(
    IN ULONG dwCipher,
    IN ULONG dwInputLength,
    IN PUCHAR pbOutput,
    IN PUCHAR pbInput,
    IN PUCHAR pbKeyTable,
    IN ULONG dwOp,
    IN PUCHAR pbFeedback
    )
{
    BYTE *pbInputEnd = pbInput + dwInputLength;
    void (RSA32API *pCipher)(BYTE *, BYTE *, void *, int) = (dwCipher == XC_SERVICE_DES_CIPHER) ? des : tripledes;
    while (pbInput < pbInputEnd)
    {
        CBC(pCipher, XC_SERVICE_DES_BLOCKLEN, pbOutput, pbInput, pbKeyTable, dwOp, pbFeedback);
        pbInput += XC_SERVICE_DES_BLOCKLEN;
        pbOutput += XC_SERVICE_DES_BLOCKLEN;
    }
}

ULONG
XCryptCryptService(
    IN ULONG dwOp,
    IN void* pArgs
    )
{
    return 0;
}

//
// original ROM Crypto vector, never gets changed.
//
const CRYPTO_VECTOR originalCryptoVector =
{
    XCryptSHAInit,
    XCryptSHAUpdate,
    XCryptSHAFinal,
    XCryptRC4Key,
    XCryptRC4Crypt,
    XCryptHMAC,
    XCryptPKEncPublic,
    XCryptPKDecPrivate,
    XCryptPKGetKeyLen,
    XCryptVerifyPKCS1Signature,
    XCryptModExp,
    XCryptDESKeyParity,
    XCryptKeyTable,
    XCryptBlockCrypt,
    XCryptBlockCryptCBC,
    XCryptCryptService
};

//
// Updated crypto vector, contains pointers to
// the routines that should get called through the ROM entry points.
// Initial is the same as originalCryptoVector.
//
CRYPTO_VECTOR updatedCryptoVector =
{
    XCryptSHAInit,
    XCryptSHAUpdate,
    XCryptSHAFinal,
    XCryptRC4Key,
    XCryptRC4Crypt,
    XCryptHMAC,
    XCryptPKEncPublic,
    XCryptPKDecPrivate,
    XCryptPKGetKeyLen,
    XCryptVerifyPKCS1Signature,
    XCryptModExp,
    XCryptDESKeyParity,
    XCryptKeyTable,
    XCryptBlockCrypt,
    XCryptBlockCryptCBC,
    XCryptCryptService
};

void
XcUpdateCrypto(
    IN PCRYPTO_VECTOR pNewVector,
    OUT OPTIONAL PCRYPTO_VECTOR pROMVector
    )
{
    //
    // Patch the non null routines
    //
    if ( pNewVector->pXcSHAInit )
    {
        updatedCryptoVector.pXcSHAInit = pNewVector->pXcSHAInit;
    }
    if ( pNewVector->pXcSHAUpdate )
    {
        updatedCryptoVector.pXcSHAUpdate = pNewVector->pXcSHAUpdate;
    }
    if ( pNewVector->pXcSHAFinal )
    {
        updatedCryptoVector.pXcSHAFinal = pNewVector->pXcSHAFinal;
    }
    if ( pNewVector->pXcRC4Key )
    {
        updatedCryptoVector.pXcRC4Key = pNewVector->pXcRC4Key;
    }
    if ( pNewVector->pXcRC4Crypt )
    {
        updatedCryptoVector.pXcRC4Crypt = pNewVector->pXcRC4Crypt;
    }
    if ( pNewVector->pXcHMAC )
    {
        updatedCryptoVector.pXcHMAC = pNewVector->pXcHMAC;
    }
    if ( pNewVector->pXcPKEncPublic )
    {
        updatedCryptoVector.pXcPKEncPublic = pNewVector->pXcPKEncPublic;
    }
    if ( pNewVector->pXcPKDecPrivate )
    {
        updatedCryptoVector.pXcPKDecPrivate = pNewVector->pXcPKDecPrivate;
    }
    if ( pNewVector->pXcPKGetKeyLen )
    {
        updatedCryptoVector.pXcPKGetKeyLen = pNewVector->pXcPKGetKeyLen;
    }
    if ( pNewVector->pXcVerifyPKCS1Signature )
    {
        updatedCryptoVector.pXcVerifyPKCS1Signature = pNewVector->pXcVerifyPKCS1Signature;
    }
    if ( pNewVector->pXcModExp )
    {
        updatedCryptoVector.pXcModExp = pNewVector->pXcModExp;
    }
    if ( pNewVector->pXcDESKeyParity )
    {
        updatedCryptoVector.pXcDESKeyParity = pNewVector->pXcDESKeyParity;
    }
    if ( pNewVector->pXcKeyTable )
    {
        updatedCryptoVector.pXcKeyTable = pNewVector->pXcKeyTable;
    }
    if ( pNewVector->pXcBlockCrypt )
    {
        updatedCryptoVector.pXcBlockCrypt = pNewVector->pXcBlockCrypt;
    }
    if ( pNewVector->pXcBlockCryptCBC )
    {
        updatedCryptoVector.pXcBlockCryptCBC = pNewVector->pXcBlockCryptCBC;
    }
    if ( pNewVector->pXcCryptService )
    {
        updatedCryptoVector.pXcCryptService = pNewVector->pXcCryptService;
    }

    //
    // return out the original ROM vector
    //
    if (pROMVector)
    {
        *pROMVector = originalCryptoVector;
    }
}

//
// Exposed ROM crypto routines that jump using the updated vector
//
void
XcSHAInit(
    IN PUCHAR pbSHAContext
    )
{
    (*updatedCryptoVector.pXcSHAInit)(pbSHAContext);
}
   
void
XcSHAUpdate(
    IN PUCHAR pbSHAContext,
    IN PUCHAR pbInput,
    IN ULONG dwInputLength
    )
{
    (*updatedCryptoVector.pXcSHAUpdate)(pbSHAContext, pbInput, dwInputLength);
}
   
void
XcSHAFinal(
    IN PUCHAR pbSHAContext,
    IN PUCHAR pbDigest
    )
{
    (*updatedCryptoVector.pXcSHAFinal)(pbSHAContext, pbDigest);
}
   
void
XcRC4Key(
    IN PUCHAR pbKeyStruct,
    IN ULONG dwKeyLength,
    IN PUCHAR pbKey
    )
{
    (*updatedCryptoVector.pXcRC4Key)(pbKeyStruct, dwKeyLength, pbKey);
}
   
void
XcRC4Crypt(
    IN PUCHAR pbKeyStruct,
    IN ULONG dwInputLength,
    IN PUCHAR pbInput
    )
{
    (*updatedCryptoVector.pXcRC4Crypt)(pbKeyStruct, dwInputLength, pbInput);
}
   
void
XcHMAC(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE pbDigest
    )
{
    (*updatedCryptoVector.pXcHMAC)(pbKeyMaterial, cbKeyMaterial, pbData, cbData, pbData2, cbData2, pbDigest);
}

ULONG
XcPKEncPublic(
    IN PUCHAR pbPubKey,
    IN PUCHAR pbInput,
    IN PUCHAR pbOutput
    )
{
    return (*updatedCryptoVector.pXcPKEncPublic)(pbPubKey, pbInput, pbOutput);
}
   
ULONG
XcPKDecPrivate(
    IN PUCHAR pbPrvKey,
    IN PUCHAR pbInput,
    IN PUCHAR pbOutput
    )
{
    return (*updatedCryptoVector.pXcPKDecPrivate)(pbPrvKey, pbInput, pbOutput);
}

ULONG
XcPKGetKeyLen(
    IN PUCHAR pbPubKey
    )
{
    return (*updatedCryptoVector.pXcPKGetKeyLen)(pbPubKey);
}

BOOLEAN
XcVerifyPKCS1Signature(
    IN PUCHAR pbSig,
    IN PUCHAR pbPubKey,
    IN PUCHAR pbDigest
    )
{
    return (*updatedCryptoVector.pXcVerifyPKCS1Signature)(pbSig, pbPubKey, pbDigest);
}
   
ULONG
XcModExp(
    IN LPDWORD pA,
    IN LPDWORD pB,
    IN LPDWORD pC,
    IN LPDWORD pD,
    IN ULONG dwN
    )
{
    return (*updatedCryptoVector.pXcModExp)(pA, pB, pC, pD, dwN);
}
   
void
XcDESKeyParity(
    IN PUCHAR pbKey,
    IN ULONG dwKeyLength
    )
{
    (*updatedCryptoVector.pXcDESKeyParity)(pbKey, dwKeyLength);
}
   
void
XcKeyTable(
    IN ULONG dwCipher,
    OUT PUCHAR pbKeyTable,
    IN PUCHAR pbKey
    )
{
    (*updatedCryptoVector.pXcKeyTable)(dwCipher, pbKeyTable, pbKey);
}
   
void
XcBlockCrypt(
    IN ULONG dwCipher,
    IN PUCHAR pbOutput,
    IN PUCHAR pbInput,
    IN PUCHAR pbKeyTable,
    IN ULONG dwOp
    )
{
    (*updatedCryptoVector.pXcBlockCrypt)(dwCipher, pbOutput, pbInput, pbKeyTable, dwOp);
}
   
void
XcBlockCryptCBC(
    IN ULONG dwCipher,
    IN ULONG dwInputLength,
    IN PUCHAR pbOutput,
    IN PUCHAR pbInput,
    IN PUCHAR pbKeyTable,
    IN ULONG dwOp,
    IN PUCHAR pbFeedback
    )
{
    (*updatedCryptoVector.pXcBlockCryptCBC)(dwCipher, dwInputLength, pbOutput, pbInput, pbKeyTable, dwOp, pbFeedback);
}

ULONG
XcCryptService(
    IN ULONG dwOp,
    IN void* pArgs
    )
{
    return (*updatedCryptoVector.pXcCryptService)(dwOp, pArgs);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\ddk\inc\dxapi.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dxapi.h

Abstract:

    This file defines the necessary structures, defines, and functions for
    the DXAPI class driver.

Author:
    Bill Parry (billpa)

Environment:

   Kernel mode only

Revision History:

--*/

ULONG
DxApi(
            IN ULONG	dwFunctionNum,
            IN PVOID	lpvInBuffer,
            IN ULONG	cbInBuffer,
            IN PVOID	lpvOutBuffer,
            IN ULONG	cbOutBuffer
);

ULONG
DxApiGetVersion(
);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\ddk\inc\gameport.h ===
/*++
Copyright (c) 1997  Microsoft Corporation

Module Name:

    gameport.h

Abstract:

    This module contains the common public declarations for the game port
    enumerator.

@@BEGIN_DDKSPLIT

Author:

    Kenneth Ray

@@END_DDKSPLIT

Environment:

    kernel mode only

Notes:


Revision History:


--*/


#ifndef __GAMEPORT_H
#define __GAMEPORT_H

#define FILE_DEVICE_GAMEENUM         FILE_DEVICE_BUS_EXTENDER

// ***************************************************************************
// IOCTL interface to the bus (fdo)
//
// Clients use this to tell the enumerator what gaming devices on legacy ports
// exist.  (like for instance a control panel)
// ***************************************************************************

//
// Define an Interface Guid to access the game port enumerator
//

#undef FAR
#define FAR
#undef PHYSICAL_ADDRESS
#define PHYSICAL_ADDRESS LARGE_INTEGER

DEFINE_GUID (GUID_GAMEENUM_BUS_ENUMERATOR, 0xcae56030, 0x684a, 0x11d0, 0xd6, 0xf6, 0x00, 0xa0, 0xc9, 0x0f, 0x57, 0xda);
//  cae56030-684a-11d0-b6f6-00a0c90f57da

#define GAMEENUM_IOCTL(_index_) \
    CTL_CODE (FILE_DEVICE_GAMEENUM, _index_, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define GAMEENUM_INTERNAL_IOCTL(_index_) \
    CTL_CODE (FILE_DEVICE_GAMEENUM, _index_, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_GAMEENUM_EXPOSE_HARDWARE  GAMEENUM_IOCTL (0x0)
#define IOCTL_GAMEENUM_REMOVE_HARDWARE  GAMEENUM_IOCTL (0x1)
#define IOCTL_GAMEENUM_PORT_DESC        GAMEENUM_IOCTL (0x2)

//
//      Private data storage area for OEM devices. Values preserved if supplied to
// IOCTL_GAMEENUM_EXPOSE_HARDWARE and GAMEENUM_INTERNAL_IOCTL_EXPOSE_SIBLING,
//      and set to zero otherwise on initial mini-driver invocation (DriverEntry).
//

#define SIZE_GAMEENUM_OEM_DATA                  8
typedef ULONG   GAMEENUM_OEM_DATA[SIZE_GAMEENUM_OEM_DATA];

#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning(disable:4200)

typedef struct _GAMEENUM_EXPOSE_HARDWARE
{
    //
    // sizeof (struct _GAMEENUM_HARDWARE)
    //
    IN ULONG Size;

    //
    // The handle of the port found in the port desc
    //
    IN PVOID PortHandle;

    //
    // A handle to the exposed PDO
    //
    OUT PVOID HardwareHandle;

    //
    // For legacy joysticks only
    //
    IN USHORT NumberJoysticks;

    //
    // legacy joysticks only (joysticks * axis <= 4).
    //
    IN USHORT NumberAxis;

    //
    // Unique ID
    //
    IN USHORT UnitID;

    //
    // Number of buttons present on the device
    //
    IN USHORT NumberButtons;

    //
    // Reserved for future use
    //
    USHORT Reserved[6];

    //
    // Specific OEM Data
    //
    IN GAMEENUM_OEM_DATA OemData;

    //
    // An array of (zero terminated wide character strings). The array itself
    //  also null terminated (ie, MULTI_SZ)
    //
    IN  WCHAR                                   HardwareIDs[];

} GAMEENUM_EXPOSE_HARDWARE, *PGAMEENUM_EXPOSE_HARDWARE;

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

typedef struct _GAMEENUM_REMOVE_HARDWARE
{
    //
    // sizeof (struct _REMOVE_HARDWARE)
    //
    IN ULONG Size;

    //
    // Same value as HardwareHandle in GAMEENUM_EXPOSE_HARDWARE
    //
    IN PVOID HardwareHandle;

} GAMEENUM_REMOVE_HARDWARE, *PGAMEENUM_REMOVE_HARDWARE;

typedef struct _GAMEENUM_PORT_DESC
{
    IN  ULONG               Size;       // sizeof (struct _PORT_DESC)
    OUT PVOID               PortHandle;
    OUT PHYSICAL_ADDRESS    PortAddress;
        ULONG               Reserved [5];
} GAMEENUM_PORT_DESC, *PGAMEENUM_PORT_DESC;

// **************************************************************************
// Internal IOCTL interface for (pdo)
// The HID to legacy game port minidriver uses this interface to
// find the address of the device.
// **************************************************************************

#define IOCTL_GAMEENUM_PORT_PARAMETERS          GAMEENUM_INTERNAL_IOCTL (0x100)
#define IOCTL_GAMEENUM_EXPOSE_SIBLING           GAMEENUM_INTERNAL_IOCTL (0x101)
#define IOCTL_GAMEENUM_REMOVE_SELF              GAMEENUM_INTERNAL_IOCTL (0x102)
#define IOCTL_GAMEENUM_ACQUIRE_ACCESSORS        GAMEENUM_INTERNAL_IOCTL (0x103)

// Of which IO_STACK_LOCATION->Parameters.Others.Argument1 is set to
// a pointer to struct _GAMEENUM_GAME_PARAMETERS

typedef
UCHAR
(*PGAMEENUM_READPORT) (
    PVOID  GameContext
    );

typedef
VOID
(*PGAMEENUM_WRITEPORT) (
    PVOID  GameContext,
    UCHAR   Value
    );

#define GAMEENUM_BUTTON_1   0x01
#define GAMEENUM_BUTTON_2   0x02
#define GAMEENUM_BUTTON_3   0x04
#define GAMEENUM_BUTTON_4   0x08

#define GAMEENUM_AXIS_X     0x10
#define GAMEENUM_AXIS_Y     0x20
#define GAMEENUM_AXIS_R     0x40
#define GAMEENUM_AXIS_Z     0x80

#ifndef NTSTATUS
typedef LONG NTSTATUS;
#endif

typedef
NTSTATUS
(*PGAMEENUM_READPORT_DIGITAL) (
    IN     PVOID   Context,
    IN     UCHAR   ButtonAxisMask,
    IN     BOOLEAN Approximate,
    IN OUT ULONG   AxisState[4],
       OUT UCHAR   ButtonState[4]
    );
/*++
Routine Description.

    Will read from the gameport digitally.

Arguments:

    Context        -    value passed in GAME_PORT_PARAMETERS.GameContext

    ButtonAxisMask -    Mask indicating which axis  and buttons are expected to
                        have valid data

    Approximate    -    OK to approximate (if polling times out, etc)

    AxisState      -    IN  = Last valid axis state
                        OUT = Current Axis state

                        Index       Maps to Axis
                        0           X
                        1           Y
                        2           R
                        3           Z

    ButtonState    -    OUT =  Current button state.

--*/

typedef
NTSTATUS
(*PGAMEENUM_ACQUIRE_PORT) (
    PVOID  GameContext
    );

typedef
VOID
(*PGAMEENUM_RELEASE_PORT) (
    PVOID  GameContext
    );

typedef enum _GAMEENUM_PORTION
{
        GameenumFirstHalf,
        GameenumSecondHalf,
        GameenumWhole
} GAMEENUM_PORTION;

typedef struct _GAMEENUM_PORT_PARAMETERS
{
    //
    // sizeof (GAMEENUM_GET_PORT_PARAMETERS)
    //
    IN  ULONG Size;

    //
    // read the game port (analog)
    //
    OUT PGAMEENUM_READPORT ReadAccessor;

    //
    // write the game port (analog)
    //
    OUT PGAMEENUM_WRITEPORT WriteAccessor;

    //
    // token to read/write this game port
    //
    OUT PVOID GameContext;

    //
    // Which joystick is it?
    //
    OUT GAMEENUM_PORTION Portion;

    //
    // legacy joysticks only
    //
    OUT USHORT NumberAxis;

    //
    // unique id
    //
    IN USHORT UnitID;

    //
    // OEM specific data
    //
    IN GAMEENUM_OEM_DATA OemData;

    //
    // Number of buttons
    //
    OUT USHORT NumberButtons;

    //
    // Reserved for future use
    //
    USHORT Reserved2;

    //
    // Read the game port (digital)
    //
    OUT PGAMEENUM_READPORT_DIGITAL  ReadAccessorDigital;

    //
    // Function to call before reading/writing to the port
    //
    OUT PGAMEENUM_ACQUIRE_PORT AcquirePort;

    //
    // Function to call when done reading/writing to the port
    //
    OUT PGAMEENUM_RELEASE_PORT ReleasePort;

    //
    // Context to pass to AcquirePort and ReleasePort
    //
    OUT PVOID PortContext;

    ULONG Reserved[3];

} GAMEENUM_PORT_PARAMETERS, *PGAMEENUM_PORT_PARAMETERS;

typedef struct _GAMEENUM_EXPOSE_SIBLING
{
    //
    // sizeof (struct _GAMEENUM_EXPOSE_SIBLING)
    //
    IN ULONG Size;

    //
    // A handle to the exposed PDO
    //
    OUT PVOID HardwareHandle;

    //
    // OEM specific data
    //
    IN GAMEENUM_OEM_DATA OemData;

    //
    // The id of this device object
    //
    IN USHORT UnitID;

    USHORT Reserved[3];

    //
    // An array of (zero terminated wide character strings). The array itself
    //  also null terminated (ie, MULTI_SZ),
    //
    IN PWCHAR HardwareIDs OPTIONAL;

} GAMEENUM_EXPOSE_SIBLING, *PGAMEENUM_EXPOSE_SIBLING;

//
// This struct is sent down to the PDO/lower filters of gameenum via
// the internal IOCTL  IOCTL_GAMEENUM_ACQUIRE_ACCESSORS.  If this IOCTL is
// handled, GameContext, ReadAccessor, and WriteAccessor must be filled in.
// ReadAccessorDigital is optional
//
typedef struct _GAMEENUM_ACQUIRE_ACCESSORS
{
    //
    // sizeof (struct _GAMEENUM_ACQUIRE_ACCESSORS)
    //
    IN ULONG                        Size;

    //
    // token to read/write this game port
    //
    OUT PVOID                       GameContext;

    //
    // read the game port (analog)
    //
    OUT PGAMEENUM_READPORT          ReadAccessor;

    //
    // write the game port (analog)
    //
    OUT PGAMEENUM_WRITEPORT         WriteAccessor;

    //
    // Read the game port (digital)
    //
    OUT PGAMEENUM_READPORT_DIGITAL  ReadAccessorDigital;

    //
    // Function to call before reading/writing to the port
    //
    OUT PGAMEENUM_ACQUIRE_PORT AcquirePort;

    //
    // Function to call when done reading/writing to the port
    //
    OUT PGAMEENUM_RELEASE_PORT ReleasePort;

    //
    // Context to pass to AcquirePort and ReleasePort
    //
    OUT PVOID PortContext;

    OUT ULONG                       Reserved[3];

} GAMEENUM_ACQUIRE_ACCESSORS, *PGAMEENUM_ACQUIRE_ACCESSORS;

#endif



=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\ddk\inc\i2cgpio.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996 - 1997  Microsoft Corporation.  All Rights Reserved.
//
//@@BEGIN_DDKSPLIT 
//
// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING 
//
//  The files 
//      \wdm10\ddk\inc\i2cgpio.h
//      \dev\ddk\inc\i2cgpio.h
//  Are the same.
//
//  When changing either file, be sure to update the other file in the other
//  directory. This has been done to ensure that the DirectX DDK can pull
//  I2CGPIO.H into its DDK from \dev\ddk\inc, and not have to enlist in the
//  \wdm10 ddk.
//
//@@END_DDKSPLIT
//==========================================================================;

#if 0
To access the IO functionality in a WDM driver or the VDD, WDM driver sends 
the following IRP to its parent.

MajorFunction = IRP_MJ_PNP;
MinorFunction = IRP_MN_QUERY_INTERFACE;

Guid = DEFINE_GUID( GUID_GPIO_INTERFACE, 
        0x02295e87L, 0xbb3f, 0x11d0, 0x80, 0xce, 0x0, 0x20, 0xaf, 0xf7, 0x49, 0x1e);

The QUERY_INTERFACE Irp will return an interface (set of function pointers)
of the type xxxxINTERFACE, defined below. This is essentially a table of
function pointers.

#endif

#ifndef __I2CGPIO_H__
#define __I2CGPIO_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// Guids
//
// DEFINE_GUID requires that you include wdm.h before this file.
// #define INITGUID to actually initialize the guid in memory.
//
DEFINE_GUID( GUID_I2C_INTERFACE, 0x02295e86L, 0xbb3f, 0x11d0, 0x80, 0xce, 0x0, 0x20, 0xaf, 0xf7, 0x49, 0x1e);
DEFINE_GUID( GUID_GPIO_INTERFACE,0x02295e87L, 0xbb3f, 0x11d0, 0x80, 0xce, 0x0, 0x20, 0xaf, 0xf7, 0x49, 0x1e);
DEFINE_GUID( GUID_COPYPROTECTION_INTERFACE, 0x02295e88L, 0xbb3f, 0x11d0, 0x80, 0xce, 0x0, 0x20, 0xaf, 0xf7, 0x49, 0x1e);

//==========================================================================;
// used below if neccessary
#ifndef BYTE
#define BYTE UCHAR
#endif
#ifndef DWORD
#define DWORD ULONG
#endif
//==========================================================================;
//
// I2C section
//
// I2C Commands
#define I2C_COMMAND_NULL         0X0000
#define I2C_COMMAND_READ         0X0001
#define I2C_COMMAND_WRITE        0X0002
#define I2C_COMMAND_STATUS       0X0004
#define I2C_COMMAND_RESET        0X0008

// The following flags are provided on a READ or WRITE command
#define I2C_FLAGS_START          0X0001 // START + addx
#define I2C_FLAGS_STOP           0X0002 // STOP
#define I2C_FLAGS_DATACHAINING   0X0004 // STOP, START + addx 
#define I2C_FLAGS_ACK            0X0010 // ACKNOWLEDGE (normally set)

// The following status flags are returned on completion of the operation
#define I2C_STATUS_NOERROR       0X0000  
#define I2C_STATUS_BUSY          0X0001
#define I2C_STATUS_ERROR         0X0002

typedef struct _I2CControl {
        ULONG Command;          // I2C_COMMAND_*
        DWORD dwCookie;         // Context identifier returned on Open
        BYTE  Data;             // Data to write, or returned byte
        BYTE  Reserved[3];      // Filler
        ULONG Flags;            // I2C_FLAGS_*
        ULONG Status;           // I2C_STATUS_*
        ULONG ClockRate;        // Bus clockrate in Hz.
} I2CControl, *PI2CControl;

// this is the Interface definition for I2C
//
typedef NTSTATUS (STDMETHODCALLTYPE *I2COPEN)(PDEVICE_OBJECT, ULONG, PI2CControl);
typedef NTSTATUS (STDMETHODCALLTYPE *I2CACCESS)(PDEVICE_OBJECT, PI2CControl);

typedef struct {
    INTERFACE _vddInterface;
    I2COPEN   i2cOpen;
    I2CACCESS i2cAccess;
} I2CINTERFACE;

//==========================================================================;
//
// GPIO section
//
// GPIO Commands

#define GPIO_COMMAND_QUERY          0X0001      // get #pins and nBufferSize
#define GPIO_COMMAND_OPEN           0X0001      // old open
#define GPIO_COMMAND_OPEN_PINS      0X0002      // get dwCookie
#define GPIO_COMMAND_CLOSE_PINS     0X0004      // invalidate cookie
#define GPIO_COMMAND_READ_BUFFER    0X0008
#define GPIO_COMMAND_WRITE_BUFFER   0X0010

// The following flags are provided on a READ_BUFFER or WRITE_BUFFER command
// lpPins bits set MUST have contiguous bits set for a read/write command.
//
// On a READ, if the number of pins set in the bitmask does not fill a 
// byte/word/dword, then zeros are returned for those positions. 
// on a WRITE, if the number of pins set in the bitmask does not fill a 
// byte/word/dword, a read/modify/write is done on the port/mmio position
// that represents those bits.

#define GPIO_FLAGS_BYTE             0x0001  // do byte read/write
#define GPIO_FLAGS_WORD             0x0002  // do word read/write
#define GPIO_FLAGS_DWORD            0x0004  // do dword read/write

// The following status flags are returned on completion of the operation
#define GPIO_STATUS_NOERROR     0X0000  
#define GPIO_STATUS_BUSY        0X0001
#define GPIO_STATUS_ERROR       0X0002
#define GPIO_STATUS_NO_ASYNCH   0X0004  // gpio provider does not do asynch xfer

typedef struct _GPIOControl {
    ULONG Command;          // GPIO_COMMAND_*
    ULONG Flags;            // GPIO_FLAGS_*
    DWORD dwCookie;         // Context identifier returned on Open
    ULONG Status;           // GPIO_STATUS_*
    ULONG nBytes;           // # of bytes to send or recieved
    ULONG nBufferSize;      // max size of buffer
    ULONG nPins;            // number of GPIO pins returned by Open
    UCHAR *Pins;            // pointer to bitmask of pins to read/write
    UCHAR *Buffer;          // pointer to GPIO data to send/recieve
    void  (*AsynchCompleteCallback)(UCHAR *Buffer);
                            // NULL if synchronous xfer, valid ptr if asynch.
    GUID  PrivateInterfaceType;
    void  (*PrivateInterface)();
    
} GPIOControl, *PGPIOControl;

// This is the GPIO interface
//
typedef NTSTATUS (STDMETHODCALLTYPE *GPIOOPEN)(PDEVICE_OBJECT, ULONG, PGPIOControl);
typedef NTSTATUS (STDMETHODCALLTYPE *GPIOACCESS)(PDEVICE_OBJECT, PGPIOControl);

typedef struct {
    INTERFACE _vddInterface;
    GPIOOPEN   gpioOpen;
    GPIOACCESS gpioAccess;
} GPIOINTERFACE;

//==========================================================================;
#ifdef    __cplusplus
}
#endif // __cplusplus

#endif //__I2CGPIO_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\ddk\inc\makefile.inc ===
TARGETSRCS0= \
        $(SDK_INC_PATH)\ntddstor.h \
        $(SDK_INC_PATH)\ntdddisk.h \
        $(SDK_INC_PATH)\ntddscsi.h \
        $(SDK_INC_PATH)\ntddcdrm.h

clean:
	-del /F /Q $(NTTARGETFILE0)

#
# ntdd*
#

$(SDK_INC_PATH)\ntddstor.h : ntddstor.x
    hsplit -o $@ nul -bt2 BEGIN_MSINTERNAL END_MSINTERNAL -c @@ ntddstor.x

$(SDK_INC_PATH)\ntdddisk.h : ntdddisk.x
    hsplit -o $@ nul -bt2 BEGIN_MSINTERNAL END_MSINTERNAL -c @@ ntdddisk.x

$(SDK_INC_PATH)\ntddcdrm.h : ntddcdrm.x
    hsplit -o $@ nul -bt2 BEGIN_MSINTERNAL END_MSINTERNAL -c @@ ntddcdrm.x

$(SDK_INC_PATH)\ntddscsi.h : ntddscsi.x
    hsplit -o $@ nul -bt2 BEGIN_MSINTERNAL END_MSINTERNAL -c @@ ntddscsi.x

#
# usb.h, usbd.h, and hcdi.h
#

$(USBD_PATH)\usbd.h: usb.x
    hsplit -ta usbd -ts usb -ts hcdi -ts usbxapi -ta usbandusbd -ta hcdiandusbd -ta usbxapiandusbd -ta nohcdi -ta nousbxapi -o $@ -i usb.x

$(USB_INC_PATH)\hcdi.h: usb.x
    hsplit -ts usbd -ts usb -ta hcdi -ts usbxapi -ts usbandusbd -ta hcdiandusbd -ts usbxapiandusbd -ts nohcdi -ta nousbxapi -o $@ -i usb.x

$(DDK_INC_PATH)\usb.h: usb.x
    hsplit -ts usbd -ta usb -ts hcdi -ts usbxapi -ta usbandusbd -ts hcdiandusbd -ts usbxapiandusbd -ta nohcdi -ta nousbxapi -o $@ -i usb.x

$(PRIVATE_INC_PATH)\usbxapi.h: usb.x
    hsplit -ts usbd -ts usb -ts hcdi -ta usbxapi -ts usbandusbd -ts hcdiandusbd -ta usbxapiandusbd -ta nohcdi -ts nousbxapi -o $@ -i usb.x


#Inference rules
.SUFFIXES :.h .ref	

# Copy .h files from here to public\sdk\inc
{}.h{$(SDK_INC_PATH)}.h:
	 copy $** $@

# Copy .ref files from here to public\sdk\inc
{}.ref{$(SDK_INC_PATH)}.ref:
	 copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\ddk\inc\vfwext.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    VfWExt.h

Abstract:

    Constants and function prototypes needed to create IHV's extension DLL
    and constants used to programatically open a target capture device.
    
    
Author:
    
    Yee J. Wu (ezuwu) 15-September-97

Environment:

    User mode only

Revision History:

--*/

#include <prsht.h>

#define VFW_HIDE_SETTINGS_PAGE       0x00000001
#define VFW_HIDE_VIDEOSRC_PAGE       0x00000002
#define VFW_HIDE_CAMERACONTROL_PAGE  0x00000004
#define VFW_HIDE_ALL_PAGES           (VFW_HIDE_SETTINGS_PAGE |\
                                     VFW_HIDE_VIDEOSRC_PAGE  |\
                                     VFW_HIDE_CAMERACONTROL_PAGE)
#define VFW_OEM_ADD_PAGE             0x80000000  // If OEM has added any page


#define VFW_USE_DEVICE_HANDLE        0x00000001
#define VFW_USE_STREAM_HANDLE        0x00000002
#define VFW_QUERY_DEV_CHANGED        0x00000100  // if selected_dev == streaming_dev


//
// This is the function pointer that vfwwdm mapper calls to add an page
//
typedef 
DWORD (CALLBACK FAR * VFWWDMExtensionProc)(
	LPVOID					pfnDeviceIoControl, 
	LPFNADDPROPSHEETPAGE	pfnAddPropertyPage, 
	LPARAM					lParam);

//
// This is the function pointer that you can call to make DeviceIoControl() calls.
//
typedef 
BOOL (CALLBACK FAR * LPFNEXTDEVIO)(
					LPARAM lParam,	
					DWORD dwFlags,
					DWORD dwIoControlCode, 
					LPVOID lpInBuffer, 
					DWORD nInBufferSize, 
					LPVOID lpOutBuffer, 
					DWORD nOutBufferSize, 
					LPDWORD lpBytesReturned,
					LPOVERLAPPED lpOverlapped);
               

//                                                             
// HLM\System\CurrentControlSet\Control\MediaResources\msvideo\MSVideo.VFWWDM 
//
// Registry values used to allow a VfW client application to programatically
// open a target capture device.  The first is the FriendlyName of the capture
// device; and the 2nd flag if set, vfwwdm mapper will open only; if failed, 
// no attempt will be made by VfWWDM mapper to open other WDM capture device.
//
// Both registry value should be clear after capDriverConnect().  VfWWDM mapper
// will not clear them unless video source dialog box is chosen.
//                
#define TARGET_DEVICE_FRIENDLY_NAME     "TargetDeviceFriendlyName"      // REG_SZ
#define TARGET_DEVICE_OPEN_EXCLUSIVELY  "TargetDeviceOpenExclusively"   // REG_DWORD
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\ddk\inc\wdmwarn4.h ===
/*
Include before wdm.h to be able to compile at warning level 4
*/

/*
4214
4201 nonstandard extension using nameless struct/union
4115
4200
4514 unreferenced inline function
**4100 unreferenced formal parameter
4057
*/

#pragma warning(disable:4214 4201 4115 4200 4100 4514 4057 4127)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\ddk\inc\unknown.h ===
/*****************************************************************************
 * unknown.h - IUnknown definitions
 *****************************************************************************
 * Copyright (c) 1996 Microsoft Corporation
 */

#ifndef _UNKNOWN_H_
#define _UNKNOWN_H_

#ifdef __cplusplus
extern "C" {
#include <wdm.h>
}
#else
#include <wdm.h>
#endif

#include <windef.h>
#define COM_NO_WINDOWS_H
#include <basetyps.h>
#ifdef PUT_GUIDS_HERE
#include <initguid.h>
#endif





DEFINE_GUID(IID_IUnknown,
0x00000000, 0x0000, 0x0000, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);
#if defined(__cplusplus) && _MSC_VER >= 1100
struct __declspec(uuid("00000000-0000-0000-c000-000000000046")) IUnknown;
#endif

/*****************************************************************************
 * IUnknown
 *****************************************************************************
 * Base interface for otherwise unknown objects.
 */
#undef INTERFACE
#define INTERFACE IUnknown
DECLARE_INTERFACE(IUnknown)
{
    STDMETHOD(QueryInterface)
    (   THIS_
        IN      REFIID,
        OUT     PVOID *
    )   PURE;

    STDMETHOD_(ULONG,AddRef)
    (   THIS
    )   PURE;

    STDMETHOD_(ULONG,Release)
    (   THIS
    )   PURE;
};
#undef INTERFACE

typedef IUnknown *PUNKNOWN;

/*****************************************************************************
 * PFNCREATEINSTANCE
 *****************************************************************************
 * Type for object create function.
 */
typedef
HRESULT
(*PFNCREATEINSTANCE)
(
    OUT PUNKNOWN *  Unknown,
    IN  REFCLSID    ClassId,
    IN  PUNKNOWN    OuterUnknown,
    IN  POOL_TYPE   PoolType
);





#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\ddk\inc\wdm.h ===
/*++ BUILD Version: 0110    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    wdm.h

Abstract:

    This module defines the WDM types, constants, and functions that are
    exposed to device drivers.

Revision History:

--*/

#ifndef _WDMDDK_
#define _WDMDDK_
#define _NTDDK_

#define NT_INCLUDED
#define _CTYPE_DISABLE_MACROS

#include <excpt.h>
#include <ntdef.h>
#include <ntstatus.h>
#include <bugcodes.h>
#include <ntiologc.h>

//
// Define types that are not exported.
//

typedef struct _KTHREAD *PKTHREAD;
typedef struct _ETHREAD *PETHREAD;
typedef struct _EPROCESS *PEPROCESS;
typedef struct _KINTERRUPT *PKINTERRUPT;
typedef struct _IO_TIMER *PIO_TIMER;

typedef struct _OBJECT_TYPE *POBJECT_TYPE;
typedef struct _CALLBACK_OBJECT *PCALLBACK_OBJECT;

typedef struct _SECURITY_QUALITY_OF_SERVICE *PSECURITY_QUALITY_OF_SERVICE;
typedef struct _ACCESS_STATE *PACCESS_STATE;

#if defined(_M_ALPHA)
void *__rdthread(void);
#pragma intrinsic(__rdthread)

unsigned char __swpirql(unsigned char);
#pragma intrinsic(__swpirql)

void *__rdpcr(void);
#pragma intrinsic(__rdpcr)
#define PCR ((PKPCR)__rdpcr())

#define KeGetCurrentThread() ((struct _KTHREAD *) __rdthread())
#endif // defined(_M_ALPHA)

#if defined(_M_IX86)
PKTHREAD NTAPI KeGetCurrentThread();
#endif // defined(_M_IX86)

#if defined(_M_IA64)

//
// Define base address for kernel and user space
//

#ifdef _WIN64

#define UREGION_INDEX 1

#define KREGION_INDEX 7

#define UADDRESS_BASE ((ULONG_PTR)UREGION_INDEX << 61)

#define KADDRESS_BASE ((ULONG_PTR)KREGION_INDEX << 61)

#else  // !_WIN64

#define KADDRESS_BASE 0

#define UADDRESS_BASE 0

#endif // !_WIN64

//
// Define Address of Processor Control Registers.
//

#define KIPCR ((ULONG_PTR)(KADDRESS_BASE + 0xffff0000))            // kernel address of first PCR

//
// Define Pointer to Processor Control Registers.
//

#define PCR ((volatile KPCR * const)KIPCR)

PKTHREAD NTAPI KeGetCurrentThread();

#endif // defined(_M_IA64)

#ifndef FAR
#define FAR
#endif

#define PsGetCurrentProcess() IoGetCurrentProcess()
#define PsGetCurrentThread() ((PETHREAD) (KeGetCurrentThread()))
extern PCCHAR KeNumberProcessors;


#if defined(_WIN64)

typedef union _SLIST_HEADER {
    ULONGLONG Alignment;
    struct {
        ULONGLONG Depth : 16;
        ULONGLONG Sequence : 8;
        ULONGLONG Next : 40;
    };
} SLIST_HEADER, *PSLIST_HEADER;

#else

typedef union _SLIST_HEADER {
    ULONGLONG Alignment;
    struct {
        SINGLE_LIST_ENTRY Next;
        USHORT Depth;
        USHORT Sequence;
    };
} SLIST_HEADER, *PSLIST_HEADER;

#endif


//
// Define alignment macros to align structure sizes and pointers up and down.
//

#define ALIGN_DOWN(length, type) \
    ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type) \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))

#define ALIGN_DOWN_POINTER(address, type) \
    ((PVOID)((ULONG_PTR)(address) & ~((ULONG_PTR)sizeof(type) - 1)))

#define ALIGN_UP_POINTER(address, type) \
    (ALIGN_DOWN_POINTER(((ULONG_PTR)(address) + sizeof(type) - 1), type))

#define POOL_TAGGING 1

#ifndef DBG
#define DBG 0
#endif

#if DBG
#define IF_DEBUG if (TRUE)
#else
#define IF_DEBUG if (FALSE)
#endif

#if DEVL


extern ULONG NtGlobalFlag;

#define IF_NTOS_DEBUG( FlagName ) \
    if (NtGlobalFlag & (FLG_ ## FlagName))

#else
#define IF_NTOS_DEBUG( FlagName ) if (FALSE)
#endif

//
// Kernel definitions that need to be here for forward reference purposes
//


//
// Processor modes.
//

typedef CCHAR KPROCESSOR_MODE;

typedef enum _MODE {
    KernelMode,
    UserMode,
    MaximumMode
} MODE;


//
// APC function types
//

//
// Put in an empty definition for the KAPC so that the
// routines can reference it before it is declared.
//

struct _KAPC;

typedef
VOID
(*PKNORMAL_ROUTINE) (
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

typedef
VOID
(*PKKERNEL_ROUTINE) (
    IN struct _KAPC *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID *NormalContext,
    IN OUT PVOID *SystemArgument1,
    IN OUT PVOID *SystemArgument2
    );

typedef
VOID
(*PKRUNDOWN_ROUTINE) (
    IN struct _KAPC *Apc
    );

typedef
BOOLEAN
(*PKSYNCHRONIZE_ROUTINE) (
    IN PVOID SynchronizeContext
    );

typedef
BOOLEAN
(*PKTRANSFER_ROUTINE) (
    VOID
    );

//
//
// Asynchronous Procedure Call (APC) object
//

typedef struct _KAPC {
    CSHORT Type;
    CSHORT Size;
    ULONG Spare0;
    struct _KTHREAD *Thread;
    LIST_ENTRY ApcListEntry;
    PKKERNEL_ROUTINE KernelRoutine;
    PKRUNDOWN_ROUTINE RundownRoutine;
    PKNORMAL_ROUTINE NormalRoutine;
    PVOID NormalContext;

    //
    // N.B. The following two members MUST be together.
    //

    PVOID SystemArgument1;
    PVOID SystemArgument2;
    CCHAR ApcStateIndex;
    KPROCESSOR_MODE ApcMode;
    BOOLEAN Inserted;
} KAPC, *PKAPC, *RESTRICTED_POINTER PRKAPC;


//
// DPC routine
//

struct _KDPC;

typedef
VOID
(*PKDEFERRED_ROUTINE) (
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

//
// Define DPC importance.
//
// LowImportance - Queue DPC at end of target DPC queue.
// MediumImportance - Queue DPC at end of target DPC queue.
// HighImportance - Queue DPC at front of target DPC DPC queue.
//
// If there is currently a DPC active on the target processor, or a DPC
// interrupt has already been requested on the target processor when a
// DPC is queued, then no further action is necessary. The DPC will be
// executed on the target processor when its queue entry is processed.
//
// If there is not a DPC active on the target processor and a DPC interrupt
// has not been requested on the target processor, then the exact treatment
// of the DPC is dependent on whether the host system is a UP system or an
// MP system.
//
// UP system.
//
// If the DPC is of medium or high importance, the current DPC queue depth
// is greater than the maximum target depth, or current DPC request rate is
// less the minimum target rate, then a DPC interrupt is requested on the
// host processor and the DPC will be processed when the interrupt occurs.
// Otherwise, no DPC interupt is requested and the DPC execution will be
// delayed until the DPC queue depth is greater that the target depth or the
// minimum DPC rate is less than the target rate.
//
// MP system.
//
// If the DPC is being queued to another processor and the depth of the DPC
// queue on the target processor is greater than the maximum target depth or
// the DPC is of high importance, then a DPC interrupt is requested on the
// target processor and the DPC will be processed when the interrupt occurs.
// Otherwise, the DPC execution will be delayed on the target processor until
// the DPC queue depth on the target processor is greater that the maximum
// target depth or the minimum DPC rate on the target processor is less than
// the target mimimum rate.
//
// If the DPC is being queued to the current processor and the DPC is not of
// low importance, the current DPC queue depth is greater than the maximum
// target depth, or the minimum DPC rate is less than the minimum target rate,
// then a DPC interrupt is request on the current processor and the DPV will
// be processed whne the interrupt occurs. Otherwise, no DPC interupt is
// requested and the DPC execution will be delayed until the DPC queue depth
// is greater that the target depth or the minimum DPC rate is less than the
// target rate.
//

typedef enum _KDPC_IMPORTANCE {
    LowImportance,
    MediumImportance,
    HighImportance
} KDPC_IMPORTANCE;

//
// Deferred Procedure Call (DPC) object
//

typedef struct _KDPC {
    CSHORT Type;
    UCHAR Number;
    UCHAR Importance;
    LIST_ENTRY DpcListEntry;
    PKDEFERRED_ROUTINE DeferredRoutine;
    PVOID DeferredContext;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
    PULONG_PTR Lock;
} KDPC, *PKDPC, *RESTRICTED_POINTER PRKDPC;

//
// Interprocessor interrupt worker routine function prototype.
//

typedef PVOID PKIPI_CONTEXT;

typedef
VOID
(*PKIPI_WORKER)(
    IN PKIPI_CONTEXT PacketContext,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

//
// Define interprocessor interrupt performance counters.
//

typedef struct _KIPI_COUNTS {
    ULONG Freeze;
    ULONG Packet;
    ULONG DPC;
    ULONG APC;
    ULONG FlushSingleTb;
    ULONG FlushMultipleTb;
    ULONG FlushEntireTb;
    ULONG GenericCall;
    ULONG ChangeColor;
    ULONG SweepDcache;
    ULONG SweepIcache;
    ULONG SweepIcacheRange;
    ULONG FlushIoBuffers;
    ULONG GratuitousDPC;
} KIPI_COUNTS, *PKIPI_COUNTS;

#if defined(NT_UP)

#define HOT_STATISTIC(a) a

#else

#define HOT_STATISTIC(a) (KeGetCurrentPrcb()->a)

#endif

//
// I/O system definitions.
//
// Define a Memory Descriptor List (MDL)
//
// An MDL describes pages in a virtual buffer in terms of physical pages.  The
// pages associated with the buffer are described in an array that is allocated
// just after the MDL header structure itself.  In a future compiler this will
// be placed at:
//
//      ULONG Pages[];
//
// Until this declaration is permitted, however, one simply calculates the
// base of the array by adding one to the base MDL pointer:
//
//      Pages = (PULONG) (Mdl + 1);
//
// Notice that while in the context of the subject thread, the base virtual
// address of a buffer mapped by an MDL may be referenced using the following:
//
//      Mdl->StartVa | Mdl->ByteOffset
//


typedef struct _MDL {
    struct _MDL *Next;
    CSHORT Size;
    CSHORT MdlFlags;
    struct _EPROCESS *Process;
    PVOID MappedSystemVa;
    PVOID StartVa;
    ULONG ByteCount;
    ULONG ByteOffset;
} MDL, *PMDL;

#define MDL_MAPPED_TO_SYSTEM_VA     0x0001
#define MDL_PAGES_LOCKED            0x0002
#define MDL_SOURCE_IS_NONPAGED_POOL 0x0004
#define MDL_ALLOCATED_FIXED_SIZE    0x0008
#define MDL_PARTIAL                 0x0010
#define MDL_PARTIAL_HAS_BEEN_MAPPED 0x0020
#define MDL_IO_PAGE_READ            0x0040
#define MDL_WRITE_OPERATION         0x0080
#define MDL_PARENT_MAPPED_SYSTEM_VA 0x0100
#define MDL_LOCK_HELD               0x0200
#define MDL_PHYSICAL_VIEW           0x0400
#define MDL_IO_SPACE                0x0800
#define MDL_NETWORK_HEADER          0x1000
#define MDL_MAPPING_CAN_FAIL        0x2000
#define MDL_ALLOCATED_MUST_SUCCEED  0x4000


#define MDL_MAPPING_FLAGS (MDL_MAPPED_TO_SYSTEM_VA     | \
                           MDL_PAGES_LOCKED            | \
                           MDL_SOURCE_IS_NONPAGED_POOL | \
                           MDL_PARTIAL_HAS_BEEN_MAPPED | \
                           MDL_PARENT_MAPPED_SYSTEM_VA | \
                           MDL_LOCK_HELD               | \
                           MDL_SYSTEM_VA               | \
                           MDL_IO_SPACE )


//
// switch to DBG when appropriate
//

#if DBG
#define PAGED_CODE() \
    if (KeGetCurrentIrql() > APC_LEVEL) { \
    KdPrint(( "EX: Pageable code called at IRQL %d\n", KeGetCurrentIrql() )); \
        ASSERT(FALSE); \
        }
#else
#define PAGED_CODE()
#endif

//
// Define function decoration depending on whether a driver, a file system,
// or a kernel component is being built.
//
#define NTKERNELAPI DECLSPEC_IMPORT         
#define NTHALAPI DECLSPEC_IMPORT         
//
//  Define an access token from a programmer's viewpoint.  The structure is
//  completely opaque and the programer is only allowed to have pointers
//  to tokens.
//

typedef PVOID PACCESS_TOKEN;            

//
// Pointer to a SECURITY_DESCRIPTOR  opaque data type.
//

typedef PVOID PSECURITY_DESCRIPTOR;     

//
// Define a pointer to the Security ID data type (an opaque data type)
//

typedef PVOID PSID;     

typedef ULONG ACCESS_MASK;
typedef ACCESS_MASK *PACCESS_MASK;


//
//  The following are masks for the predefined standard access types
//

#define DELETE                           (0x00010000L)
#define READ_CONTROL                     (0x00020000L)
#define WRITE_DAC                        (0x00040000L)
#define WRITE_OWNER                      (0x00080000L)
#define SYNCHRONIZE                      (0x00100000L)

#define STANDARD_RIGHTS_REQUIRED         (0x000F0000L)

#define STANDARD_RIGHTS_READ             (READ_CONTROL)
#define STANDARD_RIGHTS_WRITE            (READ_CONTROL)
#define STANDARD_RIGHTS_EXECUTE          (READ_CONTROL)

#define STANDARD_RIGHTS_ALL              (0x001F0000L)

#define SPECIFIC_RIGHTS_ALL              (0x0000FFFFL)

//
// AccessSystemAcl access type
//

#define ACCESS_SYSTEM_SECURITY           (0x01000000L)

//
// MaximumAllowed access type
//

#define MAXIMUM_ALLOWED                  (0x02000000L)

//
//  These are the generic rights.
//

#define GENERIC_READ                     (0x80000000L)
#define GENERIC_WRITE                    (0x40000000L)
#define GENERIC_EXECUTE                  (0x20000000L)
#define GENERIC_ALL                      (0x10000000L)


//
//  Define the generic mapping array.  This is used to denote the
//  mapping of each generic access right to a specific access mask.
//

typedef struct _GENERIC_MAPPING {
    ACCESS_MASK GenericRead;
    ACCESS_MASK GenericWrite;
    ACCESS_MASK GenericExecute;
    ACCESS_MASK GenericAll;
} GENERIC_MAPPING;
typedef GENERIC_MAPPING *PGENERIC_MAPPING;


#define LOW_PRIORITY 0              // Lowest thread priority level
#define LOW_REALTIME_PRIORITY 16    // Lowest realtime priority level
#define HIGH_PRIORITY 31            // Highest thread priority level
#define MAXIMUM_PRIORITY 32         // Number of thread priority levels

#define MAXIMUM_WAIT_OBJECTS 64     // Maximum number of wait objects

#define MAXIMUM_SUSPEND_COUNT MAXCHAR // Maximum times thread can be suspended


//
// Thread affinity
//

typedef ULONG KAFFINITY;
typedef KAFFINITY *PKAFFINITY;

//
// Thread priority
//

typedef LONG KPRIORITY;

//
// Spin Lock
//



typedef ULONG_PTR KSPIN_LOCK;
typedef KSPIN_LOCK *PKSPIN_LOCK;



//
// Interrupt routine (first level dispatch)
//

typedef
VOID
(*PKINTERRUPT_ROUTINE) (
    VOID
    );

//
// Profile source types
//
typedef enum _KPROFILE_SOURCE {
    ProfileTime,
    ProfileAlignmentFixup,
    ProfileTotalIssues,
    ProfilePipelineDry,
    ProfileLoadInstructions,
    ProfilePipelineFrozen,
    ProfileBranchInstructions,
    ProfileTotalNonissues,
    ProfileDcacheMisses,
    ProfileIcacheMisses,
    ProfileCacheMisses,
    ProfileBranchMispredictions,
    ProfileStoreInstructions,
    ProfileFpInstructions,
    ProfileIntegerInstructions,
    Profile2Issue,
    Profile3Issue,
    Profile4Issue,
    ProfileSpecialInstructions,
    ProfileTotalCycles,
    ProfileIcacheIssues,
    ProfileDcacheAccesses,
    ProfileMemoryBarrierCycles,
    ProfileLoadLinkedIssues,
    ProfileMaximum
} KPROFILE_SOURCE;

//
// for move macros
//
#ifdef _MAC
#ifndef _INC_STRING
#include <string.h>
#endif /* _INC_STRING */
#else
#include <string.h>
#endif // _MAC

//
// If debugging support enabled, define an ASSERT macro that works.  Otherwise
// define the ASSERT macro to expand to an empty expression.
//

#if DBG
NTSYSAPI
VOID
NTAPI
RtlAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

#define ASSERT( exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, msg )

#else
#define ASSERT( exp )
#define ASSERTMSG( msg, exp )
#endif // DBG

//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)

//
// Subroutines for dealing with the Registry
//

typedef NTSTATUS (NTAPI * PRTL_QUERY_REGISTRY_ROUTINE)(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

typedef struct _RTL_QUERY_REGISTRY_TABLE {
    PRTL_QUERY_REGISTRY_ROUTINE QueryRoutine;
    ULONG Flags;
    PWSTR Name;
    PVOID EntryContext;
    ULONG DefaultType;
    PVOID DefaultData;
    ULONG DefaultLength;

} RTL_QUERY_REGISTRY_TABLE, *PRTL_QUERY_REGISTRY_TABLE;


//
// The following flags specify how the Name field of a RTL_QUERY_REGISTRY_TABLE
// entry is interpreted.  A NULL name indicates the end of the table.
//

#define RTL_QUERY_REGISTRY_SUBKEY   0x00000001  // Name is a subkey and remainder of
                                                // table or until next subkey are value
                                                // names for that subkey to look at.

#define RTL_QUERY_REGISTRY_TOPKEY   0x00000002  // Reset current key to original key for
                                                // this and all following table entries.

#define RTL_QUERY_REGISTRY_REQUIRED 0x00000004  // Fail if no match found for this table
                                                // entry.

#define RTL_QUERY_REGISTRY_NOVALUE  0x00000008  // Used to mark a table entry that has no
                                                // value name, just wants a call out, not
                                                // an enumeration of all values.

#define RTL_QUERY_REGISTRY_NOEXPAND 0x00000010  // Used to suppress the expansion of
                                                // REG_MULTI_SZ into multiple callouts or
                                                // to prevent the expansion of environment
                                                // variable values in REG_EXPAND_SZ

#define RTL_QUERY_REGISTRY_DIRECT   0x00000020  // QueryRoutine field ignored.  EntryContext
                                                // field points to location to store value.
                                                // For null terminated strings, EntryContext
                                                // points to UNICODE_STRING structure that
                                                // that describes maximum size of buffer.
                                                // If .Buffer field is NULL then a buffer is
                                                // allocated.
                                                //

#define RTL_QUERY_REGISTRY_DELETE   0x00000040  // Used to delete value keys after they
                                                // are queried.

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryRegistryValues(
    IN ULONG RelativeTo,
    IN PCWSTR Path,
    IN PRTL_QUERY_REGISTRY_TABLE QueryTable,
    IN PVOID Context,
    IN PVOID Environment OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlWriteRegistryValue(
    IN ULONG RelativeTo,
    IN PCWSTR Path,
    IN PCWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteRegistryValue(
    IN ULONG RelativeTo,
    IN PCWSTR Path,
    IN PCWSTR ValueName
    );

//
// The following values for the RelativeTo parameter determine what the
// Path parameter to RtlQueryRegistryValues is relative to.
//

#define RTL_REGISTRY_ABSOLUTE     0   // Path is a full path
#define RTL_REGISTRY_SERVICES     1   // \Registry\Machine\System\CurrentControlSet\Services
#define RTL_REGISTRY_CONTROL      2   // \Registry\Machine\System\CurrentControlSet\Control
#define RTL_REGISTRY_WINDOWS_NT   3   // \Registry\Machine\Software\Microsoft\Windows NT\CurrentVersion
#define RTL_REGISTRY_DEVICEMAP    4   // \Registry\Machine\Hardware\DeviceMap
#define RTL_REGISTRY_USER         5   // \Registry\User\CurrentUser
#define RTL_REGISTRY_MAXIMUM      6
#define RTL_REGISTRY_HANDLE       0x40000000    // Low order bits are registry handle
#define RTL_REGISTRY_OPTIONAL     0x80000000    // Indicates the key node is optional


NTSYSAPI
NTSTATUS
NTAPI
RtlIntegerToUnicodeString (
    ULONG Value,
    ULONG Base,
    PUNICODE_STRING String
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlInt64ToUnicodeString (
    IN ULONGLONG Value,
    IN ULONG Base OPTIONAL,
    IN OUT PUNICODE_STRING String
    );

#ifdef _WIN64
#define RtlIntPtrToUnicodeString(Value, Base, String) RtlInt64ToUnicodeString(Value, Base, String)
#else
#define RtlIntPtrToUnicodeString(Value, Base, String) RtlIntegerToUnicodeString(Value, Base, String)
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToInteger (
    PUNICODE_STRING String,
    ULONG Base,
    PULONG Value
    );


//
//  String manipulation routines
//

#ifdef _NTSYSTEM_

#define NLS_MB_CODE_PAGE_TAG NlsMbCodePageTag
#define NLS_MB_OEM_CODE_PAGE_TAG NlsMbOemCodePageTag

#else

#define NLS_MB_CODE_PAGE_TAG (*NlsMbCodePageTag)
#define NLS_MB_OEM_CODE_PAGE_TAG (*NlsMbOemCodePageTag)

#endif // _NTSYSTEM_

extern BOOLEAN NLS_MB_CODE_PAGE_TAG;     // TRUE -> Multibyte CP, FALSE -> Singlebyte
extern BOOLEAN NLS_MB_OEM_CODE_PAGE_TAG; // TRUE -> Multibyte CP, FALSE -> Singlebyte

NTSYSAPI
VOID
NTAPI
RtlInitString(
    PSTRING DestinationString,
    PCSZ SourceString
    );

NTSYSAPI
VOID
NTAPI
RtlInitAnsiString(
    PANSI_STRING DestinationString,
    PCSZ SourceString
    );

NTSYSAPI
VOID
NTAPI
RtlInitUnicodeString(
    PUNICODE_STRING DestinationString,
    PCWSTR SourceString
    );

//
// NLS String functions
//

NTSYSAPI
NTSTATUS
NTAPI
RtlAnsiStringToUnicodeString(
    PUNICODE_STRING DestinationString,
    PANSI_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToAnsiString(
    PANSI_STRING DestinationString,
    PUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );


NTSYSAPI
LONG
NTAPI
RtlCompareUnicodeString(
    PUNICODE_STRING String1,
    PUNICODE_STRING String2,
    BOOLEAN CaseInSensitive
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualUnicodeString(
    const UNICODE_STRING *String1,
    const UNICODE_STRING *String2,
    BOOLEAN CaseInSensitive
    );


NTSYSAPI
VOID
NTAPI
RtlCopyUnicodeString(
    PUNICODE_STRING DestinationString,
    PUNICODE_STRING SourceString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeStringToString (
    PUNICODE_STRING Destination,
    PUNICODE_STRING Source
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeToString (
    PUNICODE_STRING Destination,
    PCWSTR Source
    );


NTSYSAPI
VOID
NTAPI
RtlFreeUnicodeString(
    PUNICODE_STRING UnicodeString
    );

NTSYSAPI
VOID
NTAPI
RtlFreeAnsiString(
    PANSI_STRING AnsiString
    );

NTSYSAPI
ULONG
NTAPI
RtlxUnicodeStringToAnsiSize(
    PUNICODE_STRING UnicodeString
    );

//
//  NTSYSAPI
//  ULONG
//  NTAPI
//  RtlUnicodeStringToAnsiSize(
//      PUNICODE_STRING UnicodeString
//      );
//

#define RtlUnicodeStringToAnsiSize(STRING) (                  \
    NLS_MB_CODE_PAGE_TAG ?                                    \
    RtlxUnicodeStringToAnsiSize(STRING) :                     \
    ((STRING)->Length + sizeof(UNICODE_NULL)) / sizeof(WCHAR) \
)


NTSYSAPI
ULONG
NTAPI
RtlxAnsiStringToUnicodeSize(
    PANSI_STRING AnsiString
    );

//
//  NTSYSAPI
//  ULONG
//  NTAPI
//  RtlAnsiStringToUnicodeSize(
//      PANSI_STRING AnsiString
//      );
//

#define RtlAnsiStringToUnicodeSize(STRING) (                 \
    NLS_MB_CODE_PAGE_TAG ?                                   \
    RtlxAnsiStringToUnicodeSize(STRING) :                    \
    ((STRING)->Length + sizeof(ANSI_NULL)) * sizeof(WCHAR) \
)




#include <guiddef.h>



#ifndef DEFINE_GUIDEX
    #define DEFINE_GUIDEX(name) EXTERN_C const CDECL GUID name
#endif // !defined(DEFINE_GUIDEX)

#ifndef STATICGUIDOF
    #define STATICGUIDOF(guid) STATIC_##guid
#endif // !defined(STATICGUIDOF)

#ifndef __IID_ALIGNED__
    #define __IID_ALIGNED__
    #ifdef __cplusplus
        inline int IsEqualGUIDAligned(REFGUID guid1, REFGUID guid2)
        {
            return ((*(PLONGLONG)(&guid1) == *(PLONGLONG)(&guid2)) && (*((PLONGLONG)(&guid1) + 1) == *((PLONGLONG)(&guid2) + 1)));
        }
    #else // !__cplusplus
        #define IsEqualGUIDAligned(guid1, guid2) \
            ((*(PLONGLONG)(guid1) == *(PLONGLONG)(guid2)) && (*((PLONGLONG)(guid1) + 1) == *((PLONGLONG)(guid2) + 1)))
    #endif // !__cplusplus
#endif // !__IID_ALIGNED__

NTSYSAPI
NTSTATUS
NTAPI
RtlStringFromGUID(
    IN REFGUID Guid,
    OUT PUNICODE_STRING GuidString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGUIDFromString(
    IN PUNICODE_STRING GuidString,
    OUT GUID* Guid
    );

//
// Fast primitives to compare, move, and zero memory
//



NTSYSAPI
SIZE_T
NTAPI
RtlCompareMemory (
    const VOID *Source1,
    const VOID *Source2,
    SIZE_T Length
    );

#if defined(_M_AXP64) || defined(_M_IA64)

#define RtlEqualMemory(Source1, Source2, Length) \
    ((Length) == RtlCompareMemory(Source1, Source2, Length))

NTSYSAPI
VOID
NTAPI
RtlCopyMemory (
   VOID UNALIGNED *Destination,
   CONST VOID UNALIGNED *Source,
   SIZE_T Length
   );

NTSYSAPI
VOID
NTAPI
RtlCopyMemory32 (
   VOID UNALIGNED *Destination,
   CONST VOID UNALIGNED *Source,
   ULONG Length
   );

NTSYSAPI
VOID
NTAPI
RtlMoveMemory (
   VOID UNALIGNED *Destination,
   CONST VOID UNALIGNED *Source,
   SIZE_T Length
   );

NTSYSAPI
VOID
NTAPI
RtlFillMemory (
   VOID UNALIGNED *Destination,
   SIZE_T Length,
   UCHAR Fill
   );

NTSYSAPI
VOID
NTAPI
RtlZeroMemory (
   VOID UNALIGNED *Destination,
   SIZE_T Length
   );

#else

#define RtlEqualMemory(Destination,Source,Length) (!memcmp((Destination),(Source),(Length)))
#define RtlMoveMemory(Destination,Source,Length) memmove((Destination),(Source),(Length))
#define RtlCopyMemory(Destination,Source,Length) memcpy((Destination),(Source),(Length))
#define RtlFillMemory(Destination,Length,Fill) memset((Destination),(Fill),(Length))
#define RtlZeroMemory(Destination,Length) memset((Destination),0,(Length))

#endif



#if defined(_M_ALPHA)

//
// Guaranteed byte granularity memory copy function.
//

NTSYSAPI
VOID
NTAPI
RtlCopyBytes (
   PVOID Destination,
   CONST VOID *Source,
   SIZE_T Length
   );

//
// Guaranteed byte granularity memory zero function.
//

NTSYSAPI
VOID
NTAPI
RtlZeroBytes (
   PVOID Destination,
   SIZE_T Length
   );

//
// Guaranteed byte granularity memory fill function.
//

NTSYSAPI
VOID
NTAPI
RtlFillBytes (
    PVOID Destination,
    SIZE_T Length,
    UCHAR Fill
    );

#else

#define RtlCopyBytes RtlCopyMemory
#define RtlZeroBytes RtlZeroMemory
#define RtlFillBytes RtlFillMemory

#endif

//
// Define kernel debugger print prototypes and macros.
//
// N.B. The following function cannot be directly imported because there are
//      a few places in the source tree where this function is redefined.
//

VOID
NTAPI
DbgBreakPoint(
    VOID
    );


#define DBG_STATUS_CONTROL_C        1
#define DBG_STATUS_SYSRQ            2
#define DBG_STATUS_BUGCHECK_FIRST   3
#define DBG_STATUS_BUGCHECK_SECOND  4
#define DBG_STATUS_FATAL            5
#define DBG_STATUS_DEBUG_CONTROL    6

#if DBG

#define KdPrint(_x_) DbgPrint _x_
#define KdBreakPoint() DbgBreakPoint()


#else

#define KdPrint(_x_)
#define KdBreakPoint()

#endif

#ifndef _DBGNT_

ULONG
_cdecl
DbgPrint(
    PCH Format,
    ...
    );

#endif // _DBGNT_
//
// Large integer arithmetic routines.
//

//
// Large integer add - 64-bits + 64-bits -> 64-bits
//

#if !defined(MIDL_PASS)

__inline
LARGE_INTEGER
NTAPI
RtlLargeIntegerAdd (
    LARGE_INTEGER Addend1,
    LARGE_INTEGER Addend2
    )
{
    LARGE_INTEGER Sum;

    Sum.QuadPart = Addend1.QuadPart + Addend2.QuadPart;
    return Sum;
}

//
// Enlarged integer multiply - 32-bits * 32-bits -> 64-bits
//

__inline
LARGE_INTEGER
NTAPI
RtlEnlargedIntegerMultiply (
    LONG Multiplicand,
    LONG Multiplier
    )
{
    LARGE_INTEGER Product;

    Product.QuadPart = (LONGLONG)Multiplicand * (ULONGLONG)Multiplier;
    return Product;
}

//
// Unsigned enlarged integer multiply - 32-bits * 32-bits -> 64-bits
//

__inline
LARGE_INTEGER
NTAPI
RtlEnlargedUnsignedMultiply (
    ULONG Multiplicand,
    ULONG Multiplier
    )
{
    LARGE_INTEGER Product;

    Product.QuadPart = (ULONGLONG)Multiplicand * (ULONGLONG)Multiplier;
    return Product;
}

//
// Enlarged integer divide - 64-bits / 32-bits > 32-bits
//

__inline
ULONG
NTAPI
RtlEnlargedUnsignedDivide (
    IN ULARGE_INTEGER Dividend,
    IN ULONG Divisor,
    IN PULONG Remainder
    )
{
    ULONG Quotient;

    Quotient = (ULONG)(Dividend.QuadPart / Divisor);
    if (ARGUMENT_PRESENT( Remainder )) {

        *Remainder = (ULONG)(Dividend.QuadPart % Divisor);
    }

    return Quotient;
}

//
// Large integer negation - -(64-bits)
//

__inline
LARGE_INTEGER
NTAPI
RtlLargeIntegerNegate (
    LARGE_INTEGER Subtrahend
    )
{
    LARGE_INTEGER Difference;

    Difference.QuadPart = -Subtrahend.QuadPart;
    return Difference;
}

//
// Large integer subtract - 64-bits - 64-bits -> 64-bits.
//

__inline
LARGE_INTEGER
NTAPI
RtlLargeIntegerSubtract (
    LARGE_INTEGER Minuend,
    LARGE_INTEGER Subtrahend
    )
{
    LARGE_INTEGER Difference;

    Difference.QuadPart = Minuend.QuadPart - Subtrahend.QuadPart;
    return Difference;
}

#endif

//
// Extended large integer magic divide - 64-bits / 32-bits -> 64-bits
//

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlExtendedMagicDivide (
    LARGE_INTEGER Dividend,
    LARGE_INTEGER MagicDivisor,
    CCHAR ShiftCount
    );

//
// Large Integer divide - 64-bits / 32-bits -> 64-bits
//

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlExtendedLargeIntegerDivide (
    LARGE_INTEGER Dividend,
    ULONG Divisor,
    PULONG Remainder
    );

//
// Extended integer multiply - 32-bits * 64-bits -> 64-bits
//

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlExtendedIntegerMultiply (
    LARGE_INTEGER Multiplicand,
    LONG Multiplier
    );

//
// Large integer and - 64-bite & 64-bits -> 64-bits.
//

#define RtlLargeIntegerAnd(Result, Source, Mask)   \
        {                                           \
            Result.HighPart = Source.HighPart & Mask.HighPart; \
            Result.LowPart = Source.LowPart & Mask.LowPart; \
        }

//
// Large integer conversion routines.
//

#if defined(MIDL_PASS) || defined(__cplusplus) || !defined(_M_IX86)

//
// Convert signed integer to large integer.
//

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlConvertLongToLargeInteger (
    LONG SignedInteger
    );

//
// Convert unsigned integer to large integer.
//

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlConvertUlongToLargeInteger (
    ULONG UnsignedInteger
    );


//
// Large integer shift routines.
//

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlLargeIntegerShiftLeft (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    );

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlLargeIntegerShiftRight (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    );

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlLargeIntegerArithmeticShift (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    );

#else

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4035)               // re-enable below

//
// Convert signed integer to large integer.
//

__inline LARGE_INTEGER
NTAPI
RtlConvertLongToLargeInteger (
    LONG SignedInteger
    )
{
    __asm {
        mov     eax, SignedInteger
        cdq                 ; (edx:eax) = signed LargeInt
    }
}

//
// Convert unsigned integer to large integer.
//

__inline LARGE_INTEGER
NTAPI
RtlConvertUlongToLargeInteger (
    ULONG UnsignedInteger
    )
{
    __asm {
        sub     edx, edx    ; zero highpart
        mov     eax, UnsignedInteger
    }
}

//
// Large integer shift routines.
//

__inline LARGE_INTEGER
NTAPI
RtlLargeIntegerShiftLeft (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    )
{
    __asm    {
        mov     cl, ShiftCount
        and     cl, 0x3f                    ; mod 64

        cmp     cl, 32
        jc      short sl10

        mov     edx, LargeInteger.LowPart   ; ShiftCount >= 32
        xor     eax, eax                    ; lowpart is zero
        shl     edx, cl                     ; store highpart
        jmp     short done

sl10:
        mov     eax, LargeInteger.LowPart   ; ShiftCount < 32
        mov     edx, LargeInteger.HighPart
        shld    edx, eax, cl
        shl     eax, cl
done:
    }
}


__inline LARGE_INTEGER
NTAPI
RtlLargeIntegerShiftRight (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    )
{
    __asm    {
        mov     cl, ShiftCount
        and     cl, 0x3f               ; mod 64

        cmp     cl, 32
        jc      short sr10

        mov     eax, LargeInteger.HighPart  ; ShiftCount >= 32
        xor     edx, edx                    ; lowpart is zero
        shr     eax, cl                     ; store highpart
        jmp     short done

sr10:
        mov     eax, LargeInteger.LowPart   ; ShiftCount < 32
        mov     edx, LargeInteger.HighPart
        shrd    eax, edx, cl
        shr     edx, cl
done:
    }
}


__inline LARGE_INTEGER
NTAPI
RtlLargeIntegerArithmeticShift (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    )
{
    __asm {
        mov     cl, ShiftCount
        and     cl, 3fh                 ; mod 64

        cmp     cl, 32
        jc      short sar10

        mov     eax, LargeInteger.HighPart
        sar     eax, cl
        bt      eax, 31                     ; sign bit set?
        sbb     edx, edx                    ; duplicate sign bit into highpart
        jmp     short done
sar10:
        mov     eax, LargeInteger.LowPart   ; (eax) = LargeInteger.LowPart
        mov     edx, LargeInteger.HighPart  ; (edx) = LargeInteger.HighPart
        shrd    eax, edx, cl
        sar     edx, cl
done:
    }
}

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4035)
#endif

#endif

//
// Large integer comparison routines.
//
// BOOLEAN
// RtlLargeIntegerGreaterThan (
//     LARGE_INTEGER Operand1,
//     LARGE_INTEGER Operand2
//     );
//
// BOOLEAN
// RtlLargeIntegerGreaterThanOrEqualTo (
//     LARGE_INTEGER Operand1,
//     LARGE_INTEGER Operand2
//     );
//
// BOOLEAN
// RtlLargeIntegerEqualTo (
//     LARGE_INTEGER Operand1,
//     LARGE_INTEGER Operand2
//     );
//
// BOOLEAN
// RtlLargeIntegerNotEqualTo (
//     LARGE_INTEGER Operand1,
//     LARGE_INTEGER Operand2
//     );
//
// BOOLEAN
// RtlLargeIntegerLessThan (
//     LARGE_INTEGER Operand1,
//     LARGE_INTEGER Operand2
//     );
//
// BOOLEAN
// RtlLargeIntegerLessThanOrEqualTo (
//     LARGE_INTEGER Operand1,
//     LARGE_INTEGER Operand2
//     );
//
// BOOLEAN
// RtlLargeIntegerGreaterThanZero (
//     LARGE_INTEGER Operand
//     );
//
// BOOLEAN
// RtlLargeIntegerGreaterOrEqualToZero (
//     LARGE_INTEGER Operand
//     );
//
// BOOLEAN
// RtlLargeIntegerEqualToZero (
//     LARGE_INTEGER Operand
//     );
//
// BOOLEAN
// RtlLargeIntegerNotEqualToZero (
//     LARGE_INTEGER Operand
//     );
//
// BOOLEAN
// RtlLargeIntegerLessThanZero (
//     LARGE_INTEGER Operand
//     );
//
// BOOLEAN
// RtlLargeIntegerLessOrEqualToZero (
//     LARGE_INTEGER Operand
//     );
//

#define RtlLargeIntegerGreaterThan(X,Y) (                              \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart > (Y).LowPart)) || \
    ((X).HighPart > (Y).HighPart)                                      \
)

#define RtlLargeIntegerGreaterThanOrEqualTo(X,Y) (                      \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart >= (Y).LowPart)) || \
    ((X).HighPart > (Y).HighPart)                                       \
)

#define RtlLargeIntegerEqualTo(X,Y) (                              \
    !(((X).LowPart ^ (Y).LowPart) | ((X).HighPart ^ (Y).HighPart)) \
)

#define RtlLargeIntegerNotEqualTo(X,Y) (                          \
    (((X).LowPart ^ (Y).LowPart) | ((X).HighPart ^ (Y).HighPart)) \
)

#define RtlLargeIntegerLessThan(X,Y) (                                 \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart < (Y).LowPart)) || \
    ((X).HighPart < (Y).HighPart)                                      \
)

#define RtlLargeIntegerLessThanOrEqualTo(X,Y) (                         \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart <= (Y).LowPart)) || \
    ((X).HighPart < (Y).HighPart)                                       \
)

#define RtlLargeIntegerGreaterThanZero(X) (       \
    (((X).HighPart == 0) && ((X).LowPart > 0)) || \
    ((X).HighPart > 0 )                           \
)

#define RtlLargeIntegerGreaterOrEqualToZero(X) ( \
    (X).HighPart >= 0                            \
)

#define RtlLargeIntegerEqualToZero(X) ( \
    !((X).LowPart | (X).HighPart)       \
)

#define RtlLargeIntegerNotEqualToZero(X) ( \
    ((X).LowPart | (X).HighPart)           \
)

#define RtlLargeIntegerLessThanZero(X) ( \
    ((X).HighPart < 0)                   \
)

#define RtlLargeIntegerLessOrEqualToZero(X) (           \
    ((X).HighPart < 0) || !((X).LowPart | (X).HighPart) \
)


//
//  Time conversion routines
//

typedef struct _TIME_FIELDS {
    CSHORT Year;        // range [1601...]
    CSHORT Month;       // range [1..12]
    CSHORT Day;         // range [1..31]
    CSHORT Hour;        // range [0..23]
    CSHORT Minute;      // range [0..59]
    CSHORT Second;      // range [0..59]
    CSHORT Milliseconds;// range [0..999]
    CSHORT Weekday;     // range [0..6] == [Sunday..Saturday]
} TIME_FIELDS;
typedef TIME_FIELDS *PTIME_FIELDS;


NTSYSAPI
VOID
NTAPI
RtlTimeToTimeFields (
    PLARGE_INTEGER Time,
    PTIME_FIELDS TimeFields
    );

//
//  A time field record (Weekday ignored) -> 64 bit Time value
//

NTSYSAPI
BOOLEAN
NTAPI
RtlTimeFieldsToTime (
    PTIME_FIELDS TimeFields,
    PLARGE_INTEGER Time
    );

//
// The following macros store and retrieve USHORTS and ULONGS from potentially
// unaligned addresses, avoiding alignment faults.  they should probably be
// rewritten in assembler
//

#define SHORT_SIZE  (sizeof(USHORT))
#define SHORT_MASK  (SHORT_SIZE - 1)
#define LONG_SIZE       (sizeof(LONG))
#define LONGLONG_SIZE   (sizeof(LONGLONG))
#define LONG_MASK       (LONG_SIZE - 1)
#define LONGLONG_MASK   (LONGLONG_SIZE - 1)
#define LOWBYTE_MASK 0x00FF

#define FIRSTBYTE(VALUE)  ((VALUE) & LOWBYTE_MASK)
#define SECONDBYTE(VALUE) (((VALUE) >> 8) & LOWBYTE_MASK)
#define THIRDBYTE(VALUE)  (((VALUE) >> 16) & LOWBYTE_MASK)
#define FOURTHBYTE(VALUE) (((VALUE) >> 24) & LOWBYTE_MASK)

//
// if MIPS Big Endian, order of bytes is reversed.
//

#define SHORT_LEAST_SIGNIFICANT_BIT  0
#define SHORT_MOST_SIGNIFICANT_BIT   1

#define LONG_LEAST_SIGNIFICANT_BIT       0
#define LONG_3RD_MOST_SIGNIFICANT_BIT    1
#define LONG_2ND_MOST_SIGNIFICANT_BIT    2
#define LONG_MOST_SIGNIFICANT_BIT        3

//++
//
// VOID
// RtlStoreUshort (
//     PUSHORT ADDRESS
//     USHORT VALUE
//     )
//
// Routine Description:
//
// This macro stores a USHORT value in at a particular address, avoiding
// alignment faults.
//
// Arguments:
//
//     ADDRESS - where to store USHORT value
//     VALUE - USHORT to store
//
// Return Value:
//
//     none.
//
//--

#define RtlStoreUshort(ADDRESS,VALUE)                     \
         if ((ULONG_PTR)(ADDRESS) & SHORT_MASK) {         \
             ((PUCHAR) (ADDRESS))[SHORT_LEAST_SIGNIFICANT_BIT] = (UCHAR)(FIRSTBYTE(VALUE));    \
             ((PUCHAR) (ADDRESS))[SHORT_MOST_SIGNIFICANT_BIT ] = (UCHAR)(SECONDBYTE(VALUE));   \
         }                                                \
         else {                                           \
             *((PUSHORT) (ADDRESS)) = (USHORT) VALUE;     \
         }


//++
//
// VOID
// RtlStoreUlong (
//     PULONG ADDRESS
//     ULONG VALUE
//     )
//
// Routine Description:
//
// This macro stores a ULONG value in at a particular address, avoiding
// alignment faults.
//
// Arguments:
//
//     ADDRESS - where to store ULONG value
//     VALUE - ULONG to store
//
// Return Value:
//
//     none.
//
// Note:
//     Depending on the machine, we might want to call storeushort in the
//     unaligned case.
//
//--

#define RtlStoreUlong(ADDRESS,VALUE)                      \
         if ((ULONG_PTR)(ADDRESS) & LONG_MASK) {          \
             ((PUCHAR) (ADDRESS))[LONG_LEAST_SIGNIFICANT_BIT      ] = (UCHAR)(FIRSTBYTE(VALUE));    \
             ((PUCHAR) (ADDRESS))[LONG_3RD_MOST_SIGNIFICANT_BIT   ] = (UCHAR)(SECONDBYTE(VALUE));   \
             ((PUCHAR) (ADDRESS))[LONG_2ND_MOST_SIGNIFICANT_BIT   ] = (UCHAR)(THIRDBYTE(VALUE));    \
             ((PUCHAR) (ADDRESS))[LONG_MOST_SIGNIFICANT_BIT       ] = (UCHAR)(FOURTHBYTE(VALUE));   \
         }                                                \
         else {                                           \
             *((PULONG) (ADDRESS)) = (ULONG) (VALUE);     \
         }

//++
//
// VOID
// RtlStoreUlonglong (
//     PULONGLONG ADDRESS
//     ULONG VALUE
//     )
//
// Routine Description:
//
// This macro stores a ULONGLONG value in at a particular address, avoiding
// alignment faults.
//
// Arguments:
//
//     ADDRESS - where to store ULONGLONG value
//     VALUE - ULONGLONG to store
//
// Return Value:
//
//     none.
//
//--

#define RtlStoreUlonglong(ADDRESS,VALUE)                        \
         if ((ULONG_PTR)(ADDRESS) & LONGLONG_MASK) {            \
             RtlStoreUlong((ULONG_PTR)(ADDRESS),                \
                           (ULONGLONG)(VALUE) & 0xFFFFFFFF);    \
             RtlStoreUlong((ULONG_PTR)(ADDRESS)+sizeof(ULONG),  \
                           (ULONGLONG)(VALUE) >> 32);           \
         } else {                                               \
             *((PULONGLONG)(ADDRESS)) = (ULONGLONG)(VALUE);     \
         }

//++
//
// VOID
// RtlStoreUlongPtr (
//     PULONG_PTR ADDRESS
//     ULONG_PTR VALUE
//     )
//
// Routine Description:
//
// This macro stores a ULONG_PTR value in at a particular address, avoiding
// alignment faults.
//
// Arguments:
//
//     ADDRESS - where to store ULONG_PTR value
//     VALUE - ULONG_PTR to store
//
// Return Value:
//
//     none.
//
//--

#ifdef _WIN64

#define RtlStoreUlongPtr(ADDRESS,VALUE)                         \
         RtlStoreUlonglong(ADDRESS,VALUE)

#else

#define RtlStoreUlongPtr(ADDRESS,VALUE)                         \
         RtlStoreUlong(ADDRESS,VALUE)

#endif

//++
//
// VOID
// RtlRetrieveUshort (
//     PUSHORT DESTINATION_ADDRESS
//     PUSHORT SOURCE_ADDRESS
//     )
//
// Routine Description:
//
// This macro retrieves a USHORT value from the SOURCE address, avoiding
// alignment faults.  The DESTINATION address is assumed to be aligned.
//
// Arguments:
//
//     DESTINATION_ADDRESS - where to store USHORT value
//     SOURCE_ADDRESS - where to retrieve USHORT value from
//
// Return Value:
//
//     none.
//
//--

#define RtlRetrieveUshort(DEST_ADDRESS,SRC_ADDRESS)                   \
         if ((ULONG_PTR)SRC_ADDRESS & SHORT_MASK) {                       \
             ((PUCHAR) DEST_ADDRESS)[0] = ((PUCHAR) SRC_ADDRESS)[0];  \
             ((PUCHAR) DEST_ADDRESS)[1] = ((PUCHAR) SRC_ADDRESS)[1];  \
         }                                                            \
         else {                                                       \
             *((PUSHORT) DEST_ADDRESS) = *((PUSHORT) SRC_ADDRESS);    \
         }                                                            \

//++
//
// VOID
// RtlRetrieveUlong (
//     PULONG DESTINATION_ADDRESS
//     PULONG SOURCE_ADDRESS
//     )
//
// Routine Description:
//
// This macro retrieves a ULONG value from the SOURCE address, avoiding
// alignment faults.  The DESTINATION address is assumed to be aligned.
//
// Arguments:
//
//     DESTINATION_ADDRESS - where to store ULONG value
//     SOURCE_ADDRESS - where to retrieve ULONG value from
//
// Return Value:
//
//     none.
//
// Note:
//     Depending on the machine, we might want to call retrieveushort in the
//     unaligned case.
//
//--

#define RtlRetrieveUlong(DEST_ADDRESS,SRC_ADDRESS)                    \
         if ((ULONG_PTR)SRC_ADDRESS & LONG_MASK) {                        \
             ((PUCHAR) DEST_ADDRESS)[0] = ((PUCHAR) SRC_ADDRESS)[0];  \
             ((PUCHAR) DEST_ADDRESS)[1] = ((PUCHAR) SRC_ADDRESS)[1];  \
             ((PUCHAR) DEST_ADDRESS)[2] = ((PUCHAR) SRC_ADDRESS)[2];  \
             ((PUCHAR) DEST_ADDRESS)[3] = ((PUCHAR) SRC_ADDRESS)[3];  \
         }                                                            \
         else {                                                       \
             *((PULONG) DEST_ADDRESS) = *((PULONG) SRC_ADDRESS);      \
         }

//
// Byte swap routines.  These are used to convert from little-endian to
// big-endian and vice-versa.
//

USHORT
FASTCALL
RtlUshortByteSwap(
    IN USHORT Source
    );

ULONG
FASTCALL
RtlUlongByteSwap(
    IN ULONG Source
    );

ULONGLONG
FASTCALL
RtlUlonglongByteSwap(
    IN ULONGLONG Source
    );

//
// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0-32767, and 32768-65535 are reserved for use
// by customers.
//

#define DEVICE_TYPE ULONG

#define FILE_DEVICE_BEEP                0x00000001
#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003
#define FILE_DEVICE_CONTROLLER          0x00000004
#define FILE_DEVICE_DATALINK            0x00000005
#define FILE_DEVICE_DFS                 0x00000006
#define FILE_DEVICE_DISK                0x00000007
#define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008
#define FILE_DEVICE_FILE_SYSTEM         0x00000009
#define FILE_DEVICE_INPORT_PORT         0x0000000a
#define FILE_DEVICE_KEYBOARD            0x0000000b
#define FILE_DEVICE_MAILSLOT            0x0000000c
#define FILE_DEVICE_MIDI_IN             0x0000000d
#define FILE_DEVICE_MIDI_OUT            0x0000000e
#define FILE_DEVICE_MOUSE               0x0000000f
#define FILE_DEVICE_MULTI_UNC_PROVIDER  0x00000010
#define FILE_DEVICE_NAMED_PIPE          0x00000011
#define FILE_DEVICE_NETWORK             0x00000012
#define FILE_DEVICE_NETWORK_BROWSER     0x00000013
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
#define FILE_DEVICE_NULL                0x00000015
#define FILE_DEVICE_PARALLEL_PORT       0x00000016
#define FILE_DEVICE_PHYSICAL_NETCARD    0x00000017
#define FILE_DEVICE_PRINTER             0x00000018
#define FILE_DEVICE_SCANNER             0x00000019
#define FILE_DEVICE_SERIAL_MOUSE_PORT   0x0000001a
#define FILE_DEVICE_SERIAL_PORT         0x0000001b
#define FILE_DEVICE_SCREEN              0x0000001c
#define FILE_DEVICE_SOUND               0x0000001d
#define FILE_DEVICE_STREAMS             0x0000001e
#define FILE_DEVICE_TAPE                0x0000001f
#define FILE_DEVICE_TAPE_FILE_SYSTEM    0x00000020
#define FILE_DEVICE_TRANSPORT           0x00000021
#define FILE_DEVICE_UNKNOWN             0x00000022
#define FILE_DEVICE_VIDEO               0x00000023
#define FILE_DEVICE_VIRTUAL_DISK        0x00000024
#define FILE_DEVICE_WAVE_IN             0x00000025
#define FILE_DEVICE_WAVE_OUT            0x00000026
#define FILE_DEVICE_8042_PORT           0x00000027
#define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028
#define FILE_DEVICE_BATTERY             0x00000029
#define FILE_DEVICE_BUS_EXTENDER        0x0000002a
#define FILE_DEVICE_MODEM               0x0000002b
#define FILE_DEVICE_VDM                 0x0000002c
#define FILE_DEVICE_MASS_STORAGE        0x0000002d
#define FILE_DEVICE_SMB                 0x0000002e
#define FILE_DEVICE_KS                  0x0000002f
#define FILE_DEVICE_CHANGER             0x00000030
#define FILE_DEVICE_SMARTCARD           0x00000031
#define FILE_DEVICE_ACPI                0x00000032
#define FILE_DEVICE_DVD                 0x00000033
#define FILE_DEVICE_FULLSCREEN_VIDEO    0x00000034
#define FILE_DEVICE_DFS_FILE_SYSTEM     0x00000035
#define FILE_DEVICE_DFS_VOLUME          0x00000036
#define FILE_DEVICE_SERENUM             0x00000037
#define FILE_DEVICE_TERMSRV             0x00000038
#define FILE_DEVICE_KSEC                0x00000039

//
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

//
// Macro to extract device type out of the device io control code
//
#define DEVICE_TYPE_FROM_CTL_CODE(ctrlCode)     (((ULONG)(ctrlCode & 0xffff0000)) >> 16)

//
// Define the method codes for how buffers are passed for I/O and FS controls
//

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

//
// Define the access check value for any access
//
//
// The FILE_READ_ACCESS and FILE_WRITE_ACCESS constants are also defined in
// ntioapi.h as FILE_READ_DATA and FILE_WRITE_DATA. The values for these
// constants *MUST* always be in sync.
//
//
// FILE_SPECIAL_ACCESS is checked by the NT I/O system the same as FILE_ANY_ACCESS.
// The file systems, however, may add additional access checks for I/O and FS controls
// that use this value.
//


#define FILE_ANY_ACCESS                 0
#define FILE_SPECIAL_ACCESS    (FILE_ANY_ACCESS)
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe



//
// Define access rights to files and directories
//

//
// The FILE_READ_DATA and FILE_WRITE_DATA constants are also defined in
// devioctl.h as FILE_READ_ACCESS and FILE_WRITE_ACCESS. The values for these
// constants *MUST* always be in sync.
// The values are redefined in devioctl.h because they must be available to
// both DOS and NT.
//

#define FILE_READ_DATA            ( 0x0001 )    // file & pipe
#define FILE_LIST_DIRECTORY       ( 0x0001 )    // directory

#define FILE_WRITE_DATA           ( 0x0002 )    // file & pipe
#define FILE_ADD_FILE             ( 0x0002 )    // directory

#define FILE_APPEND_DATA          ( 0x0004 )    // file
#define FILE_ADD_SUBDIRECTORY     ( 0x0004 )    // directory
#define FILE_CREATE_PIPE_INSTANCE ( 0x0004 )    // named pipe


#define FILE_READ_EA              ( 0x0008 )    // file & directory

#define FILE_WRITE_EA             ( 0x0010 )    // file & directory

#define FILE_EXECUTE              ( 0x0020 )    // file
#define FILE_TRAVERSE             ( 0x0020 )    // directory

#define FILE_DELETE_CHILD         ( 0x0040 )    // directory

#define FILE_READ_ATTRIBUTES      ( 0x0080 )    // all

#define FILE_WRITE_ATTRIBUTES     ( 0x0100 )    // all

#define FILE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x1FF)

#define FILE_GENERIC_READ         (STANDARD_RIGHTS_READ     |\
                                   FILE_READ_DATA           |\
                                   FILE_READ_ATTRIBUTES     |\
                                   FILE_READ_EA             |\
                                   SYNCHRONIZE)


#define FILE_GENERIC_WRITE        (STANDARD_RIGHTS_WRITE    |\
                                   FILE_WRITE_DATA          |\
                                   FILE_WRITE_ATTRIBUTES    |\
                                   FILE_WRITE_EA            |\
                                   FILE_APPEND_DATA         |\
                                   SYNCHRONIZE)


#define FILE_GENERIC_EXECUTE      (STANDARD_RIGHTS_EXECUTE  |\
                                   FILE_READ_ATTRIBUTES     |\
                                   FILE_EXECUTE             |\
                                   SYNCHRONIZE)




//
// Define share access rights to files and directories
//

#define FILE_SHARE_READ                 0x00000001  
#define FILE_SHARE_WRITE                0x00000002  
#define FILE_SHARE_DELETE               0x00000004  
#define FILE_SHARE_VALID_FLAGS          0x00000007

//
// Define the file attributes values
//
// Note:  0x00000008 is reserved for use for the old DOS VOLID (volume ID)
//        and is therefore not considered valid in NT.
//
// Note:  0x00000010 is reserved for use for the old DOS SUBDIRECTORY flag
//        and is therefore not considered valid in NT.  This flag has
//        been disassociated with file attributes since the other flags are
//        protected with READ_ and WRITE_ATTRIBUTES access to the file.
//
// Note:  Note also that the order of these flags is set to allow both the
//        FAT and the Pinball File Systems to directly set the attributes
//        flags in attributes words without having to pick each flag out
//        individually.  The order of these flags should not be changed!
//

#define FILE_ATTRIBUTE_READONLY             0x00000001  
#define FILE_ATTRIBUTE_HIDDEN               0x00000002  
#define FILE_ATTRIBUTE_SYSTEM               0x00000004  
//OLD DOS VOLID                             0x00000008

#define FILE_ATTRIBUTE_DIRECTORY            0x00000010  
#define FILE_ATTRIBUTE_ARCHIVE              0x00000020  
#define FILE_ATTRIBUTE_DEVICE               0x00000040  
#define FILE_ATTRIBUTE_NORMAL               0x00000080  

#define FILE_ATTRIBUTE_TEMPORARY            0x00000100  
#define FILE_ATTRIBUTE_SPARSE_FILE          0x00000200  
#define FILE_ATTRIBUTE_REPARSE_POINT        0x00000400  
#define FILE_ATTRIBUTE_COMPRESSED           0x00000800  

#define FILE_ATTRIBUTE_OFFLINE              0x00001000  
#define FILE_ATTRIBUTE_NOT_CONTENT_INDEXED  0x00002000  
#define FILE_ATTRIBUTE_ENCRYPTED            0x00004000  

//
//  This definition is old and will disappear shortly
//

#define FILE_ATTRIBUTE_CONTENT_INDEXED      FILE_ATTRIBUTE_NOT_CONTENT_INDEXED

#define FILE_ATTRIBUTE_VALID_FLAGS      0x00007fb7
#define FILE_ATTRIBUTE_VALID_SET_FLAGS  0x000031a7

//
// Define the create disposition values
//

#define FILE_SUPERSEDE                  0x00000000
#define FILE_OPEN                       0x00000001
#define FILE_CREATE                     0x00000002
#define FILE_OPEN_IF                    0x00000003
#define FILE_OVERWRITE                  0x00000004
#define FILE_OVERWRITE_IF               0x00000005
#define FILE_MAXIMUM_DISPOSITION        0x00000005

//
// Define the create/open option flags
//

#define FILE_DIRECTORY_FILE                     0x00000001
#define FILE_WRITE_THROUGH                      0x00000002
#define FILE_SEQUENTIAL_ONLY                    0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING          0x00000008

#define FILE_SYNCHRONOUS_IO_ALERT               0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020
#define FILE_NON_DIRECTORY_FILE                 0x00000040
#define FILE_CREATE_TREE_CONNECTION             0x00000080

#define FILE_COMPLETE_IF_OPLOCKED               0x00000100
#define FILE_NO_EA_KNOWLEDGE                    0x00000200
#define FILE_OPEN_FOR_RECOVERY                  0x00000400
#define FILE_RANDOM_ACCESS                      0x00000800

#define FILE_DELETE_ON_CLOSE                    0x00001000
#define FILE_OPEN_BY_FILE_ID                    0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT             0x00004000
#define FILE_NO_COMPRESSION                     0x00008000

#define FILE_RESERVE_OPFILTER                   0x00100000
#define FILE_OPEN_REPARSE_POINT                 0x00200000
#define FILE_OPEN_NO_RECALL                     0x00400000
#define FILE_OPEN_FOR_FREE_SPACE_QUERY          0x00800000

#define FILE_COPY_STRUCTURED_STORAGE            0x00000041
#define FILE_STRUCTURED_STORAGE                 0x00000441

#define FILE_VALID_OPTION_FLAGS                 0x00ffffff
#define FILE_VALID_PIPE_OPTION_FLAGS            0x00000032
#define FILE_VALID_MAILSLOT_OPTION_FLAGS        0x00000032
#define FILE_VALID_SET_FLAGS                    0x00000036

//
// Define the I/O status information return values for NtCreateFile/NtOpenFile
//

#define FILE_SUPERSEDED                 0x00000000
#define FILE_OPENED                     0x00000001
#define FILE_CREATED                    0x00000002
#define FILE_OVERWRITTEN                0x00000003
#define FILE_EXISTS                     0x00000004
#define FILE_DOES_NOT_EXIST             0x00000005

//
// Define special ByteOffset parameters for read and write operations
//

#define FILE_WRITE_TO_END_OF_FILE       0xffffffff
#define FILE_USE_FILE_POINTER_POSITION  0xfffffffe

//
// Define alignment requirement values
//

#define FILE_BYTE_ALIGNMENT             0x00000000
#define FILE_WORD_ALIGNMENT             0x00000001
#define FILE_LONG_ALIGNMENT             0x00000003
#define FILE_QUAD_ALIGNMENT             0x00000007
#define FILE_OCTA_ALIGNMENT             0x0000000f
#define FILE_32_BYTE_ALIGNMENT          0x0000001f
#define FILE_64_BYTE_ALIGNMENT          0x0000003f
#define FILE_128_BYTE_ALIGNMENT         0x0000007f
#define FILE_256_BYTE_ALIGNMENT         0x000000ff
#define FILE_512_BYTE_ALIGNMENT         0x000001ff

//
// Define the maximum length of a filename string
//

#define MAXIMUM_FILENAME_LENGTH         256

//
// Define the various device characteristics flags
//

#define FILE_REMOVABLE_MEDIA            0x00000001
#define FILE_READ_ONLY_DEVICE           0x00000002
#define FILE_FLOPPY_DISKETTE            0x00000004
#define FILE_WRITE_ONCE_MEDIA           0x00000008
#define FILE_REMOTE_DEVICE              0x00000010
#define FILE_DEVICE_IS_MOUNTED          0x00000020
#define FILE_VIRTUAL_VOLUME             0x00000040
#define FILE_AUTOGENERATED_DEVICE_NAME  0x00000080
#define FILE_DEVICE_SECURE_OPEN         0x00000100

//
// Define the base asynchronous I/O argument types
//

typedef struct _IO_STATUS_BLOCK {
    union {
        NTSTATUS Status;
        PVOID Pointer;
    };

    ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

#if defined(_WIN64)
typedef struct _IO_STATUS_BLOCK32 {
    NTSTATUS Status;
    ULONG Information;
} IO_STATUS_BLOCK32, *PIO_STATUS_BLOCK32;
#endif


//
// Define an Asynchronous Procedure Call from I/O viewpoint
//

typedef
VOID
(NTAPI *PIO_APC_ROUTINE) (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    );
#define PIO_APC_ROUTINE_DEFINED

//
// Define the file information class values
//
// WARNING:  The order of the following values are assumed by the I/O system.
//           Any changes made here should be reflected there as well.
//

typedef enum _FILE_INFORMATION_CLASS {
    FileBasicInformation = 4,         
    FileStandardInformation = 5,      
    FilePositionInformation = 14,      
    FileEndOfFileInformation = 20,     
} FILE_INFORMATION_CLASS, *PFILE_INFORMATION_CLASS;

//
// Define the various structures which are returned on query operations
//

typedef struct _FILE_BASIC_INFORMATION {                    
    LARGE_INTEGER CreationTime;                             
    LARGE_INTEGER LastAccessTime;                           
    LARGE_INTEGER LastWriteTime;                            
    LARGE_INTEGER ChangeTime;                               
    ULONG FileAttributes;                                   
} FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;         
                                                            
typedef struct _FILE_STANDARD_INFORMATION {                 
    LARGE_INTEGER AllocationSize;                           
    LARGE_INTEGER EndOfFile;                                
    ULONG NumberOfLinks;                                    
    BOOLEAN DeletePending;                                  
    BOOLEAN Directory;                                      
} FILE_STANDARD_INFORMATION, *PFILE_STANDARD_INFORMATION;   
                                                            
typedef struct _FILE_POSITION_INFORMATION {                 
    LARGE_INTEGER CurrentByteOffset;                        
} FILE_POSITION_INFORMATION, *PFILE_POSITION_INFORMATION;   
                                                            
typedef struct _FILE_NETWORK_OPEN_INFORMATION {                 
    LARGE_INTEGER CreationTime;                                 
    LARGE_INTEGER LastAccessTime;                               
    LARGE_INTEGER LastWriteTime;                                
    LARGE_INTEGER ChangeTime;                                   
    LARGE_INTEGER AllocationSize;                               
    LARGE_INTEGER EndOfFile;                                    
    ULONG FileAttributes;                                       
} FILE_NETWORK_OPEN_INFORMATION, *PFILE_NETWORK_OPEN_INFORMATION;   
                                                                

typedef struct _FILE_FULL_EA_INFORMATION {
    ULONG NextEntryOffset;
    UCHAR Flags;
    UCHAR EaNameLength;
    USHORT EaValueLength;
    CHAR EaName[1];
} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;

//
// Define the file system information class values
//
// WARNING:  The order of the following values are assumed by the I/O system.
//           Any changes made here should be reflected there as well.

typedef enum _FSINFOCLASS {
    FileFsVolumeInformation       = 1,
    FileFsLabelInformation,      // 2
    FileFsSizeInformation,       // 3
    FileFsDeviceInformation,     // 4
    FileFsAttributeInformation,  // 5
    FileFsControlInformation,    // 6
    FileFsFullSizeInformation,   // 7
    FileFsObjectIdInformation,   // 8
    FileFsMaximumInformation
} FS_INFORMATION_CLASS, *PFS_INFORMATION_CLASS;

typedef struct _FILE_FS_DEVICE_INFORMATION {                    
    DEVICE_TYPE DeviceType;                                     
    ULONG Characteristics;                                      
} FILE_FS_DEVICE_INFORMATION, *PFILE_FS_DEVICE_INFORMATION;     
                                                                
//
// Define the I/O bus interface types.
//

typedef enum _INTERFACE_TYPE {
    InterfaceTypeUndefined = -1,
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    PCIBus,
    VMEBus,
    NuBus,
    PCMCIABus,
    CBus,
    MPIBus,
    MPSABus,
    ProcessorInternal,
    InternalPowerBus,
    PNPISABus,
    PNPBus,
    MaximumInterfaceType
}INTERFACE_TYPE, *PINTERFACE_TYPE;

//
// Define the DMA transfer widths.
//

typedef enum _DMA_WIDTH {
    Width8Bits,
    Width16Bits,
    Width32Bits,
    MaximumDmaWidth
}DMA_WIDTH, *PDMA_WIDTH;

//
// Define DMA transfer speeds.
//

typedef enum _DMA_SPEED {
    Compatible,
    TypeA,
    TypeB,
    TypeC,
    TypeF,
    MaximumDmaSpeed
}DMA_SPEED, *PDMA_SPEED;

//
// Define Interface reference/dereference routines for
//  Interfaces exported by IRP_MN_QUERY_INTERFACE
//

typedef VOID (*PINTERFACE_REFERENCE)(PVOID Context);
typedef VOID (*PINTERFACE_DEREFERENCE)(PVOID Context);

//
// Define I/O Driver error log packet structure.  This structure is filled in
// by the driver.
//

typedef struct _IO_ERROR_LOG_PACKET {
    UCHAR MajorFunctionCode;
    UCHAR RetryCount;
    USHORT DumpDataSize;
    USHORT NumberOfStrings;
    USHORT StringOffset;
    USHORT EventCategory;
    NTSTATUS ErrorCode;
    ULONG UniqueErrorValue;
    NTSTATUS FinalStatus;
    ULONG SequenceNumber;
    ULONG IoControlCode;
    LARGE_INTEGER DeviceOffset;
    ULONG DumpData[1];
}IO_ERROR_LOG_PACKET, *PIO_ERROR_LOG_PACKET;

//
// Define the I/O error log message.  This message is sent by the error log
// thread over the lpc port.
//

typedef struct _IO_ERROR_LOG_MESSAGE {
    USHORT Type;
    USHORT Size;
    USHORT DriverNameLength;
    LARGE_INTEGER TimeStamp;
    ULONG DriverNameOffset;
    IO_ERROR_LOG_PACKET EntryData;
}IO_ERROR_LOG_MESSAGE, *PIO_ERROR_LOG_MESSAGE;

//
// Define the maximum message size that will be sent over the LPC to the
// application reading the error log entries.
//

//
// Regardless of LPC size restrictions, ERROR_LOG_MAXIMUM_SIZE must remain
// a value that can fit in a UCHAR.
//

#define ERROR_LOG_LIMIT_SIZE (256-16)

//
// This limit, exclusive of IO_ERROR_LOG_MESSAGE_HEADER_LENGTH, also applies
// to IO_ERROR_LOG_MESSAGE_LENGTH
// 

#define IO_ERROR_LOG_MESSAGE_HEADER_LENGTH (sizeof(IO_ERROR_LOG_MESSAGE) -    \
                                            sizeof(IO_ERROR_LOG_PACKET) +     \
                                            (sizeof(WCHAR) * 40))

#define ERROR_LOG_MESSAGE_LIMIT_SIZE                                          \
    (ERROR_LOG_LIMIT_SIZE + IO_ERROR_LOG_MESSAGE_HEADER_LENGTH)

//
// IO_ERROR_LOG_MESSAGE_LENGTH is
// min(PORT_MAXIMUM_MESSAGE_LENGTH, ERROR_LOG_MESSAGE_LIMIT_SIZE)
// 

#define IO_ERROR_LOG_MESSAGE_LENGTH                                           \
    ((PORT_MAXIMUM_MESSAGE_LENGTH > ERROR_LOG_MESSAGE_LIMIT_SIZE) ?           \
        ERROR_LOG_MESSAGE_LIMIT_SIZE :                                        \
        PORT_MAXIMUM_MESSAGE_LENGTH)

//
// Define the maximum packet size a driver can allocate.
//

#define ERROR_LOG_MAXIMUM_SIZE (IO_ERROR_LOG_MESSAGE_LENGTH -                 \
                                IO_ERROR_LOG_MESSAGE_HEADER_LENGTH)

#ifdef _WIN64
#define PORT_MAXIMUM_MESSAGE_LENGTH 512
#else
#define PORT_MAXIMUM_MESSAGE_LENGTH 256
#endif
//
// Registry Specific Access Rights.
//

#define KEY_QUERY_VALUE         (0x0001)
#define KEY_SET_VALUE           (0x0002)
#define KEY_CREATE_SUB_KEY      (0x0004)
#define KEY_ENUMERATE_SUB_KEYS  (0x0008)
#define KEY_NOTIFY              (0x0010)
#define KEY_CREATE_LINK         (0x0020)

#define KEY_READ                ((STANDARD_RIGHTS_READ       |\
                                  KEY_QUERY_VALUE            |\
                                  KEY_ENUMERATE_SUB_KEYS     |\
                                  KEY_NOTIFY)                 \
                                  &                           \
                                 (~SYNCHRONIZE))


#define KEY_WRITE               ((STANDARD_RIGHTS_WRITE      |\
                                  KEY_SET_VALUE              |\
                                  KEY_CREATE_SUB_KEY)         \
                                  &                           \
                                 (~SYNCHRONIZE))

#define KEY_EXECUTE             ((KEY_READ)                   \
                                  &                           \
                                 (~SYNCHRONIZE))

#define KEY_ALL_ACCESS          ((STANDARD_RIGHTS_ALL        |\
                                  KEY_QUERY_VALUE            |\
                                  KEY_SET_VALUE              |\
                                  KEY_CREATE_SUB_KEY         |\
                                  KEY_ENUMERATE_SUB_KEYS     |\
                                  KEY_NOTIFY                 |\
                                  KEY_CREATE_LINK)            \
                                  &                           \
                                 (~SYNCHRONIZE))

//
// Open/Create Options
//

#define REG_OPTION_RESERVED         (0x00000000L)   // Parameter is reserved

#define REG_OPTION_NON_VOLATILE     (0x00000000L)   // Key is preserved
                                                    // when system is rebooted

#define REG_OPTION_VOLATILE         (0x00000001L)   // Key is not preserved
                                                    // when system is rebooted

#define REG_OPTION_CREATE_LINK      (0x00000002L)   // Created key is a
                                                    // symbolic link

#define REG_OPTION_BACKUP_RESTORE   (0x00000004L)   // open for backup or restore
                                                    // special access rules
                                                    // privilege required

#define REG_OPTION_OPEN_LINK        (0x00000008L)   // Open symbolic link

#define REG_LEGAL_OPTION            \
                (REG_OPTION_RESERVED            |\
                 REG_OPTION_NON_VOLATILE        |\
                 REG_OPTION_VOLATILE            |\
                 REG_OPTION_CREATE_LINK         |\
                 REG_OPTION_BACKUP_RESTORE      |\
                 REG_OPTION_OPEN_LINK)

//
// Key creation/open disposition
//

#define REG_CREATED_NEW_KEY         (0x00000001L)   // New Registry Key created
#define REG_OPENED_EXISTING_KEY     (0x00000002L)   // Existing Key opened

//
// Key restore flags
//

#define REG_WHOLE_HIVE_VOLATILE     (0x00000001L)   // Restore whole hive volatile
#define REG_REFRESH_HIVE            (0x00000002L)   // Unwind changes to last flush
#define REG_NO_LAZY_FLUSH           (0x00000004L)   // Never lazy flush this hive
#define REG_FORCE_RESTORE           (0x00000008L)   // Force the restore process even when we have open handles on subkeys

//
// Key query structures
//

typedef struct _KEY_BASIC_INFORMATION {
    LARGE_INTEGER LastWriteTime;
    ULONG   TitleIndex;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable length string
} KEY_BASIC_INFORMATION, *PKEY_BASIC_INFORMATION;

typedef struct _KEY_NODE_INFORMATION {
    LARGE_INTEGER LastWriteTime;
    ULONG   TitleIndex;
    ULONG   ClassOffset;
    ULONG   ClassLength;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable length string
//          Class[1];           // Variable length string not declared
} KEY_NODE_INFORMATION, *PKEY_NODE_INFORMATION;

typedef struct _KEY_FULL_INFORMATION {
    LARGE_INTEGER LastWriteTime;
    ULONG   TitleIndex;
    ULONG   ClassOffset;
    ULONG   ClassLength;
    ULONG   SubKeys;
    ULONG   MaxNameLen;
    ULONG   MaxClassLen;
    ULONG   Values;
    ULONG   MaxValueNameLen;
    ULONG   MaxValueDataLen;
    WCHAR   Class[1];           // Variable length
} KEY_FULL_INFORMATION, *PKEY_FULL_INFORMATION;

typedef enum _KEY_INFORMATION_CLASS {
    KeyBasicInformation,
    KeyNodeInformation,
    KeyFullInformation
} KEY_INFORMATION_CLASS;

typedef struct _KEY_WRITE_TIME_INFORMATION {
    LARGE_INTEGER LastWriteTime;
} KEY_WRITE_TIME_INFORMATION, *PKEY_WRITE_TIME_INFORMATION;

typedef enum _KEY_SET_INFORMATION_CLASS {
    KeyWriteTimeInformation
} KEY_SET_INFORMATION_CLASS;

//
// Value entry query structures
//

typedef struct _KEY_VALUE_BASIC_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable size
} KEY_VALUE_BASIC_INFORMATION, *PKEY_VALUE_BASIC_INFORMATION;

typedef struct _KEY_VALUE_FULL_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   DataOffset;
    ULONG   DataLength;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable size
//          Data[1];            // Variable size data not declared
} KEY_VALUE_FULL_INFORMATION, *PKEY_VALUE_FULL_INFORMATION;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   DataLength;
    UCHAR   Data[1];            // Variable size
} KEY_VALUE_PARTIAL_INFORMATION, *PKEY_VALUE_PARTIAL_INFORMATION;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 {
    ULONG   Type;
    ULONG   DataLength;
    UCHAR   Data[1];            // Variable size
} KEY_VALUE_PARTIAL_INFORMATION_ALIGN64, *PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64;

typedef struct _KEY_VALUE_ENTRY {
    PUNICODE_STRING ValueName;
    ULONG           DataLength;
    ULONG           DataOffset;
    ULONG           Type;
} KEY_VALUE_ENTRY, *PKEY_VALUE_ENTRY;

typedef enum _KEY_VALUE_INFORMATION_CLASS {
    KeyValueBasicInformation,
    KeyValueFullInformation,
    KeyValuePartialInformation,
    KeyValueFullInformationAlign64,
    KeyValuePartialInformationAlign64
} KEY_VALUE_INFORMATION_CLASS;



#define OBJ_NAME_PATH_SEPARATOR ((WCHAR)L'\\')

//
// Object Manager Object Type Specific Access Rights.
//

#define OBJECT_TYPE_CREATE (0x0001)

#define OBJECT_TYPE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x1)

//
// Object Manager Directory Specific Access Rights.
//

#define DIRECTORY_QUERY                 (0x0001)
#define DIRECTORY_TRAVERSE              (0x0002)
#define DIRECTORY_CREATE_OBJECT         (0x0004)
#define DIRECTORY_CREATE_SUBDIRECTORY   (0x0008)

#define DIRECTORY_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0xF)

//
// Object Manager Symbolic Link Specific Access Rights.
//

#define SYMBOLIC_LINK_QUERY (0x0001)

#define SYMBOLIC_LINK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x1)

typedef struct _OBJECT_NAME_INFORMATION {               
    UNICODE_STRING Name;                                
} OBJECT_NAME_INFORMATION, *POBJECT_NAME_INFORMATION;   
#define DUPLICATE_CLOSE_SOURCE      0x00000001  
#define DUPLICATE_SAME_ACCESS       0x00000002  
#define DUPLICATE_SAME_ATTRIBUTES   0x00000004

//
// Section Information Structures.
//

typedef enum _SECTION_INHERIT {
    ViewShare = 1,
    ViewUnmap = 2
} SECTION_INHERIT;

//
// Section Access Rights.
//


#define SECTION_QUERY       0x0001
#define SECTION_MAP_WRITE   0x0002
#define SECTION_MAP_READ    0x0004
#define SECTION_MAP_EXECUTE 0x0008
#define SECTION_EXTEND_SIZE 0x0010

#define SECTION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SECTION_QUERY|\
                            SECTION_MAP_WRITE |      \
                            SECTION_MAP_READ |       \
                            SECTION_MAP_EXECUTE |    \
                            SECTION_EXTEND_SIZE)


#define SEGMENT_ALL_ACCESS SECTION_ALL_ACCESS

#define PAGE_NOACCESS          0x01     
#define PAGE_READONLY          0x02     
#define PAGE_READWRITE         0x04     
#define PAGE_WRITECOPY         0x08     
#define PAGE_EXECUTE           0x10     
#define PAGE_EXECUTE_READ      0x20     
#define PAGE_EXECUTE_READWRITE 0x40     
#define PAGE_EXECUTE_WRITECOPY 0x80     
#define PAGE_GUARD            0x100     
#define PAGE_NOCACHE          0x200     
#define PAGE_WRITECOMBINE     0x400     

#define MEM_COMMIT           0x1000     
#define MEM_RESERVE          0x2000     
#define MEM_DECOMMIT         0x4000     
#define MEM_RELEASE          0x8000     
#define MEM_FREE            0x10000     
#define MEM_PRIVATE         0x20000     
#define MEM_MAPPED          0x40000     
#define MEM_RESET           0x80000     
#define MEM_TOP_DOWN       0x100000     
#define MEM_LARGE_PAGES  0x20000000     
#define MEM_4MB_PAGES    0x80000000     
#define SEC_RESERVE       0x4000000     
#define PROCESS_DUP_HANDLE        (0x0040)  
#define PROCESS_ALL_ACCESS        (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
                                   0xFFF)



#define MAXIMUM_PROCESSORS 32



//
// Thread Specific Access Rights
//

#define THREAD_TERMINATE               (0x0001)  
#define THREAD_SET_INFORMATION         (0x0020)  

#define THREAD_ALL_ACCESS         (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
                                   0x3FF)

//
// ClientId
//

typedef struct _CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} CLIENT_ID;
typedef CLIENT_ID *PCLIENT_ID;

#define NtCurrentProcess() ( (HANDLE) -1 )  
#define NtCurrentThread() ( (HANDLE) -2 )   

#ifndef _PO_DDK_
#define _PO_DDK_

typedef enum _SYSTEM_POWER_STATE {
    PowerSystemUnspecified = 0,
    PowerSystemWorking,
    PowerSystemSleeping1,
    PowerSystemSleeping2,
    PowerSystemSleeping3,
    PowerSystemHibernate,
    PowerSystemShutdown,
    PowerSystemMaximum
} SYSTEM_POWER_STATE, *PSYSTEM_POWER_STATE;

typedef enum {
    PowerActionNone = 0,
    PowerActionReserved,
    PowerActionSleep,
    PowerActionHibernate,
    PowerActionShutdown,
    PowerActionShutdownReset,
    PowerActionShutdownOff,
    PowerActionWarmEject
} POWER_ACTION, *PPOWER_ACTION;

typedef enum _DEVICE_POWER_STATE {
    PowerDeviceUnspecified = 0,
    PowerDeviceD0,
    PowerDeviceD1,
    PowerDeviceD2,
    PowerDeviceD3,
    PowerDeviceMaximum
} DEVICE_POWER_STATE, *PDEVICE_POWER_STATE;

typedef union _POWER_STATE {
    SYSTEM_POWER_STATE SystemState;
    DEVICE_POWER_STATE DeviceState;
} POWER_STATE, *PPOWER_STATE;

typedef enum _POWER_STATE_TYPE {
    SystemPowerState = 0,
    DevicePowerState
} POWER_STATE_TYPE, *PPOWER_STATE_TYPE;


//
// Generic power related IOCTLs
//

#define IOCTL_QUERY_DEVICE_POWER_STATE  \
        CTL_CODE(FILE_DEVICE_BATTERY, 0x0, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_SET_DEVICE_WAKE           \
        CTL_CODE(FILE_DEVICE_BATTERY, 0x1, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CANCEL_DEVICE_WAKE        \
        CTL_CODE(FILE_DEVICE_BATTERY, 0x2, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// Defines for W32 interfaces
//



#define ES_SYSTEM_REQUIRED  ((ULONG)0x00000001)
#define ES_DISPLAY_REQUIRED ((ULONG)0x00000002)
#define ES_USER_PRESENT     ((ULONG)0x00000004)
#define ES_CONTINUOUS       ((ULONG)0x80000000)

typedef ULONG EXECUTION_STATE;

typedef enum {
    LT_DONT_CARE,
    LT_LOWEST_LATENCY
} LATENCY_TIME;


#endif // !_PO_DDK_


#if defined(_X86_)

//
// Types to use to contain PFNs and their counts.
//

typedef ULONG PFN_COUNT;

typedef LONG SPFN_NUMBER, *PSPFN_NUMBER;
typedef ULONG PFN_NUMBER, *PPFN_NUMBER;

//
// Define maximum size of flush multiple TB request.
//

#define FLUSH_MULTIPLE_MAXIMUM 16

//
// Indicate that the i386 compiler supports the pragma textout construct.
//

#define ALLOC_PRAGMA 1
//
// Indicate that the i386 compiler supports the DATA_SEG("INIT") and
// DATA_SEG("PAGE") pragmas
//

#define ALLOC_DATA_PRAGMA 1

#define NORMAL_DISPATCH_LENGTH 106                  
#define DISPATCH_LENGTH NORMAL_DISPATCH_LENGTH      
//
// STATUS register for each MCA bank.
//

typedef union _MCI_STATS {
    struct {
        USHORT  McaCod;
        USHORT  MsCod;
        ULONG   OtherInfo : 25;
        ULONG   Damage : 1;
        ULONG   AddressValid : 1;
        ULONG   MiscValid : 1;
        ULONG   Enabled : 1;
        ULONG   UnCorrected : 1;
        ULONG   OverFlow : 1;
        ULONG   Valid : 1;
    } MciStats;

    ULONGLONG QuadPart;

} MCI_STATS, *PMCI_STATS;

//
// Interrupt Request Level definitions
//

#define PASSIVE_LEVEL 0             // Passive release level
#define LOW_LEVEL 0                 // Lowest interrupt level
#define APC_LEVEL 1                 // APC interrupt level
#define DISPATCH_LEVEL 2            // Dispatcher level

#define PROFILE_LEVEL 27            // timer used for profiling.
#define CLOCK1_LEVEL 28             // Interval clock 1 level - Not used on x86
#define CLOCK2_LEVEL 28             // Interval clock 2 level
#define IPI_LEVEL 29                // Interprocessor interrupt level
#define POWER_LEVEL 30              // Power failure level
#define HIGH_LEVEL 31               // Highest interrupt level
#define SYNCH_LEVEL (IPI_LEVEL-1)   // synchronization level

//
// I/O space read and write macros.
//
//  These have to be actual functions on the 386, because we need
//  to use assembler, but cannot return a value if we inline it.
//
//  The READ/WRITE_REGISTER_* calls manipulate I/O registers in MEMORY space.
//  (Use x86 move instructions, with LOCK prefix to force correct behavior
//   w.r.t. caches and write buffers.)
//
//  The READ/WRITE_PORT_* calls manipulate I/O registers in PORT space.
//  (Use x86 in/out instructions.)
//

NTHALAPI
UCHAR
READ_REGISTER_UCHAR(
    PUCHAR  Register
    );

NTHALAPI
USHORT
READ_REGISTER_USHORT(
    PUSHORT Register
    );

NTHALAPI
ULONG
READ_REGISTER_ULONG(
    PULONG  Register
    );

NTHALAPI
VOID
READ_REGISTER_BUFFER_UCHAR(
    PUCHAR  Register,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
READ_REGISTER_BUFFER_USHORT(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
READ_REGISTER_BUFFER_ULONG(
    PULONG  Register,
    PULONG  Buffer,
    ULONG   Count
    );


NTHALAPI
VOID
WRITE_REGISTER_UCHAR(
    PUCHAR  Register,
    UCHAR   Value
    );

NTHALAPI
VOID
WRITE_REGISTER_USHORT(
    PUSHORT Register,
    USHORT  Value
    );

NTHALAPI
VOID
WRITE_REGISTER_ULONG(
    PULONG  Register,
    ULONG   Value
    );

NTHALAPI
VOID
WRITE_REGISTER_BUFFER_UCHAR(
    PUCHAR  Register,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_REGISTER_BUFFER_USHORT(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_REGISTER_BUFFER_ULONG(
    PULONG  Register,
    PULONG  Buffer,
    ULONG   Count
    );

NTHALAPI
UCHAR
READ_PORT_UCHAR(
    PUCHAR  Port
    );

NTHALAPI
USHORT
READ_PORT_USHORT(
    PUSHORT Port
    );

NTHALAPI
ULONG
READ_PORT_ULONG(
    PULONG  Port
    );

NTHALAPI
VOID
READ_PORT_BUFFER_UCHAR(
    PUCHAR  Port,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
READ_PORT_BUFFER_USHORT(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
READ_PORT_BUFFER_ULONG(
    PULONG  Port,
    PULONG  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_PORT_UCHAR(
    PUCHAR  Port,
    UCHAR   Value
    );

NTHALAPI
VOID
WRITE_PORT_USHORT(
    PUSHORT Port,
    USHORT  Value
    );

NTHALAPI
VOID
WRITE_PORT_ULONG(
    PULONG  Port,
    ULONG   Value
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_UCHAR(
    PUCHAR  Port,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_USHORT(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_ULONG(
    PULONG  Port,
    PULONG  Buffer,
    ULONG   Count
    );


//
// Get data cache fill size.
//

#define KeGetDcacheFillSize() 1L


#define KeFlushIoBuffers(Mdl, ReadOperation, DmaOperation)


#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))
#define ExAcquireSpinLockAtDpcLevel(Lock) KeAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock) KeReleaseSpinLockFromDpcLevel(Lock)


#define KeQueryTickCount(CurrentCount ) { \
    volatile PKSYSTEM_TIME _TickCount = *((PKSYSTEM_TIME *)(&KeTickCount)); \
    while (TRUE) {                                                          \
        (CurrentCount)->HighPart = _TickCount->High1Time;                   \
        (CurrentCount)->LowPart = _TickCount->LowPart;                      \
        if ((CurrentCount)->HighPart == _TickCount->High2Time) break;       \
        _asm { rep nop }                                                    \
    }                                                                       \
}

//
// The non-volatile 387 state
//

typedef struct _KFLOATING_SAVE {
    ULONG   DoNotUse1;
    ULONG   DoNotUse2;
    ULONG   DoNotUse3;
    ULONG   DoNotUse4;
    ULONG   DoNotUse5;
    ULONG   DoNotUse6;
    ULONG   DoNotUse7;
    ULONG   DoNotUse8;
} KFLOATING_SAVE, *PKFLOATING_SAVE;

//
// i386 Specific portions of mm component
//

//
// Define the page size for the Intel 386 as 4096 (0x1000).
//

#define PAGE_SIZE 0x1000

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT 12L


#define MmGetProcedureAddress(Address) (Address)
#define MmLockPagableCodeSection(Address) MmLockPagableDataSection(Address)


#define ExInterlockedAddUlong           ExfInterlockedAddUlong
#define ExInterlockedInsertHeadList     ExfInterlockedInsertHeadList
#define ExInterlockedInsertTailList     ExfInterlockedInsertTailList
#define ExInterlockedRemoveHeadList     ExfInterlockedRemoveHeadList
#define ExInterlockedPopEntryList       ExfInterlockedPopEntryList
#define ExInterlockedPushEntryList      ExfInterlockedPushEntryList


NTKERNELAPI
LONG
FASTCALL
InterlockedIncrement(
    IN PLONG Addend
    );

NTKERNELAPI
LONG
FASTCALL
InterlockedDecrement(
    IN PLONG Addend
    );

NTKERNELAPI
LONG
FASTCALL
InterlockedExchange(
    IN OUT PLONG Target,
    IN LONG Value
    );

#define InterlockedExchangePointer(Target, Value) \
   (PVOID)InterlockedExchange((PLONG)(Target), (LONG)(Value))

LONG
FASTCALL
InterlockedExchangeAdd(
    IN OUT PLONG Addend,
    IN LONG Increment
    );

NTKERNELAPI
LONG
FASTCALL
InterlockedCompareExchange(
    IN OUT PLONG Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );

#define InterlockedCompareExchangePointer(Destination, ExChange, Comperand) \
    (PVOID)InterlockedCompareExchange((PLONG)Destination, (LONG)ExChange, (LONG)Comperand)

#pragma warning(disable:4035)               
#if !defined(MIDL_PASS) 

__inline
LONG
FASTCALL
InterlockedExchangeAdd(
    IN OUT PLONG Addend,
    IN LONG Increment
    )
{
    __asm {
        mov     eax, Increment
        mov     ecx, Addend
   lock xadd    [ecx], eax
    }
}


#endif      
#pragma warning(default:4035)   

#if !defined(MIDL_PASS) && defined(_M_IX86)

//
// i386 function definitions
//

#pragma warning(disable:4035)               // re-enable below


//
// Get current IRQL.
//
// On x86 this function resides in the HAL
//

NTHALAPI
KIRQL
KeGetCurrentIrql();


#endif // !defined(MIDL_PASS) && defined(_M_IX86)


NTKERNELAPI
NTSTATUS
NTAPI
KeSaveFloatingPointState (
    OUT PKFLOATING_SAVE     FloatSave
    );

NTKERNELAPI
NTSTATUS
NTAPI
KeRestoreFloatingPointState (
    IN PKFLOATING_SAVE      FloatSave
    );


#endif // defined(_X86_)


#if defined(_ALPHA_)
#ifdef __cplusplus
extern "C" {
#endif

//
// Types to use to contain PFNs and their counts.
//

typedef ULONG PFN_COUNT;

typedef LONG_PTR SPFN_NUMBER, *PSPFN_NUMBER;
typedef ULONG_PTR PFN_NUMBER, *PPFN_NUMBER;

//
// Define maximum size of flush multiple TB request.
//

#define FLUSH_MULTIPLE_MAXIMUM 16

//
// Indicate that the Alpha compiler supports the pragma textout construct.
//

#define ALLOC_PRAGMA 1


//
// Include the Alpha instruction definitions
//

#include "alphaops.h"

//
// Include reference machine definitions.
//

#include "alpharef.h"

//
// length of dispatch code in interrupt template
//
#define DISPATCH_LENGTH 4

//
// Define IRQL levels across the architecture.
//

#define PASSIVE_LEVEL   0
#define LOW_LEVEL       0
#define APC_LEVEL       1
#define DISPATCH_LEVEL  2
#define HIGH_LEVEL      7
#define SYNCH_LEVEL (IPI_LEVEL-1)

//
// Non-volatile floating point state
//

typedef struct _KFLOATING_SAVE {
    ULONGLONG   Fpcr;
    ULONGLONG   SoftFpcr;
    ULONG       Reserved1;              // These reserved words are here to make it
    ULONG       Reserved2;              // the same size as i386/WDM.
    ULONG       Reserved3;
    ULONG       Reserved4;
} KFLOATING_SAVE, *PKFLOATING_SAVE;

//
// I/O space read and write macros.
//
//  These have to be actual functions on Alpha, because we need
//  to shift the VA and OR in the BYTE ENABLES.
//
//  These can become INLINEs if we require that ALL Alpha systems shift
//  the same number of bits and have the SAME byte enables.
//
//  The READ/WRITE_REGISTER_* calls manipulate I/O registers in MEMORY space?
//
//  The READ/WRITE_PORT_* calls manipulate I/O registers in PORT space?
//

NTHALAPI
UCHAR
READ_REGISTER_UCHAR(
    PUCHAR Register
    );

NTHALAPI
USHORT
READ_REGISTER_USHORT(
    PUSHORT Register
    );

NTHALAPI
ULONG
READ_REGISTER_ULONG(
    PULONG Register
    );

NTHALAPI
VOID
READ_REGISTER_BUFFER_UCHAR(
    PUCHAR  Register,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
READ_REGISTER_BUFFER_USHORT(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
READ_REGISTER_BUFFER_ULONG(
    PULONG  Register,
    PULONG  Buffer,
    ULONG   Count
    );


NTHALAPI
VOID
WRITE_REGISTER_UCHAR(
    PUCHAR Register,
    UCHAR   Value
    );

NTHALAPI
VOID
WRITE_REGISTER_USHORT(
    PUSHORT Register,
    USHORT  Value
    );

NTHALAPI
VOID
WRITE_REGISTER_ULONG(
    PULONG Register,
    ULONG   Value
    );

NTHALAPI
VOID
WRITE_REGISTER_BUFFER_UCHAR(
    PUCHAR  Register,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_REGISTER_BUFFER_USHORT(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_REGISTER_BUFFER_ULONG(
    PULONG  Register,
    PULONG  Buffer,
    ULONG   Count
    );

NTHALAPI
UCHAR
READ_PORT_UCHAR(
    PUCHAR Port
    );

NTHALAPI
USHORT
READ_PORT_USHORT(
    PUSHORT Port
    );

NTHALAPI
ULONG
READ_PORT_ULONG(
    PULONG  Port
    );

NTHALAPI
VOID
READ_PORT_BUFFER_UCHAR(
    PUCHAR  Port,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
READ_PORT_BUFFER_USHORT(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
READ_PORT_BUFFER_ULONG(
    PULONG  Port,
    PULONG  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_PORT_UCHAR(
    PUCHAR  Port,
    UCHAR   Value
    );

NTHALAPI
VOID
WRITE_PORT_USHORT(
    PUSHORT Port,
    USHORT  Value
    );

NTHALAPI
VOID
WRITE_PORT_ULONG(
    PULONG  Port,
    ULONG   Value
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_UCHAR(
    PUCHAR  Port,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_USHORT(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_ULONG(
    PULONG  Port,
    PULONG  Buffer,
    ULONG   Count
    );


#if defined(_M_ALPHA) && !defined(RC_INVOKED)

#define InterlockedIncrement _InterlockedIncrement
#define InterlockedDecrement _InterlockedDecrement
#define InterlockedExchange _InterlockedExchange
#define InterlockedExchangeAdd _InterlockedExchangeAdd

LONG
InterlockedIncrement (
    IN OUT PLONG Addend
    );

LONG
InterlockedDecrement (
    IN OUT PLONG Addend
    );

LONG
InterlockedExchange (
    IN OUT PLONG Target,
    LONG Value
    );

#if defined(_M_AXP64)

#define InterlockedCompareExchange _InterlockedCompareExchange
#define InterlockedCompareExchange64 _InterlockedCompareExchange64
#define InterlockedExchangePointer _InterlockedExchangePointer
#define InterlockedCompareExchangePointer _InterlockedCompareExchangePointer
#define InterlockedExchange64 _InterlockedExchange64

LONG
InterlockedCompareExchange (
    IN OUT PLONG Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );

LONGLONG
InterlockedCompareExchange64 (
    IN OUT PLONGLONG Destination,
    IN LONGLONG ExChange,
    IN LONGLONG Comperand
    );

PVOID
InterlockedExchangePointer (
    IN OUT PVOID *Target,
    IN PVOID Value
    );

PVOID
InterlockedCompareExchangePointer (
    IN OUT PVOID *Destination,
    IN PVOID ExChange,
    IN PVOID Comperand
    );

LONGLONG
InterlockedExchange64(
    IN OUT PLONGLONG Target,
    IN LONGLONG Value
    );

#pragma intrinsic(_InterlockedCompareExchange64)
#pragma intrinsic(_InterlockedExchangePointer)
#pragma intrinsic(_InterlockedCompareExchangePointer)
#pragma intrinsic(_InterlockedExchange64)

#else

#define InterlockedExchangePointer(Target, Value) \
    (PVOID)InterlockedExchange((PLONG)(Target), (LONG)(Value))

#define InterlockedCompareExchange(Destination, ExChange, Comperand) \
    (LONG)_InterlockedCompareExchange((PVOID *)(Destination), (PVOID)(ExChange), (PVOID)(Comperand))

#define InterlockedCompareExchangePointer(Destination, ExChange, Comperand) \
    _InterlockedCompareExchange(Destination, ExChange, Comperand)

PVOID
_InterlockedCompareExchange (
    IN OUT PVOID *Destination,
    IN PVOID ExChange,
    IN PVOID Comperand
    );

NTKERNELAPI
LONGLONG
ExpInterlockedCompareExchange64 (
    IN OUT PLONGLONG Destination,
    IN PLONGLONG Exchange,
    IN PLONGLONG Comperand
    );

#endif

LONG
InterlockedExchangeAdd(
    IN OUT PLONG Addend,
    IN LONG Value
    );

#pragma intrinsic(_InterlockedIncrement)
#pragma intrinsic(_InterlockedDecrement)
#pragma intrinsic(_InterlockedExchange)
#pragma intrinsic(_InterlockedExchangeAdd)
#pragma intrinsic(_InterlockedCompareExchange)

#endif

// there is a lot of other stuff that could go in here
//   probe macros
//   others

//
// Define the page size for the Alpha ev4 and lca as 8k.
//

#define PAGE_SIZE 0x2000

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT 13L


#define MmGetProcedureAddress(Address) (Address)
#define MmLockPagableCodeSection(Address) MmLockPagableDataSection(Address)

//
// The lowest address for system space.
//

#if defined(_AXP64_)

#define MM_LOWEST_SYSTEM_ADDRESS (PVOID)0xFFFFFE0200000000

#else

#define MM_LOWEST_SYSTEM_ADDRESS (PVOID)0xC0800000

#endif


//
// Define prototypes to access PCR values
//

NTKERNELAPI
KIRQL
KeGetCurrentIrql();


NTSTATUS
KeSaveFloatingPointState (
    OUT PKFLOATING_SAVE     FloatSave
    );

NTSTATUS
KeRestoreFloatingPointState (
    IN PKFLOATING_SAVE      FloatSave
    );

//
// Cache and write buffer flush functions.
//

VOID
KeFlushIoBuffers (
    IN PMDL Mdl,
    IN BOOLEAN ReadOperation,
    IN BOOLEAN DmaOperation
    );


#define KeQueryTickCount(CurrentCount ) \
    *(PULONGLONG)(CurrentCount) = **((volatile ULONGLONG **)(&KeTickCount));


#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))
#define ExAcquireSpinLockAtDpcLevel(Lock) KeAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock) KeReleaseSpinLockFromDpcLevel(Lock)

#ifdef __cplusplus
}   // extern "C"
#endif
#endif // _ALPHA_

#if defined(_IA64_)

//
// Types to use to contain PFNs and their counts.
//

typedef ULONG PFN_COUNT;

typedef LONG_PTR SPFN_NUMBER, *PSPFN_NUMBER;
typedef ULONG_PTR PFN_NUMBER, *PPFN_NUMBER;    

//
// Define maximum size of flush multiple TB request.
//

#define FLUSH_MULTIPLE_MAXIMUM 100

//
// Indicate that the IA64 compiler supports the pragma textout construct.
//

#define ALLOC_PRAGMA 1

//
// Define intrinsic calls and their prototypes
//

#include "ia64reg.h"

// Please contact INTEL to get IA64-specific information
// @@BEGIN_DDKSPLIT

unsigned __int64 __getReg (int);         // Intel-IA64-Filler
void __setReg (int, unsigned __int64);   // Intel-IA64-Filler
void __isrlz (void);                     // Intel-IA64-Filler
void __dsrlz (void);                     // Intel-IA64-Filler
void __fwb (void);                       // Intel-IA64-Filler
void __mf (void);                        // Intel-IA64-Filler
void __mfa (void);                       // Intel-IA64-Filler
void __synci (void);                     // Intel-IA64-Filler
__int64 __thash (__int64);               // Intel-IA64-Filler
__int64 __ttag (__int64);                // Intel-IA64-Filler
void __ptcl (__int64, __int64);          // Intel-IA64-Filler
void __ptcg (__int64, __int64);          // Intel-IA64-Filler
void __ptcga (__int64, __int64);         // Intel-IA64-Filler
void __ptri (__int64, __int64);          // Intel-IA64-Filler
void __ptrd (__int64, __int64);          // Intel-IA64-Filler
void __invalat (void);                   // Intel-IA64-Filler
void __break (int);                      // Intel-IA64-Filler
void __fc (__int64);                     // Intel-IA64-Filler
void __sum (int);                        // Intel-IA64-Filler
void __rsm (int);                        // Intel-IA64-Filler

#ifdef _M_IA64
#pragma intrinsic (__getReg)             // Intel-IA64-Filler
#pragma intrinsic (__setReg)             // Intel-IA64-Filler
#pragma intrinsic (__isrlz)              // Intel-IA64-Filler
#pragma intrinsic (__dsrlz)              // Intel-IA64-Filler
#pragma intrinsic (__fwb)                // Intel-IA64-Filler
#pragma intrinsic (__mf)                 // Intel-IA64-Filler
#pragma intrinsic (__mfa)                // Intel-IA64-Filler
#pragma intrinsic (__synci)              // Intel-IA64-Filler
#pragma intrinsic (__thash)              // Intel-IA64-Filler
#pragma intrinsic (__ttag)               // Intel-IA64-Filler
#pragma intrinsic (__ptcl)               // Intel-IA64-Filler
#pragma intrinsic (__ptcg)               // Intel-IA64-Filler
#pragma intrinsic (__ptcga)              // Intel-IA64-Filler
#pragma intrinsic (__ptri)               // Intel-IA64-Filler
#pragma intrinsic (__ptrd)               // Intel-IA64-Filler
#pragma intrinsic (__invalat)            // Intel-IA64-Filler
#pragma intrinsic (__break)              // Intel-IA64-Filler
#pragma intrinsic (__fc)                 // Intel-IA64-Filler
#pragma intrinsic (__sum)                // Intel-IA64-Filler
#pragma intrinsic (__rsm)                // Intel-IA64-Filler
#endif // _M_IA64

// @@END_DDKSPLIT


//
// Define length of interrupt vector table.
//

// Please contact INTEL to get IA64-specific information
#define MAXIMUM_VECTOR 256


//
// IA64 Interrupt Definitions.
//
// Define length of interrupt object dispatch code in longwords.
//

// Please contact INTEL to get IA64-specific information
// @@BEGIN_DDKSPLIT
#define DISPATCH_LENGTH 2*2               // Intel-IA64-Filler ; Length of dispatch code template in 32-bit words
// @@END_DDKSPLIT

//
// Begin of a block of definitions that must be synchronized with kxia64.h.
//

//
// Define Interrupt Request Levels.
//

#define PASSIVE_LEVEL            0      // Passive release level
#define LOW_LEVEL                0      // Lowest interrupt level
#define APC_LEVEL                1      // APC interrupt level
#define DISPATCH_LEVEL           2      // Dispatcher level
#define CMC_LEVEL                3      // Correctable machine check level
#define DEVICE_LEVEL_BASE        4      // 4 - 11 - Device IRQLs
#define PROFILE_LEVEL           12      // Profiling level
#define PC_LEVEL                12      // Performance Counter IRQL
#define SYNCH_LEVEL             (IPI_LEVEL-1)      // Synchronization level
#define IPI_LEVEL               14      // IPI IRQL
#define CLOCK_LEVEL             13      // Clock Timer IRQL
#define POWER_LEVEL             15      // Power failure level
#define HIGH_LEVEL              15      // Highest interrupt level

// Please contact INTEL to get IA64-specific information
// @@BEGIN_DDKSPLIT
//
// The current IRQL is maintained in the TPR.mic field. The         // Intel-IA64-Filler
// shift count is the number of bits to shift right to extract the  // Intel-IA64-Filler
// IRQL from the TPR. See the GET/SET_IRQL macros.                  // Intel-IA64-Filler
//

#define TPR_MIC        4                                            // Intel-IA64-Filler
#define TPR_IRQL_SHIFT TPR_MIC                                      // Intel-IA64-Filler

// To go from vector number <-> IRQL we just do a shift             // Intel-IA64-Filler
#define VECTOR_IRQL_SHIFT TPR_IRQL_SHIFT                            // Intel-IA64-Filler

//                                                                  // Intel-IA64-Filler
// Interrupt Vector Definitions                                     // Intel-IA64-Filler
//                                                                  // Intel-IA64-Filler

#define APC_VECTOR          APC_LEVEL << VECTOR_IRQL_SHIFT          // Intel-IA64-Filler
#define DISPATCH_VECTOR     DISPATCH_LEVEL << VECTOR_IRQL_SHIFT     // Intel-IA64-Filler

// @@END_DDKSPLIT

//
// End of a block of definitions that must be synchronized with kxia64.h.
//

//
// Define profile intervals.
//

#define DEFAULT_PROFILE_COUNT 0x40000000 // ~= 20 seconds @50mhz
#define DEFAULT_PROFILE_INTERVAL (10 * 500) // 500 microseconds
#define MAXIMUM_PROFILE_INTERVAL (10 * 1000 * 1000) // 1 second
#define MINIMUM_PROFILE_INTERVAL (10 * 40) // 40 microseconds

#if defined(_M_IA64) && !defined(RC_INVOKED)

#define InterlockedAdd _InterlockedAdd
#define InterlockedIncrement _InterlockedIncrement
#define InterlockedDecrement _InterlockedDecrement
#define InterlockedExchange _InterlockedExchange
#define InterlockedExchangeAdd _InterlockedExchangeAdd

#define InterlockedAdd64 _InterlockedAdd64
#define InterlockedIncrement64 _InterlockedIncrement64
#define InterlockedDecrement64 _InterlockedDecrement64
#define InterlockedExchange64 _InterlockedExchange64
#define InterlockedExchangeAdd64 _InterlockedExchangeAdd64
#define InterlockedCompareExchange64 _InterlockedCompareExchange64

#define InterlockedCompareExchange _InterlockedCompareExchange
#define InterlockedExchangePointer _InterlockedExchangePointer
#define InterlockedCompareExchangePointer _InterlockedCompareExchangePointer

LONG
__cdecl
InterlockedAdd (
    LONG *Addend,
    LONG Value
    );

LONGLONG
__cdecl
InterlockedAdd64 (
    LONGLONG *Addend,
    LONGLONG Value
    );

LONG
__cdecl
InterlockedIncrement(
    IN OUT PLONG Addend
    );

LONG
__cdecl
InterlockedDecrement(
    IN OUT PLONG Addend
    );

LONG
__cdecl
InterlockedExchange(
    IN OUT PLONG Target,
    IN LONG Value
    );

LONG
__cdecl
InterlockedExchangeAdd(
    IN OUT PLONG Addend,
    IN LONG Value
    );

LONG
__cdecl
InterlockedCompareExchange (
    IN OUT PLONG Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );

LONGLONG
__cdecl
InterlockedIncrement64(
    IN OUT PLONGLONG Addend
    );

LONGLONG
__cdecl
InterlockedDecrement64(
    IN OUT PLONGLONG Addend
    );

LONGLONG
__cdecl
InterlockedExchange64(
    IN OUT PLONGLONG Target,
    IN LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedExchangeAdd64(
    IN OUT PLONGLONG Addend,
    IN LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedCompareExchange64 (
    IN OUT PLONGLONG Destination,
    IN LONGLONG ExChange,
    IN LONGLONG Comperand
    );

PVOID
__cdecl
InterlockedCompareExchangePointer (
    IN OUT PVOID *Destination,
    IN PVOID Exchange,
    IN PVOID Comperand
    );

PVOID
__cdecl
InterlockedExchangePointer(
    IN OUT PVOID *Target,
    IN PVOID Value
    );

#pragma intrinsic(_InterlockedAdd)
#pragma intrinsic(_InterlockedIncrement)
#pragma intrinsic(_InterlockedDecrement)
#pragma intrinsic(_InterlockedExchange)
#pragma intrinsic(_InterlockedCompareExchange)
#pragma intrinsic(_InterlockedExchangeAdd)
#pragma intrinsic(_InterlockedAdd64)
#pragma intrinsic(_InterlockedIncrement64)
#pragma intrinsic(_InterlockedDecrement64)
#pragma intrinsic(_InterlockedExchange64)
#pragma intrinsic(_InterlockedCompareExchange64)
#pragma intrinsic(_InterlockedExchangeAdd64)
#pragma intrinsic(_InterlockedExchangePointer)
#pragma intrinsic(_InterlockedCompareExchangePointer)

#endif // defined(_M_IA64) && !defined(RC_INVOKED)


#define KI_USER_SHARED_DATA ((ULONG_PTR)(KADDRESS_BASE + 0xFFFE0000))
#define SharedUserData ((KUSER_SHARED_DATA * const)KI_USER_SHARED_DATA)

//
// Prototype for get current IRQL. **** TBD (read TPR)
//

NTKERNELAPI
KIRQL
KeGetCurrentIrql();


#define KeSaveFloatingPointState(a)         STATUS_SUCCESS
#define KeRestoreFloatingPointState(a)      STATUS_SUCCESS


//
// Define the page size
//

#define PAGE_SIZE 0x2000

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT 13L

//
// Cache and write buffer flush functions.
//

NTKERNELAPI
VOID
KeFlushIoBuffers (
    IN PMDL Mdl,
    IN BOOLEAN ReadOperation,
    IN BOOLEAN DmaOperation
    );


//
// Kernel breakin breakpoint
//

VOID
KeBreakinBreakpoint (
    VOID
    );


#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))
#define ExAcquireSpinLockAtDpcLevel(Lock) KeAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock) KeReleaseSpinLockFromDpcLevel(Lock)


#define KeQueryTickCount(CurrentCount ) \
    *(PULONGLONG)(CurrentCount) = **((volatile ULONGLONG **)(&KeTickCount));

//
// I/O space read and write macros.
//

NTHALAPI
UCHAR
READ_PORT_UCHAR (
    PUCHAR RegisterAddress
    );

NTHALAPI
USHORT
READ_PORT_USHORT (
    PUSHORT RegisterAddress
    );

NTHALAPI
ULONG
READ_PORT_ULONG (
    PULONG RegisterAddress
    );

NTHALAPI
VOID
READ_PORT_BUFFER_UCHAR (
    PUCHAR portAddress,
    PUCHAR readBuffer,
    ULONG  readCount
    );

NTHALAPI
VOID
READ_PORT_BUFFER_USHORT (
    PUSHORT portAddress,
    PUSHORT readBuffer,
    ULONG  readCount
    );

NTHALAPI
VOID
READ_PORT_BUFFER_ULONG (
    PULONG portAddress,
    PULONG readBuffer,
    ULONG  readCount
    );

NTHALAPI
VOID
WRITE_PORT_UCHAR (
    PUCHAR portAddress,
    UCHAR  Data
    );

NTHALAPI
VOID
WRITE_PORT_USHORT (
    PUSHORT portAddress,
    USHORT  Data
    );

NTHALAPI
VOID
WRITE_PORT_ULONG (
    PULONG portAddress,
    ULONG  Data
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_UCHAR (
    PUCHAR portAddress,
    PUCHAR writeBuffer,
    ULONG  writeCount
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_USHORT (
    PUSHORT portAddress,
    PUSHORT writeBuffer,
    ULONG  writeCount
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_ULONG (
    PULONG portAddress,
    PULONG writeBuffer,
    ULONG  writeCount
    );


#define READ_REGISTER_UCHAR(x) \
    (__mf(), *(volatile UCHAR * const)(x))

#define READ_REGISTER_USHORT(x) \
    (__mf(), *(volatile USHORT * const)(x))

#define READ_REGISTER_ULONG(x) \
    (__mf(), *(volatile ULONG * const)(x))

#define READ_REGISTER_BUFFER_UCHAR(x, y, z) {                           \
    PUCHAR registerBuffer = x;                                          \
    PUCHAR readBuffer = y;                                              \
    ULONG readCount;                                                    \
    __mf();                                                             \
    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \
        *readBuffer = *(volatile UCHAR * const)(registerBuffer);        \
    }                                                                   \
}

#define READ_REGISTER_BUFFER_USHORT(x, y, z) {                          \
    PUSHORT registerBuffer = x;                                         \
    PUSHORT readBuffer = y;                                             \
    ULONG readCount;                                                    \
    __mf();                                                             \
    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \
        *readBuffer = *(volatile USHORT * const)(registerBuffer);       \
    }                                                                   \
}

#define READ_REGISTER_BUFFER_ULONG(x, y, z) {                           \
    PULONG registerBuffer = x;                                          \
    PULONG readBuffer = y;                                              \
    ULONG readCount;                                                    \
    __mf();                                                             \
    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \
        *readBuffer = *(volatile ULONG * const)(registerBuffer);        \
    }                                                                   \
}

#define WRITE_REGISTER_UCHAR(x, y) {    \
    *(volatile UCHAR * const)(x) = y;   \
    KeFlushWriteBuffer();               \
}

#define WRITE_REGISTER_USHORT(x, y) {   \
    *(volatile USHORT * const)(x) = y;  \
    KeFlushWriteBuffer();               \
}

#define WRITE_REGISTER_ULONG(x, y) {    \
    *(volatile ULONG * const)(x) = y;   \
    KeFlushWriteBuffer();               \
}

#define WRITE_REGISTER_BUFFER_UCHAR(x, y, z) {                            \
    PUCHAR registerBuffer = x;                                            \
    PUCHAR writeBuffer = y;                                               \
    ULONG writeCount;                                                     \
    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \
        *(volatile UCHAR * const)(registerBuffer) = *writeBuffer;         \
    }                                                                     \
    KeFlushWriteBuffer();                                                 \
}

#define WRITE_REGISTER_BUFFER_USHORT(x, y, z) {                           \
    PUSHORT registerBuffer = x;                                           \
    PUSHORT writeBuffer = y;                                              \
    ULONG writeCount;                                                     \
    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \
        *(volatile USHORT * const)(registerBuffer) = *writeBuffer;        \
    }                                                                     \
    KeFlushWriteBuffer();                                                 \
}

#define WRITE_REGISTER_BUFFER_ULONG(x, y, z) {                            \
    PULONG registerBuffer = x;                                            \
    PULONG writeBuffer = y;                                               \
    ULONG writeCount;                                                     \
    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \
        *(volatile ULONG * const)(registerBuffer) = *writeBuffer;         \
    }                                                                     \
    KeFlushWriteBuffer();                                                 \
}

//
// Non-volatile floating point state
//

typedef struct _KFLOATING_SAVE {
    ULONG   Reserved;
} KFLOATING_SAVE, *PKFLOATING_SAVE;

//
// STATUS register for each MCA bank.
//

typedef union _MCI_STATS {
    struct {
        USHORT  McaCod;
        USHORT  MsCod;
        ULONG   OtherInfo : 25;
        ULONG   Damage : 1;
        ULONG   AddressValid : 1;
        ULONG   MiscValid : 1;
        ULONG   Enabled : 1;
        ULONG   UnCorrected : 1;
        ULONG   OverFlow : 1;
        ULONG   Valid : 1;
    } MciStats;

    ULONGLONG QuadPart;

} MCI_STATS, *PMCI_STATS;


#define MmGetProcedureAddress(Address) (Address)
#define MmLockPagableCodeSection(PLabelAddress) \
    MmLockPagableDataSection((PVOID)(*((PULONGLONG)PLabelAddress)))

//
// The lowest address for system space.
//

#define MM_LOWEST_SYSTEM_ADDRESS ((PVOID)((ULONG_PTR)(KADDRESS_BASE + 0xC0C00000)))
#endif // defined(_IA64_)

#if defined(_X86_)

//
// Define system time structure.
//

typedef struct _KSYSTEM_TIME {
    ULONG LowPart;
    LONG High1Time;
    LONG High2Time;
} KSYSTEM_TIME, *PKSYSTEM_TIME;

#endif


#ifdef _X86_

//
// Disable these two pramas that evaluate to "sti" "cli" on x86 so that driver
// writers to not leave them inadvertantly in their code.
//

#if !defined(MIDL_PASS)
#if !defined(RC_INVOKED)

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4164)   // disable C4164 warning so that apps that
                                // build with /Od don't get weird errors !
#ifdef _M_IX86
#pragma function(_enable)
#pragma function(_disable)
#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4164)   // reenable C4164 warning
#endif

#endif
#endif

#endif // _X86_

#if defined(_ALPHA_)

//
// Define system time structure.
//

typedef ULONGLONG KSYSTEM_TIME;
typedef KSYSTEM_TIME *PKSYSTEM_TIME;

#endif

#ifdef _ALPHA_                  
#endif 
#ifdef _IA64_

//
// Define system time structure (use alpha approach).
//

typedef ULONGLONG KSYSTEM_TIME;
typedef KSYSTEM_TIME *PKSYSTEM_TIME;

#endif // _IA64_

#ifdef _IA64_

#endif // _IA64_
//
// Event Specific Access Rights.
//

#define EVENT_QUERY_STATE       0x0001
#define EVENT_MODIFY_STATE      0x0002  
#define EVENT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3) 

//
// Semaphore Specific Access Rights.
//

#define SEMAPHORE_QUERY_STATE       0x0001
#define SEMAPHORE_MODIFY_STATE      0x0002  

#define SEMAPHORE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3) 


//
// Predefined Value Types.
//

#define REG_NONE                    ( 0 )   // No value type
#define REG_SZ                      ( 1 )   // Unicode nul terminated string
#define REG_EXPAND_SZ               ( 2 )   // Unicode nul terminated string
                                            // (with environment variable references)
#define REG_BINARY                  ( 3 )   // Free form binary
#define REG_DWORD                   ( 4 )   // 32-bit number
#define REG_DWORD_LITTLE_ENDIAN     ( 4 )   // 32-bit number (same as REG_DWORD)
#define REG_DWORD_BIG_ENDIAN        ( 5 )   // 32-bit number
#define REG_LINK                    ( 6 )   // Symbolic Link (unicode)
#define REG_MULTI_SZ                ( 7 )   // Multiple Unicode strings
#define REG_RESOURCE_LIST           ( 8 )   // Resource list in the resource map
#define REG_FULL_RESOURCE_DESCRIPTOR ( 9 )  // Resource list in the hardware description
#define REG_RESOURCE_REQUIREMENTS_LIST ( 10 )
#define REG_QWORD                   ( 11 )  // 64-bit number
#define REG_QWORD_LITTLE_ENDIAN     ( 11 )  // 64-bit number (same as REG_QWORD)

//
// Service Types (Bit Mask)
//
#define SERVICE_KERNEL_DRIVER          0x00000001
#define SERVICE_FILE_SYSTEM_DRIVER     0x00000002
#define SERVICE_ADAPTER                0x00000004
#define SERVICE_RECOGNIZER_DRIVER      0x00000008

#define SERVICE_DRIVER                 (SERVICE_KERNEL_DRIVER | \
                                        SERVICE_FILE_SYSTEM_DRIVER | \
                                        SERVICE_RECOGNIZER_DRIVER)

#define SERVICE_WIN32_OWN_PROCESS      0x00000010
#define SERVICE_WIN32_SHARE_PROCESS    0x00000020
#define SERVICE_WIN32                  (SERVICE_WIN32_OWN_PROCESS | \
                                        SERVICE_WIN32_SHARE_PROCESS)

#define SERVICE_INTERACTIVE_PROCESS    0x00000100

#define SERVICE_TYPE_ALL               (SERVICE_WIN32  | \
                                        SERVICE_ADAPTER | \
                                        SERVICE_DRIVER  | \
                                        SERVICE_INTERACTIVE_PROCESS)

//
// Start Type
//

#define SERVICE_BOOT_START             0x00000000
#define SERVICE_SYSTEM_START           0x00000001
#define SERVICE_AUTO_START             0x00000002
#define SERVICE_DEMAND_START           0x00000003
#define SERVICE_DISABLED               0x00000004

//
// Error control type
//
#define SERVICE_ERROR_IGNORE           0x00000000
#define SERVICE_ERROR_NORMAL           0x00000001
#define SERVICE_ERROR_SEVERE           0x00000002
#define SERVICE_ERROR_CRITICAL         0x00000003

//
//
// Define the registry driver node enumerations
//

typedef enum _CM_SERVICE_NODE_TYPE {
    DriverType               = SERVICE_KERNEL_DRIVER,
    FileSystemType           = SERVICE_FILE_SYSTEM_DRIVER,
    Win32ServiceOwnProcess   = SERVICE_WIN32_OWN_PROCESS,
    Win32ServiceShareProcess = SERVICE_WIN32_SHARE_PROCESS,
    AdapterType              = SERVICE_ADAPTER,
    RecognizerType           = SERVICE_RECOGNIZER_DRIVER
} SERVICE_NODE_TYPE;

typedef enum _CM_SERVICE_LOAD_TYPE {
    BootLoad    = SERVICE_BOOT_START,
    SystemLoad  = SERVICE_SYSTEM_START,
    AutoLoad    = SERVICE_AUTO_START,
    DemandLoad  = SERVICE_DEMAND_START,
    DisableLoad = SERVICE_DISABLED
} SERVICE_LOAD_TYPE;

typedef enum _CM_ERROR_CONTROL_TYPE {
    IgnoreError   = SERVICE_ERROR_IGNORE,
    NormalError   = SERVICE_ERROR_NORMAL,
    SevereError   = SERVICE_ERROR_SEVERE,
    CriticalError = SERVICE_ERROR_CRITICAL
} SERVICE_ERROR_TYPE;



//
// Resource List definitions
//



//
// Defines the Type in the RESOURCE_DESCRIPTOR
//
// NOTE:  For all CM_RESOURCE_TYPE values, there must be a
// corresponding ResType value in the 32-bit ConfigMgr headerfile
// (cfgmgr32.h).  Values in the range [0x6,0x80) use the same values
// as their ConfigMgr counterparts.  CM_RESOURCE_TYPE values with
// the high bit set (i.e., in the range [0x80,0xFF]), are
// non-arbitrated resources.  These correspond to the same values
// in cfgmgr32.h that have their high bit set (however, since
// cfgmgr32.h uses 16 bits for ResType values, these values are in
// the range [0x8000,0x807F).  Note that ConfigMgr ResType values
// cannot be in the range [0x8080,0xFFFF), because they would not
// be able to map into CM_RESOURCE_TYPE values.  (0xFFFF itself is
// a special value, because it maps to CmResourceTypeDeviceSpecific.)
//

typedef int CM_RESOURCE_TYPE;

// CmResourceTypeNull is reserved

#define CmResourceTypeNull                0   // ResType_All or ResType_None (0x0000)
#define CmResourceTypePort                1   // ResType_IO (0x0002)
#define CmResourceTypeInterrupt           2   // ResType_IRQ (0x0004)
#define CmResourceTypeMemory              3   // ResType_Mem (0x0001)
#define CmResourceTypeDma                 4   // ResType_DMA (0x0003)
#define CmResourceTypeDeviceSpecific      5   // ResType_ClassSpecific (0xFFFF)
#define CmResourceTypeBusNumber           6   // ResType_BusNumber (0x0006)
#define CmResourceTypeNonArbitrated     128   // Not arbitrated if 0x80 bit set
#define CmResourceTypeConfigData        128   // ResType_Reserved (0x8000)
#define CmResourceTypeDevicePrivate     129   // ResType_DevicePrivate (0x8001)
#define CmResourceTypePcCardConfig      130   // ResType_PcCardConfig (0x8002)
#define CmResourceTypeMfCardConfig      131   // ResType_MfCardConfig (0x8003)

//
// Defines the ShareDisposition in the RESOURCE_DESCRIPTOR
//

typedef enum _CM_SHARE_DISPOSITION {
    CmResourceShareUndetermined = 0,    // Reserved
    CmResourceShareDeviceExclusive,
    CmResourceShareDriverExclusive,
    CmResourceShareShared
} CM_SHARE_DISPOSITION;

//
// Define the PASSIGNED_RESOURCE type
//

#ifndef PASSIGNED_RESOURCE_DEFINED
#define PASSIGNED_RESOURCE_DEFINED
typedef PVOID PASSIGNED_RESOURCE;
#endif // PASSIGNED_RESOURCE_DEFINED


//
// Define the bit masks for Flags when type is CmResourceTypeInterrupt
//

#define CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE 0
#define CM_RESOURCE_INTERRUPT_LATCHED         1

//
// Define the bit masks for Flags when type is CmResourceTypeMemory
//

#define CM_RESOURCE_MEMORY_READ_WRITE       0x0000
#define CM_RESOURCE_MEMORY_READ_ONLY        0x0001
#define CM_RESOURCE_MEMORY_WRITE_ONLY       0x0002
#define CM_RESOURCE_MEMORY_PREFETCHABLE     0x0004

#define CM_RESOURCE_MEMORY_COMBINEDWRITE    0x0008
#define CM_RESOURCE_MEMORY_24               0x0010
#define CM_RESOURCE_MEMORY_CACHEABLE        0x0020

//
// Define the bit masks for Flags when type is CmResourceTypePort
//

#define CM_RESOURCE_PORT_MEMORY                             0x0000
#define CM_RESOURCE_PORT_IO                                 0x0001
#define CM_RESOURCE_PORT_10_BIT_DECODE                      0x0004
#define CM_RESOURCE_PORT_12_BIT_DECODE                      0x0008
#define CM_RESOURCE_PORT_16_BIT_DECODE                      0x0010
#define CM_RESOURCE_PORT_POSITIVE_DECODE                    0x0020
#define CM_RESOURCE_PORT_PASSIVE_DECODE                     0x0040
#define CM_RESOURCE_PORT_WINDOW_DECODE                      0x0080

//
// Define the bit masks for Flags when type is CmResourceTypeDma
//

#define CM_RESOURCE_DMA_8                   0x0000
#define CM_RESOURCE_DMA_16                  0x0001
#define CM_RESOURCE_DMA_32                  0x0002
#define CM_RESOURCE_DMA_8_AND_16            0x0004
#define CM_RESOURCE_DMA_BUS_MASTER          0x0008
#define CM_RESOURCE_DMA_TYPE_A              0x0010
#define CM_RESOURCE_DMA_TYPE_B              0x0020
#define CM_RESOURCE_DMA_TYPE_F              0x0040

//
// This structure defines one type of resource used by a driver.
//
// There can only be *1* DeviceSpecificData block. It must be located at
// the end of all resource descriptors in a full descriptor block.
//

//
// Make sure alignment is made properly by compiler; otherwise move
// flags back to the top of the structure (common to all members of the
// union).
//


#include "pshpack4.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
    UCHAR Type;
    UCHAR ShareDisposition;
    USHORT Flags;
    union {

        //
        // Range of resources, inclusive.  These are physical, bus relative.
        // It is known that Port and Memory below have the exact same layout
        // as Generic.
        //

        struct {
            PHYSICAL_ADDRESS Start;
            ULONG Length;
        } Generic;

        //
        //

        struct {
            PHYSICAL_ADDRESS Start;
            ULONG Length;
        } Port;

        //
        //

        struct {
            ULONG Level;
            ULONG Vector;
            ULONG Affinity;
        } Interrupt;

        //
        // Range of memory addresses, inclusive. These are physical, bus
        // relative. The value should be the same as the one passed to
        // HalTranslateBusAddress().
        //

        struct {
            PHYSICAL_ADDRESS Start;    // 64 bit physical addresses.
            ULONG Length;
        } Memory;

        //
        // Physical DMA channel.
        //

        struct {
            ULONG Channel;
            ULONG Port;
            ULONG Reserved1;
        } Dma;

        //
        // Device driver private data, usually used to help it figure
        // what the resource assignments decisions that were made.
        //

        struct {
            ULONG Data[3];
        } DevicePrivate;

        //
        // Bus Number information.
        //

        struct {
            ULONG Start;
            ULONG Length;
            ULONG Reserved;
        } BusNumber;

        //
        // Device Specific information defined by the driver.
        // The DataSize field indicates the size of the data in bytes. The
        // data is located immediately after the DeviceSpecificData field in
        // the structure.
        //

        struct {
            ULONG DataSize;
            ULONG Reserved1;
            ULONG Reserved2;
        } DeviceSpecificData;
    } u;
} CM_PARTIAL_RESOURCE_DESCRIPTOR, *PCM_PARTIAL_RESOURCE_DESCRIPTOR;
#include "poppack.h"

//
// A Partial Resource List is what can be found in the ARC firmware
// or will be generated by ntdetect.com.
// The configuration manager will transform this structure into a Full
// resource descriptor when it is about to store it in the regsitry.
//
// Note: There must a be a convention to the order of fields of same type,
// (defined on a device by device basis) so that the fields can make sense
// to a driver (i.e. when multiple memory ranges are necessary).
//

typedef struct _CM_PARTIAL_RESOURCE_LIST {
    USHORT Version;
    USHORT Revision;
    ULONG Count;
    CM_PARTIAL_RESOURCE_DESCRIPTOR PartialDescriptors[1];
} CM_PARTIAL_RESOURCE_LIST, *PCM_PARTIAL_RESOURCE_LIST;

//
// A Full Resource Descriptor is what can be found in the registry.
// This is what will be returned to a driver when it queries the registry
// to get device information; it will be stored under a key in the hardware
// description tree.
//
// Note: There must a be a convention to the order of fields of same type,
// (defined on a device by device basis) so that the fields can make sense
// to a driver (i.e. when multiple memory ranges are necessary).
//

typedef struct _CM_FULL_RESOURCE_DESCRIPTOR {
    INTERFACE_TYPE DoNotUse1;
    ULONG DoNotUse2;
    CM_PARTIAL_RESOURCE_LIST PartialResourceList;
} CM_FULL_RESOURCE_DESCRIPTOR, *PCM_FULL_RESOURCE_DESCRIPTOR;

//
// The Resource list is what will be stored by the drivers into the
// resource map via the IO API.
//

typedef struct _CM_RESOURCE_LIST {
    ULONG Count;
    CM_FULL_RESOURCE_DESCRIPTOR List[1];
} CM_RESOURCE_LIST, *PCM_RESOURCE_LIST;


//
// Define the structures used to interpret configuration data of
// \\Registry\machine\hardware\description tree.
// Basically, these structures are used to interpret component
// sepcific data.
//

//
// Define DEVICE_FLAGS
//

typedef struct _DEVICE_FLAGS {
    ULONG Failed : 1;
    ULONG ReadOnly : 1;
    ULONG Removable : 1;
    ULONG ConsoleIn : 1;
    ULONG ConsoleOut : 1;
    ULONG Input : 1;
    ULONG Output : 1;
} DEVICE_FLAGS, *PDEVICE_FLAGS;

//
// Define Component Information structure
//

typedef struct _CM_COMPONENT_INFORMATION {
    DEVICE_FLAGS Flags;
    ULONG Version;
    ULONG Key;
    ULONG AffinityMask;
} CM_COMPONENT_INFORMATION, *PCM_COMPONENT_INFORMATION;

//
// The following structures are used to interpret x86
// DeviceSpecificData of CM_PARTIAL_RESOURCE_DESCRIPTOR.
// (Most of the structures are defined by BIOS.  They are
// not aligned on word (or dword) boundary.
//

//
// Define the Rom Block structure
//

typedef struct _CM_ROM_BLOCK {
    ULONG Address;
    ULONG Size;
} CM_ROM_BLOCK, *PCM_ROM_BLOCK;



#include "pshpack1.h"



//
// Define INT13 driver parameter block
//

typedef struct _CM_INT13_DRIVE_PARAMETER {
    USHORT DriveSelect;
    ULONG MaxCylinders;
    USHORT SectorsPerTrack;
    USHORT MaxHeads;
    USHORT NumberDrives;
} CM_INT13_DRIVE_PARAMETER, *PCM_INT13_DRIVE_PARAMETER;



//
// Define Mca POS data block for slot
//

typedef struct _CM_MCA_POS_DATA {
    USHORT AdapterId;
    UCHAR PosData1;
    UCHAR PosData2;
    UCHAR PosData3;
    UCHAR PosData4;
} CM_MCA_POS_DATA, *PCM_MCA_POS_DATA;

//
// Memory configuration of eisa data block structure
//

typedef struct _EISA_MEMORY_TYPE {
    UCHAR ReadWrite: 1;
    UCHAR Cached : 1;
    UCHAR Reserved0 :1;
    UCHAR Type:2;
    UCHAR Shared:1;
    UCHAR Reserved1 :1;
    UCHAR MoreEntries : 1;
} EISA_MEMORY_TYPE, *PEISA_MEMORY_TYPE;

typedef struct _EISA_MEMORY_CONFIGURATION {
    EISA_MEMORY_TYPE ConfigurationByte;
    UCHAR DataSize;
    USHORT AddressLowWord;
    UCHAR AddressHighByte;
    USHORT MemorySize;
} EISA_MEMORY_CONFIGURATION, *PEISA_MEMORY_CONFIGURATION;


//
// Interrupt configurationn of eisa data block structure
//

typedef struct _EISA_IRQ_DESCRIPTOR {
    UCHAR Interrupt : 4;
    UCHAR Reserved :1;
    UCHAR LevelTriggered :1;
    UCHAR Shared : 1;
    UCHAR MoreEntries : 1;
} EISA_IRQ_DESCRIPTOR, *PEISA_IRQ_DESCRIPTOR;

typedef struct _EISA_IRQ_CONFIGURATION {
    EISA_IRQ_DESCRIPTOR ConfigurationByte;
    UCHAR Reserved;
} EISA_IRQ_CONFIGURATION, *PEISA_IRQ_CONFIGURATION;


//
// DMA description of eisa data block structure
//

typedef struct _DMA_CONFIGURATION_BYTE0 {
    UCHAR Channel : 3;
    UCHAR Reserved : 3;
    UCHAR Shared :1;
    UCHAR MoreEntries :1;
} DMA_CONFIGURATION_BYTE0;

typedef struct _DMA_CONFIGURATION_BYTE1 {
    UCHAR Reserved0 : 2;
    UCHAR TransferSize : 2;
    UCHAR Timing : 2;
    UCHAR Reserved1 : 2;
} DMA_CONFIGURATION_BYTE1;

typedef struct _EISA_DMA_CONFIGURATION {
    DMA_CONFIGURATION_BYTE0 ConfigurationByte0;
    DMA_CONFIGURATION_BYTE1 ConfigurationByte1;
} EISA_DMA_CONFIGURATION, *PEISA_DMA_CONFIGURATION;


//
// Port description of eisa data block structure
//

typedef struct _EISA_PORT_DESCRIPTOR {
    UCHAR NumberPorts : 5;
    UCHAR Reserved :1;
    UCHAR Shared :1;
    UCHAR MoreEntries : 1;
} EISA_PORT_DESCRIPTOR, *PEISA_PORT_DESCRIPTOR;

typedef struct _EISA_PORT_CONFIGURATION {
    EISA_PORT_DESCRIPTOR Configuration;
    USHORT PortAddress;
} EISA_PORT_CONFIGURATION, *PEISA_PORT_CONFIGURATION;


//
// Eisa slot information definition
// N.B. This structure is different from the one defined
//      in ARC eisa addendum.
//

typedef struct _CM_EISA_SLOT_INFORMATION {
    UCHAR ReturnCode;
    UCHAR ReturnFlags;
    UCHAR MajorRevision;
    UCHAR MinorRevision;
    USHORT Checksum;
    UCHAR NumberFunctions;
    UCHAR FunctionInformation;
    ULONG CompressedId;
} CM_EISA_SLOT_INFORMATION, *PCM_EISA_SLOT_INFORMATION;


//
// Eisa function information definition
//

typedef struct _CM_EISA_FUNCTION_INFORMATION {
    ULONG CompressedId;
    UCHAR IdSlotFlags1;
    UCHAR IdSlotFlags2;
    UCHAR MinorRevision;
    UCHAR MajorRevision;
    UCHAR Selections[26];
    UCHAR FunctionFlags;
    UCHAR TypeString[80];
    EISA_MEMORY_CONFIGURATION EisaMemory[9];
    EISA_IRQ_CONFIGURATION EisaIrq[7];
    EISA_DMA_CONFIGURATION EisaDma[4];
    EISA_PORT_CONFIGURATION EisaPort[20];
    UCHAR InitializationData[60];
} CM_EISA_FUNCTION_INFORMATION, *PCM_EISA_FUNCTION_INFORMATION;

//
// The following defines the way pnp bios information is stored in
// the registry \\HKEY_LOCAL_MACHINE\HARDWARE\Description\System\MultifunctionAdapter\x
// key, where x is an integer number indicating adapter instance. The
// "Identifier" of the key must equal to "PNP BIOS" and the
// "ConfigurationData" is organized as follow:
//
//      CM_PNP_BIOS_INSTALLATION_CHECK        +
//      CM_PNP_BIOS_DEVICE_NODE for device 1  +
//      CM_PNP_BIOS_DEVICE_NODE for device 2  +
//                ...
//      CM_PNP_BIOS_DEVICE_NODE for device n
//

//
// Pnp BIOS device node structure
//

typedef struct _CM_PNP_BIOS_DEVICE_NODE {
    USHORT Size;
    UCHAR Node;
    ULONG ProductId;
    UCHAR DeviceType[3];
    USHORT DeviceAttributes;
    // followed by AllocatedResourceBlock, PossibleResourceBlock
    // and CompatibleDeviceId
} CM_PNP_BIOS_DEVICE_NODE,*PCM_PNP_BIOS_DEVICE_NODE;

//
// Pnp BIOS Installation check
//

typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK {
    UCHAR Signature[4];             // $PnP (ascii)
    UCHAR Revision;
    UCHAR Length;
    USHORT ControlField;
    UCHAR Checksum;
    ULONG EventFlagAddress;         // Physical address
    USHORT RealModeEntryOffset;
    USHORT RealModeEntrySegment;
    USHORT ProtectedModeEntryOffset;
    ULONG ProtectedModeCodeBaseAddress;
    ULONG OemDeviceId;
    USHORT RealModeDataBaseAddress;
    ULONG ProtectedModeDataBaseAddress;
} CM_PNP_BIOS_INSTALLATION_CHECK, *PCM_PNP_BIOS_INSTALLATION_CHECK;

#include "poppack.h"

//
// Masks for EISA function information
//

#define EISA_FUNCTION_ENABLED                   0x80
#define EISA_FREE_FORM_DATA                     0x40
#define EISA_HAS_PORT_INIT_ENTRY                0x20
#define EISA_HAS_PORT_RANGE                     0x10
#define EISA_HAS_DMA_ENTRY                      0x08
#define EISA_HAS_IRQ_ENTRY                      0x04
#define EISA_HAS_MEMORY_ENTRY                   0x02
#define EISA_HAS_TYPE_ENTRY                     0x01
#define EISA_HAS_INFORMATION                    EISA_HAS_PORT_RANGE + \
                                                EISA_HAS_DMA_ENTRY + \
                                                EISA_HAS_IRQ_ENTRY + \
                                                EISA_HAS_MEMORY_ENTRY + \
                                                EISA_HAS_TYPE_ENTRY

//
// Masks for EISA memory configuration
//

#define EISA_MORE_ENTRIES                       0x80
#define EISA_SYSTEM_MEMORY                      0x00
#define EISA_MEMORY_TYPE_RAM                    0x01

//
// Returned error code for EISA bios call
//

#define EISA_INVALID_SLOT                       0x80
#define EISA_INVALID_FUNCTION                   0x81
#define EISA_INVALID_CONFIGURATION              0x82
#define EISA_EMPTY_SLOT                         0x83
#define EISA_INVALID_BIOS_CALL                  0x86



//
// The following structures are used to interpret mips
// DeviceSpecificData of CM_PARTIAL_RESOURCE_DESCRIPTOR.
//

//
// Device data records for adapters.
//

//
// The device data record for the Emulex SCSI controller.
//

typedef struct _CM_SCSI_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    UCHAR HostIdentifier;
} CM_SCSI_DEVICE_DATA, *PCM_SCSI_DEVICE_DATA;

//
// Device data records for controllers.
//

//
// The device data record for the Video controller.
//

typedef struct _CM_VIDEO_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    ULONG VideoClock;
} CM_VIDEO_DEVICE_DATA, *PCM_VIDEO_DEVICE_DATA;

//
// The device data record for the SONIC network controller.
//

typedef struct _CM_SONIC_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    USHORT DataConfigurationRegister;
    UCHAR EthernetAddress[8];
} CM_SONIC_DEVICE_DATA, *PCM_SONIC_DEVICE_DATA;

//
// The device data record for the serial controller.
//

typedef struct _CM_SERIAL_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    ULONG BaudClock;
} CM_SERIAL_DEVICE_DATA, *PCM_SERIAL_DEVICE_DATA;

//
// Device data records for peripherals.
//

//
// The device data record for the Monitor peripheral.
//

typedef struct _CM_MONITOR_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    USHORT HorizontalScreenSize;
    USHORT VerticalScreenSize;
    USHORT HorizontalResolution;
    USHORT VerticalResolution;
    USHORT HorizontalDisplayTimeLow;
    USHORT HorizontalDisplayTime;
    USHORT HorizontalDisplayTimeHigh;
    USHORT HorizontalBackPorchLow;
    USHORT HorizontalBackPorch;
    USHORT HorizontalBackPorchHigh;
    USHORT HorizontalFrontPorchLow;
    USHORT HorizontalFrontPorch;
    USHORT HorizontalFrontPorchHigh;
    USHORT HorizontalSyncLow;
    USHORT HorizontalSync;
    USHORT HorizontalSyncHigh;
    USHORT VerticalBackPorchLow;
    USHORT VerticalBackPorch;
    USHORT VerticalBackPorchHigh;
    USHORT VerticalFrontPorchLow;
    USHORT VerticalFrontPorch;
    USHORT VerticalFrontPorchHigh;
    USHORT VerticalSyncLow;
    USHORT VerticalSync;
    USHORT VerticalSyncHigh;
} CM_MONITOR_DEVICE_DATA, *PCM_MONITOR_DEVICE_DATA;

//
// The device data record for the Floppy peripheral.
//

typedef struct _CM_FLOPPY_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    CHAR Size[8];
    ULONG MaxDensity;
    ULONG MountDensity;
    //
    // New data fields for version >= 2.0
    //
    UCHAR StepRateHeadUnloadTime;
    UCHAR HeadLoadTime;
    UCHAR MotorOffTime;
    UCHAR SectorLengthCode;
    UCHAR SectorPerTrack;
    UCHAR ReadWriteGapLength;
    UCHAR DataTransferLength;
    UCHAR FormatGapLength;
    UCHAR FormatFillCharacter;
    UCHAR HeadSettleTime;
    UCHAR MotorSettleTime;
    UCHAR MaximumTrackValue;
    UCHAR DataTransferRate;
} CM_FLOPPY_DEVICE_DATA, *PCM_FLOPPY_DEVICE_DATA;

//
// The device data record for the Keyboard peripheral.
// The KeyboardFlags is defined (by x86 BIOS INT 16h, function 02) as:
//      bit 7 : Insert on
//      bit 6 : Caps Lock on
//      bit 5 : Num Lock on
//      bit 4 : Scroll Lock on
//      bit 3 : Alt Key is down
//      bit 2 : Ctrl Key is down
//      bit 1 : Left shift key is down
//      bit 0 : Right shift key is down
//

typedef struct _CM_KEYBOARD_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    UCHAR Type;
    UCHAR Subtype;
    USHORT KeyboardFlags;
} CM_KEYBOARD_DEVICE_DATA, *PCM_KEYBOARD_DEVICE_DATA;

//
// Declaration of the structure for disk geometries
//

typedef struct _CM_DISK_GEOMETRY_DEVICE_DATA {
    ULONG BytesPerSector;
    ULONG NumberOfCylinders;
    ULONG SectorsPerTrack;
    ULONG NumberOfHeads;
} CM_DISK_GEOMETRY_DEVICE_DATA, *PCM_DISK_GEOMETRY_DEVICE_DATA;



//
// Defines Resource Options
//

#define IO_RESOURCE_PREFERRED       0x01
#define IO_RESOURCE_DEFAULT         0x02
#define IO_RESOURCE_ALTERNATIVE     0x08


//
// This structure defines one type of resource requested by the driver
//

typedef struct _IO_RESOURCE_DESCRIPTOR {
    UCHAR Option;
    UCHAR Type;                         // use CM_RESOURCE_TYPE
    UCHAR ShareDisposition;             // use CM_SHARE_DISPOSITION
    UCHAR Spare1;
    USHORT Flags;                       // use CM resource flag defines
    USHORT Spare2;                      // align

    union {
        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Port;

        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Memory;

        struct {
            ULONG MinimumVector;
            ULONG MaximumVector;
        } Interrupt;

        struct {
            ULONG MinimumChannel;
            ULONG MaximumChannel;
        } Dma;

        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Generic;

        struct {
            ULONG Data[3];
        } DevicePrivate;

        //
        // Bus Number information.
        //

        struct {
            ULONG Length;
            ULONG MinBusNumber;
            ULONG MaxBusNumber;
            ULONG Reserved;
        } BusNumber;


        struct {
            ULONG Priority;   // use LCPRI_Xxx values in cfg.h
            ULONG Reserved1;
            ULONG Reserved2;
        } ConfigData;

    } u;

} IO_RESOURCE_DESCRIPTOR, *PIO_RESOURCE_DESCRIPTOR;




typedef struct _IO_RESOURCE_LIST {
    USHORT Version;
    USHORT Revision;

    ULONG Count;
    IO_RESOURCE_DESCRIPTOR Descriptors[1];
} IO_RESOURCE_LIST, *PIO_RESOURCE_LIST;


typedef struct _IO_RESOURCE_REQUIREMENTS_LIST {
    ULONG ListSize;
    INTERFACE_TYPE DoNotUse1;
    ULONG DoNotUse2;
    ULONG DoNotUse3;
    ULONG Reserved[3];
    ULONG AlternativeLists;
    IO_RESOURCE_LIST  List[1];
} IO_RESOURCE_REQUIREMENTS_LIST, *PIO_RESOURCE_REQUIREMENTS_LIST;

//
// Exception flag definitions.
//


#define EXCEPTION_NONCONTINUABLE 0x1    // Noncontinuable exception


//
// Define maximum number of exception parameters.
//


#define EXCEPTION_MAXIMUM_PARAMETERS 15 // maximum number of exception parameters

//
// Exception record definition.
//

typedef struct _EXCEPTION_RECORD {
    NTSTATUS ExceptionCode;
    ULONG ExceptionFlags;
    struct _EXCEPTION_RECORD *ExceptionRecord;
    PVOID ExceptionAddress;
    ULONG NumberParameters;
    ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
    } EXCEPTION_RECORD;

typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;

typedef struct _EXCEPTION_RECORD32 {
    NTSTATUS ExceptionCode;
    ULONG ExceptionFlags;
    ULONG ExceptionRecord;
    ULONG ExceptionAddress;
    ULONG NumberParameters;
    ULONG ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD32, *PEXCEPTION_RECORD32;

typedef struct _EXCEPTION_RECORD64 {
    NTSTATUS ExceptionCode;
    ULONG ExceptionFlags;
    ULONG64 ExceptionRecord;
    ULONG64 ExceptionAddress;
    ULONG NumberParameters;
    ULONG __unusedAlignment;
    ULONG64 ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD64, *PEXCEPTION_RECORD64;

//
// Typedef for pointer returned by exception_info()
//

typedef struct _EXCEPTION_POINTERS {
    PEXCEPTION_RECORD ExceptionRecord;
    PVOID ContextRecord;
} EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;


#define THREAD_WAIT_OBJECTS 3           // Builtin usable wait blocks

//
// Interrupt modes.
//

typedef enum _KINTERRUPT_MODE {
    LevelSensitive,
    Latched
    } KINTERRUPT_MODE;

//
// Wait reasons
//

typedef enum _KWAIT_REASON {
    Executive,
    FreePage,
    PageIn,
    PoolAllocation,
    DelayExecution,
    Suspended,
    UserRequest,
    WrExecutive,
    WrFreePage,
    WrPageIn,
    WrPoolAllocation,
    WrDelayExecution,
    WrSuspended,
    WrUserRequest,
    WrEventPair,
    WrQueue,
    WrLpcReceive,
    WrLpcReply,
    WrVirtualMemory,
    WrPageOut,
    WrRendezvous,
    Spare2,
    Spare3,
    Spare4,
    Spare5,
    Spare6,
    WrKernel,
    MaximumWaitReason
    } KWAIT_REASON;

//
// Common dispatcher object header
//
// N.B. The size field contains the number of dwords in the structure.
//

typedef struct _DISPATCHER_HEADER {
    UCHAR Type;
    UCHAR Absolute;
    UCHAR Size;
    UCHAR Inserted;
    LONG SignalState;
    LIST_ENTRY WaitListHead;
} DISPATCHER_HEADER;


typedef struct _KWAIT_BLOCK {
    LIST_ENTRY WaitListEntry;
    struct _KTHREAD *RESTRICTED_POINTER Thread;
    PVOID Object;
    struct _KWAIT_BLOCK *RESTRICTED_POINTER NextWaitBlock;
    USHORT WaitKey;
    USHORT WaitType;
} KWAIT_BLOCK, *PKWAIT_BLOCK, *RESTRICTED_POINTER PRKWAIT_BLOCK;

//
// Thread start function
//

typedef
VOID
(*PKSTART_ROUTINE) (
    IN PVOID StartContext
    );

//
// Kernel object structure definitions
//

//
// Device Queue object and entry
//

typedef struct _KDEVICE_QUEUE {
    CSHORT Type;
    CSHORT Size;
    LIST_ENTRY DeviceListHead;
    KSPIN_LOCK Lock;
    BOOLEAN Busy;
} KDEVICE_QUEUE, *PKDEVICE_QUEUE, *RESTRICTED_POINTER PRKDEVICE_QUEUE;

typedef struct _KDEVICE_QUEUE_ENTRY {
    LIST_ENTRY DeviceListEntry;
    ULONG SortKey;
    BOOLEAN Inserted;
} KDEVICE_QUEUE_ENTRY, *PKDEVICE_QUEUE_ENTRY, *RESTRICTED_POINTER PRKDEVICE_QUEUE_ENTRY;


//
// Event object
//

typedef struct _KEVENT {
    DISPATCHER_HEADER Header;
} KEVENT, *PKEVENT, *RESTRICTED_POINTER PRKEVENT;

//
// Define the interrupt service function type and the empty struct
// type.
//
typedef
BOOLEAN
(*PKSERVICE_ROUTINE) (
    IN struct _KINTERRUPT *Interrupt,
    IN PVOID ServiceContext
    );
//
// Mutant object
//

typedef struct _KMUTANT {
    DISPATCHER_HEADER Header;
    LIST_ENTRY MutantListEntry;
    struct _KTHREAD *RESTRICTED_POINTER OwnerThread;
    BOOLEAN Abandoned;
    UCHAR ApcDisable;
} KMUTANT, *PKMUTANT, *RESTRICTED_POINTER PRKMUTANT, KMUTEX, *PKMUTEX, *RESTRICTED_POINTER PRKMUTEX;

//
//
// Semaphore object
//

typedef struct _KSEMAPHORE {
    DISPATCHER_HEADER Header;
    LONG Limit;
} KSEMAPHORE, *PKSEMAPHORE, *RESTRICTED_POINTER PRKSEMAPHORE;


//
// Timer object
//

typedef struct _KTIMER {
    DISPATCHER_HEADER Header;
    ULARGE_INTEGER DueTime;
    LIST_ENTRY TimerListEntry;
    struct _KDPC *Dpc;
    LONG Period;
} KTIMER, *PKTIMER, *RESTRICTED_POINTER PRKTIMER;

//
// DPC object
//

NTKERNELAPI
VOID
KeInitializeDpc (
    IN PRKDPC Dpc,
    IN PKDEFERRED_ROUTINE DeferredRoutine,
    IN PVOID DeferredContext
    );

NTKERNELAPI
BOOLEAN
KeInsertQueueDpc (
    IN PRKDPC Dpc,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

NTKERNELAPI
BOOLEAN
KeRemoveQueueDpc (
    IN PRKDPC Dpc
    );

//
// Device queue object
//

NTKERNELAPI
VOID
KeInitializeDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue
    );

NTKERNELAPI
BOOLEAN
KeInsertDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry
    );

NTKERNELAPI
BOOLEAN
KeInsertByKeyDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry,
    IN ULONG SortKey
    );

NTKERNELAPI
PKDEVICE_QUEUE_ENTRY
KeRemoveDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue
    );

NTKERNELAPI
PKDEVICE_QUEUE_ENTRY
KeRemoveByKeyDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN ULONG SortKey
    );

NTKERNELAPI
BOOLEAN
KeRemoveEntryDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry
    );

NTKERNELAPI                                         
BOOLEAN                                             
KeSynchronizeExecution (                            
    IN PKINTERRUPT Interrupt,                       
    IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,    
    IN PVOID SynchronizeContext                     
    );                                              
                                                    
//
// Kernel dispatcher object functions
//
// Event Object
//


NTKERNELAPI
VOID
KeInitializeEvent (
    IN PRKEVENT Event,
    IN EVENT_TYPE Type,
    IN BOOLEAN State
    );

NTKERNELAPI
VOID
KeClearEvent (
    IN PRKEVENT Event
    );


NTKERNELAPI
LONG
KeResetEvent (
    IN PRKEVENT Event
    );

NTKERNELAPI
LONG
KeSetEvent (
    IN PRKEVENT Event,
    IN KPRIORITY Increment,
    IN BOOLEAN Wait
    );

//
// Mutex object
//

NTKERNELAPI
VOID
KeInitializeMutex (
    IN PRKMUTEX Mutex,
    IN ULONG Level
    );

#define KeReadStateMutex(Mutex) KeReadStateMutant(Mutex)

NTKERNELAPI
LONG
KeReleaseMutex (
    IN PRKMUTEX Mutex,
    IN BOOLEAN Wait
    );

//
// Semaphore object
//

NTKERNELAPI
VOID
KeInitializeSemaphore (
    IN PRKSEMAPHORE Semaphore,
    IN LONG Count,
    IN LONG Limit
    );

NTKERNELAPI
LONG
KeReadStateSemaphore (
    IN PRKSEMAPHORE Semaphore
    );

NTKERNELAPI
LONG
KeReleaseSemaphore (
    IN PRKSEMAPHORE Semaphore,
    IN KPRIORITY Increment,
    IN LONG Adjustment,
    IN BOOLEAN Wait
    );

NTKERNELAPI                                         
NTSTATUS                                            
KeDelayExecutionThread (                            
    IN KPROCESSOR_MODE WaitMode,                    
    IN BOOLEAN Alertable,                           
    IN PLARGE_INTEGER Interval                      
    );                                              
                                                    
NTKERNELAPI                                         
KPRIORITY                                           
KeQueryPriorityThread (                             
    IN PKTHREAD Thread                              
    );                                              
                                                    
NTKERNELAPI                                         
KPRIORITY                                           
KeSetPriorityThread (                               
    IN PKTHREAD Thread,                             
    IN KPRIORITY Priority                           
    );                                              
                                                    

NTKERNELAPI
VOID
KeEnterCriticalRegion (
    VOID
    );

NTKERNELAPI
VOID
KeLeaveCriticalRegion (
    VOID
    );


//
// Timer object
//

NTKERNELAPI
VOID
KeInitializeTimer (
    IN PKTIMER Timer
    );

NTKERNELAPI
VOID
KeInitializeTimerEx (
    IN PKTIMER Timer,
    IN TIMER_TYPE Type
    );

NTKERNELAPI
BOOLEAN
KeCancelTimer (
    IN PKTIMER
    );

NTKERNELAPI
BOOLEAN
KeReadStateTimer (
    PKTIMER Timer
    );

NTKERNELAPI
BOOLEAN
KeSetTimer (
    IN PKTIMER Timer,
    IN LARGE_INTEGER DueTime,
    IN PKDPC Dpc OPTIONAL
    );

NTKERNELAPI
BOOLEAN
KeSetTimerEx (
    IN PKTIMER Timer,
    IN LARGE_INTEGER DueTime,
    IN LONG Period OPTIONAL,
    IN PKDPC Dpc OPTIONAL
    );


#define KeWaitForMutexObject KeWaitForSingleObject

NTKERNELAPI
NTSTATUS
KeWaitForMultipleObjects (
    IN ULONG Count,
    IN PVOID Object[],
    IN WAIT_TYPE WaitType,
    IN KWAIT_REASON WaitReason,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL,
    IN PKWAIT_BLOCK WaitBlockArray OPTIONAL
    );

NTKERNELAPI
NTSTATUS
KeWaitForSingleObject (
    IN PVOID Object,
    IN KWAIT_REASON WaitReason,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );


//
// On X86 the following routines are defined in the HAL and imported by
// all other modules.
//

#if defined(_X86_) && !defined(_NTHAL_)

#define _DECL_HAL_KE_IMPORT  __declspec(dllimport)

#else

#define _DECL_HAL_KE_IMPORT

#endif

//
// spin lock functions
//

NTKERNELAPI
VOID
NTAPI
KeInitializeSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

#if defined(_X86_)

NTKERNELAPI
VOID
FASTCALL
KefAcquireSpinLockAtDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

NTKERNELAPI
VOID
FASTCALL
KefReleaseSpinLockFromDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

#define KeAcquireSpinLockAtDpcLevel(a)      KefAcquireSpinLockAtDpcLevel(a)
#define KeReleaseSpinLockFromDpcLevel(a)    KefReleaseSpinLockFromDpcLevel(a)

_DECL_HAL_KE_IMPORT
KIRQL
FASTCALL
KfAcquireSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

_DECL_HAL_KE_IMPORT
VOID
FASTCALL
KfReleaseSpinLock (
    IN PKSPIN_LOCK SpinLock,
    IN KIRQL NewIrql
    );


#define KeAcquireSpinLock(a,b)  *(b) = KfAcquireSpinLock(a)
#define KeReleaseSpinLock(a,b)  KfReleaseSpinLock(a,b)

#else

NTKERNELAPI
KIRQL
FASTCALL
KeAcquireSpinLockRaiseToSynch (
    IN PKSPIN_LOCK SpinLock
    );

NTKERNELAPI
VOID
KeAcquireSpinLockAtDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

NTKERNELAPI
VOID
KeReleaseSpinLockFromDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

NTKERNELAPI
KIRQL
KeAcquireSpinLockRaiseToDpc (
    IN PKSPIN_LOCK SpinLock
    );

#define KeAcquireSpinLock(SpinLock, OldIrql) \
    *(OldIrql) = KeAcquireSpinLockRaiseToDpc(SpinLock)

NTKERNELAPI
VOID
KeReleaseSpinLock (
    IN PKSPIN_LOCK SpinLock,
    IN KIRQL NewIrql
    );

#endif


#if defined(_X86_)

_DECL_HAL_KE_IMPORT
VOID
FASTCALL
KfLowerIrql (
    IN KIRQL NewIrql
    );

_DECL_HAL_KE_IMPORT
KIRQL
FASTCALL
KfRaiseIrql (
    IN KIRQL NewIrql
    );


#define KeLowerIrql(a)      KfLowerIrql(a)
#define KeRaiseIrql(a,b)    *(b) = KfRaiseIrql(a)


#elif defined(_ALPHA_)

#define KeLowerIrql(a)      __swpirql(a)
#define KeRaiseIrql(a,b)    *(b) = __swpirql(a)


#elif defined(_IA64_)

VOID
KeLowerIrql (
    IN KIRQL NewIrql
    );

VOID
KeRaiseIrql (
    IN KIRQL NewIrql,
    OUT PKIRQL OldIrql
    );


#endif

//
// Miscellaneous kernel functions
//


NTKERNELAPI
DECLSPEC_NORETURN
VOID
KeBugCheckEx(
    IN ULONG BugCheckCode,
    IN ULONG_PTR BugCheckParameter1,
    IN ULONG_PTR BugCheckParameter2,
    IN ULONG_PTR BugCheckParameter3,
    IN ULONG_PTR BugCheckParameter4
    );


NTKERNELAPI
ULONGLONG
KeQueryInterruptTime (
    VOID
    );

NTKERNELAPI
VOID
KeQuerySystemTime (
    OUT PLARGE_INTEGER CurrentTime
    );

NTKERNELAPI
ULONG
KeQueryTimeIncrement (
    VOID
    );

extern volatile KSYSTEM_TIME KeTickCount;           

typedef enum _MEMORY_CACHING_TYPE_ORIG {
    MmFrameBufferCached = 2
} MEMORY_CACHING_TYPE_ORIG;

typedef enum _MEMORY_CACHING_TYPE {
    MmNonCached = FALSE,
    MmCached = TRUE,
    MmWriteCombined = MmFrameBufferCached,
    MmHardwareCoherentCached,
    MmCachingTypeDoNotUse1,
    MmCachingTypeDoNotUse2,
    MmMaximumCacheType
} MEMORY_CACHING_TYPE;

//
// Define external data.
// because of indirection for all drivers external to ntoskrnl these are actually ptrs
//

#if defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_WDMDDK_)

extern PBOOLEAN KdDebuggerNotPresent;
extern PBOOLEAN KdDebuggerEnabled;

#else

extern BOOLEAN KdDebuggerNotPresent;
extern BOOLEAN KdDebuggerEnabled;

#endif



//
// Pool Allocation routines (in pool.c)
//

typedef enum _POOL_TYPE {
    NonPagedPool,
    PagedPool,
    NonPagedPoolMustSucceed,
    DontUseThisType,
    NonPagedPoolCacheAligned,
    PagedPoolCacheAligned,
    NonPagedPoolCacheAlignedMustS,
    MaxPoolType


    } POOL_TYPE;


NTKERNELAPI
PVOID
ExAllocatePool(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes
    );

NTKERNELAPI
PVOID
ExAllocatePoolWithQuota(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes
    );

NTKERNELAPI
PVOID
NTAPI
ExAllocatePoolWithTag(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );


#ifndef POOL_TAGGING
#define ExAllocatePoolWithTag(a,b,c) ExAllocatePool(a,b)
#endif //POOL_TAGGING

NTKERNELAPI
PVOID
ExAllocatePoolWithQuotaTag(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

#ifndef POOL_TAGGING
#define ExAllocatePoolWithQuotaTag(a,b,c) ExAllocatePoolWithQuota(a,b)
#endif //POOL_TAGGING

NTKERNELAPI
VOID
NTAPI
ExFreePool(
    IN PVOID P
    );

//
// Routines to support fast mutexes.
//

typedef struct _FAST_MUTEX {
    LONG Count;
    PKTHREAD Owner;
    ULONG Contention;
    KEVENT Event;
    ULONG OldIrql;
} FAST_MUTEX, *PFAST_MUTEX;

#if DBG
#define ExInitializeFastMutex(_FastMutex)                            \
    (_FastMutex)->Count = 1;                                         \
    (_FastMutex)->Owner = NULL;                                      \
    (_FastMutex)->Contention = 0;                                    \
    KeInitializeEvent(&(_FastMutex)->Event,                          \
                      SynchronizationEvent,                          \
                      FALSE);
#else
#define ExInitializeFastMutex(_FastMutex)                            \
    (_FastMutex)->Count = 1;                                         \
    (_FastMutex)->Contention = 0;                                    \
    KeInitializeEvent(&(_FastMutex)->Event,                          \
                      SynchronizationEvent,                          \
                      FALSE);
#endif // DBG

NTKERNELAPI
VOID
FASTCALL
ExAcquireFastMutexUnsafe (
    IN PFAST_MUTEX FastMutex
    );

NTKERNELAPI
VOID
FASTCALL
ExReleaseFastMutexUnsafe (
    IN PFAST_MUTEX FastMutex
    );

#if defined(_ALPHA_) || defined(_IA64_)

NTKERNELAPI
VOID
FASTCALL
ExAcquireFastMutex (
    IN PFAST_MUTEX FastMutex
    );

NTKERNELAPI
VOID
FASTCALL
ExReleaseFastMutex (
    IN PFAST_MUTEX FastMutex
    );


#elif defined(_X86_)

NTHALAPI
VOID
FASTCALL
ExAcquireFastMutex (
    IN PFAST_MUTEX FastMutex
    );

NTHALAPI
VOID
FASTCALL
ExReleaseFastMutex (
    IN PFAST_MUTEX FastMutex
    );


#else

#error "Target architecture not defined"

#endif

//

NTKERNELAPI
VOID
FASTCALL
ExInterlockedAddLargeStatistic (
    IN PLARGE_INTEGER Addend,
    IN ULONG Increment
    );



NTKERNELAPI
LARGE_INTEGER
ExInterlockedAddLargeInteger (
    IN PLARGE_INTEGER Addend,
    IN LARGE_INTEGER Increment,
    IN PKSPIN_LOCK Lock
    );


NTKERNELAPI
ULONG
FASTCALL
ExInterlockedAddUlong (
    IN PULONG Addend,
    IN ULONG Increment,
    IN PKSPIN_LOCK Lock
    );


#if defined(_AXP64_)

#define ExInterlockedCompareExchange64(Destination, Exchange, Comperand, Lock) \
    InterlockedCompareExchange64(Destination, *(Exchange), *(Comperand))

#elif defined(_ALPHA_)

#define ExInterlockedCompareExchange64(Destination, Exchange, Comperand, Lock) \
    ExpInterlockedCompareExchange64(Destination, Exchange, Comperand)

#elif defined(_IA64_)

#define ExInterlockedCompareExchange64(Destination, Exchange, Comperand, Lock) \
    InterlockedCompareExchange64(Destination, *(Exchange), *(Comperand))

#else

NTKERNELAPI
LONGLONG
FASTCALL
ExInterlockedCompareExchange64 (
    IN PLONGLONG Destination,
    IN PLONGLONG Exchange,
    IN PLONGLONG Comperand,
    IN PKSPIN_LOCK Lock
    );

#endif

NTKERNELAPI
PLIST_ENTRY
FASTCALL
ExInterlockedInsertHeadList (
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY ListEntry,
    IN PKSPIN_LOCK Lock
    );

NTKERNELAPI
PLIST_ENTRY
FASTCALL
ExInterlockedInsertTailList (
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY ListEntry,
    IN PKSPIN_LOCK Lock
    );

NTKERNELAPI
PLIST_ENTRY
FASTCALL
ExInterlockedRemoveHeadList (
    IN PLIST_ENTRY ListHead,
    IN PKSPIN_LOCK Lock
    );

NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
ExInterlockedPopEntryList (
    IN PSINGLE_LIST_ENTRY ListHead,
    IN PKSPIN_LOCK Lock
    );

NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
ExInterlockedPushEntryList (
    IN PSINGLE_LIST_ENTRY ListHead,
    IN PSINGLE_LIST_ENTRY ListEntry,
    IN PKSPIN_LOCK Lock
    );



//
// Define interlocked sequenced listhead functions.
//
// A sequenced interlocked list is a singly linked list with a header that
// contains the current depth and a sequence number. Each time an entry is
// inserted or removed from the list the depth is updated and the sequence
// number is incremented. This enables MIPS, Alpha, and Pentium and later
// machines to insert and remove from the list without the use of spinlocks.
// The PowerPc, however, must use a spinlock to synchronize access to the
// list.
//
// N.B. A spinlock must be specified with SLIST operations. However, it may
//      not actually be used.
//

/*++

VOID
ExInitializeSListHead (
    IN PSLIST_HEADER SListHead
    )

Routine Description:

    This function initializes a sequenced singly linked listhead.

Arguments:

    SListHead - Supplies a pointer to a sequenced singly linked listhead.

Return Value:

    None.

--*/

#define ExInitializeSListHead(_listhead_) (_listhead_)->Alignment = 0

/*++

USHORT
ExQueryDepthSList (
    IN PSLIST_HEADERT SListHead
    )

Routine Description:

    This function queries the current number of entries contained in a
    sequenced single linked list.

Arguments:

    SListHead - Supplies a pointer to the sequenced listhead which is
        be queried.

Return Value:

    The current number of entries in the sequenced singly linked list is
    returned as the function value.

--*/

#define ExQueryDepthSList(_listhead_) (USHORT)(_listhead_)->Depth

#if defined(_MIPS_) || defined(_ALPHA_) || defined(_IA64_)

#define ExInterlockedPopEntrySList(Head, Lock) \
    ExpInterlockedPopEntrySList(Head)

#define ExInterlockedPushEntrySList(Head, Entry, Lock) \
    ExpInterlockedPushEntrySList(Head, Entry)

#define ExInterlockedFlushSList(Head) \
    ExpInterlockedFlushSList(Head)

NTKERNELAPI
PSINGLE_LIST_ENTRY
ExpInterlockedPopEntrySList (
    IN PSLIST_HEADER ListHead
    );

NTKERNELAPI
PSINGLE_LIST_ENTRY
ExpInterlockedPushEntrySList (
    IN PSLIST_HEADER ListHead,
    IN PSINGLE_LIST_ENTRY ListEntry
    );

NTKERNELAPI
PSINGLE_LIST_ENTRY
ExpInterlockedFlushSList (
    IN PSLIST_HEADER ListHead
    );

#else

NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
ExInterlockedPopEntrySList (
    IN PSLIST_HEADER ListHead,
    IN PKSPIN_LOCK Lock
    );

NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
ExInterlockedPushEntrySList (
    IN PSLIST_HEADER ListHead,
    IN PSINGLE_LIST_ENTRY ListEntry,
    IN PKSPIN_LOCK Lock
    );

NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
ExInterlockedFlushSList (
    IN PSLIST_HEADER ListHead
    );

#endif


typedef
PVOID
(*PALLOCATE_FUNCTION) (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

typedef
VOID
(*PFREE_FUNCTION) (
    IN PVOID Buffer
    );

typedef struct _GENERAL_LOOKASIDE {
    SLIST_HEADER ListHead;
    USHORT Depth;
    USHORT MaximumDepth;
    ULONG TotalAllocates;
    union {
        ULONG AllocateMisses;
        ULONG AllocateHits;
    };

    ULONG TotalFrees;
    union {
        ULONG FreeMisses;
        ULONG FreeHits;
    };

    POOL_TYPE Type;
    ULONG Tag;
    ULONG Size;
    PALLOCATE_FUNCTION Allocate;
    PFREE_FUNCTION Free;
    LIST_ENTRY ListEntry;
    ULONG LastTotalAllocates;
    union {
        ULONG LastAllocateMisses;
        ULONG LastAllocateHits;
    };

    ULONG Future[2];
} GENERAL_LOOKASIDE, *PGENERAL_LOOKASIDE;

typedef struct _NPAGED_LOOKASIDE_LIST {
    GENERAL_LOOKASIDE L;
    KSPIN_LOCK Lock;
} NPAGED_LOOKASIDE_LIST, *PNPAGED_LOOKASIDE_LIST;


NTKERNELAPI
VOID
ExInitializeNPagedLookasideList (
    IN PNPAGED_LOOKASIDE_LIST Lookaside,
    IN PALLOCATE_FUNCTION Allocate,
    IN PFREE_FUNCTION Free,
    IN ULONG Flags,
    IN SIZE_T Size,
    IN ULONG Tag,
    IN USHORT Depth
    );

NTKERNELAPI
VOID
ExDeleteNPagedLookasideList (
    IN PNPAGED_LOOKASIDE_LIST Lookaside
    );

__inline
PVOID
ExAllocateFromNPagedLookasideList(
    IN PNPAGED_LOOKASIDE_LIST Lookaside
    )

/*++

Routine Description:

    This function removes (pops) the first entry from the specified
    nonpaged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a nonpaged lookaside list structure.

Return Value:

    If an entry is removed from the specified lookaside list, then the
    address of the entry is returned as the function value. Otherwise,
    NULL is returned.

--*/

{

    PVOID Entry;

    Lookaside->L.TotalAllocates += 1;
    Entry = ExInterlockedPopEntrySList(&Lookaside->L.ListHead, &Lookaside->Lock);
    if (Entry == NULL) {
        Lookaside->L.AllocateMisses += 1;
        Entry = (Lookaside->L.Allocate)(Lookaside->L.Type,
                                        Lookaside->L.Size,
                                        Lookaside->L.Tag);
    }

    return Entry;
}

__inline
VOID
ExFreeToNPagedLookasideList(
    IN PNPAGED_LOOKASIDE_LIST Lookaside,
    IN PVOID Entry
    )

/*++

Routine Description:

    This function inserts (pushes) the specified entry into the specified
    nonpaged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a nonpaged lookaside list structure.

    Entry - Supples a pointer to the entry that is inserted in the
        lookaside list.

Return Value:

    None.

--*/

{

    Lookaside->L.TotalFrees += 1;
    if (ExQueryDepthSList(&Lookaside->L.ListHead) >= Lookaside->L.Depth) {
        Lookaside->L.FreeMisses += 1;
        (Lookaside->L.Free)(Entry);

    } else {
        ExInterlockedPushEntrySList(&Lookaside->L.ListHead,
                                    (PSINGLE_LIST_ENTRY)Entry,
                                    &Lookaside->Lock);
    }

    return;
}



typedef struct _PAGED_LOOKASIDE_LIST {
    GENERAL_LOOKASIDE L;
    FAST_MUTEX Lock;
} PAGED_LOOKASIDE_LIST, *PPAGED_LOOKASIDE_LIST;

NTKERNELAPI
VOID
ExInitializePagedLookasideList (
    IN PPAGED_LOOKASIDE_LIST Lookaside,
    IN PALLOCATE_FUNCTION Allocate,
    IN PFREE_FUNCTION Free,
    IN ULONG Flags,
    IN SIZE_T Size,
    IN ULONG Tag,
    IN USHORT Depth
    );

NTKERNELAPI
VOID
ExDeletePagedLookasideList (
    IN PPAGED_LOOKASIDE_LIST Lookaside
    );

#if defined(_X86_)

NTKERNELAPI
PVOID
ExAllocateFromPagedLookasideList(
    IN PPAGED_LOOKASIDE_LIST Lookaside
    );

NTKERNELAPI
VOID
ExFreeToPagedLookasideList(
    IN PPAGED_LOOKASIDE_LIST Lookaside,
    IN PVOID Entry
    );

#else

__inline
PVOID
ExAllocateFromPagedLookasideList(
    IN PPAGED_LOOKASIDE_LIST Lookaside
    )

/*++

Routine Description:

    This function removes (pops) the first entry from the specified
    paged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a paged lookaside list structure.

Return Value:

    If an entry is removed from the specified lookaside list, then the
    address of the entry is returned as the function value. Otherwise,
    NULL is returned.

--*/

{

    PVOID Entry;

    Lookaside->L.TotalAllocates += 1;
    Entry = ExInterlockedPopEntrySList(&Lookaside->L.ListHead, NULL);
    if (Entry == NULL) {
        Lookaside->L.AllocateMisses += 1;
        Entry = (Lookaside->L.Allocate)(Lookaside->L.Type,
                                        Lookaside->L.Size,
                                        Lookaside->L.Tag);
    }

    return Entry;
}

__inline
VOID
ExFreeToPagedLookasideList(
    IN PPAGED_LOOKASIDE_LIST Lookaside,
    IN PVOID Entry
    )

/*++

Routine Description:

    This function inserts (pushes) the specified entry into the specified
    paged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a nonpaged lookaside list structure.

    Entry - Supples a pointer to the entry that is inserted in the
        lookaside list.

Return Value:

    None.

--*/

{

    Lookaside->L.TotalFrees += 1;
    if (ExQueryDepthSList(&Lookaside->L.ListHead) >= Lookaside->L.Depth) {
        Lookaside->L.FreeMisses += 1;
        (Lookaside->L.Free)(Entry);

    } else {
        ExInterlockedPushEntrySList(&Lookaside->L.ListHead,
                                    (PSINGLE_LIST_ENTRY)Entry,
                                    NULL);
    }

    return;
}

#endif


NTKERNELAPI
VOID
NTAPI
ProbeForRead(
    IN CONST VOID *Address,
    IN ULONG Length,
    IN ULONG Alignment
    );

//
// Common probe for write functions.
//

NTKERNELAPI
VOID
NTAPI
ProbeForWrite (
    IN PVOID Address,
    IN ULONG Length,
    IN ULONG Alignment
    );

//
// Worker Thread
//

typedef enum _WORK_QUEUE_TYPE {
    CriticalWorkQueue,
    DelayedWorkQueue,
    HyperCriticalWorkQueue,
    MaximumWorkQueue
} WORK_QUEUE_TYPE;

typedef
VOID
(*PWORKER_THREAD_ROUTINE)(
    IN PVOID Parameter
    );

typedef struct _WORK_QUEUE_ITEM {
    LIST_ENTRY List;
    PWORKER_THREAD_ROUTINE WorkerRoutine;
    PVOID Parameter;
} WORK_QUEUE_ITEM, *PWORK_QUEUE_ITEM;


#define ExInitializeWorkItem(Item, Routine, Context) \
    (Item)->WorkerRoutine = (Routine);               \
    (Item)->Parameter = (Context);                   \
    (Item)->List.Flink = NULL;

NTKERNELAPI
VOID
ExQueueWorkItem(
    IN PWORK_QUEUE_ITEM WorkItem,
    IN WORK_QUEUE_TYPE QueueType
    );

//
// Get previous mode
//

NTKERNELAPI
KPROCESSOR_MODE
ExGetPreviousMode(
    VOID
    );
//
// Raise status from kernel mode.
//

NTKERNELAPI
VOID
NTAPI
ExRaiseStatus (
    IN NTSTATUS Status
    );

//
// Set timer resolution.
//

NTKERNELAPI
ULONG
ExSetTimerResolution (
    IN ULONG DesiredTime,
    IN BOOLEAN SetResolution
    );


//
// Define the type for Callback function.
//

typedef struct _CALLBACK_OBJECT *PCALLBACK_OBJECT;

typedef VOID (*PCALLBACK_FUNCTION ) (
    IN PVOID CallbackContext,
    IN PVOID Argument1,
    IN PVOID Argument2
    );


NTKERNELAPI
NTSTATUS
ExCreateCallback (
    OUT PCALLBACK_OBJECT *CallbackObject,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN BOOLEAN Create,
    IN BOOLEAN AllowMultipleCallbacks
    );

NTKERNELAPI
PVOID
ExRegisterCallback (
    IN PCALLBACK_OBJECT CallbackObject,
    IN PCALLBACK_FUNCTION CallbackFunction,
    IN PVOID CallbackContext
    );

NTKERNELAPI
VOID
ExUnregisterCallback (
    IN PVOID CallbackRegistration
    );

NTKERNELAPI
VOID
ExNotifyCallback (
    IN PVOID CallbackObject,
    IN PVOID Argument1,
    IN PVOID Argument2
    );

//
// Priority increment definitions.  The comment for each definition gives
// the names of the system services that use the definition when satisfying
// a wait.
//

//
// Priority increment used when satisfying a wait on an executive event
// (NtPulseEvent and NtSetEvent)
//

#define EVENT_INCREMENT                 1

//
// Priority increment when no I/O has been done.  This is used by device
// and file system drivers when completing an IRP (IoCompleteRequest).
//

#define IO_NO_INCREMENT                 0

//
// Priority increment for completing CD-ROM I/O.  This is used by CD-ROM device
// and file system drivers when completing an IRP (IoCompleteRequest)
//

#define IO_CD_ROM_INCREMENT             1

//
// Priority increment for completing disk I/O.  This is used by disk device
// and file system drivers when completing an IRP (IoCompleteRequest)
//

#define IO_DISK_INCREMENT               1


//
// Priority increment for completing keyboard I/O.  This is used by keyboard
// device drivers when completing an IRP (IoCompleteRequest)
//

#define IO_KEYBOARD_INCREMENT           6


//
// Priority increment for completing mailslot I/O.  This is used by the mail-
// slot file system driver when completing an IRP (IoCompleteRequest).
//

#define IO_MAILSLOT_INCREMENT           2


//
// Priority increment for completing mouse I/O.  This is used by mouse device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_MOUSE_INCREMENT              6


//
// Priority increment for completing named pipe I/O.  This is used by the
// named pipe file system driver when completing an IRP (IoCompleteRequest).
//

#define IO_NAMED_PIPE_INCREMENT         2

//
// Priority increment for completing network I/O.  This is used by network
// device and network file system drivers when completing an IRP
// (IoCompleteRequest).
//

#define IO_NETWORK_INCREMENT            2


//
// Priority increment for completing parallel I/O.  This is used by parallel
// device drivers when completing an IRP (IoCompleteRequest)
//

#define IO_PARALLEL_INCREMENT           1

//
// Priority increment for completing serial I/O.  This is used by serial device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_SERIAL_INCREMENT             2

//
// Priority increment for completing sound I/O.  This is used by sound device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_SOUND_INCREMENT              8

//
// Priority increment for completing video I/O.  This is used by video device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_VIDEO_INCREMENT              1

//
// Priority increment used when satisfying a wait on an executive semaphore
// (NtReleaseSemaphore)
//

#define SEMAPHORE_INCREMENT             1

//
//  Indicates the system may do I/O to physical addresses above 4 GB.
//

extern PBOOLEAN Mm64BitPhysicalAddress;


//
// Define maximum disk transfer size to be used by MM and Cache Manager,
// so that packet-oriented disk drivers can optimize their packet allocation
// to this size.
//

#define MM_MAXIMUM_DISK_IO_SIZE          (0x10000)

//++
//
// ULONG_PTR
// ROUND_TO_PAGES (
//     IN ULONG_PTR Size
//     )
//
// Routine Description:
//
//     The ROUND_TO_PAGES macro takes a size in bytes and rounds it up to a
//     multiple of the page size.
//
//     NOTE: This macro fails for values 0xFFFFFFFF - (PAGE_SIZE - 1).
//
// Arguments:
//
//     Size - Size in bytes to round up to a page multiple.
//
// Return Value:
//
//     Returns the size rounded up to a multiple of the page size.
//
//--

#define ROUND_TO_PAGES(Size)  (((ULONG_PTR)(Size) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1))

//++
//
// ULONG
// BYTES_TO_PAGES (
//     IN ULONG Size
//     )
//
// Routine Description:
//
//     The BYTES_TO_PAGES macro takes the size in bytes and calculates the
//     number of pages required to contain the bytes.
//
// Arguments:
//
//     Size - Size in bytes.
//
// Return Value:
//
//     Returns the number of pages required to contain the specified size.
//
//--

#define BYTES_TO_PAGES(Size)  ((ULONG)((ULONG_PTR)(Size) >> PAGE_SHIFT) + \
                               (((ULONG)(Size) & (PAGE_SIZE - 1)) != 0))

//++
//
// ULONG
// BYTE_OFFSET (
//     IN PVOID Va
//     )
//
// Routine Description:
//
//     The BYTE_OFFSET macro takes a virtual address and returns the byte offset
//     of that address within the page.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns the byte offset portion of the virtual address.
//
//--

#define BYTE_OFFSET(Va) ((ULONG)((LONG_PTR)(Va) & (PAGE_SIZE - 1)))

//++
//
// PVOID
// PAGE_ALIGN (
//     IN PVOID Va
//     )
//
// Routine Description:
//
//     The PAGE_ALIGN macro takes a virtual address and returns a page-aligned
//     virtual address for that page.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns the page aligned virtual address.
//
//--

#define PAGE_ALIGN(Va) ((PVOID)((ULONG_PTR)(Va) & ~(PAGE_SIZE - 1)))

//++
//
// ULONG
// ADDRESS_AND_SIZE_TO_SPAN_PAGES (
//     IN PVOID Va,
//     IN ULONG Size
//     )
//
// Routine Description:
//
//     The ADDRESS_AND_SIZE_TO_SPAN_PAGES macro takes a virtual address and
//     size and returns the number of pages spanned by the size.
//
// Arguments:
//
//     Va - Virtual address.
//
//     Size - Size in bytes.
//
// Return Value:
//
//     Returns the number of pages spanned by the size.
//
//--

#define ADDRESS_AND_SIZE_TO_SPAN_PAGES(Va,Size) \
   (((((Size) - 1) >> PAGE_SHIFT) + \
   (((((ULONG)(Size-1)&(PAGE_SIZE-1)) + (PtrToUlong(Va) & (PAGE_SIZE -1)))) >> PAGE_SHIFT)) + 1L)

#define COMPUTE_PAGES_SPANNED(Va, Size) \
    ((ULONG)((((ULONG_PTR)(Va) & (PAGE_SIZE -1)) + (Size) + (PAGE_SIZE - 1)) >> PAGE_SHIFT))


//++
// PPFN_NUMBER
// MmGetMdlPfnArray (
//     IN PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlPfnArray routine returns the virtual address of the
//     first element of the array of physical page numbers associated with
//     the MDL.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the virtual address of the first element of the array of
//     physical page numbers associated with the MDL.
//
//--

#define MmGetMdlPfnArray(Mdl) ((PPFN_NUMBER)(Mdl + 1))

//++
//
// PVOID
// MmGetMdlVirtualAddress (
//     IN PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlVirtualAddress returns the virtual address of the buffer
//     described by the Mdl.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the virtual address of the buffer described by the Mdl
//
//--

#define MmGetMdlVirtualAddress(Mdl)                                     \
    ((PVOID) ((PCHAR) ((Mdl)->StartVa) + (Mdl)->ByteOffset))

//++
//
// ULONG
// MmGetMdlByteCount (
//     IN PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlByteCount returns the length in bytes of the buffer
//     described by the Mdl.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the byte count of the buffer described by the Mdl
//
//--

#define MmGetMdlByteCount(Mdl)  ((Mdl)->ByteCount)

//++
//
// ULONG
// MmGetMdlByteOffset (
//     IN PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlByteOffset returns the byte offset within the page
//     of the buffer described by the Mdl.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the byte offset within the page of the buffer described by the Mdl
//
//--

#define MmGetMdlByteOffset(Mdl)  ((Mdl)->ByteOffset)

//++
//
// PVOID
// MmGetMdlStartVa (
//     IN PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlBaseVa returns the virtual address of the buffer
//     described by the Mdl rounded down to the nearest page.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the returns the starting virtual address of the MDL.
//
//
//--

#define MmGetMdlBaseVa(Mdl)  ((Mdl)->StartVa)

typedef enum _MM_SYSTEM_SIZE {
    MmSmallSystem,
    MmMediumSystem,
    MmLargeSystem
} MM_SYSTEMSIZE;

NTKERNELAPI
MM_SYSTEMSIZE
MmQuerySystemSize(
    VOID
    );


typedef enum _LOCK_OPERATION {
    IoReadAccess,
    IoWriteAccess,
    IoModifyAccess
} LOCK_OPERATION;


NTKERNELAPI
VOID
MmProbeAndLockProcessPages (
    IN OUT PMDL MemoryDescriptorList,
    IN PEPROCESS Process,
    IN KPROCESSOR_MODE AccessMode,
    IN LOCK_OPERATION Operation
    );



//
// I/O support routines.
//

NTKERNELAPI
VOID
MmProbeAndLockPages (
    IN OUT PMDL MemoryDescriptorList,
    IN KPROCESSOR_MODE AccessMode,
    IN LOCK_OPERATION Operation
    );


NTKERNELAPI
VOID
MmUnlockPages (
    IN PMDL MemoryDescriptorList
    );

NTKERNELAPI
VOID
MmBuildMdlForNonPagedPool (
    IN OUT PMDL MemoryDescriptorList
    );

NTKERNELAPI
PVOID
MmMapLockedPages (
    IN PMDL MemoryDescriptorList,
    IN KPROCESSOR_MODE AccessMode
    );

NTKERNELAPI
PVOID
MmGetSystemRoutineAddress (
    IN PUNICODE_STRING SystemRoutineName
    );


//
// _MM_PAGE_PRIORITY_ provides a method for the system to handle requests
// intelligently in low resource conditions.
//
// LowPagePriority should be used when it is acceptable to the driver for the
// mapping request to fail if the system is low on resources.  An example of
// this could be for a non-critical network connection where the driver can
// handle the failure case when system resources are close to being depleted.
//
// NormalPagePriority should be used when it is acceptable to the driver for the
// mapping request to fail if the system is very low on resources.  An example
// of this could be for a non-critical local filesystem request.
//
// HighPagePriority should be used when it is unacceptable to the driver for the
// mapping request to fail unless the system is completely out of resources.
// An example of this would be the paging file path in a driver.
//

typedef enum _MM_PAGE_PRIORITY {
    LowPagePriority,
    NormalPagePriority = 16,
    HighPagePriority = 32
} MM_PAGE_PRIORITY;

//
// Note: This function is not available in WDM 1.0
//
NTKERNELAPI
PVOID
MmMapLockedPagesSpecifyCache (
     IN PMDL MemoryDescriptorList,
     IN KPROCESSOR_MODE AccessMode,
     IN MEMORY_CACHING_TYPE CacheType,
     IN PVOID BaseAddress,
     IN ULONG BugCheckOnFailure,
     IN MM_PAGE_PRIORITY Priority
     );

NTKERNELAPI
VOID
MmUnmapLockedPages (
    IN PVOID BaseAddress,
    IN PMDL MemoryDescriptorList
    );


NTKERNELAPI
PVOID
MmMapIoSpace (
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN SIZE_T NumberOfBytes,
    IN MEMORY_CACHING_TYPE CacheType
    );

NTKERNELAPI
VOID
MmUnmapIoSpace (
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes
    );


NTKERNELAPI
SIZE_T
MmSizeOfMdl(
    IN PVOID Base,
    IN SIZE_T Length
    );

NTKERNELAPI
PMDL
MmCreateMdl(
    IN PMDL MemoryDescriptorList OPTIONAL,
    IN PVOID Base,
    IN SIZE_T Length
    );

NTKERNELAPI
PVOID
MmLockPagableDataSection(
    IN PVOID AddressWithinSection
    );

NTKERNELAPI
VOID
MmResetDriverPaging (
    IN PVOID AddressWithinSection
    );


NTKERNELAPI
PVOID
MmPageEntireDriver (
    IN PVOID AddressWithinSection
    );

NTKERNELAPI
VOID
MmUnlockPagableImageSection(
    IN PVOID ImageSectionHandle
    );


//++
//
// VOID
// MmInitializeMdl (
//     IN PMDL MemoryDescriptorList,
//     IN PVOID BaseVa,
//     IN SIZE_T Length
//     )
//
// Routine Description:
//
//     This routine initializes the header of a Memory Descriptor List (MDL).
//
// Arguments:
//
//     MemoryDescriptorList - Pointer to the MDL to initialize.
//
//     BaseVa - Base virtual address mapped by the MDL.
//
//     Length - Length, in bytes, of the buffer mapped by the MDL.
//
// Return Value:
//
//     None.
//
//--

#define MmInitializeMdl(MemoryDescriptorList, BaseVa, Length) { \
    (MemoryDescriptorList)->Next = (PMDL) NULL; \
    (MemoryDescriptorList)->Size = (CSHORT)(sizeof(MDL) +  \
            (sizeof(PFN_NUMBER) * ADDRESS_AND_SIZE_TO_SPAN_PAGES((BaseVa), (Length)))); \
    (MemoryDescriptorList)->MdlFlags = 0; \
    (MemoryDescriptorList)->StartVa = (PVOID) PAGE_ALIGN((BaseVa)); \
    (MemoryDescriptorList)->ByteOffset = BYTE_OFFSET((BaseVa)); \
    (MemoryDescriptorList)->ByteCount = (ULONG)(Length); \
    }

//++
//
// PVOID
// MmGetSystemAddressForMdlSafe (
//     IN PMDL MDL,
//     IN MM_PAGE_PRIORITY PRIORITY
//     )
//
// Routine Description:
//
//     This routine returns the mapped address of an MDL. If the
//     Mdl is not already mapped or a system address, it is mapped.
//
// Arguments:
//
//     MemoryDescriptorList - Pointer to the MDL to map.
//
//     Priority - Supplies an indication as to how important it is that this
//                request succeed under low available PTE conditions.
//
// Return Value:
//
//     Returns the base address where the pages are mapped.  The base address
//     has the same offset as the virtual address in the MDL.
//
//     Unlike MmGetSystemAddressForMdl, Safe guarantees that it will always
//     return NULL on failure instead of bugchecking the system.
//
//     This macro is not usable by WDM 1.0 drivers as 1.0 did not include
//     MmMapLockedPagesSpecifyCache.  The solution for WDM 1.0 drivers is to
//     provide synchronization and set/reset the MDL_MAPPING_CAN_FAIL bit.
//
//--

#define MmGetSystemAddressForMdlSafe(MDL, PRIORITY)                    \
     (((MDL)->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA |                    \
                        MDL_SOURCE_IS_NONPAGED_POOL)) ?                \
                             ((MDL)->MappedSystemVa) :                 \
                             (MmMapLockedPagesSpecifyCache((MDL),      \
                                                           KernelMode, \
                                                           MmCached,   \
                                                           NULL,       \
                                                           FALSE,      \
                                                           (PRIORITY))))

//++
//
// PVOID
// MmGetSystemAddressForMdl (
//     IN PMDL MDL
//     )
//
// Routine Description:
//
//     This routine returns the mapped address of an MDL, if the
//     Mdl is not already mapped or a system address, it is mapped.
//
// Arguments:
//
//     MemoryDescriptorList - Pointer to the MDL to map.
//
// Return Value:
//
//     Returns the base address where the pages are mapped.  The base address
//     has the same offset as the virtual address in the MDL.
//
//--

//#define MmGetSystemAddressForMdl(MDL)
//     (((MDL)->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA)) ?
//                             ((MDL)->MappedSystemVa) :
//                ((((MDL)->MdlFlags & (MDL_SOURCE_IS_NONPAGED_POOL)) ?
//                      ((PVOID)((ULONG)(MDL)->StartVa | (MDL)->ByteOffset)) :
//                            (MmMapLockedPages((MDL),KernelMode)))))

#define MmGetSystemAddressForMdl(MDL)                                  \
     (((MDL)->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA |                    \
                        MDL_SOURCE_IS_NONPAGED_POOL)) ?                \
                             ((MDL)->MappedSystemVa) :                 \
                             (MmMapLockedPages((MDL),KernelMode)))

//++
//
// VOID
// MmPrepareMdlForReuse (
//     IN PMDL MDL
//     )
//
// Routine Description:
//
//     This routine will take all of the steps necessary to allow an MDL to be
//     re-used.
//
// Arguments:
//
//     MemoryDescriptorList - Pointer to the MDL that will be re-used.
//
// Return Value:
//
//     None.
//
//--

#define MmPrepareMdlForReuse(MDL)                                       \
    if (((MDL)->MdlFlags & MDL_PARTIAL_HAS_BEEN_MAPPED) != 0) {         \
        ASSERT(((MDL)->MdlFlags & MDL_PARTIAL) != 0);                   \
        MmUnmapLockedPages( (MDL)->MappedSystemVa, (MDL) );             \
    } else if (((MDL)->MdlFlags & MDL_PARTIAL) == 0) {                  \
        ASSERT(((MDL)->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA) == 0);       \
    }

typedef NTSTATUS (*PMM_DLL_INITIALIZE)(
    IN PUNICODE_STRING RegistryPath
    );

typedef NTSTATUS (*PMM_DLL_UNLOAD)(
    VOID
    );


//
// System Thread and Process Creation and Termination
//

NTKERNELAPI
NTSTATUS
PsCreateSystemThread(
    OUT PHANDLE ThreadHandle,
    IN ULONG DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN HANDLE ProcessHandle OPTIONAL,
    OUT PCLIENT_ID ClientId OPTIONAL,
    IN PKSTART_ROUTINE StartRoutine,
    IN PVOID StartContext
    );

NTKERNELAPI
NTSTATUS
PsTerminateSystemThread(
    IN NTSTATUS ExitStatus
    );

//
// Define I/O system data structure type codes.  Each major data structure in
// the I/O system has a type code  The type field in each structure is at the
// same offset.  The following values can be used to determine which type of
// data structure a pointer refers to.
//

#define IO_TYPE_ADAPTER                 0x00000001
#define IO_TYPE_CONTROLLER              0x00000002
#define IO_TYPE_DEVICE                  0x00000003
#define IO_TYPE_DRIVER                  0x00000004
#define IO_TYPE_FILE                    0x00000005
#define IO_TYPE_IRP                     0x00000006
#define IO_TYPE_MASTER_ADAPTER          0x00000007
#define IO_TYPE_OPEN_PACKET             0x00000008
#define IO_TYPE_TIMER                   0x00000009
#define IO_TYPE_VPB                     0x0000000a
#define IO_TYPE_ERROR_LOG               0x0000000b
#define IO_TYPE_ERROR_MESSAGE           0x0000000c
#define IO_TYPE_DEVICE_OBJECT_EXTENSION 0x0000000d


//
// Define the major function codes for IRPs.
//


#define IRP_MJ_CREATE                   0x00
#define IRP_MJ_CREATE_NAMED_PIPE        0x01
#define IRP_MJ_CLOSE                    0x02
#define IRP_MJ_READ                     0x03
#define IRP_MJ_WRITE                    0x04
#define IRP_MJ_QUERY_INFORMATION        0x05
#define IRP_MJ_SET_INFORMATION          0x06
#define IRP_MJ_QUERY_EA                 0x07
#define IRP_MJ_SET_EA                   0x08
#define IRP_MJ_FLUSH_BUFFERS            0x09
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
#define IRP_MJ_SET_VOLUME_INFORMATION   0x0b
#define IRP_MJ_DIRECTORY_CONTROL        0x0c
#define IRP_MJ_FILE_SYSTEM_CONTROL      0x0d
#define IRP_MJ_DEVICE_CONTROL           0x0e
#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0f
#define IRP_MJ_SHUTDOWN                 0x10
#define IRP_MJ_LOCK_CONTROL             0x11
#define IRP_MJ_CLEANUP                  0x12
#define IRP_MJ_CREATE_MAILSLOT          0x13
#define IRP_MJ_QUERY_SECURITY           0x14
#define IRP_MJ_SET_SECURITY             0x15
#define IRP_MJ_POWER                    0x16
#define IRP_MJ_SYSTEM_CONTROL           0x17
#define IRP_MJ_DEVICE_CHANGE            0x18
#define IRP_MJ_QUERY_QUOTA              0x19
#define IRP_MJ_SET_QUOTA                0x1a
#define IRP_MJ_PNP                      0x1b
#define IRP_MJ_PNP_POWER                IRP_MJ_PNP      // Obsolete....
#define IRP_MJ_MAXIMUM_FUNCTION         0x1b

//
// Make the Scsi major code the same as internal device control.
//

#define IRP_MJ_SCSI                     IRP_MJ_INTERNAL_DEVICE_CONTROL

//
// Define the minor function codes for IRPs.  The lower 128 codes, from 0x00 to
// 0x7f are reserved to Microsoft.  The upper 128 codes, from 0x80 to 0xff, are
// reserved to customers of Microsoft.
//

//
// Device Control Request minor function codes for SCSI support. Note that
// user requests are assumed to be zero.
//

#define IRP_MN_SCSI_CLASS               0x01

//
// PNP minor function codes.
//

#define IRP_MN_START_DEVICE                 0x00
#define IRP_MN_QUERY_REMOVE_DEVICE          0x01
#define IRP_MN_REMOVE_DEVICE                0x02
#define IRP_MN_CANCEL_REMOVE_DEVICE         0x03
#define IRP_MN_STOP_DEVICE                  0x04
#define IRP_MN_QUERY_STOP_DEVICE            0x05
#define IRP_MN_CANCEL_STOP_DEVICE           0x06

#define IRP_MN_QUERY_DEVICE_RELATIONS       0x07
#define IRP_MN_QUERY_INTERFACE              0x08
#define IRP_MN_QUERY_CAPABILITIES           0x09
#define IRP_MN_QUERY_RESOURCES              0x0A
#define IRP_MN_QUERY_RESOURCE_REQUIREMENTS  0x0B
#define IRP_MN_QUERY_DEVICE_TEXT            0x0C
#define IRP_MN_FILTER_RESOURCE_REQUIREMENTS 0x0D

#define IRP_MN_READ_CONFIG                  0x0F
#define IRP_MN_WRITE_CONFIG                 0x10
#define IRP_MN_EJECT                        0x11
#define IRP_MN_SET_LOCK                     0x12
#define IRP_MN_QUERY_ID                     0x13
#define IRP_MN_QUERY_PNP_DEVICE_STATE       0x14
#define IRP_MN_QUERY_BUS_INFORMATION        0x15
#define IRP_MN_DEVICE_USAGE_NOTIFICATION    0x16
#define IRP_MN_SURPRISE_REMOVAL             0x17

//
// POWER minor function codes
//
#define IRP_MN_WAIT_WAKE                    0x00
#define IRP_MN_POWER_SEQUENCE               0x01
#define IRP_MN_SET_POWER                    0x02
#define IRP_MN_QUERY_POWER                  0x03


//
// WMI minor function codes under IRP_MJ_SYSTEM_CONTROL
//

#define IRP_MN_QUERY_ALL_DATA               0x00
#define IRP_MN_QUERY_SINGLE_INSTANCE        0x01
#define IRP_MN_CHANGE_SINGLE_INSTANCE       0x02
#define IRP_MN_CHANGE_SINGLE_ITEM           0x03
#define IRP_MN_ENABLE_EVENTS                0x04
#define IRP_MN_DISABLE_EVENTS               0x05
#define IRP_MN_ENABLE_COLLECTION            0x06
#define IRP_MN_DISABLE_COLLECTION           0x07
#define IRP_MN_REGINFO                      0x08
#define IRP_MN_EXECUTE_METHOD               0x09



//
// Define option flags for IoCreateFile.  Note that these values must be
// exactly the same as the SL_... flags for a create function.  Note also
// that there are flags that may be passed to IoCreateFile that are not
// placed in the stack location for the create IRP.  These flags start in
// the next byte.
//

#define IO_FORCE_ACCESS_CHECK           0x0001
#define IO_OPEN_PAGING_FILE             0x0002
#define IO_OPEN_TARGET_DIRECTORY        0x0004
#define IO_NO_PARAMETER_CHECKING        0x0100

//
// Define Information fields for whether or not a REPARSE or a REMOUNT has
// occurred in the file system.
//

#define IO_REPARSE                      0x0
#define IO_REMOUNT                      0x1

//
// Define the objects that can be created by IoCreateFile.
//

typedef enum _CREATE_FILE_TYPE {
    CreateFileTypeNone,
    CreateFileTypeNamedPipe,
    CreateFileTypeMailslot
} CREATE_FILE_TYPE;

//
// Define the structures used by the I/O system
//

//
// Define empty typedefs for the _IRP, _DEVICE_OBJECT, and _DRIVER_OBJECT
// structures so they may be referenced by function types before they are
// actually defined.
//
struct _DEVICE_DESCRIPTION;
struct _DEVICE_OBJECT;
struct _DMA_ADAPTER;
struct _DRIVER_OBJECT;
struct _DRIVE_LAYOUT_INFORMATION;
struct _DISK_PARTITION;
struct _FILE_OBJECT;
struct _IRP;
struct _SCSI_REQUEST_BLOCK;

//
// Define the I/O version of a DPC routine.
//

typedef
VOID
(*PIO_DPC_ROUTINE) (
    IN PKDPC Dpc,
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PVOID Context
    );

//
// Define driver timer routine type.
//

typedef
VOID
(*PIO_TIMER_ROUTINE) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN PVOID Context
    );

//
// Define driver initialization routine type.
//

typedef
NTSTATUS
(*PDRIVER_INITIALIZE) (
    IN struct _DRIVER_OBJECT *DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

//
// Define driver cancel routine type.
//

typedef
VOID
(*PDRIVER_CANCEL) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
// Define driver dispatch routine type.
//

typedef
NTSTATUS
(*PDRIVER_DISPATCH) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
// Define driver start I/O routine type.
//

typedef
VOID
(*PDRIVER_STARTIO) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
// Define driver unload routine type.
//

typedef
VOID
(*PDRIVER_UNLOAD) (
    IN struct _DRIVER_OBJECT *DriverObject
    );

//
// Define driver AddDevice routine type.
//

typedef
NTSTATUS
(*PDRIVER_ADD_DEVICE) (
    IN struct _DRIVER_OBJECT *DriverObject,
    IN struct _DEVICE_OBJECT *PhysicalDeviceObject
    );


//
// Define fast I/O procedure prototypes.
//
// Fast I/O read and write procedures.
//

typedef
BOOLEAN
(*PFAST_IO_CHECK_IF_POSSIBLE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_READ) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_WRITE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Fast I/O query basic and standard information procedures.
//

typedef
BOOLEAN
(*PFAST_IO_QUERY_BASIC_INFO) (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_QUERY_STANDARD_INFO) (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Fast I/O lock and unlock procedures.
//

typedef
BOOLEAN
(*PFAST_IO_LOCK) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_UNLOCK_SINGLE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_UNLOCK_ALL) (
    IN struct _FILE_OBJECT *FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_UNLOCK_ALL_BY_KEY) (
    IN struct _FILE_OBJECT *FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Fast I/O device control procedure.
//

typedef
BOOLEAN
(*PFAST_IO_DEVICE_CONTROL) (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Define callbacks for NtCreateSection to synchronize correctly with
// the file system.  It pre-acquires the resources that will be needed
// when calling to query and set file/allocation size in the file system.
//

typedef
VOID
(*PFAST_IO_ACQUIRE_FILE) (
    IN struct _FILE_OBJECT *FileObject
    );

typedef
VOID
(*PFAST_IO_RELEASE_FILE) (
    IN struct _FILE_OBJECT *FileObject
    );

//
// Define callback for drivers that have device objects attached to lower-
// level drivers' device objects.  This callback is made when the lower-level
// driver is deleting its device object.
//

typedef
VOID
(*PFAST_IO_DETACH_DEVICE) (
    IN struct _DEVICE_OBJECT *SourceDevice,
    IN struct _DEVICE_OBJECT *TargetDevice
    );

//
// This structure is used by the server to quickly get the information needed
// to service a server open call.  It is takes what would be two fast io calls
// one for basic information and the other for standard information and makes
// it into one call.
//

typedef
BOOLEAN
(*PFAST_IO_QUERY_NETWORK_OPEN_INFO) (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    OUT struct _FILE_NETWORK_OPEN_INFORMATION *Buffer,
    OUT struct _IO_STATUS_BLOCK *IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
//  Define Mdl-based routines for the server to call
//

typedef
BOOLEAN
(*PFAST_IO_MDL_READ) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_MDL_READ_COMPLETE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_PREPARE_MDL_WRITE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_MDL_WRITE_COMPLETE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
//  If this routine is present, it will be called by FsRtl
//  to acquire the file for the mapped page writer.
//

typedef
NTSTATUS
(*PFAST_IO_ACQUIRE_FOR_MOD_WRITE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER EndingOffset,
    OUT struct _ERESOURCE **ResourceToRelease,
    IN struct _DEVICE_OBJECT *DeviceObject
             );

typedef
NTSTATUS
(*PFAST_IO_RELEASE_FOR_MOD_WRITE) (
    IN struct _FILE_OBJECT *FileObject,
    IN struct _ERESOURCE *ResourceToRelease,
    IN struct _DEVICE_OBJECT *DeviceObject
             );

//
//  If this routine is present, it will be called by FsRtl
//  to acquire the file for the mapped page writer.
//

typedef
NTSTATUS
(*PFAST_IO_ACQUIRE_FOR_CCFLUSH) (
    IN struct _FILE_OBJECT *FileObject,
    IN struct _DEVICE_OBJECT *DeviceObject
             );

typedef
NTSTATUS
(*PFAST_IO_RELEASE_FOR_CCFLUSH) (
    IN struct _FILE_OBJECT *FileObject,
    IN struct _DEVICE_OBJECT *DeviceObject
             );

typedef
BOOLEAN
(*PFAST_IO_READ_COMPRESSED) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_WRITE_COMPRESSED) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_MDL_READ_COMPLETE_COMPRESSED) (
    IN struct _FILE_OBJECT *FileObject,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_QUERY_OPEN) (
    IN struct _IRP *Irp,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Define the structure to describe the Fast I/O dispatch routines.  Any
// additions made to this structure MUST be added monotonically to the end
// of the structure, and fields CANNOT be removed from the middle.
//

typedef struct _FAST_IO_DISPATCH {
    ULONG SizeOfFastIoDispatch;
    PFAST_IO_CHECK_IF_POSSIBLE FastIoCheckIfPossible;
    PFAST_IO_READ FastIoRead;
    PFAST_IO_WRITE FastIoWrite;
    PFAST_IO_QUERY_BASIC_INFO FastIoQueryBasicInfo;
    PFAST_IO_QUERY_STANDARD_INFO FastIoQueryStandardInfo;
    PFAST_IO_LOCK FastIoLock;
    PFAST_IO_UNLOCK_SINGLE FastIoUnlockSingle;
    PFAST_IO_UNLOCK_ALL FastIoUnlockAll;
    PFAST_IO_UNLOCK_ALL_BY_KEY FastIoUnlockAllByKey;
    PFAST_IO_DEVICE_CONTROL FastIoDeviceControl;
    PFAST_IO_ACQUIRE_FILE AcquireFileForNtCreateSection;
    PFAST_IO_RELEASE_FILE ReleaseFileForNtCreateSection;
    PFAST_IO_DETACH_DEVICE FastIoDetachDevice;
    PFAST_IO_QUERY_NETWORK_OPEN_INFO FastIoQueryNetworkOpenInfo;
    PFAST_IO_ACQUIRE_FOR_MOD_WRITE AcquireForModWrite;
    PFAST_IO_MDL_READ MdlRead;
    PFAST_IO_MDL_READ_COMPLETE MdlReadComplete;
    PFAST_IO_PREPARE_MDL_WRITE PrepareMdlWrite;
    PFAST_IO_MDL_WRITE_COMPLETE MdlWriteComplete;
    PFAST_IO_READ_COMPRESSED FastIoReadCompressed;
    PFAST_IO_WRITE_COMPRESSED FastIoWriteCompressed;
    PFAST_IO_MDL_READ_COMPLETE_COMPRESSED MdlReadCompleteCompressed;
    PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED MdlWriteCompleteCompressed;
    PFAST_IO_QUERY_OPEN FastIoQueryOpen;
    PFAST_IO_RELEASE_FOR_MOD_WRITE ReleaseForModWrite;
    PFAST_IO_ACQUIRE_FOR_CCFLUSH AcquireForCcFlush;
    PFAST_IO_RELEASE_FOR_CCFLUSH ReleaseForCcFlush;
} FAST_IO_DISPATCH, *PFAST_IO_DISPATCH;

//
// Define the actions that a driver execution routine may request of the
// adapter/controller allocation routines upon return.
//

typedef enum _IO_ALLOCATION_ACTION {
    KeepObject = 1,
    DeallocateObject,
    DeallocateObjectKeepRegisters
} IO_ALLOCATION_ACTION, *PIO_ALLOCATION_ACTION;

//
// Define device driver adapter/controller execution routine.
//

typedef
IO_ALLOCATION_ACTION
(*PDRIVER_CONTROL) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    );

//
// Define the I/O system's security context type for use by file system's
// when checking access to volumes, files, and directories.
//

typedef struct _IO_SECURITY_CONTEXT {
    PSECURITY_QUALITY_OF_SERVICE SecurityQos;
    PACCESS_STATE AccessState;
    ACCESS_MASK DesiredAccess;
    ULONG FullCreateOptions;
} IO_SECURITY_CONTEXT, *PIO_SECURITY_CONTEXT;

//
// Define object type specific fields of various objects used by the I/O system
//

typedef struct _DMA_ADAPTER *PADAPTER_OBJECT;

//
// Define Wait Context Block (WCB)
//

typedef struct _WAIT_CONTEXT_BLOCK {
    KDEVICE_QUEUE_ENTRY WaitQueueEntry;
    PDRIVER_CONTROL DeviceRoutine;
    PVOID DeviceContext;
    ULONG NumberOfMapRegisters;
    PVOID DeviceObject;
    PVOID CurrentIrp;
    PKDPC BufferChainingDpc;
} WAIT_CONTEXT_BLOCK, *PWAIT_CONTEXT_BLOCK;

//
// Define Device Object (DO) flags
//
#define DO_BUFFERED_IO                  0x00000004      
#define DO_EXCLUSIVE                    0x00000008      
#define DO_DIRECT_IO                    0x00000010      
#define DO_MAP_IO_BUFFER                0x00000020      
#define DO_DEVICE_INITIALIZING          0x00000080      
#define DO_SHUTDOWN_REGISTERED          0x00000800      
#define DO_BUS_ENUMERATED_DEVICE        0x00001000      
#define DO_POWER_PAGABLE                0x00002000      
#define DO_POWER_INRUSH                 0x00004000      
//
// Device Object structure definition
//

typedef struct _DEVICE_OBJECT {
    CSHORT Type;
    USHORT Size;
    LONG ReferenceCount;
    struct _DRIVER_OBJECT *DriverObject;
    struct _DEVICE_OBJECT *NextDevice;
    struct _DEVICE_OBJECT *AttachedDevice;
    struct _IRP *CurrentIrp;
    PIO_TIMER Timer;
    ULONG Flags;                                // See above:  DO_...
    ULONG Characteristics;                      // See ntioapi:  FILE_...
    PVOID DoNotUse1;
    PVOID DeviceExtension;
    DEVICE_TYPE DeviceType;
    CCHAR StackSize;
    union {
        LIST_ENTRY ListEntry;
        WAIT_CONTEXT_BLOCK Wcb;
    } Queue;
    ULONG AlignmentRequirement;
    KDEVICE_QUEUE DeviceQueue;
    KDPC Dpc;

    //
    //  The following field is for exclusive use by the filesystem to keep
    //  track of the number of Fsp threads currently using the device
    //

    ULONG ActiveThreadCount;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    KEVENT DeviceLock;

    USHORT SectorSize;
    USHORT Spare1;

    struct _DEVOBJ_EXTENSION  *DeviceObjectExtension;
    PVOID  Reserved;
} DEVICE_OBJECT;
typedef struct _DEVICE_OBJECT *PDEVICE_OBJECT; 


struct  _DEVICE_OBJECT_POWER_EXTENSION;

typedef struct _DEVOBJ_EXTENSION {

    CSHORT          Type;
    USHORT          Size;

    //
    // Public part of the DeviceObjectExtension structure
    //

    PDEVICE_OBJECT  DeviceObject;               // owning device object


} DEVOBJ_EXTENSION, *PDEVOBJ_EXTENSION;

//
// Define Driver Object (DRVO) flags
//

#define DRVO_UNLOAD_INVOKED             0x00000001
#define DRVO_LEGACY_DRIVER              0x00000002
#define DRVO_BUILTIN_DRIVER             0x00000004    // Driver objects for Hal, PnP Mgr

typedef struct _DRIVER_EXTENSION {

    //
    // Back pointer to Driver Object
    //

    struct _DRIVER_OBJECT *DriverObject;

    //
    // The AddDevice entry point is called by the Plug & Play manager
    // to inform the driver when a new device instance arrives that this
    // driver must control.
    //

    PDRIVER_ADD_DEVICE AddDevice;

    //
    // The count field is used to count the number of times the driver has
    // had its registered reinitialization routine invoked.
    //

    ULONG Count;

    //
    // The service name field is used by the pnp manager to determine
    // where the driver related info is stored in the registry.
    //

    UNICODE_STRING ServiceKeyName;

    //
    // Note: any new shared fields get added here.
    //


} DRIVER_EXTENSION, *PDRIVER_EXTENSION;

typedef struct _DRIVER_OBJECT {
    CSHORT Type;
    CSHORT Size;

    //
    // The following links all of the devices created by a single driver
    // together on a list, and the Flags word provides an extensible flag
    // location for driver objects.
    //

    PDEVICE_OBJECT DeviceObject;
    ULONG Flags;

    //
    // The following section describes where the driver is loaded.  The count
    // field is used to count the number of times the driver has had its
    // registered reinitialization routine invoked.
    //

    PVOID DriverStart;
    ULONG DriverSize;
    PVOID DriverSection;
    PDRIVER_EXTENSION DriverExtension;

    //
    // The driver name field is used by the error log thread
    // determine the name of the driver that an I/O request is/was bound.
    //

    UNICODE_STRING DriverName;

    //
    // The following section is for registry support.  Thise is a pointer
    // to the path to the hardware information in the registry
    //

    PUNICODE_STRING HardwareDatabase;

    //
    // The following section contains the optional pointer to an array of
    // alternate entry points to a driver for "fast I/O" support.  Fast I/O
    // is performed by invoking the driver routine directly with separate
    // parameters, rather than using the standard IRP call mechanism.  Note
    // that these functions may only be used for synchronous I/O, and when
    // the file is cached.
    //

    PFAST_IO_DISPATCH FastIoDispatch;

    //
    // The following section describes the entry points to this particular
    // driver.  Note that the major function dispatch table must be the last
    // field in the object so that it remains extensible.
    //

    PDRIVER_INITIALIZE DriverInit;
    PDRIVER_STARTIO DriverStartIo;
    PDRIVER_UNLOAD DriverUnload;
    PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1];

} DRIVER_OBJECT;
typedef struct _DRIVER_OBJECT *PDRIVER_OBJECT; 



//
// The following structure is pointed to by the SectionObject pointer field
// of a file object, and is allocated by the various NT file systems.
//

typedef struct _SECTION_OBJECT_POINTERS {
    PVOID DataSectionObject;
    PVOID SharedCacheMap;
    PVOID ImageSectionObject;
} SECTION_OBJECT_POINTERS;
typedef SECTION_OBJECT_POINTERS *PSECTION_OBJECT_POINTERS;

//
// Define the format of a completion message.
//

typedef struct _IO_COMPLETION_CONTEXT {
    PVOID Port;
    PVOID Key;
} IO_COMPLETION_CONTEXT, *PIO_COMPLETION_CONTEXT;

//
// Define File Object (FO) flags
//

#define FO_FILE_OPEN                    0x00000001
#define FO_SYNCHRONOUS_IO               0x00000002
#define FO_ALERTABLE_IO                 0x00000004
#define FO_NO_INTERMEDIATE_BUFFERING    0x00000008
#define FO_WRITE_THROUGH                0x00000010
#define FO_SEQUENTIAL_ONLY              0x00000020
#define FO_CACHE_SUPPORTED              0x00000040
#define FO_NAMED_PIPE                   0x00000080
#define FO_STREAM_FILE                  0x00000100
#define FO_MAILSLOT                     0x00000200
#define FO_GENERATE_AUDIT_ON_CLOSE      0x00000400
#define FO_DIRECT_DEVICE_OPEN           0x00000800
#define FO_FILE_MODIFIED                0x00001000
#define FO_FILE_SIZE_CHANGED            0x00002000
#define FO_CLEANUP_COMPLETE             0x00004000
#define FO_TEMPORARY_FILE               0x00008000
#define FO_DELETE_ON_CLOSE              0x00010000
#define FO_OPENED_CASE_SENSITIVE        0x00020000
#define FO_HANDLE_CREATED               0x00040000
#define FO_FILE_FAST_IO_READ            0x00080000
#define FO_RANDOM_ACCESS                0x00100000
#define FO_FILE_OPEN_CANCELLED          0x00200000
#define FO_VOLUME_OPEN                  0x00400000

typedef struct _FILE_OBJECT {
    CSHORT Type;
    CSHORT Size;
    PDEVICE_OBJECT DeviceObject;
    PVOID DoNotUse1;
    PVOID FsContext;
    PVOID FsContext2;
    PSECTION_OBJECT_POINTERS SectionObjectPointer;
    PVOID PrivateCacheMap;
    NTSTATUS FinalStatus;
    struct _FILE_OBJECT *RelatedFileObject;
    BOOLEAN LockOperation;
    BOOLEAN DeletePending;
    BOOLEAN ReadAccess;
    BOOLEAN WriteAccess;
    BOOLEAN DeleteAccess;
    BOOLEAN SharedRead;
    BOOLEAN SharedWrite;
    BOOLEAN SharedDelete;
    ULONG Flags;
    UNICODE_STRING FileName;
    LARGE_INTEGER CurrentByteOffset;
    ULONG Waiters;
    ULONG Busy;
    PVOID LastLock;
    KEVENT Lock;
    KEVENT Event;
    PIO_COMPLETION_CONTEXT CompletionContext;
} FILE_OBJECT;
typedef struct _FILE_OBJECT *PFILE_OBJECT; 

//
// Define I/O Request Packet (IRP) flags
//

#define IRP_NOCACHE                     0x00000001
#define IRP_PAGING_IO                   0x00000002
#define IRP_MOUNT_COMPLETION            0x00000002
#define IRP_SYNCHRONOUS_API             0x00000004
#define IRP_ASSOCIATED_IRP              0x00000008
#define IRP_BUFFERED_IO                 0x00000010
#define IRP_DEALLOCATE_BUFFER           0x00000020
#define IRP_INPUT_OPERATION             0x00000040
#define IRP_SYNCHRONOUS_PAGING_IO       0x00000040
#define IRP_CREATE_OPERATION            0x00000080
#define IRP_READ_OPERATION              0x00000100
#define IRP_WRITE_OPERATION             0x00000200
#define IRP_CLOSE_OPERATION             0x00000400
//
// Define I/O request packet (IRP) alternate flags for allocation control.
//

#define IRP_QUOTA_CHARGED               0x01
#define IRP_ALLOCATED_MUST_SUCCEED      0x02
#define IRP_ALLOCATED_FIXED_SIZE        0x04
#define IRP_LOOKASIDE_ALLOCATION        0x08

//
// I/O Request Packet (IRP) definition
//

typedef struct _IRP {
    CSHORT Type;
    USHORT Size;

    //
    // Define the common fields used to control the IRP.
    //

    //
    // Define a pointer to the Memory Descriptor List (MDL) for this I/O
    // request.  This field is only used if the I/O is "direct I/O".
    //

    PMDL MdlAddress;

    //
    // Flags word - used to remember various flags.
    //

    ULONG Flags;

    //
    // The following union is used for one of three purposes:
    //
    //    1. This IRP is an associated IRP.  The field is a pointer to a master
    //       IRP.
    //
    //    2. This is the master IRP.  The field is the count of the number of
    //       IRPs which must complete (associated IRPs) before the master can
    //       complete.
    //
    //    3. This operation is being buffered and the field is the address of
    //       the system space buffer.
    //

    union {
        struct _IRP *MasterIrp;
        LONG IrpCount;
        PVOID SystemBuffer;
    } AssociatedIrp;

    //
    // Thread list entry - allows queueing the IRP to the thread pending I/O
    // request packet list.
    //

    LIST_ENTRY ThreadListEntry;

    //
    // I/O status - final status of operation.
    //

    IO_STATUS_BLOCK IoStatus;

    //
    // Requestor mode - mode of the original requestor of this operation.
    //

    KPROCESSOR_MODE RequestorMode;

    //
    // Pending returned - TRUE if pending was initially returned as the
    // status for this packet.
    //

    BOOLEAN PendingReturned;

    //
    // Stack state information.
    //

    CHAR StackCount;
    CHAR CurrentLocation;

    //
    // Cancel - packet has been canceled.
    //

    BOOLEAN Cancel;

    //
    // Cancel Irql - Irql at which the cancel spinlock was acquired.
    //

    KIRQL CancelIrql;

    //
    // ApcEnvironment - Used to save the APC environment at the time that the
    // packet was initialized.
    //

    CCHAR ApcEnvironment;

    //
    // Allocation control flags.
    //

    UCHAR AllocationFlags;

    //
    // User parameters.
    //

    PIO_STATUS_BLOCK UserIosb;
    PKEVENT UserEvent;
    union {
        struct {
            PIO_APC_ROUTINE UserApcRoutine;
            PVOID UserApcContext;
        } AsynchronousParameters;
        LARGE_INTEGER AllocationSize;
    } Overlay;

    //
    // CancelRoutine - Used to contain the address of a cancel routine supplied
    // by a device driver when the IRP is in a cancelable state.
    //

    PDRIVER_CANCEL CancelRoutine;

    //
    // Note that the UserBuffer parameter is outside of the stack so that I/O
    // completion can copy data back into the user's address space without
    // having to know exactly which service was being invoked.  The length
    // of the copy is stored in the second half of the I/O status block. If
    // the UserBuffer field is NULL, then no copy is performed.
    //

    PVOID UserBuffer;

    //
    // Kernel structures
    //
    // The following section contains kernel structures which the IRP needs
    // in order to place various work information in kernel controller system
    // queues.  Because the size and alignment cannot be controlled, they are
    // placed here at the end so they just hang off and do not affect the
    // alignment of other fields in the IRP.
    //

    union {

        struct {

            union {

                //
                // DeviceQueueEntry - The device queue entry field is used to
                // queue the IRP to the device driver device queue.
                //

                KDEVICE_QUEUE_ENTRY DeviceQueueEntry;

                struct {

                    //
                    // The following are available to the driver to use in
                    // whatever manner is desired, while the driver owns the
                    // packet.
                    //

                    PVOID DriverContext[4];

                } ;

            } ;

            //
            // Thread - pointer to caller's Thread Control Block.
            //

            PETHREAD Thread;

            //
            // Auxiliary buffer - pointer to any auxiliary buffer that is
            // required to pass information to a driver that is not contained
            // in a normal buffer.
            //

            PCHAR AuxiliaryBuffer;

            //
            // The following unnamed structure must be exactly identical
            // to the unnamed structure used in the minipacket header used
            // for completion queue entries.
            //

            struct {

                //
                // List entry - used to queue the packet to completion queue, among
                // others.
                //

                LIST_ENTRY ListEntry;

                union {

                    //
                    // Current stack location - contains a pointer to the current
                    // IO_STACK_LOCATION structure in the IRP stack.  This field
                    // should never be directly accessed by drivers.  They should
                    // use the standard functions.
                    //

                    struct _IO_STACK_LOCATION *CurrentStackLocation;

                    //
                    // Minipacket type.
                    //

                    ULONG PacketType;
                };
            };

            //
            // Original file object - pointer to the original file object
            // that was used to open the file.  This field is owned by the
            // I/O system and should not be used by any other drivers.
            //

            PFILE_OBJECT OriginalFileObject;

        } Overlay;

        //
        // APC - This APC control block is used for the special kernel APC as
        // well as for the caller's APC, if one was specified in the original
        // argument list.  If so, then the APC is reused for the normal APC for
        // whatever mode the caller was in and the "special" routine that is
        // invoked before the APC gets control simply deallocates the IRP.
        //

        KAPC Apc;

        //
        // CompletionKey - This is the key that is used to distinguish
        // individual I/O operations initiated on a single file handle.
        //

        PVOID CompletionKey;

    } Tail;

} IRP, *PIRP;

//
// Define completion routine types for use in stack locations in an IRP
//

typedef
NTSTATUS
(*PIO_COMPLETION_ROUTINE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

//
// Define stack location control flags
//

#define SL_PENDING_RETURNED             0x01
#define SL_INVOKE_ON_CANCEL             0x20
#define SL_INVOKE_ON_SUCCESS            0x40
#define SL_INVOKE_ON_ERROR              0x80

//
// Define flags for various functions
//

//
// Create / Create Named Pipe
//
// The following flags must exactly match those in the IoCreateFile call's
// options.  The case sensitive flag is added in later, by the parse routine,
// and is not an actual option to open.  Rather, it is part of the object
// manager's attributes structure.
//

#define SL_FORCE_ACCESS_CHECK           0x01
#define SL_OPEN_PAGING_FILE             0x02
#define SL_OPEN_TARGET_DIRECTORY        0x04

#define SL_CASE_SENSITIVE               0x80

//
// Read / Write
//

#define SL_KEY_SPECIFIED                0x01
#define SL_OVERRIDE_VERIFY_VOLUME       0x02
#define SL_WRITE_THROUGH                0x04
#define SL_FT_SEQUENTIAL_WRITE          0x08

//
// Device I/O Control
//
//
// Same SL_OVERRIDE_VERIFY_VOLUME as for read/write above.
//

//
// Lock
//

#define SL_FAIL_IMMEDIATELY             0x01
#define SL_EXCLUSIVE_LOCK               0x02

//
// QueryDirectory / QueryEa / QueryQuota
//

#define SL_RESTART_SCAN                 0x01
#define SL_RETURN_SINGLE_ENTRY          0x02
#define SL_INDEX_SPECIFIED              0x04

//
// NotifyDirectory
//

#define SL_WATCH_TREE                   0x01

//
// FileSystemControl
//
//    minor: mount/verify volume
//

#define SL_ALLOW_RAW_MOUNT              0x01

//
// Define PNP/POWER types required by IRP_MJ_PNP/IRP_MJ_POWER.
//

typedef enum _DEVICE_RELATION_TYPE {
    BusRelations,
    EjectionRelations,
    PowerRelations,
    RemovalRelations,
    TargetDeviceRelation
} DEVICE_RELATION_TYPE, *PDEVICE_RELATION_TYPE;

typedef struct _DEVICE_RELATIONS {
    ULONG Count;
    PDEVICE_OBJECT Objects[1];  // variable length
} DEVICE_RELATIONS, *PDEVICE_RELATIONS;

typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE {
    DeviceUsageTypeUndefined,
    DeviceUsageTypePaging,
    DeviceUsageTypeHibernation,
    DeviceUsageTypeDumpFile
} DEVICE_USAGE_NOTIFICATION_TYPE;



typedef struct _INTERFACE {
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    // interface specific entries go here
} INTERFACE, *PINTERFACE;



typedef struct _DEVICE_CAPABILITIES {
    USHORT Size;
    USHORT Version;  // the version documented here is version 1
    ULONG DeviceD1:1;
    ULONG DeviceD2:1;
    ULONG LockSupported:1;
    ULONG EjectSupported:1; // Ejectable in S0
    ULONG Removable:1;
    ULONG DockDevice:1;
    ULONG UniqueID:1;
    ULONG SilentInstall:1;
    ULONG RawDeviceOK:1;
    ULONG SurpriseRemovalOK:1;
    ULONG WakeFromD0:1;
    ULONG WakeFromD1:1;
    ULONG WakeFromD2:1;
    ULONG WakeFromD3:1;
    ULONG HardwareDisabled:1;
    ULONG NonDynamic:1;
    ULONG WarmEjectSupported:1;
    ULONG Reserved:15;

    ULONG Address;
    ULONG UINumber;

    DEVICE_POWER_STATE DeviceState[PowerSystemMaximum];
    SYSTEM_POWER_STATE SystemWake;
    DEVICE_POWER_STATE DeviceWake;
    ULONG D1Latency;
    ULONG D2Latency;
    ULONG D3Latency;
} DEVICE_CAPABILITIES, *PDEVICE_CAPABILITIES;

typedef struct _POWER_SEQUENCE {
    ULONG SequenceD1;
    ULONG SequenceD2;
    ULONG SequenceD3;
} POWER_SEQUENCE, *PPOWER_SEQUENCE;

typedef enum {
    BusQueryDeviceID = 0,       // <Enumerator>\<Enumerator-specific device id>
    BusQueryHardwareIDs = 1,    // Hardware ids
    BusQueryCompatibleIDs = 2,  // compatible device ids
    BusQueryInstanceID = 3,     // persistent id for this instance of the device
    BusQueryDeviceSerialNumber = 4    // serial number for this device
} BUS_QUERY_ID_TYPE, *PBUS_QUERY_ID_TYPE;

typedef ULONG PNP_DEVICE_STATE, *PPNP_DEVICE_STATE;

#define PNP_DEVICE_DISABLED                      0x00000001
#define PNP_DEVICE_DONT_DISPLAY_IN_UI            0x00000002
#define PNP_DEVICE_FAILED                        0x00000004
#define PNP_DEVICE_REMOVED                       0x00000008
#define PNP_DEVICE_RESOURCE_REQUIREMENTS_CHANGED 0x00000010
#define PNP_DEVICE_NOT_DISABLEABLE               0x00000020

typedef enum {
    DeviceTextDescription = 0,            // DeviceDesc property
    DeviceTextLocationInformation = 1     // DeviceLocation property
} DEVICE_TEXT_TYPE, *PDEVICE_TEXT_TYPE;

//
// Define I/O Request Packet (IRP) stack locations
//

#if !defined(_ALPHA_) && !defined(_IA64_)
#include "pshpack4.h"
#endif

#if defined(_WIN64)
#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)
#else
#define POINTER_ALIGNMENT
#endif

typedef struct _IO_STACK_LOCATION {
    UCHAR MajorFunction;
    UCHAR MinorFunction;
    UCHAR Flags;
    UCHAR Control;

    //
    // The following user parameters are based on the service that is being
    // invoked.  Drivers and file systems can determine which set to use based
    // on the above major and minor function codes.
    //

    union {

        //
        // System service parameters for:  NtCreateFile
        //

        struct {
            PIO_SECURITY_CONTEXT SecurityContext;
            ULONG Options;
            USHORT POINTER_ALIGNMENT FileAttributes;
            USHORT ShareAccess;
            ULONG POINTER_ALIGNMENT EaLength;
        } Create;


        //
        // System service parameters for:  NtReadFile
        //

        struct {
            ULONG Length;
            ULONG POINTER_ALIGNMENT Key;
            LARGE_INTEGER ByteOffset;
        } Read;

        //
        // System service parameters for:  NtWriteFile
        //

        struct {
            ULONG Length;
            ULONG POINTER_ALIGNMENT Key;
            LARGE_INTEGER ByteOffset;
        } Write;


        //
        // System service parameters for:  NtQueryInformationFile
        //

        struct {
            ULONG Length;
            FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass;
        } QueryFile;

        //
        // System service parameters for:  NtSetInformationFile
        //

        struct {
            ULONG Length;
            FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass;
            PFILE_OBJECT FileObject;
            union {
                struct {
                    BOOLEAN ReplaceIfExists;
                    BOOLEAN AdvanceOnly;
                };
                ULONG ClusterCount;
                HANDLE DeleteHandle;
            };
        } SetFile;


        //
        // System service parameters for:  NtQueryVolumeInformationFile
        //

        struct {
            ULONG Length;
            FS_INFORMATION_CLASS POINTER_ALIGNMENT FsInformationClass;
        } QueryVolume;


        //
        // System service parameters for:  NtFlushBuffersFile
        //
        // No extra user-supplied parameters.
        //


        //
        // System service parameters for:  NtDeviceIoControlFile
        //
        // Note that the user's output buffer is stored in the UserBuffer field
        // and the user's input buffer is stored in the SystemBuffer field.
        //

        struct {
            ULONG OutputBufferLength;
            ULONG POINTER_ALIGNMENT InputBufferLength;
            ULONG POINTER_ALIGNMENT IoControlCode;
            PVOID Type3InputBuffer;
        } DeviceIoControl;

        //
        // Non-system service parameters.
        //
        // Parameters for MountVolume
        //

        struct {
            PVOID DoNotUse1;
            PDEVICE_OBJECT DeviceObject;
        } MountVolume;

        //
        // Parameters for VerifyVolume
        //

        struct {
            PVOID DoNotUse1;
            PDEVICE_OBJECT DeviceObject;
        } VerifyVolume;

        //
        // Parameters for Scsi with internal device contorl.
        //

        struct {
            struct _SCSI_REQUEST_BLOCK *Srb;
        } Scsi;


        //
        // Parameters for IRP_MN_QUERY_DEVICE_RELATIONS
        //

        struct {
            DEVICE_RELATION_TYPE Type;
        } QueryDeviceRelations;

        //
        // Parameters for IRP_MN_QUERY_INTERFACE
        //

        struct {
            CONST GUID *InterfaceType;
            USHORT Size;
            USHORT Version;
            PINTERFACE Interface;
            PVOID InterfaceSpecificData;
        } QueryInterface;



        //
        // Parameters for IRP_MN_QUERY_CAPABILITIES
        //

        struct {
            PDEVICE_CAPABILITIES Capabilities;
        } DeviceCapabilities;

        //
        // Parameters for IRP_MN_FILTER_RESOURCE_REQUIREMENTS
        //

        struct {
            PIO_RESOURCE_REQUIREMENTS_LIST IoResourceRequirementList;
        } FilterResourceRequirements;

        //
        // Parameters for IRP_MN_READ_CONFIG and IRP_MN_WRITE_CONFIG
        //

        struct {
            ULONG WhichSpace;
            PVOID Buffer;
            ULONG Offset;
            ULONG POINTER_ALIGNMENT Length;
        } ReadWriteConfig;

        //
        // Parameters for IRP_MN_SET_LOCK
        //

        struct {
            BOOLEAN Lock;
        } SetLock;

        //
        // Parameters for IRP_MN_QUERY_ID
        //

        struct {
            BUS_QUERY_ID_TYPE IdType;
        } QueryId;

        //
        // Parameters for IRP_MN_QUERY_DEVICE_TEXT
        //

        struct {
            DEVICE_TEXT_TYPE DeviceTextType;
            LCID POINTER_ALIGNMENT LocaleId;
        } QueryDeviceText;

        //
        // Parameters for IRP_MN_DEVICE_USAGE_NOTIFICATION
        //

        struct {
            BOOLEAN InPath;
            BOOLEAN Reserved[3];
            DEVICE_USAGE_NOTIFICATION_TYPE POINTER_ALIGNMENT Type;
        } UsageNotification;

        //
        // Parameters for IRP_MN_WAIT_WAKE
        //

        struct {
            SYSTEM_POWER_STATE PowerState;
        } WaitWake;

        //
        // Parameter for IRP_MN_POWER_SEQUENCE
        //

        struct {
            PPOWER_SEQUENCE PowerSequence;
        } PowerSequence;

        //
        // Parameters for IRP_MN_SET_POWER and IRP_MN_QUERY_POWER
        //

        struct {
            ULONG SystemContext;
            POWER_STATE_TYPE POINTER_ALIGNMENT Type;
            POWER_STATE POINTER_ALIGNMENT State;
            POWER_ACTION POINTER_ALIGNMENT ShutdownType;
        } Power;

        //
        // Parameters for StartDevice
        //

        struct {
            PCM_RESOURCE_LIST AllocatedResources;
            PCM_RESOURCE_LIST AllocatedResourcesTranslated;
        } StartDevice;


        //
        // Parameters for Cleanup
        //
        // No extra parameters supplied
        //

        //
        // WMI Irps
        //

        struct {
            ULONG_PTR ProviderId;
            PVOID DataPath;
            ULONG BufferSize;
            PVOID Buffer;
        } WMI;

        //
        // Others - driver-specific
        //

        struct {
            PVOID Argument1;
            PVOID Argument2;
            PVOID Argument3;
            PVOID Argument4;
        } Others;

    } Parameters;

    //
    // Save a pointer to this device driver's device object for this request
    // so it can be passed to the completion routine if needed.
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // The following location contains a pointer to the file object for this
    //

    PFILE_OBJECT FileObject;

    //
    // The following routine is invoked depending on the flags in the above
    // flags field.
    //

    PIO_COMPLETION_ROUTINE CompletionRoutine;

    //
    // The following is used to store the address of the context parameter
    // that should be passed to the CompletionRoutine.
    //

    PVOID Context;

} IO_STACK_LOCATION, *PIO_STACK_LOCATION;
#if !defined(_ALPHA_) && !defined(_IA64_)
#include "poppack.h"
#endif

//
// Define the share access structure used by file systems to determine
// whether or not another accessor may open the file.
//

typedef struct _SHARE_ACCESS {
    ULONG OpenCount;
    ULONG Readers;
    ULONG Writers;
    ULONG Deleters;
    ULONG SharedRead;
    ULONG SharedWrite;
    ULONG SharedDelete;
} SHARE_ACCESS, *PSHARE_ACCESS;

//
// Public I/O routine definitions
//

NTKERNELAPI
VOID
IoAcquireCancelSpinLock(
    OUT PKIRQL Irql
    );


NTKERNELAPI
NTSTATUS
IoAllocateDriverObjectExtension(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID ClientIdentificationAddress,
    IN ULONG DriverObjectExtensionSize,
    OUT PVOID *DriverObjectExtension
    );



NTKERNELAPI
PVOID
IoAllocateErrorLogEntry(
    IN PVOID IoObject,
    IN UCHAR EntrySize
    );

NTKERNELAPI
PIRP
IoAllocateIrp(
    IN CCHAR StackSize,
    IN BOOLEAN ChargeQuota
    );

NTKERNELAPI
PMDL
IoAllocateMdl(
    IN PVOID VirtualAddress,
    IN ULONG Length,
    IN BOOLEAN SecondaryBuffer,
    IN BOOLEAN ChargeQuota,
    IN OUT PIRP Irp OPTIONAL
    );


NTKERNELAPI
NTSTATUS
IoAttachDevice(
    IN PDEVICE_OBJECT SourceDevice,
    IN PUNICODE_STRING TargetDevice,
    OUT PDEVICE_OBJECT *AttachedDevice
    );


NTKERNELAPI
PDEVICE_OBJECT
IoAttachDeviceToDeviceStack(
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice
    );

NTKERNELAPI
PIRP
IoBuildAsynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN PIO_STATUS_BLOCK IoStatusBlock OPTIONAL
    );

NTKERNELAPI
PIRP
IoBuildDeviceIoControlRequest(
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );

NTKERNELAPI
VOID
IoBuildPartialMdl(
    IN PMDL SourceMdl,
    IN OUT PMDL TargetMdl,
    IN PVOID VirtualAddress,
    IN ULONG Length
    );

typedef struct _BOOTDISK_INFORMATION {
    LONGLONG BootPartitionOffset;
    LONGLONG SystemPartitionOffset;
    ULONG BootDeviceSignature;
    ULONG SystemDeviceSignature;
} BOOTDISK_INFORMATION, *PBOOTDISK_INFORMATION;

NTKERNELAPI
NTSTATUS
IoGetBootDiskInformation(
    IN OUT PBOOTDISK_INFORMATION BootDiskInformation,
    IN ULONG Size
    );


NTKERNELAPI
PIRP
IoBuildSynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );

NTKERNELAPI
NTSTATUS
FASTCALL
IofCallDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

#define IoCallDriver(a,b)   \
        IofCallDriver(a,b)

NTKERNELAPI
BOOLEAN
IoCancelIrp(
    IN PIRP Irp
    );


NTKERNELAPI
NTSTATUS
IoCheckShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN BOOLEAN Update
    );

NTKERNELAPI
VOID
FASTCALL
IofCompleteRequest(
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    );

#define IoCompleteRequest(a,b)  \
        IofCompleteRequest(a,b)



NTKERNELAPI
NTSTATUS
IoConnectInterrupt(
    OUT PKINTERRUPT *InterruptObject,
    IN PKSERVICE_ROUTINE ServiceRoutine,
    IN PVOID ServiceContext,
    IN PKSPIN_LOCK SpinLock OPTIONAL,
    IN ULONG Vector,
    IN KIRQL Irql,
    IN KIRQL SynchronizeIrql,
    IN KINTERRUPT_MODE InterruptMode,
    IN BOOLEAN ShareVector,
    IN KAFFINITY ProcessorEnableMask,
    IN BOOLEAN FloatingSave
    );


NTKERNELAPI
NTSTATUS
IoCreateDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG DeviceExtensionSize,
    IN PUNICODE_STRING DeviceName OPTIONAL,
    IN DEVICE_TYPE DeviceType,
    IN ULONG DeviceCharacteristics,
    IN BOOLEAN Reserved,
    OUT PDEVICE_OBJECT *DeviceObject
    );

#define WDM_MAJORVERSION        0x01
#define WDM_MINORVERSION        0x10

NTKERNELAPI
BOOLEAN
IoIsWdmVersionAvailable(
    IN UCHAR MajorVersion,
    IN UCHAR MinorVersion
    );



NTKERNELAPI
NTSTATUS
IoCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG Disposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    IN CREATE_FILE_TYPE CreateFileType,
    IN PVOID ExtraCreateParameters OPTIONAL,
    IN ULONG Options
    );


NTKERNELAPI
PKEVENT
IoCreateNotificationEvent(
    IN PUNICODE_STRING EventName,
    OUT PHANDLE EventHandle
    );

NTKERNELAPI
NTSTATUS
IoCreateSymbolicLink(
    IN PUNICODE_STRING SymbolicLinkName,
    IN PUNICODE_STRING DeviceName
    );


NTKERNELAPI
NTSTATUS
IoCreateUnprotectedSymbolicLink(
    IN PUNICODE_STRING SymbolicLinkName,
    IN PUNICODE_STRING DeviceName
    );


NTKERNELAPI
VOID
IoDeleteDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
NTSTATUS
IoDeleteSymbolicLink(
    IN PUNICODE_STRING SymbolicLinkName
    );

NTKERNELAPI
VOID
IoDetachDevice(
    IN OUT PDEVICE_OBJECT TargetDevice
    );



NTKERNELAPI
VOID
IoDisconnectInterrupt(
    IN PKINTERRUPT InterruptObject
    );


NTKERNELAPI
VOID
IoFreeIrp(
    IN PIRP Irp
    );

NTKERNELAPI
VOID
IoFreeMdl(
    IN PMDL Mdl
    );

NTKERNELAPI                                 
PDEVICE_OBJECT                              
IoGetAttachedDeviceReference(               
    IN PDEVICE_OBJECT DeviceObject          
    );                                      
                                            

//++
//
// PIO_STACK_LOCATION
// IoGetCurrentIrpStackLocation(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to return a pointer to the current stack location
//     in an I/O Request Packet (IRP).
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     The function value is a pointer to the current stack location in the
//     packet.
//
//--

#define IoGetCurrentIrpStackLocation( Irp ) ( (Irp)->Tail.Overlay.CurrentStackLocation )


NTKERNELAPI
PVOID
IoGetDriverObjectExtension(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID ClientIdentificationAddress
    );

NTKERNELAPI
PEPROCESS
IoGetCurrentProcess(
    VOID
    );



NTKERNELAPI
NTSTATUS
IoGetDeviceObjectPointer(
    IN PUNICODE_STRING ObjectName,
    IN ACCESS_MASK DesiredAccess,
    OUT PFILE_OBJECT *FileObject,
    OUT PDEVICE_OBJECT *DeviceObject
    );

NTKERNELAPI
struct _DMA_ADAPTER *
IoGetDmaAdapter(
    IN PDEVICE_OBJECT PhysicalDeviceObject,           
    IN struct _DEVICE_DESCRIPTION *DeviceDescription,
    IN OUT PULONG NumberOfMapRegisters
    );


//++
//
// ULONG
// IoGetFunctionCodeFromCtlCode(
//     IN ULONG ControlCode
//     )
//
// Routine Description:
//
//     This routine extracts the function code from IOCTL and FSCTL function
//     control codes.
//     This routine should only be used by kernel mode code.
//
// Arguments:
//
//     ControlCode - A function control code (IOCTL or FSCTL) from which the
//         function code must be extracted.
//
// Return Value:
//
//     The extracted function code.
//
// Note:
//
//     The CTL_CODE macro, used to create IOCTL and FSCTL function control
//     codes, is defined in ntioapi.h
//
//--

#define IoGetFunctionCodeFromCtlCode( ControlCode ) (\
    ( ControlCode >> 2) & 0x00000FFF )


//++
//
// PIO_STACK_LOCATION
// IoGetNextIrpStackLocation(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to return a pointer to the next stack location
//     in an I/O Request Packet (IRP).
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     The function value is a pointer to the next stack location in the packet.
//
//--

#define IoGetNextIrpStackLocation( Irp ) (\
    (Irp)->Tail.Overlay.CurrentStackLocation - 1 )

NTKERNELAPI
PDEVICE_OBJECT
IoGetRelatedDeviceObject(
    IN PFILE_OBJECT FileObject
    );


//++
//
// VOID
// IoInitializeDpcRequest(
//     IN PDEVICE_OBJECT DeviceObject,
//     IN PIO_DPC_ROUTINE DpcRoutine
//     )
//
// Routine Description:
//
//     This routine is invoked to initialize the DPC in a device object for a
//     device driver during its initialization routine.  The DPC is used later
//     when the driver interrupt service routine requests that a DPC routine
//     be queued for later execution.
//
// Arguments:
//
//     DeviceObject - Pointer to the device object that the request is for.
//
//     DpcRoutine - Address of the driver's DPC routine to be executed when
//         the DPC is dequeued for processing.
//
// Return Value:
//
//     None.
//
//--

#define IoInitializeDpcRequest( DeviceObject, DpcRoutine ) (\
    KeInitializeDpc( &(DeviceObject)->Dpc,                  \
                     (PKDEFERRED_ROUTINE) (DpcRoutine),     \
                     (DeviceObject) ) )

NTKERNELAPI
VOID
IoInitializeIrp(
    IN OUT PIRP Irp,
    IN USHORT PacketSize,
    IN CCHAR StackSize
    );

NTKERNELAPI
NTSTATUS
IoInitializeTimer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_TIMER_ROUTINE TimerRoutine,
    IN PVOID Context
    );


//++
//
// BOOLEAN
// IoIsErrorUserInduced(
//     IN NTSTATUS Status
//     )
//
// Routine Description:
//
//     This routine is invoked to determine if an error was as a
//     result of user actions.  Typically these error are related
//     to removable media and will result in a pop-up.
//
// Arguments:
//
//     Status - The status value to check.
//
// Return Value:
//     The function value is TRUE if the user induced the error,
//     otherwise FALSE is returned.
//
//--
#define IoIsErrorUserInduced( Status ) ((BOOLEAN)  \
    (((Status) == STATUS_DEVICE_NOT_READY) ||      \
     ((Status) == STATUS_IO_TIMEOUT) ||            \
     ((Status) == STATUS_MEDIA_WRITE_PROTECTED) || \
     ((Status) == STATUS_NO_MEDIA_IN_DEVICE) ||    \
     ((Status) == STATUS_VERIFY_REQUIRED) ||       \
     ((Status) == STATUS_UNRECOGNIZED_MEDIA) ||    \
     ((Status) == STATUS_WRONG_VOLUME)))


//++
//
// VOID
// IoMarkIrpPending(
//     IN OUT PIRP Irp
//     )
//
// Routine Description:
//
//     This routine marks the specified I/O Request Packet (IRP) to indicate
//     that an initial status of STATUS_PENDING was returned to the caller.
//     This is used so that I/O completion can determine whether or not to
//     fully complete the I/O operation requested by the packet.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet to be marked pending.
//
// Return Value:
//
//     None.
//
//--

#define IoMarkIrpPending( Irp ) ( \
    IoGetCurrentIrpStackLocation( (Irp) )->Control |= SL_PENDING_RETURNED )


NTKERNELAPI
VOID
IoReleaseCancelSpinLock(
    IN KIRQL Irql
    );


//++
//
// VOID
// IoRequestDpc(
//     IN PDEVICE_OBJECT DeviceObject,
//     IN PIRP Irp,
//     IN PVOID Context
//     )
//
// Routine Description:
//
//     This routine is invoked by the device driver's interrupt service routine
//     to request that a DPC routine be queued for later execution at a lower
//     IRQL.
//
// Arguments:
//
//     DeviceObject - Device object for which the request is being processed.
//
//     Irp - Pointer to the current I/O Request Packet (IRP) for the specified
//         device.
//
//     Context - Provides a general context parameter to be passed to the
//         DPC routine.
//
// Return Value:
//
//     None.
//
//--

#define IoRequestDpc( DeviceObject, Irp, Context ) ( \
    KeInsertQueueDpc( &(DeviceObject)->Dpc, (Irp), (Context) ) )

//++
//
// PDRIVER_CANCEL
// IoSetCancelRoutine(
//     IN PIRP Irp,
//     IN PDRIVER_CANCEL CancelRoutine
//     )
//
// Routine Description:
//
//     This routine is invoked to set the address of a cancel routine which
//     is to be invoked when an I/O packet has been canceled.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet itself.
//
//     CancelRoutine - Address of the cancel routine that is to be invoked
//         if the IRP is cancelled.
//
// Return Value:
//
//     Previous value of CancelRoutine field in the IRP.
//
//--

#define IoSetCancelRoutine( Irp, NewCancelRoutine ) (  \
    (PDRIVER_CANCEL) InterlockedExchangePointer( (PVOID *) &(Irp)->CancelRoutine, (PVOID) (NewCancelRoutine) ) )

//++
//
// VOID
// IoSetCompletionRoutine(
//     IN PIRP Irp,
//     IN PIO_COMPLETION_ROUTINE CompletionRoutine,
//     IN PVOID Context,
//     IN BOOLEAN InvokeOnSuccess,
//     IN BOOLEAN InvokeOnError,
//     IN BOOLEAN InvokeOnCancel
//     )
//
// Routine Description:
//
//     This routine is invoked to set the address of a completion routine which
//     is to be invoked when an I/O packet has been completed by a lower-level
//     driver.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet itself.
//
//     CompletionRoutine - Address of the completion routine that is to be
//         invoked once the next level driver completes the packet.
//
//     Context - Specifies a context parameter to be passed to the completion
//         routine.
//
//     InvokeOnSuccess - Specifies that the completion routine is invoked when the
//         operation is successfully completed.
//
//     InvokeOnError - Specifies that the completion routine is invoked when the
//         operation completes with an error status.
//
//     InvokeOnCancel - Specifies that the completion routine is invoked when the
//         operation is being canceled.
//
// Return Value:
//
//     None.
//
//--

#define IoSetCompletionRoutine( Irp, Routine, CompletionContext, Success, Error, Cancel ) { \
    PIO_STACK_LOCATION irpSp;                                               \
    ASSERT( (Success) | (Error) | (Cancel) ? (Routine) != NULL : TRUE );    \
    irpSp = IoGetNextIrpStackLocation( (Irp) );                             \
    irpSp->CompletionRoutine = (Routine);                                   \
    irpSp->Context = (CompletionContext);                                   \
    irpSp->Control = 0;                                                     \
    if ((Success)) { irpSp->Control = SL_INVOKE_ON_SUCCESS; }               \
    if ((Error)) { irpSp->Control |= SL_INVOKE_ON_ERROR; }                  \
    if ((Cancel)) { irpSp->Control |= SL_INVOKE_ON_CANCEL; } }


//++
//
// VOID
// IoSetNextIrpStackLocation (
//     IN OUT PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to set the current IRP stack location to
//     the next stack location, i.e. it "pushes" the stack.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet (IRP).
//
// Return Value:
//
//     None.
//
//--

#define IoSetNextIrpStackLocation( Irp ) {      \
    (Irp)->CurrentLocation--;                   \
    (Irp)->Tail.Overlay.CurrentStackLocation--; }

//++
//
// VOID
// IoCopyCurrentIrpStackLocationToNext(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to copy the IRP stack arguments and file
//     pointer from the current IrpStackLocation to the next
//     in an I/O Request Packet (IRP).
//
//     If the caller wants to call IoCallDriver with a completion routine
//     but does not wish to change the arguments otherwise,
//     the caller first calls IoCopyCurrentIrpStackLocationToNext,
//     then IoSetCompletionRoutine, then IoCallDriver.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     None.
//
//--

#define IoCopyCurrentIrpStackLocationToNext( Irp ) { \
    PIO_STACK_LOCATION irpSp; \
    PIO_STACK_LOCATION nextIrpSp; \
    irpSp = IoGetCurrentIrpStackLocation( (Irp) ); \
    nextIrpSp = IoGetNextIrpStackLocation( (Irp) ); \
    RtlCopyMemory( nextIrpSp, irpSp, FIELD_OFFSET(IO_STACK_LOCATION, CompletionRoutine)); \
    nextIrpSp->Control = 0; }

//++
//
// VOID
// IoSkipCurrentIrpStackLocation (
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to increment the current stack location of
//     a given IRP.
//
//     If the caller wishes to call the next driver in a stack, and does not
//     wish to change the arguments, nor does he wish to set a completion
//     routine, then the caller first calls IoSkipCurrentIrpStackLocation
//     and the calls IoCallDriver.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     None
//
//--

#define IoSkipCurrentIrpStackLocation( Irp ) \
    (Irp)->CurrentLocation++; \
    (Irp)->Tail.Overlay.CurrentStackLocation++;


NTKERNELAPI
VOID
IoSetShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    OUT PSHARE_ACCESS ShareAccess
    );



typedef struct _IO_REMOVE_LOCK_TRACKING_BLOCK * PIO_REMOVE_LOCK_TRACKING_BLOCK;

typedef struct _IO_REMOVE_LOCK_COMMON_BLOCK {
    BOOLEAN     Removed;
    BOOLEAN     Reserved [3];
    LONG        IoCount;
    KEVENT      RemoveEvent;

} IO_REMOVE_LOCK_COMMON_BLOCK;

typedef struct _IO_REMOVE_LOCK_DBG_BLOCK {
    LONG        Signature;
    LONG        HighWatermark;
    LONGLONG    MaxLockedTicks;
    LONG        AllocateTag;
    LIST_ENTRY  LockList;
    KSPIN_LOCK  Spin;
    LONG        LowMemoryCount;
    ULONG       Reserved1[4];
    PVOID       Reserved2;
    PIO_REMOVE_LOCK_TRACKING_BLOCK Blocks;
} IO_REMOVE_LOCK_DBG_BLOCK;

typedef struct _IO_REMOVE_LOCK {
    IO_REMOVE_LOCK_COMMON_BLOCK Common;
#if DBG
    IO_REMOVE_LOCK_DBG_BLOCK Dbg;
#endif
} IO_REMOVE_LOCK, *PIO_REMOVE_LOCK;

#define IoInitializeRemoveLock(Lock, Tag, Maxmin, HighWater) \
        IoInitializeRemoveLockEx (Lock, Tag, Maxmin, HighWater, sizeof (IO_REMOVE_LOCK))

NTSYSAPI
VOID
NTAPI
IoInitializeRemoveLockEx(
    IN  PIO_REMOVE_LOCK Lock,
    IN  ULONG   AllocateTag, // Used only on checked kernels
    IN  ULONG   MaxLockedMinutes, // Used only on checked kernels
    IN  ULONG   HighWatermark, // Used only on checked kernels
    IN  ULONG   RemlockSize // are we checked or free
    );
//
//  Initialize a remove lock.
//
//  Note: Allocation for remove locks needs to be within the device extension,
//  so that the memory for this structure stays allocated until such time as the
//  device object itself is deallocated.
//

#define IoAcquireRemoveLock(RemoveLock, Tag) \
        IoAcquireRemoveLockEx(RemoveLock, Tag, __FILE__, __LINE__, sizeof (IO_REMOVE_LOCK))

NTSYSAPI
NTSTATUS
NTAPI
IoAcquireRemoveLockEx (
    IN PIO_REMOVE_LOCK RemoveLock,
    IN OPTIONAL PVOID   Tag, // Optional
    IN PCSTR            File,
    IN ULONG            Line,
    IN ULONG            RemlockSize // are we checked or free
    );

//
// Routine Description:
//
//    This routine is called to acquire the remove lock for a device object.
//    While the lock is held, the caller can assume that no pending pnp REMOVE
//    requests will be completed.
//
//    The lock should be acquired immediately upon entering a dispatch routine.
//    It should also be acquired before creating any new reference to the
//    device object if there's a chance of releasing the reference before the
//    new one is done, in addition to references to the driver code itself,
//    which is removed from memory when the last device object goes.
//
//    Arguments:
//
//    RemoveLock - A pointer to an initialized REMOVE_LOCK structure.
//
//    Tag - Used for tracking lock allocation and release.  The same tag
//          specified when acquiring the lock must be used to release the lock.
//          Tags are only checked in checked versions of the driver.
//
//    File - set to __FILE__ as the location in the code where the lock was taken.
//
//    Line - set to __LINE__.
//
// Return Value:
//
//    Returns whether or not the remove lock was obtained.
//    If successful the caller should continue with work calling
//    IoReleaseRemoveLock when finished.
//
//    If not successful the lock was not obtained.  The caller should abort the
//    work but not call IoReleaseRemoveLock.
//

#define IoReleaseRemoveLock(RemoveLock, Tag) \
        IoReleaseRemoveLockEx(RemoveLock, Tag, sizeof (IO_REMOVE_LOCK))

NTSYSAPI
VOID
NTAPI
IoReleaseRemoveLockEx(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID            Tag, // Optional
    IN ULONG            RemlockSize // are we checked or free
    );
//
//
// Routine Description:
//
//    This routine is called to release the remove lock on the device object.  It
//    must be called when finished using a previously locked reference to the
//    device object.  If an Tag was specified when acquiring the lock then the
//    same Tag must be specified when releasing the lock.
//
//    When the lock count reduces to zero, this routine will signal the waiting
//    event to release the waiting thread deleting the device object protected
//    by this lock.
//
// Arguments:
//
//    DeviceObject - the device object to lock
//
//    Tag - The TAG (if any) specified when acquiring the lock.  This is used
//          for lock tracking purposes
//
// Return Value:
//
//    none
//

#define IoReleaseRemoveLockAndWait(RemoveLock, Tag) \
        IoReleaseRemoveLockAndWaitEx(RemoveLock, Tag, sizeof (IO_REMOVE_LOCK))

NTSYSAPI
VOID
NTAPI
IoReleaseRemoveLockAndWaitEx(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID            Tag,
    IN ULONG            RemlockSize // are we checked or free
    );
//
//
// Routine Description:
//
//    This routine is called when the client would like to delete the
//    remove-locked resource.  This routine will block until all the remove
//    locks have released.
//
//    This routine MUST be called after acquiring the lock.
//
// Arguments:
//
//    RemoveLock
//
// Return Value:
//
//    none
//


//++
//
// USHORT
// IoSizeOfIrp(
//     IN CCHAR StackSize
//     )
//
// Routine Description:
//
//     Determines the size of an IRP given the number of stack locations
//     the IRP will have.
//
// Arguments:
//
//     StackSize - Number of stack locations for the IRP.
//
// Return Value:
//
//     Size in bytes of the IRP.
//
//--

#define IoSizeOfIrp( StackSize ) \
    ((USHORT) (sizeof( IRP ) + ((StackSize) * (sizeof( IO_STACK_LOCATION )))))




NTKERNELAPI
VOID
IoStartNextPacket(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Cancelable
    );

NTKERNELAPI
VOID
IoStartNextPacketByKey(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Cancelable,
    IN ULONG Key
    );

NTKERNELAPI
VOID
IoStartPacket(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PULONG Key OPTIONAL,
    IN PDRIVER_CANCEL CancelFunction OPTIONAL
    );



NTKERNELAPI
VOID
IoStartTimer(
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
VOID
IoStopTimer(
    IN PDEVICE_OBJECT DeviceObject
    );


NTKERNELAPI
VOID
IoUnregisterShutdownNotification(
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI                                     
VOID                                            
IoWriteErrorLogEntry(                           
    IN PVOID ElEntry                            
    );                                          

typedef struct _IO_WORKITEM *PIO_WORKITEM;

typedef
VOID
(*PIO_WORKITEM_ROUTINE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

PIO_WORKITEM
IoAllocateWorkItem(
    PDEVICE_OBJECT DeviceObject
    );

VOID
IoFreeWorkItem(
    PIO_WORKITEM IoWorkItem
    );

VOID
IoQueueWorkItem(
    IN PIO_WORKITEM IoWorkItem,
    IN PIO_WORKITEM_ROUTINE WorkerRoutine,
    IN WORK_QUEUE_TYPE QueueType,
    IN PVOID Context
    );





NTKERNELAPI
NTSTATUS
IoWMIRegistrationControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG Action
);

//
// Action code for IoWMIRetgistrationControl api
//

#define WMIREG_ACTION_REGISTER      1
#define WMIREG_ACTION_DEREGISTER    2
#define WMIREG_ACTION_REREGISTER    3
#define WMIREG_ACTION_UPDATE_GUIDS  4
#define WMIREG_ACTION_BLOCK_IRPS    5

//
// Code passed in IRP_MN_REGINFO WMI irp
//

#define WMIREGISTER                 0
#define WMIUPDATE                   1

NTKERNELAPI
NTSTATUS
IoWMIAllocateInstanceIds(
    IN GUID *Guid,
    IN ULONG InstanceCount,
    OUT ULONG *FirstInstanceId
    );

NTKERNELAPI
NTSTATUS
IoWMISuggestInstanceName(
    IN PDEVICE_OBJECT PhysicalDeviceObject OPTIONAL,
    IN PUNICODE_STRING SymbolicLinkName OPTIONAL,
    IN BOOLEAN CombineNames,
    OUT PUNICODE_STRING SuggestedInstanceName
    );

NTKERNELAPI
NTSTATUS
IoWMIWriteEvent(
    IN PVOID WnodeEventItem
    );

#if defined(_WIN64)
ULONG IoWMIDeviceObjectToProviderId(
    PDEVICE_OBJECT DeviceObject
    );
#else
#define IoWMIDeviceObjectToProviderId(DeviceObject) ((ULONG)(DeviceObject))
#endif

//
// Define the device description structure.
//

typedef struct _DEVICE_DESCRIPTION {
    ULONG Version;
    BOOLEAN Master;
    BOOLEAN ScatterGather;
    BOOLEAN DemandMode;
    BOOLEAN AutoInitialize;
    BOOLEAN Dma32BitAddresses;
    BOOLEAN IgnoreCount;
    BOOLEAN Reserved1;          // must be false
    BOOLEAN Dma64BitAddresses;
    ULONG DoNotUse2;
    ULONG DmaChannel;
    INTERFACE_TYPE  InterfaceType;
    DMA_WIDTH DmaWidth;
    DMA_SPEED DmaSpeed;
    ULONG MaximumLength;
    ULONG DmaPort;
} DEVICE_DESCRIPTION, *PDEVICE_DESCRIPTION;

//
// Define the supported version numbers for the device description structure.
//

#define DEVICE_DESCRIPTION_VERSION  0
#define DEVICE_DESCRIPTION_VERSION1 1

                                                
NTHALAPI                                        
VOID                                            
KeFlushWriteBuffer (                            
    VOID                                        
    );                                          
                                                
//
// Performance counter function.
//

NTHALAPI
LARGE_INTEGER
KeQueryPerformanceCounter (
   IN PLARGE_INTEGER PerformanceFrequency OPTIONAL
   );


//
// Stall processor execution function.
//

NTHALAPI
VOID
KeStallExecutionProcessor (
    IN ULONG MicroSeconds
    );


typedef struct _SCATTER_GATHER_ELEMENT {
    PHYSICAL_ADDRESS Address;
    ULONG Length;
    ULONG_PTR Reserved;
} SCATTER_GATHER_ELEMENT, *PSCATTER_GATHER_ELEMENT;

#pragma warning(disable:4200)
typedef struct _SCATTER_GATHER_LIST {
    ULONG NumberOfElements;
    ULONG_PTR Reserved;
    SCATTER_GATHER_ELEMENT Elements[];
} SCATTER_GATHER_LIST, *PSCATTER_GATHER_LIST;
#pragma warning(default:4200)



typedef struct _DMA_OPERATIONS *PDMA_OPERATIONS;

typedef struct _DMA_ADAPTER {
    USHORT Version;
    USHORT Size;
    PDMA_OPERATIONS DmaOperations;
    // Private Bus Device Driver data follows,
} DMA_ADAPTER, *PDMA_ADAPTER;

typedef VOID (*PPUT_DMA_ADAPTER)(
    PDMA_ADAPTER DmaAdapter
    );

typedef PVOID (*PALLOCATE_COMMON_BUFFER)(
    IN PDMA_ADAPTER DmaAdapter,
    IN ULONG Length,
    OUT PPHYSICAL_ADDRESS LogicalAddress,
    IN BOOLEAN CacheEnabled
    );

typedef VOID (*PFREE_COMMON_BUFFER)(
    IN PDMA_ADAPTER DmaAdapter,
    IN ULONG Length,
    IN PHYSICAL_ADDRESS LogicalAddress,
    IN PVOID VirtualAddress,
    IN BOOLEAN CacheEnabled
    );

typedef NTSTATUS (*PALLOCATE_ADAPTER_CHANNEL)(
    IN PDMA_ADAPTER DmaAdapter,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    );

typedef BOOLEAN (*PFLUSH_ADAPTER_BUFFERS)(
    IN PDMA_ADAPTER DmaAdapter,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    );

typedef VOID (*PFREE_ADAPTER_CHANNEL)(
    IN PDMA_ADAPTER DmaAdapter
    );

typedef VOID (*PFREE_MAP_REGISTERS)(
    IN PDMA_ADAPTER DmaAdapter,
    PVOID MapRegisterBase,
    ULONG NumberOfMapRegisters
    );

typedef PHYSICAL_ADDRESS (*PMAP_TRANSFER)(
    IN PDMA_ADAPTER DmaAdapter,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN OUT PULONG Length,
    IN BOOLEAN WriteToDevice
    );

typedef ULONG (*PGET_DMA_ALIGNMENT)(
    IN PDMA_ADAPTER DmaAdapter
    );

typedef ULONG (*PREAD_DMA_COUNTER)(
    IN PDMA_ADAPTER DmaAdapter
    );

typedef VOID
(*PDRIVER_LIST_CONTROL)(
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN PVOID Context
    );

typedef NTSTATUS
(*PGET_SCATTER_GATHER_LIST)(
    IN PDMA_ADAPTER DmaAdapter,
    IN PDEVICE_OBJECT DeviceObject,
    IN PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN PDRIVER_LIST_CONTROL ExecutionRoutine,
    IN PVOID Context,
    IN BOOLEAN WriteToDevice
    );

typedef VOID
(*PPUT_SCATTER_GATHER_LIST)(
    IN PDMA_ADAPTER DmaAdapter,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN BOOLEAN WriteToDevice
    );

typedef struct _DMA_OPERATIONS {
    ULONG Size;
    PPUT_DMA_ADAPTER PutDmaAdapter;
    PALLOCATE_COMMON_BUFFER AllocateCommonBuffer;
    PFREE_COMMON_BUFFER FreeCommonBuffer;
    PALLOCATE_ADAPTER_CHANNEL AllocateAdapterChannel;
    PFLUSH_ADAPTER_BUFFERS FlushAdapterBuffers;
    PFREE_ADAPTER_CHANNEL FreeAdapterChannel;
    PFREE_MAP_REGISTERS FreeMapRegisters;
    PMAP_TRANSFER MapTransfer;
    PGET_DMA_ALIGNMENT GetDmaAlignment;
    PREAD_DMA_COUNTER ReadDmaCounter;
    PGET_SCATTER_GATHER_LIST GetScatterGatherList;
    PPUT_SCATTER_GATHER_LIST PutScatterGatherList;
} DMA_OPERATIONS;


__inline
PVOID
HalAllocateCommonBuffer(
    IN PDMA_ADAPTER DmaAdapter,
    IN ULONG Length,
    OUT PPHYSICAL_ADDRESS LogicalAddress,
    IN BOOLEAN CacheEnabled
    ){

    PALLOCATE_COMMON_BUFFER allocateCommonBuffer;
    PVOID commonBuffer;

    allocateCommonBuffer = *(DmaAdapter)->DmaOperations->AllocateCommonBuffer;
    ASSERT( allocateCommonBuffer != NULL );

    commonBuffer = allocateCommonBuffer( DmaAdapter,
                                         Length,
                                         LogicalAddress,
                                         CacheEnabled );

    return commonBuffer;
}

__inline
VOID
HalFreeCommonBuffer(
    IN PDMA_ADAPTER DmaAdapter,
    IN ULONG Length,
    IN PHYSICAL_ADDRESS LogicalAddress,
    IN PVOID VirtualAddress,
    IN BOOLEAN CacheEnabled
    ){

    PFREE_COMMON_BUFFER freeCommonBuffer;

    freeCommonBuffer = *(DmaAdapter)->DmaOperations->FreeCommonBuffer;
    ASSERT( freeCommonBuffer != NULL );

    freeCommonBuffer( DmaAdapter,
                      Length,
                      LogicalAddress,
                      VirtualAddress,
                      CacheEnabled );
}

__inline
NTSTATUS
IoAllocateAdapterChannel(
    IN PDMA_ADAPTER DmaAdapter,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    ){

    PALLOCATE_ADAPTER_CHANNEL allocateAdapterChannel;
    NTSTATUS status;

    allocateAdapterChannel =
        *(DmaAdapter)->DmaOperations->AllocateAdapterChannel;

    ASSERT( allocateAdapterChannel != NULL );

    status = allocateAdapterChannel( DmaAdapter,
                                     DeviceObject,
                                     NumberOfMapRegisters,
                                     ExecutionRoutine,
                                     Context );

    return status;
}

__inline
BOOLEAN
IoFlushAdapterBuffers(
    IN PDMA_ADAPTER DmaAdapter,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    ){

    PFLUSH_ADAPTER_BUFFERS flushAdapterBuffers;
    BOOLEAN result;

    flushAdapterBuffers = *(DmaAdapter)->DmaOperations->FlushAdapterBuffers;
    ASSERT( flushAdapterBuffers != NULL );

    result = flushAdapterBuffers( DmaAdapter,
                                  Mdl,
                                  MapRegisterBase,
                                  CurrentVa,
                                  Length,
                                  WriteToDevice );
    return result;
}

__inline
VOID
IoFreeAdapterChannel(
    IN PDMA_ADAPTER DmaAdapter
    ){

    PFREE_ADAPTER_CHANNEL freeAdapterChannel;

    freeAdapterChannel = *(DmaAdapter)->DmaOperations->FreeAdapterChannel;
    ASSERT( freeAdapterChannel != NULL );

    freeAdapterChannel( DmaAdapter );
}

__inline
VOID
IoFreeMapRegisters(
    IN PDMA_ADAPTER DmaAdapter,
    IN PVOID MapRegisterBase,
    IN ULONG NumberOfMapRegisters
    ){

    PFREE_MAP_REGISTERS freeMapRegisters;

    freeMapRegisters = *(DmaAdapter)->DmaOperations->FreeMapRegisters;
    ASSERT( freeMapRegisters != NULL );

    freeMapRegisters( DmaAdapter,
                      MapRegisterBase,
                      NumberOfMapRegisters );
}


__inline
PHYSICAL_ADDRESS
IoMapTransfer(
    IN PDMA_ADAPTER DmaAdapter,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN OUT PULONG Length,
    IN BOOLEAN WriteToDevice
    ){

    PHYSICAL_ADDRESS physicalAddress;
    PMAP_TRANSFER mapTransfer;

    mapTransfer = *(DmaAdapter)->DmaOperations->MapTransfer;
    ASSERT( mapTransfer != NULL );

    physicalAddress = mapTransfer( DmaAdapter,
                                   Mdl,
                                   MapRegisterBase,
                                   CurrentVa,
                                   Length,
                                   WriteToDevice );

    return physicalAddress;
}

__inline
ULONG
HalGetDmaAlignment(
    IN PDMA_ADAPTER DmaAdapter
    )
{
    PGET_DMA_ALIGNMENT getDmaAlignment;
    ULONG alignment;

    getDmaAlignment = *(DmaAdapter)->DmaOperations->GetDmaAlignment;
    ASSERT( getDmaAlignment != NULL );

    alignment = getDmaAlignment( DmaAdapter );
    return alignment;
}

__inline
ULONG
HalReadDmaCounter(
    IN PDMA_ADAPTER DmaAdapter
    )
{
    PREAD_DMA_COUNTER readDmaCounter;
    ULONG counter;

    readDmaCounter = *(DmaAdapter)->DmaOperations->ReadDmaCounter;
    ASSERT( readDmaCounter != NULL );

    counter = readDmaCounter( DmaAdapter );
    return counter;
}


//
// Define PnP Device Property for IoGetDeviceProperty
//

typedef enum {
    DevicePropertyDeviceDescription,
    DevicePropertyHardwareID,
    DevicePropertyCompatibleIDs,
    DevicePropertyBootConfiguration,
    DevicePropertyBootConfigurationTranslated,
    DevicePropertyClassName,
    DevicePropertyClassGuid,
    DevicePropertyDriverKeyName,
    DevicePropertyManufacturer,
    DevicePropertyFriendlyName,
    DevicePropertyLocationInformation,
    DevicePropertyPhysicalDeviceObjectName,
    DevicePropertyBusTypeGuid,
    DevicePropertyLegacyBusType,
    DevicePropertyBusNumber,
    DevicePropertyEnumeratorName,
    DevicePropertyAddress,
    DevicePropertyUINumber
} DEVICE_REGISTRY_PROPERTY;

typedef BOOLEAN (*PTRANSLATE_BUS_ADDRESS)(
    IN PVOID Context,
    IN PHYSICAL_ADDRESS BusAddress,
    IN ULONG Length,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

typedef struct _DMA_ADAPTER *(*PGET_DMA_ADAPTER)(
    IN PVOID Context,
    IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    );

typedef ULONG (*PGET_SET_DEVICE_DATA)(
    IN PVOID Context,
    IN ULONG DataType,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

//
// Define structure returned in response to IRP_MN_QUERY_BUS_INFORMATION by a
// PDO indicating the type of bus the device exists on.
//

typedef struct _PNP_BUS_INFORMATION {
    GUID BusTypeGuid;
    INTERFACE_TYPE LegacyBusType;
    ULONG BusNumber;
} PNP_BUS_INFORMATION, *PPNP_BUS_INFORMATION;

//
// Define structure returned in response to IRP_MN_QUERY_LEGACY_BUS_INFORMATION
// by an FDO indicating the type of bus it is.  This is normally the same bus
// type as the device's children (i.e., as retrieved from the child PDO's via
// IRP_MN_QUERY_BUS_INFORMATION) except for cases like CardBus, which can
// support both 16-bit (PCMCIABus) and 32-bit (PCIBus) cards.
//

typedef struct _LEGACY_BUS_INFORMATION {
    GUID BusTypeGuid;
    INTERFACE_TYPE LegacyBusType;
    ULONG BusNumber;
} LEGACY_BUS_INFORMATION, *PLEGACY_BUS_INFORMATION;

typedef struct _BUS_INTERFACE_STANDARD {
    //
    // generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    //
    // standard bus interfaces
    //
    PTRANSLATE_BUS_ADDRESS TranslateBusAddress;
    PGET_DMA_ADAPTER GetDmaAdapter;
    PGET_SET_DEVICE_DATA SetBusData;
    PGET_SET_DEVICE_DATA GetBusData;

} BUS_INTERFACE_STANDARD, *PBUS_INTERFACE_STANDARD;

//
// The following definitions are used in ACPI QueryInterface
//
typedef BOOLEAN (* PGPE_SERVICE_ROUTINE) (
                            PVOID,
                            PVOID);

typedef NTSTATUS (* PGPE_CONNECT_VECTOR) (
                            PDEVICE_OBJECT,
                            ULONG,
                            KINTERRUPT_MODE,
                            BOOLEAN,
                            PGPE_SERVICE_ROUTINE,
                            PVOID,
                            PVOID);

typedef NTSTATUS (* PGPE_DISCONNECT_VECTOR) (
                            PVOID);

typedef NTSTATUS (* PGPE_ENABLE_EVENT) (
                            PDEVICE_OBJECT,
                            PVOID);

typedef NTSTATUS (* PGPE_DISABLE_EVENT) (
                            PDEVICE_OBJECT,
                            PVOID);

typedef NTSTATUS (* PGPE_CLEAR_STATUS) (
                            PDEVICE_OBJECT,
                            PVOID);

typedef VOID (* PDEVICE_NOTIFY_CALLBACK) (
                            PVOID,
                            ULONG);

typedef NTSTATUS (* PREGISTER_FOR_DEVICE_NOTIFICATIONS) (
                            PDEVICE_OBJECT,
                            PDEVICE_NOTIFY_CALLBACK,
                            PVOID);

typedef void (* PUNREGISTER_FOR_DEVICE_NOTIFICATIONS) (
                            PDEVICE_OBJECT,
                            PDEVICE_NOTIFY_CALLBACK);

typedef struct _ACPI_INTERFACE_STANDARD {
    //
    // Generic interface header
    //
    USHORT                  Size;
    USHORT                  Version;
    PVOID                   Context;
    PINTERFACE_REFERENCE    InterfaceReference;
    PINTERFACE_DEREFERENCE  InterfaceDereference;
    //
    // ACPI interfaces
    //
    PGPE_CONNECT_VECTOR                     GpeConnectVector;
    PGPE_DISCONNECT_VECTOR                  GpeDisconnectVector;
    PGPE_ENABLE_EVENT                       GpeEnableEvent;
    PGPE_DISABLE_EVENT                      GpeDisableEvent;
    PGPE_CLEAR_STATUS                       GpeClearStatus;
    PREGISTER_FOR_DEVICE_NOTIFICATIONS      RegisterForDeviceNotifications;
    PUNREGISTER_FOR_DEVICE_NOTIFICATIONS    UnregisterForDeviceNotifications;

} ACPI_INTERFACE_STANDARD, *PACPI_INTERFACE_STANDARD;


NTKERNELAPI
VOID
IoInvalidateDeviceRelations(
    IN PDEVICE_OBJECT DeviceObject,
    IN DEVICE_RELATION_TYPE Type
    );

NTKERNELAPI
VOID
IoRequestDeviceEject(
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTKERNELAPI
NTSTATUS
IoGetDeviceProperty(
    IN PDEVICE_OBJECT DeviceObject,
    IN DEVICE_REGISTRY_PROPERTY DeviceProperty,
    IN ULONG BufferLength,
    OUT PVOID PropertyBuffer,
    OUT PULONG ResultLength
    );

//
// The following definitions are used in IoOpenDeviceRegistryKey
//

#define PLUGPLAY_REGKEY_DEVICE  1
#define PLUGPLAY_REGKEY_DRIVER  2
#define PLUGPLAY_REGKEY_CURRENT_HWPROFILE 4

NTKERNELAPI
NTSTATUS
IoOpenDeviceRegistryKey(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG DevInstKeyType,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE DevInstRegKey
    );

NTKERNELAPI
NTSTATUS
NTAPI
IoRegisterDeviceInterface(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN CONST GUID *InterfaceClassGuid,
    IN PUNICODE_STRING ReferenceString,     OPTIONAL
    OUT PUNICODE_STRING SymbolicLinkName
    );

NTKERNELAPI
NTSTATUS
IoOpenDeviceInterfaceRegistryKey(
    IN PUNICODE_STRING SymbolicLinkName,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE DeviceInterfaceKey
    );



NTKERNELAPI
NTSTATUS
IoSetDeviceInterfaceState(
    IN PUNICODE_STRING SymbolicLinkName,
    IN BOOLEAN Enable
    );



NTKERNELAPI
NTSTATUS
NTAPI
IoGetDeviceInterfaces(
    IN CONST GUID *InterfaceClassGuid,
    IN PDEVICE_OBJECT PhysicalDeviceObject OPTIONAL,
    IN ULONG Flags,
    OUT PWSTR *SymbolicLinkList
    );

#define DEVICE_INTERFACE_INCLUDE_NONACTIVE   0x00000001

NTKERNELAPI
NTSTATUS
NTAPI
IoGetDeviceInterfaceAlias(
    IN PUNICODE_STRING SymbolicLinkName,
    IN CONST GUID *AliasInterfaceClassGuid,
    OUT PUNICODE_STRING AliasSymbolicLinkName
    );

//
// Define PnP notification event categories
//

typedef enum _IO_NOTIFICATION_EVENT_CATEGORY {
    EventCategoryReserved,
    EventCategoryHardwareProfileChange,
    EventCategoryDeviceInterfaceChange,
    EventCategoryTargetDeviceChange
} IO_NOTIFICATION_EVENT_CATEGORY;

//
// Define flags that modify the behavior of IoRegisterPlugPlayNotification
// for the various event categories...
//

#define PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES    0x00000001

typedef
NTSTATUS
(*PDRIVER_NOTIFICATION_CALLBACK_ROUTINE) (
    IN PVOID NotificationStructure,
    IN PVOID Context
);


NTKERNELAPI
NTSTATUS
IoRegisterPlugPlayNotification(
    IN IO_NOTIFICATION_EVENT_CATEGORY EventCategory,
    IN ULONG EventCategoryFlags,
    IN PVOID EventCategoryData OPTIONAL,
    IN PDRIVER_OBJECT DriverObject,
    IN PDRIVER_NOTIFICATION_CALLBACK_ROUTINE CallbackRoutine,
    IN PVOID Context,
    OUT PVOID *NotificationEntry
    );

NTKERNELAPI
NTSTATUS
IoUnregisterPlugPlayNotification(
    IN PVOID NotificationEntry
    );

NTKERNELAPI
NTSTATUS
IoReportTargetDeviceChange(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PVOID NotificationStructure  // always begins with a PLUGPLAY_NOTIFICATION_HEADER
    );

typedef
VOID
(*PDEVICE_CHANGE_COMPLETE_CALLBACK)(
    IN PVOID Context
    );

NTKERNELAPI
VOID
IoInvalidateDeviceState(
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

#define IoAdjustPagingPathCount(_count_,_paging_) {     \
    if (_paging_) {                                     \
        InterlockedIncrement(_count_);                  \
    } else {                                            \
        InterlockedDecrement(_count_);                  \
    }                                                   \
}



//
// Header structure for all Plug&Play notification events...
//

typedef struct _PLUGPLAY_NOTIFICATION_HEADER {
    USHORT Version; // presently at version 1.
    USHORT Size;    // size (in bytes) of header + event-specific data.
    GUID Event;
    //
    // Event-specific stuff starts here.
    //
} PLUGPLAY_NOTIFICATION_HEADER, *PPLUGPLAY_NOTIFICATION_HEADER;

//
// Notification structure for all EventCategoryHardwareProfileChange events...
//

typedef struct _HWPROFILE_CHANGE_NOTIFICATION {
    USHORT Version;
    USHORT Size;
    GUID Event;
    //
    // (No event-specific data)
    //
} HWPROFILE_CHANGE_NOTIFICATION, *PHWPROFILE_CHANGE_NOTIFICATION;


//
// Notification structure for all EventCategoryDeviceInterfaceChange events...
//

typedef struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION {
    USHORT Version;
    USHORT Size;
    GUID Event;
    //
    // Event-specific data
    //
    GUID InterfaceClassGuid;
    PUNICODE_STRING SymbolicLinkName;
} DEVICE_INTERFACE_CHANGE_NOTIFICATION, *PDEVICE_INTERFACE_CHANGE_NOTIFICATION;


//
// Notification structures for EventCategoryTargetDeviceChange...
//

//
// The following structure is used for TargetDeviceQueryRemove,
// TargetDeviceRemoveCancelled, and TargetDeviceRemoveComplete:
//
typedef struct _TARGET_DEVICE_REMOVAL_NOTIFICATION {
    USHORT Version;
    USHORT Size;
    GUID Event;
    //
    // Event-specific data
    //
    PFILE_OBJECT FileObject;
} TARGET_DEVICE_REMOVAL_NOTIFICATION, *PTARGET_DEVICE_REMOVAL_NOTIFICATION;

//
// The following structure header is used for all other (i.e., 3rd-party)
// target device change events.  The structure accommodates both a
// variable-length binary data buffer, and a variable-length unicode text
// buffer.  The header must indicate where the text buffer begins, so that
// the data can be delivered in the appropriate format (ANSI or Unicode)
// to user-mode recipients (i.e., that have registered for handle-based
// notification via RegisterDeviceNotification).
//

typedef struct _TARGET_DEVICE_CUSTOM_NOTIFICATION {
    USHORT Version;
    USHORT Size;
    GUID Event;
    //
    // Event-specific data
    //
    PFILE_OBJECT FileObject;    // This field must be set to NULL by callers of
                                // IoReportTargetDeviceChange.  Clients that
                                // have registered for target device change
                                // notification on the affected PDO will be
                                // called with this field set to the file object
                                // they specified during registration.
                                //
    LONG NameBufferOffset;      // offset (in bytes) from beginning of
                                // CustomDataBuffer where text begins (-1 if none)
                                //
    UCHAR CustomDataBuffer[1];  // variable-length buffer, containing (optionally)
                                // a binary data at the start of the buffer,
                                // followed by an optional unicode text buffer
                                // (word-aligned).
                                //
} TARGET_DEVICE_CUSTOM_NOTIFICATION, *PTARGET_DEVICE_CUSTOM_NOTIFICATION;


NTKERNELAPI
VOID
PoSetSystemState (
    IN EXECUTION_STATE Flags
    );

NTKERNELAPI
PVOID
PoRegisterSystemState (
    IN PVOID StateHandle,
    IN EXECUTION_STATE Flags
    );

typedef
VOID
(*PREQUEST_POWER_COMPLETE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTKERNELAPI
NTSTATUS
PoRequestPowerIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PREQUEST_POWER_COMPLETE CompletionFunction,
    IN PVOID Context,
    OUT PIRP *Irp OPTIONAL
    );

NTKERNELAPI
VOID
PoUnregisterSystemState (
    IN PVOID StateHandle
    );


NTKERNELAPI
POWER_STATE
PoSetPowerState (
    IN PDEVICE_OBJECT   DeviceObject,
    IN POWER_STATE_TYPE Type,
    IN POWER_STATE      State
    );

NTKERNELAPI
NTSTATUS
PoCallDriver (
    IN PDEVICE_OBJECT   DeviceObject,
    IN OUT PIRP         Irp
    );

NTKERNELAPI
VOID
PoStartNextPowerIrp(
    IN PIRP    Irp
    );


NTKERNELAPI
PULONG
PoRegisterDeviceForIdleDetection (
    IN PDEVICE_OBJECT     DeviceObject,
    IN ULONG              ConservationIdleTime,
    IN ULONG              PerformanceIdleTime,
    IN DEVICE_POWER_STATE State
    );

#define PoSetDeviceBusy(IdlePointer) \
    *IdlePointer = 0

//
// \Callback\PowerState values
//

#define PO_CB_SYSTEM_POWER_POLICY   0
#define PO_CB_AC_STATUS             1
#define PO_CB_BUTTON_COLLISION      2
#define PO_CB_SYSTEM_STATE_LOCK     3


//
// Object Manager types
//

typedef struct _OBJECT_HANDLE_INFORMATION {
    ULONG HandleAttributes;
    ACCESS_MASK GrantedAccess;
} OBJECT_HANDLE_INFORMATION, *POBJECT_HANDLE_INFORMATION;

NTKERNELAPI                                                     
NTSTATUS                                                        
ObReferenceObjectByHandle(                                      
    IN HANDLE Handle,                                           
    IN ACCESS_MASK DesiredAccess,                               
    IN POBJECT_TYPE ObjectType OPTIONAL,                        
    IN KPROCESSOR_MODE AccessMode,                              
    OUT PVOID *Object,                                          
    OUT POBJECT_HANDLE_INFORMATION HandleInformation OPTIONAL   
    );                                                          

#define ObDereferenceObject(a)                                     \
        ObfDereferenceObject(a)

#define ObReferenceObject(Object) ObfReferenceObject(Object)

NTKERNELAPI
VOID
FASTCALL
ObfReferenceObject(
    IN PVOID Object
    );


NTKERNELAPI
NTSTATUS
ObReferenceObjectByPointer(
    IN PVOID Object,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_TYPE ObjectType,
    IN KPROCESSOR_MODE AccessMode
    );

NTKERNELAPI
VOID
FASTCALL
ObfDereferenceObject(
    IN PVOID Object
    );


typedef struct _PCI_SLOT_NUMBER {
    union {
        struct {
            ULONG   DeviceNumber:5;
            ULONG   FunctionNumber:3;
            ULONG   Reserved:24;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;


#define PCI_TYPE0_ADDRESSES             6
#define PCI_TYPE1_ADDRESSES             2
#define PCI_TYPE2_ADDRESSES             5

typedef struct _PCI_COMMON_CONFIG {
    USHORT  VendorID;                   // (ro)
    USHORT  DeviceID;                   // (ro)
    USHORT  Command;                    // Device control
    USHORT  Status;
    UCHAR   RevisionID;                 // (ro)
    UCHAR   ProgIf;                     // (ro)
    UCHAR   SubClass;                   // (ro)
    UCHAR   BaseClass;                  // (ro)
    UCHAR   CacheLineSize;              // (ro+)
    UCHAR   LatencyTimer;               // (ro+)
    UCHAR   HeaderType;                 // (ro)
    UCHAR   BIST;                       // Built in self test

    union {
        struct _PCI_HEADER_TYPE_0 {
            ULONG   BaseAddresses[PCI_TYPE0_ADDRESSES];
            ULONG   CIS;
            USHORT  SubVendorID;
            USHORT  SubSystemID;
            ULONG   ROMBaseAddress;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved1[3];
            ULONG   Reserved2;
            UCHAR   InterruptLine;      //
            UCHAR   InterruptPin;       // (ro)
            UCHAR   MinimumGrant;       // (ro)
            UCHAR   MaximumLatency;     // (ro)
        } type0;


    } u;

    UCHAR   DeviceSpecific[192];

} PCI_COMMON_CONFIG, *PPCI_COMMON_CONFIG;


#define PCI_COMMON_HDR_LENGTH (FIELD_OFFSET (PCI_COMMON_CONFIG, DeviceSpecific))

#define PCI_MAX_DEVICES                     32
#define PCI_MAX_FUNCTION                    8
#define PCI_MAX_BRIDGE_NUMBER               0xFF

#define PCI_INVALID_VENDORID                0xFFFF

//
// Bit encodings for  PCI_COMMON_CONFIG.HeaderType
//

#define PCI_MULTIFUNCTION                   0x80
#define PCI_DEVICE_TYPE                     0x00
#define PCI_BRIDGE_TYPE                     0x01
#define PCI_CARDBUS_BRIDGE_TYPE             0x02

#define PCI_CONFIGURATION_TYPE(PciData) \
    (((PPCI_COMMON_CONFIG)(PciData))->HeaderType & ~PCI_MULTIFUNCTION)

#define PCI_MULTIFUNCTION_DEVICE(PciData) \
    ((((PPCI_COMMON_CONFIG)(PciData))->HeaderType & PCI_MULTIFUNCTION) != 0)

//
// Bit encodings for PCI_COMMON_CONFIG.Command
//

#define PCI_ENABLE_IO_SPACE                 0x0001
#define PCI_ENABLE_MEMORY_SPACE             0x0002
#define PCI_ENABLE_BUS_MASTER               0x0004
#define PCI_ENABLE_SPECIAL_CYCLES           0x0008
#define PCI_ENABLE_WRITE_AND_INVALIDATE     0x0010
#define PCI_ENABLE_VGA_COMPATIBLE_PALETTE   0x0020
#define PCI_ENABLE_PARITY                   0x0040  // (ro+)
#define PCI_ENABLE_WAIT_CYCLE               0x0080  // (ro+)
#define PCI_ENABLE_SERR                     0x0100  // (ro+)
#define PCI_ENABLE_FAST_BACK_TO_BACK        0x0200  // (ro)

//
// Bit encodings for PCI_COMMON_CONFIG.Status
//

#define PCI_STATUS_CAPABILITIES_LIST        0x0010  // (ro)
#define PCI_STATUS_66MHZ_CAPABLE            0x0020  // (ro)
#define PCI_STATUS_UDF_SUPPORTED            0x0040  // (ro)
#define PCI_STATUS_FAST_BACK_TO_BACK        0x0080  // (ro)
#define PCI_STATUS_DATA_PARITY_DETECTED     0x0100
#define PCI_STATUS_DEVSEL                   0x0600  // 2 bits wide
#define PCI_STATUS_SIGNALED_TARGET_ABORT    0x0800
#define PCI_STATUS_RECEIVED_TARGET_ABORT    0x1000
#define PCI_STATUS_RECEIVED_MASTER_ABORT    0x2000
#define PCI_STATUS_SIGNALED_SYSTEM_ERROR    0x4000
#define PCI_STATUS_DETECTED_PARITY_ERROR    0x8000

//
// The NT PCI Driver uses a WhichSpace parameter on its CONFIG_READ/WRITE
// routines.   The following values are defined-
//

#define PCI_WHICHSPACE_CONFIG               0x0
#define PCI_WHICHSPACE_ROM                  0x52696350

//
// Base Class Code encodings for Base Class (from PCI spec rev 2.1).
//

#define PCI_CLASS_PRE_20                    0x00
#define PCI_CLASS_MASS_STORAGE_CTLR         0x01
#define PCI_CLASS_NETWORK_CTLR              0x02
#define PCI_CLASS_DISPLAY_CTLR              0x03
#define PCI_CLASS_MULTIMEDIA_DEV            0x04
#define PCI_CLASS_MEMORY_CTLR               0x05
#define PCI_CLASS_BRIDGE_DEV                0x06
#define PCI_CLASS_SIMPLE_COMMS_CTLR         0x07
#define PCI_CLASS_BASE_SYSTEM_DEV           0x08
#define PCI_CLASS_INPUT_DEV                 0x09
#define PCI_CLASS_DOCKING_STATION           0x0a
#define PCI_CLASS_PROCESSOR                 0x0b
#define PCI_CLASS_SERIAL_BUS_CTLR           0x0c

// 0d thru fe reserved

#define PCI_CLASS_NOT_DEFINED               0xff

//
// Sub Class Code encodings (PCI rev 2.1).
//

// Class 00 - PCI_CLASS_PRE_20

#define PCI_SUBCLASS_PRE_20_NON_VGA         0x00
#define PCI_SUBCLASS_PRE_20_VGA             0x01

// Class 01 - PCI_CLASS_MASS_STORAGE_CTLR

#define PCI_SUBCLASS_MSC_SCSI_BUS_CTLR      0x00
#define PCI_SUBCLASS_MSC_IDE_CTLR           0x01
#define PCI_SUBCLASS_MSC_FLOPPY_CTLR        0x02
#define PCI_SUBCLASS_MSC_IPI_CTLR           0x03
#define PCI_SUBCLASS_MSC_RAID_CTLR          0x04
#define PCI_SUBCLASS_MSC_OTHER              0x80

// Class 02 - PCI_CLASS_NETWORK_CTLR

#define PCI_SUBCLASS_NET_ETHERNET_CTLR      0x00
#define PCI_SUBCLASS_NET_TOKEN_RING_CTLR    0x01
#define PCI_SUBCLASS_NET_FDDI_CTLR          0x02
#define PCI_SUBCLASS_NET_ATM_CTLR           0x03
#define PCI_SUBCLASS_NET_OTHER              0x80

// Class 03 - PCI_CLASS_DISPLAY_CTLR

// N.B. Sub Class 00 could be VGA or 8514 depending on Interface byte

#define PCI_SUBCLASS_VID_VGA_CTLR           0x00
#define PCI_SUBCLASS_VID_XGA_CTLR           0x01
#define PCI_SUBCLASS_VID_OTHER              0x80

// Class 04 - PCI_CLASS_MULTIMEDIA_DEV

#define PCI_SUBCLASS_MM_VIDEO_DEV           0x00
#define PCI_SUBCLASS_MM_AUDIO_DEV           0x01
#define PCI_SUBCLASS_MM_OTHER               0x80

// Class 05 - PCI_CLASS_MEMORY_CTLR

#define PCI_SUBCLASS_MEM_RAM                0x00
#define PCI_SUBCLASS_MEM_FLASH              0x01
#define PCI_SUBCLASS_MEM_OTHER              0x80

// Class 06 - PCI_CLASS_BRIDGE_DEV

#define PCI_SUBCLASS_BR_HOST                0x00
#define PCI_SUBCLASS_BR_ISA                 0x01
#define PCI_SUBCLASS_BR_EISA                0x02
#define PCI_SUBCLASS_BR_MCA                 0x03
#define PCI_SUBCLASS_BR_PCI_TO_PCI          0x04
#define PCI_SUBCLASS_BR_PCMCIA              0x05
#define PCI_SUBCLASS_BR_NUBUS               0x06
#define PCI_SUBCLASS_BR_CARDBUS             0x07
#define PCI_SUBCLASS_BR_OTHER               0x80

// Class 07 - PCI_CLASS_SIMPLE_COMMS_CTLR

// N.B. Sub Class 00 and 01 additional info in Interface byte

#define PCI_SUBCLASS_COM_SERIAL             0x00
#define PCI_SUBCLASS_COM_PARALLEL           0x01
#define PCI_SUBCLASS_COM_OTHER              0x80

// Class 08 - PCI_CLASS_BASE_SYSTEM_DEV

// N.B. See Interface byte for additional info.

#define PCI_SUBCLASS_SYS_INTERRUPT_CTLR     0x00
#define PCI_SUBCLASS_SYS_DMA_CTLR           0x01
#define PCI_SUBCLASS_SYS_SYSTEM_TIMER       0x02
#define PCI_SUBCLASS_SYS_REAL_TIME_CLOCK    0x03
#define PCI_SUBCLASS_SYS_OTHER              0x80

// Class 09 - PCI_CLASS_INPUT_DEV

#define PCI_SUBCLASS_INP_KEYBOARD           0x00
#define PCI_SUBCLASS_INP_DIGITIZER          0x01
#define PCI_SUBCLASS_INP_MOUSE              0x02
#define PCI_SUBCLASS_INP_OTHER              0x80

// Class 0a - PCI_CLASS_DOCKING_STATION

#define PCI_SUBCLASS_DOC_GENERIC            0x00
#define PCI_SUBCLASS_DOC_OTHER              0x80

// Class 0b - PCI_CLASS_PROCESSOR

#define PCI_SUBCLASS_PROC_386               0x00
#define PCI_SUBCLASS_PROC_486               0x01
#define PCI_SUBCLASS_PROC_PENTIUM           0x02
#define PCI_SUBCLASS_PROC_ALPHA             0x10
#define PCI_SUBCLASS_PROC_POWERPC           0x20
#define PCI_SUBCLASS_PROC_COPROCESSOR       0x40

// Class 0c - PCI_CLASS_SERIAL_BUS_CTLR

#define PCI_SUBCLASS_SB_IEEE1394            0x00
#define PCI_SUBCLASS_SB_ACCESS              0x01
#define PCI_SUBCLASS_SB_SSA                 0x02
#define PCI_SUBCLASS_SB_USB                 0x03
#define PCI_SUBCLASS_SB_FIBRE_CHANNEL       0x04




//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.BaseAddresses
//

#define PCI_ADDRESS_IO_SPACE                0x00000001  // (ro)
#define PCI_ADDRESS_MEMORY_TYPE_MASK        0x00000006  // (ro)
#define PCI_ADDRESS_MEMORY_PREFETCHABLE     0x00000008  // (ro)

#define PCI_ADDRESS_IO_ADDRESS_MASK         0xfffffffc
#define PCI_ADDRESS_MEMORY_ADDRESS_MASK     0xfffffff0
#define PCI_ADDRESS_ROM_ADDRESS_MASK        0xfffff800

#define PCI_TYPE_32BIT      0
#define PCI_TYPE_20BIT      2
#define PCI_TYPE_64BIT      4

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.ROMBaseAddresses
//

#define PCI_ROMADDRESS_ENABLED              0x00000001


//
// Reference notes for PCI configuration fields:
//
// ro   these field are read only.  changes to these fields are ignored
//
// ro+  these field are intended to be read only and should be initialized
//      by the system to their proper values.  However, driver may change
//      these settings.
//
// ---
//
//      All resources comsumed by a PCI device start as unitialized
//      under NT.  An uninitialized memory or I/O base address can be
//      determined by checking it's corrisponding enabled bit in the
//      PCI_COMMON_CONFIG.Command value.  An InterruptLine is unitialized
//      if it contains the value of -1.
//





#ifdef POOL_TAGGING
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,' mdW')
#endif

extern POBJECT_TYPE *IoFileObjectType;
extern POBJECT_TYPE *ExEventObjectType;
extern POBJECT_TYPE *ExSemaphoreObjectType;

//
// Define exported ZwXxx routines to device drivers.
//

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwReadFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwWriteFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwClose(
    IN HANDLE Handle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwMakeTemporaryObject(
    IN HANDLE Handle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenSection(
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwMapViewOfSection(
    IN HANDLE SectionHandle,
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG ZeroBits,
    IN ULONG CommitSize,
    IN OUT PLARGE_INTEGER SectionOffset OPTIONAL,
    IN OUT PSIZE_T ViewSize,
    IN SECTION_INHERIT InheritDisposition,
    IN ULONG AllocationType,
    IN ULONG Protect
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwUnmapViewOfSection(
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG TitleIndex,
    IN PUNICODE_STRING Class OPTIONAL,
    IN ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteKey(
    IN HANDLE KeyHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateValueKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryKey(
    IN HANDLE KeyHandle,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwSetValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN ULONG TitleIndex OPTIONAL,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    );

#endif // _WDMDDK_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\ddk\inc\wdmguid.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    wdmguid.h

Abstract:

    Defines GUIDs for function device classes and device events used in
    Plug & Play.

Author:

    Paula Tomlinson (paulat) 03-Dec-1996

Revision History:

--*/

#ifndef FAR
#define FAR
#endif

//
// Device events that can be broadcasted to drivers and user-mode apps.
//
DEFINE_GUID( GUID_HWPROFILE_QUERY_CHANGE,          0xcb3a4001L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_HWPROFILE_CHANGE_CANCELLED,      0xcb3a4002L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_HWPROFILE_CHANGE_COMPLETE,       0xcb3a4003L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_DEVICE_INTERFACE_ARRIVAL,        0xcb3a4004L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_DEVICE_INTERFACE_REMOVAL,        0xcb3a4005L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_TARGET_DEVICE_QUERY_REMOVE,      0xcb3a4006L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_TARGET_DEVICE_REMOVE_CANCELLED,  0xcb3a4007L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_TARGET_DEVICE_REMOVE_COMPLETE,   0xcb3a4008L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_PNP_CUSTOM_NOTIFICATION,         0xACA73F8EL, 0x8D23, 0x11D1, 0xAC, 0x7D, 0x00, 0x00, 0xF8, 0x75, 0x71, 0xD0 );
DEFINE_GUID( GUID_PNP_POWER_NOTIFICATION,          0xC2CF0660L, 0xEB7A, 0x11D1, 0xBD, 0x7F, 0x00, 0x00, 0xF8, 0x75, 0x71, 0xD0 );


//
// Interface GUIDs used for IRP_MN_QUERY_INTERFACE
//
DEFINE_GUID( GUID_BUS_INTERFACE_STANDARD,          0x496B8280L, 0x6F25, 0x11D0, 0xBE, 0xAF, 0x08, 0x00, 0x2B, 0xE2, 0x09, 0x2F );
DEFINE_GUID( GUID_PCI_BUS_INTERFACE_STANDARD,      0x496B8281L, 0x6F25, 0x11D0, 0xBE, 0xAF, 0x08, 0x00, 0x2B, 0xE2, 0x09, 0x2F );
DEFINE_GUID( GUID_ARBITER_INTERFACE_STANDARD,      0xe644f185L, 0x8c0e, 0x11d0, 0xbe, 0xcf, 0x08, 0x00, 0x2b, 0xe2, 0x09, 0x2f );
DEFINE_GUID( GUID_TRANSLATOR_INTERFACE_STANDARD,   0x6c154a92L, 0xaacf, 0x11d0, 0x8d, 0x2a, 0x00, 0xa0, 0xc9, 0x06, 0xb2, 0x44 );
DEFINE_GUID( GUID_ACPI_INTERFACE_STANDARD,         0xb091a08aL, 0xba97, 0x11d0, 0xbd, 0x14, 0x00, 0xaa, 0x00, 0xb7, 0xb3, 0x2a );
DEFINE_GUID( GUID_INT_ROUTE_INTERFACE_STANDARD,    0x70941bf4L, 0x0073, 0x11d1, 0xa0, 0x9e, 0x00, 0xc0, 0x4f, 0xc3, 0x40, 0xb1 );
DEFINE_GUID( GUID_PCMCIA_BUS_INTERFACE_STANDARD,   0x76173af0L, 0xc504, 0x11d1, 0x94, 0x7f, 0x00, 0xc0, 0x4f, 0xb9, 0x60, 0xee );
DEFINE_GUID( GUID_ACPI_REGS_INTERFACE_STANDARD,    0x06141966L, 0x7245, 0x6369, 0x46, 0x2e, 0x4e, 0x65, 0x6c, 0x73, 0x6f, 0x6e );
DEFINE_GUID( GUID_LEGACY_DEVICE_DETECTION_STANDARD, 0x50feb0deL, 0x596a, 0x11d2, 0xa5, 0xb8, 0x00, 0x00, 0xf8, 0x1a, 0x46, 0x19);
DEFINE_GUID( GUID_PCI_DEVICE_PRESENT_INTERFACE,    0xd1b82c26L, 0xbf49, 0x45ef, 0xb2, 0x16, 0x71, 0xcb, 0xd7, 0x88, 0x9b, 0x57 );
DEFINE_GUID( GUID_MF_ENUMERATION_INTERFACE,        0xaeb895f0L, 0x5586, 0x11d1, 0x8d, 0x84, 0x00, 0xa0, 0xc9, 0x06, 0xb2, 0x44 );

//
// Bus type GUIDs
//

DEFINE_GUID( GUID_BUS_TYPE_INTERNAL,               0x1530ea73L, 0x086b, 0x11d1, 0xa0, 0x9f, 0x00, 0xc0, 0x4f, 0xc3, 0x40, 0xb1 );
DEFINE_GUID( GUID_BUS_TYPE_PCMCIA,                 0x09343630L, 0xaf9f, 0x11d0, 0x92, 0xE9, 0x00, 0x00, 0xf8, 0x1e, 0x1b, 0x30 );
DEFINE_GUID( GUID_BUS_TYPE_PCI,                    0xc8ebdfb0L, 0xb510, 0x11d0, 0x80, 0xe5, 0x00, 0xa0, 0xc9, 0x25, 0x42, 0xe3 );
DEFINE_GUID( GUID_BUS_TYPE_ISAPNP,                 0xe676f854L, 0xd87d, 0x11d0, 0x92, 0xb2, 0x00, 0xa0, 0xc9, 0x05, 0x5f, 0xc5 );
DEFINE_GUID( GUID_BUS_TYPE_EISA,                   0xddc35509L, 0xf3fc, 0x11d0, 0xa5, 0x37, 0x00, 0x00, 0xf8, 0x75, 0x3e, 0xd1 );
DEFINE_GUID( GUID_BUS_TYPE_MCA,                    0x1c75997aL, 0xdc33, 0x11d0, 0x92, 0xb2, 0x00, 0xa0, 0xc9, 0x05, 0x5f, 0xc5 );
DEFINE_GUID( GUID_BUS_TYPE_SERENUM,                0x77114a87L, 0x8944, 0x11d1, 0xbd, 0x90, 0x00, 0xa0, 0xc9, 0x06, 0xbe, 0x2d );
DEFINE_GUID( GUID_BUS_TYPE_USB,                    0x9d7debbcL, 0xc85d, 0x11d1, 0x9e, 0xb4, 0x00, 0x60, 0x08, 0xc3, 0xa1, 0x9a );
// {9D7DEBBC-C85D-11d1-9EB4-006008C3A19A}

//
// Power management WMI guids for device control
//

DEFINE_GUID( GUID_POWER_DEVICE_ENABLE,             0x827c0a6fL, 0xfeb0, 0x11d0, 0xbd, 0x26, 0x00, 0xaa, 0x00, 0xb7, 0xb3, 0x2a );
DEFINE_GUID( GUID_POWER_DEVICE_TIMEOUTS,           0xa45da735L, 0xfeb0, 0x11d0, 0xbd, 0x26, 0x00, 0xaa, 0x00, 0xb7, 0xb3, 0x2a );
DEFINE_GUID( GUID_POWER_DEVICE_WAKE_ENABLE,        0xa9546a82L, 0xfeb0, 0x11d0, 0xbd, 0x26, 0x00, 0xaa, 0x00, 0xb7, 0xb3, 0x2a );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dinput\inc\makefile.inc ===
#
# The contents of this file was moved from windows\directx\dinput\makefile0
#

COPYRIGHT_STRING = Copyright (c) 1990-1999  Microsoft Corporation


OUTPUT_HDRS = $(SDK_INC_PATH)\dinput.h \
              $(PRIVATE_INC_PATH)\dinputp.h

dinput: $(OUTPUT_HDRS)

clean: cleansrc

cleansrc:
    del $(OUTPUT_HDRS)

#
#   Yuck!  We can't use -u because it causes all trail-commented lines to
#   be deleted!  Instead, we must explicitly exclude DX3 rather than saying
#   "Anything that isn't DX5 should be excluded".
#
#   -u      = skip unknown flags
#   -ts foo = skip `foo' tags
#   -ta foo = include `foo' tags
#   -v  500 = this is version 500
#
#   Tags:
#
#       dx3  = DX3
#       dx5  = DX5
#       dx5  = DX5
#       dx5a = DX5a     (Win98 Gold)
#       dx5b2= DX5b2    (NT5 beta 2)
#       dx6  = DX6.1a   (Win98 OSR1)
#       dx7  = DX7      (Win2000 Gold)
#       dx8  = DX8
#
#HSPLITFLAGS=-u -ta dx5 -v 500      # Can't use this (See above)

# The following line builds the DX5 header
#HSPLITFLAGS=-ts dx3 -ta dx5 -ts dx5a -ts dx5b2 -ts dx6 -ts dx7 -ts dx8 -v 500

# The following line builds the DX5a header; note that DX5a includes DX5
#HSPLITFLAGS=-ts dx3 -ta dx5 -ta dx5a -ts dx5b2 -ts dx6 -ts dx7 -ts dx8 -v 50A

# The following line builds the DX5B2 header
#HSPLITFLAGS=-ts dx3 -ts dx5 -ts dx5a -ta dx5b2 -ts dx6 -ts dx7 -ts dx8 -v 5B2

# The following line builds the DX6.1a header
#HSPLITFLAGS=-ts dx3 -ts dx5 -ts dx5a -ts dx5b2 -ta dx6 -ts dx7 -ts dx8 -v 600

# The following line builds the DX7 header
#HSPLITFLAGS=-ts dx3 -ts dx5 -ts dx5a -ts dx5b2 -ts dx6 -ta dx7 -ts dx8 -v 700

# The following line builds the DX8 header
#HSPLITFLAGS=-ts dx3 -ts dx5 -ts dx5a -ts dx5b2 -ts dx6 -ts dx7 -ta dx8 -v 800

# The following line builds the DX8 for XBOX header
HSPLITFLAGS=-ts dx3 -ts dx5 -ts dx5a -ts dx5b2 -ts dx6 -ta dx7 -ts dx8 -v 800 -ts noxbox -ta dx8x


$(SDK_INC_PATH)\dinput.h $(PRIVATE_INC_PATH)\dinputp.h: dinput.w dimkhdr.m4
        m4 dinput.w >dinput.wx
        hsplit $(HSPLITFLAGS) -o dinput.x dinputp.x dinput.wx
        del dinput.wx
        wcshdr.exe < dinput.x > $(SDK_INC_PATH)\dinput.h
        del dinput.x
        wcshdr.exe < dinputp.x > $(PRIVATE_INC_PATH)\dinputp.h
        del dinputp.x


$(SDK_INC_PATH)\dinputd.h $(PRIVATE_INC_PATH)\dinputdp.h: dinputd.w dimkhdr.m4
        m4 dinputd.w >dinputd.wx
        hsplit $(HSPLITFLAGS) -o dinputd.x dinputdp.x dinputd.wx
        del dinputd.wx
        wcshdr.exe < dinputd.x > $(SDK_INC_PATH)\dinputd.h
        del dinputd.x
        wcshdr.exe < dinputdp.x > $(PRIVATE_INC_PATH)\dinputdp.h
        del dinputdp.x
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dmusic\inc\dmusbuff.h ===
/***************************************************************************
*                                                                          *
*   DMusBuff.h -- This module defines the buffer format for DirectMusic    *
*                 Shared file between user mode and kernel mode components *
*                                                                          *
*   Copyright (c) 1998, Microsoft Corp. All rights reserved.               *
*                                                                          *
***************************************************************************/

#ifndef _DMusBuff_
#define _DMusBuff_

/* Format of DirectMusic events in a buffer
 *
 * A buffer contains 1 or more events, each with the following header.
 * Immediately following the header is the event data. The header+data
 * size is rounded to the nearest quadword (8 bytes).
 */
 
#include <pshpack4.h>                       /* Do not pad at end - that's where the data is */ 
typedef struct _DMUS_EVENTHEADER *LPDMUS_EVENTHEADER;
typedef struct _DMUS_EVENTHEADER
{
    DWORD           cbEvent;                /* Unrounded bytes in event */
    DWORD           dwChannelGroup;         /* Channel group of event */
    REFERENCE_TIME  rtDelta;                /* Delta from start time of entire buffer */
    DWORD           dwFlags;                /* Flags DMUS_EVENT_xxx */
} DMUS_EVENTHEADER;
#include <poppack.h>

#define DMUS_EVENT_STRUCTURED   0x00000001  /* Unstructured data (SysEx, etc.) */

/* The number of bytes to allocate for an event with 'cb' data bytes.
 */ 
#define QWORD_ALIGN(x) (((x) + 7) & ~7)
#define DMUS_EVENT_SIZE(cb) QWORD_ALIGN(sizeof(DMUS_EVENTHEADER) + cb)


#endif /* _DMusBuff_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dmusic\inc\dls1.h ===
/*==========================================================================;
//
//  dls1.h
//
//
//  Description:
//
//  Interface defines and structures for the Instrument Collection Form
//  RIFF DLS.
//
//
//  Written by Sonic Foundry 1996.  Released for public use.
//
//=========================================================================*/

#ifndef _INC_DLS1
#define _INC_DLS1
#ifdef XBOX
#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )				\
		( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
		( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif
#endif // XBOX

/*//////////////////////////////////////////////////////////////////////////
//
//
// Layout of an instrument collection:
//
//
// RIFF [] 'DLS ' [dlid,colh,INSTLIST,WAVEPOOL,INFOLIST]
//
// INSTLIST
// LIST [] 'lins'
//               LIST [] 'ins ' [dlid,insh,RGNLIST,ARTLIST,INFOLIST]
//               LIST [] 'ins ' [dlid,insh,RGNLIST,ARTLIST,INFOLIST]
//               LIST [] 'ins ' [dlid,insh,RGNLIST,ARTLIST,INFOLIST]
//
// RGNLIST
// LIST [] 'lrgn' 
//               LIST [] 'rgn '  [rgnh,wsmp,wlnk,ARTLIST]
//               LIST [] 'rgn '  [rgnh,wsmp,wlnk,ARTLIST]
//               LIST [] 'rgn '  [rgnh,wsmp,wlnk,ARTLIST]
//
// ARTLIST
// LIST [] 'lart'
//         'art1' level 1 Articulation connection graph
//         'art2' level 2 Articulation connection graph
//         '3rd1' Possible 3rd party articulation structure 1
//         '3rd2' Possible 3rd party articulation structure 2 .... and so on
//
// WAVEPOOL 
// ptbl [] [pool table]
// LIST [] 'wvpl'
//               [path],
//               [path],
//               LIST [] 'wave' [dlid,RIFFWAVE]
//               LIST [] 'wave' [dlid,RIFFWAVE]
//               LIST [] 'wave' [dlid,RIFFWAVE]
//               LIST [] 'wave' [dlid,RIFFWAVE]
//               LIST [] 'wave' [dlid,RIFFWAVE]
//
// INFOLIST
// LIST [] 'INFO' 
//               'icmt' 'One of those crazy comments.'
//               'icop' 'Copyright (C) 1996 Sonic Foundry'
//
/////////////////////////////////////////////////////////////////////////*/


/*/////////////////////////////////////////////////////////////////////////
// FOURCC's used in the DLS file
/////////////////////////////////////////////////////////////////////////*/

#define FOURCC_DLS   mmioFOURCC('D','L','S',' ')
#define FOURCC_DLID  mmioFOURCC('d','l','i','d')
#define FOURCC_COLH  mmioFOURCC('c','o','l','h')
#define FOURCC_WVPL  mmioFOURCC('w','v','p','l')
#define FOURCC_PTBL  mmioFOURCC('p','t','b','l')
#define FOURCC_PATH  mmioFOURCC('p','a','t','h')
#define FOURCC_wave  mmioFOURCC('w','a','v','e')
#define FOURCC_LINS  mmioFOURCC('l','i','n','s')
#define FOURCC_INS   mmioFOURCC('i','n','s',' ')
#define FOURCC_INSH  mmioFOURCC('i','n','s','h')
#define FOURCC_LRGN  mmioFOURCC('l','r','g','n')
#define FOURCC_RGN   mmioFOURCC('r','g','n',' ')
#define FOURCC_RGNH  mmioFOURCC('r','g','n','h')
#define FOURCC_LART  mmioFOURCC('l','a','r','t')
#define FOURCC_ART1  mmioFOURCC('a','r','t','1')
#define FOURCC_WLNK  mmioFOURCC('w','l','n','k')
#define FOURCC_WSMP  mmioFOURCC('w','s','m','p')
#define FOURCC_VERS  mmioFOURCC('v','e','r','s')

/*/////////////////////////////////////////////////////////////////////////
// Articulation connection graph definitions 
/////////////////////////////////////////////////////////////////////////*/

/* Generic Sources */
#define CONN_SRC_NONE              0x0000
#define CONN_SRC_LFO               0x0001
#define CONN_SRC_KEYONVELOCITY     0x0002
#define CONN_SRC_KEYNUMBER         0x0003
#define CONN_SRC_EG1               0x0004
#define CONN_SRC_EG2               0x0005
#define CONN_SRC_PITCHWHEEL        0x0006

/* Midi Controllers 0-127 */
#define CONN_SRC_CC1               0x0081
#define CONN_SRC_CC7               0x0087
#define CONN_SRC_CC10              0x008a
#define CONN_SRC_CC11              0x008b

/* Generic Destinations */
#define CONN_DST_NONE              0x0000
#define CONN_DST_ATTENUATION       0x0001
#define CONN_DST_PITCH             0x0003
#define CONN_DST_PAN               0x0004

/* LFO Destinations */
#define CONN_DST_LFO_FREQUENCY     0x0104
#define CONN_DST_LFO_STARTDELAY    0x0105

/* EG1 Destinations */
#define CONN_DST_EG1_ATTACKTIME    0x0206
#define CONN_DST_EG1_DECAYTIME     0x0207
#define CONN_DST_EG1_RELEASETIME   0x0209
#define CONN_DST_EG1_SUSTAINLEVEL  0x020a

/* EG2 Destinations */
#define CONN_DST_EG2_ATTACKTIME    0x030a
#define CONN_DST_EG2_DECAYTIME     0x030b
#define CONN_DST_EG2_RELEASETIME   0x030d
#define CONN_DST_EG2_SUSTAINLEVEL  0x030e

#define CONN_TRN_NONE              0x0000
#define CONN_TRN_CONCAVE           0x0001

typedef struct _DLSID {
  ULONG    ulData1;
  USHORT   usData2;
  USHORT   usData3;
  BYTE     abData4[8];
} DLSID, FAR *LPDLSID;

typedef struct _DLSVERSION {
  DWORD    dwVersionMS;
  DWORD    dwVersionLS;
}DLSVERSION, FAR *LPDLSVERSION;
                   

typedef struct _CONNECTION {
  USHORT   usSource;
  USHORT   usControl;
  USHORT   usDestination;
  USHORT   usTransform;
  LONG     lScale;
  }CONNECTION, FAR *LPCONNECTION;


/* Level 1 Articulation Data */

typedef struct _CONNECTIONLIST {
  ULONG    cbSize;            /* size of the connection list structure */
  ULONG    cConnections;      /* count of connections in the list */
  } CONNECTIONLIST, FAR *LPCONNECTIONLIST;



/*/////////////////////////////////////////////////////////////////////////
// Generic type defines for regions and instruments
/////////////////////////////////////////////////////////////////////////*/

typedef struct _RGNRANGE {
  USHORT usLow;
  USHORT usHigh;
}RGNRANGE, FAR * LPRGNRANGE;

#define F_INSTRUMENT_DRUMS      0x80000000

typedef struct _MIDILOCALE {
  ULONG ulBank;
  ULONG ulInstrument;
}MIDILOCALE, FAR *LPMIDILOCALE;

/*/////////////////////////////////////////////////////////////////////////
// Header structures found in an DLS file for collection, instruments, and
// regions.
/////////////////////////////////////////////////////////////////////////*/

#define F_RGN_OPTION_SELFNONEXCLUSIVE  0x0001

typedef struct _RGNHEADER {
  RGNRANGE RangeKey;            /* Key range  */
  RGNRANGE RangeVelocity;       /* Velocity Range  */
  USHORT   fusOptions;          /* Synthesis options for this range */
  USHORT   usKeyGroup;          /* Key grouping for non simultaneous play */
                                /* 0 = no group, 1 up is group */
                                /* for Level 1 only groups 1-15 are allowed */
}RGNHEADER, FAR *LPRGNHEADER;

typedef struct _INSTHEADER {
  ULONG      cRegions;          /* Count of regions in this instrument */
  MIDILOCALE Locale;            /* Intended MIDI locale of this instrument */
}INSTHEADER, FAR *LPINSTHEADER;

typedef struct _DLSHEADER {
  ULONG      cInstruments;      /* Count of instruments in the collection */
}DLSHEADER, FAR *LPDLSHEADER;

/*////////////////////////////////////////////////////////////////////////////
// definitions for the Wave link structure
////////////////////////////////////////////////////////////////////////////*/

/* ****  For level 1 only WAVELINK_CHANNEL_MONO is valid  **** */
/* ulChannel allows for up to 32 channels of audio with each bit position */
/* specifiying a channel of playback */

#define WAVELINK_CHANNEL_LEFT    0x0001l
#define WAVELINK_CHANNEL_RIGHT   0x0002l

#define F_WAVELINK_PHASE_MASTER  0x0001

typedef struct _WAVELINK { /* any paths or links are stored right after struct */
  USHORT   fusOptions;     /* options flags for this wave */
  USHORT   usPhaseGroup;   /* Phase grouping for locking channels */
  ULONG    ulChannel;      /* channel placement */
  ULONG    ulTableIndex;   /* index into the wave pool table, 0 based */
}WAVELINK, FAR *LPWAVELINK;

#define POOL_CUE_NULL  0xffffffffl

typedef struct _POOLCUE { 
  ULONG    ulOffset;       /* Offset to the entry in the list */
}POOLCUE, FAR *LPPOOLCUE;

typedef struct _POOLTABLE {
  ULONG    cbSize;            /* size of the pool table structure */
  ULONG    cCues;             /* count of cues in the list */
  } POOLTABLE, FAR *LPPOOLTABLE;

/*////////////////////////////////////////////////////////////////////////////
// Structures for the "wsmp" chunk
////////////////////////////////////////////////////////////////////////////*/

#define F_WSMP_NO_TRUNCATION     0x0001l
#define F_WSMP_NO_COMPRESSION    0x0002l


typedef struct _rwsmp {
  ULONG   cbSize;
  USHORT  usUnityNote;         /* MIDI Unity Playback Note */
  SHORT   sFineTune;           /* Fine Tune in log tuning */
  LONG    lAttenuation;        /* Overall Attenuation to be applied to data */
  ULONG   fulOptions;          /* Flag options  */
  ULONG   cSampleLoops;        /* Count of Sample loops, 0 loops is one shot */
  } WSMPL, FAR *LPWSMPL;


/* This loop type is a normal forward playing loop which is continually */
/* played until the envelope reaches an off threshold in the release */
/* portion of the volume envelope */

#define WLOOP_TYPE_FORWARD   0

typedef struct _rloop {
  ULONG cbSize;
  ULONG ulType;              /* Loop Type */
  ULONG ulStart;             /* Start of loop in samples */
  ULONG ulLength;            /* Length of loop in samples */
} WLOOP, FAR *LPWLOOP;

#endif /*_INC_DLS1 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dmusic\inc\dmdls.h ===
/************************************************************************
*                                                                       *
*   dmdls.h -- DLS download definitions for DirectMusic API's           *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corporation                       *
*                                                                       *
************************************************************************/

#ifndef _DMDLS_
#define _DMDLS_

#include "dls1.h"

typedef long PCENT;     /* Pitch cents */
typedef long GCENT;     /* Gain cents */
typedef long TCENT;     /* Time cents */
typedef long PERCENT;   /* Per.. cent! */

typedef LONGLONG REFERENCE_TIME;
typedef REFERENCE_TIME *LPREFERENCE_TIME;

#if defined(XBOX) && defined(MAKEFOURCC) && !defined(MAKE_FOURCC)
#define MAKE_FOURCC
#endif // XBOX, etc.

#ifndef MAKE_FOURCC
#define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
                ((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) |   \
                ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24 ))


typedef DWORD           FOURCC;         /* a four character code */
#endif

typedef struct _DMUS_DOWNLOADINFO
{
    DWORD dwDLType;                     /* Instrument or Wave */
    DWORD dwDLId;                       /* Unique identifier to tag this download. */
    DWORD dwNumOffsetTableEntries;      /* Number of index in the offset address table. */
    DWORD cbSize;                       /* Total size of this memory chunk. */
} DMUS_DOWNLOADINFO;

#define DMUS_DOWNLOADINFO_INSTRUMENT        1
#define DMUS_DOWNLOADINFO_WAVE              2
#define DMUS_DOWNLOADINFO_INSTRUMENT2       3   /* New version for better DLS2 support. */

/* Support for oneshot and streaming wave data 
 */
#define DMUS_DOWNLOADINFO_WAVEARTICULATION  4   /* Wave articulation data */
#define DMUS_DOWNLOADINFO_STREAMINGWAVE     5   /* One chunk of a streaming */
#define DMUS_DOWNLOADINFO_ONESHOTWAVE       6

#define DMUS_DEFAULT_SIZE_OFFSETTABLE   1

/* Flags for DMUS_INSTRUMENT's ulFlags member */
 
#define DMUS_INSTRUMENT_GM_INSTRUMENT   (1 << 0)

typedef struct _DMUS_OFFSETTABLE
{
    ULONG ulOffsetTable[DMUS_DEFAULT_SIZE_OFFSETTABLE];
} DMUS_OFFSETTABLE;

typedef struct _DMUS_INSTRUMENT
{
    ULONG           ulPatch;
    ULONG           ulFirstRegionIdx;             
    ULONG           ulGlobalArtIdx;         /* If zero the instrument does not have an articulation */
    ULONG           ulFirstExtCkIdx;        /* If zero no 3rd party entenstion chunks associated with the instrument */
    ULONG           ulCopyrightIdx;         /* If zero no Copyright information associated with the instrument */
    ULONG           ulFlags;                        
} DMUS_INSTRUMENT;

typedef struct _DMUS_REGION
{
    RGNRANGE        RangeKey;
    RGNRANGE        RangeVelocity;
    USHORT          fusOptions;
    USHORT          usKeyGroup;
    ULONG           ulRegionArtIdx;         /* If zero the region does not have an articulation */
    ULONG           ulNextRegionIdx;        /* If zero no more regions */
    ULONG           ulFirstExtCkIdx;        /* If zero no 3rd party entenstion chunks associated with the region */
    WAVELINK        WaveLink;
    WSMPL           WSMP;                   /*  If WSMP.cSampleLoops > 1 then a WLOOP is included */
    WLOOP           WLOOP[1];
} DMUS_REGION;

typedef struct _DMUS_LFOPARAMS
{
    PCENT       pcFrequency;
    TCENT       tcDelay;
    GCENT       gcVolumeScale;
    PCENT       pcPitchScale;
    GCENT       gcMWToVolume;
    PCENT       pcMWToPitch;
} DMUS_LFOPARAMS;

typedef struct _DMUS_VEGPARAMS
{
    TCENT       tcAttack;
    TCENT       tcDecay;
    PERCENT     ptSustain;
    TCENT       tcRelease;
    TCENT       tcVel2Attack;
    TCENT       tcKey2Decay;
} DMUS_VEGPARAMS;

typedef struct _DMUS_PEGPARAMS
{
    TCENT       tcAttack;
    TCENT       tcDecay;
    PERCENT     ptSustain;
    TCENT       tcRelease;
    TCENT       tcVel2Attack;
    TCENT       tcKey2Decay;
    PCENT       pcRange;
} DMUS_PEGPARAMS;

typedef struct _DMUS_MSCPARAMS
{
    PERCENT     ptDefaultPan;
} DMUS_MSCPARAMS;

typedef struct _DMUS_ARTICPARAMS
{
    DMUS_LFOPARAMS   LFO;
    DMUS_VEGPARAMS   VolEG;
    DMUS_PEGPARAMS   PitchEG;
    DMUS_MSCPARAMS   Misc;
} DMUS_ARTICPARAMS;

typedef struct _DMUS_ARTICULATION           /* Articulation chunk for DMUS_DOWNLOADINFO_INSTRUMENT format. */
{
    ULONG           ulArt1Idx;              /* DLS Level 1 articulation chunk */
    ULONG           ulFirstExtCkIdx;        /* 3rd party extenstion chunks associated with the articulation */
} DMUS_ARTICULATION;

typedef struct _DMUS_ARTICULATION2          /* Articulation chunk for DMUS_DOWNLOADINFO_INSTRUMENT2 format. */
{
    ULONG           ulArtIdx;               /* DLS Level 1/2 articulation chunk */
    ULONG           ulFirstExtCkIdx;        /* 3rd party extenstion chunks associated with the articulation */
    ULONG           ulNextArtIdx;           /* Additional articulation chunks */
} DMUS_ARTICULATION2;

#define DMUS_MIN_DATA_SIZE 4       
/*  The actual number is determined by cbSize of struct _DMUS_EXTENSIONCHUNK */

typedef struct _DMUS_EXTENSIONCHUNK
{
    ULONG           cbSize;                      /*  Size of extension chunk  */
    ULONG           ulNextExtCkIdx;              /*  If zero no more 3rd party entenstion chunks */
    FOURCC          ExtCkID;                                      
    BYTE            byExtCk[DMUS_MIN_DATA_SIZE]; /*  The actual number that follows is determined by cbSize */
} DMUS_EXTENSIONCHUNK;

/*  The actual number is determined by cbSize of struct _DMUS_COPYRIGHT */

typedef struct _DMUS_COPYRIGHT
{
    ULONG           cbSize;                             /*  Size of copyright information */
    BYTE            byCopyright[DMUS_MIN_DATA_SIZE];    /*  The actual number that follows is determined by cbSize */
} DMUS_COPYRIGHT;

typedef struct _DMUS_WAVEDATA
{
    ULONG           cbSize;
    BYTE            byData[DMUS_MIN_DATA_SIZE]; 
} DMUS_WAVEDATA;

typedef struct _DMUS_WAVE
{
    ULONG           ulFirstExtCkIdx;    /* If zero no 3rd party entenstion chunks associated with the wave */
    ULONG           ulCopyrightIdx;     /* If zero no Copyright information associated with the wave */
    ULONG           ulWaveDataIdx;      /* Location of actual wave data. */
    WAVEFORMATEX    WaveformatEx;       
} DMUS_WAVE;

typedef struct _DMUS_NOTERANGE *LPDMUS_NOTERANGE;
typedef struct _DMUS_NOTERANGE
{
    DWORD           dwLowNote;  /* Sets the low note for the range of MIDI note events to which the instrument responds.*/
    DWORD           dwHighNote; /* Sets the high note for the range of MIDI note events to which the instrument responds.*/
} DMUS_NOTERANGE;

typedef struct _DMUS_WAVEARTDL
{
    ULONG               ulDownloadIdIdx;    /* Download ID's of each buffer */
    ULONG               ulBus;              /* Playback bus */
    ULONG               ulBuffers;          /* Buffers */
    ULONG               ulMasterDLId;       /* Download ID of master voice of slave group */
    USHORT              usOptions;          /* Same as DLS2 region options */
}   DMUS_WAVEARTDL,
    *LPDMUS_WAVEARTDL;

typedef struct _DMUS_WAVEDL
{
    ULONG               cbWaveData;         /* Bytes of wave data */
}   DMUS_WAVEDL,
    *LPDMUS_WAVEDL;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dmusic\inc\dmksctrl.h ===
/************************************************************************
*                                                                       *
*   dmksctrl.h -- Definition of IKsControl                              *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corporation
*                                                                       *
*                                                                       *
*   This header file contains the definition of IKsControl, which       *
*   duplicates definitions from ks.h and ksproxy.h. Your code should    *
*   include ks.h and ksproxy.h directly if you have them (they are      *
*   provided in the Windows 98 DDK and will be in the Windows NT 5      *
*   SDK).                                                               *
*                                                                       *
************************************************************************/

#ifndef _DMKSCTRL_
#define _DMKSCTRL_

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)   /* Disable warnings on anonymous unions */

#include <pshpack8.h>

#include <objbase.h>

#if !defined(_NTRTL_)
    #ifndef DEFINE_GUIDEX
        #define DEFINE_GUIDEX(name) EXTERN_C const CDECL GUID name
    #endif /* !defined(DEFINE_GUIDEX) */

    #ifndef STATICGUIDOF
        #define STATICGUIDOF(guid) STATIC_##guid
    #endif /* !defined(STATICGUIDOF) */
#endif /* !defined(_NTRTL_) */

#ifndef STATIC_IID_IKsControl
#define STATIC_IID_IKsControl\
    0x28F54685L, 0x06FD, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
#endif /* STATIC_IID_IKsControl */

/* 
 * Warning: This will prevent the rest of ks.h from being pulled in if ks.h is 
 * included after dmksctrl.h. Make sure you do not include both headers in
 * the same source file.
 */
#ifndef _KS_
#define _KS_

#if (defined(_MSC_EXTENSIONS) || defined(__cplusplus)) && !defined(CINTERFACE)
typedef struct {
    union {
        struct {
            GUID    Set;
            ULONG   Id;
            ULONG   Flags;
        };
        LONGLONG    Alignment;
    };
} KSIDENTIFIER, *PKSIDENTIFIER;
#else
typedef struct {
    union {
        struct {
            GUID    Set;
            ULONG   Id;
            ULONG   Flags;
        } Data;
        LONGLONG    Alignment;
    };
} KSIDENTIFIER, *PKSIDENTIFIER;
#endif

typedef KSIDENTIFIER KSPROPERTY, *PKSPROPERTY, KSMETHOD, *PKSMETHOD, KSEVENT, *PKSEVENT;

#define KSMETHOD_TYPE_NONE                  0x00000000
#define KSMETHOD_TYPE_READ                  0x00000001
#define KSMETHOD_TYPE_WRITE                 0x00000002
#define KSMETHOD_TYPE_MODIFY                0x00000003
#define KSMETHOD_TYPE_SOURCE                0x00000004

#define KSMETHOD_TYPE_SEND                  0x00000001
#define KSMETHOD_TYPE_SETSUPPORT            0x00000100
#define KSMETHOD_TYPE_BASICSUPPORT          0x00000200

#define KSPROPERTY_TYPE_GET                 0x00000001
#define KSPROPERTY_TYPE_SET                 0x00000002
#define KSPROPERTY_TYPE_SETSUPPORT          0x00000100
#define KSPROPERTY_TYPE_BASICSUPPORT        0x00000200
#define KSPROPERTY_TYPE_RELATIONS           0x00000400
#define KSPROPERTY_TYPE_SERIALIZESET        0x00000800
#define KSPROPERTY_TYPE_UNSERIALIZESET      0x00001000
#define KSPROPERTY_TYPE_SERIALIZERAW        0x00002000
#define KSPROPERTY_TYPE_UNSERIALIZERAW      0x00004000
#define KSPROPERTY_TYPE_SERIALIZESIZE       0x00008000
#define KSPROPERTY_TYPE_DEFAULTVALUES       0x00010000

#define KSPROPERTY_TYPE_TOPOLOGY            0x10000000
#endif  /* _KS_ */

#ifndef _IKsControl_
#define _IKsControl_

#ifdef DECLARE_INTERFACE_


#undef INTERFACE
#define INTERFACE IKsControl
DECLARE_INTERFACE_(IKsControl, IUnknown)
{
     /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*IKsControl*/
    STDMETHOD(KsProperty)(
        THIS_
        IN PKSPROPERTY Property,
        IN ULONG PropertyLength,
        IN OUT LPVOID PropertyData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
    ) PURE;
    STDMETHOD(KsMethod)(
        THIS_
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
    ) PURE;
    STDMETHOD(KsEvent)(
        THIS_
        IN PKSEVENT Event OPTIONAL,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
    ) PURE;
};

#endif /* DECLARE_INTERFACE_ */
#endif /* _IKsControl_ */

#include <poppack.h>

DEFINE_GUID(IID_IKsControl, 0x28F54685, 0x06FD, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96);

/* These formats are in ksmedia.h
 */
#ifndef _KSMEDIA_

DEFINE_GUID(KSDATAFORMAT_SUBTYPE_MIDI, 0x1D262760L, 0xE957, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00);
DEFINE_GUID(KSDATAFORMAT_SUBTYPE_DIRECTMUSIC, 0x1a82f8bc,  0x3f8b, 0x11d2, 0xb7, 0x74, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1);

#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

#endif /* _DMKSCTRL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dmusic\inc\dmerror.h ===
/************************************************************************
*                                                                       *
*   dmerror.h -- Error code returned by DirectMusic API's               *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corporation
*                                                                       *
************************************************************************/

#ifdef DXAPI
#ifndef _DMERROR_
#define _DMERROR_

#define FACILITY_DIRECTMUSIC      0x878       /* Shared with DirectSound */
#define DMUS_ERRBASE              0x1000      /* Make error codes human readable in hex */

#ifndef MAKE_HRESULT
#define MAKE_HRESULT(sev,fac,code) \
    ((HRESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )
#endif
    
#define MAKE_DMHRESULTSUCCESS(code)     MAKE_HRESULT(0, FACILITY_DIRECTMUSIC, (DMUS_ERRBASE + (code)))
#define MAKE_DMHRESULTERROR(code)       MAKE_HRESULT(1, FACILITY_DIRECTMUSIC, (DMUS_ERRBASE + (code)))

/* DMUS_S_PARTIALLOAD
 *
 * The object could only load partially. This can happen if some components are
 * not registered properly, such as embedded tracks and tools. This can also happen
 * if some content is missing. For example, if a segment uses a DLS collection that
 * is not in the loader's current search directory.
 */
#define DMUS_S_PARTIALLOAD              MAKE_DMHRESULTSUCCESS(0x091)

/* DMUS_S_PARTIALDOWNLOAD
 *
 * Return value from IDirectMusicBand::Download() which indicates that
 * some of the instruments safely downloaded, but others failed. This usually
 * occurs when some instruments are on PChannels not supported by the performance
 * or port.
 */
#define DMUS_S_PARTIALDOWNLOAD          MAKE_DMHRESULTSUCCESS(0x092)

/* DMUS_S_REQUEUE
 *
 * Return value from IDirectMusicTool::ProcessPMsg() which indicates to the
 * performance that it should cue the PMsg again automatically.
 */
#define DMUS_S_REQUEUE                  MAKE_DMHRESULTSUCCESS(0x200)

/* DMUS_S_FREE
 *
 * Return value from IDirectMusicTool::ProcessPMsg() which indicates to the
 * performance that it should free the PMsg automatically.
 */
#define DMUS_S_FREE                     MAKE_DMHRESULTSUCCESS(0x201)

/* DMUS_S_END
 *
 * Return value from IDirectMusicTrack::Play() which indicates to the
 * segment that the track has no more data after mtEnd.
 */
#define DMUS_S_END                      MAKE_DMHRESULTSUCCESS(0x202)

/* DMUS_S_STRING_TRUNCATED
 *
 * Returned string has been truncated to fit the buffer size.
 */
#define DMUS_S_STRING_TRUNCATED         MAKE_DMHRESULTSUCCESS(0x210)

/* DMUS_S_LAST_TOOL
 *
 * Returned from IDirectMusicGraph::StampPMsg(), this indicates that the PMsg
 * is already stamped with the last tool in the graph. The returned PMsg's
 * tool pointer is now NULL.
 */
#define DMUS_S_LAST_TOOL                MAKE_DMHRESULTSUCCESS(0x211)

/* DMUS_S_OVER_CHORD
 *
 * Returned from IDirectMusicPerformance::MusicToMIDI(), this indicates 
 * that no note has been calculated because the music value has the note 
 * at a position higher than the top note of the chord. This applies only
 * to DMUS_PLAYMODE_NORMALCHORD play mode. This success code indicates
 * that the caller should not do anything with the note. It is not meant
 * to be played against this chord.
 */
#define DMUS_S_OVER_CHORD               MAKE_DMHRESULTSUCCESS(0x212)

/* DMUS_S_UP_OCTAVE
 *
 * Returned from IDirectMusicPerformance::MIDIToMusic(),  and
 * IDirectMusicPerformance::MusicToMIDI(), this indicates 
 * that the note conversion generated a note value that is below 0, 
 * so it has been bumped up one or more octaves to be in the proper
 * MIDI range of 0 through 127. 
 * Note that this is valid for MIDIToMusic() when using play modes
 * DMUS_PLAYMODE_FIXEDTOCHORD and DMUS_PLAYMODE_FIXEDTOKEY, both of
 * which store MIDI values in wMusicValue. With MusicToMIDI(), it is
 * valid for all play modes.
 * Ofcourse, DMUS_PLAYMODE_FIXED will never return this success code.
 */
#define DMUS_S_UP_OCTAVE                MAKE_DMHRESULTSUCCESS(0x213)

/* DMUS_S_DOWN_OCTAVE
 *
 * Returned from IDirectMusicPerformance::MIDIToMusic(),  and
 * IDirectMusicPerformance::MusicToMIDI(), this indicates 
 * that the note conversion generated a note value that is above 127, 
 * so it has been bumped down one or more octaves to be in the proper
 * MIDI range of 0 through 127. 
 * Note that this is valid for MIDIToMusic() when using play modes
 * DMUS_PLAYMODE_FIXEDTOCHORD and DMUS_PLAYMODE_FIXEDTOKEY, both of
 * which store MIDI values in wMusicValue. With MusicToMIDI(), it is
 * valid for all play modes.
 * Ofcourse, DMUS_PLAYMODE_FIXED will never return this success code.
 */
#define DMUS_S_DOWN_OCTAVE              MAKE_DMHRESULTSUCCESS(0x214)

/* DMUS_S_NOBUFFERCONTROL
 *
 * Although the audio output from the port will be routed to the
 * same device as the given DirectSound buffer, buffer controls
 * such as pan and volume will not affect the output.
 *
 */
#define DMUS_S_NOBUFFERCONTROL          MAKE_DMHRESULTSUCCESS(0x215)

/* DMUS_S_GARBAGE_COLLECTED
 *
 * The requested operation was not performed because during CollectGarbage
 * the loader determined that the object had been released.
 */
#define DMUS_S_GARBAGE_COLLECTED        MAKE_DMHRESULTSUCCESS(0x216)

/* DMUS_E_DRIVER_FAILED
 *
 * An unexpected error was returned from a device driver, indicating
 * possible failure of the driver or hardware.
 */
#define DMUS_E_DRIVER_FAILED            MAKE_DMHRESULTERROR(0x0101)

/* DMUS_E_PORTS_OPEN
 *
 * The requested operation cannot be performed while there are 
 * instantiated ports in any process in the system.
 */
#define DMUS_E_PORTS_OPEN               MAKE_DMHRESULTERROR(0x0102)

/* DMUS_E_DEVICE_IN_USE
 *
 * The requested device is already in use (possibly by a non-DirectMusic
 * client) and cannot be opened again.
 */
#define DMUS_E_DEVICE_IN_USE            MAKE_DMHRESULTERROR(0x0103)

/* DMUS_E_INSUFFICIENTBUFFER
 *
 * Buffer is not large enough for requested operation.
 */
#define DMUS_E_INSUFFICIENTBUFFER       MAKE_DMHRESULTERROR(0x0104)

/* DMUS_E_BUFFERNOTSET
 *
 * No buffer was prepared for the download data.
 */
#define DMUS_E_BUFFERNOTSET             MAKE_DMHRESULTERROR(0x0105)

/* DMUS_E_BUFFERNOTAVAILABLE
 *
 * Download failed due to inability to access or create download buffer.
 */
#define DMUS_E_BUFFERNOTAVAILABLE       MAKE_DMHRESULTERROR(0x0106)

/* DMUS_E_NOTADLSCOL
 *
 * Error parsing DLS collection. File is corrupt.
 */
#define DMUS_E_NOTADLSCOL               MAKE_DMHRESULTERROR(0x0108)

/* DMUS_E_INVALIDOFFSET
 *
 * Wave chunks in DLS collection file are at incorrect offsets.
 */
#define DMUS_E_INVALIDOFFSET            MAKE_DMHRESULTERROR(0x0109)

/* DMUS_E_ALREADY_LOADED
 *
 * Second attempt to load a DLS collection that is currently open. 
 */
#define DMUS_E_ALREADY_LOADED           MAKE_DMHRESULTERROR(0x0111)

/* DMUS_E_INVALIDPOS
 *
 * Error reading wave data from DLS collection. Indicates bad file.
 */
#define DMUS_E_INVALIDPOS               MAKE_DMHRESULTERROR(0x0113)

/* DMUS_E_INVALIDPATCH
 *
 * There is no instrument in the collection that matches patch number.
 */
#define DMUS_E_INVALIDPATCH             MAKE_DMHRESULTERROR(0x0114)

/* DMUS_E_CANNOTSEEK
 *
 * The IStream* doesn't support Seek().
 */
#define DMUS_E_CANNOTSEEK               MAKE_DMHRESULTERROR(0x0115)

/* DMUS_E_CANNOTWRITE
 *
 * The IStream* doesn't support Write().
 */
#define DMUS_E_CANNOTWRITE              MAKE_DMHRESULTERROR(0x0116)

/* DMUS_E_CHUNKNOTFOUND
 *
 * The RIFF parser doesn't contain a required chunk while parsing file.
 */
#define DMUS_E_CHUNKNOTFOUND            MAKE_DMHRESULTERROR(0x0117)

/* DMUS_E_INVALID_DOWNLOADID
 *
 * Invalid download id was used in the process of creating a download buffer.
 */
#define DMUS_E_INVALID_DOWNLOADID       MAKE_DMHRESULTERROR(0x0119)

/* DMUS_E_NOT_DOWNLOADED_TO_PORT
 *
 * Tried to unload an object that was not downloaded or previously unloaded.
 */
#define DMUS_E_NOT_DOWNLOADED_TO_PORT   MAKE_DMHRESULTERROR(0x0120)

/* DMUS_E_ALREADY_DOWNLOADED
 *
 * Buffer was already downloaded to synth.
 */
#define DMUS_E_ALREADY_DOWNLOADED       MAKE_DMHRESULTERROR(0x0121)

/* DMUS_E_UNKNOWN_PROPERTY
 *
 * The specified property item was not recognized by the target object.
 */
#define DMUS_E_UNKNOWN_PROPERTY         MAKE_DMHRESULTERROR(0x0122)

/* DMUS_E_SET_UNSUPPORTED
 *
 * The specified property item may not be set on the target object.
 */
#define DMUS_E_SET_UNSUPPORTED          MAKE_DMHRESULTERROR(0x0123)

/* DMUS_E_GET_UNSUPPORTED
 *
 * The specified property item may not be retrieved from the target object.
 */ 
#define DMUS_E_GET_UNSUPPORTED          MAKE_DMHRESULTERROR(0x0124)

/* DMUS_E_NOTMONO
 *
 * Wave chunk has more than one interleaved channel. DLS format requires MONO.
 */
#define DMUS_E_NOTMONO                  MAKE_DMHRESULTERROR(0x0125)

/* DMUS_E_BADARTICULATION
 *
 * Invalid articulation chunk in DLS collection.
 */
#define DMUS_E_BADARTICULATION          MAKE_DMHRESULTERROR(0x0126)

/* DMUS_E_BADINSTRUMENT
 *
 * Invalid instrument chunk in DLS collection.
 */
#define DMUS_E_BADINSTRUMENT            MAKE_DMHRESULTERROR(0x0127)

/* DMUS_E_BADWAVELINK
 *
 * Wavelink chunk in DLS collection points to invalid wave.
 */
#define DMUS_E_BADWAVELINK              MAKE_DMHRESULTERROR(0x0128)

/* DMUS_E_NOARTICULATION
 *
 * Articulation missing from instrument in DLS collection.
 */
#define DMUS_E_NOARTICULATION           MAKE_DMHRESULTERROR(0x0129)

/* DMUS_E_NOTPCM
 *
 * Downoaded DLS wave is not in PCM format. 
*/
#define DMUS_E_NOTPCM                   MAKE_DMHRESULTERROR(0x012A)

/* DMUS_E_BADWAVE
 *
 * Bad wave chunk in DLS collection
 */
#define DMUS_E_BADWAVE                  MAKE_DMHRESULTERROR(0x012B)

/* DMUS_E_BADOFFSETTABLE
 *
 * Offset Table for download buffer has errors. 
 */
#define DMUS_E_BADOFFSETTABLE           MAKE_DMHRESULTERROR(0x012C)

/* DMUS_E_UNKNOWNDOWNLOAD
 *
 * Attempted to download unknown data type.
 */
#define DMUS_E_UNKNOWNDOWNLOAD          MAKE_DMHRESULTERROR(0x012D)

/* DMUS_E_NOSYNTHSINK
 *
 * The operation could not be completed because no sink was connected to
 * the synthesizer.
 */
#define DMUS_E_NOSYNTHSINK              MAKE_DMHRESULTERROR(0x012E)

/* DMUS_E_ALREADYOPEN
 *
 * An attempt was made to open the software synthesizer while it was already 
 * open.
 * ASSERT?
 */
#define DMUS_E_ALREADYOPEN              MAKE_DMHRESULTERROR(0x012F)

/* DMUS_E_ALREADYCLOSE
 *
 * An attempt was made to close the software synthesizer while it was already 
 * open.
 * ASSERT?
 */
#define DMUS_E_ALREADYCLOSED            MAKE_DMHRESULTERROR(0x0130)

/* DMUS_E_SYNTHNOTCONFIGURED
 *
 * The operation could not be completed because the software synth has not 
 * yet been fully configured.
 * ASSERT?
 */
#define DMUS_E_SYNTHNOTCONFIGURED       MAKE_DMHRESULTERROR(0x0131)

/* DMUS_E_SYNTHACTIVE
 *
 * The operation cannot be carried out while the synthesizer is active.
 */
#define DMUS_E_SYNTHACTIVE              MAKE_DMHRESULTERROR(0x0132)

/* DMUS_E_CANNOTREAD
 *
 * An error occurred while attempting to read from the IStream* object.
 */
#define DMUS_E_CANNOTREAD               MAKE_DMHRESULTERROR(0x0133)

/* DMUS_E_DMUSIC_RELEASED
 *
 * The operation cannot be performed because the final instance of the
 * DirectMusic object was released. Ports cannot be used after final 
 * release of the DirectMusic object.
 */
#define DMUS_E_DMUSIC_RELEASED          MAKE_DMHRESULTERROR(0x0134)

/* DMUS_E_BUFFER_EMPTY
 *
 * There was no data in the referenced buffer.
 */
#define DMUS_E_BUFFER_EMPTY             MAKE_DMHRESULTERROR(0x0135)

/* DMUS_E_BUFFER_FULL
 *
 * There is insufficient space to insert the given event into the buffer.
 */
#define DMUS_E_BUFFER_FULL              MAKE_DMHRESULTERROR(0x0136)

/* DMUS_E_PORT_NOT_CAPTURE
 *
 * The given operation could not be carried out because the port is a
 * capture port.
 */
#define DMUS_E_PORT_NOT_CAPTURE         MAKE_DMHRESULTERROR(0x0137)

/* DMUS_E_PORT_NOT_RENDER
 *
 * The given operation could not be carried out because the port is a
 * render port.
 */
#define DMUS_E_PORT_NOT_RENDER          MAKE_DMHRESULTERROR(0x0138)

/* DMUS_E_DSOUND_NOT_SET
 *
 * The port could not be created because no DirectSound has been specified.
 * Specify a DirectSound interface via the IDirectMusic::SetDirectSound
 * method; pass NULL to have DirectMusic manage usage of DirectSound.
 */
#define DMUS_E_DSOUND_NOT_SET           MAKE_DMHRESULTERROR(0x0139)

/* DMUS_E_ALREADY_ACTIVATED
 *
 * The operation cannot be carried out while the port is active.
 */
#define DMUS_E_ALREADY_ACTIVATED        MAKE_DMHRESULTERROR(0x013A)

/* DMUS_E_INVALIDBUFFER
 *
 * Invalid DirectSound buffer was handed to port. 
 */
#define DMUS_E_INVALIDBUFFER            MAKE_DMHRESULTERROR(0x013B)

/* DMUS_E_WAVEFORMATNOTSUPPORTED
 *
 * Invalid buffer format was handed to the synth sink.
 */
#define DMUS_E_WAVEFORMATNOTSUPPORTED   MAKE_DMHRESULTERROR(0x013C)

/* DMUS_E_SYNTHINACTIVE
 *
 * The operation cannot be carried out while the synthesizer is inactive.
 */
#define DMUS_E_SYNTHINACTIVE            MAKE_DMHRESULTERROR(0x013D)

/* DMUS_E_DSOUND_ALREADY_SET
 *
 * IDirectMusic::SetDirectSound has already been called. It may not be
 * changed while in use.
 */
#define DMUS_E_DSOUND_ALREADY_SET       MAKE_DMHRESULTERROR(0x013E)

/* DMUS_E_INVALID_EVENT
 *
 * The given event is invalid (either it is not a valid MIDI message
 * or it makes use of running status). The event cannot be packed
 * into the buffer.
 */
#define DMUS_E_INVALID_EVENT            MAKE_DMHRESULTERROR(0x013F)

/* DMUS_E_UNSUPPORTED_STREAM
 *
 * The IStream* object does not contain data supported by the loading object.
 */
#define DMUS_E_UNSUPPORTED_STREAM       MAKE_DMHRESULTERROR(0x0150)

/* DMUS_E_ALREADY_INITED
 *
 * The object has already been initialized.
 */
#define DMUS_E_ALREADY_INITED           MAKE_DMHRESULTERROR(0x0151)

/* DMUS_E_INVALID_BAND
 *
 * The file does not contain a valid band.
 */
#define DMUS_E_INVALID_BAND             MAKE_DMHRESULTERROR(0x0152)

/* DMUS_E_TRACK_HDR_NOT_FIRST_CK
 *
 * The IStream* object's data does not have a track header as the first chunk,
 * and therefore can not be read by the segment object.
 */
#define DMUS_E_TRACK_HDR_NOT_FIRST_CK   MAKE_DMHRESULTERROR(0x0155)

/* DMUS_E_TOOL_HDR_NOT_FIRST_CK
 *
 * The IStream* object's data does not have a tool header as the first chunk,
 * and therefore can not be read by the graph object.
 */
#define DMUS_E_TOOL_HDR_NOT_FIRST_CK    MAKE_DMHRESULTERROR(0x0156)

/* DMUS_E_INVALID_TRACK_HDR
 *
 * The IStream* object's data contains an invalid track header (ckid is 0 and
 * fccType is NULL,) and therefore can not be read by the segment object.
 */
#define DMUS_E_INVALID_TRACK_HDR        MAKE_DMHRESULTERROR(0x0157)

/* DMUS_E_INVALID_TOOL_HDR
 *
 * The IStream* object's data contains an invalid tool header (ckid is 0 and
 * fccType is NULL,) and therefore can not be read by the graph object.
 */
#define DMUS_E_INVALID_TOOL_HDR         MAKE_DMHRESULTERROR(0x0158)

/* DMUS_E_ALL_TOOLS_FAILED
 *
 * The graph object was unable to load all tools from the IStream* object data.
 * This may be due to errors in the stream, or the tools being incorrectly
 * registered on the client.
 */
#define DMUS_E_ALL_TOOLS_FAILED         MAKE_DMHRESULTERROR(0x0159)

/* DMUS_E_ALL_TRACKS_FAILED
 *
 * The segment object was unable to load all tracks from the IStream* object data.
 * This may be due to errors in the stream, or the tracks being incorrectly
 * registered on the client.
 */
#define DMUS_E_ALL_TRACKS_FAILED        MAKE_DMHRESULTERROR(0x0160)

/* DMUS_E_NOT_FOUND
 *
 * The requested item was not contained by the object.
 */
#define DMUS_E_NOT_FOUND                MAKE_DMHRESULTERROR(0x0161)

/* DMUS_E_NOT_INIT
 *
 * A required object is not initialized or failed to initialize.
 */
#define DMUS_E_NOT_INIT                 MAKE_DMHRESULTERROR(0x0162)

/* DMUS_E_TYPE_DISABLED
 *
 * The requested parameter type is currently disabled. Parameter types may
 * be enabled and disabled by certain calls to SetParam().
 */
#define DMUS_E_TYPE_DISABLED            MAKE_DMHRESULTERROR(0x0163)

/* DMUS_E_TYPE_UNSUPPORTED
 *
 * The requested parameter type is not supported on the object.
 */
#define DMUS_E_TYPE_UNSUPPORTED         MAKE_DMHRESULTERROR(0x0164)

/* DMUS_E_TIME_PAST
 *
 * The time is in the past, and the operation can not succeed.
 */
#define DMUS_E_TIME_PAST                MAKE_DMHRESULTERROR(0x0165)

/* DMUS_E_TRACK_NOT_FOUND
 *
 * The requested track is not contained by the segment.
 */
#define DMUS_E_TRACK_NOT_FOUND			MAKE_DMHRESULTERROR(0x0166)

/* DMUS_E_TRACK_NO_CLOCKTIME_SUPPORT
 *
 * The track does not support clock time playback or getparam.
 */
#define DMUS_E_TRACK_NO_CLOCKTIME_SUPPORT   MAKE_DMHRESULTERROR(0x0167)
 
/* DMUS_E_NO_MASTER_CLOCK
 *
 * There is no master clock in the performance. Be sure to call
 * IDirectMusicPerformance::Init().
 */
#define DMUS_E_NO_MASTER_CLOCK          MAKE_DMHRESULTERROR(0x0170)

/* DMUS_E_LOADER_NOCLASSID
 *
 * The class id field is required and missing in the DMUS_OBJECTDESC.
 */
#define DMUS_E_LOADER_NOCLASSID         MAKE_DMHRESULTERROR(0x0180)

/* DMUS_E_LOADER_BADPATH
 *
 * The requested file path is invalid.
 */
#define DMUS_E_LOADER_BADPATH           MAKE_DMHRESULTERROR(0x0181)

/* DMUS_E_LOADER_FAILEDOPEN
 *
 * File open failed - either file doesn't exist or is locked.
 */
#define DMUS_E_LOADER_FAILEDOPEN        MAKE_DMHRESULTERROR(0x0182)

/* DMUS_E_LOADER_FORMATNOTSUPPORTED
 *
 * Search data type is not supported.
 */
#define DMUS_E_LOADER_FORMATNOTSUPPORTED    MAKE_DMHRESULTERROR(0x0183)

/* DMUS_E_LOADER_FAILEDCREATE
 *
 * Unable to find or create object.
 */
#define DMUS_E_LOADER_FAILEDCREATE      MAKE_DMHRESULTERROR(0x0184)

/* DMUS_E_LOADER_OBJECTNOTFOUND
 *
 * Object was not found.
 */
#define DMUS_E_LOADER_OBJECTNOTFOUND    MAKE_DMHRESULTERROR(0x0185)

/* DMUS_E_LOADER_NOFILENAME
 *
 * The file name is missing from the DMUS_OBJECTDESC.
 */
#define DMUS_E_LOADER_NOFILENAME	    MAKE_DMHRESULTERROR(0x0186)

/* DMUS_E_INVALIDFILE
 *
 * The file requested is not a valid file.
 */
#define DMUS_E_INVALIDFILE              MAKE_DMHRESULTERROR(0x0200)

/* DMUS_E_ALREADY_EXISTS
 *
 * The tool is already contained in the graph. Create a new instance.
 */
#define DMUS_E_ALREADY_EXISTS           MAKE_DMHRESULTERROR(0x0201)

/* DMUS_E_OUT_OF_RANGE
 *
 * Value is out of range, for instance the requested length is longer than
 * the segment.
 */
#define DMUS_E_OUT_OF_RANGE             MAKE_DMHRESULTERROR(0x0202)

/* DMUS_E_SEGMENT_INIT_FAILED
 *
 * Segment initialization failed, most likely due to a critical memory situation.
 */
#define DMUS_E_SEGMENT_INIT_FAILED      MAKE_DMHRESULTERROR(0x0203)

/* DMUS_E_ALREADY_SENT
 *
 * The DMUS_PMSG has already been sent to the performance object via
 * IDirectMusicPerformance::SendPMsg().
 */
#define DMUS_E_ALREADY_SENT             MAKE_DMHRESULTERROR(0x0204)

/* DMUS_E_CANNOT_FREE
 *
 * The DMUS_PMSG was either not allocated by the performance via
 * IDirectMusicPerformance::AllocPMsg(), or it was already freed via
 * IDirectMusicPerformance::FreePMsg().
 */
#define DMUS_E_CANNOT_FREE              MAKE_DMHRESULTERROR(0x0205)

/* DMUS_E_CANNOT_OPEN_PORT
 *
 * The default system port could not be opened.
 */
#define DMUS_E_CANNOT_OPEN_PORT         MAKE_DMHRESULTERROR(0x0206)

/* DMUS_E_CANNOT_CONVERT
 *
 * A call to MIDIToMusic() or MusicToMIDI() resulted in an error because
 * the requested conversion could not happen. This usually occurs when the
 * provided DMUS_CHORD_KEY structure has an invalid chord or scale pattern.
 */
#define DMUS_E_CANNOT_CONVERT           MAKE_DMHRESULTERROR(0x0207)
/* misspelling in previous versions of DirectX preserved for backward compatibility */
#define DMUS_E_CONNOT_CONVERT           DMUS_E_CANNOT_CONVERT

/* DMUS_E_DESCEND_CHUNK_FAIL
 * 
 * DMUS_E_DESCEND_CHUNK_FAIL is returned when the end of the file 
 * was reached before the desired chunk was found.
 */
#define DMUS_E_DESCEND_CHUNK_FAIL       MAKE_DMHRESULTERROR(0x0210)

/* DMUS_E_NOT_LOADED
 *
 * An attempt to use this object failed because it first needs to
 * be loaded.
 */
#define DMUS_E_NOT_LOADED               MAKE_DMHRESULTERROR(0x0211)

/* DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE
 *
 * The activeX scripting engine for the script's language is not compatible with
 * DirectMusic.
 *
 */
#define DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE  MAKE_DMHRESULTERROR(0x0213)

/* DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE
 *
 * A varient was used that had a type that is not supported by DirectMusic.
 *
 */
#define DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE    MAKE_DMHRESULTERROR(0x0214)

/* DMUS_E_SCRIPT_ERROR_IN_SCRIPT
 *
 * An error was encountered while parsing or executing the script.
 * The pErrorInfo parameter (if supplied) was filled with information about the error.
 */
#define DMUS_E_SCRIPT_ERROR_IN_SCRIPT        MAKE_DMHRESULTERROR(0x0215)

/* DMUS_E_SCRIPT_CANTLOAD_OLEAUT32
 *
 * Loading of oleaut32.dll failed.  VBScript and other activeX scripting languages
 * require use of oleaut32.dll.  On platforms where oleaut32.dll is not present, only
 * the DirectMusicScript language, which doesn't require oleaut32.dll can be used.
 */
#define DMUS_E_SCRIPT_CANTLOAD_OLEAUT32      MAKE_DMHRESULTERROR(0x0216)

/* DMUS_E_SCRIPT_LOADSCRIPT_ERROR
 *
 * An error occured while parsing a script loaded using LoadScript.  The script that
 * was loaded contains an error.
 */
#define DMUS_E_SCRIPT_LOADSCRIPT_ERROR       MAKE_DMHRESULTERROR(0x0217)

/* DMUS_E_SCRIPT_INVALID_FILE
 *
 * The script file is invalid.
 */
#define DMUS_E_SCRIPT_INVALID_FILE           MAKE_DMHRESULTERROR(0x0218)

/* DMUS_E_INVALID_SCRIPTTRACK
 *
 * The file contains an invalid script track.
 */
#define DMUS_E_INVALID_SCRIPTTRACK           MAKE_DMHRESULTERROR(0x0219)

/* DMUS_E_SCRIPT_VARIABLE_NOT_FOUND
 *
 * The script does not contain a variable with the specified name.
 */
#define DMUS_E_SCRIPT_VARIABLE_NOT_FOUND     MAKE_DMHRESULTERROR(0x021A)

/* DMUS_E_SCRIPT_ROUTINE_NOT_FOUND
 *
 * The script does not contain a routine with the specified name.
 */
#define DMUS_E_SCRIPT_ROUTINE_NOT_FOUND      MAKE_DMHRESULTERROR(0x021B)

/* DMUS_E_SCRIPT_CONTENT_READONLY
 *
 * Scripts variables for content referenced or embedded in a script cannot be set.
 */
#define DMUS_E_SCRIPT_CONTENT_READONLY       MAKE_DMHRESULTERROR(0x021C)

/* DMUS_E_SCRIPT_NOT_A_REFERENCE
 *
 * Attempt was made to set a script's variable by reference to a value that was
 * not an object type.
 */
#define DMUS_E_SCRIPT_NOT_A_REFERENCE        MAKE_DMHRESULTERROR(0x021D)

/* DMUS_E_SCRIPT_VALUE_NOT_SUPPORTED
 *
 * Attempt was made to set a script's variable by value to an object that does
 * not support a default value property.
 */
#define DMUS_E_SCRIPT_VALUE_NOT_SUPPORTED    MAKE_DMHRESULTERROR(0x021E)

/* DMUS_E_INVALID_SEGMENTTRIGGERTRACK
 *
 * The file contains an invalid segment trigger track.
 */
#define DMUS_E_INVALID_SEGMENTTRIGGERTRACK   MAKE_DMHRESULTERROR(0x0220)

/* DMUS_E_INVALID_LYRICSTRACK
 *
 * The file contains an invalid lyrics track.
 */
#define DMUS_E_INVALID_LYRICSTRACK           MAKE_DMHRESULTERROR(0x0221)

/* DMUS_E_INVALID_PARAMCONTROLTRACK
 *
 * The file contains an invalid parameter control track.
 */
#define DMUS_E_INVALID_PARAMCONTROLTRACK     MAKE_DMHRESULTERROR(0x0222)

/* DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR
 *
 * A script written in AudioVBScript could not be read because it contained a statement that
 * is not allowed by the AudioVBScript language.
 */
#define DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR     MAKE_DMHRESULTERROR(0x0223)

/* DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR
 *
 * A script routine written in AudioVBScript failed because an invalid operation occurred.  For example,
 * adding the number 3 to a segment object would produce this error.  So would attempting to call a routine
 * that doesn't exist.
 */
#define DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR     MAKE_DMHRESULTERROR(0x0224)

/* DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE
 *
 * A script routine written in AudioVBScript failed because a function outside of a script failed to complete.
 * For example, a call to PlaySegment that fails to play because of low memory would return this error.
 */
#define DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE     MAKE_DMHRESULTERROR(0x0225)

/* DMUS_E_AUDIOPATHS_NOT_VALID
 *
 * The Performance has set up some PChannels using the AssignPChannel command, which 
 * makes it not capable of supporting audio paths.
 */
#define DMUS_E_AUDIOPATHS_NOT_VALID     MAKE_DMHRESULTERROR(0x0226)

/* DMUS_E_AUDIOPATHS_IN_USE
 *
 * This is the inverse of the previous error. 
 * The Performance has set up some audio paths, which makes is incompatible
 * with the calls to allocate pchannels, etc. 
 */
#define DMUS_E_AUDIOPATHS_IN_USE     MAKE_DMHRESULTERROR(0x0227)

/* DMUS_E_NO_AUDIOPATH_CONFIG
 *
 * A segment or song was asked for its embedded audio path configuration,
 * but there isn't any. 
 */
#define DMUS_E_NO_AUDIOPATH_CONFIG     MAKE_DMHRESULTERROR(0x0228)

/* DMUS_E_AUDIOPATH_INACTIVE
 *
 * An audiopath is inactive, perhaps because closedown was called.
 */
#define DMUS_E_AUDIOPATH_INACTIVE     MAKE_DMHRESULTERROR(0x0229)

/* DMUS_E_AUDIOPATH_NOBUFFER
 *
 * An audiopath failed to create because a requested buffer could not be created.
 */
#define DMUS_E_AUDIOPATH_NOBUFFER     MAKE_DMHRESULTERROR(0x022A)

/* DMUS_E_AUDIOPATH_NOPORT
 *
 * An audiopath could not be used for playback because it lacked port assignments.
 */
#define DMUS_E_AUDIOPATH_NOPORT     MAKE_DMHRESULTERROR(0x022B)

/* DMUS_E_NO_AUDIOPATH
 *
 * Attempt was made to play segment in audiopath mode and there was no audiopath.
 */
#define DMUS_E_NO_AUDIOPATH     MAKE_DMHRESULTERROR(0x022C)

/* DMUS_E_INVALIDCHUNK
 *
 * Invalid data was found in a RIFF file chunk.
 */
#define DMUS_E_INVALIDCHUNK     MAKE_DMHRESULTERROR(0x022D)

/* DMUS_E_AUDIOPATH_NOGLOBALFXBUFFER
 *
 * Attempt was made to create an audiopath that sends to a global effects buffer which did not exist.
 */
#define DMUS_E_AUDIOPATH_NOGLOBALFXBUFFER     MAKE_DMHRESULTERROR(0x022E)

/* DMUS_E_INVALID_CONTAINER_OBJECT
 *
 * The file does not contain a valid container object.
 */
#define DMUS_E_INVALID_CONTAINER_OBJECT    MAKE_DMHRESULTERROR(0x022F)

#endif
#else
#include "dmusicip.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dmusic\inc\dmplugin.h ===
/************************************************************************
*                                                                       *
*   dmplugin.h -- This module contains the API for plugins for the      *
*                 DirectMusic performance layer                         *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corporation                       *
*                                                                       *
************************************************************************/

#ifndef _DMPLUGIN_
#define _DMPLUGIN_

#ifdef XBOX
#include <xtl.h>
#include <xobjbase.h>
#else
#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>
#include <mmsystem.h>
#endif // XBOX

#include <dmusicip.h>

#include <pshpack8.h>

#ifdef __cplusplus
extern "C" {
#endif

interface IDirectMusicTrack;
//interface IDirectMusicTool;
//interface IDirectMusicTool8;
interface IDirectMusicTrack8;
interface IDirectMusicPerformance;
interface IDirectMusicSegment;
interface IDirectMusicSegmentState;
interface IDirectMusicGraph;
#ifndef __cplusplus 
typedef interface IDirectMusicTrack IDirectMusicTrack;
//typedef interface IDirectMusicTool IDirectMusicTool;
//typedef interface IDirectMusicTool8 IDirectMusicTool8;
typedef interface IDirectMusicTrack8 IDirectMusicTrack8;
typedef interface IDirectMusicPerformance IDirectMusicPerformance;
typedef interface IDirectMusicSegment IDirectMusicSegment;
typedef interface IDirectMusicSegmentState IDirectMusicSegmentState;
typedef interface IDirectMusicGraph IDirectMusicGraph;
#endif

typedef struct _DMUS_PMSG DMUS_PMSG;
typedef long              MUSIC_TIME;

/* Registry location for tools */
#define DMUS_REGSTR_PATH_TOOLS  "Software\\Microsoft\\DirectMusic\\Tools"

 
/* The following flags are sent in the IDirectMusicTrack::Play() method */
/* inside the dwFlags parameter */
typedef enum enumDMUS_TRACKF_FLAGS
{
    DMUS_TRACKF_SEEK            = 1,      /* set on a seek */
    DMUS_TRACKF_LOOP            = 2,      /* set on a loop (repeat) */
    DMUS_TRACKF_START           = 4,      /* set on first call to Play */
    DMUS_TRACKF_FLUSH           = 8,      /* set when this call is in response to a flush on the perfomance */
    DMUS_TRACKF_DIRTY           = 0x10,   /* set when the track should consider any cached values from a previous call to GetParam to be invalidated */
    /* The following flags are DX8 only. */
    DMUS_TRACKF_NOTIFY_OFF      = 0x20,   /* tells track not to send notifications. */
    DMUS_TRACKF_PLAY_OFF        = 0x40,   /* tells track not to play anything (but can still send notifications.) */
    DMUS_TRACKF_LOOPEND         = 0x80,   /* set when the end of range is also a loop end. */
    DMUS_TRACKF_STOP            = 0x100,  /* set when the end of range is also end of playing this segment. */
    DMUS_TRACKF_RECOMPOSE       = 0x200,  /* set to indicate the track should compose. */
    DMUS_TRACKF_CLOCK           = 0x400,  /* set when time parameters are in reference (clock) time. Only valid for PlayEx(). */
} DMUS_TRACKF_FLAGS;

/* The following flags are sent in the IDirectMusicTrack8::GetParamEx() and SetParamEx() methods */
/* inside the dwFlags parameter */
#define DMUS_TRACK_PARAMF_CLOCK  0x01       /* set when the time is measured is in reference (clock) time */

/*////////////////////////////////////////////////////////////////////
// IDirectMusicTrack */
#undef  INTERFACE
#define INTERFACE  IDirectMusicTrack
DECLARE_INTERFACE_(IDirectMusicTrack, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)         (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)          (THIS) PURE;
    STDMETHOD_(ULONG,Release)         (THIS) PURE;

    /*  IDirectMusicTrack */
    STDMETHOD(Init)                   (THIS_ IDirectMusicSegment* pSegment) PURE;
    STDMETHOD(InitPlay)               (THIS_ IDirectMusicSegmentState* pSegmentState, 
                                             IDirectMusicPerformance* pPerformance, 
                                             void** ppStateData, 
                                             DWORD dwVirtualTrackID,
                                             DWORD dwFlags) PURE;
    STDMETHOD(EndPlay)                (THIS_ void* pStateData) PURE;
    STDMETHOD(Play)                   (THIS_ void* pStateData, 
                                             MUSIC_TIME mtStart, 
                                             MUSIC_TIME mtEnd, 
                                             MUSIC_TIME mtOffset, 
                                             DWORD dwFlags, 
                                             IDirectMusicPerformance* pPerf, 
                                             IDirectMusicSegmentState* pSegSt, 
                                             DWORD dwVirtualID) PURE;
    STDMETHOD(GetParam)               (THIS_ REFGUID rguidType, 
                                             MUSIC_TIME mtTime, 
                                             MUSIC_TIME* pmtNext, 
                                             void* pParam) PURE; 
    STDMETHOD(SetParam)               (THIS_ REFGUID rguidType, 
                                             MUSIC_TIME mtTime, 
                                             void* pParam) PURE;
    STDMETHOD(IsParamSupported)       (THIS_ REFGUID rguidType) PURE;
    STDMETHOD(AddNotificationType)    (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(RemoveNotificationType) (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(Clone)                  (THIS_ MUSIC_TIME mtStart, 
                                             MUSIC_TIME mtEnd, 
                                             IDirectMusicTrack** ppTrack) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDirectMusicTrack8 */
#undef  INTERFACE
#define INTERFACE  IDirectMusicTrack8
DECLARE_INTERFACE_(IDirectMusicTrack8, IDirectMusicTrack)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)         (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)          (THIS) PURE;
    STDMETHOD_(ULONG,Release)         (THIS) PURE;

    /*  IDirectMusicTrack */
    STDMETHOD(Init)                   (THIS_ IDirectMusicSegment* pSegment) PURE;
    STDMETHOD(InitPlay)               (THIS_ IDirectMusicSegmentState* pSegmentState, 
                                             IDirectMusicPerformance* pPerformance, 
                                             void** ppStateData, 
                                             DWORD dwVirtualTrackID,
                                             DWORD dwFlags) PURE;
    STDMETHOD(EndPlay)                (THIS_ void* pStateData) PURE;
    STDMETHOD(Play)                   (THIS_ void* pStateData, 
                                             MUSIC_TIME mtStart, 
                                             MUSIC_TIME mtEnd, 
                                             MUSIC_TIME mtOffset, 
                                             DWORD dwFlags, 
                                             IDirectMusicPerformance* pPerf, 
                                             IDirectMusicSegmentState* pSegSt, 
                                             DWORD dwVirtualID) PURE;
    STDMETHOD(GetParam)               (THIS_ REFGUID rguidType, 
                                             MUSIC_TIME mtTime, 
                                             MUSIC_TIME* pmtNext, 
                                             void* pParam) PURE; 
    STDMETHOD(SetParam)               (THIS_ REFGUID rguidType, 
                                             MUSIC_TIME mtTime, 
                                             void* pParam) PURE;
    STDMETHOD(IsParamSupported)       (THIS_ REFGUID rguidType) PURE;
    STDMETHOD(AddNotificationType)    (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(RemoveNotificationType) (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(Clone)                  (THIS_ MUSIC_TIME mtStart, 
                                             MUSIC_TIME mtEnd, 
                                             IDirectMusicTrack** ppTrack) PURE;
    /* IDirectMusicTrack8 */
    STDMETHOD(PlayEx)                 (THIS_ void* pStateData, 
                                             REFERENCE_TIME rtStart, 
                                             REFERENCE_TIME rtEnd, 
                                             REFERENCE_TIME rtOffset, 
                                             DWORD dwFlags, 
                                             IDirectMusicPerformance* pPerf, 
                                             IDirectMusicSegmentState* pSegSt, 
                                             DWORD dwVirtualID) PURE; 
    STDMETHOD(GetParamEx)             (THIS_ REFGUID rguidType,         /* Command type. */
                                             REFERENCE_TIME rtTime,     /* Time, in ref time if dwFlags == DMUS_TRACK_PARAMF_CLOCK. Otherwise, music time. */
                                             REFERENCE_TIME* prtNext,   /* Time of next parameter, relative to rtTime, in music or clock time units. */
                                             void* pParam,              /* Pointer to the parameter data. */
                                             void * pStateData,         /* State data for track instance. */
                                             DWORD dwFlags) PURE;       /* Control flags. */
    STDMETHOD(SetParamEx)             (THIS_ REFGUID rguidType, 
                                             REFERENCE_TIME rtTime, 
                                             void* pParam,              /* Pointer to the parameter data. */
                                             void * pStateData,         /* State data for track instance. */
                                             DWORD dwFlags) PURE;       /* Control flags. */
    STDMETHOD(Compose)                (THIS_ IUnknown* pContext,        /* Context for composition (song or segment) */
                                             DWORD dwTrackGroup,
                                             IDirectMusicTrack** ppResultTrack) PURE;
    STDMETHOD(Join)                   (THIS_ IDirectMusicTrack* pNewTrack,
                                             MUSIC_TIME mtJoin,
                                             IUnknown* pContext,        /* Context for joining (song or segment) */
                                             DWORD dwTrackGroup,
                                             IDirectMusicTrack** ppResultTrack) PURE;
};

/* CLSID's */
DEFINE_GUID(CLSID_DirectMusicTempoTrack,0xd2ac2885, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSeqTrack,0xd2ac2886, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSysExTrack,0xd2ac2887, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicTimeSigTrack,0xd2ac2888, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicChordTrack,0xd2ac288b, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicCommandTrack,0xd2ac288c, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicStyleTrack,0xd2ac288d, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicMotifTrack,0xd2ac288e, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSignPostTrack,0xf17e8672, 0xc3b4, 0x11d1, 0x87, 0xb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicBandTrack,0xd2ac2894, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicChordMapTrack,0xd2ac2896, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicMuteTrack,0xd2ac2898, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* New CLSID's for DX8 */
DEFINE_GUID(CLSID_DirectMusicScriptTrack,0x4108fa85, 0x3586, 0x11d3, 0x8b, 0xd7, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {4108FA85-3586-11d3-8BD7-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicMarkerTrack,0x55a8fd00, 0x4288, 0x11d3, 0x9b, 0xd1, 0x8a, 0xd, 0x61, 0xc8, 0x88, 0x35);
DEFINE_GUID(CLSID_DirectMusicSegmentTriggerTrack, 0xbae4d665, 0x4ea1, 0x11d3, 0x8b, 0xda, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {BAE4D665-4EA1-11d3-8BDA-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicLyricsTrack, 0x995c1cf5, 0x54ff, 0x11d3, 0x8b, 0xda, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {995C1CF5-54FF-11d3-8BDA-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicParamControlTrack, 0x4be0537b, 0x5c19, 0x11d3, 0x8b, 0xdc, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {4BE0537B-5C19-11d3-8BDC-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicMelodyFormulationTrack, 0xb0684266, 0xb57f, 0x11d2, 0x97, 0xf9, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);
DEFINE_GUID(CLSID_DirectMusicWaveTrack,0xeed36461, 0x9ea5, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);

/* IID's */
DEFINE_GUID(IID_IDirectMusicTrack, 0xf96029a1, 0x4282, 0x11d2, 0x87, 0x17, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
//DEFINE_GUID(IID_IDirectMusicTool,0xd2ac28ba, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Interface IDs for DX8 */
/* changed interfaces (GUID only) */
DEFINE_GUID(IID_IDirectMusicTool8, 0xe674303, 0x3b05, 0x11d3, 0x9b, 0xd1, 0xf9, 0xe7, 0xf0, 0xa0, 0x15, 0x36);
DEFINE_GUID(IID_IDirectMusicTrack8, 0xe674304, 0x3b05, 0x11d3, 0x9b, 0xd1, 0xf9, 0xe7, 0xf0, 0xa0, 0x15, 0x36);

#ifdef __cplusplus
}; /* extern "C" */
#endif

#include <poppack.h>

#endif /* #ifndef _DMPLUGIN_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dmusic\inc\dls2.h ===
/*
 
 	dls2.h
 	
 	Description:
 
 	Interface defines and structures for the DLS2 extensions of DLS.
 
 
     Written by Microsoft 1998.  Released for public use.
 
*/
 
#ifndef _INC_DLS2
#define _INC_DLS2
#ifdef XBOX
#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )				\
		( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
		( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif
#endif // XBOX

/*
     FOURCC's used in the DLS2 file, in addition to DLS1 chunks
*/
 
#define FOURCC_RGN2  mmioFOURCC('r','g','n','2')
#define FOURCC_LAR2  mmioFOURCC('l','a','r','2')
#define FOURCC_ART2  mmioFOURCC('a','r','t','2')
#define FOURCC_CDL   mmioFOURCC('c','d','l',' ')
#define FOURCC_DLID	 mmioFOURCC('d','l','i','d')
 
/*
     Articulation connection graph definitions. These are in addition to
     the definitions in the DLS1 header.
*/
 
/* Generic Sources (in addition to DLS1 sources. */
#define CONN_SRC_POLYPRESSURE		0x0007	/* Polyphonic Pressure */
#define CONN_SRC_CHANNELPRESSURE		0x0008	/* Channel Pressure */
#define CONN_SRC_VIBRATO			0x0009	/* Vibrato LFO */
#define CONN_SRC_MONOPRESSURE       	0x000a  /* MIDI Mono pressure */
 
 
/* Midi Controllers */
#define CONN_SRC_CC91			0x00db	/* Reverb Send */
#define CONN_SRC_CC93			0x00dd	/* Chorus Send */
 
 
/* Generic Destinations */
#define CONN_DST_GAIN			0x0001	/* Same as CONN_DST_ ATTENUATION, but more appropriate terminology. */
#define CONN_DST_KEYNUMBER 0x0005  /* Key Number Generator */
 
/* Audio Channel Output Destinations */
#define CONN_DST_LEFT			0x0010	/* Left Channel Send */
#define CONN_DST_RIGHT			0x0011	/* Right Channel Send */
#define CONN_DST_CENTER			0x0012	/* Center Channel Send */
#define CONN_DST_LEFTREAR			0x0013	/* Left Rear Channel Send */
#define CONN_DST_RIGHTREAR			0x0014	/* Right Rear Channel Send */
#define CONN_DST_LFE_CHANNEL		0x0015	/* LFE Channel Send */
#define CONN_DST_CHORUS			0x0080	/* Chorus Send */
#define CONN_DST_REVERB			0x0081	/* Reverb Send */
 
/* Vibrato LFO Destinations */
#define CONN_DST_VIB_FREQUENCY		0x0114	/* Vibrato Frequency */
#define CONN_DST_VIB_STARTDELAY		0x0115	/* Vibrato Start Delay */
 
/* EG1 Destinations */
#define CONN_DST_EG1_DELAYTIME		0x020B	/* EG1 Delay Time */
#define CONN_DST_EG1_HOLDTIME		0x020C	/* EG1 Hold Time */
#define CONN_DST_EG1_SHUTDOWNTIME		0x020D	/* EG1 Shutdown Time */
 
 
/*	EG2 Destinations */
#define CONN_DST_EG2_DELAYTIME		0x030F	/* EG2 Delay Time */
#define CONN_DST_EG2_HOLDTIME		0x0310	/* EG2 Hold Time */
 
 
/* Filter Destinations */
#define CONN_DST_FILTER_CUTOFF		0x0500	/* Filter Cutoff Frequency */
#define CONN_DST_FILTER_Q			0x0501	/* Filter Resonance */
 
 
/* Transforms */
#define CONN_TRN_CONVEX			0x0002	/* Convex Transform */
#define CONN_TRN_SWITCH			0x0003	/* Switch Transform */
 
 
/*	Conditional chunk operators */
 #define DLS_CDL_AND			0x0001	/* X = X & Y */
 #define DLS_CDL_OR			0x0002	/* X = X | Y */
 #define DLS_CDL_XOR			0x0003	/* X = X ^ Y */
 #define DLS_CDL_ADD			0x0004	/* X = X + Y */
 #define DLS_CDL_SUBTRACT		0x0005	/* X = X - Y */
 #define DLS_CDL_MULTIPLY		0x0006	/* X = X * Y */
 #define DLS_CDL_DIVIDE		0x0007	/* X = X / Y */
 #define DLS_CDL_LOGICAL_AND	0x0008	/* X = X && Y */
 #define DLS_CDL_LOGICAL_OR		0x0009	/* X = X || Y */
 #define DLS_CDL_LT			0x000A	/* X = (X < Y) */
 #define DLS_CDL_LE			0x000B	/* X = (X <= Y) */
 #define DLS_CDL_GT			0x000C	/* X = (X > Y) */
 #define DLS_CDL_GE			0x000D	/* X = (X >= Y) */
 #define DLS_CDL_EQ			0x000E	/* X = (X == Y) */
 #define DLS_CDL_NOT			0x000F	/* X = !X */
 #define DLS_CDL_CONST		0x0010	/* 32-bit constant */
 #define DLS_CDL_QUERY		0x0011	/* 32-bit value returned from query */
 #define DLS_CDL_QUERYSUPPORTED	0x0012	/* Test to see if query is supported by synth */
 
/*
  Loop and release
*/

#define WLOOP_TYPE_RELEASE 1

/*
  WaveLink chunk <wlnk-ck>
*/

#define F_WAVELINK_MULTICHANNEL 0x0002


/*
  DLSID queries for <cdl-ck>
*/

DEFINE_GUID(DLSID_GMInHardware, 0x178f2f24, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(DLSID_GSInHardware, 0x178f2f25, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(DLSID_XGInHardware, 0x178f2f26, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(DLSID_SupportsDLS1, 0x178f2f27, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(DLSID_SupportsDLS2, 0xf14599e5, 0x4689, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(DLSID_SampleMemorySize, 0x178f2f28, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(DLSID_ManufacturersID, 0xb03e1181, 0x8095, 0x11d2, 0xa1, 0xef, 0x0, 0x60, 0x8, 0x33, 0xdb, 0xd8);
DEFINE_GUID(DLSID_ProductID, 0xb03e1182, 0x8095, 0x11d2, 0xa1, 0xef, 0x0, 0x60, 0x8, 0x33, 0xdb, 0xd8);
DEFINE_GUID(DLSID_SamplePlaybackRate, 0x2a91f713, 0xa4bf, 0x11d2, 0xbb, 0xdf, 0x0, 0x60, 0x8, 0x33, 0xdb, 0xd8);

#endif	/* _INC_DLS2 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dmusic\inc\dmusicc.h ===
/************************************************************************
*                                                                       *
*   dmusicc.h -- This module defines the DirectMusic core API's         *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corporation
*                                                                       *
************************************************************************/

#ifndef _DMUSICC_
#define _DMUSICC_

#ifdef XBOX
#include <xtl.h>
#else // XBOX
#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>
#endif // XBOX

#ifndef XBOX
#include <mmsystem.h>
#endif // XBOX

#include "dls1.h"
#include "dmerror.h"
#include "dmdls.h"
#include "dsound.h"
#include "dmusbuff.h"

#include <pshpack8.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef ULONGLONG    SAMPLE_TIME;
typedef ULONGLONG    SAMPLE_POSITION;	
typedef SAMPLE_TIME *LPSAMPLE_TIME;

#define DMUS_MAX_DESCRIPTION 128
#define DMUS_MAX_DRIVER 128

typedef struct _DMUS_BUFFERDESC *LPDMUS_BUFFERDESC;
typedef struct _DMUS_BUFFERDESC
{
    DWORD dwSize;
    DWORD dwFlags;
    GUID guidBufferFormat;
    DWORD cbBuffer;
} DMUS_BUFFERDESC;

/* DMUS_EFFECT_ flags are used in the dwEffectFlags fields of both DMUS_PORTCAPS 
 * and DMUS_PORTPARAMS.
 */
#define DMUS_EFFECT_NONE             0x00000000
#define DMUS_EFFECT_REVERB           0x00000001
#define DMUS_EFFECT_CHORUS           0x00000002

/* For DMUS_PORTCAPS dwClass
 */ 
#define DMUS_PC_INPUTCLASS       (0)
#define DMUS_PC_OUTPUTCLASS      (1)

/* For DMUS_PORTCAPS dwFlags
 */
#define DMUS_PC_DLS              (0x00000001)   // Supports DLS downloading and DLS level 1.
#define DMUS_PC_EXTERNAL         (0x00000002)   // External MIDI module.
#define DMUS_PC_SOFTWARESYNTH    (0x00000004)   // Software synthesizer.
#define DMUS_PC_MEMORYSIZEFIXED  (0x00000008)   // Memory size is fixed.
#define DMUS_PC_GMINHARDWARE     (0x00000010)   // GM sound set is built in, no need to download.
#define DMUS_PC_GSINHARDWARE     (0x00000020)   // GS sound set is built in.
#define DMUS_PC_XGINHARDWARE     (0x00000040)   // XG sound set is built in.
#define DMUS_PC_DIRECTSOUND      (0x00000080)   // Connects to DirectSound via a DSound buffer.
#define DMUS_PC_SHAREABLE        (0x00000100)   // Synth can be actively shared by multiple apps at once.
#define DMUS_PC_DLS2             (0x00000200)   // Supports DLS2 instruments.
#define DMUS_PC_AUDIOPATH        (0x00000400)   // Multiple outputs can be connected to DirectSound for audiopaths.
#define DMUS_PC_WAVE             (0x00000800)   // Supports streaming and one shot waves.

#define DMUS_PC_SYSTEMMEMORY     (0x7FFFFFFF)   // Sample memory is system memory.


typedef struct _DMUS_PORTCAPS
{
    DWORD   dwSize;
    DWORD   dwFlags;
    GUID    guidPort;
    DWORD   dwClass;
    DWORD   dwType;
    DWORD   dwMemorySize;
    DWORD   dwMaxChannelGroups;
    DWORD   dwMaxVoices;    
    DWORD   dwMaxAudioChannels;
    DWORD   dwEffectFlags;
    WCHAR   wszDescription[DMUS_MAX_DESCRIPTION];
} DMUS_PORTCAPS;

typedef DMUS_PORTCAPS *LPDMUS_PORTCAPS;

/* Values for DMUS_PORTCAPS dwType. This field indicates the underlying 
 * driver type of the port.
 */
#define DMUS_PORT_WINMM_DRIVER      (0)
#define DMUS_PORT_USER_MODE_SYNTH   (1)
#define DMUS_PORT_KERNEL_MODE       (2)

/* These flags (set in dwValidParams) indicate which other members of the */
/* DMUS_PORTPARAMS are valid. */
/* */
#define DMUS_PORTPARAMS_VOICES           0x00000001
#define DMUS_PORTPARAMS_CHANNELGROUPS    0x00000002
#define DMUS_PORTPARAMS_AUDIOCHANNELS    0x00000004
#define DMUS_PORTPARAMS_SAMPLERATE       0x00000008
#define DMUS_PORTPARAMS_EFFECTS          0x00000020
#define DMUS_PORTPARAMS_SHARE            0x00000040
#define DMUS_PORTPARAMS_FEATURES         0x00000080     /* DirectX 8.0 and above */

typedef struct _DMUS_PORTPARAMS
{
    DWORD   dwSize;
    DWORD   dwValidParams;
    DWORD   dwVoices;
    DWORD   dwChannelGroups;
    DWORD   dwAudioChannels;
    DWORD   dwSampleRate;
    DWORD   dwEffectFlags;
    BOOL    fShare;
} DMUS_PORTPARAMS7;

typedef struct _DMUS_PORTPARAMS8
{
    DWORD   dwSize;
    DWORD   dwValidParams;
    DWORD   dwVoices;
    DWORD   dwChannelGroups;
    DWORD   dwAudioChannels;
    DWORD   dwSampleRate;
    DWORD   dwEffectFlags;
    BOOL    fShare;
    DWORD   dwFeatures;
} DMUS_PORTPARAMS8;

#define DMUS_PORT_FEATURE_AUDIOPATH     0x00000001	/* Supports audiopath connection to DSound buffers. */
#define DMUS_PORT_FEATURE_STREAMING     0x00000002	/* Supports streaming waves through the synth. */


typedef DMUS_PORTPARAMS8 DMUS_PORTPARAMS;
typedef DMUS_PORTPARAMS *LPDMUS_PORTPARAMS;

typedef struct _DMUS_SYNTHSTATS *LPDMUS_SYNTHSTATS;
typedef struct _DMUS_SYNTHSTATS8 *LPDMUS_SYNTHSTATS8;
typedef struct _DMUS_SYNTHSTATS
{
    DWORD   dwSize;             /* Size in bytes of the structure */
    DWORD   dwValidStats;       /* Flags indicating which fields below are valid. */
    DWORD   dwVoices;           /* Average number of voices playing. */
    DWORD   dwTotalCPU;         /* Total CPU usage as percent * 100. */
    DWORD   dwCPUPerVoice;      /* CPU per voice as percent * 100. */
    DWORD   dwLostNotes;        /* Number of notes lost in 1 second. */
    DWORD   dwFreeMemory;       /* Free memory in bytes */
    long    lPeakVolume;        /* Decibel level * 100. */
} DMUS_SYNTHSTATS;

typedef struct _DMUS_SYNTHSTATS8
{
    DWORD   dwSize;             /* Size in bytes of the structure */
    DWORD   dwValidStats;       /* Flags indicating which fields below are valid. */
    DWORD   dwVoices;           /* Average number of voices playing. */
    DWORD   dwTotalCPU;         /* Total CPU usage as percent * 100. */
    DWORD   dwCPUPerVoice;      /* CPU per voice as percent * 100. */
    DWORD   dwLostNotes;        /* Number of notes lost in 1 second. */
    DWORD   dwFreeMemory;       /* Free memory in bytes */
    long    lPeakVolume;        /* Decibel level * 100. */
	DWORD   dwSynthMemUse;		/* Memory used by synth wave data */ 
} DMUS_SYNTHSTATS8;

#define DMUS_SYNTHSTATS_VOICES          (1 << 0)
#define DMUS_SYNTHSTATS_TOTAL_CPU       (1 << 1)
#define DMUS_SYNTHSTATS_CPU_PER_VOICE   (1 << 2)
#define DMUS_SYNTHSTATS_LOST_NOTES      (1 << 3)
#define DMUS_SYNTHSTATS_PEAK_VOLUME     (1 << 4)
#define DMUS_SYNTHSTATS_FREE_MEMORY     (1 << 5)

#define DMUS_SYNTHSTATS_SYSTEMMEMORY    DMUS_PC_SYSTEMMEMORY

typedef struct _DMUS_WAVES_REVERB_PARAMS
{
    float   fInGain;        /* Input gain in dB (to avoid output overflows) */
    float   fReverbMix;     /* Reverb mix in dB. 0dB means 100% wet reverb (no direct signal)
                            Negative values gives less wet signal.
                            The coeficients are calculated so that the overall output level stays 
                            (approximately) constant regardless of the ammount of reverb mix. */
    float   fReverbTime;    /* The reverb decay time, in milliseconds. */
    float   fHighFreqRTRatio; /* The ratio of the high frequencies to the global reverb time. 
                            Unless very 'splashy-bright' reverbs are wanted, this should be set to 
                            a value < 1.0.
                            For example if dRevTime==1000ms and dHighFreqRTRatio=0.1 than the 
                            decay time for high frequencies will be 100ms.*/

} DMUS_WAVES_REVERB_PARAMS;

/*  Note: Default values for Reverb are:
    fInGain             = 0.0dB   (no change in level)
    fReverbMix          = -10.0dB   (a reasonable reverb mix)
    fReverbTime         = 1000.0ms (one second global reverb time)
    fHighFreqRTRatio    = 0.001    (the ratio of the high frequencies to the global reverb time) 
*/

typedef enum
{
    DMUS_CLOCK_SYSTEM = 0,
    DMUS_CLOCK_WAVE = 1
} DMUS_CLOCKTYPE;

#define DMUS_CLOCKF_GLOBAL              0x00000001

typedef struct _DMUS_CLOCKINFO7 *LPDMUS_CLOCKINFO7;
typedef struct _DMUS_CLOCKINFO7
{
    DWORD           dwSize;
    DMUS_CLOCKTYPE  ctType;
    GUID            guidClock;          /* Identifies this time source */
    WCHAR           wszDescription[DMUS_MAX_DESCRIPTION];
} DMUS_CLOCKINFO7;

typedef struct _DMUS_CLOCKINFO8 *LPDMUS_CLOCKINFO8;
typedef struct _DMUS_CLOCKINFO8
{
    DWORD           dwSize;
    DMUS_CLOCKTYPE  ctType;
    GUID            guidClock;          /* Identifies this time source */
    WCHAR           wszDescription[DMUS_MAX_DESCRIPTION];
    DWORD           dwFlags;           
} DMUS_CLOCKINFO8;

typedef DMUS_CLOCKINFO8 DMUS_CLOCKINFO;
typedef DMUS_CLOCKINFO *LPDMUS_CLOCKINFO;

/* Default bus identifiers
 *
 * The first 17 are direct mappings to the destinations defined in both
 * the MMA DLS Level 2 specification and the Microsoft Multi-Channel audio
 * specification.
 */
#define DSBUSID_FIRST_SPKR_LOC              0
#define DSBUSID_FRONT_LEFT                  0
#define DSBUSID_LEFT                        0   /* Front left is also just left */
#define DSBUSID_FRONT_RIGHT                 1
#define DSBUSID_RIGHT                       1   /* Ditto front right */ 
#define DSBUSID_FRONT_CENTER                2
#define DSBUSID_LOW_FREQUENCY               3
#define DSBUSID_BACK_LEFT                   4
#define DSBUSID_BACK_RIGHT                  5
#define DSBUSID_FRONT_LEFT_OF_CENTER        6 
#define DSBUSID_FRONT_RIGHT_OF_CENTER       7
#define DSBUSID_BACK_CENTER                 8
#define DSBUSID_SIDE_LEFT                   9
#define DSBUSID_SIDE_RIGHT                 10
#define DSBUSID_TOP_CENTER                 11
#define DSBUSID_TOP_FRONT_LEFT             12
#define DSBUSID_TOP_FRONT_CENTER           13
#define DSBUSID_TOP_FRONT_RIGHT            14
#define DSBUSID_TOP_BACK_LEFT              15
#define DSBUSID_TOP_BACK_CENTER            16
#define DSBUSID_TOP_BACK_RIGHT             17
#define DSBUSID_LAST_SPKR_LOC              17

#define DSBUSID_IS_SPKR_LOC(id) ( ((id) >= DSBUSID_FIRST_SPKR_LOC) && ((id) <= DSBUSID_LAST_SPKR_LOC) )

/* These bus identifiers are for the standard DLS effect sends 
 */
#define DSBUSID_REVERB_SEND                64
#define DSBUSID_CHORUS_SEND                65

/* Dynamic bus identifiers start here. See the documentation for how
 * synthesizers map the output of voices to static and dynamic
 * bus identifiers.
 */ 
#define DSBUSID_DYNAMIC_0                 512 

/* Null bus, used to identify busses that have no function mapping. 
*/
#define DSBUSID_NULL			   0xFFFFFFFF

interface IDirectMusic;
interface IDirectMusic8;
interface IDirectMusicBuffer;
interface IDirectMusicPort;
interface IDirectMusicThru;
interface IReferenceClock;

#ifndef __cplusplus 

typedef interface IDirectMusic IDirectMusic;
typedef interface IDirectMusic8 IDirectMusic8;
typedef interface IDirectMusicPort IDirectMusicPort;
typedef interface IDirectMusicBuffer IDirectMusicBuffer;
typedef interface IDirectMusicThru IDirectMusicThru;
typedef interface IReferenceClock IReferenceClock;

#endif  /* C++ */

typedef IDirectMusic *LPDIRECTMUSIC;
typedef IDirectMusic8 *LPDIRECTMUSIC8;
typedef IDirectMusicPort *LPDIRECTMUSICPORT;
typedef IDirectMusicBuffer *LPDIRECTMUSICBUFFER;

#undef  INTERFACE
#define INTERFACE  IDirectMusic
DECLARE_INTERFACE_(IDirectMusic, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusic */
    STDMETHOD(EnumPort)             (THIS_ DWORD dwIndex, 
                                           LPDMUS_PORTCAPS pPortCaps) PURE;
    STDMETHOD(CreateMusicBuffer)    (THIS_ LPDMUS_BUFFERDESC pBufferDesc, 
                                           LPDIRECTMUSICBUFFER *ppBuffer, 
                                           LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(CreatePort)           (THIS_ REFCLSID rclsidPort, 
                                           LPDMUS_PORTPARAMS pPortParams, 
                                           LPDIRECTMUSICPORT *ppPort, 
                                           LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(EnumMasterClock)      (THIS_ DWORD dwIndex, 
                                           LPDMUS_CLOCKINFO lpClockInfo) PURE;
    STDMETHOD(GetMasterClock)       (THIS_ LPGUID pguidClock, 
                                           IReferenceClock **ppReferenceClock) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ REFGUID rguidClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(GetDefaultPort)       (THIS_ LPGUID pguidPort) PURE;
    STDMETHOD(SetDirectSound)       (THIS_ LPDIRECTSOUND pDirectSound,
                                           HWND hWnd) PURE;
};

#undef  INTERFACE
#define INTERFACE  IDirectMusic8
DECLARE_INTERFACE_(IDirectMusic8, IDirectMusic)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusic */
    STDMETHOD(EnumPort)             (THIS_ DWORD dwIndex, 
                                           LPDMUS_PORTCAPS pPortCaps) PURE;
    STDMETHOD(CreateMusicBuffer)    (THIS_ LPDMUS_BUFFERDESC pBufferDesc, 
                                           LPDIRECTMUSICBUFFER *ppBuffer, 
                                           LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(CreatePort)           (THIS_ REFCLSID rclsidPort, 
                                           LPDMUS_PORTPARAMS pPortParams, 
                                           LPDIRECTMUSICPORT *ppPort, 
                                           LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(EnumMasterClock)      (THIS_ DWORD dwIndex, 
                                           LPDMUS_CLOCKINFO lpClockInfo) PURE;
    STDMETHOD(GetMasterClock)       (THIS_ LPGUID pguidClock, 
                                           IReferenceClock **ppReferenceClock) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ REFGUID rguidClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(GetDefaultPort)       (THIS_ LPGUID pguidPort) PURE;
    STDMETHOD(SetDirectSound)       (THIS_ LPDIRECTSOUND pDirectSound,
                                           HWND hWnd) PURE;
    /*  IDirectMusic8 */
    STDMETHOD(SetExternalMasterClock)
                                    (THIS_ IReferenceClock *pClock) PURE;                                          
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicBuffer
DECLARE_INTERFACE_(IDirectMusicBuffer, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicBuffer */
    STDMETHOD(Flush)                (THIS) PURE;
    STDMETHOD(TotalTime)            (THIS_ LPREFERENCE_TIME prtTime) PURE;
    
    STDMETHOD(PackStructured)       (THIS_ REFERENCE_TIME rt,
                                           DWORD dwChannelGroup,
                                           DWORD dwChannelMessage) PURE;
    
    STDMETHOD(PackUnstructured)     (THIS_ REFERENCE_TIME rt,
                                           DWORD dwChannelGroup,
                                           DWORD cb,
                                           LPBYTE lpb) PURE;
    
    STDMETHOD(ResetReadPtr)         (THIS) PURE;
    STDMETHOD(GetNextEvent)         (THIS_ LPREFERENCE_TIME prt,
                                           LPDWORD pdwChannelGroup,
                                           LPDWORD pdwLength,
                                           LPBYTE *ppData) PURE;

    STDMETHOD(GetRawBufferPtr)      (THIS_ LPBYTE *ppData) PURE;
    STDMETHOD(GetStartTime)         (THIS_ LPREFERENCE_TIME prt) PURE;
    STDMETHOD(GetUsedBytes)         (THIS_ LPDWORD pcb) PURE;
    STDMETHOD(GetMaxBytes)          (THIS_ LPDWORD pcb) PURE;
    STDMETHOD(GetBufferFormat)      (THIS_ LPGUID pGuidFormat) PURE;

    STDMETHOD(SetStartTime)         (THIS_ REFERENCE_TIME rt) PURE;
    STDMETHOD(SetUsedBytes)         (THIS_ DWORD cb) PURE;
};

typedef IDirectMusicBuffer IDirectMusicBuffer8;
typedef IDirectMusicBuffer8 *LPDIRECTMUSICBUFFER8;

#undef  INTERFACE
#define INTERFACE  IDirectMusicInstrument
DECLARE_INTERFACE_(IDirectMusicInstrument, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /* IDirectMusicInstrument */
    STDMETHOD(GetPatch)                 (THIS_ DWORD* pdwPatch) PURE;
    STDMETHOD(SetPatch)                 (THIS_ DWORD dwPatch) PURE;
};

typedef IDirectMusicInstrument IDirectMusicInstrument8;
typedef IDirectMusicInstrument8 *LPDIRECTMUSICINSTRUMENT8;

#undef  INTERFACE
#define INTERFACE  IDirectMusicDownloadedInstrument
DECLARE_INTERFACE_(IDirectMusicDownloadedInstrument, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /* IDirectMusicDownloadedInstrument */
    /* None at this time */
};

typedef IDirectMusicDownloadedInstrument IDirectMusicDownloadedInstrument8;
typedef IDirectMusicDownloadedInstrument8 *LPDIRECTMUSICDOWNLOADEDINSTRUMENT8;

#undef  INTERFACE
#define INTERFACE  IDirectMusicCollection
DECLARE_INTERFACE_(IDirectMusicCollection, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /* IDirectMusicCollection */
    STDMETHOD(GetInstrument)            (THIS_ DWORD dwPatch, 
                                               IDirectMusicInstrument** ppInstrument) PURE;
    STDMETHOD(EnumInstrument)           (THIS_ DWORD dwIndex, 
                                               DWORD* pdwPatch, 
                                               LPWSTR pwszName, 
                                               DWORD dwNameLen) PURE;
};

typedef IDirectMusicCollection IDirectMusicCollection8;
typedef IDirectMusicCollection8 *LPDIRECTMUSICCOLLECTION8;

#undef  INTERFACE
#define INTERFACE  IDirectMusicDownload 
DECLARE_INTERFACE_(IDirectMusicDownload , IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicDownload */
    STDMETHOD(GetBuffer)            (THIS_ void** ppvBuffer, 
                                           DWORD* pdwSize) PURE;
};

typedef IDirectMusicDownload IDirectMusicDownload8;
typedef IDirectMusicDownload8 *LPDIRECTMUSICDOWNLOAD8;

#undef  INTERFACE
#define INTERFACE  IDirectMusicPortDownload
DECLARE_INTERFACE_(IDirectMusicPortDownload, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicPortDownload */
    STDMETHOD(GetBuffer)            (THIS_ DWORD dwDLId, 
                                           IDirectMusicDownload** ppIDMDownload) PURE;
    STDMETHOD(AllocateBuffer)       (THIS_ DWORD dwSize, 
                                           IDirectMusicDownload** ppIDMDownload) PURE;
    STDMETHOD(GetDLId)              (THIS_ DWORD* pdwStartDLId, 
                                           DWORD dwCount) PURE;
    STDMETHOD(GetAppend)            (THIS_ DWORD* pdwAppend) PURE;
    STDMETHOD(Download)             (THIS_ IDirectMusicDownload* pIDMDownload) PURE;
    STDMETHOD(Unload)               (THIS_ IDirectMusicDownload* pIDMDownload) PURE;
};

typedef IDirectMusicPortDownload IDirectMusicPortDownload8;
typedef IDirectMusicPortDownload8 *LPDIRECTMUSICPORTDOWNLOAD8;

/* Standard values for voice priorities. Numerically higher priorities are higher in priority.
 * These priorities are used to set the voice priority for all voices on a channel. They are
 * used in the dwPriority parameter of IDirectMusicPort::GetPriority and returned in the
 * lpwPriority parameter of pdwPriority.
 *
 * These priorities are shared with DirectSound.
 */

#ifndef _DIRECTAUDIO_PRIORITIES_DEFINED_
#define _DIRECTAUDIO_PRIORITIES_DEFINED_

#define DAUD_CRITICAL_VOICE_PRIORITY    (0xF0000000)
#define DAUD_HIGH_VOICE_PRIORITY        (0xC0000000)
#define DAUD_STANDARD_VOICE_PRIORITY    (0x80000000)
#define DAUD_LOW_VOICE_PRIORITY         (0x40000000)
#define DAUD_PERSIST_VOICE_PRIORITY     (0x10000000) 

/* These are the default priorities assigned if not overridden. By default priorities are
 * equal across channel groups (e.g. channel 5 on channel group 1 has the same priority as
 * channel 5 on channel group 2).
 *
 * In accordance with DLS level 1, channel 10 has the highest priority, followed by 1 through 16
 * except for 10.
 */
#define DAUD_CHAN1_VOICE_PRIORITY_OFFSET    (0x0000000E)
#define DAUD_CHAN2_VOICE_PRIORITY_OFFSET    (0x0000000D)
#define DAUD_CHAN3_VOICE_PRIORITY_OFFSET    (0x0000000C)
#define DAUD_CHAN4_VOICE_PRIORITY_OFFSET    (0x0000000B)
#define DAUD_CHAN5_VOICE_PRIORITY_OFFSET    (0x0000000A)
#define DAUD_CHAN6_VOICE_PRIORITY_OFFSET    (0x00000009)
#define DAUD_CHAN7_VOICE_PRIORITY_OFFSET    (0x00000008)
#define DAUD_CHAN8_VOICE_PRIORITY_OFFSET    (0x00000007)
#define DAUD_CHAN9_VOICE_PRIORITY_OFFSET    (0x00000006)
#define DAUD_CHAN10_VOICE_PRIORITY_OFFSET   (0x0000000F)
#define DAUD_CHAN11_VOICE_PRIORITY_OFFSET   (0x00000005)
#define DAUD_CHAN12_VOICE_PRIORITY_OFFSET   (0x00000004)
#define DAUD_CHAN13_VOICE_PRIORITY_OFFSET   (0x00000003)
#define DAUD_CHAN14_VOICE_PRIORITY_OFFSET   (0x00000002)
#define DAUD_CHAN15_VOICE_PRIORITY_OFFSET   (0x00000001)
#define DAUD_CHAN16_VOICE_PRIORITY_OFFSET   (0x00000000)
 
 
#define DAUD_CHAN1_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN1_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN2_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN2_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN3_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN3_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN4_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN4_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN5_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN5_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN6_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN6_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN7_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN7_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN8_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN8_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN9_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN9_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN10_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN10_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN11_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN11_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN12_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN12_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN13_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN13_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN14_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN14_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN15_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN15_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN16_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN16_VOICE_PRIORITY_OFFSET)

#endif  /* _DIRECTAUDIO_PRIORITIES_DEFINED_ */


#undef  INTERFACE
#define INTERFACE  IDirectMusicPort
DECLARE_INTERFACE_(IDirectMusicPort, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicPort */
    /*  */
    STDMETHOD(PlayBuffer)           (THIS_ LPDIRECTMUSICBUFFER pBuffer) PURE;
    STDMETHOD(SetReadNotificationHandle) (THIS_ HANDLE hEvent) PURE;
    STDMETHOD(Read)                 (THIS_ LPDIRECTMUSICBUFFER pBuffer) PURE;
    STDMETHOD(DownloadInstrument)   (THIS_ IDirectMusicInstrument *pInstrument, 
                                     IDirectMusicDownloadedInstrument **ppDownloadedInstrument,
                                     DMUS_NOTERANGE *pNoteRanges,
                                     DWORD dwNumNoteRanges) PURE;
    STDMETHOD(UnloadInstrument)     (THIS_ IDirectMusicDownloadedInstrument *pDownloadedInstrument) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(GetRunningStats)      (THIS_ LPDMUS_SYNTHSTATS pStats) PURE;
    STDMETHOD(Compact)              (THIS) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDMUS_PORTCAPS pPortCaps) PURE;
    STDMETHOD(DeviceIoControl)      (THIS_ DWORD dwIoControlCode, 
                                           LPVOID lpInBuffer, 
                                           DWORD nInBufferSize, 
                                           LPVOID lpOutBuffer, 
                                           DWORD nOutBufferSize, 
                                           LPDWORD lpBytesReturned, 
                                           LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(SetNumChannelGroups)  (THIS_ DWORD dwChannelGroups) PURE;
    STDMETHOD(GetNumChannelGroups)  (THIS_ LPDWORD pdwChannelGroups) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fActive) PURE;
    STDMETHOD(SetChannelPriority)   (THIS_ DWORD dwChannelGroup, DWORD dwChannel, DWORD dwPriority) PURE;
    STDMETHOD(GetChannelPriority)   (THIS_ DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwPriority) PURE;
    STDMETHOD(SetDirectSound)       (THIS_ LPDIRECTSOUND pDirectSound, LPDIRECTSOUNDBUFFER pDirectSoundBuffer) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pWaveFormatEx, LPDWORD pdwWaveFormatExSize, LPDWORD pdwBufferSize) PURE;
};

typedef IDirectMusicPort IDirectMusicPort8;
typedef IDirectMusicPort8 *LPDIRECTMUSICPORT8;

#undef  INTERFACE
#define INTERFACE  IDirectMusicThru
DECLARE_INTERFACE_(IDirectMusicThru, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    
    /* IDirectMusicThru 
     */
    STDMETHOD(ThruChannel)          (THIS_ DWORD dwSourceChannelGroup, 
                                           DWORD dwSourceChannel, 
                                           DWORD dwDestinationChannelGroup,
                                           DWORD dwDestinationChannel,
                                           LPDIRECTMUSICPORT pDestinationPort) PURE;
};

typedef IDirectMusicThru IDirectMusicThru8;
typedef IDirectMusicThru8 *LPDIRECTMUSICTHRU8;

#ifndef __IReferenceClock_INTERFACE_DEFINED__
#define __IReferenceClock_INTERFACE_DEFINED__

DEFINE_GUID(IID_IReferenceClock,0x56a86897,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#undef  INTERFACE
#define INTERFACE  IReferenceClock
DECLARE_INTERFACE_(IReferenceClock, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /*  IReferenceClock */
    /*  */
    
    /*  get the time now */
    STDMETHOD(GetTime)                  (THIS_ REFERENCE_TIME *pTime) PURE;

    /*  ask for an async notification that a time has elapsed */
    STDMETHOD(AdviseTime)               (THIS_ REFERENCE_TIME baseTime,         /*  base time */
                                               REFERENCE_TIME streamTime,       /*  stream offset time */
                                               HANDLE hEvent,                   /*  advise via this event */
                                               DWORD * pdwAdviseCookie) PURE;   /*  where your cookie goes */

    /*  ask for an async periodic notification that a time has elapsed */
    STDMETHOD(AdvisePeriodic)           (THIS_ REFERENCE_TIME startTime,        /*  starting at this time */
                                               REFERENCE_TIME periodTime,       /*  time between notifications */
                                               HANDLE hSemaphore,               /*  advise via a semaphore */
                                               DWORD * pdwAdviseCookie) PURE;   /*  where your cookie goes */

    /*  cancel a request for notification */
    STDMETHOD(Unadvise)                 (THIS_ DWORD dwAdviseCookie) PURE;
};

#endif /* __IReferenceClock_INTERFACE_DEFINED__ */

DEFINE_GUID(CLSID_DirectMusic,0x636b9f10,0x0c7d,0x11d1,0x95,0xb2,0x00,0x20,0xaf,0xdc,0x74,0x21);
//DEFINE_GUID(CLSID_DirectMusicCollection,0x480ff4b0, 0x28b2, 0x11d1, 0xbe, 0xf7, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);
DEFINE_GUID(CLSID_DirectMusicSynth,0x58C2B4D0,0x46E7,0x11D1,0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29);

DEFINE_GUID(IID_IDirectMusic,0x6536115a,0x7b2d,0x11d2,0xba,0x18,0x00,0x00,0xf8,0x75,0xac,0x12);
DEFINE_GUID(IID_IDirectMusicBuffer,0xd2ac2878, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicPort, 0x08f2d8c9,0x37c2,0x11d2,0xb9,0xf9,0x00,0x00,0xf8,0x75,0xac,0x12);
DEFINE_GUID(IID_IDirectMusicThru, 0xced153e7, 0x3606, 0x11d2, 0xb9, 0xf9, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(IID_IDirectMusicPortDownload,0xd2ac287a, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicDownload,0xd2ac287b, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicCollection,0xd2ac287c, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicInstrument,0xd2ac287d, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicDownloadedInstrument,0xd2ac287e, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);


/* Alternate interface ID for IID_IDirectMusic, available in DX7 release and after. */
DEFINE_GUID(IID_IDirectMusic2,0x6fc2cae1, 0xbc78, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

DEFINE_GUID(IID_IDirectMusic8,0x2d3629f7,0x813d,0x4939,0x85,0x08,0xf0,0x5c,0x6b,0x75,0xfd,0x97);

#define IID_IDirectMusicThru8 IID_IDirectMusicThru
#define IID_IDirectMusicPortDownload8 IID_IDirectMusicPortDownload
#define IID_IDirectMusicDownload8 IID_IDirectMusicDownload
#define IID_IDirectMusicCollection8 IID_IDirectMusicCollection
#define IID_IDirectMusicInstrument8 IID_IDirectMusicInstrument
#define IID_IDirectMusicDownloadedInstrument8 IID_IDirectMusicDownloadedInstrument
#define IID_IDirectMusicPort8 IID_IDirectMusicPort


/* Property Query GUID_DMUS_PROP_GM_Hardware - Local GM set, no need to download
 * Property Query GUID_DMUS_PROP_GS_Hardware - Local GS set, no need to download
 * Property Query GUID_DMUS_PROP_XG_Hardware - Local XG set, no need to download
 * Property Query GUID_DMUS_PROP_DLS1        - Support DLS level 1
 * Property Query GUID_DMUS_PROP_INSTRUMENT2 - Support new INSTRUMENT2 download format
 * Property Query GUID_DMUS_PROP_XG_Capable  - Support minimum requirements of XG
 * Property Query GUID_DMUS_PROP_GS_Capable  - Support minimum requirements of GS
 * Property Query GUID_DMUS_PROP_SynthSink_DSOUND - Synthsink talks to DSound
 * Property Query GUID_DMUS_PROP_SynthSink_WAVE - Synthsink talks to Wave device
 *
 * Item 0: Supported
 * Returns a DWORD which is non-zero if the feature is supported
 */
DEFINE_GUID(GUID_DMUS_PROP_GM_Hardware, 0x178f2f24, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_GS_Hardware, 0x178f2f25, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_XG_Hardware, 0x178f2f26, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_XG_Capable,  0x6496aba1, 0x61b0, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(GUID_DMUS_PROP_GS_Capable,  0x6496aba2, 0x61b0, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(GUID_DMUS_PROP_DLS1,        0x178f2f27, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_DLS2,        0xf14599e5, 0x4689, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(GUID_DMUS_PROP_INSTRUMENT2, 0x865fd372, 0x9f67, 0x11d2, 0x87, 0x2a, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_DMUS_PROP_SynthSink_DSOUND,0xaa97844, 0xc877, 0x11d1, 0x87, 0xc, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_DMUS_PROP_SynthSink_WAVE,0xaa97845, 0xc877, 0x11d1, 0x87, 0xc, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_DMUS_PROP_SampleMemorySize, 0x178f2f28, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_SamplePlaybackRate, 0x2a91f713, 0xa4bf, 0x11d2, 0xbb, 0xdf, 0x0, 0x60, 0x8, 0x33, 0xdb, 0xd8);

/* Property Get/Set GUID_DMUS_PROP_WriteLatency
 *
 * Item 0: Synth buffer write latency, in milliseconds
 * Get/Set SynthSink latency, the average time after the play head that the next buffer gets written.
 */
DEFINE_GUID(GUID_DMUS_PROP_WriteLatency,0x268a0fa0, 0x60f2, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

/* Property Get/Set GUID_DMUS_PROP_WritePeriod
 *
 * Item 0: Synth buffer write period, in milliseconds
 * Get/Set SynthSink buffer write period, time span between successive writes.
 */
DEFINE_GUID(GUID_DMUS_PROP_WritePeriod,0x268a0fa1, 0x60f2, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

/* Property Get GUID_DMUS_PROP_MemorySize
 *
 * Item 0: Memory size
 * Returns a DWORD containing the total number of bytes of sample RAM
 */
DEFINE_GUID(GUID_DMUS_PROP_MemorySize,  0x178f2f28, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);

/* Property Set GUID_DMUS_PROP_WavesReverb
 *
 * Item 0: DMUS_WAVES_REVERB structure
 * Sets reverb parameters
 */
DEFINE_GUID(GUID_DMUS_PROP_WavesReverb,0x4cb5622, 0x32e5, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

/* Property Set GUID_DMUS_PROP_Effects
 *
 * Item 0: DWORD with effects flags. 
 * Get/Set effects bits, same as dwEffectFlags in DMUS_PORTPARAMS and DMUS_PORTCAPS:
 * DMUS_EFFECT_NONE 
 * DMUS_EFFECT_REVERB 
 * DMUS_EFFECT_CHORUS 
 */
DEFINE_GUID(GUID_DMUS_PROP_Effects, 0xcda8d611, 0x684a, 0x11d2, 0x87, 0x1e, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Property Set GUID_DMUS_PROP_LegacyCaps
 *
 * Item 0: The MIDINCAPS or MIDIOUTCAPS which describes the port's underlying WinMM device. This property is only supported
 * by ports which wrap WinMM devices.
 */

DEFINE_GUID(GUID_DMUS_PROP_LegacyCaps,0xcfa7cdc2, 0x00a1, 0x11d2, 0xaa, 0xd5, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);

/* Property Set GUID_DMUS_PROP_Volume
 *
 * Item 0: A long which contains an offset, in 1/100 dB, to be added to the final volume
 *
 */
DEFINE_GUID(GUID_DMUS_PROP_Volume, 0xfedfae25L, 0xe46e, 0x11d1, 0xaa, 0xce, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);

/* Min and Max values for setting volume with GUID_DMUS_PROP_Volume */

#define DMUS_VOLUME_MAX     2000        /* +20 dB */
#define DMUS_VOLUME_MIN   -20000        /* -200 dB */


#ifdef __cplusplus
}; /* extern "C" */
#endif

#include <poppack.h>

#endif /* #ifndef _DMUSICC_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dmusic\inc\dmusicf.h ===
/************************************************************************
*                                                                       *
*   dmusicf.h -- This module defines the DirectMusic file formats       *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corporation
*                                                                       *
************************************************************************/

#ifndef _DMUSICF_
#define _DMUSICF_

#ifdef XBOX
#include <xtl.h>
#else // XBOX
#include <windows.h>
#endif // XBOX

#define COM_NO_WINDOWS_H
#include <objbase.h>

#ifdef XBOX
#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )				\
		( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
		( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif
#else
#include <mmsystem.h>
#endif // XBOX

#include <pshpack8.h>

#ifdef __cplusplus
extern "C" {
#endif

interface IDirectMusicCollection;
#ifndef __cplusplus 
typedef interface IDirectMusicCollection IDirectMusicCollection;
#endif

/* Common chunks */

#define DMUS_FOURCC_GUID_CHUNK        mmioFOURCC('g','u','i','d')
#define DMUS_FOURCC_INFO_LIST         mmioFOURCC('I','N','F','O')
#define DMUS_FOURCC_UNFO_LIST         mmioFOURCC('U','N','F','O')
#define DMUS_FOURCC_UNAM_CHUNK        mmioFOURCC('U','N','A','M')
#define DMUS_FOURCC_UART_CHUNK        mmioFOURCC('U','A','R','T')
#define DMUS_FOURCC_UCOP_CHUNK        mmioFOURCC('U','C','O','P')
#define DMUS_FOURCC_USBJ_CHUNK        mmioFOURCC('U','S','B','J')
#define DMUS_FOURCC_UCMT_CHUNK        mmioFOURCC('U','C','M','T')
#define DMUS_FOURCC_CATEGORY_CHUNK    mmioFOURCC('c','a','t','g')
#define DMUS_FOURCC_VERSION_CHUNK     mmioFOURCC('v','e','r','s')

/* The following structures are used by the Tracks, and are the packed structures */
/* that are passed to the Tracks inside the IStream. */


typedef struct _DMUS_IO_SEQ_ITEM
{
    MUSIC_TIME    mtTime;
    MUSIC_TIME    mtDuration;
    DWORD         dwPChannel;
    short         nOffset; 
    BYTE          bStatus;
    BYTE          bByte1;
    BYTE          bByte2;
} DMUS_IO_SEQ_ITEM;


typedef struct _DMUS_IO_CURVE_ITEM
{
    MUSIC_TIME  mtStart;
    MUSIC_TIME  mtDuration;
    MUSIC_TIME  mtResetDuration;
    DWORD       dwPChannel;
    short       nOffset;
    short       nStartValue;
    short       nEndValue;
    short       nResetValue;
    BYTE        bType;
    BYTE        bCurveShape;
    BYTE        bCCData;
    BYTE        bFlags;
    /* Following was added for DX8. */
    WORD        wParamType;      /* RPN or NRPN parameter number. */
    WORD        wMergeIndex;     /* Allows multiple parameters to be merged (pitchbend, volume, and expression.) */
} DMUS_IO_CURVE_ITEM;


typedef struct _DMUS_IO_TEMPO_ITEM
{
    MUSIC_TIME    lTime;
    double        dblTempo;
} DMUS_IO_TEMPO_ITEM;


typedef struct _DMUS_IO_SYSEX_ITEM
{
    MUSIC_TIME    mtTime;
    DWORD         dwPChannel;
    DWORD         dwSysExLength;
} DMUS_IO_SYSEX_ITEM;

/* Style chunks */

#define DMUS_FOURCC_STYLE_FORM            mmioFOURCC('D','M','S','T')
#define DMUS_FOURCC_STYLE_CHUNK           mmioFOURCC('s','t','y','h')
#define DMUS_FOURCC_PART_LIST             mmioFOURCC('p','a','r','t')
#define DMUS_FOURCC_PART_CHUNK            mmioFOURCC('p','r','t','h')
#define DMUS_FOURCC_NOTE_CHUNK            mmioFOURCC('n','o','t','e')
#define DMUS_FOURCC_CURVE_CHUNK           mmioFOURCC('c','r','v','e')
#define DMUS_FOURCC_MARKER_CHUNK          mmioFOURCC('m','r','k','r')
#define DMUS_FOURCC_RESOLUTION_CHUNK      mmioFOURCC('r','s','l','n')
#define DMUS_FOURCC_ANTICIPATION_CHUNK    mmioFOURCC('a','n','p','n')
#define DMUS_FOURCC_PATTERN_LIST          mmioFOURCC('p','t','t','n')
#define DMUS_FOURCC_PATTERN_CHUNK         mmioFOURCC('p','t','n','h')
#define DMUS_FOURCC_RHYTHM_CHUNK          mmioFOURCC('r','h','t','m')
#define DMUS_FOURCC_PARTREF_LIST          mmioFOURCC('p','r','e','f')
#define DMUS_FOURCC_PARTREF_CHUNK         mmioFOURCC('p','r','f','c')
#define DMUS_FOURCC_STYLE_PERS_REF_LIST   mmioFOURCC('p','r','r','f')
#define DMUS_FOURCC_MOTIFSETTINGS_CHUNK   mmioFOURCC('m','t','f','s')

/* Flags used by variations: these make up the DWORDs in dwVariationChoices.               */

/* These flags determine the types of chords supported by a given variation in DirectMusic */
/* mode.  The first seven flags (bits 1-7) are set if the variation supports major chords  */
/* rooted in scale positions, so, e.g., if bits 1, 2, and 4 are set, the variation         */
/* supports major chords rooted in the tonic, second, and fourth scale positions.  The     */
/* next seven flags serve the same purpose, but for minor chords, and the following seven  */
/* flags serve the same purpose for chords that are not major or minor (e.g., SUS 4        */
/* chords).  Bits 22, 23, and 24 are set if the variation supports chords rooted in the    */
/* scale, chords rooted sharp of scale tones, and chords rooted flat of scale tones,       */
/* respectively.  For example, to support a C# minor chord in the scale of C Major,        */
/* bits 8 (for tonic minor) and 24 (for sharp) need to be set.  Bits 25, 26, an 27 handle  */
/* chords that are triads, 6th or 7th chords, and chords with extensions, respectively.    */
/* bits 28 and 29 handle chords that are followed by tonic and dominant chords,            */
/* respectively.                                                                           */
#define DMUS_VARIATIONF_MAJOR        0x0000007F /* Seven positions in the scale - major chords. */    
#define DMUS_VARIATIONF_MINOR        0x00003F80 /* Seven positions in the scale - minor chords. */    
#define DMUS_VARIATIONF_OTHER        0x001FC000 /* Seven positions in the scale - other chords. */    
#define DMUS_VARIATIONF_ROOT_SCALE   0x00200000 /* Handles chord roots in the scale. */         
#define DMUS_VARIATIONF_ROOT_FLAT    0x00400000 /* Handles flat chord roots (based on scale notes). */         
#define DMUS_VARIATIONF_ROOT_SHARP   0x00800000 /* Handles sharp chord roots (based on scale notes). */         
#define DMUS_VARIATIONF_TYPE_TRIAD   0x01000000 /* Handles simple chords - triads. */  
#define DMUS_VARIATIONF_TYPE_6AND7   0x02000000 /* Handles simple chords - 6 and 7. */  
#define DMUS_VARIATIONF_TYPE_COMPLEX 0x04000000 /* Handles complex chords. */  
#define DMUS_VARIATIONF_DEST_TO1     0x08000000 /* Handles transitions to 1 chord. */  
#define DMUS_VARIATIONF_DEST_TO5     0x10000000 /* Handles transitions to 5 chord. */  
#define DMUS_VARIATIONF_DEST_OTHER   0x40000000 /* Handles transitions to chords other than 1 . */  

/* legacy mask for variation modes */
#define DMUS_VARIATIONF_MODES        0xE0000000
/* Bits 29 and 31 of the variation flags are the Mode bits.  If both are 0, it's IMA. */  
/* If bit 29 is 1, it's Direct Music. */
#define DMUS_VARIATIONF_MODES_EX     (0x20000000 | 0x80000000)
#define DMUS_VARIATIONF_IMA25_MODE   0x00000000
#define DMUS_VARIATIONF_DMUS_MODE    0x20000000

/* Set this if the part uses marker events */
#define DMUS_PARTF_USE_MARKERS       0x1
/* Set this if the part is allowed to switch only on chord-aligned markers */
#define DMUS_PARTF_ALIGN_CHORDS      0x2

/* These specify if the marker event signals whether to stop a variation or start a 
pattern/variation (or both), and whether new variations must align with a chord */
#define DMUS_MARKERF_START            0x1
#define DMUS_MARKERF_STOP             0x2
#define DMUS_MARKERF_CHORD_ALIGN      0x4

/* if this flag is set, variation settings in a playing pattern-based track's state data will 
persist in the track after it stops playing */
#define DMUS_PATTERNF_PERSIST_CONTROL 0x1

/* These specify possible values for DMUS_IO_PARTREF.bRandomVariation
   all but DMUS_VARIATIONT_SEQUENTIAL and DMUS_VARIATIONT_RANDOM are dx8. */
typedef enum enumDMUS_VARIATIONT_TYPES
{
    DMUS_VARIATIONT_SEQUENTIAL       = 0, /* Play sequential starting with variation 1. */
    DMUS_VARIATIONT_RANDOM           = 1, /* Play randomly. */
    DMUS_VARIATIONT_RANDOM_START     = 2, /* Play sequential starting with a random variation. */
    DMUS_VARIATIONT_NO_REPEAT        = 3, /* Play randomly, but don't play the same variation twice. */
    DMUS_VARIATIONT_RANDOM_ROW       = 4  /* Play randomly as a row: don't repeat any variation until all have played. */
} DMUS_VARIATIONT_TYPES;

#pragma pack(2)

typedef struct _DMUS_IO_TIMESIG
{
    /* Time signatures define how many beats per measure, which note receives */
    /* the beat, and the grid resolution. */
    BYTE    bBeatsPerMeasure;   /* beats per measure (top of time sig) */
    BYTE    bBeat;              /* what note receives the beat (bottom of time sig.) */
                                /* we can assume that 0 means 256th note */
    WORD    wGridsPerBeat;      /* grids per beat */
} DMUS_IO_TIMESIG;

typedef struct _DMUS_IO_STYLE
{
    DMUS_IO_TIMESIG     timeSig;        /* Styles have a default Time Signature */
    double              dblTempo;   
} DMUS_IO_STYLE;

typedef struct _DMUS_IO_VERSION
{
    DWORD               dwVersionMS;        /* Version # high-order 32 bits */
    DWORD               dwVersionLS;        /* Version # low-order 32 bits  */
} DMUS_IO_VERSION;

typedef struct _DMUS_IO_PATTERN
{
    DMUS_IO_TIMESIG     timeSig;           /* Patterns can override the Style's Time sig. */
    BYTE                bGrooveBottom;     /* bottom of groove range */
    BYTE                bGrooveTop;        /* top of groove range */
    WORD                wEmbellishment;    /* Fill, Break, Intro, End, Normal, Motif */
    WORD                wNbrMeasures;      /* length in measures */
    BYTE                bDestGrooveBottom; /* bottom of groove range for next pattern */
    BYTE                bDestGrooveTop;    /* top of groove range for next pattern */
    DWORD               dwFlags;           /* various flags */
} DMUS_IO_PATTERN;

typedef struct _DMUS_IO_STYLEPART
{
    DMUS_IO_TIMESIG     timeSig;        /* can override pattern's */
    DWORD               dwVariationChoices[32]; /* MOAW choice bitfield */
    GUID                guidPartID;     /* identifies the part */
    WORD                wNbrMeasures;   /* length of the Part */
    BYTE                bPlayModeFlags; /* see PLAYMODE flags */
    BYTE                bInvertUpper;   /* inversion upper limit */
    BYTE                bInvertLower;   /* inversion lower limit */
    BYTE                bPad[3];        /* for DWORD alignment */
    DWORD               dwFlags;        /* various flags */ 
} DMUS_IO_STYLEPART;

typedef struct _DMUS_IO_PARTREF
{
    GUID    guidPartID;         /* unique ID for matching up with parts */
    WORD    wLogicalPartID;     /* corresponds to port/device/midi channel OBSOLETE */
    BYTE    bVariationLockID;   /* parts with the same ID lock variations. */
                                /* high bit is used to identify master Part */
    BYTE    bSubChordLevel;     /* tells which sub chord level this part wants */
    BYTE    bPriority;          /* 256 priority levels. Parts with lower priority */
                                /* aren't played first when a device runs out of */
                                /* notes */
    BYTE    bRandomVariation;   /* when set, matching variations play in random order */
                                /* when clear, matching variations play sequentially */
    WORD    wPad;               /* not used */
    DWORD   dwPChannel;         /* replaces wLogicalPartID */
} DMUS_IO_PARTREF;

typedef struct _DMUS_IO_STYLENOTE
{
    MUSIC_TIME  mtGridStart;    /* when this note occurs */
    DWORD       dwVariation;    /* variation bits */
    MUSIC_TIME  mtDuration;     /* how long this note lasts */
    short       nTimeOffset;    /* offset from mtGridStart */
    WORD        wMusicValue;    /* Position in scale. */
    BYTE        bVelocity;      /* Note velocity. */
    BYTE        bTimeRange;     /* Range to randomize start time. */
    BYTE        bDurRange;      /* Range to randomize duration. */
    BYTE        bVelRange;      /* Range to randomize velocity. */
    BYTE        bInversionID;   /* Identifies inversion group to which this note belongs */
    BYTE        bPlayModeFlags; /* Can override part */
    /* Following exists only under DX8 and on */
    BYTE        bNoteFlags;     /* values from DMUS_NOTEF_FLAGS */
} DMUS_IO_STYLENOTE;

typedef struct _DMUS_IO_STYLECURVE
{
    MUSIC_TIME  mtGridStart;    /* when this curve occurs */
    DWORD       dwVariation;    /* variation bits */
    MUSIC_TIME  mtDuration;     /* how long this curve lasts */
    MUSIC_TIME  mtResetDuration;/* how long after the end of the curve to reset the curve */
    short       nTimeOffset;    /* offset from mtGridStart */
    short       nStartValue;    /* curve's start value */
    short       nEndValue;      /* curve's end value */
    short       nResetValue;    /* the value to which to reset the curve */
    BYTE        bEventType;     /* type of curve */
    BYTE        bCurveShape;    /* shape of curve */
    BYTE        bCCData;        /* CC# */
    BYTE        bFlags;         /* Bit 1=TRUE means to send nResetValue. Otherwise, don't.
                                   Other bits are reserved. */
    /*  Following was added for DX8. */
    WORD        wParamType;      /* RPN or NRPN parameter number. */
    WORD        wMergeIndex;     /* Allows multiple parameters to be merged (pitchbend, volume, and expression.) */
} DMUS_IO_STYLECURVE;

typedef struct _DMUS_IO_STYLEMARKER
{
    MUSIC_TIME  mtGridStart;    /* when this marker occurs */
    DWORD       dwVariation;    /* variation bits */
    WORD        wMarkerFlags;   /* how the marker is used */
} DMUS_IO_STYLEMARKER;

typedef struct _DMUS_IO_STYLERESOLUTION
{
    DWORD    dwVariation;       /* variation bits */
    WORD     wMusicValue;       /* Position in scale. */
    BYTE     bInversionID;      /* Identifies inversion group to which this note belongs */
    BYTE     bPlayModeFlags;    /* Can override part */
} DMUS_IO_STYLERESOLUTION;

typedef struct _DMUS_IO_STYLE_ANTICIPATION
{
    MUSIC_TIME    mtGridStart;   /* when this anticipation occurs */
    DWORD         dwVariation;   /* variation bits */
    short         nTimeOffset;   /* offset from mtGridStart */
    BYTE          bTimeRange;    /* Range to randomize start time. */
} DMUS_IO_STYLE_ANTICIPATION;

typedef struct _DMUS_IO_MOTIFSETTINGS
{
    DWORD       dwRepeats;      /* Number of repeats. By default, 0. */
    MUSIC_TIME  mtPlayStart;    /* Start of playback. By default, 0. */
    MUSIC_TIME  mtLoopStart;    /* Start of looping portion. By default, 0. */
    MUSIC_TIME  mtLoopEnd;      /* End of loop. Must be greater than mtLoopStart. Or, 0, indicating loop full motif.  */
    DWORD       dwResolution;   /* Default resolution. */
} DMUS_IO_MOTIFSETTINGS;

#pragma pack()


/*
RIFF
(
    'DMST'          // Style
    <styh-ck>       // Style header chunk
    <guid-ck>       // Every Style has a GUID
    [<UNFO-list>]   // Name, author, copyright info., comments
    [<vers-ck>]     // version chunk
    <part-list>...  // Array of parts in the Style, used by patterns
    <pttn-list>...  // Array of patterns in the Style
    <DMBD-form>...  // Array of bands in the Style
    [<prrf-list>]...// Optional array of chord map references in the Style
)

    // <styh-ck>
    styh
    (
        <DMUS_IO_STYLE>
    )

    // <guid-ck>
    guid
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <part-list>
    LIST
    (
        'part'
        <prth-ck>       // Part header chunk
        [<UNFO-list>]   // Name, author, copyright info., comments
        [<note-ck>]     // Optional chunk containing an array of notes in Part
        [<crve-ck>]     // Optional chunk containing an array of curves in Part
        [<mrkr-ck>]     // Optional chunk containing an array of markers in Part
        [<rsln-ck>]     // Optional chunk containing an array of variation resolutions in Part
        [<anpn-ck>]     // Optional chunk containing an array of resolution anticipations in Part
    )

        // <orth-ck>
        prth
        (
            <DMUS_IO_STYLEPART>
        )

        // <note-ck>
        'note'
        (
            // sizeof DMUS_IO_STYLENOTE:DWORD
            <DMUS_IO_STYLENOTE>...
        )

        // <crve-ck>
        'crve'
        (
            // sizeof DMUS_IO_STYLECURVE:DWORD
            <DMUS_IO_STYLECURVE>...
        )

        // <mrkr-ck>
        'mrkr'
        (
            // sizeof DMUS_IO_STYLEMARKER:DWORD
            <DMUS_IO_STYLEMARKER>...
        )

        // <rsln-ck>
        'rsln'
        (
            // sizeof DMUS_IO_STYLERESOLUTION:DWORD
            <DMUS_IO_STYLERESOLUTION>...
        )

        // <anpn-ck>
        'anpn'
        (
            // sizeof DMUS_IO_STYLE_ANTICIPATION:DWORD
            <DMUS_IO_STYLE_ANTICIPATION>...
        )

    // <pttn-list>
    LIST
    (
        'pttn'
        <ptnh-ck>       // Pattern header chunk
        <rhtm-ck>       // Chunk containing an array of rhythms for chord matching
        [<UNFO-list>]   // Name, author, copyright info., comments
        [<mtfs-ck>]     // Motif settings chunk
        [<DMBD-form>]   // Optional band to be associated with the pattern (for motifs)
        <pref-list>...  // Array of part reference id's
    )

        // <ptnh-ck>
        ptnh
        (
            <DMUS_IO_PATTERN>
        )

        // <rhtm-ck>
        'rhtm'
        (
            // DWORD's representing rhythms for chord matching based on number
            // of measures in the pattern
        )


        // pref-list
        LIST
        (
            'pref'
            <prfc-ck>   // part ref chunk
        )

        // <prfc-ck>
        prfc
        (
            <DMUS_IO_PARTREF>
        )

        // <mtfs-ck>
        mtfs
        (
            <DMUS_IO_MOTIFSETTINGS>
        )

    // <prrf-list>
    LIST
    (
        'prrf'
        <DMRF-list>... // Array of Chordmap references
    )
*/

/* Pattern chunk, for use in Pattern tracks */

#define DMUS_FOURCC_PATTERN_FORM        mmioFOURCC('D','M','P','T')

/*
RIFF
(
    'DMPT'          // Pattern
    <styh-ck>       // Style header chunk
    <pttn-list>     // The pattern, in single pattern format (includes DMUS_FOURCC_PART_LIST chunks)
)
*/


/* Chord and command file formats */

/* These specify possible values for DMUS_IO_COMMAND.bRepeatMode (dx8) */
typedef enum enumDMUS_PATTERNT_TYPES
{
    DMUS_PATTERNT_RANDOM           = 0, /* Play randomly. (dx7 behavior) */
    DMUS_PATTERNT_REPEAT           = 1, /* Repeat last pattern. */
    DMUS_PATTERNT_SEQUENTIAL       = 2, /* Play sequential starting with first matching pattern. */
    DMUS_PATTERNT_RANDOM_START     = 3, /* Play sequential starting with a random pattern. */
    DMUS_PATTERNT_NO_REPEAT        = 4, /* Play randomly, but don't play the same pattern twice. */
    DMUS_PATTERNT_RANDOM_ROW       = 5  /* Play randomly as a row: don't repeat any pattern until all have played. */
} DMUS_PATTERNT_TYPES;

#define DMUS_FOURCC_CHORDTRACK_LIST         mmioFOURCC('c','o','r','d')
#define DMUS_FOURCC_CHORDTRACKHEADER_CHUNK  mmioFOURCC('c','r','d','h')
#define DMUS_FOURCC_CHORDTRACKBODY_CHUNK    mmioFOURCC('c','r','d','b')

#define DMUS_FOURCC_COMMANDTRACK_CHUNK      mmioFOURCC('c','m','n','d')

typedef struct _DMUS_IO_CHORD
{
    WCHAR       wszName[16];    /* Name of the chord */
    MUSIC_TIME  mtTime;         /* Time of this chord */
    WORD        wMeasure;       /* Measure this falls on */
    BYTE        bBeat;          /* Beat this falls on */
    BYTE        bFlags;         /* Various flags */
} DMUS_IO_CHORD;

typedef struct _DMUS_IO_SUBCHORD
{
    DWORD   dwChordPattern;     /* Notes in the subchord */
    DWORD   dwScalePattern;     /* Notes in the scale */
    DWORD   dwInversionPoints;  /* Where inversions can occur */
    DWORD   dwLevels;           /* Which levels are supported by this subchord */
    BYTE    bChordRoot;         /* Root of the subchord */
    BYTE    bScaleRoot;         /* Root of the scale */
} DMUS_IO_SUBCHORD;

typedef struct _DMUS_IO_COMMAND
{
    MUSIC_TIME  mtTime;         /* Time of this command */
    WORD        wMeasure;       /* Measure this falls on */
    BYTE        bBeat;          /* Beat this falls on */
    BYTE        bCommand;       /* Command type (see #defines below) */
    BYTE        bGrooveLevel;   /* Groove level (0 if command is not a groove) */
    BYTE        bGrooveRange;   /* Groove range  */
    BYTE        bRepeatMode;    /* Used to control selection of patterns with same groove level  */
} DMUS_IO_COMMAND;


/*

    // <cord-list>
    LIST
    (
        'cord'
        <crdh-ck>
        <crdb-ck>       // Chord body chunk
    )

        // <crdh-ck>
        crdh
        (
            // Scale: dword (upper 8 bits for root, lower 24 for scale)
        )

        // <crdb-ck>
        crdb
        (
            // sizeof DMUS_IO_CHORD:dword
            <DMUS_IO_CHORD>
            // # of DMUS_IO_SUBCHORDS:dword
            // sizeof DMUS_IO_SUBCHORDS:dword
            // a number of <DMUS_IO_SUBCHORD>
        )


    // <cmnd-list>
    'cmnd'
    (
        //sizeof DMUS_IO_COMMAND: DWORD
        <DMUS_IO_COMMAND>...
    )

*/

/*  File io for DirectMusic Tool and ToolGraph objects
*/

/* RIFF ids: */

#define DMUS_FOURCC_TOOLGRAPH_FORM  mmioFOURCC('D','M','T','G')
#define DMUS_FOURCC_TOOL_LIST       mmioFOURCC('t','o','l','l')
#define DMUS_FOURCC_TOOL_FORM       mmioFOURCC('D','M','T','L')
#define DMUS_FOURCC_TOOL_CHUNK      mmioFOURCC('t','o','l','h')

/* io structures: */

typedef struct _DMUS_IO_TOOL_HEADER
{
    GUID        guidClassID;    /* Class id of tool. */
    long        lIndex;         /* Position in graph. */
    DWORD       cPChannels;     /* Number of items in channels array. */
    FOURCC      ckid;           /* chunk ID of tool's data chunk if 0 fccType valid. */
    FOURCC      fccType;        /* list type if NULL ckid valid. */
    DWORD       dwPChannels[1]; /* Array of PChannels, size determined by cPChannels. */
} DMUS_IO_TOOL_HEADER;

/*
RIFF
(
    'DMTG'          // DirectMusic ToolGraph chunk
    [<guid-ck>]     // GUID for ToolGraph
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    <toll-list>     // List of Tools
)

    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <toll-list>
    LIST
    (
        'toll'          // Array of tools
        <DMTL-form>...  // Each tool is encapsulated in a RIFF chunk
    )

// <DMTL-form>      Tools are embedded in a graph. Theoretically, they can be saved as individual files too.
RIFF
(
    'DMTL'
    <tolh-ck>
    [<data>]        // Tool data. Must be a RIFF readable chunk.
)

    // <tolh-ck>            // Tool header chunk
    (
        'tolh'
        <DMUS_IO_TOOL_HEADER>   // Tool header
    )
*/

/*  The AudioPath file carries everything for describing a specific audio path,
    including Tool Graph and Buffer Descriptor.
    This can even be used for configuring a complete performance.
*/

#define DMUS_FOURCC_AUDIOPATH_FORM  mmioFOURCC('D','M','A','P')

/*
RIFF
(
    'DMAP'          // DirectMusic AudioPath chunk
    [<guid-ck>]     // GUID for this Audio Path configuration
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    [<DMTG-form>]   // Optional ToolGraph
    [<pcsl-list>]   // Optional list of port configurations
    [<dbfl-list>]...// Optional array of Dsound buffer descriptors
)
*/

#define DMUS_FOURCC_PORTCONFIGS_LIST    mmioFOURCC('p','c','s','l')
#define DMUS_FOURCC_PORTCONFIG_LIST     mmioFOURCC('p','c','f','l')
#define DMUS_FOURCC_PORTCONFIG_ITEM     mmioFOURCC('p','c','f','h')
#define DMUS_FOURCC_PORTPARAMS_ITEM     mmioFOURCC('p','p','r','h')
#define DMUS_FOURCC_DSBUFFER_LIST       mmioFOURCC('d','b','f','l')
#define DMUS_FOURCC_DSBUFFATTR_ITEM     mmioFOURCC('d','d','a','h')
#define DMUS_FOURCC_MIXBINS_ITEM        mmioFOURCC('m','x','b','n')
#define DMUS_FOURCC_PCHANNELS_LIST      mmioFOURCC('p','c','h','l')
#define DMUS_FOURCC_PCHANNELS_ITEM      mmioFOURCC('p','c','h','h')

typedef struct _DMUS_IO_PORTCONFIG_HEADER
{
    GUID    guidPort;           /* GUID of requested port. */
    DWORD   dwPChannelBase;     /* PChannel that this should start on. */
    DWORD   dwPChannelCount;    /* How many channels. */
    DWORD   dwFlags;            /* Various flags. */
} DMUS_IO_PORTCONFIG_HEADER;

#define DMUS_PORTCONFIGF_DRUMSON10  1   /* This port configured for drums on channel 10. */
#define DMUS_PORTCONFIGF_USEDEFAULT 2   /* Use the default port. */

/* Each portconfig has one or more pchannel to buffer mappings. Each buffer
   is identified by a guid. Each pchannel can map to one or more buffers.
   This is defined with one or more DMUS_IO_PCHANNELTOBUFFER_HEADER
   structures. Each defines a range of PChannels and the set of buffers
   that they connect to. 
*/

typedef struct _DMUS_IO_PCHANNELTOBUFFER_HEADER
{
    DWORD   dwPChannelBase;     /* PChannel that this should start on. */
    DWORD   dwPChannelCount;    /* How many PChannels. */
    DWORD   dwBufferCount;      /* How many buffers do these connect to. */
    DWORD   dwFlags;            /* Various flags. Currently reserved for future use. Must be 0. */
} DMUS_IO_PCHANNELTOBUFFER_HEADER;

/* Each buffer is represented by an DSBC form. This is wrapped by the 
   DMUS_IO_BUFFER_ATTRIBUTES_HEADER which identifies how to use the
   buffer. In particular, it indicates whether this gets dynamically duplicated
   or all references to this should share the same instance. 
   To resolve references, the unique GUID of the buffer is also stored
   in this structure. 
*/
   
typedef struct _DMUS_IO_BUFFER_ATTRIBUTES_HEADER
{
    GUID    guidBufferID;       /* Each buffer config has a unique ID. */
    DWORD   dwFlags;            /* Various flags. */
} DMUS_IO_BUFFER_ATTRIBUTES_HEADER;

/* DMUS_IO_BUFFER_ATTRIBUTES_HEADER.dwFlags: */
#define DMUS_BUFFERF_SHARED     1   /* Share this with other audio paths, instead of creating unique copies. */
#define DMUS_BUFFERF_DEFINED    2   /* Use one of the standard predefined buffers (see GUID_Buffer... in dmusici.h.) */
#define DMUS_BUFFERF_MIXIN      8   /* This is a mixin buffer. */

typedef struct _DMUS_IO_BUFFER_MIXBINS_HEADER
{
    DWORD   dwMixBins;          /* Set of mixbins to control. */
    BYTE    bControllers[8];    /* Set of 8 controllers that manage the mixbins. */
} DMUS_IO_BUFFER_MIXBINS_HEADER;


/*

LIST
(
    'pcsl'          // Array of port configurations
    <pcfl-list>...  // One or more port configurations, each in a list chunk
)

LIST
(
    'pcfl'          // List container for one port configuration.
    <pcfh-ck>       // Portconfig header chunk.
    <pprh-ck>       // Port params, to be used to create the port.
    [<dbfl-list>]...// Optional array of Dsound buffer descriptors
    [<pchl-list>]   // Optional list of pchannel to buffer assignments

)

    // <pcfh-ck>            // Port config header chunk
    (
        'pcfh'
        <DMUS_IO_PORTCONFIG_HEADER>   // Port config header
    )

    // <pprh-ck>            // Port params header chunk
    (
        'pprh'
        <DMUS_PORTPARAMS8>   // Port params header
    )

LIST
(
    'pchl'          // List container for one or more pchannel to buffer assignments.
    <pchh-ck>...    // One or more pchannel to buffer assignment headers and data.

    // <pchh-ck>
    (
        'pchh'
        <DMUS_IO_PCHANNELTOBUFFER_HEADER>   // Description of PChannels
        <GUID>...                           // Array of GUIDs defining the buffers they all connect to.
    )
)

LIST
(
    'dbfl'          // List container for one buffer and buffer attributes header.
    <ddah-ck>       // Buffer attributes header. 
    [<mxbn-ck>]     // Optional mixbin list.
    [<DSBC-form>]   // Buffer configuration. Not required when header uses a predefined buffer type.

    // <ddah-ck>
    (
        'ddah'
        <DMUS_IO_BUFFER_ATTRIBUTES_HEADER>   // Buffer attributes.
    )
    // <mxbn-ck>
    (
        'mxbn'
        <DMUS_IO_BUFFER_MIXBINS_HEADER>       // Set of up to 8 mixbins.
    )    
)
*/

/*  File io for DirectMusic Band Track object */


/* RIFF ids: */
#define DMUS_FOURCC_BANDTRACK_FORM  mmioFOURCC('D','M','B','T')
#define DMUS_FOURCC_BANDTRACK_CHUNK mmioFOURCC('b','d','t','h')
#define DMUS_FOURCC_BANDS_LIST      mmioFOURCC('l','b','d','l')
#define DMUS_FOURCC_BAND_LIST       mmioFOURCC('l','b','n','d')
#define DMUS_FOURCC_BANDITEM_CHUNK  mmioFOURCC('b','d','i','h')
#define DMUS_FOURCC_BANDITEM_CHUNK2 mmioFOURCC('b','d','2','h')

/* io structures */
typedef struct _DMUS_IO_BAND_TRACK_HEADER
{
    BOOL bAutoDownload;     /* Determines if Auto-Download is enabled. */
} DMUS_IO_BAND_TRACK_HEADER;

typedef struct _DMUS_IO_BAND_ITEM_HEADER
{
    MUSIC_TIME lBandTime;   /* Position in track list. */
} DMUS_IO_BAND_ITEM_HEADER;

typedef struct _DMUS_IO_BAND_ITEM_HEADER2
{
    MUSIC_TIME lBandTimeLogical;   /* Position in track list. Time in the music with which band change is associated. */
    MUSIC_TIME lBandTimePhysical;  /* Precise time band change will take effect. Should be close to logical time. */
} DMUS_IO_BAND_ITEM_HEADER2;

/*
RIFF
(
    'DMBT'          // DirectMusic Band Track form-type
    [<bdth-ck>]     // Band track header
    [<guid-ck>]     // GUID for band track
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    <lbdl-list>     // List of Band items
)

    // <bnth-ck>
    'bdth'
    (
        <DMUS_IO_BAND_TRACK_HEADER>
    )

    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <lbdl-list>
    LIST
    (
        'lbdl'
        <lbnd-list>...  // Array of bands, each encapsulated in a list chunk
    )

        // <lbnd-list>
        LIST
        (
            'lbnd'
            <bdih-ck> or <bd2h-ck>  // bdih is a legacy format.  bd2h is preferred for new content.
            <DMBD-form> // Band
        )

            // <bdih-ck> or <bd2h-ck>       // band item header
            (
                <DMUS_IO_BAND_ITEM_HEADER> or <DMUS_IO_BAND_ITEM_HEADER2> // Band item header
            )
*/      


/*  File io for DirectMusic Band object
*/

/* RIFF ids: */

#define DMUS_FOURCC_BAND_FORM           mmioFOURCC('D','M','B','D')
#define DMUS_FOURCC_INSTRUMENTS_LIST    mmioFOURCC('l','b','i','l')
#define DMUS_FOURCC_INSTRUMENT_LIST     mmioFOURCC('l','b','i','n')
#define DMUS_FOURCC_INSTRUMENT_CHUNK    mmioFOURCC('b','i','n','s')

/* Flags for DMUS_IO_INSTRUMENT
 */
#define DMUS_IO_INST_PATCH          (1 << 0)        /* dwPatch is valid. */
#define DMUS_IO_INST_BANKSELECT     (1 << 1)        /* dwPatch contains a valid Bank Select MSB and LSB part */
#define DMUS_IO_INST_ASSIGN_PATCH   (1 << 3)        /* dwAssignPatch is valid */
#define DMUS_IO_INST_NOTERANGES     (1 << 4)        /* dwNoteRanges is valid */
#define DMUS_IO_INST_PAN            (1 << 5)        /* bPan is valid */
#define DMUS_IO_INST_VOLUME         (1 << 6 )       /* bVolume is valid */
#define DMUS_IO_INST_TRANSPOSE      (1 << 7)        /* nTranspose is valid */
#define DMUS_IO_INST_GM             (1 << 8)        /* Instrument is from GM collection */
#define DMUS_IO_INST_GS             (1 << 9)        /* Instrument is from GS collection */
#define DMUS_IO_INST_XG             (1 << 10)       /* Instrument is from XG collection */
#define DMUS_IO_INST_CHANNEL_PRIORITY (1 << 11)     /* dwChannelPriority is valid */
#define DMUS_IO_INST_USE_DEFAULT_GM_SET (1 << 12)   /* Always use the default GM set for this patch,  */
                                                    /* don't rely on the synth caps stating GM or GS in hardware. */
#define DMUS_IO_INST_PITCHBENDRANGE (1 << 13)     /* nPitchBendRange is valid */

/* io structures */
typedef struct _DMUS_IO_INSTRUMENT
{
    DWORD   dwPatch;            /* MSB, LSB and Program change to define instrument */
    DWORD   dwAssignPatch;      /* MSB, LSB and Program change to assign to instrument when downloading */
    DWORD   dwNoteRanges[4];    /* 128 bits; one for each MIDI note instrument needs to able to play */
    DWORD   dwPChannel;         /* PChannel instrument plays on */
    DWORD   dwFlags;            /* DMUS_IO_INST_ flags */
    BYTE    bPan;               /* Pan for instrument */
    BYTE    bVolume;            /* Volume for instrument */
    short   nTranspose;         /* Number of semitones to transpose notes */
    DWORD   dwChannelPriority;  /* Channel priority */
    short   nPitchBendRange;    /* Number of semitones shifted by pitch bend */
} DMUS_IO_INSTRUMENT;

/*
// <DMBD-form> bands can be embedded in other forms
RIFF
(
    'DMBD'          // DirectMusic Band chunk
    [<guid-ck>]     // GUID for band
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    <lbil-list>     // List of Instruments
)

    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <lbil-list>
    LIST
    (
        'lbil'          // Array of instruments
        <lbin-list>...  // Each instrument is encapsulated in a list
    )

        // <lbin-list>
        LIST
        (
            'lbin'
            <bins-ck>
            [<DMRF-list>]       // Optional reference to DLS Collection file.
        )

            // <bins-ck>            // Instrument chunk
            (
                'bins'
                <DMUS_IO_INSTRUMENT>    // Instrument header
            )
*/      

/* This RIFF id and io struct have been added to allow wave files (and the wave object) to 
   differentiate between streaming and one-shot waves, and to give a prefetch for streaming
   waves  */

#define DMUS_FOURCC_WAVEHEADER_CHUNK   mmioFOURCC('w','a','v','h')

typedef struct _DMUS_IO_WAVE_HEADER
{
    REFERENCE_TIME  rtReadAhead;    /* How far ahead in the stream wave data will be read (in REFERENCE_TIME).  Ignored for one-shot waves.  */
    DWORD           dwFlags;        /* Various flags, including whether this is a streaming wave and whether it can be invalidated. */
} DMUS_IO_WAVE_HEADER;


/*  File io for Wave track */

/* RIFF ids: */

#define DMUS_FOURCC_WAVETRACK_LIST      mmioFOURCC('w','a','v','t')
#define DMUS_FOURCC_WAVETRACK_CHUNK     mmioFOURCC('w','a','t','h')
#define DMUS_FOURCC_WAVEPART_LIST       mmioFOURCC('w','a','v','p')
#define DMUS_FOURCC_WAVEPART_CHUNK      mmioFOURCC('w','a','p','h')
#define DMUS_FOURCC_WAVEITEM_LIST       mmioFOURCC('w','a','v','i')
#define DMUS_FOURCC_WAVE_LIST           mmioFOURCC('w','a','v','e')
#define DMUS_FOURCC_WAVEITEM_CHUNK      mmioFOURCC('w','a','i','h')

/* This flag is included in DMUS_IO_WAVE_TRACK_HEADER.dwFlags.  If set, the track will get its 
   variations from a pattern track, via GetParam(GUID_Variations). */
#define DMUS_WAVETRACKF_SYNC_VAR   0x1
/* This is also included in DMUS_IO_WAVE_TRACK_HEADER.dwFlags.  If set, variation control 
   information will persist from one playback instance to the next.*/
#define DMUS_WAVETRACKF_PERSIST_CONTROL 0x2

typedef struct _DMUS_IO_WAVE_TRACK_HEADER
{
    long        lVolume;        /* Gain, in 1/100th of dB, to be applied to all waves.  Note:  All gain values should be negative. */
    DWORD       dwFlags;        /* Flags, including whether this track syncs to a pattern track for its variations. */
} DMUS_IO_WAVE_TRACK_HEADER;

typedef struct _DMUS_IO_WAVE_PART_HEADER
{
    long            lVolume;        /* Gain, in 1/100th of dB, to be applied to all waves in wave part.  Note:  All gain values should be negative. */
    DWORD           dwVariations;   /* Variation mask for which of 32 variations */
    DWORD           dwPChannel;     /* PChannel */
    DWORD           dwLockToPart;   /* Part ID to lock to. */
    DWORD           dwFlags;        /* Flags, including stuff for managing how variations are chosen (in low-order nibble) */
    DWORD           dwIndex;        /* Index for distinguishing multiple parts on the same PChannel*/
} DMUS_IO_WAVE_PART_HEADER;

typedef struct _DMUS_IO_WAVE_ITEM_HEADER
{
    long            lVolume;        /* Gain, in 1/100th of dB.  Note:  All gain values should be negative. */
    long            lPitch;         /* Pitch offset in 1/100th of a semitone. */
    DWORD           dwVariations;   /* Variation flags for which of 32 variations this wave belongs to. */
    REFERENCE_TIME  rtTime;         /* Start time, in REFERENCE_TIME, if clock time track, or MUSIC_TIME for music time track. */
    REFERENCE_TIME  rtStartOffset;  /* Distance into wave to start playback, in reference time units. */
    REFERENCE_TIME  rtReserved;     /* Reserved field. */
    REFERENCE_TIME  rtDuration;     /* Duration, in REFERENCE_TIME or MUSIC_TIME, depending on track timing format. */
    MUSIC_TIME      mtLogicalTime;  /* If in music track format, this indicates the musical boundary where this belongs. Otherwise, ignored. */
    DWORD           dwLoopStart;    /* Start point for a looping wave. */
    DWORD           dwLoopEnd;      /* End point for a looping wave. */
    DWORD           dwFlags;        /* Various flags, including whether this is a streaming wave and whether it can be invalidated. */
    WORD            wVolumeRange;   /* XBOX only: Random range for volume. */
    WORD            wPitchRange;    /* XBOX only: Random range for pitch. */
} DMUS_IO_WAVE_ITEM_HEADER;

/*
LIST
{
    'wavt'          // Wave track chunk
    <wath-ck>       // Wave track header
    <wavp-list>...  // Array of Wave Parts
}
    // <wath-ck>
    'wath'
    {
        <DMUS_IO_WAVE_TRACK_HEADER>
    }

    //  <wavp-list>
    LIST
    {
        'wavp'
        <waph-ck>       //  Wave Part Header
        <wavi-list>     //  List of wave items
    }

        //  <waph-ck>
        'waph'
        {
            <DMUS_IO_WAVE_PART_HEADER>
        }

        //  <wavi-list>
        LIST
        {
            'wavi'
            <wave-list>...  //  Array of waves; each wave is encapsulated in a list
        }

            //  <wave-list>
            LIST
            {
                'wave'
                <waih-ck>       //  Wave item header
                <DMRF-list>     //  Reference to wave object
            }

                //  <waih-ck>
                'waih'
                {
                    <DMUS_IO_WAVE_ITEM_HEADER>
                }

*/

/*  File io for DirectMusic Container file. This embeds a set of related files. And,
    in turn, it can be embedded within a segment or script file.
*/

#define DMUS_FOURCC_CONTAINER_FORM          mmioFOURCC('D','M','C','N')
#define DMUS_FOURCC_CONTAINER_CHUNK         mmioFOURCC('c','o','n','h')
#define DMUS_FOURCC_CONTAINED_ALIAS_CHUNK   mmioFOURCC('c','o','b','a')
#define DMUS_FOURCC_CONTAINED_OBJECT_CHUNK  mmioFOURCC('c','o','b','h')
#define DMUS_FOURCC_CONTAINED_OBJECTS_LIST  mmioFOURCC('c','o','s','l')
#define DMUS_FOURCC_CONTAINED_OBJECT_LIST   mmioFOURCC('c','o','b','l')

typedef struct _DMUS_IO_CONTAINER_HEADER
{
    DWORD       dwFlags;        /* Flags. */
} DMUS_IO_CONTAINER_HEADER;

#define DMUS_CONTAINER_NOLOADS  (1 << 1)   /* Contained items are not loaded when the container is loaded.
                                              Entries will be created in the loader (via SetObject) but
                                              the actual objects will not be created until they are
                                              specifically loaded at a later time. */

typedef struct _DMUS_IO_CONTAINED_OBJECT_HEADER
{
    GUID        guidClassID;    /* Class id of object. */
    DWORD       dwFlags;        /* Flags, for example DMUS_CONTAINED_OBJF_KEEP. */
    FOURCC      ckid;           /* chunk ID of track's data chunk if 0 fccType valid. */
    FOURCC      fccType;        /* list type if NULL ckid valid */
        /* Note that LIST:DMRF may be used for ckid and fccType in order to reference an
           object instead of embedding it within the container. */
} DMUS_IO_CONTAINED_OBJECT_HEADER;

#define DMUS_CONTAINED_OBJF_KEEP    1   /* Keep the object cached in the loader after the container is released. */

/*
RIFF
(
    'DMCN'          // DirectMusic Container chunk
    <conh-ck>       // Container header chunk
    [<guid-ck>]     // GUID for container
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    <cosl-list>     // List of objects.
)

    // <conh-ck>        
    'conh'
    (
        <DMUS_IO_CONTAINER_HEADER>
    )
    
    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    LIST
    (
        'cosl'          // Array of embedded objects.
        <cobl-list>...  // Each object is encapsulated in a LIST chunk
    )

    // <cobl-list>      // Encapsulates one object
    LIST
    (
        'cobl'
        [<coba-ck>]         // Alias.  An alternative name by which this object is known
                            // within the container.
        <cobh-ck>           // Required header, includes CLASS ID for object.
        [<data>] or <DMRF>  // Object data of the type specified in <cobh-ck>.
                            // If DMRF, it is a reference of where to find the object.
                            // Otherwise, it could be any RIFF readable chunk in the
                            //    exact same format as a file.  The object will load
                            //    itself from this data.
    )

    // <coba-ck>
    'coba'
    (
        // Alias, stored as NULL terminated string of WCHARs
    )

    // <cobh-ck>
    'cobh'
    (
        <DMUS_IO_CONTAINED_OBJECT_HEADER>
    )
*/

/*  File io for DirectMusic Segment object */

/* RIFF ids: */

#define DMUS_FOURCC_SEGMENT_FORM        mmioFOURCC('D','M','S','G')
#define DMUS_FOURCC_SEGMENT_CHUNK       mmioFOURCC('s','e','g','h')
#define DMUS_FOURCC_TRACK_LIST          mmioFOURCC('t','r','k','l')
#define DMUS_FOURCC_TRACK_FORM          mmioFOURCC('D','M','T','K')
#define DMUS_FOURCC_TRACK_CHUNK         mmioFOURCC('t','r','k','h')
#define DMUS_FOURCC_TRACK_EXTRAS_CHUNK  mmioFOURCC('t','r','k','x')

/* io structures:*/

typedef struct _DMUS_IO_SEGMENT_HEADER
{
    DWORD       dwRepeats;      /* Number of repeats. By default, 0. */
    MUSIC_TIME  mtLength;       /* Length, in music time. */
    MUSIC_TIME  mtPlayStart;    /* Start of playback. By default, 0. */
    MUSIC_TIME  mtLoopStart;    /* Start of looping portion. By default, 0. */
    MUSIC_TIME  mtLoopEnd;      /* End of loop. Must be greater than dwPlayStart. Or, 0, indicating loop full segment. */
    DWORD       dwResolution;   /* Default resolution. */
    /* Following added for DX8: */
    REFERENCE_TIME rtLength;    /* Length, in reference time (overrides music time length.) */
    DWORD       dwFlags;
    DWORD       dwReserved;     /* Reserved. */
    /* Added for XBOX. */
    REFERENCE_TIME rtLoopStart; /* Clock time loop start. */
    REFERENCE_TIME rtLoopEnd;   /* Clock time loop end. */
} DMUS_IO_SEGMENT_HEADER;

#define DMUS_SEGIOF_REFLENGTH   1  /* Use the time in rtLength for the segment length. */
#define DMUS_SEGIOF_REFLOOP     2  /* Use the values in rtLoopStart and rtLoopEnd to do clock time looping. */

typedef struct _DMUS_IO_TRACK_HEADER
{
    GUID        guidClassID;    /* Class id of track. */
    DWORD       dwPosition;     /* Position in track list. */
    DWORD       dwGroup;        /* Group bits for track. */
    FOURCC      ckid;           /* chunk ID of track's data chunk. */
    FOURCC      fccType;        /* list type if ckid is RIFF or LIST */ 
} DMUS_IO_TRACK_HEADER;

/*  Additional parameters for the track header chunk, introduced in DX8 and
    on, are stored in a separate chunk. */

typedef struct _DMUS_IO_TRACK_EXTRAS_HEADER
{
    DWORD       dwFlags;        /* DX8 Added flags for control tracks. */
    DWORD       dwPriority;     /* Priority for composition. */
} DMUS_IO_TRACK_EXTRAS_HEADER;

/*
RIFF
(
    'DMSG'          // DirectMusic Segment chunk
    <segh-ck>       // Segment header chunk
    [<guid-ck>]     // GUID for segment
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    [<DMCN-form>]   // Optional container of objects embedded in file. Must precede tracklist.
    <trkl-list>     // List of Tracks
    [<DMTG-form>]   // Optional ToolGraph
    [<DMAP-form>]   // Optional Audio Path
)

    // <segh-ck>        
    'segh'
    (
        <DMUS_IO_SEGMENT_HEADER>
    )
    
    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <trkl-list>
    LIST
    (
        'trkl'          // Array of tracks
        <DMTK-form>...  // Each track is encapsulated in a RIFF chunk
    )

    // <DMTK-form>      // Tracks can be embedded in a segment or stored as separate files.
    RIFF
    (
        'DMTK'
        <trkh-ck>
        [<trkx-ck>]     // Optional track flags. 
        [<guid-ck>]     // Optional GUID for track object instance (not to be confused with Class id in track header)
        [<vers-ck>]     // Optional version info
        [<UNFO-list>]   // Optional name, author, copyright info., comments
        [<data>]        // Track data. Must be a RIFF readable chunk.
    )

    // <trkh-ck>            // Track header chunk
    (
        'trkh'
        <DMUS_IO_TRACK_HEADER>  // Track header
    )

    // <trkx-ck>            // Track flags chunk
    (
        'trkx'
        <DMUS_IO_TRACK_EXTRAS_HEADER>  // DX8 Track flags header
    )
*/

/*  File io for DirectMusic Song object */
/*  Note: Song file format is not supported in DX8. */

/* RIFF ids: */

#define DMUS_FOURCC_SONG_FORM           mmioFOURCC('D','M','S','O') /* Entire song. */
#define DMUS_FOURCC_SONG_CHUNK          mmioFOURCC('s','n','g','h') /* Song header info. */
#define DMUS_FOURCC_SONGSEGMENTS_LIST   mmioFOURCC('s','e','g','l') /* List of embedded segments. */
#define DMUS_FOURCC_SONGSEGMENT_LIST    mmioFOURCC('s','s','g','l') /* Container for a segment or segment reference. */
#define DMUS_FOURCC_TOOLGRAPHS_LIST     mmioFOURCC('t','l','g','l') /* List of embedded tool graphs. */
#define DMUS_FOURCC_SEGREFS_LIST        mmioFOURCC('s','r','s','l') /* List of segment references. */
#define DMUS_FOURCC_SEGREF_LIST         mmioFOURCC('s','g','r','l') /* Container for a segment reference. */
#define DMUS_FOURCC_SEGREF_CHUNK        mmioFOURCC('s','g','r','h') /* Segment reference header. */
#define DMUS_FOURCC_SEGTRANS_CHUNK      mmioFOURCC('s','t','r','h') /* Set of transitions to this segment. */
#define DMUS_FOURCC_TRACKREFS_LIST      mmioFOURCC('t','r','s','l') /* Set of track references within the segment reference. */
#define DMUS_FOURCC_TRACKREF_LIST       mmioFOURCC('t','k','r','l') /* Container for a track reference. */
#define DMUS_FOURCC_TRACKREF_CHUNK      mmioFOURCC('t','k','r','h') /* Track reference header. */

/* io structures:*/

typedef struct _DMUS_IO_SONG_HEADER
{
    DWORD       dwFlags;
    DWORD       dwStartSegID;   /* Id of the segment that starts playback. */
} DMUS_IO_SONG_HEADER;

typedef struct _DMUS_IO_SEGREF_HEADER
{
    DWORD       dwID;           /* Each has a unique ID. Must be less than DMUS_SONG_MAXSEGID. */
    DWORD       dwSegmentID;    /* Optional segment to link to. */
    DWORD       dwToolGraphID;  /* Optional tool graph to use for processing. */
    DWORD       dwFlags;        /* Various control flags. Currently reserved for future use. Must be 0. */
    DWORD       dwNextPlayID;   /* ID of next segment, to chain segments into a song. */
} DMUS_IO_SEGREF_HEADER;


typedef struct _DMUS_IO_TRACKREF_HEADER
{
    DWORD       dwSegmentID;    /* Which segment to find this in. */
    DWORD       dwFlags;        /* Reference control flags. */
} DMUS_IO_TRACKREF_HEADER;

/*  Transition definition chunk defines a transition, using an optional transition template
    segment.
*/

typedef struct _DMUS_IO_TRANSITION_DEF
{
    DWORD       dwSegmentID;        /* Segment the transition goes to. */
    DWORD       dwTransitionID;     /* Template segment to use for the transition. */
    DWORD       dwPlayFlags;        /* Flags to use for transition. */
} DMUS_IO_TRANSITION_DEF;

#define DMUS_SONG_MAXSEGID      0x7FFFFFFF  /* Segment ids can not go higher than this. */
#define DMUS_SONG_ANYSEG        0x80000000  /* Special ID to indicate any segment. */
#define DMUS_SONG_NOSEG         0xFFFFFFFF  /* Special ID to indicate no segment. */
#define DMUS_SONG_NOFROMSEG     0x80000001  /* Special ID for dwSegmentID to indicate transition from nothing (or outside the song) into this segment. */

/*
RIFF
(
    'DMSO'          // DirectMusic Song chunk
    <sngh-ck>       // Song header chunk
    [<guid-ck>]     // GUID for song
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    [<DMCN-form>]   // Optional container of objects embedded in file. Must precede segment list.
    <segl-list>     // List of Segments
    [<tlgl-list>]   // Optional list of ToolGraphs
    [<DMAP-form>]   // Optional Audio Path - to be shared by all segments in song.
    <srsl-list>     // List of segment references.
)

    // <sngh-ck>        
    'sngh'
    (
        <DMUS_IO_SONG_HEADER>
    )
    
    // <segl-list>
    LIST
    (
        'segl'          // Array of segments
        <ssgl-list>...  // Each segment is wrapped in this.
    )

    // <ssgl-list>
    LIST
    (
        'ssgl'          // Segment container.
        [DMSG-form]     // Each segment is either a full embedded segment RIFF form.
        [DMRF-list]     // Or a reference to an external segment.
    )

    // <tlgl-list>
    LIST
    (
        'tlgl'          // Array of toolgraphs
        <DMTG-form>...  // Each toolgraph is a full RIFF form.
    )

    // <srsl-list>
    LIST
    (
        'srsl'          // Array of segment references
        <sgrl-list>...  // Each segment reference is contained in a RIFF list.
    )

    // <sgrl-list>      // Segment reference container.
    LIST
    (
        'sgrl'
        <sgrh-ck>       // Segment reference header chunk.
        <segh-ck>       // Segment header chunk. Defines the segment. 
        <UNFO-list>     // Name, author, etc. Primarily for name, though, which is required for Song->GetSegment().
        [<strh-ck>]     // Segment transition chunk. Defines how to do transitions from other segments.
        [<trsl-list>]   // List of track references, to create a segment from tracks in multiple segments.
    )

    // <sgrh-ck>        // Segment reference header chunk
    (
        'sgrh'
        <DMUS_IO_SEGREF_HEADER>  // Segment reference header
    )

    // <strh-ck>        // Segment transition chunk. 
    (
        'strh'
        <DMUS_IO_TRANSITION_DEF>    // Default transition.
        <DMUS_IO_TRANSITION_DEF>... // Additional transitions.
    )

    // <trsl-list>      // Array of track references
    (
        'trsl'
        <tkrl-list>...  // Each track reference is multiple chunks in a tkrl list.
    )

    // <tkrl-list>      // Track reference container
    (
        'tkrl'
        <tkrh-ck>       // Track reference header chunk.
        <trkh-ck>       // Normal track header chunk.
        [<trkx-ck>]     // Optional track flags. 
    )

    // <tkrh-ck>        // Track reference header chunk
    (
        'tkrh'
        <DMUS_IO_TRACKREF_HEADER>  // Track reference header
    )
*/

/*  File io for DirectMusic reference chunk. 
    This is used to embed a reference to an object.
*/

/*  RIFF ids: */

#define DMUS_FOURCC_REF_LIST        mmioFOURCC('D','M','R','F')
#define DMUS_FOURCC_REF_CHUNK       mmioFOURCC('r','e','f','h')
#define DMUS_FOURCC_DATE_CHUNK      mmioFOURCC('d','a','t','e')
#define DMUS_FOURCC_NAME_CHUNK      mmioFOURCC('n','a','m','e')
#define DMUS_FOURCC_FILE_CHUNK      mmioFOURCC('f','i','l','e')

typedef struct _DMUS_IO_REFERENCE
{
    GUID    guidClassID;    /* Class id is always required. */
    DWORD   dwValidData;    /* Flags. */
} DMUS_IO_REFERENCE;

/*
LIST
(
    'DMRF'          // DirectMusic Reference chunk
    <refh-ck>       // Reference header chunk
    [<guid-ck>]     // Optional object GUID.
    [<date-ck>]     // Optional file date.
    [<name-ck>]     // Optional name.
    [<file-ck>]     // Optional file name.
    [<catg-ck>]     // Optional category name.
    [<vers-ck>]     // Optional version info.
)

    // <refh-ck>
    'refh'
    (
        <DMUS_IO_REFERENCE>
    )

    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <date-ck>
    date
    (
        <FILETIME>
    )

    // <name-ck>
    name
    (
        // Name, stored as NULL terminated string of WCHARs
    )

    // <file-ck>
    file
    (
        // File name, stored as NULL terminated string of WCHARs
    )

    // <catg-ck>
    catg
    (
        // Category name, stored as NULL terminated string of WCHARs
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )
*/

/* Chord Maps */

/* runtime chunks */
#define DMUS_FOURCC_CHORDMAP_FORM       mmioFOURCC('D','M','P','R')
#define DMUS_FOURCC_IOCHORDMAP_CHUNK    mmioFOURCC('p','e','r','h')
#define DMUS_FOURCC_SUBCHORD_CHUNK      mmioFOURCC('c','h','d','t')
#define DMUS_FOURCC_CHORDENTRY_CHUNK    mmioFOURCC('c','h','e','h')
#define DMUS_FOURCC_SUBCHORDID_CHUNK    mmioFOURCC('s','b','c','n')
#define DMUS_FOURCC_IONEXTCHORD_CHUNK   mmioFOURCC('n','c','r','d')
#define DMUS_FOURCC_NEXTCHORDSEQ_CHUNK  mmioFOURCC('n','c','s','q')
#define DMUS_FOURCC_IOSIGNPOST_CHUNK    mmioFOURCC('s','p','s','h')
#define DMUS_FOURCC_CHORDNAME_CHUNK     mmioFOURCC('I','N','A','M')

/* runtime list chunks */
#define DMUS_FOURCC_CHORDENTRY_LIST     mmioFOURCC('c','h','o','e')
#define DMUS_FOURCC_CHORDMAP_LIST       mmioFOURCC('c','m','a','p')
#define DMUS_FOURCC_CHORD_LIST          mmioFOURCC('c','h','r','d')
#define DMUS_FOURCC_CHORDPALETTE_LIST   mmioFOURCC('c','h','p','l')
#define DMUS_FOURCC_CADENCE_LIST        mmioFOURCC('c','a','d','e')
#define DMUS_FOURCC_SIGNPOSTITEM_LIST   mmioFOURCC('s','p','s','t')

#define DMUS_FOURCC_SIGNPOST_LIST       mmioFOURCC('s','p','s','q')

/* values for dwChord field of DMUS_IO_PERS_SIGNPOST */
/* DMUS_SIGNPOSTF_ flags are also used in templates (DMUS_IO_SIGNPOST) */
#define DMUS_SIGNPOSTF_A        1      
#define DMUS_SIGNPOSTF_B        2
#define DMUS_SIGNPOSTF_C        4
#define DMUS_SIGNPOSTF_D        8
#define DMUS_SIGNPOSTF_E        0x10
#define DMUS_SIGNPOSTF_F        0x20
#define DMUS_SIGNPOSTF_LETTER   (DMUS_SIGNPOSTF_A | DMUS_SIGNPOSTF_B | DMUS_SIGNPOSTF_C | DMUS_SIGNPOSTF_D | DMUS_SIGNPOSTF_E | DMUS_SIGNPOSTF_F)
#define DMUS_SIGNPOSTF_1        0x100
#define DMUS_SIGNPOSTF_2        0x200
#define DMUS_SIGNPOSTF_3        0x400
#define DMUS_SIGNPOSTF_4        0x800
#define DMUS_SIGNPOSTF_5        0x1000
#define DMUS_SIGNPOSTF_6        0x2000
#define DMUS_SIGNPOSTF_7        0x4000
#define DMUS_SIGNPOSTF_ROOT     (DMUS_SIGNPOSTF_1 | DMUS_SIGNPOSTF_2 | DMUS_SIGNPOSTF_3 | DMUS_SIGNPOSTF_4 | DMUS_SIGNPOSTF_5 | DMUS_SIGNPOSTF_6 | DMUS_SIGNPOSTF_7)
#define DMUS_SIGNPOSTF_CADENCE  0x8000

/* values for dwFlags field of DMUS_IO_CHORDMAP */
#define DMUS_CHORDMAPF_VERSION8  1   /* Chordmap is version 8 or above. */

/* values for dwChord field of DMUS_IO_PERS_SIGNPOST */
#define DMUS_SPOSTCADENCEF_1  2   /* Use the first cadence chord. */
#define DMUS_SPOSTCADENCEF_2  4   /* Use the second cadence chord. */

/* run time data structs */
typedef struct _DMUS_IO_CHORDMAP
{
    WCHAR   wszLoadName[20];
    DWORD   dwScalePattern;
    DWORD   dwFlags;           /* Various flags. Only lower 16 bits are significant. */
} DMUS_IO_CHORDMAP;

typedef struct _DMUS_IO_CHORDMAP_SUBCHORD
{
    DWORD   dwChordPattern;
    DWORD   dwScalePattern;
    DWORD   dwInvertPattern;
    BYTE    bChordRoot;
    BYTE    bScaleRoot;
    WORD    wCFlags;
    DWORD   dwLevels;   /* parts or which subchord levels this chord supports */
} DMUS_IO_CHORDMAP_SUBCHORD;

/* Legacy name... */
typedef DMUS_IO_CHORDMAP_SUBCHORD DMUS_IO_PERS_SUBCHORD;

typedef struct _DMUS_IO_CHORDENTRY
{
    DWORD   dwFlags;
    WORD    wConnectionID;  /* replaces runtime "pointer to this" */
} DMUS_IO_CHORDENTRY;

typedef struct _DMUS_IO_NEXTCHORD
{
    DWORD   dwFlags;
    WORD    nWeight;
    WORD    wMinBeats;
    WORD    wMaxBeats;
    WORD    wConnectionID;  /* points to an ioChordEntry */
} DMUS_IO_NEXTCHORD;

typedef struct _DMUS_IO_CHORDMAP_SIGNPOST
{
    DWORD   dwChords;   /* 1bit per group */
    DWORD   dwFlags;
} DMUS_IO_CHORDMAP_SIGNPOST;

/* Legacy name... */
typedef DMUS_IO_CHORDMAP_SIGNPOST DMUS_IO_PERS_SIGNPOST;

/*
RIFF
(
    'DMPR'
    <perh-ck>           // Chord map header chunk
    [<guid-ck>]         // guid chunk
    [<vers-ck>]         // version chunk (two DWORDS)
    [<UNFO-list>]       // Unfo chunk
    <chdt-ck>           // subchord database
    <chpl-list>         // chord palette
    <cmap-list>         // chord map
    <spsq-list>         // signpost list
 )

<cmap-list> ::= LIST('cmap' <choe-list> )

<choe-list> ::= LIST('choe'
                                <cheh-ck>   // chord entry data
                                <chrd-list> // chord definition
                                <ncsq-ck>   // connecting(next) chords
                     )

<chrd-list> ::= LIST('chrd' 
                                <INAM-ck>   // name of chord in wide char format
                                <sbcn-ck>   // list of subchords composing chord
                    )

<chpl-list> ::= LIST('chpl' 
                                <chrd-list> ... // chord definition
                    )

<spsq-list> ::== LIST('spsq' <spst-list> ... )

<spst-list> ::= LIST('spst'
                             <spsh-ck>
                             <chrd-list>
                             [<cade-list>]
                    )

<cade-list> ::= LIST('cade' <chrd-list> ...)

<perh-ck> ::= perh(<DMUS_IO_CHORDMAP>)

<chdt-ck> ::= chdt(<cbChordSize::WORD>
                   <DMUS_IO_PERS_SUBCHORD> ... )

<cheh-ck> ::= cheh(<DMUS_IO_CHORDENTRY>)

<sbcn-ck> ::= sbcn(<cSubChordID:WORD> ...)

<ncsq-ck> ::= ncsq(<wNextChordSize:WORD> 
                   <DMUS_IO_NEXTCHORD>...)

<spsh-ck> ::= spsh(<DMUS_IO_PERS_SIGNPOST>)

*/

/*  File io for DirectMusic Script object */

/* RIFF ids: */

#define DMUS_FOURCC_SCRIPT_FORM             mmioFOURCC('D','M','S','C')
#define DMUS_FOURCC_SCRIPT_CHUNK            mmioFOURCC('s','c','h','d')
#define DMUS_FOURCC_SCRIPTVERSION_CHUNK     mmioFOURCC('s','c','v','e')
#define DMUS_FOURCC_SCRIPTLANGUAGE_CHUNK    mmioFOURCC('s','c','l','a')
#define DMUS_FOURCC_SCRIPTSOURCE_CHUNK      mmioFOURCC('s','c','s','r')

/* io structures:*/

typedef struct _DMUS_IO_SCRIPT_HEADER
{
    DWORD       dwFlags; /* DMUS_SCRIPTIOF_ flags */
} DMUS_IO_SCRIPT_HEADER;

#define DMUS_SCRIPTIOF_LOAD_ALL_CONTENT       (1 << 0)
    /* If set, when the script loads it will also load all the content in its container. */
#define DMUS_SCRIPTIOF_DOWNLOAD_ALL_SEGMENTS  (1 << 1)
    /* If set and LOAD_ALL_CONTENT is also set, when the script initializes it will also download all the segments in its container.
       If set and LOAD_ALL_CONTENT is not set, when the script calls segment.Load on a segment then the segment will also be downloaded.
       If not set, the script must manually download and unload by calling segment.DownloadSoundData and segment.UnloadSoundData. */

/*
RIFF
(
    'DMSC'              // DirectMusic Script chunk
    <schd-ck>           // Script header chunk
    [<guid-ck>]         // GUID for script
    [<vers-ck>]         // Optional version info
    [<UNFO-list>]       // Name, author, copyright info., comments
    <scve-ck>           // Version of DirectMusic this script was authored to run against
    <DMCN-form>         // Container of content referenced by the script.
    <scla-ck>           // ActiveX scripting language in which the script is written
    <scsr-ck> or <DMRF> // The script's source code.
                        // If scsr-ck, the source is embedding in the chunk.
                        // If DMRF, it is a reference of where to find a text file with the source.
                        //    Class id (guidClassID in DMUS_IO_REFERENCE) must be GUID_NULL because
                        //    this text file is not a DirectMusic object in its own right.
)

    // <schd-ck>
    'schd'
    (
        <DMUS_FOURCC_SCRIPT_CHUNK>
    )
    
    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <scve-ck>
    scve
    (
        <DMUS_IO_VERSION>
    )

    'scla'
    (
        // Language name, stored as NULL terminated string of WCHARs
    )

    'scsr'
    (
        // Source code, stored as NULL terminated string of WCHARs
    )
*/

/* Signpost tracks */

#define DMUS_FOURCC_SIGNPOST_TRACK_CHUNK     mmioFOURCC( 's', 'g', 'n', 'p' )


typedef struct _DMUS_IO_SIGNPOST
{
    MUSIC_TIME  mtTime;
    DWORD       dwChords;
    WORD        wMeasure;
} DMUS_IO_SIGNPOST;

/*

    // <sgnp-list>
    'sgnp'
    (
        //sizeof DMUS_IO_SIGNPOST: DWORD
        <DMUS_IO_SIGNPOST>...
    )

*/

#define DMUS_FOURCC_MUTE_CHUNK  mmioFOURCC('m','u','t','e')

typedef struct _DMUS_IO_MUTE
{
    MUSIC_TIME  mtTime;
    DWORD       dwPChannel;
    DWORD       dwPChannelMap;
} DMUS_IO_MUTE;

/*

    // <mute-list>
    'mute'
    (
        //sizeof DMUS_IO_MUTE:DWORD
        <DMUS_IO_MUTE>...
    )


*/

/* Used for both style and chord map tracks */

#define DMUS_FOURCC_TIME_STAMP_CHUNK    mmioFOURCC('s', 't', 'm', 'p')

/* Style tracks */

#define DMUS_FOURCC_STYLE_TRACK_LIST    mmioFOURCC('s', 't', 't', 'r')
#define DMUS_FOURCC_STYLE_REF_LIST      mmioFOURCC('s', 't', 'r', 'f')

/*

    // <sttr-list>
    LIST('sttr'
    (
        <strf-list>...  // Array of Style references
    )

    // <strf-list>
    LIST('strf'
    (
        <stmp-ck>
        <DMRF>
    )

  // <stmp-ck>
  'stmp'
  (
    // time:DWORD
  )

*/

/* Chord map tracks */

#define DMUS_FOURCC_PERS_TRACK_LIST mmioFOURCC('p', 'f', 't', 'r')
#define DMUS_FOURCC_PERS_REF_LIST   mmioFOURCC('p', 'f', 'r', 'f')

/*

    // <pftr-list>
    LIST('pftr'
    (
        <pfrf-list>...  // Array of Chord map references
    )

    // <pfrf-list>
    LIST('pfrf'
    (
        <stmp-ck>
        <DMRF>
    )

  // <stmp-ck>
  'stmp'
  (
    // time:DWORD
  )

*/

#define DMUS_FOURCC_TEMPO_TRACK     mmioFOURCC('t','e','t','r')

/*
    // tempo array
    'tetr'
    (
        // sizeof DMUS_IO_TEMPO_ITEM: DWORD
        <DMUS_IO_TEMPO_ITEM>...
    )
 */

#define DMUS_FOURCC_SEQ_TRACK       mmioFOURCC('s','e','q','t')
#define DMUS_FOURCC_SEQ_LIST        mmioFOURCC('e','v','t','l')
#define DMUS_FOURCC_CURVE_LIST      mmioFOURCC('c','u','r','l')

/*
    // sequence track
    'seqt'
    (
        // sequence array
        'evtl'
        (
            // sizeof DMUS_IO_SEQ_ITEM: DWORD
            <DMUS_IO_SEQ_ITEM>...
        )
        // curve array
        'curl'
        (
            // sizeof DMUS_IO_CURVE_ITEM: DWORD
            <DMUS_IO_CURVE_ITEM>...
        )
    )
*/

#define DMUS_FOURCC_SYSEX_TRACK     mmioFOURCC('s','y','e','x')

/*
    // sysex track
    'syex'
    (
        {
            <DMUS_IO_SYSEX_ITEM>
            <BYTE>...    // Array of bytes, length defined in the DMUS_IO_SYSEXITEM structure
        }...
    )
*/

#define DMUS_FOURCC_TIMESIGNATURE_TRACK mmioFOURCC('t','i','m','s')

typedef struct _DMUS_IO_TIMESIGNATURE_ITEM
{
    MUSIC_TIME    lTime;
    BYTE          bBeatsPerMeasure;   /* beats per measure (top of time sig) */
    BYTE          bBeat;              /* what note receives the beat (bottom of time sig.) */
                                      /* we can assume that 0 means 256th note */
    WORD          wGridsPerBeat;      /* grids per beat */
} DMUS_IO_TIMESIGNATURE_ITEM;

/*  DX6 time signature track
    
    'tims'
    (
        // size of DMUS_IO_TIMESIGNATURE_ITEM : DWORD
        <DMUS_IO_TIMESIGNATURE_ITEM>...
    )
*/

/*  DX8 Time signature track. The track has been updated from DX7 to support a list of
    RIFF chunks. This will allow the time signature track to expand in the future.
*/

#define DMUS_FOURCC_TIMESIGTRACK_LIST   mmioFOURCC('T','I','M','S')
#define DMUS_FOURCC_TIMESIG_CHUNK       DMUS_FOURCC_TIMESIGNATURE_TRACK

/*
LIST
(
    'TIMS'          // Time Signature Track list-type
    <tims-ck>       // Chunk containing an array of time signatures
)

    'tims'
    (
        // size of DMUS_IO_TIMESIGNATURE_ITEM : DWORD
        <DMUS_IO_TIMESIGNATURE_ITEM>...
    )
 
*/

/*  DX8 Marker track. This is used to store valid start points and other
    flow control parameters that may come later. For example, if we want
    to implement more sophisticated looping and branching constructs, they
    would live in this track.
*/

#define DMUS_FOURCC_MARKERTRACK_LIST    mmioFOURCC('M','A','R','K')
#define DMUS_FOURCC_VALIDSTART_CHUNK    mmioFOURCC('v','a','l','s')
#define DMUS_FOURCC_PLAYMARKER_CHUNK    mmioFOURCC('p','l','a','y')

/* io structures */
typedef struct _DMUS_IO_VALID_START
{
    MUSIC_TIME mtTime;      /* Time of a legal start. */
} DMUS_IO_VALID_START;

typedef struct _DMUS_IO_PLAY_MARKER
{
    MUSIC_TIME mtTime;      /* Time of a next legal play point marker. */
} DMUS_IO_PLAY_MARKER;

/*
LIST
(
    'MARK'          // Marker Track list-type
    [<vals-ck>]     // Chunk containing an array of start points
    [<play-ck>]     // Chunk containing an array of play start markers
)

    'vals'
    (
        // size of DMUS_IO_VALID_START : DWORD
        <DMUS_IO_VALID_START>...
    )

    'play'
    (
        // size of DMUS_IO_PLAY_MARKER : DWORD
        <DMUS_IO_PLAY_MARKER>...
    )
  
*/

/* segment trigger tracks */

/* RIFF ids: */
#define DMUS_FOURCC_SEGTRACK_LIST                   mmioFOURCC('s','e','g','t')
#define DMUS_FOURCC_SEGTRACK_CHUNK                  mmioFOURCC('s','g','t','h')
#define DMUS_FOURCC_SEGMENTS_LIST                   mmioFOURCC('l','s','g','l')
#define DMUS_FOURCC_SEGMENT_LIST                    mmioFOURCC('l','s','e','g')
#define DMUS_FOURCC_SEGMENTITEM_CHUNK               mmioFOURCC('s','g','i','h')
#define DMUS_FOURCC_SEGMENTITEMNAME_CHUNK           mmioFOURCC('s','n','a','m')

/* io structures */
typedef struct _DMUS_IO_SEGMENT_TRACK_HEADER
{
    DWORD dwFlags; /* Reserved leave as 0. */
} DMUS_IO_SEGMENT_TRACK_HEADER;

typedef struct _DMUS_IO_SEGMENT_ITEM_HEADER
{
    MUSIC_TIME      lTimeLogical;    /* Position in track list. Time in the music with which the event is associated. */
    MUSIC_TIME      lTimePhysical;   /* Precise time event will be triggered. Should be close to logical time. */
    DWORD           dwPlayFlags;     /* Flags for PlaySegment(). */
    DWORD           dwFlags;         /* Flags. */
} DMUS_IO_SEGMENT_ITEM_HEADER;

/* values for dwflags field of DMUS_IO_SEGMENT_ITEM_HEADER */
#define DMUS_SEGMENTTRACKF_MOTIF                 1        /* interpret DMRF as link to style, and use snam as the name of a motif within the style */

/*
LIST
(
    'segt'          // DirectMusic Segment Trigger Track form-type
    [<sgth-ck>]     // Segment track header
    <lsgl-list>     // List of Segment Lists
)

    // <sgth-ck>
    'sgth'
    (
        <DMUS_IO_SEGMENT_TRACK_HEADER>
    )

    // <lsgl-list>
    LIST
    (
        'lsgl'          // Array of segments
        <lseg-list>...  // Each segment is encapsulated in a list (that way it can still be riff parsed.)
    )

        // <lseg-list>
        LIST
        (
            'lseg'
            <sgih-ck>
            <DMRF-list>    // Link to a segment or style file.
            [<snam-ck>]    // Name field.  Used with DMUS_SEGMENTTRACKF_MOTIF flag.
        )

            // <sgih-ck>            // segment item header
            (
                <DMUS_IO_SEGMENT_ITEM_HEADER>  // Segment item header
            )

            // <snam-ck>
            (
                // Name, stored as NULL terminated string of WCHARs
            )
*/      

/* Script track. */

/* RIFF ids: */
#define DMUS_FOURCC_SCRIPTTRACK_LIST                mmioFOURCC('s','c','r','t')
#define DMUS_FOURCC_SCRIPTTRACKEVENTS_LIST          mmioFOURCC('s','c','r','l')
#define DMUS_FOURCC_SCRIPTTRACKEVENT_LIST           mmioFOURCC('s','c','r','e')
#define DMUS_FOURCC_SCRIPTTRACKEVENTHEADER_CHUNK    mmioFOURCC('s','c','r','h')
#define DMUS_FOURCC_SCRIPTTRACKEVENTNAME_CHUNK      mmioFOURCC('s','c','r','n')

/* Flags for DMUS_IO_SCRIPTTRACK_TIMING
 */
#define DMUS_IO_SCRIPTTRACKF_PREPARE (1 << 0)        /* Fire event in advance of time stamp, at Prepare time.  This is the default because it leaves the script time to change the music happening at the target time. */
#define DMUS_IO_SCRIPTTRACKF_QUEUE   (1 << 1)        /* Fire event just before time stamp, at Queue time. */
#define DMUS_IO_SCRIPTTRACKF_ATTIME  (1 << 2)        /* Fire event right at the time stamp. */

typedef struct _DMUS_IO_SCRIPTTRACK_EVENTHEADER
{
    DWORD dwFlags;              /* various bits (see DMUS_IO_SCRIPTTRACKF_*) */
    MUSIC_TIME lTimeLogical;    /* Position in track list. Time in the music with which the event is associated. */
    MUSIC_TIME lTimePhysical;   /* Precise time event will be triggered. Should be close to logical time. */
} DMUS_IO_SCRIPTTRACK_EVENTHEADER;

/*
    // Script Track

    // <scrt-list>
    LIST
    (
        <scrl-list>       // List of script events
    )

        // <scrl-list>
        LIST
        (
            <scre-list>...    // Array of event descriptions
        )

            // <scre-list>
            LIST
            (
                <scrh-ck>         // Event header chunk
                <DMRF>
                <scrn-ck>         // Routine name
            )

                'scrh'
                (
                    <DMUS_IO_SCRIPTTRACK_EVENTHEADER>
                )

                'scrn'
                (
                    // Name, stored as NULL terminated string of WCHARs
                )
*/

/* Lyrics/Notification track. */

/* RIFF ids: */
#define DMUS_FOURCC_LYRICSTRACK_LIST                mmioFOURCC('l','y','r','t')
#define DMUS_FOURCC_LYRICSTRACKEVENTS_LIST          mmioFOURCC('l','y','r','l')
#define DMUS_FOURCC_LYRICSTRACKEVENT_LIST           mmioFOURCC('l','y','r','e')
#define DMUS_FOURCC_LYRICSTRACKEVENTHEADER_CHUNK    mmioFOURCC('l','y','r','h')
#define DMUS_FOURCC_LYRICSTRACKEVENTTEXT_CHUNK      mmioFOURCC('l','y','r','n')

typedef struct _DMUS_IO_LYRICSTRACK_EVENTHEADER
{
    DWORD dwFlags;              /* Reserved leave as 0. */
    DWORD dwTimingFlags;        /* Combination DMUS_PMSGF_TOOL_* flags.  Determines the precise timing of when the notification happens. Invalid with the flag DMUS_PMSGF_REFTIME, DMUS_PMSGF_MUSICTIME, DMUS_PMSGF_TOOL_FLUSH, or DMUS_PMSGF_LOCKTOREFTIME. */
    MUSIC_TIME lTimeLogical;    /* Position in track list. Time in the music with which the event is associated. */
    MUSIC_TIME lTimePhysical;   /* Precise time event will be triggered. Should be close to logical time. */
} DMUS_IO_LYRICSTRACK_EVENTHEADER;

/*
    // Lyrics/Notification Track

    // <lyrt-list>
    LIST
    (
        <lyrl-list>       // List of notification events
    )

        // <lyrl-list>
        LIST
        (
            <lyre-list>...    // Array of event descriptions
        )

            // <lyre-list>
            LIST
            (
                <lyrh-ck>         // Event header chunk
                <lyrn-ck>         // Notification text
            )

                'lyrh'
                (
                    <DMUS_IO_LYRICSTRACK_EVENTHEADER>
                )

                'lyrn'
                (
                    // Name, stored as NULL terminated string of WCHARs
                )
*/

/* Parameter control track */

/* RIFF ids: */
#define DMUS_FOURCC_PARAMCONTROLTRACK_TRACK_LIST            mmioFOURCC('p','r','m','t')
#define DMUS_FOURCC_PARAMCONTROLTRACK_OBJECT_LIST           mmioFOURCC('p','r','o','l')
#define DMUS_FOURCC_PARAMCONTROLTRACK_OBJECT_CHUNK          mmioFOURCC('p','r','o','h')
#define DMUS_FOURCC_PARAMCONTROLTRACK_PARAM_LIST            mmioFOURCC('p','r','p','l')
#define DMUS_FOURCC_PARAMCONTROLTRACK_PARAM_CHUNK           mmioFOURCC('p','r','p','h')
#define DMUS_FOURCC_PARAMCONTROLTRACK_CURVES_CHUNK          mmioFOURCC('p','r','c','c')

typedef struct _DMUS_IO_PARAMCONTROLTRACK_OBJECTHEADER
{
    DWORD dwFlags;              /* Reserved.  Must be zero. */
    GUID guidTimeFormat;        /* Time format to set the object to.  Must be GUID_TIME_REFERNCE or GUID_TIME_MUSIC from medparam.h. */
    /* Path for finding the object. These fields correspond to the first five parameters of IDirectMusicSegmentState::GetObjectInPath. */
    DWORD dwPChannel;
    DWORD dwStage;
    DWORD dwBuffer;
    GUID guidObject;
    DWORD dwIndex;
} DMUS_IO_PARAMCONTROLTRACK_OBJECTHEADER;

typedef struct _DMUS_IO_PARAMCONTROLTRACK_PARAMHEADER
{
    DWORD dwFlags;              /* Reserved.  Must be zero. */
    DWORD dwIndex;              /* Index number of the parameter on the object */
} DMUS_IO_PARAMCONTROLTRACK_PARAMHEADER;

typedef struct _DMUS_IO_PARAMCONTROLTRACK_CURVEINFO
{
    MUSIC_TIME  mtStartTime;
    MUSIC_TIME  mtEndTime;
    float       fltStartValue;
    float       fltEndValue;
    DWORD       dwCurveType;   /* One of the items from the MP_CURVE_TYPE enum in medparam.h */
    DWORD       dwFlags;       /* A combination of the MPF_ENVLP_* constants in medparam.h */
} DMUS_IO_PARAMCONTROLTRACK_CURVEINFO;

/*
    // <prmt-list>
    LIST
    (
        <prol-list>...   // one for each object
    )

        // <prol-list>
        LIST
        (
            <proh-ck>       // object header chunk
            <prpl-list>...  // one for each parameter
        )

            // <proh-ck>
            proh
            (
                <DMUS_IO_PARAMCONTROLTRACK_OBJECTHEADER>
            )

            // <prpl-list>
            LIST
            (
                <prph-ck>       // parameter header chunk
                <prcc-ck>       // chunk containing an array of curves
            )

                // <prph-ck>
                prph
                (
                    <DMUS_IO_PARAMCONTROLTRACK_PARAMHEADER>
                )

                // <prcc-ck>
                prcc
                (
                    // sizeof DMUS_IO_PARAMCONTROLTRACK_CURVEINFO:DWORD
                    <DMUS_IO_PARAMCONTROLTRACK_CURVEINFO>... // curves, sorted in order of mtTime
                )
*/

/* Melody formulation track */
/* Note: Melody formulation file format is not supported in DX8. */

typedef DMUS_CONNECTION_RULE DMUS_IO_CONNECTION_RULE; /* defined in dmusici.h */

typedef DMUS_MELODY_FRAGMENT DMUS_IO_MELODY_FRAGMENT; /* defined in dmusici.h */

#define DMUS_FOURCC_MELODYFORM_TRACK_LIST     mmioFOURCC( 'm', 'f', 'r', 'm' )
#define DMUS_FOURCC_MELODYFORM_HEADER_CHUNK   mmioFOURCC( 'm', 'l', 'f', 'h' )
#define DMUS_FOURCC_MELODYFORM_BODY_CHUNK     mmioFOURCC( 'm', 'l', 'f', 'b' )

typedef struct _DMUS_IO_MELFORM
{
    DWORD        dwPlaymode;       /* NOT CURRENTLY USED - MUST BE 0 */   
} DMUS_IO_MELFORM;


/*
    // <mfrm-list>
    LIST
    (
        'mfrm'
        <mlfh-ck>       // Melody formulation header chunk
        <mlfb-ck>       // Melody formulation body chunk
    )

    // <mlfb-ck>
    'mlfb'
    (
        <DMUS_IO_MELFORM>
    )

  // <mlfb-ck>
    'mlfb'
    (
        //sizeof DMUS_IO_MELODY_FRAGMENT: DWORD
        <DMUS_IO_MELODY_FRAGMENT>...
    )

*/

#if (DIRECTSOUND_VERSION >= 0x0800) || defined(XBOX)

/* DirectSoundBufferConfig FX Map */

/* RIFF ids: */

#define DMUS_FOURCC_DSBC_FORM       mmioFOURCC('D','S','B','C')
#define DMUS_FOURCC_DSBD_CHUNK      mmioFOURCC('d','s','b','d')
#define DMUS_FOURCC_BSID_CHUNK      mmioFOURCC('b','s','i','d')
#define DMUS_FOURCC_DS3D_CHUNK      mmioFOURCC('d','s','3','d')
#define DMUS_FOURCC_DSBC_LIST       mmioFOURCC('f','x','l','s')
#define DMUS_FOURCC_DSFX_FORM       mmioFOURCC('D','S','F','X')
#define DMUS_FOURCC_DSFX_CHUNK      mmioFOURCC('f','x','h','r')
#define DMUS_FOURCC_DSFX_DATA       mmioFOURCC('d','a','t','a')

/* io structures */

typedef struct _DSOUND_IO_DSBUFFERDESC
{
    DWORD dwFlags;        /* DirectSound buffer creation flags */
    WORD nChannels;       /* No. of channels (rest of buffer format is determined by owning sink) */
    LONG lVolume;         /* Initial pan; only used if CTRLVOLUME is specified */
    LONG lPan;            /* Initial pan; only used if CTRLPAN is specified */
    DWORD dwReserved;     /* Reserved - must be 0 */
} DSOUND_IO_DSBUFFERDESC;

typedef struct _DSOUND_IO_DSBUSID
{
    DWORD busid[1];       /* Array size determined from chunk size */
} DSOUND_IO_DSBUSID;

typedef struct _DSOUND_IO_3D
{
    GUID guid3DAlgorithm; /* GUID identifying the 3D algorithm to use (defined in dsound.h) */
    DS3DBUFFER ds3d;      /* Initial 3D parameters */
} DSOUND_IO_3D;

typedef struct _DSOUND_IO_DXDMO_HEADER
{
    DWORD dwEffectFlags;  /* Effect creation flags - equivalent to DSEFFECTDESC::dwFlags */
    GUID guidDSFXClass;   /* GUID identifying the effect to use - corresponds to a COM CLSID */
    GUID guidReserved;    /* Reserved - must be the null GUID */
    GUID guidSendBuffer;  /* GUID identifying the buffer to send to if this is a send effect */
    DWORD dwReserved;     /* Reserved - must be 0 */
} DSOUND_IO_DXDMO_HEADER;

typedef struct _DSOUND_IO_DXDMO_DATA
{
    DWORD data[1];      /* Array size determined by the DMO involved */
} DSOUND_IO_DXDMO_DATA;

/*
RIFF
(
    'DSBC'          // DirectSoundBufferConfig chunk
    [<guid-ck>]     // GUID identifier for this DirectSoundBufferConfig
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    <dsbd-ck>       // DirectSound Buffer descriptor chunk
    [<bsid-ck>]     // Optional bus id array
    [<ds3d-ck>]     // Optional 3d Parameters
    [<fxls-list>]   // Optional list of FX descriptors
)

    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    'vers'
    (
        <DMUS_IO_VERSION>
    )

    // <dsbd-ck>
    'dsbd'
    (
        <DSOUND_IO_DSBUFFERDESC>  // Creation parameters and initial settings for the buffer
    )

    // <bsid-ck>
    'bsid'
    (
        <DSOUND_IO_DSBUSID>  // The size of DSOUND_IO_DSBUSID is determined by the chunk size 
    )

    // <ds3d-ck>
    'ds3d'
    (
        <DSOUND_IO_3D>  // Initial 3D buffer parameters: position, etc.
    )

    // <fx-list>
    LIST
    (
        'fxls'          // Array of DMO creation parameter blocks
        <DSFX-form>...  // Each DMO is encapsulated in a RIFF chunk
    )

// <DSFX-form>          // DMOs can be embedded in a buffer configuration or stored as separate files
RIFF
(
    'DSFX'
    <fxhr-ck>           // FX header chunk
    [<data-ck>]         // FX initial settings chunk
)

    // <fxhr-ck>
    'fxhr'
    (
        <DSOUND_IO_DXDMO_HEADER>
    )

    // <data-ck>
    'data'
    (
        <DSOUND_IO_DXDMO_DATA>  // Opaque data block used by the DMO to load itself.
        // For our standard included DMOs, this is simply the structure accepted by
        // the DMO's SetAllParameters() method - e.g. struct DSFXChorus for Chorus.
    )
*/

#endif

#ifdef __cplusplus
}; /* extern "C" */
#endif

#include <poppack.h>

#endif /* #ifndef _DMUSICF_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dmusic\inc\dmusici.h ===
/************************************************************************
*                                    ~~                                   *
*   dmusici.h -- This module contains the API for the                   *
*                DirectMusic performance layer                          *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corporation
*                                                                       *
************************************************************************/

#ifndef _DMUSICI_
#define _DMUSICI_

#include <xtl.h>
#ifndef _DUMMY_MSG
#define _DUMMY_MSG
struct MSG;
typedef struct MSG* LPMSG;
#endif
#include <xobjbase.h>
#include <pshpack8.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef WORD            TRANSITION_TYPE;
typedef long            MUSIC_TIME;

#define MT_MIN          0x80000000  /* Minimum music time value. */
#define MT_MAX          0x7FFFFFFF  /* Maximum music time value. */

#define DMUS_PPQ        768     /* parts per quarter note */

interface IDirectMusicPerformance;
interface IDirectMusicSegment;
interface IDirectMusicSegmentState;
interface IDirectMusicLoader;
interface IDirectMusicScript;
interface IDirectMusicAudioPath;
interface IDirectMusicTool;
interface IDirectMusicGraph;
interface IDirectMusicObject;
#ifndef __cplusplus 
typedef interface IDirectMusicPerformance IDirectMusicPerformance;
typedef interface IDirectMusicSegment IDirectMusicSegment;
typedef interface IDirectMusicSegmentState IDirectMusicSegmentState;
typedef interface IDirectMusicObject IDirectMusicObject;
typedef interface IDirectMusicLoader IDirectMusicLoader;
typedef interface IDirectMusicScript IDirectMusicScript;
typedef interface IDirectMusicAudioPath IDirectMusicAudioPath;
typedef interface IDirectMusicTool IDirectMusicTool;
typedef interface IDirectMusicGraph IDirectMusicGraph;
#endif


#define DMUS_PMSG_PART                                                                              \
    DWORD               dwSize;                                                                     \
    REFERENCE_TIME      rtTime;             /* real time (in 100 nanosecond increments) */          \
    MUSIC_TIME          mtTime;             /* music time */                                        \
    DWORD               dwFlags;            /* various bits (see DMUS_PMSGF_FLAGS enumeration) */    \
    DWORD               dwPChannel;         /* Performance Channel. The Performance can */          \
                                            /* use this to determine the port/channel. */           \
    DWORD               dwVirtualTrackID;   /* virtual track ID */                                  \
    IDirectMusicTool*   pTool;              /* tool interface pointer */                            \
    IDirectMusicGraph*  pGraph;             /* tool graph interface pointer */                      \
    DWORD               dwType;             /* PMSG type (see DMUS_PMSGT_TYPES defines) */              \
    DWORD               dwVoiceID;          /* unique voice id which allows synthesizers to */      \
                                            /* identify a specific event. For DirectX 6.0, */       \
                                            /* this field should always be 0. */                    \
    DWORD               dwGroupID;          /* Track group id */                                 \
    IUnknown*           punkUser;           /* user com pointer, auto released upon PMSG free */

/* every DMUS_PMSG is based off of this structure. The Performance needs 
   to access these members consistently in every PMSG that goes through it. */
typedef struct _DMUS_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

} DMUS_PMSG;

#define DMUS_PCHANNEL_BROADCAST_PERFORMANCE	0xFFFFFFFF  /* PMsg is sent on all PChannels of the performance. */
#define DMUS_PCHANNEL_BROADCAST_AUDIOPATH   0xFFFFFFFE  /* PMsg is sent on all PChannels of the audio path. */
#define DMUS_PCHANNEL_BROADCAST_SEGMENT	    0xFFFFFFFD  /* PMsg is sent on all PChannels of the segment. */
#define DMUS_PCHANNEL_BROADCAST_GROUPS  	0xFFFFFFFC  /* A duplicate PMsg is for each Channels Groups in the performance. */

/*  The DMUS_PATH constants are used in conjunction with GetObjectInPath to find a requested
    interface at a particular stage in the audio path. 
*/
#define DMUS_PATH_SEGMENT          0x1000      /* Get the segment itself (from a segment state.) */
#define DMUS_PATH_SEGMENT_GRAPH    0x1200      /* Get the segment's tool graph. */
#define DMUS_PATH_SEGMENT_TOOL     0x1300      /* Look in Tool Graph of Segment. */
#define DMUS_PATH_AUDIOPATH        0x2000      /* Get the audiopath itself (from a segment state.) */
#define DMUS_PATH_AUDIOPATH_GRAPH  0x2200      /* Get the audiopath's tool graph. */
#define DMUS_PATH_AUDIOPATH_TOOL   0x2300      /* Look in Tool Graph of Audio Path. */
#define DMUS_PATH_PERFORMANCE      0x3000      /* Access the performance. */
#define DMUS_PATH_PERFORMANCE_GRAPH 0x3200     /* Get the performance's tool graph. */
#define DMUS_PATH_PERFORMANCE_TOOL 0x3300      /* Look in Tool Graph of Performance. */
#define DMUS_PATH_BUFFER           0x6000      /* Look in DirectSoundBuffer. */

/*  To ignore PChannels when calling GetObjectInPath(), use the DMUS_PCHANNEL_ALL constant. */
#define DMUS_PCHANNEL_ALL           0xFFFFFFFB      

/*  The DMUS_APATH types are used in conjunction with CreateStandardAudioPath to
    build default path types. _SHARED_ means the same buffer is shared across multiple
    instantiations of the audiopath type. _DYNAMIC_ means a unique buffer is created
    every time. 
*/

/* A standard music set up with stereo outs and no reverb or chorus send. */
#define DMUS_APATH_SHARED_STEREO             0xFFFF0001
/* A standard music set up with stereo outs and reverb & chorus sends. */
#define DMUS_APATH_SHARED_STEREOPLUSREVERB   0xFFFF0002
/* An audio path with one dynamic bus from the synth feeding to a dynamic mono buffer. */
#define DMUS_APATH_DYNAMIC_MONO              0xFFFF0003   
/* An audio path with one dynamic bus from the synth feeding to a dynamic 3d buffer.*/
#define DMUS_APATH_DYNAMIC_3D                0xFFFF0004
/* Sends to quad mixbins on channels 1 through 4. */
#define DMUS_APATH_MIXBIN_QUAD               ((1 << DSMIXBIN_FRONT_LEFT ) | (1 << DSMIXBIN_FRONT_RIGHT ) | (1 << DSMIXBIN_BACK_LEFT ) | (1 << DSMIXBIN_BACK_RIGHT) )
/* Sends to quad mixbins on channels 1 through 4 and environmental reverb on 5. */
#define DMUS_APATH_MIXBIN_QUAD_ENV           ((1 << DSMIXBIN_FRONT_LEFT ) | (1 << DSMIXBIN_FRONT_RIGHT ) | (1 << DSMIXBIN_BACK_LEFT ) | (1 << DSMIXBIN_BACK_RIGHT ) | (1 << DSMIXBIN_I3DL2) )
/* Sends to quad mixbins on channels 1 through 4 and music reverb and chorus on 5, 6. */
#define DMUS_APATH_MIXBIN_QUAD_MUSIC         ((1 << DSMIXBIN_FRONT_LEFT ) | (1 << DSMIXBIN_FRONT_RIGHT ) | (1 << DSMIXBIN_BACK_LEFT ) | (1 << DSMIXBIN_BACK_RIGHT ) | (1 << DSMIXBIN_FXSEND_0 ) | (1 << DSMIXBIN_FXSEND_1) )
/* Sends to 5.1 mixbins on channels 1 through 6. */
#define DMUS_APATH_MIXBIN_5DOT1              ((1 << DSMIXBIN_FRONT_LEFT ) | (1 << DSMIXBIN_FRONT_RIGHT ) | (1 << DSMIXBIN_FRONT_CENTER ) | (1 << DSMIXBIN_LOW_FREQUENCY ) | (1 << DSMIXBIN_BACK_LEFT ) | (1 << DSMIXBIN_BACK_RIGHT) )
/* Sends to 5.1 mixbins on channels 1 through 6 and environmental reverb on 7. */
#define DMUS_APATH_MIXBIN_5DOT1_ENV          ((1 << DSMIXBIN_FRONT_LEFT ) | (1 << DSMIXBIN_FRONT_RIGHT ) | (1 << DSMIXBIN_FRONT_CENTER ) | (1 << DSMIXBIN_LOW_FREQUENCY ) | (1 << DSMIXBIN_BACK_LEFT ) | (1 << DSMIXBIN_BACK_RIGHT ) | (1 << DSMIXBIN_I3DL2) )
/* Sends to 5.1 mixbins on channels 1 through 6 and music reverb and chorus on 7, 8. */
#define DMUS_APATH_MIXBIN_5DOT1_MUSIC        ((1 << DSMIXBIN_FRONT_LEFT ) | (1 << DSMIXBIN_FRONT_RIGHT ) | (1 << DSMIXBIN_FRONT_CENTER ) | (1 << DSMIXBIN_LOW_FREQUENCY ) | (1 << DSMIXBIN_BACK_LEFT ) | (1 << DSMIXBIN_BACK_RIGHT ) | (1 << DSMIXBIN_FXSEND_0 ) | (1 << DSMIXBIN_FXSEND_1) )
/* 1,2 -> Stereo, 3 -> environmental reverb, 4 through 8 -> effects. */
#define DMUS_APATH_MIXBIN_STEREO_EFFECTS     ((1 << DSMIXBIN_FRONT_LEFT ) | (1 << DSMIXBIN_FRONT_RIGHT ) | (1 << DSMIXBIN_I3DL2 ) | (1 << DSMIXBIN_FXSEND_0 ) | (1 << DSMIXBIN_FXSEND_1 ) | (1 << DSMIXBIN_FXSEND_2 ) | (1 << DSMIXBIN_FXSEND_3 ) | (1 << DSMIXBIN_FXSEND_4) )


#define DMUS_INITAUDIO_NOTHREADS     0x1     /* If this is set, the app must call DirectMusicDoWork. */

/* DMUS_PMSGF_FLAGS fill the DMUS_PMSG's dwFlags member */
typedef enum enumDMUS_PMSGF_FLAGS
{
    DMUS_PMSGF_REFTIME          = 1,      /* if rtTime is valid */
    DMUS_PMSGF_MUSICTIME        = 2,      /* if mtTime is valid */
    DMUS_PMSGF_TOOL_IMMEDIATE   = 4,      /* if PMSG should be processed immediately */ 
    DMUS_PMSGF_TOOL_QUEUE       = 8,      /* if PMSG should be processed a little early, at Queue time */
    DMUS_PMSGF_TOOL_ATTIME      = 0x10,   /* if PMSG should be processed at the time stamp */
    DMUS_PMSGF_TOOL_FLUSH       = 0x20,   /* if PMSG is being flushed */
    DMUS_PMSGF_LOCKTOREFTIME    = 0x40,   /* if rtTime can not be overriden by a tempo change. */
    DMUS_PMSGF_DX8              = 0x80    /* if the message has DX8 or later extensions. */
    /* The values of DMUS_TIME_RESOLVE_FLAGS may also be used inside the */
    /* DMUS_PMSG's dwFlags member. */
} DMUS_PMSGF_FLAGS;

/* DMUS_PMSGT_TYPES fill the DMUS_PMSG's dwType member */
typedef enum enumDMUS_PMSGT_TYPES
{
    DMUS_PMSGT_MIDI             = 0,      /* MIDI short message */
    DMUS_PMSGT_NOTE             = 1,      /* Interactive Music Note */
    DMUS_PMSGT_SYSEX            = 2,      /* MIDI long message (system exclusive message) */
    DMUS_PMSGT_NOTIFICATION     = 3,      /* Notification message */
    DMUS_PMSGT_TEMPO            = 4,      /* Tempo message */
    DMUS_PMSGT_CURVE            = 5,      /* Control change / pitch bend, etc. curve */
    DMUS_PMSGT_TIMESIG          = 6,      /* Time signature */
    DMUS_PMSGT_PATCH            = 7,      /* Patch changes */
    DMUS_PMSGT_TRANSPOSE        = 8,      /* Transposition messages */
    DMUS_PMSGT_CHANNEL_PRIORITY = 9,      /* Channel priority */
    DMUS_PMSGT_STOP             = 10,     /* Stop message */
    DMUS_PMSGT_DIRTY            = 11,     /* Tells Tools that cache GetParam() info to refresh */
    DMUS_PMSGT_WAVE             = 12,     /* Carries control information for playing a wave. */
    DMUS_PMSGT_LYRIC            = 13,     /* Lyric message from lyric track. */
    DMUS_PMSGT_SCRIPTLYRIC      = 14,     /* Lyric message sent by a script with the Trace function. */
    DMUS_PMSGT_USER             = 255     /* User message */
} DMUS_PMSGT_TYPES;

/* DMUS_SEGF_FLAGS correspond to IDirectMusicPerformance::PlaySegment, and other API */
typedef enum enumDMUS_SEGF_FLAGS
{
    DMUS_SEGF_REFTIME           = 1<<6,   /* 0x40 Time parameter is in reference time  */
    DMUS_SEGF_SECONDARY         = 1<<7,   /* 0x80 Secondary segment */
    DMUS_SEGF_QUEUE             = 1<<8,   /* 0x100 Queue at the end of the primary segment queue (primary only) */
    DMUS_SEGF_CONTROL           = 1<<9,   /* 0x200 Play as a control track (secondary segments only) */
    DMUS_SEGF_AFTERPREPARETIME  = 1<<10,  /* 0x400 Play after the prepare time (See IDirectMusicPerformance::GetPrepareTime) */
    DMUS_SEGF_GRID              = 1<<11,  /* 0x800 Play on grid boundary */
    DMUS_SEGF_BEAT              = 1<<12,  /* 0x1000 Play on beat boundary */
    DMUS_SEGF_MEASURE           = 1<<13,  /* 0x2000 Play on measure boundary */
    DMUS_SEGF_DEFAULT           = 1<<14,  /* 0x4000 Use segment's default boundary */
    DMUS_SEGF_NOINVALIDATE      = 1<<15,  /* 0x8000 Play without invalidating the currently playing segment(s) */
    DMUS_SEGF_ALIGN             = 1<<16,  /* 0x10000 Align segment with requested boundary, but switch at first valid point */
    DMUS_SEGF_VALID_START_BEAT  = 1<<17,  /* 0x20000 In conjunction with DMUS_SEGF_ALIGN, allows the switch to occur on any beat. */
    DMUS_SEGF_VALID_START_GRID  = 1<<18,  /* 0x40000 In conjunction with DMUS_SEGF_ALIGN, allows the switch to occur on any grid. */
    DMUS_SEGF_VALID_START_TICK  = 1<<19,  /* 0x80000 In conjunction with DMUS_SEGF_ALIGN, allows the switch to occur any time. */
    DMUS_SEGF_AUTOTRANSITION    = 1<<20,  /* 0x100000 Compose and play a transition segment, using either the transition template or transition embedded in song. */
    DMUS_SEGF_AFTERQUEUETIME    = 1<<21,  /* 0x200000 Make sure to play after the queue time. This is default for primary segments */
    DMUS_SEGF_AFTERLATENCYTIME  = 1<<22,  /* 0x400000 Make sure to play after the latency time. This is true for all segments, so this is a nop */
    DMUS_SEGF_SEGMENTEND        = 1<<23,  /* 0x800000 Play at the next end of segment. */
    DMUS_SEGF_MARKER            = 1<<24,  /* 0x1000000 Play at next marker in the primary segment. If there are no markers, default to any other resolution requests. */
    DMUS_SEGF_TIMESIG_ALWAYS    = 1<<25,  /* 0x2000000 Even if there is no primary segment, align start time with current time signature. */
    DMUS_SEGF_USE_AUDIOPATH     = 1<<26,  /* 0x4000000 Uses the audio path that is embedded in the segment or song. */
    DMUS_SEGF_VALID_START_MEASURE = 1<<27,/* 0x8000000 In conjunction with DMUS_SEGF_ALIGN, allows the switch to occur on any bar. */
    DMUS_SEGF_INVALIDATE_PRI    = 1<<28   /* 0x10000000 invalidate only the current primary seg state */
} DMUS_SEGF_FLAGS;

#define DMUS_SEG_REPEAT_INFINITE    0xFFFFFFFF  /* For IDirectMusicSegment::SetRepeat*/
#define DMUS_SEG_ALLTRACKS          0x80000000  /* For IDirectMusicSegment::SetParam() and SetTrackConfig() - selects all tracks instead on nth index. */
#define DMUS_SEG_ANYTRACK           0x80000000  /* For IDirectMusicSegment::GetParam() - checks each track until it finds one that returns data (not DMUS_E_NOT_FOUND.) */
                                                

/* DMUS_TIME_RESOLVE_FLAGS correspond to IDirectMusicPerformance::GetResolvedTime, and can */
/* also be used interchangeably with the corresponding DMUS_SEGF_FLAGS, since their values */
/* are intentionally the same */
typedef enum enumDMUS_TIME_RESOLVE_FLAGS
{
    DMUS_TIME_RESOLVE_AFTERPREPARETIME  = DMUS_SEGF_AFTERPREPARETIME,
    DMUS_TIME_RESOLVE_AFTERQUEUETIME    = DMUS_SEGF_AFTERQUEUETIME,
    DMUS_TIME_RESOLVE_AFTERLATENCYTIME  = DMUS_SEGF_AFTERLATENCYTIME,
    DMUS_TIME_RESOLVE_GRID              = DMUS_SEGF_GRID,
    DMUS_TIME_RESOLVE_BEAT              = DMUS_SEGF_BEAT,
    DMUS_TIME_RESOLVE_MEASURE           = DMUS_SEGF_MEASURE,
    DMUS_TIME_RESOLVE_MARKER            = DMUS_SEGF_MARKER,
    DMUS_TIME_RESOLVE_SEGMENTEND        = DMUS_SEGF_SEGMENTEND,
} DMUS_TIME_RESOLVE_FLAGS;

/* The following flags are sent inside the DMUS_CHORD_KEY.dwFlags parameter */
typedef enum enumDMUS_CHORDKEYF_FLAGS
{
    DMUS_CHORDKEYF_SILENT            = 1,      /* is the chord silent? */
} DMUS_CHORDKEYF_FLAGS;

#define DMUS_MAXSUBCHORD 8

typedef struct _DMUS_SUBCHORD
{
    DWORD   dwChordPattern;     /* Notes in the subchord */
    DWORD   dwScalePattern;     /* Notes in the scale */
    DWORD   dwInversionPoints;  /* Where inversions can occur */
    DWORD   dwLevels;           /* Which levels are supported by this subchord */
    BYTE    bChordRoot;         /* Root of the subchord */
    BYTE    bScaleRoot;         /* Root of the scale */
} DMUS_SUBCHORD;

typedef struct _DMUS_CHORD_KEY
{
    WCHAR           wszName[16];        /* Name of the chord */
    WORD            wMeasure;           /* Measure this falls on */
    BYTE            bBeat;              /* Beat this falls on */
    BYTE            bSubChordCount;     /* Number of chords in the list of subchords */
    DMUS_SUBCHORD   SubChordList[DMUS_MAXSUBCHORD]; /* List of sub chords */
    DWORD           dwScale;            /* Scale underlying the entire chord */
    BYTE            bKey;               /* Key underlying the entire chord */
    BYTE            bFlags;             /* Miscelaneous flags */
} DMUS_CHORD_KEY;

typedef DMUS_CHORD_KEY DMUS_CHORD_PARAM; /* DMUS_CHORD_KEY defined in dmusici.h */

/* DMUS_NOTE_PMSG */
typedef struct _DMUS_NOTE_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    MUSIC_TIME mtDuration;     /* duration */
    WORD    wMusicValue;       /* Description of note in chord and key. */
    WORD    wMeasure;          /* Measure in which this note occurs */
    short   nOffset;           /* Offset from grid at which this note occurs */
    BYTE    bBeat;             /* Beat (in measure) at which this note occurs */
    BYTE    bGrid;             /* Grid offset from beat at which this note occurs */
    BYTE    bVelocity;         /* Note velocity */
    BYTE    bFlags;            /* see DMUS_NOTEF_FLAGS */
    BYTE    bTimeRange;        /* Range to randomize time. */
    BYTE    bDurRange;         /* Range to randomize duration. */
    BYTE    bVelRange;         /* Range to randomize velocity. */
    BYTE    bPlayModeFlags;    /* Play mode */
    BYTE    bSubChordLevel;    /* Which subchord level this note uses.  */
    BYTE    bMidiValue;        /* The MIDI note value, converted from wMusicValue */
    char    cTranspose;        /* Transposition to add to midi note value after converted from wMusicValue. */
} DMUS_NOTE_PMSG;

typedef enum enumDMUS_NOTEF_FLAGS
{
    DMUS_NOTEF_NOTEON = 1,              /* Set if this is a MIDI Note On. Otherwise, it is MIDI Note Off */
    DMUS_NOTEF_NOINVALIDATE = 2,        /* Don't invalidate this note off. */
    DMUS_NOTEF_NOINVALIDATE_INSCALE = 4,/* Don't invalidate if still within the scale. */
    DMUS_NOTEF_NOINVALIDATE_INCHORD = 8,/* Don't invalidate if still within the chord. */
    DMUS_NOTEF_REGENERATE = 0x10,       /* Regenerate the note on an invalidate. */
} DMUS_NOTEF_FLAGS;

/* The DMUS_PLAYMODE_FLAGS are used to determine how to convert wMusicValue
   into the appropriate bMidiValue.
*/

typedef enum enumDMUS_PLAYMODE_FLAGS
{
    DMUS_PLAYMODE_KEY_ROOT          = 1,  /* Transpose on top of the key root. */
    DMUS_PLAYMODE_CHORD_ROOT        = 2,  /* Transpose on top of the chord root. */
    DMUS_PLAYMODE_SCALE_INTERVALS   = 4,  /* Use scale intervals from scale pattern. */
    DMUS_PLAYMODE_CHORD_INTERVALS   = 8,  /* Use chord intervals from chord pattern. */
    DMUS_PLAYMODE_NONE              = 16, /* No mode. Indicates the parent part's mode should be used. */
} DMUS_PLAYMODE_FLAGS;

/* The following are playback modes that can be created by combining the DMUS_PLAYMODE_FLAGS
   in various ways:
*/

/* Fixed. wMusicValue holds final MIDI note value. This is used for drums, sound effects, and sequenced
   notes that should not be transposed by the chord or scale.
*/
#define DMUS_PLAYMODE_FIXED             0  
/* In fixed to key, the musicvalue is again a fixed MIDI value, but it
   is transposed on top of the key root. 
*/
#define DMUS_PLAYMODE_FIXEDTOKEY        DMUS_PLAYMODE_KEY_ROOT
/* In fixed to chord, the musicvalue is also a fixed MIDI value, but it
   is transposed on top of the chord root. 
*/
#define DMUS_PLAYMODE_FIXEDTOCHORD      DMUS_PLAYMODE_CHORD_ROOT
/* In Pedalpoint, the key root is used and the notes only track the intervals in
   the scale. The chord root and intervals are completely ignored. This is useful
   for melodic lines that play relative to the key root.
*/
#define DMUS_PLAYMODE_PEDALPOINT        (DMUS_PLAYMODE_KEY_ROOT | DMUS_PLAYMODE_SCALE_INTERVALS)
/* In the Melodic mode, the chord root is used but the notes only track the intervals in
   the scale. The key root and chord intervals are completely ignored. This is useful
   for melodic lines that play relative to the chord root. 
*/
#define DMUS_PLAYMODE_MELODIC           (DMUS_PLAYMODE_CHORD_ROOT | DMUS_PLAYMODE_SCALE_INTERVALS)
/* Normal chord mode is the prevalent playback mode. 
   The notes track the intervals in the chord, which is based on the chord root. 
   If there is a scale component to the MusicValue, the additional intervals 
   are pulled from the scale and added.
   If the chord does not have an interval to match the chord component of
   the MusicValue, the note is silent.
*/
#define DMUS_PLAYMODE_NORMALCHORD       (DMUS_PLAYMODE_CHORD_ROOT | DMUS_PLAYMODE_CHORD_INTERVALS)
/* If it is desirable to play a note that is above the top of the chord, the
   always play mode (known as "purpleized" in a former life) finds a position
   for the note by using intervals from the scale. Essentially, this mode is
   a combination of the Normal and Melodic playback modes, where a failure
   in Normal causes a second try in Melodic mode.
*/
#define DMUS_PLAYMODE_ALWAYSPLAY        (DMUS_PLAYMODE_MELODIC | DMUS_PLAYMODE_NORMALCHORD)

/* In PedalpointChord, the key root is used and the notes only track the intervals in
   the chord. The chord root and scale intervals are completely ignored. This is useful
   for chordal lines that play relative to the key root.
*/
#define DMUS_PLAYMODE_PEDALPOINTCHORD   (DMUS_PLAYMODE_KEY_ROOT | DMUS_PLAYMODE_CHORD_INTERVALS)

/* For completeness, here's a mode that tries for pedalpointchord, but if it fails
   uses scale intervals
*/
#define DMUS_PLAYMODE_PEDALPOINTALWAYS  (DMUS_PLAYMODE_PEDALPOINT | DMUS_PLAYMODE_PEDALPOINTCHORD)


/*  Legacy names for modes... */
#define DMUS_PLAYMODE_PURPLEIZED        DMUS_PLAYMODE_ALWAYSPLAY
#define DMUS_PLAYMODE_SCALE_ROOT        DMUS_PLAYMODE_KEY_ROOT
#define DMUS_PLAYMODE_FIXEDTOSCALE      DMUS_PLAYMODE_FIXEDTOKEY

/* DMUS_MIDI_PMSG */
typedef struct _DMUS_MIDI_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    BYTE    bStatus;
    BYTE    bByte1;
    BYTE    bByte2;
    BYTE    bPad[1];
} DMUS_MIDI_PMSG;

/* DMUS_PATCH_PMSG */
typedef struct _DMUS_PATCH_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    BYTE    byInstrument;
    BYTE    byMSB;
    BYTE    byLSB;
    BYTE    byPad[1];
} DMUS_PATCH_PMSG;

/* DMUS_TRANSPOSE_PMSG */
typedef struct _DMUS_TRANSPOSE_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    short   nTranspose;
    WORD            wMergeIndex;     /* Allows multiple parameters to be merged (pitchbend, volume, and expression.)*/
} DMUS_TRANSPOSE_PMSG;

/* DMUS_CHANNEL_PRIORITY_PMSG */
typedef struct _DMUS_CHANNEL_PRIORITY_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    DWORD   dwChannelPriority;
} DMUS_CHANNEL_PRIORITY_PMSG;

/* DMUS_TEMPO_PMSG */
typedef struct _DMUS_TEMPO_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    double  dblTempo;                       /* the tempo */
} DMUS_TEMPO_PMSG;

#define DMUS_TEMPO_MAX          1000
#define DMUS_TEMPO_MIN          1

#define DMUS_MASTERTEMPO_MAX    100.0f
#define DMUS_MASTERTEMPO_MIN    0.01f

/* DMUS_SYSEX_PMSG */
typedef struct _DMUS_SYSEX_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    DWORD   dwLen;          /* length of the data */
    BYTE    abData[1];      /* array of data, length equal to dwLen */
} DMUS_SYSEX_PMSG;

/* DMUS_CURVE_PMSG */
typedef struct _DMUS_CURVE_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    MUSIC_TIME      mtDuration;      /* how long this curve lasts */
    MUSIC_TIME      mtOriginalStart; /* must be set to either zero when this PMSG is created or to the original mtTime of the curve */
    MUSIC_TIME      mtResetDuration; /* how long after the curve is finished to allow a flush or
                                        invalidation to reset to the reset value, nResetValue */
    short           nStartValue;     /* curve's start value */
    short           nEndValue;       /* curve's end value */
    short           nResetValue;     /* curve's reset value, set when a flush or invalidation
                                        occurs within mtDuration + mtResetDuration */
    WORD            wMeasure;        /* Measure in which this curve occurs */
    short           nOffset;         /* Offset from grid at which this curve occurs */
    BYTE            bBeat;           /* Beat (in measure) at which this curve occurs */
    BYTE            bGrid;           /* Grid offset from beat at which this curve occurs */
    BYTE            bType;           /* type of curve */
    BYTE            bCurveShape;     /* shape of curve */
    BYTE            bCCData;         /* CC# if this is a control change type */
    BYTE            bFlags;          /* Curve reset and start from current value flags. */
    WORD            wParamType;      /* RPN or NRPN parameter number. */
    WORD            wMergeIndex;     /* Allows multiple parameters to be merged (pitchbend, volume, and expression.)*/
} DMUS_CURVE_PMSG;

typedef enum enumDMUS_CURVE_FLAGS
{
    DMUS_CURVE_RESET = 1,            /* When set, the nResetValue must be sent when the 
                                        time is reached or an invalidate occurs because
                                        of a transition. If not set, the curve stays
                                        permanently stuck at the new value. */
    DMUS_CURVE_START_FROM_CURRENT = 2/* Ignore Start, start the curve at the current value. 
                                        This only works for volume, expression, and pitchbend. */
} DMUS_CURVE_FLAGS;

     

/* Curve shapes */
enum
{ 
    DMUS_CURVES_LINEAR  = 0,
    DMUS_CURVES_INSTANT = 1,
    DMUS_CURVES_EXP     = 2,
    DMUS_CURVES_LOG     = 3,
    DMUS_CURVES_SINE    = 4
};
/* curve types */
#define DMUS_CURVET_PBCURVE      0x03   /* Pitch bend curve. */
#define DMUS_CURVET_CCCURVE      0x04   /* Control change curve. */
#define DMUS_CURVET_MATCURVE     0x05   /* Mono aftertouch curve. */
#define DMUS_CURVET_PATCURVE     0x06   /* Poly aftertouch curve. */
#define DMUS_CURVET_RPNCURVE     0x07   /* RPN curve with curve type in wParamType. */
#define DMUS_CURVET_NRPNCURVE    0x08   /* NRPN curve with curve type in wParamType. */

/* DMUS_TIMESIG_PMSG */
typedef struct _DMUS_TIMESIG_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    /* Time signatures define how many beats per measure, which note receives */
    /* the beat, and the grid resolution. */
    BYTE    bBeatsPerMeasure;       /* beats per measure (top of time sig) */
    BYTE    bBeat;                  /* what note receives the beat (bottom of time sig.) */
                                    /* we can assume that 0 means 256th note */
    WORD    wGridsPerBeat;          /* grids per beat */
} DMUS_TIMESIG_PMSG;



/* notification type values */
/* The following correspond to GUID_NOTIFICATION_SEGMENT */
#define DMUS_NOTIFICATION_SEGSTART       0
#define DMUS_NOTIFICATION_SEGEND         1
#define DMUS_NOTIFICATION_SEGALMOSTEND   2
#define DMUS_NOTIFICATION_SEGLOOP        3
#define DMUS_NOTIFICATION_SEGABORT       4
/* The following correspond to GUID_NOTIFICATION_PERFORMANCE */
#define DMUS_NOTIFICATION_MUSICSTARTED   0
#define DMUS_NOTIFICATION_MUSICSTOPPED   1
#define DMUS_NOTIFICATION_MUSICALMOSTEND 2
/* The following corresponds to GUID_NOTIFICATION_MEASUREANDBEAT */
#define DMUS_NOTIFICATION_MEASUREBEAT    0
/* The following corresponds to GUID_NOTIFICATION_CHORD */
#define DMUS_NOTIFICATION_CHORD          0
/* The following correspond to GUID_NOTIFICATION_COMMAND */
#define DMUS_NOTIFICATION_GROOVE         0
#define DMUS_NOTIFICATION_EMBELLISHMENT  1
/* The following corresponds to GUID_NOTIFICATION_RECOMPOSE */
#define DMUS_NOTIFICATION_RECOMPOSE          0

/* DMUS_NOTIFICATION_PMSG */
typedef struct _DMUS_NOTIFICATION_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    GUID    guidNotificationType;
    DWORD   dwNotificationOption;
    DWORD   dwField1;
    DWORD   dwField2;
} DMUS_NOTIFICATION_PMSG;

/* DMUS_WAVE_PMSG */
typedef struct _DMUS_WAVE_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */
    
    REFERENCE_TIME rtDuration;      /* Duration of the wave, in either reference time or music time. */  
    long    lOffset;                /* Offset from actual time to logical time, in music or ref time. */
    long    lVolume;		        /* Initial volume, in 100ths of a dB. */
    long    lPitch;			        /* Initial pitch, in 100ths of a semitone. */
    DWORD   dwStartOffset;          /* How far into the wave to start, in sample time units. (XBOX only) */
    DWORD   dwLoopStart;            /* Starting loop point. (XBOX only) */
    DWORD   dwLoopEnd;              /* Ending loop point. (XBOX only) */
    BYTE    bFlags;                 /* Flags, including DMUS_WAVEF_OFF... */
} DMUS_WAVE_PMSG;


#define DMUS_READAHEAD_MIN          50         /* Readahead min in milliseconds */

#define DMUS_WAVEF_OFF              0x01       /* If wave is playing and this is the off message. */
#define DMUS_WAVEF_STREAMING        0x02       /* If wave is streaming. */
#define DMUS_WAVEF_NOINVALIDATE     0x04       /* Don't invalidate this wave. */
#define DMUS_WAVEF_NOPREROLL        0x08       /* Don't preroll any wave data. */  
#define DMUS_WAVEF_IGNORELOOPS      0x20       /* Ignore segment looping. */

/* DMUS_LYRIC_PMSG */
typedef struct _DMUS_LYRIC_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */
    
    WCHAR    wszString[1];      /* null-terminated Unicode lyric string (structure is actually larger than size 1) */
} DMUS_LYRIC_PMSG;

#define DMUS_MAX_NAME           64         /* Maximum object name length. */
#define DMUS_MAX_CATEGORY       64         /* Maximum object category name length. */
#define DMUS_MAX_FILENAME       MAX_PATH

typedef struct _DMUS_VERSION {
  DWORD    dwVersionMS;
  DWORD    dwVersionLS;
}DMUS_VERSION, FAR *LPDMUS_VERSION;

/* Time Signature structure, used by IDirectMusicStyle */
/* Also used as a parameter for GetParam() and SetParam */
typedef struct _DMUS_TIMESIGNATURE
{
    MUSIC_TIME mtTime;
    BYTE    bBeatsPerMeasure;       /* beats per measure (top of time sig) */
    BYTE    bBeat;                  /* what note receives the beat (bottom of time sig.) */
                                    /* we can assume that 0 means 256th note */
    WORD    wGridsPerBeat;          /* grids per beat */
} DMUS_TIMESIGNATURE;

typedef struct _DMUS_RHYTHM_PARAM
{
    DMUS_TIMESIGNATURE  TimeSig;
    DWORD               dwRhythmPattern;
} DMUS_RHYTHM_PARAM;

typedef struct _DMUS_TEMPO_PARAM
{
    MUSIC_TIME  mtTime;
    double      dblTempo;
} DMUS_TEMPO_PARAM;


typedef struct _DMUS_MUTE_PARAM
{
    DWORD   dwPChannel;
    DWORD   dwPChannelMap;
    BOOL    fMute;
} DMUS_MUTE_PARAM;

typedef struct _DMUS_VALID_START_PARAM
{
    MUSIC_TIME mtTime;                      /* Time of the first legal start 
                                               point after (or including) the requested time. 
                                               This is a returned value.
                                               Time format is the relative offset from requested time. */
} DMUS_VALID_START_PARAM;

typedef struct _DMUS_PLAY_MARKER_PARAM
{
    MUSIC_TIME mtTime;                      /* Time of the first legal segment play 
                                               marker before (or including) the requested time. 
                                               This is a returned value.
                                               Time format is the relative offset from requested time. */
} DMUS_PLAY_MARKER_PARAM;

/*      The DMUSOBJECTDESC structure is used to communicate everything you could */
/*      possibly use to describe a DirectMusic object.  */

typedef struct _DMUS_OBJECTDESC
{
    DWORD          dwSize;                 /* Size of this structure. */
    DWORD          dwValidData;            /* Flags indicating which fields below are valid. */
    GUID           guidObject;             /* Unique ID for this object. */
    GUID           guidClass;              /* GUID for the class of object. */
    FILETIME       ftDate;                 /* Last edited date of object. */
    DMUS_VERSION   vVersion;               /* Version. */
    WCHAR          wszName[DMUS_MAX_NAME]; /* Name of object. */
    WCHAR          wszCategory[DMUS_MAX_CATEGORY]; /* Category for object (optional). */
    WCHAR          wszFileName[DMUS_MAX_FILENAME]; /* File path. */
    LONGLONG       llMemLength;            /* Size of Memory data. */
    LPBYTE         pbMemData;              /* Memory pointer for data. */
    IStream *      pStream;                /* Stream with data. */
} DMUS_OBJECTDESC;

typedef DMUS_OBJECTDESC *LPDMUS_OBJECTDESC;

/*      Flags for dwValidData. When set, a flag indicates that the  */
/*      corresponding field in DMUSOBJECTDESC holds valid data. */

#define DMUS_OBJ_OBJECT         (1 << 0)     /* Object GUID is valid. */
#define DMUS_OBJ_CLASS          (1 << 1)     /* Class GUID is valid. */
#define DMUS_OBJ_NAME           (1 << 2)     /* Name is valid. */
#define DMUS_OBJ_CATEGORY       (1 << 3)     /* Category is valid. */
#define DMUS_OBJ_FILENAME       (1 << 4)     /* File path is valid. */
#define DMUS_OBJ_FULLPATH       (1 << 5)     /* Path is full path. */
#define DMUS_OBJ_URL            (1 << 6)     /* Path is URL. */
#define DMUS_OBJ_VERSION        (1 << 7)     /* Version is valid. */
#define DMUS_OBJ_DATE           (1 << 8)     /* Date is valid. */
#define DMUS_OBJ_LOADED         (1 << 9)     /* Object is currently loaded in memory. */
#define DMUS_OBJ_MEMORY         (1 << 10)    /* Object is pointed to by pbMemData. */
#define DMUS_OBJ_STREAM         (1 << 11)    /* Object is stored in pStream. */

/*      The DMUS_SCRIPT_ERRORINFO structure describes an error that occurred in a script.
        It is returned by methods in IDirectMusicScript. */
typedef struct _DMUS_SCRIPT_ERRORINFO
{
    DWORD dwSize; /* Size of this structure. */
    HRESULT hr;
    ULONG ulLineNumber;
    LONG ichCharPosition;
    CHAR wszSourceFile[DMUS_MAX_FILENAME];
    CHAR wszSourceComponent[DMUS_MAX_FILENAME];
    CHAR wszDescription[DMUS_MAX_FILENAME];
    CHAR wszSourceLineText[DMUS_MAX_FILENAME];
} DMUS_SCRIPT_ERRORINFO;


typedef struct _DMUS_COMMAND_PARAM_2
{
	MUSIC_TIME mtTime;
    BYTE bCommand;
    BYTE bGrooveLevel;
    BYTE bGrooveRange;
    BYTE bRepeatMode;
} DMUS_COMMAND_PARAM_2;


/*////////////////////////////////////////////////////////////////////
// IDirectMusicObject */
#undef  INTERFACE
#define INTERFACE  IDirectMusicObject
DECLARE_INTERFACE_(IDirectMusicObject, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicObject */
    STDMETHOD(GetDescriptor)        (THIS_ LPDMUS_OBJECTDESC pDesc) PURE;
    STDMETHOD(SetDescriptor)        (THIS_ LPDMUS_OBJECTDESC pDesc) PURE;
    STDMETHOD(ParseDescriptor)      (THIS_ LPSTREAM pStream, 
                                           LPDMUS_OBJECTDESC pDesc) PURE;
};

typedef IDirectMusicObject IDirectMusicObject8;

/*////////////////////////////////////////////////////////////////////
// IDirectMusicLoader */
#undef  INTERFACE
#define INTERFACE  IDirectMusicLoader
DECLARE_INTERFACE_(IDirectMusicLoader, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicLoader */
    /* IDirectMusicLoader */
    STDMETHOD(GetObject)            (THIS_ LPDMUS_OBJECTDESC pDesc,
                                           REFIID riid,
                                           LPVOID FAR *ppv) PURE;
    STDMETHOD(SetObject)            (THIS_ LPDMUS_OBJECTDESC pDesc) PURE;
    STDMETHOD(SetSearchDirectory)   (THIS_ REFGUID rguidClass, 
                                           const char *pzPath, 
                                           BOOL fClear) PURE;
    STDMETHOD(ClearCache)           (THIS_ REFGUID rguidClass) PURE;
    STDMETHOD_(void, CollectGarbage)                (THIS) PURE;
    STDMETHOD(ReleaseObjectByUnknown)               (THIS_ IUnknown *pObject) PURE;
    STDMETHOD(LoadObjectFromFile)                   (THIS_ REFGUID rguidClassID, 
                                                           REFIID iidInterfaceID, 
                                                           const char *pzFilePath, 
                                                           void ** ppObject) PURE;
};                                  

typedef IDirectMusicLoader IDirectMusicLoader8;

/*  Stream objects must support IDirectMusicGetLoader interface to access loader while file parsing. 
	If you write your own loader, you will need to add this interface to the stream object.
*/

#undef  INTERFACE
#define INTERFACE  IDirectMusicGetLoader
DECLARE_INTERFACE_(IDirectMusicGetLoader, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicGetLoader */
    STDMETHOD(GetLoader)            (THIS_ IDirectMusicLoader ** ppLoader) PURE;
};

typedef IDirectMusicGetLoader IDirectMusicGetLoader8;

/*////////////////////////////////////////////////////////////////////
// IDirectMusicSegment */
#undef  INTERFACE
#define INTERFACE  IDirectMusicSegment
DECLARE_INTERFACE_(IDirectMusicSegment, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicSegment */
    STDMETHOD(SetRepeats)               (THIS_ DWORD  dwRepeats) PURE;
    STDMETHOD(Compose)                  (THIS_ MUSIC_TIME mtTime,
                                               IDirectMusicSegment* pFromSegment,
                                               IDirectMusicSegment* pToSegment,
                                               IDirectMusicSegment** ppComposedSegment) PURE;
    STDMETHOD(Download)                 (THIS_ IUnknown *pAudioPath) PURE;
    STDMETHOD(Unload)                   (THIS_ IUnknown *pAudioPath) PURE;
    STDMETHOD(GetLength)                (THIS_ MUSIC_TIME* pmtLength) PURE;
    STDMETHOD(SetLength)                (THIS_ MUSIC_TIME mtLength) PURE;
    STDMETHOD(SetClockTimeLength)		(THIS_ REFERENCE_TIME rtLength, BOOL fClockTime) PURE;
    STDMETHOD(GetClockTimeLength)		(THIS_ REFERENCE_TIME *prtLength, BOOL *pfClockTime) PURE;
    STDMETHOD(SetLoopPoints)            (THIS_ MUSIC_TIME mtStart, 
                                               MUSIC_TIME mtEnd) PURE;
    STDMETHOD(GetLoopPoints)            (THIS_ MUSIC_TIME* pmtStart, 
                                               MUSIC_TIME* pmtEnd) PURE;
    STDMETHOD(SetStartPoint)            (THIS_ MUSIC_TIME mtStart) PURE;
    STDMETHOD(GetStartPoint)            (THIS_ MUSIC_TIME* pmtStart) PURE;
    STDMETHOD(SetWavePlaybackParams)    (THIS_ DWORD dwFlags, DWORD dwReadAhead) PURE;
    STDMETHOD(AddNotificationType)      (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(RemoveNotificationType)   (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(GetRepeats)               (THIS_ DWORD* pdwRepeats) PURE;

};

typedef IDirectMusicSegment IDirectMusicSegment8;


/*/////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState */
#undef  INTERFACE
#define INTERFACE  IDirectMusicSegmentState
DECLARE_INTERFACE_(IDirectMusicSegmentState, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicSegmentState */
    STDMETHOD(GetObjectInPath)      (THIS_ DWORD dwPChannel,    /* PChannel to search. */
                                           DWORD dwStage,       /* Which stage in the path. */
                                           DWORD dwBuffer,      /* Which buffer to address, if more than one. */
                                           REFGUID guidObject,  /* ClassID of object. */
                                           DWORD dwIndex,       /* Which object of that class. */
                                           REFGUID iidInterface,/* Requested COM interface. */
                                           void ** ppObject) PURE; /* Pointer to interface. */
    STDMETHOD(SetVolume)            (THIS_ long lVolume,        /* Gain, in 100ths of a dB. This must be negative (0 represents full volume.) */
                                           DWORD dwDuration) PURE;/* Duration of volume ramp in  milliseconds. Note that 0 is more efficient. */
    STDMETHOD(SetPitch)             (THIS_ long lPitch,         /* Pitch bend, in 100ths of a semitone. */
                                           DWORD dwDuration) PURE;/* Duration of pitch ramp in  milliseconds. Note that 0 is more efficient. */
    STDMETHOD(GetSegment )          (THIS_ IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(GetStartTime)         (THIS_ MUSIC_TIME* pmtStart) PURE;
};

typedef IDirectMusicSegmentState IDirectMusicSegmentState8;

/*////////////////////////////////////////////////////////////////////
// IDirectMusicAudioPath */
#undef  INTERFACE
#define INTERFACE  IDirectMusicAudioPath
DECLARE_INTERFACE_(IDirectMusicAudioPath, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicAudioPath */
    STDMETHOD(GetObjectInPath)      (THIS_ DWORD dwPChannel,    /* PChannel to search. */
                                           DWORD dwStage,       /* Which stage in the path. */
                                           DWORD dwBuffer,      /* Which buffer to address, if more than one. */
                                           REFGUID guidObject,  /* ClassID of object. */
                                           DWORD dwIndex,       /* Which object of that class. */
                                           REFGUID iidInterface,/* Requested COM interface. */
                                           void ** ppObject) PURE; /* Pointer to interface. */
    STDMETHOD(Activate)             (THIS_ BOOL fActivate) PURE;/* True to activate, False to deactivate. */
    STDMETHOD(SetVolume)            (THIS_ long lVolume,        /* Gain, in 100ths of a dB. This must be negative (0 represents full volume.) */
                                           DWORD dwDuration) PURE;/* Duration of volume ramp in  milliseconds. Note that 0 is more efficient. */
    STDMETHOD(SetPitch)             (THIS_ long lPitch,         /* Pitch bend, in 100ths of a semitone. */
                                           DWORD dwDuration) PURE;/* Duration of pitch ramp in  milliseconds. Note that 0 is more efficient. */
};

typedef IDirectMusicAudioPath IDirectMusicAudioPath8;


/*////////////////////////////////////////////////////////////////////
// IDirectMusicPerformance */

#undef  INTERFACE
#define INTERFACE  IDirectMusicPerformance
DECLARE_INTERFACE_(IDirectMusicPerformance, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicPerformance */
    STDMETHOD(GetSegmentState)      (THIS_ IDirectMusicSegmentState** ppSegmentState, 
                                           MUSIC_TIME mtTime) PURE;
    STDMETHOD(SendPMsg)             (THIS_ DMUS_PMSG* pPMSG) PURE;
    STDMETHOD(MusicToReferenceTime) (THIS_ MUSIC_TIME mtTime, 
                                           REFERENCE_TIME* prtTime) PURE;
    STDMETHOD(ReferenceToMusicTime) (THIS_ REFERENCE_TIME rtTime, 
                                           MUSIC_TIME* pmtTime) PURE;
    STDMETHOD(IsPlaying)            (THIS_ IDirectMusicSegment* pSegment, 
                                           IDirectMusicSegmentState* pSegState) PURE;
    STDMETHOD(GetTime)              (THIS_ REFERENCE_TIME* prtNow, 
                                           MUSIC_TIME* pmtNow) PURE;
    STDMETHOD(AllocPMsg)            (THIS_ ULONG cb, 
                                           DMUS_PMSG** ppPMSG) PURE;
    STDMETHOD(FreePMsg)             (THIS_ DMUS_PMSG* pPMSG) PURE;
    STDMETHOD(GetNotificationPMsg)  (THIS_ DMUS_NOTIFICATION_PMSG** ppNotificationPMsg) PURE;
    STDMETHOD(AddNotificationType)  (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(RemoveNotificationType)(THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(GetGlobalParam)       (THIS_ REFGUID rguidType, 
                                           void* pParam, 
                                           DWORD dwSize) PURE;
    STDMETHOD(SetGlobalParam)       (THIS_ REFGUID rguidType, 
                                           void* pParam, 
                                           DWORD dwSize) PURE;
    STDMETHOD(PlaySegmentEx)        (THIS_ IUnknown* pSource,                       /* Segment to play. Alternately, could be an IDirectMusicSong  */
                                           const char *pzSegmentName,                     /* If song, which segment in the song  */
                                           IUnknown* pTransition,                   /* Optional template segment to compose transition with. */
                                           DWORD dwFlags,                           /* DMUS_SEGF_ flags. */ 
                                           __int64 i64StartTime,                    /* Time to start playback. */
                                           IDirectMusicSegmentState** ppSegmentState, /* Returned Segment State. */
                                           IUnknown *pFrom,                         /* Optional segmentstate or audiopath to replace. */
                                           IUnknown *pAudioPath) PURE;              /* Optional audioPath to play on. */
    STDMETHOD(StopEx)               (THIS_ IUnknown *pObjectToStop,                 /* Segstate, AudioPath, Segment, or Song. */ 
                                           __int64 i64StopTime, 
                                           DWORD dwFlags) PURE;
    STDMETHOD(ClonePMsg)            (THIS_ DMUS_PMSG* pSourcePMSG,
                                           DMUS_PMSG** ppCopyPMSG) PURE;
    STDMETHOD(CreateAudioPath)      (THIS_ IUnknown *pSourceConfig,                 /* Source configuration, from AudioPathConfig file. */
                                           BOOL fActivate,                          /* TRUE to activate on creation. */
                                           IDirectMusicAudioPath **ppNewPath) PURE; /* Returns created audiopath. */                                           
    STDMETHOD(CreateStandardAudioPath)(THIS_ DWORD dwType,                          /* Type of path to create. */
                                           DWORD dwPChannelCount,                   /* How many PChannels to allocate for it. */
                                           BOOL fActivate,                          /* TRUE to activate on creation. */
                                           IDirectMusicAudioPath **ppNewPath) PURE; /* Returns created audiopath. */
    STDMETHOD(SetDefaultAudioPath)  (THIS_ IDirectMusicAudioPath *pAudioPath) PURE;
    STDMETHOD(GetDefaultAudioPath)  (THIS_ IDirectMusicAudioPath **ppAudioPath) PURE;
    STDMETHOD(GetParamEx)           (THIS_ REFGUID rguidType,                       /* GetParam command ID. */
                                           DWORD dwTrackID,                         /* Virtual track ID of caller. */
                                           DWORD dwGroupBits,                       /* Group bits of caller. */
                                           DWORD dwIndex,                           /* Index to Nth parameter. */
                                           MUSIC_TIME mtTime,                       /* Time of requested parameter. */
                                           MUSIC_TIME* pmtNext,                     /* Returned delta to next parameter. */
                                           void* pParam) PURE;                      /* Data structure to fill with parameter. */
    STDMETHOD(InitAudioX)           (THIS_ DWORD dwDefaultPathType,                 /* Requested default audio path type, also optional. */
                                           DWORD dwPChannelCount,                   /* Number of PChannels, if default audio path to be created. */
                                           DWORD dwVoiceCount,                      /* Number of Voices (DSoundBuffers) allocated by synth. */
						                   DWORD dwFlags) PURE;                 
    STDMETHOD(CloseDown)            (THIS) PURE;
    STDMETHOD(Invalidate)           (THIS_ MUSIC_TIME mtTime, 
                                           DWORD dwFlags) PURE;
};

typedef IDirectMusicPerformance IDirectMusicPerformance8;


/*////////////////////////////////////////////////////////////////////
// IDirectMusicGraph */
#undef  INTERFACE
#define INTERFACE  IDirectMusicGraph
DECLARE_INTERFACE_(IDirectMusicGraph, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicGraph */
    STDMETHOD(StampPMsg)            (THIS_ DMUS_PMSG* pPMSG) PURE;
    STDMETHOD(InsertTool)           (THIS_ IDirectMusicTool* pTool, 
                                           DWORD* pdwPChannels, 
                                           DWORD cPChannels, 
                                           LONG lIndex) PURE;
    STDMETHOD(GetTool)              (THIS_ DWORD dwIndex, 
                                           IDirectMusicTool** ppTool) PURE;
    STDMETHOD(RemoveTool)           (THIS_ IDirectMusicTool* pTool) PURE;
};

typedef IDirectMusicGraph IDirectMusicGraph8;

/*////////////////////////////////////////////////////////////////////
// IDirectMusicTool */
#undef  INTERFACE
#define INTERFACE  IDirectMusicTool
DECLARE_INTERFACE_(IDirectMusicTool, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicTool */
    STDMETHOD(Init)                 (THIS_ IDirectMusicGraph* pGraph) PURE;
    STDMETHOD(GetMsgDeliveryType)   (THIS_ DWORD* pdwDeliveryType ) PURE;
    STDMETHOD(GetMediaTypeArraySize)(THIS_ DWORD* pdwNumElements ) PURE;
    STDMETHOD(GetMediaTypes)        (THIS_ DWORD** padwMediaTypes, 
                                           DWORD dwNumElements) PURE;
    STDMETHOD(ProcessPMsg)          (THIS_ IDirectMusicPerformance* pPerf, 
                                           DMUS_PMSG* pPMSG) PURE;
    STDMETHOD(Flush)                (THIS_ IDirectMusicPerformance* pPerf, 
                                           DMUS_PMSG* pPMSG, 
                                           REFERENCE_TIME rtTime) PURE;
};


/*/////////////////////////////////////////////////////////////////////
// IDirectMusicScript */

#undef  INTERFACE
#define INTERFACE  IDirectMusicScript
DECLARE_INTERFACE_(IDirectMusicScript, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicScript */
    STDMETHOD(Init)                     (THIS_ IDirectMusicPerformance *pPerformance,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(CallRoutine)              (THIS_ const char *pszRoutineName,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(SetVariableNumber)        (THIS_ const char *pszVariableName,
                                               LONG lValue,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(GetVariableNumber)        (THIS_ const char *pszVariableName,
                                               LONG *plValue,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(SetVariableObject)        (THIS_ const char *pszVariableName,
                                               IUnknown *punkValue,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(GetVariableObject)        (THIS_ const char *pszVariableName,
                                               REFIID riid,
                                               LPVOID FAR *ppv,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(SetVariableString)        (THIS_ const char *pszVariableName,
                                               const char * pszValue,
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
    STDMETHOD(GetVariableString)        (THIS_ const char *pszVariableName,
                                               char *pszValue,
                                               LONG lLength,
                                               LONG *plConverted, 
                                               DMUS_SCRIPT_ERRORINFO *pErrorInfo) PURE;
};

typedef IDirectMusicScript IDirectMusicScript8;


/* CLSID's */
DEFINE_GUID(CLSID_DirectMusicPerformance,0xd2ac2881, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSegment,0xd2ac2882, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicLoader,0xd2ac2892, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicCollection,0x480ff4b0, 0x28b2, 0x11d1, 0xbe, 0xf7, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);
DEFINE_GUID(CLSID_DirectMusicSegmentState,0xd2ac2883, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicGraph,0xd2ac2884, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicStyle,0xd2ac288a, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicChordMap,0xd2ac288f, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicComposer,0xd2ac2890, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicScript,0x810b5013, 0xe88d, 0x11d2, 0x8b, 0xc1, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {810B5013-E88D-11d2-8BC1-00600893B1B6} */
DEFINE_GUID(CLSID_DirectMusicContainer,0x9301e380, 0x1f22, 0x11d3, 0x82, 0x26, 0xd2, 0xfa, 0x76, 0x25, 0x5d, 0x47);
DEFINE_GUID(CLSID_DirectMusicAudioPathConfig,0xee0b9ca0, 0xa81e, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);
DEFINE_GUID(CLSID_DirectMusicPatternTrack,0xd2ac2897, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectSoundWave,0x8a667154, 0xf9cb, 0x11d2, 0xad, 0x8a, 0x0, 0x60, 0xb0, 0x57, 0x5a, 0xbc);
DEFINE_GUID(CLSID_DirectMusicSong, 0xaed5f0a5, 0xd972, 0x483d, 0xa3, 0x84, 0x64, 0x9d, 0xfe, 0xb9, 0xc1, 0x81);
DEFINE_GUID(CLSID_DirectMusicStreamStream, 0xf34feac1, 0xe3af, 0x49ad, 0x83, 0x97, 0xb, 0xed, 0x32, 0x3e, 0xf9, 0x6b);
DEFINE_GUID(CLSID_DirectMusicMemStream, 0x75ccb447, 0x8d3f, 0x4154, 0xab, 0xad, 0x59, 0x60, 0xae, 0xd4, 0xba, 0x63);
DEFINE_GUID(CLSID_DirectMusicFileStream, 0xf12f2c7d, 0x3651, 0x486f, 0xb9, 0xfa, 0x16, 0xe1, 0x1d, 0x15, 0x24, 0xfd);

/* Special GUID for all object types. This is used by the loader. */
DEFINE_GUID(GUID_DirectMusicAllTypes,0xd2ac2893, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Notification guids */
DEFINE_GUID(GUID_NOTIFICATION_SEGMENT,0xd2ac2899, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_NOTIFICATION_PERFORMANCE,0x81f75bc5, 0x4e5d, 0x11d2, 0xbc, 0xc7, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(GUID_NOTIFICATION_MEASUREANDBEAT,0xd2ac289a, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_NOTIFICATION_CHORD,0xd2ac289b, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_NOTIFICATION_COMMAND,0xd2ac289c, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_NOTIFICATION_RECOMPOSE, 0xd348372b, 0x945b, 0x45ae, 0xa5, 0x22, 0x45, 0xf, 0x12, 0x5b, 0x84, 0xa5);

/* Track param type guids */

/* Use to get a DMUS_COMMAND_PARAM_2 param in the Command track */
DEFINE_GUID(GUID_CommandParam2, 0x28f97ef7, 0x9538, 0x11d2, 0x97, 0xa9, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);

/* Use to get/set a DMUS_COMMAND_PARAM_2 param to be used as the command following all commands in
the Command track (this information can't be saved) */
DEFINE_GUID(GUID_CommandParamNext, 0x472afe7a, 0x281b, 0x11d3, 0x81, 0x7d, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);

/* Use to get/set a DMUS_CHORD_PARAM param in the Chord track */
DEFINE_GUID(GUID_ChordParam,0xd2ac289e, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get a DMUS_RHYTHM_PARAM param in the Chord track */
DEFINE_GUID(GUID_RhythmParam,0xd2ac289f, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get/set an IDirectMusicStyle param in the Style track */
DEFINE_GUID(GUID_IDirectMusicStyle,0xd2ac28a1, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get a DMUS_TIMESIGNATURE param in the Style and TimeSig tracks */
DEFINE_GUID(GUID_TimeSignature,0xd2ac28a4, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get/set a DMUS_TEMPO_PARAM param in the Tempo track */
DEFINE_GUID(GUID_TempoParam,0xd2ac28a5, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get the next valid point in a segment at which it may start */
DEFINE_GUID(GUID_Valid_Start_Time,0x7f6b1760, 0x1fdb, 0x11d3, 0x82, 0x26, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

/* Use to get the next point in the currently playing primary segment at which a new segment may start */
DEFINE_GUID(GUID_Play_Marker,0xd8761a41, 0x801a, 0x11d3, 0x9b, 0xd1, 0xda, 0xf7, 0xe1, 0xc3, 0xd8, 0x34);


/* Use to get/set a DMUS_MUTE_PARAM param in the Mute track */
DEFINE_GUID(GUID_MuteParam,0xd2ac28af, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);



/* Global data guids */
DEFINE_GUID(GUID_PerfMasterTempo,0xd2ac28b0, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_PerfMasterVolume,0xd2ac28b1, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_PerfMasterGrooveLevel,0xd2ac28b2, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* GUID for default GM/GS dls collection. */
DEFINE_GUID(GUID_DefaultGMCollection, 0xf17e8673, 0xc3b4, 0x11d1, 0x87, 0xb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);


/* IID's */
DEFINE_GUID(IID_IDirectMusicLoader,0x4fdad3f6, 0xe642, 0x4a1b, 0x90, 0x28, 0x1c, 0x2f, 0xfd, 0x91, 0x5c, 0x2a);
DEFINE_GUID(IID_IDirectMusicSegment, 0x3fc8898, 0xac24, 0x4bb8, 0xaf, 0x2f, 0x6f, 0xba, 0xb6, 0x40, 0x8a, 0x8e);
DEFINE_GUID(IID_IDirectMusicSegmentState, 0xfbdf2f1d, 0x6378, 0x43ba, 0x97, 0x29, 0x4b, 0x74, 0xb1, 0xdb, 0x3b, 0xd5);
DEFINE_GUID(IID_IDirectMusicPerformance,0x37a8aa56, 0x79fd, 0x4fcc, 0x8b, 0x58, 0xd3, 0x9d, 0x75, 0x86, 0x1f, 0x3);
DEFINE_GUID(IID_IDirectMusicGraph,0x5ae1e2a9, 0x38d7, 0x42a2, 0x9d, 0x31, 0xa1, 0x9c, 0x9a, 0x93, 0x6a, 0x4a);
DEFINE_GUID(IID_IDirectMusicGetLoader,0xb0e1656f, 0x3e45, 0x418e, 0x9b, 0x2d, 0x34, 0xd5, 0x33, 0xd1, 0x77, 0xe1);
DEFINE_GUID(IID_IDirectMusicObject,0x632aee51, 0xb9d, 0x4ea4, 0x9b, 0x60, 0x23, 0xcc, 0x58, 0xf5, 0x56, 0x1e);
DEFINE_GUID(IID_IDirectMusicTool,0xe59eeefe, 0x7a62, 0x4ca7, 0x8b, 0x47, 0x1f, 0xdd, 0x72, 0x8f, 0xba, 0x57);
DEFINE_GUID(IID_IDirectMusicScript, 0x801413c2, 0x392, 0x4265, 0xb3, 0x1a, 0x13, 0xd, 0x7, 0xdf, 0x31, 0xd0);
#define IID_IDirectMusicScript8 IID_IDirectMusicScript
DEFINE_GUID(IID_IDirectMusicAudioPath,0x242ed927, 0xf094, 0x42e4, 0x9b, 0xb9, 0x52, 0xd2, 0x14, 0x19, 0x94, 0x4a);
#define IID_IDirectMusicAudioPath8 IID_IDirectMusicAudioPath
/* unchanged interfaces (alias only) */
#define IID_IDirectMusicGraph8 IID_IDirectMusicGraph
#define IID_IDirectMusicLoader8 IID_IDirectMusicLoader
#define IID_IDirectMusicPerformance8 IID_IDirectMusicPerformance
#define IID_IDirectMusicSegment8 IID_IDirectMusicSegment
#define IID_IDirectMusicSegmentState8 IID_IDirectMusicSegmentState

// Special GUID meaning "select all objects" for use in GetObjectInPath()
DEFINE_GUID(GUID_All_Objects, 0xaa114de5, 0xc262, 0x4169, 0xa1, 0xc8, 0x23, 0xd6, 0x98, 0xcc, 0x73, 0xb5);

HRESULT WINAPI DirectMusicCreateInstance(REFCLSID clsid, LPUNKNOWN pUnkOuter, REFIID iid, LPVOID *ppvInterface);
void WINAPI DirectMusicDoWork(DWORD dwQuantum);

typedef HRESULT (CALLBACK* LPDIRECTMUSICFACTORYFN)(REFCLSID clsid, LPUNKNOWN pUnkOuter, REFIID iid, LPVOID *ppvInterface);
HRESULT CALLBACK DirectMusicDefaultFactory(REFCLSID clsid, LPUNKNOWN pUnkOuter, REFIID iid, LPVOID *ppvInterface);

#undef  INTERFACE
#define INTERFACE  IDirectMusicHeap
DECLARE_INTERFACE_(IDirectMusicHeap, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)               (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)                (THIS) PURE;
    STDMETHOD_(ULONG,Release)               (THIS) PURE;

    /*  IDirectMusicHeap */
    STDMETHOD(Allocate)   (THIS_ DWORD cbSize, PVOID* pData) PURE;
    STDMETHOD(GetSize) (THIS_ PVOID pData, LPDWORD pcbSize) PURE;
    STDMETHOD(Free)   (THIS_ PVOID pData) PURE;
};

void* WINAPI DirectMusicAlloc(size_t cb);
void  WINAPI DirectMusicFree(void *pv);
void* WINAPI DirectMusicPhysicalAlloc(size_t dwSize);
void WINAPI DirectMusicPhysicalFree(void* lpAddress);

HRESULT WINAPI DirectMusicCreateDefaultHeap(IDirectMusicHeap** ppHeap);
HRESULT WINAPI DirectMusicCreateDefaultPhysicalHeap(IDirectMusicHeap** ppHeap);

HRESULT WINAPI DirectMusicCreateFixedSizeHeap(DWORD cbSize, IDirectMusicHeap** ppHeap);
HRESULT WINAPI DirectMusicCreateFixedSizePhysicalHeap(DWORD cbSize, IDirectMusicHeap** ppHeap);

HRESULT WINAPI DirectMusicInitialize();
HRESULT WINAPI DirectMusicInitializeEx(IDirectMusicHeap* pNormalHeap, 
    IDirectMusicHeap* pPhysicalHeap,
    LPDIRECTMUSICFACTORYFN pFactory);
HRESULT WINAPI DirectMusicInitializeFixedSizeHeaps(DWORD cbNormalHeapSize, 
    DWORD cbPhysicalHeapSize,
    LPDIRECTMUSICFACTORYFN pFactory);

#ifdef __cplusplus
}; /* extern "C" */
#endif

#include <poppack.h>

long WINAPI DirectMusicMemCheck(DWORD dwMemType, char **ppName);
void WINAPI DirectMusicMemDump();
void WINAPI DirectMusicSetDebugLevel(int iDebugLevel, int iRIPLevel);

#endif /* #ifndef _DMUSICI_ */

/************************************************************************
*                                                                       *
*   dmerror.h -- Error code returned by DirectMusic API's               *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corporation
*                                                                       *
************************************************************************/

#ifndef _DMERROR_
#define _DMERROR_

#define FACILITY_DIRECTMUSIC      0x878       /* Shared with DirectSound */
#define DMUS_ERRBASE              0x1000      /* Make error codes human readable in hex */

#ifndef MAKE_HRESULT
#define MAKE_HRESULT(sev,fac,code) \
    ((HRESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )
#endif
    
#define MAKE_DMHRESULTSUCCESS(code)     MAKE_HRESULT(0, FACILITY_DIRECTMUSIC, (DMUS_ERRBASE + (code)))
#define MAKE_DMHRESULTERROR(code)       MAKE_HRESULT(1, FACILITY_DIRECTMUSIC, (DMUS_ERRBASE + (code)))

/* DMUS_S_REQUEUE
 *
 * Return value from IDirectMusicTool::ProcessPMsg() which indicates to the
 * performance that it should cue the PMsg again automatically.
 */
#define DMUS_S_REQUEUE                  MAKE_DMHRESULTSUCCESS(0x200)

/* DMUS_S_FREE
 *
 * Return value from IDirectMusicTool::ProcessPMsg() which indicates to the
 * performance that it should free the PMsg automatically.
 */
#define DMUS_S_FREE                     MAKE_DMHRESULTSUCCESS(0x201)

/* DMUS_S_END
 *
 * Return value from IDirectMusicTrack::Play() which indicates to the
 * segment that the track has no more data after mtEnd.
 */
#define DMUS_S_END                      MAKE_DMHRESULTSUCCESS(0x202)

/* DMUS_S_LAST_TOOL
 *
 * Returned from IDirectMusicGraph::StampPMsg(), this indicates that the PMsg
 * is already stamped with the last tool in the graph. The returned PMsg's
 * tool pointer is now NULL.
 */
#define DMUS_S_LAST_TOOL                MAKE_DMHRESULTSUCCESS(0x211)

/* DMUS_S_OVER_CHORD
 *
 * Returned from IDirectMusicPerformance::MusicToMIDI(), this indicates 
 * that no note has been calculated because the music value has the note 
 * at a position higher than the top note of the chord. This applies only
 * to DMUS_PLAYMODE_NORMALCHORD play mode. This success code indicates
 * that the caller should not do anything with the note. It is not meant
 * to be played against this chord.
 */
#define DMUS_S_OVER_CHORD               MAKE_DMHRESULTSUCCESS(0x212)

/* DMUS_S_UP_OCTAVE
 *
 * Returned from IDirectMusicPerformance::MIDIToMusic(),  and
 * IDirectMusicPerformance::MusicToMIDI(), this indicates 
 * that the note conversion generated a note value that is below 0, 
 * so it has been bumped up one or more octaves to be in the proper
 * MIDI range of 0 through 127. 
 * Note that this is valid for MIDIToMusic() when using play modes
 * DMUS_PLAYMODE_FIXEDTOCHORD and DMUS_PLAYMODE_FIXEDTOKEY, both of
 * which store MIDI values in wMusicValue. With MusicToMIDI(), it is
 * valid for all play modes.
 * Ofcourse, DMUS_PLAYMODE_FIXED will never return this success code.
 */
#define DMUS_S_UP_OCTAVE                MAKE_DMHRESULTSUCCESS(0x213)

/* DMUS_S_DOWN_OCTAVE
 *
 * Returned from IDirectMusicPerformance::MIDIToMusic(),  and
 * IDirectMusicPerformance::MusicToMIDI(), this indicates 
 * that the note conversion generated a note value that is above 127, 
 * so it has been bumped down one or more octaves to be in the proper
 * MIDI range of 0 through 127. 
 * Note that this is valid for MIDIToMusic() when using play modes
 * DMUS_PLAYMODE_FIXEDTOCHORD and DMUS_PLAYMODE_FIXEDTOKEY, both of
 * which store MIDI values in wMusicValue. With MusicToMIDI(), it is
 * valid for all play modes.
 * Ofcourse, DMUS_PLAYMODE_FIXED will never return this success code.
 */
#define DMUS_S_DOWN_OCTAVE              MAKE_DMHRESULTSUCCESS(0x214)


/* DMUS_S_GARBAGE_COLLECTED
 *
 * The requested operation was not performed because during CollectGarbage
 * the loader determined that the object had been released.
 */
#define DMUS_S_GARBAGE_COLLECTED        MAKE_DMHRESULTSUCCESS(0x216)


/* DMUS_E_SET_UNSUPPORTED
 *
 * The specified property item may not be set on the target object.
 */
#define DMUS_E_SET_UNSUPPORTED          MAKE_DMHRESULTERROR(0x0123)

/* DMUS_E_GET_UNSUPPORTED
 *
 * The specified property item may not be retrieved from the target object.
 */ 
#define DMUS_E_GET_UNSUPPORTED          MAKE_DMHRESULTERROR(0x0124)


/* DMUS_E_NOT_FOUND
 *
 * The requested item was not contained by the object.
 */
#define DMUS_E_NOT_FOUND                MAKE_DMHRESULTERROR(0x0161)

/* DMUS_E_NOT_INIT
 *
 * A required object is not initialized or failed to initialize.
 */
#define DMUS_E_NOT_INIT                 MAKE_DMHRESULTERROR(0x0162)


/* DMUS_E_TIME_PAST
 *
 * The time is in the past, and the operation can not succeed.
 */
#define DMUS_E_TIME_PAST                MAKE_DMHRESULTERROR(0x0165)

/* DMUS_E_LOADER_FAILEDCREATE
 *
 * Unable to find or create object.
 */
#define DMUS_E_LOADER_FAILEDCREATE      MAKE_DMHRESULTERROR(0x0184)

/* DMUS_E_LOADER_OBJECTNOTFOUND
 *
 * Object was not found.
 */
#define DMUS_E_LOADER_OBJECTNOTFOUND    MAKE_DMHRESULTERROR(0x0185)

/* DMUS_E_INVALIDFILE
 *
 * The file requested is not a valid file.
 */
#define DMUS_E_INVALIDFILE              MAKE_DMHRESULTERROR(0x0200) 

/* DMUS_E_CANNOT_CONVERT
 *
 * A call to MIDIToMusic() or MusicToMIDI() resulted in an error because
 * the requested conversion could not happen. This usually occurs when the
 * provided DMUS_CHORD_KEY structure has an invalid chord or scale pattern.
 */
#define DMUS_E_CANNOT_CONVERT           MAKE_DMHRESULTERROR(0x0207)

/* DMUS_E_SCRIPT_ERROR_IN_SCRIPT
 *
 * An error was encountered while parsing or executing the script.
 * The pErrorInfo parameter (if supplied) was filled with information about the error.
 */
#define DMUS_E_SCRIPT_ERROR_IN_SCRIPT        MAKE_DMHRESULTERROR(0x0215)

/* DMUS_E_SCRIPT_VARIABLE_NOT_FOUND
 *
 * The script does not contain a variable with the specified name.
 */
#define DMUS_E_SCRIPT_VARIABLE_NOT_FOUND     MAKE_DMHRESULTERROR(0x021A)

/* DMUS_E_SCRIPT_ROUTINE_NOT_FOUND
 *
 * The script does not contain a routine with the specified name.
 */
#define DMUS_E_SCRIPT_ROUTINE_NOT_FOUND      MAKE_DMHRESULTERROR(0x021B)

/* DMUS_E_SCRIPT_CONTENT_READONLY
 *
 * Scripts variables for content referenced or embedded in a script cannot be set.
 */
#define DMUS_E_SCRIPT_CONTENT_READONLY       MAKE_DMHRESULTERROR(0x021C)

/* DMUS_E_SCRIPT_NOT_A_REFERENCE
 *
 * Attempt was made to set a script's variable by reference to a value that was
 * not an object type.
 */
#define DMUS_E_SCRIPT_NOT_A_REFERENCE        MAKE_DMHRESULTERROR(0x021D)

/* DMUS_E_SCRIPT_VALUE_NOT_SUPPORTED
 *
 * Attempt was made to set a script's variable by value to an object that does
 * not support a default value property.
 */
#define DMUS_E_SCRIPT_VALUE_NOT_SUPPORTED    MAKE_DMHRESULTERROR(0x021E)


/* DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR
 *
 * A script written in AudioVBScript could not be read because it contained a statement that
 * is not allowed by the AudioVBScript language.
 */
#define DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR     MAKE_DMHRESULTERROR(0x0223)

/* DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR
 *
 * A script routine written in AudioVBScript failed because an invalid operation occurred.  For example,
 * adding the number 3 to a segment object would produce this error.  So would attempting to call a routine
 * that doesn't exist.
 */
#define DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR     MAKE_DMHRESULTERROR(0x0224)

/* DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE
 *
 * A script routine written in AudioVBScript failed because a function outside of a script failed to complete.
 * For example, a call to PlaySegment that fails to play because of low memory would return this error.
 */
#define DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE     MAKE_DMHRESULTERROR(0x0225)

/* DMUS_E_NO_AUDIOPATH_CONFIG
 *
 * A segment or song was asked for its embedded audio path configuration,
 * but there isn't any. 
 */
#define DMUS_E_NO_AUDIOPATH_CONFIG     MAKE_DMHRESULTERROR(0x0228)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dmusic\inc\makefile.inc ===
dmusici.h: dmusici.x
    sed "/@@BEGIN_MSINTERNAL/,/@@END_MSINTERNAL/D" $? > $@

$(PRIVATE_INC_PATH)\dmusicip.h: dmusici.x
    copy $? $@

{}.h{$(PRIVATE_INC_PATH)}.h:
    copy $** $@

{}.h{$(SDK_INC_PATH)}.h:
    copy $** $@

{}.h{$(XDK_INC_PATH)}.h:
    copy $** $@

clean:
	-del /F /Q $(NTTARGETFILE0)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dplay\inc\makefile.inc ===
dplay8.h: dplay8.x
    sed "/@@BEGIN_MSINTERNAL/,/@@END_MSINTERNAL/D" $? > $@

$(PRIVATE_INC_PATH)\dplay8p.h: dplay8.x
    copy $? $@

dpaddr.h: dpaddr.x
    sed "/@@BEGIN_MSINTERNAL/,/@@END_MSINTERNAL/D" $? > $@

$(PRIVATE_INC_PATH)\dpaddrp.h: dpaddr.x
    copy $? $@

$(PRIVATE_INC_PATH)\dpsp8p.h: dpsp8.x
    copy $? $@

{}.h{$(SDK_INC_PATH)}.h:
    copy $** $@

{}.h{$(XDK_INC_PATH)}.h:
    copy $** $@

clean:
	del /F /Q $(NTTARGETFILE0)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dplay\inc\dplay8.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1998-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPlay8.h
 *  Content:    DirectPlay8 include file
 *
 ***************************************************************************/

#ifndef __DIRECTPLAY8_H__
#define __DIRECTPLAY8_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <dpaddr.h>

/****************************************************************************
 *
 * DirectPlay8 Callback Functions
 *
 ****************************************************************************/

//
// Callback Function Type Definition
//
typedef HRESULT (WINAPI *PFNDPNMESSAGEHANDLER)(PVOID,DWORD,PVOID);

/****************************************************************************
 *
 * DirectPlay8 Datatypes (Non-Structure / Non-Message)
 *
 ****************************************************************************/

//
// Player IDs.  Used to uniquely identify a player in a session
//
typedef DWORD   DPNID,      *PDPNID;

//
// Used as identifiers for operations
//
typedef DWORD   DPNHANDLE, *PDPNHANDLE;

/****************************************************************************
 *
 * DirectPlay8 Message Identifiers
 *
 ****************************************************************************/

#define DPN_MSGID_OFFSET                    0xFFFF0000
#define DPN_MSGID_ADD_PLAYER_TO_GROUP       ( DPN_MSGID_OFFSET | 0x0001 )
#define DPN_MSGID_APPLICATION_DESC          ( DPN_MSGID_OFFSET | 0x0002 )
#define DPN_MSGID_ASYNC_OP_COMPLETE         ( DPN_MSGID_OFFSET | 0x0003 )
#define DPN_MSGID_CLIENT_INFO               ( DPN_MSGID_OFFSET | 0x0004 )
#define DPN_MSGID_CONNECT_COMPLETE          ( DPN_MSGID_OFFSET | 0x0005 )
#define DPN_MSGID_CREATE_GROUP              ( DPN_MSGID_OFFSET | 0x0006 )
#define DPN_MSGID_CREATE_PLAYER             ( DPN_MSGID_OFFSET | 0x0007 )
#define DPN_MSGID_DESTROY_GROUP             ( DPN_MSGID_OFFSET | 0x0008 )
#define DPN_MSGID_DESTROY_PLAYER            ( DPN_MSGID_OFFSET | 0x0009 )
#define DPN_MSGID_ENUM_HOSTS_QUERY          ( DPN_MSGID_OFFSET | 0x000a )
#define DPN_MSGID_ENUM_HOSTS_RESPONSE       ( DPN_MSGID_OFFSET | 0x000b )
#define DPN_MSGID_GROUP_INFO                ( DPN_MSGID_OFFSET | 0x000c )
#define DPN_MSGID_HOST_MIGRATE              ( DPN_MSGID_OFFSET | 0x000d )
#define DPN_MSGID_INDICATE_CONNECT          ( DPN_MSGID_OFFSET | 0x000e )
#define DPN_MSGID_INDICATED_CONNECT_ABORTED ( DPN_MSGID_OFFSET | 0x000f )
#define DPN_MSGID_PEER_INFO                 ( DPN_MSGID_OFFSET | 0x0010 )
#define DPN_MSGID_RECEIVE                   ( DPN_MSGID_OFFSET | 0x0011 )
#define DPN_MSGID_REMOVE_PLAYER_FROM_GROUP  ( DPN_MSGID_OFFSET | 0x0012 )
#define DPN_MSGID_RETURN_BUFFER             ( DPN_MSGID_OFFSET | 0x0013 )
#define DPN_MSGID_SEND_COMPLETE             ( DPN_MSGID_OFFSET | 0x0014 )
#define DPN_MSGID_SERVER_INFO               ( DPN_MSGID_OFFSET | 0x0015 )
#define DPN_MSGID_TERMINATE_SESSION         ( DPN_MSGID_OFFSET | 0x0016 )

/****************************************************************************
 *
 * DirectPlay8 Constants
 *
 ****************************************************************************/

#define IID_IDirectPlay8Peer		0
#define IID_IDirectPlay8Client		1
#define IID_IDirectPlay8Server		2


// {EBFE7BA0-628D-11D2-AE0F-006097B01411}
DEFINE_GUID(CLSID_DP8SP_TCPIP, 0xebfe7ba0, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

#define DPNID_ALL_PLAYERS_GROUP             0

//
// DESTROY_GROUP reasons
//
#define DPNDESTROYGROUPREASON_NORMAL                0x0001
#define DPNDESTROYGROUPREASON_AUTODESTRUCTED        0x0002
#define DPNDESTROYGROUPREASON_SESSIONTERMINATED     0x0003

//
// DESTROY_PLAYER reasons
//
#define DPNDESTROYPLAYERREASON_NORMAL               0x0001
#define DPNDESTROYPLAYERREASON_CONNECTIONLOST       0x0002
#define DPNDESTROYPLAYERREASON_SESSIONTERMINATED    0x0003
#define DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER  0x0004

/****************************************************************************
 *
 * DirectPlay8 Flags
 *
 ****************************************************************************/

//
// Cancel flags
//
#define DPNCANCEL_CONNECT                   0x0001
#define DPNCANCEL_ENUM                      0x0002
#define DPNCANCEL_SEND                      0x0004
#define DPNCANCEL_ALL_OPERATIONS            0x8000

//
// Enumerate clients and groups flags (For EnumPlayersAndGroups)
//
#define DPNENUM_PLAYERS                     0x0001
#define DPNENUM_GROUPS                      0x0010

//
// Enum hosts flags (For EnumHosts)
//
#define DPNENUMHOSTS_NOBROADCASTFALLBACK    0x0002

//
// Enum service provider flags (For EnumSP)
//
#define DPNENUMSERVICEPROVIDERS_ALL         0x0001

//
// Get send queue info flags (For GetSendQueueInfo)
//
#define DPNGETSENDQUEUEINFO_PRIORITY_NORMAL 0x0001
#define DPNGETSENDQUEUEINFO_PRIORITY_HIGH   0x0002
#define DPNGETSENDQUEUEINFO_PRIORITY_LOW    0x0004

//
// Group information flags (For Group Info)
//
#define DPNGROUP_AUTODESTRUCT               0x0001

//
// Host flags (For Host)
//

//
// Set info
//
#define DPNINFO_NAME                        0x0001
#define DPNINFO_DATA                        0x0002

//
// Register Lobby flags
//
#define DPNLOBBY_REGISTER                   0x0001
#define DPNLOBBY_UNREGISTER                 0x0002

//
// Player information flags (For Player Info / Player Messages)
//
#define DPNPLAYER_LOCAL                     0x0002
#define DPNPLAYER_HOST                      0x0004

//
// Send flags (For Send/SendTo)
//
#define DPNSEND_NOCOPY                      0x0001
#define DPNSEND_NOCOMPLETE                  0x0002
#define DPNSEND_COMPLETEONPROCESS           0x0004
#define DPNSEND_GUARANTEED                  0x0008
#define DPNSEND_NONSEQUENTIAL               0x0010
#define DPNSEND_NOLOOPBACK                  0x0020
#define DPNSEND_PRIORITY_LOW                0x0040
#define DPNSEND_PRIORITY_HIGH               0x0080

//
// Session Flags (for DPN_APPLICATION_DESC)
//
#define DPNSESSION_CLIENT_SERVER            0x0001
#define DPNSESSION_MIGRATE_HOST             0x0004
#define DPNSESSION_REQUIREPASSWORD          0x0080

//
// SP capabilities flags
//
#define DPNSPCAPS_SUPPORTSDPNSRV            0x0001
#define DPNSPCAPS_SUPPORTSBROADCAST         0x0002
#define DPNSPCAPS_SUPPORTSALLADAPTERS       0x0004

/****************************************************************************
 *
 * DirectPlay8 Structures (Non-Message)
 *
 ****************************************************************************/

//
// Application description
//
typedef struct  _DPN_APPLICATION_DESC
{
    DWORD   dwSize;                         // Size of this structure
    DWORD   dwFlags;                        // Flags (DPNSESSION_...)
    GUID    guidInstance;                   // Instance GUID
    GUID    guidApplication;                // Application GUID
    DWORD   dwMaxPlayers;                   // Maximum # of players allowed (0=no limit)
    DWORD   dwCurrentPlayers;               // Current # of players allowed
    WCHAR   *pwszSessionName;               // Name of the session
    WCHAR   *pwszPassword;                  // Password for the session
    PVOID   pvReservedData;
    DWORD   dwReservedDataSize;
    PVOID   pvApplicationReservedData;
    DWORD   dwApplicationReservedDataSize;
} DPN_APPLICATION_DESC, *PDPN_APPLICATION_DESC;

//
// Generic Buffer Description
//
typedef struct  _BUFFERDESC
{
    DWORD               dwBufferSize;
    BYTE * UNALIGNED    pBufferData;
} BUFFERDESC, DPN_BUFFER_DESC, *PDPN_BUFFER_DESC;

typedef BUFFERDESC  FAR * PBUFFERDESC;

//
// DirectPlay8 capabilities
//
typedef struct  _DPN_CAPS
{
    DWORD   dwSize;                         // Size of this structure
    DWORD   dwFlags;                        // Flags
    DWORD   dwConnectTimeout;               // ms before a connect request times out
    DWORD   dwConnectRetries;               // # of times to attempt the connection
    DWORD   dwTimeoutUntilKeepAlive;        // ms of inactivity before a keep alive is sent
} DPN_CAPS, *PDPN_CAPS;

// Connection Statistics information

typedef struct _DPN_CONNECTION_INFO
{
    DWORD   dwSize;
    DWORD   dwRoundTripLatencyMS;
    DWORD   dwThroughputBPS;
    DWORD   dwPeakThroughputBPS;

    DWORD   dwBytesSentGuaranteed;
    DWORD   dwPacketsSentGuaranteed;
    DWORD   dwBytesSentNonGuaranteed;
    DWORD   dwPacketsSentNonGuaranteed;

    DWORD   dwBytesRetried;     // Guaranteed only
    DWORD   dwPacketsRetried;   // Guaranteed only
    DWORD   dwBytesDropped;     // Non Guaranteed only
    DWORD   dwPacketsDropped;   // Non Guaranteed only

    DWORD   dwMessagesTransmittedHighPriority;
    DWORD   dwMessagesTimedOutHighPriority;
    DWORD   dwMessagesTransmittedNormalPriority;
    DWORD   dwMessagesTimedOutNormalPriority;
    DWORD   dwMessagesTransmittedLowPriority;
    DWORD   dwMessagesTimedOutLowPriority;

    DWORD   dwBytesReceivedGuaranteed;
    DWORD   dwPacketsReceivedGuaranteed;
    DWORD   dwBytesReceivedNonGuaranteed;
    DWORD   dwPacketsReceivedNonGuaranteed;
    DWORD   dwMessagesReceived;

} DPN_CONNECTION_INFO, *PDPN_CONNECTION_INFO;

//
// Group information strucutre
//
typedef struct  _DPN_GROUP_INFO
{
    DWORD   dwSize;             // size of this structure
    DWORD   dwInfoFlags;        // information contained
    PWSTR   pwszName;           // Unicode Name
    PVOID   pvData;             // data block
    DWORD   dwDataSize;         // size in BYTES of data block
    DWORD   dwGroupFlags;       // group flags (DPNGROUP_...)
} DPN_GROUP_INFO, *PDPN_GROUP_INFO;

//
// Player information structure
//
typedef struct  _DPN_PLAYER_INFO
{
    DWORD   dwSize;             // size of this structure
    DWORD   dwInfoFlags;        // information contained
    PWSTR   pwszName;           // Unicode Name
    PVOID   pvData;             // data block
    DWORD   dwDataSize;         // size in BYTES of data block
    DWORD   dwPlayerFlags;      // player flags (DPNPLAYER_...)
} DPN_PLAYER_INFO, *PDPN_PLAYER_INFO;

typedef struct _DPN_SECURITY_CREDENTIALS    DPN_SECURITY_CREDENTIALS, *PDPN_SECURITY_CREDENTIALS;
typedef struct _DPN_SECURITY_DESC           DPN_SECURITY_DESC, *PDPN_SECURITY_DESC;

//
// Service provider & adapter enumeration structure
//
typedef struct _DPN_SERVICE_PROVIDER_INFO
{
    DWORD       dwFlags;
    GUID        guid;       // SP Guid
    WCHAR       *pwszName;  // Friendly Name
    PVOID       pvReserved;
    DWORD       dwReserved;
} DPN_SERVICE_PROVIDER_INFO, *PDPN_SERVICE_PROVIDER_INFO;

//
// Service provider caps structure
//
typedef struct _DPN_SP_CAPS
{
    DWORD   dwSize;                         // Size of this structure
    DWORD   dwFlags;                        // Flags ((DPNSPCAPS_...)
    DWORD   dwNumThreads;                   // # of worker threads to use
    DWORD   dwDefaultEnumCount;             // default # of enum requests
    DWORD   dwDefaultEnumRetryInterval;     // default ms between enum requests
    DWORD   dwDefaultEnumTimeout;           // default enum timeout
    DWORD   dwMaxEnumPayloadSize;           // maximum size in bytes for enum payload data
    DWORD   dwBuffersPerThread;             // number of receive buffers per thread
    DWORD   dwSystemBufferSize;             // amount of buffering to do in addition to posted receive buffers
} DPN_SP_CAPS, *PDPN_SP_CAPS;



/****************************************************************************
 *
 * IDirectPlay8 message handler call back structures
 *
 ****************************************************************************/

//
// Add player to group strucutre for message handler
// (DPN_MSGID_ADD_PLAYER_TO_GROUP)
//
typedef struct  _DPNMSG_ADD_PLAYER_TO_GROUP
{
    DWORD   dwSize;             // Size of this structure
    DPNID   dpnidGroup;         // DPNID of group
    PVOID   pvGroupContext;     // Group context value
    DPNID   dpnidPlayer;        // DPNID of added player
    PVOID   pvPlayerContext;    // Player context value
} DPNMSG_ADD_PLAYER_TO_GROUP, *PDPNMSG_ADD_PLAYER_TO_GROUP;

//
// Async operation completion structure for message handler
// (DPN_MSGID_ASYNC_OP_COMPLETE)
//
typedef struct  _DPNMSG_ASYNC_OP_COMPLETE
{
    DWORD       dwSize;         // Size of this structure
    DPNHANDLE   hAsyncOp;       // DirectPlay8 async operation handle
    PVOID       pvUserContext;  // User context supplied
    HRESULT     hResultCode;    // HRESULT of operation
} DPNMSG_ASYNC_OP_COMPLETE, *PDPNMSG_ASYNC_OP_COMPLETE;

//
// Client info structure for message handler
// (DPN_MSGID_CLIENT_INFO)
//
typedef struct  _DPNMSG_CLIENT_INFO
{
    DWORD   dwSize;             // Size of this structure
    DPNID   dpnidClient;        // DPNID of client
    PVOID   pvPlayerContext;    // Player context value
} DPNMSG_CLIENT_INFO, *PDPNMSG_CLIENT_INFO;

//
// Connect complete structure for message handler
// (DPN_MSGID_CONNECT_COMPLETE)
//
typedef struct  _DPNMSG_CONNECT_COMPLETE
{
    DWORD       dwSize;                     // Size of this structure
    DPNHANDLE   hAsyncOp;                   // DirectPlay8 Async operation handle
    PVOID       pvUserContext;              // User context supplied at Connect
    HRESULT     hResultCode;                // HRESULT of connection attempt
    PVOID       pvApplicationReplyData;     // Connection reply data from Host/Server
    DWORD       dwApplicationReplyDataSize; // Size (in bytes) of pvApplicationReplyData
} DPNMSG_CONNECT_COMPLETE, *PDPNMSG_CONNECT_COMPLETE;

//
// Create group structure for message handler
// (DPN_MSGID_CREATE_GROUP)
//
typedef struct  _DPNMSG_CREATE_GROUP
{
    DWORD   dwSize;             // Size of this structure
    DPNID   dpnidGroup;         // DPNID of new group
    DPNID   dpnidOwner;         // Owner of newgroup
    PVOID   pvGroupContext;     // Group context value
} DPNMSG_CREATE_GROUP, *PDPNMSG_CREATE_GROUP;

//
// Create player structure for message handler
// (DPN_MSGID_CREATE_PLAYER)
//
typedef struct  _DPNMSG_CREATE_PLAYER
{
    DWORD   dwSize;             // Size of this structure
    DPNID   dpnidPlayer;        // DPNID of new player
    PVOID   pvPlayerContext;    // Player context value
} DPNMSG_CREATE_PLAYER, *PDPNMSG_CREATE_PLAYER;

//
// Destroy group structure for message handler
// (DPN_MSGID_DESTROY_GROUP)
//
typedef struct  _DPNMSG_DESTROY_GROUP
{
    DWORD   dwSize;             // Size of this structure
    DPNID   dpnidGroup;         // DPNID of destroyed group
    PVOID   pvGroupContext;     // Group context value
    DWORD   dwReason;           // Information only
} DPNMSG_DESTROY_GROUP, *PDPNMSG_DESTROY_GROUP;

//
// Destroy player structure for message handler
// (DPN_MSGID_DESTROY_PLAYER)
//
typedef struct  _DPNMSG_DESTROY_PLAYER
{
    DWORD   dwSize;             // Size of this structure
    DPNID   dpnidPlayer;        // DPNID of leaving player
    PVOID   pvPlayerContext;    // Player context value
    DWORD   dwReason;           // Information only
} DPNMSG_DESTROY_PLAYER, *PDPNMSG_DESTROY_PLAYER;

//
// Enumeration request received structure for message handler
// (DPN_MSGID_ENUM_HOSTS_QUERY)
//
typedef struct  _DPNMSG_ENUM_HOSTS_QUERY
{
    DWORD               dwSize;                 // Size of this structure.
    IDirectPlay8Address *pAddressSender;        // Address of client who sent the request
    IDirectPlay8Address *pAddressDevice;        // Address of device request was received on
    PVOID               pvReceivedData;         // Request data (set on client)
    DWORD               dwReceivedDataSize;     // Request data size (set on client)
    DWORD               dwMaxResponseDataSize;  // Max allowable size of enum response
    PVOID               pvResponseData;         // Optional query repsonse (user set)
    DWORD               dwResponseDataSize;     // Optional query response size (user set)
    PVOID               pvResponseContext;      // Optional query response context (user set)
} DPNMSG_ENUM_HOSTS_QUERY, *PDPNMSG_ENUM_HOSTS_QUERY;

//
// Enumeration response received structure for message handler
// (DPN_MSGID_ENUM_HOSTS_RESPONSE)
//
typedef struct  _DPNMSG_ENUM_HOSTS_RESPONSE
{
    DWORD                       dwSize;                     // Size of this structure
    IDirectPlay8Address         *pAddressSender;            // Address of host who responded
    IDirectPlay8Address         *pAddressDevice;            // Device response was received on
    const DPN_APPLICATION_DESC  *pApplicationDescription;   // Application description for the session
    PVOID                       pvResponseData;             // Optional response data (set on host)
    DWORD                       dwResponseDataSize;         // Optional response data size (set on host)
    PVOID                       pvUserContext;              // Context value supplied for enumeration
    DWORD                       dwRoundTripLatencyMS;       // Round trip latency in MS
} DPNMSG_ENUM_HOSTS_RESPONSE, *PDPNMSG_ENUM_HOSTS_RESPONSE;

//
// Group info structure for message handler
// (DPN_MSGID_GROUP_INFO)
//
typedef struct  _DPNMSG_GROUP_INFO
{
    DWORD   dwSize;                 // Size of this structure
    DPNID   dpnidGroup;             // DPNID of group
    PVOID   pvGroupContext;         // Group context value
} DPNMSG_GROUP_INFO, *PDPNMSG_GROUP_INFO;

//
// Migrate host structure for message handler
// (DPN_MSGID_HOST_MIGRATE)
//
typedef struct  _DPNMSG_HOST_MIGRATE
{
    DWORD   dwSize;                 // Size of this structure
    DPNID   dpnidNewHost;           // DPNID of new Host player
    PVOID   pvPlayerContext;        // Player context value
} DPNMSG_HOST_MIGRATE, *PDPNMSG_HOST_MIGRATE;

//
// Indicate connect structure for message handler
// (DPN_MSGID_INDICATE_CONNECT)
//
typedef struct  _DPNMSG_INDICATE_CONNECT
{
    DWORD       dwSize;                 // Size of this structure
    PVOID       pvUserConnectData;      // Connecting player data
    DWORD       dwUserConnectDataSize;  // Size (in bytes) of pvUserConnectData
    PVOID       pvReplyData;            // Connection reply data
    DWORD       dwReplyDataSize;        // Size (in bytes) of pvReplyData
    PVOID       pvReplyContext;         // Buffer context for pvReplyData
    PVOID       pvPlayerContext;        // Player context preset
    IDirectPlay8Address *pAddressPlayer;// Address of connecting player
    IDirectPlay8Address *pAddressDevice;// Address of device receiving connect attempt
} DPNMSG_INDICATE_CONNECT, *PDPNMSG_INDICATE_CONNECT;

//
// Indicated connect aborted structure for message handler
// (DPN_MSGID_INDICATED_CONNECT_ABORTED)
//
typedef struct  _DPNMSG_INDICATED_CONNECT_ABORTED
{
    DWORD       dwSize;             // Size of this structure
    PVOID       pvPlayerContext;    // Player context preset from DPNMSG_INDICATE_CONNECT
} DPNMSG_INDICATED_CONNECT_ABORTED, *PDPNMSG_INDICATED_CONNECT_ABORTED;

//
// Peer info structure for message handler
// (DPN_MSGID_PEER_INFO)
//
typedef struct  _DPNMSG_PEER_INFO
{
    DWORD   dwSize;                 // Size of this structure
    DPNID   dpnidPeer;              // DPNID of peer
    PVOID   pvPlayerContext;        // Player context value
} DPNMSG_PEER_INFO, *PDPNMSG_PEER_INFO;

//
// Receive structure for message handler
// (DPN_MSGID_RECEIVE)
//
typedef struct  _DPNMSG_RECEIVE
{
    DWORD       dwSize;             // Size of this structure
    DPNID       dpnidSender;        // DPNID of sending player
    PVOID       pvPlayerContext;    // Player context value of sending player
    PBYTE       pReceiveData;       // Received data
    DWORD       dwReceiveDataSize;  // Size (in bytes) of pReceiveData
    DPNHANDLE   hBufferHandle;      // Buffer handle for pReceiveData
} DPNMSG_RECEIVE, *PDPNMSG_RECEIVE;

//
// Remove player from group structure for message handler
// (DPN_MSGID_REMOVE_PLAYER_FROM_GROUP)
//
typedef struct  _DPNMSG_REMOVE_PLAYER_FROM_GROUP
{
    DWORD   dwSize;                 // Size of this structure
    DPNID   dpnidGroup;             // DPNID of group
    PVOID   pvGroupContext;         // Group context value
    DPNID   dpnidPlayer;            // DPNID of deleted player
    PVOID   pvPlayerContext;        // Player context value
} DPNMSG_REMOVE_PLAYER_FROM_GROUP, *PDPNMSG_REMOVE_PLAYER_FROM_GROUP;

//
// Returned buffer structure for message handler
// (DPN_MSGID_RETURN_BUFFER)
//
typedef struct  _DPNMSG_RETURN_BUFFER
{
    DWORD       dwSize;             // Size of this structure
    HRESULT     hResultCode;        // Return value of operation
    PVOID       pvBuffer;           // Buffer being returned
    PVOID       pvUserContext;      // Context associated with buffer
} DPNMSG_RETURN_BUFFER, *PDPNMSG_RETURN_BUFFER;

//
// Send complete structure for message handler
// (DPN_MSGID_SEND_COMPLETE)
//
typedef struct  _DPNMSG_SEND_COMPLETE
{
    DWORD       dwSize;             // Size of this structure
    DPNHANDLE   hAsyncOp;           // DirectPlay8 Async operation handle
    PVOID       pvUserContext;      // User context supplied at Send/SendTo
    HRESULT     hResultCode;        // HRESULT of send
    DWORD       dwSendTime;         // Send time in ms
} DPNMSG_SEND_COMPLETE, *PDPNMSG_SEND_COMPLETE;

//
// Server info structure for message handler
// (DPN_MSGID_SERVER_INFO)
//
typedef struct  _DPNMSG_SERVER_INFO
{
    DWORD   dwSize;                 // Size of this structure
    DPNID   dpnidServer;            // DPNID of server
    PVOID   pvPlayerContext;        // Player context value
} DPNMSG_SERVER_INFO, *PDPNMSG_SERVER_INFO;

//
// Terminated session structure for message handler
// (DPN_MSGID_TERMINATE_SESSION)
//
typedef struct  _DPNMSG_TERMINATE_SESSION
{
    DWORD       dwSize;             // Size of this structure
    HRESULT     hResultCode;        // Reason
    PVOID       pvTerminateData;    // Data passed from Host/Server
    DWORD       dwTerminateDataSize;// Size (in bytes) of pvTerminateData
} DPNMSG_TERMINATE_SESSION, *PDPNMSG_TERMINATE_SESSION;

typedef struct IDirectPlay8Peer     IDirectPlay8Peer;
typedef IDirectPlay8Peer    *PDIRECTPLAY8PEER, *LPDIRECTPLAY8PEER;

typedef struct IDirectPlay8Server   IDirectPlay8Server;
typedef IDirectPlay8Server  *PDIRECTPLAY8SERVER, *LPDIRECTPLAY8SERVER;

typedef struct IDirectPlay8Client   IDirectPlay8Client;
typedef IDirectPlay8Client  *PDIRECTPLAY8CLIENT, *LPDIRECTPLAY8CLIENT;




/****************************************************************************
 *
 * DirectPlay8 Functions
 *
 ****************************************************************************/

extern HRESULT WINAPI DPlayInitialize(DWORD dwMaxMemUsage);
extern HRESULT WINAPI DPlayCleanup(void);

extern HRESULT WINAPI DirectPlay8Create(DWORD dwIID, void **ppvInterface, void **pUnknown);

/****************************************************************************
 *
 * DirectPlay8 Application Interfaces
 *
 ****************************************************************************/


//
// COM definition for DirectPlay8 Client interface
//
// IUnknown methods
ULONG WINAPI IDirectPlay8Client_AddRef(LPDIRECTPLAY8CLIENT pDirectPlay8Client);
ULONG WINAPI IDirectPlay8Client_Release(LPDIRECTPLAY8CLIENT pDirectPlay8Client);

// IDirectPlay8Client methods
HRESULT WINAPI IDirectPlay8Client_Initialize(LPDIRECTPLAY8CLIENT pDirectPlay8Client, PVOID const pvUserContext, const PFNDPNMESSAGEHANDLER pfn, const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_EnumServiceProviders(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const GUID *const pguidServiceProvider, const GUID *const pguidApplication, DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer, PDWORD const pcbEnumData, PDWORD const pcReturned, const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_EnumHosts(LPDIRECTPLAY8CLIENT pDirectPlay8Client, PDPN_APPLICATION_DESC const pApplicationDesc,IDirectPlay8Address *const pAddrHost,IDirectPlay8Address *const pDeviceInfo,PVOID const pUserEnumData,const DWORD dwUserEnumDataSize,const DWORD dwEnumCount,const DWORD dwRetryInterval,const DWORD dwTimeOut,PVOID const pvUserContext,DPNHANDLE *const pAsyncHandle,const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_CancelAsyncOperation(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const DPNHANDLE hAsyncHandle, const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_Connect(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address *const pHostAddr,IDirectPlay8Address *const pDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,const void *const pvUserConnectData,const DWORD dwUserConnectDataSize,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_Send(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const DPN_BUFFER_DESC *const prgBufferDesc,const DWORD cBufferDesc,const DWORD dwTimeOut,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_GetSendQueueInfo(LPDIRECTPLAY8CLIENT pDirectPlay8Client, DWORD *const pdwNumMsgs, DWORD *const pdwNumBytes, const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_GetApplicationDesc(LPDIRECTPLAY8CLIENT pDirectPlay8Client, DPN_APPLICATION_DESC *const pAppDescBuffer, DWORD *const pcbDataSize, const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_SetClientInfo(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const DPN_PLAYER_INFO *const pdpnPlayerInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_GetServerInfo(LPDIRECTPLAY8CLIENT pDirectPlay8Client, DPN_PLAYER_INFO *const pdpnPlayerInfo,DWORD *const pdwSize,const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_GetServerAddress(LPDIRECTPLAY8CLIENT pDirectPlay8Client, IDirectPlay8Address **const pAddress,const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_Close(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_ReturnBuffer(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const DPNHANDLE hBufferHandle,const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_GetCaps(LPDIRECTPLAY8CLIENT pDirectPlay8Client, DPN_CAPS *const pdpCaps,const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_SetCaps(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const DPN_CAPS *const pdpCaps, const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_SetSPCaps(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const GUID *const pguidSP, const DPN_SP_CAPS *const pdpspCaps, const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_GetSPCaps(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const GUID *const pguidSP,DPN_SP_CAPS *const pdpspCaps,const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_GetConnectionInfo(LPDIRECTPLAY8CLIENT pDirectPlay8Client, DPN_CONNECTION_INFO *const pdpConnectionInfo,const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_RegisterLobby(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const DPNHANDLE dpnHandle, PVOID const pIDP8LobbiedApplication,const DWORD dwFlags);
HRESULT WINAPI IDirectPlay8Client_DoWork(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const DWORD dwFlags);

#ifdef __cplusplus

// IDirectPlay8Client wrapper class
struct IDirectPlay8Client
{
    __inline ULONG STDMETHODCALLTYPE AddRef(void)
    {
        return IDirectPlay8Client_AddRef(this);
    }

    __inline ULONG STDMETHODCALLTYPE Release(void)
    {
        return IDirectPlay8Client_Release(this);
    }

    __inline HRESULT STDMETHODCALLTYPE Initialize(PVOID const pvUserContext, const PFNDPNMESSAGEHANDLER pfn, const DWORD dwFlags)
    {
        return IDirectPlay8Client_Initialize(this, pvUserContext, pfn, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE EnumServiceProviders(const GUID *const pguidServiceProvider, const GUID *const pguidApplication, DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer, PDWORD const pcbEnumData, PDWORD const pcReturned, const DWORD dwFlags)
    {
        return IDirectPlay8Client_EnumServiceProviders(this, pguidServiceProvider, pguidApplication, pSPInfoBuffer, pcbEnumData, pcReturned, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE EnumHosts(PDPN_APPLICATION_DESC const pApplicationDesc,IDirectPlay8Address *const pAddrHost,IDirectPlay8Address *const pDeviceInfo,PVOID const pUserEnumData,const DWORD dwUserEnumDataSize,const DWORD dwEnumCount,const DWORD dwRetryInterval,const DWORD dwTimeOut,PVOID const pvUserContext,DPNHANDLE *const pAsyncHandle,const DWORD dwFlags)
    {
        return IDirectPlay8Client_EnumHosts(this, pApplicationDesc, pAddrHost, pDeviceInfo, pUserEnumData, dwUserEnumDataSize, dwEnumCount, dwRetryInterval, dwTimeOut, pvUserContext, pAsyncHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE CancelAsyncOperation(const DPNHANDLE hAsyncHandle, const DWORD dwFlags)
    {
        return IDirectPlay8Client_CancelAsyncOperation(this, hAsyncHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE Connect(const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address *const pHostAddr,IDirectPlay8Address *const pDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,const void *const pvUserConnectData,const DWORD dwUserConnectDataSize,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags)
    {
        return IDirectPlay8Client_Connect(this, pdnAppDesc, pHostAddr, pDeviceInfo, pdnSecurity, pdnCredentials, pvUserConnectData, dwUserConnectDataSize, pvAsyncContext, phAsyncHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE Send(const DPN_BUFFER_DESC *const prgBufferDesc,const DWORD cBufferDesc,const DWORD dwTimeOut,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags)
    {
        return IDirectPlay8Client_Send(this, prgBufferDesc, cBufferDesc, dwTimeOut, pvAsyncContext, phAsyncHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetSendQueueInfo(DWORD *const pdwNumMsgs, DWORD *const pdwNumBytes, const DWORD dwFlags)
    {
        return IDirectPlay8Client_GetSendQueueInfo(this, pdwNumMsgs, pdwNumBytes, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetApplicationDesc(DPN_APPLICATION_DESC *const pAppDescBuffer, DWORD *const pcbDataSize, const DWORD dwFlags)
    {
        return IDirectPlay8Client_GetApplicationDesc(this, pAppDescBuffer, pcbDataSize, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE SetClientInfo(const DPN_PLAYER_INFO *const pdpnPlayerInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags)
    {
        return IDirectPlay8Client_SetClientInfo(this, pdpnPlayerInfo, pvAsyncContext, phAsyncHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetServerInfo(DPN_PLAYER_INFO *const pdpnPlayerInfo,DWORD *const pdwSize,const DWORD dwFlags)
    {
        return IDirectPlay8Client_GetServerInfo(this, pdpnPlayerInfo, pdwSize, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetServerAddress(IDirectPlay8Address **const pAddress,const DWORD dwFlags)
    {
        return IDirectPlay8Client_GetServerAddress(this, pAddress, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE Close(const DWORD dwFlags)
    {
        return IDirectPlay8Client_Close(this, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE ReturnBuffer(const DPNHANDLE hBufferHandle,const DWORD dwFlags)
    {
        return IDirectPlay8Client_ReturnBuffer(this, hBufferHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetCaps(DPN_CAPS *const pdpCaps,const DWORD dwFlags)
    {
        return IDirectPlay8Client_GetCaps(this, pdpCaps, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE SetCaps(const DPN_CAPS *const pdpCaps, const DWORD dwFlags)
    {
        return IDirectPlay8Client_SetCaps(this, pdpCaps, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE SetSPCaps(const GUID *const pguidSP, const DPN_SP_CAPS *const pdpspCaps, const DWORD dwFlags)
    {
        return IDirectPlay8Client_SetSPCaps(this, pguidSP, pdpspCaps, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetSPCaps(const GUID *const pguidSP,DPN_SP_CAPS *const pdpspCaps,const DWORD dwFlags)
    {
        return IDirectPlay8Client_GetSPCaps(this, pguidSP, pdpspCaps, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetConnectionInfo(DPN_CONNECTION_INFO *const pdpConnectionInfo,const DWORD dwFlags)
    {
        return IDirectPlay8Client_GetConnectionInfo(this, pdpConnectionInfo, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE RegisterLobby(const DPNHANDLE dpnHandle, PVOID const pIDP8LobbiedApplication,const DWORD dwFlags)
    {
        return IDirectPlay8Client_RegisterLobby(this, dpnHandle, pIDP8LobbiedApplication, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE DoWork(const DWORD dwFlags)
    {
        return IDirectPlay8Client_DoWork(this, dwFlags);
    }
};

#endif // __cplusplus



//
// COM definition for DirectPlay8 Server interface
//
// IUnknown methods
ULONG WINAPI IDirectPlay8Server_AddRef(LPDIRECTPLAY8SERVER pDirectPlay8Server);
ULONG WINAPI IDirectPlay8Server_Release(LPDIRECTPLAY8SERVER pDirectPlay8Server);

// IDirectPlay8Server methods
HRESULT WINAPI IDirectPlay8Server_Initialize(LPDIRECTPLAY8SERVER pDirectPlay8Server, PVOID const pvUserContext, const PFNDPNMESSAGEHANDLER pfn, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_EnumServiceProviders(LPDIRECTPLAY8SERVER pDirectPlay8Server, const GUID *const pguidServiceProvider,const GUID *const pguidApplication,DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,PDWORD const pcbEnumData,PDWORD const pcReturned,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_CancelAsyncOperation(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNHANDLE hAsyncHandle,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_GetSendQueueInfo(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID dpnid,DWORD *const pdwNumMsgs, DWORD *const pdwNumBytes, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_GetApplicationDesc(LPDIRECTPLAY8SERVER pDirectPlay8Server, DPN_APPLICATION_DESC *const pAppDescBuffer, DWORD *const pcbDataSize, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_SetServerInfo(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPN_PLAYER_INFO *const pdpnPlayerInfo,PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_GetClientInfo(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID dpnid,DPN_PLAYER_INFO *const pdpnPlayerInfo,DWORD *const pdwSize,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_GetClientAddress(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID dpnid,IDirectPlay8Address **const pAddress,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_GetLocalHostAddresses(LPDIRECTPLAY8SERVER pDirectPlay8Server, IDirectPlay8Address **const prgpAddress,DWORD *const pcAddress,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_SetApplicationDesc(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPN_APPLICATION_DESC *const pad, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_Host(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address **const prgpDeviceInfo,const DWORD cDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,void *const pvPlayerContext,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_SendTo(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID dpnid,const DPN_BUFFER_DESC *const prgBufferDesc,const DWORD cBufferDesc,const DWORD dwTimeOut,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_CreateGroup(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPN_GROUP_INFO *const pdpnGroupInfo,void *const pvGroupContext,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_DestroyGroup(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID idGroup, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_AddPlayerToGroup(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID idGroup, const DPNID idClient, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_RemovePlayerFromGroup(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID idGroup, const DPNID idClient, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_SetGroupInfo(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_GetGroupInfo(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,DWORD *const pdwSize,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_EnumPlayersAndGroups(LPDIRECTPLAY8SERVER pDirectPlay8Server, DPNID *const prgdpnid, DWORD *const pcdpnid, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_EnumGroupMembers(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID dpnid, DPNID *const prgdpnid, DWORD *const pcdpnid, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_Close(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_DestroyClient(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID dpnidClient, const void *const pvDestroyData, const DWORD dwDestroyDataSize, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_ReturnBuffer(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNHANDLE hBufferHandle,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_GetPlayerContext(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID dpnid,PVOID *const ppvPlayerContext,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_GetGroupContext(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID dpnid,PVOID *const ppvGroupContext,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_GetCaps(LPDIRECTPLAY8SERVER pDirectPlay8Server, DPN_CAPS *const pdpCaps,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_SetCaps(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPN_CAPS *const pdpCaps, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_SetSPCaps(LPDIRECTPLAY8SERVER pDirectPlay8Server, const GUID *const pguidSP, const DPN_SP_CAPS *const pdpspCaps, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_GetSPCaps(LPDIRECTPLAY8SERVER pDirectPlay8Server, const GUID *const pguidSP, DPN_SP_CAPS *const pdpspCaps,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_GetConnectionInfo(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNID dpnid, DPN_CONNECTION_INFO *const pdpConnectionInfo,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_RegisterLobby(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DPNHANDLE dpnHandle, PVOID const pIDP8LobbiedApplication,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Server_DoWork(LPDIRECTPLAY8SERVER pDirectPlay8Server, const DWORD dwFlags);


#ifdef __cplusplus

// IDirectPlay8Server wrapper class
struct IDirectPlay8Server
{
    __inline ULONG STDMETHODCALLTYPE AddRef(void)
    {
        return IDirectPlay8Server_AddRef(this);
    }

    __inline ULONG STDMETHODCALLTYPE Release(void)
    {
        return IDirectPlay8Server_Release(this);
    }

    __inline HRESULT STDMETHODCALLTYPE Initialize(PVOID const pvUserContext, const PFNDPNMESSAGEHANDLER pfn, const DWORD dwFlags )
    {
        return IDirectPlay8Server_Initialize(this, pvUserContext, pfn, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE EnumServiceProviders(const GUID *const pguidServiceProvider,const GUID *const pguidApplication,DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,PDWORD const pcbEnumData,PDWORD const pcReturned,const DWORD dwFlags )
    {
        return IDirectPlay8Server_EnumServiceProviders(this, pguidServiceProvider, pguidApplication, pSPInfoBuffer, pcbEnumData, pcReturned, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE CancelAsyncOperation(const DPNHANDLE hAsyncHandle,const DWORD dwFlags )
    {
        return IDirectPlay8Server_CancelAsyncOperation(this, hAsyncHandle, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE GetSendQueueInfo(const DPNID dpnid,DWORD *const pdwNumMsgs, DWORD *const pdwNumBytes, const DWORD dwFlags )
    {
        return IDirectPlay8Server_GetSendQueueInfo(this, dpnid, pdwNumMsgs, pdwNumBytes, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE GetApplicationDesc(DPN_APPLICATION_DESC *const pAppDescBuffer, DWORD *const pcbDataSize, const DWORD dwFlags )
    {
        return IDirectPlay8Server_GetApplicationDesc(this, pAppDescBuffer, pcbDataSize, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE SetServerInfo(const DPN_PLAYER_INFO *const pdpnPlayerInfo,PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags )
    {
        return IDirectPlay8Server_SetServerInfo(this, pdpnPlayerInfo, pvAsyncContext, phAsyncHandle, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE GetClientInfo(const DPNID dpnid,DPN_PLAYER_INFO *const pdpnPlayerInfo,DWORD *const pdwSize,const DWORD dwFlags )
    {
        return IDirectPlay8Server_GetClientInfo(this, dpnid, pdpnPlayerInfo, pdwSize, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE GetClientAddress(const DPNID dpnid,IDirectPlay8Address **const pAddress,const DWORD dwFlags )
    {
        return IDirectPlay8Server_GetClientAddress(this, dpnid, pAddress, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE GetLocalHostAddresses(IDirectPlay8Address **const prgpAddress,DWORD *const pcAddress,const DWORD dwFlags )
    {
        return IDirectPlay8Server_GetLocalHostAddresses(this, prgpAddress, pcAddress, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE SetApplicationDesc(const DPN_APPLICATION_DESC *const pad, const DWORD dwFlags )
    {
        return IDirectPlay8Server_SetApplicationDesc(this, pad, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE Host(const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address **const prgpDeviceInfo,const DWORD cDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,void *const pvPlayerContext,const DWORD dwFlags )
    {
        return IDirectPlay8Server_Host(this, pdnAppDesc, prgpDeviceInfo, cDeviceInfo, pdnSecurity, pdnCredentials, pvPlayerContext, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE SendTo(const DPNID dpnid,const DPN_BUFFER_DESC *const prgBufferDesc,const DWORD cBufferDesc,const DWORD dwTimeOut,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags )
    {
        return IDirectPlay8Server_SendTo(this, dpnid, prgBufferDesc, cBufferDesc, dwTimeOut, pvAsyncContext, phAsyncHandle, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE CreateGroup(const DPN_GROUP_INFO *const pdpnGroupInfo,void *const pvGroupContext,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags )
    {
        return IDirectPlay8Server_CreateGroup(this, pdpnGroupInfo, pvGroupContext, pvAsyncContext, phAsyncHandle, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE DestroyGroup(const DPNID idGroup, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags )
    {
        return IDirectPlay8Server_DestroyGroup(this, idGroup, pvAsyncContext, phAsyncHandle, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE AddPlayerToGroup(const DPNID idGroup, const DPNID idClient, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags )
    {
        return IDirectPlay8Server_AddPlayerToGroup(this, idGroup, idClient, pvAsyncContext, phAsyncHandle, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE RemovePlayerFromGroup(const DPNID idGroup, const DPNID idClient, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags )
    {
        return IDirectPlay8Server_RemovePlayerFromGroup(this, idGroup, idClient, pvAsyncContext, phAsyncHandle, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE SetGroupInfo(const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags )
    {
        return IDirectPlay8Server_SetGroupInfo(this, dpnid, pdpnGroupInfo, pvAsyncContext, phAsyncHandle, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE GetGroupInfo(const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,DWORD *const pdwSize,const DWORD dwFlags )
    {
        return IDirectPlay8Server_GetGroupInfo(this, dpnid, pdpnGroupInfo, pdwSize, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE EnumPlayersAndGroups(DPNID *const prgdpnid, DWORD *const pcdpnid, const DWORD dwFlags )
    {
        return IDirectPlay8Server_EnumPlayersAndGroups(this, prgdpnid, pcdpnid, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE EnumGroupMembers(const DPNID dpnid, DPNID *const prgdpnid, DWORD *const pcdpnid, const DWORD dwFlags )
    {
        return IDirectPlay8Server_EnumGroupMembers(this, dpnid, prgdpnid, pcdpnid, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE Close(const DWORD dwFlags )
    {
        return IDirectPlay8Server_Close(this, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE DestroyClient(const DPNID dpnidClient, const void *const pvDestroyData, const DWORD dwDestroyDataSize, const DWORD dwFlags )
    {
        return IDirectPlay8Server_DestroyClient(this, dpnidClient, pvDestroyData, dwDestroyDataSize, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE ReturnBuffer(const DPNHANDLE hBufferHandle,const DWORD dwFlags )
    {
        return IDirectPlay8Server_ReturnBuffer(this, hBufferHandle, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE GetPlayerContext(const DPNID dpnid,PVOID *const ppvPlayerContext,const DWORD dwFlags )
    {
        return IDirectPlay8Server_GetPlayerContext(this, dpnid, ppvPlayerContext, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE GetGroupContext(const DPNID dpnid,PVOID *const ppvGroupContext,const DWORD dwFlags )
    {
        return IDirectPlay8Server_GetGroupContext(this, dpnid, ppvGroupContext, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE GetCaps(DPN_CAPS *const pdpCaps,const DWORD dwFlags )
    {
        return IDirectPlay8Server_GetCaps(this, pdpCaps, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE SetCaps(const DPN_CAPS *const pdpCaps, const DWORD dwFlags )
    {
        return IDirectPlay8Server_SetCaps(this, pdpCaps, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE SetSPCaps(const GUID *const pguidSP, const DPN_SP_CAPS *const pdpspCaps, const DWORD dwFlags )
    {
        return IDirectPlay8Server_SetSPCaps(this, pguidSP, pdpspCaps, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE GetSPCaps(const GUID *const pguidSP, DPN_SP_CAPS *const pdpspCaps,const DWORD dwFlags )
    {
        return IDirectPlay8Server_GetSPCaps(this, pguidSP, pdpspCaps, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE GetConnectionInfo(const DPNID dpnid, DPN_CONNECTION_INFO *const pdpConnectionInfo,const DWORD dwFlags )
    {
        return IDirectPlay8Server_GetConnectionInfo(this, dpnid, pdpConnectionInfo, dwFlags );
    }

    __inline HRESULT STDMETHODCALLTYPE RegisterLobby(const DPNHANDLE dpnHandle, PVOID const pIDP8LobbiedApplication,const DWORD dwFlags )
    {
        return IDirectPlay8Server_RegisterLobby(this, dpnHandle, pIDP8LobbiedApplication, dwFlags );
    }


    __inline HRESULT STDMETHODCALLTYPE DoWork(const DWORD dwFlags)
    {
        return IDirectPlay8Server_DoWork(this, dwFlags);
    }
};

#endif // __cplusplus

//
// COM definition for DirectPlay8 Peer interface
//
// IUnknown methods
ULONG WINAPI IDirectPlay8Peer_AddRef(LPDIRECTPLAY8PEER pDirectPlay8Peer);
ULONG WINAPI IDirectPlay8Peer_Release(LPDIRECTPLAY8PEER pDirectPlay8Peer);

// IDirectPlay8Peer methods
HRESULT WINAPI IDirectPlay8Peer_Initialize(LPDIRECTPLAY8PEER pDirectPlay8Peer, PVOID const pvUserContext, const PFNDPNMESSAGEHANDLER pfn, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_EnumServiceProviders(LPDIRECTPLAY8PEER pDirectPlay8Peer, const GUID *const pguidServiceProvider, const GUID *const pguidApplication, DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer, DWORD *const pcbEnumData, DWORD *const pcReturned, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_CancelAsyncOperation(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNHANDLE hAsyncHandle, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_Connect(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address *const pHostAddr,IDirectPlay8Address *const pDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,const void *const pvUserConnectData,const DWORD dwUserConnectDataSize,void *const pvPlayerContext,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_SendTo(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID dpnid,const DPN_BUFFER_DESC *const prgBufferDesc,const DWORD cBufferDesc,const DWORD dwTimeOut,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_GetSendQueueInfo(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID dpnid, DWORD *const pdwNumMsgs, DWORD *const pdwNumBytes, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_Host(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address **const prgpDeviceInfo,const DWORD cDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,void *const pvPlayerContext,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_GetApplicationDesc(LPDIRECTPLAY8PEER pDirectPlay8Peer, DPN_APPLICATION_DESC *const pAppDescBuffer, DWORD *const pcbDataSize, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_SetApplicationDesc(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPN_APPLICATION_DESC *const pad, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_CreateGroup(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPN_GROUP_INFO *const pdpnGroupInfo,void *const pvGroupContext,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_DestroyGroup(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID idGroup, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_AddPlayerToGroup(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID idGroup, const DPNID idClient, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_RemovePlayerFromGroup(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID idGroup, const DPNID idClient, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_SetGroupInfo(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_GetGroupInfo(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,DWORD *const pdwSize,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_EnumPlayersAndGroups(LPDIRECTPLAY8PEER pDirectPlay8Peer, DPNID *const prgdpnid, DWORD *const pcdpnid, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_EnumGroupMembers(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID dpnid, DPNID *const prgdpnid, DWORD *const pcdpnid, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_SetPeerInfo(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPN_PLAYER_INFO *const pdpnPlayerInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_GetPeerInfo(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID dpnid,DPN_PLAYER_INFO *const pdpnPlayerInfo,DWORD *const pdwSize,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_GetPeerAddress(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID dpnid,IDirectPlay8Address **const pAddress,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_GetLocalHostAddresses(LPDIRECTPLAY8PEER pDirectPlay8Peer, IDirectPlay8Address **const prgpAddress,DWORD *const pcAddress,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_Close(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_EnumHosts(LPDIRECTPLAY8PEER pDirectPlay8Peer, PDPN_APPLICATION_DESC const pApplicationDesc,IDirectPlay8Address *const pAddrHost,IDirectPlay8Address *const pDeviceInfo,PVOID const pUserEnumData,const DWORD dwUserEnumDataSize,const DWORD dwEnumCount,const DWORD dwRetryInterval,const DWORD dwTimeOut,PVOID const pvUserContext,DPNHANDLE *const pAsyncHandle,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_DestroyPeer(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID dpnidClient, const void *const pvDestroyData, const DWORD dwDestroyDataSize, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_ReturnBuffer(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNHANDLE hBufferHandle,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_GetPlayerContext(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID dpnid,PVOID *const ppvPlayerContext,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_GetGroupContext(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID dpnid,PVOID *const ppvGroupContext,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_GetCaps(LPDIRECTPLAY8PEER pDirectPlay8Peer, DPN_CAPS *const pdpCaps,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_SetCaps(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPN_CAPS *const pdpCaps, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_SetSPCaps(LPDIRECTPLAY8PEER pDirectPlay8Peer, const GUID *const pguidSP, const DPN_SP_CAPS *const pdpspCaps, const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_GetSPCaps(LPDIRECTPLAY8PEER pDirectPlay8Peer, const GUID *const pguidSP, DPN_SP_CAPS *const pdpspCaps,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_GetConnectionInfo(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID dpnid, DPN_CONNECTION_INFO *const pdpConnectionInfo,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_RegisterLobby(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNHANDLE dpnHandle, PVOID const pIDP8LobbiedApplication,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_TerminateSession(LPDIRECTPLAY8PEER pDirectPlay8Peer, void *const pvTerminateData,const DWORD dwTerminateDataSize,const DWORD dwFlags );
HRESULT WINAPI IDirectPlay8Peer_DoWork(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DWORD dwFlags);

#ifdef __cplusplus

// IDirectPlay8Peer wrapper class
struct IDirectPlay8Peer
{
    __inline ULONG STDMETHODCALLTYPE AddRef(void)
    {
        return IDirectPlay8Peer_AddRef(this);
    }

    __inline ULONG STDMETHODCALLTYPE Release(void)
    {
        return IDirectPlay8Peer_Release(this);
    }

    __inline HRESULT STDMETHODCALLTYPE Initialize(PVOID const pvUserContext, const PFNDPNMESSAGEHANDLER pfn, const DWORD dwFlags)
    {
        return IDirectPlay8Peer_Initialize(this, pvUserContext, pfn, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE EnumServiceProviders(const GUID *const pguidServiceProvider, const GUID *const pguidApplication, DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer, DWORD *const pcbEnumData, DWORD *const pcReturned, const DWORD dwFlags)
    {
        return IDirectPlay8Peer_EnumServiceProviders(this, pguidServiceProvider, pguidApplication, pSPInfoBuffer, pcbEnumData, pcReturned, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE CancelAsyncOperation(const DPNHANDLE hAsyncHandle, const DWORD dwFlags)
    {
        return IDirectPlay8Peer_CancelAsyncOperation(this, hAsyncHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE Connect(const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address *const pHostAddr,IDirectPlay8Address *const pDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,const void *const pvUserConnectData,const DWORD dwUserConnectDataSize,void *const pvPlayerContext,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_Connect(this, pdnAppDesc, pHostAddr, pDeviceInfo, pdnSecurity, pdnCredentials, pvUserConnectData, dwUserConnectDataSize, pvPlayerContext, pvAsyncContext, phAsyncHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE SendTo(const DPNID dpnid,const DPN_BUFFER_DESC *const prgBufferDesc,const DWORD cBufferDesc,const DWORD dwTimeOut,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_SendTo(this, dpnid, prgBufferDesc, cBufferDesc, dwTimeOut, pvAsyncContext, phAsyncHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetSendQueueInfo(const DPNID dpnid, DWORD *const pdwNumMsgs, DWORD *const pdwNumBytes, const DWORD dwFlags)
    {
        return IDirectPlay8Peer_GetSendQueueInfo(this, dpnid, pdwNumMsgs, pdwNumBytes, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE Host(const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address **const prgpDeviceInfo,const DWORD cDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,void *const pvPlayerContext,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_Host(this, pdnAppDesc, prgpDeviceInfo, cDeviceInfo, pdnSecurity, pdnCredentials, pvPlayerContext, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetApplicationDesc(DPN_APPLICATION_DESC *const pAppDescBuffer, DWORD *const pcbDataSize, const DWORD dwFlags)
    {
        return IDirectPlay8Peer_GetApplicationDesc(this, pAppDescBuffer, pcbDataSize, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE SetApplicationDesc(const DPN_APPLICATION_DESC *const pad, const DWORD dwFlags)
    {
        return IDirectPlay8Peer_SetApplicationDesc(this, pad, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE CreateGroup(const DPN_GROUP_INFO *const pdpnGroupInfo,void *const pvGroupContext,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_CreateGroup(this, pdpnGroupInfo, pvGroupContext, pvAsyncContext, phAsyncHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE DestroyGroup(const DPNID idGroup, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags)
    {
        return IDirectPlay8Peer_DestroyGroup(this, idGroup, pvAsyncContext, phAsyncHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE AddPlayerToGroup(const DPNID idGroup, const DPNID idClient, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags)
    {
        return IDirectPlay8Peer_AddPlayerToGroup(this, idGroup, idClient, pvAsyncContext, phAsyncHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE RemovePlayerFromGroup(const DPNID idGroup, const DPNID idClient, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags)
    {
        return IDirectPlay8Peer_RemovePlayerFromGroup(this, idGroup, idClient, pvAsyncContext, phAsyncHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE SetGroupInfo(const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags)
    {
        return IDirectPlay8Peer_SetGroupInfo(this, dpnid, pdpnGroupInfo, pvAsyncContext, phAsyncHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetGroupInfo(const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,DWORD *const pdwSize,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_GetGroupInfo(this, dpnid, pdpnGroupInfo, pdwSize, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE EnumPlayersAndGroups(DPNID *const prgdpnid, DWORD *const pcdpnid, const DWORD dwFlags)
    {
        return IDirectPlay8Peer_EnumPlayersAndGroups(this, prgdpnid, pcdpnid, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE EnumGroupMembers(const DPNID dpnid, DPNID *const prgdpnid, DWORD *const pcdpnid, const DWORD dwFlags)
    {
        return IDirectPlay8Peer_EnumGroupMembers(this, dpnid, prgdpnid, pcdpnid, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE SetPeerInfo(const DPN_PLAYER_INFO *const pdpnPlayerInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags)
    {
        return IDirectPlay8Peer_SetPeerInfo(this, pdpnPlayerInfo, pvAsyncContext, phAsyncHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetPeerInfo(const DPNID dpnid,DPN_PLAYER_INFO *const pdpnPlayerInfo,DWORD *const pdwSize,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_GetPeerInfo(this, dpnid, pdpnPlayerInfo, pdwSize, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetPeerAddress(const DPNID dpnid,IDirectPlay8Address **const pAddress,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_GetPeerAddress(this, dpnid, pAddress, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetLocalHostAddresses(IDirectPlay8Address **const prgpAddress,DWORD *const pcAddress,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_GetLocalHostAddresses(this, prgpAddress, pcAddress, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE Close(const DWORD dwFlags)
    {
        return IDirectPlay8Peer_Close(this, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE EnumHosts(PDPN_APPLICATION_DESC const pApplicationDesc,IDirectPlay8Address *const pAddrHost,IDirectPlay8Address *const pDeviceInfo,PVOID const pUserEnumData,const DWORD dwUserEnumDataSize,const DWORD dwEnumCount,const DWORD dwRetryInterval,const DWORD dwTimeOut,PVOID const pvUserContext,DPNHANDLE *const pAsyncHandle,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_EnumHosts(this, pApplicationDesc, pAddrHost, pDeviceInfo, pUserEnumData, dwUserEnumDataSize, dwEnumCount, dwRetryInterval, dwTimeOut, pvUserContext, pAsyncHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE DestroyPeer(const DPNID dpnidClient, const void *const pvDestroyData, const DWORD dwDestroyDataSize, const DWORD dwFlags)
    {
        return IDirectPlay8Peer_DestroyPeer(this, dpnidClient, pvDestroyData, dwDestroyDataSize, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE ReturnBuffer(const DPNHANDLE hBufferHandle,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_ReturnBuffer(this, hBufferHandle, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetPlayerContext(const DPNID dpnid,PVOID *const ppvPlayerContext,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_GetPlayerContext(this, dpnid, ppvPlayerContext, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetGroupContext(const DPNID dpnid,PVOID *const ppvGroupContext,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_GetGroupContext(this, dpnid, ppvGroupContext, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetCaps(DPN_CAPS *const pdpCaps,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_GetCaps(this, pdpCaps, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE SetCaps(const DPN_CAPS *const pdpCaps, const DWORD dwFlags)
    {
        return IDirectPlay8Peer_SetCaps(this, pdpCaps, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE SetSPCaps(const GUID *const pguidSP, const DPN_SP_CAPS *const pdpspCaps, const DWORD dwFlags)
    {
        return IDirectPlay8Peer_SetSPCaps(this, pguidSP, pdpspCaps, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetSPCaps(const GUID *const pguidSP, DPN_SP_CAPS *const pdpspCaps,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_GetSPCaps(this, pguidSP, pdpspCaps, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE GetConnectionInfo(const DPNID dpnid, DPN_CONNECTION_INFO *const pdpConnectionInfo,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_GetConnectionInfo(this, dpnid, pdpConnectionInfo, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE RegisterLobby(const DPNHANDLE dpnHandle, PVOID const pIDP8LobbiedApplication,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_RegisterLobby(this, dpnHandle, pIDP8LobbiedApplication, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE TerminateSession(void *const pvTerminateData,const DWORD dwTerminateDataSize,const DWORD dwFlags)
    {
        return IDirectPlay8Peer_TerminateSession(this, pvTerminateData, dwTerminateDataSize, dwFlags);
    }


    __inline HRESULT STDMETHODCALLTYPE DoWork(const DWORD dwFlags)
    {
        return IDirectPlay8Peer_DoWork(this, dwFlags);
    }
};

#endif // __cplusplus






/****************************************************************************
 *
 * DIRECTPLAY8 ERRORS
 *
 * Errors are represented by negative values and cannot be combined.
 *
 ****************************************************************************/

#define _DPN_FACILITY_CODE  0x015
#define _DPNHRESULT_BASE        0x8000
#define MAKE_DPNHRESULT( code )         MAKE_HRESULT( 1, _DPN_FACILITY_CODE, ( code + _DPNHRESULT_BASE ) )

#define DPN_OK                          S_OK

#define DPNSUCCESS_EQUAL                MAKE_HRESULT( 0, _DPN_FACILITY_CODE, ( 0x5 + _DPNHRESULT_BASE ) )
#define DPNSUCCESS_NOTEQUAL             MAKE_HRESULT( 0, _DPN_FACILITY_CODE, (0x0A + _DPNHRESULT_BASE ) )
#define DPNSUCCESS_PENDING              MAKE_HRESULT( 0, _DPN_FACILITY_CODE, (0x0e + _DPNHRESULT_BASE ) )

#define DPNERR_ABORTED                  MAKE_DPNHRESULT(  0x30 )
#define DPNERR_ADDRESSING               MAKE_DPNHRESULT(  0x40 )
#define DPNERR_ALREADYCLOSING           MAKE_DPNHRESULT(  0x50 )
#define DPNERR_ALREADYCONNECTED         MAKE_DPNHRESULT(  0x60 )
#define DPNERR_ALREADYDISCONNECTING     MAKE_DPNHRESULT(  0x70 )
#define DPNERR_ALREADYINITIALIZED       MAKE_DPNHRESULT(  0x80 )
#define DPNERR_ALREADYREGISTERED        MAKE_DPNHRESULT(  0x90 )
#define DPNERR_BUFFERTOOSMALL           MAKE_DPNHRESULT( 0x100 )
#define DPNERR_CANNOTCANCEL             MAKE_DPNHRESULT( 0x110 )
#define DPNERR_CANTCREATEGROUP          MAKE_DPNHRESULT( 0x120 )
#define DPNERR_CANTCREATEPLAYER         MAKE_DPNHRESULT( 0x130 )
#define DPNERR_CANTLAUNCHAPPLICATION    MAKE_DPNHRESULT( 0x140 )
#define DPNERR_CONNECTING               MAKE_DPNHRESULT( 0x150 )
#define DPNERR_CONNECTIONLOST           MAKE_DPNHRESULT( 0x160 )
#define DPNERR_CONVERSION               MAKE_DPNHRESULT( 0x170 )
#define DPNERR_DATATOOLARGE             MAKE_DPNHRESULT( 0x175 )
#define DPNERR_DOESNOTEXIST             MAKE_DPNHRESULT( 0x180 )
#define DPNERR_DUPLICATECOMMAND         MAKE_DPNHRESULT( 0x190 )
#define DPNERR_ENDPOINTNOTRECEIVING     MAKE_DPNHRESULT( 0x200 )
#define DPNERR_ENUMQUERYTOOLARGE        MAKE_DPNHRESULT( 0x210 )
#define DPNERR_ENUMRESPONSETOOLARGE     MAKE_DPNHRESULT( 0x220 )
#define DPNERR_EXCEPTION                MAKE_DPNHRESULT( 0x230 )
#define DPNERR_GENERIC                  E_FAIL
#define DPNERR_GROUPNOTEMPTY            MAKE_DPNHRESULT( 0x240 )
#define DPNERR_HOSTING                  MAKE_DPNHRESULT( 0x250 )
#define DPNERR_HOSTREJECTEDCONNECTION   MAKE_DPNHRESULT( 0x260 )
#define DPNERR_HOSTTERMINATEDSESSION    MAKE_DPNHRESULT( 0x270 )
#define DPNERR_INCOMPLETEADDRESS        MAKE_DPNHRESULT( 0x280 )
#define DPNERR_INVALIDADDRESSFORMAT     MAKE_DPNHRESULT( 0x290 )
#define DPNERR_INVALIDAPPLICATION       MAKE_DPNHRESULT( 0x300 )
#define DPNERR_INVALIDCOMMAND           MAKE_DPNHRESULT( 0x310 )
#define DPNERR_INVALIDDEVICEADDRESS     MAKE_DPNHRESULT( 0x320 )
#define DPNERR_INVALIDENDPOINT          MAKE_DPNHRESULT( 0x330 )
#define DPNERR_INVALIDFLAGS             MAKE_DPNHRESULT( 0x340 )
#define DPNERR_INVALIDGROUP             MAKE_DPNHRESULT( 0x350 )
#define DPNERR_INVALIDHANDLE            MAKE_DPNHRESULT( 0x360 )
#define DPNERR_INVALIDHOSTADDRESS       MAKE_DPNHRESULT( 0x370 )
#define DPNERR_INVALIDINSTANCE          MAKE_DPNHRESULT( 0x380 )
#define DPNERR_INVALIDINTERFACE         MAKE_DPNHRESULT( 0x390 )
#define DPNERR_INVALIDOBJECT            MAKE_DPNHRESULT( 0x400 )
#define DPNERR_INVALIDPARAM             E_INVALIDARG
#define DPNERR_INVALIDPASSWORD          MAKE_DPNHRESULT( 0x410 )
#define DPNERR_INVALIDPLAYER            MAKE_DPNHRESULT( 0x420 )
#define DPNERR_INVALIDPOINTER           E_POINTER
#define DPNERR_INVALIDPRIORITY          MAKE_DPNHRESULT( 0x430 )
#define DPNERR_INVALIDSTRING            MAKE_DPNHRESULT( 0x440 )
#define DPNERR_INVALIDURL               MAKE_DPNHRESULT( 0x450 )
#define DPNERR_INVALIDVERSION           MAKE_DPNHRESULT( 0x460 )
#define DPNERR_NOCAPS                   MAKE_DPNHRESULT( 0x470 )
#define DPNERR_NOCONNECTION             MAKE_DPNHRESULT( 0x480 )
#define DPNERR_NOHOSTPLAYER             MAKE_DPNHRESULT( 0x490 )
#define DPNERR_NOINTERFACE              E_NOINTERFACE
#define DPNERR_NOMOREADDRESSCOMPONENTS  MAKE_DPNHRESULT( 0x500 )
#define DPNERR_NORESPONSE               MAKE_DPNHRESULT( 0x510 )
#define DPNERR_NOTALLOWED               MAKE_DPNHRESULT( 0x520 )
#define DPNERR_NOTHOST                  MAKE_DPNHRESULT( 0x530 )
#define DPNERR_NOTREADY                 MAKE_DPNHRESULT( 0x540 )
#define DPNERR_NOTREGISTERED            MAKE_DPNHRESULT( 0x550 )
#define DPNERR_OUTOFMEMORY              E_OUTOFMEMORY
#define DPNERR_PENDING                  DPNSUCCESS_PENDING
#define DPNERR_PLAYERALREADYINGROUP     MAKE_DPNHRESULT( 0x560 )
#define DPNERR_PLAYERLOST               MAKE_DPNHRESULT( 0x570 )
#define DPNERR_PLAYERNOTINGROUP         MAKE_DPNHRESULT( 0x580 )
#define DPNERR_PLAYERNOTREACHABLE       MAKE_DPNHRESULT( 0x590 )
#define DPNERR_SENDTOOLARGE             MAKE_DPNHRESULT( 0x600 )
#define DPNERR_SESSIONFULL              MAKE_DPNHRESULT( 0x610 )
#define DPNERR_TABLEFULL                MAKE_DPNHRESULT( 0x620 )
#define DPNERR_TIMEDOUT                 MAKE_DPNHRESULT( 0x630 )
#define DPNERR_UNINITIALIZED            MAKE_DPNHRESULT( 0x640 )
#define DPNERR_UNSUPPORTED              E_NOTIMPL
#define DPNERR_USERCANCEL               MAKE_DPNHRESULT( 0x650 )
#define DPNERR_NOAGGREGATION                CLASS_E_NOAGGREGATION

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dsound\inc\wmvxmo.h ===
/*
 *  wmvxmo.h - Xbox WMV decoder XMO interfaces
 *
 *  Copyright (C) 2000-2001 Microsoft Corporation.  All Rights Reserved.
 *
 */

#ifndef _WMVXMO_H
#define _WMVXMO_H

typedef struct IWMVDecoder IWMVDecoder;
typedef IWMVDecoder* LPWMVDECODER;

//
// WMV decoder callback function for reading input data
//
typedef DWORD
(CALLBACK *LPFNWMVXMODATACALLBACK)(
    LPVOID pvContext,
    DWORD dwOffset,
    DWORD dwByteCount,
    LPVOID* ppvData
    );

//
// Function for creating WMV decoder instance
//
STDAPI
WmvCreateDecoder(
    IN LPCSTR pszFileName,
    IN LPFNWMVXMODATACALLBACK pfnCallback,
    IN DWORD dwVideoOutputFormat,
    IN LPVOID pvContext,
    OUT LPWMVDECODER* ppWmvDecoder
    );

//
// Supported video output format
//
#define WMVVIDEOFORMAT_YUY2     1

typedef struct _WMVVIDEOINFO {
    DWORD dwWidth;
    DWORD dwHeight;
    DWORD dwOutputBitsPerPixel;
    FLOAT fFramesPerSecond;
    DWORD dwBitsPerSecond;
} WMVVIDEOINFO, *PWMVVIDEOINFO, *LPWMVVIDEOINFO;

#undef INTERFACE
#define INTERFACE IWMVDecoder

DECLARE_INTERFACE_(IWMVDecoder, XMediaObject)
{
    // IUnknown methods
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // XMediaObject methods
    STDMETHOD(GetInfo)(THIS_ LPXMEDIAINFO pInfo) PURE;
    STDMETHOD(GetStatus)(THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Process)(THIS_ LPCXMEDIAPACKET pInputPacket, LPCXMEDIAPACKET pOutputPacket) PURE;
    STDMETHOD(Discontinuity)(THIS) PURE;
    STDMETHOD(Flush)(THIS) PURE;

    STDMETHOD(GetPlayDuration)(THIS_ PREFERENCE_TIME prtPlayDuration, PREFERENCE_TIME prtPreroll) PURE;
    STDMETHOD(GetVideoInfo)(THIS_ LPWMVVIDEOINFO pVideoInfo) PURE;
    STDMETHOD(GetAudioInfo)(THIS_ LPWAVEFORMATEX pAudioInfo) PURE;
    STDMETHOD(Seek)(THIS_ PREFERENCE_TIME prtSeekPosition) PURE;
    STDMETHOD(ProcessMultiple)(THIS_ LPCXMEDIAPACKET pVideoOutputPacket, LPCXMEDIAPACKET pAudioOutputPacket) PURE;
};

//
// WMV error codes
//
#define WMV_FACILITY_CODE 0x879
#define MAKE_WMVHRESULT(code) MAKE_HRESULT(SEVERITY_ERROR, WMV_FACILITY_CODE, code)
#define WMVERR_NO_AUDIO_STREAM  MAKE_WMVHRESULT(0x100)
#define WMVERR_NO_VIDEO_STREAM  MAKE_WMVHRESULT(0x101)

#endif // !_WMVXMO_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dmusic\inc\dmusics.h ===
/************************************************************************
*                                                                       *
*   dmusics.h -- Definitions for created a DirectMusic software synth   *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corporation
*                                                                       *
************************************************************************/

#ifndef _DMUSICS_
#define _DMUSICS_

#include "dmusicc.h"

/* Software synths are enumerated from under this registry key.
 */
#define REGSTR_PATH_SOFTWARESYNTHS  "Software\\Microsoft\\DirectMusic\\SoftwareSynths"

interface IDirectMusicSynth;
interface IDirectMusicSynthSink;

#ifndef __cplusplus 
typedef interface IDirectMusicSynth IDirectMusicSynth;
typedef interface IDirectMusicSynthSink IDirectMusicSynthSink;
#endif

#ifndef _DMUS_VOICE_STATE_DEFINED
#define _DMUS_VOICE_STATE_DEFINED

typedef struct _DMUS_VOICE_STATE
{
    BOOL                bExists;
    SAMPLE_POSITION     spPosition;
} DMUS_VOICE_STATE; 

#endif /* _DMUS_VOICE_STATE_DEFINED */

/* IDirectMusicSynth::Refresh
 *
 * This is the last buffer of the stream. It may be a partial block.
 */
#define REFRESH_F_LASTBUFFER        0x00000001

#undef  INTERFACE
#define INTERFACE  IDirectMusicSynth
DECLARE_INTERFACE_(IDirectMusicSynth, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSynth */
    STDMETHOD(Open)                 (THIS_ LPDMUS_PORTPARAMS pPortParams) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(SetNumChannelGroups)  (THIS_ DWORD dwGroups) PURE;
    STDMETHOD(Download)             (THIS_ LPHANDLE phDownload, 
                                           LPVOID pvData, 
                                           LPBOOL pbFree ) PURE;
    STDMETHOD(Unload)               (THIS_ HANDLE hDownload, 
                                           HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE), 
                                           HANDLE hUserData ) PURE; 
    STDMETHOD(PlayBuffer)           (THIS_ REFERENCE_TIME rt, 
                                           LPBYTE pbBuffer, 
                                           DWORD cbBuffer) PURE;
    STDMETHOD(GetRunningStats)      (THIS_ LPDMUS_SYNTHSTATS pStats) PURE;
    STDMETHOD(GetPortCaps)          (THIS_ LPDMUS_PORTCAPS pCaps) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(SetSynthSink)         (THIS_ IDirectMusicSynthSink *pSynthSink) PURE;
    STDMETHOD(Render)               (THIS_ short *pBuffer, 
                                           DWORD dwLength, 
                                           LONGLONG llPosition) PURE;
    STDMETHOD(SetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           DWORD dwPriority) PURE;
    STDMETHOD(GetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           LPDWORD pdwPriority) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pWaveFormatEx,
                                           LPDWORD pdwWaveFormatExSize) PURE;
    STDMETHOD(GetAppend)            (THIS_ DWORD* pdwAppend) PURE;
};

#undef  INTERFACE

#define INTERFACE  IDirectMusicSynth8
DECLARE_INTERFACE_(IDirectMusicSynth8, IDirectMusicSynth)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSynth */
    STDMETHOD(Open)                 (THIS_ LPDMUS_PORTPARAMS pPortParams) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(SetNumChannelGroups)  (THIS_ DWORD dwGroups) PURE;
    STDMETHOD(Download)             (THIS_ LPHANDLE phDownload, 
                                           LPVOID pvData, 
                                           LPBOOL pbFree ) PURE;
    STDMETHOD(Unload)               (THIS_ HANDLE hDownload, 
                                           HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE), 
                                           HANDLE hUserData ) PURE; 
    STDMETHOD(PlayBuffer)           (THIS_ REFERENCE_TIME rt, 
                                           LPBYTE pbBuffer, 
                                           DWORD cbBuffer) PURE;
    STDMETHOD(GetRunningStats)      (THIS_ LPDMUS_SYNTHSTATS pStats) PURE;
    STDMETHOD(GetPortCaps)          (THIS_ LPDMUS_PORTCAPS pCaps) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(SetSynthSink)         (THIS_ IDirectMusicSynthSink *pSynthSink) PURE;
    STDMETHOD(Render)               (THIS_ short *pBuffer, 
                                           DWORD dwLength, 
                                           LONGLONG llPosition) PURE;
    STDMETHOD(SetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           DWORD dwPriority) PURE;
    STDMETHOD(GetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           LPDWORD pdwPriority) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pWaveFormatEx,
                                           LPDWORD pdwWaveFormatExSize) PURE;
    STDMETHOD(GetAppend)            (THIS_ DWORD* pdwAppend) PURE;

	/* IDirectMusicSynth8 */
    STDMETHOD(PlayVoice)            (THIS_ REFERENCE_TIME rt, 
										   DWORD dwVoiceId, 
										   DWORD dwChannelGroup, 
										   DWORD dwChannel, 
										   DWORD dwDLId, 
										   long	 prPitch,			/* PREL not defined here */
										   long  vrVolume,          /* VREL not defined here */
                                           SAMPLE_TIME stVoiceStart,
                                           SAMPLE_TIME stLoopStart,
                                           SAMPLE_TIME stLoopEnd) PURE;

    STDMETHOD(StopVoice)            (THIS_ REFERENCE_TIME rt, 
										   DWORD dwVoiceId ) PURE;

    STDMETHOD(GetVoiceState)        (THIS_ DWORD dwVoice[], 
										   DWORD cbVoice,
										   DMUS_VOICE_STATE dwVoiceState[] ) PURE;
    STDMETHOD(Refresh)              (THIS_ DWORD dwDownloadID,
                                           DWORD dwFlags) PURE;
#ifdef XBOX
    STDMETHOD(IsReadyForData)       (THIS_ DWORD dwDownloadID) PURE;
#endif
#ifdef XBOX
    STDMETHOD(AssignChannelToOutput) (THIS_ DWORD dwChannelGroup,                   // Channel group and
		                                    DWORD dwChannel,                        // channel to assign
                                            IDirectSoundBuffer *pBuffer,            // Buffer, if assigned to buffer.
                                            DWORD dwMixBins,
                                            BYTE *pbMixBins)PURE;
#else
    STDMETHOD(AssignChannelToBuses) (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           LPDWORD pdwBuses,
                                           DWORD cBuses) PURE;   
#endif
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicSynthSink
DECLARE_INTERFACE_(IDirectMusicSynthSink, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSynthSink */
    STDMETHOD(Init)                 (THIS_ IDirectMusicSynth *pSynth) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(SampleToRefTime)      (THIS_ LONGLONG llSampleTime,
                                           REFERENCE_TIME *prfTime) PURE;
    STDMETHOD(RefTimeToSample)      (THIS_ REFERENCE_TIME rfTime, 
                                           LONGLONG *pllSampleTime) PURE;
    STDMETHOD(SetDirectSound)       (THIS_ LPDIRECTSOUND pDirectSound,
                                           LPDIRECTSOUNDBUFFER pDirectSoundBuffer) PURE;                                           
    STDMETHOD(GetDesiredBufferSize) (THIS_ LPDWORD pdwBufferSizeInSamples) PURE;                                           
};

DEFINE_GUID(IID_IDirectMusicSynth, 0x9823661,  0x5c85, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(IID_IDirectMusicSynth8,0x53cab625, 0x2711, 0x4c9f, 0x9d, 0xe7, 0x1b, 0x7f, 0x92, 0x5f, 0x6f, 0xc8);
DEFINE_GUID(IID_IDirectMusicSynthSink,0x9823663, 0x5c85, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

/* Property Set GUID_DMUS_PROP_SetSynthSink
 *
 * Item 0: An IUnknown on which the port can QueryInterface for a user-mode synth sink.
 */
DEFINE_GUID(GUID_DMUS_PROP_SetSynthSink,0x0a3a5ba5, 0x37b6, 0x11d2, 0xb9, 0xf9, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);

/* Property Set GUID_DMUS_PROP_SinkUsesDSound
 *
 * Item 0: A DWORD boolean indicating whether or not the sink requires an IDirectSound interface. The
 * default is FALSE if this property item is not implemented by the sink.
 */
DEFINE_GUID(GUID_DMUS_PROP_SinkUsesDSound, 0xbe208857, 0x8952, 0x11d2, 0xba, 0x1c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12); 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dplay\inc\dpaddr.h ===
/*==========================================================================;
 *
 *  Copyright (C) 2000 - 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpaddr.h
 *  Content:   DirectPlayAddress include file
 ***************************************************************************/

#ifndef __DIRECTPLAYADDRESS__
#define __DIRECTPLAYADDRESS__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <dplay8.h>


/****************************************************************************
 *
 * DirectPlay8Address Interface Pointer definitions
 *
 ****************************************************************************/

typedef struct IDirectPlay8Address IDirectPlay8Address;
typedef IDirectPlay8Address         *PDIRECTPLAY8ADDRESS, *LPDIRECTPLAY8ADDRESS;

/****************************************************************************
 *
 * DirectPlay8Address Forward Declarations For External Types
 *
 ****************************************************************************/

typedef struct sockaddr SOCKADDR;

/****************************************************************************
 *
 * DirectPlay8Address Constants
 *
 ****************************************************************************/
//
// Asynchronous operation flags
//
#define DPNA_DATATYPE_STRING                0x00000001
#define DPNA_DATATYPE_DWORD                 0x00000002
#define DPNA_DATATYPE_GUID                  0x00000003
#define DPNA_DATATYPE_BINARY                0x00000004
#define DPNA_DATATYPE_STRING_ANSI           0x00000005

#define DPNA_INDEX_INVALID                  0xFFFFFFFF

/****************************************************************************
 *
 * DirectPlay8Address Address Elements
 *
 ****************************************************************************/

#define DPNA_DPNSVR_PORT                                      6073

#define DPNA_SEPARATOR_KEYVALUE             L'='
#define DPNA_SEPARATOR_USERDATA             L'#'
#define DPNA_SEPARATOR_COMPONENT            L';'
#define DPNA_ESCAPECHAR                     L'%'

// Header
#define DPNA_HEADER                         L"x-directplay:/"

// key names for address components
#define DPNA_KEY_APPLICATION_INSTANCE       L"applicationinstance"
#define DPNA_KEY_BAUD                       L"baud"
#define DPNA_KEY_DEVICE                     L"device"
#define DPNA_KEY_FLOWCONTROL                L"flowcontrol"
#define DPNA_KEY_HOSTNAME                   L"hostname"
#define DPNA_KEY_PARITY                     L"parity"
#define DPNA_KEY_PHONENUMBER                L"phonenumber"
#define DPNA_KEY_PORT                       L"port"
#define DPNA_KEY_PROGRAM                    L"program"
#define DPNA_KEY_PROVIDER                   L"provider"
#define DPNA_KEY_STOPBITS                   L"stopbits"

//// ANSI DEFINITIONS

// Header
#define DPNA_HEADER_A                       "x-directplay:/"
#define DPNA_SEPARATOR_KEYVALUE_A           '='
#define DPNA_SEPARATOR_USERDATA_A           '#'
#define DPNA_SEPARATOR_COMPONENT_A          ';'
#define DPNA_ESCAPECHAR_A                   '%'

// key names for address components
#define DPNA_KEY_APPLICATION_INSTANCE_A     "applicationinstance"
#define DPNA_KEY_BAUD_A                     "baud"
#define DPNA_KEY_DEVICE_A                   "device"
#define DPNA_KEY_FLOWCONTROL_A              "flowcontrol"
#define DPNA_KEY_HOSTNAME_A                 "hostname"
#define DPNA_KEY_PARITY_A                   "parity"
#define DPNA_KEY_PHONENUMBER_A              "phonenumber"
#define DPNA_KEY_PORT_A                     "port"
#define DPNA_KEY_PROGRAM_A                  "program"
#define DPNA_KEY_PROVIDER_A                 "provider"
#define DPNA_KEY_STOPBITS_A                 "stopbits"

// Shortcut values
//
// These can be used instead of the corresponding CLSID_DP8SP_XXXX guids
//
#define DPNA_VALUE_TCPIPPROVIDER            L"IP"
#define DPNA_VALUE_TCPIPPROVIDER_A            "IP"

#define IID_IDirectPlay8Address		0
#define IID_IDirectPlay8AddressIP	1

/****************************************************************************
 *
 * DirectPlay8Address Functions
 *
 ****************************************************************************/

extern HRESULT WINAPI DirectPlay8AddressCreate( DWORD dwIID, void ** ppvInterface, void **pUnknown);

/****************************************************************************
 *
 * DirectPlay8Address Application Interfaces
 *
 ****************************************************************************/

// IUnknown methods
ULONG WINAPI IDirectPlay8Address_AddRef(LPDIRECTPLAY8ADDRESS pDirectPlay8Address);
ULONG WINAPI IDirectPlay8Address_Release(LPDIRECTPLAY8ADDRESS pDirectPlay8Address);

// IDirectPlay8Address methods
HRESULT WINAPI IDirectPlay8Address_BuildFromURLW(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, WCHAR *pwszSourceURL);
HRESULT WINAPI IDirectPlay8Address_BuildFromURLA(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, CHAR *pszSourceURL);
HRESULT WINAPI IDirectPlay8Address_Duplicate(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, PDIRECTPLAY8ADDRESS *ppdpaNewAddress);
HRESULT WINAPI IDirectPlay8Address_SetEqual(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, PDIRECTPLAY8ADDRESS pdpaAddress);
HRESULT WINAPI IDirectPlay8Address_IsEqual(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, PDIRECTPLAY8ADDRESS pdpaAddress);
HRESULT WINAPI IDirectPlay8Address_Clear(LPDIRECTPLAY8ADDRESS pDirectPlay8Address);
HRESULT WINAPI IDirectPlay8Address_GetURLW(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, WCHAR *pwszURL, PDWORD pdwNumChars);
HRESULT WINAPI IDirectPlay8Address_GetURLA(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, CHAR *pszURL, PDWORD pdwNumChars);
HRESULT WINAPI IDirectPlay8Address_GetSP(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, GUID *pguidSP);
HRESULT WINAPI IDirectPlay8Address_GetUserData(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, void *pvUserData, PDWORD pdwBufferSize);
HRESULT WINAPI IDirectPlay8Address_SetSP(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, const GUID *const pguidSP);
HRESULT WINAPI IDirectPlay8Address_SetUserData(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, const void * const pvUserData, const DWORD dwDataSize);
HRESULT WINAPI IDirectPlay8Address_GetNumComponents(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, PDWORD pdwNumComponents);
HRESULT WINAPI IDirectPlay8Address_GetComponentByName(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, const WCHAR * const pwszName, void *pvBuffer, PDWORD pdwBufferSize, PDWORD pdwDataType);
HRESULT WINAPI IDirectPlay8Address_GetComponentByIndex(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, const DWORD dwComponentID, WCHAR * pwszName, PDWORD pdwNameLen, void *pvBuffer, PDWORD pdwBufferSize, PDWORD pdwDataType);
HRESULT WINAPI IDirectPlay8Address_AddComponent(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, const WCHAR * const pwszName, const void * const lpvData, const DWORD dwDataSize, const DWORD dwDataType);
HRESULT WINAPI IDirectPlay8Address_GetDevice(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, GUID *pGUID);
HRESULT WINAPI IDirectPlay8Address_SetDevice(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, const GUID * const pGUID);
HRESULT WINAPI IDirectPlay8Address_BuildFromSockAddr(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, const SOCKADDR * const pSockAddr);
HRESULT WINAPI IDirectPlay8Address_BuildAddress(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, const WCHAR * const wszAddress, const USHORT usPort);
HRESULT WINAPI IDirectPlay8Address_BuildLocalAddress(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, const GUID * const pguidAdapter, const USHORT usPort);
HRESULT WINAPI IDirectPlay8Address_GetSockAddress(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, SOCKADDR *pSockAddr, PDWORD pDword);
HRESULT WINAPI IDirectPlay8Address_GetLocalAddress(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, GUID *pguidAdapter, USHORT *pusPort);
HRESULT WINAPI IDirectPlay8Address_GetAddress(LPDIRECTPLAY8ADDRESS pDirectPlay8Address, WCHAR *wszAddress, PDWORD pdwAddressLength, USHORT *psPort);

#ifdef __cplusplus

// IDirectPlay8Address wrapper class
struct IDirectPlay8Address
{
    __inline ULONG STDMETHODCALLTYPE AddRef(void)
    {
        return IDirectPlay8Address_AddRef(this);
    }

    __inline ULONG STDMETHODCALLTYPE Release(void)
    {
        return IDirectPlay8Address_Release(this);
    }

    __inline HRESULT STDMETHODCALLTYPE QueryInterface(DWORD riid, LPVOID *ppvObj)
    {
	if (ppvObj != NULL)
            *ppvObj = this;

        return S_OK;
    }

    __inline HRESULT STDMETHODCALLTYPE BuildFromURLW(WCHAR *pwszSourceURL)
    {
        return IDirectPlay8Address_BuildFromURLW(this, pwszSourceURL);
    }

    __inline HRESULT STDMETHODCALLTYPE BuildFromURLA(CHAR *pszSourceURL)
    {
        return IDirectPlay8Address_BuildFromURLA(this, pszSourceURL);
    }

    __inline HRESULT STDMETHODCALLTYPE Duplicate(PDIRECTPLAY8ADDRESS *ppdpaNewAddress)
    {
        return IDirectPlay8Address_Duplicate(this, ppdpaNewAddress);
    }

    __inline HRESULT STDMETHODCALLTYPE SetEqual(PDIRECTPLAY8ADDRESS pdpaAddress)
    {
        return IDirectPlay8Address_SetEqual(this, pdpaAddress);
    }

    __inline HRESULT STDMETHODCALLTYPE IsEqual(PDIRECTPLAY8ADDRESS pdpaAddress)
    {
        return IDirectPlay8Address_IsEqual(this, pdpaAddress);
    }

    __inline HRESULT STDMETHODCALLTYPE Clear(void)
    {
        return IDirectPlay8Address_Clear(this);
    }

    __inline HRESULT STDMETHODCALLTYPE GetURLW(WCHAR *pwszURL, PDWORD pdwNumChars)
    {
        return IDirectPlay8Address_GetURLW(this, pwszURL, pdwNumChars);
    }

    __inline HRESULT STDMETHODCALLTYPE GetURLA(CHAR *pszURL, PDWORD pdwNumChars)
    {
        return IDirectPlay8Address_GetURLA(this, pszURL, pdwNumChars);
    }

    __inline HRESULT STDMETHODCALLTYPE GetSP(GUID *pguidSP)
    {
        return IDirectPlay8Address_GetSP(this, pguidSP);
    }

    __inline HRESULT STDMETHODCALLTYPE GetUserData(void *pvUserData, PDWORD pdwBufferSize)
    {
        return IDirectPlay8Address_GetUserData(this, pvUserData, pdwBufferSize);
    }

    __inline HRESULT STDMETHODCALLTYPE SetSP(const GUID *const pguidSP)
    {
        return IDirectPlay8Address_SetSP(this, pguidSP);
    }

    __inline HRESULT STDMETHODCALLTYPE SetUserData(const void * const pvUserData, const DWORD dwDataSize)
    {
        return IDirectPlay8Address_SetUserData(this, pvUserData, dwDataSize);
    }

    __inline HRESULT STDMETHODCALLTYPE GetNumComponents(PDWORD pdwNumComponents)
    {
        return IDirectPlay8Address_GetNumComponents(this, pdwNumComponents);
    }

    __inline HRESULT STDMETHODCALLTYPE GetComponentByName(const WCHAR * const pwszName, void *pvBuffer, PDWORD pdwBufferSize, PDWORD pdwDataType)
    {
        return IDirectPlay8Address_GetComponentByName(this, pwszName, pvBuffer, pdwBufferSize, pdwDataType);
    }

    __inline HRESULT STDMETHODCALLTYPE GetComponentByIndex(const DWORD dwComponentID, WCHAR * pwszName, PDWORD pdwNameLen, void *pvBuffer, PDWORD pdwBufferSize, PDWORD pdwDataType)
    {
        return IDirectPlay8Address_GetComponentByIndex(this, dwComponentID, pwszName, pdwNameLen, pvBuffer, pdwBufferSize, pdwDataType);
    }

    __inline HRESULT STDMETHODCALLTYPE AddComponent(const WCHAR * const pwszName, const void * const lpvData, const DWORD dwDataSize, const DWORD dwDataType)
    {
        return IDirectPlay8Address_AddComponent(this, pwszName, lpvData, dwDataSize, dwDataType);
    }

    __inline HRESULT STDMETHODCALLTYPE GetDevice(GUID *pGUID)
    {
        return IDirectPlay8Address_GetDevice(this, pGUID);
    }

    __inline HRESULT STDMETHODCALLTYPE SetDevice(const GUID * const pGUID)
    {
        return IDirectPlay8Address_SetDevice(this, pGUID);
    }

    // Constructs a IDirectPlay8 TCP Address from a SOCKADDR structure
    __inline HRESULT STDMETHODCALLTYPE BuildFromSockAddr(const SOCKADDR * const pSockAddr)
    {
        return IDirectPlay8Address_BuildFromSockAddr(this, pSockAddr);
    }

    // Constructs a TCP Address from a string (hostname) and port
    __inline HRESULT STDMETHODCALLTYPE BuildAddress(const WCHAR * const wszAddress, const USHORT usPort)
    {
        return IDirectPlay8Address_BuildAddress(this, wszAddress, usPort);
    }

    // Builds a local TCP Address
    __inline HRESULT STDMETHODCALLTYPE BuildLocalAddress(const GUID * const pguidAdapter, const USHORT usPort)
    {
        return IDirectPlay8Address_BuildLocalAddress(this, pguidAdapter, usPort);
    }

    // Gets the address from the structure in SOCKADR format
    __inline HRESULT STDMETHODCALLTYPE GetSockAddress(SOCKADDR *pSockAddr, PDWORD pDword)
    {
        return IDirectPlay8Address_GetSockAddress(this, pSockAddr, pDword);
    }

    // Gets the local afddress
    __inline HRESULT STDMETHODCALLTYPE GetLocalAddress(GUID *pguidAdapter, USHORT *pusPort)
    {
        return IDirectPlay8Address_GetLocalAddress(this, pguidAdapter, pusPort);
    }

    // Gets the remote address
    __inline HRESULT STDMETHODCALLTYPE GetAddress(WCHAR *wszAddress, PDWORD pdwAddressLength, USHORT *psPort)
    {
        return IDirectPlay8Address_GetAddress(this, wszAddress, pdwAddressLength, psPort);
    }

};

#endif // __cplusplus

#ifdef __cplusplus
}
#endif // __cplusplus

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dsound\inc\makefile.inc ===
headers: clean \
         $(PRIVATE_INC_PATH)\dsoundp.h \
         $(SDK_INC_PATH)\dsound.h \
         $(XDK_INC_PATH)\dsound.h \
         $(PRIVATE_INC_PATH)\dsfxparmp.h \
         $(SDK_INC_PATH)\dsfxparm.h \
         $(XDK_INC_PATH)\dsfxparm.h \
         $(SDK_INC_PATH)\wmvxmo.h \
         $(XDK_INC_PATH)\wmvxmo.h \
         $(SDK_INC_PATH)\wavbndlr.h \
         $(XDK_INC_PATH)\wavbndlr.h

$(PRIVATE_INC_PATH)\dsoundp.h: dsound.x
    copy $? $@

$(SDK_INC_PATH)\dsound.h: dsound.x
    sed "/@@BEGIN_MSINTERNAL/,/@@END_MSINTERNAL/D" $? > $@

$(XDK_INC_PATH)\dsound.h: $(SDK_INC_PATH)\dsound.h
    copy $? $@

$(PRIVATE_INC_PATH)\dsfxparmp.h: dsfxparm.x
    copy $? $@

$(SDK_INC_PATH)\dsfxparm.h: dsfxparm.x
    sed "/@@BEGIN_MSINTERNAL/,/@@END_MSINTERNAL/D" $? > $@

$(XDK_INC_PATH)\dsfxparm.h: $(SDK_INC_PATH)\dsfxparm.h
    copy $? $@

$(SDK_INC_PATH)\wmvxmo.h: wmvxmo.h
    copy $? $@

$(XDK_INC_PATH)\wmvxmo.h: $(SDK_INC_PATH)\wmvxmo.h
    copy $? $@

$(SDK_INC_PATH)\wavbndlr.h: wavbndlr.h
    copy $? $@

$(XDK_INC_PATH)\wavbndlr.h: $(SDK_INC_PATH)\wavbndlr.h
    copy $? $@

clean:
    if exist $(PRIVATE_INC_PATH)\dsoundp.h      del /f /q $(PRIVATE_INC_PATH)\dsoundp.h
    if exist $(SDK_INC_PATH)\dsound.h           del /f /q $(SDK_INC_PATH)\dsound.h
    if exist $(XDK_INC_PATH)\dsound.h           del /f /q $(XDK_INC_PATH)\dsound.h
    if exist $(PRIVATE_INC_PATH)\dsfxparmp.h    del /f /q $(PRIVATE_INC_PATH)\dsfxparmp.h
    if exist $(SDK_INC_PATH)\dsfxparm.h         del /f /q $(SDK_INC_PATH)\dsfxparm.h
    if exist $(XDK_INC_PATH)\dsfxparm.h         del /f /q $(XDK_INC_PATH)\dsfxparm.h
    if exist $(SDK_INC_PATH)\wmvxmo.h           del /f /q $(SDK_INC_PATH)\wmvxmo.h
    if exist $(XDK_INC_PATH)\wmvxmo.h           del /f /q $(XDK_INC_PATH)\wmvxmo.h
    if exist $(SDK_INC_PATH)\wavbnldr.h         del /f /q $(SDK_INC_PATH)\wavbnldr.h
    if exist $(XDK_INC_PATH)\wavbnldr.h         del /f /q $(XDK_INC_PATH)\wavbnldr.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dxg\d3dx8effect.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 - 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8effect.h
//  Content:    D3DX effect types and functions
//
///////////////////////////////////////////////////////////////////////////

#include "d3dx8.h"

#ifndef __D3DX8EFFECT_H__
#define __D3DX8EFFECT_H__


typedef enum _D3DXPARAMETERTYPE
{
    D3DXPT_DWORD        = 0,
    D3DXPT_FLOAT        = 1,
    D3DXPT_VECTOR       = 2,
    D3DXPT_MATRIX       = 3,
    D3DXPT_TEXTURE      = 4,
    D3DXPT_VERTEXSHADER = 5,
    D3DXPT_PIXELSHADER  = 6,
    D3DXPT_CONSTANT     = 7,
    D3DXPT_FORCE_DWORD  = 0x7fffffff /* force 32-bit size enum */

} D3DXPARAMETERTYPE;


typedef struct _D3DXEFFECT_DESC
{
    UINT Parameters;
    UINT Techniques;
    DWORD Usage;

} D3DXEFFECT_DESC;


typedef struct _D3DXPARAMETER_DESC
{
    DWORD Name;
    D3DXPARAMETERTYPE Type;

} D3DXPARAMETER_DESC;


typedef struct _D3DXTECHNIQUE_DESC
{
    DWORD Name;
    UINT Passes;

} D3DXTECHNIQUE_DESC;


typedef struct _D3DXPASS_DESC
{
    DWORD Name;

} D3DXPASS_DESC;


typedef struct ID3DXEffect *LPD3DXEFFECT;
typedef struct ID3DXTechnique *LPD3DXTECHNIQUE;




//////////////////////////////////////////////////////////////////////////////
// ID3DXTechnique ////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

// {A00F378D-AF79-4917-907E-4D635EE63844}
DEFINE_GUID( IID_ID3DXTechnique,
0xa00f378d, 0xaf79, 0x4917, 0x90, 0x7e, 0x4d, 0x63, 0x5e, 0xe6, 0x38, 0x44);


DECLARE_INTERFACE_(ID3DXTechnique, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXTechnique
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DXTECHNIQUE_DESC* pDesc) PURE;
    STDMETHOD(GetPassDesc)(THIS_ UINT Index, D3DXPASS_DESC* pDesc) PURE;

    STDMETHOD_(BOOL, IsParameterUsed)(THIS_ DWORD dwName) PURE;

    STDMETHOD(Validate)(THIS) PURE;
    STDMETHOD(Begin)(THIS_ UINT *pPasses) PURE;
    STDMETHOD(Pass)(THIS_ UINT Index) PURE;
    STDMETHOD(End)(THIS) PURE;
};


//////////////////////////////////////////////////////////////////////////////
// ID3DXEffect ///////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


// {281BBDD4-AEDF-4907-8650-E79CDFD45165}
DEFINE_GUID( IID_ID3DXEffect,
0x281bbdd4, 0xaedf, 0x4907, 0x86, 0x50, 0xe7, 0x9c, 0xdf, 0xd4, 0x51, 0x65);


DECLARE_INTERFACE_(ID3DXEffect, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXEffect
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DXEFFECT_DESC* pDesc) PURE;

    STDMETHOD(GetParameterDesc)(THIS_ UINT Index, D3DXPARAMETER_DESC* pDesc) PURE;
    STDMETHOD(GetTechniqueDesc)(THIS_ UINT Index, D3DXTECHNIQUE_DESC* pDesc) PURE;

    STDMETHOD(SetDword)(THIS_ DWORD Name, DWORD dw) PURE;
    STDMETHOD(GetDword)(THIS_ DWORD Name, DWORD* pdw) PURE;
    STDMETHOD(SetFloat)(THIS_ DWORD Name, FLOAT f) PURE;
    STDMETHOD(GetFloat)(THIS_ DWORD Name, FLOAT* pf) PURE;
    STDMETHOD(SetVector)(THIS_ DWORD Name, D3DXVECTOR4* pVector) PURE;
    STDMETHOD(GetVector)(THIS_ DWORD Name, D3DXVECTOR4* pVector) PURE;
    STDMETHOD(SetMatrix)(THIS_ DWORD Name, D3DXMATRIX* pMatrix) PURE;
    STDMETHOD(GetMatrix)(THIS_ DWORD Name, D3DXMATRIX* pMatrix) PURE;
    STDMETHOD(SetTexture)(THIS_ DWORD Name, LPDIRECT3DBASETEXTURE8 pTexture) PURE;
    STDMETHOD(GetTexture)(THIS_ DWORD Name, LPDIRECT3DBASETEXTURE8 *ppTexture) PURE;
    STDMETHOD(SetVertexShader)(THIS_ DWORD Name, DWORD Handle) PURE;
    STDMETHOD(GetVertexShader)(THIS_ DWORD Name, DWORD* pHandle) PURE;
    STDMETHOD(SetPixelShader)(THIS_ DWORD Name, DWORD Handle) PURE;
    STDMETHOD(GetPixelShader)(THIS_ DWORD Name, DWORD* pHandle) PURE;

    STDMETHOD(GetTechnique)(THIS_ UINT Index, LPD3DXTECHNIQUE* ppTechnique) PURE;
    STDMETHOD(CloneEffect)(THIS_ LPDIRECT3DDEVICE8 pDevice, DWORD Usage, LPD3DXEFFECT* ppEffect) PURE;
};



//////////////////////////////////////////////////////////////////////////////
// APIs //////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


#ifdef __cplusplus
extern "C" {
#endif //__cplusplus


//----------------------------------------------------------------------------
// D3DXCompileEffect:
// ------------------
// Compiles an ascii effect description into a binary form usable by
// D3DXCreateEffect.
//
// Parameters:
//  pSrcFile
//      Name of the file containing the ascii effect description
//  pSrcData
//      Pointer to ascii effect description
//  SrcDataSize
//      Size of the effect description in bytes
//  ppCompiledEffect
//      Returns a buffer containing compiled effect.
//  ppCompilationErrors
//      Returns a buffer containing any error messages which occurred during
//      compile.  Or NULL if you do not care about the error messages.
//
//----------------------------------------------------------------------------

HRESULT WINAPI
    D3DXCompileEffectFromFileA(
        LPCSTR            pSrcFile,
        LPD3DXBUFFER*     ppCompiledEffect,
        LPD3DXBUFFER*     ppCompilationErrors);

#define D3DXCompileEffectFromFile D3DXCompileEffectFromFileA


HRESULT WINAPI
    D3DXCompileEffect(
        LPCVOID           pSrcData,
        UINT              SrcDataSize,
        LPD3DXBUFFER*     ppCompiledEffect,
        LPD3DXBUFFER*     ppCompilationErrors);



//----------------------------------------------------------------------------
// D3DXCreateEffect:
// -----------------
// Creates an effect object, given compiled binary effect data
//
// Parameters:
//  pDevice
//      Pointer to the device to be used.
//  pCompiledEffect
//      Pointer to compiled effect data
//  CompiledEffectSize
//      Size of compiled effect data in bytes
//  Usage
//      Allows the specification of D3DUSAGE_SOFTWAREPROCESSING
//  ppEffect
//      Returns the created effect object
//----------------------------------------------------------------------------


HRESULT WINAPI
    D3DXCreateEffect(
        LPDIRECT3DDEVICE8 pDevice,
        LPCVOID           pCompiledEffect,
        UINT              CompiledEffectSize,
        DWORD             Usage,
        LPD3DXEFFECT*     ppEffect);



#ifdef __cplusplus
}
#endif //__cplusplus

#endif //__D3DX8EFFECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dvoice\inc\makefile.inc ===
dvoice.h: dvoice.x
    sed "/@@BEGIN_MSINTERNAL/,/@@END_MSINTERNAL/D" $? > $@

$(PRIVATE_INC_PATH)\dvoicep.h: dvoice.x
    copy $? $@

{}.h{$(SDK_INC_PATH)}.h:
    copy $** $@

{}.h{$(XDK_INC_PATH)}.h:
    copy $** $@

clean:
	del /F /Q $(NTTARGETFILE0)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dsound\inc\wavbndlr.h ===
/***************************************************************************
 *
 *  Copyright (C) 11/2/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       wavbndlr.h
 *  Content:    Wave Bundler definitions.
 *
 ****************************************************************************/

#ifndef __WAVBNDLR_H__
#define __WAVBNDLR_H__

//
// Wave bank entry compressed data format
//

#define WAVEBANKMINIFORMAT_TAG_PCM      0x0 // PCM data
#define WAVEBANKMINIFORMAT_TAG_ADPCM    0x1 // ADPCM data

#define WAVEBANKMINIFORMAT_BITDEPTH_4   0x0 // 4-bit data (ADPCM only)
#define WAVEBANKMINIFORMAT_BITDEPTH_8   0x0 // 8-bit data (PCM only)
#define WAVEBANKMINIFORMAT_BITDEPTH_16  0x1 // 16-bit data (PCM only)

typedef struct _WAVEBANKMINIWAVEFORMAT
{
    DWORD       wFormatTag      : 1;    // PCM vs. ADPCM
    DWORD       nChannels       : 3;    // Channel count (1 - 6)
    DWORD       nSamplesPerSec  : 27;   // Sampling rate
    DWORD       wBitsPerSample  : 1;    // Bits per sample (8 vs. 16, PCM only)
} WAVEBANKMINIWAVEFORMAT, *LPWAVEBANKMINIWAVEFORMAT;

typedef const WAVEBANKMINIWAVEFORMAT *LPCWAVEBANKMINIWAVEFORMAT;

// 
// Wave bank expanded wave format
//

typedef union _WAVEBANKUNIWAVEFORMAT
{
    WAVEFORMATEX        WaveFormatEx;
    XBOXADPCMWAVEFORMAT AdpcmWaveFormat;
} WAVEBANKUNIWAVEFORMAT, *LPWAVEBANKUNIWAVEFORMAT;

typedef const WAVEBANKUNIWAVEFORMAT *LPCWAVEBANKUNIWAVEFORMAT;

//
// Wave bank entry region indices
//

typedef struct _WAVEBANKENTRYREGION
{
    DWORD           dwStart;                // Starting byte offset
    DWORD           dwLength;               // Region length, in bytes
} WAVEBANKENTRYREGION, *LPWAVEBANKENTRYREGION;

typedef const WAVEBANKENTRYREGION *LPCWAVEBANKENTRYREGION;

//
// Wave bank entry meta-data
//

typedef struct _WAVEBANKENTRY
{
    WAVEBANKMINIWAVEFORMAT Format;         // Entry format
    WAVEBANKENTRYREGION    PlayRegion;     // Offsets from the start of the data segment that contains this entry
    WAVEBANKENTRYREGION    LoopRegion;     // Offests relative to the play region that contains the loop region
} WAVEBANKENTRY, *LPWAVEBANKENTRY;

typedef const WAVEBANKENTRY *LPCWAVEBANKENTRY;

//
// Wave bank flags
//

#define WAVEBANK_TYPE_BUFFER            0x00000000
#define WAVEBANK_TYPE_STREAMING         0x00000001
#define WAVEBANK_TYPE_MASK              0x00000001

//
// Wave bank file header
//

#define WAVEBANKHEADER_SIGNATURE        'DNBW'
#define WAVEBANKHEADER_VERSION          2
#define WAVEBANKHEADER_BANKNAME_LENGTH  16

typedef struct _WAVEBANKHEADER
{
    DWORD           dwSignature;                                // File signature
    DWORD           dwVersion;                                  // Version of the tool that created the file
    DWORD           dwFlags;                                    // Wave bank flags (currently unused)
    DWORD           dwEntryCount;                               // Number of entries in the bank
    DWORD           dwAlignment;                                // Entry alignment
    CHAR            szBankName[WAVEBANKHEADER_BANKNAME_LENGTH]; // Bank identifier string
} WAVEBANKHEADER, *LPWAVEBANKHEADER;

typedef const WAVEBANKHEADER *LPCWAVEBANKHEADER;

//
// Wave bank section data
//

typedef struct _WAVEBANKSECTIONDATA
{
    LPWAVEBANKHEADER    pHeader;            // File header
    LPWAVEBANKENTRY     paMetaData;         // Array of entry meta-data
    LPVOID              pvData;             // Wave data base address
    DWORD               dwDataSize;         // Wave data size, in bytes
} WAVEBANKSECTIONDATA, *LPWAVEBANKSECTIONDATA;

typedef const WAVEBANKSECTIONDATA *LPCWAVEBANKSECTIONDATA;

//
// Helper functions
//

EXTERN_C BOOL WaveBankExpandFormat(LPCWAVEBANKMINIWAVEFORMAT pwfxCompressed, LPWAVEBANKUNIWAVEFORMAT pwfxExpanded);
EXTERN_C BOOL WaveBankCompressFormat(LPCWAVEBANKUNIWAVEFORMAT pwfxExpanded, LPWAVEBANKMINIWAVEFORMAT pwfxCompressed);

#ifdef __cplusplus

//
// Wave bank reader object
//

class CWaveBankReader
{
private:
    LPVOID                  m_pvBaseAddress;    // Bank base address
    DWORD                   m_dwBankSize;       // Bank size, in bytes

public:
    CWaveBankReader(void);
    virtual ~CWaveBankReader(void);

public:
    // Initialization
    HRESULT Open(LPCSTR pszBankPath);
    void Flush(void);

    // Bank data
    void GetSectionData(LPWAVEBANKSECTIONDATA pSectionData);
};

#endif // __cplusplus

#endif // __WAVBNDLR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dxg\d3dx8shape.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 - 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8shapes.h
//  Content:    D3DX simple shapes
//
///////////////////////////////////////////////////////////////////////////

#include "d3dx8.h"

#ifndef __D3DX8SHAPES_H__
#define __D3DX8SHAPES_H__

///////////////////////////////////////////////////////////////////////////
// Functions:
///////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus


//-------------------------------------------------------------------------
// D3DXCreatePolygon:
// ------------------
// Creates a mesh containing an n-sided polygon.  The polygon is centered
// at the origin.
//
// Parameters:
//
//  pDevice     The D3D device with which the mesh is going to be used.
//  Length      Length of each side.
//  Sides       Number of sides the polygon has.  (Must be >= 3)
//  ppMesh      The mesh object which will be created
//  ppAdjacency Returns a buffer containing adjacency info.  Can be NULL.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreatePolygon(
        LPDIRECT3DDEVICE8   pDevice,
        FLOAT               Length,
        UINT                Sides,
        LPD3DXMESH*         ppMesh,
        LPD3DXBUFFER*       ppAdjacency);


//-------------------------------------------------------------------------
// D3DXCreateBox:
// --------------
// Creates a mesh containing an axis-aligned box.  The box is centered at
// the origin.
//
// Parameters:
//
//  pDevice     The D3D device with which the mesh is going to be used.
//  Width       Width of box (along X-axis)
//  Height      Height of box (along Y-axis)
//  Depth       Depth of box (along Z-axis)
//  ppMesh      The mesh object which will be created
//  ppAdjacency Returns a buffer containing adjacency info.  Can be NULL.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateBox(
        LPDIRECT3DDEVICE8   pDevice,
        FLOAT               Width,
        FLOAT               Height,
        FLOAT               Depth,
        LPD3DXMESH*         ppMesh,
        LPD3DXBUFFER*       ppAdjacency);


//-------------------------------------------------------------------------
// D3DXCreateCylinder:
// -------------------
// Creates a mesh containing a cylinder.  The generated cylinder is
// centered at the origin, and its axis is aligned with the Z-axis.
//
// Parameters:
//
//  pDevice     The D3D device with which the mesh is going to be used.
//  Radius1     Radius at -Z end (should be >= 0.0f)
//  Radius2     Radius at +Z end (should be >= 0.0f)
//  Length      Length of cylinder (along Z-axis)
//  Slices      Number of slices about the main axis
//  Stacks      Number of stacks along the main axis
//  ppMesh      The mesh object which will be created
//  ppAdjacency Returns a buffer containing adjacency info.  Can be NULL.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateCylinder(
        LPDIRECT3DDEVICE8   pDevice,
        FLOAT               Radius1,
        FLOAT               Radius2,
        FLOAT               Length,
        UINT                Slices,
        UINT                Stacks,
        LPD3DXMESH*         ppMesh,
        LPD3DXBUFFER*       ppAdjacency);


//-------------------------------------------------------------------------
// D3DXCreateSphere:
// -----------------
// Creates a mesh containing a sphere.  The sphere is centered at the
// origin.
//
// Parameters:
//
//  pDevice     The D3D device with which the mesh is going to be used.
//  Radius      Radius of the sphere (should be >= 0.0f)
//  Slices      Number of slices about the main axis
//  Stacks      Number of stacks along the main axis
//  ppMesh      The mesh object which will be created
//  ppAdjacency Returns a buffer containing adjacency info.  Can be NULL.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateSphere(
        LPDIRECT3DDEVICE8  pDevice,
        FLOAT              Radius,
        UINT               Slices,
        UINT               Stacks,
        LPD3DXMESH*        ppMesh,
        LPD3DXBUFFER*      ppAdjacency);


//-------------------------------------------------------------------------
// D3DXCreateTorus:
// ----------------
// Creates a mesh containing a torus.  The generated torus is centered at
// the origin, and its axis is aligned with the Z-axis.
//
// Parameters:
//
//  pDevice     The D3D device with which the mesh is going to be used.
//  InnerRadius Inner radius of the torus (should be >= 0.0f)
//  OuterRadius Outer radius of the torue (should be >= 0.0f)
//  Sides       Number of sides in a cross-section (must be >= 3)
//  Rings       Number of rings making up the torus (must be >= 3)
//  ppMesh      The mesh object which will be created
//  ppAdjacency Returns a buffer containing adjacency info.  Can be NULL.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateTorus(
        LPDIRECT3DDEVICE8   pDevice,
        FLOAT               InnerRadius,
        FLOAT               OuterRadius,
        UINT                Sides,
        UINT                Rings,
        LPD3DXMESH*         ppMesh,
        LPD3DXBUFFER*       ppAdjacency);


//-------------------------------------------------------------------------
// D3DXCreateTeapot:
// -----------------
// Creates a mesh containing a teapot.
//
// Parameters:
//
//  pDevice     The D3D device with which the mesh is going to be used.
//  ppMesh      The mesh object which will be created
//  ppAdjacency Returns a buffer containing adjacency info.  Can be NULL.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateTeapot(
        LPDIRECT3DDEVICE8   pDevice,
        LPD3DXMESH*         ppMesh,
        LPD3DXBUFFER*       ppAdjacency);


#ifdef __cplusplus
}
#endif //__cplusplus

#endif //__D3DX8SHAPES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dxg\d3dx.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx.h
//  Content:    D3DX utility library
//
///////////////////////////////////////////////////////////////////////////

#ifndef __D3DX_H__
#define __D3DX_H__

#ifndef D3DXINLINE
#ifdef __cplusplus
#define D3DXINLINE inline
#else
#define D3DXINLINE _inline
#endif
#endif

#include "d3dxcore.h"
#include "d3dxmath.h"
#include "d3dxshapes.h"
#include "d3dxsprite.h"

#endif //__D3DX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dxg\d3ddm.hpp ===
#ifndef _D3DDM_HPP
#define _D3DDM_HPP

#define D3DDM_VERSION       0xDBDB0003      // version tag

// base names for shared memory segments
#define D3DDM_TGTCTX_SM     "D3DDM_DTC_"    // tgt pid
#define D3DDM_MONCTX_SM     "D3DDM_DMC_"    // mon id
#define D3DDM_CMDDATA_SM    "D3DDM_CD_"     // mon id
#define D3DDM_TSHFILE_SM    "D3DDM_TSF_"    // tgt pid; target shader -> file association
#define D3DDM_IMAGE_SM      "D3DDM_I_"      // 0..n

// base names for events
#define D3DDM_TGT_EVENTBP   "D3DDM_TEBP_"   // tgt pid
#define D3DDM_TGT_EVENTACK  "D3DDM_TEACK_"  // tgt pid
#define D3DDM_MON_EVENTCMD  "D3DDM_MECMD_"  // mon id

#define D3DDM_MAX_BP   32    // max number of breakpoints for all types

// event definitions - can set more than one in single word so they
// can be used as breakpoint enables
#define D3DDM_EVENT_RSTOKEN             (1<<0)
#define D3DDM_EVENT_BEGINSCENE          (1<<1)
#define D3DDM_EVENT_ENDSCENE            (1<<2)

#define D3DDM_EVENT_VERTEX              (1<<8)
#define D3DDM_EVENT_VERTEXSHADERINST    (2<<8)
#define D3DDM_EVENT_VERTEXSHADER        (3<<8)

#define D3DDM_EVENT_PRIMITIVE           (1<<15)

#define D3DDM_EVENT_PIXEL               (1<<16)
#define D3DDM_EVENT_PIXELSHADERINST     (1<<17)
#define D3DDM_EVENT_PIXELSHADER         (1<<18)

#define D3DDM_EVENT_TARGETDISCONNECT    (1<<30)
#define D3DDM_EVENT_TARGETEXIT          (1<<31)

// command definitions - command enum is in upper 16 bits so lower 16
// can be used to send command specific parameter information
#define D3DDM_CMD_MASK                  (0xffff<<16)
#define D3DDM_CMD_GO                    (1<<16)

#define D3DDM_CMD_GETDEVICESTATE        (2<<16)
#define D3DDM_CMD_GETTEXTURESTATE       (3<<16)
#define D3DDM_CMD_GETPRIMITIVESTATE     (4<<16)
#define D3DDM_CMD_GETVERTEXSHADER       (5<<16)

#define D3DDM_CMD_GETVERTEXSTATE        (8<<16)
#define D3DDM_CMD_GETVERTEXSHADERCONST  (9<<16)
#define D3DDM_CMD_GETVERTEXSHADERINST   (10<<16) // 15:00 shader instruction
#define D3DDM_CMD_GETVERTEXSHADERSTATE  (11<<16)

#define D3DDM_CMD_GETPIXELSTATE         (16<<16) // 01:00 pixel selection from 2x2 grid
#define D3DDM_CMD_GETPIXELSHADERCONST   (17<<16)
#define D3DDM_CMD_GETPIXELSHADERINST    (18<<16) // 15:00 shader instruction
#define D3DDM_CMD_GETPIXELSHADERSTATE   (19<<16)

#define D3DDM_CMD_DUMPTEXTURE           (32<<16) // 03:00 SM selection (up to 16)
                                                 // 06:04 texture stage (0..7)
                                                 // 10:07 LOD (0..15)
                                                 // 15:11 cubemap or volume slice (0..31)
#define D3DDM_CMD_DUMPRENDERTARGET      (33<<16) // 03:00 SM selection (up to 16)

const UINT D3DDM_MAX_TSSSTAGES      = 8;
const UINT D3DDM_MAX_TSSVALUE       = 32;
const UINT D3DDM_MAX_RS             = 256;

const UINT D3DDM_MAX_VSDECL         = 128;
const UINT D3DDM_MAX_VSINPUTREG     = 16;
const UINT D3DDM_MAX_VSCONSTREG     = 128;
const UINT D3DDM_MAX_VSTEMPREG      = 12;
const UINT D3DDM_MAX_VSRASTOUTREG   = 3;
const UINT D3DDM_MAX_VSATTROUTREG   = 2;
const UINT D3DDM_MAX_VSTEXCRDOUTREG = 8;
const UINT D3DDM_MAX_VSINSTDWORD    = 32;
const UINT D3DDM_MAX_VSINSTSTRING   = 128;

const UINT D3DDM_MAX_PSINPUTREG     = 2;
const UINT D3DDM_MAX_PSCONSTREG     = 8;
const UINT D3DDM_MAX_PSTEMPREG      = 2;
const UINT D3DDM_MAX_PSTEXTREG      = 8;
const UINT D3DDM_MAX_PSINSTDWORD    = 32;
const UINT D3DDM_MAX_PSINSTSTRING   = 128;

// structs for command data
typedef struct _D3DDMDeviceState
{
    UINT32  TextureStageState[D3DDM_MAX_TSSSTAGES][D3DDM_MAX_TSSVALUE];
    UINT32  RenderState[D3DDM_MAX_RS];
    UINT32  VertexShaderHandle;
    UINT32  PixelShaderHandle;
    UINT    MaxVShaderHandle;
    UINT    MaxPShaderHandle;
} D3DDMDeviceState;
typedef struct _D3DDMTextureState
{
} D3DDMTextureState;
typedef struct _D3DDMVertexShader
{
    UINT32  Decl[D3DDM_MAX_VSDECL];
    // followed by user data
} D3DDMVertexShader;

typedef struct _D3DDMVertexState
{
    FLOAT   InputRegs[D3DDM_MAX_VSINPUTREG][4];
} D3DDMVertexState;
typedef struct _D3DDMVertexShaderConst
{
    FLOAT   ConstRegs[D3DDM_MAX_VSCONSTREG][4];
} D3DDMVertexShaderConst;
typedef struct _D3DDMVertexShaderInst
{
    DWORD   Inst[D3DDM_MAX_VSINSTDWORD];
    char    InstString[D3DDM_MAX_VSINSTSTRING];
} D3DDMVertexShaderInst;
typedef struct _D3DDMVertexShaderState
{
    UINT    CurrentInst;
    FLOAT   TempRegs[D3DDM_MAX_VSTEMPREG][4];
    FLOAT   AddressReg[4];
    FLOAT   RastOutRegs[D3DDM_MAX_VSRASTOUTREG][4];
    FLOAT   AttrOutRegs[D3DDM_MAX_VSATTROUTREG][4];
    FLOAT   TexCrdOutRegs[D3DDM_MAX_VSTEXCRDOUTREG][4];
} D3DDMVertexShaderState;

typedef struct _D3DDMPrimState
{
} D3DDMPrimState;

typedef struct _D3DDMPixelState
{
    UINT    Location[2];
    FLOAT   Depth;
    FLOAT   FogIntensity;
    FLOAT   InputRegs[D3DDM_MAX_PSINPUTREG][4];
} D3DDMPixelState;
typedef struct _D3DDMPixelShaderConst
{
    FLOAT   ConstRegs[D3DDM_MAX_PSCONSTREG][4];
} D3DDMPixelShaderConst;
typedef struct _D3DDMPixelShaderInst
{
    DWORD   Inst[D3DDM_MAX_PSINSTDWORD];
    char    InstString[D3DDM_MAX_PSINSTSTRING];
} D3DDMPixelShaderInst;
typedef struct _D3DDMPixelShaderState
{
    UINT    CurrentInst;
    FLOAT   TempRegs[D3DDM_MAX_PSTEMPREG][4];
    FLOAT   TextRegs[D3DDM_MAX_PSTEXTREG][4];
    BOOL    Discard;
} D3DDMPixelShaderState;

// size of command data buffer - large enough for any (single) command,
// the largest of which is the instruction + instruction comment (128KB)
#define D3DDM_CMDDATA_SIZE  0x28000

//
// DebugMonitorContext & DebugTargetContext - Contexts for each side of the
// target/monitor processes.
//
// DebugMonitorContext is R/W to monitor and RO to debug target.  The only
// exception is the TargetIDRequest, which is written by a target when
// requesting to be connected to that monitor.
//
// The TargetBP (BreakPoint) event is signaled by the target whenever a
// breakpoint is hit.
//
// The MonitorCmd (Command) event is signaled by the monitor when a command
// is ready to be processed by the target, and the TargetAck is signaled
// when the target is done processing the command.  This is reversed during
// target attachment, where the target signals (via MonitorCmd) the monitor
// to look at it's TargetIDRequest and connect to that target, sending an
// acknowledge to the target via TargetAck.
//

typedef struct _DebugMonitorContext
{
    int     MonitorID;          // 1..X ID of monitor
    int     TargetIDRequest;    // pid of CMDing target; writeable by target
    int     TargetID;           // pid of attached target; zero if not connected
    UINT32  Command;            // D3DDM_CMD_* token

// breakpoint settings
    UINT32  EventBP;
    UINT64  VertexCountBP;
    UINT64  PrimitiveCountBP;
    UINT64  PixelCountBP;
    DWORD   VertexShaderHandleBP;
    DWORD   PixelShaderHandleBP;
    UINT32  RastVertexBPEnable;
    UINT32  PixelBPEnable;

    INT32   RastVertexBP[D3DDM_MAX_BP][2];
    UINT    PixelBP[D3DDM_MAX_BP][2];
} DebugMonitorContext;

typedef struct _DebugTargetContext
{
    DWORD   Version;            // version
    int     ProcessID;          // pid of this target
    int     MonitorID;          // ID of monitor; zero if not connected
    UINT32  CommandBufferSize;  // size of data in command buffer

// status/state
    UINT32  EventStatus;
    UINT32  SceneCount;
    UINT64  PrimitiveCount;
    UINT64  PixelCount;

// The target side maintains dirty flags so the monitor side knows when to
// requery target-side state.
#define D3DDM_SC_DEVICESTATE        (1<<0)
#define D3DDM_SC_TEXTURE            (1<<1)
#define D3DDM_SC_PSSETSHADER        (1<<2)
#define D3DDM_SC_PSCONSTANTS        (1<<3)
#define D3DDM_SC_VSSETSHADER        (1<<4)
#define D3DDM_SC_VSCONSTANTS        (1<<5)
#define D3DDM_SC_VSMODIFYSHADERS    (1<<6)
#define D3DDM_SC_PSMODIFYSHADERS    (1<<7)
    UINT32  StateChanged;

} DebugTargetContext;

#endif // _D3DDM_HPP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dvoice\inc\dvoice.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 - 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpvoice.h
 *  Content:    DirectPlayVoice include file
 ***************************************************************************/

#ifndef __DVOICE__
#define __DVOICE__


/****************************************************************************
 *
 * DirectPlayVoice Callback Functions
 *
 ****************************************************************************/
typedef HRESULT (FAR PASCAL *PDVMESSAGEHANDLER)(
    PVOID   pvUserContext,
    DWORD   dwMessageType,
    LPVOID  lpMessage
);

typedef PDVMESSAGEHANDLER LPDVMESSAGEHANDLER;

/****************************************************************************
 *
 * DirectPlayVoice Datatypes (Non-Structure / Non-Message)
 *
 ****************************************************************************/

typedef DWORD DVID, *LPDVID, *PDVID;

/****************************************************************************
 *
 * DirectPlayVoice Message Types
 *
 ****************************************************************************/

#define DVMSGID_BASE                        0x0000

#define DVMSGID_MINBASE                     (DVMSGID_CREATEVOICEPLAYER)
#define DVMSGID_CREATEVOICEPLAYER           (DVMSGID_BASE+0x0001)
#define DVMSGID_DELETEVOICEPLAYER           (DVMSGID_BASE+0x0002)
#define DVMSGID_SESSIONLOST                 (DVMSGID_BASE+0x0003)
#define DVMSGID_PLAYERVOICESTART            (DVMSGID_BASE+0x0004)
#define DVMSGID_PLAYERVOICESTOP             (DVMSGID_BASE+0x0005)
#define DVMSGID_RECORDSTART                 (DVMSGID_BASE+0x0006)
#define DVMSGID_RECORDSTOP                  (DVMSGID_BASE+0x0007)
#define DVMSGID_CONNECTRESULT               (DVMSGID_BASE+0x0008)
#define DVMSGID_DISCONNECTRESULT            (DVMSGID_BASE+0x0009)
#define DVMSGID_INPUTLEVEL                  (DVMSGID_BASE+0x000A)
#define DVMSGID_VOICEPERIPHERALNOTPRESENT   (DVMSGID_BASE+0x000B)
#define DVMSGID_HOSTMIGRATED                (DVMSGID_BASE+0x000C)
#define DVMSGID_SETTARGETS                  (DVMSGID_BASE+0x000D)
#define DVMSGID_PLAYEROUTPUTLEVEL           (DVMSGID_BASE+0x000E)
#define DVMSGID_LOCALHOSTSETUP              (DVMSGID_BASE+0x0012)
#define DVMSGID_MAXBASE                     (DVMSGID_LOCALHOSTSETUP)

/****************************************************************************
 *
 * DirectPlayVoice Constants
 *
 ****************************************************************************/

#define DVID_SYS                0

//
// Used to identify the session host in client/server
//
#define DVID_SERVERPLAYER       1

//
// Used to target all players
//
#define DVID_ALLPLAYERS         0

//
// Used to identify the main buffer
//
#define DVID_REMAINING          0xFFFFFFFF

//
// Input level range
//
#define DVINPUTLEVEL_MIN                    0x00000000
#define DVINPUTLEVEL_MAX                    0x00000063  // 99 decimal

#define DVNOTIFYPERIOD_MINPERIOD            20

//
// Use the default value
//
#define DVTHRESHOLD_DEFAULT               0xFFFFFFFF

//
// Sensitivity Ranges
//
#define DVTHRESHOLD_MIN                   0x00000000
#define DVTHRESHOLD_MAX                   0x00000063    // 99 decimal

//
// Sensitivity field is not used
//
#define DVTHRESHOLD_UNUSED                0xFFFFFFFE

//
// Session Types
//
#define DVSESSIONTYPE_PEER                  0x00000001
#define DVSESSIONTYPE_MIXING                0x00000002
#define DVSESSIONTYPE_FORWARDING            0x00000003
#define DVSESSIONTYPE_ECHO                  0x00000004


/****************************************************************************
 *
 * DirectPlayVoice Flags
 *
 ****************************************************************************/

//
// Mute the recording
//
#define DVCLIENTCONFIG_RECORDMUTE           0x00000001

//
// Mute the playback
//
#define DVCLIENTCONFIG_PLAYBACKMUTE         0x00000002

//
// Voice Activation manual mode
//
#define DVCLIENTCONFIG_MANUALVOICEACTIVATED 0x00000004

//
// Only playback voices that have buffers created for them
//
#define DVCLIENTCONFIG_MUTEGLOBAL           0x00000010

//
// Enable automatic voice activation
//
#define DVCLIENTCONFIG_AUTOVOICEACTIVATED   0x00000020

//
// disables recording from the local player
// will also be set automatically if the voice peripheral gets removed
//

#define DVCLIENTCONFIG_HALFDUPLEX           0x00000040

//
// determines the behavior of DirectPlay Voice in the case where
// there is no voice peripheral attached to dwPort. If this flag is set,
// all voices that would have been sent to the voice peripheral for 
// playback will not be played at all. If this flag is not set, 
// all voices that would have been sent to the voice peripheral 
// for playback will be sent to the main audio output device (MCPX).
//

#define DVCLIENTCONFIG_MUTEIFNODEVICE       0x00000080

//
// API flags dwFlags field in Connect, etc
//

//
// Shutdown the voice session without migrating the host
//
#define DVFLAGS_NOHOSTMIGRATE               0x00000008

//
// Disable host migration in the voice session
//
#define DVSESSION_NOHOSTMIGRATION           0x00000001

//
// Server controlled targetting
//
#define DVSESSION_SERVERCONTROLTARGET       0x00000002

//
// Player is in half duplex mode
//
#define DVPLAYERCAPS_HALFDUPLEX             0x00000001

//
// Specifies that player is the local player
//
#define DVPLAYERCAPS_LOCAL                  0x00000002


/****************************************************************************
 *
 * DirectPlayVoice Interface Pointer definitions
 *
 ****************************************************************************/

typedef struct IDirectPlayVoiceClient IDirectPlayVoiceClient;
typedef IDirectPlayVoiceClient *LPDIRECTPLAYVOICECLIENT, *PDIRECTPLAYVOICECLIENT;

typedef struct IDirectPlayVoiceServer IDirectPlayVoiceServer;
typedef IDirectPlayVoiceServer *LPDIRECTPLAYVOICESERVER, *PDIRECTPLAYVOICESERVER;


//
// DirectPlayVoice Client Configuration
// (Connect / GetClientConfig)
//
typedef struct
{
    DWORD   dwSize;                 // Size of this structure
    DWORD   dwFlags;                // Flags for client config (DVCLIENTCONFIG_...)
    DWORD   dwThreshold;            // Voice Activation Threshold 
    DWORD   dwPort;                 // Player Number(slot # on the xbox) to use for this dvoice instance
} DVCLIENTCONFIG, *LPDVCLIENTCONFIG, *PDVCLIENTCONFIG;

//
// DirectPlayVoice Session Description
// (Host / GetSessionDesc)
//
typedef struct
{
    DWORD   dwSize;                 // Size of this structure
    DWORD   dwFlags;                // Session flags (DVSESSION_...)
    DWORD   dwSessionType;          // Session type (DVSESSIONTYPE_...)
    GUID    guidCT;                 // Compression Type to use

} DVSESSIONDESC, *LPDVSESSIONDESC, *PDVSESSIONDESC;

/****************************************************************************
 *
 * DirectPlayVoice message handler call back structures
 *
 ****************************************************************************/

//
// Result of the Connect() call.  (If it wasn't called Async)
// (DVMSGID_CONNECTRESULT)
//

typedef struct
{
    DWORD   dwSize;                         // Size of this structure
} DVMSG_VOICEPERIPHERALNOTPRESENT, *LPDVMSG_VOICEPERIPHERALNOTPRESENT, *PDVMSG_VOICEPERIPHERALNOTPRESENT;

//
// Result of the Connect() call.  (If it wasn't called Async)
// (DVMSGID_CONNECTRESULT)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    HRESULT hrResult;                       // Result of the Connect() call
} DVMSG_CONNECTRESULT, *LPDVMSG_CONNECTRESULT, *PDVMSG_CONNECTRESULT;

//
// A new player has entered the voice session
// (DVMSGID_CREATEVOICEPLAYER)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DVID    dvidPlayer;                     // DVID of the player who joined
    DWORD   dwFlags;                        // Player flags (DVPLAYERCAPS_...)
    PVOID   pvPlayerContext;                // Context value for this player (user set)
} DVMSG_CREATEVOICEPLAYER, *LPDVMSG_CREATEVOICEPLAYER, *PDVMSG_CREATEVOICEPLAYER;

//
// A player has left the voice session
// (DVMSGID_DELETEVOICEPLAYER)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DVID    dvidPlayer;                     // DVID of the player who left
    PVOID   pvPlayerContext;                // Context value for the player
} DVMSG_DELETEVOICEPLAYER, *LPDVMSG_DELETEVOICEPLAYER, *PDVMSG_DELETEVOICEPLAYER;

//
// Result of the Disconnect() call.  (If it wasn't called Async)
// (DVMSGID_DISCONNECTRESULT)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    HRESULT hrResult;                       // Result of the Disconnect() call
} DVMSG_DISCONNECTRESULT, *LPDVMSG_DISCONNECTRESULT, *PDVMSG_DISCONNECTRESULT;

//
// The voice session host has migrated.
// (DVMSGID_HOSTMIGRATED)
//
typedef struct
{
    DWORD                   dwSize;         // Size of this structure
    DVID                    dvidNewHostID;  // DVID of the player who is now the host
    LPDIRECTPLAYVOICESERVER pdvServerInterface;
                                            // Pointer to the new host object (if local player is now host)
} DVMSG_HOSTMIGRATED, *LPDVMSG_HOSTMIGRATED, *PDVMSG_HOSTMIGRATED;

//
// The current input level / recording volume on the local machine
// (DVMSGID_INPUTLEVEL)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DWORD   dwPeakLevel;                    // Current peak level of the audio
    LONG    lRecordVolume;                  // Current recording volume
    PVOID   pvLocalPlayerContext;           // Context value for the local player
} DVMSG_INPUTLEVEL, *LPDVMSG_INPUTLEVEL, *PDVMSG_INPUTLEVEL;

//
// The local client is about to become the new host
// (DVMSGID_LOCALHOSTSETUP)
//
typedef struct
{
    DWORD               dwSize;             // Size of this structure
    PVOID               pvContext;          // Context value to be passed to Initialize() of new host object
    PDVMESSAGEHANDLER   pMessageHandler;    // Message handler to be used by new host object
} DVMSG_LOCALHOSTSETUP, *LPDVMSG_LOCALHOSTSETUP, *PDVMSG_LOCALHOSTSETUP;

//
// The current peak level of an individual player's incoming audio stream as it is
// being played back.
// (DVMSGID_PLAYEROUTPUTLEVEL)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DVID    dvidSourcePlayerID;                   // DVID of the player
    DWORD   dwPeakLevel;                    // Peak level of the player's stream
    PVOID   pvPlayerContext;                // Context value for the player
} DVMSG_PLAYEROUTPUTLEVEL, *LPDVMSG_PLAYEROUTPUTLEVEL, *PDVMSG_PLAYEROUTPUTLEVEL;

//
// An audio stream from the specified player has started playing back on the local client.
// (DVMSGID_PLAYERVOICESTART).
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DVID    dvidSourcePlayerID;             // DVID of the Player
    PVOID   pvPlayerContext;                // Context value for this player
} DVMSG_PLAYERVOICESTART, *LPDVMSG_PLAYERVOICESTART, *PDVMSG_PLAYERVOICESTART;

//
// The audio stream from the specified player has stopped playing back on the local client.
// (DVMSGID_PLAYERVOICESTOP)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DVID    dvidSourcePlayerID;             // DVID of the player
    PVOID   pvPlayerContext;                // Context value for this player
} DVMSG_PLAYERVOICESTOP, *LPDVMSG_PLAYERVOICESTOP, *PDVMSG_PLAYERVOICESTOP;

//
// Transmission has started on the local machine
// (DVMSGID_RECORDSTART)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DWORD   dwPeakLevel;                    // Peak level that caused transmission to start
    PVOID   pvLocalPlayerContext;           // Context value for the local player
} DVMSG_RECORDSTART, *LPDVMSG_RECORDSTART, *PDVMSG_RECORDSTART;

//
// Transmission has stopped on the local machine
// (DVMSGID_RECORDSTOP)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DWORD   dwPeakLevel;                    // Peak level that caused transmission to stop
    PVOID   pvLocalPlayerContext;           // Context value for the local player
} DVMSG_RECORDSTOP, *LPDVMSG_RECORDSTOP, *PDVMSG_RECORDSTOP;

//
// The voice session has been lost
// (DVMSGID_SESSIONLOST)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    HRESULT hrResult;                       // Reason the session was disconnected
} DVMSG_SESSIONLOST, *LPDVMSG_SESSIONLOST, *PDVMSG_SESSIONLOST;

//
// The target list has been updated for the local client
// (DVMSGID_SETTARGETS)
//
typedef struct
{
    DWORD   dwSize;                         // Size of this structure
    DWORD   dwNumTargets;                   // # of targets
    PDVID   pdvidTargets;                   // An array of DVIDs specifying the current targets
} DVMSG_SETTARGETS, *LPDVMSG_SETTARGETS, *PDVMSG_SETTARGETS;




/****************************************************************************
 *
 * DirectPlayVoice Functions
 *
 ****************************************************************************/

#define IID_IDirectPlayVoiceClient 1
#define IID_IDirectPlayVoiceServer 2

extern HRESULT WINAPI DirectPlayVoiceCreate(
    DWORD dwIID,
    void **ppvInterface,
    void *pUnknown);

extern HRESULT WINAPI XDirectPlayVoiceCreate(
	DWORD dwIID, 
	void** ppvInterface);

/****************************************************************************
 *
 * DirectPlay8 Application Interfaces
 *
 ****************************************************************************/
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

ULONG WINAPI IDirectPlayVoiceClient_AddRef(LPDIRECTPLAYVOICECLIENT pArg1);
ULONG WINAPI IDirectPlayVoiceClient_Release(LPDIRECTPLAYVOICECLIENT pArg1);

HRESULT WINAPI IDirectPlayVoiceClient_Initialize(LPDIRECTPLAYVOICECLIENT pArg0, PVOID pArg1, PDVMESSAGEHANDLER pArg2, PVOID pArg3, LPDWORD pArg4, DWORD Arg5);
HRESULT WINAPI IDirectPlayVoiceClient_Connect(LPDIRECTPLAYVOICECLIENT pArg0, PDVCLIENTCONFIG pArg1, DWORD Arg2 );
HRESULT WINAPI IDirectPlayVoiceClient_Disconnect(LPDIRECTPLAYVOICECLIENT pArg0, DWORD Arg1 );
HRESULT WINAPI IDirectPlayVoiceClient_DoWork(LPDIRECTPLAYVOICECLIENT pArg0);
HRESULT WINAPI IDirectPlayVoiceClient_GetSessionDesc(LPDIRECTPLAYVOICECLIENT pArg0, PDVSESSIONDESC pArg1 );
HRESULT WINAPI IDirectPlayVoiceClient_GetClientConfig(LPDIRECTPLAYVOICECLIENT pArg0, PDVCLIENTCONFIG pArg1 );
HRESULT WINAPI IDirectPlayVoiceClient_SetClientConfig(LPDIRECTPLAYVOICECLIENT pArg0, PDVCLIENTCONFIG pArg1 );
HRESULT WINAPI IDirectPlayVoiceClient_CreateSoundTarget(LPDIRECTPLAYVOICECLIENT pArg0, DVID dvidID, PWAVEFORMATEX *ppwfxMediaFormat, XMediaObject **ppMediaObject);
HRESULT WINAPI IDirectPlayVoiceClient_DeleteSoundTarget(LPDIRECTPLAYVOICECLIENT pArg0, DVID dvidID, XMediaObject **ppMediaObject);
HRESULT WINAPI IDirectPlayVoiceClient_SetTransmitTargets(LPDIRECTPLAYVOICECLIENT pArg0, PDVID pArg1, DWORD Arg2, DWORD Arg3 );
HRESULT WINAPI IDirectPlayVoiceClient_GetTransmitTargets(LPDIRECTPLAYVOICECLIENT pArg0, PDVID pArg1, PDWORD pArg2, DWORD Arg3 );
HRESULT WINAPI IDirectPlayVoiceClient_SetNotifyMask(LPDIRECTPLAYVOICECLIENT pArg0, PDWORD pArg1, DWORD Arg2 );


#ifdef __cplusplus
}
#endif // __cplusplus

/*
 * DIRECTVOICE Interface Definition
 *
 */

#ifdef __cplusplus

struct IDirectPlayVoiceClient
{

    __inline ULONG STDMETHODCALLTYPE AddRef(void)
    {
        return IDirectPlayVoiceClient_AddRef(this);
    }

    __inline ULONG STDMETHODCALLTYPE Release(void)
    {
        return IDirectPlayVoiceClient_Release(this);
    }

    /*** IDirectPlayVoiceClient methods ***/
    __inline HRESULT STDMETHODCALLTYPE Initialize (PVOID pArg1, PDVMESSAGEHANDLER pArg2, PVOID pArg3, LPDWORD pArg4, DWORD Arg5 )
    {
        return IDirectPlayVoiceClient_Initialize(this,pArg1,pArg2,pArg3,pArg4, Arg5);
    }

    __inline HRESULT STDMETHODCALLTYPE Connect (PDVCLIENTCONFIG pArg1, DWORD Arg2 )
    {
        return IDirectPlayVoiceClient_Connect(this,pArg1,Arg2);
    }

    __inline HRESULT STDMETHODCALLTYPE Disconnect (DWORD Arg1 )
    {
        return IDirectPlayVoiceClient_Disconnect(this,Arg1);
    }

    __inline HRESULT STDMETHODCALLTYPE DoWork ()
    {

        return IDirectPlayVoiceClient_DoWork(this);

    }

    __inline HRESULT STDMETHODCALLTYPE GetSessionDesc (PDVSESSIONDESC pArg1 )
    {
        return IDirectPlayVoiceClient_GetSessionDesc(this,pArg1);
    }

    __inline HRESULT STDMETHODCALLTYPE GetClientConfig (PDVCLIENTCONFIG pArg1 )
    {
        return IDirectPlayVoiceClient_GetClientConfig(this,pArg1);
    }

    __inline HRESULT STDMETHODCALLTYPE SetClientConfig (PDVCLIENTCONFIG pArg1 )
    {
        return IDirectPlayVoiceClient_SetClientConfig(this,pArg1);
    }

    __inline HRESULT STDMETHODCALLTYPE CreateSoundTarget( DVID dvidID, PWAVEFORMATEX *ppwfxMediaFormat, XMediaObject **ppMediaObject)
    {
        return IDirectPlayVoiceClient_CreateSoundTarget( this, dvidID, ppwfxMediaFormat, ppMediaObject);
    }

    __inline HRESULT STDMETHODCALLTYPE DeleteSoundTarget( DVID dvidID, XMediaObject **ppMediaObject )
    {
        return IDirectPlayVoiceClient_DeleteSoundTarget( this, dvidID, ppMediaObject );
    }

    __inline HRESULT STDMETHODCALLTYPE SetTransmitTargets (PDVID pArg1, DWORD Arg2, DWORD Arg3 )
    {
        return IDirectPlayVoiceClient_SetTransmitTargets(this, pArg1, Arg2, Arg3);
    }

    __inline HRESULT STDMETHODCALLTYPE GetTransmitTargets (PDVID pArg1, PDWORD pArg2, DWORD Arg3 )
    {
        return IDirectPlayVoiceClient_GetTransmitTargets(this, pArg1, pArg2, Arg3);
    }

    __inline HRESULT STDMETHODCALLTYPE SetNotifyMask (PDWORD pArg1, DWORD Arg2 )
    {
        return IDirectPlayVoiceClient_SetNotifyMask(this, pArg1, Arg2);
    }

};

#endif // __cplusplus



#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

ULONG WINAPI IDirectPlayVoiceServer_AddRef(LPDIRECTPLAYVOICESERVER pArg1);
ULONG WINAPI IDirectPlayVoiceServer_Release(LPDIRECTPLAYVOICESERVER pArg1);

HRESULT WINAPI IDirectPlayVoiceServer_Initialize(LPDIRECTPLAYVOICESERVER pArg0,PVOID pArg1, PDVMESSAGEHANDLER pArg2, PVOID pArg3, LPDWORD pArg4, DWORD Arg5 );
HRESULT WINAPI IDirectPlayVoiceServer_StartSession(LPDIRECTPLAYVOICESERVER pArg0,PDVSESSIONDESC pArg1, DWORD Arg2);
HRESULT WINAPI IDirectPlayVoiceServer_StopSession(LPDIRECTPLAYVOICESERVER pArg0,DWORD Arg1);
HRESULT WINAPI IDirectPlayVoiceServer_GetSessionDesc(LPDIRECTPLAYVOICESERVER pArg0,PDVSESSIONDESC pArg1 );
HRESULT WINAPI IDirectPlayVoiceServer_SetTransmitTargets(LPDIRECTPLAYVOICESERVER pArg0,DVID Arg1, PDVID pArg2, DWORD Arg3, DWORD Arg4 );
HRESULT WINAPI IDirectPlayVoiceServer_GetTransmitTargets(LPDIRECTPLAYVOICESERVER pArg0,DVID Arg1, PDVID pArg2, PDWORD Arg3, DWORD Arg4 );
HRESULT WINAPI IDirectPlayVoiceServer_SetNotifyMask(LPDIRECTPLAYVOICESERVER pArg0,PDWORD pArg1, DWORD Arg2 );

#ifdef __cplusplus
}
#endif // __cplusplus

#ifdef __cplusplus

struct IDirectPlayVoiceServer
{
    /*** IUnknown methods ***/

    __inline ULONG STDMETHODCALLTYPE AddRef(void)
    {
        return IDirectPlayVoiceServer_AddRef(this);
    }

    __inline ULONG STDMETHODCALLTYPE Release(void)
    {
        return IDirectPlayVoiceServer_Release(this);
    }

    /*** IDirectPlayVoiceServer methods ***/
    __inline HRESULT STDMETHODCALLTYPE Initialize (PVOID pArg1, PDVMESSAGEHANDLER pArg2, PVOID pArg3, LPDWORD pArg4, DWORD Arg5 )
    {
        return IDirectPlayVoiceServer_Initialize(this,pArg1,pArg2,pArg3,pArg4, Arg5);
    }

    __inline HRESULT STDMETHODCALLTYPE StartSession(PDVSESSIONDESC pArg1, DWORD Arg2)
    {
        return IDirectPlayVoiceServer_StartSession(this,pArg1,Arg2);
    }

    __inline HRESULT STDMETHODCALLTYPE StopSession(DWORD Arg1)
    {
        return IDirectPlayVoiceServer_StopSession(this,Arg1);
    }

    __inline HRESULT STDMETHODCALLTYPE GetSessionDesc (PDVSESSIONDESC pArg1 )
    {
        return IDirectPlayVoiceServer_GetSessionDesc(this,pArg1);
    }

    __inline HRESULT STDMETHODCALLTYPE SetTransmitTargets (DVID Arg1, PDVID pArg2, DWORD Arg3, DWORD Arg4 )
    {
        return IDirectPlayVoiceServer_SetTransmitTargets(this, Arg1, pArg2, Arg3, Arg4);
    }

    __inline HRESULT STDMETHODCALLTYPE GetTransmitTargets (DVID Arg1, PDVID pArg2, PDWORD pArg3, DWORD Arg4 )
    {
        return IDirectPlayVoiceServer_GetTransmitTargets(this, Arg1, pArg2, pArg3, Arg4);
    }

    __inline HRESULT STDMETHODCALLTYPE SetNotifyMask (PDWORD pArg1, DWORD Arg2 )
    {
        return IDirectPlayVoiceServer_SetNotifyMask(this, pArg1, Arg2);
    }

};

#endif // __cplusplus


/****************************************************************************
 *
 * DIRECTPLAYVOICE ERRORS
 *
 * Errors are represented by negative values and cannot be combined.
 *
 ****************************************************************************/

#define _FACDPV  0x15
#define MAKE_DVHRESULT( code )          MAKE_HRESULT( 1, _FACDPV, code )

#define DV_OK                           S_OK
#define DV_FULLDUPLEX                   MAKE_HRESULT( 0, _FACDPV,  0x0005 )
#define DV_HALFDUPLEX                   MAKE_HRESULT( 0, _FACDPV,  0x000A )
#define DV_PENDING                      MAKE_HRESULT( 0, _FACDPV,  0x0010 )

#define DVERR_BUFFERTOOSMALL            MAKE_DVHRESULT(  0x001E )
#define DVERR_EXCEPTION                 MAKE_DVHRESULT(  0x004A )
#define DVERR_GENERIC                   E_FAIL
#define DVERR_INVALIDFLAGS              MAKE_DVHRESULT( 0x0078 )
#define DVERR_INVALIDOBJECT             MAKE_DVHRESULT( 0x0082 )
#define DVERR_INVALIDPARAM              E_INVALIDARG
#define DVERR_INVALIDPLAYER             MAKE_DVHRESULT( 0x0087 )
#define DVERR_INVALIDGROUP              MAKE_DVHRESULT( 0x0091 )
#define DVERR_INVALIDHANDLE             MAKE_DVHRESULT( 0x0096 )
#define DVERR_OUTOFMEMORY               E_OUTOFMEMORY
#define DVERR_PENDING                   DV_PENDING
#define DVERR_NOTSUPPORTED              E_NOTIMPL
#define DVERR_NOINTERFACE               E_NOINTERFACE
#define DVERR_SESSIONLOST               MAKE_DVHRESULT( 0x012C )
#define DVERR_NOVOICESESSION            MAKE_DVHRESULT( 0x012E )
#define DVERR_CONNECTIONLOST            MAKE_DVHRESULT( 0x0168 )
#define DVERR_NOTINITIALIZED            MAKE_DVHRESULT( 0x0169 )
#define DVERR_CONNECTED                 MAKE_DVHRESULT( 0x016A )
#define DVERR_NOTCONNECTED              MAKE_DVHRESULT( 0x016B )
#define DVERR_CONNECTABORTING           MAKE_DVHRESULT( 0x016E )
#define DVERR_NOTALLOWED                MAKE_DVHRESULT( 0x016F )
#define DVERR_INVALIDTARGET             MAKE_DVHRESULT( 0x0170 )
#define DVERR_TRANSPORTNOTHOST          MAKE_DVHRESULT( 0x0171 )
#define DVERR_COMPRESSIONNOTSUPPORTED   MAKE_DVHRESULT( 0x0172 )
#define DVERR_ALREADYPENDING            MAKE_DVHRESULT( 0x0173 )
#define DVERR_SOUNDINITFAILURE          MAKE_DVHRESULT( 0x0174 )
#define DVERR_TIMEOUT                   MAKE_DVHRESULT( 0x0175 )
#define DVERR_CONNECTABORTED            MAKE_DVHRESULT( 0x0176 )
#define DVERR_NO3DSOUND                 MAKE_DVHRESULT( 0x0177 )
#define DVERR_ALREADYBUFFERED           MAKE_DVHRESULT( 0x0178 )
#define DVERR_NOTBUFFERED               MAKE_DVHRESULT( 0x0179 )
#define DVERR_HOSTING                   MAKE_DVHRESULT( 0x017A )
#define DVERR_NOTHOSTING                MAKE_DVHRESULT( 0x017B )
#define DVERR_INVALIDDEVICE             MAKE_DVHRESULT( 0x017C )
#define DVERR_RECORDSYSTEMERROR         MAKE_DVHRESULT( 0x017D )
#define DVERR_PLAYBACKSYSTEMERROR       MAKE_DVHRESULT( 0x017E )
#define DVERR_SENDERROR                 MAKE_DVHRESULT( 0x017F )
#define DVERR_USERCANCEL                MAKE_DVHRESULT( 0x0180 )
#define DVERR_RUNSETUP                  MAKE_DVHRESULT( 0x0183 )
#define DVERR_INCOMPATIBLEVERSION       MAKE_DVHRESULT( 0x0184 )
#define DVERR_INITIALIZED               MAKE_DVHRESULT( 0x0187 )
#define DVERR_INVALIDPOINTER            E_POINTER
#define DVERR_NOTRANSPORT               MAKE_DVHRESULT( 0x0188 )
#define DVERR_NOCALLBACK                MAKE_DVHRESULT( 0x0189 )
#define DVERR_TRANSPORTNOTINIT          MAKE_DVHRESULT( 0x018A )
#define DVERR_TRANSPORTNOSESSION        MAKE_DVHRESULT( 0x018B )
#define DVERR_TRANSPORTNOPLAYER         MAKE_DVHRESULT( 0x018C )
#define DVERR_INVALIDBUFFER             MAKE_DVHRESULT( 0x018F )


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dxg\d3dx8core.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 - 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8core.h
//  Content:    D3DX core types and functions
//
///////////////////////////////////////////////////////////////////////////

#include "d3dx8.h"

#ifndef __D3DX8CORE_H__
#define __D3DX8CORE_H__

#undef INTERFACE
#define INTERFACE VOID

///////////////////////////////////////////////////////////////////////////
// ID3DXBuffer:
// ------------
// The buffer object is used to return arbitrary lenght data.
///////////////////////////////////////////////////////////////////////////

typedef interface ID3DXBuffer ID3DXBuffer;
typedef interface ID3DXBuffer *LPD3DXBUFFER;

// {932E6A7E-C68E-45dd-A7BF-53D19C86DB1F}
DEFINE_GUID(IID_ID3DXBuffer,
0x932e6a7e, 0xc68e, 0x45dd, 0xa7, 0xbf, 0x53, 0xd1, 0x9c, 0x86, 0xdb, 0x1f);

DECLARE_INTERFACE_(ID3DXBuffer, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXBuffer
    STDMETHOD_(LPVOID, GetBufferPointer)(THIS) PURE;
    STDMETHOD_(DWORD, GetBufferSize)(THIS) PURE;
};






///////////////////////////////////////////////////////////////////////////
// ID3DXSprite:
// ------------
// This object intends to provide an easy way to drawing sprites using D3D.
//
// Begin -
//    Prepares device for drawing sprites
//
// Draw, DrawAffine, DrawTransform
//    Draws a sprite in screen-space.  Before transformation, the sprite is
//    the size of SrcRect, with its top-left corner at the origin (0,0).
//    The color and alpha channels are modulated by Color.
//
// End -
//     Restores device state to how it was when Begin was called.
///////////////////////////////////////////////////////////////////////////

typedef interface ID3DXSprite ID3DXSprite;
typedef interface ID3DXSprite *LPD3DXSPRITE;


// {E8691849-87B8-4929-9050-1B0542D5538C}
DEFINE_GUID( IID_ID3DXSprite,
0xe8691849, 0x87b8, 0x4929, 0x90, 0x50, 0x1b, 0x5, 0x42, 0xd5, 0x53, 0x8c);


DECLARE_INTERFACE_(ID3DXSprite, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXSprite
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;

    STDMETHOD(Begin)(THIS) PURE;

    STDMETHOD(Draw)(THIS_ LPDIRECT3DTEXTURE8  pSrcTexture,
        CONST RECT* pSrcRect, CONST D3DXVECTOR2* pScaling,
        CONST D3DXVECTOR2* pRotationCenter, FLOAT Rotation,
        CONST D3DXVECTOR2* pTranslation, D3DCOLOR Color) PURE;

    STDMETHOD(DrawTransform)(THIS_ LPDIRECT3DTEXTURE8 pSrcTexture,
        CONST RECT* pSrcRect, CONST D3DXMATRIX* pTransform,
        D3DCOLOR Color) PURE;

    STDMETHOD(End)(THIS) PURE;
};


#ifdef __cplusplus
extern "C" {
#endif //__cplusplus


HRESULT WINAPI
    D3DXCreateSprite(
        LPDIRECT3DDEVICE8   pDevice,
        LPD3DXSPRITE*       ppSprite);

#ifdef __cplusplus
}
#endif //__cplusplus





///////////////////////////////////////////////////////////////////////////
// ID3DXRenderToSurface:
// ---------------------
// This object abstracts rendering to surfaces.  These surfaces do not
// necessarily need to be render targets.  If they are not, a compatible
// render target is used, and the result copied into surface at end scene.
///////////////////////////////////////////////////////////////////////////

typedef struct _D3DXRTS_DESC
{
    UINT                Width;
    UINT                Height;
    D3DFORMAT           Format;
    BOOL                DepthStencil;
    D3DFORMAT           DepthStencilFormat;

} D3DXRTS_DESC;


typedef interface ID3DXRenderToSurface ID3DXRenderToSurface;
typedef interface ID3DXRenderToSurface *LPD3DXRENDERTOSURFACE;


// {69CC587C-E40C-458d-B5D3-B029E18EB60A}
DEFINE_GUID( IID_ID3DXRenderToSurface,
0x69cc587c, 0xe40c, 0x458d, 0xb5, 0xd3, 0xb0, 0x29, 0xe1, 0x8e, 0xb6, 0xa);


DECLARE_INTERFACE_(ID3DXRenderToSurface, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXRenderToSurface
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DXRTS_DESC* pDesc) PURE;

    STDMETHOD(BeginScene)(THIS_ LPDIRECT3DSURFACE8 pSurface, CONST D3DVIEWPORT8* pViewport) PURE;
    STDMETHOD(EndScene)(THIS) PURE;
};


#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

HRESULT WINAPI
    D3DXCreateRenderToSurface(
        LPDIRECT3DDEVICE8       pDevice,
        UINT                    Width,
        UINT                    Height,
        D3DFORMAT               Format,
        BOOL                    DepthStencil,
        D3DFORMAT               DepthStencilFormat,
        LPD3DXRENDERTOSURFACE*  ppRenderToSurface);

#ifdef __cplusplus
}
#endif //__cplusplus



///////////////////////////////////////////////////////////////////////////
// ID3DXRenderToEnvMap:
// --------------------
///////////////////////////////////////////////////////////////////////////

typedef struct _D3DXRTE_DESC
{
    UINT        Size;
    D3DFORMAT   Format;
    BOOL        DepthStencil;
    D3DFORMAT   DepthStencilFormat;
} D3DXRTE_DESC;


typedef interface ID3DXRenderToEnvMap ID3DXRenderToEnvMap;
typedef interface ID3DXRenderToEnvMap *LPD3DXRenderToEnvMap;

// {9F6779E5-60A9-4d8b-AEE4-32770F405DBA}
DEFINE_GUID( IID_ID3DXRenderToEnvMap,
0x9f6779e5, 0x60a9, 0x4d8b, 0xae, 0xe4, 0x32, 0x77, 0xf, 0x40, 0x5d, 0xba);


DECLARE_INTERFACE_(ID3DXRenderToEnvMap, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXRenderToEnvMap
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DXRTE_DESC* pDesc) PURE;

    STDMETHOD(BeginCube)(THIS_
        LPDIRECT3DCUBETEXTURE8 pCubeTex) PURE;

    STDMETHOD(BeginSphere)(THIS_
        LPDIRECT3DTEXTURE8 pTex) PURE;

    STDMETHOD(BeginHemisphere)(THIS_
        LPDIRECT3DTEXTURE8 pTexZPos,
        LPDIRECT3DTEXTURE8 pTexZNeg) PURE;

    STDMETHOD(BeginParabolic)(THIS_
        LPDIRECT3DTEXTURE8 pTexZPos,
        LPDIRECT3DTEXTURE8 pTexZNeg) PURE;

    STDMETHOD(Face)(THIS_ D3DCUBEMAP_FACES Face) PURE;
    STDMETHOD(End)(THIS) PURE;
};


#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

HRESULT WINAPI
    D3DXCreateRenderToEnvMap(
        LPDIRECT3DDEVICE8       pDevice,
        UINT                    Size,
        D3DFORMAT               Format,
        BOOL                    DepthStencil,
        D3DFORMAT               DepthStencilFormat,
        LPD3DXRenderToEnvMap*   ppRenderToEnvMap);

#ifdef __cplusplus
}
#endif //__cplusplus

///////////////////////////////////////////////////////////////////////////
// Misc APIs:
///////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus


//-------------------------------------------------------------------------
// D3DXGetFVFVertexSize:
// ---------------------
// Returns the size (in bytes) of a vertex for a given FVF.
//-------------------------------------------------------------------------

UINT WINAPI
    D3DXGetFVFVertexSize(DWORD FVF);


//-------------------------------------------------------------------------
// D3DXGetErrorString:
// ------------------
// Returns the error string for given an hresult.  Interprets all D3DX and
// D3D hresults.
//
// Parameters:
//  hr
//      The error code to be deciphered.
//  pBuffer
//      Pointer to the buffer to be filled in.
//  BufferLen
//      Count of characters in buffer.  Any error message longer than this
//      length will be truncated to fit.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXGetErrorStringA(
        HRESULT             hr,
        LPSTR               pBuffer,
        UINT                BufferLen);

HRESULT WINAPI
    D3DXGetErrorStringW(
        HRESULT             hr,
        LPWSTR              pBuffer,
        UINT                BufferLen);

#ifdef UNICODE
#define D3DXGetErrorString D3DXGetErrorStringW
#else
#define D3DXGetErrorString D3DXGetErrorStringA
#endif



#ifdef __cplusplus
}
#endif //__cplusplus


#endif //__D3DX8CORE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dxg\d3dx8math.inl ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1998 - 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8math.inl
//  Content:    D3DX math inline functions
//
//////////////////////////////////////////////////////////////////////////////

#ifndef __D3DX8MATH_INL__
#define __D3DX8MATH_INL__


//===========================================================================
//
// Inline Class Methods
//
//===========================================================================

#ifdef __cplusplus

//--------------------------
// 2D Vector
//--------------------------

D3DXINLINE
D3DXVECTOR2::D3DXVECTOR2( CONST FLOAT *pf )
{
#ifdef D3DX_DEBUG
    if(!pf)
        return;
#endif

    x = pf[0];
    y = pf[1];
}

D3DXINLINE
D3DXVECTOR2::D3DXVECTOR2( FLOAT fx, FLOAT fy )
{
    x = fx;
    y = fy;
}

// casting
D3DXINLINE
D3DXVECTOR2::operator FLOAT* ()
{
    return (FLOAT *) &x;
}

D3DXINLINE
D3DXVECTOR2::operator CONST FLOAT* () const
{
    return (CONST FLOAT *) &x;
}

// assignment operators
D3DXINLINE D3DXVECTOR2&
D3DXVECTOR2::operator += ( CONST D3DXVECTOR2& v )
{
    x += v.x;
    y += v.y;
    return *this;
}

D3DXINLINE D3DXVECTOR2&
D3DXVECTOR2::operator -= ( CONST D3DXVECTOR2& v )
{
    x -= v.x;
    y -= v.y;
    return *this;
}

D3DXINLINE D3DXVECTOR2&
D3DXVECTOR2::operator *= ( FLOAT f )
{
    x *= f;
    y *= f;
    return *this;
}

D3DXINLINE D3DXVECTOR2&
D3DXVECTOR2::operator /= ( FLOAT f )
{
    FLOAT fInv = 1.0f / f;
    x *= fInv;
    y *= fInv;
    return *this;
}

// unary operators
D3DXINLINE D3DXVECTOR2
D3DXVECTOR2::operator + () const
{
    return *this;
}

D3DXINLINE D3DXVECTOR2
D3DXVECTOR2::operator - () const
{
    return D3DXVECTOR2(-x, -y);
}

// binary operators
D3DXINLINE D3DXVECTOR2
D3DXVECTOR2::operator + ( CONST D3DXVECTOR2& v ) const
{
    return D3DXVECTOR2(x + v.x, y + v.y);
}

D3DXINLINE D3DXVECTOR2
D3DXVECTOR2::operator - ( CONST D3DXVECTOR2& v ) const
{
    return D3DXVECTOR2(x - v.x, y - v.y);
}

D3DXINLINE D3DXVECTOR2
D3DXVECTOR2::operator * ( FLOAT f ) const
{
    return D3DXVECTOR2(x * f, y * f);
}

D3DXINLINE D3DXVECTOR2
D3DXVECTOR2::operator / ( FLOAT f ) const
{
    FLOAT fInv = 1.0f / f;
    return D3DXVECTOR2(x * fInv, y * fInv);
}


D3DXINLINE D3DXVECTOR2
operator * ( FLOAT f, CONST D3DXVECTOR2& v )
{
    return D3DXVECTOR2(f * v.x, f * v.y);
}

D3DXINLINE BOOL
D3DXVECTOR2::operator == ( CONST D3DXVECTOR2& v ) const
{
    return x == v.x && y == v.y;
}

D3DXINLINE BOOL
D3DXVECTOR2::operator != ( CONST D3DXVECTOR2& v ) const
{
    return x != v.x || y != v.y;
}




//--------------------------
// 3D Vector
//--------------------------
D3DXINLINE
D3DXVECTOR3::D3DXVECTOR3( CONST FLOAT *pf )
{
#ifdef D3DX_DEBUG
    if(!pf)
        return;
#endif

    x = pf[0];
    y = pf[1];
    z = pf[2];
}

D3DXINLINE
D3DXVECTOR3::D3DXVECTOR3( CONST D3DVECTOR& v )
{
    x = v.x;
    y = v.y;
    z = v.z;
}

D3DXINLINE
D3DXVECTOR3::D3DXVECTOR3( FLOAT fx, FLOAT fy, FLOAT fz )
{
    x = fx;
    y = fy;
    z = fz;
}


// casting
D3DXINLINE
D3DXVECTOR3::operator FLOAT* ()
{
    return (FLOAT *) &x;
}

D3DXINLINE
D3DXVECTOR3::operator CONST FLOAT* () const
{
    return (CONST FLOAT *) &x;
}


// assignment operators
D3DXINLINE D3DXVECTOR3&
D3DXVECTOR3::operator += ( CONST D3DXVECTOR3& v )
{
    x += v.x;
    y += v.y;
    z += v.z;
    return *this;
}

D3DXINLINE D3DXVECTOR3&
D3DXVECTOR3::operator -= ( CONST D3DXVECTOR3& v )
{
    x -= v.x;
    y -= v.y;
    z -= v.z;
    return *this;
}

D3DXINLINE D3DXVECTOR3&
D3DXVECTOR3::operator *= ( FLOAT f )
{
    x *= f;
    y *= f;
    z *= f;
    return *this;
}

D3DXINLINE D3DXVECTOR3&
D3DXVECTOR3::operator /= ( FLOAT f )
{
    FLOAT fInv = 1.0f / f;
    x *= fInv;
    y *= fInv;
    z *= fInv;
    return *this;
}


// unary operators
D3DXINLINE D3DXVECTOR3
D3DXVECTOR3::operator + () const
{
    return *this;
}

D3DXINLINE D3DXVECTOR3
D3DXVECTOR3::operator - () const
{
    return D3DXVECTOR3(-x, -y, -z);
}


// binary operators
D3DXINLINE D3DXVECTOR3
D3DXVECTOR3::operator + ( CONST D3DXVECTOR3& v ) const
{
    return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);
}

D3DXINLINE D3DXVECTOR3
D3DXVECTOR3::operator - ( CONST D3DXVECTOR3& v ) const
{
    return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);
}

D3DXINLINE D3DXVECTOR3
D3DXVECTOR3::operator * ( FLOAT f ) const
{
    return D3DXVECTOR3(x * f, y * f, z * f);
}

D3DXINLINE D3DXVECTOR3
D3DXVECTOR3::operator / ( FLOAT f ) const
{
    FLOAT fInv = 1.0f / f;
    return D3DXVECTOR3(x * fInv, y * fInv, z * fInv);
}


D3DXINLINE D3DXVECTOR3
operator * ( FLOAT f, CONST struct D3DXVECTOR3& v )
{
    return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);
}


D3DXINLINE BOOL
D3DXVECTOR3::operator == ( CONST D3DXVECTOR3& v ) const
{
    return x == v.x && y == v.y && z == v.z;
}

D3DXINLINE BOOL
D3DXVECTOR3::operator != ( CONST D3DXVECTOR3& v ) const
{
    return x != v.x || y != v.y || z != v.z;
}



//--------------------------
// 4D Vector
//--------------------------
D3DXINLINE
D3DXVECTOR4::D3DXVECTOR4( CONST FLOAT *pf )
{
#ifdef D3DX_DEBUG
    if(!pf)
        return;
#endif

    x = pf[0];
    y = pf[1];
    z = pf[2];
    w = pf[3];
}

D3DXINLINE
D3DXVECTOR4::D3DXVECTOR4( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
{
    x = fx;
    y = fy;
    z = fz;
    w = fw;
}


// casting
D3DXINLINE
D3DXVECTOR4::operator FLOAT* ()
{
    return (FLOAT *) &x;
}

D3DXINLINE
D3DXVECTOR4::operator CONST FLOAT* () const
{
    return (CONST FLOAT *) &x;
}


// assignment operators
D3DXINLINE D3DXVECTOR4&
D3DXVECTOR4::operator += ( CONST D3DXVECTOR4& v )
{
    x += v.x;
    y += v.y;
    z += v.z;
    w += v.w;
    return *this;
}

D3DXINLINE D3DXVECTOR4&
D3DXVECTOR4::operator -= ( CONST D3DXVECTOR4& v )
{
    x -= v.x;
    y -= v.y;
    z -= v.z;
    w -= v.w;
    return *this;
}

D3DXINLINE D3DXVECTOR4&
D3DXVECTOR4::operator *= ( FLOAT f )
{
    x *= f;
    y *= f;
    z *= f;
    w *= f;
    return *this;
}

D3DXINLINE D3DXVECTOR4&
D3DXVECTOR4::operator /= ( FLOAT f )
{
    FLOAT fInv = 1.0f / f;
    x *= fInv;
    y *= fInv;
    z *= fInv;
    w *= fInv;
    return *this;
}


// unary operators
D3DXINLINE D3DXVECTOR4
D3DXVECTOR4::operator + () const
{
    return *this;
}

D3DXINLINE D3DXVECTOR4
D3DXVECTOR4::operator - () const
{
    return D3DXVECTOR4(-x, -y, -z, -w);
}


// binary operators
D3DXINLINE D3DXVECTOR4
D3DXVECTOR4::operator + ( CONST D3DXVECTOR4& v ) const
{
    return D3DXVECTOR4(x + v.x, y + v.y, z + v.z, w + v.w);
}

D3DXINLINE D3DXVECTOR4
D3DXVECTOR4::operator - ( CONST D3DXVECTOR4& v ) const
{
    return D3DXVECTOR4(x - v.x, y - v.y, z - v.z, w - v.w);
}

D3DXINLINE D3DXVECTOR4
D3DXVECTOR4::operator * ( FLOAT f ) const
{
    return D3DXVECTOR4(x * f, y * f, z * f, w * f);
}

D3DXINLINE D3DXVECTOR4
D3DXVECTOR4::operator / ( FLOAT f ) const
{
    FLOAT fInv = 1.0f / f;
    return D3DXVECTOR4(x * fInv, y * fInv, z * fInv, w * fInv);
}


D3DXINLINE D3DXVECTOR4
operator * ( FLOAT f, CONST D3DXVECTOR4& v )
{
    return D3DXVECTOR4(f * v.x, f * v.y, f * v.z, f * v.w);
}


D3DXINLINE BOOL
D3DXVECTOR4::operator == ( CONST D3DXVECTOR4& v ) const
{
    return x == v.x && y == v.y && z == v.z && w == v.w;
}

D3DXINLINE BOOL
D3DXVECTOR4::operator != ( CONST D3DXVECTOR4& v ) const
{
    return x != v.x || y != v.y || z != v.z || w != v.w;
}


//--------------------------
// Matrix
//--------------------------
D3DXINLINE
D3DXMATRIX::D3DXMATRIX( CONST FLOAT* pf )
{
#ifdef D3DX_DEBUG
    if(!pf)
        return;
#endif

    memcpy(&_11, pf, sizeof(D3DXMATRIX));
}

D3DXINLINE
D3DXMATRIX::D3DXMATRIX( CONST D3DMATRIX& mat )
{
    memcpy(&_11, &mat, sizeof(D3DXMATRIX));
}

D3DXINLINE
D3DXMATRIX::D3DXMATRIX( FLOAT f11, FLOAT f12, FLOAT f13, FLOAT f14,
                        FLOAT f21, FLOAT f22, FLOAT f23, FLOAT f24,
                        FLOAT f31, FLOAT f32, FLOAT f33, FLOAT f34,
                        FLOAT f41, FLOAT f42, FLOAT f43, FLOAT f44 )
{
    _11 = f11; _12 = f12; _13 = f13; _14 = f14;
    _21 = f21; _22 = f22; _23 = f23; _24 = f24;
    _31 = f31; _32 = f32; _33 = f33; _34 = f34;
    _41 = f41; _42 = f42; _43 = f43; _44 = f44;
}



// access grants
D3DXINLINE FLOAT&
D3DXMATRIX::operator () ( UINT iRow, UINT iCol )
{
    return m[iRow][iCol];
}

D3DXINLINE FLOAT
D3DXMATRIX::operator () ( UINT iRow, UINT iCol ) const
{
    return m[iRow][iCol];
}


// casting operators
D3DXINLINE
D3DXMATRIX::operator FLOAT* ()
{
    return (FLOAT *) &_11;
}

D3DXINLINE
D3DXMATRIX::operator CONST FLOAT* () const
{
    return (CONST FLOAT *) &_11;
}


// assignment operators
D3DXINLINE D3DXMATRIX&
D3DXMATRIX::operator *= ( CONST D3DXMATRIX& mat )
{
    D3DXMatrixMultiply(this, this, &mat);
    return *this;
}

D3DXINLINE D3DXMATRIX&
D3DXMATRIX::operator += ( CONST D3DXMATRIX& mat )
{
    _11 += mat._11; _12 += mat._12; _13 += mat._13; _14 += mat._14;
    _21 += mat._21; _22 += mat._22; _23 += mat._23; _24 += mat._24;
    _31 += mat._31; _32 += mat._32; _33 += mat._33; _34 += mat._34;
    _41 += mat._41; _42 += mat._42; _43 += mat._43; _44 += mat._44;
    return *this;
}

D3DXINLINE D3DXMATRIX&
D3DXMATRIX::operator -= ( CONST D3DXMATRIX& mat )
{
    _11 -= mat._11; _12 -= mat._12; _13 -= mat._13; _14 -= mat._14;
    _21 -= mat._21; _22 -= mat._22; _23 -= mat._23; _24 -= mat._24;
    _31 -= mat._31; _32 -= mat._32; _33 -= mat._33; _34 -= mat._34;
    _41 -= mat._41; _42 -= mat._42; _43 -= mat._43; _44 -= mat._44;
    return *this;
}

D3DXINLINE D3DXMATRIX&
D3DXMATRIX::operator *= ( FLOAT f )
{
    _11 *= f; _12 *= f; _13 *= f; _14 *= f;
    _21 *= f; _22 *= f; _23 *= f; _24 *= f;
    _31 *= f; _32 *= f; _33 *= f; _34 *= f;
    _41 *= f; _42 *= f; _43 *= f; _44 *= f;
    return *this;
}

D3DXINLINE D3DXMATRIX&
D3DXMATRIX::operator /= ( FLOAT f )
{
    FLOAT fInv = 1.0f / f;
    _11 *= fInv; _12 *= fInv; _13 *= fInv; _14 *= fInv;
    _21 *= fInv; _22 *= fInv; _23 *= fInv; _24 *= fInv;
    _31 *= fInv; _32 *= fInv; _33 *= fInv; _34 *= fInv;
    _41 *= fInv; _42 *= fInv; _43 *= fInv; _44 *= fInv;
    return *this;
}


// unary operators
D3DXINLINE D3DXMATRIX
D3DXMATRIX::operator + () const
{
    return *this;
}

D3DXINLINE D3DXMATRIX
D3DXMATRIX::operator - () const
{
    return D3DXMATRIX(-_11, -_12, -_13, -_14,
                      -_21, -_22, -_23, -_24,
                      -_31, -_32, -_33, -_34,
                      -_41, -_42, -_43, -_44);
}


// binary operators
D3DXINLINE D3DXMATRIX
D3DXMATRIX::operator * ( CONST D3DXMATRIX& mat ) const
{
    D3DXMATRIX matT;
    D3DXMatrixMultiply(&matT, this, &mat);
    return matT;
}

D3DXINLINE D3DXMATRIX
D3DXMATRIX::operator + ( CONST D3DXMATRIX& mat ) const
{
    return D3DXMATRIX(_11 + mat._11, _12 + mat._12, _13 + mat._13, _14 + mat._14,
                      _21 + mat._21, _22 + mat._22, _23 + mat._23, _24 + mat._24,
                      _31 + mat._31, _32 + mat._32, _33 + mat._33, _34 + mat._34,
                      _41 + mat._41, _42 + mat._42, _43 + mat._43, _44 + mat._44);
}

D3DXINLINE D3DXMATRIX
D3DXMATRIX::operator - ( CONST D3DXMATRIX& mat ) const
{
    return D3DXMATRIX(_11 - mat._11, _12 - mat._12, _13 - mat._13, _14 - mat._14,
                      _21 - mat._21, _22 - mat._22, _23 - mat._23, _24 - mat._24,
                      _31 - mat._31, _32 - mat._32, _33 - mat._33, _34 - mat._34,
                      _41 - mat._41, _42 - mat._42, _43 - mat._43, _44 - mat._44);
}

D3DXINLINE D3DXMATRIX
D3DXMATRIX::operator * ( FLOAT f ) const
{
    return D3DXMATRIX(_11 * f, _12 * f, _13 * f, _14 * f,
                      _21 * f, _22 * f, _23 * f, _24 * f,
                      _31 * f, _32 * f, _33 * f, _34 * f,
                      _41 * f, _42 * f, _43 * f, _44 * f);
}

D3DXINLINE D3DXMATRIX
D3DXMATRIX::operator / ( FLOAT f ) const
{
    FLOAT fInv = 1.0f / f;
    return D3DXMATRIX(_11 * fInv, _12 * fInv, _13 * fInv, _14 * fInv,
                      _21 * fInv, _22 * fInv, _23 * fInv, _24 * fInv,
                      _31 * fInv, _32 * fInv, _33 * fInv, _34 * fInv,
                      _41 * fInv, _42 * fInv, _43 * fInv, _44 * fInv);
}


D3DXINLINE D3DXMATRIX
operator * ( FLOAT f, CONST D3DXMATRIX& mat )
{
    return D3DXMATRIX(f * mat._11, f * mat._12, f * mat._13, f * mat._14,
                      f * mat._21, f * mat._22, f * mat._23, f * mat._24,
                      f * mat._31, f * mat._32, f * mat._33, f * mat._34,
                      f * mat._41, f * mat._42, f * mat._43, f * mat._44);
}


D3DXINLINE BOOL
D3DXMATRIX::operator == ( CONST D3DXMATRIX& mat ) const
{
    return 0 == memcmp(this, &mat, sizeof(D3DXMATRIX));
}

D3DXINLINE BOOL
D3DXMATRIX::operator != ( CONST D3DXMATRIX& mat ) const
{
    return 0 != memcmp(this, &mat, sizeof(D3DXMATRIX));
}



//--------------------------
// Quaternion
//--------------------------

D3DXINLINE
D3DXQUATERNION::D3DXQUATERNION( CONST FLOAT* pf )
{
#ifdef D3DX_DEBUG
    if(!pf)
        return;
#endif

    x = pf[0];
    y = pf[1];
    z = pf[2];
    w = pf[3];
}

D3DXINLINE
D3DXQUATERNION::D3DXQUATERNION( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
{
    x = fx;
    y = fy;
    z = fz;
    w = fw;
}


// casting
D3DXINLINE
D3DXQUATERNION::operator FLOAT* ()
{
    return (FLOAT *) &x;
}

D3DXINLINE
D3DXQUATERNION::operator CONST FLOAT* () const
{
    return (CONST FLOAT *) &x;
}


// assignment operators
D3DXINLINE D3DXQUATERNION&
D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
{
    x += q.x;
    y += q.y;
    z += q.z;
    w += q.w;
    return *this;
}

D3DXINLINE D3DXQUATERNION&
D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
{
    x -= q.x;
    y -= q.y;
    z -= q.z;
    w -= q.w;
    return *this;
}

D3DXINLINE D3DXQUATERNION&
D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
{
    D3DXQuaternionMultiply(this, this, &q);
    return *this;
}

D3DXINLINE D3DXQUATERNION&
D3DXQUATERNION::operator *= ( FLOAT f )
{
    x *= f;
    y *= f;
    z *= f;
    w *= f;
    return *this;
}

D3DXINLINE D3DXQUATERNION&
D3DXQUATERNION::operator /= ( FLOAT f )
{
    FLOAT fInv = 1.0f / f;
    x *= fInv;
    y *= fInv;
    z *= fInv;
    w *= fInv;
    return *this;
}


// unary operators
D3DXINLINE D3DXQUATERNION
D3DXQUATERNION::operator + () const
{
    return *this;
}

D3DXINLINE D3DXQUATERNION
D3DXQUATERNION::operator - () const
{
    return D3DXQUATERNION(-x, -y, -z, -w);
}


// binary operators
D3DXINLINE D3DXQUATERNION
D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
{
    return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
}

D3DXINLINE D3DXQUATERNION
D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
{
    return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
}

D3DXINLINE D3DXQUATERNION
D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
{
    D3DXQUATERNION qT;
    D3DXQuaternionMultiply(&qT, this, &q);
    return qT;
}

D3DXINLINE D3DXQUATERNION
D3DXQUATERNION::operator * ( FLOAT f ) const
{
    return D3DXQUATERNION(x * f, y * f, z * f, w * f);
}

D3DXINLINE D3DXQUATERNION
D3DXQUATERNION::operator / ( FLOAT f ) const
{
    FLOAT fInv = 1.0f / f;
    return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
}


D3DXINLINE D3DXQUATERNION
operator * (FLOAT f, CONST D3DXQUATERNION& q )
{
    return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
}


D3DXINLINE BOOL
D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
{
    return x == q.x && y == q.y && z == q.z && w == q.w;
}

D3DXINLINE BOOL
D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
{
    return x != q.x || y != q.y || z != q.z || w != q.w;
}



//--------------------------
// Plane
//--------------------------

D3DXINLINE
D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
{
#ifdef D3DX_DEBUG
    if(!pf)
        return;
#endif

    a = pf[0];
    b = pf[1];
    c = pf[2];
    d = pf[3];
}

D3DXINLINE
D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
{
    a = fa;
    b = fb;
    c = fc;
    d = fd;
}


// casting
D3DXINLINE
D3DXPLANE::operator FLOAT* ()
{
    return (FLOAT *) &a;
}

D3DXINLINE
D3DXPLANE::operator CONST FLOAT* () const
{
    return (CONST FLOAT *) &a;
}


// unary operators
D3DXINLINE D3DXPLANE
D3DXPLANE::operator + () const
{
    return *this;
}

D3DXINLINE D3DXPLANE
D3DXPLANE::operator - () const
{
    return D3DXPLANE(-a, -b, -c, -d);
}


// binary operators
D3DXINLINE BOOL
D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
{
    return a == p.a && b == p.b && c == p.c && d == p.d;
}

D3DXINLINE BOOL
D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
{
    return a != p.a || b != p.b || c != p.c || d != p.d;
}




//--------------------------
// Color
//--------------------------

D3DXINLINE
D3DXCOLOR::D3DXCOLOR( DWORD dw )
{
    CONST FLOAT f = 1.0f / 255.0f;
    r = f * (FLOAT) (unsigned char) (dw >> 16);
    g = f * (FLOAT) (unsigned char) (dw >>  8);
    b = f * (FLOAT) (unsigned char) (dw >>  0);
    a = f * (FLOAT) (unsigned char) (dw >> 24);
}

D3DXINLINE
D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
{
#ifdef D3DX_DEBUG
    if(!pf)
        return;
#endif

    r = pf[0];
    g = pf[1];
    b = pf[2];
    a = pf[3];
}

D3DXINLINE
D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
{
    r = c.r;
    g = c.g;
    b = c.b;
    a = c.a;
}

D3DXINLINE
D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
{
    r = fr;
    g = fg;
    b = fb;
    a = fa;
}


// casting
D3DXINLINE
D3DXCOLOR::operator DWORD () const
{
    DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
    DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
    DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
    DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

    return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
}


D3DXINLINE
D3DXCOLOR::operator FLOAT * ()
{
    return (FLOAT *) &r;
}

D3DXINLINE
D3DXCOLOR::operator CONST FLOAT * () const
{
    return (CONST FLOAT *) &r;
}


D3DXINLINE
D3DXCOLOR::operator D3DCOLORVALUE * ()
{
    return (D3DCOLORVALUE *) &r;
}

D3DXINLINE
D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
{
    return (CONST D3DCOLORVALUE *) &r;
}


D3DXINLINE
D3DXCOLOR::operator D3DCOLORVALUE& ()
{
    return *((D3DCOLORVALUE *) &r);
}

D3DXINLINE
D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
{
    return *((CONST D3DCOLORVALUE *) &r);
}


// assignment operators
D3DXINLINE D3DXCOLOR&
D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
{
    r += c.r;
    g += c.g;
    b += c.b;
    a += c.a;
    return *this;
}

D3DXINLINE D3DXCOLOR&
D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
{
    r -= c.r;
    g -= c.g;
    b -= c.b;
    a -= c.a;
    return *this;
}

D3DXINLINE D3DXCOLOR&
D3DXCOLOR::operator *= ( FLOAT f )
{
    r *= f;
    g *= f;
    b *= f;
    a *= f;
    return *this;
}

D3DXINLINE D3DXCOLOR&
D3DXCOLOR::operator /= ( FLOAT f )
{
    FLOAT fInv = 1.0f / f;
    r *= fInv;
    g *= fInv;
    b *= fInv;
    a *= fInv;
    return *this;
}


// unary operators
D3DXINLINE D3DXCOLOR
D3DXCOLOR::operator + () const
{
    return *this;
}

D3DXINLINE D3DXCOLOR
D3DXCOLOR::operator - () const
{
    return D3DXCOLOR(-r, -g, -b, -a);
}


// binary operators
D3DXINLINE D3DXCOLOR
D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
{
    return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
}

D3DXINLINE D3DXCOLOR
D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
{
    return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
}

D3DXINLINE D3DXCOLOR
D3DXCOLOR::operator * ( FLOAT f ) const
{
    return D3DXCOLOR(r * f, g * f, b * f, a * f);
}

D3DXINLINE D3DXCOLOR
D3DXCOLOR::operator / ( FLOAT f ) const
{
    FLOAT fInv = 1.0f / f;
    return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
}


D3DXINLINE D3DXCOLOR
operator * (FLOAT f, CONST D3DXCOLOR& c )
{
    return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
}


D3DXINLINE BOOL
D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
{
    return r == c.r && g == c.g && b == c.b && a == c.a;
}

D3DXINLINE BOOL
D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
{
    return r != c.r || g != c.g || b != c.b || a != c.a;
}


#endif //__cplusplus



//===========================================================================
//
// Inline functions
//
//===========================================================================


//--------------------------
// 2D Vector
//--------------------------

D3DXINLINE FLOAT D3DXVec2Length
    ( CONST D3DXVECTOR2 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

#ifdef __cplusplus
    return sqrtf(pV->x * pV->x + pV->y * pV->y);
#else
    return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
#endif
}

D3DXINLINE FLOAT D3DXVec2LengthSq
    ( CONST D3DXVECTOR2 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

    return pV->x * pV->x + pV->y * pV->y;
}

D3DXINLINE FLOAT D3DXVec2Dot
    ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pV1 || !pV2)
        return 0.0f;
#endif

    return pV1->x * pV2->x + pV1->y * pV2->y;
}

D3DXINLINE FLOAT D3DXVec2CCW
    ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pV1 || !pV2)
        return 0.0f;
#endif

    return pV1->x * pV2->y - pV1->y * pV2->x;
}

D3DXINLINE D3DXVECTOR2* D3DXVec2Add
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + pV2->x;
    pOut->y = pV1->y + pV2->y;
    return pOut;
}

D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x - pV2->x;
    pOut->y = pV1->y - pV2->y;
    return pOut;
}

D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
    return pOut;
}

D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
    return pOut;
}

D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV)
        return NULL;
#endif

    pOut->x = pV->x * s;
    pOut->y = pV->y * s;
    return pOut;
}

D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
      FLOAT s )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + s * (pV2->x - pV1->x);
    pOut->y = pV1->y + s * (pV2->y - pV1->y);
    return pOut;
}


//--------------------------
// 3D Vector
//--------------------------

D3DXINLINE FLOAT D3DXVec3Length
    ( CONST D3DXVECTOR3 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

#ifdef __cplusplus
    return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
#else
    return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
#endif
}

D3DXINLINE FLOAT D3DXVec3LengthSq
    ( CONST D3DXVECTOR3 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

    return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;
}

D3DXINLINE FLOAT D3DXVec3Dot
    ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pV1 || !pV2)
        return 0.0f;
#endif

    return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;
}

D3DXINLINE D3DXVECTOR3* D3DXVec3Cross
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
{
    D3DXVECTOR3 v;

#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    v.x = pV1->y * pV2->z - pV1->z * pV2->y;
    v.y = pV1->z * pV2->x - pV1->x * pV2->z;
    v.z = pV1->x * pV2->y - pV1->y * pV2->x;

    *pOut = v;
    return pOut;
}

D3DXINLINE D3DXVECTOR3* D3DXVec3Add
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + pV2->x;
    pOut->y = pV1->y + pV2->y;
    pOut->z = pV1->z + pV2->z;
    return pOut;
}

D3DXINLINE D3DXVECTOR3* D3DXVec3Subtract
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x - pV2->x;
    pOut->y = pV1->y - pV2->y;
    pOut->z = pV1->z - pV2->z;
    return pOut;
}

D3DXINLINE D3DXVECTOR3* D3DXVec3Minimize
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
    pOut->z = pV1->z < pV2->z ? pV1->z : pV2->z;
    return pOut;
}

D3DXINLINE D3DXVECTOR3* D3DXVec3Maximize
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
    pOut->z = pV1->z > pV2->z ? pV1->z : pV2->z;
    return pOut;
}

D3DXINLINE D3DXVECTOR3* D3DXVec3Scale
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, FLOAT s)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV)
        return NULL;
#endif

    pOut->x = pV->x * s;
    pOut->y = pV->y * s;
    pOut->z = pV->z * s;
    return pOut;
}

D3DXINLINE D3DXVECTOR3* D3DXVec3Lerp
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2,
      FLOAT s )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + s * (pV2->x - pV1->x);
    pOut->y = pV1->y + s * (pV2->y - pV1->y);
    pOut->z = pV1->z + s * (pV2->z - pV1->z);
    return pOut;
}


//--------------------------
// 4D Vector
//--------------------------

D3DXINLINE FLOAT D3DXVec4Length
    ( CONST D3DXVECTOR4 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

#ifdef __cplusplus
    return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z + pV->w * pV->w);
#else
    return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z + pV->w * pV->w);
#endif
}

D3DXINLINE FLOAT D3DXVec4LengthSq
    ( CONST D3DXVECTOR4 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

    return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z + pV->w * pV->w;
}

D3DXINLINE FLOAT D3DXVec4Dot
    ( CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pV1 || !pV2)
        return 0.0f;
#endif

    return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z + pV1->w * pV2->w;
}

D3DXINLINE D3DXVECTOR4* D3DXVec4Add
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + pV2->x;
    pOut->y = pV1->y + pV2->y;
    pOut->z = pV1->z + pV2->z;
    pOut->w = pV1->w + pV2->w;
    return pOut;
}

D3DXINLINE D3DXVECTOR4* D3DXVec4Subtract
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x - pV2->x;
    pOut->y = pV1->y - pV2->y;
    pOut->z = pV1->z - pV2->z;
    pOut->w = pV1->w - pV2->w;
    return pOut;
}

D3DXINLINE D3DXVECTOR4* D3DXVec4Minimize
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
    pOut->z = pV1->z < pV2->z ? pV1->z : pV2->z;
    pOut->w = pV1->w < pV2->w ? pV1->w : pV2->w;
    return pOut;
}

D3DXINLINE D3DXVECTOR4* D3DXVec4Maximize
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
    pOut->z = pV1->z > pV2->z ? pV1->z : pV2->z;
    pOut->w = pV1->w > pV2->w ? pV1->w : pV2->w;
    return pOut;
}

D3DXINLINE D3DXVECTOR4* D3DXVec4Scale
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV, FLOAT s)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV)
        return NULL;
#endif

    pOut->x = pV->x * s;
    pOut->y = pV->y * s;
    pOut->z = pV->z * s;
    pOut->w = pV->w * s;
    return pOut;
}

D3DXINLINE D3DXVECTOR4* D3DXVec4Lerp
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2,
      FLOAT s )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + s * (pV2->x - pV1->x);
    pOut->y = pV1->y + s * (pV2->y - pV1->y);
    pOut->z = pV1->z + s * (pV2->z - pV1->z);
    pOut->w = pV1->w + s * (pV2->w - pV1->w);
    return pOut;
}


//--------------------------
// 4D Matrix
//--------------------------

D3DXINLINE D3DXMATRIX* D3DXMatrixIdentity
    ( D3DXMATRIX *pOut )
{
#ifdef D3DX_DEBUG
    if(!pOut)
        return NULL;
#endif

    pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =
    pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
    pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
    pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;

    pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;
    return pOut;
}


D3DXINLINE BOOL D3DXMatrixIsIdentity
    ( CONST D3DXMATRIX *pM )
{
#ifdef D3DX_DEBUG
    if(!pM)
        return FALSE;
#endif

    return pM->m[0][0] == 1.0f && pM->m[0][1] == 0.0f && pM->m[0][2] == 0.0f && pM->m[0][3] == 0.0f &&
           pM->m[1][0] == 0.0f && pM->m[1][1] == 1.0f && pM->m[1][2] == 0.0f && pM->m[1][3] == 0.0f &&
           pM->m[2][0] == 0.0f && pM->m[2][1] == 0.0f && pM->m[2][2] == 1.0f && pM->m[2][3] == 0.0f &&
           pM->m[3][0] == 0.0f && pM->m[3][1] == 0.0f && pM->m[3][2] == 0.0f && pM->m[3][3] == 1.0f;
}


//--------------------------
// Quaternion
//--------------------------

D3DXINLINE FLOAT D3DXQuaternionLength
    ( CONST D3DXQUATERNION *pQ )
{
#ifdef D3DX_DEBUG
    if(!pQ)
        return 0.0f;
#endif

#ifdef __cplusplus
    return sqrtf(pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z + pQ->w * pQ->w);
#else
    return (FLOAT) sqrt(pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z + pQ->w * pQ->w);
#endif
}

D3DXINLINE FLOAT D3DXQuaternionLengthSq
    ( CONST D3DXQUATERNION *pQ )
{
#ifdef D3DX_DEBUG
    if(!pQ)
        return 0.0f;
#endif

    return pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z + pQ->w * pQ->w;
}

D3DXINLINE FLOAT D3DXQuaternionDot
    ( CONST D3DXQUATERNION *pQ1, CONST D3DXQUATERNION *pQ2 )
{
#ifdef D3DX_DEBUG
    if(!pQ1 || !pQ2)
        return 0.0f;
#endif

    return pQ1->x * pQ2->x + pQ1->y * pQ2->y + pQ1->z * pQ2->z + pQ1->w * pQ2->w;
}


D3DXINLINE D3DXQUATERNION* D3DXQuaternionIdentity
    ( D3DXQUATERNION *pOut )
{
#ifdef D3DX_DEBUG
    if(!pOut)
        return NULL;
#endif

    pOut->x = pOut->y = pOut->z = 0.0f;
    pOut->w = 1.0f;
    return pOut;
}

D3DXINLINE BOOL D3DXQuaternionIsIdentity
    ( CONST D3DXQUATERNION *pQ )
{
#ifdef D3DX_DEBUG
    if(!pQ)
        return FALSE;
#endif

    return pQ->x == 0.0f && pQ->y == 0.0f && pQ->z == 0.0f && pQ->w == 1.0f;
}


D3DXINLINE D3DXQUATERNION* D3DXQuaternionConjugate
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pQ)
        return NULL;
#endif

    pOut->x = -pQ->x;
    pOut->y = -pQ->y;
    pOut->z = -pQ->z;
    pOut->w =  pQ->w;
    return pOut;
}


//--------------------------
// Plane
//--------------------------

D3DXINLINE FLOAT D3DXPlaneDot
    ( CONST D3DXPLANE *pP, CONST D3DXVECTOR4 *pV)
{
#ifdef D3DX_DEBUG
    if(!pP || !pV)
        return 0.0f;
#endif

    return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d * pV->w;
}

D3DXINLINE FLOAT D3DXPlaneDotCoord
    ( CONST D3DXPLANE *pP, CONST D3DXVECTOR3 *pV)
{
#ifdef D3DX_DEBUG
    if(!pP || !pV)
        return 0.0f;
#endif

    return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;
}

D3DXINLINE FLOAT D3DXPlaneDotNormal
    ( CONST D3DXPLANE *pP, CONST D3DXVECTOR3 *pV)
{
#ifdef D3DX_DEBUG
    if(!pP || !pV)
        return 0.0f;
#endif

    return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z;
}


//--------------------------
// Color
//--------------------------

D3DXINLINE D3DXCOLOR* D3DXColorNegative
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC)
        return NULL;
#endif

    pOut->r = 1.0f - pC->r;
    pOut->g = 1.0f - pC->g;
    pOut->b = 1.0f - pC->b;
    pOut->a = pC->a;
    return pOut;
}

D3DXINLINE D3DXCOLOR* D3DXColorAdd
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC1 || !pC2)
        return NULL;
#endif

    pOut->r = pC1->r + pC2->r;
    pOut->g = pC1->g + pC2->g;
    pOut->b = pC1->b + pC2->b;
    pOut->a = pC1->a + pC2->a;
    return pOut;
}

D3DXINLINE D3DXCOLOR* D3DXColorSubtract
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC1 || !pC2)
        return NULL;
#endif

    pOut->r = pC1->r - pC2->r;
    pOut->g = pC1->g - pC2->g;
    pOut->b = pC1->b - pC2->b;
    pOut->a = pC1->a - pC2->a;
    return pOut;
}

D3DXINLINE D3DXCOLOR* D3DXColorScale
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC, FLOAT s)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC)
        return NULL;
#endif

    pOut->r = pC->r * s;
    pOut->g = pC->g * s;
    pOut->b = pC->b * s;
    pOut->a = pC->a * s;
    return pOut;
}

D3DXINLINE D3DXCOLOR* D3DXColorModulate
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC1 || !pC2)
        return NULL;
#endif

    pOut->r = pC1->r * pC2->r;
    pOut->g = pC1->g * pC2->g;
    pOut->b = pC1->b * pC2->b;
    pOut->a = pC1->a * pC2->a;
    return pOut;
}

D3DXINLINE D3DXCOLOR* D3DXColorLerp
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2, FLOAT s)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC1 || !pC2)
        return NULL;
#endif

    pOut->r = pC1->r + s * (pC2->r - pC1->r);
    pOut->g = pC1->g + s * (pC2->g - pC1->g);
    pOut->b = pC1->b + s * (pC2->b - pC1->b);
    pOut->a = pC1->a + s * (pC2->a - pC1->a);
    return pOut;
}


#endif // __D3DX8MATH_INL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dxg\d3dx8tex.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 - 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8tex.h
//  Content:    D3DX texturing APIs
//
///////////////////////////////////////////////////////////////////////////

#include "d3dx8.h"

#ifndef __D3DX8TEX_H__
#define __D3DX8TEX_H__

//-------------------------------------------------------------------------
// D3DXSetDXT3DXT5
// ---------------
//
// Set premultiplied alpha format for DXT surface and texture processing.
// When set to true, DXT surfaces will be processed with nonpremultiplied
// alpha i.e. DXT3 / DXT5 format. When set to false, surfaces will be
// processed with premultiplied alpha, i.e. DXT2 / DXT4 format. The default
// is nonpremultiplied alpha - DXT3 / DXT5.
//
//-------------------------------------------------------------------------

void WINAPI D3DXSetDXT3DXT5(BOOL Set);

//-------------------------------------------------------------------------
// D3DXGetDXT3DXT5
// ---------------
//
// Get whether D3DX is currently using nonpremultiplied alpha format -
// DXT3 / DXT5 or premultiplied alpha format - DXT2 / DXT4 for DXT surface
// and texture processing.
//
//-------------------------------------------------------------------------

BOOL WINAPI D3DXGetDXT3DXT5(void);

//-------------------------------------------------------------------------
// D3DX_FILTER flags:
// ------------------
//
// A valid filter must contain one of these values:
//
//  D3DX_FILTER_NONE
//      No scaling or filtering will take place.  Pixels outside the bounds
//      of the source image are assumed to be transparent black.
//  D3DX_FILTER_POINT
//      Each destination pixel is computed by sampling the nearest pixel
//      from the source image.
//  D3DX_FILTER_LINEAR
//      Each destination pixel is computed by linearly interpolating between
//      the nearest pixels in the source image.  This filter works best
//      when the scale on each axis is less than 2.
//  D3DX_FILTER_TRIANGLE
//      Every pixel in the source image contributes equally to the
//      destination image.  This is the slowest of all the filters.
//  D3DX_FILTER_BOX
//      Each pixel is computed by averaging a 2x2(x2) box pixels from
//      the source image. Only works when the dimensions of the
//      destination are half those of the source. (as with mip maps)
//
//
// And can be OR'd with any of these optional flags:
//
//  D3DX_FILTER_MIRROR_U
//      Indicates that pixels off the edge of the texture on the U-axis
//      should be mirrored, not wraped.
//  D3DX_FILTER_MIRROR_V
//      Indicates that pixels off the edge of the texture on the V-axis
//      should be mirrored, not wraped.
//  D3DX_FILTER_MIRROR_W
//      Indicates that pixels off the edge of the texture on the W-axis
//      should be mirrored, not wraped.
//  D3DX_FILTER_MIRROR
//      Same as specifying D3DX_FILTER_MIRROR_U, D3DX_FILTER_MIRROR_V,
//      and D3DX_FILTER_MIRROR_V
//  D3DX_FILTER_DITHER
//      Dithers the resulting image.
//
//-------------------------------------------------------------------------

#define D3DX_FILTER_NONE      (1 << 0)
#define D3DX_FILTER_POINT     (2 << 0)
#define D3DX_FILTER_LINEAR    (3 << 0)
#define D3DX_FILTER_TRIANGLE  (4 << 0)
#define D3DX_FILTER_BOX       (5 << 0)

#define D3DX_FILTER_MIRROR_U  (1 << 16)
#define D3DX_FILTER_MIRROR_V  (2 << 16)
#define D3DX_FILTER_MIRROR_W  (4 << 16)
#define D3DX_FILTER_MIRROR    (7 << 16)
#define D3DX_FILTER_DITHER    (8 << 16)


//-------------------------------------------------------------------------
// D3DXIMAGE_INFO:
// ---------------
// This structure is used to return a rough description of what the
// the original contents of an image file looked like.
//
//  Width
//      Width of original image in pixels
//  Height
//      Height of original image in pixels
//  Depth
//      Depth of original image in pixels
//  MipLevels
//      Number of mip levels in original image
//  Format
//      D3D format which most closely describes the data in original image
//
//-------------------------------------------------------------------------


typedef struct _D3DXIMAGE_INFO
{
    UINT Width;
    UINT Height;
    UINT Depth;
    UINT MipLevels;
    D3DFORMAT Format;

} D3DXIMAGE_INFO;

#ifndef _PALETTEENTRY_DEFINED
#define _PALETTEENTRY_DEFINED

typedef struct tagPALETTEENTRY {
    BYTE        peRed;
    BYTE        peGreen;
    BYTE        peBlue;
    BYTE        peFlags;
} PALETTEENTRY, *PPALETTEENTRY, FAR *LPPALETTEENTRY;

#endif


#ifdef __cplusplus
extern "C" {
#endif //__cplusplus


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


//-------------------------------------------------------------------------
// D3DXLoadSurfaceFromFile/Resource:
// ---------------------------------
// Load surface from a file or resource
//
// Parameters:
//  pDestSurface
//      Destination surface, which will receive the image.
//  pDestPalette
//      Destination palette of 256 colors, or NULL
//  pDestRect
//      Destination rectangle, or NULL for entire surface
//  pSrcFile
//      File name of the source image.
//  pSrcModule
//      Module where resource is located, or NULL for module associated
//      with image the os used to create the current process.
//  pSrcResource
//      Resource name
//  pSrcData
//      Pointer to file in memory.
//  SrcDataSize
//      Size in bytes of file in memory.
//  pSrcRect
//      Source rectangle, or NULL for entire image
//  Filter
//      D3DX_FILTER flags controlling how the image is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_TRIANGLE.
//  ColorKey
//      Color to replace with transparent black, or 0 to disable colorkey.
//      This is always a 32-bit ARGB color, independent of the source image
//      format.  Alpha is significant, and should usually be set to FF for
//      opaque colorkeys.  (ex. Opaque black == 0xff000000)
//  pSrcInfo
//      Pointer to a D3DXIMAGE_INFO structure to be filled in with the
//      description of the data in the source image file, or NULL.
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXLoadSurfaceFromFileA(
        LPDIRECT3DSURFACE8    pDestSurface,
        CONST PALETTEENTRY*   pDestPalette,
        CONST RECT*           pDestRect,
        LPCSTR                pSrcFile,
        CONST RECT*           pSrcRect,
        DWORD                 Filter,
        D3DCOLOR              ColorKey,
        D3DXIMAGE_INFO*       pSrcInfo);

#define D3DXLoadSurfaceFromFile D3DXLoadSurfaceFromFileA


HRESULT WINAPI
    D3DXLoadSurfaceFromFileInMemory(
        LPDIRECT3DSURFACE8    pDestSurface,
        CONST PALETTEENTRY*   pDestPalette,
        CONST RECT*           pDestRect,
        LPCVOID               pSrcData,
        UINT                  SrcDataSize,
        CONST RECT*           pSrcRect,
        DWORD                 Filter,
        D3DCOLOR              ColorKey,
        D3DXIMAGE_INFO*       pSrcInfo);



//-------------------------------------------------------------------------
// D3DXLoadSurfaceFromSurface:
// --------------------------
// Load surface from another surface (with color conversion)
//
// Parameters:
//  pDestSurface
//      Destination surface, which will receive the image.
//  pDestPalette
//      Destination palette of 256 colors, or NULL
//  pDestRect
//      Destination rectangle, or NULL for entire surface
//  pSrcSurface
//      Source surface
//  pSrcPalette
//      Source palette of 256 colors, or NULL
//  pSrcRect
//      Source rectangle, or NULL for entire surface
//  Filter
//      D3DX_FILTER flags controlling how the image is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_TRIANGLE.
//  ColorKey
//      Color to replace with transparent black, or 0 to disable colorkey.
//      This is always a 32-bit ARGB color, independent of the source image
//      format.  Alpha is significant, and should usually be set to FF for
//      opaque colorkeys.  (ex. Opaque black == 0xff000000)
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXLoadSurfaceFromSurface(
        LPDIRECT3DSURFACE8    pDestSurface,
        CONST PALETTEENTRY*   pDestPalette,
        CONST RECT*           pDestRect,
        LPDIRECT3DSURFACE8    pSrcSurface,
        CONST PALETTEENTRY*   pSrcPalette,
        CONST RECT*           pSrcRect,
        DWORD                 Filter,
        D3DCOLOR              ColorKey);


//-------------------------------------------------------------------------
// D3DXLoadSurfaceFromMemory:
// ------------------------
// Load surface from memory.
//
// Parameters:
//  pDestSurface
//      Destination surface, which will receive the image.
//  pDestPalette
//      Destination palette of 256 colors, or NULL
//  pDestRect
//      Destination rectangle, or NULL for entire surface
//  pSrcMemory
//      Pointer to the top-left corner of the source image in memory
//  SrcFormat
//      Pixel format of the source image.
//  SrcPitch
//      Pitch of source image, in bytes.  For DXT formats, this number
//      should represent the width of one row of cells, in bytes.
//  pSrcPalette
//      Source palette of 256 colors, or NULL
//  pSrcRect
//      Source rectangle.
//  Filter
//      D3DX_FILTER flags controlling how the image is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_TRIANGLE.
//  ColorKey
//      Color to replace with transparent black, or 0 to disable colorkey.
//      This is always a 32-bit ARGB color, independent of the source image
//      format.  Alpha is significant, and should usually be set to FF for
//      opaque colorkeys.  (ex. Opaque black == 0xff000000)
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXLoadSurfaceFromMemory(
        LPDIRECT3DSURFACE8    pDestSurface,
        CONST PALETTEENTRY*   pDestPalette,
        CONST RECT*           pDestRect,
        LPCVOID               pSrcMemory,
        D3DFORMAT             SrcFormat,
        UINT                  SrcPitch,
        CONST PALETTEENTRY*   pSrcPalette,
        CONST RECT*           pSrcRect,
        DWORD                 Filter,
        D3DCOLOR              ColorKey);



///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////



//-------------------------------------------------------------------------
// D3DXLoadVolumeFromVolume:
// --------------------------
// Load volume from another volume (with color conversion)
//
// Parameters:
//  pDestVolume
//      Destination volume, which will receive the image.
//  pDestPalette
//      Destination palette of 256 colors, or NULL
//  pDestBox
//      Destination box, or NULL for entire volume
//  pSrcVolume
//      Source volume
//  pSrcPalette
//      Source palette of 256 colors, or NULL
//  pSrcBox
//      Source box, or NULL for entire volume
//  Filter
//      D3DX_FILTER flags controlling how the image is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_TRIANGLE.
//  ColorKey
//      Color to replace with transparent black, or 0 to disable colorkey.
//      This is always a 32-bit ARGB color, independent of the source image
//      format.  Alpha is significant, and should usually be set to FF for
//      opaque colorkeys.  (ex. Opaque black == 0xff000000)
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXLoadVolumeFromVolume(
        LPDIRECT3DVOLUME8     pDestVolume,
        CONST PALETTEENTRY*   pDestPalette,
        CONST D3DBOX*         pDestBox,
        LPDIRECT3DVOLUME8     pSrcVolume,
        CONST PALETTEENTRY*   pSrcPalette,
        CONST D3DBOX*         pSrcBox,
        DWORD                 Filter,
        D3DCOLOR              ColorKey);


//-------------------------------------------------------------------------
// D3DXLoadVolumeFromMemory:
// ------------------------
// Load volume from memory.
//
// Parameters:
//  pDestVolume
//      Destination volume, which will receive the image.
//  pDestPalette
//      Destination palette of 256 colors, or NULL
//  pDestBox
//      Destination box, or NULL for entire volume
//  pSrcMemory
//      Pointer to the top-left corner of the source volume in memory
//  SrcFormat
//      Pixel format of the source volume.
//  SrcRowPitch
//      Pitch of source image, in bytes.  For DXT formats, this number
//      should represent the size of one row of cells, in bytes.
//  SrcSlicePitch
//      Pitch of source image, in bytes.  For DXT formats, this number
//      should represent the size of one slice of cells, in bytes.
//  pSrcPalette
//      Source palette of 256 colors, or NULL
//  pSrcBox
//      Source box.
//  Filter
//      D3DX_FILTER flags controlling how the image is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_TRIANGLE.
//  ColorKey
//      Color to replace with transparent black, or 0 to disable colorkey.
//      This is always a 32-bit ARGB color, independent of the source image
//      format.  Alpha is significant, and should usually be set to FF for
//      opaque colorkeys.  (ex. Opaque black == 0xff000000)
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXLoadVolumeFromMemory(
        LPDIRECT3DVOLUME8     pDestVolume,
        CONST PALETTEENTRY*   pDestPalette,
        CONST D3DBOX*         pDestBox,
        LPCVOID               pSrcMemory,
        D3DFORMAT             SrcFormat,
        UINT                  SrcRowPitch,
        UINT                  SrcSlicePitch,
        CONST PALETTEENTRY*   pSrcPalette,
        CONST D3DBOX*         pSrcBox,
        DWORD                 Filter,
        D3DCOLOR              ColorKey);


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////




//-------------------------------------------------------------------------
// D3DXCheckTextureRequirements:
// -----------------------------
//
// Checks texture creation parameters.  If parameters are invalid, this
// function returns corrected parameters.
//
// Parameters:
//
//  pDevice
//      The D3D device to be used
//  pWidth
//      Desired width in pixels, or NULL.  Returns corrected width.
//  pHeight
//      Desired height in pixels, or NULL.  Returns corrected height.
//  pNumMipLevels
//      Number of desired mipmap levels, or NULL.  Returns corrected number.
//  Usage
//      Texture usage flags
//  pFormat
//      Desired pixel format, or NULL.  Returns corrected format.
//  Pool
//      Memory pool to be used to create texture
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCheckTextureRequirements(
        LPDIRECT3DDEVICE8     pDevice,
        UINT*                 pWidth,
        UINT*                 pHeight,
        UINT*                 pNumMipLevels,
        DWORD                 Usage,
        D3DFORMAT*            pFormat,
        D3DPOOL               Pool);


//-------------------------------------------------------------------------
// D3DXCreateTexture:
// ------------------
// Create an empty texture
//
// Parameters:
//
//  pDevice
//      The D3D device with which the texture is going to be used.
//  Width
//      width in pixels; must be non-zero
//  Height
//      height in pixels; must be non-zero
//  MipLevels
//      number of mip levels desired; if zero or D3DX_DEFAULT, a complete
//      mipmap chain will be created.
//  Usage
//      Texture usage flags
//  Format
//      Pixel format.
//  Pool
//      Memory pool to be used to create texture
//  ppTexture
//      The texture object that will be created
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateTexture(
        LPDIRECT3DDEVICE8     pDevice,
        UINT                  Width,
        UINT                  Height,
        UINT                  MipLevels,
        DWORD                 Usage,
        D3DFORMAT             Format,
        D3DPOOL               Pool,
        LPDIRECT3DTEXTURE8*   ppTexture);


//-------------------------------------------------------------------------
// D3DXCreateTextureFromFile:
// --------------------------
// Create a texture object from a file.
//
// Parameters:
//
//  pDevice
//      The D3D device with which the texture is going to be used.
//  pSrcFile
//      File name.
//  hSrcModule
//      Module handle. if NULL, current module will be used.
//  pSrcResource
//      Resource name in module
//  pvSrcData
//      Pointer to file in memory.
//  SrcDataSize
//      Size in bytes of file in memory.
//  Width
//      Width in pixels; if zero or D3DX_DEFAULT, the width will be taken
//      from the file.
//  Height
//      Height in pixels; if zero of D3DX_DEFAULT, the height will be taken
//      from the file.
//  MipLevels
//      Number of mip levels;  if zero or D3DX_DEFAULT, a complete mipmap
//      chain will be created.
//  Usage
//      Texture usage flags
//  Format
//      Desired pixel format.  If D3DFMT_UNKNOWN, the format will be
//      taken from the file.
//  Pool
//      Memory pool to be used to create texture
//  Filter
//      D3DX_FILTER flags controlling how the image is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_TRIANGLE.
//  MipFilter
//      D3DX_FILTER flags controlling how each miplevel is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_BOX,
//  ColorKey
//      Color to replace with transparent black, or 0 to disable colorkey.
//      This is always a 32-bit ARGB color, independent of the source image
//      format.  Alpha is significant, and should usually be set to FF for
//      opaque colorkeys.  (ex. Opaque black == 0xff000000)
//  pSrcInfo
//      Pointer to a D3DXIMAGE_INFO structure to be filled in with the
//      description of the data in the source image file, or NULL.
//  pPalette
//      256 color palette to be filled in, or NULL
//  ppTexture
//      The texture object that will be created
//
//-------------------------------------------------------------------------

HRESULT WINAPI
    D3DXCreateTextureFromFileA(
        LPDIRECT3DDEVICE8     pDevice,
        LPCSTR                pSrcFile,
        LPDIRECT3DTEXTURE8*   ppTexture);

#define D3DXCreateTextureFromFile D3DXCreateTextureFromFileA


HRESULT WINAPI
    D3DXCreateTextureFromFileExA(
        LPDIRECT3DDEVICE8     pDevice,
        LPCSTR                pSrcFile,
        UINT                  Width,
        UINT                  Height,
        UINT                  MipLevels,
        DWORD                 Usage,
        D3DFORMAT             Format,
        D3DPOOL               Pool,
        DWORD                 Filter,
        DWORD                 MipFilter,
        D3DCOLOR              ColorKey,
        D3DXIMAGE_INFO*       pSrcInfo,
        PALETTEENTRY*         pPalette,
        LPDIRECT3DTEXTURE8*   ppTexture);

#define D3DXCreateTextureFromFileEx D3DXCreateTextureFromFileExA


HRESULT WINAPI
    D3DXCreateTextureFromFileInMemory(
        LPDIRECT3DDEVICE8     pDevice,
        LPCVOID               pSrcData,
        UINT                  SrcDataSize,
        LPDIRECT3DTEXTURE8*   ppTexture);


HRESULT WINAPI
    D3DXCreateTextureFromFileInMemoryEx(
        LPDIRECT3DDEVICE8     pDevice,
        LPCVOID               pSrcData,
        UINT                  SrcDataSize,
        UINT                  Width,
        UINT                  Height,
        UINT                  MipLevels,
        DWORD                 Usage,
        D3DFORMAT             Format,
        D3DPOOL               Pool,
        DWORD                 Filter,
        DWORD                 MipFilter,
        D3DCOLOR              ColorKey,
        D3DXIMAGE_INFO*       pSrcInfo,
        PALETTEENTRY*         pPalette,
        LPDIRECT3DTEXTURE8*   ppTexture);



//-------------------------------------------------------------------------
// D3DXFilterTexture:
// ------------------
// Filters mipmaps levels of a texture.
//
// Parameters:
//  pTexture
//      The texture object to be filtered
//  pPalette
//      256 color palette to be used, or NULL for non-palettized formats
//  SrcLevel
//      The level whose image is used to generate the subsequent levels.
//  Filter
//      D3DX_FILTER flags controlling how each miplevel is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_BOX,
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXFilterTexture(
        LPDIRECT3DTEXTURE8    pTexture,
        CONST PALETTEENTRY*   pPalette,
        UINT                  SrcLevel,
        DWORD                 Filter);





///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////





//-------------------------------------------------------------------------
// D3DXCheckCubeTextureRequirements:
// ---------------------------------
//
// Checks cube texture creation parameters.  If parameters are invalid,
// this function returns corrected parameters.
//
// Parameters:
//
//  pDevice
//      The D3D device to be used
//  pSize
//      Desired width and height in pixels, or NULL.  Returns corrected size.
//  pNumMipLevels
//      Number of desired mipmap levels, or NULL.  Returns corrected number.
//  Usage
//      Texture usage flags
//  pFormat
//      Desired pixel format, or NULL.  Returns corrected format.
//  Pool
//      Memory pool to be used to create texture
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCheckCubeTextureRequirements(
        LPDIRECT3DDEVICE8     pDevice,
        UINT*                 pSize,
        UINT*                 pNumMipLevels,
        DWORD                 Usage,
        D3DFORMAT*            pFormat,
        D3DPOOL               Pool);


//-------------------------------------------------------------------------
// D3DXCreateCubeTexture:
// ----------------------
// Create an empty cube texture
//
// Parameters:
//
//  pDevice
//      The D3D device with which the texture is going to be used.
//  Size
//      width and height in pixels; must be non-zero
//  MipLevels
//      number of mip levels desired; if zero or D3DX_DEFAULT, a complete
//      mipmap chain will be created.
//  Usage
//      Texture usage flags
//  Format
//      Pixel format.
//  Pool
//      Memory pool to be used to create texture
//  ppCubeTexture
//      The cube texture object that will be created
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateCubeTexture(
        LPDIRECT3DDEVICE8         pDevice,
        UINT                      Size,
        UINT                      MipLevels,
        DWORD                     Usage,
        D3DFORMAT                 Format,
        D3DPOOL                   Pool,
        LPDIRECT3DCUBETEXTURE8*   ppCubeTexture);


//-------------------------------------------------------------------------
// D3DXCreateCubeTextureFromFile:
// --------------------------
// Create a cube texture object from a file.
//
// Parameters:
//
//  pDevice
//      The D3D device with which the texture is going to be used.
//  pSrcFile
//      File name.
//  pvSrcData
//      Pointer to file in memory.
//  SrcDataSize
//      Size in bytes of file in memory.
//  Size
//      Width and height in pixels; if zero or D3DX_DEFAULT, the size
//      will be taken from the file.
//  MipLevels
//      Number of mip levels;  if zero or D3DX_DEFAULT, a complete mipmap
//      chain will be created.
//  Format
//      Desired pixel format.  If D3DFMT_UNKNOWN, the format will be
//      taken from the file.
//  Filter
//      D3DX_FILTER flags controlling how the image is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_TRIANGLE.
//  MipFilter
//      D3DX_FILTER flags controlling how each miplevel is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_BOX,
//  ColorKey
//      Color to replace with transparent black, or 0 to disable colorkey.
//      This is always a 32-bit ARGB color, independent of the source image
//      format.  Alpha is significant, and should usually be set to FF for
//      opaque colorkeys.  (ex. Opaque black == 0xff000000)
//  pSrcInfo
//      Pointer to a D3DXIMAGE_INFO structure to be filled in with the
//      description of the data in the source image file, or NULL.
//  pPalette
//      256 color palette to be filled in, or NULL
//  ppCubeTexture
//      The cube texture object that will be created
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateCubeTextureFromFileA(
        LPDIRECT3DDEVICE8         pDevice,
        LPCSTR                    pSrcFile,
        LPDIRECT3DCUBETEXTURE8*   ppCubeTexture);

#define D3DXCreateCubeTextureFromFile D3DXCreateCubeTextureFromFileA


HRESULT WINAPI
    D3DXCreateCubeTextureFromFileExA(
        LPDIRECT3DDEVICE8         pDevice,
        LPCSTR                    pSrcFile,
        UINT                      Size,
        UINT                      MipLevels,
        DWORD                     Usage,
        D3DFORMAT                 Format,
        D3DPOOL                   Pool,
        DWORD                     Filter,
        DWORD                     MipFilter,
        D3DCOLOR                  ColorKey,
        D3DXIMAGE_INFO*           pSrcInfo,
        PALETTEENTRY*             pPalette,
        LPDIRECT3DCUBETEXTURE8*   ppCubeTexture);

#define D3DXCreateCubeTextureFromFileEx D3DXCreateCubeTextureFromFileExA


HRESULT WINAPI
    D3DXCreateCubeTextureFromFileInMemory(
        LPDIRECT3DDEVICE8         pDevice,
        LPCVOID                   pSrcData,
        UINT                      SrcDataSize,
        LPDIRECT3DCUBETEXTURE8*   ppCubeTexture);


HRESULT WINAPI
    D3DXCreateCubeTextureFromFileInMemoryEx(
        LPDIRECT3DDEVICE8         pDevice,
        LPCVOID                   pSrcData,
        UINT                      SrcDataSize,
        UINT                      Size,
        UINT                      MipLevels,
        DWORD                     Usage,
        D3DFORMAT                 Format,
        D3DPOOL                   Pool,
        DWORD                     Filter,
        DWORD                     MipFilter,
        D3DCOLOR                  ColorKey,
        D3DXIMAGE_INFO*           pSrcInfo,
        PALETTEENTRY*             pPalette,
        LPDIRECT3DCUBETEXTURE8*   ppCubeTexture);


//-------------------------------------------------------------------------
// D3DXFilterCubeTexture:
// ----------------------
// Filters mipmaps levels of a cube texture map.
//
// Parameters:
//  pCubeTexture
//      The cube texture object to be filtered
//  pPalette
//      256 color palette to be used, or NULL
//  SrcLevel
//      The level whose image is used to generate the subsequent levels.
//  Filter
//      D3DX_FILTER flags controlling how each miplevel is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_BOX,
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXFilterCubeTexture(
        LPDIRECT3DCUBETEXTURE8    pCubeTexture,
        CONST PALETTEENTRY*       pPalette,
        UINT                      SrcLevel,
        DWORD                     Filter);




///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////




//-------------------------------------------------------------------------
// D3DXCheckVolumeTextureRequirements:
// -----------------------------------
//
// Checks volume texture creation parameters.  If parameters are invalid,
// this function returns corrected parameters.
//
// Parameters:
//
//  pDevice
//      The D3D device to be used
//  pWidth
//      Desired width in pixels, or NULL.  Returns corrected size.
//  pHeight
//      Desired height in pixels, or NULL.  Returns corrected size.
//  pDepth
//      Desired depth in pixels, or NULL.  Returns corrected size.
//  pNumMipLevels
//      Number of desired mipmap levels, or NULL.  Returns corrected number.
//  pFormat
//      Desired pixel format, or NULL.  Returns corrected format.
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCheckVolumeTextureRequirements(
        LPDIRECT3DDEVICE8     pDevice,
        UINT*                 pWidth,
        UINT*                 pHeight,
        UINT*                 pDepth,
        UINT*                 pNumMipLevels,
        DWORD                 Usage,
        D3DFORMAT*            pFormat,
        D3DPOOL               Pool);


//-------------------------------------------------------------------------
// D3DXCreateVolumeTexture:
// ----------------------
// Create an empty volume texture
//
// Parameters:
//
//  pDevice
//      The D3D device with which the texture is going to be used.
//  Width
//      width in pixels; must be non-zero
//  Height
//      height in pixels; must be non-zero
//  Depth
//      depth in pixels; must be non-zero
//  MipLevels
//      number of mip levels desired; if zero or D3DX_DEFAULT, a complete
//      mipmap chain will be created.
//  Format
//      pixel format.
//  ppVolumeTexture
//      The volume texture object that will be created
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateVolumeTexture(
        LPDIRECT3DDEVICE8         pDevice,
        UINT                      Width,
        UINT                      Height,
        UINT                      Depth,
        UINT                      MipLevels,
        DWORD                     Usage,
        D3DFORMAT                 Format,
        D3DPOOL                   Pool,
        LPDIRECT3DVOLUMETEXTURE8* ppVolumeTexture);


//-------------------------------------------------------------------------
// D3DXFilterVolumeTexture:
// ------------------------
// Filters mipmaps levels of a volume texture map.
//
// Parameters:
//  pVolumeTexture
//      The volume texture object to be filtered
//  pPalette
//      256 color palette to be used, or NULL
//  SrcLevel
//      The level whose image is used to generate the subsequent levels.
//  Filter
//      D3DX_FILTER flags controlling how each miplevel is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_BOX,
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXFilterVolumeTexture(
        LPDIRECT3DVOLUMETEXTURE8  pVolumeTexture,
        CONST PALETTEENTRY*       pPalette,
        UINT                      SrcLevel,
        DWORD                     Filter);



#ifdef __cplusplus
}
#endif //__cplusplus

#endif //__D3DX8TEX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dxg\d3dxshapes.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dxshapes.h
//  Content:    D3DX simple shapes
//
///////////////////////////////////////////////////////////////////////////

#ifndef __D3DXSHAPES_H__
#define __D3DXSHAPES_H__

#include <d3d.h>
#include <limits.h>
#include "d3dxerr.h"


typedef struct ID3DXSimpleShape *LPD3DXSIMPLESHAPE;

// {CFCD4602-EB7B-11d2-A440-00A0C90629A8}
DEFINE_GUID( IID_ID3DXSimpleShape, 
0xcfcd4602, 0xeb7b, 0x11d2, 0xa4, 0x40, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8 );


///////////////////////////////////////////////////////////////////////////
// Interfaces:
///////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------------
// ID3DXSimpleShape interface: 
//-------------------------------------------------------------------------

DECLARE_INTERFACE_(ID3DXSimpleShape, IUnknown)
{
    // IUnknown methods 
    STDMETHOD(QueryInterface)(THIS_ REFIID  riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // ID3DXSimpleShape methods
    STDMETHOD_(LPDIRECT3DVERTEXBUFFER7, GetVB)(THIS) PURE;
    STDMETHOD_(DWORD, GetIndices)(THIS_ LPWORD *ppIndices) PURE;
    STDMETHOD(Draw)(THIS) PURE;
};



///////////////////////////////////////////////////////////////////////////
// Functions:
///////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus


//-------------------------------------------------------------------------
// D3DXCreatePolygon: Creates an 'n' sided polygon using the device
// ----------------  specified. It returns a vertex buffer that can be used
//                   for drawing or manipulation by the program later on.
//
// Params: 
//     [in]  LPDIRECT3DDEVICE7 pDevice: The device to create off. 
//     [in]  float sideSize: Length of a side.
//     [in]  DWORD numTexCoords:   The number of texture coordinates desired
//                                 in the vertex-buffer. (Default is 1)
//                                 D3DX_DEFAULT is a valid input.
//     [out] IDirect3DVertexBuffer7** ppVB: The output shape interface.
//-------------------------------------------------------------------------
HRESULT WINAPI 
    D3DXCreatePolygon(LPDIRECT3DDEVICE7  pDevice,
                      float              sideSize, 
                      DWORD              numSides, 
                      DWORD              numTexCoords, 
                      LPD3DXSIMPLESHAPE* ppShape );

//-------------------------------------------------------------------------
// D3DXCreateBox: Creates a box (cuboid) of given dimensions using the  
// ------------  device. It returns a vertex buffer that can
//               be used for drawing or manipulation by the program later on.
//
// Params: 
//     [in]  LPDIRECT3DDEVICE7 pDevice: The device to create off. 
//     [in]  float width: Width of the box (along x-axis)
//     [in]  float height: Height of the box (along y-axis)
//     [in]  float depth: Depth of the box (along z-axis)
//     [in]  DWORD numTexCoords: The number of texture coordinates desired
//                               in the vertex-buffer. Default is 1. 
//                               D3DX_DEFAULT is a valid input here.
//     [out] LPD3DXSIMPLESHAPE* ppShape: The output vertex-buffer.
//-------------------------------------------------------------------------
HRESULT WINAPI 
    D3DXCreateBox(LPDIRECT3DDEVICE7  pDevice, 
                  float              width,
                  float              height,
                  float              depth,
                  DWORD              numTexCoords, 
                  LPD3DXSIMPLESHAPE* ppShape );

//-------------------------------------------------------------------------
// D3DXCreateCylinder: Creates a cylinder of given dimensions using the  
// -----------------  device. It returns a vertex buffer that
//                    can be used for drawing or manipulation by the program
//                    later on.
//
// Params: 
//     [in]  LPDIRECT3DDEVICE7 pDevice: The device to create off. 
//     [in]  float baseRadius: Base-radius (default is 1.0f, shd be >= 0.0f)
//     [in]  float topRadius: Top-radius (default is 1.0f, shd be >= 0.0f)
//     [in]  float height: Height (default is 1.0f, shd be >= 0.0f)
//     [in]  DWORD numSlices: Number of slices about the main axis.
//                            (default is 8) D3DX_DEFAULT is a valid input.
//     [in]  DWORD numStacks: Number of stacks along the main axis. 
//                            (default is 8) D3DX_DEFAULT is a valid input.
//     [in]  DWORD numTexCoords: The number of texture coordinates desired
//                               in the vertex-buffer. Default is 1. 
//                               D3DX_DEFAULT is a valid input here.
//     [out] LPD3DXSIMPLESHAPE* ppShape: The output shape interface.
//-------------------------------------------------------------------------
HRESULT WINAPI 
    D3DXCreateCylinder(LPDIRECT3DDEVICE7  pDevice,
                       float              baseRadius, 
                       float              topRadius, 
                       float              height, 
                       DWORD              numSlices, 
                       DWORD              numStacks,   
                       DWORD              numTexCoords, 
                       LPD3DXSIMPLESHAPE* ppShape );


//-------------------------------------------------------------------------
// D3DXCreateTorus: Creates a torus of given dimensions using the  
// --------------  device specified. It returns a vertex buffer that can
//                 be used for drawing or manipulation by the program later
//                 on. It draws a doughnut, centered at (0, 0, 0) whose axis 
//                 is aligned with the z-axis. With the innerRadius used
//                 as the radius of the cross-section (minor-Radius) and 
//                 the outerRadius used as the radius of the central 'hole'. 
//
// Params: 
//     [in]  LPDIRECT3DDEVICE7 pDevice: The device to create off. 
//     [in]  float innerRadius: inner radius (default is 1.0f, shd be >= 0.0f)
//     [in]  float outerRadius: outer radius (default is 2.0f, shd be >= 0.0f)
//     [in]  DWORD numSides: Number of sides in the cross-section 
//                           (default is 8). D3DX_DEFAULT is a valid input.
//     [in]  DWORD numRings: Number of rings making up the torus 
//                           (default is 8) D3DX_DEFAULT is a valid input.
//     [in]  DWORD numTexCoords: The number of texture coordinates desired
//                                 in the vertex-buffer. Default is 1. 
//                                 D3DX_DEFAULT is a valid input here.
//     [out] LPD3DXSIMPLESHAPE* ppShape: The output shape interface.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateTorus(LPDIRECT3DDEVICE7  pDevice,
                    float              innerRadius,
                    float              outerRadius, 
                    DWORD              numSides,
                    DWORD              numRings, 
                    DWORD              numTexCoords,  
                    LPD3DXSIMPLESHAPE* ppShape );

//-------------------------------------------------------------------------
// D3DXCreateTeapot: Creates a teapot using the device specified. 
// ----------------  It returns a vertex buffer that can be used for
//                   drawing or manipulation by the program later on.
//
// Params: 
//     [in]  LPDIRECT3DDEVICE7 pDevice: The device to create off. 
//     [in]  DWORD numTexCoords: The number of texture coordinates desired
//                               in the vertex-buffer. Default is 1. 
//                               D3DX_DEFAULT is a valid input here.
//     [out] LPD3DXSIMPLESHAPE* ppShape: The output shape interface.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateTeapot(LPDIRECT3DDEVICE7  pDevice,
                     DWORD              numTexCoords, 
                     LPD3DXSIMPLESHAPE* ppShape);

//-------------------------------------------------------------------------
// D3DXCreateSphere: Creates a cylinder of given dimensions using the
// ----------------  device specified. 
//                   It returns a vertex buffer that can be used for
//                   drawing or manipulation by the program later on.
//
// Params: 
//     [in]  LPDIRECT3DDEVICE7 pDevice: The device to create off. 
//     [in]  float radius: radius (default is 1.0f, shd be >= 0.0f)
//     [in]  float height: Height (default is 1.0f, shd be >= 0.0f)
//     [in]  DWORD numSlices: Number of slices about the main axis
//                            (default is 8) D3DX_DEFAULT is a valid input.
//     [in]  DWORD numStacks: Number of stacks along the main axis
//                            (default is 8) D3DX_DEFAULT is a valid input.
//     [in]  DWORD numTexCoords: The number of texture coordinates desired
//                               in the vertex-buffer. Default is 1. 
//                               D3DX_DEFAULT is a valid input here.
//     [out] LPD3DXSIMPLESHAPE* ppShape: The output shape interface.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateSphere(LPDIRECT3DDEVICE7  pDevice, 
                     float              radius, 
                     DWORD              numSlices, 
                     DWORD              numStacks,
                     DWORD              numTexCoords, 
                     LPD3DXSIMPLESHAPE* ppShape);

#ifdef __cplusplus
}
#endif //__cplusplus    
#endif //__D3DXSHAPES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dxg\d3dxmath.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dxmath.h
//  Content:    D3DX math types and functions
//
//////////////////////////////////////////////////////////////////////////////

#ifndef __D3DXMATH_H__
#define __D3DXMATH_H__

#include <d3d.h>
#include <math.h>
#include <limits.h>
#include "d3dxerr.h"

#ifndef D3DXINLINE
#ifdef __cplusplus
#define D3DXINLINE inline
#else
#define D3DXINLINE _inline
#endif
#endif

#pragma warning(disable:4201) // anonymous unions warning



typedef struct ID3DXMatrixStack *LPD3DXMATRIXSTACK;

// {E3357330-CC5E-11d2-A434-00A0C90629A8}
DEFINE_GUID( IID_ID3DXMatrixStack,
             0xe3357330, 0xcc5e, 0x11d2, 0xa4, 0x34, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);


//===========================================================================
//
// General purpose utilities
//
//===========================================================================
#define D3DX_PI    ((float)  3.141592654f)
#define D3DX_1BYPI ((float)  0.318309886f)

#define D3DXToRadian( degree ) ((degree) * (D3DX_PI / 180.0f))
#define D3DXToDegree( radian ) ((radian) * (180.0f / D3DX_PI))



//===========================================================================
//
// Vectors
//
//===========================================================================

//--------------------------
// 2D Vector
//--------------------------
typedef struct D3DXVECTOR2
{
#ifdef __cplusplus
public:
    D3DXVECTOR2() {};
    D3DXVECTOR2( const float * );
    D3DXVECTOR2( float x, float y );

    // casting
    operator float* ();
    operator const float* () const;

    // assignment operators
    D3DXVECTOR2& operator += ( const D3DXVECTOR2& );
    D3DXVECTOR2& operator -= ( const D3DXVECTOR2& );
    D3DXVECTOR2& operator *= ( float );
    D3DXVECTOR2& operator /= ( float );

    // unary operators
    D3DXVECTOR2 operator + () const;
    D3DXVECTOR2 operator - () const;

    // binary operators
    D3DXVECTOR2 operator + ( const D3DXVECTOR2& ) const;
    D3DXVECTOR2 operator - ( const D3DXVECTOR2& ) const;
    D3DXVECTOR2 operator * ( float ) const;
    D3DXVECTOR2 operator / ( float ) const;

    friend D3DXVECTOR2 operator * ( float, const D3DXVECTOR2& );

    BOOL operator == ( const D3DXVECTOR2& ) const;
    BOOL operator != ( const D3DXVECTOR2& ) const;


public:
#endif //__cplusplus
    float x, y;
} D3DXVECTOR2, *LPD3DXVECTOR2;


//--------------------------
// 3D Vector
//--------------------------
typedef struct D3DXVECTOR3
{
#ifdef __cplusplus
public:
    D3DXVECTOR3() {};
    D3DXVECTOR3( const float * );
    D3DXVECTOR3( const D3DVECTOR& );
    D3DXVECTOR3( float x, float y, float z );

    // casting
    operator float* ();
    operator const float* () const;

    operator D3DVECTOR* ();
    operator const D3DVECTOR* () const;

    operator D3DVECTOR& ();
    operator const D3DVECTOR& () const;

    // assignment operators
    D3DXVECTOR3& operator += ( const D3DXVECTOR3& );
    D3DXVECTOR3& operator -= ( const D3DXVECTOR3& );
    D3DXVECTOR3& operator *= ( float );
    D3DXVECTOR3& operator /= ( float );

    // unary operators
    D3DXVECTOR3 operator + () const;
    D3DXVECTOR3 operator - () const;

    // binary operators
    D3DXVECTOR3 operator + ( const D3DXVECTOR3& ) const;
    D3DXVECTOR3 operator - ( const D3DXVECTOR3& ) const;
    D3DXVECTOR3 operator * ( float ) const;
    D3DXVECTOR3 operator / ( float ) const;

    friend D3DXVECTOR3 operator * ( float, const struct D3DXVECTOR3& );

    BOOL operator == ( const D3DXVECTOR3& ) const;
    BOOL operator != ( const D3DXVECTOR3& ) const;

public:
#endif //__cplusplus
    float x, y, z;
} D3DXVECTOR3, *LPD3DXVECTOR3;


//--------------------------
// 4D Vector
//--------------------------
typedef struct D3DXVECTOR4
{
#ifdef __cplusplus
public:
    D3DXVECTOR4() {};
    D3DXVECTOR4( const float* );
    D3DXVECTOR4( float x, float y, float z, float w );

    // casting
    operator float* ();
    operator const float* () const;

    // assignment operators
    D3DXVECTOR4& operator += ( const D3DXVECTOR4& );
    D3DXVECTOR4& operator -= ( const D3DXVECTOR4& );
    D3DXVECTOR4& operator *= ( float );
    D3DXVECTOR4& operator /= ( float );

    // unary operators
    D3DXVECTOR4 operator + () const;
    D3DXVECTOR4 operator - () const;

    // binary operators
    D3DXVECTOR4 operator + ( const D3DXVECTOR4& ) const;
    D3DXVECTOR4 operator - ( const D3DXVECTOR4& ) const;
    D3DXVECTOR4 operator * ( float ) const;
    D3DXVECTOR4 operator / ( float ) const;

    friend D3DXVECTOR4 operator * ( float, const D3DXVECTOR4& );

    BOOL operator == ( const D3DXVECTOR4& ) const;
    BOOL operator != ( const D3DXVECTOR4& ) const;

public:
#endif //__cplusplus
    float x, y, z, w;
} D3DXVECTOR4, *LPD3DXVECTOR4;


//===========================================================================
//
// Matrices
//
//===========================================================================
typedef struct D3DXMATRIX
{
#ifdef __cplusplus
public:
    D3DXMATRIX() {};
    D3DXMATRIX( const float * );
    D3DXMATRIX( const D3DMATRIX& );
    D3DXMATRIX( float m00, float m01, float m02, float m03,
                float m10, float m11, float m12, float m13,
                float m20, float m21, float m22, float m23,
                float m30, float m31, float m32, float m33 );


    // access grants
    float& operator () ( UINT iRow, UINT iCol );
    float  operator () ( UINT iRow, UINT iCol ) const;

    // casting operators
    operator float* ();
    operator const float* () const;

    operator D3DMATRIX* ();
    operator const D3DMATRIX* () const;

    operator D3DMATRIX& ();
    operator const D3DMATRIX& () const;

    // assignment operators
    D3DXMATRIX& operator *= ( const D3DXMATRIX& );
    D3DXMATRIX& operator += ( const D3DXMATRIX& );
    D3DXMATRIX& operator -= ( const D3DXMATRIX& );
    D3DXMATRIX& operator *= ( float );
    D3DXMATRIX& operator /= ( float );

    // unary operators
    D3DXMATRIX operator + () const;
    D3DXMATRIX operator - () const;

    // binary operators
    D3DXMATRIX operator * ( const D3DXMATRIX& ) const;
    D3DXMATRIX operator + ( const D3DXMATRIX& ) const;
    D3DXMATRIX operator - ( const D3DXMATRIX& ) const;
    D3DXMATRIX operator * ( float ) const;
    D3DXMATRIX operator / ( float ) const;

    friend D3DXMATRIX operator * ( float, const D3DXMATRIX& );

    BOOL operator == ( const D3DXMATRIX& ) const;
    BOOL operator != ( const D3DXMATRIX& ) const;


#endif //__cplusplus

    union
    {
        float m[4][4];
#ifdef __cplusplus
        struct
        {
            float m00, m01, m02, m03;
            float m10, m11, m12, m13;
            float m20, m21, m22, m23;
            float m30, m31, m32, m33;
        };
#endif //__cplusplus
    };
} D3DXMATRIX, *LPD3DXMATRIX;


//===========================================================================
//
//    Quaternions
//
//===========================================================================
typedef struct D3DXQUATERNION
{
#ifdef __cplusplus
public:
    D3DXQUATERNION() {}
    D3DXQUATERNION( const float * );
    D3DXQUATERNION( float x, float y, float z, float w );

    // casting
    operator float* ();
    operator const float* () const;

    // assignment operators
    D3DXQUATERNION& operator += ( const D3DXQUATERNION& );
    D3DXQUATERNION& operator -= ( const D3DXQUATERNION& );
    D3DXQUATERNION& operator *= ( const D3DXQUATERNION& );
    D3DXQUATERNION& operator *= ( float );
    D3DXQUATERNION& operator /= ( float );

    // unary operators
    D3DXQUATERNION  operator + () const;
    D3DXQUATERNION  operator - () const;

    // binary operators
    D3DXQUATERNION operator + ( const D3DXQUATERNION& ) const;
    D3DXQUATERNION operator - ( const D3DXQUATERNION& ) const;
    D3DXQUATERNION operator * ( const D3DXQUATERNION& ) const;
    D3DXQUATERNION operator * ( float ) const;
    D3DXQUATERNION operator / ( float ) const;

    friend D3DXQUATERNION operator * (float, const D3DXQUATERNION& );

    BOOL operator == ( const D3DXQUATERNION& ) const;
    BOOL operator != ( const D3DXQUATERNION& ) const;

#endif //__cplusplus
    float x, y, z, w;
} D3DXQUATERNION, *LPD3DXQUATERNION;


//===========================================================================
//
// Planes
//
//===========================================================================
typedef struct D3DXPLANE
{
#ifdef __cplusplus
public:
    D3DXPLANE() {}
    D3DXPLANE( const float* );
    D3DXPLANE( float a, float b, float c, float d );

    // casting
    operator float* ();
    operator const float* () const;

    // unary operators
    D3DXPLANE operator + () const;
    D3DXPLANE operator - () const;

    // binary operators
    BOOL operator == ( const D3DXPLANE& ) const;
    BOOL operator != ( const D3DXPLANE& ) const;

#endif //__cplusplus
    float a, b, c, d;
} D3DXPLANE, *LPD3DXPLANE;


//===========================================================================
//
// Colors
//
//===========================================================================

typedef struct D3DXCOLOR
{
#ifdef __cplusplus
public:
    D3DXCOLOR() {}
    D3DXCOLOR( DWORD argb );
    D3DXCOLOR( const float * );
    D3DXCOLOR( const D3DCOLORVALUE& );
    D3DXCOLOR( float r, float g, float b, float a );

    // casting
    operator DWORD () const;

    operator float* ();
    operator const float* () const;

    operator D3DCOLORVALUE* ();
    operator const D3DCOLORVALUE* () const;

    operator D3DCOLORVALUE& ();
    operator const D3DCOLORVALUE& () const;

    // assignment operators
    D3DXCOLOR& operator += ( const D3DXCOLOR& );
    D3DXCOLOR& operator -= ( const D3DXCOLOR& );
    D3DXCOLOR& operator *= ( float );
    D3DXCOLOR& operator /= ( float );

    // unary operators
    D3DXCOLOR operator + () const;
    D3DXCOLOR operator - () const;

    // binary operators
    D3DXCOLOR operator + ( const D3DXCOLOR& ) const;
    D3DXCOLOR operator - ( const D3DXCOLOR& ) const;
    D3DXCOLOR operator * ( float ) const;
    D3DXCOLOR operator / ( float ) const;

    friend D3DXCOLOR operator * (float, const D3DXCOLOR& );

    BOOL operator == ( const D3DXCOLOR& ) const;
    BOOL operator != ( const D3DXCOLOR& ) const;

#endif //__cplusplus
    FLOAT r, g, b, a;
} D3DXCOLOR, *LPD3DXCOLOR;



//===========================================================================
//
// D3DX math functions:
//
// NOTE:
//  * All these functions can take the same object as in and out parameters.
//
//  * Out parameters are typically also returned as return values, so that
//    the output of one function may be used as a parameter to another.
//
//===========================================================================

//--------------------------
// 2D Vector
//--------------------------

// inline

float D3DXVec2Length
    ( const D3DXVECTOR2 *pV );

float D3DXVec2LengthSq
    ( const D3DXVECTOR2 *pV );

float D3DXVec2Dot
    ( const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 );

// Z component of ((x1,y1,0) cross (x2,y2,0))
float D3DXVec2CCW
    ( const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 );

D3DXVECTOR2* D3DXVec2Add
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 );

D3DXVECTOR2* D3DXVec2Subtract
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 );

// Minimize each component.  x = min(x1, x2), y = min(y1, y2)
D3DXVECTOR2* D3DXVec2Minimize
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 );

// Maximize each component.  x = max(x1, x2), y = max(y1, y2)
D3DXVECTOR2* D3DXVec2Maximize
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 );

D3DXVECTOR2* D3DXVec2Scale
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV, float s );

// Linear interpolation. V1 + s(V2-V1)
D3DXVECTOR2* D3DXVec2Lerp
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2,
      float s );

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

D3DXVECTOR2* WINAPI D3DXVec2Normalize
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV );

// Hermite interpolation between position V1, tangent T1 (when s == 0)
// and position V2, tangent T2 (when s == 1).
D3DXVECTOR2* WINAPI D3DXVec2Hermite
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pT1,
      const D3DXVECTOR2 *pV2, const D3DXVECTOR2 *pT2, float s );

// Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)
D3DXVECTOR2* WINAPI D3DXVec2BaryCentric
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2,
      D3DXVECTOR2 *pV3, float f, float g);

// Transform (x, y, 0, 1) by matrix.
D3DXVECTOR4* WINAPI D3DXVec2Transform
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR2 *pV, const D3DXMATRIX *pM );

// Transform (x, y, 0, 1) by matrix, project result back into w=1.
D3DXVECTOR2* WINAPI D3DXVec2TransformCoord
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV, const D3DXMATRIX *pM );

// Transform (x, y, 0, 0) by matrix.
D3DXVECTOR2* WINAPI D3DXVec2TransformNormal
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV, const D3DXMATRIX *pM );

#ifdef __cplusplus
}
#endif


//--------------------------
// 3D Vector
//--------------------------

// inline

float D3DXVec3Length
    ( const D3DXVECTOR3 *pV );

float D3DXVec3LengthSq
    ( const D3DXVECTOR3 *pV );

float D3DXVec3Dot
    ( const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 );

D3DXVECTOR3* D3DXVec3Cross
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 );

D3DXVECTOR3* D3DXVec3Add
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 );

D3DXVECTOR3* D3DXVec3Subtract
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 );

// Minimize each component.  x = min(x1, x2), y = min(y1, y2), ...
D3DXVECTOR3* D3DXVec3Minimize
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 );

// Maximize each component.  x = max(x1, x2), y = max(y1, y2), ...
D3DXVECTOR3* D3DXVec3Maximize
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 );

D3DXVECTOR3* D3DXVec3Scale
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, float s);

// Linear interpolation. V1 + s(V2-V1)
D3DXVECTOR3* D3DXVec3Lerp
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2,
      float s );

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

D3DXVECTOR3* WINAPI D3DXVec3Normalize
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV );

// Hermite interpolation between position V1, tangent T1 (when s == 0)
// and position V2, tangent T2 (when s == 1).
D3DXVECTOR3* WINAPI D3DXVec3Hermite
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pT1,
      const D3DXVECTOR3 *pV2, const D3DXVECTOR3 *pT2, float s );

// Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)
D3DXVECTOR3* WINAPI D3DXVec3BaryCentric
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2,
      const D3DXVECTOR3 *pV3, float f, float g);

// Transform (x, y, z, 1) by matrix.
D3DXVECTOR4* WINAPI D3DXVec3Transform
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR3 *pV, const D3DXMATRIX *pM );

// Transform (x, y, z, 1) by matrix, project result back into w=1.
D3DXVECTOR3* WINAPI D3DXVec3TransformCoord
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, const D3DXMATRIX *pM );

// Transform (x, y, z, 0) by matrix.
D3DXVECTOR3* WINAPI D3DXVec3TransformNormal
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, const D3DXMATRIX *pM );

#ifdef __cplusplus
}
#endif



//--------------------------
// 4D Vector
//--------------------------

// inline

float D3DXVec4Length
    ( const D3DXVECTOR4 *pV );

float D3DXVec4LengthSq
    ( const D3DXVECTOR4 *pV );

float D3DXVec4Dot
    ( const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2 );

D3DXVECTOR4* D3DXVec4Add
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2);

D3DXVECTOR4* D3DXVec4Subtract
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2);

// Minimize each component.  x = min(x1, x2), y = min(y1, y2), ...
D3DXVECTOR4* D3DXVec4Minimize
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2);

// Maximize each component.  x = max(x1, x2), y = max(y1, y2), ...
D3DXVECTOR4* D3DXVec4Maximize
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2);

D3DXVECTOR4* D3DXVec4Scale
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV, float s);

// Linear interpolation. V1 + s(V2-V1)
D3DXVECTOR4* D3DXVec4Lerp
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2,
      float s );

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Cross-product in 4 dimensions.
D3DXVECTOR4* WINAPI D3DXVec4Cross
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2,
      const D3DXVECTOR4 *pV3);

D3DXVECTOR4* WINAPI D3DXVec4Normalize
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV );

// Hermite interpolation between position V1, tangent T1 (when s == 0)
// and position V2, tangent T2 (when s == 1).
D3DXVECTOR4* WINAPI D3DXVec4Hermite
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pT1,
      const D3DXVECTOR4 *pV2, const D3DXVECTOR4 *pT2, float s );

// Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)
D3DXVECTOR4* WINAPI D3DXVec4BaryCentric
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2,
      const D3DXVECTOR4 *pV3, float f, float g);

// Transform vector by matrix.
D3DXVECTOR4* WINAPI D3DXVec4Transform
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV, const D3DXMATRIX *pM );

#ifdef __cplusplus
}
#endif


//--------------------------
// 4D Matrix
//--------------------------

// inline

D3DXMATRIX* D3DXMatrixIdentity
    ( D3DXMATRIX *pOut );

BOOL D3DXMatrixIsIdentity
    ( const D3DXMATRIX *pM );


// non-inline
#ifdef __cplusplus
extern "C" {
#endif

float WINAPI D3DXMatrixfDeterminant
    ( const D3DXMATRIX *pM );

// Matrix multiplication.  The result represents the transformation M2 
// followed by the transformation M1.  (Out = M1 * M2)
D3DXMATRIX* WINAPI D3DXMatrixMultiply
    ( D3DXMATRIX *pOut, const D3DXMATRIX *pM1, const D3DXMATRIX *pM2 );

D3DXMATRIX* WINAPI D3DXMatrixTranspose
    ( D3DXMATRIX *pOut, const D3DXMATRIX *pM );

// Calculate inverse of matrix.  Inversion my fail, in which case NULL will
// be returned.  The determinant of pM is also returned it pfDeterminant
// is non-NULL.
D3DXMATRIX* WINAPI D3DXMatrixInverse
    ( D3DXMATRIX *pOut, float *pfDeterminant, const D3DXMATRIX *pM );

// Build a matrix which scales by (sx, sy, sz)
D3DXMATRIX* WINAPI D3DXMatrixScaling
    ( D3DXMATRIX *pOut, float sx, float sy, float sz );

// Build a matrix which translates by (x, y, z)
D3DXMATRIX* WINAPI D3DXMatrixTranslation
    ( D3DXMATRIX *pOut, float x, float y, float z );

// Build a matrix which rotates around the X axis
D3DXMATRIX* WINAPI D3DXMatrixRotationX
    ( D3DXMATRIX *pOut, float angle );

// Build a matrix which rotates around the Y axis
D3DXMATRIX* WINAPI D3DXMatrixRotationY
    ( D3DXMATRIX *pOut, float angle );

// Build a matrix which rotates around the Z axis
D3DXMATRIX* WINAPI D3DXMatrixRotationZ
    ( D3DXMATRIX *pOut, float angle );

// Build a matrix which rotates around an arbitrary axis
D3DXMATRIX* WINAPI D3DXMatrixRotationAxis
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pV, float angle );

// Build a matrix from a quaternion
D3DXMATRIX* WINAPI D3DXMatrixRotationQuaternion
    ( D3DXMATRIX *pOut, const D3DXQUATERNION *pQ);

// Yaw around the Y axis, a pitch around the X axis,
// and a roll around the Z axis.
D3DXMATRIX* WINAPI D3DXMatrixRotationYawPitchRoll
    ( D3DXMATRIX *pOut, float yaw, float pitch, float roll );


// Build transformation matrix.  NULL arguments are treated as identity.
// Mout = Msc-1 * Msr-1 * Ms * Msr * Msc * Mrc-1 * Mr * Mrc * Mt
D3DXMATRIX* WINAPI D3DXMatrixTransformation
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pScalingCenter,
      const D3DXQUATERNION *pScalingRotation, const D3DXVECTOR3 *pScaling,
      const D3DXVECTOR3 *pRotationCenter, const D3DXQUATERNION *pRotation,
      const D3DXVECTOR3 *pTranslation);

// Build affine transformation matrix.  NULL arguments are treated as identity.
// Mout = Ms * Mrc-1 * Mr * Mrc * Mt
D3DXMATRIX* WINAPI D3DXMatrixAffineTransformation
    ( D3DXMATRIX *pOut, float Scaling, const D3DXVECTOR3 *pRotationCenter,
      const D3DXQUATERNION *pRotation, const D3DXVECTOR3 *pTranslation);

// Build a lookat matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixLookAt
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pEye, const D3DXVECTOR3 *pAt,
      const D3DXVECTOR3 *pUp );

// Build a lookat matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixLookAtLH
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pEye, const D3DXVECTOR3 *pAt,
      const D3DXVECTOR3 *pUp );

// Build a perspective projection matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspective
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf );

// Build a perspective projection matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveLH
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf );

// Build a perspective projection matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveFov
    ( D3DXMATRIX *pOut, float fovy, float aspect, float zn, float zf );

// Build a perspective projection matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveFovLH
    ( D3DXMATRIX *pOut, float fovy, float aspect, float zn, float zf );

// Build a perspective projection matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveOffCenter
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf );

// Build a perspective projection matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveOffCenterLH
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf );

// Build an ortho projection matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixOrtho
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf );

// Build an ortho projection matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixOrthoLH
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf );

// Build an ortho projection matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixOrthoOffCenter
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf );

// Build an ortho projection matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixOrthoOffCenterLH
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf );

// Build a matrix which flattens geometry into a plane, as if casting
// a shadow from a light.
D3DXMATRIX* WINAPI D3DXMatrixShadow
    ( D3DXMATRIX *pOut, const D3DXVECTOR4 *pLight,
      const D3DXPLANE *pPlane );

// Build a matrix which reflects the coordinate system about a plane
D3DXMATRIX* WINAPI D3DXMatrixReflect
    ( D3DXMATRIX *pOut, const D3DXPLANE *pPlane );

#ifdef __cplusplus
}
#endif


//--------------------------
// Quaternion
//--------------------------

// inline

float D3DXQuaternionLength
    ( const D3DXQUATERNION *pQ );

// Length squared, or "norm"
float D3DXQuaternionLengthSq
    ( const D3DXQUATERNION *pQ );

float D3DXQuaternionDot
    ( const D3DXQUATERNION *pQ1, const D3DXQUATERNION *pQ2 );

// (0, 0, 0, 1)
D3DXQUATERNION* D3DXQuaternionIdentity
    ( D3DXQUATERNION *pOut );

BOOL D3DXQuaternionIsIdentity
    ( const D3DXQUATERNION *pQ );

// (-x, -y, -z, w)
D3DXQUATERNION* D3DXQuaternionConjugate
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ );


// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Compute a quaternin's axis and angle of rotation. Expects unit quaternions.
void WINAPI D3DXQuaternionToAxisAngle
    ( const D3DXQUATERNION *pQ, D3DXVECTOR3 *pAxis, float *pAngle );

// Build a quaternion from a rotation matrix.
D3DXQUATERNION* WINAPI D3DXQuaternionRotationMatrix
    ( D3DXQUATERNION *pOut, const D3DXMATRIX *pM);

// Rotation about arbitrary axis.
D3DXQUATERNION* WINAPI D3DXQuaternionRotationAxis
    ( D3DXQUATERNION *pOut, const D3DXVECTOR3 *pV, float angle );

// Yaw around the Y axis, a pitch around the X axis,
// and a roll around the Z axis.
D3DXQUATERNION* WINAPI D3DXQuaternionRotationYawPitchRoll
    ( D3DXQUATERNION *pOut, float yaw, float pitch, float roll );

// Quaternion multiplication.  The result represents the rotation Q2 
// followed by the rotation Q1.  (Out = Q2 * Q1)
D3DXQUATERNION* WINAPI D3DXQuaternionMultiply
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2 );

D3DXQUATERNION* WINAPI D3DXQuaternionNormalize
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ );

// Conjugate and re-norm
D3DXQUATERNION* WINAPI D3DXQuaternionInverse
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ );

// Expects unit quaternions.
// if q = (cos(theta), sin(theta) * v); ln(q) = (0, theta * v)
D3DXQUATERNION* WINAPI D3DXQuaternionLn
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ );

// Expects pure quaternions. (w == 0)  w is ignored in calculation.
// if q = (0, theta * v); exp(q) = (cos(theta), sin(theta) * v)
D3DXQUATERNION* WINAPI D3DXQuaternionExp
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ );

// Spherical linear interpolation between Q1 (s == 0) and Q2 (s == 1).
// Expects unit quaternions.
D3DXQUATERNION* WINAPI D3DXQuaternionSlerp
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2, float t );

// Spherical quadrangle interpolation.
// Slerp(Slerp(Q1, Q4, t), Slerp(Q2, Q3, t), 2t(1-t))
D3DXQUATERNION* WINAPI D3DXQuaternionSquad
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2, const D3DXQUATERNION *pQ3,
      const D3DXQUATERNION *pQ4, float t );

// Slerp(Slerp(Q1, Q2, f+g), Slerp(Q1, Q3, f+g), g/(f+g))
D3DXQUATERNION* WINAPI D3DXQuaternionBaryCentric
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2, const D3DXQUATERNION *pQ3,
      float f, float g );

#ifdef __cplusplus
}
#endif


//--------------------------
// Plane
//--------------------------

// inline

// ax + by + cz + dw
float D3DXPlaneDot
    ( const D3DXPLANE *pP, const D3DXVECTOR4 *pV);

// ax + by + cz + d
float D3DXPlaneDotCoord
    ( const D3DXPLANE *pP, const D3DXVECTOR3 *pV);

// ax + by + cz
float D3DXPlaneDotNormal
    ( const D3DXPLANE *pP, const D3DXVECTOR3 *pV);

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Normalize plane (so that |a,b,c| == 1)
D3DXPLANE* WINAPI D3DXPlaneNormalize
    ( D3DXPLANE *pOut, const D3DXPLANE *pP);

// Find the intersection between a plane and a line.  If the line is
// parallel to the plane, NULL is returned.
D3DXVECTOR3* WINAPI D3DXPlaneIntersectLine
    ( D3DXVECTOR3 *pOut, const D3DXPLANE *pP, const D3DXVECTOR3 *pV1,
      const D3DXVECTOR3 *pV2);

// Construct a plane from a point and a normal
D3DXPLANE* WINAPI D3DXPlaneFromPointNormal
    ( D3DXPLANE *pOut, const D3DXVECTOR3 *pPoint, const D3DXVECTOR3 *pNormal);

// Construct a plane from 3 points
D3DXPLANE* WINAPI D3DXPlaneFromPoints
    ( D3DXPLANE *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2,
      const D3DXVECTOR3 *pV3);

// Transform a plane by a matrix.  The vector (a,b,c) must be normal.
// M must be an affine transform.
D3DXPLANE* WINAPI D3DXPlaneTransform
    ( D3DXPLANE *pOut, const D3DXPLANE *pP, const D3DXMATRIX *pM );

#ifdef __cplusplus
}
#endif


//--------------------------
// Color
//--------------------------

// inline

// (1-r, 1-g, 1-b, a)
D3DXCOLOR* D3DXColorNegative
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC);

D3DXCOLOR* D3DXColorAdd
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC1, const D3DXCOLOR *pC2);

D3DXCOLOR* D3DXColorSubtract
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC1, const D3DXCOLOR *pC2);

D3DXCOLOR* D3DXColorScale
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC, float s);

// (r1*r2, g1*g2, b1*b2, a1*a2)
D3DXCOLOR* D3DXColorModulate
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC1, const D3DXCOLOR *pC2);

// Linear interpolation of r,g,b, and a. C1 + s(C2-C1)
D3DXCOLOR* D3DXColorLerp
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC1, const D3DXCOLOR *pC2, float s);

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Interpolate r,g,b between desaturated color and color.
// DesaturatedColor + s(Color - DesaturatedColor)
D3DXCOLOR* WINAPI D3DXColorAdjustSaturation
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC, float s);

// Interpolate r,g,b between 50% grey and color.  Grey + s(Color - Grey)
D3DXCOLOR* WINAPI D3DXColorAdjustContrast
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC, float c);

#ifdef __cplusplus
}
#endif






//===========================================================================
//
//    Matrix Stack
//
//===========================================================================

DECLARE_INTERFACE_(ID3DXMatrixStack, IUnknown)
{
    //
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //
    // ID3DXMatrixStack methods
    //

    // Pops the top of the stack, returns the current top
    // *after* popping the top.
    STDMETHOD(Pop)(THIS) PURE;

    // Pushes the stack by one, duplicating the current matrix.
    STDMETHOD(Push)(THIS) PURE;

    // Loads identity in the current matrix.
    STDMETHOD(LoadIdentity)(THIS) PURE;

    // Loads the given matrix into the current matrix
    STDMETHOD(LoadMatrix)(THIS_ const D3DXMATRIX* pM ) PURE;

    // Right-Multiplies the given matrix to the current matrix.
    // (transformation is about the current world origin)
    STDMETHOD(MultMatrix)(THIS_ const D3DXMATRIX* pM ) PURE;

    // Left-Multiplies the given matrix to the current matrix
    // (transformation is about the local origin of the object)
    STDMETHOD(MultMatrixLocal)(THIS_ const D3DXMATRIX* pM ) PURE;

    // Right multiply the current matrix with the computed rotation
    // matrix, counterclockwise about the given axis with the given angle.
    // (rotation is about the current world origin)
    STDMETHOD(RotateAxis)
        (THIS_ const D3DXVECTOR3* pV, float angle) PURE;

    // Left multiply the current matrix with the computed rotation
    // matrix, counterclockwise about the given axis with the given angle.
    // (rotation is about the local origin of the object)
    STDMETHOD(RotateAxisLocal)
        (THIS_ const D3DXVECTOR3* pV, float angle) PURE;

    // Right multiply the current matrix with the computed rotation
    // matrix. All angles are counterclockwise. (rotation is about the
    // current world origin)

    // The rotation is composed of a yaw around the Y axis, a pitch around
    // the X axis, and a roll around the Z axis.
    STDMETHOD(RotateYawPitchRoll)
        (THIS_ float yaw, float pitch, float roll) PURE;

    // Left multiply the current matrix with the computed rotation
    // matrix. All angles are counterclockwise. (rotation is about the
    // local origin of the object)

    // The rotation is composed of a yaw around the Y axis, a pitch around
    // the X axis, and a roll around the Z axis.
    STDMETHOD(RotateYawPitchRollLocal)
        (THIS_ float yaw, float pitch, float roll) PURE;

    // Right multiply the current matrix with the computed scale
    // matrix. (transformation is about the current world origin)
    STDMETHOD(Scale)(THIS_ float x, float y, float z) PURE;

    // Left multiply the current matrix with the computed scale
    // matrix. (transformation is about the local origin of the object)
    STDMETHOD(ScaleLocal)(THIS_ float x, float y, float z) PURE;

    // Right multiply the current matrix with the computed translation
    // matrix. (transformation is about the current world origin)
    STDMETHOD(Translate)(THIS_ float x, float y, float z ) PURE;

    // Left multiply the current matrix with the computed translation
    // matrix. (transformation is about the local origin of the object)
    STDMETHOD(TranslateLocal)(THIS_ float x, float y, float z) PURE;

    // Obtain the current matrix at the top of the stack
    STDMETHOD_(D3DXMATRIX*, GetTop)(THIS) PURE;
};

#ifdef __cplusplus
extern "C" {
#endif

HRESULT WINAPI D3DXCreateMatrixStack( DWORD flags, LPD3DXMATRIXSTACK *ppStack );

#ifdef __cplusplus
}
#endif

#include "d3dxmath.inl"

#pragma warning(default:4201)

#endif // __D3DXMATH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dxg\d3dxcore.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dxcore.h
//  Content:    D3DX core types and functions
//
///////////////////////////////////////////////////////////////////////////

#ifndef __D3DXCORE_H__
#define __D3DXCORE_H__

#include <d3d.h>
#include <limits.h>
#include "d3dxerr.h"


typedef struct ID3DXContext *LPD3DXCONTEXT;

// {9B74ED7A-BBEF-11d2-9F8E-0000F8080835}
DEFINE_GUID(IID_ID3DXContext, 
     0x9b74ed7a, 0xbbef, 0x11d2, 0x9f, 0x8e, 0x0, 0x0, 0xf8, 0x8, 0x8, 0x35);


///////////////////////////////////////////////////////////////////////////
// Defines and Enumerators used below:
///////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------------
// D3DX_DEFAULT:
// ---------
// A predefined value that could be used for any parameter in D3DX APIs or 
// member functions that is an enumerant or a handle.  The D3DX 
// documentation indicates wherever D3DX_DEFAULT may be used, 
// and how it will be interpreted in each situation.
//-------------------------------------------------------------------------
#define D3DX_DEFAULT ULONG_MAX
                            
//-------------------------------------------------------------------------
// D3DX_DEFAULT_FLOAT:
// ------------------
// Similar to D3DX_DEFAULT, but used for floating point parameters.
// The D3DX documentation indicates wherever D3DX_DEFAULT_FLOAT may be used, 
// and how it will be interpreted in each situation.
//-------------------------------------------------------------------------
#define D3DX_DEFAULT_FLOAT FLT_MAX
                            
//-------------------------------------------------------------------------
// Hardware Acceleration Level:
// ---------------------------
// These constants represent pre-defined hardware acceleration levels,
// and may be used as a default anywhere a (DWORD) deviceIndex is required.
// Each pre-define indicates a different level of hardware acceleration.
// They are an alternative to using explicit deviceIndices retrieved by
// D3DXGetDeviceDescription().
//
// The only case these pre-defines should be used as device indices is if
// a particular level of acceleration is required, and given more than 
// one capable device on the computer, it does not matter which one
// is used.
//
// The method of selection is as follows: If one of the D3DX devices on 
// the primary DDraw device supports a requested hardware acceleration 
// level, it will be used. Otherwise, the first matching device discovered 
// by D3DX will be used.  
//
// Of course, it is possible for no match to exist for any of the
// pre-defines on a particular computer.  Passing such a value into the
// D3DX apis will simply cause them to fail, reporting that no match
// is available.
// 
// D3DX_HWLEVEL_NULL:      Null implementation (draws nothing)
// D3DX_HWLEVEL_REFERENCE: Reference implementation (slowest)
// D3DX_HWLEVEL_2D:        2D acceleration only (RGB rasterizer used)
// D3DX_HWLEVEL_RASTER:    Rasterization acceleration (likely most useful)
// D3DX_HWLEVEL_TL:        Transform and lighting acceleration 
// D3DX_DEFAULT:           The highest level of acceleration available
//                         on the primary DDraw device.
//-------------------------------------------------------------------------
#define D3DX_HWLEVEL_NULL       (D3DX_DEFAULT - 1)
#define D3DX_HWLEVEL_REFERENCE  (D3DX_DEFAULT - 2)
#define D3DX_HWLEVEL_2D         (D3DX_DEFAULT - 3) 
#define D3DX_HWLEVEL_RASTER     (D3DX_DEFAULT - 4) 
#define D3DX_HWLEVEL_TL         (D3DX_DEFAULT - 5) 

//-------------------------------------------------------------------------
// Surface Class:
// -------------
// These are the various types of 2D-surfaces classified according to their
// usage. Note that a number of them overlap. e.g. STENCILBUFFERS and 
// DEPTHBUFFERS overlap (since in DX7 implementation the stencil and depth
// bits are part of the same pixel format).
//
// Mapping to the DX7 DDPIXELFORMAT concepts:
// -----------------------------------------
// D3DX_SC_DEPTHBUFFER:    All ddpfs which have the DDPF_ZPIXELS or the
//                           DDPF_ZBUFFER flags set.
// D3DX_SC_STENCILBUFFER:  All ddpfs which have the DDPF_STENCILBUFFER 
//                          flag set.
// D3DX_SC_BUMPMAP:        All ddpfs which have the DDPF_BUMPLUMINANCE 
//                           or the DDPF_BUMPDUDV flags set.
// D3DX_SC_LUMINANCEMAP:   All ddpfs which have the DDPF_BUMPLUMINANCE
//                           or the DDPF_LUMINANCE flags set.
// D3DX_SC_COLORTEXTURE:   All the surfaces that have color information in
//                           them and can be used for texturing.
// D3DX_SC_COLORRENDERTGT: All the surfaces that contain color 
//                           information and can be used as render targets.
//-------------------------------------------------------------------------
#define D3DX_SC_DEPTHBUFFER     0x01
#define D3DX_SC_STENCILBUFFER   0x02
#define D3DX_SC_COLORTEXTURE    0x04
#define D3DX_SC_BUMPMAP         0x08
#define D3DX_SC_LUMINANCEMAP    0x10
#define D3DX_SC_COLORRENDERTGT  0x20

//-------------------------------------------------------------------------
// Surface Formats:
// ---------------
// These are the various types of surface formats that can be enumerated, 
// there is no DDPIXELFORMAT structure in D3DX, the enums carry the meaning 
// (like FOURCCs).
//
// All the surface classes are represented here.  
//
//-------------------------------------------------------------------------
typedef enum _D3DX_SURFACEFORMAT
{
    D3DX_SF_UNKNOWN    = 0,
    D3DX_SF_R8G8B8     = 1,
    D3DX_SF_A8R8G8B8   = 2,
    D3DX_SF_X8R8G8B8   = 3,
    D3DX_SF_R5G6B5     = 4,
    D3DX_SF_R5G5B5     = 5,
    D3DX_SF_PALETTE4   = 6,
    D3DX_SF_PALETTE8   = 7,
    D3DX_SF_A1R5G5B5   = 8,
    D3DX_SF_X4R4G4B4   = 9,
    D3DX_SF_A4R4G4B4   =10,
    D3DX_SF_L8         =11,      // 8 bit luminance-only
    D3DX_SF_A8L8       =12,      // 16 bit alpha-luminance
    D3DX_SF_U8V8       =13,      // 16 bit bump map format
    D3DX_SF_U5V5L6     =14,      // 16 bit bump map format with luminance
    D3DX_SF_U8V8L8     =15,      // 24 bit bump map format with luminance
    D3DX_SF_UYVY       =16,      // UYVY format (PC98 compliance)
    D3DX_SF_YUY2       =17,      // YUY2 format (PC98 compliance)
    D3DX_SF_DXT1       =18,      // S3 texture compression technique 1
    D3DX_SF_DXT3       =19,      // S3 texture compression technique 3
    D3DX_SF_DXT5       =20,      // S3 texture compression technique 5
    D3DX_SF_R3G3B2     =21,      // 8 bit RGB texture format
    D3DX_SF_A8         =22,      // 8 bit alpha-only
    D3DX_SF_TEXTUREMAX =23,      // Last texture format

    D3DX_SF_Z16S0      =256,
    D3DX_SF_Z32S0      =257,
    D3DX_SF_Z15S1      =258,
    D3DX_SF_Z24S8      =259,
    D3DX_SF_S1Z15      =260,
    D3DX_SF_S8Z24      =261,
    D3DX_SF_DEPTHMAX   =262,     // Last depth format

    D3DX_SF_FORCEMAX  = (DWORD)(-1)
} D3DX_SURFACEFORMAT;

//-------------------------------------------------------------------------
// Filtering types for Texture APIs 
//
// -------------
// These are the various filter types for generation of mip-maps 
//
// D3DX_FILTERTYPE
// -----------------------------------------
// D3DX_FT_POINT:   Point sampling only - no filtering
// D3DX_FT_LINEAR:  Bi-linear filtering
//
//-------------------------------------------------------------------------
typedef enum _D3DX_FILTERTYPE
{
    D3DX_FT_POINT    = 0x01,
    D3DX_FT_LINEAR   = 0x02,
    D3DX_FT_DEFAULT  = D3DX_DEFAULT
} D3DX_FILTERTYPE;

///////////////////////////////////////////////////////////////////////////
// Structures used below:
///////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------------
// D3DX_VIDMODEDESC: Display mode description.
// ----------------
// width:       Screen Width 
// height:      Screen Height
// bpp:         Bits per pixel
// refreshRate: Refresh rate
//-------------------------------------------------------------------------
typedef struct  _D3DX_VIDMODEDESC
{
    DWORD width;
    DWORD height;
    DWORD bpp;
    DWORD refreshRate;
} D3DX_VIDMODEDESC;

//-------------------------------------------------------------------------
// D3DX_DEVICEDESC: Description of a device that can do 3D
// ---------------
// deviceIndex:   Unique (DWORD) number for the device.
// hwLevel:       Level of acceleration afforded.  This is one of the
//                predefined Device Indices, and exists in this
//                structure for informational purposes only.  More than
//                one device on the system may have the same hwLevel.
//                To refer to a particular device with the D3DX apis,
//                use the value in the deviceIndex member instead.
// ddGuid:        The ddraw GUID
// d3dDeviceGuid: Direct3D Device GUID
// ddDeviceID:    DDraw's GetDeviceIdentifier GUID.  This GUID is unique to
//                a particular driver revision on a particular video card.
// driverDesc:    String describing the driver
// monitor:       Handle to the video monitor used by this device (multimon
//                specific).  Devices that use different monitors on a 
//                multimon system report different values in this field.
//                Therefore, to test for a multimon system, an application 
//                should look for more than one different monitor handle in 
//                the list of D3DX devices.
// onPrimary:     Indicates if this device is on the primary monitor
//                (multimon specific).
//-------------------------------------------------------------------------
#define D3DX_DRIVERDESC_LENGTH    256

typedef struct _D3DX_DEVICEDESC
{
    DWORD       deviceIndex;  
    DWORD       hwLevel;
    GUID        ddGuid;       
    GUID        d3dDeviceGuid;   
    GUID        ddDeviceID;      
    char        driverDesc[D3DX_DRIVERDESC_LENGTH];          
    HMONITOR    monitor;
    BOOL        onPrimary;
} D3DX_DEVICEDESC;

///////////////////////////////////////////////////////////////////////////
// APIs:
///////////////////////////////////////////////////////////////////////////
#ifdef __cplusplus
extern "C" {
#endif //__cplusplus
    
//-------------------------------------------------------------------------
// D3DXInitialize: The very first call a D3DX app must make.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXInitialize();

//-------------------------------------------------------------------------
// D3DXUninitialize: The very last call a D3DX app must make.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXUninitialize();

//-------------------------------------------------------------------------
// D3DXGetDeviceCount: Returns the maximum number of D3DXdevices 
// ------------------  available.
//
// D3DXGetDeviceDescription: Lists the 2D and 3D capabilities of the devices. 
// ------------------------  Also, the various guids needed by ddraw and d3d.
//
// Params: 
//     [in] DWORD deviceIndex: Which device? Starts at 0.
//     [in] D3DX_DEVICEDESC* pd3dxDevice: Pointer to the D3DX_DEVICEDESC
//                                        structure to be filled in.
//-------------------------------------------------------------------------
DWORD WINAPI 
    D3DXGetDeviceCount();

HRESULT WINAPI
    D3DXGetDeviceDescription(DWORD            deviceIndex, 
                             D3DX_DEVICEDESC* pd3dxDeviceDesc);

//-------------------------------------------------------------------------
// D3DXGetMaxNumVideoModes: Returns the maximum number of video-modes .
// -----------------------  
//
// Params:
//     [in]  DWORD deviceIndex: The device being referred to.
//     [in]  DWORD flags: If D3DX_GVM_REFRESHRATE is set, then the refresh
//                        rates are not ignored.
//
// D3DXGetVideoMode:  Describes a particular video mode for this device
// ----------------
//
// Note:  These queries will simply give you a list of modes that the
//        display adapter tells DirectX that it supports.
//        There is no guarantee that D3DXCreateContext(Ex) will succeed 
//        with all listed video modes.  This is a fundamental limitation 
//        of the current DirectX architecture which D3DX cannot hide in 
//        any clean way.
//
// Params:
//     [in]  DWORD deviceIndex: The device being referred to.
//     [in]  DWORD flags: If D3DX_GVM_REFRESHRATE is set, then the refresh
//                        rates are returned
//     [in]  DWORD which: Which VideoMode ? Starts at 0.
//     [out] D3DX_VIDMODEDESC* pModeList: Pointer to the D3DX_VIDMODEDESC
//                        structure that will be filled in.
//-------------------------------------------------------------------------
DWORD WINAPI 
    D3DXGetMaxNumVideoModes(DWORD       deviceIndex, 
                            DWORD       flags);

HRESULT WINAPI
    D3DXGetVideoMode(DWORD             deviceIndex, 
                     DWORD             flags, 
                     DWORD             modeIndex, 
                     D3DX_VIDMODEDESC* pModeDesc);

#define D3DX_GVM_REFRESHRATE      0x00000001
//-------------------------------------------------------------------------
// D3DXGetMaxSurfaceFormats: Returns the maximum number of surface
// ------------------------  formats supported by the device at that
//                           video mode.
//
// D3DXGetSurfaceFormat: Describes one of the supported surface formats.
// --------------------- 
//
// Params:
//     [in]  DWORD  deviceIndex: The device being referred to.
//     [in]  D3DX_VIDMODEDESC* pDesc: The display mode at which the supported
//                                    surface formats are requested. If it is
//                                    NULL, the current display mode is 
//                                    assumed.
//     [in]  DWORD surfClassFlags: Required surface classes.  Only surface
//                                 formats which support all specified 
//                                 surface classes will be returned.  
//                                 (Multiple surface classes may be specified
//                                 using bitwise OR.) 
//     [in]  DWORD which: Which surface formats to retrieve. Starts at 0.
//     [out] D3DX_SURFACEFORMAT* pFormat: The surface format
//-------------------------------------------------------------------------
DWORD WINAPI 
    D3DXGetMaxSurfaceFormats(DWORD             deviceIndex, 
                             D3DX_VIDMODEDESC* pDesc,
                             DWORD             surfClassFlags);
HRESULT WINAPI
    D3DXGetSurfaceFormat(DWORD               deviceIndex,
                         D3DX_VIDMODEDESC*   pDesc,
                         DWORD               surfClassFlags,                   
                         DWORD               surfaceIndex, 
                         D3DX_SURFACEFORMAT* pFormat);


//-------------------------------------------------------------------------
// D3DXGetCurrentVideoMode: Retrieves the current video mode for this device.
// -------------------
//
// Params:
//     [in]  DWORD deviceIndex: The device being referred to.
//     [out] D3DX_VIDMODEDESC* pVidMode: The current video mode
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXGetCurrentVideoMode(DWORD             deviceIndex, 
                            D3DX_VIDMODEDESC* pVidMode);

//-------------------------------------------------------------------------
// D3DXGetDeviceCaps: Lists all the capabilities of a device at a display 
//                    mode.
// ----------------
//
// Params:
//     [in]  DWORD  deviceIndex: The device being referred to.
//     [in]  D3DX_VIDMODEDESC* pDesc:  If this is NULL, we will return the 
//                                     caps at the current display mode of 
//                                     the device.
//     [out] D3DDEVICEDESC7* pD3DDeviceDesc7: D3D Caps ( NULL to ignore 
//                                              parameter)
//     [out] DDCAPS7* pDDHalCaps: DDraw HAL Caps (NULL to ignore parameter)
//     [out] DDCAPS7* pDDHelCaps: DDraw HEL Caps (NULL to ignore  paramter)
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXGetDeviceCaps(DWORD             deviceIndex, 
                      D3DX_VIDMODEDESC* pVidMode,
                      D3DDEVICEDESC7*   pD3DCaps,
                      DDCAPS*           pDDHALCaps,
                      DDCAPS*           pDDHELCaps);

//-------------------------------------------------------------------------
// D3DXCreateContext: Initializes the chosen device. It is the simplest init
// -----------------  function available.  Parameters are treated the same
//                    as the matching subset of parameters in 
//                    D3DXCreateContextEx, documented below.
//                    Remaining D3DXCreateContextEx parameters that are
//                    not present in D3DXCreateContext are treated as
//                    D3DX_DEFAULT.  Note that multimon is not supported
//                    with D3DXCreateContext.
//
// D3DXCreateContextEx: A more advanced function to initialize the device.
// -------------------  Also accepts D3DX_DEFAULT for most of the parameters
//                      and then will do what D3DXCreateContext did.
//
// Note: Do not expect D3DXCreateContext(Ex) to be fail-safe (as with any
//       API).  Supported device capablilites should be used as a guide
//       for choosing parameter values.  Keep in mind that there will 
//       inevitably be some combinations of parameters that just do not work.
// 
// Params:
//     [in]  DWORD deviceIndex: The device being referred to.   
//     [in]  DWORD flags: The valid flags are D3DX_CONTEXT_FULLSCREEN, and
//                        D3DX_CONTEXT_OFFSCREEN.  These flags cannot both
//                        be specified.  If no flags are specified, the
//                        context defaults to windowed mode.
//
//     [in]  HWND  hwnd: Device window.  See note.
//     [in]  HWND  hwndFocus: Window which receives keyboard messages from 
//                            the device window.  The device window should be 
//                            a child of focus window.  Useful for multimon 
//                            applications.  See note.
//     NOTE: 
//         windowed:   
//             hwnd must be a valid window.  hwndFocus must be NULL or 
//             D3DX_DEFAULT.
//
//         fullscreen: 
//             Either hwnd or hwndFocus must be a valid window.  (Both cannot
//             be NULL or D3DX_DEFAULT).  If hwnd is NULL or D3DX_DEFAULT, 
//             a default device window will be created as a child of hwndFocus.
//
//         offscreen:
//             Both hwnd and hwndFocus must be NULL or D3DX_DEFAULT
//
//     [in]  DWORD numColorBits: If D3DX_DEFAULT is passed for windowed mode,
//                               the current desktop's color depth is chosen.
//                               For full screen mode, D3DX_DEFAULT causes 16
//                               bit color to be used.                               
//     [in]  DWORD numAlphaBits: If D3DX_DEFAULT is passed, 0 is chosen.
//     [in]  DWORD numDepthbits: If D3DX_DEFAULT is passed,
//                               the highest available number of depth bits
//                               is chosen.  See note.
//     [in]  DWORD numStencilBits: If D3DX_DEFAULT is passed, the highest
//                                 available number of stencil bits is chosen.
//                                 See note.
//
//     NOTE: If both numDepthBits and numStencilBits are D3DX_DEFAULT,
//           D3DX first picks the highest available number of stencil
//           bits.  Then, for the chosen number of stencil bits, 
//           the highest available number of depth bits is chosen.
//           If only one of numStencilBits or numDepthBits 
//           is D3DX_DEFAULT, the highest number of bits available 
//           for this parameter is chosen out of only the formats
//           that support the number of bits requested for the
//           fixed parameter.
//
//     [in]  DWORD numBackBuffers: Number of back buffers, or D3DX_DEFAULT.
//                                 See note.
//
//     NOTE:
//        windowed: D3DX_DEFAULT means 1.  You must specify one back buffer.
//
//        fullscreen: D3DX_DEFAULT means 1.  Any number of back buffers can be
//            specified.
//
//        offscreen: D3DX_DEFAULT means 0.  You cannot specify additional back 
//            buffers.
//
//     [in]  DWORD width: Width, in pixels, or D3DX_DEFAULT.  See note.
//     [in]  DWORD height: Height, in pixels, or D3DX_DEFAULT.  See note.
//
//     NOTE: 
//        windowed: If either width or height is D3DX_DEFAULT, both values
//            default to the dimensions of the client area of hwnd.
//
//        fullscreen: If either width or height is D3DX_DEFAULT, width 
//            defaults to 640, and height defaults to 480.
//
//        offscreen: An error is returned if either width or height is 
//            D3DX_DEFAULT.
//
//     [in]  DWORD refreshRate: D3DX_DEFAULT means we let ddraw choose for 
//                              us.  Ignored for windowed and offscreen modes.
//     [out] LPD3DXCONTEXT* ppCtx: This is the Context object that is used for
//                                 rendering on that device.
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateContext(DWORD          deviceIndex,  
                      DWORD          flags,
                      HWND           hwnd,
                      DWORD          width, 
                      DWORD          height,
                      LPD3DXCONTEXT* ppCtx);

HRESULT WINAPI
    D3DXCreateContextEx(DWORD          deviceIndex,  
                        DWORD          flags,
                        HWND           hwnd,
                        HWND           hwndFocus, 
                        DWORD          numColorBits,
                        DWORD          numAlphaBits,
                        DWORD          numDepthbits,
                        DWORD          numStencilBits,
                        DWORD          numBackBuffers,
                        DWORD          width, 
                        DWORD          height,
                        DWORD          refreshRate,
                        LPD3DXCONTEXT* ppCtx);

// The D3DXCreateContext(Ex) flags are:
#define D3DX_CONTEXT_FULLSCREEN  0x00000001
#define D3DX_CONTEXT_OFFSCREEN   0x00000002

//-------------------------------------------------------------------------
// D3DXGetErrorString: Prints out the error string given an hresult. Prints
// ------------------  Win32 as well as DX6 error messages besides the D3DX
//                     messages.
//
// Params:
//     [in]  HRESULT hr: The error code to be deciphered.
//     [in]  DWORD strLength: Length of the string passed in.
//     [out] LPSTR pStr:  The string output. This string of appropriate
//                       size needs to be passed in.
//-------------------------------------------------------------------------
void WINAPI
    D3DXGetErrorString(HRESULT hr, 
                       DWORD   strLength, 
                       LPSTR   pStr);

//-------------------------------------------------------------------------
// D3DXMakeDDPixelFormat: Fills in a DDPIXELFORMAT structure based on the 
// ---------------------   D3DX surface format requested.
//
// Params:
//     [in]  D3DX_SURFACEFORMAT d3dxFormat: Surface format.
//     [out] DDPIXELFORMAT*     pddpf:      Pixel format matching the given
//                                          surface format.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXMakeDDPixelFormat(D3DX_SURFACEFORMAT d3dxFormat, 
                          DDPIXELFORMAT*     pddpf);

//-------------------------------------------------------------------------
// D3DXMakeSurfaceFormat: Determines the surface format corresponding to 
// ---------------------  a given DDPIXELFORMAT. 
//
// Params:
//     [in]  DDPIXELFORMAT* pddpf: Pixel format.
// Return Value:
//     D3DX_SURFACEFORMAT: Surface format matching the given pixel format.
//                         D3DX_SF_UNKNOWN if the format is not supported
//-------------------------------------------------------------------------
D3DX_SURFACEFORMAT WINAPI
    D3DXMakeSurfaceFormat(DDPIXELFORMAT* pddpf);

#ifdef __cplusplus
}
#endif //__cplusplus    

///////////////////////////////////////////////////////////////////////////
// Interfaces:
///////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------------
// ID3DXContext interface: 
//
// This encapsulates all the stuff that the app might 
// want to do at initialization time and any global control over d3d and 
// ddraw.
//-------------------------------------------------------------------------


DECLARE_INTERFACE_(ID3DXContext, IUnknown)
{
    //
    // IUnknown methods 
    //
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // Get the DDraw and Direct3D objects to call DirectDraw or
    // Direct3D Immediate Mode functions. 
    // If the objects don't exist (because they have not
    // been created for some reason) NULL is returned.
    // All the objects returned in the following Get* functions
    // are addref'ed. It is the application's responsibility to
    // release them when no longer needed.
    STDMETHOD_(LPDIRECTDRAW7,GetDD)(THIS) PURE;
    STDMETHOD_(LPDIRECT3D7,GetD3D)(THIS) PURE;
    STDMETHOD_(LPDIRECT3DDEVICE7,GetD3DDevice)(THIS) PURE;

    // Get the various buffers that get created at the init time
    // These are addref'ed as well. It is the application's responsibility
    // to release them before the app quits or when it needs a resize.
    STDMETHOD_(LPDIRECTDRAWSURFACE7,GetPrimary)(THIS) PURE;
    STDMETHOD_(LPDIRECTDRAWSURFACE7,GetZBuffer)(THIS) PURE;
    STDMETHOD_(LPDIRECTDRAWSURFACE7,GetBackBuffer)(THIS_ DWORD which) PURE;

    // Get the associated window handles 
    STDMETHOD_(HWND,GetWindow)(THIS) PURE;
    STDMETHOD_(HWND,GetFocusWindow)(THIS) PURE;

    // 
    // Various Get methods, in case the user had specified default
    // parameters
    //
    STDMETHOD(GetDeviceIndex)(THIS_ 
                              LPDWORD pDeviceIndex, 
                              LPDWORD pHwLevel) PURE;

    STDMETHOD_(DWORD, GetNumBackBuffers)(THIS) PURE;

    STDMETHOD(GetNumBits)(THIS_
                          LPDWORD pColorBits, 
                          LPDWORD pDepthBits,
                          LPDWORD pAlphaBits, 
                          LPDWORD pStencilBits) PURE;

    STDMETHOD(GetBufferSize)(THIS_ 
                             LPDWORD pWidth, 
                             LPDWORD pHeight) PURE;

    // Get the flags that were used to create this context
    STDMETHOD_(DWORD, GetCreationFlags)(THIS) PURE;
    STDMETHOD_(DWORD, GetRefreshRate)(THIS) PURE;
    
    // Restoring surfaces in case stuff is lost
    STDMETHOD(RestoreSurfaces)(THIS) PURE;
    
    // Resize all the buffers to the new width and height
    STDMETHOD(Resize)(THIS_ DWORD width, DWORD height) PURE;

    // Update the frame using a flip or a blit,
    // If the D3DX_UPDATE_NOVSYNC flag is set, blit is used if the 
    // driver cannot flip without waiting for vsync in full-screen mode.
    STDMETHOD(UpdateFrame)(THIS_ DWORD flags) PURE;

    // Render a string at the specified coordinates, with the specified 
    // colour. This is only provided as a convenience for 
    // debugging/information during development.
    // topLeftX and topLeftY represent the location of the top left corner
    // of the string, on the render target.  
    // The coordinate and color parameters each have a range of 0.0-1.0
    STDMETHOD(DrawDebugText)(THIS_
                             float topLeftX, 
                             float topLeftY,
                             D3DCOLOR color,
                             LPSTR pString) PURE;

    // Clears to the current viewport
    // The following are the valid flags:
    // D3DCLEAR_TARGET  (to clear the render target )
    // D3DCLEAR_ZBUFFER (to clear the depth-buffer )
    // D3DCLEAR_STENCIL (to clear the stencil-buffer )
    STDMETHOD(Clear)(THIS_ DWORD ClearFlags) PURE;

    STDMETHOD(SetClearColor)(THIS_ D3DCOLOR color ) PURE;
    STDMETHOD(SetClearDepth)(THIS_ float z) PURE;
    STDMETHOD(SetClearStencil)(THIS_ DWORD stencil) PURE;
};


//-------------------------------------------------------------------------
// Flags for Update member function:
//

// Flag to indicate that blit should be used instead of a flip
// for full-screen rendering.
#define D3DX_UPDATE_NOVSYNC (1<<0)

///////////////////////////////////////////////////////////////////////////
// Texturing APIs:
///////////////////////////////////////////////////////////////////////////
#ifdef __cplusplus
extern "C" {
#endif //__cplusplus
    
//-------------------------------------------------------------------------
// D3DXCheckTextureRequirements: Return information about texture creation 
// ----------------------------  (used by CreateTexture, CreateTextureFromFile
//                                and CreateCubeMapTexture)
//
// Parameters:
//
//  pd3dDevice
//      The D3D device with which the texture is going to be used.
//  pFlags   
//      allows specification of D3DX_TEXTURE_NOMIPMAP
//      D3DX_TEXTURE_NOMIPMAP may be returned in the case where mipmap creation 
//      is not supported.
//  pWidth
//      width in pixels or NULL 
//      returns corrected width
//  pHeight       
//      height in pixels or NULL
//      returns corrected height
//  pPixelFormat
//      surface format 
//      returns best match to input format
//
//  Notes: 1. Unless the flags is set to specifically prevent creating 
//            mipmaps, mipmaps are generated all the way till 1x1 surface.
//         2. width, height and pixelformat are altered based on available 
//            hardware. For example:
//              a. Texture dimensions may be required to be powers of 2
//              b. We may require width == height for some devices
//              c. If PixelFormat is unavailable, a best fit is made
//-------------------------------------------------------------------------
HRESULT WINAPI 
    D3DXCheckTextureRequirements( LPDIRECT3DDEVICE7     pd3dDevice,
                                  LPDWORD               pFlags, 
                                  LPDWORD               pWidth,  
                                  LPDWORD               pHeight,  
                                  D3DX_SURFACEFORMAT*   pPixelFormat);

//-------------------------------------------------------------------------
// D3DXCreateTexture: Create an empty texture object
// -----------------
//
// Parameters:
//
//  pd3dDevice
//      The D3D device with which the texture is going to be used.
//  pFlags   
//      allows specification of D3DX_TEXTURE_NOMIPMAP
//      D3DX_TEXTURE_NOMIPMAP may be returned in the case where mipmap creation 
//      is not supported. Additionally, D3DX_TEXTURE_STAGE<n> can be specified
//      to indicate which texture stage the texture is for e.g. 
//      D3D_TEXTURE_STAGE1 indicates that the texture is for use with texture 
//      stage one. Stage Zero is the default if no TEXTURE_STAGE flags are
//      set.
//  pWidth
//      width in pixels; 0 or NULL is unacceptable
//      returns corrected width
//  pHeight       
//      height in pixels; 0 or NULL is unacceptable
//      returns corrected height
//  pPixelFormat
//      surface format. D3DX_DEFAULT is unacceptable.
//      returns actual format that was used
//  pDDPal
//      DDraw palette that is set (if present) on paletted surfaces.
//      It is ignored even if it is set, for non-paletted surfaces.
//  ppDDSurf
//      The ddraw surface that will be created
//  pNumMipMaps
//      the number of mipmaps actually generated
//
//  Notes: See notes for D3DXCheckTextureRequirements. 
//-------------------------------------------------------------------------
HRESULT WINAPI 
    D3DXCreateTexture( LPDIRECT3DDEVICE7     pd3dDevice,
                       LPDWORD               pFlags, 
                       LPDWORD               pWidth,  
                       LPDWORD               pHeight,  
                       D3DX_SURFACEFORMAT*   pPixelFormat,
                       LPDIRECTDRAWPALETTE   pDDPal,
                       LPDIRECTDRAWSURFACE7* ppDDSurf,
                       LPDWORD               pNumMipMaps);

//-------------------------------------------------------------------------
// D3DXCreateCubeMapTexture: Create blank cube-map texture
// ------------------------
//
// Parameters:
//
//  pd3dDevice
//      The D3D device with which the texture is going to be used.
//  pFlags   
//      allows specification of D3DX_TEXTURE_NOMIPMAP
//      D3DX_TEXTURE_NOMIPMAP may be returned in the case where mipmap creation 
//      is not supported. Additionally, D3DX_TEXTURE_STAGE<n> can be specified
//      to indicate which texture stage the texture is for e.g. 
//      D3D_TEXTURE_STAGE1 indicates that the texture is for use with texture 
//      stage one. Stage Zero is the default if no TEXTURE_STAGE flags are
//      set.
//  cubefaces
//      allows specification of which faces of the cube-map to generate.
//      D3DX_DEFAULT, 0, and DDSCAPS2_CUBEMAP_ALLFACES all mean
//      "create all 6 faces of the cubemap". Any combination of
//      DDSCAPS2_CUBEMAP_POSITIVEX, DDSCAPS2_CUBEMAP_NEGATIVEX,
//      DDSCAPS2_CUBEMAP_POSITIVEY, DDSCAPS2_CUBEMAP_NEGATIVEY,
//      DDSCAPS2_CUBEMAP_POSITIVEZ, or DDSCAPS2_CUBEMAP_NEGATIVEZ, is
//      valid.
//  colorEmptyFaces
//      allows specification of the color to use for the faces that were not
//      specified in the cubefaces parameter.
//  pWidth
//      width in pixels; 0 or NULL is unacceptable
//      returns corrected width
//  pHeight       
//      height in pixels; 0 or NULL is unacceptable
//      returns corrected height
//  pPixelFormat
//      surface format. D3DX_DEFAULT is unacceptable.
//      returns actual format that was used
//  pDDPal
//      DDraw palette that is set (if present) on paletted surfaces.
//      It is ignored even if it is set, for non-paletted surfaces.
//  ppDDSurf
//      the ddraw surface that will be created
//  pNumMipMaps
//      the number of mipmaps generated for a particular face of the 
//      cubemap.
//
//  Notes: See notes for D3DXCheckTextureRequirements. 
//-------------------------------------------------------------------------
HRESULT WINAPI 
    D3DXCreateCubeMapTexture( LPDIRECT3DDEVICE7     pd3dDevice,
                              LPDWORD               pFlags, 
                              DWORD                 cubefaces,
                              D3DCOLOR              colorEmptyFaces,
                              LPDWORD               pWidth,  
                              LPDWORD               pHeight,  
                              D3DX_SURFACEFORMAT    *pPixelFormat,
                              LPDIRECTDRAWPALETTE   pDDPal,
                              LPDIRECTDRAWSURFACE7* ppDDSurf,
                              LPDWORD               pNumMipMaps);


//-------------------------------------------------------------------------
// D3DXCreateTextureFromFile: Create a texture object from a file or from the 
// -------------------------  resource. Only BMP and DIB are supported from the
//                            resource portion of the executable.
//
// Parameters:
//
//  pd3dDevice
//      The D3D device with which the texture is going to be used.
//  pFlags   
//      allows specification of D3DX_TEXTURE_NOMIPMAP
//      D3DX_TEXTURE_NOMIPMAP may be returned in the case where mipmap creation 
//      is not supported. Additionally, D3DX_TEXTURE_STAGE<n> can be specified
//      to indicate which texture stage the texture is for e.g. 
//      D3D_TEXTURE_STAGE1 indicates that the texture is for use with texture 
//      stage one. Stage Zero is the default if no TEXTURE_STAGE flags are
//      set.
//  pWidth  
//      Width in pixels. If 0 or D3DX_DEFAULT, the width will be taken 
//      from the file
//      returns corrected width
//  pHeight   
//      Height in pixels. If 0 or D3DX_DEFAULT, the height will be taken 
//      from the file
//      returns corrected height
//  pPixelFormat
//      If D3DX_SF_UNKNOWN is passed in, pixel format closest to the bitmap 
//      will be chosen
//      returns actual format that was used
//  pDDPal
//      DDraw palette that is set (if present) on paletted surfaces.
//      It is ignored even if it is set, for non-paletted surfaces.
//  ppDDSurf
//      The ddraw surface that will be created.
//  pNumMipMaps
//      The number of mipmaps generated.
//  pSrcName
//      File name. BMP, DIB, DDS, are supported. 
//      
//      TGA is supported for the following cases: 16, 24, 32bpp direct color and 8bpp palettized. 
//      Also, 8, 16bpp grayscale is supported. RLE versions of the above 
//      TGA formats are also supported. ColorKey and Premultiplied Alpha 
//      are not currently supported for TGA files.
//      returns created format
//
//  Notes: See notes for D3DXCheckTextureRequirements. 
//-------------------------------------------------------------------------
HRESULT WINAPI 
    D3DXCreateTextureFromFile( LPDIRECT3DDEVICE7     pd3dDevice,
                               LPDWORD               pFlags, 
                               LPDWORD               pWidth,  
                               LPDWORD               pHeight,  
                               D3DX_SURFACEFORMAT*   pPixelFormat,
                               LPDIRECTDRAWPALETTE   pDDPal,
                               LPDIRECTDRAWSURFACE7* ppDDSurf,
                               LPDWORD               pNumMipMaps,
                               LPSTR                 pSrcName,
                               D3DX_FILTERTYPE       filterType);

//-------------------------------------------------------------------------
// D3DXLoadTextureFromFile: Load from a file into a mipmap level. Doing the 
// -----------------------  necessary color conversion and rescaling. File
//                          format support is identical to 
//                          D3DXCreateTextureFromFile's.
//
//  pd3dDevice
//      The D3D device with which the texture is going to be used.
// pTexture
//      a pointer to a DD7Surface which was created with either 
//      CreateTextureFromFile or CreateTexture.
// mipMapLevel
//      indicates mipmap level
//      Note: 
//          1. Error if mipmap level doesn't exist
//          2. If D3DX_DEFAULT and equal number of mipmap levels exist
//             then all the source mip-levels are loaded
//          3. If the source has mipmaps and the dest doesn't, use the top one
//          4. If the dest has miplevels and source doesn't, we expand
//          5. If there are unequal numbers of miplevels, we expand
// pSrcName
//      File name. BMP, DIB, DDS, are supported. 
//      For details on TGA support, refer to the comments for 
//      D3DXCreateTextureFromFile
// pSrcRect
//      the source rectangle or null (whole surface)
// pDestRect
//      the destination rectangle or null (whole surface)
// filterType 
//      filter used for mipmap generation
//-------------------------------------------------------------------------
HRESULT WINAPI 
    D3DXLoadTextureFromFile( LPDIRECT3DDEVICE7    pd3dDevice,
                             LPDIRECTDRAWSURFACE7 pTexture,
                             DWORD                mipMapLevel,
                             LPSTR                pSrcName, 
                             RECT*                pSrcRect, 
                             RECT*                pDestRect,
                             D3DX_FILTERTYPE      filterType);

//-------------------------------------------------------------------------
// D3DXLoadTextureFromSurface: Load from a DDraw Surface into a mipmap level. 
// --------------------------  Doing the necessary color conversion.
//
//  pd3dDevice
//      The D3D device with which the texture is going to be used.
// pTexture
//      a pointer to a DD7Surface which was created with either 
//      CreateTextureFromFile or CreateTexture.
// mipMapLevel
//      indicates mipmap level
//      Note: 
//          1. Error if mipmap level doesn't exist
//          2. If D3DX_DEFAULT and equal number of mipmap levels exist
//             then all the source mip-levels are loaded
//          3. If the source has mipmaps and the dest doesn't, use the top one
//          4. If the dest has miplevels and source doesn't, we expand
//          5. If there are unequal numbers of miplevels, we expand
// pSurfaceSrc
//      the source surface
// pSrcRect
//      the source rectangle or null (whole surface)
// pDestRect
//      the destination rectangle or null (whole surface)
// filterType 
//      filter used for mipmap generation
//-------------------------------------------------------------------------
HRESULT WINAPI 
    D3DXLoadTextureFromSurface( LPDIRECT3DDEVICE7    pd3dDevice,
                                LPDIRECTDRAWSURFACE7 pTexture,
                                DWORD                mipMapLevel,
                                LPDIRECTDRAWSURFACE7 pSurfaceSrc, 
                                RECT*                pSrcRect, 
                                RECT*                pDestRect,
                                D3DX_FILTERTYPE      filterType);

//-------------------------------------------------------------------------
// D3DXLoadTextureFromMemory: Load a mip level from memory. Doing the necessary
// -------------------------  color conversion.
//
//  pd3dDevice
//      The D3D device with which the texture is going to be used.
// pTexture
//      a pointer to a DD7Surface which was created with either 
//      CreateTextureFromFile or CreateTexture.
// mipMapLevel
//      indicates mipmap level
//      Note: 
//          1. Error if mipmap level doesn't exist
//          2. If D3DX_DEFAULT and equal number of mipmap levels exist
//             then all the source mip-levels are loaded
//          3. If the source has mipmaps and the dest doesn't, use the top one
//          4. If the dest has miplevels and source doesn't, we expand
//          5. If there are unequal numbers of miplevels, we expand
// pMemory
//      pointer to source memory from which the texture will be loaded
// pDDPal
//      DirectDraw Palette, that the app passes in optionally if the memory is 
//      supposed to be paletteized.
// srcPixelFormat
//      PixelFormat of the source.
// srcPitch
//      The pitch of the memory or D3DX_DEFAULT (based on srcPixelFormat)
// pDestRect
//      The destination rectangle or null (whole surface)
// filterType 
//      filter used for mipmap generation
// 
// Assumptions: The source (memory) is loaded in full
//-------------------------------------------------------------------------
HRESULT WINAPI 
    D3DXLoadTextureFromMemory( LPDIRECT3DDEVICE7    pd3dDevice, 
                               LPDIRECTDRAWSURFACE7 pTexture,
                               DWORD                mipMapLevel, 
                               LPVOID               pMemory,
                               LPDIRECTDRAWPALETTE  pDDPal,
                               D3DX_SURFACEFORMAT   srcPixelFormat,
                               DWORD                srcPitch,
                               RECT*                pDestRect,
                               D3DX_FILTERTYPE      filterType);

#ifdef __cplusplus
}
#endif //__cplusplus    

//-------------------------------------------------------------------------
// Flags for texture create functions; applies to 
// D3DXCreateTexture, D3DXCreateCubeMapTexture and D3DXCreateTextureFromFile.
//

// Flag to indicate that mipmap generation is not desired.
#define D3DX_TEXTURE_NOMIPMAP  (1 << 8)

// Flags to indicate which texture stage the texture is
// intended for use with. Specifying the stage is necessary at
// texture creation time for HW devices that expose the
// D3DDEVCAPS_SEPARATETEXTUREMEMORIES bit in their D3DDEVICEDESC
// structure.
#define D3DX_TEXTURE_STAGE0    (0)
#define D3DX_TEXTURE_STAGE1    (1)
#define D3DX_TEXTURE_STAGE2    (2)
#define D3DX_TEXTURE_STAGE3    (3)
#define D3DX_TEXTURE_STAGE4    (4)
#define D3DX_TEXTURE_STAGE5    (5)
#define D3DX_TEXTURE_STAGE6    (6)
#define D3DX_TEXTURE_STAGE7    (7)

// Mask to extract the texture stage value out of the flags to
// the texture create functions.
#define D3DX_TEXTURE_STAGE_MASK (0x7)

#endif //__D3DXCORE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dxg\d3dx8math.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1998 - 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8math.h
//  Content:    D3DX math types and functions
//
//////////////////////////////////////////////////////////////////////////////

#include "d3dx8.h"

#ifndef __XGMATH_H__

#ifndef __D3DX8MATH_H__
#define __D3DX8MATH_H__

#ifdef __cplusplus
extern "C++" {
#endif // __cplusplus

#include <math.h>

#pragma warning(disable:4201) // anonymous unions warning



typedef struct ID3DXMatrixStack *LPD3DXMATRIXSTACK;

// {E3357330-CC5E-11d2-A434-00A0C90629A8}
DEFINE_GUID( IID_ID3DXMatrixStack,
0xe3357330, 0xcc5e, 0x11d2, 0xa4, 0x34, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);


//===========================================================================
//
// General purpose utilities
//
//===========================================================================
#define D3DX_PI    ((FLOAT)  3.141592654f)
#define D3DX_1BYPI ((FLOAT)  0.318309886f)

#define D3DXToRadian( degree ) ((degree) * (D3DX_PI / 180.0f))
#define D3DXToDegree( radian ) ((radian) * (180.0f / D3DX_PI))



//===========================================================================
//
// Vectors
//
//===========================================================================

//--------------------------
// 2D Vector
//--------------------------
typedef struct D3DXVECTOR2
{
#ifdef __cplusplus
public:
    D3DXVECTOR2() {};
    D3DXVECTOR2( CONST FLOAT * );
    D3DXVECTOR2( FLOAT x, FLOAT y );

    // casting
    operator FLOAT* ();
    operator CONST FLOAT* () const;

    // assignment operators
    D3DXVECTOR2& operator += ( CONST D3DXVECTOR2& );
    D3DXVECTOR2& operator -= ( CONST D3DXVECTOR2& );
    D3DXVECTOR2& operator *= ( FLOAT );
    D3DXVECTOR2& operator /= ( FLOAT );

    // unary operators
    D3DXVECTOR2 operator + () const;
    D3DXVECTOR2 operator - () const;

    // binary operators
    D3DXVECTOR2 operator + ( CONST D3DXVECTOR2& ) const;
    D3DXVECTOR2 operator - ( CONST D3DXVECTOR2& ) const;
    D3DXVECTOR2 operator * ( FLOAT ) const;
    D3DXVECTOR2 operator / ( FLOAT ) const;

    friend D3DXVECTOR2 operator * ( FLOAT, CONST D3DXVECTOR2& );

    BOOL operator == ( CONST D3DXVECTOR2& ) const;
    BOOL operator != ( CONST D3DXVECTOR2& ) const;


public:
#endif //__cplusplus
    FLOAT x, y;
} D3DXVECTOR2, *LPD3DXVECTOR2;


//--------------------------
// 3D Vector
//--------------------------
#ifdef __cplusplus
typedef struct D3DXVECTOR3 : public D3DVECTOR
{
public:
    D3DXVECTOR3() {};
    D3DXVECTOR3( CONST FLOAT * );
    D3DXVECTOR3( CONST D3DVECTOR& );
    D3DXVECTOR3( FLOAT x, FLOAT y, FLOAT z );

    // casting
    operator FLOAT* ();
    operator CONST FLOAT* () const;

    // assignment operators
    D3DXVECTOR3& operator += ( CONST D3DXVECTOR3& );
    D3DXVECTOR3& operator -= ( CONST D3DXVECTOR3& );
    D3DXVECTOR3& operator *= ( FLOAT );
    D3DXVECTOR3& operator /= ( FLOAT );

    // unary operators
    D3DXVECTOR3 operator + () const;
    D3DXVECTOR3 operator - () const;

    // binary operators
    D3DXVECTOR3 operator + ( CONST D3DXVECTOR3& ) const;
    D3DXVECTOR3 operator - ( CONST D3DXVECTOR3& ) const;
    D3DXVECTOR3 operator * ( FLOAT ) const;
    D3DXVECTOR3 operator / ( FLOAT ) const;

    friend D3DXVECTOR3 operator * ( FLOAT, CONST struct D3DXVECTOR3& );

    BOOL operator == ( CONST D3DXVECTOR3& ) const;
    BOOL operator != ( CONST D3DXVECTOR3& ) const;

} D3DXVECTOR3, *LPD3DXVECTOR3;

#else //!__cplusplus
typedef struct _D3DVECTOR D3DXVECTOR3, *LPD3DXVECTOR3;
#endif //!__cplusplus


//--------------------------
// 4D Vector
//--------------------------
typedef struct D3DXVECTOR4
{
#ifdef __cplusplus
public:
    D3DXVECTOR4() {};
    D3DXVECTOR4( CONST FLOAT* );
    D3DXVECTOR4( FLOAT x, FLOAT y, FLOAT z, FLOAT w );

    // casting
    operator FLOAT* ();
    operator CONST FLOAT* () const;

    // assignment operators
    D3DXVECTOR4& operator += ( CONST D3DXVECTOR4& );
    D3DXVECTOR4& operator -= ( CONST D3DXVECTOR4& );
    D3DXVECTOR4& operator *= ( FLOAT );
    D3DXVECTOR4& operator /= ( FLOAT );

    // unary operators
    D3DXVECTOR4 operator + () const;
    D3DXVECTOR4 operator - () const;

    // binary operators
    D3DXVECTOR4 operator + ( CONST D3DXVECTOR4& ) const;
    D3DXVECTOR4 operator - ( CONST D3DXVECTOR4& ) const;
    D3DXVECTOR4 operator * ( FLOAT ) const;
    D3DXVECTOR4 operator / ( FLOAT ) const;

    friend D3DXVECTOR4 operator * ( FLOAT, CONST D3DXVECTOR4& );

    BOOL operator == ( CONST D3DXVECTOR4& ) const;
    BOOL operator != ( CONST D3DXVECTOR4& ) const;

public:
#endif //__cplusplus
    FLOAT x, y, z, w;
} D3DXVECTOR4, *LPD3DXVECTOR4;


//===========================================================================
//
// Matrices
//
//===========================================================================
#ifdef __cplusplus
typedef struct D3DXMATRIX : public D3DMATRIX
{
public:
    D3DXMATRIX() {};
    D3DXMATRIX( CONST FLOAT * );
    D3DXMATRIX( CONST D3DMATRIX& );
    D3DXMATRIX( FLOAT _11, FLOAT _12, FLOAT _13, FLOAT _14,
                FLOAT _21, FLOAT _22, FLOAT _23, FLOAT _24,
                FLOAT _31, FLOAT _32, FLOAT _33, FLOAT _34,
                FLOAT _41, FLOAT _42, FLOAT _43, FLOAT _44 );


    // access grants
    FLOAT& operator () ( UINT Row, UINT Col );
    FLOAT  operator () ( UINT Row, UINT Col ) const;

    // casting operators
    operator FLOAT* ();
    operator CONST FLOAT* () const;

    // assignment operators
    D3DXMATRIX& operator *= ( CONST D3DXMATRIX& );
    D3DXMATRIX& operator += ( CONST D3DXMATRIX& );
    D3DXMATRIX& operator -= ( CONST D3DXMATRIX& );
    D3DXMATRIX& operator *= ( FLOAT );
    D3DXMATRIX& operator /= ( FLOAT );

    // unary operators
    D3DXMATRIX operator + () const;
    D3DXMATRIX operator - () const;

    // binary operators
    D3DXMATRIX operator * ( CONST D3DXMATRIX& ) const;
    D3DXMATRIX operator + ( CONST D3DXMATRIX& ) const;
    D3DXMATRIX operator - ( CONST D3DXMATRIX& ) const;
    D3DXMATRIX operator * ( FLOAT ) const;
    D3DXMATRIX operator / ( FLOAT ) const;

    friend D3DXMATRIX operator * ( FLOAT, CONST D3DXMATRIX& );

    BOOL operator == ( CONST D3DXMATRIX& ) const;
    BOOL operator != ( CONST D3DXMATRIX& ) const;

} D3DXMATRIX, *LPD3DXMATRIX;

#else //!__cplusplus
typedef struct _D3DMATRIX D3DXMATRIX, *LPD3DXMATRIX;
#endif //!__cplusplus


//===========================================================================
//
//    Quaternions
//
//===========================================================================
typedef struct D3DXQUATERNION
{
#ifdef __cplusplus
public:
    D3DXQUATERNION() {}
    D3DXQUATERNION( CONST FLOAT * );
    D3DXQUATERNION( FLOAT x, FLOAT y, FLOAT z, FLOAT w );

    // casting
    operator FLOAT* ();
    operator CONST FLOAT* () const;

    // assignment operators
    D3DXQUATERNION& operator += ( CONST D3DXQUATERNION& );
    D3DXQUATERNION& operator -= ( CONST D3DXQUATERNION& );
    D3DXQUATERNION& operator *= ( CONST D3DXQUATERNION& );
    D3DXQUATERNION& operator *= ( FLOAT );
    D3DXQUATERNION& operator /= ( FLOAT );

    // unary operators
    D3DXQUATERNION  operator + () const;
    D3DXQUATERNION  operator - () const;

    // binary operators
    D3DXQUATERNION operator + ( CONST D3DXQUATERNION& ) const;
    D3DXQUATERNION operator - ( CONST D3DXQUATERNION& ) const;
    D3DXQUATERNION operator * ( CONST D3DXQUATERNION& ) const;
    D3DXQUATERNION operator * ( FLOAT ) const;
    D3DXQUATERNION operator / ( FLOAT ) const;

    friend D3DXQUATERNION operator * (FLOAT, CONST D3DXQUATERNION& );

    BOOL operator == ( CONST D3DXQUATERNION& ) const;
    BOOL operator != ( CONST D3DXQUATERNION& ) const;

#endif //__cplusplus
    FLOAT x, y, z, w;
} D3DXQUATERNION, *LPD3DXQUATERNION;


//===========================================================================
//
// Planes
//
//===========================================================================
typedef struct D3DXPLANE
{
#ifdef __cplusplus
public:
    D3DXPLANE() {}
    D3DXPLANE( CONST FLOAT* );
    D3DXPLANE( FLOAT a, FLOAT b, FLOAT c, FLOAT d );

    // casting
    operator FLOAT* ();
    operator CONST FLOAT* () const;

    // unary operators
    D3DXPLANE operator + () const;
    D3DXPLANE operator - () const;

    // binary operators
    BOOL operator == ( CONST D3DXPLANE& ) const;
    BOOL operator != ( CONST D3DXPLANE& ) const;

#endif //__cplusplus
    FLOAT a, b, c, d;
} D3DXPLANE, *LPD3DXPLANE;


//===========================================================================
//
// Colors
//
//===========================================================================

typedef struct D3DXCOLOR
{
#ifdef __cplusplus
public:
    D3DXCOLOR() {}
    D3DXCOLOR( DWORD argb );
    D3DXCOLOR( CONST FLOAT * );
    D3DXCOLOR( CONST D3DCOLORVALUE& );
    D3DXCOLOR( FLOAT r, FLOAT g, FLOAT b, FLOAT a );

    // casting
    operator DWORD () const;

    operator FLOAT* ();
    operator CONST FLOAT* () const;

    operator D3DCOLORVALUE* ();
    operator CONST D3DCOLORVALUE* () const;

    operator D3DCOLORVALUE& ();
    operator CONST D3DCOLORVALUE& () const;

    // assignment operators
    D3DXCOLOR& operator += ( CONST D3DXCOLOR& );
    D3DXCOLOR& operator -= ( CONST D3DXCOLOR& );
    D3DXCOLOR& operator *= ( FLOAT );
    D3DXCOLOR& operator /= ( FLOAT );

    // unary operators
    D3DXCOLOR operator + () const;
    D3DXCOLOR operator - () const;

    // binary operators
    D3DXCOLOR operator + ( CONST D3DXCOLOR& ) const;
    D3DXCOLOR operator - ( CONST D3DXCOLOR& ) const;
    D3DXCOLOR operator * ( FLOAT ) const;
    D3DXCOLOR operator / ( FLOAT ) const;

    friend D3DXCOLOR operator * (FLOAT, CONST D3DXCOLOR& );

    BOOL operator == ( CONST D3DXCOLOR& ) const;
    BOOL operator != ( CONST D3DXCOLOR& ) const;

#endif //__cplusplus
    FLOAT r, g, b, a;
} D3DXCOLOR, *LPD3DXCOLOR;



//===========================================================================
//
// D3DX math functions:
//
// NOTE:
//  * All these functions can take the same object as in and out parameters.
//
//  * Out parameters are typically also returned as return values, so that
//    the output of one function may be used as a parameter to another.
//
//===========================================================================

//--------------------------
// 2D Vector
//--------------------------

// inline

FLOAT D3DXVec2Length
    ( CONST D3DXVECTOR2 *pV );

FLOAT D3DXVec2LengthSq
    ( CONST D3DXVECTOR2 *pV );

FLOAT D3DXVec2Dot
    ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );

// Z component of ((x1,y1,0) cross (x2,y2,0))
FLOAT D3DXVec2CCW
    ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );

D3DXVECTOR2* D3DXVec2Add
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );

D3DXVECTOR2* D3DXVec2Subtract
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );

// Minimize each component.  x = min(x1, x2), y = min(y1, y2)
D3DXVECTOR2* D3DXVec2Minimize
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );

// Maximize each component.  x = max(x1, x2), y = max(y1, y2)
D3DXVECTOR2* D3DXVec2Maximize
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );

D3DXVECTOR2* D3DXVec2Scale
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s );

// Linear interpolation. V1 + s(V2-V1)
D3DXVECTOR2* D3DXVec2Lerp
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
      FLOAT s );

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

D3DXVECTOR2* WINAPI D3DXVec2Normalize
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV );

// Hermite interpolation between position V1, tangent T1 (when s == 0)
// and position V2, tangent T2 (when s == 1).
D3DXVECTOR2* WINAPI D3DXVec2Hermite
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pT1,
      CONST D3DXVECTOR2 *pV2, CONST D3DXVECTOR2 *pT2, FLOAT s );

// CatmullRom interpolation between V1 (when s == 0) and V2 (when s == 1)
D3DXVECTOR2* WINAPI D3DXVec2CatmullRom
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV0, CONST D3DXVECTOR2 *pV1,
      CONST D3DXVECTOR2 *pV2, CONST D3DXVECTOR2 *pV3, FLOAT s );

// Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)
D3DXVECTOR2* WINAPI D3DXVec2BaryCentric
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
      D3DXVECTOR2 *pV3, FLOAT f, FLOAT g);

// Transform (x, y, 0, 1) by matrix.
D3DXVECTOR4* WINAPI D3DXVec2Transform
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR2 *pV, CONST D3DXMATRIX *pM );

// Transform (x, y, 0, 1) by matrix, project result back into w=1.
D3DXVECTOR2* WINAPI D3DXVec2TransformCoord
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, CONST D3DXMATRIX *pM );

// Transform (x, y, 0, 0) by matrix.
D3DXVECTOR2* WINAPI D3DXVec2TransformNormal
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, CONST D3DXMATRIX *pM );

#ifdef __cplusplus
}
#endif


//--------------------------
// 3D Vector
//--------------------------

// inline

FLOAT D3DXVec3Length
    ( CONST D3DXVECTOR3 *pV );

FLOAT D3DXVec3LengthSq
    ( CONST D3DXVECTOR3 *pV );

FLOAT D3DXVec3Dot
    ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );

D3DXVECTOR3* D3DXVec3Cross
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );

D3DXVECTOR3* D3DXVec3Add
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );

D3DXVECTOR3* D3DXVec3Subtract
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );

// Minimize each component.  x = min(x1, x2), y = min(y1, y2), ...
D3DXVECTOR3* D3DXVec3Minimize
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );

// Maximize each component.  x = max(x1, x2), y = max(y1, y2), ...
D3DXVECTOR3* D3DXVec3Maximize
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );

D3DXVECTOR3* D3DXVec3Scale
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, FLOAT s);

// Linear interpolation. V1 + s(V2-V1)
D3DXVECTOR3* D3DXVec3Lerp
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2,
      FLOAT s );

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

D3DXVECTOR3* WINAPI D3DXVec3Normalize
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV );

// Hermite interpolation between position V1, tangent T1 (when s == 0)
// and position V2, tangent T2 (when s == 1).
D3DXVECTOR3* WINAPI D3DXVec3Hermite
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pT1,
      CONST D3DXVECTOR3 *pV2, CONST D3DXVECTOR3 *pT2, FLOAT s );

// CatmullRom interpolation between V1 (when s == 0) and V2 (when s == 1)
D3DXVECTOR3* WINAPI D3DXVec3CatmullRom
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV0, CONST D3DXVECTOR3 *pV1,
      CONST D3DXVECTOR3 *pV2, CONST D3DXVECTOR3 *pV3, FLOAT s );

// Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)
D3DXVECTOR3* WINAPI D3DXVec3BaryCentric
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2,
      CONST D3DXVECTOR3 *pV3, FLOAT f, FLOAT g);

// Transform (x, y, z, 1) by matrix.
D3DXVECTOR4* WINAPI D3DXVec3Transform
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DXMATRIX *pM );

// Transform (x, y, z, 1) by matrix, project result back into w=1.
D3DXVECTOR3* WINAPI D3DXVec3TransformCoord
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DXMATRIX *pM );

// Transform (x, y, z, 0) by matrix.  If you transforming a normal by a
// non-affine matrix, the matrix you pass to this function should be the
// transpose of the inverse of the matrix you would use to transform a coord.
D3DXVECTOR3* WINAPI D3DXVec3TransformNormal
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DXMATRIX *pM );

// Project vector from object space into screen space
D3DXVECTOR3* WINAPI D3DXVec3Project
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DVIEWPORT8 *pViewport,
      CONST D3DXMATRIX *pProjection, CONST D3DXMATRIX *pView, CONST D3DXMATRIX *pWorld);

// Project vector from screen space into object space
D3DXVECTOR3* WINAPI D3DXVec3Unproject
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DVIEWPORT8 *pViewport,
      CONST D3DXMATRIX *pProjection, CONST D3DXMATRIX *pView, CONST D3DXMATRIX *pWorld);

#ifdef __cplusplus
}
#endif



//--------------------------
// 4D Vector
//--------------------------

// inline

FLOAT D3DXVec4Length
    ( CONST D3DXVECTOR4 *pV );

FLOAT D3DXVec4LengthSq
    ( CONST D3DXVECTOR4 *pV );

FLOAT D3DXVec4Dot
    ( CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2 );

D3DXVECTOR4* D3DXVec4Add
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2);

D3DXVECTOR4* D3DXVec4Subtract
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2);

// Minimize each component.  x = min(x1, x2), y = min(y1, y2), ...
D3DXVECTOR4* D3DXVec4Minimize
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2);

// Maximize each component.  x = max(x1, x2), y = max(y1, y2), ...
D3DXVECTOR4* D3DXVec4Maximize
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2);

D3DXVECTOR4* D3DXVec4Scale
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV, FLOAT s);

// Linear interpolation. V1 + s(V2-V1)
D3DXVECTOR4* D3DXVec4Lerp
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2,
      FLOAT s );

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Cross-product in 4 dimensions.
D3DXVECTOR4* WINAPI D3DXVec4Cross
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2,
      CONST D3DXVECTOR4 *pV3);

D3DXVECTOR4* WINAPI D3DXVec4Normalize
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV );

// Hermite interpolation between position V1, tangent T1 (when s == 0)
// and position V2, tangent T2 (when s == 1).
D3DXVECTOR4* WINAPI D3DXVec4Hermite
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pT1,
      CONST D3DXVECTOR4 *pV2, CONST D3DXVECTOR4 *pT2, FLOAT s );

// CatmullRom interpolation between V1 (when s == 0) and V2 (when s == 1)
D3DXVECTOR4* WINAPI D3DXVec4CatmullRom
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV0, CONST D3DXVECTOR4 *pV1,
      CONST D3DXVECTOR4 *pV2, CONST D3DXVECTOR4 *pV3, FLOAT s );

// Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)
D3DXVECTOR4* WINAPI D3DXVec4BaryCentric
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2,
      CONST D3DXVECTOR4 *pV3, FLOAT f, FLOAT g);

// Transform vector by matrix.
D3DXVECTOR4* WINAPI D3DXVec4Transform
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV, CONST D3DXMATRIX *pM );

#ifdef __cplusplus
}
#endif


//--------------------------
// 4D Matrix
//--------------------------

// inline

D3DXMATRIX* D3DXMatrixIdentity
    ( D3DXMATRIX *pOut );

BOOL D3DXMatrixIsIdentity
    ( CONST D3DXMATRIX *pM );


// non-inline
#ifdef __cplusplus
extern "C" {
#endif

FLOAT WINAPI D3DXMatrixfDeterminant
    ( CONST D3DXMATRIX *pM );

// Matrix multiplication.  The result represents the transformation M2
// followed by the transformation M1.  (Out = M1 * M2)
D3DXMATRIX* WINAPI D3DXMatrixMultiply
    ( D3DXMATRIX *pOut, CONST D3DXMATRIX *pM1, CONST D3DXMATRIX *pM2 );

D3DXMATRIX* WINAPI D3DXMatrixTranspose
    ( D3DXMATRIX *pOut, CONST D3DXMATRIX *pM );

// Calculate inverse of matrix.  Inversion my fail, in which case NULL will
// be returned.  The determinant of pM is also returned it pfDeterminant
// is non-NULL.
D3DXMATRIX* WINAPI D3DXMatrixInverse
    ( D3DXMATRIX *pOut, FLOAT *pDeterminant, CONST D3DXMATRIX *pM );

// Build a matrix which scales by (sx, sy, sz)
D3DXMATRIX* WINAPI D3DXMatrixScaling
    ( D3DXMATRIX *pOut, FLOAT sx, FLOAT sy, FLOAT sz );

// Build a matrix which translates by (x, y, z)
D3DXMATRIX* WINAPI D3DXMatrixTranslation
    ( D3DXMATRIX *pOut, FLOAT x, FLOAT y, FLOAT z );

// Build a matrix which rotates around the X axis
D3DXMATRIX* WINAPI D3DXMatrixRotationX
    ( D3DXMATRIX *pOut, FLOAT Angle );

// Build a matrix which rotates around the Y axis
D3DXMATRIX* WINAPI D3DXMatrixRotationY
    ( D3DXMATRIX *pOut, FLOAT Angle );

// Build a matrix which rotates around the Z axis
D3DXMATRIX* WINAPI D3DXMatrixRotationZ
    ( D3DXMATRIX *pOut, FLOAT Angle );

// Build a matrix which rotates around an arbitrary axis
D3DXMATRIX* WINAPI D3DXMatrixRotationAxis
    ( D3DXMATRIX *pOut, CONST D3DXVECTOR3 *pV, FLOAT Angle );

// Build a matrix from a quaternion
D3DXMATRIX* WINAPI D3DXMatrixRotationQuaternion
    ( D3DXMATRIX *pOut, CONST D3DXQUATERNION *pQ);

// Yaw around the Y axis, a pitch around the X axis,
// and a roll around the Z axis.
D3DXMATRIX* WINAPI D3DXMatrixRotationYawPitchRoll
    ( D3DXMATRIX *pOut, FLOAT Yaw, FLOAT Pitch, FLOAT Roll );


// Build transformation matrix.  NULL arguments are treated as identity.
// Mout = Msc-1 * Msr-1 * Ms * Msr * Msc * Mrc-1 * Mr * Mrc * Mt
D3DXMATRIX* WINAPI D3DXMatrixTransformation
    ( D3DXMATRIX *pOut, CONST D3DXVECTOR3 *pScalingCenter,
      CONST D3DXQUATERNION *pScalingRotation, CONST D3DXVECTOR3 *pScaling,
      CONST D3DXVECTOR3 *pRotationCenter, CONST D3DXQUATERNION *pRotation,
      CONST D3DXVECTOR3 *pTranslation);

// Build affine transformation matrix.  NULL arguments are treated as identity.
// Mout = Ms * Mrc-1 * Mr * Mrc * Mt
D3DXMATRIX* WINAPI D3DXMatrixAffineTransformation
    ( D3DXMATRIX *pOut, FLOAT Scaling, CONST D3DXVECTOR3 *pRotationCenter,
      CONST D3DXQUATERNION *pRotation, CONST D3DXVECTOR3 *pTranslation);

// Build a lookat matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixLookAtRH
    ( D3DXMATRIX *pOut, CONST D3DXVECTOR3 *pEye, CONST D3DXVECTOR3 *pAt,
      CONST D3DXVECTOR3 *pUp );

// Build a lookat matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixLookAtLH
    ( D3DXMATRIX *pOut, CONST D3DXVECTOR3 *pEye, CONST D3DXVECTOR3 *pAt,
      CONST D3DXVECTOR3 *pUp );

// Build a perspective projection matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveRH
    ( D3DXMATRIX *pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf );

// Build a perspective projection matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveLH
    ( D3DXMATRIX *pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf );

// Build a perspective projection matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveFovRH
    ( D3DXMATRIX *pOut, FLOAT fovy, FLOAT Aspect, FLOAT zn, FLOAT zf );

// Build a perspective projection matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveFovLH
    ( D3DXMATRIX *pOut, FLOAT fovy, FLOAT Aspect, FLOAT zn, FLOAT zf );

// Build a perspective projection matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveOffCenterRH
    ( D3DXMATRIX *pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
      FLOAT zf );

// Build a perspective projection matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveOffCenterLH
    ( D3DXMATRIX *pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
      FLOAT zf );

// Build an ortho projection matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixOrthoRH
    ( D3DXMATRIX *pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf );

// Build an ortho projection matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixOrthoLH
    ( D3DXMATRIX *pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf );

// Build an ortho projection matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixOrthoOffCenterRH
    ( D3DXMATRIX *pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
      FLOAT zf );

// Build an ortho projection matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixOrthoOffCenterLH
    ( D3DXMATRIX *pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
      FLOAT zf );

// Build a matrix which flattens geometry into a plane, as if casting
// a shadow from a light.
D3DXMATRIX* WINAPI D3DXMatrixShadow
    ( D3DXMATRIX *pOut, CONST D3DXVECTOR4 *pLight,
      CONST D3DXPLANE *pPlane );

// Build a matrix which reflects the coordinate system about a plane
D3DXMATRIX* WINAPI D3DXMatrixReflect
    ( D3DXMATRIX *pOut, CONST D3DXPLANE *pPlane );

#ifdef __cplusplus
}
#endif


//--------------------------
// Quaternion
//--------------------------

// inline

FLOAT D3DXQuaternionLength
    ( CONST D3DXQUATERNION *pQ );

// Length squared, or "norm"
FLOAT D3DXQuaternionLengthSq
    ( CONST D3DXQUATERNION *pQ );

FLOAT D3DXQuaternionDot
    ( CONST D3DXQUATERNION *pQ1, CONST D3DXQUATERNION *pQ2 );

// (0, 0, 0, 1)
D3DXQUATERNION* D3DXQuaternionIdentity
    ( D3DXQUATERNION *pOut );

BOOL D3DXQuaternionIsIdentity
    ( CONST D3DXQUATERNION *pQ );

// (-x, -y, -z, w)
D3DXQUATERNION* D3DXQuaternionConjugate
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );


// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Compute a quaternin's axis and angle of rotation. Expects unit quaternions.
void WINAPI D3DXQuaternionToAxisAngle
    ( CONST D3DXQUATERNION *pQ, D3DXVECTOR3 *pAxis, FLOAT *pAngle );

// Build a quaternion from a rotation matrix.
D3DXQUATERNION* WINAPI D3DXQuaternionRotationMatrix
    ( D3DXQUATERNION *pOut, CONST D3DXMATRIX *pM);

// Rotation about arbitrary axis.
D3DXQUATERNION* WINAPI D3DXQuaternionRotationAxis
    ( D3DXQUATERNION *pOut, CONST D3DXVECTOR3 *pV, FLOAT Angle );

// Yaw around the Y axis, a pitch around the X axis,
// and a roll around the Z axis.
D3DXQUATERNION* WINAPI D3DXQuaternionRotationYawPitchRoll
    ( D3DXQUATERNION *pOut, FLOAT Yaw, FLOAT Pitch, FLOAT Roll );

// Quaternion multiplication.  The result represents the rotation Q2
// followed by the rotation Q1.  (Out = Q2 * Q1)
D3DXQUATERNION* WINAPI D3DXQuaternionMultiply
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ1,
      CONST D3DXQUATERNION *pQ2 );

D3DXQUATERNION* WINAPI D3DXQuaternionNormalize
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );

// Conjugate and re-norm
D3DXQUATERNION* WINAPI D3DXQuaternionInverse
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );

// Expects unit quaternions.
// if q = (cos(theta), sin(theta) * v); ln(q) = (0, theta * v)
D3DXQUATERNION* WINAPI D3DXQuaternionLn
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );

// Expects pure quaternions. (w == 0)  w is ignored in calculation.
// if q = (0, theta * v); exp(q) = (cos(theta), sin(theta) * v)
D3DXQUATERNION* WINAPI D3DXQuaternionExp
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );

// Spherical linear interpolation between Q1 (s == 0) and Q2 (s == 1).
// Expects unit quaternions.
D3DXQUATERNION* WINAPI D3DXQuaternionSlerp
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ1,
      CONST D3DXQUATERNION *pQ2, FLOAT t );

// Spherical quadrangle interpolation.
// Slerp(Slerp(Q1, Q4, t), Slerp(Q2, Q3, t), 2t(1-t))
D3DXQUATERNION* WINAPI D3DXQuaternionSquad
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ1,
      CONST D3DXQUATERNION *pQ2, CONST D3DXQUATERNION *pQ3,
      CONST D3DXQUATERNION *pQ4, FLOAT t );

// Slerp(Slerp(Q1, Q2, f+g), Slerp(Q1, Q3, f+g), g/(f+g))
D3DXQUATERNION* WINAPI D3DXQuaternionBaryCentric
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ1,
      CONST D3DXQUATERNION *pQ2, CONST D3DXQUATERNION *pQ3,
      FLOAT f, FLOAT g );

#ifdef __cplusplus
}
#endif


//--------------------------
// Plane
//--------------------------

// inline

// ax + by + cz + dw
FLOAT D3DXPlaneDot
    ( CONST D3DXPLANE *pP, CONST D3DXVECTOR4 *pV);

// ax + by + cz + d
FLOAT D3DXPlaneDotCoord
    ( CONST D3DXPLANE *pP, CONST D3DXVECTOR3 *pV);

// ax + by + cz
FLOAT D3DXPlaneDotNormal
    ( CONST D3DXPLANE *pP, CONST D3DXVECTOR3 *pV);

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Normalize plane (so that |a,b,c| == 1)
D3DXPLANE* WINAPI D3DXPlaneNormalize
    ( D3DXPLANE *pOut, CONST D3DXPLANE *pP);

// Find the intersection between a plane and a line.  If the line is
// parallel to the plane, NULL is returned.
D3DXVECTOR3* WINAPI D3DXPlaneIntersectLine
    ( D3DXVECTOR3 *pOut, CONST D3DXPLANE *pP, CONST D3DXVECTOR3 *pV1,
      CONST D3DXVECTOR3 *pV2);

// Construct a plane from a point and a normal
D3DXPLANE* WINAPI D3DXPlaneFromPointNormal
    ( D3DXPLANE *pOut, CONST D3DXVECTOR3 *pPoint, CONST D3DXVECTOR3 *pNormal);

// Construct a plane from 3 points
D3DXPLANE* WINAPI D3DXPlaneFromPoints
    ( D3DXPLANE *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2,
      CONST D3DXVECTOR3 *pV3);

// Transform a plane by a matrix.  The vector (a,b,c) must be normal.
// M must be an affine transform.
D3DXPLANE* WINAPI D3DXPlaneTransform
    ( D3DXPLANE *pOut, CONST D3DXPLANE *pP, CONST D3DXMATRIX *pM );

#ifdef __cplusplus
}
#endif


//--------------------------
// Color
//--------------------------

// inline

// (1-r, 1-g, 1-b, a)
D3DXCOLOR* D3DXColorNegative
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC);

D3DXCOLOR* D3DXColorAdd
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2);

D3DXCOLOR* D3DXColorSubtract
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2);

D3DXCOLOR* D3DXColorScale
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC, FLOAT s);

// (r1*r2, g1*g2, b1*b2, a1*a2)
D3DXCOLOR* D3DXColorModulate
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2);

// Linear interpolation of r,g,b, and a. C1 + s(C2-C1)
D3DXCOLOR* D3DXColorLerp
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2, FLOAT s);

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Interpolate r,g,b between desaturated color and color.
// DesaturatedColor + s(Color - DesaturatedColor)
D3DXCOLOR* WINAPI D3DXColorAdjustSaturation
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC, FLOAT s);

// Interpolate r,g,b between 50% grey and color.  Grey + s(Color - Grey)
D3DXCOLOR* WINAPI D3DXColorAdjustContrast
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC, FLOAT c);

#ifdef __cplusplus
}
#endif






//===========================================================================
//
//    Matrix Stack
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   ID3DXMatrixStack

DECLARE_INTERFACE_(ID3DXMatrixStack, IUnknown)
{
    //
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //
    // ID3DXMatrixStack methods
    //

    // Pops the top of the stack, returns the current top
    // *after* popping the top.
    STDMETHOD(Pop)(THIS) PURE;

    // Pushes the stack by one, duplicating the current matrix.
    STDMETHOD(Push)(THIS) PURE;

    // Loads identity in the current matrix.
    STDMETHOD(LoadIdentity)(THIS) PURE;

    // Loads the given matrix into the current matrix
    STDMETHOD(LoadMatrix)(THIS_ CONST D3DXMATRIX* pM ) PURE;

    // Right-Multiplies the given matrix to the current matrix.
    // (transformation is about the current world origin)
    STDMETHOD(MultMatrix)(THIS_ CONST D3DXMATRIX* pM ) PURE;

    // Left-Multiplies the given matrix to the current matrix
    // (transformation is about the local origin of the object)
    STDMETHOD(MultMatrixLocal)(THIS_ CONST D3DXMATRIX* pM ) PURE;

    // Right multiply the current matrix with the computed rotation
    // matrix, counterclockwise about the given axis with the given angle.
    // (rotation is about the current world origin)
    STDMETHOD(RotateAxis)
        (THIS_ CONST D3DXVECTOR3* pV, FLOAT Angle) PURE;

    // Left multiply the current matrix with the computed rotation
    // matrix, counterclockwise about the given axis with the given angle.
    // (rotation is about the local origin of the object)
    STDMETHOD(RotateAxisLocal)
        (THIS_ CONST D3DXVECTOR3* pV, FLOAT Angle) PURE;

    // Right multiply the current matrix with the computed rotation
    // matrix. All angles are counterclockwise. (rotation is about the
    // current world origin)

    // The rotation is composed of a yaw around the Y axis, a pitch around
    // the X axis, and a roll around the Z axis.
    STDMETHOD(RotateYawPitchRoll)
        (THIS_ FLOAT Yaw, FLOAT Pitch, FLOAT Roll) PURE;

    // Left multiply the current matrix with the computed rotation
    // matrix. All angles are counterclockwise. (rotation is about the
    // local origin of the object)

    // The rotation is composed of a yaw around the Y axis, a pitch around
    // the X axis, and a roll around the Z axis.
    STDMETHOD(RotateYawPitchRollLocal)
        (THIS_ FLOAT Yaw, FLOAT Pitch, FLOAT Roll) PURE;

    // Right multiply the current matrix with the computed scale
    // matrix. (transformation is about the current world origin)
    STDMETHOD(Scale)(THIS_ FLOAT x, FLOAT y, FLOAT z) PURE;

    // Left multiply the current matrix with the computed scale
    // matrix. (transformation is about the local origin of the object)
    STDMETHOD(ScaleLocal)(THIS_ FLOAT x, FLOAT y, FLOAT z) PURE;

    // Right multiply the current matrix with the computed translation
    // matrix. (transformation is about the current world origin)
    STDMETHOD(Translate)(THIS_ FLOAT x, FLOAT y, FLOAT z ) PURE;

    // Left multiply the current matrix with the computed translation
    // matrix. (transformation is about the local origin of the object)
    STDMETHOD(TranslateLocal)(THIS_ FLOAT x, FLOAT y, FLOAT z) PURE;

    // Obtain the current matrix at the top of the stack
    STDMETHOD_(D3DXMATRIX*, GetTop)(THIS) PURE;
};

#ifdef __cplusplus
extern "C" {
#endif

HRESULT WINAPI D3DXCreateMatrixStack( DWORD Flags, LPD3DXMATRIXSTACK *ppStack );

#ifdef __cplusplus
}
#endif

#include "d3dx8math.inl"

#pragma warning(default:4201)

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __D3DX8MATH_H__

#endif // __XGMATH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dxg\d3dxsprite.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dxsprite.h
//  Content:    D3DX sprite helper functions
//
//      These functions allow you to use sprites with D3DX. A "sprite" is
//      loosely defined as a 2D image that you want to transfer to the 
//      rendering target. The source image can be a texture created
//      with the help of the D3DX texture loader; though advanced users may
//      want to create their own. A helper function (PrepareDeviceForSprite)
//      is provided to make it easy to set up render states on a device. 
//      (Again, advanced users can use their own created devices.) 
//
//      There are two general techniques for sprites; the simpler one just
//      specifies a destination rectangle and a rotation anlge. A more 
//      powerful technique supports rendering to non-rectangular quads.
//
//      Both techniques support clipping, alpha, and rotation. More
//      details are below.
//
///////////////////////////////////////////////////////////////////////////

#ifndef __D3DXSPRITE_H__
#define __D3DXSPRITE_H__

#include <d3d.h>
#include <limits.h>
#include "d3dxerr.h"

#ifdef __cplusplus
extern "C" {
#endif


//-------------------------------------------------------------------------
// D3DXPrepareDeviceForSprite:
//
// Call this function to set up all the render states necessary for
// BltSprite/WarpSprite to work correctly. (Advanced users may opt to
// not call this function first; in which case Blt/WarpSprite functions
// will use whatever render/texture states were set up on the device when
// they are called.)
//
// Warning: This function modifies render states and may impact performance
// negatively on some 3D hardware if it is called too often per frame.
//
// Warning: If the render state changes (other than through calls to 
// BltSprite or WarpSprite), you will need to call this function again before 
// calling BltSprite or WarpSprite.
//
// Details: This function modifies the the rendering first texture stage and 
// it modifies some renderstates for the entire device. Here is the exact 
// list:
// 
//   SetTextureStageState(0, D3DTSS_COLORARG1,         D3DTA_TEXTURE);
//   SetTextureStageState(0, D3DTSS_COLOROP,           D3DTOP_SELECTARG1);
//   SetTextureStageState(0, D3DTSS_ALPHAARG1,         D3DTA_TEXTURE);
//   SetTextureStageState(0, D3DTSS_ALPHAARG2,         D3DTA_DIFFUSE);
//   SetTextureStageState(0, D3DTSS_ALPHAOP,           D3DTOP_MODULATE);
//   SetTextureStageState(0, D3DTSS_MINFILTER,         D3DTFN_LINEAR);
//   SetTextureStageState(0, D3DTSS_MAGFILTER,         D3DTFG_LINEAR);
// 
//   SetRenderState(D3DRENDERSTATE_SRCBLEND,           D3DBLEND_SRCALPHA);
//   SetRenderState(D3DRENDERSTATE_DESTBLEND,          D3DBLEND_INVSRCALPHA);
//   SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE,   TRUE);
//
//   Depending on the value of ZEnable parameter, this function will
//   will either call
//   SetRenderState(D3DRENDERSTATE_ZENABLE,            FALSE);
//   - or -
//   SetRenderState(D3DRENDERSTATE_ZENABLE,            TRUE);
//
// Parameters: 
//      pd3dDevice  - a pointer to the d3d device that you wish to prepare
//                    for use with D3DX Sprite Services
//      ZEnable     - a flag indicating whether you want the sprites to
//                    check and update the Z buffer as part of rendering.
//                    If ZEnable is FALSE, OR you are using
//                    alpha-blending, then it is necessary to render your
//                    sprites from back-to-front. 
//
//-------------------------------------------------------------------------

#ifdef __cplusplus
HRESULT WINAPI
    D3DXPrepareDeviceForSprite( LPDIRECT3DDEVICE7 pd3dDevice, 
                                BOOL ZEnable = FALSE);
#else
HRESULT WINAPI
    D3DXPrepareDeviceForSprite( LPDIRECT3DDEVICE7 pd3dDevice, 
                                BOOL ZEnable);
#endif



//-------------------------------------------------------------------------
// The D3DXDrawBasicSprite() function performs blitting of source images onto 
// a 3D rendering device. This function only calls SetTexture on the first 
// renderstage with the parameter (pd3dTexture) if that parameter is non-null. 
// This function assumes that D3DXPrepareDeviceForSprite has been called on 
// the device or that caller has in some other way correctly prepared the 
// renderstates.
//
// This function supports scaling, rotations, alpha-blending, and choosing 
// a source sub-rect.
// 
// Rotation angle is specified in radians. Both rotations and scales
// are applied around the center of the sprite; where the center of the
// sprite is half the width/height of the sprite, plus the offset parameter. 
//
// Use the offset parameter if you want the sprite's center to be something 
// other than the image center.
//
// The destination point indicates where you would like the center of
// the sprite to draw to.
//
// Parameters: 
//      pd3dTexture - a pointer to the surface containing the texture
//      pd3dDevice  - a pointer to the d3d device to render to. It is
//                    assumed that render states are set up. (See
//                    D3DXPrepareDeviceForSprite)
//      ppointDest  - a pointer to the target point for the sprite. The
//                    components of the vector must be in screen
//                    space.
//      alpha       - alpha value to apply to sprite. 1.0 means totally
//                    opaque; and 0.0 means totally transparent. 
//                    WARNING: If you are using alpha, then you should render
//                    from back to front in order to avoid rendering
//                    artifacts.
//      angleRad    - angle of rotation around the 'center' of the rect
//      scale       - a uniform scale that is applied to the source rect
//                    to specify the size of the image that is rendered
//      pOffset     - offset from the center of the source rect to use as the 
//                    center of rotation
//      pSourceRect - a rect that indicates what portion of the source
//                    source texture to use. If NULL is passed, then the
//                    entire source is used. If the source texture was 
//                    created via D3DX, then the rect should be specified
//                    in the coordinates of the original image (so that you
//                    don't have to worry about stretching/scaling that D3DX
//                    may have done to make the image work with your current
//                    3D Device.) Note that horizontal or vertical mirroring 
//                    may be simply accomplished by swapping the left/right 
//                    or top/bottom fields of this RECT.
//-------------------------------------------------------------------------

#ifdef __cplusplus
HRESULT WINAPI 
    D3DXDrawSpriteSimple(LPDIRECTDRAWSURFACE7  pd3dTexture, 
                         LPDIRECT3DDEVICE7     pd3dDevice, 
                         const D3DXVECTOR3     *ppointDest, 
                         float                 alpha        = 1.0f,
                         float                 scale        = 1.0f,
                         float                 angleRad     = 0.0f,
                         const D3DXVECTOR2     *pOffset     = NULL,
                         const RECT            *pSourceRect = NULL);
#else
HRESULT WINAPI 
    D3DXDrawSpriteSimple(LPDIRECTDRAWSURFACE7  pd3dTexture, 
                         LPDIRECT3DDEVICE7     pd3dDevice, 
                         D3DXVECTOR3           *ppointDest, 
                         float                 alpha,
                         float                 scale,
                         float                 angleRad,
                         D3DXVECTOR2           *pOffset,
                         RECT                  *pSourceRect);
#endif

//-------------------------------------------------------------------------
// The D3DXDrawSprite() function transforms source images onto a 3D 
// rendering device. It takes a general 4x4 matrix which is use to transform
// the points of a default rect: (left=-.5, top=-.5, right=+.5, bottom=+.5).
// (This default rect was chosen so that it was centered around the origin
// to ease setting up rotations. And it was chosen to have a width/height of one
// to ease setting up scales.)
// 
// This function only calls SetTexture on the first 
// renderstage with the parameter (pd3dTexture) if that parameter is non-null. 
// This function assumes that D3DXPrepareDeviceForSprite has been called on 
// the device or that caller has in some other way correctly prepared the 
// renderstates.
//
// This function supports alpha-blending, and choosing 
// a source sub-rect. (A value of NULL for source sub-rect means the entire
// texture is used.)
//
// Note that if the transformed points have a value for w (the homogenous
// coordinate) that is not 1, then this function will invert it and pass
// that value to D3D as the rhw field of a TLVERTEX. If the value for w is
// zero, then it use 1 as the rhw.
//
// Parameters: 
//      pd3dTexture - a pointer to the surface containing the texture
//      pd3dDevice  - a pointer to the d3d device to render to. It is
//                    assumed that render states are set up. (See
//                    D3DXPrepareDeviceForSprite)
//      pMatrixTransform - 4x4 matrix that specifies the transformation
//                    that will be applied to the default -.5 to +.5 
//                    rectangle.
//      alpha       - alpha value to apply to sprite. 1.0 means totally
//                    opaque; and 0.0 means totally transparent. 
//                    WARNING: If you are using alpha, then you should render
//                    from back to front in order to avoid rendering
//                    artifacts.Furthermore, you should avoid scenarios where 
//                    semi-transparent objects intersect.
//      pSourceRect - a rect that indicates what portion of the source
//                    source texture to use. If NULL is passed, then the
//                    entire source is used. If the source texture was 
//                    created via D3DX, then the rect should be specified
//                    in the coordinates of the original image (so that you
//                    don't have to worry about stretching/scaling that D3DX
//                    may have done to make the image work with your current
//                    3D Device.) Note that mirroring may be simply accomplished
//                    by swapping the left/right or top/bottom fields of
//                    this RECT.
// 
//-------------------------------------------------------------------------

#ifdef __cplusplus
HRESULT WINAPI 
    D3DXDrawSpriteTransform(LPDIRECTDRAWSURFACE7  pd3dTexture, 
                            LPDIRECT3DDEVICE7     pd3dDevice, 
                            const D3DXMATRIX      *pMatrixTransform, 
                            float                 alpha         = 1.0f,
                            const RECT            *pSourceRect  = NULL);
#else
HRESULT WINAPI 
    D3DXDrawSpriteTransform(LPDIRECTDRAWSURFACE7  pd3dTexture, 
                            LPDIRECT3DDEVICE7     pd3dDevice, 
                            D3DXMATRIX            *pMatrixTransform, 
                            float                 alpha,
                            RECT                  *pSourceRect);
#endif

//-------------------------------------------------------------------------
// The D3DXBuildSpriteTransform() function is a helper provided which
// creates a matrix corresponding to simple properties. This matrix is
// set up to pass directly to D3DXTransformSprite.
//
// Parameters: 
//      pMatrix     - a pointer to the result matrix
//      prectDest   - a pointer to the target rectangle for the sprite
//      angleRad    - angle of rotation around the 'center' of the rect
//      pOffset     - offset from the center of the source rect to use as the 
//                    center of rotation
// 
//-------------------------------------------------------------------------

#ifdef __cplusplus
void WINAPI
    D3DXBuildSpriteTransform(D3DXMATRIX            *pMatrix,
                             const RECT            *prectDest,
                             float                 angleRad     = 0.0f,
                             const D3DXVECTOR2     *pOffset     = NULL);
#else
void WINAPI
    D3DXBuildSpriteTransform(D3DXMATRIX            *pMatrix,
                             RECT                  *prectDest,
                             float                 angleRad,
                             D3DXVECTOR2           *pOffset);
#endif


//-------------------------------------------------------------------------
// The D3DXDrawSprite3D() function renders a texture onto a 3D quad. The
// quad ABCD is broken into two triangles ABC and ACD which are rendered
// via DrawPrim.
//
// Parameters: 
//      pd3dTexture - a pointer to the surface containing the texture
//      pd3dDevice  - a pointer to the d3d device to render to. It is
//                    assumed that render states are set up. (See
//                    D3DXPrepareDeviceForSprite)
//      quad        - array of 4 points in the following order:
//                    upper-left, upper-right, lower-right, lower-left.
//                    If these vectors contain a W, then this function
//                    will take the reciprocal of that value to pass as
//                    as the rhw (i.e. reciprocal homogenous w).
//      alpha       - alpha value to apply to sprite. 1.0 means totally
//                    opaque; and 0.0 means totally transparent. 
//                    WARNING: If you are using alpha, then you should render
//                    from back to front in order to avoid rendering
//                    artifacts.Furthermore, you should avoid scenarios where 
//                    semi-transparent objects intersect.
//      pSourceRect - a rect that indicates what portion of the source
//                    source texture to use. If NULL is passed, then the
//                    entire source is used. If the source texture was 
//                    created via D3DX, then the rect should be specified
//                    in the coordinates of the original image (so that you
//                    don't have to worry about stretching/scaling that D3DX
//                    may have done to make the image work with your current
//                    3D Device.) Note that mirroring may be simply accomplished
//                    by swapping the left/right or top/bottom fields of
//                    this RECT.
//-------------------------------------------------------------------------

#ifdef __cplusplus
HRESULT WINAPI 
    D3DXDrawSprite3D(LPDIRECTDRAWSURFACE7  pd3dTexture, 
                     LPDIRECT3DDEVICE7     pd3dDevice, 
                     const D3DXVECTOR4     quad[4], 
                     float                 alpha         = 1.0f,
                     const RECT            *pSourceRect  = NULL);
#else
HRESULT WINAPI 
    D3DXDrawSprite3D(LPDIRECTDRAWSURFACE7  pd3dTexture, 
                     LPDIRECT3DDEVICE7     pd3dDevice, 
                     D3DXVECTOR4           quad[4], 
                     float                 alpha,
                     RECT                  *pSourceRect);
#endif



#ifdef __cplusplus
} // extern "C"
#endif

#endif // __D3DXSPRITE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dxg\xgmath.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       xgmath.h
 *
 ****************************************************************************/
 
#ifndef __XGMATH_H__
#define __XGMATH_H__

#ifndef XGINLINE
#ifdef __cplusplus
#define XGINLINE inline
#else
#define XGINLINE _inline
#endif
#endif

#ifdef __cplusplus
extern "C++" {
#endif // __cplusplus

#include <math.h>

#pragma warning(disable:4201) // anonymous unions warning

//===========================================================================
//
// General purpose utilities
//
//===========================================================================
#define XG_PI    ((FLOAT)  3.141592654f)
#define XG_1BYPI ((FLOAT)  0.318309886f)

#define XGToRadian( degree ) ((degree) * (XG_PI / 180.0f))
#define XGToDegree( radian ) ((radian) * (180.0f / XG_PI))

//===========================================================================
//
// Vectors
//
//===========================================================================

//--------------------------
// 2D Vector
//--------------------------
typedef struct XGVECTOR2
{
#ifdef __cplusplus
public:
    XGVECTOR2() {};
    XGVECTOR2( CONST FLOAT * );
    XGVECTOR2( FLOAT x, FLOAT y );

    // casting
    operator FLOAT* ();
    operator CONST FLOAT* () const;

    // assignment operators
    XGVECTOR2& operator += ( CONST XGVECTOR2& );
    XGVECTOR2& operator -= ( CONST XGVECTOR2& );
    XGVECTOR2& operator *= ( FLOAT );
    XGVECTOR2& operator /= ( FLOAT );

    // unary operators
    XGVECTOR2 operator + () const;
    XGVECTOR2 operator - () const;

    // binary operators
    XGVECTOR2 operator + ( CONST XGVECTOR2& ) const;
    XGVECTOR2 operator - ( CONST XGVECTOR2& ) const;
    XGVECTOR2 operator * ( FLOAT ) const;
    XGVECTOR2 operator / ( FLOAT ) const;

    friend XGVECTOR2 operator * ( FLOAT, CONST XGVECTOR2& );

    BOOL operator == ( CONST XGVECTOR2& ) const;
    BOOL operator != ( CONST XGVECTOR2& ) const;


public:
#endif //__cplusplus
    FLOAT x, y;
} XGVECTOR2, *LPXGVECTOR2;


//--------------------------
// 3D Vector
//--------------------------
#ifdef __cplusplus
typedef struct XGVECTOR3 : public D3DVECTOR
{
public:
    XGVECTOR3() {};
    XGVECTOR3( CONST FLOAT * );
    XGVECTOR3( CONST D3DVECTOR& );
    XGVECTOR3( FLOAT x, FLOAT y, FLOAT z );

    // casting
    operator FLOAT* ();
    operator CONST FLOAT* () const;

    // assignment operators
    XGVECTOR3& operator += ( CONST XGVECTOR3& );
    XGVECTOR3& operator -= ( CONST XGVECTOR3& );
    XGVECTOR3& operator *= ( FLOAT );
    XGVECTOR3& operator /= ( FLOAT );

    // unary operators
    XGVECTOR3 operator + () const;
    XGVECTOR3 operator - () const;

    // binary operators
    XGVECTOR3 operator + ( CONST XGVECTOR3& ) const;
    XGVECTOR3 operator - ( CONST XGVECTOR3& ) const;
    XGVECTOR3 operator * ( FLOAT ) const;
    XGVECTOR3 operator / ( FLOAT ) const;

    friend XGVECTOR3 operator * ( FLOAT, CONST struct XGVECTOR3& );

    BOOL operator == ( CONST XGVECTOR3& ) const;
    BOOL operator != ( CONST XGVECTOR3& ) const;

} XGVECTOR3, *LPXGVECTOR3;

#else //!__cplusplus
typedef struct _D3DVECTOR XGVECTOR3, *LPXGVECTOR3;
#endif //!__cplusplus


//--------------------------
// 4D Vector
//--------------------------
typedef struct XGVECTOR4
{
#ifdef __cplusplus
public:
    XGVECTOR4() {};
    XGVECTOR4( CONST FLOAT* );
    XGVECTOR4( FLOAT x, FLOAT y, FLOAT z, FLOAT w );

    // casting
    operator FLOAT* ();
    operator CONST FLOAT* () const;

    // assignment operators
    XGVECTOR4& operator += ( CONST XGVECTOR4& );
    XGVECTOR4& operator -= ( CONST XGVECTOR4& );
    XGVECTOR4& operator *= ( FLOAT );
    XGVECTOR4& operator /= ( FLOAT );

    // unary operators
    XGVECTOR4 operator + () const;
    XGVECTOR4 operator - () const;

    // binary operators
    XGVECTOR4 operator + ( CONST XGVECTOR4& ) const;
    XGVECTOR4 operator - ( CONST XGVECTOR4& ) const;
    XGVECTOR4 operator * ( FLOAT ) const;
    XGVECTOR4 operator / ( FLOAT ) const;

    friend XGVECTOR4 operator * ( FLOAT, CONST XGVECTOR4& );

    BOOL operator == ( CONST XGVECTOR4& ) const;
    BOOL operator != ( CONST XGVECTOR4& ) const;

public:
#endif //__cplusplus
    FLOAT x, y, z, w;
} XGVECTOR4, *LPXGVECTOR4;


//===========================================================================
//
// Matrices
//
//===========================================================================
#ifdef __cplusplus
typedef __declspec(align(16)) struct XGMATRIX : public D3DMATRIX
{
public:

    XGMATRIX() {};
    XGMATRIX( CONST FLOAT * );
    XGMATRIX( CONST D3DMATRIX& );
    XGMATRIX( FLOAT _11, FLOAT _12, FLOAT _13, FLOAT _14,
                FLOAT _21, FLOAT _22, FLOAT _23, FLOAT _24,
                FLOAT _31, FLOAT _32, FLOAT _33, FLOAT _34,
                FLOAT _41, FLOAT _42, FLOAT _43, FLOAT _44 );

    // access grants
    FLOAT& operator () ( UINT Row, UINT Col );
    FLOAT  operator () ( UINT Row, UINT Col ) const;

    // casting operators
    operator FLOAT* ();
    operator CONST FLOAT* () const;

    // assignment operators
    XGMATRIX& operator *= ( CONST XGMATRIX& );
    XGMATRIX& operator += ( CONST XGMATRIX& );
    XGMATRIX& operator -= ( CONST XGMATRIX& );
    XGMATRIX& operator *= ( FLOAT );
    XGMATRIX& operator /= ( FLOAT );

    // unary operators
    XGMATRIX operator + () const;
    XGMATRIX operator - () const;

    // binary operators
    XGMATRIX operator * ( CONST XGMATRIX& ) const;
    XGMATRIX operator + ( CONST XGMATRIX& ) const;
    XGMATRIX operator - ( CONST XGMATRIX& ) const;
    XGMATRIX operator * ( FLOAT ) const;
    XGMATRIX operator / ( FLOAT ) const;

    friend XGMATRIX operator * ( FLOAT, CONST XGMATRIX& );

    BOOL operator == ( CONST XGMATRIX& ) const;
    BOOL operator != ( CONST XGMATRIX& ) const;

} XGMATRIX;

#else //!__cplusplus
typedef __declspec(align(16)) struct _D3DMATRIX XGMATRIX;
#endif //!__cplusplus

typedef struct XGMATRIX *LPXGMATRIX;

//===========================================================================
//
//    Quaternions
//
//===========================================================================
typedef struct XGQUATERNION
{
#ifdef __cplusplus
public:
    XGQUATERNION() {}
    XGQUATERNION( CONST FLOAT * );
    XGQUATERNION( FLOAT x, FLOAT y, FLOAT z, FLOAT w );

    // casting
    operator FLOAT* ();
    operator CONST FLOAT* () const;

    // assignment operators
    XGQUATERNION& operator += ( CONST XGQUATERNION& );
    XGQUATERNION& operator -= ( CONST XGQUATERNION& );
    XGQUATERNION& operator *= ( CONST XGQUATERNION& );
    XGQUATERNION& operator *= ( FLOAT );
    XGQUATERNION& operator /= ( FLOAT );

    // unary operators
    XGQUATERNION  operator + () const;
    XGQUATERNION  operator - () const;

    // binary operators
    XGQUATERNION operator + ( CONST XGQUATERNION& ) const;
    XGQUATERNION operator - ( CONST XGQUATERNION& ) const;
    XGQUATERNION operator * ( CONST XGQUATERNION& ) const;
    XGQUATERNION operator * ( FLOAT ) const;
    XGQUATERNION operator / ( FLOAT ) const;

    friend XGQUATERNION operator * (FLOAT, CONST XGQUATERNION& );

    BOOL operator == ( CONST XGQUATERNION& ) const;
    BOOL operator != ( CONST XGQUATERNION& ) const;

#endif //__cplusplus
    FLOAT x, y, z, w;
} XGQUATERNION, *LPXGQUATERNION;


//===========================================================================
//
// Planes
//
//===========================================================================
typedef struct XGPLANE
{
#ifdef __cplusplus
public:
    XGPLANE() {}
    XGPLANE( CONST FLOAT* );
    XGPLANE( FLOAT a, FLOAT b, FLOAT c, FLOAT d );

    // casting
    operator FLOAT* ();
    operator CONST FLOAT* () const;

    // unary operators
    XGPLANE operator + () const;
    XGPLANE operator - () const;

    // binary operators
    BOOL operator == ( CONST XGPLANE& ) const;
    BOOL operator != ( CONST XGPLANE& ) const;

#endif //__cplusplus
    FLOAT a, b, c, d;
} XGPLANE, *LPXGPLANE;


//===========================================================================
//
// Colors
//
//===========================================================================

typedef struct XGCOLOR
{
#ifdef __cplusplus
public:
    XGCOLOR() {}
    XGCOLOR( DWORD argb );
    XGCOLOR( CONST FLOAT * );
    XGCOLOR( CONST D3DCOLORVALUE& );
    XGCOLOR( FLOAT r, FLOAT g, FLOAT b, FLOAT a );

    // casting
    operator DWORD () const;

    operator FLOAT* ();
    operator CONST FLOAT* () const;

    operator D3DCOLORVALUE* ();
    operator CONST D3DCOLORVALUE* () const;

    operator D3DCOLORVALUE& ();
    operator CONST D3DCOLORVALUE& () const;

    // assignment operators
    XGCOLOR& operator += ( CONST XGCOLOR& );
    XGCOLOR& operator -= ( CONST XGCOLOR& );
    XGCOLOR& operator *= ( FLOAT );
    XGCOLOR& operator /= ( FLOAT );

    // unary operators
    XGCOLOR operator + () const;
    XGCOLOR operator - () const;

    // binary operators
    XGCOLOR operator + ( CONST XGCOLOR& ) const;
    XGCOLOR operator - ( CONST XGCOLOR& ) const;
    XGCOLOR operator * ( FLOAT ) const;
    XGCOLOR operator / ( FLOAT ) const;

    friend XGCOLOR operator * (FLOAT, CONST XGCOLOR& );

    BOOL operator == ( CONST XGCOLOR& ) const;
    BOOL operator != ( CONST XGCOLOR& ) const;

#endif //__cplusplus
    FLOAT r, g, b, a;
} XGCOLOR, *LPXGCOLOR;


//===========================================================================
//
// XGraphics math functions:
//
// NOTE:
//  * All these functions can take the same object as in and out parameters.
//
//  * Out parameters are typically also returned as return values, so that
//    the output of one function may be used as a parameter to another.
//
//===========================================================================

//--------------------------
// 2D Vector
//--------------------------

// inline

FLOAT XGVec2Length
    ( CONST XGVECTOR2 *pV );

FLOAT XGVec2LengthSq
    ( CONST XGVECTOR2 *pV );

FLOAT XGVec2Dot
    ( CONST XGVECTOR2 *pV1, CONST XGVECTOR2 *pV2 );

// Z component of ((x1,y1,0) cross (x2,y2,0))
FLOAT XGVec2CCW
    ( CONST XGVECTOR2 *pV1, CONST XGVECTOR2 *pV2 );

XGVECTOR2* XGVec2Add
    ( XGVECTOR2 *pOut, CONST XGVECTOR2 *pV1, CONST XGVECTOR2 *pV2 );

XGVECTOR2* XGVec2Subtract
    ( XGVECTOR2 *pOut, CONST XGVECTOR2 *pV1, CONST XGVECTOR2 *pV2 );

// Minimize each component.  x = min(x1, x2), y = min(y1, y2)
XGVECTOR2* XGVec2Minimize
    ( XGVECTOR2 *pOut, CONST XGVECTOR2 *pV1, CONST XGVECTOR2 *pV2 );

// Maximize each component.  x = max(x1, x2), y = max(y1, y2)
XGVECTOR2* XGVec2Maximize
    ( XGVECTOR2 *pOut, CONST XGVECTOR2 *pV1, CONST XGVECTOR2 *pV2 );

XGVECTOR2* XGVec2Scale
    ( XGVECTOR2 *pOut, CONST XGVECTOR2 *pV, FLOAT s );

// Linear interpolation. V1 + s(V2-V1)
XGVECTOR2* XGVec2Lerp
    ( XGVECTOR2 *pOut, CONST XGVECTOR2 *pV1, CONST XGVECTOR2 *pV2,
      FLOAT s );

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

XGVECTOR2* WINAPI XGVec2Normalize
    ( XGVECTOR2 *pOut, CONST XGVECTOR2 *pV );

// Hermite interpolation between position V1, tangent T1 (when s == 0)
// and position V2, tangent T2 (when s == 1).
XGVECTOR2* WINAPI XGVec2Hermite
    ( XGVECTOR2 *pOut, CONST XGVECTOR2 *pV1, CONST XGVECTOR2 *pT1,
      CONST XGVECTOR2 *pV2, CONST XGVECTOR2 *pT2, FLOAT s );

// CatmullRom interpolation between V1 (when s == 0) and V2 (when s == 1)
XGVECTOR2* WINAPI XGVec2CatmullRom
    ( XGVECTOR2 *pOut, CONST XGVECTOR2 *pV0, CONST XGVECTOR2 *pV1,
      CONST XGVECTOR2 *pV2, CONST XGVECTOR2 *pV3, FLOAT s );

// Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)
XGVECTOR2* WINAPI XGVec2BaryCentric
    ( XGVECTOR2 *pOut, CONST XGVECTOR2 *pV1, CONST XGVECTOR2 *pV2,
      XGVECTOR2 *pV3, FLOAT f, FLOAT g);

// Transform (x, y, 0, 1) by matrix.
XGVECTOR4* WINAPI XGVec2Transform
    ( XGVECTOR4 *pOut, CONST XGVECTOR2 *pV, CONST XGMATRIX *pM );

// Transform (x, y, 0, 1) by matrix, project result back into w=1.
XGVECTOR2* WINAPI XGVec2TransformCoord
    ( XGVECTOR2 *pOut, CONST XGVECTOR2 *pV, CONST XGMATRIX *pM );

// Transform (x, y, 0, 0) by matrix.
XGVECTOR2* WINAPI XGVec2TransformNormal
    ( XGVECTOR2 *pOut, CONST XGVECTOR2 *pV, CONST XGMATRIX *pM );

#ifdef __cplusplus
}
#endif


//--------------------------
// 3D Vector
//--------------------------

// inline

FLOAT XGVec3Length
    ( CONST XGVECTOR3 *pV );

FLOAT XGVec3LengthSq
    ( CONST XGVECTOR3 *pV );

FLOAT XGVec3Dot
    ( CONST XGVECTOR3 *pV1, CONST XGVECTOR3 *pV2 );

XGVECTOR3* XGVec3Cross
    ( XGVECTOR3 *pOut, CONST XGVECTOR3 *pV1, CONST XGVECTOR3 *pV2 );

XGVECTOR3* XGVec3Add
    ( XGVECTOR3 *pOut, CONST XGVECTOR3 *pV1, CONST XGVECTOR3 *pV2 );

XGVECTOR3* XGVec3Subtract
    ( XGVECTOR3 *pOut, CONST XGVECTOR3 *pV1, CONST XGVECTOR3 *pV2 );

// Minimize each component.  x = min(x1, x2), y = min(y1, y2), ...
XGVECTOR3* XGVec3Minimize
    ( XGVECTOR3 *pOut, CONST XGVECTOR3 *pV1, CONST XGVECTOR3 *pV2 );

// Maximize each component.  x = max(x1, x2), y = max(y1, y2), ...
XGVECTOR3* XGVec3Maximize
    ( XGVECTOR3 *pOut, CONST XGVECTOR3 *pV1, CONST XGVECTOR3 *pV2 );

XGVECTOR3* XGVec3Scale
    ( XGVECTOR3 *pOut, CONST XGVECTOR3 *pV, FLOAT s);

// Linear interpolation. V1 + s(V2-V1)
XGVECTOR3* XGVec3Lerp
    ( XGVECTOR3 *pOut, CONST XGVECTOR3 *pV1, CONST XGVECTOR3 *pV2,
      FLOAT s );

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

XGVECTOR3* WINAPI XGVec3Normalize
    ( XGVECTOR3 *pOut, CONST XGVECTOR3 *pV );

// Hermite interpolation between position V1, tangent T1 (when s == 0)
// and position V2, tangent T2 (when s == 1).
XGVECTOR3* WINAPI XGVec3Hermite
    ( XGVECTOR3 *pOut, CONST XGVECTOR3 *pV1, CONST XGVECTOR3 *pT1,
      CONST XGVECTOR3 *pV2, CONST XGVECTOR3 *pT2, FLOAT s );

// CatmullRom interpolation between V1 (when s == 0) and V2 (when s == 1)
XGVECTOR3* WINAPI XGVec3CatmullRom
    ( XGVECTOR3 *pOut, CONST XGVECTOR3 *pV0, CONST XGVECTOR3 *pV1,
      CONST XGVECTOR3 *pV2, CONST XGVECTOR3 *pV3, FLOAT s );

// Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)
XGVECTOR3* WINAPI XGVec3BaryCentric
    ( XGVECTOR3 *pOut, CONST XGVECTOR3 *pV1, CONST XGVECTOR3 *pV2,
      CONST XGVECTOR3 *pV3, FLOAT f, FLOAT g);

// Transform (x, y, z, 1) by matrix.
XGVECTOR4* WINAPI XGVec3Transform
    ( XGVECTOR4 *pOut, CONST XGVECTOR3 *pV, CONST XGMATRIX *pM );

// Transform (x, y, z, 1) by matrix, project result back into w=1.
XGVECTOR3* WINAPI XGVec3TransformCoord
    ( XGVECTOR3 *pOut, CONST XGVECTOR3 *pV, CONST XGMATRIX *pM );

// Transform (x, y, z, 0) by matrix.  If you transforming a normal by a
// non-affine matrix, the matrix you pass to this function should be the
// transpose of the inverse of the matrix you would use to transform a coord.
XGVECTOR3* WINAPI XGVec3TransformNormal
    ( XGVECTOR3 *pOut, CONST XGVECTOR3 *pV, CONST XGMATRIX *pM );

// Project vector from object space into screen space
XGVECTOR3* WINAPI XGVec3Project
    ( XGVECTOR3 *pOut, CONST XGVECTOR3 *pV, CONST D3DVIEWPORT8 *pViewport,
      CONST XGMATRIX *pProjection, CONST XGMATRIX *pView, CONST XGMATRIX *pWorld);

// Project vector from screen space into object space
XGVECTOR3* WINAPI XGVec3Unproject
    ( XGVECTOR3 *pOut, CONST XGVECTOR3 *pV, CONST D3DVIEWPORT8 *pViewport,
      CONST XGMATRIX *pProjection, CONST XGMATRIX *pView, CONST XGMATRIX *pWorld);

#ifdef __cplusplus
}
#endif



//--------------------------
// 4D Vector
//--------------------------

// inline

FLOAT XGVec4Length
    ( CONST XGVECTOR4 *pV );

FLOAT XGVec4LengthSq
    ( CONST XGVECTOR4 *pV );

FLOAT XGVec4Dot
    ( CONST XGVECTOR4 *pV1, CONST XGVECTOR4 *pV2 );

XGVECTOR4* XGVec4Add
    ( XGVECTOR4 *pOut, CONST XGVECTOR4 *pV1, CONST XGVECTOR4 *pV2);

XGVECTOR4* XGVec4Subtract
    ( XGVECTOR4 *pOut, CONST XGVECTOR4 *pV1, CONST XGVECTOR4 *pV2);

// Minimize each component.  x = min(x1, x2), y = min(y1, y2), ...
XGVECTOR4* XGVec4Minimize
    ( XGVECTOR4 *pOut, CONST XGVECTOR4 *pV1, CONST XGVECTOR4 *pV2);

// Maximize each component.  x = max(x1, x2), y = max(y1, y2), ...
XGVECTOR4* XGVec4Maximize
    ( XGVECTOR4 *pOut, CONST XGVECTOR4 *pV1, CONST XGVECTOR4 *pV2);

XGVECTOR4* XGVec4Scale
    ( XGVECTOR4 *pOut, CONST XGVECTOR4 *pV, FLOAT s);

// Linear interpolation. V1 + s(V2-V1)
XGVECTOR4* XGVec4Lerp
    ( XGVECTOR4 *pOut, CONST XGVECTOR4 *pV1, CONST XGVECTOR4 *pV2,
      FLOAT s );

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Cross-product in 4 dimensions.
XGVECTOR4* WINAPI XGVec4Cross
    ( XGVECTOR4 *pOut, CONST XGVECTOR4 *pV1, CONST XGVECTOR4 *pV2,
      CONST XGVECTOR4 *pV3);

XGVECTOR4* WINAPI XGVec4Normalize
    ( XGVECTOR4 *pOut, CONST XGVECTOR4 *pV );

// Hermite interpolation between position V1, tangent T1 (when s == 0)
// and position V2, tangent T2 (when s == 1).
XGVECTOR4* WINAPI XGVec4Hermite
    ( XGVECTOR4 *pOut, CONST XGVECTOR4 *pV1, CONST XGVECTOR4 *pT1,
      CONST XGVECTOR4 *pV2, CONST XGVECTOR4 *pT2, FLOAT s );

// CatmullRom interpolation between V1 (when s == 0) and V2 (when s == 1)
XGVECTOR4* WINAPI XGVec4CatmullRom
    ( XGVECTOR4 *pOut, CONST XGVECTOR4 *pV0, CONST XGVECTOR4 *pV1,
      CONST XGVECTOR4 *pV2, CONST XGVECTOR4 *pV3, FLOAT s );

// Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)
XGVECTOR4* WINAPI XGVec4BaryCentric
    ( XGVECTOR4 *pOut, CONST XGVECTOR4 *pV1, CONST XGVECTOR4 *pV2,
      CONST XGVECTOR4 *pV3, FLOAT f, FLOAT g);

// Transform vector by matrix.
XGVECTOR4* WINAPI XGVec4Transform
    ( XGVECTOR4 *pOut, CONST XGVECTOR4 *pV, CONST XGMATRIX *pM );

#ifdef __cplusplus
}
#endif


//--------------------------
// 4D Matrix
//--------------------------

// inline

XGMATRIX* XGMatrixIdentity
    ( XGMATRIX *pOut );

BOOL XGMatrixIsIdentity
    ( CONST XGMATRIX *pM );


// non-inline
#ifdef __cplusplus
extern "C" {
#endif

FLOAT WINAPI XGMatrixfDeterminant
    ( CONST XGMATRIX *pM );

// Matrix multiplication.  The result represents the transformation M2
// followed by the transformation M1.  (Out = M1 * M2)
XGMATRIX* WINAPI XGMatrixMultiply
    ( XGMATRIX *pOut, CONST XGMATRIX *pM1, CONST XGMATRIX *pM2 );

XGMATRIX* WINAPI XGMatrixTranspose
    ( XGMATRIX *pOut, CONST XGMATRIX *pM );

// Calculate inverse of matrix.  Inversion my fail, in which case NULL will
// be returned.  The determinant of pM is also returned it pfDeterminant
// is non-NULL.
XGMATRIX* WINAPI XGMatrixInverse
    ( XGMATRIX *pOut, FLOAT *pDeterminant, CONST XGMATRIX *pM );

// Build a matrix which scales by (sx, sy, sz)
XGMATRIX* WINAPI XGMatrixScaling
    ( XGMATRIX *pOut, FLOAT sx, FLOAT sy, FLOAT sz );

// Build a matrix which translates by (x, y, z)
XGMATRIX* WINAPI XGMatrixTranslation
    ( XGMATRIX *pOut, FLOAT x, FLOAT y, FLOAT z );

// Build a matrix which rotates around the X axis
XGMATRIX* WINAPI XGMatrixRotationX
    ( XGMATRIX *pOut, FLOAT Angle );

// Build a matrix which rotates around the Y axis
XGMATRIX* WINAPI XGMatrixRotationY
    ( XGMATRIX *pOut, FLOAT Angle );

// Build a matrix which rotates around the Z axis
XGMATRIX* WINAPI XGMatrixRotationZ
    ( XGMATRIX *pOut, FLOAT Angle );

// Build a matrix which rotates around an arbitrary axis
XGMATRIX* WINAPI XGMatrixRotationAxis
    ( XGMATRIX *pOut, CONST XGVECTOR3 *pV, FLOAT Angle );

// Build a matrix from a quaternion
XGMATRIX* WINAPI XGMatrixRotationQuaternion
    ( XGMATRIX *pOut, CONST XGQUATERNION *pQ);

// Yaw around the Y axis, a pitch around the X axis,
// and a roll around the Z axis.
XGMATRIX* WINAPI XGMatrixRotationYawPitchRoll
    ( XGMATRIX *pOut, FLOAT Yaw, FLOAT Pitch, FLOAT Roll );

// Build transformation matrix.  NULL arguments are treated as identity.
// Mout = Msc-1 * Msr-1 * Ms * Msr * Msc * Mrc-1 * Mr * Mrc * Mt
XGMATRIX* WINAPI XGMatrixTransformation
    ( XGMATRIX *pOut, CONST XGVECTOR3 *pScalingCenter,
      CONST XGQUATERNION *pScalingRotation, CONST XGVECTOR3 *pScaling,
      CONST XGVECTOR3 *pRotationCenter, CONST XGQUATERNION *pRotation,
      CONST XGVECTOR3 *pTranslation);

// Build affine transformation matrix.  NULL arguments are treated as identity.
// Mout = Ms * Mrc-1 * Mr * Mrc * Mt
XGMATRIX* WINAPI XGMatrixAffineTransformation
    ( XGMATRIX *pOut, FLOAT Scaling, CONST XGVECTOR3 *pRotationCenter,
      CONST XGQUATERNION *pRotation, CONST XGVECTOR3 *pTranslation);

// Build a lookat matrix. (right-handed)
XGMATRIX* WINAPI XGMatrixLookAtRH
    ( XGMATRIX *pOut, CONST XGVECTOR3 *pEye, CONST XGVECTOR3 *pAt,
      CONST XGVECTOR3 *pUp );

// Build a lookat matrix. (left-handed)
XGMATRIX* WINAPI XGMatrixLookAtLH
    ( XGMATRIX *pOut, CONST XGVECTOR3 *pEye, CONST XGVECTOR3 *pAt,
      CONST XGVECTOR3 *pUp );

// Build a perspective projection matrix. (right-handed)
XGMATRIX* WINAPI XGMatrixPerspectiveRH
    ( XGMATRIX *pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf );

// Build a perspective projection matrix. (left-handed)
XGMATRIX* WINAPI XGMatrixPerspectiveLH
    ( XGMATRIX *pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf );

// Build a perspective projection matrix. (right-handed)
XGMATRIX* WINAPI XGMatrixPerspectiveFovRH
    ( XGMATRIX *pOut, FLOAT fovy, FLOAT Aspect, FLOAT zn, FLOAT zf );

// Build a perspective projection matrix. (left-handed)
XGMATRIX* WINAPI XGMatrixPerspectiveFovLH
    ( XGMATRIX *pOut, FLOAT fovy, FLOAT Aspect, FLOAT zn, FLOAT zf );

// Build a perspective projection matrix. (right-handed)
XGMATRIX* WINAPI XGMatrixPerspectiveOffCenterRH
    ( XGMATRIX *pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
      FLOAT zf );

// Build a perspective projection matrix. (left-handed)
XGMATRIX* WINAPI XGMatrixPerspectiveOffCenterLH
    ( XGMATRIX *pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
      FLOAT zf );

// Build an ortho projection matrix. (right-handed)
XGMATRIX* WINAPI XGMatrixOrthoRH
    ( XGMATRIX *pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf );

// Build an ortho projection matrix. (left-handed)
XGMATRIX* WINAPI XGMatrixOrthoLH
    ( XGMATRIX *pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf );

// Build an ortho projection matrix. (right-handed)
XGMATRIX* WINAPI XGMatrixOrthoOffCenterRH
    ( XGMATRIX *pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
      FLOAT zf );

// Build an ortho projection matrix. (left-handed)
XGMATRIX* WINAPI XGMatrixOrthoOffCenterLH
    ( XGMATRIX *pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
      FLOAT zf );

// Build a matrix which flattens geometry into a plane, as if casting
// a shadow from a light.
XGMATRIX* WINAPI XGMatrixShadow
    ( XGMATRIX *pOut, CONST XGVECTOR4 *pLight,
      CONST XGPLANE *pPlane );

// Build a matrix which reflects the coordinate system about a plane
XGMATRIX* WINAPI XGMatrixReflect
    ( XGMATRIX *pOut, CONST XGPLANE *pPlane );

#ifdef __cplusplus
}
#endif


//--------------------------
// Quaternion
//--------------------------

// inline

FLOAT XGQuaternionLength
    ( CONST XGQUATERNION *pQ );

// Length squared, or "norm"
FLOAT XGQuaternionLengthSq
    ( CONST XGQUATERNION *pQ );

FLOAT XGQuaternionDot
    ( CONST XGQUATERNION *pQ1, CONST XGQUATERNION *pQ2 );

// (0, 0, 0, 1)
XGQUATERNION* XGQuaternionIdentity
    ( XGQUATERNION *pOut );

BOOL XGQuaternionIsIdentity
    ( CONST XGQUATERNION *pQ );

// (-x, -y, -z, w)
XGQUATERNION* XGQuaternionConjugate
    ( XGQUATERNION *pOut, CONST XGQUATERNION *pQ );


// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Compute a quaternin's axis and angle of rotation. Expects unit quaternions.
void WINAPI XGQuaternionToAxisAngle
    ( CONST XGQUATERNION *pQ, XGVECTOR3 *pAxis, FLOAT *pAngle );

// Build a quaternion from a rotation matrix.
XGQUATERNION* WINAPI XGQuaternionRotationMatrix
    ( XGQUATERNION *pOut, CONST XGMATRIX *pM);

// Rotation about arbitrary axis.
XGQUATERNION* WINAPI XGQuaternionRotationAxis
    ( XGQUATERNION *pOut, CONST XGVECTOR3 *pV, FLOAT Angle );

// Yaw around the Y axis, a pitch around the X axis,
// and a roll around the Z axis.
XGQUATERNION* WINAPI XGQuaternionRotationYawPitchRoll
    ( XGQUATERNION *pOut, FLOAT Yaw, FLOAT Pitch, FLOAT Roll );

// Quaternion multiplication.  The result represents the rotation Q2
// followed by the rotation Q1.  (Out = Q2 * Q1)
XGQUATERNION* WINAPI XGQuaternionMultiply
    ( XGQUATERNION *pOut, CONST XGQUATERNION *pQ1,
      CONST XGQUATERNION *pQ2 );

XGQUATERNION* WINAPI XGQuaternionNormalize
    ( XGQUATERNION *pOut, CONST XGQUATERNION *pQ );

// Conjugate and re-norm
XGQUATERNION* WINAPI XGQuaternionInverse
    ( XGQUATERNION *pOut, CONST XGQUATERNION *pQ );

// Expects unit quaternions.
// if q = (cos(theta), sin(theta) * v); ln(q) = (0, theta * v)
XGQUATERNION* WINAPI XGQuaternionLn
    ( XGQUATERNION *pOut, CONST XGQUATERNION *pQ );

// Expects pure quaternions. (w == 0)  w is ignored in calculation.
// if q = (0, theta * v); exp(q) = (cos(theta), sin(theta) * v)
XGQUATERNION* WINAPI XGQuaternionExp
    ( XGQUATERNION *pOut, CONST XGQUATERNION *pQ );

// Spherical linear interpolation between Q1 (s == 0) and Q2 (s == 1).
// Expects unit quaternions.
XGQUATERNION* WINAPI XGQuaternionSlerp
    ( XGQUATERNION *pOut, CONST XGQUATERNION *pQ1,
      CONST XGQUATERNION *pQ2, FLOAT t );

// Spherical quadrangle interpolation.
// Slerp(Slerp(Q1, Q4, t), Slerp(Q2, Q3, t), 2t(1-t))
XGQUATERNION* WINAPI XGQuaternionSquad
    ( XGQUATERNION *pOut, CONST XGQUATERNION *pQ1,
      CONST XGQUATERNION *pQ2, CONST XGQUATERNION *pQ3,
      CONST XGQUATERNION *pQ4, FLOAT t );

// Slerp(Slerp(Q1, Q2, f+g), Slerp(Q1, Q3, f+g), g/(f+g))
XGQUATERNION* WINAPI XGQuaternionBaryCentric
    ( XGQUATERNION *pOut, CONST XGQUATERNION *pQ1,
      CONST XGQUATERNION *pQ2, CONST XGQUATERNION *pQ3,
      FLOAT f, FLOAT g );

#ifdef __cplusplus
}
#endif


//--------------------------
// Plane
//--------------------------

// inline

// ax + by + cz + dw
FLOAT XGPlaneDot
    ( CONST XGPLANE *pP, CONST XGVECTOR4 *pV);

// ax + by + cz + d
FLOAT XGPlaneDotCoord
    ( CONST XGPLANE *pP, CONST XGVECTOR3 *pV);

// ax + by + cz
FLOAT XGPlaneDotNormal
    ( CONST XGPLANE *pP, CONST XGVECTOR3 *pV);

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Normalize plane (so that |a,b,c| == 1)
XGPLANE* WINAPI XGPlaneNormalize
    ( XGPLANE *pOut, CONST XGPLANE *pP);

// Find the intersection between a plane and a line.  If the line is
// parallel to the plane, NULL is returned.
XGVECTOR3* WINAPI XGPlaneIntersectLine
    ( XGVECTOR3 *pOut, CONST XGPLANE *pP, CONST XGVECTOR3 *pV1,
      CONST XGVECTOR3 *pV2);

// Construct a plane from a point and a normal
XGPLANE* WINAPI XGPlaneFromPointNormal
    ( XGPLANE *pOut, CONST XGVECTOR3 *pPoint, CONST XGVECTOR3 *pNormal);

// Construct a plane from 3 points
XGPLANE* WINAPI XGPlaneFromPoints
    ( XGPLANE *pOut, CONST XGVECTOR3 *pV1, CONST XGVECTOR3 *pV2,
      CONST XGVECTOR3 *pV3);

// Transform a plane by a matrix.  The vector (a,b,c) must be normal.
// M must be an affine transform.
XGPLANE* WINAPI XGPlaneTransform
    ( XGPLANE *pOut, CONST XGPLANE *pP, CONST XGMATRIX *pM );

#ifdef __cplusplus
}
#endif


//--------------------------
// Color
//--------------------------

// inline

// (1-r, 1-g, 1-b, a)
XGCOLOR* XGColorNegative
    (XGCOLOR *pOut, CONST XGCOLOR *pC);

XGCOLOR* XGColorAdd
    (XGCOLOR *pOut, CONST XGCOLOR *pC1, CONST XGCOLOR *pC2);

XGCOLOR* XGColorSubtract
    (XGCOLOR *pOut, CONST XGCOLOR *pC1, CONST XGCOLOR *pC2);

XGCOLOR* XGColorScale
    (XGCOLOR *pOut, CONST XGCOLOR *pC, FLOAT s);

// (r1*r2, g1*g2, b1*b2, a1*a2)
XGCOLOR* XGColorModulate
    (XGCOLOR *pOut, CONST XGCOLOR *pC1, CONST XGCOLOR *pC2);

// Linear interpolation of r,g,b, and a. C1 + s(C2-C1)
XGCOLOR* XGColorLerp
    (XGCOLOR *pOut, CONST XGCOLOR *pC1, CONST XGCOLOR *pC2, FLOAT s);

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Interpolate r,g,b between desaturated color and color.
// DesaturatedColor + s(Color - DesaturatedColor)
XGCOLOR* WINAPI XGColorAdjustSaturation
    (XGCOLOR *pOut, CONST XGCOLOR *pC, FLOAT s);

// Interpolate r,g,b between 50% grey and color.  Grey + s(Color - Grey)
XGCOLOR* WINAPI XGColorAdjustContrast
    (XGCOLOR *pOut, CONST XGCOLOR *pC, FLOAT c);

#ifdef __cplusplus
}
#endif

#include "xgmath.inl"

#pragma warning(default:4201)

#ifdef __cplusplus
}
#endif // __cplusplus

#ifdef _USE_XGMATH

//--------------------------
// D3DX Compatibility defines
//--------------------------

#define D3DX_PI XG_PI
#define D3DX_1BYPI XG_1BYPI

#define D3DXToRadian XGToRadian
#define D3DXToDegree XGToDegree

#define D3DXVECTOR2 XGVECTOR2
#define LPD3DXVECTOR2 LPXGVECTOR2
#define D3DXVECTOR3 XGVECTOR3
#define LPD3DXVECTOR3 LPXGVECTOR3
#define D3DXVECTOR4 XGVECTOR4
#define LPD3DXVECTOR4 LPXGVECTOR4
#define D3DXMATRIX XGMATRIX
#define LPD3DXMATRIX LPXGMATRIX
#define D3DXQUATERNION XGQUATERNION
#define LPD3DXQUATERNION LPXGQUATERNION
#define D3DXPLANE XGPLANE
#define LPD3DXPLANE LPXGPLANE
#define D3DXCOLOR XGCOLOR
#define LPD3DXCOLOR LPXGCOLOR

#define D3DXVec2Length XGVec2Length
#define D3DXVec2LengthSq XGVec2LengthSq
#define D3DXVec2Dot XGVec2Dot
#define D3DXVec2CCW XGVec2CCW
#define D3DXVec2Add XGVec2Add
#define D3DXVec2Subtract XGVec2Subtract
#define D3DXVec2Minimize XGVec2Minimize
#define D3DXVec2Maximize XGVec2Maximize
#define D3DXVec2Scale XGVec2Scale
#define D3DXVec2Lerp XGVec2Lerp
#define D3DXVec2Normalize XGVec2Normalize
#define D3DXVec2Hermite XGVec2Hermite
#define D3DXVec2CatmullRom XGVec2CatmullRom
#define D3DXVec2BaryCentric XGVec2BaryCentric
#define D3DXVec2Transform XGVec2Transform
#define D3DXVec2TransformCoord XGVec2TransformCoord
#define D3DXVec2TransformNormal XGVec2TransformNormal

#define D3DXVec3Length XGVec3Length
#define D3DXVec3LengthSq XGVec3LengthSq
#define D3DXVec3Dot XGVec3Dot
#define D3DXVec3Cross XGVec3Cross
#define D3DXVec3Add XGVec3Add
#define D3DXVec3Subtract XGVec3Subtract
#define D3DXVec3Minimize XGVec3Minimize
#define D3DXVec3Maximize XGVec3Maximize
#define D3DXVec3Scale XGVec3Scale
#define D3DXVec3Lerp XGVec3Lerp
#define D3DXVec3Normalize XGVec3Normalize
#define D3DXVec3Hermite XGVec3Hermite
#define D3DXVec3CatmullRom XGVec3CatmullRom
#define D3DXVec3BaryCentric XGVec3BaryCentric
#define D3DXVec3Transform XGVec3Transform
#define D3DXVec3TransformCoord XGVec3TransformCoord
#define D3DXVec3TransformNormal XGVec3TransformNormal
#define D3DXVec3Project XGVec3Project
#define D3DXVec3Unproject XGVec3Unproject

#define D3DXVec4Length XGVec4Length
#define D3DXVec4LengthSq XGVec4LengthSq
#define D3DXVec4Dot XGVec4Dot
#define D3DXVec4Add XGVec4Add
#define D3DXVec4Subtract XGVec4Subtract
#define D3DXVec4Minimize XGVec4Minimize
#define D3DXVec4Maximize XGVec4Maximize
#define D3DXVec4Scale XGVec4Scale
#define D3DXVec4Lerp XGVec4Lerp
#define D3DXVec4Cross XGVec4Cross
#define D3DXVec4Normalize XGVec4Normalize
#define D3DXVec4Hermite XGVec4Hermite
#define D3DXVec4CatmullRom XGVec4CatmullRom
#define D3DXVec4BaryCentric XGVec4BaryCentric
#define D3DXVec4Transform XGVec4Transform

#define D3DXMatrixIdentity XGMatrixIdentity
#define D3DXMatrixIsIdentity XGMatrixIsIdentity
#define D3DXMatrixfDeterminant XGMatrixfDeterminant
#define D3DXMatrixMultiply XGMatrixMultiply
#define D3DXMatrixTranspose XGMatrixTranspose
#define D3DXMatrixInverse XGMatrixInverse
#define D3DXMatrixScaling XGMatrixScaling
#define D3DXMatrixTranslation XGMatrixTranslation
#define D3DXMatrixRotationX XGMatrixRotationX
#define D3DXMatrixRotationY XGMatrixRotationY
#define D3DXMatrixRotationZ XGMatrixRotationZ
#define D3DXMatrixRotationAxis XGMatrixRotationAxis
#define D3DXMatrixRotationQuaternion XGMatrixRotationQuaternion
#define D3DXMatrixRotationYawPitchRoll XGMatrixRotationYawPitchRoll
#define D3DXMatrixTransformation XGMatrixTransformation
#define D3DXMatrixAffineTransformation XGMatrixAffineTransformation
#define D3DXMatrixLookAtRH XGMatrixLookAtRH
#define D3DXMatrixLookAtLH XGMatrixLookAtLH
#define D3DXMatrixPerspectiveRH XGMatrixPerspectiveRH
#define D3DXMatrixPerspectiveLH XGMatrixPerspectiveLH
#define D3DXMatrixPerspectiveFovRH XGMatrixPerspectiveFovRH
#define D3DXMatrixPerspectiveFovLH XGMatrixPerspectiveFovLH
#define D3DXMatrixPerspectiveOffCenterRH XGMatrixPerspectiveOffCenterRH
#define D3DXMatrixPerspectiveOffCenterLH XGMatrixPerspectiveOffCenterLH
#define D3DXMatrixOrthoRH XGMatrixOrthoRH
#define D3DXMatrixOrthoLH XGMatrixOrthoLH
#define D3DXMatrixOrthoOffCenterRH XGMatrixOrthoOffCenterRH
#define D3DXMatrixOrthoOffCenterLH XGMatrixOrthoOffCenterLH
#define D3DXMatrixShadow XGMatrixShadow
#define D3DXMatrixReflect XGMatrixReflect

#define D3DXQuaternionLength XGQuaternionLength
#define D3DXQuaternionLengthSq XGQuaternionLengthSq
#define D3DXQuaternionDot XGQuaternionDot
#define D3DXQuaternionIdentity XGQuaternionIdentity
#define D3DXQuaternionIsIdentity XGQuaternionIsIdentity
#define D3DXQuaternionConjugate XGQuaternionConjugate
#define D3DXQuaternionToAxisAngle XGQuaternionToAxisAngle
#define D3DXQuaternionRotationMatrix XGQuaternionRotationMatrix
#define D3DXQuaternionRotationAxis XGQuaternionRotationAxis
#define D3DXQuaternionRotationYawPitchRoll XGQuaternionRotationYawPitchRoll
#define D3DXQuaternionMultiply XGQuaternionMultiply
#define D3DXQuaternionNormalize XGQuaternionNormalize
#define D3DXQuaternionInverse XGQuaternionInverse
#define D3DXQuaternionLn XGQuaternionLn
#define D3DXQuaternionExp XGQuaternionExp
#define D3DXQuaternionSlerp XGQuaternionSlerp
#define D3DXQuaternionSquad XGQuaternionSquad
#define D3DXQuaternionBaryCentric XGQuaternionBaryCentric

#define D3DXPlaneDot XGPlaneDot
#define D3DXPlaneDotCoord XGPlaneDotCoord
#define D3DXPlaneDotNormal XGPlaneDotNormal
#define D3DXPlaneNormalize XGPlaneNormalize
#define D3DXPlaneIntersectLine XGPlaneIntersectLine
#define D3DXPlaneFromPointNormal XGPlaneFromPointNormal
#define D3DXPlaneFromPoints XGPlaneFromPoints
#define D3DXPlaneTransform XGPlaneTransform

#define D3DXColorNegative XGColorNegative
#define D3DXColorAdd XGColorAdd
#define D3DXColorSubtract XGColorSubtract
#define D3DXColorScale XGColorScale
#define D3DXColorModulate XGColorModulate
#define D3DXColorLerp XGColorLerp
#define D3DXColorAdjustSaturation XGColorAdjustSaturation
#define D3DXColorAdjustContrast XGColorAdjustContrast

#endif // _USE_XGMATH

#endif // __XGMATH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dxg\makefile.inc ===
TARGETFILES= \
    $(O)\d3d8.h \
    $(O)\xmetal.h \
    $(O)\d3d8caps.h \
    $(O)\d3d8types.h \
    $(O)\d3d8perf.h \
    $(O)\d3d8sddi.h \
    $(O)\dx7todx8.h \
    $(O)\d3dx8mesh.h \
    $(O)\d3dx8.h \
    $(O)\xfont.h \
    $(O)\xfontformat.h \
    $(D3DX8_INC_PATH)\d3dx8meshp.h \
    $(D3DX8_INC_PATH)\d3dx8p.h \
    $(PROJECT_INC_PATH)\d3d8sddi.h \
    $(SDK_INC_PATH)\dx7todx8.h \
    $(SDK_INC_PATH)\d3d8.h \
    $(SDK_INC_PATH)\xmetal.h \
    $(SDK_INC_PATH)\d3d8caps.h \
    $(SDK_INC_PATH)\d3d8types.h \
    $(SDK_INC_PATH)\d3d8perf.h \
    $(SDK_INC_PATH)\d3dx8.h \
    $(SDK_INC_PATH)\d3dx8mesh.h \
    $(SDK_INC_PATH)\d3dx8core.h \
    $(SDK_INC_PATH)\d3dx8effect.h \
    $(SDK_INC_PATH)\d3dx8math.h \
    $(SDK_INC_PATH)\d3dx8math.inl \
    $(SDK_INC_PATH)\d3dx8shape.h \
    $(SDK_INC_PATH)\d3dx8tex.h \
    $(SDK_INC_PATH)\xgraphics.h \
    $(SDK_INC_PATH)\xgmath.h \
    $(SDK_INC_PATH)\xgmath.inl \
    $(XDK_INC_PATH)\d3d8.h \
    $(XDK_INC_PATH)\xmetal.h \
    $(XDK_INC_PATH)\d3d8caps.h \
    $(XDK_INC_PATH)\d3d8types.h \
    $(XDK_INC_PATH)\d3d8perf.h \
    $(XDK_INC_PATH)\d3dx8.h \
    $(XDK_INC_PATH)\d3dx8mesh.h \
    $(XDK_INC_PATH)\d3dx8core.h \
    $(XDK_INC_PATH)\d3dx8effect.h \
    $(XDK_INC_PATH)\d3dx8math.h \
    $(XDK_INC_PATH)\d3dx8math.inl \
    $(XDK_INC_PATH)\d3dx8shape.h \
    $(XDK_INC_PATH)\d3dx8tex.h \
    $(XDK_INC_PATH)\xgraphics.h \
    $(XDK_INC_PATH)\xgmath.h \
    $(XDK_INC_PATH)\xgmath.inl \
    $(WSDK_INC_PATH)\d3d8-xbox.h \
    $(WSDK_INC_PATH)\d3d8types-xbox.h \
    $(WSDK_INC_PATH)\xgraphics.h \
    $(WSDK_INC_PATH)\xgmath.h \
    $(WSDK_INC_PATH)\xgmath.inl \
    $(PRIVATE_INC_PATH)\d3d8perfp.h \
    $(SDK_INC_PATH)\xfont.h \
    $(SDK_INC_PATH)\xfontformat.h \
    $(XDK_INC_PATH)\xfont.h \
    $(XDK_INC_PATH)\xfontformat.h \
    $(WSDK_INC_PATH)\xfont-pc.h \
    $(WSDK_INC_PATH)\xfontformat-pc.h

processedfiles: \
    $(TARGETFILES)

clean:
    -del /q /f $(TARGETFILES) 2>nul

DX8HSPLITFLAGS = -ts dx3 -ts dx4 -ts dx5 -ts dx6 -ts dx7 -ta dx8 -v 800
DX8HSPLITSDKFLAGS = $(DX8HSPLITFLAGS) -ta external -ts internal
DX8HSPLITINTERNALFLAGS = $(DX8HSPLITFLAGS) -ts external -ta internal

$(O)\d3d8.h : d3d8.x
    hsplit $(DX8HSPLITSDKFLAGS) -ta xboxonly -ts xboxwindows -ts january -o $@ tmp.px d3d8.x
    del tmp.px

$(O)\xmetal.h : xmetal.x
    hsplit $(DX8HSPLITSDKFLAGS) -ta xboxonly -ts xboxwindows -ts january -o $@ tmp.px xmetal.x
    del tmp.px

$(O)\d3d8caps.h :d3d8caps.x
    hsplit $(DX8HSPLITSDKFLAGS) -o $@ tmp.px d3d8caps.x
    del tmp.px

$(O)\d3d8types.h : d3d8typs.x
    hsplit $(DX8HSPLITSDKFLAGS) -o $@ tmp.px d3d8typs.x
    del tmp.px

$(O)\d3d8perf.h : d3d8perf.x
    cl /EP /C d3d8perf.x > tmp.cx
    hsplit -ta external -ts internal -ts remove -o $@ tmp.px tmp.cx
    del tmp.px
    del tmp.cx

$(PRIVATE_INC_PATH)\d3d8perfp.h : d3d8perf.x
    hsplit -ts external -ta internal -ts remove -o $@ tmp.px d3d8perf.x
    del tmp.px

$(O)\d3d8sddi.h : d3d8sddi.x
    copy $? $@

$(O)\dx7todx8.h : dx7todx8.x
    copy $? $@

$(O)\d3dx8mesh.h : d3dx8mesh.w d3dmkhdr.m4
    m4  d3dx8mesh.w > tmp.wx
    hsplit $(DX8HSPLITSDKFLAGS) -o $@ tmp.px tmp.wx
    del tmp.wx
    del tmp.px

$(D3DX8_INC_PATH)\d3dx8meshp.h : d3dx8mesh.w d3dmkhdr.m4
    m4  d3dx8mesh.w > tmp.wx
    hsplit $(DX8HSPLITINTERNALFLAGS) -o $@ tmp.px tmp.wx
    del tmp.wx
    del tmp.px

$(O)\d3dx8.h : d3dx8.w d3dmkhdr.m4
    m4  d3dx8.w > tmp.wx
    hsplit $(DX8HSPLITSDKFLAGS) -o $@ tmp.px tmp.wx
    del tmp.wx
    del tmp.px

$(D3DX8_INC_PATH)\d3dx8p.h : d3dx8.w d3dmkhdr.m4
    m4  d3dx8.w > tmp.wx
    hsplit $(DX8HSPLITINTERNALFLAGS) -o $@ tmp.px tmp.wx
    del tmp.wx
    del tmp.px
    
$(O)\xfont.h : xfont.x
    hsplit $(DX8HSPLITSDKFLAGS) -ta xboxonly -ts xboxwindows -o $@ tmp.px xfont.x
    del tmp.px

$(O)\xfontformat.h : xfontformat.x
    hsplit $(DX8HSPLITSDKFLAGS) -ta xboxonly -ts xboxwindows -o $@ tmp.px xfontformat.x
    del tmp.px

$(SDK_INC_PATH)\dx7todx8.h    :      $(O)\dx7todx8.h    
    copy $? $@

$(SDK_INC_PATH)\d3d8.h        :      $(O)\d3d8.h        
    copy $? $@

$(SDK_INC_PATH)\xmetal.h      :      $(O)\xmetal.h        
    copy $? $@

$(SDK_INC_PATH)\d3d8caps.h    :      $(O)\d3d8caps.h    
    copy $? $@

$(SDK_INC_PATH)\d3d8types.h   :      $(O)\d3d8types.h   
    copy $? $@

$(SDK_INC_PATH)\d3d8perf.h   :       $(O)\d3d8perf.h   
    copy $? $@

$(PROJECT_INC_PATH)\d3d8sddi.h:      $(O)\d3d8sddi.h    
    copy $? $@

$(SDK_INC_PATH)\d3dx8.h       :      $(O)\d3dx8.h       
    copy $? $@

$(SDK_INC_PATH)\d3dx8mesh.h   :      $(O)\d3dx8mesh.h   
    copy $? $@

$(SDK_INC_PATH)\d3dx8core.h   :      d3dx8core.h       
    copy $? $@

$(SDK_INC_PATH)\d3dx8effect.h :      d3dx8effect.h     
    copy $? $@

$(SDK_INC_PATH)\d3dx8math.h   :      d3dx8math.h       
    copy $? $@

$(SDK_INC_PATH)\d3dx8math.inl :      d3dx8math.inl     
    copy $? $@

$(SDK_INC_PATH)\d3dx8shape.h  :      d3dx8shape.h      
    copy $? $@

$(SDK_INC_PATH)\d3dx8tex.h    :      d3dx8tex.h        
    copy $? $@

$(SDK_INC_PATH)\xgmath.h      :      xgmath.h        
    copy $? $@

$(SDK_INC_PATH)\xgmath.inl    :      xgmath.inl
    copy $? $@

{$(SDK_INC_PATH)}.h{$(XDK_INC_PATH)}.h:
    copy $** $@

$(SDK_INC_PATH)\xfont.h    :      $(O)\xfont.h    
    copy $? $@

$(SDK_INC_PATH)\xfontformat.h    :      $(O)\xfontformat.h    
    copy $? $@

$(XDK_INC_PATH)\xfont.h    :      $(O)\xfont.h    
    copy $(O)\xfont.h $(XDK_INC_PATH)\xfont.h

$(XDK_INC_PATH)\xfontformat.h    :      $(O)\xfontformat.h    
    copy $(O)\xfontformat.h $(XDK_INC_PATH)\xfontformat.h

$(XDK_INC_PATH)\d3dx8math.inl : $(SDK_INC_PATH)\d3dx8math.inl
    copy $** $@

$(XDK_INC_PATH)\xgmath.inl    : $(SDK_INC_PATH)\xgmath.inl
    copy $** $@

$(SDK_INC_PATH)\xgraphics.h : xgraphics.x
    hsplit $(DX8HSPLITSDKFLAGS) -ta xboxonly -ts xboxwindows -ts january -o $@ tmp.px xgraphics.x
    del tmp.px

$(WSDK_INC_PATH)\xgraphics.h : xgraphics.x
    hsplit $(DX8HSPLITSDKFLAGS) -ts xboxonly -ta xboxwindows -ts january -o $@ tmp.px xgraphics.x
    del tmp.px

$(WSDK_INC_PATH)\xgmath.h   :    xgmath.h
    copy $? $@
    
$(WSDK_INC_PATH)\xgmath.inl :    xgmath.inl
    copy $? $@

$(WSDK_INC_PATH)\d3d8-xbox.h       :      d3d8.x
    hsplit $(DX8HSPLITSDKFLAGS) -ts xboxonly -ta xboxwindows -ts january -o $@ tmp.px d3d8.x
    del tmp.px

$(WSDK_INC_PATH)\d3d8types-xbox.h  :      $(O)\d3d8types.h   
    copy $? $@

$(WSDK_INC_PATH)\xfont-pc.h   :    xfont.x
    hsplit $(DX8HSPLITSDKFLAGS) -ts xboxonly -ta xboxwindows -o $@ tmp.px xfont.x
    del tmp.px
    
$(WSDK_INC_PATH)\xfontformat-pc.h   :    xfontformat.x
    hsplit $(DX8HSPLITSDKFLAGS) -ts xboxonly -ta xboxwindows -o $@ tmp.px xfontformat.x
    del tmp.px
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dxg\obj\i386\d3d8.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3d8.h
 *  Content:    Xbox Direct3D include file
 *
 ****************************************************************************/

#ifndef _D3D8_H_
#define _D3D8_H_

#pragma warning( push )
#pragma warning( disable : 4100 ) // unreferenced formal parameter

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0800
#endif  //DIRECT3D_VERSION

#ifndef D3DINLINE
#define D3DINLINE static __forceinline
#endif

#ifndef D3DMINLINE
#define D3DMINLINE __forceinline
#endif

#define D3DFASTCALL __fastcall

#define D3D_SDK_VERSION 0

#include <stdlib.h>

typedef struct Direct3D                  Direct3D;
typedef struct D3DDevice                 D3DDevice;
typedef struct D3DResource               D3DResource;
typedef struct D3DBaseTexture            D3DBaseTexture;
typedef struct D3DTexture                D3DTexture;
typedef struct D3DVolumeTexture          D3DVolumeTexture;
typedef struct D3DCubeTexture            D3DCubeTexture;
typedef struct D3DVertexBuffer           D3DVertexBuffer;
typedef struct D3DIndexBuffer            D3DIndexBuffer;
typedef struct D3DPalette                D3DPalette;
typedef struct D3DSurface                D3DSurface;
typedef struct D3DVolume                 D3DVolume;
typedef struct D3DPushBuffer             D3DPushBuffer;
typedef struct D3DFixup                  D3DFixup;

// Compatibility typedefs.

#define IDirect3D8                       Direct3D
#define IDirect3DDevice8                 D3DDevice
#define IDirect3DResource8               D3DResource
#define IDirect3DBaseTexture8            D3DBaseTexture
#define IDirect3DTexture8                D3DTexture
#define IDirect3DVolumeTexture8          D3DVolumeTexture
#define IDirect3DCubeTexture8            D3DCubeTexture
#define IDirect3DVertexBuffer8           D3DVertexBuffer
#define IDirect3DIndexBuffer8            D3DIndexBuffer
#define IDirect3DPalette8                D3DPalette
#define IDirect3DSurface8                D3DSurface
#define IDirect3DVolume8                 D3DVolume
#define IDirect3DPushBuffer8             D3DPushBuffer
#define IDirect3DFixup8                  D3DFixup

// Pointer typedefs.

typedef struct Direct3D                  *LPDIRECT3D8,              *PDIRECT3D8;
typedef struct D3DDevice                 *LPDIRECT3DDEVICE8,        *PDIRECT3DDEVICE8;
typedef struct D3DResource               *LPDIRECT3DRESOURCE8,      *PDIRECT3DRESOURCE8;
typedef struct D3DBaseTexture            *LPDIRECT3DBASETEXTURE8,   *PDIRECT3DBASETEXTURE8;
typedef struct D3DTexture                *LPDIRECT3DTEXTURE8,       *PDIRECT3DTEXTURE8;
typedef struct D3DVolumeTexture          *LPDIRECT3DVOLUMETEXTURE8, *PDIRECT3DVOLUMETEXTURE8;
typedef struct D3DCubeTexture            *LPDIRECT3DCUBETEXTURE8,   *PDIRECT3DCUBETEXTURE8;
typedef struct D3DVertexBuffer           *LPDIRECT3DVERTEXBUFFER8,  *PDIRECT3DVERTEXBUFFER8;
typedef struct D3DIndexBuffer            *LPDIRECT3DINDEXBUFFER8,   *PDIRECT3DINDEXBUFFER8;
typedef struct D3DPalette                *LPDIRECT3DPALETTE8,       *PDIRECT3DPALETTE8;
typedef struct D3DSurface                *LPDIRECT3DSURFACE8,       *PDIRECT3DSURFACE8;
typedef struct D3DVolume                 *LPDIRECT3DVOLUME8,        *PDIRECT3DVOLUME8;
typedef struct D3DPushBuffer             *LPDIRECT3DPUSHBUFFER8,    *PDIRECT3DPUSHBUFFER8;
typedef struct D3DFixup                  *LPDIRECT3DFIXUP8,         *PDIRECT3DFIXUP8;

#include "d3d8types.h"
#include "d3d8caps.h"


#ifdef __cplusplus
extern "C" {
#endif

/*
 * The XBOX implementation of Direct3DCreate8 exists only for backwards
 * compatibility.
 *
 * There is no need to store the result of this function call.  You can
 * pass 'NULL' for the Direct3D 'this' pointer as it is completely
 * ignored.
 */

Direct3D * WINAPI Direct3DCreate8(UINT SDKVersion);

/****************************************************************************
 *
 * Parameter for Direct3D Enum and GetCaps8 functions to get the info for
 * the current mode only.
 *
 ****************************************************************************/

#define D3DCURRENT_DISPLAY_MODE                 0x00EFFFFFL

/****************************************************************************
 *
 * Flags for Direct3D::CreateDevice's BehaviorFlags
 *
 ****************************************************************************/

#define D3DCREATE_PUREDEVICE                    0x00000010L
#define D3DCREATE_SOFTWARE_VERTEXPROCESSING     0x00000020L
#define D3DCREATE_HARDWARE_VERTEXPROCESSING     0x00000040L
#define D3DCREATE_MIXED_VERTEXPROCESSING        0x00000080L

// D3DCREATE_FPU_PRESERVE is not supported on Xbox
// D3DCREATE_MULTITHREADED is not supported on Xbox

/****************************************************************************
 *
 * Parameter for Direct3D::CreateDevice's Adapter
 *
 ****************************************************************************/

#define D3DADAPTER_DEFAULT                     0

/****************************************************************************
 *
 * Flags for Direct3D::EnumAdapters
 *
 ****************************************************************************/

#define D3DENUM_NO_WHQL_LEVEL                   0x00000002L

/****************************************************************************
 *
 * Maximum number of back-buffers supported in DX8
 *
 ****************************************************************************/

#define D3DPRESENT_BACK_BUFFERS_MAX             2L

/****************************************************************************
 *
 * Flags for D3DDevice::SetGammaRamp
 *
 ****************************************************************************/

#define D3DSGR_NO_CALIBRATION                  0x00000000L
#define D3DSGR_CALIBRATE                       0x00000001L
#define D3DSGR_IMMEDIATE                       0x00000002L

/****************************************************************************
 * Flags for SetPrivateData method on all D3D8 interfaces
 *
 * The passed pointer is an IUnknown ptr. The SizeOfData argument to SetPrivateData
 * must be set to sizeof(IUnknown*). Direct3D will call AddRef through this
 * pointer and Release when the private data is destroyed. The data will be
 * destroyed when another SetPrivateData with the same GUID is set, when
 * FreePrivateData is called, or when the D3D8 object is freed.
 ****************************************************************************/

#define D3DSPD_IUNKNOWN                         0x00000001L

/*
 *  DirectDraw error codes
 */

#define _FACD3D  0x876
#define MAKE_D3DHRESULT( code )  MAKE_HRESULT( 1, _FACD3D, code )

/*
 * Direct3D Errors
 */

#define D3D_OK                              S_OK

#define D3DERR_WRONGTEXTUREFORMAT               MAKE_D3DHRESULT(2072)
#define D3DERR_UNSUPPORTEDCOLOROPERATION        MAKE_D3DHRESULT(2073)
#define D3DERR_UNSUPPORTEDCOLORARG              MAKE_D3DHRESULT(2074)
#define D3DERR_UNSUPPORTEDALPHAOPERATION        MAKE_D3DHRESULT(2075)
#define D3DERR_UNSUPPORTEDALPHAARG              MAKE_D3DHRESULT(2076)
#define D3DERR_TOOMANYOPERATIONS                MAKE_D3DHRESULT(2077)
#define D3DERR_CONFLICTINGTEXTUREFILTER         MAKE_D3DHRESULT(2078)
#define D3DERR_UNSUPPORTEDFACTORVALUE           MAKE_D3DHRESULT(2079)
#define D3DERR_CONFLICTINGRENDERSTATE           MAKE_D3DHRESULT(2081)
#define D3DERR_UNSUPPORTEDTEXTUREFILTER         MAKE_D3DHRESULT(2082)
#define D3DERR_CONFLICTINGTEXTUREPALETTE        MAKE_D3DHRESULT(2086)
#define D3DERR_DRIVERINTERNALERROR              MAKE_D3DHRESULT(2087)
#define D3DERR_TESTINCOMPLETE                   MAKE_D3DHRESULT(2088) // Xbox extension
#define D3DERR_BUFFERTOOSMALL                   MAKE_D3DHRESULT(2089) // Xbox extension

#define D3DERR_NOTFOUND                         MAKE_D3DHRESULT(2150)
#define D3DERR_MOREDATA                         MAKE_D3DHRESULT(2151)
#define D3DERR_DEVICELOST                       MAKE_D3DHRESULT(2152)
#define D3DERR_DEVICENOTRESET                   MAKE_D3DHRESULT(2153)
#define D3DERR_NOTAVAILABLE                     MAKE_D3DHRESULT(2154)
#define D3DERR_OUTOFVIDEOMEMORY                 MAKE_D3DHRESULT(380)
#define D3DERR_INVALIDDEVICE                    MAKE_D3DHRESULT(2155)
#define D3DERR_INVALIDCALL                      MAKE_D3DHRESULT(2156)

/****************************************************************************
 *
 * BeginStateBlock/EndStateBlock semantics require that D3D have the ability
 * to record all API state-changing calls in a state block.  Rather than add 
 * a time-consuming are-we-recording-a-state-block check to every SetRenderState 
 * and SetTextureStageState call that would slow callers even if they never 
 * used BeginStateBlock/EndStateBlock, we've placed that logic inline so that 
 * it can be eliminated if not needed by the title.
 *
 * To enable BeginStateBlock/EndStateBlock, define the following before
 * including xtl.h.  This needs to be done for all modules that can change
 * state that should be recorded by BeginStateBlock.
 *
 *      #define D3DCOMPILE_BEGINSTATEBLOCK 1
 *
 ****************************************************************************/

typedef enum _D3DSTATEBLOCKDIRTYINDEX
{
    D3DSBD_TEXTURES              = 0, 
    D3DSBD_PIXELSHADER           = D3DSBD_TEXTURES + D3DTSS_MAXSTAGES,
    D3DSBD_VERTEXSHADER          = D3DSBD_PIXELSHADER + 1,
    D3DSBD_INDICES               = D3DSBD_VERTEXSHADER + 1,
    D3DSBD_STREAMS               = D3DSBD_INDICES + 1,
    D3DSBD_PIXELSHADERCONSTANTS  = D3DSBD_STREAMS + D3DVS_STREAMS_MAX_V1_0,
    D3DSBD_VERTEXSHADERCONSTANTS = D3DSBD_PIXELSHADERCONSTANTS + D3DPS_CONSTREG_MAX_DX8,
    D3DSBD_RENDERSTATES          = D3DSBD_VERTEXSHADERCONSTANTS + D3DVS_CONSTREG_COUNT_XBOX,
    D3DSBD_TEXTURESTATES         = D3DSBD_RENDERSTATES + D3DRS_MAX,
    D3DSBD_TRANSFORMS            = D3DSBD_TEXTURESTATES + (D3DTSS_MAXSTAGES * D3DTSS_MAX),
    D3DSBD_VIEWPORT              = D3DSBD_TRANSFORMS + D3DTS_MAX,
    D3DSBD_MATERIAL              = D3DSBD_VIEWPORT + 1,
    D3DSBD_BACKMATERIAL          = D3DSBD_MATERIAL + 1,
    D3DSBD_MAX                   = D3DSBD_BACKMATERIAL + 1,
    D3DSBD_FORCE_DWORD           = 0x7fffffff, // force 32-bit size enum
} D3DSTATEBLOCKDIRTYINDEX;

#ifdef D3DCOMPILE_BEGINSTATEBLOCK
        
    #define D3DDIRTY_TEXTURE(stage)                                         \
        { D3D__StateBlockDirty[D3DSBD_TEXTURES + (stage)] = TRUE; }
        
    #define D3DDIRTY_PIXELSHADER()                                          \
        { D3D__StateBlockDirty[D3DSBD_PIXELSHADER] = TRUE; }
        
    #define D3DDIRTY_VERTEXSHADER()                                         \
        { D3D__StateBlockDirty[D3DSBD_VERTEXSHADER] = TRUE; }
        
    #define D3DDIRTY_INDICES()                                              \
        { D3D__StateBlockDirty[D3DSBD_INDICES] = TRUE; }
        
    #define D3DDIRTY_STREAM(stream)                                         \
        { D3D__StateBlockDirty[D3DSBD_STREAMS + (stream)] = TRUE; }
        
    #define D3DDIRTY_PIXELSHADERCONSTANT(index, count)                      \
        { memset(&D3D__StateBlockDirty[D3DSBD_PIXELSHADERCONSTANTS + (index)], TRUE, (count)); }
        
    #define D3DDIRTY_VERTEXSHADERCONSTANT(index, count)                     \
        { memset(&D3D__StateBlockDirty[D3DSBD_VERTEXSHADERCONSTANTS + (index) + 96], TRUE, (count)); }
                          
    #define D3DDIRTY_RENDERSTATE(state)                                     \
        { D3D__StateBlockDirty[D3DSBD_RENDERSTATES + (state)] = TRUE; }
    
    #define D3DDIRTY_TEXTURESTATE(stage, state)                             \
        { D3D__StateBlockDirty[D3DSBD_TEXTURESTATES +                       \
                          ((state) * D3DTSS_MAXSTAGES) + (stage)] = TRUE; } 
        
    #define D3DDIRTY_TRANSFORM(transform)                                   \
        { D3D__StateBlockDirty[D3DSBD_TRANSFORMS + (transform)] = TRUE; }
        
    #define D3DDIRTY_VIEWPORT()                                             \
        { D3D__StateBlockDirty[D3DSBD_VIEWPORT] = TRUE; }
        
    #define D3DDIRTY_MATERIAL()                                             \
        { D3D__StateBlockDirty[D3DSBD_MATERIAL] = TRUE; }
        
    #define D3DDIRTY_BACKMATERIAL()                                         \
        { D3D__StateBlockDirty[D3DSBD_BACKMATERIAL] = TRUE; }
    
#else
        
    #define D3DDIRTY_TEXTURE(stage)
    #define D3DDIRTY_PIXELSHADER()                                         
    #define D3DDIRTY_VERTEXSHADER()                                        
    #define D3DDIRTY_INDICES()                                             
    #define D3DDIRTY_STREAM(stream)                                         
    #define D3DDIRTY_PIXELSHADERCONSTANT(index, count)                         
    #define D3DDIRTY_VERTEXSHADERCONSTANT(index, count)                        
    #define D3DDIRTY_RENDERSTATE(state)                                    
    #define D3DDIRTY_TEXTURESTATE(stage, state)                            
    #define D3DDIRTY_TRANSFORM(transform)                                  
    #define D3DDIRTY_VIEWPORT()
    #define D3DDIRTY_MATERIAL()                                            
    #define D3DDIRTY_BACKMATERIAL()                                            

#endif

/****************************************************************************
 *
 * __declspec(selectany) has the lovely attribute that it allows the linker
 * to remove duplicate instantiations of global declarations, and to remove
 * the instantiation entirely if unreferenced.
 *
 ****************************************************************************/

#define D3DCONST extern CONST DECLSPEC_SELECTANY

/****************************************************************************
 *
 * Private internal data - Please don't access these directly, as they're
 *                         subject to change.
 *
 ****************************************************************************/

D3DCONST UINT D3DPRIMITIVETOVERTEXCOUNT[11][2] =
{
    {0, 0},         // Illegal
    {1, 0},         // D3DPT_POINTLIST     = 1,
    {2, 0},         // D3DPT_LINELIST      = 2,
    {1, 1},         // D3DPT_LINELOOP      = 3,
    {1, 1},         // D3DPT_LINESTRIP     = 4,
    {3, 0},         // D3DPT_TRIANGLELIST  = 5,
    {1, 2},         // D3DPT_TRIANGLESTRIP = 6,
    {1, 2},         // D3DPT_TRIANGLEFAN   = 7,
    {4, 0},         // D3DPT_QUADLIST      = 8,
    {2, 2},         // D3DPT_QUADSTRIP     = 9,
    {0, 0},         // Illegal (D3DPT_POLYGON)
};

D3DCONST DWORD D3DSIMPLERENDERSTATEENCODE[] =
{                                          
    0x040260,    0x040264,    0x040268,    0x04026c,    // 0
    0x040270,    0x040274,    0x040278,    0x04027c,    // 4
    0x040288,    0x04028c,    0x040a60,    0x040a64,    // 8
    0x040a68,    0x040a6c,    0x040a70,    0x040a74,    // 12
    0x040a78,    0x040a7c,    0x040a80,    0x040a84,    // 16
    0x040a88,    0x040a8c,    0x040a90,    0x040a94,    // 20
    0x040a98,    0x040a9c,    0x040aa0,    0x040aa4,    // 24
    0x040aa8,    0x040aac,    0x040ab0,    0x040ab4,    // 28
    0x040ab8,    0x040abc,    0x040ac0,    0x040ac4,    // 32
    0x040ac8,    0x040acc,    0x040ad0,    0x040ad4,    // 36
    0x040ad8,    0x040adc,    0x0417f8,    0x041e20,    // 40
    0x041e24,    0x041e40,    0x041e44,    0x041e48,    // 44
    0x041e4c,    0x041e50,    0x041e54,    0x041e58,    // 48
    0x041e5c,    0x041e60,    0x041d90,    0x041e74,    // 52
    0x041e78,    0x040354,    0x04033c,    0x040304,    // 56
    0x040300,    0x040340,    0x040344,    0x040348,    // 60
    0x04035c,    0x040310,    0x04037c,    0x040358,    // 64
    0x040374,    0x040378,    0x040364,    0x040368,    // 68
    0x04036c,    0x040360,    0x040350,    0x04034c,    // 72
    0x0409f8,    0x040384,    0x040388,    0x040330,    // 76
    0x040334,    0x040338,    
};

D3DCONST DWORD D3DTEXTUREDIRECTENCODE[] =
{ 
    0x081b00,    0x081b40,    0x081b80,    0x081bc0,
};
     
#define D3DDIRTYFLAG_TEXTURE_STATE                0x0000000f
#define D3DDIRTYFLAG_TEXTURE_STATE_0              0x00000001
#define D3DDIRTYFLAG_TEXTURE_STATE_1              0x00000002
#define D3DDIRTYFLAG_TEXTURE_STATE_2              0x00000004
#define D3DDIRTYFLAG_TEXTURE_STATE_3              0x00000008
#define D3DDIRTYFLAG_VERTEXFORMAT                 0x00000070
#define D3DDIRTYFLAG_VERTEXFORMAT_VB              0x00000010
#define D3DDIRTYFLAG_VERTEXFORMAT_UP              0x00000020
#define D3DDIRTYFLAG_VERTEXFORMAT_OFFSETS         0x00000040
#define D3DDIRTYFLAG_POINTPARAMS                  0x00000100
#define D3DDIRTYFLAG_TRANSFORM                    0x00000200
#define D3DDIRTYFLAG_TEXTURE_TRANSFORM            0x00000400
#define D3DDIRTYFLAG_COMBINERS                    0x00000800
#define D3DDIRTYFLAG_LIGHTS                       0x00001000
#define D3DDIRTYFLAG_SPECFOG_COMBINER             0x00002000
#define D3DDIRTYFLAG_SHADER_STAGE_PROGRAM         0x00004000

D3DCONST DWORD D3DDIRTYFROMRENDERSTATE[] =
{
    D3DDIRTYFLAG_SPECFOG_COMBINER,                      // D3DRS_FOGENABLE                 
    D3DDIRTYFLAG_SPECFOG_COMBINER,                      // D3DRS_FOGTABLEMODE              
    D3DDIRTYFLAG_SPECFOG_COMBINER,                      // D3DRS_FOGSTART                  
    D3DDIRTYFLAG_SPECFOG_COMBINER,                      // D3DRS_FOGEND                    
    D3DDIRTYFLAG_SPECFOG_COMBINER,                      // D3DRS_FOGDENSITY                
    D3DDIRTYFLAG_SPECFOG_COMBINER,                      // D3DRS_RANGEFOGENABLE            
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DRS_WRAP0                     
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DRS_WRAP1                     
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DRS_WRAP2                     
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DRS_WRAP3                     
    // D3DRS_LIGHTING dirties the transform because of the inverse-model-
    // view optimization:
    (D3DDIRTYFLAG_LIGHTS | D3DDIRTYFLAG_TRANSFORM),     // D3DRS_LIGHTING                   
    (D3DDIRTYFLAG_LIGHTS | D3DDIRTYFLAG_SPECFOG_COMBINER),// D3DRS_SPECULARENABLE             
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_LOCALVIEWER                
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_COLORVERTEX                
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_BACKSPECULARMATERIALSOURCE 
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_BACKDIFFUSEMATERIALSOURCE  
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_BACKAMBIENTMATERIALSOURCE  
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_BACKEMISSIVEMATERIALSOURCE 
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_SPECULARMATERIALSOURCE     
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_DIFFUSEMATERIALSOURCE      
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_AMBIENTMATERIALSOURCE      
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_EMISSIVEMATERIALSOURCE     
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_BACKAMBIENT                
    D3DDIRTYFLAG_LIGHTS,                                // D3DRS_AMBIENT                    
    D3DDIRTYFLAG_POINTPARAMS,                           // D3DRS_POINTSIZE                 
    D3DDIRTYFLAG_POINTPARAMS,                           // D3DRS_POINTSIZE_MIN             
    (D3DDIRTYFLAG_POINTPARAMS | D3DDIRTYFLAG_COMBINERS),// D3DRS_POINTSPRITEENABLE         
    D3DDIRTYFLAG_POINTPARAMS,                           // D3DRS_POINTSCALEENABLE          
    D3DDIRTYFLAG_POINTPARAMS,                           // D3DRS_POINTSCALE_A              
    D3DDIRTYFLAG_POINTPARAMS,                           // D3DRS_POINTSCALE_B              
    D3DDIRTYFLAG_POINTPARAMS,                           // D3DRS_POINTSCALE_C              
    D3DDIRTYFLAG_POINTPARAMS,                           // D3DRS_POINTSIZE_MAX             
    0,                                                  // D3DRS_PATCHEDGESTYLE            
    0,                                                  // D3DRS_PATCHSEGMENTS             
    0,                                                  // D3DRS_MULTISAMPLEFILTER
};

D3DCONST DWORD D3DDIRTYFROMTEXTURESTATE[] =
{
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_ADDRESSU
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_ADDRESSV
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_ADDRESSW
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_MAGFILTER
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_MINFILTER
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_MIPFILTER
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_MIPMAPLODBIAS
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_MAXMIPLEVEL
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_MAXANISOTROPY
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_COLORKEYOP
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_COLORSIGN
    D3DDIRTYFLAG_TEXTURE_STATE,                         // D3DTSS_ALPHAKILL
    (D3DDIRTYFLAG_COMBINERS | D3DDIRTYFLAG_SHADER_STAGE_PROGRAM | D3DDIRTYFLAG_TEXTURE_STATE),
                                                        // D3DTSS_COLOROP (special cased)
    D3DDIRTYFLAG_COMBINERS,                             // D3DTSS_COLORARG0           
    D3DDIRTYFLAG_COMBINERS,                             // D3DTSS_COLORARG1           
    D3DDIRTYFLAG_COMBINERS,                             // D3DTSS_COLORARG2           
    D3DDIRTYFLAG_COMBINERS,                             // D3DTSS_ALPHAOP             
    D3DDIRTYFLAG_COMBINERS,                             // D3DTSS_ALPHAARG0           
    D3DDIRTYFLAG_COMBINERS,                             // D3DTSS_ALPHAARG1           
    D3DDIRTYFLAG_COMBINERS,                             // D3DTSS_ALPHAARG2           
    D3DDIRTYFLAG_COMBINERS,                             // D3DTSS_RESULTARG           
    D3DDIRTYFLAG_TEXTURE_TRANSFORM,                     // D3DTSS_TEXTURETRANSFORMFLAGS
};

// Macro for converting from primitive count to number of vertices.
//
#define D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount) \
    ((PrimitiveCount) * D3DPRIMITIVETOVERTEXCOUNT[PrimitiveType][0] + \
     + D3DPRIMITIVETOVERTEXCOUNT[PrimitiveType][1])

/****************************************************************************
 *
 * Publicly accessible globals - Feel free to modify the values.
 *
 ****************************************************************************/

// 'Extern' declaration that is both C and C++ friendly.
//
#ifdef __cplusplus
    #define D3DEXTERN extern "C"
#else
    #define D3DEXTERN extern
#endif

// Set D3D__NullHardware to TRUE to enable infinitely fast hardware (so fast 
// you can't even see the results).  This is useful for determining how CPU-
// bound your program is.
//
D3DEXTERN BOOL D3D__NullHardware; 

// Set D3D__SingleStepPusher to TRUE to cause D3D to do an implicit 
// BlockUntilIdle after every D3D API call.  This is useful for tracking
// weird hardware crashes and hangs down to the problem API call.
// 
D3DEXTERN BOOL D3D__SingleStepPusher;

/****************************************************************************
 *
 * Private D3D globals - Please don't use these directly, as they're subject
 *                       subject to change.
 *
 ****************************************************************************/

// This array marks what APIs have been called when recording state blocks:
//
D3DEXTERN BYTE D3D__StateBlockDirty[];

// This array shadows the current render states:
//
D3DEXTERN DWORD D3D__RenderState[D3DRS_MAX];

// This array shadows the current texture stage states:
//
D3DEXTERN DWORD D3D__TextureState[D3DTSS_MAXSTAGES][D3DTSS_MAX];

// This array contains the dirty flags for deferred render and texture states:
//
D3DEXTERN DWORD D3D__DirtyFlags;

// This points to the data of the currently selected index buffer.  This is
// used for converting Draw[Indexed]Primitive calls to Draw[Indexed]Vertices
// calls inline.
//
D3DEXTERN WORD* D3D__IndexData;

/****************************************************************************
 *
 * Miscellaneous public defines
 *
 ****************************************************************************/

// The required alignment for any memory that is going to be
// rendered to from the hardware.
//
#define D3D_RENDER_MEMORY_ALIGNMENT           64

// The required alignment for any memory that is tiled, including the
// default frame buffers and depth buffer.
//
#define D3D_TILED_SURFACE_ALIGNMENT           0x4000

// Types of our DPC-level callback functions.
//
typedef void (__cdecl * D3DCALLBACK)(DWORD Context);
typedef void (__cdecl * D3DVBLANKCALLBACK)(D3DVBLANKDATA *pData);
typedef void (__cdecl * D3DSWAPCALLBACK)(D3DSWAPDATA *pData);

/*
 * NOTE: The C version of the methods for all of these interfaces
 *       are named "<interfacename>_<method name>" and have an 
 *       explicit pointer to the interface as the first parameter.
 *       The actual definition of these methods is at the end
 *       of this file.
 */

/*
 * Direct3D, IDirect3D8 interface
 *
 */

#ifdef __cplusplus

struct Direct3D
{
    static ULONG WINAPI AddRef();
    static ULONG WINAPI Release();

    static UINT WINAPI GetAdapterCount();

    static HRESULT WINAPI GetAdapterIdentifier(UINT Adapter, DWORD Flags, D3DADAPTER_IDENTIFIER8 *pIdentifier);
    static UINT    WINAPI GetAdapterModeCount(UINT Adapter);
    static HRESULT WINAPI EnumAdapterModes(UINT Adapter, UINT Mode, D3DDISPLAYMODE *pMode);
    static HRESULT WINAPI GetAdapterDisplayMode(UINT Adapter, D3DDISPLAYMODE *pMode);
    static HRESULT WINAPI CheckDeviceType(UINT Adapter, D3DDEVTYPE CheckType, D3DFORMAT DisplayFormat, D3DFORMAT BackBufferFormat, BOOL Windowed);
    static HRESULT WINAPI CheckDeviceFormat(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, DWORD Usage, D3DRESOURCETYPE RType, D3DFORMAT CheckFormat);
    static HRESULT WINAPI CheckDeviceMultiSampleType(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT SurfaceFormat, BOOL Windowed, D3DMULTISAMPLE_TYPE MultiSampleType);
    static HRESULT WINAPI CheckDepthStencilMatch(UINT Adapter,D3DDEVTYPE DeviceType,D3DFORMAT AdapterFormat,D3DFORMAT RenderTargetFormat,D3DFORMAT DepthStencilFormat);
    static HRESULT WINAPI GetDeviceCaps(UINT Adapter,D3DDEVTYPE DeviceType,D3DCAPS8 *pCaps);
    static HRESULT WINAPI CreateDevice(UINT Adapter, D3DDEVTYPE DeviceType, void *pUnused, DWORD BehaviorFlags, D3DPRESENT_PARAMETERS *pPresentationParameters, D3DDevice **ppReturnedDeviceInterface);
    static HRESULT WINAPI SetPushBufferSize(DWORD PushBufferSize, DWORD KickOffSize); // Xbox extension
};

#endif __cplusplus

/*
 * D3DDevice, IDirect3DDevice8 interface
 */

#ifdef __cplusplus

struct D3DDevice
{
    // Standard D3D APIs:

    static ULONG WINAPI AddRef();
    static ULONG WINAPI Release();
    static HRESULT WINAPI GetDirect3D(Direct3D **ppD3D8);
    static HRESULT WINAPI GetDeviceCaps(D3DCAPS8 *pCaps);
    static HRESULT WINAPI GetDisplayMode(D3DDISPLAYMODE *pMode);
    static HRESULT WINAPI GetCreationParameters(D3DDEVICE_CREATION_PARAMETERS *pParameters);
    static HRESULT WINAPI Reset(D3DPRESENT_PARAMETERS *pPresentationParameters);
    static HRESULT WINAPI Present(CONST RECT *pSourceRect, CONST RECT *pDestRect, void *pUnused, void *pUnused2);
    static HRESULT WINAPI GetBackBuffer(INT BackBuffer, D3DBACKBUFFER_TYPE Type, D3DSurface **ppBackBuffer);
    static HRESULT WINAPI GetRasterStatus(D3DRASTER_STATUS *pRasterStatus);
    static void    WINAPI SetGammaRamp(DWORD Flags, CONST D3DGAMMARAMP *pRamp);
    static void    WINAPI GetGammaRamp(D3DGAMMARAMP *pRamp);
    static HRESULT WINAPI CreateTexture(UINT Width, UINT Height, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DTexture **ppTexture);
    static HRESULT WINAPI CreateVolumeTexture(UINT Width, UINT Height, UINT Depth, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DVolumeTexture **ppVolumeTexture);
    static HRESULT WINAPI CreateCubeTexture(UINT EdgeLength, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DCubeTexture **ppCubeTexture);
    static HRESULT WINAPI CreateVertexBuffer(UINT Length, DWORD Usage, DWORD FVF, D3DPOOL Pool, D3DVertexBuffer **ppVertexBuffer);
    static HRESULT WINAPI CreateIndexBuffer(UINT Length, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DIndexBuffer **ppIndexBuffer);
    static HRESULT WINAPI CreateRenderTarget(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, BOOL Lockable, D3DSurface **ppSurface);
    static HRESULT WINAPI CreateDepthStencilSurface(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, D3DSurface **ppSurface);
    static HRESULT WINAPI CreateImageSurface(UINT Width, UINT Height, D3DFORMAT Format, D3DSurface **ppSurface);
    static HRESULT WINAPI CopyRects(D3DSurface *pSourceSurface, CONST RECT *pSourceRectsArray, UINT cRects, D3DSurface *pDestinationSurface, CONST POINT *pDestPointsArray);
    static HRESULT WINAPI SetRenderTarget(D3DSurface *pRenderTarget, D3DSurface *pNewZStencil);
    static HRESULT WINAPI GetRenderTarget(D3DSurface **ppRenderTarget);
    static HRESULT WINAPI GetDepthStencilSurface(D3DSurface **ppZStencilSurface);
    static HRESULT WINAPI BeginScene();
    static HRESULT WINAPI EndScene();
    static HRESULT WINAPI Clear(DWORD Count, CONST D3DRECT *pRects, DWORD Flags, D3DCOLOR Color, float Z, DWORD Stencil);
    static HRESULT WINAPI SetTransform(D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix);
    static HRESULT WINAPI GetTransform(D3DTRANSFORMSTATETYPE State, D3DMATRIX *pMatrix);
    static HRESULT WINAPI MultiplyTransform(D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix);
    static HRESULT WINAPI SetViewport(CONST D3DVIEWPORT8 *pViewport);
    static HRESULT WINAPI GetViewport(D3DVIEWPORT8 *pViewport);
    static HRESULT WINAPI SetMaterial(CONST D3DMATERIAL8 *pMaterial);
    static HRESULT WINAPI GetMaterial(D3DMATERIAL8 *pMaterial);
    static HRESULT WINAPI SetLight(DWORD Index, CONST D3DLIGHT8 *pLight);
    static HRESULT WINAPI GetLight(DWORD Index, D3DLIGHT8 *pLight);
    static HRESULT WINAPI LightEnable(DWORD Index, BOOL Enable);
    static HRESULT WINAPI GetLightEnable(DWORD Index, BOOL *pEnable);
    static HRESULT WINAPI SetRenderState(D3DRENDERSTATETYPE State, DWORD Value);
    static HRESULT WINAPI GetRenderState(D3DRENDERSTATETYPE State, DWORD *pValue);
#if D3DCOMPILE_BEGINSTATEBLOCK
    static HRESULT WINAPI BeginStateBlock();
    static HRESULT WINAPI EndStateBlock(DWORD *pToken);
#endif
    static HRESULT WINAPI ApplyStateBlock(DWORD Token);
    static HRESULT WINAPI CaptureStateBlock(DWORD Token);
    static HRESULT WINAPI DeleteStateBlock(DWORD Token);
    static HRESULT WINAPI CreateStateBlock(D3DSTATEBLOCKTYPE Type,DWORD *pToken);
    static HRESULT WINAPI GetTexture(DWORD Stage, D3DBaseTexture **ppTexture);
    static HRESULT WINAPI SetTexture(DWORD Stage, D3DBaseTexture *pTexture);
    static HRESULT WINAPI GetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD *pValue);
    static HRESULT WINAPI SetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value);
    static HRESULT WINAPI DrawPrimitive(D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT PrimitiveCount);
    static HRESULT WINAPI DrawIndexedPrimitive(D3DPRIMITIVETYPE, UINT MinIndex, UINT NumIndices, UINT StartIndex, UINT PrimitiveCount);
    static HRESULT WINAPI DrawPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType, UINT PrimitiveCount, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride);
    static HRESULT WINAPI DrawIndexedPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType, UINT MinVertexIndex, UINT NumVertexIndices, UINT PrimitiveCount, CONST void *pIndexData, D3DFORMAT IndexDataFormat, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride);
    static HRESULT WINAPI CreateVertexShader(CONST DWORD *pDeclaration, CONST DWORD *pFunction, DWORD *pHandle, DWORD Usage);
    static HRESULT WINAPI SetVertexShader(DWORD Handle);
    static HRESULT WINAPI GetVertexShader(DWORD *pHandle);
    static HRESULT WINAPI DeleteVertexShader(DWORD Handle);
    static HRESULT WINAPI SetVertexShaderConstant(INT Register, CONST void *pConstantData, DWORD ConstantCount);
    static HRESULT WINAPI GetVertexShaderConstant(INT Register, void *pConstantData, DWORD ConstantCount);
    static HRESULT WINAPI GetVertexShaderDeclaration(DWORD Handle, void *pData, DWORD *pSizeOfData);
    static HRESULT WINAPI GetVertexShaderFunction(DWORD Handle,void *pData, DWORD *pSizeOfData);
    static HRESULT WINAPI SetStreamSource(UINT StreamNumber, D3DVertexBuffer *pStreamData, UINT Stride);
    static HRESULT WINAPI GetStreamSource(UINT StreamNumber, D3DVertexBuffer **ppStreamData, UINT *pStride);
    static HRESULT WINAPI SetIndices(D3DIndexBuffer *pIndexData, UINT BaseVertexIndex);
    static HRESULT WINAPI GetIndices(D3DIndexBuffer **ppIndexData, UINT *pBaseVertexIndex);
    static HRESULT WINAPI CreatePixelShader(CONST D3DPIXELSHADERDEF *pPSDef, DWORD *pHandle);
    static HRESULT WINAPI SetPixelShader(DWORD Handle);
    static HRESULT WINAPI SetPixelShaderProgram(CONST D3DPIXELSHADERDEF *pPSDef);
    static HRESULT WINAPI GetPixelShader(DWORD *pHandle);
    static HRESULT WINAPI DeletePixelShader(DWORD Handle);
    static HRESULT WINAPI SetPixelShaderConstant(DWORD Register, CONST void *pConstantData, DWORD ConstantCount);
    static HRESULT WINAPI GetPixelShaderConstant(DWORD Register, void *pConstantData, DWORD ConstantCount);
    static HRESULT WINAPI GetPixelShaderFunction(DWORD Handle, D3DPIXELSHADERDEF *pData);
    static HRESULT WINAPI DrawRectPatch(UINT Handle, CONST float *pNumSegs, CONST D3DRECTPATCH_INFO *pRectPatchInfo);
    static HRESULT WINAPI DrawTriPatch(UINT Handle, CONST float *pNumSegs, CONST D3DTRIPATCH_INFO *pTriPatchInfo);
    static HRESULT WINAPI DeletePatch(UINT Handle);

    // The following APIs are all Xbox extensions:

    static HRESULT WINAPI SetShaderConstantMode(D3DSHADERCONSTANTMODE Mode);
    static HRESULT WINAPI GetShaderConstantMode(D3DSHADERCONSTANTMODE *pMode);
    static HRESULT WINAPI LoadVertexShader(DWORD Handle, DWORD Address);
    static HRESULT WINAPI LoadVertexShaderProgram(CONST DWORD *pFunction, DWORD Address);
    static HRESULT WINAPI SelectVertexShader(DWORD Handle, DWORD Address);
    static HRESULT WINAPI SelectVertexShaderDirect(D3DVERTEXATTRIBUTEFORMAT *pVAF, DWORD Address);
    static HRESULT WINAPI RunVertexStateShader(DWORD Address, CONST float *pData);
    static HRESULT WINAPI GetVertexShaderSize(DWORD Handle, UINT *pSize);
    static HRESULT WINAPI GetVertexShaderType(DWORD Handle, DWORD *pType);
    static HRESULT WINAPI DrawVertices(D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT VertexCount);
    static HRESULT WINAPI DrawIndexedVertices(D3DPRIMITIVETYPE, UINT VertexCount, CONST WORD *pIndexData);
    static HRESULT WINAPI DrawVerticesUP(D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride);
    static HRESULT WINAPI DrawIndexedVerticesUP(D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST void *pIndexData, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride);
    static HRESULT WINAPI PrimeVertexCache(UINT VertexCount, CONST WORD *pIndexData);
    static HRESULT WINAPI CreatePalette(D3DPALETTESIZE Size, D3DPalette **ppPalette);
    static HRESULT WINAPI GetPalette(DWORD Stage, D3DPalette **ppPalette);
    static HRESULT WINAPI SetPalette(DWORD Stage, D3DPalette *pPalette);
    static HRESULT WINAPI SetTextureStageStateNotInline(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value);
    static HRESULT WINAPI SetRenderStateNotInline(D3DRENDERSTATETYPE State, DWORD Value);
    static HRESULT WINAPI SetBackMaterial(CONST D3DMATERIAL8 *pMaterial);
    static HRESULT WINAPI GetBackMaterial(D3DMATERIAL8 *pMaterial);
    static HRESULT WINAPI UpdateOverlay(D3DSurface *pSurface, CONST RECT *SrcRect, CONST RECT *DstRect, BOOL EnableColorKey, D3DCOLOR ColorKey);
    static HRESULT WINAPI EnableOverlay(BOOL Enable);
    static HRESULT WINAPI BeginVisibilityTest();
    static HRESULT WINAPI EndVisibilityTest(DWORD Index);
    static HRESULT WINAPI GetVisibilityTestResult(DWORD Index, UINT* pResult, ULONGLONG* pTimeStamp);
    static BOOL    WINAPI GetOverlayUpdateStatus();
    static HRESULT WINAPI GetDisplayFieldStatus(D3DFIELD_STATUS *pFieldStatus);
    static HRESULT WINAPI SetVertexData2f(INT Register, float a, float b);
    static HRESULT WINAPI SetVertexData4f(INT Register, float a, float b, float c, float d);
    static HRESULT WINAPI SetVertexData2s(INT Register, SHORT a, SHORT b);
    static HRESULT WINAPI SetVertexData4s(INT Register, SHORT a, SHORT b, SHORT c, SHORT d);
    static HRESULT WINAPI SetVertexData4ub(INT Register, BYTE a, BYTE b, BYTE c, BYTE d);
    static HRESULT WINAPI SetVertexDataColor(INT Register, D3DCOLOR Color);
    static HRESULT WINAPI Begin(D3DPRIMITIVETYPE PrimitiveType);
    static HRESULT WINAPI End();
    static HRESULT WINAPI CreateFixup(UINT Size, D3DFixup **ppFixup);
    static HRESULT WINAPI CreatePushBuffer(UINT Size, BOOL RunUsingCpuCopy, D3DPushBuffer **ppPushBuffer);
    static HRESULT WINAPI BeginPushBuffer(D3DPushBuffer *pPushBuffer);
    static HRESULT WINAPI EndPushBuffer();
    static HRESULT WINAPI RunPushBuffer(D3DPushBuffer* pPushBuffer, D3DFixup *pFixup);
    static HRESULT WINAPI GetPushBufferOffset(DWORD* pOffset);
    static HRESULT WINAPI Nop();
    static HRESULT WINAPI GetProjectionViewportMatrix(D3DMATRIX* pProjectionViewport);
    static HRESULT WINAPI SetModelView(CONST D3DMATRIX* pModelView, CONST D3DMATRIX* pInverseModelView, CONST D3DMATRIX* pComposite);
    static HRESULT WINAPI GetModelView(D3DMATRIX* pModelView);
    static HRESULT WINAPI SetVertexBlendModelView(UINT Count, CONST D3DMATRIX* pModelViews, CONST D3DMATRIX* pInverseModelViews, CONST D3DMATRIX* pProjectionViewport);
    static HRESULT WINAPI GetVertexBlendModelView(UINT Count, D3DMATRIX* pModelViews, D3DMATRIX* pProjectionViewport);
    static HRESULT WINAPI SetVertexShaderInput(DWORD Handle, UINT StreamCount, CONST D3DSTREAM_INPUT* pStreamInputs);
    static HRESULT WINAPI SetVertexShaderInputDirect(D3DVERTEXATTRIBUTEFORMAT *pVAF, UINT StreamCount, CONST D3DSTREAM_INPUT* pStreamInputs);
    static HRESULT WINAPI GetVertexShaderInput(DWORD* pHandle, UINT* pStreamCount, D3DSTREAM_INPUT* pStreamInputs);
    static HRESULT WINAPI SwitchTexture(DWORD Stage, D3DBaseTexture *pTexture);
    static HRESULT WINAPI Suspend();
    static HRESULT WINAPI Resume(BOOL Reset);
    static HRESULT WINAPI SetScissors(DWORD Count, BOOL Exclusive, CONST D3DRECT *pRects);
    static HRESULT WINAPI GetScissors(DWORD* pCount, BOOL *pExclusive, D3DRECT *pRects);
    static HRESULT WINAPI SetTile(DWORD Index, CONST D3DTILE* pTile);
    static HRESULT WINAPI GetTile(DWORD Index, D3DTILE* pTile);
    static DWORD   WINAPI GetTileCompressionTags(DWORD ZStartTag, DWORD ZEndTag);
    static void    WINAPI SetTileCompressionTagBits(DWORD Partition, DWORD Address, CONST DWORD *pData, DWORD Count);
    static void    WINAPI GetTileCompressionTagBits(DWORD Partition, DWORD Address, DWORD *pData, DWORD Count);
    static HRESULT WINAPI BeginPush(DWORD Count, DWORD **ppPush);
    static HRESULT WINAPI EndPush(DWORD *pPush);
    static BOOL    WINAPI IsBusy();
    static void    WINAPI BlockUntilIdle();
    static void    WINAPI KickPushBuffer();
    static void    WINAPI SetVerticalBlankCallback(D3DVBLANKCALLBACK pCallback);
    static void    WINAPI SetSwapCallback(D3DSWAPCALLBACK pCallback);
    static void    WINAPI BlockUntilVerticalBlank();
    static DWORD   WINAPI InsertFence();
    static BOOL    WINAPI IsFencePending(DWORD Fence);
    static VOID    WINAPI BlockOnFence(DWORD Fence);
    static VOID    WINAPI InsertCallback(D3DCALLBACKTYPE Type, D3DCALLBACK pCallback, DWORD Context);
    static VOID    WINAPI FlushVertexCache();
    static void    WINAPI SetFlickerFilter(DWORD Filter);
    static void    WINAPI SetSoftDisplayFilter(BOOL Enable);
    static HRESULT WINAPI SetCopyRectsState(CONST D3DCOPYRECTSTATE *pCopyRectState, CONST D3DCOPYRECTROPSTATE *pCopyRectRopState);
    static HRESULT WINAPI GetCopyRectsState(D3DCOPYRECTSTATE *pCopyRectState, D3DCOPYRECTROPSTATE *pCopyRectRopState);
    static HRESULT WINAPI PersistDisplay();
    static HRESULT WINAPI GetPersistedSurface(IDirect3DSurface8 **ppSurface);
    static DWORD   WINAPI Swap(DWORD Flags);
    static HRESULT WINAPI SetBackBufferScale(float x, float y);
    static HRESULT WINAPI GetBackBufferScale(float *pX, float *pY);
    static HRESULT WINAPI SetScreenSpaceOffset(float x, float Y);
    static HRESULT WINAPI GetScreenSpaceOffset(float *pX, float *pY);
    static void    WINAPI SetOverscanColor(D3DCOLOR Color);
    static D3DCOLOR WINAPI GetOverscanColor();
    static DWORD   WINAPI SetDebugMarker(DWORD Marker);
    static DWORD   WINAPI GetDebugMarker();
};

#endif __cplusplus

/*
 * D3DResource, IDirect3DResource8 interface
 *
 * The root structure of all D3D 'resources' such as textures and vertex buffers.
 */

#define D3DCOMMON_REFCOUNT_MASK      0x0000FFFF

#define D3DCOMMON_TYPE_MASK          0x00070000
#define D3DCOMMON_TYPE_SHIFT         16
#define D3DCOMMON_TYPE_VERTEXBUFFER  0x00000000
#define D3DCOMMON_TYPE_INDEXBUFFER   0x00010000
#define D3DCOMMON_TYPE_PUSHBUFFER    0x00020000
#define D3DCOMMON_TYPE_PALETTE       0x00030000
#define D3DCOMMON_TYPE_TEXTURE       0x00040000
#define D3DCOMMON_TYPE_SURFACE       0x00050000
#define D3DCOMMON_TYPE_FIXUP         0x00060000

#define D3DCOMMON_INTREFCOUNT_MASK   0x00780000
#define D3DCOMMON_INTREFCOUNT_SHIFT  19

// This flag was used for UMA emulation on pre-Beta development kit
// machines, and is deprecated on the final hardware.
//
#define D3DCOMMON_VIDEOMEMORY        0

// Internal flag to indicate that this resource was created by Direct3D 
//
#define D3DCOMMON_D3DCREATED         0x01000000

// The rest of the bits may be used by derived classes.
#define D3DCOMMON_UNUSED_MASK        0xFE000000
#define D3DCOMMON_UNUSED_SHIFT       25

#ifdef __cplusplus

struct D3DResource
{
    ULONG WINAPI AddRef();

    // DOC:  If the GPU is currently using this object when the last call 
    //   to release is made then this call will block until the GPU is done 
    //   with this object.  The caller will have to manually check this if 
    //   they do not want this call to block.
    //
    ULONG WINAPI Release();

    HRESULT WINAPI GetDevice(D3DDevice **ppDevice);
    D3DRESOURCETYPE WINAPI GetType();

    HRESULT WINAPI SetPrivateData(REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags);
    HRESULT WINAPI GetPrivateData(REFGUID refguid, void *pData, DWORD *pSizeOfData);
    HRESULT WINAPI FreePrivateData(REFGUID refguid);

    // DOC: This additional method returns TRUE if the data for this
    //  : resource is currently being used by the GPU.  This can be used
    //  : to avoid blocking in Release and Lock.  This will always return
    //  : TRUE if the resource is currently set on the device.
    //
    BOOL WINAPI IsBusy();

    // DOC: A blocking form of 'IsBusy' that ensure that this resource is
    //  : no longer used by the GPU.  This will wait for the GPU to go
    //  : idle if this resource is set on the device.
    //
    void    WINAPI BlockUntilNotBusy();

    // DOC: On pre-beta development kits, this API set whether the we should 
    //  ; use video or AGP memory for the data of this resource.  
    //  ;
    //  ; This API has been deprecated on the final hardware.
    //
    void    WINAPI MoveResourceMemory(D3DMEMORY where);

    // DOC: Performs some debug checks and maps the resource's 
    //  : data field from a contiguous memory address to the physical memory
    //  : address.  It should be called for any resource that is not created
    //  : through an D3DDevice "Create" routine.
    //  :
    //  : This API does not modify any state in the resource besides the
    //  : Data field nor does the library keep track of what resources
    //  : have been registered.  
    //  :
    //  : This method takes a contiguous memory address, adds the current
    //  : contents of the Data field to it, converts it to a physical
    //  : address and sets that as the Data field of the resource.
    //
    void    WINAPI Register(void *pBase);

    // All resources need these fields.  Inherit them in C++.

    DWORD Common;           // Refcount and flags common to all resources
    DWORD Data;             // Offset to the data held by this resource
    DWORD Lock;             // Lock information, initialize to zero
};

#endif __cplusplus

/*
 * D3DPixelContainer interface
 *
 * A base structure that describes the shared layout between textures
 * and surfaces.
 */

// The layout of the Format field.

#define D3DFORMAT_RESERVED1_MASK        0x00000003      // Must be zero
                                        
#define D3DFORMAT_DMACHANNEL_MASK       0x00000003
#define D3DFORMAT_DMACHANNEL_A          0x00000001      // DMA channel A - the default for all system memory
#define D3DFORMAT_DMACHANNEL_B          0x00000002      // DMA channel B - unused
#define D3DFORMAT_CUBEMAP               0x00000004      // Set if the texture if a cube map
#define D3DFORMAT_BORDERSOURCE_COLOR    0x00000008
#define D3DFORMAT_DIMENSION_MASK        0x000000F0      // # of dimensions
#define D3DFORMAT_DIMENSION_SHIFT       4
#define D3DFORMAT_FORMAT_MASK           0x0000FF00
#define D3DFORMAT_FORMAT_SHIFT          8
#define D3DFORMAT_MIPMAP_MASK           0x000F0000 
#define D3DFORMAT_MIPMAP_SHIFT          16
#define D3DFORMAT_USIZE_MASK            0x00F00000      // Log 2 of the U size of the base texture
#define D3DFORMAT_USIZE_SHIFT           20
#define D3DFORMAT_VSIZE_MASK            0x0F000000      // Log 2 of the V size of the base texture
#define D3DFORMAT_VSIZE_SHIFT           24
#define D3DFORMAT_PSIZE_MASK            0xF0000000      // Log 2 of the P size of the base texture
#define D3DFORMAT_PSIZE_SHIFT           28

// The layout of the size field, used for non swizzled or compressed textures.
// 
// The Size field of a container will be zero if the texture is swizzled or compressed.
// It is guarenteed to be non-zero otherwise because either the height/width will be 
// greater than one or the pitch adjust will be nonzero because the minimum texture
// pitch is 8 bytes.

#define D3DSIZE_WIDTH_MASK              0x00000FFF   // Width of the texture - 1, in texels
#define D3DSIZE_HEIGHT_MASK             0x00FFF000   // Height of the texture - 1, in texels
#define D3DSIZE_HEIGHT_SHIFT            12
#define D3DSIZE_PITCH_MASK              0xFF000000   // Pitch / 64 - 1
#define D3DSIZE_PITCH_SHIFT             24

#define D3DTEXTURE_ALIGNMENT            128
#define D3DTEXTURE_CUBEFACE_ALIGNMENT   128

#define D3DTEXTURE_PITCH_ALIGNMENT 64
#define D3DTEXTURE_PITCH_MIN       64

#ifdef __cplusplus

struct D3DPixelContainer : public D3DResource
{
    DWORD Format;   // Format information about the texture.
    DWORD Size;     // Size of a non power-of-2 texture, must be zero otherwise
};

#endif __cplusplus

/*
 * D3DBaseTexture interface
 *
 * The root structure of all D3D textures.  Inherits all of the methods
 * from D3DResource.
 *
 * The data memory pointed to by the Data field must be aligned on a
 * D3DTEXTURE_ALIGNMENT byte multiple.
 */

struct D3DBaseTexture
    #ifdef __cplusplus
        : public D3DPixelContainer
    #endif
{

#ifdef __cplusplus
    DWORD WINAPI GetLevelCount();
#endif

#ifndef __cplusplus

    // Manually inherit these from D3DResource
    DWORD Common;
    DWORD Data;
    DWORD Lock;

    DWORD Format;   // Format information about the texture.
    DWORD Size;     // Size of a non power-of-2 texture, must be zero otherwise
#endif

};


/*
 * D3DTexture, IDirect3DTexture8 interface
 *
 * A normal texture.  Inherits from D3DBaseTexture
 */

#ifdef __cplusplus

struct D3DTexture : public D3DBaseTexture
{
    HRESULT WINAPI GetLevelDesc(UINT Level, D3DSURFACE_DESC *pDesc);
    HRESULT WINAPI GetSurfaceLevel(UINT Level, D3DSurface **ppSurfaceLevel);
    HRESULT WINAPI LockRect(UINT Level, D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags);
    HRESULT WINAPI UnlockRect(UINT Level);
};

#endif __cplusplus


/*
 * D3DVolumeTexture, IDirect3DVolumeTexture8 interface
 *
 * A volume texture.  Inherits from D3DBaseTexture
 */

#ifdef __cplusplus

struct D3DVolumeTexture : public D3DBaseTexture
{
    HRESULT WINAPI GetLevelDesc(UINT Level, D3DVOLUME_DESC *pDesc);
    HRESULT WINAPI GetVolumeLevel(UINT Level, D3DVolume **ppVolumeLevel);
    HRESULT WINAPI LockBox(UINT Level, D3DLOCKED_BOX *pLockedVolume, CONST D3DBOX *pBox, DWORD Flags);
    HRESULT WINAPI UnlockBox(UINT Level);
};

#endif __cplusplus


/*
 * D3DCubeTexture, IDirect3DCubeTexture8 interface
 *
 * A cube texture.  Inherits from D3DBaseTexture
 */

#ifdef __cplusplus

struct D3DCubeTexture : public D3DBaseTexture
{
    HRESULT WINAPI GetLevelDesc(UINT Level, D3DSURFACE_DESC *pDesc);
    HRESULT WINAPI GetCubeMapSurface(D3DCUBEMAP_FACES FaceType, UINT Level, D3DSurface **ppCubeMapSurface);
    HRESULT WINAPI LockRect(D3DCUBEMAP_FACES FaceType, UINT Level, D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags);
    HRESULT WINAPI UnlockRect(D3DCUBEMAP_FACES FaceType, UINT Level);
};

#endif __cplusplus


/*
 * D3DVertexBuffer, IDirect3DVertexBuffer8 interface
 *
 * A vertex buffer.
 *
 * The data for the vertex buffer must be aligned on a 
 * D3DVERTEXBUFFER_ALIGNMENT byte multiple.
 */

#define D3DVERTEXBUFFER_ALIGNMENT     4    

struct D3DVertexBuffer
    #ifdef __cplusplus
        : public D3DResource
    #endif
{
#ifdef __cplusplus

    HRESULT WINAPI Lock(UINT OffsetToLock, UINT SizeToLock, BYTE **ppbData, DWORD Flags);
    HRESULT WINAPI Unlock();
    HRESULT WINAPI GetDesc(D3DVERTEXBUFFER_DESC *pDesc);

#endif __cplusplus

#ifndef __cplusplus

    // Manually inherit these from D3DResource
    DWORD Common;
    DWORD Data;
    DWORD Lock;

#endif

};


/*
 * D3DIndexBuffer, IDirect3DIndexBuffer8 interface
 *
 * An index buffer.
 *
 * The data for the index buffer must be aligned on a D3DINDEXBUFFER_ALIGNMENT
 * byte multiple.
 */

#define D3DINDEXBUFFER_ALIGNMENT        4      

struct D3DIndexBuffer
    #ifdef __cplusplus
        : public D3DResource
    #endif
{
#ifdef __cplusplus

    HRESULT WINAPI Lock(UINT OffsetToLock, UINT SizeToLock, BYTE **ppbData, DWORD Flags);
    HRESULT WINAPI Unlock();
    HRESULT WINAPI GetDesc(D3DINDEXBUFFER_DESC *pDesc);

#endif __cplusplus

#ifndef __cplusplus

    // Manually inherit these from D3DResource
    DWORD Common;                    
    DWORD Data;
    DWORD Lock;

#endif

};


/*
 * D3DPalette, IDirect3DPalette8 interface
 *
 * A palette.
 */

#define D3DPALETTE_ALIGNMENT 64

#define D3DPALETTE_COMMON_VIDEOMEMORY            0
#define D3DPALETTE_COMMON_UNUSED                 0x20000000
#define D3DPALETTE_COMMON_PALETTESIZE_MASK       0xC0000000
#define D3DPALETTE_COMMON_PALETTESIZE_SHIFT      30

#define D3DPALETTE_COMMON_PALETTESET_SHIFT       28
#define D3DPALETTE_COMMON_PALETTESET_MASK        0xF

struct D3DPalette
    #ifdef __cplusplus
        : public D3DResource
    #endif
{
#ifdef __cplusplus

    HRESULT WINAPI Lock(D3DCOLOR **ppColors, DWORD Flags);
    HRESULT WINAPI Unlock();
    D3DPALETTESIZE WINAPI GetSize();

#endif __cplusplus

#ifndef __cplusplus

    // Manually inherit these from D3DResource
    DWORD Common;
    DWORD Data;
    DWORD Lock;

#endif

};


/*
 * D3DSurface, IDirect3DSurface8 interface
 *
 * Abstracts a chunk of data that can be drawn to.  The Common and Format
 * fields use the D3DCOMMON and D3DFORMAT constants defined for
 * textures.
 */

#define D3DSURFACE_ALIGNMENT    D3D_RENDER_MEMORY_ALIGNMENT
#define D3DSURFACE_OWNSMEMORY   0x80000000

struct D3DSurface
    #if defined(__cplusplus)
        : public D3DPixelContainer
    #endif
{
#ifdef __cplusplus

    HRESULT WINAPI GetContainer(D3DBaseTexture **ppBaseTexture);
    HRESULT WINAPI GetDesc(D3DSURFACE_DESC *pDesc);
    HRESULT WINAPI LockRect(D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags);
    HRESULT WINAPI UnlockRect();

#endif __cplusplus

#ifndef __cplusplus

    // Manually inherit these from D3DPixelContainer
    DWORD Common;
    DWORD Data;
    DWORD Lock;
    DWORD Format;
    DWORD Size;

#endif

    D3DBaseTexture *Parent; 
};


/*
 * D3DVolume, IDirect3DVolume8 interface
 */

#define D3DVOLUME_ALIGNMENT    D3D_RENDER_MEMORY_ALIGNMENT
#define D3DVOLUME_OWNSMEMORY   0x800000000

struct D3DVolume
    #if defined(__cplusplus)
        : public D3DPixelContainer
    #endif
{
#ifdef __cplusplus

    HRESULT WINAPI GetContainer(D3DBaseTexture **ppBaseTexture);
    HRESULT WINAPI GetDesc(D3DVOLUME_DESC *pDesc);
    HRESULT WINAPI LockBox(D3DLOCKED_BOX *pLockedVolume, CONST D3DBOX *pBox, DWORD Flags);
    HRESULT WINAPI UnlockBox();

#endif

#ifndef __cplusplus

    // Manually inherit these from D3DResource
    DWORD Common;
    DWORD Data;
    DWORD Lock;
    DWORD Format; 
    DWORD Size;

#endif

    D3DBaseTexture *Parent; 
};


/*
 * D3DPushBuffer, IDirect3DPushBuffer8 interface
 *
 * A push-buffer resource.
 */

#define D3DPUSHBUFFER_ALIGNMENT 4

// The following flag, when set in the Common field, dictates that when 
// RunPushBuffer is called, the push-buffer is copied using the CPU instead 
// of executed in-place by the GPU.  This should be used for small push-
// buffers to avoid the high latency cost of the GPU JUMP command.  In this
// case, the memory should be cacheable (not write-combined), and need not
// be physically contiguous.
#define D3DPUSHBUFFER_RUN_USING_CPU_COPY  0x80000000

struct D3DPushBuffer
    #ifdef __cplusplus
        : public D3DResource
    #endif
{
#ifdef __cplusplus

    HRESULT WINAPI Verify(BOOL StampResources);
    HRESULT WINAPI BeginFixup(D3DFixup* pFixup, BOOL NoWait);
    HRESULT WINAPI EndFixup();
    HRESULT WINAPI RunPushBuffer(DWORD Offset, D3DPushBuffer* pDestinationPushBuffer, D3DFixup* pDestinationFixup);
    HRESULT WINAPI SetModelView(DWORD Offset, CONST D3DMATRIX* pModelView, CONST D3DMATRIX* pInverseModelView, CONST D3DMATRIX* pComposite);
    HRESULT WINAPI SetVertexBlendModelView(DWORD Offset, UINT Count, CONST D3DMATRIX* pModelViews, CONST D3DMATRIX* pInverseModelViews, CONST D3DMATRIX* pProjectionViewport);
    HRESULT WINAPI SetVertexShaderInput(DWORD Offset, DWORD Handle, UINT StreamCount, CONST D3DSTREAM_INPUT *pStreamInputs);
    HRESULT WINAPI SetVertexShaderInputDirect(DWORD Offset, D3DVERTEXATTRIBUTEFORMAT *pVAF, UINT StreamCount, CONST D3DSTREAM_INPUT *pStreamInputs);
    HRESULT WINAPI SetRenderTarget(DWORD Offset, D3DSurface* pRenderTarget, D3DSurface* pZBuffer);
    HRESULT WINAPI SetTexture(DWORD Offset, DWORD Stage, D3DBaseTexture *pTexture);
    HRESULT WINAPI SetPalette(DWORD Offset, DWORD Stage,D3DPalette *pPalette);
    HRESULT WINAPI EndVisibilityTest(DWORD Offset, DWORD Index);
    HRESULT WINAPI SetVertexShaderConstant(DWORD Offset, INT Register, CONST VOID* pConstantData, DWORD ConstantCount);
    HRESULT WINAPI Jump(DWORD Offset, UINT DestinationOffset);
    HRESULT WINAPI GetSize(DWORD* pSize);

#endif __cplusplus

#ifndef __cplusplus

    // Manually inherit these from D3DResource.  
    //
    // Note (in an exception to all other resources) that 'Data' is a virtual 
    // address for the D3DPUSHBUFFER_RUN_USING_CPU_COPY case.
    DWORD Common;
    DWORD Data;
    DWORD Lock;

#endif

    // Size, in bytes, of the push-buffer program.
    DWORD Size;

    // Size, in bytes, of the allocation of the buffer pointed to by 'Data'.
    DWORD AllocationSize;
};


/*
 * D3DFixup, IFixup8 interface
 *
 * A fix-up resource for push-buffers.
 */

#define D3DFIXUP_ALIGNMENT 4

struct D3DFixup
    #ifdef __cplusplus
        : public D3DResource
    #endif
{
#ifdef __cplusplus

    HRESULT WINAPI Reset(); 
    HRESULT WINAPI GetSize(DWORD* pSize);
    HRESULT WINAPI GetSpace(DWORD* pSpace);

#endif __cplusplus

#ifndef __cplusplus

    // Manually inherit these from D3DResource.  
    //
    // Note that 'Data' is always a virtual address.
    DWORD Common;
    DWORD Data;
    DWORD Lock;

#endif

    // Offset to the last completed fix-up.  RunPushBuffer uses this and 'Data'.
    DWORD Run;

    // Offset to where we'll append the next fix-up.
    DWORD Next;

    // Size of the whole allocation.
    DWORD Size;
};


/*
 * Helper methods.
 */

//----------------------------------------------------------------------------
// Allocate a block of contiguous memory and return a write-combined
// pointer to it.  This memory is suitable to be used as the data
// for any of the D3D structures.
//
// Returns NULL if the memory could not be allocated.
//
void* WINAPI D3D_AllocContiguousMemory(
    DWORD Size,         // The size of the allocation in bytes
    DWORD Alignment     // The alignment of the allocation
    );

//----------------------------------------------------------------------------
// Frees memory allocated by the above method.
//
    
void WINAPI D3D_FreeContiguousMemory(
    void *pMemory       // The block of memory to free
    );


//----------------------------------------------------------------------------
// D3D_CopyContiguousMemory has been deprecated on the final hardware.
// Use CopyRects instead.  
//
// With the API as speced, this function was hideously expensive because 
// it had to flush the GPU's entire push-buffer, and then spin the CPU until 
// the copy was done.  CopyRects lets everything be nicely asynchronous,
// just as it is with all other GPU APIs.  
// 
// To get equivalent behavior with CopyRects, use XGSetSurfaceHeader to create
// wrapper surfaces around the memory (the pitches should equal the widths 
// times the pixel size and not be more than 8128).  Then surface.IsBusy(),
// LockRect(), and the other standard synchronization APIs may be used to
// determine when the copy is done.
//
// void WINAPI D3D_CopyContiguousMemory(
//     void *pSource,
//     void *pDest,
//     DWORD Size
//     ); 

//----------------------------------------------------------------------------
// On pre-beta development kits, this function was used to copy data
// from AGP memory to video memory.
//
// This function is deprecated on the final hardware.
//
D3DINLINE void WINAPI D3D_CopyContiguousMemoryToVideo(
    void *pMemory          // Contiguous memory block to move.
    )
{
}


/*
 * C exported method definitions for the class methods defined above and the C++
 * thunks that defer to them.
 */

/* Direct3D */

D3DINLINE ULONG   WINAPI Direct3D_AddRef() { return 1; }
D3DINLINE ULONG   WINAPI Direct3D_Release() { return 1; }
D3DINLINE UINT    WINAPI Direct3D_GetAdapterCount() { return 1; }
HRESULT WINAPI Direct3D_GetAdapterIdentifier(UINT Adapter, DWORD Flags, D3DADAPTER_IDENTIFIER8 *pIdentifier);
UINT    WINAPI Direct3D_GetAdapterModeCount(UINT Adapter);
HRESULT WINAPI Direct3D_EnumAdapterModes(UINT Adapter, UINT Mode, D3DDISPLAYMODE *pMode);
HRESULT WINAPI Direct3D_GetAdapterDisplayMode(UINT Adapter, D3DDISPLAYMODE *pMode);
HRESULT WINAPI Direct3D_CheckDeviceType(UINT Adapter, D3DDEVTYPE CheckType, D3DFORMAT DisplayFormat, D3DFORMAT BackBufferFormat, BOOL Windowed);
HRESULT WINAPI Direct3D_CheckDeviceFormat(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, DWORD Usage, D3DRESOURCETYPE RType, D3DFORMAT CheckFormat);
HRESULT WINAPI Direct3D_CheckDeviceMultiSampleType(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT SurfaceFormat, BOOL Windowed, D3DMULTISAMPLE_TYPE MultiSampleType);
HRESULT WINAPI Direct3D_CheckDepthStencilMatch(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, D3DFORMAT RenderTargetFormat, D3DFORMAT DepthStencilFormat);
HRESULT WINAPI Direct3D_GetDeviceCaps(UINT Adapter,D3DDEVTYPE DeviceType,D3DCAPS8 *pCaps);
HRESULT WINAPI Direct3D_CreateDevice(UINT Adapter, D3DDEVTYPE DeviceType, void *pUnused, DWORD BehaviorFlags, D3DPRESENT_PARAMETERS *pPresentationParameters, D3DDevice **ppReturnedDeviceInterface);
void    WINAPI Direct3D_SetPushBufferSize(DWORD PushBufferSize, DWORD KickOffSize);

// Compatibility wrappers.

D3DINLINE ULONG   WINAPI IDirect3D8_AddRef(Direct3D *pThis) { return Direct3D_AddRef(); }
D3DINLINE ULONG   WINAPI IDirect3D8_Release(Direct3D *pThis) { return Direct3D_Release(); }
D3DINLINE UINT    WINAPI IDirect3D8_GetAdapterCount(Direct3D *pThis) { return Direct3D_GetAdapterCount(); }
D3DINLINE HRESULT WINAPI IDirect3D8_GetAdapterIdentifier(Direct3D *pThis, UINT Adapter, DWORD Flags, D3DADAPTER_IDENTIFIER8 *pIdentifier) { return Direct3D_GetAdapterIdentifier(Adapter, Flags, pIdentifier); }
D3DINLINE UINT    WINAPI IDirect3D8_GetAdapterModeCount(Direct3D *pThis, UINT Adapter) { return Direct3D_GetAdapterModeCount(Adapter); }
D3DINLINE HRESULT WINAPI IDirect3D8_EnumAdapterModes(Direct3D *pThis, UINT Adapter, UINT iMode, D3DDISPLAYMODE *pMode) { return Direct3D_EnumAdapterModes(Adapter, iMode, pMode); }
D3DINLINE HRESULT WINAPI IDirect3D8_GetAdapterDisplayMode(Direct3D *pThis, UINT Adapter, D3DDISPLAYMODE *pMode) { return Direct3D_GetAdapterDisplayMode(Adapter, pMode); }
D3DINLINE HRESULT WINAPI IDirect3D8_CheckDeviceType(Direct3D *pThis, UINT Adapter, D3DDEVTYPE CheckType, D3DFORMAT DisplayFormat, D3DFORMAT BackBufferFormat, BOOL Windowed) { return Direct3D_CheckDeviceType(Adapter, CheckType, DisplayFormat, BackBufferFormat, Windowed); }
D3DINLINE HRESULT WINAPI IDirect3D8_CheckDeviceFormat(Direct3D *pThis, UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, DWORD Usage, D3DRESOURCETYPE RType, D3DFORMAT CheckFormat) { return Direct3D_CheckDeviceFormat(Adapter, DeviceType, AdapterFormat, Usage, RType, CheckFormat); }
D3DINLINE HRESULT WINAPI IDirect3D8_CheckDeviceMultiSampleType(Direct3D *pThis, UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT SurfaceFormat, BOOL Windowed, D3DMULTISAMPLE_TYPE MultiSampleType) { return Direct3D_CheckDeviceMultiSampleType(Adapter, DeviceType, SurfaceFormat, Windowed, MultiSampleType); }
D3DINLINE HRESULT WINAPI IDirect3D8_CheckDepthStencilMatch(Direct3D *pThis, UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, D3DFORMAT RenderTargetFormat, D3DFORMAT DepthStencilFormat) { return Direct3D_CheckDepthStencilMatch(Adapter, DeviceType, AdapterFormat, RenderTargetFormat, DepthStencilFormat); }
D3DINLINE HRESULT WINAPI IDirect3D8_GetDeviceCaps(Direct3D *pThis, UINT Adapter,D3DDEVTYPE DeviceType,D3DCAPS8 *pCaps) { return Direct3D_GetDeviceCaps(Adapter, DeviceType, pCaps); }
D3DINLINE HRESULT WINAPI IDirect3D8_CreateDevice(Direct3D *pThis, UINT Adapter, D3DDEVTYPE DeviceType, void *pUnused, DWORD BehaviorFlags, D3DPRESENT_PARAMETERS *pPresentationParameters, D3DDevice **ppReturnedDeviceInterface) { return Direct3D_CreateDevice(Adapter, DeviceType, pUnused, BehaviorFlags, pPresentationParameters, ppReturnedDeviceInterface); }
D3DINLINE HRESULT WINAPI IDirect3D8_SetPushBufferSize(Direct3D *pThis, DWORD PushBufferSize, DWORD KickOffSize) { Direct3D_SetPushBufferSize(PushBufferSize, KickOffSize); return S_OK; }

#ifdef __cplusplus

D3DMINLINE ULONG   WINAPI Direct3D::AddRef() { return Direct3D_AddRef(); }
D3DMINLINE ULONG   WINAPI Direct3D::Release() { return Direct3D_Release(); }
D3DMINLINE UINT    WINAPI Direct3D::GetAdapterCount() { return Direct3D_GetAdapterCount(); }
D3DMINLINE HRESULT WINAPI Direct3D::GetAdapterIdentifier(UINT Adapter, DWORD Flags, D3DADAPTER_IDENTIFIER8 *pIdentifier) { return Direct3D_GetAdapterIdentifier(Adapter, Flags, pIdentifier); }
D3DMINLINE UINT    WINAPI Direct3D::GetAdapterModeCount(UINT Adapter) { return Direct3D_GetAdapterModeCount(Adapter); }
D3DMINLINE HRESULT WINAPI Direct3D::EnumAdapterModes(UINT Adapter, UINT Mode, D3DDISPLAYMODE *pMode) { return Direct3D_EnumAdapterModes(Adapter, Mode, pMode); }
D3DMINLINE HRESULT WINAPI Direct3D::GetAdapterDisplayMode(UINT Adapter, D3DDISPLAYMODE *pMode) { return Direct3D_GetAdapterDisplayMode(Adapter, pMode); }
D3DMINLINE HRESULT WINAPI Direct3D::CheckDeviceType(UINT Adapter, D3DDEVTYPE CheckType, D3DFORMAT DisplayFormat, D3DFORMAT BackBufferFormat, BOOL Windowed) { return Direct3D_CheckDeviceType(Adapter, CheckType, DisplayFormat, BackBufferFormat, Windowed); }
D3DMINLINE HRESULT WINAPI Direct3D::CheckDeviceFormat(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, DWORD Usage, D3DRESOURCETYPE RType, D3DFORMAT CheckFormat) { return Direct3D_CheckDeviceFormat(Adapter, DeviceType, AdapterFormat, Usage, RType, CheckFormat); }
D3DMINLINE HRESULT WINAPI Direct3D::CheckDeviceMultiSampleType(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT SurfaceFormat, BOOL Windowed, D3DMULTISAMPLE_TYPE MultiSampleType) { return Direct3D_CheckDeviceMultiSampleType(Adapter, DeviceType, SurfaceFormat, Windowed, MultiSampleType); }
D3DMINLINE HRESULT WINAPI Direct3D::CheckDepthStencilMatch(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, D3DFORMAT RenderTargetFormat, D3DFORMAT DepthStencilFormat) { return Direct3D_CheckDepthStencilMatch(Adapter, DeviceType, AdapterFormat, RenderTargetFormat, DepthStencilFormat); }
D3DMINLINE HRESULT WINAPI Direct3D::GetDeviceCaps(UINT Adapter, D3DDEVTYPE DeviceType, D3DCAPS8 *pCaps) { return Direct3D_GetDeviceCaps(Adapter, DeviceType, pCaps); }
D3DMINLINE HRESULT WINAPI Direct3D::CreateDevice(UINT Adapter, D3DDEVTYPE DeviceType, void *pUnused, DWORD BehaviorFlags, D3DPRESENT_PARAMETERS *pPresentationParameters, D3DDevice **ppReturnedDeviceInterface) { return Direct3D_CreateDevice(Adapter, DeviceType, pUnused, BehaviorFlags, pPresentationParameters, ppReturnedDeviceInterface); }
D3DMINLINE HRESULT WINAPI Direct3D::SetPushBufferSize(DWORD PushBufferSize, DWORD KickOffSize) { Direct3D_SetPushBufferSize(PushBufferSize, KickOffSize); return S_OK; }

#endif __cplusplus

/* D3DDevice */

ULONG   WINAPI D3DDevice_AddRef();
ULONG   WINAPI D3DDevice_Release();
void    WINAPI D3DDevice_GetDirect3D(Direct3D **ppD3D8);
void    WINAPI D3DDevice_GetDeviceCaps(D3DCAPS8 *pCaps);
void    WINAPI D3DDevice_GetDisplayMode(D3DDISPLAYMODE *pMode);
void    WINAPI D3DDevice_GetCreationParameters(D3DDEVICE_CREATION_PARAMETERS *pParameters);
HRESULT WINAPI D3DDevice_Reset(D3DPRESENT_PARAMETERS *pPresentationParameters);
void    WINAPI D3DDevice_GetBackBuffer(INT BackBuffer, D3DBACKBUFFER_TYPE Type, D3DSurface **ppBackBuffer);
void    WINAPI D3DDevice_GetRasterStatus(D3DRASTER_STATUS *pRasterStatus);
void    WINAPI D3DDevice_SetFlickerFilter(DWORD Filter);
void    WINAPI D3DDevice_SetSoftDisplayFilter(BOOL Enable);
void    WINAPI D3DDevice_SetGammaRamp(DWORD Flags, CONST D3DGAMMARAMP *pRamp);
void    WINAPI D3DDevice_GetGammaRamp(D3DGAMMARAMP *pRamp);
HRESULT WINAPI D3DDevice_CreateTexture(UINT Width, UINT Height, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DTexture **ppTexture);
HRESULT WINAPI D3DDevice_CreateVolumeTexture(UINT Width, UINT Height, UINT Depth, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DVolumeTexture **ppVolumeTexture);
HRESULT WINAPI D3DDevice_CreateCubeTexture(UINT EdgeLength, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DCubeTexture **ppCubeTexture);
HRESULT WINAPI D3DDevice_CreateVertexBuffer(UINT Length, DWORD Usage, DWORD FVF, D3DPOOL Pool, D3DVertexBuffer **ppVertexBuffer);
HRESULT WINAPI D3DDevice_CreateIndexBuffer(UINT Length, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DIndexBuffer **ppIndexBuffer);
HRESULT WINAPI D3DDevice_CreatePalette(D3DPALETTESIZE Size, D3DPalette **ppPalette);
HRESULT WINAPI D3DDevice_CreateRenderTarget(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, BOOL Lockable, D3DSurface **ppSurface);
HRESULT WINAPI D3DDevice_CreateDepthStencilSurface(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, D3DSurface **ppSurface);
HRESULT WINAPI D3DDevice_CreateImageSurface(UINT Width, UINT Height, D3DFORMAT Format, D3DSurface **ppSurface);
void    WINAPI D3DDevice_CopyRects(D3DSurface *pSourceSurface, CONST RECT *pSourceRectsArray, UINT cRects, D3DSurface *pDestinationSurface, CONST POINT *pDestPointsArray);
void    WINAPI D3DDevice_SetCopyRectsState(CONST D3DCOPYRECTSTATE *pCopyRectState, CONST D3DCOPYRECTROPSTATE *pCopyRectRopState);
void    WINAPI D3DDevice_GetCopyRectsState(D3DCOPYRECTSTATE *pCopyRectState, D3DCOPYRECTROPSTATE *pCopyRectRopState);
void    WINAPI D3DDevice_SetRenderTarget(D3DSurface *pRenderTarget, D3DSurface *pNewZStencil);
void    WINAPI D3DDevice_GetRenderTarget(D3DSurface **ppRenderTarget);
HRESULT WINAPI D3DDevice_GetDepthStencilSurface(D3DSurface **ppZStencilSurface);
D3DINLINE void    WINAPI D3DDevice_BeginScene() { }
D3DINLINE void    WINAPI D3DDevice_EndScene() { }
void    WINAPI D3DDevice_Clear(DWORD Count, CONST D3DRECT *pRects, DWORD Flags, D3DCOLOR Color, float Z, DWORD Stencil);
void    WINAPI D3DDevice_SetTransform(D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix);
void    WINAPI D3DDevice_GetTransform(D3DTRANSFORMSTATETYPE State, D3DMATRIX *pMatrix);
void    WINAPI D3DDevice_MultiplyTransform(D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix);
void    WINAPI D3DDevice_SetViewport(CONST D3DVIEWPORT8 *pViewport);
void    WINAPI D3DDevice_GetViewport(D3DVIEWPORT8 *pViewport);
void    WINAPI D3DDevice_SetMaterial(CONST D3DMATERIAL8 *pMaterial);
void    WINAPI D3DDevice_GetMaterial(D3DMATERIAL8 *pMaterial);
void    WINAPI D3DDevice_SetBackMaterial(CONST D3DMATERIAL8 *pMaterial);
void    WINAPI D3DDevice_GetBackMaterial(D3DMATERIAL8 *pMaterial);
HRESULT WINAPI D3DDevice_SetLight(DWORD Index, CONST D3DLIGHT8 *pLight);
void    WINAPI D3DDevice_GetLight(DWORD Index, D3DLIGHT8 *pLight);
HRESULT WINAPI D3DDevice_LightEnable(DWORD Index, BOOL Enable);
void    WINAPI D3DDevice_GetLightEnable(DWORD Index, BOOL *pEnable);
void    WINAPI D3DDevice_SetRenderStateNotInline(D3DRENDERSTATETYPE State, DWORD Value);
HRESULT WINAPI D3DDevice_SetRenderState_ParameterCheck(D3DRENDERSTATETYPE State, DWORD Value);
void    D3DFASTCALL D3DDevice_SetRenderState_Simple(DWORD Method, DWORD Value);
void    WINAPI D3DDevice_SetRenderState_PSTextureModes(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_VertexBlend(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_FogColor(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_FillMode(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_BackFillMode(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_TwoSidedLighting(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_NormalizeNormals(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_ZEnable(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_StencilEnable(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_StencilFail(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_CullMode(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_FrontFace(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_TextureFactor(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_ZBias(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_LogicOp(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_EdgeAntiAlias(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_MultiSampleAntiAlias(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_MultiSampleMask(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_MultiSampleMode(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_MultiSampleRenderTargetMode(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_ShadowFunc(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_LineWidth(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_Dxt1NoiseEnable(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_YuvEnable(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_OcclusionCullEnable(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_StencilCullEnable(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_RopZCmpAlwaysRead(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_RopZRead(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_DoNotCullUncompressed(DWORD Value);
void    WINAPI D3DDevice_SetTextureStageStateNotInline(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value);
HRESULT WINAPI D3DDevice_SetTextureState_ParameterCheck(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value);
void    WINAPI D3DDevice_SetTextureState_BumpEnv(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value);
void    WINAPI D3DDevice_SetTextureState_TexCoordIndex(DWORD Stage, DWORD Value);
void    WINAPI D3DDevice_SetTextureState_BorderColor(DWORD Stage, DWORD Value);
void    WINAPI D3DDevice_SetTextureState_ColorKeyColor(DWORD Stage, DWORD Value);
#if D3DCOMPILE_BEGINSTATEBLOCK
void    WINAPI D3DDevice_BeginStateBlock();
HRESULT WINAPI D3DDevice_EndStateBlock(DWORD *pToken);
#endif
void    WINAPI D3DDevice_ApplyStateBlock(DWORD Token);
void    WINAPI D3DDevice_CaptureStateBlock(DWORD Token);
void    WINAPI D3DDevice_DeleteStateBlock(DWORD Token);
HRESULT WINAPI D3DDevice_CreateStateBlock(D3DSTATEBLOCKTYPE Type,DWORD *pToken);
void    WINAPI D3DDevice_GetTexture(DWORD Stage, D3DBaseTexture **ppTexture);
void    WINAPI D3DDevice_SetTexture(DWORD Stage, D3DBaseTexture *pTexture);
void    WINAPI D3DDevice_GetPalette(DWORD Stage, D3DPalette **ppPalette);
void    WINAPI D3DDevice_SetPalette(DWORD Stage, D3DPalette *pPalette);
void    WINAPI D3DDevice_DrawVertices(D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT VertexCount);
void    WINAPI D3DDevice_DrawIndexedVertices(D3DPRIMITIVETYPE, UINT VertexCount, CONST WORD *pIndexData);
void    WINAPI D3DDevice_DrawVerticesUP(D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride);
void    WINAPI D3DDevice_DrawIndexedVerticesUP(D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST void *pIndexData, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride);
void    WINAPI D3DDevice_PrimeVertexCache(UINT VertexCount, CONST WORD *pIndexData);
HRESULT WINAPI D3DDevice_CreateVertexShader(CONST DWORD *pDeclaration, CONST DWORD *pFunction, DWORD *pHandle, DWORD Usage);
void    WINAPI D3DDevice_SetVertexShader(DWORD Handle);
void    WINAPI D3DDevice_GetVertexShader(DWORD *pHandle);
void    WINAPI D3DDevice_DeleteVertexShader(DWORD Handle);
void    WINAPI D3DDevice_SetVertexShaderConstant(INT Register, CONST void *pConstantData, DWORD ConstantCount);
void    WINAPI D3DDevice_GetVertexShaderConstant(INT Register, void *pConstantData, DWORD ConstantCount);
void    WINAPI D3DDevice_SetShaderConstantMode(D3DSHADERCONSTANTMODE Mode);
void    WINAPI D3DDevice_GetShaderConstantMode(D3DSHADERCONSTANTMODE *pMode);
void    WINAPI D3DDevice_LoadVertexShader(DWORD Handle, DWORD Address);
void    WINAPI D3DDevice_LoadVertexShaderProgram(CONST DWORD *pFunction, DWORD Address);
void    WINAPI D3DDevice_SelectVertexShader(DWORD Handle, DWORD Address);
void    WINAPI D3DDevice_SelectVertexShaderDirect(D3DVERTEXATTRIBUTEFORMAT *pVAF, DWORD Address);
void    WINAPI D3DDevice_RunVertexStateShader(DWORD Address, CONST float *pData);
void    WINAPI D3DDevice_GetVertexShaderSize(DWORD Handle, UINT* pSize);
void    WINAPI D3DDevice_GetVertexShaderType(DWORD Handle, DWORD* pType);
HRESULT WINAPI D3DDevice_GetVertexShaderDeclaration(DWORD Handle, void *pData, DWORD *pSizeOfData);
HRESULT WINAPI D3DDevice_GetVertexShaderFunction(DWORD Handle,void *pData, DWORD *pSizeOfData);
void    WINAPI D3DDevice_SetStreamSource(UINT StreamNumber, D3DVertexBuffer *pStreamData, UINT Stride);
void    WINAPI D3DDevice_GetStreamSource(UINT StreamNumber, D3DVertexBuffer **ppStreamData, UINT *pStride);
void    WINAPI D3DDevice_SetIndices(D3DIndexBuffer* pIndexData, UINT BaseVertexIndex);
void    WINAPI D3DDevice_GetIndices(D3DIndexBuffer** ppIndexData, UINT *pBaseVertexIndex);
void    WINAPI D3DDevice_CreatePixelShader(CONST D3DPIXELSHADERDEF *pPSDef, DWORD *pHandle);
void    WINAPI D3DDevice_SetPixelShader(DWORD Handle);
void    WINAPI D3DDevice_SetPixelShaderProgram(CONST D3DPIXELSHADERDEF *pPSDef);
void    WINAPI D3DDevice_GetPixelShader(DWORD *pHandle);
void    WINAPI D3DDevice_DeletePixelShader(DWORD Handle);
void    WINAPI D3DDevice_SetPixelShaderConstant(DWORD Register, CONST void *pConstantData, DWORD ConstantCount);
void    WINAPI D3DDevice_GetPixelShaderConstant(DWORD Register, void *pConstantData, DWORD ConstantCount);
void    WINAPI D3DDevice_GetPixelShaderFunction(DWORD Handle, D3DPIXELSHADERDEF *pData);
HRESULT WINAPI D3DDevice_DrawRectPatch(UINT Handle, CONST float *pNumSegs, CONST D3DRECTPATCH_INFO *pRectPatchInfo);
HRESULT WINAPI D3DDevice_DrawTriPatch(UINT Handle, CONST float *pNumSegs, CONST D3DTRIPATCH_INFO *pTriPatchInfo);
void    WINAPI D3DDevice_DeletePatch(UINT Handle);
void    WINAPI D3DDevice_UpdateOverlay(D3DSurface *pSurface, CONST RECT *SrcRect, CONST RECT *DstRect, BOOL EnableColorKey, D3DCOLOR ColorKey);
void    WINAPI D3DDevice_EnableOverlay(BOOL Enable);
void    WINAPI D3DDevice_BeginVisibilityTest();
HRESULT WINAPI D3DDevice_EndVisibilityTest(DWORD Index);
HRESULT WINAPI D3DDevice_GetVisibilityTestResult(DWORD Index, UINT *pResult, ULONGLONG *pTimeStamp);
BOOL    WINAPI D3DDevice_IsBusy();
void    WINAPI D3DDevice_BlockUntilIdle();
void    WINAPI D3DDevice_KickPushBuffer();
void    WINAPI D3DDevice_SetVerticalBlankCallback(D3DVBLANKCALLBACK pCallback);
void    WINAPI D3DDevice_SetSwapCallback(D3DSWAPCALLBACK pCallback);
void    WINAPI D3DDevice_BlockUntilVerticalBlank();
DWORD   WINAPI D3DDevice_InsertFence();
BOOL    WINAPI D3DDevice_IsFencePending(DWORD Fence);
VOID    WINAPI D3DDevice_BlockOnFence(DWORD Fence);
void    WINAPI D3DDevice_InsertCallback(D3DCALLBACKTYPE Type, D3DCALLBACK pCallback, DWORD Context);
void    WINAPI D3DDevice_FlushVertexCache();
HRESULT WINAPI D3DDevice_PersistDisplay();
HRESULT WINAPI D3DDevice_GetPersistedSurface(IDirect3DSurface8 **ppSurface);
BOOL    WINAPI D3DDevice_GetOverlayUpdateStatus();
void    WINAPI D3DDevice_GetDisplayFieldStatus(D3DFIELD_STATUS *pFieldStatus);
void    WINAPI D3DDevice_SetVertexData2f(INT Register, float a, float b);
void    WINAPI D3DDevice_SetVertexData4f(INT Register, float a, float b, float c, float d);
void    WINAPI D3DDevice_SetVertexData2s(INT Register, SHORT a, SHORT b);
void    WINAPI D3DDevice_SetVertexData4s(INT Register, SHORT a, SHORT b, SHORT c, SHORT d);
void    WINAPI D3DDevice_SetVertexData4ub(INT Register, BYTE a, BYTE b, BYTE c, BYTE d);
void    WINAPI D3DDevice_SetVertexDataColor(INT Register, D3DCOLOR Color);
void    WINAPI D3DDevice_Begin(D3DPRIMITIVETYPE PrimitiveType);
void    WINAPI D3DDevice_End();
HRESULT WINAPI D3DDevice_CreateFixup(UINT Size, D3DFixup **ppFixup);
HRESULT WINAPI D3DDevice_CreatePushBuffer(UINT Size, BOOL RunUsingCpuCopy, D3DPushBuffer **ppPushBuffer);
void    WINAPI D3DDevice_BeginPushBuffer(D3DPushBuffer *pPushBuffer);
HRESULT WINAPI D3DDevice_EndPushBuffer();
void    WINAPI D3DDevice_RunPushBuffer(D3DPushBuffer *pPushBuffer, D3DFixup *pFixup);
void    WINAPI D3DDevice_GetPushBufferOffset(DWORD* pOffset);
void    WINAPI D3DDevice_Nop();
void    WINAPI D3DDevice_GetProjectionViewportMatrix(D3DMATRIX* pProjectionViewport);
void    WINAPI D3DDevice_SetModelView(CONST D3DMATRIX* pModelView, CONST D3DMATRIX* pInverseModelView, CONST D3DMATRIX* pComposite);
HRESULT WINAPI D3DDevice_GetModelView(D3DMATRIX* pModelView);
void    WINAPI D3DDevice_SetVertexBlendModelView(UINT Count, CONST D3DMATRIX* pModelViews, CONST D3DMATRIX* pInverseModelViews, CONST D3DMATRIX* pProjectionViewport);
HRESULT WINAPI D3DDevice_GetVertexBlendModelView(UINT Count, D3DMATRIX* pModelViews, D3DMATRIX* pProjectionViewport);
void    WINAPI D3DDevice_SetVertexShaderInput(DWORD Handle, UINT StreamCount, CONST D3DSTREAM_INPUT* pStreamInputs);
void    WINAPI D3DDevice_SetVertexShaderInputDirect(D3DVERTEXATTRIBUTEFORMAT *pVAF, UINT StreamCount, CONST D3DSTREAM_INPUT* pStreamInputs);
HRESULT WINAPI D3DDevice_GetVertexShaderInput(DWORD* pHandle, UINT* pStreamCount, D3DSTREAM_INPUT* pStreamInputs);
void    D3DFASTCALL D3DDevice_SwitchTexture(DWORD Method, DWORD Data, DWORD Format);
void    WINAPI D3DDevice_Suspend();
void    WINAPI D3DDevice_Resume(BOOL Reset);
void    WINAPI D3DDevice_SetScissors(DWORD Count, BOOL Exclusive, CONST D3DRECT *pRects);
void    WINAPI D3DDevice_GetScissors(DWORD* pCount, BOOL *pExclusive, D3DRECT *pRects);
void    WINAPI D3DDevice_SetTile(DWORD Index, CONST D3DTILE* pTile);
void    WINAPI D3DDevice_GetTile(DWORD Index, D3DTILE* pTile);
DWORD   WINAPI D3DDevice_GetTileCompressionTags(DWORD ZStartTag, DWORD ZEndTag);
void    WINAPI D3DDevice_SetTileCompressionTagBits(DWORD Partition, DWORD Address, CONST DWORD *pData, DWORD Count);
void    WINAPI D3DDevice_GetTileCompressionTagBits(DWORD Partition, DWORD Address, DWORD *pData, DWORD Count);
void    WINAPI D3DDevice_BeginPush(DWORD Count, DWORD **ppPush);
void    WINAPI D3DDevice_EndPush(DWORD *pPush);
DWORD   WINAPI D3DDevice_Swap(DWORD Flags);
void    WINAPI D3DDevice_SetBackBufferScale(float x, float y);
void    WINAPI D3DDevice_GetBackBufferScale(float *pX, float *pY);
void    WINAPI D3DDevice_SetScreenSpaceOffset(float x, float y);
void    WINAPI D3DDevice_GetScreenSpaceOffset(float *pX, float *pY);
void    WINAPI D3DDevice_SetOverscanColor(D3DCOLOR Color);
D3DCOLOR WINAPI D3DDevice_GetOverscanColor();

#ifdef _DEBUG
DWORD   WINAPI D3DDevice_SetDebugMarker(DWORD Marker);
DWORD   WINAPI D3DDevice_GetDebugMarker();
#else
D3DINLINE DWORD   WINAPI D3DDevice_SetDebugMarker(DWORD Marker) { return 0; }
D3DINLINE DWORD   WINAPI D3DDevice_GetDebugMarker() { return 0; }
#endif

D3DINLINE void D3DDevice_GetRenderState(D3DRENDERSTATETYPE State, DWORD *pValue)
{
    *pValue = D3D__RenderState[State];
}
D3DINLINE void D3DDevice_GetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD *pValue)
{
    *pValue = D3D__TextureState[Stage][Type];
}

#if D3DCOMPILE_NOTINLINE
    
    D3DINLINE void D3DDevice_SetRenderState(D3DRENDERSTATETYPE State, DWORD Value)
    {
        D3DDevice_SetRenderStateNotInline(State, Value);
    }
    D3DINLINE void D3DDevice_SetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value)
    {
        D3DDevice_SetTextureStageStateNotInline(Stage, Type, Value);
    }

#else
    
    // This D3DINLINE version of SetRenderState has the nice advantage that it
    // essentially moves to compile-time the big 'switch' statement for
    // handling all the render state types.  When given a constant value for 
    // 'State', all of these 'if's get nicely compiled away.  We can't use a 
    // static call-table because the compiler cannot remove the indirect.
    //
    // If you're calling SetRenderState with a non-constant value for 'State',
    // it's better to call SetRenderStateNotInline (it will reduce code bloat
    // and be a bit faster because the non-D3DINLINE version uses a call-table).
    //
    D3DINLINE void D3DDevice_SetRenderState(D3DRENDERSTATETYPE State, DWORD Value)
    {
        #ifdef _DEBUG
        if (D3DDevice_SetRenderState_ParameterCheck(State, Value) != S_OK)
            return;
        #endif

        if (State < D3DRS_SIMPLE_MAX)
        {
            D3DDevice_SetRenderState_Simple(D3DSIMPLERENDERSTATEENCODE[State], Value);
            #if !D3DCOMPILE_PUREDEVICE
            D3D__RenderState[State] = Value;
            #endif
        }
        else if (State < D3DRS_DEFERRED_MAX)
        {
            D3D__DirtyFlags |= D3DDIRTYFROMRENDERSTATE[State - D3DRS_SIMPLE_MAX];
            D3D__RenderState[State] = Value;
        }
        else if (State == D3DRS_PSTEXTUREMODES)
        {
            D3DDevice_SetRenderState_PSTextureModes(Value);
        }
        else if (State == D3DRS_VERTEXBLEND)
        {
            D3DDevice_SetRenderState_VertexBlend(Value);
        }
        else if (State == D3DRS_FOGCOLOR)
        {
            D3DDevice_SetRenderState_FogColor(Value);
        }
        else if (State == D3DRS_FILLMODE)
        {
            D3DDevice_SetRenderState_FillMode(Value);
        }
        else if (State == D3DRS_BACKFILLMODE)
        {
            D3DDevice_SetRenderState_BackFillMode(Value);
        }
        else if (State == D3DRS_TWOSIDEDLIGHTING)
        {
            D3DDevice_SetRenderState_TwoSidedLighting(Value);
        }
        else if (State == D3DRS_NORMALIZENORMALS)
        {
            D3DDevice_SetRenderState_NormalizeNormals(Value);
        }
        else if (State == D3DRS_ZENABLE)
        {
            D3DDevice_SetRenderState_ZEnable(Value);
        }
        else if (State == D3DRS_STENCILENABLE)
        {
            D3DDevice_SetRenderState_StencilEnable(Value);
        }
        else if (State == D3DRS_STENCILFAIL)
        {
            D3DDevice_SetRenderState_StencilFail(Value);
        }
        else if (State == D3DRS_CULLMODE)
        {
            D3DDevice_SetRenderState_CullMode(Value);
        }
        else if (State == D3DRS_FRONTFACE)
        {
            D3DDevice_SetRenderState_FrontFace(Value);
        }
        else if (State == D3DRS_TEXTUREFACTOR)
        {
            D3DDevice_SetRenderState_TextureFactor(Value);
        }
        else if (State == D3DRS_ZBIAS)
        {
            D3DDevice_SetRenderState_ZBias(Value);
        }
        else if (State == D3DRS_LOGICOP)
        {
            D3DDevice_SetRenderState_LogicOp(Value);
        }
        else if (State == D3DRS_EDGEANTIALIAS)
        {
            D3DDevice_SetRenderState_EdgeAntiAlias(Value);
        }
        else if (State == D3DRS_MULTISAMPLEANTIALIAS)
        {
            D3DDevice_SetRenderState_MultiSampleAntiAlias(Value);
        }
        else if (State == D3DRS_MULTISAMPLEMASK)
        {
            D3DDevice_SetRenderState_MultiSampleMask(Value);
        }
        else if (State == D3DRS_MULTISAMPLEMODE)
        {
            D3DDevice_SetRenderState_MultiSampleMode(Value);
        }
        else if (State == D3DRS_MULTISAMPLERENDERTARGETMODE)
        {
            D3DDevice_SetRenderState_MultiSampleRenderTargetMode(Value);
        }
        else if (State == D3DRS_SHADOWFUNC)
        {
            D3DDevice_SetRenderState_ShadowFunc(Value);
        }
        else if (State == D3DRS_LINEWIDTH)
        {
            D3DDevice_SetRenderState_LineWidth(Value);
        }
        else if (State == D3DRS_DXT1NOISEENABLE)
        {
            D3DDevice_SetRenderState_Dxt1NoiseEnable(Value);
        }
        else if (State == D3DRS_YUVENABLE)
        {
            D3DDevice_SetRenderState_YuvEnable(Value);
        }
        else if (State == D3DRS_OCCLUSIONCULLENABLE)
        {
            D3DDevice_SetRenderState_OcclusionCullEnable(Value);
        }
        else if (State == D3DRS_STENCILCULLENABLE)
        {
            D3DDevice_SetRenderState_StencilCullEnable(Value);
        }
        else if (State == D3DRS_ROPZCMPALWAYSREAD)
        {
            D3DDevice_SetRenderState_RopZCmpAlwaysRead(Value);
        }
        else if (State == D3DRS_ROPZREAD)
        {
            D3DDevice_SetRenderState_RopZRead(Value);
        }
        else if (State == D3DRS_DONOTCULLUNCOMPRESSED)
        {
            D3DDevice_SetRenderState_DoNotCullUncompressed(Value);
        }
    }

    // As above, but for SetTextureStageState:

    D3DINLINE void D3DDevice_SetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value)
    {
        #ifdef _DEBUG
        if (D3DDevice_SetTextureState_ParameterCheck(Stage, Type, Value) != S_OK)
            return;
        #endif
        
        if (Type < D3DTSS_DEFERRED_TEXTURE_STATE_MAX)
        {
            D3D__DirtyFlags |= (D3DDIRTYFLAG_TEXTURE_STATE_0 << Stage);
            D3D__TextureState[Stage][Type] = Value;
        }
        else if (Type == D3DTSS_COLOROP)
        {
            // Only D3DTOP_BUMPENVMAP and D3DTOP_BUMPENVMAPLUMINANCE require the
            // sign flags and shader program to be recomputed:

            D3D__DirtyFlags |= (Value < D3DTOP_BUMPENVMAP)
                             ? (D3DDIRTYFLAG_COMBINERS)
                             : (D3DDIRTYFLAG_COMBINERS | 
                                D3DDIRTYFLAG_SHADER_STAGE_PROGRAM | 
                                D3DDIRTYFLAG_TEXTURE_STATE);

            D3D__TextureState[Stage][Type] = Value;
        }
        else if (Type < D3DTSS_DEFERRED_MAX)
        {
            D3D__DirtyFlags |= D3DDIRTYFROMTEXTURESTATE[Type];
            D3D__TextureState[Stage][Type] = Value;
        }
        else if (Type == D3DTSS_TEXCOORDINDEX)
        {
            D3DDevice_SetTextureState_TexCoordIndex(Stage, Value);
        }
        else if (Type == D3DTSS_BORDERCOLOR)
        {
            D3DDevice_SetTextureState_BorderColor(Stage, Value);
        }
        else if (Type == D3DTSS_COLORKEYCOLOR)
        {
            D3DDevice_SetTextureState_ColorKeyColor(Stage, Value);
        }
        else if ((Type >= D3DTSS_BUMPENVMAT00) && (Type <= D3DTSS_BUMPENVLOFFSET))
        {
            D3DDevice_SetTextureState_BumpEnv(Stage, Type, Value);
        }
    }

#endif

// Compatibility wrappers.

D3DINLINE ULONG   WINAPI IDirect3DDevice8_AddRef(D3DDevice *pThis) { return D3DDevice_AddRef(); }
D3DINLINE ULONG   WINAPI IDirect3DDevice8_Release(D3DDevice *pThis) { return D3DDevice_Release(); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetDirect3D(D3DDevice *pThis, Direct3D **ppD3D8) { D3DDevice_GetDirect3D(ppD3D8); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetDeviceCaps(D3DDevice *pThis, D3DCAPS8 *pCaps) { D3DDevice_GetDeviceCaps(pCaps); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetDisplayMode(D3DDevice *pThis, D3DDISPLAYMODE *pMode) { D3DDevice_GetDisplayMode(pMode); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetCreationParameters(D3DDevice *pThis, D3DDEVICE_CREATION_PARAMETERS *pParameters) { D3DDevice_GetCreationParameters(pParameters); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_Reset(D3DDevice *pThis, D3DPRESENT_PARAMETERS *pPresentationParameters) { return D3DDevice_Reset(pPresentationParameters); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_Present(D3DDevice *pThis, CONST RECT *pSourceRect, CONST RECT *pDestRect, void *pUnused, void *pUnused2) { D3DDevice_Swap(0); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetBackBuffer(D3DDevice *pThis, INT BackBuffer, D3DBACKBUFFER_TYPE Type, D3DSurface **ppBackBuffer) { D3DDevice_GetBackBuffer(BackBuffer, Type, ppBackBuffer); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetRasterStatus(D3DDevice *pThis, D3DRASTER_STATUS *pRasterStatus) { D3DDevice_GetRasterStatus(pRasterStatus); return S_OK; }
D3DINLINE void    WINAPI IDirect3DDevice8_SetFlickerFilter(D3DDevice *pThis, DWORD Filter) { D3DDevice_SetFlickerFilter(Filter); }
D3DINLINE void    WINAPI IDirect3DDevice8_SetSoftDisplayFilter(D3DDevice *pThis, BOOL Enable) { D3DDevice_SetSoftDisplayFilter(Enable); }
D3DINLINE void    WINAPI IDirect3DDevice8_SetGammaRamp(D3DDevice *pThis, DWORD Flags, CONST D3DGAMMARAMP *pRamp) { D3DDevice_SetGammaRamp(Flags, pRamp); }
D3DINLINE void    WINAPI IDirect3DDevice8_GetGammaRamp(D3DDevice *pThis, D3DGAMMARAMP *pRamp) { D3DDevice_GetGammaRamp(pRamp); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateTexture(D3DDevice *pThis, UINT Width, UINT Height, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DTexture **ppTexture) { return D3DDevice_CreateTexture(Width, Height, Levels, Usage, Format, Pool, ppTexture); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateVolumeTexture(D3DDevice *pThis, UINT Width, UINT Height, UINT Depth, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DVolumeTexture **ppVolumeTexture) { return D3DDevice_CreateVolumeTexture(Width, Height, Depth, Levels, Usage, Format, Pool, ppVolumeTexture); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateCubeTexture(D3DDevice *pThis, UINT EdgeLength, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DCubeTexture **ppCubeTexture) { return D3DDevice_CreateCubeTexture(EdgeLength, Levels, Usage, Format, Pool, ppCubeTexture); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateVertexBuffer(D3DDevice *pThis, UINT Length, DWORD Usage, DWORD FVF, D3DPOOL Pool, D3DVertexBuffer **ppVertexBuffer) { return D3DDevice_CreateVertexBuffer(Length, Usage, FVF, Pool, ppVertexBuffer); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateIndexBuffer(D3DDevice *pThis, UINT Length, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DIndexBuffer **ppIndexBuffer) { return D3DDevice_CreateIndexBuffer(Length, Usage, Format, Pool, ppIndexBuffer); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreatePalette(D3DDevice *pThis, D3DPALETTESIZE Size, D3DPalette **ppPalette) { return D3DDevice_CreatePalette(Size, ppPalette); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateRenderTarget(D3DDevice *pThis, UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, BOOL Lockable, D3DSurface **ppSurface) { return D3DDevice_CreateRenderTarget(Width, Height, Format, MultiSample, Lockable, ppSurface); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateDepthStencilSurface(D3DDevice *pThis, UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, D3DSurface **ppSurface) { return D3DDevice_CreateDepthStencilSurface(Width, Height, Format, MultiSample, ppSurface); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateImageSurface(D3DDevice *pThis, UINT Width, UINT Height, D3DFORMAT Format, D3DSurface **ppSurface) { return D3DDevice_CreateImageSurface(Width, Height, Format, ppSurface); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CopyRects(D3DDevice *pThis, D3DSurface *pSourceSurface, CONST RECT *pSourceRectsArray, UINT cRects, D3DSurface *pDestinationSurface, CONST POINT *pDestPointsArray) { D3DDevice_CopyRects(pSourceSurface, pSourceRectsArray, cRects, pDestinationSurface, pDestPointsArray); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetCopyRectsState(CONST D3DCOPYRECTSTATE *pCopyRectState, CONST D3DCOPYRECTROPSTATE *pCopyRectRopState) { D3DDevice_SetCopyRectsState(pCopyRectState, pCopyRectRopState); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetCopyRectsState(D3DCOPYRECTSTATE *pCopyRectState, D3DCOPYRECTROPSTATE *pCopyRectRopState) { D3DDevice_GetCopyRectsState(pCopyRectState, pCopyRectRopState); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetRenderTarget(D3DDevice *pThis, D3DSurface *pRenderTarget, D3DSurface *pNewZStencil) { D3DDevice_SetRenderTarget(pRenderTarget, pNewZStencil); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetRenderTarget(D3DDevice *pThis, D3DSurface **ppRenderTarget) { D3DDevice_GetRenderTarget(ppRenderTarget); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetDepthStencilSurface(D3DDevice *pThis, D3DSurface **ppZStencilSurface) { return D3DDevice_GetDepthStencilSurface(ppZStencilSurface); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_BeginScene(D3DDevice *pThis) { D3DDevice_BeginScene(); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_EndScene(D3DDevice *pThis) { D3DDevice_EndScene(); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_Clear(D3DDevice *pThis, DWORD Count, CONST D3DRECT *pRects, DWORD Flags, D3DCOLOR Color, float Z, DWORD Stencil) { D3DDevice_Clear(Count, pRects, Flags, Color, Z, Stencil); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetTransform(D3DDevice *pThis, D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix) { D3DDIRTY_TRANSFORM(State); D3DDevice_SetTransform(State, pMatrix); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetTransform(D3DDevice *pThis, D3DTRANSFORMSTATETYPE State, D3DMATRIX *pMatrix) { D3DDevice_GetTransform(State, pMatrix); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_MultiplyTransform(D3DDevice *pThis, D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix) { D3DDevice_MultiplyTransform(State, pMatrix); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetViewport(D3DDevice *pThis, CONST D3DVIEWPORT8 *pViewport) { D3DDIRTY_VIEWPORT(); D3DDevice_SetViewport(pViewport); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetViewport(D3DDevice *pThis, D3DVIEWPORT8 *pViewport) { D3DDevice_GetViewport(pViewport); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetMaterial(D3DDevice *pThis, CONST D3DMATERIAL8 *pMaterial) { D3DDIRTY_MATERIAL(); D3DDevice_SetMaterial(pMaterial); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetMaterial(D3DDevice *pThis, D3DMATERIAL8 *pMaterial) { D3DDevice_GetMaterial(pMaterial); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetBackMaterial(D3DDevice *pThis, CONST D3DMATERIAL8 *pMaterial) { D3DDIRTY_BACKMATERIAL(); D3DDevice_SetBackMaterial(pMaterial); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetBackMaterial(D3DDevice *pThis, D3DMATERIAL8 *pMaterial) { D3DDevice_GetBackMaterial(pMaterial); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetLight(D3DDevice *pThis, DWORD Index, CONST D3DLIGHT8 *pLight) { return D3DDevice_SetLight(Index, pLight); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetLight(D3DDevice *pThis, DWORD Index, D3DLIGHT8 *pLight) { D3DDevice_GetLight(Index, pLight); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_LightEnable(D3DDevice *pThis, DWORD Index, BOOL Enable) { return D3DDevice_LightEnable(Index, Enable); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetLightEnable(D3DDevice *pThis, DWORD Index, BOOL *pEnable) { D3DDevice_GetLightEnable(Index, pEnable); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetRenderState(D3DDevice *pThis, D3DRENDERSTATETYPE State, DWORD Value) { D3DDIRTY_RENDERSTATE(State); D3DDevice_SetRenderState(State, Value); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetRenderStateNotInline(D3DDevice *pThis, D3DRENDERSTATETYPE State, DWORD Value) { D3DDIRTY_RENDERSTATE(State); D3DDevice_SetRenderStateNotInline(State, Value); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetRenderState(D3DDevice *pThis, D3DRENDERSTATETYPE State, DWORD *pValue) { D3DDevice_GetRenderState(State, pValue); return S_OK; }
#if D3DCOMPILE_BEGINSTATEBLOCK
D3DINLINE HRESULT WINAPI IDirect3DDevice8_BeginStateBlock(D3DDevice *pThis) { D3DDevice_BeginStateBlock(); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_EndStateBlock(D3DDevice *pThis, DWORD *pToken) { return D3DDevice_EndStateBlock(pToken); }
#endif
D3DINLINE HRESULT WINAPI IDirect3DDevice8_ApplyStateBlock(D3DDevice *pThis, DWORD Token) { D3DDevice_ApplyStateBlock(Token); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CaptureStateBlock(D3DDevice *pThis, DWORD Token) { D3DDevice_CaptureStateBlock(Token); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DeleteStateBlock(D3DDevice *pThis, DWORD Token) { D3DDevice_DeleteStateBlock(Token); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateStateBlock(D3DDevice *pThis, D3DSTATEBLOCKTYPE Type,DWORD *pToken) { return D3DDevice_CreateStateBlock(Type, pToken); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetTexture(D3DDevice *pThis, DWORD Stage, D3DBaseTexture **ppTexture) { D3DDevice_GetTexture(Stage, ppTexture); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetTexture(D3DDevice *pThis, DWORD Stage, D3DBaseTexture *pTexture) { D3DDIRTY_TEXTURE(Stage); D3DDevice_SetTexture(Stage, pTexture); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetPalette(D3DDevice *pThis, DWORD Stage, D3DPalette **ppPalette) { D3DDevice_GetPalette(Stage, ppPalette); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetPalette(D3DDevice *pThis, DWORD Stage, D3DPalette *pPalette) { D3DDevice_SetPalette(Stage, pPalette); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetTextureStageState(D3DDevice *pThis, DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD *pValue) { D3DDevice_GetTextureStageState(Stage, Type, pValue); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetTextureStageState(D3DDevice *pThis, DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value) { D3DDIRTY_TEXTURESTATE(Stage, Type); D3DDevice_SetTextureStageState(Stage, Type, Value); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetTextureStageStateNotInline(D3DDevice *pThis, DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value) { D3DDIRTY_TEXTURESTATE(Stage, Type); D3DDevice_SetTextureStageStateNotInline(Stage, Type, Value); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawPrimitive(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT PrimitiveCount) { D3DDevice_DrawVertices(PrimitiveType, StartVertex, D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount)); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawIndexedPrimitive(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType, UINT MinIndex, UINT NumIndices, UINT StartIndex, UINT PrimitiveCount) { D3DDevice_DrawIndexedVertices(PrimitiveType, D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount), D3D__IndexData + StartIndex); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawPrimitiveUP(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType, UINT PrimitiveCount, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride) { D3DDevice_DrawVerticesUP(PrimitiveType, D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount), pVertexStreamZeroData, VertexStreamZeroStride); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawIndexedPrimitiveUP(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType, UINT MinVertexIndex, UINT NumVertexIndices, UINT PrimitiveCount, CONST void *pIndexData, D3DFORMAT IndexDataFormat, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride) { D3DDevice_DrawIndexedVerticesUP(PrimitiveType, D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount), pIndexData, pVertexStreamZeroData, VertexStreamZeroStride); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawVertices(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT VertexCount) { D3DDevice_DrawVertices(PrimitiveType, StartVertex, VertexCount); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawIndexedVertices(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, WORD *pIndexData) { D3DDevice_DrawIndexedVertices(PrimitiveType, VertexCount, pIndexData); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawVerticesUP(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride) { D3DDevice_DrawVerticesUP(PrimitiveType, VertexCount, pVertexStreamZeroData, VertexStreamZeroStride); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawIndexedVerticesUP(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST void *pIndexData, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride) { D3DDevice_DrawIndexedVerticesUP(PrimitiveType, VertexCount, pIndexData, pVertexStreamZeroData, VertexStreamZeroStride); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_PrimeVertexCache(D3DDevice *pThis, UINT VertexCount, CONST WORD *pIndexData) { D3DDevice_PrimeVertexCache(VertexCount, pIndexData); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateVertexShader(D3DDevice *pThis, CONST DWORD *pDeclaration, CONST DWORD *pFunction, DWORD *pHandle, DWORD Usage) { return D3DDevice_CreateVertexShader(pDeclaration, pFunction, pHandle, Usage); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexShader(D3DDevice *pThis, DWORD Handle) { D3DDIRTY_VERTEXSHADER(); D3DDevice_SetVertexShader(Handle); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVertexShader(D3DDevice *pThis, DWORD *pHandle) { D3DDevice_GetVertexShader(pHandle); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DeleteVertexShader(D3DDevice *pThis, DWORD Handle) { D3DDevice_DeleteVertexShader(Handle); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexShaderConstant(D3DDevice *pThis, INT Register, CONST void *pConstantData, DWORD ConstantCount) { D3DDIRTY_VERTEXSHADERCONSTANT(Register, ConstantCount); D3DDevice_SetVertexShaderConstant(Register, pConstantData, ConstantCount); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVertexShaderConstant(D3DDevice *pThis, INT Register, void *pConstantData, DWORD ConstantCount) { D3DDevice_GetVertexShaderConstant(Register, pConstantData, ConstantCount); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetShaderConstantMode(D3DDevice *pThis, D3DSHADERCONSTANTMODE Mode) { D3DDevice_SetShaderConstantMode(Mode); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetShaderConstantMode(D3DDevice *pThis, D3DSHADERCONSTANTMODE *pMode) { D3DDevice_GetShaderConstantMode(pMode); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_LoadVertexShader(D3DDevice *pThis, DWORD Handle, DWORD Address) { D3DDevice_LoadVertexShader(Handle, Address); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_LoadVertexShaderProgram(D3DDevice *pThis, CONST DWORD *pFunction, DWORD Address) { D3DDevice_LoadVertexShaderProgram(pFunction, Address); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SelectVertexShader(D3DDevice *pThis, DWORD Handle, DWORD Address) { D3DDevice_SelectVertexShader(Handle, Address); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SelectVertexShaderDirect(D3DDevice *pThis, D3DVERTEXATTRIBUTEFORMAT *pVAF, DWORD Address) { D3DDevice_SelectVertexShaderDirect(pVAF, Address); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_RunVertexStateShader(D3DDevice *pThis, DWORD Address, CONST float *pData) { D3DDevice_RunVertexStateShader(Address, pData); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVertexShaderSize(D3DDevice *pThis, DWORD Handle, UINT* pSize) { D3DDevice_GetVertexShaderSize(Handle, pSize); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVertexShaderType(D3DDevice *pThis, DWORD Handle, DWORD* pType) { D3DDevice_GetVertexShaderType(Handle, pType); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVertexShaderDeclaration(D3DDevice *pThis, DWORD Handle, void *pData, DWORD *pSizeOfData) { return D3DDevice_GetVertexShaderDeclaration(Handle, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVertexShaderFunction(D3DDevice *pThis, DWORD Handle,void *pData, DWORD *pSizeOfData) { return D3DDevice_GetVertexShaderFunction(Handle, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetStreamSource(D3DDevice *pThis, UINT StreamNumber, D3DVertexBuffer *pStreamData, UINT Stride) { D3DDIRTY_STREAM(StreamNumber); D3DDevice_SetStreamSource(StreamNumber, pStreamData, Stride); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetStreamSource(D3DDevice *pThis, UINT StreamNumber, D3DVertexBuffer **ppStreamData, UINT *pStride) { D3DDevice_GetStreamSource(StreamNumber, ppStreamData, pStride); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetIndices(D3DDevice *pThis, D3DIndexBuffer* pIndexData, UINT BaseVertexIndex) { D3DDIRTY_INDICES(); D3DDevice_SetIndices(pIndexData, BaseVertexIndex); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetIndices(D3DDevice *pThis, D3DIndexBuffer** ppIndexData, UINT *pBaseVertexIndex) { D3DDevice_GetIndices(ppIndexData, pBaseVertexIndex); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreatePixelShader(D3DDevice *pThis, CONST D3DPIXELSHADERDEF *pPSDef, DWORD *pHandle) { D3DDevice_CreatePixelShader(pPSDef, pHandle); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetPixelShader(D3DDevice *pThis, DWORD Handle) { D3DDIRTY_PIXELSHADER(); D3DDevice_SetPixelShader(Handle); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetPixelShaderProgram(D3DDevice *pThis, CONST D3DPIXELSHADERDEF *pPSDef) { D3DDIRTY_PIXELSHADER(); D3DDevice_SetPixelShaderProgram(pPSDef); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetPixelShader(D3DDevice *pThis, DWORD *pHandle) { D3DDevice_GetPixelShader(pHandle); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DeletePixelShader(D3DDevice *pThis, DWORD Handle) { D3DDevice_DeletePixelShader(Handle); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetPixelShaderConstant(D3DDevice *pThis, DWORD Register, CONST void *pConstantData, DWORD ConstantCount) { D3DDIRTY_PIXELSHADERCONSTANT(Register, ConstantCount); D3DDevice_SetPixelShaderConstant(Register, pConstantData, ConstantCount); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetPixelShaderConstant(D3DDevice *pThis, DWORD Register, void *pConstantData, DWORD ConstantCount) { D3DDevice_GetPixelShaderConstant(Register, pConstantData, ConstantCount); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetPixelShaderFunction(D3DDevice *pThis, DWORD Handle, D3DPIXELSHADERDEF *pData) { D3DDevice_GetPixelShaderFunction(Handle, pData); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawRectPatch(D3DDevice *pThis, UINT Handle, CONST float *pNumSegs, CONST D3DRECTPATCH_INFO *pRectPatchInfo) { return D3DDevice_DrawRectPatch(Handle, pNumSegs, pRectPatchInfo); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawTriPatch(D3DDevice *pThis, UINT Handle, CONST float *pNumSegs, CONST D3DTRIPATCH_INFO *pTriPatchInfo) { return D3DDevice_DrawTriPatch(Handle, pNumSegs, pTriPatchInfo); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DeletePatch(D3DDevice *pThis, UINT Handle) { D3DDevice_DeletePatch(Handle); return S_OK; }
D3DINLINE BOOL    WINAPI IDirect3DDevice8_IsBusy(D3DDevice *pThis) { return D3DDevice_IsBusy(); }
D3DINLINE void    WINAPI IDirect3DDevice8_BlockUntilIdle(D3DDevice *pThis) { D3DDevice_BlockUntilIdle(); }
D3DINLINE void    WINAPI IDirect3DDevice8_KickPushBuffer(D3DDevice *pThis) { D3DDevice_KickPushBuffer(); }
D3DINLINE void    WINAPI IDirect3DDevice8_SetVerticalBlankCallback(D3DDevice *pThis, D3DVBLANKCALLBACK pCallback) { D3DDevice_SetVerticalBlankCallback(pCallback); }
D3DINLINE void    WINAPI IDirect3DDevice8_SetSwapCallback(D3DDevice *pThis, D3DSWAPCALLBACK pCallback) { D3DDevice_SetSwapCallback(pCallback); }
D3DINLINE void    WINAPI IDirect3DDevice8_BlockUntilVerticalBlank(D3DDevice *pThis) { D3DDevice_BlockUntilVerticalBlank(); }
D3DINLINE DWORD   WINAPI IDirect3DDevice8_InsertFence(D3DDevice *pThis) { return D3DDevice_InsertFence(); }
D3DINLINE BOOL    WINAPI IDirect3DDevice8_IsFencePending(D3DDevice *pThis, DWORD Fence) { return D3DDevice_IsFencePending(Fence); }
D3DINLINE VOID    WINAPI IDirect3DDevice8_BlockOnFence(D3DDevice *pThis, DWORD Fence) { D3DDevice_BlockOnFence(Fence); }
D3DINLINE void    WINAPI IDirect3DDevice8_InsertCallback(D3DDevice *pThis, D3DCALLBACKTYPE Type, D3DCALLBACK pCallback, DWORD Context) { D3DDevice_InsertCallback(Type, pCallback, Context); }
D3DINLINE void    WINAPI IDirect3DDevice8_FlushVertexCache(D3DDevice *pThis) { D3DDevice_FlushVertexCache(); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_PersistDisplay(D3DDevice *pThis) { return D3DDevice_PersistDisplay(); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetPersistedSurface(D3DDevice *pThis, IDirect3DSurface8 **ppSurface) { D3DDevice_GetPersistedSurface(ppSurface); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_UpdateOverlay(D3DDevice *pThis, D3DSurface *pSurface, CONST RECT *SrcRect, CONST RECT *DstRect, BOOL EnableColorKey, D3DCOLOR ColorKey) { D3DDevice_UpdateOverlay(pSurface, SrcRect, DstRect, EnableColorKey, ColorKey); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_EnableOverlay(D3DDevice *pThis, BOOL Enable) { D3DDevice_EnableOverlay(Enable); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_BeginVisibilityTest(D3DDevice *pThis) { D3DDevice_BeginVisibilityTest(); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_EndVisibilityTest(D3DDevice *pThis, DWORD Index) { return D3DDevice_EndVisibilityTest(Index); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVisibilityTestResult(D3DDevice *pThis, DWORD Index, UINT *pResult, ULONGLONG *pTimeStamp) { return D3DDevice_GetVisibilityTestResult(Index, pResult, pTimeStamp); }
D3DINLINE BOOL    WINAPI IDirect3DDevice8_GetOverlayUpdateStatus(D3DDevice *pThis) { return D3DDevice_GetOverlayUpdateStatus(); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetDisplayFieldStatus(D3DDevice *pThis, D3DFIELD_STATUS *pFieldStatus) { D3DDevice_GetDisplayFieldStatus(pFieldStatus); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexData2f(D3DDevice *pThis, INT Register, float a, float b) { D3DDevice_SetVertexData2f(Register, a, b); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexData4f(D3DDevice *pThis, INT Register, float a, float b, float c, float d) { D3DDevice_SetVertexData4f(Register, a, b, c, d); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexData2s(D3DDevice *pThis, INT Register, SHORT a, SHORT b) { D3DDevice_SetVertexData2s(Register, a, b); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexData4s(D3DDevice *pThis, INT Register, SHORT a, SHORT b, SHORT c, SHORT d) { D3DDevice_SetVertexData4s(Register, a, b, c, d); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexData4ub(D3DDevice *pThis, INT Register, BYTE a, BYTE b, BYTE c, BYTE d) { D3DDevice_SetVertexData4ub(Register, a, b, c, d); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexDataColor(D3DDevice *pThis, INT Register, D3DCOLOR Color) { D3DDevice_SetVertexDataColor(Register, Color); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_Begin(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType) { D3DDevice_Begin(PrimitiveType); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_End(D3DDevice *pThis) { D3DDevice_End(); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateFixup(D3DDevice *pThis, UINT Size, D3DFixup **ppFixup) { return D3DDevice_CreateFixup(Size, ppFixup); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreatePushBuffer(D3DDevice *pThis, UINT Size, BOOL RunUsingCpuCopy, D3DPushBuffer** ppPushBuffer) { return D3DDevice_CreatePushBuffer(Size, RunUsingCpuCopy, ppPushBuffer); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_BeginPushBuffer(D3DDevice *pThis, D3DPushBuffer *pPushBuffer) { D3DDevice_BeginPushBuffer(pPushBuffer); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_EndPushBuffer(D3DDevice *pThis) { return D3DDevice_EndPushBuffer(); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_RunPushBuffer(D3DDevice *pThis, D3DPushBuffer* pPushBuffer, D3DFixup *pFixup) { D3DDevice_RunPushBuffer(pPushBuffer, pFixup); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetPushBufferOffset(D3DDevice *pThis, DWORD* pOffset) { D3DDevice_GetPushBufferOffset(pOffset); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_Nop(D3DDevice *pThis) { D3DDevice_Nop(); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetProjectionViewportMatrix(D3DDevice *pThis, D3DMATRIX* pProjectionViewport) { D3DDevice_GetProjectionViewportMatrix(pProjectionViewport); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetModelView(D3DDevice *pThis, CONST D3DMATRIX* pModelView, CONST D3DMATRIX* pInverseModelView, CONST D3DMATRIX* pComposite) { D3DDevice_SetModelView(pModelView, pInverseModelView, pComposite); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetModelView(D3DDevice *pThis, D3DMATRIX* pModelView) { return D3DDevice_GetModelView(pModelView); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexBlendModelView(D3DDevice *pThis, UINT Count, CONST D3DMATRIX* pModelViews, CONST D3DMATRIX* pInverseModelViews, CONST D3DMATRIX* pProjectionViewport) { D3DDevice_SetVertexBlendModelView(Count, pModelViews, pInverseModelViews, pProjectionViewport); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVertexBlendModelView(D3DDevice *pThis, UINT Count, D3DMATRIX* pModelViews, D3DMATRIX* pProjectionViewport) { return D3DDevice_GetVertexBlendModelView(Count, pModelViews, pProjectionViewport); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexShaderInput(D3DDevice *pThis, DWORD Handle, UINT StreamCount, CONST D3DSTREAM_INPUT* pStreamInputs) { D3DDevice_SetVertexShaderInput(Handle, StreamCount, pStreamInputs); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexShaderInputDirect(D3DDevice *pThis, D3DVERTEXATTRIBUTEFORMAT *pVAF, UINT StreamCount, CONST D3DSTREAM_INPUT* pStreamInputs) { D3DDevice_SetVertexShaderInputDirect(pVAF, StreamCount, pStreamInputs); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVertexShaderInput(D3DDevice *pThis, DWORD* pHandle, UINT* pStreamCount, D3DSTREAM_INPUT* pStreamInputs) { return D3DDevice_GetVertexShaderInput(pHandle, pStreamCount, pStreamInputs); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SwitchTexture(D3DDevice *pThis, DWORD Stage, D3DBaseTexture *pTexture) { D3DDevice_SwitchTexture(D3DTEXTUREDIRECTENCODE[Stage], (pTexture)->Data, (pTexture)->Format); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_Suspend(D3DDevice *pThis) { D3DDevice_Suspend(); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_Resume(D3DDevice *pThis, BOOL Reset) { D3DDevice_Resume(Reset); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetScissors(D3DDevice *pThis, DWORD Count, BOOL Exclusive, CONST D3DRECT *pRects) { D3DDevice_SetScissors(Count, Exclusive, pRects); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetScissors(D3DDevice *pThis, DWORD* pCount, BOOL *pExclusive, D3DRECT *pRects) { D3DDevice_GetScissors(pCount, pExclusive, pRects); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetTile(D3DDevice *pThis, DWORD Index, CONST D3DTILE* pTile) { D3DDevice_SetTile(Index, pTile); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetTile(D3DDevice *pThis, DWORD Index, D3DTILE* pTile) { D3DDevice_GetTile(Index, pTile); return S_OK; }
D3DINLINE DWORD   WINAPI IDirect3DDevice8_GetTileCompressionTags(D3DDevice *pThis, DWORD ZStartTag, DWORD ZEndTag) { return D3DDevice_GetTileCompressionTags(ZStartTag, ZEndTag); }
D3DINLINE void    WINAPI IDirect3DDevice8_SetTileCompressionTagBits(D3DDevice *pThis, DWORD Partition, DWORD Address, CONST DWORD *pData, DWORD Count) { D3DDevice_SetTileCompressionTagBits(Partition, Address, pData, Count); }
D3DINLINE void    WINAPI IDirect3DDevice8_GetTileCompressionTagBits(D3DDevice *pThis, DWORD Partition, DWORD Address, DWORD *pData, DWORD Count) { D3DDevice_GetTileCompressionTagBits(Partition, Address, pData, Count); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_BeginPush(D3DDevice *pThis, DWORD Count, DWORD **ppPush) { D3DDevice_BeginPush(Count, ppPush); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_EndPush(D3DDevice *pThis, DWORD *pPush) { D3DDevice_EndPush(pPush); return S_OK; }
D3DINLINE DWORD   WINAPI IDirect3DDevice8_Swap(DWORD Flags) { return D3DDevice_Swap(Flags); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetBackBufferScale(float x, float y) { D3DDevice_SetBackBufferScale(x, y); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetBackBufferScale(float *pX, float *pY) { D3DDevice_GetBackBufferScale(pX, pY); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetScreenSpaceOffset(float x, float y) { D3DDevice_SetScreenSpaceOffset(x, y); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetScreenSpaceOffset(float *pX, float *pY) { D3DDevice_GetScreenSpaceOffset(pX, pY); return S_OK; }
D3DINLINE void    WINAPI IDirect3DDevice8_SetOverscanColor(D3DCOLOR Color) { D3DDevice_SetOverscanColor(Color); }
D3DINLINE D3DCOLOR WINAPI IDirect3DDevice8_GetOverscanColor() { return D3DDevice_GetOverscanColor(); }                                                                                                                                 
#ifdef _DEBUG
D3DINLINE DWORD   WINAPI IDirect3DDevice8_SetDebugMarker(DWORD Marker) { return D3DDevice_SetDebugMarker(Marker); }
D3DINLINE DWORD   WINAPI IDirect3DDevice8_GetDebugMarker() { return D3DDevice_GetDebugMarker(); }
#else
D3DINLINE DWORD   WINAPI IDirect3DDevice8_SetDebugMarker(DWORD Marker) { return 0; }
D3DINLINE DWORD   WINAPI IDirect3DDevice8_GetDebugMarker() { return 0; }
#endif

#ifdef __cplusplus

D3DMINLINE ULONG   WINAPI D3DDevice::AddRef() { return D3DDevice_AddRef(); }
D3DMINLINE ULONG   WINAPI D3DDevice::Release() { return D3DDevice_Release(); }
D3DMINLINE HRESULT WINAPI D3DDevice::GetDirect3D(Direct3D **ppD3D8) { D3DDevice_GetDirect3D(ppD3D8); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetDeviceCaps(D3DCAPS8 *pCaps) { D3DDevice_GetDeviceCaps(pCaps); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetDisplayMode(D3DDISPLAYMODE *pMode) { D3DDevice_GetDisplayMode(pMode); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetCreationParameters(D3DDEVICE_CREATION_PARAMETERS *pParameters) { D3DDevice_GetCreationParameters(pParameters); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::Reset(D3DPRESENT_PARAMETERS *pPresentationParameters) { return D3DDevice_Reset(pPresentationParameters); }
D3DMINLINE HRESULT WINAPI D3DDevice::Present(CONST RECT *pSourceRect, CONST RECT *pDestRect, void *pUnused, void *pUnused2) { D3DDevice_Swap(0); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetBackBuffer(INT BackBuffer, D3DBACKBUFFER_TYPE Type, D3DSurface **ppBackBuffer) { D3DDevice_GetBackBuffer(BackBuffer, Type, ppBackBuffer); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetRasterStatus(D3DRASTER_STATUS *pRasterStatus) { D3DDevice_GetRasterStatus(pRasterStatus); return S_OK; }
D3DMINLINE void    WINAPI D3DDevice::SetFlickerFilter(DWORD Filter) { D3DDevice_SetFlickerFilter(Filter); }
D3DMINLINE void    WINAPI D3DDevice::SetSoftDisplayFilter(BOOL Enable) { D3DDevice_SetSoftDisplayFilter(Enable); }
D3DMINLINE void    WINAPI D3DDevice::SetGammaRamp(DWORD Flags, CONST D3DGAMMARAMP *pRamp) { D3DDevice_SetGammaRamp(Flags, pRamp); }
D3DMINLINE void    WINAPI D3DDevice::GetGammaRamp(D3DGAMMARAMP *pRamp) { D3DDevice_GetGammaRamp(pRamp); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateTexture(UINT Width, UINT Height, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DTexture **ppTexture) { return D3DDevice_CreateTexture(Width, Height, Levels, Usage, Format, Pool, ppTexture); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateVolumeTexture(UINT Width, UINT Height, UINT Depth, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DVolumeTexture **ppVolumeTexture) { return D3DDevice_CreateVolumeTexture(Width, Height, Depth, Levels, Usage, Format, Pool, ppVolumeTexture); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateCubeTexture(UINT EdgeLength, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DCubeTexture **ppCubeTexture) { return D3DDevice_CreateCubeTexture(EdgeLength, Levels, Usage, Format, Pool, ppCubeTexture); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateVertexBuffer(UINT Length, DWORD Usage, DWORD FVF, D3DPOOL Pool, D3DVertexBuffer **ppVertexBuffer) { return D3DDevice_CreateVertexBuffer(Length, Usage, FVF, Pool, ppVertexBuffer); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateIndexBuffer(UINT Length, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DIndexBuffer **ppIndexBuffer) { return D3DDevice_CreateIndexBuffer(Length, Usage, Format, Pool, ppIndexBuffer); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreatePalette(D3DPALETTESIZE Size, D3DPalette **ppPalette) { return D3DDevice_CreatePalette(Size, ppPalette); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateRenderTarget(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, BOOL Lockable, D3DSurface **ppSurface) { return D3DDevice_CreateRenderTarget(Width, Height, Format, MultiSample, Lockable, ppSurface); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateDepthStencilSurface(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, D3DSurface **ppSurface) { return D3DDevice_CreateDepthStencilSurface(Width, Height, Format, MultiSample, ppSurface); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateImageSurface(UINT Width, UINT Height, D3DFORMAT Format, D3DSurface **ppSurface) { return D3DDevice_CreateImageSurface(Width, Height, Format, ppSurface); }
D3DMINLINE HRESULT WINAPI D3DDevice::CopyRects(D3DSurface *pSourceSurface, CONST RECT *pSourceRectsArray, UINT cRects, D3DSurface *pDestinationSurface, CONST POINT *pDestPointsArray) { D3DDevice_CopyRects(pSourceSurface, pSourceRectsArray, cRects, pDestinationSurface, pDestPointsArray); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetCopyRectsState(CONST D3DCOPYRECTSTATE *pCopyRectState, CONST D3DCOPYRECTROPSTATE *pCopyRectRopState) { D3DDevice_SetCopyRectsState(pCopyRectState, pCopyRectRopState); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetCopyRectsState(D3DCOPYRECTSTATE *pCopyRectState, D3DCOPYRECTROPSTATE *pCopyRectRopState) { D3DDevice_GetCopyRectsState(pCopyRectState, pCopyRectRopState); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetRenderTarget(D3DSurface *pRenderTarget, D3DSurface *pNewZStencil) { D3DDevice_SetRenderTarget(pRenderTarget, pNewZStencil); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetRenderTarget(D3DSurface **ppRenderTarget) { D3DDevice_GetRenderTarget(ppRenderTarget); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetDepthStencilSurface(D3DSurface **ppZStencilSurface) { return D3DDevice_GetDepthStencilSurface(ppZStencilSurface); }
D3DMINLINE HRESULT WINAPI D3DDevice::BeginScene() { D3DDevice_BeginScene(); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::EndScene() { D3DDevice_EndScene(); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::Clear(DWORD Count, CONST D3DRECT *pRects, DWORD Flags, D3DCOLOR Color, float Z, DWORD Stencil) { D3DDevice_Clear(Count, pRects, Flags, Color, Z, Stencil); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetTransform(D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix) { D3DDIRTY_TRANSFORM(State); D3DDevice_SetTransform(State, pMatrix); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetTransform(D3DTRANSFORMSTATETYPE State, D3DMATRIX *pMatrix) { D3DDevice_GetTransform(State, pMatrix); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::MultiplyTransform(D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix) { D3DDevice_MultiplyTransform(State, pMatrix); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetViewport(CONST D3DVIEWPORT8 *pViewport) { D3DDIRTY_VIEWPORT(); D3DDevice_SetViewport(pViewport); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetViewport(D3DVIEWPORT8 *pViewport) { D3DDevice_GetViewport(pViewport); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetMaterial(CONST D3DMATERIAL8 *pMaterial) { D3DDIRTY_MATERIAL(); D3DDevice_SetMaterial(pMaterial); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetMaterial(D3DMATERIAL8 *pMaterial) { D3DDevice_GetMaterial(pMaterial); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetBackMaterial(CONST D3DMATERIAL8 *pBackMaterial) { D3DDIRTY_BACKMATERIAL(); D3DDevice_SetBackMaterial(pBackMaterial); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetBackMaterial(D3DMATERIAL8 *pBackMaterial) { D3DDevice_GetBackMaterial(pBackMaterial); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetLight(DWORD Index, CONST D3DLIGHT8 *pLight) { return D3DDevice_SetLight(Index, pLight); }
D3DMINLINE HRESULT WINAPI D3DDevice::GetLight(DWORD Index, D3DLIGHT8 *pLight) { D3DDevice_GetLight(Index, pLight); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::LightEnable(DWORD Index, BOOL Enable) { return D3DDevice_LightEnable(Index, Enable); }
D3DMINLINE HRESULT WINAPI D3DDevice::GetLightEnable(DWORD Index, BOOL *pEnable) { D3DDevice_GetLightEnable(Index, pEnable); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetRenderState(D3DRENDERSTATETYPE State, DWORD Value) { D3DDIRTY_RENDERSTATE(State); D3DDevice_SetRenderState(State, Value); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetRenderStateNotInline(D3DRENDERSTATETYPE State, DWORD Value) { D3DDIRTY_RENDERSTATE(State); D3DDevice_SetRenderStateNotInline(State, Value); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetRenderState(D3DRENDERSTATETYPE State, DWORD *pValue) { D3DDevice_GetRenderState(State, pValue); return S_OK; }
#if D3DCOMPILE_BEGINSTATEBLOCK
D3DMINLINE HRESULT WINAPI D3DDevice::BeginStateBlock() { D3DDevice_BeginStateBlock(); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::EndStateBlock(DWORD *pToken) { return D3DDevice_EndStateBlock(pToken); }
#endif
D3DMINLINE HRESULT WINAPI D3DDevice::ApplyStateBlock(DWORD Token) { D3DDevice_ApplyStateBlock(Token); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::CaptureStateBlock(DWORD Token) { D3DDevice_CaptureStateBlock(Token); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DeleteStateBlock(DWORD Token) { D3DDevice_DeleteStateBlock(Token); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateStateBlock(D3DSTATEBLOCKTYPE Type,DWORD *pToken) { return D3DDevice_CreateStateBlock(Type, pToken); }
D3DMINLINE HRESULT WINAPI D3DDevice::GetTexture(DWORD Stage, D3DBaseTexture **ppTexture) { D3DDevice_GetTexture(Stage, ppTexture); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetTexture(DWORD Stage, D3DBaseTexture *pTexture) { D3DDIRTY_TEXTURE(Stage); D3DDevice_SetTexture(Stage, pTexture); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetPalette(DWORD Stage, D3DPalette **ppPalette) { D3DDevice_GetPalette(Stage, ppPalette); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetPalette(DWORD Stage, D3DPalette *pPalette) { D3DDevice_SetPalette(Stage, pPalette); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD *pValue) { D3DDevice_GetTextureStageState(Stage, Type, pValue); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value) { D3DDIRTY_TEXTURESTATE(Stage, Type); D3DDevice_SetTextureStageState(Stage, Type, Value); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetTextureStageStateNotInline(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value) { D3DDIRTY_TEXTURESTATE(Stage, Type); D3DDevice_SetTextureStageStateNotInline(Stage, Type, Value); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawPrimitive(D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT PrimitiveCount) { D3DDevice_DrawVertices(PrimitiveType, StartVertex, D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount)); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawIndexedPrimitive(D3DPRIMITIVETYPE PrimitiveType, UINT MinIndex, UINT NumIndices, UINT StartIndex, UINT PrimitiveCount) { D3DDevice_DrawIndexedVertices(PrimitiveType, D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount), D3D__IndexData + StartIndex); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType, UINT PrimitiveCount, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride) { D3DDevice_DrawVerticesUP(PrimitiveType, D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount), pVertexStreamZeroData, VertexStreamZeroStride); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawIndexedPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType, UINT MinVertexIndex, UINT NumVertexIndices, UINT PrimitiveCount, CONST void *pIndexData, D3DFORMAT IndexDataFormat, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride) { D3DDevice_DrawIndexedVerticesUP(PrimitiveType, D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount), pIndexData, pVertexStreamZeroData, VertexStreamZeroStride); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawVertices(D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT VertexCount) { D3DDevice_DrawVertices(PrimitiveType, StartVertex, VertexCount); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawIndexedVertices(D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST WORD* pIndexData) { D3DDevice_DrawIndexedVertices(PrimitiveType, VertexCount, pIndexData); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawVerticesUP(D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride) { D3DDevice_DrawVerticesUP(PrimitiveType, VertexCount, pVertexStreamZeroData, VertexStreamZeroStride); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawIndexedVerticesUP(D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST void *pIndexData, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride) { D3DDevice_DrawIndexedVerticesUP(PrimitiveType, VertexCount, pIndexData, pVertexStreamZeroData, VertexStreamZeroStride); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::PrimeVertexCache(UINT VertexCount, CONST WORD *pIndexData) { D3DDevice_PrimeVertexCache(VertexCount, pIndexData); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateVertexShader(CONST DWORD *pDeclaration, CONST DWORD *pFunction, DWORD *pHandle, DWORD Usage) { return D3DDevice_CreateVertexShader(pDeclaration, pFunction, pHandle, Usage); }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexShader(DWORD Handle) { D3DDIRTY_VERTEXSHADER(); D3DDevice_SetVertexShader(Handle); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVertexShader(DWORD *pHandle) { D3DDevice_GetVertexShader(pHandle); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetShaderConstantMode(D3DSHADERCONSTANTMODE Mode) { D3DDevice_SetShaderConstantMode(Mode); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetShaderConstantMode(D3DSHADERCONSTANTMODE *pMode) { D3DDevice_GetShaderConstantMode(pMode); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::LoadVertexShader(DWORD Handle, DWORD Address) { D3DDevice_LoadVertexShader(Handle, Address); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::LoadVertexShaderProgram(CONST DWORD *pFunction, DWORD Address) { D3DDevice_LoadVertexShaderProgram(pFunction, Address); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SelectVertexShader(DWORD Handle, DWORD Address) { D3DDevice_SelectVertexShader(Handle, Address); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SelectVertexShaderDirect(D3DVERTEXATTRIBUTEFORMAT *pVAF, DWORD Address) { D3DDevice_SelectVertexShaderDirect(pVAF, Address); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::RunVertexStateShader(DWORD Address, CONST float *pData) { D3DDevice_RunVertexStateShader(Address, pData); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVertexShaderSize(DWORD Handle, UINT *pSize) { D3DDevice_GetVertexShaderSize(Handle, pSize); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVertexShaderType(DWORD Handle, DWORD *pType) { D3DDevice_GetVertexShaderType(Handle, pType); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVertexShaderDeclaration(DWORD Handle, void *pData, DWORD *pSizeOfData) { return D3DDevice_GetVertexShaderDeclaration(Handle, pData, pSizeOfData); }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVertexShaderFunction(DWORD Handle, void *pData, DWORD *pSizeOfData) { return D3DDevice_GetVertexShaderFunction(Handle, pData, pSizeOfData); }
D3DMINLINE HRESULT WINAPI D3DDevice::DeleteVertexShader(DWORD Handle) { D3DDevice_DeleteVertexShader(Handle); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexShaderConstant(INT Register, CONST void *pConstantData, DWORD ConstantCount) { D3DDIRTY_VERTEXSHADERCONSTANT(Register, ConstantCount); D3DDevice_SetVertexShaderConstant(Register, pConstantData, ConstantCount); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVertexShaderConstant(INT Register, void *pConstantData, DWORD ConstantCount) { D3DDevice_GetVertexShaderConstant(Register, pConstantData, ConstantCount); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetStreamSource(UINT StreamNumber, D3DVertexBuffer *pStreamData, UINT Stride) { D3DDIRTY_STREAM(StreamNumber); D3DDevice_SetStreamSource(StreamNumber, pStreamData, Stride); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetStreamSource(UINT StreamNumber, D3DVertexBuffer **ppStreamData, UINT *pStride) { D3DDevice_GetStreamSource(StreamNumber, ppStreamData, pStride); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetIndices(D3DIndexBuffer* pIndexData, UINT BaseVertexIndex) { D3DDIRTY_INDICES(); D3DDevice_SetIndices(pIndexData, BaseVertexIndex); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetIndices(D3DIndexBuffer** ppIndexData, UINT *pBaseVertexIndex) { D3DDevice_GetIndices(ppIndexData, pBaseVertexIndex); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::CreatePixelShader(CONST D3DPIXELSHADERDEF *pPSDef, DWORD *pHandle) { D3DDevice_CreatePixelShader(pPSDef, pHandle); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetPixelShader(DWORD Handle) { D3DDIRTY_PIXELSHADER(); D3DDevice_SetPixelShader(Handle); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetPixelShaderProgram(CONST D3DPIXELSHADERDEF *pPSDef) { D3DDIRTY_PIXELSHADER(); D3DDevice_SetPixelShaderProgram(pPSDef); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetPixelShader(DWORD *pHandle) { D3DDevice_GetPixelShader(pHandle); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DeletePixelShader(DWORD Handle) { D3DDevice_DeletePixelShader(Handle); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetPixelShaderConstant(DWORD Register, CONST void *pConstantData, DWORD ConstantCount) { D3DDIRTY_PIXELSHADERCONSTANT(Register, ConstantCount); D3DDevice_SetPixelShaderConstant(Register, pConstantData, ConstantCount); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetPixelShaderConstant(DWORD Register, void *pConstantData, DWORD ConstantCount) { D3DDevice_GetPixelShaderConstant(Register, pConstantData, ConstantCount); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetPixelShaderFunction(DWORD Handle, D3DPIXELSHADERDEF *pData) { D3DDevice_GetPixelShaderFunction(Handle, pData); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawRectPatch(UINT Handle, CONST float *pNumSegs, CONST D3DRECTPATCH_INFO *pRectPatchInfo) { return D3DDevice_DrawRectPatch(Handle, pNumSegs, pRectPatchInfo); }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawTriPatch(UINT Handle, CONST float *pNumSegs, CONST D3DTRIPATCH_INFO *pTriPatchInfo) { return D3DDevice_DrawTriPatch(Handle, pNumSegs, pTriPatchInfo); }
D3DMINLINE HRESULT WINAPI D3DDevice::DeletePatch(UINT Handle) { D3DDevice_DeletePatch(Handle); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::UpdateOverlay(D3DSurface *pSurface, CONST RECT *SrcRect, CONST RECT *DstRect, BOOL EnableColorKey, D3DCOLOR ColorKey) { D3DDevice_UpdateOverlay(pSurface, SrcRect, DstRect, EnableColorKey, ColorKey); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::EnableOverlay(BOOL Enable) { D3DDevice_EnableOverlay(Enable); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::BeginVisibilityTest() { D3DDevice_BeginVisibilityTest(); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::EndVisibilityTest(DWORD Index) { return D3DDevice_EndVisibilityTest(Index); }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVisibilityTestResult(DWORD Index, UINT *pResult, ULONGLONG *pTimeStamp) { return D3DDevice_GetVisibilityTestResult(Index, pResult, pTimeStamp); }
D3DMINLINE BOOL    WINAPI D3DDevice::IsBusy() { return D3DDevice_IsBusy(); }
D3DMINLINE void    WINAPI D3DDevice::BlockUntilIdle() { D3DDevice_BlockUntilIdle(); }
D3DMINLINE void    WINAPI D3DDevice::KickPushBuffer() { D3DDevice_KickPushBuffer(); }
D3DMINLINE void    WINAPI D3DDevice::SetVerticalBlankCallback(D3DVBLANKCALLBACK pCallback) { D3DDevice_SetVerticalBlankCallback(pCallback); }
D3DMINLINE void    WINAPI D3DDevice::SetSwapCallback(D3DSWAPCALLBACK pCallback) { D3DDevice_SetSwapCallback(pCallback); }
D3DMINLINE void    WINAPI D3DDevice::BlockUntilVerticalBlank() { D3DDevice_BlockUntilVerticalBlank(); }
D3DMINLINE DWORD   WINAPI D3DDevice::InsertFence() { return D3DDevice_InsertFence(); }
D3DMINLINE BOOL    WINAPI D3DDevice::IsFencePending(DWORD Fence) { return D3DDevice_IsFencePending(Fence); }
D3DMINLINE void    WINAPI D3DDevice::BlockOnFence(DWORD Fence) { D3DDevice_BlockOnFence(Fence); }
D3DMINLINE void    WINAPI D3DDevice::InsertCallback(D3DCALLBACKTYPE Type, D3DCALLBACK pCallback, DWORD Context) { D3DDevice_InsertCallback(Type, pCallback, Context); }
D3DMINLINE void    WINAPI D3DDevice::FlushVertexCache() { D3DDevice_FlushVertexCache(); }
D3DMINLINE HRESULT WINAPI D3DDevice::PersistDisplay() { return D3DDevice_PersistDisplay(); }
D3DMINLINE HRESULT WINAPI D3DDevice::GetPersistedSurface(IDirect3DSurface8 **ppSurface) { D3DDevice_GetPersistedSurface(ppSurface); return S_OK; }
D3DMINLINE BOOL    WINAPI D3DDevice::GetOverlayUpdateStatus() { return D3DDevice_GetOverlayUpdateStatus(); }
D3DMINLINE HRESULT WINAPI D3DDevice::GetDisplayFieldStatus(D3DFIELD_STATUS *pFieldStatus) { D3DDevice_GetDisplayFieldStatus(pFieldStatus); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexData2f(INT Register, float a, float b) { D3DDevice_SetVertexData2f(Register, a, b); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexData4f(INT Register, float a, float b, float c, float d) { D3DDevice_SetVertexData4f(Register, a, b, c, d); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexData2s(INT Register, SHORT a, SHORT b) { D3DDevice_SetVertexData2s(Register, a, b); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexData4s(INT Register, SHORT a, SHORT b, SHORT c, SHORT d) { D3DDevice_SetVertexData4s(Register, a, b, c, d); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexData4ub(INT Register, BYTE a, BYTE b, BYTE c, BYTE d) { D3DDevice_SetVertexData4ub(Register, a, b, c, d); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexDataColor(INT Register, D3DCOLOR Color) { D3DDevice_SetVertexDataColor(Register, Color); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::Begin(D3DPRIMITIVETYPE PrimitiveType) { D3DDevice_Begin(PrimitiveType); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::End() { D3DDevice_End(); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateFixup(UINT Size, D3DFixup **ppFixup) { return D3DDevice_CreateFixup(Size, ppFixup); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreatePushBuffer(UINT Size, BOOL RunUsingCpuCopy, D3DPushBuffer **ppPushBuffer) { return D3DDevice_CreatePushBuffer(Size, RunUsingCpuCopy, ppPushBuffer); }
D3DMINLINE HRESULT WINAPI D3DDevice::BeginPushBuffer(D3DPushBuffer* pPushBuffer) { D3DDevice_BeginPushBuffer(pPushBuffer); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::EndPushBuffer() { return D3DDevice_EndPushBuffer(); }
D3DMINLINE HRESULT WINAPI D3DDevice::RunPushBuffer(D3DPushBuffer* pPushBuffer, D3DFixup *pFixup) { D3DDevice_RunPushBuffer(pPushBuffer, pFixup); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetPushBufferOffset(DWORD* pOffset) { D3DDevice_GetPushBufferOffset(pOffset); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::Nop() { D3DDevice_Nop(); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetProjectionViewportMatrix(D3DMATRIX* pProjectionViewport) { D3DDevice_GetProjectionViewportMatrix(pProjectionViewport); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetModelView(CONST D3DMATRIX* pModelView, CONST D3DMATRIX* pInverseModelView, CONST D3DMATRIX* pComposite) { D3DDevice_SetModelView(pModelView, pInverseModelView, pComposite); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetModelView(D3DMATRIX* pModelView) { return D3DDevice_GetModelView(pModelView); }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexBlendModelView(UINT Count, CONST D3DMATRIX* pModelViews, CONST D3DMATRIX* pInverseModelViews, CONST D3DMATRIX* pProjectionViewport) { D3DDevice_SetVertexBlendModelView(Count, pModelViews, pInverseModelViews, pProjectionViewport); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVertexBlendModelView(UINT Count, D3DMATRIX* pModelViews, D3DMATRIX* pProjectionViewport) { return D3DDevice_GetVertexBlendModelView(Count, pModelViews, pProjectionViewport); }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexShaderInput(DWORD Handle, UINT StreamCount, CONST D3DSTREAM_INPUT* pStreamInputs) { D3DDevice_SetVertexShaderInput(Handle, StreamCount, pStreamInputs); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexShaderInputDirect(D3DVERTEXATTRIBUTEFORMAT *pVAF, UINT StreamCount, CONST D3DSTREAM_INPUT* pStreamInputs) { D3DDevice_SetVertexShaderInputDirect(pVAF, StreamCount, pStreamInputs); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVertexShaderInput(DWORD* pHandle, UINT* pStreamCount, D3DSTREAM_INPUT* pStreamInputs) { return D3DDevice_GetVertexShaderInput(pHandle, pStreamCount, pStreamInputs); }
D3DMINLINE HRESULT WINAPI D3DDevice::SwitchTexture(DWORD Stage, D3DBaseTexture *pTexture) { D3DDevice_SwitchTexture(D3DTEXTUREDIRECTENCODE[Stage], (pTexture)->Data, (pTexture)->Format); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::Suspend() { D3DDevice_Suspend(); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::Resume(BOOL Reset) { D3DDevice_Resume(Reset); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetScissors(DWORD Count, BOOL Exclusive, CONST D3DRECT *pRects) { D3DDevice_SetScissors(Count, Exclusive, pRects); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetScissors(DWORD* pCount, BOOL *pExclusive, D3DRECT *pRects) { D3DDevice_GetScissors(pCount, pExclusive, pRects); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetTile(DWORD Index, CONST D3DTILE* pTile) { D3DDevice_SetTile(Index, pTile); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetTile(DWORD Index, D3DTILE* pTile) { D3DDevice_GetTile(Index, pTile); return S_OK; }
D3DMINLINE DWORD   WINAPI D3DDevice::GetTileCompressionTags(DWORD ZStartTag, DWORD ZEndTag) { return D3DDevice_GetTileCompressionTags(ZStartTag, ZEndTag); }
D3DMINLINE void    WINAPI D3DDevice::SetTileCompressionTagBits(DWORD Partition, DWORD Address, CONST DWORD *pData, DWORD Count) { D3DDevice_SetTileCompressionTagBits(Partition, Address, pData, Count); }
D3DMINLINE void    WINAPI D3DDevice::GetTileCompressionTagBits(DWORD Partition, DWORD Address, DWORD *pData, DWORD Count) { D3DDevice_GetTileCompressionTagBits(Partition, Address, pData, Count); }
D3DMINLINE HRESULT WINAPI D3DDevice::BeginPush(DWORD Count, DWORD **ppPush) { D3DDevice_BeginPush(Count, ppPush); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::EndPush(DWORD *pPush) { D3DDevice_EndPush(pPush); return S_OK; }
D3DMINLINE DWORD   WINAPI D3DDevice::Swap(DWORD Flags) { return D3DDevice_Swap(Flags); }
D3DMINLINE HRESULT WINAPI D3DDevice::SetBackBufferScale(float x, float y) { D3DDevice_SetBackBufferScale(x, y); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetBackBufferScale(float *pX, float *pY) { D3DDevice_GetBackBufferScale(pX, pY); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetScreenSpaceOffset(float x, float y) { D3DDevice_SetScreenSpaceOffset(x, y); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetScreenSpaceOffset(float *pX, float *pY) { D3DDevice_GetScreenSpaceOffset(pX, pY); return S_OK; }
D3DMINLINE void    WINAPI D3DDevice::SetOverscanColor(D3DCOLOR Color) { D3DDevice_SetOverscanColor(Color); }
D3DMINLINE D3DCOLOR WINAPI D3DDevice::GetOverscanColor() { return D3DDevice_GetOverscanColor(); }
#ifdef _DEBUG
D3DMINLINE DWORD   WINAPI D3DDevice::SetDebugMarker(DWORD Marker) { return D3DDevice_SetDebugMarker(Marker); }
D3DMINLINE DWORD   WINAPI D3DDevice::GetDebugMarker() { return D3DDevice_GetDebugMarker(); }
#else
D3DMINLINE DWORD   WINAPI D3DDevice::SetDebugMarker(DWORD Marker) { return 0; }
D3DMINLINE DWORD   WINAPI D3DDevice::GetDebugMarker() { return 0; }
#endif

#endif __cplusplus

/* D3DResource */

ULONG   WINAPI D3DResource_AddRef(D3DResource *pThis);
ULONG   WINAPI D3DResource_Release(D3DResource *pThis);
void    WINAPI D3DResource_GetDevice(D3DResource *pThis, D3DDevice **ppDevice);
HRESULT WINAPI D3DResource_SetPrivateData(D3DResource *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags);
HRESULT WINAPI D3DResource_GetPrivateData(D3DResource *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData);
void    WINAPI D3DResource_FreePrivateData(D3DResource *pThis, REFGUID refguid);
D3DRESOURCETYPE WINAPI D3DResource_GetType(D3DResource *pThis);
BOOL    WINAPI D3DResource_IsBusy(D3DResource *pThis);
void    WINAPI D3DResource_BlockUntilNotBusy(D3DResource *pThis);
void    WINAPI D3DResource_Register(D3DResource *pThis, void *pBase);
D3DINLINE void WINAPI D3DResource_MoveResourceMemory(D3DResource *pThis, D3DMEMORY where) { }

// Compatibility wrappers.

D3DINLINE ULONG   WINAPI IDirect3DResource8_AddRef(D3DResource *pThis) { return D3DResource_AddRef(pThis); }
D3DINLINE ULONG   WINAPI IDirect3DResource8_Release(D3DResource *pThis) { return D3DResource_Release(pThis); }
D3DINLINE HRESULT WINAPI IDirect3DResource8_GetDevice(D3DResource *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice(pThis, ppDevice); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DResource8_SetPrivateData(D3DResource *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData(pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DResource8_GetPrivateData(D3DResource *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData(pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DResource8_FreePrivateData(D3DResource *pThis, REFGUID refguid) { D3DResource_FreePrivateData(pThis, refguid); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DResource8_GetType(D3DResource *pThis) { return D3DResource_GetType(pThis); }
D3DINLINE BOOL    WINAPI IDirect3DResource8_IsBusy(D3DResource *pThis) { return D3DResource_IsBusy(pThis); }
D3DINLINE void    WINAPI IDirect3DResource8_BlockUntilNotBusy(D3DResource *pThis) { D3DResource_BlockUntilNotBusy(pThis); }
D3DINLINE void    WINAPI IDirect3DResource8_MoveResourceMemory(D3DResource *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory(pThis, where); }
D3DINLINE void    WINAPI IDirect3DResource8_Register(D3DResource *pThis, void *pBase) { D3DResource_Register(pThis, pBase); }

#ifdef __cplusplus

D3DMINLINE ULONG WINAPI D3DResource::AddRef() { return D3DResource_AddRef(this); }
D3DMINLINE ULONG WINAPI D3DResource::Release() { return D3DResource_Release(this); }
D3DMINLINE HRESULT WINAPI D3DResource::GetDevice(D3DDevice **ppDevice) { D3DResource_GetDevice(this, ppDevice); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DResource::SetPrivateData(REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData(this, refguid, pData, SizeOfData, Flags); }
D3DMINLINE HRESULT WINAPI D3DResource::GetPrivateData(REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData(this, refguid, pData, pSizeOfData); }
D3DMINLINE HRESULT WINAPI D3DResource::FreePrivateData(REFGUID refguid) { D3DResource_FreePrivateData(this, refguid); return S_OK; }
D3DMINLINE D3DRESOURCETYPE WINAPI D3DResource::GetType() { return D3DResource_GetType(this); }
D3DMINLINE BOOL    WINAPI D3DResource::IsBusy() { return D3DResource_IsBusy(this); }
D3DMINLINE void    WINAPI D3DResource::BlockUntilNotBusy() { D3DResource_BlockUntilNotBusy(this); }
D3DMINLINE void    WINAPI D3DResource::MoveResourceMemory(D3DMEMORY where) { D3DResource_MoveResourceMemory(this, where); }
D3DMINLINE void    WINAPI D3DResource::Register(void *pBase) { D3DResource_Register(this, pBase); }

#endif __cplusplus

/* D3DBaseTexture */

D3DINLINE ULONG   WINAPI D3DBaseTexture_AddRef(D3DBaseTexture *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DBaseTexture_Release(D3DBaseTexture *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DBaseTexture_GetDevice(D3DBaseTexture *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DBaseTexture_GetType(D3DBaseTexture *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DBaseTexture_IsBusy(D3DBaseTexture *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DBaseTexture_BlockUntilNotBusy(D3DBaseTexture *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DBaseTexture_MoveResourceMemory(D3DBaseTexture *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DBaseTexture_Register(D3DBaseTexture *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI D3DBaseTexture_SetPrivateData(D3DBaseTexture *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DBaseTexture_GetPrivateData(D3DBaseTexture *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DBaseTexture_FreePrivateData(D3DBaseTexture *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

DWORD WINAPI D3DBaseTexture_GetLevelCount(D3DBaseTexture *pThis);

// Compatibility wrappers.

D3DINLINE ULONG   WINAPI IDirect3DBaseTexture8_AddRef(D3DBaseTexture *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DBaseTexture8_Release(D3DBaseTexture *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DBaseTexture8_GetDevice(D3DBaseTexture *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DBaseTexture8_GetType(D3DBaseTexture *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DBaseTexture8_IsBusy(D3DBaseTexture *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DBaseTexture8_BlockUntilNotBusy(D3DBaseTexture *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DBaseTexture8_MoveResourceMemory(D3DBaseTexture *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DBaseTexture8_Register(D3DBaseTexture *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI IDirect3DBaseTexture8_SetPrivateData(D3DBaseTexture *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DBaseTexture8_GetPrivateData(D3DBaseTexture *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DBaseTexture8_FreePrivateData(D3DBaseTexture *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }
D3DINLINE DWORD WINAPI IDirect3DBaseTexture8_GetLevelCount(D3DBaseTexture *pThis) { return D3DBaseTexture_GetLevelCount(pThis); }

#ifdef __cplusplus

D3DMINLINE DWORD WINAPI D3DBaseTexture::GetLevelCount() { return D3DBaseTexture_GetLevelCount(this); }

#endif __cplusplus

/* D3DTexture */

D3DINLINE ULONG   WINAPI D3DTexture_AddRef(D3DTexture *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DTexture_Release(D3DTexture *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DTexture_GetDevice(D3DTexture *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DTexture_GetType(D3DTexture *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DTexture_IsBusy(D3DTexture *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DTexture_BlockUntilNotBusy(D3DTexture *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DTexture_MoveResourceMemory(D3DTexture *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DTexture_Register(D3DTexture *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE DWORD   WINAPI D3DTexture_GetLevelCount(D3DTexture *pThis) { return D3DBaseTexture_GetLevelCount((D3DBaseTexture *)pThis); }
D3DINLINE HRESULT WINAPI D3DTexture_SetPrivateData(D3DTexture *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DTexture_GetPrivateData(D3DTexture *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DTexture_FreePrivateData(D3DTexture *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

void    WINAPI D3DTexture_GetLevelDesc(D3DTexture *pThis, UINT Level, D3DSURFACE_DESC *pDesc);
HRESULT WINAPI D3DTexture_GetSurfaceLevel(D3DTexture *pThis, UINT Level, D3DSurface **ppSurfaceLevel);
void    WINAPI D3DTexture_LockRect(D3DTexture *pThis, UINT Level, D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags);
D3DINLINE void WINAPI D3DTexture_UnlockRect(D3DTexture *pThis, UINT Level) { }

// Compatibilty wrappers.

D3DINLINE ULONG   WINAPI IDirect3DTexture8_AddRef(D3DTexture *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DTexture8_Release(D3DTexture *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DTexture8_GetDevice(D3DTexture *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DTexture8_GetType(D3DTexture *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DTexture8_IsBusy(D3DTexture *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DTexture8_BlockUntilNotBusy(D3DTexture *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DTexture8_MoveResourceMemory(D3DTexture *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DTexture8_Register(D3DTexture *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE DWORD   WINAPI IDirect3DTexture8_GetLevelCount(D3DTexture *pThis) { return D3DBaseTexture_GetLevelCount((D3DBaseTexture *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DTexture8_SetPrivateData(D3DTexture *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DTexture8_GetPrivateData(D3DTexture *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DTexture8_FreePrivateData(D3DTexture *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DTexture8_GetLevelDesc(D3DTexture *pThis, UINT Level, D3DSURFACE_DESC *pDesc) { D3DTexture_GetLevelDesc(pThis, Level, pDesc); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DTexture8_GetSurfaceLevel(D3DTexture *pThis, UINT Level, D3DSurface **ppSurfaceLevel) { return D3DTexture_GetSurfaceLevel(pThis, Level, ppSurfaceLevel); }
D3DINLINE HRESULT WINAPI IDirect3DTexture8_LockRect(D3DTexture *pThis, UINT Level, D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags) { D3DTexture_LockRect(pThis, Level, pLockedRect, pRect, Flags); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DTexture8_UnlockRect(D3DTexture *pThis, UINT Level) { D3DTexture_UnlockRect(pThis, Level); return S_OK; }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DTexture::GetLevelDesc(UINT Level, D3DSURFACE_DESC *pDesc) { D3DTexture_GetLevelDesc(this, Level, pDesc); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DTexture::GetSurfaceLevel(UINT Level, D3DSurface **ppSurfaceLevel) { return D3DTexture_GetSurfaceLevel(this, Level, ppSurfaceLevel); }
D3DMINLINE HRESULT WINAPI D3DTexture::LockRect(UINT Level, D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags) { D3DTexture_LockRect(this, Level, pLockedRect, pRect, Flags); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DTexture::UnlockRect(UINT Level) { D3DTexture_UnlockRect(this, Level); return S_OK; }

#endif __cplusplus

/* D3DVolumeTexture */

D3DINLINE ULONG   WINAPI D3DVolumeTexture_AddRef(D3DVolumeTexture *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DVolumeTexture_Release(D3DVolumeTexture *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVolumeTexture_GetDevice(D3DVolumeTexture *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DVolumeTexture_GetType(D3DVolumeTexture *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DVolumeTexture_IsBusy(D3DVolumeTexture *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVolumeTexture_BlockUntilNotBusy(D3DVolumeTexture *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVolumeTexture_MoveResourceMemory(D3DVolumeTexture *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DVolumeTexture_Register(D3DVolumeTexture *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE DWORD   WINAPI D3DVolumeTexture_GetLevelCount(D3DVolumeTexture *pThis) { return D3DBaseTexture_GetLevelCount((D3DBaseTexture *)pThis); }
D3DINLINE HRESULT WINAPI D3DVolumeTexture_SetPrivateData(D3DVolumeTexture *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DVolumeTexture_GetPrivateData(D3DVolumeTexture *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DVolumeTexture_FreePrivateData(D3DVolumeTexture *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

void    WINAPI D3DVolumeTexture_GetLevelDesc(D3DVolumeTexture *pThis, UINT Level, D3DVOLUME_DESC *pDesc);
HRESULT WINAPI D3DVolumeTexture_GetVolumeLevel(D3DVolumeTexture *pThis, UINT Level, D3DVolume **ppVolumeLevel);
void    WINAPI D3DVolumeTexture_LockBox(D3DVolumeTexture *pThis, UINT Level, D3DLOCKED_BOX *pLockedVolume, CONST D3DBOX *pBox, DWORD Flags);
D3DINLINE void WINAPI D3DVolumeTexture_UnlockBox(D3DVolumeTexture *pThis, UINT Level) { }

// Compatibilty wrappers.

D3DINLINE ULONG   WINAPI IDirect3DVolumeTexture8_AddRef(D3DVolumeTexture *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DVolumeTexture8_Release(D3DVolumeTexture *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DVolumeTexture8_GetDevice(D3DVolumeTexture *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DVolumeTexture8_GetType(D3DVolumeTexture *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DVolumeTexture8_IsBusy(D3DVolumeTexture *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DVolumeTexture8_BlockUntilNotBusy(D3DVolumeTexture *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DVolumeTexture8_MoveResourceMemory(D3DVolumeTexture *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DVolumeTexture8_Register(D3DVolumeTexture *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE DWORD   WINAPI IDirect3DVolumeTexture8_GetLevelCount(D3DVolumeTexture *pThis) { return D3DBaseTexture_GetLevelCount((D3DBaseTexture *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DVolumeTexture8_SetPrivateData(D3DVolumeTexture *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DVolumeTexture8_GetPrivateData(D3DVolumeTexture *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DVolumeTexture8_FreePrivateData(D3DVolumeTexture *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVolumeTexture8_GetLevelDesc(D3DVolumeTexture *pThis, UINT Level, D3DVOLUME_DESC *pDesc) { D3DVolumeTexture_GetLevelDesc(pThis, Level, pDesc); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVolumeTexture8_GetVolumeLevel(D3DVolumeTexture *pThis, UINT Level, D3DVolume **ppVolumeLevel) { return D3DVolumeTexture_GetVolumeLevel(pThis, Level, ppVolumeLevel); }
D3DINLINE HRESULT WINAPI IDirect3DVolumeTexture8_LockBox(D3DVolumeTexture *pThis, UINT Level, D3DLOCKED_BOX *pLockedVolume, CONST D3DBOX *pBox, DWORD Flags) { D3DVolumeTexture_LockBox(pThis, Level, pLockedVolume, pBox, Flags); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVolumeTexture8_UnlockBox(D3DVolumeTexture *pThis, UINT Level) { D3DVolumeTexture_UnlockBox(pThis, Level); return S_OK; }


#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DVolumeTexture::GetLevelDesc(UINT Level, D3DVOLUME_DESC *pDesc) { D3DVolumeTexture_GetLevelDesc(this, Level, pDesc); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DVolumeTexture::GetVolumeLevel(UINT Level, D3DVolume **ppVolumeLevel) { return D3DVolumeTexture_GetVolumeLevel(this, Level, ppVolumeLevel); }
D3DMINLINE HRESULT WINAPI D3DVolumeTexture::LockBox(UINT Level, D3DLOCKED_BOX *pLockedVolume, CONST D3DBOX *pBox, DWORD Flags) { D3DVolumeTexture_LockBox(this, Level, pLockedVolume, pBox, Flags); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DVolumeTexture::UnlockBox(UINT Level) { D3DVolumeTexture_UnlockBox(this, Level); return S_OK; }

#endif __cplusplus

/* D3DCubeTexture */

D3DINLINE ULONG   WINAPI D3DCubeTexture_AddRef(D3DCubeTexture *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DCubeTexture_Release(D3DCubeTexture *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DCubeTexture_GetDevice(D3DCubeTexture *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DCubeTexture_GetType(D3DCubeTexture *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DCubeTexture_IsBusy(D3DCubeTexture *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DCubeTexture_BlockUntilNotBusy(D3DCubeTexture *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DCubeTexture_MoveResourceMemory(D3DCubeTexture *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DCubeTexture_Register(D3DCubeTexture *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE DWORD   WINAPI D3DCubeTexture_GetLevelCount(D3DCubeTexture *pThis) { return D3DBaseTexture_GetLevelCount((D3DBaseTexture *)pThis); }
D3DINLINE HRESULT WINAPI D3DCubeTexture_SetPrivateData(D3DCubeTexture *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DCubeTexture_GetPrivateData(D3DCubeTexture *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DCubeTexture_FreePrivateData(D3DCubeTexture *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

void    WINAPI D3DCubeTexture_GetLevelDesc(D3DCubeTexture *pThis, UINT Level, D3DSURFACE_DESC *pDesc);
HRESULT WINAPI D3DCubeTexture_GetCubeMapSurface(D3DCubeTexture *pThis, D3DCUBEMAP_FACES FaceType, UINT Level, D3DSurface **ppCubeMapSurface);
void    WINAPI D3DCubeTexture_LockRect(D3DCubeTexture *pThis, D3DCUBEMAP_FACES FaceType, UINT Level, D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags);
D3DINLINE void WINAPI D3DCubeTexture_UnlockRect(D3DCubeTexture *pThis, D3DCUBEMAP_FACES FaceType, UINT Level) { }

D3DINLINE ULONG   WINAPI IDirect3DCubeTexture8_AddRef(D3DCubeTexture *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DCubeTexture8_Release(D3DCubeTexture *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DCubeTexture8_GetDevice(D3DCubeTexture *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DCubeTexture8_GetType(D3DCubeTexture *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DCubeTexture8_IsBusy(D3DCubeTexture *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DCubeTexture8_BlockUntilNotBusy(D3DCubeTexture *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DCubeTexture8_MoveResourceMemory(D3DCubeTexture *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DCubeTexture8_Register(D3DCubeTexture *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE DWORD   WINAPI IDirect3DCubeTexture8_GetLevelCount(D3DCubeTexture *pThis) { return D3DBaseTexture_GetLevelCount((D3DBaseTexture *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DCubeTexture8_SetPrivateData(D3DCubeTexture *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DCubeTexture8_GetPrivateData(D3DCubeTexture *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DCubeTexture8_FreePrivateData(D3DCubeTexture *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DCubeTexture8_GetLevelDesc(D3DCubeTexture *pThis, UINT Level, D3DSURFACE_DESC *pDesc) { D3DCubeTexture_GetLevelDesc(pThis, Level, pDesc); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DCubeTexture8_GetCubeMapSurface(D3DCubeTexture *pThis, D3DCUBEMAP_FACES FaceType, UINT Level, D3DSurface **ppCubeMapSurface) { return D3DCubeTexture_GetCubeMapSurface(pThis, FaceType, Level, ppCubeMapSurface); }
D3DINLINE HRESULT WINAPI IDirect3DCubeTexture8_LockRect(D3DCubeTexture *pThis, D3DCUBEMAP_FACES FaceType, UINT Level, D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags) { D3DCubeTexture_LockRect(pThis, FaceType, Level, pLockedRect, pRect, Flags); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DCubeTexture8_UnlockRect(D3DCubeTexture *pThis, D3DCUBEMAP_FACES FaceType, UINT Level) { D3DCubeTexture_UnlockRect(pThis, FaceType, Level); return S_OK; }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DCubeTexture::GetLevelDesc(UINT Level, D3DSURFACE_DESC *pDesc) { D3DCubeTexture_GetLevelDesc(this, Level, pDesc); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DCubeTexture::GetCubeMapSurface(D3DCUBEMAP_FACES FaceType, UINT Level, D3DSurface **ppCubeMapSurface) { return D3DCubeTexture_GetCubeMapSurface(this, FaceType, Level, ppCubeMapSurface); }
D3DMINLINE HRESULT WINAPI D3DCubeTexture::LockRect(D3DCUBEMAP_FACES FaceType, UINT Level, D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags) { D3DCubeTexture_LockRect(this, FaceType, Level, pLockedRect, pRect, Flags); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DCubeTexture::UnlockRect(D3DCUBEMAP_FACES FaceType, UINT Level) { D3DCubeTexture_UnlockRect(this, FaceType, Level); return S_OK; }

#endif __cplusplus

/* D3DVertexBuffer */

D3DINLINE ULONG   WINAPI D3DVertexBuffer_AddRef(D3DVertexBuffer *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DVertexBuffer_Release(D3DVertexBuffer *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVertexBuffer_GetDevice(D3DVertexBuffer *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DVertexBuffer_GetType(D3DVertexBuffer *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DVertexBuffer_IsBusy(D3DVertexBuffer *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVertexBuffer_BlockUntilNotBusy(D3DVertexBuffer *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVertexBuffer_MoveResourceMemory(D3DVertexBuffer *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DVertexBuffer_Register(D3DVertexBuffer *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI D3DVertexBuffer_SetPrivateData(D3DVertexBuffer *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DVertexBuffer_GetPrivateData(D3DVertexBuffer *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DVertexBuffer_FreePrivateData(D3DVertexBuffer *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

void    WINAPI D3DVertexBuffer_Lock(D3DVertexBuffer *pThis, UINT OffsetToLock, UINT SizeToLock, BYTE **ppbData, DWORD Flags);
void    WINAPI D3DVertexBuffer_GetDesc(D3DVertexBuffer *pThis, D3DVERTEXBUFFER_DESC *pDesc);
D3DINLINE void WINAPI D3DVertexBuffer_Unlock(D3DVertexBuffer *pThis) { }

D3DINLINE ULONG   WINAPI IDirect3DVertexBuffer8_AddRef(D3DVertexBuffer *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DVertexBuffer8_Release(D3DVertexBuffer *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DVertexBuffer8_GetDevice(D3DVertexBuffer *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DVertexBuffer8_GetType(D3DVertexBuffer *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DVertexBuffer8_IsBusy(D3DVertexBuffer *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DVertexBuffer8_BlockUntilNotBusy(D3DVertexBuffer *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DVertexBuffer8_MoveResourceMemory(D3DVertexBuffer *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DVertexBuffer8_Register(D3DVertexBuffer *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI IDirect3DVertexBuffer8_SetPrivateData(D3DVertexBuffer *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DVertexBuffer8_GetPrivateData(D3DVertexBuffer *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DVertexBuffer8_FreePrivateData(D3DVertexBuffer *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVertexBuffer8_Lock(D3DVertexBuffer *pThis, UINT OffsetToLock, UINT SizeToLock, BYTE **ppbData, DWORD Flags) { D3DVertexBuffer_Lock(pThis, OffsetToLock, SizeToLock, ppbData, Flags); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVertexBuffer8_Unlock(D3DVertexBuffer *pThis) { D3DVertexBuffer_Unlock(pThis); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVertexBuffer8_GetDesc(D3DVertexBuffer *pThis, D3DVERTEXBUFFER_DESC *pDesc) { D3DVertexBuffer_GetDesc(pThis, pDesc); return S_OK; }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DVertexBuffer::Lock(UINT OffsetToLock, UINT SizeToLock, BYTE **ppbData, DWORD Flags) { D3DVertexBuffer_Lock(this, OffsetToLock, SizeToLock, ppbData, Flags); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DVertexBuffer::Unlock() { D3DVertexBuffer_Unlock(this); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DVertexBuffer::GetDesc(D3DVERTEXBUFFER_DESC *pDesc) { D3DVertexBuffer_GetDesc(this, pDesc); return S_OK; }

#endif __cplusplus

/* D3DIndexBuffer */

D3DINLINE ULONG   WINAPI D3DIndexBuffer_AddRef(D3DIndexBuffer *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DIndexBuffer_Release(D3DIndexBuffer *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DIndexBuffer_GetDevice(D3DIndexBuffer *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DIndexBuffer_GetType(D3DIndexBuffer *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DIndexBuffer_IsBusy(D3DIndexBuffer *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DIndexBuffer_BlockUntilNotBusy(D3DIndexBuffer *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DIndexBuffer_MoveResourceMemory(D3DIndexBuffer *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DIndexBuffer_Register(D3DIndexBuffer *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI D3DIndexBuffer_SetPrivateData(D3DIndexBuffer *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DIndexBuffer_GetPrivateData(D3DIndexBuffer *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DIndexBuffer_FreePrivateData(D3DIndexBuffer *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

D3DINLINE void    WINAPI D3DIndexBuffer_Lock(D3DIndexBuffer *pThis, UINT OffsetToLock, UINT SizeToLock, BYTE **ppbData, DWORD Flags) { *(ppbData) = (BYTE*) (pThis)->Data + (OffsetToLock); }
D3DINLINE void    WINAPI D3DIndexBuffer_Unlock(D3DIndexBuffer *pThis) { }
void    WINAPI D3DIndexBuffer_GetDesc(D3DIndexBuffer *pThis, D3DINDEXBUFFER_DESC *pDesc);

// Compatibilty wrappers.

D3DINLINE ULONG   WINAPI IDirect3DIndexBuffer8_AddRef(D3DIndexBuffer *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DIndexBuffer8_Release(D3DIndexBuffer *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DIndexBuffer8_GetDevice(D3DIndexBuffer *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DIndexBuffer8_GetType(D3DIndexBuffer *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DIndexBuffer8_IsBusy(D3DIndexBuffer *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DIndexBuffer8_BlockUntilNotBusy(D3DIndexBuffer *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DIndexBuffer8_MoveResourceMemory(D3DIndexBuffer *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DIndexBuffer8_Register(D3DIndexBuffer *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI IDirect3DIndexBuffer8_SetPrivateData(D3DIndexBuffer *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DIndexBuffer8_GetPrivateData(D3DIndexBuffer *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DIndexBuffer8_FreePrivateData(D3DIndexBuffer *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DIndexBuffer8_Lock(D3DIndexBuffer *pThis, UINT OffsetToLock, UINT SizeToLock, BYTE **ppbData, DWORD Flags) { D3DIndexBuffer_Lock(pThis, OffsetToLock, SizeToLock, ppbData, Flags); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DIndexBuffer8_Unlock(D3DIndexBuffer *pThis) { D3DIndexBuffer_Unlock(pThis); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DIndexBuffer8_GetDesc(D3DIndexBuffer *pThis, D3DINDEXBUFFER_DESC *pDesc) { D3DIndexBuffer_GetDesc(pThis, pDesc); return S_OK; }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DIndexBuffer::Lock(UINT OffsetToLock, UINT SizeToLock, BYTE **ppbData, DWORD Flags) { D3DIndexBuffer_Lock(this, OffsetToLock, SizeToLock, ppbData, Flags); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DIndexBuffer::Unlock() { D3DIndexBuffer_Unlock(this); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DIndexBuffer::GetDesc(D3DINDEXBUFFER_DESC *pDesc) { D3DIndexBuffer_GetDesc(this, pDesc); return S_OK; }

#endif __cplusplus

/* D3DPalette */

D3DINLINE ULONG   WINAPI D3DPalette_AddRef(D3DPalette *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DPalette_Release(D3DPalette *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DPalette_GetDevice(D3DPalette *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DPalette_GetType(D3DPalette *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DPalette_IsBusy(D3DPalette *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DPalette_BlockUntilNotBusy(D3DPalette *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DPalette_MoveResourceMemory(D3DPalette *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DPalette_Register(D3DPalette *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI D3DPalette_SetPrivateData(D3DPalette *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DPalette_GetPrivateData(D3DPalette *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DPalette_FreePrivateData(D3DPalette *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

void    WINAPI D3DPalette_Lock(D3DPalette *pThis, D3DCOLOR **ppColor, DWORD Flags);
D3DPALETTESIZE WINAPI D3DPalette_GetSize(D3DPalette *pThis);
D3DINLINE void WINAPI D3DPalette_Unlock(D3DPalette *pThis) { }

D3DINLINE ULONG   WINAPI IDirect3DPalette8_AddRef(D3DPalette *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DPalette8_Release(D3DPalette *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DPalette8_GetDevice(D3DPalette *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DPalette8_GetType(D3DPalette *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DPalette8_IsBusy(D3DPalette *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DPalette8_BlockUntilNotBusy(D3DPalette *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DPalette8_MoveResourceMemory(D3DPalette *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DPalette8_Register(D3DPalette *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI IDirect3DPalette8_SetPrivateData(D3DPalette *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DPalette8_GetPrivateData(D3DPalette *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DPalette8_FreePrivateData(D3DPalette *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }

D3DINLINE HRESULT WINAPI IDirect3DPalette8_Lock(D3DPalette *pThis, D3DCOLOR **ppColor, DWORD Flags) { D3DPalette_Lock(pThis, ppColor, Flags); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPalette8_Unlock(D3DPalette *pThis) { D3DPalette_Unlock(pThis); return S_OK; }
D3DINLINE D3DPALETTESIZE WINAPI IDirect3DPalette8_GetSize(D3DPalette *pThis) { return D3DPalette_GetSize(pThis); }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DPalette::Lock(D3DCOLOR **ppColors, DWORD Flags) { D3DPalette_Lock(this, ppColors, Flags); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPalette::Unlock() { D3DPalette_Unlock(this); return S_OK; }
D3DMINLINE D3DPALETTESIZE WINAPI D3DPalette::GetSize() { return D3DPalette_GetSize(this); }

#endif __cplusplus

/* D3DPushBuffer */

D3DINLINE ULONG   WINAPI D3DPushBuffer_AddRef(D3DPushBuffer *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DPushBuffer_Release(D3DPushBuffer *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DPushBuffer_GetDevice(D3DPushBuffer *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DPushBuffer_GetType(D3DPushBuffer *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DPushBuffer_IsBusy(D3DPushBuffer *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DPushBuffer_BlockUntilNotBusy(D3DPushBuffer *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DPushBuffer_MoveResourceMemory(D3DPushBuffer *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DPushBuffer_Register(D3DPushBuffer *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI D3DPushBuffer_SetPrivateData(D3DPushBuffer *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DPushBuffer_GetPrivateData(D3DPushBuffer *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DPushBuffer_FreePrivateData(D3DPushBuffer *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

void    WINAPI D3DPushBuffer_Verify(D3DPushBuffer* pPushBuffer, BOOL StampResources);
void    WINAPI D3DPushBuffer_BeginFixup(D3DPushBuffer* pPushBuffer, D3DFixup* pFixup, BOOL NoWait);
HRESULT WINAPI D3DPushBuffer_EndFixup(D3DPushBuffer* pPushBuffer);
void    WINAPI D3DPushBuffer_RunPushBuffer(D3DPushBuffer* pPushBuffer, DWORD Offset, D3DPushBuffer* pDestinationPushBuffer, D3DFixup* pDestinationFixup);
void    WINAPI D3DPushBuffer_SetModelView(D3DPushBuffer* pPushBuffer, DWORD Offset, CONST D3DMATRIX* pModelView, CONST D3DMATRIX* pInverseModelView, CONST D3DMATRIX* pComposite);
void    WINAPI D3DPushBuffer_SetVertexBlendModelView(D3DPushBuffer* pPushBuffer, DWORD Offset, UINT Count, CONST D3DMATRIX* pModelViews, CONST D3DMATRIX* pInverseModelViews, CONST D3DMATRIX* pProjectionViewport);
void    WINAPI D3DPushBuffer_SetVertexShaderInput(D3DPushBuffer* pPushBuffer, DWORD Offset, DWORD Handle, UINT StreamCount, CONST D3DSTREAM_INPUT *pStreamInputs);
void    WINAPI D3DPushBuffer_SetVertexShaderInputDirect(D3DPushBuffer* pPushBuffer, DWORD Offset, D3DVERTEXATTRIBUTEFORMAT *pVAF, UINT StreamCount, CONST D3DSTREAM_INPUT *pStreamInputs);
void    WINAPI D3DPushBuffer_SetRenderTarget(D3DPushBuffer* pPushBuffer, DWORD Offset, D3DSurface* pRenderTarget, D3DSurface* pZBuffer);
void    WINAPI D3DPushBuffer_SetTexture(D3DPushBuffer* pPushBuffer, DWORD Offset, DWORD Stage, D3DBaseTexture *pTexture);
void    WINAPI D3DPushBuffer_SetPalette(D3DPushBuffer* pPushBuffer, DWORD Offset, DWORD Stage,D3DPalette *pPalette);
HRESULT WINAPI D3DPushBuffer_EndVisibilityTest(D3DPushBuffer* pPushBuffer, DWORD Offset, DWORD Index);
void    WINAPI D3DPushBuffer_SetVertexShaderConstant(D3DPushBuffer* pPushBuffer, DWORD Offset, INT Register, CONST void* pConstantData, DWORD ConstantCount);
void    WINAPI D3DPushBuffer_Jump(D3DPushBuffer* pPushBuffer, DWORD Offset, UINT DestinationOffset);

D3DINLINE ULONG   WINAPI IDirect3DPushBuffer8_AddRef(D3DPushBuffer *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DPushBuffer8_Release(D3DPushBuffer *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_GetDevice(D3DPushBuffer *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DPushBuffer8_GetType(D3DPushBuffer *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DPushBuffer8_IsBusy(D3DPushBuffer *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DPushBuffer8_BlockUntilNotBusy(D3DPushBuffer *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DPushBuffer8_MoveResourceMemory(D3DPushBuffer *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DPushBuffer8_Register(D3DPushBuffer *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetPrivateData(D3DPushBuffer *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_GetPrivateData(D3DPushBuffer *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_FreePrivateData(D3DPushBuffer *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }

D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_Verify(D3DPushBuffer* pPushBuffer, BOOL StampResources) { D3DPushBuffer_Verify(pPushBuffer, StampResources); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_BeginFixup(D3DPushBuffer* pPushBuffer, D3DFixup* pFixup, BOOL NoWait) { D3DPushBuffer_BeginFixup(pPushBuffer, pFixup, NoWait); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_EndFixup(D3DPushBuffer* pPushBuffer) { return D3DPushBuffer_EndFixup(pPushBuffer); }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_RunPushBuffer(D3DPushBuffer* pPushBuffer, DWORD Offset, D3DPushBuffer* pDestinationPushBuffer, D3DFixup* pDestinationFixup) { D3DPushBuffer_RunPushBuffer(pPushBuffer, Offset, pDestinationPushBuffer, pDestinationFixup); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetModelView(D3DPushBuffer* pPushBuffer, DWORD Offset, CONST D3DMATRIX* pModelView, CONST D3DMATRIX* pInverseModelView, CONST D3DMATRIX* pComposite) { D3DPushBuffer_SetModelView(pPushBuffer, Offset, pModelView, pInverseModelView, pComposite); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetVertexBlendModelView(D3DPushBuffer* pPushBuffer, DWORD Offset, UINT Count, CONST D3DMATRIX* pModelViews, CONST D3DMATRIX* pInverseModelViews, CONST D3DMATRIX* pProjectionViewport) { D3DPushBuffer_SetVertexBlendModelView(pPushBuffer, Offset, Count, pModelViews, pInverseModelViews, pProjectionViewport); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetVertexShaderInput(D3DPushBuffer* pPushBuffer, DWORD Offset, DWORD Handle, UINT StreamCount, CONST D3DSTREAM_INPUT *pStreamInputs) { D3DPushBuffer_SetVertexShaderInput(pPushBuffer, Offset, Handle, StreamCount, pStreamInputs); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetVertexShaderInputDirect(D3DPushBuffer* pPushBuffer, DWORD Offset, D3DVERTEXATTRIBUTEFORMAT *pVAF, UINT StreamCount, CONST D3DSTREAM_INPUT *pStreamInputs) { D3DPushBuffer_SetVertexShaderInputDirect(pPushBuffer, Offset, pVAF, StreamCount, pStreamInputs); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetRenderTarget(D3DPushBuffer* pPushBuffer, DWORD Offset, D3DSurface* pRenderTarget, D3DSurface* pZBuffer) { D3DPushBuffer_SetRenderTarget(pPushBuffer, Offset, pRenderTarget, pZBuffer); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetTexture(D3DPushBuffer* pPushBuffer, DWORD Offset, DWORD Stage, D3DBaseTexture *pTexture) { D3DPushBuffer_SetTexture(pPushBuffer, Offset, Stage, pTexture); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetPalette(D3DPushBuffer* pPushBuffer, DWORD Offset, DWORD Stage,D3DPalette *pPalette) { D3DPushBuffer_SetPalette(pPushBuffer, Offset, Stage, pPalette); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_EndVisibilityTest(D3DPushBuffer* pPushBuffer, DWORD Offset, DWORD Index) { return D3DPushBuffer_EndVisibilityTest(pPushBuffer, Offset, Index); }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetVertexShaderConstant(D3DPushBuffer* pPushBuffer, DWORD Offset, INT Register, CONST void* pConstantData, DWORD ConstantCount) { D3DPushBuffer_SetVertexShaderConstant(pPushBuffer, Offset, Register, pConstantData, ConstantCount); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_Jump(D3DPushBuffer* pPushBuffer, DWORD Offset, UINT DestinationOffset) { D3DPushBuffer_Jump(pPushBuffer, Offset, DestinationOffset); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_GetSize(D3DPushBuffer* pPushBuffer, DWORD* pSize) { *pSize = pPushBuffer->Size; return S_OK; }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DPushBuffer::Verify(BOOL StampResources) { D3DPushBuffer_Verify(this, StampResources); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::BeginFixup(D3DFixup* pFixup, BOOL NoWait) { D3DPushBuffer_BeginFixup(this, pFixup, NoWait); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::EndFixup() { return D3DPushBuffer_EndFixup(this); }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::RunPushBuffer(DWORD Offset, D3DPushBuffer* pDestinationPushBuffer, D3DFixup* pDestinationFixup) { D3DPushBuffer_RunPushBuffer(this, Offset, pDestinationPushBuffer, pDestinationFixup); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::SetModelView(DWORD Offset, CONST D3DMATRIX* pModelView, CONST D3DMATRIX* pInverseModelView, CONST D3DMATRIX* pComposite) { D3DPushBuffer_SetModelView(this, Offset, pModelView, pInverseModelView, pComposite); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::SetVertexBlendModelView(DWORD Offset, UINT Count, CONST D3DMATRIX* pModelViews, CONST D3DMATRIX* pInverseModelViews, CONST D3DMATRIX* pProjectionViewport) { D3DPushBuffer_SetVertexBlendModelView(this, Offset, Count, pModelViews, pInverseModelViews, pProjectionViewport); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::SetVertexShaderInput(DWORD Offset, DWORD Handle, UINT StreamCount, CONST D3DSTREAM_INPUT *pStreamInputs) { D3DPushBuffer_SetVertexShaderInput(this, Offset, Handle, StreamCount, pStreamInputs); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::SetVertexShaderInputDirect(DWORD Offset, D3DVERTEXATTRIBUTEFORMAT *pVAF, UINT StreamCount, CONST D3DSTREAM_INPUT *pStreamInputs) { D3DPushBuffer_SetVertexShaderInputDirect(this, Offset, pVAF, StreamCount, pStreamInputs); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::SetRenderTarget(DWORD Offset, D3DSurface* pRenderTarget, D3DSurface* pZBuffer) { D3DPushBuffer_SetRenderTarget(this, Offset, pRenderTarget, pZBuffer); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::SetTexture(DWORD Offset, DWORD Stage, D3DBaseTexture *pTexture) { D3DPushBuffer_SetTexture(this, Offset, Stage, pTexture); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::SetPalette(DWORD Offset, DWORD Stage,D3DPalette *pPalette) { D3DPushBuffer_SetPalette(this, Offset, Stage, pPalette); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::EndVisibilityTest(DWORD Offset, DWORD Index) { return D3DPushBuffer_EndVisibilityTest(this, Offset, Index); }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::SetVertexShaderConstant(DWORD Offset, INT Register, CONST void* pConstantData, DWORD ConstantCount) { D3DPushBuffer_SetVertexShaderConstant(this, Offset, Register, pConstantData, ConstantCount); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::Jump(DWORD Offset, UINT DestinationOffset) { D3DPushBuffer_Jump(this, Offset, DestinationOffset); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::GetSize(DWORD* pSize) { *pSize = Size; return S_OK; }

#endif __cplusplus

/* D3DFixup */

D3DINLINE ULONG   WINAPI D3DFixup_AddRef(D3DFixup *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DFixup_Release(D3DFixup *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DFixup_GetDevice(D3DFixup *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DFixup_GetType(D3DFixup *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DFixup_IsBusy(D3DFixup *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DFixup_BlockUntilNotBusy(D3DFixup *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DFixup_MoveResourceMemory(D3DFixup *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DFixup_Register(D3DFixup *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI D3DFixup_SetPrivateData(D3DFixup *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DFixup_GetPrivateData(D3DFixup *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DFixup_FreePrivateData(D3DFixup *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

void    WINAPI D3DFixup_Reset(D3DFixup* pFixup);
void    WINAPI D3DFixup_GetSize(D3DFixup* pFixup, DWORD* pSize);
void    WINAPI D3DFixup_GetSpace(D3DFixup* pFixup, DWORD* pSpace);

D3DINLINE ULONG   WINAPI IDirect3DFixup8_AddRef(D3DFixup *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DFixup8_Release(D3DFixup *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DFixup8_GetDevice(D3DFixup *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DFixup8_GetType(D3DFixup *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DFixup8_IsBusy(D3DFixup *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DFixup8_BlockUntilNotBusy(D3DFixup *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DFixup8_MoveResourceMemory(D3DFixup *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DFixup8_Register(D3DFixup *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI IDirect3DFixup8_SetPrivateData(D3DFixup *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DFixup8_GetPrivateData(D3DFixup *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DFixup8_FreePrivateData(D3DFixup *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }

D3DINLINE HRESULT WINAPI IDirect3DFixup8_Reset(D3DFixup* pFixup) { D3DFixup_Reset(pFixup); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DFixup8_GetSize(D3DFixup* pFixup, DWORD* pSize) { D3DFixup_GetSize(pFixup, pSize); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DFixup8_GetSpace(D3DFixup* pFixup, DWORD* pSpace) { D3DFixup_GetSpace(pFixup, pSpace); return S_OK; }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DFixup::Reset() { D3DFixup_Reset(this); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DFixup::GetSize(DWORD* pSize) { D3DFixup_GetSize(this, pSize); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DFixup::GetSpace(DWORD* pSpace) { D3DFixup_GetSpace(this, pSpace); return S_OK; }

#endif __cplusplus

/* D3DSurface */

D3DINLINE ULONG   WINAPI D3DSurface_AddRef(D3DSurface *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DSurface_Release(D3DSurface *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DSurface_GetDevice(D3DSurface *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DSurface_GetType(D3DSurface *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DSurface_IsBusy(D3DSurface *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DSurface_BlockUntilNotBusy(D3DSurface *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DSurface_MoveResourceMemory(D3DSurface *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DSurface_Register(D3DSurface *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI D3DSurface_SetPrivateData(D3DSurface *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DSurface_GetPrivateData(D3DSurface *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DSurface_FreePrivateData(D3DSurface *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

HRESULT WINAPI D3DSurface_GetContainer(D3DSurface *pThis, D3DBaseTexture **ppBaseTexture);
void    WINAPI D3DSurface_GetDesc(D3DSurface *pThis, D3DSURFACE_DESC *pDesc);
void    WINAPI D3DSurface_LockRect(D3DSurface *pThis, D3DLOCKED_RECT *pLockedRect,CONST RECT *pRect, DWORD Flags);
D3DINLINE void WINAPI D3DSurface_UnlockRect(D3DSurface *pThis) { }

D3DINLINE ULONG   WINAPI IDirect3DSurface8_AddRef(D3DSurface *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DSurface8_Release(D3DSurface *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DSurface8_GetDevice(D3DSurface *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DSurface8_GetType(D3DSurface *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DSurface8_IsBusy(D3DSurface *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DSurface8_BlockUntilNotBusy(D3DSurface *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DSurface8_MoveResourceMemory(D3DSurface *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DSurface8_Register(D3DSurface *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI IDirect3DSurface8_SetPrivateData(D3DSurface *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DSurface8_GetPrivateData(D3DSurface *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DSurface8_FreePrivateData(D3DSurface *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DSurface8_GetContainer(D3DSurface *pThis, D3DBaseTexture **ppBaseTexture) { return D3DSurface_GetContainer(pThis, ppBaseTexture); }
D3DINLINE HRESULT WINAPI IDirect3DSurface8_GetDesc(D3DSurface *pThis, D3DSURFACE_DESC *pDesc) { D3DSurface_GetDesc(pThis, pDesc); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DSurface8_LockRect(D3DSurface *pThis, D3DLOCKED_RECT *pLockedRect,CONST RECT *pRect, DWORD Flags) { D3DSurface_LockRect(pThis, pLockedRect,pRect, Flags); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DSurface8_UnlockRect(D3DSurface *pThis) { D3DSurface_UnlockRect(pThis); return S_OK; }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DSurface::GetContainer(D3DBaseTexture **ppBaseTexture) { return D3DSurface_GetContainer(this, ppBaseTexture); }
D3DMINLINE HRESULT WINAPI D3DSurface::GetDesc(D3DSURFACE_DESC *pDesc) { D3DSurface_GetDesc(this, pDesc); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DSurface::LockRect(D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags) { D3DSurface_LockRect(this, pLockedRect, pRect, Flags); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DSurface::UnlockRect() { D3DSurface_UnlockRect(this); return S_OK; }

#endif __cplusplus

/* D3DVolume */

D3DINLINE ULONG   WINAPI D3DVolume_AddRef(D3DVolume *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DVolume_Release(D3DVolume *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVolume_GetDevice(D3DVolume *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DVolume_GetType(D3DVolume *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DVolume_IsBusy(D3DVolume *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVolume_BlockUntilNotBusy(D3DVolume *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVolume_MoveResourceMemory(D3DVolume *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DVolume_Register(D3DVolume *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI D3DVolume_SetPrivateData(D3DVolume *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DVolume_GetPrivateData(D3DVolume *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DVolume_FreePrivateData(D3DVolume *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

void    WINAPI D3DVolume_GetContainer(D3DVolume *pThis, D3DBaseTexture **ppBaseTexture);
void    WINAPI D3DVolume_GetDesc(D3DVolume *pThis, D3DVOLUME_DESC *pDesc);
void    WINAPI D3DVolume_LockBox(D3DVolume *pThis, D3DLOCKED_BOX *pLockedVolume, CONST D3DBOX *pBox, DWORD Flags);
D3DINLINE void WINAPI D3DVolume_UnlockBox(D3DVolume *pThis) { }

D3DINLINE ULONG   WINAPI IDirect3DVolume8_AddRef(D3DVolume *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DVolume8_Release(D3DVolume *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DVolume8_GetDevice(D3DVolume *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DVolume8_GetType(D3DVolume *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DVolume8_IsBusy(D3DVolume *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DVolume8_BlockUntilNotBusy(D3DVolume *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DVolume8_MoveResourceMemory(D3DVolume *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DVolume8_Register(D3DVolume *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI IDirect3DVolume8_SetPrivateData(D3DVolume *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DVolume8_GetPrivateData(D3DVolume *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DVolume8_FreePrivateData(D3DVolume *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVolume8_GetContainer(D3DVolume *pThis, D3DBaseTexture **ppBaseTexture) { D3DVolume_GetContainer(pThis, ppBaseTexture); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVolume8_GetDesc(D3DVolume *pThis, D3DVOLUME_DESC *pDesc) { D3DVolume_GetDesc(pThis, pDesc); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVolume8_LockBox(D3DVolume *pThis, D3DLOCKED_BOX *pLockedVolume, CONST D3DBOX *pBox, DWORD Flags) { D3DVolume_LockBox(pThis, pLockedVolume, pBox, Flags); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVolume8_UnlockBox(D3DVolume *pThis) { D3DVolume_UnlockBox(pThis); return S_OK; }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DVolume::GetContainer(D3DBaseTexture **ppBaseTexture) { D3DVolume_GetContainer(this, ppBaseTexture); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DVolume::GetDesc(D3DVOLUME_DESC *pDesc) { D3DVolume_GetDesc(this, pDesc); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DVolume::LockBox(D3DLOCKED_BOX *pLockedVolume, CONST D3DBOX *pBox, DWORD Flags) { D3DVolume_LockBox(this, pLockedVolume, pBox, Flags); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DVolume::UnlockBox() { D3DVolume_UnlockBox(this); return S_OK; }

#endif __cplusplus

#ifdef __cplusplus
};
#endif

#pragma warning( pop )

#endif /* _D3D_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dxg\obj\i386\d3d8sddi.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       D3D8sddi.h
 *  Content:    Defines the interface between the ddi thunk layer
 *              and the refrast/RGB HEL layer..
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   04-nov-99  smac    initial implementation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifndef __D3D8SW_INCLUDED__
#define __D3D8SW_INCLUDED__

typedef struct _D3D8_SWCAPS
{
    D3DHAL_D3DEXTENDEDCAPS      D3DExtendedCaps;        // Extended D3D caps
    D3DHAL_GLOBALDRIVERDATA     D3DGlobalDriverData;    // D3D global driver data
    DWORD                       Caps;                   // Subset of DDraw Caps
    DWORD                       Caps2;                  // Subset of DDraw Caps2
    D3DCAPS8                    D3DCaps8;               // DX8 DDI caps
    DWORD                       dwFlags;
} D3D8_SWCAPS, * PD3D8_SWCAPS;

// Surface types
#define SWSURF_SURFACE                     0x00000001
#define SWSURF_VOLUME                      0x00000002
#define SWSURF_MIPMAP                      0x00000004
#define SWSURF_MIPVOLUME                   0x00000008
#define SWSURF_CUBEMAP                     0x00000010
#define SWSURF_VERTEXBUFFER                0x00000020
#define SWSURF_OPTIMIZERVERTEXBUFFER       0x00000040
#define SWSURF_INDEXBUFFER                 0x00000080
#define SWSURF_COMMANDBUFFER               0x00000100

// Flags
#define SWFLAG_D3DEXENDEDCAPS              0x00000001
#define SWFLAG_D3DGLOBALDRIVERDATA         0x00000002
#define SWFLAG_D3DCAPS8                    0x00000004



typedef struct _D3D8_SWCALLBACKS
{
    // From Callbacks
    LPD3DHAL_CONTEXTCREATECB                CreateContext;
    LPD3DHAL_CONTEXTDESTROYCB               ContextDestroy;
    LPD3DHAL_CONTEXTDESTROYALLCB            ContextDestroyAll;
    LPD3DHAL_SCENECAPTURECB                 SceneCapture;
    LPD3DHAL_RENDERSTATECB                  RenderState;
    LPD3DHAL_RENDERPRIMITIVECB              RenderPrimitive;
    LPD3DHAL_TEXTURECREATECB                TextureCreate;
    LPD3DHAL_TEXTUREDESTROYCB               TextureDestroy;
    LPD3DHAL_TEXTURESWAPCB                  TextureSwap;
    LPD3DHAL_TEXTUREGETSURFCB               TextureGetSurf;
    LPD3DHAL_GETSTATECB                     GetState;

    // From Callbacks2
    LPD3DHAL_SETRENDERTARGETCB              SetRenderTarget;
    LPD3DHAL_CLEARCB                        Clear;
    LPD3DHAL_DRAWONEPRIMITIVECB             DrawOnePrimitive;
    LPD3DHAL_DRAWONEINDEXEDPRIMITIVECB      DrawOneIndexedPrimitive;
    LPD3DHAL_DRAWPRIMITIVESCB               DrawPrimitives;

    // From Callbacks3
    LPD3DHAL_CLEAR2CB                       Clear2;
    LPD3DHAL_VALIDATETEXTURESTAGESTATECB    ValidateTextureStageState;
    LPD3DHAL_DRAWPRIMITIVES2CB              DrawPrimitives2;

    // From MiscCallbacks in DDraw
    LPDDHAL_GETDRIVERSTATE                  GetDriverState;
    LPDDHAL_CREATESURFACEEX                 CreateSurfaceEx;

    // DDraw Callbacks
    LPDDHAL_CREATESURFACE                   CreateSurface;
    LPDDHALSURFCB_DESTROYSURFACE            DestroySurface;
    LPDDHALSURFCB_LOCK                      Lock;
    LPDDHALSURFCB_UNLOCK                    Unlock;

} D3D8_SWCALLBACKS, * PD3D8_SWCALLBACKS;


#ifdef __cplusplus
extern "C" {
#endif

HRESULT APIENTRY D3D8GetSWInfo(
    PD3D8_SWCAPS        pCaps,
    PD3D8_SWCALLBACKS   pCallbacks
    );

#ifdef __cplusplus
}
#endif


// Prototypes required to hook the DDI layer (used by RefRast and the HEL

#define D3D8_REFRASTNAME            "D3DREF8.DLL"

#define D3D8HOOK_GETSWINFOPROCNAME  "D3D8GetSWInfo"

typedef HRESULT (WINAPI * PD3D8GetSWInfo)(PD3D8_SWCAPS       pCaps,
                                         PD3D8_SWCALLBACKS  pCallbacks);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dxg\xgmath.inl ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1998 - 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:       xgmath.inl
//  Content:    XG math inline functions
//
//////////////////////////////////////////////////////////////////////////////

#ifndef __XGMATH_INL__
#define __XGMATH_INL__

#pragma warning(disable:4035)

//===========================================================================
//
// Inline Class Methods
//
//===========================================================================

#ifdef __cplusplus

#include <malloc.h>

//--------------------------
// 2D Vector
//--------------------------

XGINLINE
XGVECTOR2::XGVECTOR2( CONST FLOAT *pf )
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pf != NULL);
#endif

#endif

    x = pf[0];
    y = pf[1];
}

XGINLINE
XGVECTOR2::XGVECTOR2( FLOAT fx, FLOAT fy )
{
    x = fx;
    y = fy;
}

// casting
XGINLINE
XGVECTOR2::operator FLOAT* ()
{
    return (FLOAT *) &x;
}

XGINLINE
XGVECTOR2::operator CONST FLOAT* () const
{
    return (CONST FLOAT *) &x;
}

// assignment operators
XGINLINE XGVECTOR2&
XGVECTOR2::operator += ( CONST XGVECTOR2& v )
{
    x += v.x;
    y += v.y;
    return *this;
}

XGINLINE XGVECTOR2&
XGVECTOR2::operator -= ( CONST XGVECTOR2& v )
{
    x -= v.x;
    y -= v.y;
    return *this;
}

XGINLINE XGVECTOR2&
XGVECTOR2::operator *= ( FLOAT f )
{
    x *= f;
    y *= f;
    return *this;
}

XGINLINE XGVECTOR2&
XGVECTOR2::operator /= ( FLOAT f )
{
    FLOAT fInv = 1.0f / f;
    x *= fInv;
    y *= fInv;
    return *this;
}

// unary operators
XGINLINE XGVECTOR2
XGVECTOR2::operator + () const
{
    return *this;
}

XGINLINE XGVECTOR2
XGVECTOR2::operator - () const
{
    return XGVECTOR2(-x, -y);
}

// binary operators
XGINLINE XGVECTOR2
XGVECTOR2::operator + ( CONST XGVECTOR2& v ) const
{
    return XGVECTOR2(x + v.x, y + v.y);
}

XGINLINE XGVECTOR2
XGVECTOR2::operator - ( CONST XGVECTOR2& v ) const
{
    return XGVECTOR2(x - v.x, y - v.y);
}

XGINLINE XGVECTOR2
XGVECTOR2::operator * ( FLOAT f ) const
{
    return XGVECTOR2(x * f, y * f);
}

XGINLINE XGVECTOR2
XGVECTOR2::operator / ( FLOAT f ) const
{
    FLOAT fInv = 1.0f / f;
    return XGVECTOR2(x * fInv, y * fInv);
}


XGINLINE XGVECTOR2
operator * ( FLOAT f, CONST XGVECTOR2& v )
{
    return XGVECTOR2(f * v.x, f * v.y);
}

XGINLINE BOOL
XGVECTOR2::operator == ( CONST XGVECTOR2& v ) const
{
    return x == v.x && y == v.y;
}

XGINLINE BOOL
XGVECTOR2::operator != ( CONST XGVECTOR2& v ) const
{
    return x != v.x || y != v.y;
}




//--------------------------
// 3D Vector
//--------------------------
XGINLINE
XGVECTOR3::XGVECTOR3( CONST FLOAT *pf )
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pf != NULL);
#endif

#endif

    x = pf[0];
    y = pf[1];
    z = pf[2];
}

XGINLINE
XGVECTOR3::XGVECTOR3( CONST D3DVECTOR& v )
{
    x = v.x;
    y = v.y;
    z = v.z;
}

XGINLINE
XGVECTOR3::XGVECTOR3( FLOAT fx, FLOAT fy, FLOAT fz )
{
    x = fx;
    y = fy;
    z = fz;
}


// casting
XGINLINE
XGVECTOR3::operator FLOAT* ()
{
    return (FLOAT *) &x;
}

XGINLINE
XGVECTOR3::operator CONST FLOAT* () const
{
    return (CONST FLOAT *) &x;
}


// assignment operators
XGINLINE XGVECTOR3&
XGVECTOR3::operator += ( CONST XGVECTOR3& v )
{
    x += v.x;
    y += v.y;
    z += v.z;
    return *this;
}

XGINLINE XGVECTOR3&
XGVECTOR3::operator -= ( CONST XGVECTOR3& v )
{
    x -= v.x;
    y -= v.y;
    z -= v.z;
    return *this;
}

XGINLINE XGVECTOR3&
XGVECTOR3::operator *= ( FLOAT f )
{
    x *= f;
    y *= f;
    z *= f;
    return *this;
}

XGINLINE XGVECTOR3&
XGVECTOR3::operator /= ( FLOAT f )
{
    FLOAT fInv = 1.0f / f;
    x *= fInv;
    y *= fInv;
    z *= fInv;
    return *this;
}


// unary operators
XGINLINE XGVECTOR3
XGVECTOR3::operator + () const
{
    return *this;
}

XGINLINE XGVECTOR3
XGVECTOR3::operator - () const
{
    return XGVECTOR3(-x, -y, -z);
}


// binary operators
XGINLINE XGVECTOR3
XGVECTOR3::operator + ( CONST XGVECTOR3& v ) const
{
    return XGVECTOR3(x + v.x, y + v.y, z + v.z);
}

XGINLINE XGVECTOR3
XGVECTOR3::operator - ( CONST XGVECTOR3& v ) const
{
    return XGVECTOR3(x - v.x, y - v.y, z - v.z);
}

XGINLINE XGVECTOR3
XGVECTOR3::operator * ( FLOAT f ) const
{
    return XGVECTOR3(x * f, y * f, z * f);
}

XGINLINE XGVECTOR3
XGVECTOR3::operator / ( FLOAT f ) const
{
    FLOAT fInv = 1.0f / f;
    return XGVECTOR3(x * fInv, y * fInv, z * fInv);
}


XGINLINE XGVECTOR3
operator * ( FLOAT f, CONST struct XGVECTOR3& v )
{
    return XGVECTOR3(f * v.x, f * v.y, f * v.z);
}


XGINLINE BOOL
XGVECTOR3::operator == ( CONST XGVECTOR3& v ) const
{
    return x == v.x && y == v.y && z == v.z;
}

XGINLINE BOOL
XGVECTOR3::operator != ( CONST XGVECTOR3& v ) const
{
    return x != v.x || y != v.y || z != v.z;
}



//--------------------------
// 4D Vector
//--------------------------
XGINLINE
XGVECTOR4::XGVECTOR4( CONST FLOAT *pf )
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pf != NULL);
#endif

#endif

    x = pf[0];
    y = pf[1];
    z = pf[2];
    w = pf[3];
}

XGINLINE
XGVECTOR4::XGVECTOR4( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
{
    x = fx;
    y = fy;
    z = fz;
    w = fw;
}


// casting
XGINLINE
XGVECTOR4::operator FLOAT* ()
{
    return (FLOAT *) &x;
}

XGINLINE
XGVECTOR4::operator CONST FLOAT* () const
{
    return (CONST FLOAT *) &x;
}


// assignment operators
XGINLINE XGVECTOR4&
XGVECTOR4::operator += ( CONST XGVECTOR4& v )
{
    x += v.x;
    y += v.y;
    z += v.z;
    w += v.w;
    return *this;
}

XGINLINE XGVECTOR4&
XGVECTOR4::operator -= ( CONST XGVECTOR4& v )
{
    x -= v.x;
    y -= v.y;
    z -= v.z;
    w -= v.w;
    return *this;
}

XGINLINE XGVECTOR4&
XGVECTOR4::operator *= ( FLOAT f )
{
    x *= f;
    y *= f;
    z *= f;
    w *= f;
    return *this;
}

XGINLINE XGVECTOR4&
XGVECTOR4::operator /= ( FLOAT f )
{
    FLOAT fInv = 1.0f / f;
    x *= fInv;
    y *= fInv;
    z *= fInv;
    w *= fInv;
    return *this;
}


// unary operators
XGINLINE XGVECTOR4
XGVECTOR4::operator + () const
{
    return *this;
}

XGINLINE XGVECTOR4
XGVECTOR4::operator - () const
{
    return XGVECTOR4(-x, -y, -z, -w);
}


// binary operators
XGINLINE XGVECTOR4
XGVECTOR4::operator + ( CONST XGVECTOR4& v ) const
{
    return XGVECTOR4(x + v.x, y + v.y, z + v.z, w + v.w);
}

XGINLINE XGVECTOR4
XGVECTOR4::operator - ( CONST XGVECTOR4& v ) const
{
    return XGVECTOR4(x - v.x, y - v.y, z - v.z, w - v.w);
}

XGINLINE XGVECTOR4
XGVECTOR4::operator * ( FLOAT f ) const
{
    return XGVECTOR4(x * f, y * f, z * f, w * f);
}

XGINLINE XGVECTOR4
XGVECTOR4::operator / ( FLOAT f ) const
{
    FLOAT fInv = 1.0f / f;
    return XGVECTOR4(x * fInv, y * fInv, z * fInv, w * fInv);
}


XGINLINE XGVECTOR4
operator * ( FLOAT f, CONST XGVECTOR4& v )
{
    return XGVECTOR4(f * v.x, f * v.y, f * v.z, f * v.w);
}


XGINLINE BOOL
XGVECTOR4::operator == ( CONST XGVECTOR4& v ) const
{
    return x == v.x && y == v.y && z == v.z && w == v.w;
}

XGINLINE BOOL
XGVECTOR4::operator != ( CONST XGVECTOR4& v ) const
{
    return x != v.x || y != v.y || z != v.z || w != v.w;
}


//--------------------------
// Matrix
//--------------------------
XGINLINE
XGMATRIX::XGMATRIX( CONST FLOAT* pf )
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pf != NULL);
#endif

#endif

    memcpy(&_11, pf, sizeof(XGMATRIX));
}

XGINLINE
XGMATRIX::XGMATRIX( CONST D3DMATRIX& mat )
{
    memcpy(&_11, &mat, sizeof(XGMATRIX));
}

XGINLINE
XGMATRIX::XGMATRIX( FLOAT f11, FLOAT f12, FLOAT f13, FLOAT f14,
                        FLOAT f21, FLOAT f22, FLOAT f23, FLOAT f24,
                        FLOAT f31, FLOAT f32, FLOAT f33, FLOAT f34,
                        FLOAT f41, FLOAT f42, FLOAT f43, FLOAT f44 )
{
    _11 = f11; _12 = f12; _13 = f13; _14 = f14;
    _21 = f21; _22 = f22; _23 = f23; _24 = f24;
    _31 = f31; _32 = f32; _33 = f33; _34 = f34;
    _41 = f41; _42 = f42; _43 = f43; _44 = f44;
}


// access grants
XGINLINE FLOAT&
XGMATRIX::operator () ( UINT iRow, UINT iCol )
{
    return m[iRow][iCol];
}

XGINLINE FLOAT
XGMATRIX::operator () ( UINT iRow, UINT iCol ) const
{
    return m[iRow][iCol];
}


// casting operators
XGINLINE
XGMATRIX::operator FLOAT* ()
{
    return (FLOAT *) &_11;
}

XGINLINE
XGMATRIX::operator CONST FLOAT* () const
{
    return (CONST FLOAT *) &_11;
}


// assignment operators
XGINLINE XGMATRIX&
XGMATRIX::operator *= ( CONST XGMATRIX& mat )
{
    XGMatrixMultiply(this, this, &mat);
    return *this;
}

XGINLINE XGMATRIX&
XGMATRIX::operator += ( CONST XGMATRIX& mat )
{
    _11 += mat._11; _12 += mat._12; _13 += mat._13; _14 += mat._14;
    _21 += mat._21; _22 += mat._22; _23 += mat._23; _24 += mat._24;
    _31 += mat._31; _32 += mat._32; _33 += mat._33; _34 += mat._34;
    _41 += mat._41; _42 += mat._42; _43 += mat._43; _44 += mat._44;
    return *this;
}

XGINLINE XGMATRIX&
XGMATRIX::operator -= ( CONST XGMATRIX& mat )
{
    _11 -= mat._11; _12 -= mat._12; _13 -= mat._13; _14 -= mat._14;
    _21 -= mat._21; _22 -= mat._22; _23 -= mat._23; _24 -= mat._24;
    _31 -= mat._31; _32 -= mat._32; _33 -= mat._33; _34 -= mat._34;
    _41 -= mat._41; _42 -= mat._42; _43 -= mat._43; _44 -= mat._44;
    return *this;
}

XGINLINE XGMATRIX&
XGMATRIX::operator *= ( FLOAT f )
{
    _11 *= f; _12 *= f; _13 *= f; _14 *= f;
    _21 *= f; _22 *= f; _23 *= f; _24 *= f;
    _31 *= f; _32 *= f; _33 *= f; _34 *= f;
    _41 *= f; _42 *= f; _43 *= f; _44 *= f;
    return *this;
}

XGINLINE XGMATRIX&
XGMATRIX::operator /= ( FLOAT f )
{
    FLOAT fInv = 1.0f / f;
    _11 *= fInv; _12 *= fInv; _13 *= fInv; _14 *= fInv;
    _21 *= fInv; _22 *= fInv; _23 *= fInv; _24 *= fInv;
    _31 *= fInv; _32 *= fInv; _33 *= fInv; _34 *= fInv;
    _41 *= fInv; _42 *= fInv; _43 *= fInv; _44 *= fInv;
    return *this;
}


// unary operators
XGINLINE XGMATRIX
XGMATRIX::operator + () const
{
    return *this;
}

XGINLINE XGMATRIX
XGMATRIX::operator - () const
{
    return XGMATRIX(-_11, -_12, -_13, -_14,
                      -_21, -_22, -_23, -_24,
                      -_31, -_32, -_33, -_34,
                      -_41, -_42, -_43, -_44);
}


// binary operators
XGINLINE XGMATRIX
XGMATRIX::operator * ( CONST XGMATRIX& mat ) const
{
    XGMATRIX matT;
    XGMatrixMultiply(&matT, this, &mat);
    return matT;
}

XGINLINE XGMATRIX
XGMATRIX::operator + ( CONST XGMATRIX& mat ) const
{
    return XGMATRIX(_11 + mat._11, _12 + mat._12, _13 + mat._13, _14 + mat._14,
                      _21 + mat._21, _22 + mat._22, _23 + mat._23, _24 + mat._24,
                      _31 + mat._31, _32 + mat._32, _33 + mat._33, _34 + mat._34,
                      _41 + mat._41, _42 + mat._42, _43 + mat._43, _44 + mat._44);
}

XGINLINE XGMATRIX
XGMATRIX::operator - ( CONST XGMATRIX& mat ) const
{
    return XGMATRIX(_11 - mat._11, _12 - mat._12, _13 - mat._13, _14 - mat._14,
                      _21 - mat._21, _22 - mat._22, _23 - mat._23, _24 - mat._24,
                      _31 - mat._31, _32 - mat._32, _33 - mat._33, _34 - mat._34,
                      _41 - mat._41, _42 - mat._42, _43 - mat._43, _44 - mat._44);
}

XGINLINE XGMATRIX
XGMATRIX::operator * ( FLOAT f ) const
{
    return XGMATRIX(_11 * f, _12 * f, _13 * f, _14 * f,
                      _21 * f, _22 * f, _23 * f, _24 * f,
                      _31 * f, _32 * f, _33 * f, _34 * f,
                      _41 * f, _42 * f, _43 * f, _44 * f);
}

XGINLINE XGMATRIX
XGMATRIX::operator / ( FLOAT f ) const
{
    FLOAT fInv = 1.0f / f;
    return XGMATRIX(_11 * fInv, _12 * fInv, _13 * fInv, _14 * fInv,
                      _21 * fInv, _22 * fInv, _23 * fInv, _24 * fInv,
                      _31 * fInv, _32 * fInv, _33 * fInv, _34 * fInv,
                      _41 * fInv, _42 * fInv, _43 * fInv, _44 * fInv);
}


XGINLINE XGMATRIX
operator * ( FLOAT f, CONST XGMATRIX& mat )
{
    return XGMATRIX(f * mat._11, f * mat._12, f * mat._13, f * mat._14,
                      f * mat._21, f * mat._22, f * mat._23, f * mat._24,
                      f * mat._31, f * mat._32, f * mat._33, f * mat._34,
                      f * mat._41, f * mat._42, f * mat._43, f * mat._44);
}


XGINLINE BOOL
XGMATRIX::operator == ( CONST XGMATRIX& mat ) const
{
    return 0 == memcmp(this, &mat, sizeof(XGMATRIX));
}

XGINLINE BOOL
XGMATRIX::operator != ( CONST XGMATRIX& mat ) const
{
    return 0 != memcmp(this, &mat, sizeof(XGMATRIX));
}



//--------------------------
// Quaternion
//--------------------------

XGINLINE
XGQUATERNION::XGQUATERNION( CONST FLOAT* pf )
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pf != NULL);
#endif

#endif

    x = pf[0];
    y = pf[1];
    z = pf[2];
    w = pf[3];
}

XGINLINE
XGQUATERNION::XGQUATERNION( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
{
    x = fx;
    y = fy;
    z = fz;
    w = fw;
}


// casting
XGINLINE
XGQUATERNION::operator FLOAT* ()
{
    return (FLOAT *) &x;
}

XGINLINE
XGQUATERNION::operator CONST FLOAT* () const
{
    return (CONST FLOAT *) &x;
}


// assignment operators
XGINLINE XGQUATERNION&
XGQUATERNION::operator += ( CONST XGQUATERNION& q )
{
    x += q.x;
    y += q.y;
    z += q.z;
    w += q.w;
    return *this;
}

XGINLINE XGQUATERNION&
XGQUATERNION::operator -= ( CONST XGQUATERNION& q )
{
    x -= q.x;
    y -= q.y;
    z -= q.z;
    w -= q.w;
    return *this;
}

XGINLINE XGQUATERNION&
XGQUATERNION::operator *= ( CONST XGQUATERNION& q )
{
    XGQuaternionMultiply(this, this, &q);
    return *this;
}

XGINLINE XGQUATERNION&
XGQUATERNION::operator *= ( FLOAT f )
{
    x *= f;
    y *= f;
    z *= f;
    w *= f;
    return *this;
}

XGINLINE XGQUATERNION&
XGQUATERNION::operator /= ( FLOAT f )
{
    FLOAT fInv = 1.0f / f;
    x *= fInv;
    y *= fInv;
    z *= fInv;
    w *= fInv;
    return *this;
}


// unary operators
XGINLINE XGQUATERNION
XGQUATERNION::operator + () const
{
    return *this;
}

XGINLINE XGQUATERNION
XGQUATERNION::operator - () const
{
    return XGQUATERNION(-x, -y, -z, -w);
}


// binary operators
XGINLINE XGQUATERNION
XGQUATERNION::operator + ( CONST XGQUATERNION& q ) const
{
    return XGQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
}

XGINLINE XGQUATERNION
XGQUATERNION::operator - ( CONST XGQUATERNION& q ) const
{
    return XGQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
}

XGINLINE XGQUATERNION
XGQUATERNION::operator * ( CONST XGQUATERNION& q ) const
{
    XGQUATERNION qT;
    XGQuaternionMultiply(&qT, this, &q);
    return qT;
}

XGINLINE XGQUATERNION
XGQUATERNION::operator * ( FLOAT f ) const
{
    return XGQUATERNION(x * f, y * f, z * f, w * f);
}

XGINLINE XGQUATERNION
XGQUATERNION::operator / ( FLOAT f ) const
{
    FLOAT fInv = 1.0f / f;
    return XGQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
}


XGINLINE XGQUATERNION
operator * (FLOAT f, CONST XGQUATERNION& q )
{
    return XGQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
}


XGINLINE BOOL
XGQUATERNION::operator == ( CONST XGQUATERNION& q ) const
{
    return x == q.x && y == q.y && z == q.z && w == q.w;
}

XGINLINE BOOL
XGQUATERNION::operator != ( CONST XGQUATERNION& q ) const
{
    return x != q.x || y != q.y || z != q.z || w != q.w;
}




//--------------------------
// Plane
//--------------------------

XGINLINE
XGPLANE::XGPLANE( CONST FLOAT* pf )
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pf != NULL);
#endif

#endif

    a = pf[0];
    b = pf[1];
    c = pf[2];
    d = pf[3];
}

XGINLINE
XGPLANE::XGPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
{
    a = fa;
    b = fb;
    c = fc;
    d = fd;
}


// casting
XGINLINE
XGPLANE::operator FLOAT* ()
{
    return (FLOAT *) &a;
}

XGINLINE
XGPLANE::operator CONST FLOAT* () const
{
    return (CONST FLOAT *) &a;
}


// unary operators
XGINLINE XGPLANE
XGPLANE::operator + () const
{
    return *this;
}

XGINLINE XGPLANE
XGPLANE::operator - () const
{
    return XGPLANE(-a, -b, -c, -d);
}


// binary operators
XGINLINE BOOL
XGPLANE::operator == ( CONST XGPLANE& p ) const
{
    return a == p.a && b == p.b && c == p.c && d == p.d;
}

XGINLINE BOOL
XGPLANE::operator != ( CONST XGPLANE& p ) const
{
    return a != p.a || b != p.b || c != p.c || d != p.d;
}




//--------------------------
// Color
//--------------------------

XGINLINE
XGCOLOR::XGCOLOR( DWORD dw )
{
    CONST FLOAT f = 1.0f / 255.0f;
    r = f * (FLOAT) (unsigned char) (dw >> 16);
    g = f * (FLOAT) (unsigned char) (dw >>  8);
    b = f * (FLOAT) (unsigned char) (dw >>  0);
    a = f * (FLOAT) (unsigned char) (dw >> 24);
}

XGINLINE
XGCOLOR::XGCOLOR( CONST FLOAT* pf )
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pf != NULL);
#endif

#endif

    r = pf[0];
    g = pf[1];
    b = pf[2];
    a = pf[3];
}

XGINLINE
XGCOLOR::XGCOLOR( CONST D3DCOLORVALUE& c )
{
    r = c.r;
    g = c.g;
    b = c.b;
    a = c.a;
}

XGINLINE
XGCOLOR::XGCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
{
    r = fr;
    g = fg;
    b = fb;
    a = fa;
}


// casting
XGINLINE
XGCOLOR::operator DWORD () const
{
    FLOAT R = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (r * 255.0f + 0.5f);
    FLOAT G = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (g * 255.0f + 0.5f);
    FLOAT B = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (b * 255.0f + 0.5f);
    FLOAT A = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (a * 255.0f + 0.5f);

    __asm {
        cvtss2si eax, B

        cvtss2si edx, A
        shl edx, 24
        or eax, edx

        cvtss2si edx, R
        shl edx, 16
        or eax, edx

        cvtss2si edx, G
        shl edx, 8
        or eax, edx
    }
}


XGINLINE
XGCOLOR::operator FLOAT * ()
{
    return (FLOAT *) &r;
}

XGINLINE
XGCOLOR::operator CONST FLOAT * () const
{
    return (CONST FLOAT *) &r;
}


XGINLINE
XGCOLOR::operator D3DCOLORVALUE * ()
{
    return (D3DCOLORVALUE *) &r;
}

XGINLINE
XGCOLOR::operator CONST D3DCOLORVALUE * () const
{
    return (CONST D3DCOLORVALUE *) &r;
}


XGINLINE
XGCOLOR::operator D3DCOLORVALUE& ()
{
    return *((D3DCOLORVALUE *) &r);
}

XGINLINE
XGCOLOR::operator CONST D3DCOLORVALUE& () const
{
    return *((CONST D3DCOLORVALUE *) &r);
}


// assignment operators
XGINLINE XGCOLOR&
XGCOLOR::operator += ( CONST XGCOLOR& c )
{
    r += c.r;
    g += c.g;
    b += c.b;
    a += c.a;
    return *this;
}

XGINLINE XGCOLOR&
XGCOLOR::operator -= ( CONST XGCOLOR& c )
{
    r -= c.r;
    g -= c.g;
    b -= c.b;
    a -= c.a;
    return *this;
}

XGINLINE XGCOLOR&
XGCOLOR::operator *= ( FLOAT f )
{
    r *= f;
    g *= f;
    b *= f;
    a *= f;
    return *this;
}

XGINLINE XGCOLOR&
XGCOLOR::operator /= ( FLOAT f )
{
    FLOAT fInv = 1.0f / f;
    r *= fInv;
    g *= fInv;
    b *= fInv;
    a *= fInv;
    return *this;
}


// unary operators
XGINLINE XGCOLOR
XGCOLOR::operator + () const
{
    return *this;
}

XGINLINE XGCOLOR
XGCOLOR::operator - () const
{
    return XGCOLOR(-r, -g, -b, -a);
}


// binary operators
XGINLINE XGCOLOR
XGCOLOR::operator + ( CONST XGCOLOR& c ) const
{
    return XGCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
}

XGINLINE XGCOLOR
XGCOLOR::operator - ( CONST XGCOLOR& c ) const
{
    return XGCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
}

XGINLINE XGCOLOR
XGCOLOR::operator * ( FLOAT f ) const
{
    return XGCOLOR(r * f, g * f, b * f, a * f);
}

XGINLINE XGCOLOR
XGCOLOR::operator / ( FLOAT f ) const
{
    FLOAT fInv = 1.0f / f;
    return XGCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
}


XGINLINE XGCOLOR
operator * (FLOAT f, CONST XGCOLOR& c )
{
    return XGCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
}


XGINLINE BOOL
XGCOLOR::operator == ( CONST XGCOLOR& c ) const
{
    return r == c.r && g == c.g && b == c.b && a == c.a;
}

XGINLINE BOOL
XGCOLOR::operator != ( CONST XGCOLOR& c ) const
{
    return r != c.r || g != c.g || b != c.b || a != c.a;
}

#endif //__cplusplus

//===========================================================================
//
// Inline functions
//
//===========================================================================


//--------------------------
// 2D Vector
//--------------------------

XGINLINE FLOAT XGVec2Length
    ( CONST XGVECTOR2 *pV )
{
    FLOAT res;

#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pV != NULL);
#endif

#endif

    __asm {
        mov     edx, pV
        movups  xmm1, [edx]
        movaps  xmm2, xmm1

        mulps   xmm1, xmm2

        movaps  xmm0, xmm1

        shufps  xmm0, xmm0, 1h
        addps   xmm1, xmm0

        sqrtss  xmm1, xmm1
        movss  [res], xmm1
    }

    return res;
}

XGINLINE FLOAT XGVec2LengthSq
    ( CONST XGVECTOR2 *pV )
{
    FLOAT res;

#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pV != NULL);
#endif

#endif

    __asm {
        mov     edx, pV
        movups  xmm1, [edx]
        movaps  xmm2, xmm1

        mulps   xmm1, xmm2

        movaps  xmm0, xmm1

        shufps  xmm0, xmm0, 1h
        addps   xmm1, xmm0

        movss  [res], xmm1
    }

    return res;
}

XGINLINE FLOAT XGVec2Dot
    ( CONST XGVECTOR2 *pV1, CONST XGVECTOR2 *pV2 )
{
    FLOAT res;

#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pV1 != NULL && pV2 != NULL);
#endif

#endif

    __asm {
        mov     edx, pV1
        movlps  xmm1, [edx]

        mov     ecx, pV2
        movlps  xmm2, [ecx]

        mulps   xmm1, xmm2

        movaps  xmm0, xmm1

        shufps  xmm0, xmm0, 1h
        addps   xmm1, xmm0

        movss  [res], xmm1
    }

    return res;
}

XGINLINE FLOAT XGVec2CCW
    ( CONST XGVECTOR2 *pV1, CONST XGVECTOR2 *pV2 )
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pV1 != NULL && pV2 != NULL);
#endif

#endif

    return pV1->x * pV2->y - pV1->y * pV2->x;
}

XGINLINE XGVECTOR2* XGVec2Add
    ( XGVECTOR2 *pOut, CONST XGVECTOR2 *pV1, CONST XGVECTOR2 *pV2 )
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pOut != NULL && pV1 != NULL && pV2 != NULL);
#endif

#endif

    __asm {
        mov     edx, pV1
        movlps  xmm1, [edx]

        mov     ecx, pV2
        movlps  xmm2, [ecx]

        addps   xmm1, xmm2

        mov     eax, pOut
        movlps  [eax], xmm1
    }
}

XGINLINE XGVECTOR2* XGVec2Subtract
    ( XGVECTOR2 *pOut, CONST XGVECTOR2 *pV1, CONST XGVECTOR2 *pV2 )
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pOut != NULL && pV1 != NULL && pV2 != NULL);
#endif

#endif

    __asm {
        mov     edx, pV1
        movlps  xmm1, [edx]

        mov     ecx, pV2
        movlps  xmm2, [ecx]

        subps   xmm1, xmm2

        mov     eax, pOut
        movlps  [eax], xmm1
    }
}

XGINLINE XGVECTOR2* XGVec2Minimize
    ( XGVECTOR2 *pOut, CONST XGVECTOR2 *pV1, CONST XGVECTOR2 *pV2 )
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pOut != NULL && pV1 != NULL && pV2 != NULL);
#endif

#endif

    __asm {
        mov      ecx, pV1
        mov      edx, pV2
        movlps   xmm0, [ecx]
        movlps   xmm1, [edx]
        minps    xmm0, xmm1
        mov      eax, pOut
        movlps   [eax], xmm0
    }
}

XGINLINE XGVECTOR2* XGVec2Maximize
    ( XGVECTOR2 *pOut, CONST XGVECTOR2 *pV1, CONST XGVECTOR2 *pV2 )
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pOut != NULL && pV1 != NULL && pV2 != NULL);
#endif

#endif

    __asm {
        mov      ecx, pV1
        mov      edx, pV2
        movlps   xmm0, [ecx]
        movlps   xmm1, [edx]
        maxps    xmm0, xmm1
        mov      eax, pOut
        movlps   [eax], xmm0
    }
}

XGINLINE XGVECTOR2* XGVec2Scale
    ( XGVECTOR2 *pOut, CONST XGVECTOR2 *pV, FLOAT s )
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pOut != NULL && pV != NULL);
#endif

#endif

    __asm {
        movss   xmm0, s
        shufps  xmm0, xmm0, 0h

        mov     ecx, pV
        movlps  xmm1, [ecx]

        mulps   xmm0, xmm1

        mov     eax, pOut
        movlps  [eax], xmm0
    }
}

XGINLINE XGVECTOR2* XGVec2Lerp
    ( XGVECTOR2 *pOut, CONST XGVECTOR2 *pV1, CONST XGVECTOR2 *pV2,
      FLOAT s )
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pOut != NULL && pV1 != NULL && pV2 != NULL);
#endif

#endif

    __asm {
        movss   xmm0, s
        shufps  xmm0, xmm0, 0h

        mov     ecx, pV1
        movlps  xmm1, [ecx]

        mov     edx, pV2
        movlps  xmm2, [edx]

        subps   xmm2, xmm1
        mulps   xmm0, xmm2

        addps   xmm0, xmm1

        mov     eax, pOut
        movlps  [eax], xmm0
    }
}


//--------------------------
// 3D Vector
//--------------------------

XGINLINE FLOAT XGVec3Length
    ( CONST XGVECTOR3 *pV )
{
    FLOAT res;

#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pV != NULL);
#endif

#endif

    __asm {
        mov     edx, pV
        movss   xmm1, [edx]
        movhps  xmm1, [edx+4]

        movaps  xmm2, xmm1

        mulps   xmm1, xmm2

        movaps  xmm0, xmm1

        shufps  xmm0, xmm0, 32h
        addps   xmm1, xmm0

        shufps  xmm0, xmm0, 32h
        addps   xmm1, xmm0

        sqrtss  xmm1, xmm1
        movss   [res], xmm1
    }

    return res;
}

XGINLINE FLOAT XGVec3LengthSq
    ( CONST XGVECTOR3 *pV )
{
    FLOAT res;

#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pV != NULL);
#endif

#endif

    __asm {
        mov     edx, pV
        movss   xmm1, [edx]
        movhps  xmm1, [edx+4]

        movaps  xmm2, xmm1

        mulps   xmm1, xmm2

        movaps  xmm0, xmm1

        shufps  xmm0, xmm0, 32h
        addps   xmm1, xmm0

        shufps  xmm0, xmm0, 32h
        addps   xmm1, xmm0

        movss   [res], xmm1
    }

    return res;
}

XGINLINE FLOAT XGVec3Dot
    ( CONST XGVECTOR3 *pV1, CONST XGVECTOR3 *pV2 )
{
    FLOAT res;

#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pV1 != NULL && pV2 != NULL);
#endif

#endif

    __asm {
        mov     edx, pV1
        movss   xmm1, [edx]
        movhps  xmm1, [edx+4]

        mov     edx, pV2
        movss   xmm2, [edx]
        movhps  xmm2, [edx+4]

        mulps   xmm1, xmm2

        movaps  xmm0, xmm1

        shufps  xmm0, xmm0, 32h
        addps   xmm1, xmm0

        shufps  xmm0, xmm0, 32h
        addps   xmm1, xmm0

        movss   [res], xmm1
    }

    return res;
}

XGINLINE XGVECTOR3* XGVec3Cross
    ( XGVECTOR3 *pOut, CONST XGVECTOR3 *pV1, CONST XGVECTOR3 *pV2 )
{
    XGVECTOR3 v;

#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pOut != NULL && pV1 != NULL && pV2 != NULL);
#endif

#endif

    v.x = pV1->y * pV2->z - pV1->z * pV2->y;
    v.y = pV1->z * pV2->x - pV1->x * pV2->z;
    v.z = pV1->x * pV2->y - pV1->y * pV2->x;

    *pOut = v;
    return pOut;
}

XGINLINE XGVECTOR3* XGVec3Add
    ( XGVECTOR3 *pOut, CONST XGVECTOR3 *pV1, CONST XGVECTOR3 *pV2 )
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pOut != NULL && pV1 != NULL && pV2 != NULL);
#endif

#endif

    __asm {
        mov      ecx, pV1
        movss    xmm0, [ecx]
        movhps   xmm0, [ecx+4]

        mov      edx, pV2
        movss    xmm1, [edx]
        movhps   xmm1, [edx+4]

        addps    xmm0, xmm1

        mov      eax, pOut
        movss    [eax], xmm0
        movhps   [eax+4], xmm0
    }
}

XGINLINE XGVECTOR3* XGVec3Subtract
    ( XGVECTOR3 *pOut, CONST XGVECTOR3 *pV1, CONST XGVECTOR3 *pV2 )
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pOut != NULL && pV1 != NULL && pV2 != NULL);
#endif

#endif

    __asm {
        mov      ecx, pV1
        movss    xmm0, [ecx]
        movhps   xmm0, [ecx+4]

        mov      edx, pV2
        movss    xmm1, [edx]
        movhps   xmm1, [edx+4]

        subps    xmm0, xmm1

        mov      eax, pOut
        movss    [eax], xmm0
        movhps   [eax+4], xmm0
    }
}

XGINLINE XGVECTOR3* XGVec3Minimize
    ( XGVECTOR3 *pOut, CONST XGVECTOR3 *pV1, CONST XGVECTOR3 *pV2 )
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pOut != NULL && pV1 != NULL && pV2 != NULL);
#endif

#endif

    __asm {
        mov      ecx, pV1
        movss    xmm0, [ecx]
        movhps   xmm0, [ecx+4]

        mov      edx, pV2
        movss    xmm1, [edx]
        movhps   xmm1, [edx+4]

        minps    xmm0, xmm1

        mov      eax, pOut
        movss    [eax], xmm0
        movhps   [eax+4], xmm0
    }
}

XGINLINE XGVECTOR3* XGVec3Maximize
    ( XGVECTOR3 *pOut, CONST XGVECTOR3 *pV1, CONST XGVECTOR3 *pV2 )
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pOut != NULL && pV1 != NULL && pV2 != NULL);
#endif

#endif

    __asm {
        mov      ecx, pV1
        movss    xmm0, [ecx]
        movhps   xmm0, [ecx+4]

        mov      edx, pV2
        movss    xmm1, [edx]
        movhps   xmm1, [edx+4]

        maxps    xmm0, xmm1

        mov      eax, pOut
        movss    [eax], xmm0
        movhps   [eax+4], xmm0
    }
}

XGINLINE XGVECTOR3* XGVec3Scale
    ( XGVECTOR3 *pOut, CONST XGVECTOR3 *pV, FLOAT s)
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pOut != NULL && pV != NULL);
#endif

#endif

    __asm {
        movss    xmm0, s
        shufps   xmm0, xmm0, 0h

        mov      edx, pV
        movss    xmm1, [edx]
        movhps   xmm1, [edx+4]

        mulps    xmm0, xmm1

        mov      eax, pOut
        movss    [eax], xmm0
        movhps   [eax+4], xmm0
    }
}

XGINLINE XGVECTOR3* XGVec3Lerp
    ( XGVECTOR3 *pOut, CONST XGVECTOR3 *pV1, CONST XGVECTOR3 *pV2,
      FLOAT s )
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pOut != NULL && pV1 != NULL && pV2 != NULL);
#endif

#endif

    __asm {
        mov      ecx, pV1
        movss    xmm1, [ecx]
        movhps   xmm1, [ecx+4]

        mov      edx, pV2
        movss    xmm2, [edx]
        movhps   xmm2, [edx+4]

        subps    xmm2, xmm1

        movss    xmm0, s
        shufps   xmm0, xmm0, 0h

        mulps    xmm0, xmm2
        
        addps    xmm0, xmm1

        mov      eax, pOut
        movss    [eax], xmm0
        movhps   [eax+4], xmm0
    }
}


//--------------------------
// 4D Vector
//--------------------------

XGINLINE FLOAT XGVec4Length
    ( CONST XGVECTOR4 *pV )
{
    FLOAT res;

#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pV != NULL);
#endif

#endif

    __asm {
        mov     edx, pV
        movups  xmm1, [edx]
        movaps  xmm2, xmm1

        mulps   xmm1, xmm2

        movaps  xmm0, xmm1

        shufps  xmm0, xmm0, 93h
        addps   xmm1, xmm0

        shufps  xmm0, xmm0, 93h
        addps   xmm1, xmm0

        shufps  xmm0, xmm0, 93h
        addps   xmm1, xmm0

        sqrtss  xmm1, xmm1
        movss  [res], xmm1
    }

    return res;
}

XGINLINE FLOAT XGVec4LengthSq
    ( CONST XGVECTOR4 *pV )
{
    FLOAT res;

#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pV != NULL);
#endif

#endif

    __asm {
        mov     edx, pV
        movups  xmm1, [edx]
        movaps  xmm2, xmm1

        mulps   xmm1, xmm2

        movaps  xmm0, xmm1

        shufps  xmm0, xmm0, 93h
        addps   xmm1, xmm0

        shufps  xmm0, xmm0, 93h
        addps   xmm1, xmm0

        shufps  xmm0, xmm0, 93h
        addps   xmm1, xmm0

        movss  [res], xmm1
    }

    return res;
}

XGINLINE FLOAT XGVec4Dot
    ( CONST XGVECTOR4 *pV1, CONST XGVECTOR4 *pV2 )
{
    FLOAT res;

#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pV1 != NULL && pV2 != NULL);
#endif

#endif

    __asm {
        mov     edx, pV1
        movups  xmm1, [edx]

        mov     ecx, pV2
        movups  xmm2, [ecx]

        mulps   xmm1, xmm2

        movaps  xmm0, xmm1

        shufps  xmm0, xmm0, 93h
        addps   xmm1, xmm0

        shufps  xmm0, xmm0, 93h
        addps   xmm1, xmm0

        shufps  xmm0, xmm0, 93h
        addps   xmm1, xmm0

        movss  [res], xmm1
    }

    return res;
}

XGINLINE XGVECTOR4* XGVec4Add
    ( XGVECTOR4 *pOut, CONST XGVECTOR4 *pV1, CONST XGVECTOR4 *pV2)
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pOut != NULL && pV1 != NULL && pV2 != NULL);
#endif

#endif

    __asm {
        mov     edx, pV1
        movups  xmm1, [edx]

        mov     ecx, pV2
        movups  xmm2, [ecx]

        addps   xmm1, xmm2

        mov     eax, pOut
        movups  [eax], xmm1
    }
}

XGINLINE XGVECTOR4* XGVec4Subtract
    ( XGVECTOR4 *pOut, CONST XGVECTOR4 *pV1, CONST XGVECTOR4 *pV2)
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pOut != NULL && pV1 != NULL && pV2 != NULL);
#endif

#endif

    __asm {
        mov     edx, pV1
        movups  xmm1, [edx]

        mov     ecx, pV2
        movups  xmm2, [ecx]

        subps   xmm1, xmm2

        mov     eax, pOut
        movups  [eax], xmm1
    }
}

XGINLINE XGVECTOR4* XGVec4Minimize
    ( XGVECTOR4 *pOut, CONST XGVECTOR4 *pV1, CONST XGVECTOR4 *pV2)
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pOut != NULL && pV1 != NULL && pV2 != NULL);
#endif

#endif

    __asm {
        mov      ecx, pV1
        mov      edx, pV2
        movups   xmm0, [ecx]
        movups   xmm1, [edx]
        minps    xmm0, xmm1
        mov      eax, pOut
        movups   [eax], xmm0
    }
}

XGINLINE XGVECTOR4* XGVec4Maximize
    ( XGVECTOR4 *pOut, CONST XGVECTOR4 *pV1, CONST XGVECTOR4 *pV2)
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pOut != NULL && pV1 != NULL && pV2 != NULL);
#endif

#endif

    __asm {
        mov      ecx, pV1
        mov      edx, pV2
        movups   xmm0, [ecx]
        movups   xmm1, [edx]
        maxps    xmm0, xmm1
        mov      eax, pOut
        movups   [eax], xmm0
    }
}

XGINLINE XGVECTOR4* XGVec4Scale
    ( XGVECTOR4 *pOut, CONST XGVECTOR4 *pV, FLOAT s)
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pOut != NULL && pV);
#endif

#endif

    __asm {
        movss   xmm0, s
        shufps  xmm0, xmm0, 0h

        mov     ecx, pV
        movups  xmm1, [ecx]

        mulps   xmm0, xmm1

        mov     eax, pOut
        movups  [eax], xmm0
    }
}

XGINLINE XGVECTOR4* XGVec4Lerp
    ( XGVECTOR4 *pOut, CONST XGVECTOR4 *pV1, CONST XGVECTOR4 *pV2,
      FLOAT s )
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pOut != NULL && pV1 != NULL && pV2 != NULL);
#endif

#endif

    __asm {
        movss   xmm0, s
        shufps  xmm0, xmm0, 0h

        mov     ecx, pV1
        movups  xmm1, [ecx]

        mov     edx, pV2
        movups  xmm2, [edx]

        subps   xmm2, xmm1
        mulps   xmm0, xmm2

        addps   xmm0, xmm1

        mov     eax, pOut
        movups  [eax], xmm0
    }
}


//--------------------------
// 4D Matrix
//--------------------------

XGINLINE XGMATRIX* XGMatrixIdentity
    ( XGMATRIX *pOut )
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pOut != NULL);
#endif

#endif

    pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =
    pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
    pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
    pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;

    pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;
    return pOut;
}


XGINLINE BOOL XGMatrixIsIdentity
    ( CONST XGMATRIX *pM )
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pM != NULL);
#endif

#endif

    return pM->m[0][0] == 1.0f && pM->m[0][1] == 0.0f && pM->m[0][2] == 0.0f && pM->m[0][3] == 0.0f &&
           pM->m[1][0] == 0.0f && pM->m[1][1] == 1.0f && pM->m[1][2] == 0.0f && pM->m[1][3] == 0.0f &&
           pM->m[2][0] == 0.0f && pM->m[2][1] == 0.0f && pM->m[2][2] == 1.0f && pM->m[2][3] == 0.0f &&
           pM->m[3][0] == 0.0f && pM->m[3][1] == 0.0f && pM->m[3][2] == 0.0f && pM->m[3][3] == 1.0f;
}


//--------------------------
// Quaternion
//--------------------------

XGINLINE FLOAT XGQuaternionLength
    ( CONST XGQUATERNION *pQ )
{
    FLOAT res;

#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pQ != NULL);
#endif

#endif

    __asm {
        mov     edx, pQ
        movups  xmm1, [edx]
        movaps  xmm2, xmm1

        mulps   xmm1, xmm2

        movaps  xmm0, xmm1

        shufps  xmm0, xmm0, 93h
        addps   xmm1, xmm0

        shufps  xmm0, xmm0, 93h
        addps   xmm1, xmm0

        shufps  xmm0, xmm0, 93h
        addps   xmm1, xmm0

        sqrtss  xmm1, xmm1
        movss  [res], xmm1
    }

    return res;
}

XGINLINE FLOAT XGQuaternionLengthSq
    ( CONST XGQUATERNION *pQ )
{
    FLOAT res;

#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pQ != NULL);
#endif

#endif
    
    __asm {
        mov     edx, pQ
        movups  xmm1, [edx]
        movaps  xmm2, xmm1

        mulps   xmm1, xmm2

        movaps  xmm0, xmm1

        shufps  xmm0, xmm0, 93h
        addps   xmm1, xmm0

        shufps  xmm0, xmm0, 93h
        addps   xmm1, xmm0

        shufps  xmm0, xmm0, 93h
        addps   xmm1, xmm0

        movss  [res], xmm1
    }

    return res;
}

XGINLINE FLOAT XGQuaternionDot
    ( CONST XGQUATERNION *pQ1, CONST XGQUATERNION *pQ2 )
{
    FLOAT res;

#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pQ1 != NULL && pQ2 != NULL);
#endif

#endif

    __asm {
        mov     edx, pQ1
        movups  xmm1, [edx]

        mov     ecx, pQ2
        movups  xmm2, [ecx]

        mulps   xmm1, xmm2

        movaps  xmm0, xmm1

        shufps  xmm0, xmm0, 93h
        addps   xmm1, xmm0

        shufps  xmm0, xmm0, 93h
        addps   xmm1, xmm0

        shufps  xmm0, xmm0, 93h
        addps   xmm1, xmm0

        movss  [res], xmm1
    }

    return res;
}

XGINLINE XGQUATERNION* XGQuaternionIdentity
    ( XGQUATERNION *pOut )
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pOut != NULL);
#endif

#endif

    pOut->x = pOut->y = pOut->z = 0.0f;
    pOut->w = 1.0f;
    return pOut;
}

XGINLINE BOOL XGQuaternionIsIdentity
    ( CONST XGQUATERNION *pQ )
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pQ != NULL);
#endif

#endif

    return pQ->x == 0.0f && pQ->y == 0.0f && pQ->z == 0.0f && pQ->w == 1.0f;
}


XGINLINE XGQUATERNION* XGQuaternionConjugate
    ( XGQUATERNION *pOut, CONST XGQUATERNION *pQ )
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pOut != NULL && pQ != NULL);
#endif

#endif

    pOut->x = -pQ->x;
    pOut->y = -pQ->y;
    pOut->z = -pQ->z;
    pOut->w =  pQ->w;
    return pOut;
}

//--------------------------
// Plane
//--------------------------

XGINLINE FLOAT XGPlaneDot
    ( CONST XGPLANE *pP, CONST XGVECTOR4 *pV)
{
    FLOAT res;

#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pP != NULL && pV != NULL);
#endif

#endif

    __asm {
        mov     edx, pP
        movups  xmm1, [edx]

        mov     ecx, pV
        movups  xmm2, [ecx]

        mulps   xmm1, xmm2

        movaps  xmm0, xmm1

        shufps  xmm0, xmm0, 93h
        addps   xmm1, xmm0

        shufps  xmm0, xmm0, 93h
        addps   xmm1, xmm0

        shufps  xmm0, xmm0, 93h
        addps   xmm1, xmm0

        movss  [res], xmm1
    }

    return res;
}

XGINLINE FLOAT XGPlaneDotCoord
    ( CONST XGPLANE *pP, CONST XGVECTOR3 *pV)
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pP != NULL && pV != NULL);
#endif

#endif

    return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;
}

XGINLINE FLOAT XGPlaneDotNormal
    ( CONST XGPLANE *pP, CONST XGVECTOR3 *pV)
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pP != NULL && pV != NULL);
#endif

#endif

    return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z;
}


//--------------------------
// Color
//--------------------------

XGINLINE XGCOLOR* XGColorNegative
    (XGCOLOR *pOut, CONST XGCOLOR *pC)
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pOut != NULL && pC != NULL);
#endif

#endif

    pOut->r = 1.0f - pC->r;
    pOut->g = 1.0f - pC->g;
    pOut->b = 1.0f - pC->b;
    pOut->a = pC->a;
    return pOut;
}

XGINLINE XGCOLOR* XGColorAdd
    (XGCOLOR *pOut, CONST XGCOLOR *pC1, CONST XGCOLOR *pC2)
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pOut != NULL && pC1 != NULL && pC2 != NULL);
#endif

#endif

    __asm {
        mov     edx, pC1
        movups  xmm1, [edx]

        mov     ecx, pC2
        movups  xmm2, [ecx]

        addps   xmm1, xmm2

        mov     eax, pOut
        movups  [eax], xmm1
    }
}

XGINLINE XGCOLOR* XGColorSubtract
    (XGCOLOR *pOut, CONST XGCOLOR *pC1, CONST XGCOLOR *pC2)
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pOut != NULL && pC1 != NULL && pC2 != NULL);
#endif

#endif

    __asm {
        mov     edx, pC1
        movups  xmm1, [edx]

        mov     ecx, pC2
        movups  xmm2, [ecx]

        subps   xmm1, xmm2

        mov     eax, pOut
        movups  [eax], xmm1
    }
}

XGINLINE XGCOLOR* XGColorScale
    (XGCOLOR *pOut, CONST XGCOLOR *pC, FLOAT s)
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pOut != NULL && pC != NULL);
#endif

#endif

    __asm {
        movss   xmm0, s
        shufps  xmm0, xmm0, 0h

        mov     ecx, pC
        movups  xmm1, [ecx]

        mulps   xmm0, xmm1

        mov     eax, pOut
        movups  [eax], xmm0
    }
}

XGINLINE XGCOLOR* XGColorModulate
    (XGCOLOR *pOut, CONST XGCOLOR *pC1, CONST XGCOLOR *pC2)
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pOut != NULL && pC1 != NULL && pC2 != NULL);
#endif

#endif

    __asm {
        mov     edx, pC1
        movups  xmm1, [edx]

        mov     ecx, pC2
        movups  xmm2, [ecx]

        mulps   xmm1, xmm2

        mov     eax, pOut
        movups  [eax], xmm1
    }
}

XGINLINE XGCOLOR* XGColorLerp
    (XGCOLOR *pOut, CONST XGCOLOR *pC1, CONST XGCOLOR *pC2, FLOAT s)
{
#ifdef _DEBUG

#ifdef ASSERT
    ASSERT(pOut != NULL && pC1 != NULL && pC2 != NULL);
#endif

#endif

    __asm {
        movss   xmm0, s
        shufps  xmm0, xmm0, 0h

        mov     ecx, pC1
        movups  xmm1, [ecx]

        mov     edx, pC2
        movups  xmm2, [edx]

        subps   xmm2, xmm1
        mulps   xmm0, xmm2

        addps   xmm0, xmm1

        mov     eax, pOut
        movups  [eax], xmm0
    }
}

#pragma warning(default:4035)

#endif // __XG8MATH_INL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dxg\d3dxmath.inl ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dxmath.inl
//  Content:    D3DX math inline functions
//
//////////////////////////////////////////////////////////////////////////////

#ifndef __D3DXMATH_INL__
#define __D3DXMATH_INL__


//===========================================================================
//
// Inline Class Methods
//
//===========================================================================

#ifdef __cplusplus

//--------------------------
// 2D Vector
//--------------------------

D3DXINLINE 
D3DXVECTOR2::D3DXVECTOR2( const float *pf )
{
#ifdef D3DX_DEBUG
    if(!pf)
        return;
#endif

    x = pf[0];
    y = pf[1];
}

D3DXINLINE 
D3DXVECTOR2::D3DXVECTOR2( float fx, float fy )
{
    x = fx;
    y = fy;
}

// casting
D3DXINLINE 
D3DXVECTOR2::operator float* ()
{
    return (float *) &x;
}

D3DXINLINE 
D3DXVECTOR2::operator const float* () const
{
    return (const float *) &x;
}

// assignment operators
D3DXINLINE D3DXVECTOR2& 
D3DXVECTOR2::operator += ( const D3DXVECTOR2& v )
{
    x += v.x;
    y += v.y;
    return *this;
}

D3DXINLINE D3DXVECTOR2& 
D3DXVECTOR2::operator -= ( const D3DXVECTOR2& v )
{
    x -= v.x;
    y -= v.y;
    return *this;
}

D3DXINLINE D3DXVECTOR2& 
D3DXVECTOR2::operator *= ( float f )
{
    x *= f;
    y *= f;
    return *this;
}

D3DXINLINE D3DXVECTOR2& 
D3DXVECTOR2::operator /= ( float f )
{
    float fInv = 1.0f / f;
    x *= fInv;
    y *= fInv;
    return *this;
}

// unary operators
D3DXINLINE D3DXVECTOR2 
D3DXVECTOR2::operator + () const
{
    return *this;
}

D3DXINLINE D3DXVECTOR2 
D3DXVECTOR2::operator - () const
{
    return D3DXVECTOR2(-x, -y);
}

// binary operators
D3DXINLINE D3DXVECTOR2 
D3DXVECTOR2::operator + ( const D3DXVECTOR2& v ) const
{
    return D3DXVECTOR2(x + v.x, y + v.y);
}

D3DXINLINE D3DXVECTOR2 
D3DXVECTOR2::operator - ( const D3DXVECTOR2& v ) const
{
    return D3DXVECTOR2(x - v.x, y - v.y);
}

D3DXINLINE D3DXVECTOR2 
D3DXVECTOR2::operator * ( float f ) const
{
    return D3DXVECTOR2(x * f, y * f);
}

D3DXINLINE D3DXVECTOR2 
D3DXVECTOR2::operator / ( float f ) const
{
    float fInv = 1.0f / f;
    return D3DXVECTOR2(x * fInv, y * fInv);
}


D3DXINLINE D3DXVECTOR2 
operator * ( float f, const D3DXVECTOR2& v )
{
    return D3DXVECTOR2(f * v.x, f * v.y);
}

D3DXINLINE BOOL 
D3DXVECTOR2::operator == ( const D3DXVECTOR2& v ) const
{
    return x == v.x && y == v.y;
}

D3DXINLINE BOOL 
D3DXVECTOR2::operator != ( const D3DXVECTOR2& v ) const
{
    return x != v.x || y != v.y;
}




//--------------------------
// 3D Vector
//--------------------------
D3DXINLINE 
D3DXVECTOR3::D3DXVECTOR3( const float *pf )
{
#ifdef D3DX_DEBUG
    if(!pf)
        return;
#endif

    x = pf[0];
    y = pf[1];
    z = pf[2];
}

D3DXINLINE 
D3DXVECTOR3::D3DXVECTOR3( const D3DVECTOR& v )
{
    x = v.x;
    y = v.y;
    z = v.z;
}

D3DXINLINE 
D3DXVECTOR3::D3DXVECTOR3( float fx, float fy, float fz )
{
    x = fx;
    y = fy;
    z = fz;
}


// casting
D3DXINLINE 
D3DXVECTOR3::operator float* ()
{
    return (float *) &x;
}

D3DXINLINE 
D3DXVECTOR3::operator const float* () const
{
    return (const float *) &x;
}


D3DXINLINE 
D3DXVECTOR3::operator D3DVECTOR* ()
{
    return (D3DVECTOR *) &x;
}

D3DXINLINE 
D3DXVECTOR3::operator const D3DVECTOR* () const
{
    return (const D3DVECTOR *) &x;
}


D3DXINLINE 
D3DXVECTOR3::operator D3DVECTOR& ()
{
    return *((D3DVECTOR *) &x);
}

D3DXINLINE 
D3DXVECTOR3::operator const D3DVECTOR& () const
{
    return *((const D3DVECTOR *) &x);
}


// assignment operators
D3DXINLINE D3DXVECTOR3& 
D3DXVECTOR3::operator += ( const D3DXVECTOR3& v )
{
    x += v.x;
    y += v.y;
    z += v.z;
    return *this;
}

D3DXINLINE D3DXVECTOR3& 
D3DXVECTOR3::operator -= ( const D3DXVECTOR3& v )
{
    x -= v.x;
    y -= v.y;
    z -= v.z;
    return *this;
}

D3DXINLINE D3DXVECTOR3& 
D3DXVECTOR3::operator *= ( float f )
{
    x *= f;
    y *= f;
    z *= f;
    return *this;
}

D3DXINLINE D3DXVECTOR3& 
D3DXVECTOR3::operator /= ( float f )
{
    float fInv = 1.0f / f;
    x *= fInv;
    y *= fInv;
    z *= fInv;
    return *this;
}


// unary operators
D3DXINLINE D3DXVECTOR3 
D3DXVECTOR3::operator + () const
{
    return *this;
}

D3DXINLINE D3DXVECTOR3 
D3DXVECTOR3::operator - () const
{
    return D3DXVECTOR3(-x, -y, -z);
}


// binary operators
D3DXINLINE D3DXVECTOR3 
D3DXVECTOR3::operator + ( const D3DXVECTOR3& v ) const
{
    return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);
}

D3DXINLINE D3DXVECTOR3 
D3DXVECTOR3::operator - ( const D3DXVECTOR3& v ) const
{
    return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);
}

D3DXINLINE D3DXVECTOR3 
D3DXVECTOR3::operator * ( float f ) const
{
    return D3DXVECTOR3(x * f, y * f, z * f);
}

D3DXINLINE D3DXVECTOR3 
D3DXVECTOR3::operator / ( float f ) const
{
    float fInv = 1.0f / f;
    return D3DXVECTOR3(x * fInv, y * fInv, z * fInv);
}


D3DXINLINE D3DXVECTOR3 
operator * ( float f, const struct D3DXVECTOR3& v )
{
    return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);
}


D3DXINLINE BOOL 
D3DXVECTOR3::operator == ( const D3DXVECTOR3& v ) const
{
    return x == v.x && y == v.y && z == v.z;
}

D3DXINLINE BOOL 
D3DXVECTOR3::operator != ( const D3DXVECTOR3& v ) const
{
    return x != v.x || y != v.y || z != v.z;
}



//--------------------------
// 4D Vector
//--------------------------
D3DXINLINE 
D3DXVECTOR4::D3DXVECTOR4( const float *pf )
{
#ifdef D3DX_DEBUG
    if(!pf)
        return;
#endif

    x = pf[0];
    y = pf[1];
    z = pf[2];
    w = pf[3];
}

D3DXINLINE 
D3DXVECTOR4::D3DXVECTOR4( float fx, float fy, float fz, float fw )
{
    x = fx;
    y = fy;
    z = fz;
    w = fw;
}


// casting
D3DXINLINE 
D3DXVECTOR4::operator float* ()
{
    return (float *) &x;
}

D3DXINLINE 
D3DXVECTOR4::operator const float* () const
{
    return (const float *) &x;
}


// assignment operators
D3DXINLINE D3DXVECTOR4& 
D3DXVECTOR4::operator += ( const D3DXVECTOR4& v )
{
    x += v.x;
    y += v.y;
    z += v.z;
    w += v.w;
    return *this;
}

D3DXINLINE D3DXVECTOR4& 
D3DXVECTOR4::operator -= ( const D3DXVECTOR4& v )
{
    x -= v.x;
    y -= v.y;
    z -= v.z;
    w -= v.w;
    return *this;
}

D3DXINLINE D3DXVECTOR4& 
D3DXVECTOR4::operator *= ( float f )
{
    x *= f;
    y *= f;
    z *= f;
    w *= f;
    return *this;
}

D3DXINLINE D3DXVECTOR4& 
D3DXVECTOR4::operator /= ( float f )
{
    float fInv = 1.0f / f;
    x *= fInv;
    y *= fInv;
    z *= fInv;
    w *= fInv;
    return *this;
}


// unary operators
D3DXINLINE D3DXVECTOR4 
D3DXVECTOR4::operator + () const
{
    return *this;
}

D3DXINLINE D3DXVECTOR4 
D3DXVECTOR4::operator - () const
{
    return D3DXVECTOR4(-x, -y, -z, -w);
}


// binary operators
D3DXINLINE D3DXVECTOR4 
D3DXVECTOR4::operator + ( const D3DXVECTOR4& v ) const
{
    return D3DXVECTOR4(x + v.x, y + v.y, z + v.z, w + v.w);
}

D3DXINLINE D3DXVECTOR4 
D3DXVECTOR4::operator - ( const D3DXVECTOR4& v ) const
{
    return D3DXVECTOR4(x - v.x, y - v.y, z - v.z, w - v.w);
}

D3DXINLINE D3DXVECTOR4 
D3DXVECTOR4::operator * ( float f ) const
{
    return D3DXVECTOR4(x * f, y * f, z * f, w * f);
}

D3DXINLINE D3DXVECTOR4 
D3DXVECTOR4::operator / ( float f ) const
{
    float fInv = 1.0f / f;
    return D3DXVECTOR4(x * fInv, y * fInv, z * fInv, w * fInv);
}


D3DXINLINE D3DXVECTOR4 
operator * ( float f, const D3DXVECTOR4& v )
{
    return D3DXVECTOR4(f * v.x, f * v.y, f * v.z, f * v.w);
}


D3DXINLINE BOOL 
D3DXVECTOR4::operator == ( const D3DXVECTOR4& v ) const
{
    return x == v.x && y == v.y && z == v.z && w == v.w;
}

D3DXINLINE BOOL 
D3DXVECTOR4::operator != ( const D3DXVECTOR4& v ) const
{
    return x != v.x || y != v.y || z != v.z || w != v.w;
}


//--------------------------
// Matrix
//--------------------------
D3DXINLINE 
D3DXMATRIX::D3DXMATRIX( const float* pf )
{
#ifdef D3DX_DEBUG
    if(!pf)
        return;
#endif

    memcpy(&m00, pf, sizeof(D3DXMATRIX));
}

D3DXINLINE 
D3DXMATRIX::D3DXMATRIX( const D3DMATRIX& mat )
{
    memcpy(&m00, &mat, sizeof(D3DXMATRIX));
}

D3DXINLINE 
D3DXMATRIX::D3DXMATRIX( float f00, float f01, float f02, float f03,
                        float f10, float f11, float f12, float f13,
                        float f20, float f21, float f22, float f23,
                        float f30, float f31, float f32, float f33 )
{
    m00 = f00; m01 = f01; m02 = f02; m03 = f03;
    m10 = f10; m11 = f11; m12 = f12; m13 = f13;
    m20 = f20; m21 = f21; m22 = f22; m23 = f23;
    m30 = f30; m31 = f31; m32 = f32; m33 = f33;
}



// access grants
D3DXINLINE float& 
D3DXMATRIX::operator () ( UINT iRow, UINT iCol )
{
    return m[iRow][iCol];
}

D3DXINLINE float  
D3DXMATRIX::operator () ( UINT iRow, UINT iCol ) const
{
    return m[iRow][iCol];
}


// casting operators
D3DXINLINE 
D3DXMATRIX::operator float* ()
{
    return (float *) &m00;
}

D3DXINLINE 
D3DXMATRIX::operator const float* () const
{
    return (const float *) &m00;
}


D3DXINLINE 
D3DXMATRIX::operator D3DMATRIX* ()
{
    return (D3DMATRIX *) &m00;
}

D3DXINLINE 
D3DXMATRIX::operator const D3DMATRIX* () const
{
    return (const D3DMATRIX *) &m00;
}


D3DXINLINE 
D3DXMATRIX::operator D3DMATRIX& ()
{
    return *((D3DMATRIX *) &m00);
}

D3DXINLINE 
D3DXMATRIX::operator const D3DMATRIX& () const
{
    return *((const D3DMATRIX *) &m00);
}


// assignment operators
D3DXINLINE D3DXMATRIX& 
D3DXMATRIX::operator *= ( const D3DXMATRIX& mat )
{
    D3DXMatrixMultiply(this, this, &mat);
    return *this;
}

D3DXINLINE D3DXMATRIX& 
D3DXMATRIX::operator += ( const D3DXMATRIX& mat )
{
    m00 += mat.m00; m01 += mat.m01; m02 += mat.m02; m03 += mat.m03;
    m10 += mat.m10; m11 += mat.m11; m12 += mat.m12; m13 += mat.m13;
    m20 += mat.m20; m21 += mat.m21; m22 += mat.m22; m23 += mat.m23;
    m30 += mat.m30; m31 += mat.m31; m32 += mat.m32; m33 += mat.m33;
    return *this;
}

D3DXINLINE D3DXMATRIX& 
D3DXMATRIX::operator -= ( const D3DXMATRIX& mat )
{
    m00 -= mat.m00; m01 -= mat.m01; m02 -= mat.m02; m03 -= mat.m03;
    m10 -= mat.m10; m11 -= mat.m11; m12 -= mat.m12; m13 -= mat.m13;
    m20 -= mat.m20; m21 -= mat.m21; m22 -= mat.m22; m23 -= mat.m23;
    m30 -= mat.m30; m31 -= mat.m31; m32 -= mat.m32; m33 -= mat.m33;
    return *this;
}

D3DXINLINE D3DXMATRIX& 
D3DXMATRIX::operator *= ( float f )
{
    m00 *= f; m01 *= f; m02 *= f; m03 *= f;
    m10 *= f; m11 *= f; m12 *= f; m13 *= f;
    m20 *= f; m21 *= f; m22 *= f; m23 *= f;
    m30 *= f; m31 *= f; m32 *= f; m33 *= f;
    return *this;
}

D3DXINLINE D3DXMATRIX& 
D3DXMATRIX::operator /= ( float f )
{
    float fInv = 1.0f / f;
    m00 *= fInv; m01 *= fInv; m02 *= fInv; m03 *= fInv;
    m10 *= fInv; m11 *= fInv; m12 *= fInv; m13 *= fInv;
    m20 *= fInv; m21 *= fInv; m22 *= fInv; m23 *= fInv;
    m30 *= fInv; m31 *= fInv; m32 *= fInv; m33 *= fInv;
    return *this;
}


// unary operators
D3DXINLINE D3DXMATRIX 
D3DXMATRIX::operator + () const
{
    return *this;
}

D3DXINLINE D3DXMATRIX 
D3DXMATRIX::operator - () const
{
    return D3DXMATRIX(-m00, -m01, -m02, -m03,
                      -m10, -m11, -m12, -m13,
                      -m20, -m21, -m22, -m23,
                      -m30, -m31, -m32, -m33);
}


// binary operators
D3DXINLINE D3DXMATRIX 
D3DXMATRIX::operator * ( const D3DXMATRIX& mat ) const
{
    D3DXMATRIX matT;
    D3DXMatrixMultiply(&matT, this, &mat);
    return matT;
}

D3DXINLINE D3DXMATRIX 
D3DXMATRIX::operator + ( const D3DXMATRIX& mat ) const
{
    return D3DXMATRIX(m00 + mat.m00, m01 + mat.m01, m02 + mat.m02, m03 + mat.m03, 
                      m10 + mat.m10, m11 + mat.m11, m12 + mat.m12, m13 + mat.m13, 
                      m20 + mat.m20, m21 + mat.m21, m22 + mat.m22, m23 + mat.m23, 
                      m30 + mat.m30, m31 + mat.m31, m32 + mat.m32, m33 + mat.m33);
}    

D3DXINLINE D3DXMATRIX 
D3DXMATRIX::operator - ( const D3DXMATRIX& mat ) const
{
    return D3DXMATRIX(m00 - mat.m00, m01 - mat.m01, m02 - mat.m02, m03 - mat.m03, 
                      m10 - mat.m10, m11 - mat.m11, m12 - mat.m12, m13 - mat.m13, 
                      m20 - mat.m20, m21 - mat.m21, m22 - mat.m22, m23 - mat.m23, 
                      m30 - mat.m30, m31 - mat.m31, m32 - mat.m32, m33 - mat.m33);
}

D3DXINLINE D3DXMATRIX 
D3DXMATRIX::operator * ( float f ) const
{
    return D3DXMATRIX(m00 * f, m01 * f, m02 * f, m03 * f, 
                      m10 * f, m11 * f, m12 * f, m13 * f, 
                      m20 * f, m21 * f, m22 * f, m23 * f, 
                      m30 * f, m31 * f, m32 * f, m33 * f);
}

D3DXINLINE D3DXMATRIX 
D3DXMATRIX::operator / ( float f ) const
{
    float fInv = 1.0f / f;
    return D3DXMATRIX(m00 * fInv, m01 * fInv, m02 * fInv, m03 * fInv, 
                      m10 * fInv, m11 * fInv, m12 * fInv, m13 * fInv, 
                      m20 * fInv, m21 * fInv, m22 * fInv, m23 * fInv, 
                      m30 * fInv, m31 * fInv, m32 * fInv, m33 * fInv);
}


D3DXINLINE D3DXMATRIX 
operator * ( float f, const D3DXMATRIX& mat )
{
    return D3DXMATRIX(f * mat.m00, f * mat.m01, f * mat.m02, f * mat.m03, 
                      f * mat.m10, f * mat.m11, f * mat.m12, f * mat.m13, 
                      f * mat.m20, f * mat.m21, f * mat.m22, f * mat.m23, 
                      f * mat.m30, f * mat.m31, f * mat.m32, f * mat.m33);
}


D3DXINLINE BOOL 
D3DXMATRIX::operator == ( const D3DXMATRIX& mat ) const
{
    return 0 == memcmp(this, &mat, sizeof(D3DXMATRIX));
}

D3DXINLINE BOOL 
D3DXMATRIX::operator != ( const D3DXMATRIX& mat ) const
{
    return 0 != memcmp(this, &mat, sizeof(D3DXMATRIX));
}



//--------------------------
// Quaternion
//--------------------------

D3DXINLINE 
D3DXQUATERNION::D3DXQUATERNION( const float* pf )
{
#ifdef D3DX_DEBUG
    if(!pf)
        return;
#endif

    x = pf[0];
    y = pf[1];
    z = pf[2];
    w = pf[3];
}

D3DXINLINE 
D3DXQUATERNION::D3DXQUATERNION( float fx, float fy, float fz, float fw )
{
    x = fx;
    y = fy;
    z = fz;
    w = fw;
}


// casting
D3DXINLINE 
D3DXQUATERNION::operator float* ()
{
    return (float *) &x;
}

D3DXINLINE 
D3DXQUATERNION::operator const float* () const
{
    return (const float *) &x;
}


// assignment operators
D3DXINLINE D3DXQUATERNION& 
D3DXQUATERNION::operator += ( const D3DXQUATERNION& q )
{
    x += q.x;
    y += q.y;
    z += q.z;
    w += q.w;
    return *this;
}

D3DXINLINE D3DXQUATERNION& 
D3DXQUATERNION::operator -= ( const D3DXQUATERNION& q )
{
    x -= q.x;
    y -= q.y;
    z -= q.z;
    w -= q.w;
    return *this;
}

D3DXINLINE D3DXQUATERNION& 
D3DXQUATERNION::operator *= ( const D3DXQUATERNION& q )
{
    D3DXQuaternionMultiply(this, this, &q);
    return *this;
}

D3DXINLINE D3DXQUATERNION& 
D3DXQUATERNION::operator *= ( float f )
{
    x *= f;
    y *= f;
    z *= f;
    w *= f;
    return *this;
}

D3DXINLINE D3DXQUATERNION& 
D3DXQUATERNION::operator /= ( float f )
{
    float fInv = 1.0f / f;
    x *= fInv;
    y *= fInv;
    z *= fInv;
    w *= fInv;
    return *this;
}


// unary operators
D3DXINLINE D3DXQUATERNION  
D3DXQUATERNION::operator + () const
{
    return *this;
}

D3DXINLINE D3DXQUATERNION  
D3DXQUATERNION::operator - () const
{
    return D3DXQUATERNION(-x, -y, -z, -w);
}


// binary operators
D3DXINLINE D3DXQUATERNION 
D3DXQUATERNION::operator + ( const D3DXQUATERNION& q ) const
{
    return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
}

D3DXINLINE D3DXQUATERNION 
D3DXQUATERNION::operator - ( const D3DXQUATERNION& q ) const
{
    return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
}

D3DXINLINE D3DXQUATERNION 
D3DXQUATERNION::operator * ( const D3DXQUATERNION& q ) const
{
    D3DXQUATERNION qT;
    D3DXQuaternionMultiply(&qT, this, &q);
    return qT;
}

D3DXINLINE D3DXQUATERNION 
D3DXQUATERNION::operator * ( float f ) const
{
    return D3DXQUATERNION(x * f, y * f, z * f, w * f);
}

D3DXINLINE D3DXQUATERNION 
D3DXQUATERNION::operator / ( float f ) const
{
    float fInv = 1.0f / f;
    return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
}


D3DXINLINE D3DXQUATERNION 
operator * (float f, const D3DXQUATERNION& q )
{
    return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
}


D3DXINLINE BOOL 
D3DXQUATERNION::operator == ( const D3DXQUATERNION& q ) const
{
    return x == q.x && y == q.y && z == q.z && w == q.w;
}

D3DXINLINE BOOL 
D3DXQUATERNION::operator != ( const D3DXQUATERNION& q ) const
{
    return x != q.x || y != q.y || z != q.z || w != q.w;
}



//--------------------------
// Plane
//--------------------------

D3DXINLINE 
D3DXPLANE::D3DXPLANE( const float* pf )
{
#ifdef D3DX_DEBUG
    if(!pf)
        return;
#endif

    a = pf[0];
    b = pf[1];
    c = pf[2];
    d = pf[3];
}

D3DXINLINE 
D3DXPLANE::D3DXPLANE( float fa, float fb, float fc, float fd )
{
    a = fa;
    b = fb;
    c = fc;
    d = fd;
}


// casting
D3DXINLINE 
D3DXPLANE::operator float* ()
{
    return (float *) &a;
}

D3DXINLINE 
D3DXPLANE::operator const float* () const
{
    return (const float *) &a;
}


// unary operators
D3DXINLINE D3DXPLANE 
D3DXPLANE::operator + () const
{
    return *this;
}

D3DXINLINE D3DXPLANE 
D3DXPLANE::operator - () const
{
    return D3DXPLANE(-a, -b, -c, -d);
}


// binary operators
D3DXINLINE BOOL 
D3DXPLANE::operator == ( const D3DXPLANE& p ) const
{
    return a == p.a && b == p.b && c == p.c && d == p.d;
}

D3DXINLINE BOOL 
D3DXPLANE::operator != ( const D3DXPLANE& p ) const
{
    return a != p.a || b != p.b || c != p.c || d != p.d;
}




//--------------------------
// Color
//--------------------------

D3DXINLINE 
D3DXCOLOR::D3DXCOLOR( DWORD dw )
{
    const float f = 1.0f / 255.0f;
    r = f * (float) (unsigned char) (dw >> 16);
    g = f * (float) (unsigned char) (dw >>  8);
    b = f * (float) (unsigned char) (dw >>  0);
    a = f * (float) (unsigned char) (dw >> 24);
}

D3DXINLINE 
D3DXCOLOR::D3DXCOLOR( const float* pf )
{
#ifdef D3DX_DEBUG
    if(!pf)
        return;
#endif

    r = pf[0];
    g = pf[1];
    b = pf[2];
    a = pf[3];
}

D3DXINLINE 
D3DXCOLOR::D3DXCOLOR( const D3DCOLORVALUE& c )
{
    r = c.r;
    g = c.g;
    b = c.b;
    a = c.a;
}

D3DXINLINE 
D3DXCOLOR::D3DXCOLOR( float fr, float fg, float fb, float fa )
{
    r = fr;
    g = fg;
    b = fb;
    a = fa;
}


// casting
D3DXINLINE 
D3DXCOLOR::operator DWORD () const
{
    DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
    DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
    DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
    DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

    return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
}


D3DXINLINE 
D3DXCOLOR::operator float * ()
{
    return (float *) &r;
}

D3DXINLINE 
D3DXCOLOR::operator const float * () const
{
    return (const float *) &r;
}


D3DXINLINE 
D3DXCOLOR::operator D3DCOLORVALUE * ()
{
    return (D3DCOLORVALUE *) &r;
}

D3DXINLINE 
D3DXCOLOR::operator const D3DCOLORVALUE * () const
{
    return (const D3DCOLORVALUE *) &r;
}


D3DXINLINE 
D3DXCOLOR::operator D3DCOLORVALUE& ()
{
    return *((D3DCOLORVALUE *) &r);
}

D3DXINLINE 
D3DXCOLOR::operator const D3DCOLORVALUE& () const
{
    return *((const D3DCOLORVALUE *) &r);
}


// assignment operators
D3DXINLINE D3DXCOLOR& 
D3DXCOLOR::operator += ( const D3DXCOLOR& c )
{
    r += c.r;
    g += c.g;
    b += c.b;
    a += c.a;
    return *this;
}

D3DXINLINE D3DXCOLOR& 
D3DXCOLOR::operator -= ( const D3DXCOLOR& c )
{
    r -= c.r;
    g -= c.g;
    b -= c.b;
    a -= c.a;
    return *this;
}

D3DXINLINE D3DXCOLOR& 
D3DXCOLOR::operator *= ( float f )
{
    r *= f;
    g *= f;
    b *= f;
    a *= f;
    return *this;
}

D3DXINLINE D3DXCOLOR& 
D3DXCOLOR::operator /= ( float f )
{
    float fInv = 1.0f / f;
    r *= fInv;
    g *= fInv;
    b *= fInv;
    a *= fInv;
    return *this;
}


// unary operators
D3DXINLINE D3DXCOLOR 
D3DXCOLOR::operator + () const
{
    return *this;
}

D3DXINLINE D3DXCOLOR 
D3DXCOLOR::operator - () const
{
    return D3DXCOLOR(-r, -g, -b, -a);
}


// binary operators
D3DXINLINE D3DXCOLOR 
D3DXCOLOR::operator + ( const D3DXCOLOR& c ) const
{
    return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
}

D3DXINLINE D3DXCOLOR 
D3DXCOLOR::operator - ( const D3DXCOLOR& c ) const
{
    return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
}

D3DXINLINE D3DXCOLOR 
D3DXCOLOR::operator * ( float f ) const
{
    return D3DXCOLOR(r * f, g * f, b * f, a * f);
}

D3DXINLINE D3DXCOLOR 
D3DXCOLOR::operator / ( float f ) const
{
    float fInv = 1.0f / f;
    return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
}


D3DXINLINE D3DXCOLOR 
operator * (float f, const D3DXCOLOR& c )
{
    return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
}


D3DXINLINE BOOL 
D3DXCOLOR::operator == ( const D3DXCOLOR& c ) const
{
    return r == c.r && g == c.g && b == c.b && a == c.a;
}

D3DXINLINE BOOL 
D3DXCOLOR::operator != ( const D3DXCOLOR& c ) const
{
    return r != c.r || g != c.g || b != c.b || a != c.a;
}


#endif //__cplusplus



//===========================================================================
//
// Inline functions
//
//===========================================================================


//--------------------------
// 2D Vector
//--------------------------

D3DXINLINE float D3DXVec2Length
    ( const D3DXVECTOR2 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

#ifdef __cplusplus
    return sqrtf(pV->x * pV->x + pV->y * pV->y);
#else
    return (float) sqrt(pV->x * pV->x + pV->y * pV->y);
#endif 
}

D3DXINLINE float D3DXVec2LengthSq
    ( const D3DXVECTOR2 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

    return pV->x * pV->x + pV->y * pV->y;
}

D3DXINLINE float D3DXVec2Dot
    ( const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pV1 || !pV2)
        return 0.0f;
#endif

    return pV1->x * pV2->x + pV1->y * pV2->y;
}

D3DXINLINE float D3DXVec2CCW
    ( const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pV1 || !pV2)
        return 0.0f;
#endif

    return pV1->x * pV2->y - pV1->y * pV2->x;
}

D3DXINLINE D3DXVECTOR2* D3DXVec2Add
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + pV2->x;
    pOut->y = pV1->y + pV2->y;
    return pOut;
}

D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x - pV2->x;
    pOut->y = pV1->y - pV2->y;
    return pOut;
}

D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
    return pOut;
}

D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
    return pOut;
}

D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV, float s )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV)
        return NULL;
#endif

    pOut->x = pV->x * s;
    pOut->y = pV->y * s;
    return pOut;
}

D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2,
      float s )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + s * (pV2->x - pV1->x);
    pOut->y = pV1->y + s * (pV2->y - pV1->y);
    return pOut;
}


//--------------------------
// 3D Vector
//--------------------------

D3DXINLINE float D3DXVec3Length
    ( const D3DXVECTOR3 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

#ifdef __cplusplus
    return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
#else
    return (float) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
#endif
}

D3DXINLINE float D3DXVec3LengthSq
    ( const D3DXVECTOR3 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

    return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;
}

D3DXINLINE float D3DXVec3Dot
    ( const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pV1 || !pV2)
        return 0.0f;
#endif

    return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;
}

D3DXINLINE D3DXVECTOR3* D3DXVec3Cross
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 )
{
    D3DXVECTOR3 v;

#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    v.x = pV1->y * pV2->z - pV1->z * pV2->y;
    v.y = pV1->z * pV2->x - pV1->x * pV2->z;
    v.z = pV1->x * pV2->y - pV1->y * pV2->x;

    *pOut = v;
    return pOut;
}

D3DXINLINE D3DXVECTOR3* D3DXVec3Add
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + pV2->x;
    pOut->y = pV1->y + pV2->y;
    pOut->z = pV1->z + pV2->z;
    return pOut;
}

D3DXINLINE D3DXVECTOR3* D3DXVec3Subtract
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x - pV2->x;
    pOut->y = pV1->y - pV2->y;
    pOut->z = pV1->z - pV2->z;
    return pOut;
}

D3DXINLINE D3DXVECTOR3* D3DXVec3Minimize
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
    pOut->z = pV1->z < pV2->z ? pV1->z : pV2->z;
    return pOut;
}

D3DXINLINE D3DXVECTOR3* D3DXVec3Maximize
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
    pOut->z = pV1->z > pV2->z ? pV1->z : pV2->z;
    return pOut;
}

D3DXINLINE D3DXVECTOR3* D3DXVec3Scale
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, float s)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV)
        return NULL;
#endif

    pOut->x = pV->x * s;
    pOut->y = pV->y * s;
    pOut->z = pV->z * s;
    return pOut;
}

D3DXINLINE D3DXVECTOR3* D3DXVec3Lerp
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2,
      float s )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + s * (pV2->x - pV1->x);
    pOut->y = pV1->y + s * (pV2->y - pV1->y);
    pOut->z = pV1->z + s * (pV2->z - pV1->z);
    return pOut;
}


//--------------------------
// 4D Vector
//--------------------------

D3DXINLINE float D3DXVec4Length
    ( const D3DXVECTOR4 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

#ifdef __cplusplus
    return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z + pV->w * pV->w);
#else
    return (float) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z + pV->w * pV->w);
#endif
}

D3DXINLINE float D3DXVec4LengthSq
    ( const D3DXVECTOR4 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

    return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z + pV->w * pV->w;
}

D3DXINLINE float D3DXVec4Dot
    ( const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pV1 || !pV2)
        return 0.0f;
#endif

    return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z + pV1->w * pV2->w;
}

D3DXINLINE D3DXVECTOR4* D3DXVec4Add
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + pV2->x;
    pOut->y = pV1->y + pV2->y;
    pOut->z = pV1->z + pV2->z;
    pOut->w = pV1->w + pV2->w;
    return pOut;
}

D3DXINLINE D3DXVECTOR4* D3DXVec4Subtract
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x - pV2->x;
    pOut->y = pV1->y - pV2->y;
    pOut->z = pV1->z - pV2->z;
    pOut->w = pV1->w - pV2->w;
    return pOut;
}

D3DXINLINE D3DXVECTOR4* D3DXVec4Minimize
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
    pOut->z = pV1->z < pV2->z ? pV1->z : pV2->z;
    pOut->w = pV1->w < pV2->w ? pV1->w : pV2->w;
    return pOut;
}

D3DXINLINE D3DXVECTOR4* D3DXVec4Maximize
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
    pOut->z = pV1->z > pV2->z ? pV1->z : pV2->z;
    pOut->w = pV1->w > pV2->w ? pV1->w : pV2->w;
    return pOut;
}

D3DXINLINE D3DXVECTOR4* D3DXVec4Scale
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV, float s)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV)
        return NULL;
#endif

    pOut->x = pV->x * s;
    pOut->y = pV->y * s;
    pOut->z = pV->z * s;
    pOut->w = pV->w * s;
    return pOut;
}

D3DXINLINE D3DXVECTOR4* D3DXVec4Lerp
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2,
      float s )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + s * (pV2->x - pV1->x);
    pOut->y = pV1->y + s * (pV2->y - pV1->y);
    pOut->z = pV1->z + s * (pV2->z - pV1->z);
    pOut->w = pV1->w + s * (pV2->w - pV1->w);
    return pOut;
}


//--------------------------
// 4D Matrix
//--------------------------

D3DXINLINE D3DXMATRIX* D3DXMatrixIdentity
    ( D3DXMATRIX *pOut )
{
#ifdef D3DX_DEBUG
    if(!pOut)
        return NULL;
#endif

    pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] = 
    pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] = 
    pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] = 
    pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;

    pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;
    return pOut;
}


D3DXINLINE BOOL D3DXMatrixIsIdentity
    ( const D3DXMATRIX *pM )
{
#ifdef D3DX_DEBUG
    if(!pM)
        return FALSE;
#endif

    return pM->m[0][0] == 1.0f && pM->m[0][1] == 0.0f && pM->m[0][2] == 0.0f && pM->m[0][3] == 0.0f &&
           pM->m[1][0] == 0.0f && pM->m[1][1] == 1.0f && pM->m[1][2] == 0.0f && pM->m[1][3] == 0.0f &&
           pM->m[2][0] == 0.0f && pM->m[2][1] == 0.0f && pM->m[2][2] == 1.0f && pM->m[2][3] == 0.0f &&
           pM->m[3][0] == 0.0f && pM->m[3][1] == 0.0f && pM->m[3][2] == 0.0f && pM->m[3][3] == 1.0f;
}


//--------------------------
// Quaternion
//--------------------------

D3DXINLINE float D3DXQuaternionLength
    ( const D3DXQUATERNION *pQ )
{
#ifdef D3DX_DEBUG
    if(!pQ)
        return 0.0f;
#endif

#ifdef __cplusplus
    return sqrtf(pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z + pQ->w * pQ->w);
#else
    return (float) sqrt(pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z + pQ->w * pQ->w);
#endif
}

D3DXINLINE float D3DXQuaternionLengthSq
    ( const D3DXQUATERNION *pQ )
{
#ifdef D3DX_DEBUG
    if(!pQ)
        return 0.0f;
#endif

    return pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z + pQ->w * pQ->w;
}

D3DXINLINE float D3DXQuaternionDot
    ( const D3DXQUATERNION *pQ1, const D3DXQUATERNION *pQ2 )
{
#ifdef D3DX_DEBUG
    if(!pQ1 || !pQ2)
        return 0.0f;
#endif

    return pQ1->x * pQ2->x + pQ1->y * pQ2->y + pQ1->z * pQ2->z + pQ1->w * pQ2->w;
}


D3DXINLINE D3DXQUATERNION* D3DXQuaternionIdentity
    ( D3DXQUATERNION *pOut )
{
#ifdef D3DX_DEBUG
    if(!pOut)
        return NULL;
#endif

    pOut->x = pOut->y = pOut->z = 0.0f;
    pOut->w = 1.0f;
    return pOut;
}

D3DXINLINE BOOL D3DXQuaternionIsIdentity
    ( const D3DXQUATERNION *pQ )
{
#ifdef D3DX_DEBUG
    if(!pQ)
        return FALSE;
#endif

    return pQ->x == 0.0f && pQ->y == 0.0f && pQ->z == 0.0f && pQ->w == 1.0f;
}


D3DXINLINE D3DXQUATERNION* D3DXQuaternionConjugate
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pQ)
        return NULL;
#endif

    pOut->x = -pQ->x;
    pOut->y = -pQ->y;
    pOut->z = -pQ->z;
    pOut->w =  pQ->w;
    return pOut;
}


//--------------------------
// Plane
//--------------------------

D3DXINLINE float D3DXPlaneDot
    ( const D3DXPLANE *pP, const D3DXVECTOR4 *pV)
{
#ifdef D3DX_DEBUG
    if(!pP || !pV)
        return 0.0f;
#endif

    return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d * pV->w;
}

D3DXINLINE float D3DXPlaneDotCoord
    ( const D3DXPLANE *pP, const D3DXVECTOR3 *pV)
{
#ifdef D3DX_DEBUG
    if(!pP || !pV)
        return 0.0f;
#endif

    return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;
}

D3DXINLINE float D3DXPlaneDotNormal
    ( const D3DXPLANE *pP, const D3DXVECTOR3 *pV)
{
#ifdef D3DX_DEBUG
    if(!pP || !pV)
        return 0.0f;
#endif

    return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z;
}


//--------------------------
// Color
//--------------------------

D3DXINLINE D3DXCOLOR* D3DXColorNegative
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC)
        return NULL;
#endif

    pOut->r = 1.0f - pC->r;
    pOut->g = 1.0f - pC->g;
    pOut->b = 1.0f - pC->b;
    pOut->a = pC->a;
    return pOut;
}

D3DXINLINE D3DXCOLOR* D3DXColorAdd        
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC1, const D3DXCOLOR *pC2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC1 || !pC2)
        return NULL;
#endif

    pOut->r = pC1->r + pC2->r;
    pOut->g = pC1->g + pC2->g;
    pOut->b = pC1->b + pC2->b;
    pOut->a = pC1->a + pC2->a;
    return pOut;
}

D3DXINLINE D3DXCOLOR* D3DXColorSubtract   
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC1, const D3DXCOLOR *pC2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC1 || !pC2)
        return NULL;
#endif

    pOut->r = pC1->r - pC2->r;
    pOut->g = pC1->g - pC2->g;
    pOut->b = pC1->b - pC2->b;
    pOut->a = pC1->a - pC2->a;
    return pOut;
}

D3DXINLINE D3DXCOLOR* D3DXColorScale      
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC, float s)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC)
        return NULL;
#endif

    pOut->r = pC->r * s;
    pOut->g = pC->g * s;
    pOut->b = pC->b * s;
    pOut->a = pC->a * s;
    return pOut;
} 

D3DXINLINE D3DXCOLOR* D3DXColorModulate   
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC1, const D3DXCOLOR *pC2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC1 || !pC2)
        return NULL;
#endif

    pOut->r = pC1->r * pC2->r;
    pOut->g = pC1->g * pC2->g;
    pOut->b = pC1->b * pC2->b;
    pOut->a = pC1->a * pC2->a;
    return pOut;
}

D3DXINLINE D3DXCOLOR* D3DXColorLerp       
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC1, const D3DXCOLOR *pC2, float s)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC1 || !pC2)
        return NULL;
#endif

    pOut->r = pC1->r + s * (pC2->r - pC1->r);
    pOut->g = pC1->g + s * (pC2->g - pC1->g);
    pOut->b = pC1->b + s * (pC2->b - pC1->b);
    pOut->a = pC1->a + s * (pC2->a - pC1->a);
    return pOut;
}


#endif // __D3DXMATH_INL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dxg\obj\i386\d3d8caps.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3d8caps.h
 *  Content:    Direct3D capabilities include file
 *
 ***************************************************************************/

#ifndef _D3D8CAPS_H
#define _D3D8CAPS_H

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0800
#endif  //DIRECT3D_VERSION

#pragma pack(4)

typedef struct _D3DCAPS8
{
    /* Device Info */
    D3DDEVTYPE  DeviceType;
    UINT    AdapterOrdinal;

    /* Caps from DX7 Draw */
    DWORD   Caps;
    DWORD   Caps2;
    DWORD   Caps3;
    DWORD   PresentationIntervals;

    /* Cursor Caps */
    DWORD   CursorCaps;

    /* 3D Device Caps */
    DWORD   DevCaps;

    DWORD   PrimitiveMiscCaps;
    DWORD   RasterCaps;
    DWORD   ZCmpCaps;
    DWORD   SrcBlendCaps;
    DWORD   DestBlendCaps;
    DWORD   AlphaCmpCaps;
    DWORD   ShadeCaps;
    DWORD   TextureCaps;
    DWORD   TextureFilterCaps;          // D3DPTFILTERCAPS for IDirect3DTexture8's
    DWORD   CubeTextureFilterCaps;      // D3DPTFILTERCAPS for IDirect3DCubeTexture8's
    DWORD   VolumeTextureFilterCaps;    // D3DPTFILTERCAPS for IDirect3DVolumeTexture8's
    DWORD   TextureAddressCaps;         // D3DPTADDRESSCAPS for IDirect3DTexture8's
    DWORD   VolumeTextureAddressCaps;   // D3DPTADDRESSCAPS for IDirect3DVolumeTexture8's

    DWORD   LineCaps;                   // D3DLINECAPS

    DWORD   MaxTextureWidth, MaxTextureHeight;
    DWORD   MaxVolumeExtent;

    DWORD   MaxTextureRepeat;
    DWORD   MaxTextureAspectRatio;
    DWORD   MaxAnisotropy;
    float   MaxVertexW;

    float   GuardBandLeft;
    float   GuardBandTop;
    float   GuardBandRight;
    float   GuardBandBottom;

    float   ExtentsAdjust;
    DWORD   StencilCaps;

    DWORD   FVFCaps;
    DWORD   TextureOpCaps;
    DWORD   MaxTextureBlendStages;
    DWORD   MaxSimultaneousTextures;

    DWORD   VertexProcessingCaps;
    DWORD   MaxActiveLights;
    DWORD   MaxUserClipPlanes;
    DWORD   MaxVertexBlendMatrices;
    DWORD   MaxVertexBlendMatrixIndex;

    float   MaxPointSize;

    DWORD   MaxPrimitiveCount;          // max number of primitives per DrawPrimitive call
    DWORD   MaxVertexIndex;
    DWORD   MaxStreams;
    DWORD   MaxStreamStride;            // max stride for SetStreamSource

    DWORD   VertexShaderVersion;
    DWORD   MaxVertexShaderConst;       // number of vertex shader constant registers

    DWORD   PixelShaderVersion;
    float   MaxPixelShaderValue;        // max value of pixel shader arithmetic component

} D3DCAPS8;

//
// BIT DEFINES FOR D3DCAPS8 DWORD MEMBERS
//

//
// Caps
//
#define D3DCAPS_READ_SCANLINE           0x00020000L

//
// Caps2
//
#define D3DCAPS2_NO2DDURING3DSCENE      0x00000002L
#define D3DCAPS2_FULLSCREENGAMMA        0x00020000L
#define D3DCAPS2_CANRENDERWINDOWED      0x00080000L
#define D3DCAPS2_CANCALIBRATEGAMMA      0x00100000L
#define D3DCAPS2_RESERVED               0x02000000L

//
// Caps3
//
#define D3DCAPS3_RESERVED               0x8000001fL

//
// PresentationIntervals
//
#define D3DPRESENT_INTERVAL_DEFAULT             0x00000000L
#define D3DPRESENT_INTERVAL_ONE                 0x00000001L
#define D3DPRESENT_INTERVAL_TWO                 0x00000002L
#define D3DPRESENT_INTERVAL_THREE               0x00000004L
#define D3DPRESENT_INTERVAL_FOUR                0x00000008L
#define D3DPRESENT_INTERVAL_IMMEDIATE           0x80000000L
#define D3DPRESENT_INTERVAL_ONE_OR_IMMEDIATE    0x80000001L
#define D3DPRESENT_INTERVAL_TWO_OR_IMMEDIATE    0x80000002L

//
// CursorCaps
//
// Driver supports HW color cursor in at least hi-res modes(height >=400)
#define D3DCURSORCAPS_COLOR             0x00000001L
// Driver supports HW cursor also in low-res modes(height < 400)
#define D3DCURSORCAPS_LOWRES            0x00000002L

//
// DevCaps
//
#define D3DDEVCAPS_EXECUTESYSTEMMEMORY  0x00000010L /* Device can use execute buffers from system memory */
#define D3DDEVCAPS_EXECUTEVIDEOMEMORY   0x00000020L /* Device can use execute buffers from video memory */
#define D3DDEVCAPS_TLVERTEXSYSTEMMEMORY 0x00000040L /* Device can use TL buffers from system memory */
#define D3DDEVCAPS_TLVERTEXVIDEOMEMORY  0x00000080L /* Device can use TL buffers from video memory */
#define D3DDEVCAPS_TEXTURESYSTEMMEMORY  0x00000100L /* Device can texture from system memory */
#define D3DDEVCAPS_TEXTUREVIDEOMEMORY   0x00000200L /* Device can texture from device memory */
#define D3DDEVCAPS_DRAWPRIMTLVERTEX     0x00000400L /* Device can draw TLVERTEX primitives */
#define D3DDEVCAPS_CANRENDERAFTERFLIP   0x00000800L /* Device can render without waiting for flip to complete */
#define D3DDEVCAPS_TEXTURENONLOCALVIDMEM 0x00001000L /* Device can texture from nonlocal video memory */
#define D3DDEVCAPS_DRAWPRIMITIVES2      0x00002000L /* Device can support DrawPrimitives2 */
#define D3DDEVCAPS_SEPARATETEXTUREMEMORIES 0x00004000L /* Device is texturing from separate memory pools */
#define D3DDEVCAPS_DRAWPRIMITIVES2EX    0x00008000L /* Device can support Extended DrawPrimitives2 i.e. DX7 compliant driver*/
#define D3DDEVCAPS_HWTRANSFORMANDLIGHT  0x00010000L /* Device can support transformation and lighting in hardware and DRAWPRIMITIVES2EX must be also */
#define D3DDEVCAPS_CANBLTSYSTONONLOCAL  0x00020000L /* Device supports a Tex Blt from system memory to non-local vidmem */
#define D3DDEVCAPS_HWRASTERIZATION      0x00080000L /* Device has HW acceleration for rasterization */
#define D3DDEVCAPS_PUREDEVICE           0x00100000L /* Device supports D3DCREATE_PUREDEVICE */
#define D3DDEVCAPS_QUINTICRTPATCHES     0x00200000L /* Device supports quintic Beziers and BSplines */
#define D3DDEVCAPS_RTPATCHES            0x00400000L /* Device supports Rect and Tri patches */
#define D3DDEVCAPS_RTPATCHHANDLEZERO    0x00800000L /* Indicates that RT Patches may be drawn efficiently using handle 0 */
#define D3DDEVCAPS_NPATCHES             0x01000000L /* Device supports N-Patches */

//
// PrimitiveMiscCaps
//
#define D3DPMISCCAPS_MASKZ              0x00000002L
#define D3DPMISCCAPS_LINEPATTERNREP     0x00000004L
#define D3DPMISCCAPS_CULLNONE           0x00000010L
#define D3DPMISCCAPS_CULLCW             0x00000020L
#define D3DPMISCCAPS_CULLCCW            0x00000040L
#define D3DPMISCCAPS_COLORWRITEENABLE   0x00000080L
#define D3DPMISCCAPS_CLIPPLANESCALEDPOINTS 0x00000100L /* Device correctly clips scaled points to clip planes */
#define D3DPMISCCAPS_CLIPTLVERTS        0x00000200L /* device will clip post-transformed vertex primitives */
#define D3DPMISCCAPS_TSSARGTEMP         0x00000400L /* device supports D3DTA_TEMP for temporary register */
#define D3DPMISCCAPS_BLENDOP            0x00000800L /* device supports D3DRS_BLENDOP */

//
// LineCaps
//
#define D3DLINECAPS_TEXTURE             0x00000001L
#define D3DLINECAPS_ZTEST               0x00000002L
#define D3DLINECAPS_BLEND               0x00000004L
#define D3DLINECAPS_ALPHACMP            0x00000008L
#define D3DLINECAPS_FOG                 0x00000010L

//
// RasterCaps
//
#define D3DPRASTERCAPS_DITHER           0x00000001L
#define D3DPRASTERCAPS_ROP2             0x00000002L
#define D3DPRASTERCAPS_XOR              0x00000004L
#define D3DPRASTERCAPS_PAT              0x00000008L
#define D3DPRASTERCAPS_ZTEST            0x00000010L
#define D3DPRASTERCAPS_FOGVERTEX        0x00000080L
#define D3DPRASTERCAPS_FOGTABLE         0x00000100L
#define D3DPRASTERCAPS_ANTIALIASEDGES   0x00001000L
#define D3DPRASTERCAPS_MIPMAPLODBIAS    0x00002000L
#define D3DPRASTERCAPS_ZBIAS            0x00004000L
#define D3DPRASTERCAPS_ZBUFFERLESSHSR   0x00008000L
#define D3DPRASTERCAPS_FOGRANGE         0x00010000L
#define D3DPRASTERCAPS_ANISOTROPY       0x00020000L
#define D3DPRASTERCAPS_WBUFFER          0x00040000L
#define D3DPRASTERCAPS_WFOG             0x00100000L
#define D3DPRASTERCAPS_ZFOG             0x00200000L
#define D3DPRASTERCAPS_COLORPERSPECTIVE 0x00400000L /* Device iterates colors perspective correct */
#define D3DPRASTERCAPS_STRETCHBLTMULTISAMPLE  0x00800000L

//
// ZCmpCaps, AlphaCmpCaps
//
#define D3DPCMPCAPS_NEVER               0x00000001L
#define D3DPCMPCAPS_LESS                0x00000002L
#define D3DPCMPCAPS_EQUAL               0x00000004L
#define D3DPCMPCAPS_LESSEQUAL           0x00000008L
#define D3DPCMPCAPS_GREATER             0x00000010L
#define D3DPCMPCAPS_NOTEQUAL            0x00000020L
#define D3DPCMPCAPS_GREATEREQUAL        0x00000040L
#define D3DPCMPCAPS_ALWAYS              0x00000080L

//
// SourceBlendCaps, DestBlendCaps
//
#define D3DPBLENDCAPS_ZERO              0x00000001L
#define D3DPBLENDCAPS_ONE               0x00000002L
#define D3DPBLENDCAPS_SRCCOLOR          0x00000004L
#define D3DPBLENDCAPS_INVSRCCOLOR       0x00000008L
#define D3DPBLENDCAPS_SRCALPHA          0x00000010L
#define D3DPBLENDCAPS_INVSRCALPHA       0x00000020L
#define D3DPBLENDCAPS_DESTALPHA         0x00000040L
#define D3DPBLENDCAPS_INVDESTALPHA      0x00000080L
#define D3DPBLENDCAPS_DESTCOLOR         0x00000100L
#define D3DPBLENDCAPS_INVDESTCOLOR      0x00000200L
#define D3DPBLENDCAPS_SRCALPHASAT       0x00000400L
#define D3DPBLENDCAPS_BOTHSRCALPHA      0x00000800L
#define D3DPBLENDCAPS_BOTHINVSRCALPHA   0x00001000L

//
// ShadeCaps
//
#define D3DPSHADECAPS_COLORGOURAUDRGB       0x00000008L
#define D3DPSHADECAPS_SPECULARGOURAUDRGB    0x00000200L
#define D3DPSHADECAPS_ALPHAGOURAUDBLEND     0x00004000L
#define D3DPSHADECAPS_FOGGOURAUD            0x00080000L

//
// TextureCaps
//
#define D3DPTEXTURECAPS_PERSPECTIVE         0x00000001L /* Perspective-correct texturing is supported */
#define D3DPTEXTURECAPS_POW2                0x00000002L /* Power-of-2 texture dimensions are required - applies to non-Cube/Volume textures only. */
#define D3DPTEXTURECAPS_ALPHA               0x00000004L /* Alpha in texture pixels is supported */
#define D3DPTEXTURECAPS_SQUAREONLY          0x00000020L /* Only square textures are supported */
#define D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE 0x00000040L /* Texture indices are not scaled by the texture size prior to interpolation */
#define D3DPTEXTURECAPS_ALPHAPALETTE        0x00000080L /* Device can draw alpha from texture palettes */
// Device can use non-POW2 textures if:
//  1) D3DTEXTURE_ADDRESS is set to CLAMP for this texture's stage
//  2) D3DRS_WRAP(N) is zero for this texture's coordinates
//  3) mip mapping is not enabled (use magnification filter only)
#define D3DPTEXTURECAPS_NONPOW2CONDITIONAL  0x00000100L
#define D3DPTEXTURECAPS_PROJECTED           0x00000400L /* Device can do D3DTTFF_PROJECTED */
#define D3DPTEXTURECAPS_CUBEMAP             0x00000800L /* Device can do cubemap textures */
#define D3DPTEXTURECAPS_VOLUMEMAP           0x00002000L /* Device can do volume textures */
#define D3DPTEXTURECAPS_MIPMAP              0x00004000L /* Device can do mipmapped textures */
#define D3DPTEXTURECAPS_MIPVOLUMEMAP        0x00008000L /* Device can do mipmapped volume textures */
#define D3DPTEXTURECAPS_MIPCUBEMAP          0x00010000L /* Device can do mipmapped cube maps */
#define D3DPTEXTURECAPS_CUBEMAP_POW2        0x00020000L /* Device requires that cubemaps be power-of-2 dimension */
#define D3DPTEXTURECAPS_VOLUMEMAP_POW2      0x00040000L /* Device requires that volume maps be power-of-2 dimension */

//
// TextureFilterCaps
//
#define D3DPTFILTERCAPS_MINFPOINT           0x00000100L /* Min Filter */
#define D3DPTFILTERCAPS_MINFLINEAR          0x00000200L
#define D3DPTFILTERCAPS_MINFANISOTROPIC     0x00000400L
#define D3DPTFILTERCAPS_MIPFPOINT           0x00010000L /* Mip Filter */
#define D3DPTFILTERCAPS_MIPFLINEAR          0x00020000L
#define D3DPTFILTERCAPS_MAGFPOINT           0x01000000L /* Mag Filter */
#define D3DPTFILTERCAPS_MAGFLINEAR          0x02000000L
#define D3DPTFILTERCAPS_MAGFANISOTROPIC     0x04000000L
#define D3DPTFILTERCAPS_MAGFAFLATCUBIC      0x08000000L
#define D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC   0x10000000L

//
// TextureAddressCaps
//
#define D3DPTADDRESSCAPS_WRAP           0x00000001L
#define D3DPTADDRESSCAPS_MIRROR         0x00000002L
#define D3DPTADDRESSCAPS_CLAMP          0x00000004L
#define D3DPTADDRESSCAPS_BORDER         0x00000008L
#define D3DPTADDRESSCAPS_INDEPENDENTUV  0x00000010L
#define D3DPTADDRESSCAPS_MIRRORONCE     0x00000020L

//
// StencilCaps
//
#define D3DSTENCILCAPS_KEEP             0x00000001L
#define D3DSTENCILCAPS_ZERO             0x00000002L
#define D3DSTENCILCAPS_REPLACE          0x00000004L
#define D3DSTENCILCAPS_INCRSAT          0x00000008L
#define D3DSTENCILCAPS_DECRSAT          0x00000010L
#define D3DSTENCILCAPS_INVERT           0x00000020L
#define D3DSTENCILCAPS_INCR             0x00000040L
#define D3DSTENCILCAPS_DECR             0x00000080L

//
// TextureOpCaps
//
#define D3DTEXOPCAPS_DISABLE                    0x00000001L
#define D3DTEXOPCAPS_SELECTARG1                 0x00000002L
#define D3DTEXOPCAPS_SELECTARG2                 0x00000004L
#define D3DTEXOPCAPS_MODULATE                   0x00000008L
#define D3DTEXOPCAPS_MODULATE2X                 0x00000010L
#define D3DTEXOPCAPS_MODULATE4X                 0x00000020L
#define D3DTEXOPCAPS_ADD                        0x00000040L
#define D3DTEXOPCAPS_ADDSIGNED                  0x00000080L
#define D3DTEXOPCAPS_ADDSIGNED2X                0x00000100L
#define D3DTEXOPCAPS_SUBTRACT                   0x00000200L
#define D3DTEXOPCAPS_ADDSMOOTH                  0x00000400L
#define D3DTEXOPCAPS_BLENDDIFFUSEALPHA          0x00000800L
#define D3DTEXOPCAPS_BLENDTEXTUREALPHA          0x00001000L
#define D3DTEXOPCAPS_BLENDFACTORALPHA           0x00002000L
#define D3DTEXOPCAPS_BLENDTEXTUREALPHAPM        0x00004000L
#define D3DTEXOPCAPS_BLENDCURRENTALPHA          0x00008000L
#define D3DTEXOPCAPS_PREMODULATE                0x00010000L
#define D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR     0x00020000L
#define D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA     0x00040000L
#define D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR  0x00080000L
#define D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA  0x00100000L
#define D3DTEXOPCAPS_BUMPENVMAP                 0x00200000L
#define D3DTEXOPCAPS_BUMPENVMAPLUMINANCE        0x00400000L
#define D3DTEXOPCAPS_DOTPRODUCT3                0x00800000L
#define D3DTEXOPCAPS_MULTIPLYADD                0x01000000L
#define D3DTEXOPCAPS_LERP                       0x02000000L

//
// FVFCaps
//
#define D3DFVFCAPS_TEXCOORDCOUNTMASK    0x0000ffffL /* mask for texture coordinate count field */
#define D3DFVFCAPS_DONOTSTRIPELEMENTS   0x00080000L /* Device prefers that vertex elements not be stripped */
#define D3DFVFCAPS_PSIZE                0x00100000L /* Device can receive point size */

//
// VertexProcessingCaps
//
#define D3DVTXPCAPS_TEXGEN              0x00000001L /* device can do texgen */
#define D3DVTXPCAPS_MATERIALSOURCE7     0x00000002L /* device can do DX7-level colormaterialsource ops */
#define D3DVTXPCAPS_DIRECTIONALLIGHTS   0x00000008L /* device can do directional lights */
#define D3DVTXPCAPS_POSITIONALLIGHTS    0x00000010L /* device can do positional lights (includes point and spot) */
#define D3DVTXPCAPS_LOCALVIEWER         0x00000020L /* device can do local viewer */
#define D3DVTXPCAPS_TWEENING            0x00000040L /* device can do vertex tweening */
#define D3DVTXPCAPS_NO_VSDT_UBYTE4      0x00000080L /* device does not support D3DVSDT_UBYTE4 */

#pragma pack()

#endif /* _D3D8CAPS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dxg\obj\i386\d3d8perf.h ===
/*==========================================================================;
 *
 *  Copyright (C) 2000 - 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3d8perf.h
 *  Content:    Xbox Direct3D debug library API
 *
 ****************************************************************************/


#ifndef _D3D8PERF_H_
#define _D3D8PERF_H_

#ifdef __cplusplus
extern "C" {
#endif

/*
 * This file exposes the extra functionality implemented in the
 * performance-instrumented and debug version of the Direct3D library 
 * (d3d8i.lib and d3d8d.lib).
 */

// Enumeration of all of the non-api events that the driver counts.
typedef enum _D3DPERF_PerformanceCounters
{
    PERF_VERTICES,

    PERF_SETTRANSFORM_WORLD,
    PERF_SETTRANSFORM_VIEW,
    PERF_SETTRANSFORM_PROJECTION,
    PERF_SETTRANSFORM_TEXTURE,

    PERF_PUSHBUFFER_SEGMENTS,
    PERF_PUSHBUFFER_WAITS,
    PERF_OBJECTLOCK_WAITS,
    PERF_PRESENT_WAITS,
    PERF_D3DDEVICE_BLOCKUNTILIDLE_WAITS,
    PERF_D3DDEVICE_BLOCKUNTILVERTICALBLANK_WAITS,
    PERF_D3DDEVICE_BLOCKONFENCE_WAITS,
    PERF_CPUSPINDURINGWAIT_TIME,
    PERF_UNSWIZZLING_TEXTURE_LOCKS,
    PERF_PUSHBUFFER_JUMPTOBEGINNING,
    PERF_RUNPUSHBUFFER_BYTES,

    PERF_REDUNDANT_SETRENDERSTATE,
    PERF_REDUNDANT_SETTEXTURESTATE,
    PERF_REDUNDANT_SETVERTEXSHADER,
    PERF_REDUNDANT_SETTRANSFORM,
    PERF_REDUNDANT_SETTEXTURE,
    PERF_REDUNDANT_SETPALETTE,
    PERF_REDUNDANT_SETSTREAMSOURCE,

    PERF_SETSTATE_POINTPARAMS,
    PERF_SETSTATE_COMBINERS,
    PERF_SETSTATE_TEXTURESTATE,
    PERF_SETSTATE_SPECFOGCOMBINER,
    PERF_SETSTATE_TEXTRANSFORM,
    PERF_SETSTATE_LIGHTS,
    PERF_SETSTATE_TRANSFORM,

    D3DPERF_MAX,
    D3DPERF_FORCE_LONG  =   0xFFFFFFFF

} D3DPERF_PerformanceCounters;

// Counts of the number of times each API is called.
typedef enum _D3DPERF_APICounters
{

    /* Direct3D APIs */

    API_DIRECT3D_CHECKDEPTHSTENCILMATCH,
    API_DIRECT3D_CHECKDEVICEFORMAT,
    API_DIRECT3D_CHECKDEVICEMULTISAMPLETYPE,
    API_DIRECT3D_CHECKDEVICETYPE,
    API_DIRECT3D_CREATEDEVICE,
    API_DIRECT3D_ENUMADAPTERMODES,
    API_DIRECT3D_GETADAPTERDISPLAYMODE,
    API_DIRECT3D_GETADAPTERIDENTIFIER,
    API_DIRECT3D_GETADAPTERMODECOUNT,
    API_DIRECT3D_GETDEVICECAPS,
    API_DIRECT3D_SETPUSHBUFFERSIZE,

    /* D3DDevice APIs */

    API_D3DDEVICE_APPLYSTATEBLOCK,
    API_D3DDEVICE_BEGIN,
    API_D3DDEVICE_BEGINPUSH,
    API_D3DDEVICE_BEGINPUSHBUFFER,
    API_D3DDEVICE_BEGINSTATEBLOCK,
    API_D3DDEVICE_BEGINVISIBILITYTEST,
    API_D3DDEVICE_BLOCKONFENCE,
    API_D3DDEVICE_BLOCKUNTILIDLE,
    API_D3DDEVICE_BLOCKUNTILVERTICALBLANK,
    API_D3DDEVICE_CAPTURESTATEBLOCK,
    API_D3DDEVICE_CLEAR,
    API_D3DDEVICE_COPYRECTS,
    API_D3DDEVICE_CREATECUBETEXTURE,
    API_D3DDEVICE_CREATEDEPTHSTENCILSURFACE,
    API_D3DDEVICE_CREATEFIXUP,
    API_D3DDEVICE_CREATEIMAGESURFACE,
    API_D3DDEVICE_CREATEINDEXBUFFER,
    API_D3DDEVICE_CREATEPALETTE,
    API_D3DDEVICE_CREATEPIXELSHADER,
    API_D3DDEVICE_CREATEPUSHBUFFER,
    API_D3DDEVICE_CREATERENDERTARGET,
    API_D3DDEVICE_CREATESTATEBLOCK,
    API_D3DDEVICE_CREATETEXTURE,
    API_D3DDEVICE_CREATEVERTEXBUFFER,
    API_D3DDEVICE_CREATEVERTEXSHADER,
    API_D3DDEVICE_CREATEVOLUMETEXTURE,
    API_D3DDEVICE_DELETEPATCH,
    API_D3DDEVICE_DELETEPIXELSHADER,
    API_D3DDEVICE_DELETESTATEBLOCK,
    API_D3DDEVICE_DELETEVERTEXSHADER,
    API_D3DDEVICE_DRAWINDEXEDVERTICES,
    API_D3DDEVICE_DRAWINDEXEDVERTICESUP,
    API_D3DDEVICE_DRAWRECTPATCH,
    API_D3DDEVICE_DRAWTRIPATCH,
    API_D3DDEVICE_DRAWVERTICES,
    API_D3DDEVICE_DRAWVERTICESUP,
    API_D3DDEVICE_ENABLECC,
    API_D3DDEVICE_ENABLEOVERLAY,
    API_D3DDEVICE_END,
    API_D3DDEVICE_ENDPUSH,
    API_D3DDEVICE_ENDPUSHBUFFER,
    API_D3DDEVICE_ENDSTATEBLOCK,
    API_D3DDEVICE_ENDVISIBILITYTEST,
    API_D3DDEVICE_FLUSHVERTEXCACHE,
    API_D3DDEVICE_GETBACKBUFFER,
    API_D3DDEVICE_GETBACKBUFFERSCALE,
    API_D3DDEVICE_GETBACKMATERIAL,
    API_D3DDEVICE_GETCCSTATUS,
    API_D3DDEVICE_GETCREATIONPARAMETERS,
    API_D3DDEVICE_GETDEPTHSTENCILSURFACE,
    API_D3DDEVICE_GETDEVICECAPS,
    API_D3DDEVICE_GETDIRECT3D,
    API_D3DDEVICE_GETDISPLAYFIELDSTATUS,
    API_D3DDEVICE_GETDISPLAYMODE,
    API_D3DDEVICE_GETGAMMARAMP,
    API_D3DDEVICE_GETINDICES,
    API_D3DDEVICE_GETLIGHT,
    API_D3DDEVICE_GETLIGHTENABLE,
    API_D3DDEVICE_GETMATERIAL,
    API_D3DDEVICE_GETMODELVIEW,
    API_D3DDEVICE_GETOVERLAYUPDATESTATUS,
    API_D3DDEVICE_GETPALETTE,
    API_D3DDEVICE_GETPIXELSHADER,
    API_D3DDEVICE_GETPIXELSHADERCONSTANT,
    API_D3DDEVICE_GETPIXELSHADERFUNCTION,
    API_D3DDEVICE_GETPROJECTIONVIEWPORTMATRIX,
    API_D3DDEVICE_GETPUSHBUFFEROFFSET,
    API_D3DDEVICE_GETRASTERSTATUS,
    API_D3DDEVICE_GETRENDERSTATE,
    API_D3DDEVICE_GETRENDERTARGET,
    API_D3DDEVICE_GETSCISSORS,
    API_D3DDEVICE_GETSCREENSPACEOFFSET,
    API_D3DDEVICE_GETSHADERCONSTANTMODE,
    API_D3DDEVICE_GETSTREAMSOURCE,
    API_D3DDEVICE_GETTEXTURE,
    API_D3DDEVICE_GETTEXTURESTAGESTATE,
    API_D3DDEVICE_GETTILE,
    API_D3DDEVICE_GETTILECOMPRESSIONTAGS,
    API_D3DDEVICE_GETTRANSFORM,
    API_D3DDEVICE_GETVERTEXBLENDMODELVIEW,
    API_D3DDEVICE_GETVERTEXSHADER,
    API_D3DDEVICE_GETVERTEXSHADERCONSTANT,
    API_D3DDEVICE_GETVERTEXSHADERDECLARATION,
    API_D3DDEVICE_GETVERTEXSHADERFUNCTION,
    API_D3DDEVICE_GETVERTEXSHADERINPUT,
    API_D3DDEVICE_GETVERTEXSHADERSIZE,
    API_D3DDEVICE_GETVERTEXSHADERTYPE,
    API_D3DDEVICE_GETVIEWPORT,
    API_D3DDEVICE_GETVISIBILITYTESTRESULT,
    API_D3DDEVICE_INSERTCALLBACK,
    API_D3DDEVICE_INSERTFENCE,
    API_D3DDEVICE_ISBUSY,
    API_D3DDEVICE_ISFENCEPENDING,
    API_D3DDEVICE_KICKPUSHBUFFER,
    API_D3DDEVICE_LIGHTENABLE,
    API_D3DDEVICE_LOADVERTEXSHADER,
    API_D3DDEVICE_LOADVERTEXSHADERPROGRAM,
    API_D3DDEVICE_MULTIPLYTRANSFORM,
    API_D3DDEVICE_NOP,
    API_D3DDEVICE_PERSISTDISPLAY,
    API_D3DDEVICE_PRESENT,
    API_D3DDEVICE_PRIMEVERTEXCACHE,
    API_D3DDEVICE_READVERTEXSHADERCONSTANT,
    API_D3DDEVICE_RESET,
    API_D3DDEVICE_RESUME,
    API_D3DDEVICE_RUNPUSHBUFFER,
    API_D3DDEVICE_RUNVERTEXSTATESHADER,
    API_D3DDEVICE_SELECTVERTEXSHADER,
    API_D3DDEVICE_SENDCC,
    API_D3DDEVICE_SETBACKBUFFERSCALE,
    API_D3DDEVICE_SETBACKMATERIAL,
    API_D3DDEVICE_SETGAMMARAMP,
    API_D3DDEVICE_SETINDICES,
    API_D3DDEVICE_SETLIGHT,
    API_D3DDEVICE_SETMATERIAL,
    API_D3DDEVICE_SETMODELVIEW,
    API_D3DDEVICE_SETPALETTE,
    API_D3DDEVICE_SETPIXELSHADER,
    API_D3DDEVICE_SETPIXELSHADERCONSTANT,
    API_D3DDEVICE_SETPIXELSHADERPROGRAM,
    API_D3DDEVICE_SETRENDERSTATE_BACKFILLMODE,
    API_D3DDEVICE_SETRENDERSTATE_CULLMODE,
    API_D3DDEVICE_SETRENDERSTATE_DONOTCULLUNCOMPRESSED,
    API_D3DDEVICE_SETRENDERSTATE_DXT1NOISEENABLE,
    API_D3DDEVICE_SETRENDERSTATE_EDGEANTIALIAS,
    API_D3DDEVICE_SETRENDERSTATE_FILLMODE,
    API_D3DDEVICE_SETRENDERSTATE_FOGCOLOR,
    API_D3DDEVICE_SETRENDERSTATE_FRONTFACE,
    API_D3DDEVICE_SETRENDERSTATE_LINEWIDTH,
    API_D3DDEVICE_SETRENDERSTATE_LOGICOP,
    API_D3DDEVICE_SETRENDERSTATE_MULTISAMPLEANTIALIAS,
    API_D3DDEVICE_SETRENDERSTATE_MULTISAMPLEMASK,
    API_D3DDEVICE_SETRENDERSTATE_MULTISAMPLEMODE,
    API_D3DDEVICE_SETRENDERSTATE_MULTISAMPLERENDERTARGETMODE,
    API_D3DDEVICE_SETRENDERSTATE_NORMALIZENORMALS,
    API_D3DDEVICE_SETRENDERSTATE_OCCLUSIONCULLENABLE,
    API_D3DDEVICE_SETRENDERSTATE_PARAMETERCHECK,
    API_D3DDEVICE_SETRENDERSTATE_PSTEXTUREMODES,
    API_D3DDEVICE_SETRENDERSTATE_ROPZCMPALWAYSREAD,
    API_D3DDEVICE_SETRENDERSTATE_ROPZREAD,
    API_D3DDEVICE_SETRENDERSTATE_SHADOWFUNC,
    API_D3DDEVICE_SETRENDERSTATE_SIMPLE,
    API_D3DDEVICE_SETRENDERSTATE_STENCILCULLENABLE,
    API_D3DDEVICE_SETRENDERSTATE_STENCILENABLE,
    API_D3DDEVICE_SETRENDERSTATE_STENCILFAIL,
    API_D3DDEVICE_SETRENDERSTATE_TEXTUREFACTOR,
    API_D3DDEVICE_SETRENDERSTATE_TWOSIDEDLIGHTING,
    API_D3DDEVICE_SETRENDERSTATE_VERTEXBLEND,
    API_D3DDEVICE_SETRENDERSTATE_YUVENABLE,
    API_D3DDEVICE_SETRENDERSTATE_ZBIAS,
    API_D3DDEVICE_SETRENDERSTATE_ZENABLE,
    API_D3DDEVICE_SETRENDERSTATENOTINLINE,
    API_D3DDEVICE_SETRENDERTARGET,
    API_D3DDEVICE_SETSCISSORS,
    API_D3DDEVICE_SETSCREENSPACEOFFSET,
    API_D3DDEVICE_SETSHADERCONSTANTMODE,
    API_D3DDEVICE_SETSTREAMSOURCE,
    API_D3DDEVICE_SETSWAPCALLBACK,
    API_D3DDEVICE_SETTEXTURE,
    API_D3DDEVICE_SETTEXTURESTAGESTATENOTINLINE,
    API_D3DDEVICE_SETTEXTURESTATE_BORDERCOLOR,
    API_D3DDEVICE_SETTEXTURESTATE_BUMPENV,
    API_D3DDEVICE_SETTEXTURESTATE_COLORKEYCOLOR,
    API_D3DDEVICE_SETTEXTURESTATE_PARAMETERCHECK,
    API_D3DDEVICE_SETTEXTURESTATE_TEXCOORDINDEX,
    API_D3DDEVICE_SETTILE,
    API_D3DDEVICE_SETTRANSFORM,
    API_D3DDEVICE_SETVERTEXBLENDMODELVIEW,
    API_D3DDEVICE_SETVERTEXDATA2F,
    API_D3DDEVICE_SETVERTEXDATA2S,
    API_D3DDEVICE_SETVERTEXDATA4F,
    API_D3DDEVICE_SETVERTEXDATA4S,
    API_D3DDEVICE_SETVERTEXDATA4UB,
    API_D3DDEVICE_SETVERTEXDATACOLOR,
    API_D3DDEVICE_SETVERTEXSHADER,
    API_D3DDEVICE_SETVERTEXSHADERCONSTANT,
    API_D3DDEVICE_SETVERTEXSHADERINPUT,
    API_D3DDEVICE_SETVERTICALBLANKCALLBACK,
    API_D3DDEVICE_SETVIEWPORT,
    API_D3DDEVICE_SUSPEND,
    API_D3DDEVICE_SWITCHTEXTURE,
    API_D3DDEVICE_UPDATEOVERLAY,

    /* D3DResource APIs */

    API_D3DRESOURCE_ADDREF,
    API_D3DRESOURCE_BLOCKUNTILNOTBUSY,
    API_D3DRESOURCE_FREEPRIVATEDATA,
    API_D3DRESOURCE_GETDEVICE,
    API_D3DRESOURCE_GETPRIVATEDATA,
    API_D3DRESOURCE_GETTYPE,
    API_D3DRESOURCE_ISBUSY,
    API_D3DRESOURCE_REGISTER,
    API_D3DRESOURCE_RELEASE,
    API_D3DRESOURCE_SETPRIVATEDATA,

    /* D3DBaseTexture APIs */

    API_D3DBASETEXTURE_GETLEVELCOUNT,

    /* D3DTexture APIs */

    API_D3DTEXTURE_GETLEVELDESC,
    API_D3DTEXTURE_GETSURFACELEVEL,
    API_D3DTEXTURE_LOCKRECT,

    /* D3DCubeTexture APIs */

    API_D3DCUBETEXTURE_GETCUBEMAPSURFACE,
    API_D3DCUBETEXTURE_GETLEVELDESC,
    API_D3DCUBETEXTURE_LOCKRECT,

    /* D3DVolumeTexture APIs */

    API_D3DVOLUMETEXURE_GETLEVELDESC,
    API_D3DVOLUMETEXURE_GETVOLUMELEVEL,
    API_D3DVOLUMETEXURE_LOCKBOX,

    /* D3DVertexBuffer APIs */

    API_D3DVERTEXBUFFER_GETDESC,
    API_D3DVERTEXBUFFER_LOCK,

    /* D3DIndexBuffer APIs */

    API_D3DINDEXBUFFER_GETDESC,

    /* D3DVolume APIs */

    API_D3DVOLUME_GETCONTAINER,
    API_D3DVOLUME_GETDESC,
    API_D3DVOLUME_LOCKBOX,

    /* D3DSurface APIs */

    API_D3DSURFACE_GETCONTAINER,
    API_D3DSURFACE_GETDESC,
    API_D3DSURFACE_LOCKRECT,

    /* D3DPalette APIs */

    API_D3DPALETTE_GETSIZE,
    API_D3DPALETTE_LOCK,

    /* D3DPushBuffer APIs */

    API_D3DPUSHBUFFER_BEGINFIXUP,
    API_D3DPUSHBUFFER_ENDFIXUP,
    API_D3DPUSHBUFFER_ENDVISIBILITYTEST,
    API_D3DPUSHBUFFER_JUMP,
    API_D3DPUSHBUFFER_RUNPUSHBUFFER,
    API_D3DPUSHBUFFER_SETMODELVIEW,
    API_D3DPUSHBUFFER_SETPALETTE,
    API_D3DPUSHBUFFER_SETRENDERTARGET,
    API_D3DPUSHBUFFER_SETTEXTURE,
    API_D3DPUSHBUFFER_SETVERTEXBLENDMODELVIEW,
    API_D3DPUSHBUFFER_SETVERTEXSHADERCONSTANT,
    API_D3DPUSHBUFFER_SETVERTEXSHADERINPUT,
    API_D3DPUSHBUFFER_VERIFY,

    /* D3DFixup APIs */

    API_D3DFIXUP_GETSIZE,
    API_D3DFIXUP_GETSPACE,
    API_D3DFIXUP_RESET,

    D3DAPI_MAX,
    D3DAPI_FORCE_LONG  =   0xFFFFFFFF

} D3DPERF_APICounters;

// A structure that contains performance information gathered by
// the driver.
//
typedef struct _D3DWAITINFO
{
    DWORD Count;
    ULONGLONG Cycles;

} D3DWAITINFO;

// function callback declaration for cycle time threshold callback
//
typedef void (WINAPI *PFNCycleThresholdHandler)(D3DPERF_PerformanceCounters perfctr,
    ULONGLONG Cycles);

// function callback declaration for spewing framerate information
//
typedef void (WINAPI *PFNDumpFrameRateInfoHandler)(void);

// m_dwDumpFPSInfoMask flags which specify what data to display during default
// m_pfnDumpFrameRateInfoHandler callback. By default everything is enabled
// except D3DPERF_DUMP_FPS_PERFPROFILE which has a much higher overhead.
//
// To use set m_FrameRateIntervalTime to 10000 (10ms) or similar.
//
#define D3DPERF_DUMP_FPS_INTINFO        0x00000001  // interrupts & context switches
#define D3DPERF_DUMP_FPS_MEMORY         0x00000002  // memory info
#define D3DPERF_DUMP_FPS_PUSHBUFFER     0x00000004  // pushbuffer info
#define D3DPERF_DUMP_FPS_WAITINFO       0x00000008  // *_WAITS timings
#define D3DPERF_DUMP_FPS_PERFPROFILE    0x00000010  // 100ns timer which pings GPU to
                                                    // determine %busy/idle time.
#define D3DPERF_DUMP_FPS_VERTEXINFO     0x00000020  // vertex processing info
#define D3DPERF_DUMP_FPS_PERFEVENTS     0x00000040  // performance events info

// Structure which allows SetRenderState calls to be overriden. For example,
// set m_RenderStateOverrides[D3DRS_FILLMODE] = { TRUE, D3DFILL_WIREFRAME }
// to turn on wireframe mode.
//
typedef struct _D3DOVERRIDERENDERSTATE
{
    BOOL Override;
    DWORD Value;
} D3DOVERRIDERENDERSTATE;

// D3D profile busy/idle samples
//
typedef enum _D3DPERFPROF
{
    D3DPERF_PROF_GPU,
    D3DPERF_PROF_FE,
    D3DPERF_PROF_BE,
    D3DPERF_PROF_MAX
} D3DPERFPROF;

// D3D performance event types.
//
typedef enum _D3DPERFEventsType
{
    D3DPERFEvent_Header                 = 0,
    D3DPERFEvent_DrawVerticesUP         = 1,
    D3DPERFEvent_DrawIndexedVerticesUP  = 2,
    D3DPERFEvent_DrawVertices           = 3,
    D3DPERFEvent_DrawIndexedVertices    = 4,
    D3DPERFEvent_BeginEnd               = 5,
    D3DPERFEvent_RunPushBuffer          = 6,

    D3DPERFEvent_VBlank                 = 7,
    D3DPERFEvent_Kickoff                = 8,
    D3DPERFEvent_Present                = 9,

    D3DPERFEvent_BlockUntilIdle         = 10,
    D3DPERFEvent_BlockOnFence           = 11,
    D3DPERFEvent_PushBufferWait         = 12,
    D3DPERFEvent_ObjectLockWait         = 13,

    D3DPERFEvent_User0                  = 21,
    D3DPERFEvent_User1                  = 22,
    D3DPERFEvent_User2                  = 23,
    D3DPERFEvent_User3                  = 24,
    D3DPERFEvent_User4                  = 25,
    D3DPERFEvent_User5                  = 26,
    D3DPERFEvent_User6                  = 27,
    D3DPERFEvent_User7                  = 28,
    D3DPERFEvent_User8                  = 29,
    D3DPERFEvent_User9                  = 30,
    D3DPERFEvent_User10                 = 31,

    D3DPERFEvent_Max                    = 32,
} D3DPERFEventsType;

// D3D performance event structure.
// 
typedef struct _D3DPERFEvent
{
    WORD Type;                          // Event type. D3DPERFEventsType or
                                        // user defined event.
    union
    {
        char HeaderText[30];            // D3DPERFEvent_Header

        struct
        {
            WORD GpuPct;                // Pct fe/be gpu was busy since last sample.
                                        // 0xffff means there weren't enough samples.
            DWORD CpuPutPtr;            // cpu put ptr location at CycleCpuStart

            ULONGLONG CycleCpuStart;    // rdtsc for start of timing
            DWORD CycleCpuLength;       // cpu cycle length of timing block

            DWORD CycleGpuStartDelta;   // gpu start cycle delta from CycleCpuStart
            DWORD CycleGpuLength;       // total gpu processing time

            DWORD Data;                 // Event Data. Space event took in pushbuffer
                                        // or for RunPushBuffer size of pushbuffer.
        };
    };
} D3DPERFEvent;

// Structure that contains all of the performance information gathered by
// the driver.
//
typedef struct _D3DPERF
{
    // Time Stamp Counter value of last D3DPERF_Reset() call.
    ULONGLONG m_TSCLastResetVal;

    // Time Stamp Counter value of last Present() call
    ULONGLONG m_TSCLastPresentVal;

    // Max and Min Frame number (.Count) with cycle counts (.Cycles)
    D3DWAITINFO m_FrameTimeMin;
    D3DWAITINFO m_FrameTimeMax;

    // Issues debug break when perfctr and break number line up.
    DWORD m_BreakCount;
    D3DPERF_PerformanceCounters m_Breakperfctr;

    // Pushbuffer location at D3DPERF_Reset call
    DWORD *m_pPutLocationAtReset;

    // Count of dwords skipped jumping back to pushbuffer start
    ULONGLONG m_PushBufferEndDwordsSkipped;

    // Interval time to dump framerate information in milliseconds
    DWORD m_FrameRateIntervalTime;
    // Mask which controls what information D3DPERF_DumpFrameRateInfo
    // (default m_pfnDumpFrameRateInfoHandler handler) spits out.
    DWORD m_dwDumpFPSInfoMask;
    PFNDumpFrameRateInfoHandler m_pfnDumpFrameRateInfoHandler;

    // Holds threshold cycle count for spewing wait times
    DWORD m_DumpWaitCycleTimesThreshold;
    // Handler function to call when threshold cycle count hit. This
    // function defaults to D3DPERF_DumpCounterCycleInfo which simply
    // dumps PERF_OBJECTLOCK_WAITS count and wait times.
    PFNCycleThresholdHandler m_pfnCycleThresholdHandler;

    // If true, the next D3DPERF_Reset call will go through
    // m_RenderStateOverrides and set any renderstates which have
    // the Override member set to true.
    BOOL m_SetRenderStateOverridesOnReset;

    // Profile data gathered when profile is started via D3DPERF_StartPerfProfile
    //  (also via m_dwDumpFPSInfoMask/m_DumpWaitCycleTimesThreshold)

    // Total number of profile samples read
    DWORD m_ProfileSamples;

    // Time profiler was started. Initialized in D3DPERF_StartPerfProfile.
    ULONGLONG m_TSCProfileStartTime;

    // Perf state bitmask history over last 10ms where it then wraps.
    // 0x2 means gpu (1 << D3DPERF_PROF_GPU) and (1 << D3DPERF_PROF_FE) were busy.
    // Cleared in D3DPERF_StartPerfProfile and D3DPERF_Reset calls.
    WORD m_ProfileData[105000];

    // Total busy counts for each unit read while profiler was enabled
    DWORD m_ProfileBusyCounts[D3DPERF_PROF_MAX];


    // Performance monitoring members.

    // Mask of performance events to record.
    // D3DPERF_PerfEventStart(WORD Type, ...) does the following:
    //   if((1 << Type) && !(g_PerfCounters.RecordD3DPerfEvents & (1 << Type)))
    //       return NULL;
    DWORD RecordD3DPerfEvents;

    // if SpewFrameCount != 0, D3DPERF_DumpPerfEvents will spew
    // Count frame(s) starting at present #D3DPerfEventSpewFrameStart
    // in pD3DPerfEvents.
    DWORD D3DPerfEventSpewFrameStart;
    DWORD D3DPerfEventSpewFrameCount;

    // Holds threshold cycle count for spewing perf times
    DWORD m_DumpPerfCycleTimesThresholdCpu;
    DWORD m_DumpPerfCycleTimesThresholdGpu;

    // The current open event in pD3DPerfEvents.
    DWORD CurrentD3DPerfEvent;
    // Count of elements in pD3DPerfEvents
    DWORD CountD3DPerfEvents;
    // Pointer to array of pD3DPerfEvents
    D3DPERFEvent *pD3DPerfEvents;


    // Values used to override any calls to SetRenderState.
    //
    D3DOVERRIDERENDERSTATE m_RenderStateOverrides[D3DRS_MAX];

    // The count of the number of times certain performance-related events
    // happen.  Use D3DPERF_PerformanceCounters to index into this array.
    //
    D3DWAITINFO m_PerformanceCounters[D3DPERF_MAX];

    // The count of the number of times each API is called.  Use
    // D3DPERF_APICounters to index into this array.
    //
    DWORD m_APICounters[D3DAPI_MAX];

    // The count of the number of times each render state is set.  Use
    // D3DRENDERSTATE to index into this array.
    //
    DWORD m_RenderStateCounters[D3DRS_MAX];

    // The count of the number of times each texture state is set.
    DWORD m_TextureStateCounters[D3DTSS_MAX];

} D3DPERF;

// Holds the name of an individual renderstate or texturestate.  You need
// to search through the array of these things to find the name for the
// state.
//
typedef struct _D3DSTATENAME
{
    DWORD m_State;
    char *m_Name;

} D3DSTATENAME;

// Holds the names for the different performance things gathered
// by the driver.
//
typedef struct _D3DPERFNAMES
{
    // Array of string of human-readable names for the above counters.
    char *m_PerformanceCounterNames[D3DPERF_MAX];

    // An array of human-readable names for the above counters.
    char *m_APICounterNames[D3DAPI_MAX];

    // Human-readable names for the renderstate counters.
    D3DSTATENAME m_RenderStateNames[D3DRS_MAX];

    // Human-readable names for the texture states.
    D3DSTATENAME m_TextureStateNames[D3DTSS_MAX];

} D3DPERFNAMES;

// Holds information on the pushbuffer and guesstimate on count of bytes
// written since last D3DPERF_Reset.
//
typedef struct _D3DPUSHBUFFERINFO
{
    DWORD PushBufferSize;
    DWORD PushSegmentSize;
    DWORD PushSegmentCount;

    DWORD *pPushBase;
    DWORD *pPushLimit;

    ULONGLONG PushBufferBytesWritten;

} D3DPUSHBUFFERINFO;


// Returns the performance structure which is statically allocated and should
// never be freed.
//
D3DPERF * WINAPI D3DPERF_GetStatistics();

// Returns an array of names which is statically allocated.
//
D3DPERFNAMES * WINAPI D3DPERF_GetNames();

// Returns information on the pushbuffer
//
void WINAPI D3DPERF_GetPushBufferInfo(D3DPUSHBUFFERINFO *pPushBufferInfo);

// Dumps current frame rate information.
//
void WINAPI D3DPERF_DumpFrameRateInfo();

// Reset all of the perf counters to zero.
//
void WINAPI D3DPERF_Reset();

// Trivial dumper of all statistics to the debug output.
//
void WINAPI D3DPERF_Dump();


// D3D Perf states
//
typedef enum _D3DPERFSTATETYPE
{
    D3DPERFSTATE_VTX_CACHE,     // 4KB pre-t&l cache
    D3DPERFSTATE_VTX_FILE,      // 24 entry post t&l cache
    D3DPERFSTATE_VTX_ALL,       // enable/disable all vtx states
} D3DPERFSTATETYPE;

// Set state routine which allows you to enable/disable
// the vertex cache and/or file. This can be useful to determine
// how well you're currently, or not, using vertex caching.
//
HRESULT WINAPI D3DPERF_SetState(D3DPERFSTATETYPE State, DWORD Value);

// GPU Profile control routines. Enabling the PerfProfiler starts
// profiler interrupt run every 100ns which checks the current busy/idle
// status of the gpu.
//
BOOL WINAPI D3DPERF_StartPerfProfile();
void WINAPI D3DPERF_StopPerfProfile();
void WINAPI D3DPERF_DumpPerfProfCounts();

// Routine to spew current list of performance monitoring events.
// Setting D3DPERF_DUMP_FPS_PERFEVENTS will cause D3DPERF_DumpFrameRateInfo to
// dump this information also. Looks something like:
//
//   Event                  CpuStart   CpuTime  GpuStart  GpuTime  CpuPut  Data Gpu%
//   Kickoff                       0      1683         0        0  113320      0
//      *** FrameMove ***
//   user0                    12705    106084   1900673   109887  113376   6176
//    DrawIndexedVertices     108691      6869   1947551    54773  115132   3924  90
//    DrawIndexedVertices     123267    278445   2216913  1471443  120420  86052
//
// FrameMove: is a user inserted header via D3DPERF_InsertPerfEventHeader
// user0: user event inserted via
//      D3DPERFEvent *pD3DPerfEvent = D3DPERF_PerfEventStart(D3DPERFEvent_User0, TRUE);
//      ...
//      D3DPERF_PerfEventEnd(pD3DPerfEvent, TRUE);
// CpuStart: cycle time of when event was start
// CpuTime: count of cycles cpu took for event
// GpuStart: cycle time of when gpu started working on event
// GpuTime: count of cycles gpu took for event
// CpuPut: where the CpuPut pushbuffer pointer was at start of event
// Gpu%: Gpu busy percentage since last event with more than 15 samples
//
void WINAPI D3DPERF_DumpPerfEvents();

/*
 * Helper routines to set up various d3dperf members to dump
 *  framerate information.
 */

// Sets a breakpoint on a specified performance counter number
//
__inline void WINAPI D3DPERF_SetBreakPerfCount(D3DPERF_PerformanceCounters perfctr,
    DWORD BreakCount)
{
    D3DPERF *pPerf = D3DPERF_GetStatistics();
    pPerf->m_Breakperfctr = perfctr;
    pPerf->m_BreakCount = BreakCount;
}

// Sets frame rate interval (in ms) to call D3DPERF_DumpFrameRateInfo()
//
__inline void WINAPI D3DPERF_SetShowFrameRateInterval(DWORD FrameRateIntervalTime)
{
    D3DPERF *pPerf = D3DPERF_GetStatistics();
    pPerf->m_FrameRateIntervalTime = FrameRateIntervalTime;
}

// Default handler for DumpWaitCycleTimesThreshold which just spews
// PERF_OBJECTLOCK_WAITS count and time
void WINAPI D3DPERF_DumpCounterCycleInfo(D3DPERF_PerformanceCounters perfctr,
    ULONGLONG Cycles);

// Sets threshold Cycle count and handler function for hitting wait time thresholds
__inline void WINAPI D3DPERF_SetWaitCycleTimeThreshold(
    PFNCycleThresholdHandler pfnCycleThresholdHandler,
    DWORD DumpWaitCycleTimesThreshold)
{
    D3DPERF *pPerf = D3DPERF_GetStatistics();
    pPerf->m_DumpWaitCycleTimesThreshold = DumpWaitCycleTimesThreshold;
    pPerf->m_pfnCycleThresholdHandler = pfnCycleThresholdHandler;
}

// D3DPERF_StartCountingPerfEvent
//
// This should only be done when the chip is idle as
// any outstanding requests to the gpu will try to write
// back to pPerf->pD3DPerfEvents.
//
__inline BOOL WINAPI D3DPERF_StartCountingPerfEvent(
    DWORD EventCount
    )
{
    D3DPERF *pPerf = D3DPERF_GetStatistics();

    // if we've got a count of events and it's not the same as last time
    if(EventCount && pPerf->CountD3DPerfEvents != EventCount)
    {
        // free old block, alloc new block
        free(pPerf->pD3DPerfEvents);

        pPerf->pD3DPerfEvents = (D3DPERFEvent *)malloc(sizeof(D3DPERFEvent) * EventCount);
        if(pPerf->pD3DPerfEvents)
            memset(pPerf->pD3DPerfEvents, 0, sizeof(D3DPERFEvent) * EventCount);
        else
            EventCount = 0;
    }

    pPerf->CurrentD3DPerfEvent = 0;                 // current entry in pD3DPerfEvents
    pPerf->CountD3DPerfEvents = EventCount;         // count of items in pD3DPerfEvents

    if(!pPerf->D3DPerfEventSpewFrameCount)
    {
        pPerf->D3DPerfEventSpewFrameStart = 2;      // by default just spew one frame
        pPerf->D3DPerfEventSpewFrameCount = 1;      // starting at the second present
    }

    // record mask (-1 is all)
    if(!pPerf->RecordD3DPerfEvents)
    {
        pPerf->RecordD3DPerfEvents =
            (1 << D3DPERFEvent_Header) |
            (1 << D3DPERFEvent_Present) |
            (1 << D3DPERFEvent_BlockUntilIdle) |
            (1 << D3DPERFEvent_BlockOnFence) |
            (1 << D3DPERFEvent_PushBufferWait) |
            (1 << D3DPERFEvent_ObjectLockWait) |
            (1 << D3DPERFEvent_User0) | (1 << D3DPERFEvent_User1) |
            (1 << D3DPERFEvent_User2) | (1 << D3DPERFEvent_User3) |
            (1 << D3DPERFEvent_User4) | (1 << D3DPERFEvent_User5) |
            (1 << D3DPERFEvent_User6) | (1 << D3DPERFEvent_User7) |
            (1 << D3DPERFEvent_User8) | (1 << D3DPERFEvent_User9) |
            (1 << D3DPERFEvent_User10);
    }

    return pPerf->RecordD3DPerfEvents;
}

// Insert a performance event header
//
__inline void WINAPI D3DPERF_InsertPerfEventHeader(
    char *szHeader
    )
{
    D3DPERF *pPerf = D3DPERF_GetStatistics();

    if(pPerf->CountD3DPerfEvents)
    {
        DWORD CurrentEvent =
            (InterlockedIncrement((PLONG)&pPerf->CurrentD3DPerfEvent) - 1) %
            pPerf->CountD3DPerfEvents;
        D3DPERFEvent *pD3DPerfEvent = &pPerf->pD3DPerfEvents[CurrentEvent];

        pD3DPerfEvent->Type = D3DPERFEvent_Header;

        strncpy(pD3DPerfEvent->HeaderText, szHeader, sizeof(pD3DPerfEvent->HeaderText));
        pD3DPerfEvent->HeaderText[sizeof(pD3DPerfEvent->HeaderText) - 1] = 0;
    }
}

// D3DPERF_PerfEventStart/End.
//
//  Insert a performance Event. Type should be from D3DPERFEvent_User0 to User10.
//  RecordGpuTime states whether you want to insert fences for counting gpu times.
//
//      D3DPERFEvent *pD3DPerfEvent = D3DPERF_PerfEventStart(D3DPERFEvent_User0, TRUE);
//      ...
//      D3DPERF_PerfEventEnd(pD3DPerfEvent, TRUE);
//
D3DPERFEvent * WINAPI D3DPERF_PerfEventStart(
    WORD Type, BOOL RecordGpuTime);

void WINAPI D3DPERF_PerfEventEnd(
    D3DPERFEvent *pD3DPerfEvent, BOOL RecordGpuTime);

// D3DPERF_BlockTimer / PERFEVENT_BLOCKTIMER
// 
// Convenient struct+macro for inserting user-defined perf events.
// Will time the period spanning the life of the object.
//
// Example usage:
//
//     void RenderScene()
//     {
//         PERFEVENT_BLOCKTIMER("RenderScene", TRUE); // do record GPU time
//
//         // BLOCK OF CODE TO BE TIMED
//     }
// -or-
//     void UpdateLogic()
//     {
//         PERFEVENT_BLOCKTIMER("UpdateLogic", FALSE); // don't record GPU time
//
//         // BLOCK OF CODE TO BE TIMED
//     }
//
#ifdef __cplusplus
struct D3DPERF_BlockTimer
{
    D3DPERFEvent *m_pD3DPerfEvent;
    BOOL          m_bRecordGpuTime;

    __forceinline D3DPERF_BlockTimer(char *pszHeaderString,
                                     BOOL  bRecordGpuTime,
                                     WORD  EventType = D3DPERFEvent_User0)
    {
        if(pszHeaderString) { D3DPERF_InsertPerfEventHeader(pszHeaderString); }
        m_bRecordGpuTime = bRecordGpuTime;
        m_pD3DPerfEvent = D3DPERF_PerfEventStart(EventType, m_bRecordGpuTime);
    }

    __forceinline ~D3DPERF_BlockTimer()
    {
        D3DPERF_PerfEventEnd(m_pD3DPerfEvent, m_bRecordGpuTime);
    }
};

#define PERFEVENT_BLOCKTIMER(x,y)    D3DPERF_BlockTimer _PerfEventTimer(x,y)
#endif __cplusplus

#ifdef __cplusplus
}
#endif

#endif _D3D8PERF_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dxg\obj\i386\d3dx8.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 - 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8.h
//  Content:    D3DX utility library
//
///////////////////////////////////////////////////////////////////////////

#ifndef __D3DX8_H__
#define __D3DX8_H__

#include <d3d8.h>
#include <limits.h>

#include <xobjbase.h>

#ifndef D3DXINLINE
#ifdef __cplusplus
#define D3DXINLINE inline
#else
#define D3DXINLINE _inline
#endif
#endif

#define D3DX_DEFAULT ULONG_MAX
#define D3DX_DEFAULT_FLOAT FLT_MAX

#include "d3dx8math.h"
#include "d3dx8core.h"
#include "d3dx8tex.h"
#include "d3dx8mesh.h"
#include "d3dx8shape.h"
#include "d3dx8effect.h"


#endif //__D3DX8_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dxg\obj\i386\d3d8types.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3d8types.h
 *  Content:    Xbox Direct3D types include file
 *
 ***************************************************************************/

#ifndef _D3D8TYPES_H_
#define _D3D8TYPES_H_

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0800
#endif  //DIRECT3D_VERSION

// include this file content only if compiling for DX8 interfaces
#if(DIRECT3D_VERSION >= 0x0800)

#include <float.h>

#pragma warning(disable:4201) // anonymous unions warning
#pragma pack(4)

// D3DCOLOR is equivalent to D3DFMT_A8R8G8B8
#ifndef D3DCOLOR_DEFINED
typedef DWORD D3DCOLOR;
#define D3DCOLOR_DEFINED
#endif

// maps unsigned 8 bits/channel to D3DCOLOR
#define D3DCOLOR_ARGB(a,r,g,b) \
    ((D3DCOLOR)((((a)&0xff)<<24)|(((r)&0xff)<<16)|(((g)&0xff)<<8)|((b)&0xff)))
#define D3DCOLOR_RGBA(r,g,b,a) D3DCOLOR_ARGB(a,r,g,b)
#define D3DCOLOR_XRGB(r,g,b)   D3DCOLOR_ARGB(0xff,r,g,b)

// maps floating point channels (0.f to 1.f range) to D3DCOLOR
#define D3DCOLOR_COLORVALUE(r,g,b,a) \
    D3DCOLOR_RGBA((DWORD)((r)*255.f),(DWORD)((g)*255.f),(DWORD)((b)*255.f),(DWORD)((a)*255.f))

#ifndef D3DVECTOR_DEFINED
typedef struct _D3DVECTOR {
    float x;
    float y;
    float z;
} D3DVECTOR;
#define D3DVECTOR_DEFINED
#endif
typedef struct _D3DVECTOR *LPD3DVECTOR;

#ifndef D3DCOLORVALUE_DEFINED
typedef struct _D3DCOLORVALUE {
    float r;
    float g;
    float b;
    float a;
} D3DCOLORVALUE;
#define D3DCOLORVALUE_DEFINED
#endif

#ifndef D3DRECT_DEFINED
typedef struct _D3DRECT {
    LONG x1;
    LONG y1;
    LONG x2;
    LONG y2;
} D3DRECT;
#define D3DRECT_DEFINED
#endif

#ifndef D3DMATRIX_DEFINED
typedef struct _D3DMATRIX {
    union {
        struct {
            float        _11, _12, _13, _14;
            float        _21, _22, _23, _24;
            float        _31, _32, _33, _34;
            float        _41, _42, _43, _44;

        };
        float m[4][4];
    };
} D3DMATRIX;
#define D3DMATRIX_DEFINED
#endif

typedef struct _D3DVIEWPORT8 {
    DWORD       X;
    DWORD       Y;            /* Viewport Top left */
    DWORD       Width;
    DWORD       Height;       /* Viewport Dimensions */
    float       MinZ;         /* Min/max of clip Volume */
    float       MaxZ;
} D3DVIEWPORT8;

typedef struct _D3DMATERIAL8 {
    D3DCOLORVALUE   Diffuse;        /* Diffuse color RGBA */
    D3DCOLORVALUE   Ambient;        /* Ambient color RGB */
    D3DCOLORVALUE   Specular;       /* Specular 'shininess' */
    D3DCOLORVALUE   Emissive;       /* Emissive color RGB */
    float           Power;          /* Sharpness if specular highlight */
} D3DMATERIAL8;

typedef enum _D3DLIGHTTYPE {
    D3DLIGHT_POINT          = 1,
    D3DLIGHT_SPOT           = 2,
    D3DLIGHT_DIRECTIONAL    = 3,
    D3DLIGHT_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
} D3DLIGHTTYPE;

typedef struct _D3DLIGHT8 {
    D3DLIGHTTYPE    Type;            /* Type of light source */
    D3DCOLORVALUE   Diffuse;         /* Diffuse color of light */
    D3DCOLORVALUE   Specular;        /* Specular color of light */
    D3DCOLORVALUE   Ambient;         /* Ambient color of light */
    D3DVECTOR       Position;         /* Position in world space */
    D3DVECTOR       Direction;        /* Direction in world space */
    float           Range;            /* Cutoff range */
    float           Falloff;          /* Falloff */
    float           Attenuation0;     /* Constant attenuation */
    float           Attenuation1;     /* Linear attenuation */
    float           Attenuation2;     /* Quadratic attenuation */
    float           Theta;            /* Inner angle of spotlight cone */
    float           Phi;              /* Outer angle of spotlight cone */
} D3DLIGHT8;

/*
 * Options for clearing
 */
#define D3DCLEAR_TARGET            0x000000f0l  /* Clear target surface */
#define D3DCLEAR_ZBUFFER           0x00000001l  /* Clear target z buffer */
#define D3DCLEAR_STENCIL           0x00000002l  /* Clear stencil planes */

// The following are Xbox extensions
#define D3DCLEAR_TARGET_R          0x00000010l  /* Clear target surface R component */
#define D3DCLEAR_TARGET_G          0x00000020l  /* Clear target surface G component */
#define D3DCLEAR_TARGET_B          0x00000040l  /* Clear target surface B component */
#define D3DCLEAR_TARGET_A          0x00000080l  /* Clear target surface A component */

// The driver uses these values as the maximum value for Z in the z-buffer.

#define D3DZ_MAX_D16         65535.0
#define D3DZ_MAX_D24S8       16777215.0
#define D3DZ_MAX_F16         511.9375   

// We can't use the whole available range for the 24-bit floating point z
// because the maximum value is very, very close to the IEEE single 
// precision maximum.  Any calculation using the value will cause an overflow.
//
// Back off a bit from the max (3.4028e38),
//
#define D3DZ_MAX_F24S8       1.0e30

/*
 * The following defines the rendering states
 */

typedef enum _D3DSHADEMODE {
    D3DSHADE_FLAT               = 0x1d00,
    D3DSHADE_GOURAUD            = 0x1d01,
    D3DSHADE_FORCE_DWORD        = 0x7fffffff, /* force 32-bit size enum */
} D3DSHADEMODE;


typedef enum _D3DFILLMODE {
    D3DFILL_POINT               = 0x1b00,
    D3DFILL_WIREFRAME           = 0x1b01,
    D3DFILL_SOLID               = 0x1b02,
    D3DFILL_FORCE_DWORD         = 0x7fffffff, /* force 32-bit size enum */
} D3DFILLMODE;

typedef enum _D3DBLEND {
    D3DBLEND_ZERO               = 0,
    D3DBLEND_ONE                = 1,
    D3DBLEND_SRCCOLOR           = 0x300,
    D3DBLEND_INVSRCCOLOR        = 0x301,
    D3DBLEND_SRCALPHA           = 0x302,
    D3DBLEND_INVSRCALPHA        = 0x303,
    D3DBLEND_DESTALPHA          = 0x304,
    D3DBLEND_INVDESTALPHA       = 0x305,
    D3DBLEND_DESTCOLOR          = 0x306,
    D3DBLEND_INVDESTCOLOR       = 0x307,
    D3DBLEND_SRCALPHASAT        = 0x308,
    D3DBLEND_CONSTANTCOLOR      = 0x8001,
    D3DBLEND_INVCONSTANTCOLOR   = 0x8002,
    D3DBLEND_CONSTANTALPHA      = 0x8003,
    D3DBLEND_INVCONSTANTALPHA   = 0x8004,

    // D3DBLEND_BOTHSRCALPHA not supported on Xbox
    // D3DBLEND_BOTHINVSRCALPHA not supported on Xbox

    D3DBLEND_FORCE_DWORD        = 0x7fffffff, /* force 32-bit size enum */
} D3DBLEND;

typedef enum _D3DBLENDOP {
    D3DBLENDOP_ADD              = 0x8006,
    D3DBLENDOP_SUBTRACT         = 0x800a,
    D3DBLENDOP_REVSUBTRACT      = 0x800b,
    D3DBLENDOP_MIN              = 0x8007,
    D3DBLENDOP_MAX              = 0x8008,
    D3DBLENDOP_ADDSIGNED        = 0xf006,       // Xbox extension
    D3DBLENDOP_REVSUBTRACTSIGNED= 0xf005,       // Xbox extension
    D3DBLENDOP_FORCE_DWORD      = 0x7fffffff, /* force 32-bit size enum */
} D3DBLENDOP;

typedef enum _D3DTEXTUREADDRESS {
    D3DTADDRESS_WRAP            = 1,
    D3DTADDRESS_MIRROR          = 2,
    D3DTADDRESS_CLAMP           = 3,
    D3DTADDRESS_BORDER          = 4,
    D3DTADDRESS_CLAMPTOEDGE     = 5, // Xbox extension

    // D3DTADDRESS_MIRRORONCE not supported on Xbox

    D3DTADDRESS_MAX             = 6,
    D3DTADDRESS_FORCE_DWORD     = 0x7fffffff, /* force 32-bit size enum */
} D3DTEXTUREADDRESS;

typedef enum _D3DTEXTURECOLORKEYOP {            // Xbox extension
    D3DTCOLORKEYOP_DISABLE      = 0,
    D3DTCOLORKEYOP_ALPHA        = 1,
    D3DTCOLORKEYOP_RGBA         = 2,
    D3DTCOLORKEYOP_KILL         = 3,

    D3DTCOLORKEYOP_MAX          = 4,
    D3DTCOLORKEYOP_FORCE_DWORD  = 0x7fffffff, /* force 32-bit size enum */
} D3DTEXTURECOLORKEYOP;

typedef enum _D3DTEXTUREALPHAKILL {             // Xbox extension
    D3DTALPHAKILL_DISABLE       = 0,
    D3DTALPHAKILL_ENABLE        = 4,

    D3DTALPHAKILL_FORCE_DWORD   = 0x7fffffff, /* force 32-bit size enum */
} D3DTEXTUREALPHAKILL;

typedef enum _D3DCULL {
    D3DCULL_NONE                = 0,
    D3DCULL_CW                  = 0x900,
    D3DCULL_CCW                 = 0x901,
    D3DCULL_FORCE_DWORD         = 0x7fffffff, /* force 32-bit size enum */
} D3DCULL;

typedef enum _D3DFRONT {                        // Xbox extension
    D3DFRONT_CW                 = 0x900,
    D3DFRONT_CCW                = 0x901,
    D3DFRONT_FORCE_DWORD        = 0x7fffffff, /* force 32-bit size enum */
} D3DFRONT;

typedef enum _D3DCMPFUNC {
    D3DCMP_NEVER                = 0x200,
    D3DCMP_LESS                 = 0x201,
    D3DCMP_EQUAL                = 0x202,
    D3DCMP_LESSEQUAL            = 0x203,
    D3DCMP_GREATER              = 0x204,
    D3DCMP_NOTEQUAL             = 0x205,
    D3DCMP_GREATEREQUAL         = 0x206,
    D3DCMP_ALWAYS               = 0x207,
    D3DCMP_FORCE_DWORD          = 0x7fffffff, /* force 32-bit size enum */
} D3DCMPFUNC;

typedef enum _D3DSTENCILOP {
    D3DSTENCILOP_KEEP           = 0x1e00,
    D3DSTENCILOP_ZERO           = 0,
    D3DSTENCILOP_REPLACE        = 0x1e01,
    D3DSTENCILOP_INCRSAT        = 0x1e02,
    D3DSTENCILOP_DECRSAT        = 0x1e03,
    D3DSTENCILOP_INVERT         = 0x150a,
    D3DSTENCILOP_INCR           = 0x8507,
    D3DSTENCILOP_DECR           = 0x8508,
    D3DSTENCILOP_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
} D3DSTENCILOP;

typedef enum _D3DFOGMODE {
    D3DFOG_NONE                 = 0,
    D3DFOG_EXP                  = 1,
    D3DFOG_EXP2                 = 2,
    D3DFOG_LINEAR               = 3,
    D3DFOG_FORCE_DWORD          = 0x7fffffff, /* force 32-bit size enum */
} D3DFOGMODE;

typedef enum _D3DSWATHWIDTH {                   // Xbox extension
    D3DSWATH_8                  = 0,
    D3DSWATH_16                 = 1,
    D3DSWATH_32                 = 2,
    D3DSWATH_64                 = 3,
    D3DSWATH_128                = 4,
    D3DSWATH_OFF                = 0xf,
    D3DSWATH_FORCE_DWORD        = 0x7fffffff, /* force 32-bit size enum */
} D3DSWATHWIDTH;

typedef enum _D3DPALETTESIZE {                  // Xbox extension
    D3DPALETTE_256              = 0,
    D3DPALETTE_128              = 1,
    D3DPALETTE_64               = 2,
    D3DPALETTE_32               = 3,

    D3DPALETTE_MAX              = 4,
    D3DPALETTE_FORCE_DWORD      = 0x7fffffff, /* force 32-bit size enum */
} D3DPALETTESIZE;

typedef DWORD D3DSHADERCONSTANTMODE;            // Xbox extension

#define D3DSCM_96CONSTANTS                  0
#define D3DSCM_192CONSTANTS                 1
#define D3DSCM_192CONSTANTSANDFIXEDPIPELINE 2
#define D3DSCM_NORESERVEDCONSTANTS          0x10    // Flag

typedef enum _D3DLOGICOP {                      // Xbox extension
    D3DLOGICOP_NONE             = 0,
    D3DLOGICOP_CLEAR            = 0x1500,
    D3DLOGICOP_AND              = 0x1501,
    D3DLOGICOP_AND_REVERSE      = 0x1502,
    D3DLOGICOP_COPY             = 0x1503,
    D3DLOGICOP_AND_INVERTED     = 0x1504,
    D3DLOGICOP_NOOP             = 0x1505,
    D3DLOGICOP_XOR              = 0x1506,
    D3DLOGICOP_OR               = 0x1507,
    D3DLOGICOP_NOR              = 0x1508,
    D3DLOGICOP_EQUIV            = 0x1509,
    D3DLOGICOP_INVERT           = 0x150a,
    D3DLOGICOP_OR_REVERSE       = 0x150b,
    D3DLOGICOP_COPY_INVERTED    = 0x150c,
    D3DLOGICOP_OR_INVERTED      = 0x150d,
    D3DLOGICOP_NAND             = 0x150e,
    D3DLOGICOP_SET              = 0x150f,
    D3DLOGICOP_FORCE_DWORD      = 0x7fffffff, /* force 32-bit size enum */
} D3DLOGICOP;

typedef enum _D3DZBUFFERTYPE {
    D3DZB_FALSE                 = 0,
    D3DZB_TRUE                  = 1, // Z buffering
    D3DZB_USEW                  = 2, // W buffering
    D3DZB_FORCE_DWORD           = 0x7fffffff, /* force 32-bit size enum */
} D3DZBUFFERTYPE;

// Primitives supported by draw-primitive API
typedef enum _D3DPRIMITIVETYPE {
    D3DPT_POINTLIST             = 1,
    D3DPT_LINELIST              = 2,
    D3DPT_LINELOOP              = 3,  // Xbox extension
    D3DPT_LINESTRIP             = 4,
    D3DPT_TRIANGLELIST          = 5,
    D3DPT_TRIANGLESTRIP         = 6,
    D3DPT_TRIANGLEFAN           = 7,
    D3DPT_QUADLIST              = 8,  // Xbox extension
    D3DPT_QUADSTRIP             = 9,  // Xbox extension
    D3DPT_POLYGON               = 10, // Xbox extension

    D3DPT_MAX                   = 11,
    D3DPT_FORCE_DWORD           = 0x7fffffff, /* force 32-bit size enum */
} D3DPRIMITIVETYPE;

typedef enum _D3DTRANSFORMSTATETYPE {
    D3DTS_VIEW          = 0,
    D3DTS_PROJECTION    = 1,
    D3DTS_TEXTURE0      = 2,
    D3DTS_TEXTURE1      = 3,
    D3DTS_TEXTURE2      = 4,
    D3DTS_TEXTURE3      = 5,
    D3DTS_WORLD         = 6,
    D3DTS_WORLD1        = 7,
    D3DTS_WORLD2        = 8,
    D3DTS_WORLD3        = 9,

    D3DTS_MAX           = 10,
    D3DTS_FORCE_DWORD   = 0x7fffffff, /* force 32-bit size enum */
} D3DTRANSFORMSTATETYPE;

#define D3DTS_WORLDMATRIX(index) (D3DTRANSFORMSTATETYPE)(index + D3DTS_WORLD)

typedef enum _D3DRENDERSTATETYPE {

    // Simple render states that are processed by D3D immediately:

    D3DRS_PS_MIN                        = 0,

    // The following pixel-shader renderstates are all Xbox extensions:

    D3DRS_PSALPHAINPUTS0                = 0,   // Pixel shader, Stage 0 alpha inputs                         
    D3DRS_PSALPHAINPUTS1                = 1,   // Pixel shader, Stage 1 alpha inputs                         
    D3DRS_PSALPHAINPUTS2                = 2,   // Pixel shader, Stage 2 alpha inputs                         
    D3DRS_PSALPHAINPUTS3                = 3,   // Pixel shader, Stage 3 alpha inputs                         
    D3DRS_PSALPHAINPUTS4                = 4,   // Pixel shader, Stage 4 alpha inputs                         
    D3DRS_PSALPHAINPUTS5                = 5,   // Pixel shader, Stage 5 alpha inputs                         
    D3DRS_PSALPHAINPUTS6                = 6,   // Pixel shader, Stage 6 alpha inputs                         
    D3DRS_PSALPHAINPUTS7                = 7,   // Pixel shader, Stage 7 alpha inputs                         
    D3DRS_PSFINALCOMBINERINPUTSABCD     = 8,   // Pixel shader, Final combiner inputs ABCD
    D3DRS_PSFINALCOMBINERINPUTSEFG      = 9,   // Pixel shader, Final combiner inputs EFG
    D3DRS_PSCONSTANT0_0                 = 10,  // Pixel shader, C0 in stage 0
    D3DRS_PSCONSTANT0_1                 = 11,  // Pixel shader, C0 in stage 1
    D3DRS_PSCONSTANT0_2                 = 12,  // Pixel shader, C0 in stage 2
    D3DRS_PSCONSTANT0_3                 = 13,  // Pixel shader, C0 in stage 3
    D3DRS_PSCONSTANT0_4                 = 14,  // Pixel shader, C0 in stage 4
    D3DRS_PSCONSTANT0_5                 = 15,  // Pixel shader, C0 in stage 5
    D3DRS_PSCONSTANT0_6                 = 16,  // Pixel shader, C0 in stage 6
    D3DRS_PSCONSTANT0_7                 = 17,  // Pixel shader, C0 in stage 7
    D3DRS_PSCONSTANT1_0                 = 18,  // Pixel shader, C1 in stage 0
    D3DRS_PSCONSTANT1_1                 = 19,  // Pixel shader, C1 in stage 1
    D3DRS_PSCONSTANT1_2                 = 20,  // Pixel shader, C1 in stage 2
    D3DRS_PSCONSTANT1_3                 = 21,  // Pixel shader, C1 in stage 3
    D3DRS_PSCONSTANT1_4                 = 22,  // Pixel shader, C1 in stage 4
    D3DRS_PSCONSTANT1_5                 = 23,  // Pixel shader, C1 in stage 5
    D3DRS_PSCONSTANT1_6                 = 24,  // Pixel shader, C1 in stage 6
    D3DRS_PSCONSTANT1_7                 = 25,  // Pixel shader, C1 in stage 7
    D3DRS_PSALPHAOUTPUTS0               = 26,  // Pixel shader, Stage 0 alpha outputs                        
    D3DRS_PSALPHAOUTPUTS1               = 27,  // Pixel shader, Stage 1 alpha outputs                        
    D3DRS_PSALPHAOUTPUTS2               = 28,  // Pixel shader, Stage 2 alpha outputs                        
    D3DRS_PSALPHAOUTPUTS3               = 29,  // Pixel shader, Stage 3 alpha outputs                        
    D3DRS_PSALPHAOUTPUTS4               = 30,  // Pixel shader, Stage 4 alpha outputs                        
    D3DRS_PSALPHAOUTPUTS5               = 31,  // Pixel shader, Stage 5 alpha outputs                        
    D3DRS_PSALPHAOUTPUTS6               = 32,  // Pixel shader, Stage 6 alpha outputs                        
    D3DRS_PSALPHAOUTPUTS7               = 33,  // Pixel shader, Stage 7 alpha outputs                        
    D3DRS_PSRGBINPUTS0                  = 34,  // Pixel shader, Stage 0 RGB inputs                           
    D3DRS_PSRGBINPUTS1                  = 35,  // Pixel shader, Stage 1 RGB inputs                           
    D3DRS_PSRGBINPUTS2                  = 36,  // Pixel shader, Stage 2 RGB inputs                           
    D3DRS_PSRGBINPUTS3                  = 37,  // Pixel shader, Stage 3 RGB inputs                           
    D3DRS_PSRGBINPUTS4                  = 38,  // Pixel shader, Stage 4 RGB inputs                           
    D3DRS_PSRGBINPUTS5                  = 39,  // Pixel shader, Stage 5 RGB inputs                           
    D3DRS_PSRGBINPUTS6                  = 40,  // Pixel shader, Stage 6 RGB inputs                           
    D3DRS_PSRGBINPUTS7                  = 41,  // Pixel shader, Stage 7 RGB inputs                           
    D3DRS_PSCOMPAREMODE                 = 42,  // Pixel shader, Compare modes for clipplane texture mode     
    D3DRS_PSFINALCOMBINERCONSTANT0      = 43,  // Pixel shader, C0 in final combiner
    D3DRS_PSFINALCOMBINERCONSTANT1      = 44,  // Pixel shader, C1 in final combiner
    D3DRS_PSRGBOUTPUTS0                 = 45,  // Pixel shader, Stage 0 RGB outputs                          
    D3DRS_PSRGBOUTPUTS1                 = 46,  // Pixel shader, Stage 1 RGB outputs                          
    D3DRS_PSRGBOUTPUTS2                 = 47,  // Pixel shader, Stage 2 RGB outputs                          
    D3DRS_PSRGBOUTPUTS3                 = 48,  // Pixel shader, Stage 3 RGB outputs                          
    D3DRS_PSRGBOUTPUTS4                 = 49,  // Pixel shader, Stage 4 RGB outputs                          
    D3DRS_PSRGBOUTPUTS5                 = 50,  // Pixel shader, Stage 5 RGB outputs                          
    D3DRS_PSRGBOUTPUTS6                 = 51,  // Pixel shader, Stage 6 RGB outputs                          
    D3DRS_PSRGBOUTPUTS7                 = 52,  // Pixel shader, Stage 7 RGB outputs                          
    D3DRS_PSCOMBINERCOUNT               = 53,  // Pixel shader, Active combiner count (Stages 0-7)           
                                               // Pixel shader, Reserved
    D3DRS_PSDOTMAPPING                  = 55,  // Pixel shader, Input mapping for dot product modes          
    D3DRS_PSINPUTTEXTURE                = 56,  // Pixel shader, Texture source for some texture modes        
                                        
    D3DRS_PS_MAX                        = 57,  
                                        
    D3DRS_ZFUNC                         = 57,  // D3DCMPFUNC 
    D3DRS_ALPHAFUNC                     = 58,  // D3DCMPFUNC 
    D3DRS_ALPHABLENDENABLE              = 59,  // TRUE to enable alpha blending 
    D3DRS_ALPHATESTENABLE               = 60,  // TRUE to enable alpha tests 
    D3DRS_ALPHAREF                      = 61,  // BYTE
    D3DRS_SRCBLEND                      = 62,  // D3DBLEND 
    D3DRS_DESTBLEND                     = 63,  // D3DBLEND 
    D3DRS_ZWRITEENABLE                  = 64,  // TRUE to enable Z writes 
    D3DRS_DITHERENABLE                  = 65,  // TRUE to enable dithering 
    D3DRS_SHADEMODE                     = 66,  // D3DSHADEMODE 
    D3DRS_COLORWRITEENABLE              = 67,  // D3DCOLORWRITEENABLE_ALPHA, etc. per-channel write enable
    D3DRS_STENCILZFAIL                  = 68,  // D3DSTENCILOP to do if stencil test passes and Z test fails 
    D3DRS_STENCILPASS                   = 69,  // D3DSTENCILOP to do if both stencil and Z tests pass 
    D3DRS_STENCILFUNC                   = 70,  // D3DCMPFUNC
    D3DRS_STENCILREF                    = 71,  // BYTE reference value used in stencil test 
    D3DRS_STENCILMASK                   = 72,  // BYTE mask value used in stencil test 
    D3DRS_STENCILWRITEMASK              = 73,  // BYTE write mask applied to values written to stencil buffer 
    D3DRS_BLENDOP                       = 74,  // D3DBLENDOP setting
    D3DRS_BLENDCOLOR                    = 75,  // D3DCOLOR for D3DBLEND_CONSTANT, etc. (Xbox extension)
    D3DRS_SWATHWIDTH                    = 76,  // D3DSWATHWIDTH (Xbox extension)
    D3DRS_POLYGONOFFSETZSLOPESCALE      = 77,  // float Z factor for shadow maps (Xbox extension)
    D3DRS_POLYGONOFFSETZOFFSET          = 78,  // float bias for polygon offset (Xbox extension)
    D3DRS_POINTOFFSETENABLE             = 79,  // TRUE to enable polygon offset for points (Xbox extension)
    D3DRS_WIREFRAMEOFFSETENABLE         = 80,  // TRUE to enable polygon offset for lines (Xbox extension)
    D3DRS_SOLIDOFFSETENABLE             = 81,  // TRUE to enable polygon offset for fills (Xbox extension)
                                        
    D3DRS_SIMPLE_MAX                    = 82,

    // State whose handling is deferred until the next Draw[Indexed]Vertices
    // call because of interdependencies on other states:

    D3DRS_FOGENABLE                     = 82,  // TRUE to enable fog blending 
    D3DRS_FOGTABLEMODE                  = 83,  // D3DFOGMODE 
    D3DRS_FOGSTART                      = 84,  // float fog start (for both vertex and pixel fog) 
    D3DRS_FOGEND                        = 85,  // float fog end      
    D3DRS_FOGDENSITY                    = 86,  // float fog density  
    D3DRS_RANGEFOGENABLE                = 87,  // TRUE to enable range-based fog 
    D3DRS_WRAP0                         = 88,  // D3DWRAP* flags (D3DWRAP_U, D3DWRAPCOORD_0, etc.) for 1st texture coord.
    D3DRS_WRAP1                         = 89,  // D3DWRAP* flags (D3DWRAP_U, D3DWRAPCOORD_0, etc.) for 2nd texture coord. 
    D3DRS_WRAP2                         = 90,  // D3DWRAP* flags (D3DWRAP_U, D3DWRAPCOORD_0, etc.) for 3rd texture coord. 
    D3DRS_WRAP3                         = 91,  // D3DWRAP* flags (D3DWRAP_U, D3DWRAPCOORD_0, etc.) for 4th texture coord. 
    D3DRS_LIGHTING                      = 92,  // TRUE to enable lighting
    D3DRS_SPECULARENABLE                = 93,  // TRUE to enable specular 
    D3DRS_LOCALVIEWER                   = 94,  // TRUE to enable camera-relative specular highlights
    D3DRS_COLORVERTEX                   = 95,  // TRUE to enable per-vertex color
    D3DRS_BACKSPECULARMATERIALSOURCE    = 96,  // D3DMATERIALCOLORSOURCE (Xbox extension)
    D3DRS_BACKDIFFUSEMATERIALSOURCE     = 97,  // D3DMATERIALCOLORSOURCE (Xbox extension)
    D3DRS_BACKAMBIENTMATERIALSOURCE     = 98,  // D3DMATERIALCOLORSOURCE (Xbox extension)
    D3DRS_BACKEMISSIVEMATERIALSOURCE    = 99,  // D3DMATERIALCOLORSOURCE (Xbox extension)
    D3DRS_SPECULARMATERIALSOURCE        = 100, // D3DMATERIALCOLORSOURCE 
    D3DRS_DIFFUSEMATERIALSOURCE         = 101, // D3DMATERIALCOLORSOURCE 
    D3DRS_AMBIENTMATERIALSOURCE         = 102, // D3DMATERIALCOLORSOURCE 
    D3DRS_EMISSIVEMATERIALSOURCE        = 103, // D3DMATERIALCOLORSOURCE 
    D3DRS_BACKAMBIENT                   = 104, // D3DCOLOR (Xbox extension)
    D3DRS_AMBIENT                       = 105, // D3DCOLOR 
    D3DRS_POINTSIZE                     = 106, // float point size 
    D3DRS_POINTSIZE_MIN                 = 107, // float point size min threshold 
    D3DRS_POINTSPRITEENABLE             = 108, // TRUE to enable point sprites
    D3DRS_POINTSCALEENABLE              = 109, // TRUE to enable point size scaling
    D3DRS_POINTSCALE_A                  = 110, // float point attenuation A value 
    D3DRS_POINTSCALE_B                  = 111, // float point attenuation B value 
    D3DRS_POINTSCALE_C                  = 112, // float point attenuation C value 
    D3DRS_POINTSIZE_MAX                 = 113, // float point size max threshold 
    D3DRS_PATCHEDGESTYLE                = 114, // D3DPATCHEDGESTYLE
    D3DRS_PATCHSEGMENTS                 = 115, // DWORD number of segments per edge when drawing patches
    D3DRS_SWAPFILTER                    = 116, // D3DTEXF_* (D3DTEXF_LINEAR etc.) filter to use for Swap (Xbox extension)
                                        
    D3DRS_DEFERRED_MAX                  = 117,

    // Complex state that has immediate processing:

    D3DRS_PSTEXTUREMODES                = 117, // Pixel shader, Texture addressing modes (Xbox extension)
    D3DRS_VERTEXBLEND                   = 118, // D3DVERTEXBLENDFLAGS
    D3DRS_FOGCOLOR                      = 119, // D3DCOLOR 
    D3DRS_FILLMODE                      = 120, // D3DFILLMODE        
    D3DRS_BACKFILLMODE                  = 121, // D3DFILLMODE (Xbox extension)
    D3DRS_TWOSIDEDLIGHTING              = 122, // TRUE to enable two-sided lighting (Xbox extension)
    D3DRS_NORMALIZENORMALS              = 123, // TRUE to enable automatic normalization
    D3DRS_ZENABLE                       = 124, // D3DZBUFFERTYPE (or TRUE/FALSE for legacy) 
    D3DRS_STENCILENABLE                 = 125, // TRUE to enable stenciling
    D3DRS_STENCILFAIL                   = 126, // D3DSTENCILOP to do if stencil test fails 
    D3DRS_FRONTFACE                     = 127, // D3DFRONT (Xbox extension)
    D3DRS_CULLMODE                      = 128, // D3DCULL 
    D3DRS_TEXTUREFACTOR                 = 129, // D3DCOLOR used for multi-texture blend 
    D3DRS_ZBIAS                         = 130, // LONG Z bias 
    D3DRS_LOGICOP                       = 131, // D3DLOGICOP (Xbox extension)
    D3DRS_EDGEANTIALIAS                 = 132, // TRUE to enable edge antialiasing (Xbox extension)
    D3DRS_MULTISAMPLEANTIALIAS          = 133, // TRUE to enable multisample antialiasing
    D3DRS_MULTISAMPLEMASK               = 134, // DWORD per-pixel and per-sample enable/disable
    D3DRS_MULTISAMPLEMODE               = 135, // D3DMULTISAMPLEMODE for the backbuffer (Xbox extension)
    D3DRS_MULTISAMPLERENDERTARGETMODE   = 136, // D3DMULTISAMPLEMODE for non-backbuffer render targets (Xbox extension)
    D3DRS_SHADOWFUNC                    = 137, // D3DCMPFUNC (Xbox extension)
    D3DRS_LINEWIDTH                     = 138, // float (Xbox extension)
    D3DRS_DXT1NOISEENABLE               = 139, // TRUE to enable DXT1 decompression noise (Xbox extension)
    D3DRS_YUVENABLE                     = 140, // TRUE to enable use of D3DFMT_YUY2 and D3DFMT_UYVY texture formats
    D3DRS_OCCLUSIONCULLENABLE           = 141, // TRUE to enable Z occlusion culling
    D3DRS_STENCILCULLENABLE             = 142, // TRUE to enable stencil culling
    D3DRS_ROPZCMPALWAYSREAD             = 143, // TRUE to always read target packet when Z enabled
    D3DRS_ROPZREAD                      = 144, // TRUE to always read Z
    D3DRS_DONOTCULLUNCOMPRESSED         = 145, // TRUE to never attempt occlusion culling (stencil or Z) on uncompressed packets
                                        
    D3DRS_MAX                           = 146, // Total number of renderstates 

    // Render states that are not supported on Xbox:
    //
    // D3DRS_LINEPATTERN
    // D3DRS_LASTPIXEL
    // D3DRS_CLIPPING
    // D3DRS_FOGVERTEXMODE
    // D3DRS_CLIPPLANEENABLE
    // D3DRS_SOFTWAREVERTEXPROCESSING
    // D3DRS_DEBUGMONITORTOKEN
    // D3DRS_INDEXEDVERTEXBLENDENABLE
    // D3DRS_TWEENFACTOR

    D3DRS_FORCE_DWORD                   = 0x7fffffff, /* force 32-bit size enum */
} D3DRENDERSTATETYPE;

// Values for material source
typedef enum _D3DMATERIALCOLORSOURCE
{
    D3DMCS_MATERIAL         = 0,            // Color from material is used
    D3DMCS_COLOR1           = 1,            // Diffuse vertex color is used
    D3DMCS_COLOR2           = 2,            // Specular vertex color is used
    D3DMCS_FORCE_DWORD      = 0x7fffffff,   // force 32-bit size enum
} D3DMATERIALCOLORSOURCE;

// Bias to apply to the texture coordinate set to apply a wrap to.
#define D3DRENDERSTATE_WRAPBIAS                 D3DRS_WRAP0

/* Flags to construct the WRAP render states */
#define D3DWRAP_U   0x00000010L
#define D3DWRAP_V   0x00001000L
#define D3DWRAP_W   0x00100000L

/* Flags to construct the WRAP render states for 1D thru 4D texture coordinates */
#define D3DWRAPCOORD_0   0x00000010L    // same as D3DWRAP_U
#define D3DWRAPCOORD_1   0x00001000L    // same as D3DWRAP_V
#define D3DWRAPCOORD_2   0x00100000L    // same as D3DWRAP_W
#define D3DWRAPCOORD_3   0x01000000L

/* Flags to construct D3DRS_COLORWRITEENABLE */
#define D3DCOLORWRITEENABLE_RED     (1L<<16)
#define D3DCOLORWRITEENABLE_GREEN   (1L<<8)
#define D3DCOLORWRITEENABLE_BLUE    (1L<<0)
#define D3DCOLORWRITEENABLE_ALPHA   (1L<<24)
#define D3DCOLORWRITEENABLE_ALL     0x01010101 // Xbox extension

/*
 * State enumerants for per-stage texture processing.
 */
typedef enum _D3DTEXTURESTAGESTATETYPE
{
    // State whose handling is deferred until the next Draw[Indexed]Vertices
    // call because of interdependencies on other states:

    D3DTSS_ADDRESSU              =  0,  // D3DTEXTUREADDRESS for U coordinate 
    D3DTSS_ADDRESSV              =  1,  // D3DTEXTUREADDRESS for V coordinate 
    D3DTSS_ADDRESSW              =  2,  // D3DTEXTUREADDRESS for W coordinate 
    D3DTSS_MAGFILTER             =  3,  // D3DTEXF_* (D3DTEXF_LINEAR etc.) filter to use for magnification 
    D3DTSS_MINFILTER             =  4,  // D3DTEXF_* (D3DTEXF_LINEAR etc.) filter to use for minification 
    D3DTSS_MIPFILTER             =  5,  // D3DTEXF_* (D3DTEXF_LINEAR etc.) filter to use between mipmaps during minification 
    D3DTSS_MIPMAPLODBIAS         =  6,  // float mipmap LOD bias 
    D3DTSS_MAXMIPLEVEL           =  7,  // DWORD 0..(n-1) LOD index of largest map to use (0 == largest) 
    D3DTSS_MAXANISOTROPY         =  8,  // DWORD maximum anisotropy 
    D3DTSS_COLORKEYOP            =  9,  // D3DTEXTURECOLORKEYOP (Xbox extension)
    D3DTSS_COLORSIGN             = 10,  // D3DTSIGN_* (D3DTSIGN_ASIGNED etc.) for color channels (xbox extension)
    D3DTSS_ALPHAKILL             = 11,  // D3DTEXTUREALPHAKILL (Xbox extension)

    D3DTSS_DEFERRED_TEXTURE_STATE_MAX = 12,

    D3DTSS_COLOROP               = 12,  // D3DTEXTUREOP - per-stage blending controls for color channels 
    D3DTSS_COLORARG0             = 13,  // D3DTA_* (D3DTA_TEXTURE etc.) third arg for triadic ops 
    D3DTSS_COLORARG1             = 14,  // D3DTA_* (D3DTA_TEXTURE etc.) texture arg
    D3DTSS_COLORARG2             = 15,  // D3DTA_* (D3DTA_TEXTURE etc.) texture arg 
    D3DTSS_ALPHAOP               = 16,  // D3DTEXTUREOP - per-stage blending controls for alpha channel 
    D3DTSS_ALPHAARG0             = 17,  // D3DTA_* (D3DTA_TEXTURE etc.) third arg for triadic ops 
    D3DTSS_ALPHAARG1             = 18,  // D3DTA_* (D3DTA_TEXTURE etc.) texture arg
    D3DTSS_ALPHAARG2             = 19,  // D3DTA_* (D3DTA_TEXTURE etc.) texture arg) 
    D3DTSS_RESULTARG             = 20,  // D3DTA_CURRENT or D3DTA_TEMP - arg for result 
    D3DTSS_TEXTURETRANSFORMFLAGS = 21,  // D3DTEXTURETRANSFORMFLAGS controls texture transform 

    D3DTSS_DEFERRED_MAX          = 22,

    // State that has immediate processing:

    D3DTSS_BUMPENVMAT00          = 22,  // float (bump mapping matrix) 
    D3DTSS_BUMPENVMAT01          = 23,  // float (bump mapping matrix) 
    D3DTSS_BUMPENVMAT11          = 24,  // float (bump mapping matrix) 
    D3DTSS_BUMPENVMAT10          = 25,  // float (bump mapping matrix) 
    D3DTSS_BUMPENVLSCALE         = 26,  // float scale for bump map luminance 
    D3DTSS_BUMPENVLOFFSET        = 27,  // float offset for bump map luminance 
    D3DTSS_TEXCOORDINDEX         = 28,  // DWORD identifies which set of texture coordinates index this texture 
    D3DTSS_BORDERCOLOR           = 29,  // D3DCOLOR 
    D3DTSS_COLORKEYCOLOR         = 30,  // D3DCOLOR value for color key (Xbox extension)
                                 
    D3DTSS_MAX                   = 32,  // Total number of texture stage states (bumped to a power of 2)

    D3DTSS_FORCE_DWORD           = 0x7fffffff, // force 32-bit size enum 
} D3DTEXTURESTAGESTATETYPE;

/*
 * The maximum number of texture stages supported on Xbox
 */

#define D3DTSS_MAXSTAGES 4

/*
 * The maximum index value possible for EndVisibilityTest
 */

#define D3DVISIBILITY_TEST_MAX 4096

// Values, used with D3DTSS_TEXCOORDINDEX, to specify that the vertex data(position
// and normal in the camera space) should be taken as texture coordinates
// Low 16 bits are used to specify texture coordinate index, to take the WRAP mode from
//
#define D3DTSS_TCI_PASSTHRU                             0x00000000
#define D3DTSS_TCI_CAMERASPACENORMAL                    0x00010000
#define D3DTSS_TCI_CAMERASPACEPOSITION                  0x00020000
#define D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR          0x00030000
#define D3DTSS_TCI_OBJECT                               0x00040000
#define D3DTSS_TCI_SPHERE                               0x00050000

#define D3DTSS_TCI_TEXCOORDINDEX_MAX                    8
#define D3DTSS_TCI_TEXGEN_MAX                           0x00060000

/*
 * Enumerations for COLOROP and ALPHAOP texture blending operations set in
 * texture processing stage controls in D3DRENDERSTATE.
 */
typedef enum _D3DTEXTUREOP
{
    // Control
    D3DTOP_DISABLE              = 1,      // disables stage
    D3DTOP_SELECTARG1           = 2,      // the default
    D3DTOP_SELECTARG2           = 3,

    // Modulate
    D3DTOP_MODULATE             = 4,      // multiply args together
    D3DTOP_MODULATE2X           = 5,      // multiply and  1 bit
    D3DTOP_MODULATE4X           = 6,      // multiply and  2 bits

    // Add
    D3DTOP_ADD                  =  7,   // add arguments together
    D3DTOP_ADDSIGNED            =  8,   // add with -0.5 bias
    D3DTOP_ADDSIGNED2X          =  9,   // as above but left  1 bit
    D3DTOP_SUBTRACT             = 10,   // Arg1 - Arg2, with no saturation
    D3DTOP_ADDSMOOTH            = 11,   // add 2 args, subtract product
                                        // Arg1 + Arg2 - Arg1*Arg2
                                        // = Arg1 + (1-Arg1)*Arg2

    // Linear alpha blend: Arg1*(Alpha) + Arg2*(1-Alpha)
    D3DTOP_BLENDDIFFUSEALPHA    = 12, // iterated alpha
    D3DTOP_BLENDTEXTUREALPHA    = 14, // texture alpha
    D3DTOP_BLENDFACTORALPHA     = 15, // alpha from D3DRENDERSTATE_TEXTUREFACTOR

    // Linear alpha blend with pre-multiplied arg1 input: Arg1 + Arg2*(1-Alpha)
    D3DTOP_BLENDTEXTUREALPHAPM  = 16, // texture alpha
    D3DTOP_BLENDCURRENTALPHA    = 13, // by alpha of current color

    // Specular mapping
    D3DTOP_PREMODULATE            = 17,     // modulate with next texture before use
    D3DTOP_MODULATEALPHA_ADDCOLOR = 18,     // Arg1.RGB + Arg1.A*Arg2.RGB
                                            // COLOROP only
    D3DTOP_MODULATECOLOR_ADDALPHA = 19,     // Arg1.RGB*Arg2.RGB + Arg1.A
                                            // COLOROP only
    D3DTOP_MODULATEINVALPHA_ADDCOLOR = 20,  // (1-Arg1.A)*Arg2.RGB + Arg1.RGB
                                            // COLOROP only
    D3DTOP_MODULATEINVCOLOR_ADDALPHA = 21,  // (1-Arg1.RGB)*Arg2.RGB + Arg1.A
                                            // COLOROP only

    // This can do either diffuse or specular bump mapping with correct input.
    // Performs the function (Arg1.R*Arg2.R + Arg1.G*Arg2.G + Arg1.B*Arg2.B)
    // where each component has been scaled and offset to make it signed.
    // The result is replicated into all four (including alpha) channels.
    // This is a valid COLOROP only.
    D3DTOP_DOTPRODUCT3          = 22,

    // Triadic ops
    D3DTOP_MULTIPLYADD          = 23, // Arg0 + Arg1*Arg2
    D3DTOP_LERP                 = 24, // (Arg0)*Arg1 + (1-Arg0)*Arg2

    // Bump mapping
    D3DTOP_BUMPENVMAP           = 25, // per pixel env map perturbation
    D3DTOP_BUMPENVMAPLUMINANCE  = 26, // with luminance channel

    D3DTOP_MAX                  = 27,
    D3DTOP_FORCE_DWORD = 0x7fffffff,
} D3DTEXTUREOP;

/*
 * Values for COLORARG0,1,2, ALPHAARG0,1,2, and RESULTARG texture blending
 * operations set in texture processing stage controls in D3DRENDERSTATE.
 */
#define D3DTA_SELECTMASK        0x0000000f  // mask for arg selector
#define D3DTA_DIFFUSE           0x00000000  // select diffuse color (read only)
#define D3DTA_CURRENT           0x00000001  // select stage destination register (read/write)
#define D3DTA_TEXTURE           0x00000002  // select texture color (read only)
#define D3DTA_TFACTOR           0x00000003  // select RENDERSTATE_TEXTUREFACTOR (read only)
#define D3DTA_SPECULAR          0x00000004  // select specular color (read only)
#define D3DTA_TEMP              0x00000005  // select temporary register color (read/write)
#define D3DTA_COMPLEMENT        0x00000010  // take 1.0 - x (read modifier)
#define D3DTA_ALPHAREPLICATE    0x00000020  // replicate alpha to color components (read modifier)

#define D3DTA_SELECTMAX         0x00000006
#define D3DTA_MODIFIERMAX       0x00000040

/*
 * Flags for D3DTSS_COLORSIGN (Xbox extension)
 */
#define D3DTSIGN_ASIGNED           0x10000000
#define D3DTSIGN_AUNSIGNED         0
#define D3DTSIGN_RSIGNED           0x20000000
#define D3DTSIGN_RUNSIGNED         0
#define D3DTSIGN_GSIGNED           0x40000000
#define D3DTSIGN_GUNSIGNED         0
#define D3DTSIGN_BSIGNED           0x80000000
#define D3DTSIGN_BUNSIGNED         0

//
// Values for D3DTSS_***FILTER texture stage states
//
typedef enum _D3DTEXTUREFILTERTYPE
{
    D3DTEXF_NONE            = 0,    // filtering disabled (valid for mip filter only)
    D3DTEXF_POINT           = 1,    // nearest
    D3DTEXF_LINEAR          = 2,    // linear interpolation
    D3DTEXF_ANISOTROPIC     = 3,    // anisotropic
    D3DTEXF_QUINCUNX        = 4,    // quincunx kernel (Xbox extension)
    D3DTEXF_GAUSSIANCUBIC   = 5,    // different cubic kernel

    D3DTEXF_MAX             = 6,
    D3DTEXF_FORCE_DWORD     = 0x7fffffff,   // force 32-bit size enum
} D3DTEXTUREFILTERTYPE;

/* The maximum number of vertices user can pass to any d3d
   drawing function or to create vertex buffer with
*/
#define D3DMAXNUMVERTICES    ((1<<16) - 1)
/* The maximum number of primitives user can pass to any d3d
   drawing function.
*/
#define D3DMAXNUMPRIMITIVES  ((1<<16) - 1)

//-------------------------------------------------------------------
// Flexible vertex format bits
//
#define D3DFVF_RESERVED0        0x001
#define D3DFVF_POSITION_MASK    0x00E
#define D3DFVF_XYZ              0x002
#define D3DFVF_XYZRHW           0x004
#define D3DFVF_XYZB1            0x006
#define D3DFVF_XYZB2            0x008
#define D3DFVF_XYZB3            0x00a
#define D3DFVF_XYZB4            0x00c

#define D3DFVF_NORMAL           0x010
#define D3DFVF_DIFFUSE          0x040
#define D3DFVF_SPECULAR         0x080

#define D3DFVF_TEXCOUNT_MASK    0xf00
#define D3DFVF_TEXCOUNT_SHIFT   8
#define D3DFVF_TEX0             0x000
#define D3DFVF_TEX1             0x100
#define D3DFVF_TEX2             0x200
#define D3DFVF_TEX3             0x300
#define D3DFVF_TEX4             0x400

#define D3DFVF_RESERVED2        0xE000  // 4 reserved bits

// D3DFVF_PSIZE is not supported on Xbox with the fixed function pipeline 
// (a programmable vertex shader can be written to support per-vertex point
// sizes)

//---------------------------------------------------------------------
// Vertex Shaders
//

/*

Vertex Shader Declaration

The declaration portion of a vertex shader defines the static external
interface of the shader.  The information in the declaration includes:

- Assignments of vertex shader input registers to data streams.  These
assignments bind a specific vertex register to a single component within a
vertex stream.  A vertex stream element is identified by a byte offset
within the stream and a type.  The type specifies the arithmetic data type
plus the dimensionality (1, 2, 3, or 4 values).  Stream data which is
less than 4 values are always expanded out to 4 values with zero or more
0.F values and one 1.F value.

- Assignment of vertex shader input registers to implicit data from the
primitive tessellator.  This controls the loading of vertex data which is
not loaded from a stream, but rather is generated during primitive
tessellation prior to the vertex shader.

- Loading data into the constant memory at the time a shader is set as the
current shader.  Each token specifies values for one or more contiguous 4
DWORD constant registers.  This allows the shader to update an arbitrary
subset of the constant memory, overwriting the device state (which
contains the current values of the constant memory).  Note that these
values can be subsequently overwritten (between DrawPrimitive calls)
during the time a shader is bound to a device via the
SetVertexShaderConstant method.


Declaration arrays are single-dimensional arrays of DWORDs composed of
multiple tokens each of which is one or more DWORDs.  The single-DWORD
token value 0xFFFFFFFF is a special token used to indicate the end of the
declaration array.  The single DWORD token value 0x00000000 is a NOP token
with is ignored during the declaration parsing.  Note that 0x00000000 is a
valid value for DWORDs following the first DWORD for multiple word tokens.

[31:29] TokenType
    0x0 - NOP (requires all DWORD bits to be zero)
    0x1 - stream selector
    0x2 - stream data definition (map to vertex input memory)
    0x3 - vertex input memory from tessellator
    0x4 - constant memory from shader
    0x5 - extension
    0x6 - reserved
    0x7 - end-of-array (requires all DWORD bits to be 1)

NOP Token (single DWORD token)
    [31:29] 0x0
    [28:00] 0x0

Stream Selector (single DWORD token)
    [31:29] 0x1
    [28]    indicates whether this is a tessellator stream
    [27:04] 0x0
    [03:00] stream selector (0..15)

Stream Data Definition (single DWORD token)
    Vertex Input Register Load
      [31:29] 0x2
      [28]    0x0
      [27:24] 0x0
      [23:16] type (dimensionality and data type)
      [15:04] 0x0
      [03:00] vertex register address (0..15)
    DWORD Data Skip (no register load)
      [31:29] 0x2
      [28]    0x1
      [27]    0x0
      [26:20] 0x0
      [19:16] count of DWORDS to skip over (0..15)
      [15:00] 0x0
    BYTE Data Skip (no register load)
      [31:29] 0x2
      [28]    0x1
      [27]    0x1
      [26:20] 0x0
      [19:16] count of BYTES to skip over (0..15)
      [15:00] 0x0
  
Vertex Input Memory from Tessellator Data (single DWORD token)
    [31:29] 0x3
    [28]    indicates whether data is normals or u/v
    [27:24] 0x0
    [23:20] vertex register address (0..15)
    [19:04] 0x0
    [03:00] vertex register address (0..15)

Constant Memory from Shader (multiple DWORD token)
    [31:29] 0x4
    [28:25] count of 4*DWORD constants to load (0..15)
    [24:08] 0x0
    [07:00] constant memory address (0..191 - biased by 96)

Extension Token (single or multiple DWORD token)
    [31:29] 0x5
    [28:24] count of additional DWORDs in token (0..31)
    [23:00] extension-specific information

End-of-array token (single DWORD token)
    [31:29] 0x7
    [28:00] 0x1fffffff

The stream selector token must be immediately followed by a contiguous set 
of stream data definition tokens.  This token sequence fully defines that 
stream, including the set of elements within the stream, the order in 
which the elements appear, the type of each element, and the vertex 
register into which to load an element.

Streams are allowed to include data which is not loaded into a vertex 
register, thus allowing data which is not used for this shader to exist 
in the vertex stream.  This skipped data is defined only by a count of 
DWORDs to skip over, since the type i nformation is irrelevant.

The token sequence:
Stream Select: stream=0
Stream Data Definition (Load): type=FLOAT3; register=3
Stream Data Definition (Load): type=FLOAT3; register=4
Stream Data Definition (Skip): count=2
Stream Data Definition (Load): type=FLOAT2; register=7

defines stream zero to consist of 4 elements, 3 of which are loaded into 
registers and the fourth skipped over.  Register 3 is loaded with the 
first three DWORDs in each vertex interpreted as FLOAT data.  Register 4 
is loaded with the 4th, 5th, and 6th DWORDs interpreted as FLOAT data.  
The next two DWORDs (7th and 8th) are skipped over and not loaded into 
any vertex input register.   Register 7 is loaded with the 9th and 10th 
DWORDS interpreted as FLOAT data.  Placing of tokens other than NOPs 
between the Stream Selector and Stream Data Definition tokens is disallowed.

*/

// Vertex Shader 1.0 register limits. D3D device must provide at least
// specified number of registers
//

#define D3DVS_STREAMS_MAX_V1_0          16
#define D3DVS_INPUTREG_MAX_V1_0         16
#define D3DVS_TEMPREG_MAX_V1_0          12
// This max required number. Device could have more registers. Check caps.
#define D3DVS_CONSTREG_COUNT_XBOX       192
#define D3DVS_TCRDOUTREG_MAX_V1_0       8
#define D3DVS_ADDRREG_MAX_V1_0          1
#define D3DVS_ATTROUTREG_MAX_V1_0       2
#define D3DVS_MAXINSTRUCTIONCOUNT_V1_0  128

// The following two vertex shader constant addresses are reserved on Xbox
// when the SetShaderConstantMode does not have the D3DSCM_NORESERVEDCONSTANTS 
// bit set (that is, these are reserved unless all of your vertex shaders use
// #pragma screenspace):
//
#define D3DVS_XBOX_RESERVEDCONSTANT1    -38
#define D3DVS_XBOX_RESERVEDCONSTANT2    -37

// Calling SetVertexShader with FVF_XYZRHW invalidates the first 11 or 12
// vertex shader program slots as loaded via LoadVertexShader. Max is 12...
//
#define D3DVS_XBOX_RESERVEDXYZRHWSLOTS  12

// Pixel Shader DX8 register limits. D3D device will have at most these
// specified number of registers
//
#define D3DPS_INPUTREG_MAX_DX8         8
#define D3DPS_TEMPREG_MAX_DX8          8
#define D3DPS_CONSTREG_MAX_DX8         16
#define D3DPS_TEXTUREREG_MAX_DX8       8


typedef enum _D3DVSD_TOKENTYPE
{
    D3DVSD_TOKEN_NOP        = 0,    // NOP or extension
    D3DVSD_TOKEN_STREAM,            // stream selector
    D3DVSD_TOKEN_STREAMDATA,        // stream data definition (map to vertex input memory)
    D3DVSD_TOKEN_TESSELLATOR,       // vertex input memory from tessellator
    D3DVSD_TOKEN_CONSTMEM,          // constant memory from shader
    D3DVSD_TOKEN_EXT,               // extension
    D3DVSD_TOKEN_END = 7,           // end-of-array (requires all DWORD bits to be 1)
    D3DVSD_FORCE_DWORD = 0x7fffffff,// force 32-bit size enum
} D3DVSD_TOKENTYPE;

#define D3DVSD_TOKENTYPESHIFT   29
#define D3DVSD_TOKENTYPEMASK    (7 << D3DVSD_TOKENTYPESHIFT)

#define D3DVSD_STREAMNUMBERSHIFT 0
#define D3DVSD_STREAMNUMBERMASK (0xF << D3DVSD_STREAMNUMBERSHIFT)

#define D3DVSD_DATALOADTYPESHIFT 28
#define D3DVSD_DATALOADTYPEMASK (0x1 << D3DVSD_DATALOADTYPESHIFT)

#define D3DVSD_DATATYPESHIFT 16
#define D3DVSD_DATATYPEMASK (0xFF << D3DVSD_DATATYPESHIFT)

#define D3DVSD_SKIPCOUNTSHIFT 16
#define D3DVSD_SKIPCOUNTMASK (0xF << D3DVSD_SKIPCOUNTSHIFT)

#define D3DVSD_VERTEXREGSHIFT 0
#define D3DVSD_VERTEXREGMASK (0x1F << D3DVSD_VERTEXREGSHIFT)

#define D3DVSD_VERTEXREGINSHIFT 20
#define D3DVSD_VERTEXREGINMASK (0xF << D3DVSD_VERTEXREGINSHIFT)

#define D3DVSD_CONSTCOUNTSHIFT 25
#define D3DVSD_CONSTCOUNTMASK (0xF << D3DVSD_CONSTCOUNTSHIFT)

#define D3DVSD_CONSTADDRESSSHIFT 0
#define D3DVSD_CONSTADDRESSMASK (0xFF << D3DVSD_CONSTADDRESSSHIFT)

#define D3DVSD_CONSTRSSHIFT 16
#define D3DVSD_CONSTRSMASK (0x1FFF << D3DVSD_CONSTRSSHIFT)

#define D3DVSD_EXTCOUNTSHIFT 24
#define D3DVSD_EXTCOUNTMASK (0x1F << D3DVSD_EXTCOUNTSHIFT)

#define D3DVSD_EXTINFOSHIFT 0
#define D3DVSD_EXTINFOMASK (0xFFFFFF << D3DVSD_EXTINFOSHIFT)

#define D3DVSD_MAKETOKENTYPE(tokenType) ((tokenType << D3DVSD_TOKENTYPESHIFT) & D3DVSD_TOKENTYPEMASK)

// macros for generation of CreateVertexShader Declaration token array

// Set current stream
// _StreamNumber [0..(MaxStreams-1)] stream to get data from
//
#define D3DVSD_STREAM( _StreamNumber ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAM) | (_StreamNumber))

// Set tessellator stream
//
#define D3DVSD_STREAMTESSSHIFT 28
#define D3DVSD_STREAMTESSMASK (1 << D3DVSD_STREAMTESSSHIFT)
#define D3DVSD_STREAM_TESS( ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAM) | (D3DVSD_STREAMTESSMASK))

// bind single vertex register to vertex element from vertex stream
//
// _VertexRegister [0..26] address of the vertex register
// _Type [D3DVSDT_*] dimensionality and arithmetic data type

#define D3DVSD_REG( _VertexRegister, _Type ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAMDATA) |            \
     ((_Type) << D3DVSD_DATATYPESHIFT) | (_VertexRegister))

// Skip _DWORDCount DWORDs in vertex
//
#define D3DVSD_SKIP( _DWORDCount ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAMDATA) | 0x10000000 | \
     ((_DWORDCount) << D3DVSD_SKIPCOUNTSHIFT))

// Skip _BYTECount BYTEs in vertex (Xbox extension)
//
#define D3DVSD_SKIPBYTES( _BYTECount ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAMDATA) | 0x18000000 | \
     ((_BYTECount) << D3DVSD_SKIPCOUNTSHIFT))

// load data into vertex shader constant memory
//
// _ConstantAddress [-96..95] - address of constant array to begin filling data
// _Count [0..15] - number of constant vectors to load (4 DWORDs each)
// followed by 4*_Count DWORDS of data
//
#define D3DVSD_CONST( _ConstantAddress, _Count ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_CONSTMEM) | \
     ((_Count) << D3DVSD_CONSTCOUNTSHIFT) | ((_ConstantAddress) + 96))

// enable tessellator generated normals
//
// _VertexRegisterIn  [0..15] address of vertex register whose input stream
//                            will be used in normal computation
// _VertexRegisterOut [0..15] address of vertex register to output the normal to
//
#define D3DVSD_TESSNORMAL( _VertexRegisterIn, _VertexRegisterOut ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_TESSELLATOR) | \
     ((_VertexRegisterIn) << D3DVSD_VERTEXREGINSHIFT) | \
     (_VertexRegisterOut))

// enable tessellator generated surface parameters
//
// _VertexRegister [0..15] address of vertex register to output parameters
//
#define D3DVSD_TESSUV( _VertexRegister ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_TESSELLATOR) | 0x10000000 | \
     (_VertexRegister))

// Generates END token
//
#define D3DVSD_END() 0xFFFFFFFF

// Generates NOP token
#define D3DVSD_NOP() 0x00000000

// bit declarations for _Type fields
#define D3DVSDT_FLOAT1      0x12    // 1D float expanded to (value, 0., 0., 1.)
#define D3DVSDT_FLOAT2      0x22    // 2D float expanded to (value, value, 0., 1.)
#define D3DVSDT_FLOAT3      0x32    // 3D float expanded to (value, value, value, 1.)
#define D3DVSDT_FLOAT4      0x42    // 4D float
#define D3DVSDT_D3DCOLOR    0x40    // 4D packed unsigned bytes mapped to 0. to 1. range
                                    // Input is in D3DCOLOR format (ARGB) expanded to (R, G, B, A)
#define D3DVSDT_SHORT2      0x25    // 2D signed short expanded to (value, value, 0., 1.)
#define D3DVSDT_SHORT4      0x45    // 4D signed short

// The following are Xbox extensions
#define D3DVSDT_NORMSHORT1  0x11    // 1D signed, normalized short expanded to (value, 0, 0., 1.)
                                    // (signed, normalized short maps from -1.0 to 1.0)
#define D3DVSDT_NORMSHORT2  0x21    // 2D signed, normalized short expanded to (value, value, 0., 1.)
#define D3DVSDT_NORMSHORT3  0x31    // 3D signed, normalized short expanded to (value, value, value, 1.)  
#define D3DVSDT_NORMSHORT4  0x41    // 4D signed, normalized short expanded to (value, value, value, value)  
#define D3DVSDT_NORMPACKED3 0x16    // 3 signed, normalized components packed in 32-bits.  (11,11,10).  
                                    // Each component ranges from -1.0 to 1.0.  
                                    // Expanded to (value, value, value, 1.)
#define D3DVSDT_SHORT1      0x15    // 1D signed short expanded to (value, 0., 0., 1.)  
                                    // Signed shorts map to the range [-32768, 32767]
#define D3DVSDT_SHORT3      0x35    // 3D signed short expanded to (value, value, value, 1.)
#define D3DVSDT_PBYTE1      0x14    // 1D packed byte expanded to (value, 0., 0., 1.)  
                                    // Packed bytes map to the range [0, 1]
#define D3DVSDT_PBYTE2      0x24    // 2D packed byte expanded to (value, value, 0., 1.)
#define D3DVSDT_PBYTE3      0x34    // 3D packed byte expanded to (value, value, value, 1.)
#define D3DVSDT_PBYTE4      0x44    // 4D packed byte expanded to (value, value, value, value) 
#define D3DVSDT_FLOAT2H     0x72    // 2D homogeneous float expanded to (value, value,0., value.)
                                    // Useful for projective texture coordinates.
#define D3DVSDT_NONE        0x02    // No stream data

// D3DVSDT_UBYTE4 not supported on Xbox (hardware can't do it)

// assignments of vertex input registers for fixed function vertex shader
//
#define D3DVSDE_VERTEX          -1  // Xbox extension, used only in Begin/End bracket
#define D3DVSDE_POSITION        0
#define D3DVSDE_BLENDWEIGHT     1
#define D3DVSDE_NORMAL          2
#define D3DVSDE_DIFFUSE         3
#define D3DVSDE_SPECULAR        4
#define D3DVSDE_FOG             5   // Xbox extension
#define D3DVSDE_BACKDIFFUSE     7   // Xbox extension
#define D3DVSDE_BACKSPECULAR    8   // Xbox extension
#define D3DVSDE_TEXCOORD0       9
#define D3DVSDE_TEXCOORD1       10
#define D3DVSDE_TEXCOORD2       11
#define D3DVSDE_TEXCOORD3       12

// D3DVSDE_PSIZE is not supported on Xbox with the fixed function pipeline 
// (a programmable vertex shader can be written to support per-vertex point
// sizes)

// Maximum supported number of texture coordinate sets
#define D3DDP_MAXTEXCOORD   4

// Some Vertex Shader APIs take allow the vertex format to be specified with 
// a structure rather than a handle to a vertex shader object.  The following 
// structure defines how vertex attributes are read from one or more streams.

typedef struct _D3DVERTEXSHADERINPUT
{
    DWORD StreamIndex;      // which stream 
    DWORD Offset;           // Byte offset from the start of the stream.
    DWORD Format;           // format of this attribute (D3DVSDT_*)
    BYTE  TessType;         // 0=none, 1=normal, 2=autotex
    BYTE  TessSource;       // source register for normal/uv autocalc
} D3DVERTEXSHADERINPUT;

// Up to 16 different inputs are supported by the vertex shader hardware.
// Each of the 16 entries in the following structure defines which 
// stream that value comes from, what byte offset corresponds to an 
// attribute, and the format of the attribute.

typedef struct _D3DVERTEXATTRIBUTEFORMAT
{
    D3DVERTEXSHADERINPUT Input[16];
} D3DVERTEXATTRIBUTEFORMAT;


//
// Instruction Token Bit Definitions
//
#define D3DSI_OPCODE_MASK       0x0000FFFF

typedef enum _D3DSHADER_INSTRUCTION_OPCODE_TYPE
{
    D3DSIO_NOP          = 0,    // PS/VS
    D3DSIO_MOV          ,       // PS/VS
    D3DSIO_ADD          ,       // PS/VS
    D3DSIO_SUB          ,       // PS
    D3DSIO_MAD          ,       // PS/VS
    D3DSIO_MUL          ,       // PS/VS
    D3DSIO_RCP          ,       // VS
    D3DSIO_RSQ          ,       // VS
    D3DSIO_DP3          ,       // PS/VS
    D3DSIO_DP4          ,       // VS
    D3DSIO_MIN          ,       // VS
    D3DSIO_MAX          ,       // VS
    D3DSIO_SLT          ,       // VS
    D3DSIO_SGE          ,       // VS
    D3DSIO_EXP          ,       // VS
    D3DSIO_LOG          ,       // VS
    D3DSIO_LIT          ,       // VS
    D3DSIO_DST          ,       // VS
    D3DSIO_LRP          ,       // PS
    D3DSIO_FRC          ,       // VS
    D3DSIO_M4x4         ,       // VS
    D3DSIO_M4x3         ,       // VS
    D3DSIO_M3x4         ,       // VS
    D3DSIO_M3x3         ,       // VS
    D3DSIO_M3x2         ,       // VS

    D3DSIO_TEXCOORD     = 64,   // PS
    D3DSIO_TEXKILL      ,       // PS
    D3DSIO_TEX          ,       // PS
    D3DSIO_TEXBEM       ,       // PS
    D3DSIO_TEXBEML      ,       // PS
    D3DSIO_TEXREG2AR    ,       // PS
    D3DSIO_TEXREG2GB    ,       // PS
    D3DSIO_TEXM3x2PAD   ,       // PS
    D3DSIO_TEXM3x2TEX   ,       // PS
    D3DSIO_TEXM3x3PAD   ,       // PS
    D3DSIO_TEXM3x3TEX   ,       // PS
    D3DSIO_TEXM3x3DIFF  ,       // PS
    D3DSIO_TEXM3x3SPEC  ,       // PS
    D3DSIO_TEXM3x3VSPEC ,       // PS
    D3DSIO_EXPP         ,       // VS
    D3DSIO_LOGP         ,       // VS
    D3DSIO_CND          ,       // PS
    D3DSIO_DEF          ,       // PS
    
    // Xbox Extensions
    D3DSIO_DPH          =256,   // VS
    D3DSIO_RCC          ,       // VS
    D3DSIO_XMMA         ,       // PS
    D3DSIO_XMMC         ,       // PS
    D3DSIO_XDM          ,       // PS
    D3DSIO_XDD          ,       // PS
    D3DSIO_XFC          ,       // PS
    D3DSIO_TEXM3x2DEPTH ,       // PS
    D3DSIO_TEXBRDF      ,       // PS

    D3DSIO_COMMENT      = 0xFFFE,
    D3DSIO_END          = 0xFFFF,

    D3DSIO_FORCE_DWORD  = 0x7fffffff,   // force 32-bit size enum
} D3DSHADER_INSTRUCTION_OPCODE_TYPE;

//
// Co-Issue Instruction Modifier - if set then this instruction is to be
// issued in parallel with the previous instruction(s) for which this bit
// is not set.
//
#define D3DSI_COISSUE           0x40000000

//
// Parameter Token Bit Definitions
//
#define D3DSP_REGNUM_MASK       0x00000FFF

// destination parameter write mask
#define D3DSP_WRITEMASK_0       0x00010000  // Component 0 (X;Red)
#define D3DSP_WRITEMASK_1       0x00020000  // Component 1 (Y;Green)
#define D3DSP_WRITEMASK_2       0x00040000  // Component 2 (Z;Blue)
#define D3DSP_WRITEMASK_3       0x00080000  // Component 3 (W;Alpha)
#define D3DSP_WRITEMASK_ALL     0x000F0000  // All Components

// destination parameter modifiers
#define D3DSP_DSTMOD_SHIFT      20
#define D3DSP_DSTMOD_MASK       0x00F00000

#define D3DSP_DSTSRC_SHIFT      15          // indicates src or dst
#define D3DSP_DSTSRC_MASK       0x00008000

typedef enum _D3DSHADER_PARAM_DSTMOD_TYPE
{
    D3DSPDM_NONE    = 0<<D3DSP_DSTMOD_SHIFT, // nop
    D3DSPDM_BIAS    = 1<<D3DSP_DSTMOD_SHIFT, // subtract 0.5
    D3DSPDM_FORCE_DWORD  = 0x7fffffff,      // force 32-bit size enum
} D3DSHADER_PARAM_DSTMOD_TYPE;

// destination parameter 
#define D3DSP_DSTSHIFT_SHIFT    24
#define D3DSP_DSTSHIFT_MASK     0x0F000000

// destination/source parameter register type
#define D3DSP_REGTYPE_SHIFT     28
#define D3DSP_REGTYPE_MASK      0x70000000

typedef enum _D3DSHADER_PARAM_REGISTER_TYPE
{
    D3DSPR_TEMP     = 0<<D3DSP_REGTYPE_SHIFT, // Temporary Register File
    D3DSPR_INPUT    = 1<<D3DSP_REGTYPE_SHIFT, // Input Register File
    D3DSPR_CONST    = 2<<D3DSP_REGTYPE_SHIFT, // Constant Register File
    D3DSPR_ADDR     = 3<<D3DSP_REGTYPE_SHIFT, // Address Register (VS)
    D3DSPR_TEXTURE  = 3<<D3DSP_REGTYPE_SHIFT, // Texture Register File (PS)
    D3DSPR_RASTOUT  = 4<<D3DSP_REGTYPE_SHIFT, // Rasterizer Register File
    D3DSPR_ATTROUT  = 5<<D3DSP_REGTYPE_SHIFT, // Attribute Output Register File
    D3DSPR_TEXCRDOUT= 6<<D3DSP_REGTYPE_SHIFT, // Texture Coordinate Output Register File
    D3DSPR_FORCE_DWORD  = 0x7fffffff,         // force 32-bit size enum
} D3DSHADER_PARAM_REGISTER_TYPE;

// Register offsets in the Rasterizer Register File
//
typedef enum _D3DVS_RASTOUT_OFFSETS
{
    D3DSRO_POSITION = 0,
    D3DSRO_FOG,
    D3DSRO_POINT_SIZE,
    D3DSRO_FORCE_DWORD  = 0x7fffffff,         // force 32-bit size enum
} D3DVS_RASTOUT_OFFSETS;

// Source operand addressing modes

#define D3DVS_ADDRESSMODE_SHIFT 13
#define D3DVS_ADDRESSMODE_MASK  (3 << D3DVS_ADDRESSMODE_SHIFT)

enum D3DVS_ADRRESSMODE
{
    D3DVS_ADDRMODE_ABSOLUTE  = (0 << D3DVS_ADDRESSMODE_SHIFT),
    D3DVS_ADDRMODE_RELATIVE  = (1 << D3DVS_ADDRESSMODE_SHIFT),   // Relative to register A0
    D3DVS_ADDRMODE_FORCE_DWORD = 0x7fffffff, // force 32-bit size enum
};

// Source operand swizzle definitions
//
#define D3DVS_SWIZZLE_SHIFT     16
#define D3DVS_SWIZZLE_MASK      0x00FF0000

// The following bits define where to take component X:

#define D3DVS_X_X       (0 << D3DVS_SWIZZLE_SHIFT)
#define D3DVS_X_Y       (1 << D3DVS_SWIZZLE_SHIFT)
#define D3DVS_X_Z       (2 << D3DVS_SWIZZLE_SHIFT)
#define D3DVS_X_W       (3 << D3DVS_SWIZZLE_SHIFT)

// The following bits define where to take component Y:

#define D3DVS_Y_X       (0 << (D3DVS_SWIZZLE_SHIFT + 2))
#define D3DVS_Y_Y       (1 << (D3DVS_SWIZZLE_SHIFT + 2))
#define D3DVS_Y_Z       (2 << (D3DVS_SWIZZLE_SHIFT + 2))
#define D3DVS_Y_W       (3 << (D3DVS_SWIZZLE_SHIFT + 2))

// The following bits define where to take component Z:

#define D3DVS_Z_X       (0 << (D3DVS_SWIZZLE_SHIFT + 4))
#define D3DVS_Z_Y       (1 << (D3DVS_SWIZZLE_SHIFT + 4))
#define D3DVS_Z_Z       (2 << (D3DVS_SWIZZLE_SHIFT + 4))
#define D3DVS_Z_W       (3 << (D3DVS_SWIZZLE_SHIFT + 4))

// The following bits define where to take component W:

#define D3DVS_W_X       (0 << (D3DVS_SWIZZLE_SHIFT + 6))
#define D3DVS_W_Y       (1 << (D3DVS_SWIZZLE_SHIFT + 6))
#define D3DVS_W_Z       (2 << (D3DVS_SWIZZLE_SHIFT + 6))
#define D3DVS_W_W       (3 << (D3DVS_SWIZZLE_SHIFT + 6))

// Value when there is no swizzle (X is taken from X, Y is taken from Y,
// Z is taken from Z, W is taken from W
//
#define D3DVS_NOSWIZZLE (D3DVS_X_X | D3DVS_Y_Y | D3DVS_Z_Z | D3DVS_W_W)

// source parameter swizzle
#define D3DSP_SWIZZLE_SHIFT     16
#define D3DSP_SWIZZLE_MASK      0x00FF0000

#define D3DSP_NOSWIZZLE \
    ( (0 << (D3DSP_SWIZZLE_SHIFT + 0)) | \
      (1 << (D3DSP_SWIZZLE_SHIFT + 2)) | \
      (2 << (D3DSP_SWIZZLE_SHIFT + 4)) | \
      (3 << (D3DSP_SWIZZLE_SHIFT + 6)) )

// pixel-shader swizzle ops
#define D3DSP_REPLICATEALPHA \
    ( (3 << (D3DSP_SWIZZLE_SHIFT + 0)) | \
      (3 << (D3DSP_SWIZZLE_SHIFT + 2)) | \
      (3 << (D3DSP_SWIZZLE_SHIFT + 4)) | \
      (3 << (D3DSP_SWIZZLE_SHIFT + 6)) )

// source parameter modifiers
#define D3DSP_SRCMOD_SHIFT      24
#define D3DSP_SRCMOD_MASK       0x0F000000

typedef enum _D3DSHADER_PARAM_SRCMOD_TYPE
{
    D3DSPSM_NONE    = 0<<D3DSP_SRCMOD_SHIFT, // nop
    D3DSPSM_NEG     = 1<<D3DSP_SRCMOD_SHIFT, // negate
    D3DSPSM_BIAS    = 2<<D3DSP_SRCMOD_SHIFT, // bias
    D3DSPSM_BIASNEG = 3<<D3DSP_SRCMOD_SHIFT, // bias and negate
    D3DSPSM_SIGN    = 4<<D3DSP_SRCMOD_SHIFT, // sign
    D3DSPSM_SIGNNEG = 5<<D3DSP_SRCMOD_SHIFT, // sign and negate
    D3DSPSM_COMP    = 6<<D3DSP_SRCMOD_SHIFT, // complement
    D3DSPSM_SAT     = 7<<D3DSP_SRCMOD_SHIFT, // saturate

    D3DSPSM_FORCE_DWORD = 0x7fffffff,        // force 32-bit size enum
} D3DSHADER_PARAM_SRCMOD_TYPE;

// pixel shader version token
#define D3DPS_VERSION(_Major,_Minor) (0xFFFF0000|((_Major)<<8)|(_Minor))

// vertex shader version token
#define D3DVS_VERSION(_Major,_Minor) (0xFFFE0000|((_Major)<<8)|(_Minor))

// extract major/minor from version cap
#define D3DSHADER_VERSION_MAJOR(_Version) (((_Version)>>8)&0xFF)
#define D3DSHADER_VERSION_MINOR(_Version) (((_Version)>>0)&0xFF)

// destination/source parameter register type
#define D3DSI_COMMENTSIZE_SHIFT     16
#define D3DSI_COMMENTSIZE_MASK      0x7FFF0000
#define D3DSHADER_COMMENT(_DWordSize) \
    ((((_DWordSize)<<D3DSI_COMMENTSIZE_SHIFT)&D3DSI_COMMENTSIZE_MASK)|D3DSIO_COMMENT)

// pixel/vertex shader end token
#define D3DPS_END()  0x0000FFFF
#define D3DVS_END()  0x0000FFFF

//-------------------------------------------------------------------------
// D3D Vertex Shader Microcode Type values:
// --------------
//
// D3DSMT_VERTEXSHADER
//   An ordinary vertex shader.
//
// D3DSMT_READWRITE_VERTEXSHADER
//   A vertex shader that can write to the constant registers.
//
// D3DSMT_VERTEXSTATESHADER
//   A vertex state shader.
//
//-------------------------------------------------------------------------

#define D3DSMT_VERTEXSHADER              1
#define D3DSMT_READWRITE_VERTEXSHADER    2
#define D3DSMT_VERTEXSTATESHADER         3

//---------------------------------------------------------------------

// High order surfaces
//
typedef enum _D3DBASISTYPE
{
   D3DBASIS_BEZIER      = 0,
   D3DBASIS_BSPLINE     = 1,
   D3DBASIS_INTERPOLATE = 2,
   D3DBASIS_FORCE_DWORD = 0x7fffffff,
} D3DBASISTYPE;

typedef enum _D3DORDERTYPE
{
   D3DORDER_LINEAR      = 1,
   D3DORDER_CUBIC       = 3,
   D3DORDER_QUINTIC     = 5,
   D3DORDER_FORCE_DWORD = 0x7fffffff,
} D3DORDERTYPE;

typedef enum _D3DPATCHEDGESTYLE
{
   D3DPATCHEDGE_DISCRETE    = 0,
   D3DPATCHEDGE_CONTINUOUS  = 1,
   D3DPATCHEDGE_FORCE_DWORD = 0x7fffffff,
} D3DPATCHEDGESTYLE;

typedef enum _D3DSTATEBLOCKTYPE
{
    D3DSBT_ALL           = 1, // capture all state
    D3DSBT_PIXELSTATE    = 2, // capture pixel state
    D3DSBT_VERTEXSTATE   = 3, // capture vertex state
    D3DSBT_FORCE_DWORD   = 0x7fffffff,
} D3DSTATEBLOCKTYPE;

// The D3DVERTEXBLENDFLAGS type is used with D3DRS_VERTEXBLEND state.
//
typedef enum _D3DVERTEXBLENDFLAGS
{
    D3DVBF_DISABLE           = 0,     // Disable vertex blending
    D3DVBF_1WEIGHTS          = 1,     // 2 matrix blending
    D3DVBF_2WEIGHTS          = 3,     // 3 matrix blending
    D3DVBF_3WEIGHTS          = 5,     // 4 matrix blending
    D3DVBF_2WEIGHTS2MATRICES = 2,     // Xbox extension
    D3DVBF_3WEIGHTS3MATRICES = 4,     // Xbox extension
    D3DVBF_4WEIGHTS4MATRICES = 6,     // Xbox extension

    D3DVBF_MAX               = 7,
    D3DVBF_FORCE_DWORD       = 0x7fffffff, // force 32-bit size enum
} D3DVERTEXBLENDFLAGS;

typedef enum _D3DTEXTURETRANSFORMFLAGS 
{
    D3DTTFF_DISABLE         = 0,    // texture coordinates are passed directly
    D3DTTFF_COUNT1          = 1,    // rasterizer should expect 1-D texture coords
    D3DTTFF_COUNT2          = 2,    // rasterizer should expect 2-D texture coords
    D3DTTFF_COUNT3          = 3,    // rasterizer should expect 3-D texture coords
    D3DTTFF_COUNT4          = 4,    // rasterizer should expect 4-D texture coords
    D3DTTFF_PROJECTED       = 256,  // texcoords to be divided by COUNTth element
    D3DTTFF_FORCE_DWORD     = 0x7fffffff,
} D3DTEXTURETRANSFORMFLAGS;

// Macros to set texture coordinate format bits in the FVF id

#define D3DFVF_TEXTUREFORMAT2 0         // Two floating point values
#define D3DFVF_TEXTUREFORMAT1 3         // One floating point value
#define D3DFVF_TEXTUREFORMAT3 1         // Three floating point values
#define D3DFVF_TEXTUREFORMAT4 2         // Four floating point values

#define D3DFVF_TEXCOORDSIZE3(CoordIndex) (D3DFVF_TEXTUREFORMAT3 << (CoordIndex*2 + 16))
#define D3DFVF_TEXCOORDSIZE2(CoordIndex) (D3DFVF_TEXTUREFORMAT2)
#define D3DFVF_TEXCOORDSIZE4(CoordIndex) (D3DFVF_TEXTUREFORMAT4 << (CoordIndex*2 + 16))
#define D3DFVF_TEXCOORDSIZE1(CoordIndex) (D3DFVF_TEXTUREFORMAT1 << (CoordIndex*2 + 16))


//---------------------------------------------------------------------

/* Direct3D8 Device types */
typedef enum _D3DDEVTYPE
{
    D3DDEVTYPE_HAL         = 1,
    D3DDEVTYPE_REF         = 2,
    D3DDEVTYPE_SW          = 3,

    D3DDEVTYPE_FORCE_DWORD  = 0x7fffffff
} D3DDEVTYPE;

/* AntiAliasing buffer types */

typedef DWORD D3DMULTISAMPLE_TYPE;

#define D3DMULTISAMPLE_NONE                                      0x0011

// Number of samples, sample type, and filter (Xbox extensions):
//
#define D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR              0x1021
#define D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX            0x1121
#define D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR   0x2021
#define D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR     0x2012
                                                              
#define D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_LINEAR              0x1022
#define D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN            0x1222
#define D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_LINEAR              0x2022
#define D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN            0x2222
                                                              
#define D3DMULTISAMPLE_9_SAMPLES_MULTISAMPLE_GAUSSIAN            0x1233
#define D3DMULTISAMPLE_9_SAMPLES_SUPERSAMPLE_GAUSSIAN            0x2233
                                                                  
// Format of the pre-filter (big) color buffer (Xbox extensions):
//                                                          
#define D3DMULTISAMPLE_PREFILTER_FORMAT_DEFAULT                  0x00000 
#define D3DMULTISAMPLE_PREFILTER_FORMAT_X1R5G5B5                 0x10000 
#define D3DMULTISAMPLE_PREFILTER_FORMAT_R5G6B5                   0x20000 
#define D3DMULTISAMPLE_PREFILTER_FORMAT_X8R8G8B8                 0x30000 
#define D3DMULTISAMPLE_PREFILTER_FORMAT_A8R8G8B8                 0x40000 

// Defaults:
//
#define D3DMULTISAMPLE_2_SAMPLES D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX
#define D3DMULTISAMPLE_4_SAMPLES D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN
#define D3DMULTISAMPLE_9_SAMPLES D3DMULTISAMPLE_9_SAMPLES_SUPERSAMPLE_GAUSSIAN

/* Types for D3DRS_MULTISAMPLEMODE and D3DRS_MULTISAMPLERENDERTARGETMODE */
typedef enum _D3DMULTISAMPLEMODE
{
    D3DMULTISAMPLEMODE_1X                                   = 0,
    D3DMULTISAMPLEMODE_2X                                   = 1,
    D3DMULTISAMPLEMODE_4X                                   = 2,

    D3DMULTISAMPLEMODE_FORCE_DWORD                          = 0x7fffffff
} D3DMULTISAMPLETYPE;


/* Formats
 * Most of these names have the following convention:
 *      A = Alpha
 *      R = Red
 *      G = Green
 *      B = Blue
 *      X = Unused Bits
 *      P = Palette
 *      L = Luminance
 *      U = dU coordinate for BumpMap
 *      V = dV coordinate for BumpMap
 *      S = Stencil
 *      D = Depth (e.g. Z or W buffer)
 *
 *      Further, the order of the pieces are from MSB first; hence
 *      D3DFMT_A8L8 indicates that the high byte of this two byte
 *      format is alpha.
 *
 *      D16 indicates:
 *           - An integer 16-bit value.
 *           - An app-lockable surface.
 *
 *      All Depth/Stencil formats except D3DFMT_D16_LOCKABLE indicate:
 *          - no particular bit ordering per pixel, and
 *          - are not app lockable, and
 *          - the driver is allowed to consume more than the indicated
 *            number of bits per Depth channel (but not Stencil channel).
 */

// DOC: The numerical values for these formats have changed from D3D8
//    : to make the mapping to the NV internal format value easier.
//    : Most noteably is that D3DFMT_UNKNOWN is no longer zero.
//
typedef enum _D3DFORMAT
{
    D3DFMT_UNKNOWN              = 0xFFFFFFFF,

    /* Swizzled formats */

    D3DFMT_A8R8G8B8             = 0x00000006,
    D3DFMT_X8R8G8B8             = 0x00000007,
    D3DFMT_R5G6B5               = 0x00000005,
    D3DFMT_R6G5B5               = 0x00000027,
    D3DFMT_X1R5G5B5             = 0x00000003,
    D3DFMT_A1R5G5B5             = 0x00000002,
    D3DFMT_A4R4G4B4             = 0x00000004,
    D3DFMT_A8                   = 0x00000019,
    D3DFMT_A8B8G8R8             = 0x0000003A,   
    D3DFMT_B8G8R8A8             = 0x0000003B,   
    D3DFMT_R4G4B4A4             = 0x00000039,   
    D3DFMT_R5G5B5A1             = 0x00000038,   
    D3DFMT_R8G8B8A8             = 0x0000003C,   
    D3DFMT_R8B8                 = 0x00000029,   
    D3DFMT_G8B8                 = 0x00000028,   

    D3DFMT_P8                   = 0x0000000B,

    D3DFMT_L8                   = 0x00000000,
    D3DFMT_A8L8                 = 0x0000001A,
    D3DFMT_AL8                  = 0x00000001,   
    D3DFMT_L16                  = 0x00000032,   

    D3DFMT_V8U8                 = 0x00000028,
    D3DFMT_L6V5U5               = 0x00000027,
    D3DFMT_X8L8V8U8             = 0x00000007,
    D3DFMT_Q8W8V8U8             = 0x0000003A,
    D3DFMT_V16U16               = 0x00000033,

    D3DFMT_D16_LOCKABLE         = 0x0000002C,
    D3DFMT_D16                  = 0x0000002C,
    D3DFMT_D24S8                = 0x0000002A,
    D3DFMT_F16                  = 0x0000002D,   
    D3DFMT_F24S8                = 0x0000002B,

    /* YUV formats */

    D3DFMT_YUY2                 = 0x00000024,
    D3DFMT_UYVY                 = 0x00000025,

    /* Compressed formats */

    D3DFMT_DXT1                 = 0x0000000C,
    D3DFMT_DXT2                 = 0x0000000E,
    D3DFMT_DXT3                 = 0x0000000E,
    D3DFMT_DXT4                 = 0x0000000F,
    D3DFMT_DXT5                 = 0x0000000F,

    /* Linear formats */

    D3DFMT_LIN_A1R5G5B5         = 0x00000010,   
    D3DFMT_LIN_A4R4G4B4         = 0x0000001D,   
    D3DFMT_LIN_A8               = 0x0000001F,   
    D3DFMT_LIN_A8B8G8R8         = 0x0000003F,   
    D3DFMT_LIN_A8R8G8B8         = 0x00000012,   
    D3DFMT_LIN_B8G8R8A8         = 0x00000040,   
    D3DFMT_LIN_G8B8             = 0x00000017,   
    D3DFMT_LIN_R4G4B4A4         = 0x0000003E,   
    D3DFMT_LIN_R5G5B5A1         = 0x0000003D,   
    D3DFMT_LIN_R5G6B5           = 0x00000011,   
    D3DFMT_LIN_R6G5B5           = 0x00000037,   
    D3DFMT_LIN_R8B8             = 0x00000016,   
    D3DFMT_LIN_R8G8B8A8         = 0x00000041,   
    D3DFMT_LIN_X1R5G5B5         = 0x0000001C,   
    D3DFMT_LIN_X8R8G8B8         = 0x0000001E,   

    D3DFMT_LIN_A8L8             = 0x00000020,   
    D3DFMT_LIN_AL8              = 0x0000001B,   
    D3DFMT_LIN_L16              = 0x00000035,   
    D3DFMT_LIN_L8               = 0x00000013,   

    D3DFMT_LIN_V16U16           = 0x00000036,
    D3DFMT_LIN_V8U8             = 0x00000017,
    D3DFMT_LIN_L6V5U5           = 0x00000037,
    D3DFMT_LIN_X8L8V8U8         = 0x0000001E,
    D3DFMT_LIN_Q8W8V8U8         = 0x00000012,

    D3DFMT_LIN_D24S8            = 0x0000002E,   
    D3DFMT_LIN_F24S8            = 0x0000002F,   
    D3DFMT_LIN_D16              = 0x00000030,   
    D3DFMT_LIN_F16              = 0x00000031,   

    D3DFMT_VERTEXDATA           = 100,
    D3DFMT_INDEX16              = 101,

    D3DFMT_FORCE_DWORD          =0x7fffffff
} D3DFORMAT;

/* Display mode flags */

#define D3DPRESENTFLAG_LOCKABLE_BACKBUFFER      0x00000001
#define D3DPRESENTFLAG_WIDESCREEN               0x00000010
#define D3DPRESENTFLAG_INTERLACED               0x00000020
#define D3DPRESENTFLAG_PROGRESSIVE              0x00000040
#define D3DPRESENTFLAG_FIELD                    0x00000080
#define D3DPRESENTFLAG_10X11PIXELASPECTRATIO    0x00000100

/* Display Modes */
typedef struct _D3DDISPLAYMODE
{
    UINT            Width;
    UINT            Height;
    UINT            RefreshRate;
    DWORD           Flags;
    D3DFORMAT       Format;
} D3DDISPLAYMODE;

/* Creation Parameters */
typedef struct _D3DDEVICE_CREATION_PARAMETERS
{
    UINT            AdapterOrdinal;
    D3DDEVTYPE      DeviceType;
    HWND            hFocusWindow;
    DWORD           BehaviorFlags;
} D3DDEVICE_CREATION_PARAMETERS;


/* SwapEffects */
typedef enum _D3DSWAPEFFECT
{
    D3DSWAPEFFECT_DISCARD           = 1,
    D3DSWAPEFFECT_FLIP              = 2,
    D3DSWAPEFFECT_COPY              = 3,
    D3DSWAPEFFECT_COPY_VSYNC        = 4,

    D3DSWAPEFFECT_FORCE_DWORD       = 0x7fffffff
} D3DSWAPEFFECT;

/* Swap flags (Xbox extension) */
#define D3DSWAP_COPY                0x00000001L
#define D3DSWAP_BYPASSCOPY          0x00000002L
#define D3DSWAP_FINISH              0x00000004L

#define D3DSWAP_DEFAULT             0x00000000L

/* Insert Callback (Xbox extension) */
typedef enum _D3DCALLBACKTYPE
{
    D3DCALLBACK_READ                = 0,
    D3DCALLBACK_WRITE               = 1,

    D3DCALLBACKTYPE_FORCE_DWORD     = 0x7fffffff
} D3DCALLBACKTYPE;

/* VBlank data (Xbox extension) */
#define D3DVBLANK_SWAPDONE          0x00000001L
#define D3DVBLANK_SWAPMISSED        0x00000002L

typedef struct _D3DVBLANKDATA
{
    DWORD           VBlank;
    DWORD           Swap;
    DWORD           Flags;
} D3DVBLANKDATA;

/* Swap data (Xbox extension) */
typedef struct _D3DSWAPDATA
{
    DWORD           Swap;
    DWORD           SwapVBlank;
    DWORD           MissedVBlanks;
    DWORD           TimeUntilSwapVBlank;
    DWORD           TimeBetweenSwapVBlanks;
} D3DSWAPDATA;

/* Pool types */

// DOC: All parameters typed as D3DPOOL will be ignored.  Change the type from an enum
//  : to a DWORD so developers can cheat and just pass '0' for this value.

typedef DWORD D3DPOOL;

#define D3DPOOL_DEFAULT             0
#define D3DPOOL_MANAGED             1
#define D3DPOOL_SYSTEMMEM           2

/* RefreshRate pre-defines */
#define D3DPRESENT_RATE_DEFAULT         0x00000000
#define D3DPRESENT_RATE_UNLIMITED       0x00000000


/* Reset and CreateDevice Parameters */
typedef struct _D3DPRESENT_PARAMETERS_
{
    UINT                BackBufferWidth;
    UINT                BackBufferHeight;
    D3DFORMAT           BackBufferFormat;
    UINT                BackBufferCount;
    D3DMULTISAMPLE_TYPE MultiSampleType;
    D3DSWAPEFFECT       SwapEffect;
    HWND                hDeviceWindow;
    BOOL                Windowed;
    BOOL                EnableAutoDepthStencil;
    D3DFORMAT           AutoDepthStencilFormat;
    DWORD               Flags;
    UINT                FullScreen_RefreshRateInHz; 
    UINT                FullScreen_PresentationInterval;
    D3DSurface         *BufferSurfaces[3];
    D3DSurface         *DepthStencilSurface;

} D3DPRESENT_PARAMETERS;

/* Gamma Ramp: Xbox changes WORD values to BYTE */

typedef struct _D3DGAMMARAMP
{
    BYTE                red  [256];
    BYTE                green[256];
    BYTE                blue [256];
} D3DGAMMARAMP;

/* Back buffer types */
typedef DWORD D3DBACKBUFFER_TYPE;

#define D3DBACKBUFFER_TYPE_MONO   0


/* Types */
typedef enum _D3DRESOURCETYPE 
{
    D3DRTYPE_NONE                   =  0,
    D3DRTYPE_SURFACE                =  1,
    D3DRTYPE_VOLUME                 =  2,
    D3DRTYPE_TEXTURE                =  3,
    D3DRTYPE_VOLUMETEXTURE          =  4,
    D3DRTYPE_CUBETEXTURE            =  5,
    D3DRTYPE_VERTEXBUFFER           =  6,
    D3DRTYPE_INDEXBUFFER            =  7,
    D3DRTYPE_PUSHBUFFER             =  8,
    D3DRTYPE_PALETTE                =  9,
    D3DRTYPE_FIXUP                  =  10,

    D3DRTYPE_FORCE_DWORD            = 0x7fffffff
} D3DRESOURCETYPE;

/* Locations */

// Enumeration used for memory movement (Xbox extension)
//
typedef enum _D3DMEMORY 
{
    D3DMEM_AGP                      = 0,
    D3DMEM_VIDEO                    = 1
} D3DMEMORY;

/* Usages */
#define D3DUSAGE_RENDERTARGET           (0x00000001L)
#define D3DUSAGE_DEPTHSTENCIL           (0x00000002L)

/* Usages for Vertex/Index buffers */
#define D3DUSAGE_WRITEONLY              (0x00000008L)
#define D3DUSAGE_POINTS                 (0x00000040L)
#define D3DUSAGE_RTPATCHES              (0x00000080L)
#define D3DUSAGE_DYNAMIC                (0x00000200L)

/* Usages for CreateVertexShader */
#define D3DUSAGE_PERSISTENTDIFFUSE      (0x00000400L)   // Xbox extension
#define D3DUSAGE_PERSISTENTSPECULAR     (0x00000800L)   // Xbox extension
#define D3DUSAGE_PERSISTENTBACKDIFFUSE  (0x00001000L)   // Xbox extension
#define D3DUSAGE_PERSISTENTBACKSPECULAR (0x00002000L)   // Xbox extension

/* Usages for CreateTexture/CreateImageSurface */
#define D3DUSAGE_BORDERSOURCE_COLOR     (0x00000000L)   // Xbox extension
#define D3DUSAGE_BORDERSOURCE_TEXTURE   (0x00010000L)   // Xbox extension


/* CubeMap Face identifiers */
typedef enum _D3DCUBEMAP_FACES
{
    D3DCUBEMAP_FACE_POSITIVE_X     = 0,
    D3DCUBEMAP_FACE_NEGATIVE_X     = 1,
    D3DCUBEMAP_FACE_POSITIVE_Y     = 2,
    D3DCUBEMAP_FACE_NEGATIVE_Y     = 3,
    D3DCUBEMAP_FACE_POSITIVE_Z     = 4,
    D3DCUBEMAP_FACE_NEGATIVE_Z     = 5,

    D3DCUBEMAP_FACE_FORCE_DWORD    = 0x7fffffff
} D3DCUBEMAP_FACES;


/* Lock flags */

#define D3DLOCK_NOFLUSH             0x00000010L // Xbox extension
#define D3DLOCK_NOOVERWRITE         0x00000020L 
#define D3DLOCK_TILED               0x00000040L // Xbox extension
#define D3DLOCK_READONLY            0x00000080L

// D3DLOCK_NOSYSLOCK not supported on Xbox
// D3DLOCK_NO_DIRTY_UPDATE not supported on Xbox
// D3DLOCK_DISCARD not supported on Xbox 
//
//     (NOTE: The lack of D3DLOCK_DISCARD support can cause significant 
//      performance degradation for the unwary.  See the documentation
//      for notes on using IsBusy or fences in order to manage your own
//      pool of temporary vertex buffers when generating vertex data
//      dynamically.)

/* Vertex Buffer Description */
typedef struct _D3DVERTEXBUFFER_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;

} D3DVERTEXBUFFER_DESC;

/* Index Buffer Description */
typedef struct _D3DINDEXBUFFER_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
} D3DINDEXBUFFER_DESC;


/* Surface Description */
typedef struct _D3DSURFACE_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
    DWORD               Usage;
    UINT                Size;

    D3DMULTISAMPLE_TYPE MultiSampleType;
    UINT                Width;
    UINT                Height;
} D3DSURFACE_DESC;

typedef struct _D3DVOLUME_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
    DWORD               Usage;
    UINT                Size;

    UINT                Width;
    UINT                Height;
    UINT                Depth;
} D3DVOLUME_DESC;

/* Structure for LockRect */
typedef struct _D3DLOCKED_RECT
{
    INT                 Pitch;
    void*               pBits;
} D3DLOCKED_RECT;

/* Structures for LockBox */
typedef struct _D3DBOX
{
    UINT                Left;
    UINT                Top;
    UINT                Right;
    UINT                Bottom;
    UINT                Front;
    UINT                Back;
} D3DBOX;

typedef struct _D3DLOCKED_BOX
{
    INT                 RowPitch;
    INT                 SlicePitch;
    void*               pBits;
} D3DLOCKED_BOX;

/* Structures for high order primitives */
typedef struct _D3DRECTPATCH_INFO
{
    UINT                StartVertexOffsetWidth;
    UINT                StartVertexOffsetHeight;
    UINT                Width;
    UINT                Height;
    UINT                Stride;
    D3DBASISTYPE        Basis;
    D3DORDERTYPE        Order;
} D3DRECTPATCH_INFO;

typedef struct _D3DTRIPATCH_INFO
{
    UINT                StartVertexOffset;
    UINT                NumVertices;
    D3DBASISTYPE        Basis;
    D3DORDERTYPE        Order;
} D3DTRIPATCH_INFO;

/* Adapter Identifier */
#define MAX_DEVICE_IDENTIFIER_STRING        512
typedef struct _D3DADAPTER_IDENTIFIER8
{
    char            Driver[MAX_DEVICE_IDENTIFIER_STRING];
    char            Description[MAX_DEVICE_IDENTIFIER_STRING];

#ifdef _WIN32
    LARGE_INTEGER   DriverVersion;            /* Defined for 32 bit components */
#else
    DWORD           DriverVersionLowPart;     /* Defined for 16 bit driver components */
    DWORD           DriverVersionHighPart;
#endif

    DWORD           VendorId;
    DWORD           DeviceId;
    DWORD           SubSysId;
    DWORD           Revision;

    GUID            DeviceIdentifier;

    DWORD           WHQLLevel;

} D3DADAPTER_IDENTIFIER8;


/* Raster Status structure returned by GetRasterStatus */
typedef struct _D3DRASTER_STATUS
{
    BOOL            InVBlank;
    UINT            ScanLine;
} D3DRASTER_STATUS;


/* Field Type enum defines possible values for a display field */
typedef enum _D3DFIELDTYPE                      // Xbox extension
{                    
    D3DFIELD_ODD            = 1,
    D3DFIELD_EVEN           = 2,
    D3DFIELD_PROGRESSIVE    = 3,
    D3DFIELD_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
} D3DFIELDTYPE;


/* Field Status structure is returned by GetDisplayFieldStatus */
typedef struct _D3DFIELD_STATUS                 // Xbox extension
{
    D3DFIELDTYPE   Field;
    UINT           VBlankCount;
} D3DFIELD_STATUS;


/* SetVertexInput struct */
typedef struct _D3DSTREAM_INPUT                 // Xbox extension
{
    D3DVertexBuffer    *VertexBuffer;
    UINT                Stride;
    UINT                Offset;
} D3DSTREAM_INPUT;


/* Maximum number of scissors rectangles */     
#define D3DSCISSORS_MAX             8

/* D3DTILE constants */
#define D3DTILE_MAXTILES            8
#define D3DTILE_MAXTAGS             76800
#define D3DTILE_TAGSIZE             64
#define D3DTILE_ALIGNMENT           0x4000

/* D3DTILE macro for calculating the end tag for a Z-compressed tile */
#define D3DTILE_ZENDTAG(pTile) ((((pTile)->ZStartTag + ((pTile)->Size / D3DTILE_TAGSIZE)) + 255) & ~255)

/* D3DTILE Flags */
#define D3DTILE_FLAGS_ZBUFFER       0x00000001
#define D3DTILE_FLAGS_ZCOMPRESS     0x80000000
#define D3DTILE_FLAGS_Z32BITS       0x04000000
#define D3DTILE_FLAGS_Z16BITS       0x00000000

/* D3DTILE Pitch values */
#define D3DTILE_PITCH_0200          0x0200
#define D3DTILE_PITCH_0300          0x0300
#define D3DTILE_PITCH_0400          0x0400
#define D3DTILE_PITCH_0500          0x0500
#define D3DTILE_PITCH_0600          0x0600
#define D3DTILE_PITCH_0700          0x0700
#define D3DTILE_PITCH_0800          0x0800
#define D3DTILE_PITCH_0A00          0x0A00
#define D3DTILE_PITCH_0C00          0x0C00
#define D3DTILE_PITCH_0E00          0x0E00
#define D3DTILE_PITCH_1000          0x1000
#define D3DTILE_PITCH_1400          0x1400
#define D3DTILE_PITCH_1800          0x1800
#define D3DTILE_PITCH_1C00          0x1C00
#define D3DTILE_PITCH_2000          0x2000
#define D3DTILE_PITCH_2800          0x2800
#define D3DTILE_PITCH_3000          0x3000
#define D3DTILE_PITCH_3800          0x3800
#define D3DTILE_PITCH_4000          0x4000
#define D3DTILE_PITCH_5000          0x5000
#define D3DTILE_PITCH_6000          0x6000
#define D3DTILE_PITCH_7000          0x7000
#define D3DTILE_PITCH_8000          0x8000
#define D3DTILE_PITCH_A000          0xA000
#define D3DTILE_PITCH_C000          0xC000
#define D3DTILE_PITCH_E000          0xE000

/* SetTile struct */
typedef struct _D3DTILE                         // Xbox extension
{                   
    DWORD   Flags;
    void*   pMemory;
    DWORD   Size;
    DWORD   Pitch;
    DWORD   ZStartTag; 
    DWORD   ZOffset;
} D3DTILE;

/* CopyRectsState Operation values */
typedef enum _D3DCOPYRECTOPERATION
{
    D3DCOPYRECT_SRCCOPY_AND         = 0,
    D3DCOPYRECT_ROP_AND             = 1,
    D3DCOPYRECT_BLEND_AND           = 2,
    D3DCOPYRECT_SRCCOPY             = 3,
    D3DCOPYRECT_SRCCOPY_PREMULT     = 4,
    D3DCOPYRECT_BLEND_PREMULT       = 5,
    D3DCOPYRECT_FORCE_DWORD         = 0x7fffffff, /* force 32-bit size enum */
} D3DCOPYRECTOPERATION;

/* CopyRectsState Color Format values */
typedef enum _D3DCOPYRECTCOLORFORMAT
{
    D3DCOPYRECT_COLOR_FORMAT_DEFAULT                 = 0,
    D3DCOPYRECT_COLOR_FORMAT_Y8                      = 1,
    D3DCOPYRECT_COLOR_FORMAT_X1R5G5B5_Z1R5G5B5       = 2,
    D3DCOPYRECT_COLOR_FORMAT_X1R5G5B5_O1R5G5B5       = 3,
    D3DCOPYRECT_COLOR_FORMAT_R5G6B5                  = 4,
    D3DCOPYRECT_COLOR_FORMAT_Y16                     = 5,
    D3DCOPYRECT_COLOR_FORMAT_X8R8G8B8_Z8R8G8B8       = 6,
    D3DCOPYRECT_COLOR_FORMAT_X8R8G8B8_O8R8G8B8       = 7,
    D3DCOPYRECT_COLOR_FORMAT_X1A7R8G8B8_Z1A7R8G8B8   = 8,
    D3DCOPYRECT_COLOR_FORMAT_X1A7R8G8B8_O1A7R8G8B8   = 9,
    D3DCOPYRECT_COLOR_FORMAT_A8R8G8B8                = 10,
    D3DCOPYRECT_COLOR_FORMAT_Y32                     = 11,
    D3DCOPYRECT_COLOR_FORMAT_FORCE_DWORD             = 0x7fffffff, /* force 32-bit size enum */
} D3DCOPYRECTCOLORFORMAT;

/* CopyRectsState struct */
typedef struct _D3DCOPYRECTSTATE                // Xbox extension
{
    D3DCOPYRECTCOLORFORMAT ColorFormat;
    D3DCOPYRECTOPERATION Operation;

    BOOL ColorKeyEnable;
    DWORD ColorKeyValue;

    // D3DCOPYRECT_BLEND_AND alpha value 
    // The VALUE_FRACTION bits (30:21) contain the 10 bit unsigned fraction of the alpha value.
    // The VALUE bits (31:31) contain the 1 bit signed integer of the alpha value.
    DWORD BlendAlpha;

    // D3DCOPYRECT_*_PREMULT alpha value
    // Contains an alpha value for all four channels.
    DWORD PremultAlpha;

    // Clipping Rect
    DWORD ClippingPoint;    // y_x S16_S16
    DWORD ClippingSize;     // height_width U16_U16

} D3DCOPYRECTSTATE;

/* CopyRectRopState struct */
typedef struct _D3DCOPYRECTROPSTATE             // Xbox extension
{
    DWORD Rop;              // Ternary raster operation.
                            //   DSTINVERT:0x55, SRCCOPY:0xCC,
                            //   SRCPAINT:0xEE, SRCINVERT:0x66,
                            //   ...

    DWORD Shape;            // 0:8X_8Y, 1:64X_1Y, 2:1X_64Y
    DWORD PatternSelect;    // 1:monochrome, 2:color

    DWORD MonoColor0;       // Color to use when bit is "0"
    DWORD MonoColor1;       // Color to use when bit is "1" 

    DWORD MonoPattern0;     // 8x8 = 64 bit pattern
    DWORD MonoPattern1;     //

    CONST DWORD *ColorPattern;  // Color Pattern used if PatternSelect == color
                                // 32-bit: Array of 64 DWORDS
                                // 16-bit: Array of 32 DWORDS

} D3DCOPYRECTROPSTATE;

/*----------------------------------------------
/* Pixel Shader Binary Format
/*----------------------------------------------

/*---------------------------------------------------*/
/*  This structure holds all of the state necessary  */
/*  to define an Xbox Pixel Shader.  It is the       */
/*  structure generated when a pixel shader is       */
/*  assembled.  Each member of this structure        */
/*  corresponds to a D3D Renderstate that can be     */
/*  set at any time using the SetRenderState()       */
/*  method.                                          */
/*  The members of this structure have been ordered  */
/*  to enable the most efficient hardware load       */
/*  possible.                                        */
/*---------------------------------------------------*/

typedef struct _D3DPixelShaderDef
{
   DWORD    PSAlphaInputs[8];          // Alpha inputs for each stage
   DWORD    PSFinalCombinerInputsABCD; // Final combiner inputs
   DWORD    PSFinalCombinerInputsEFG;  // Final combiner inputs (continued)
   DWORD    PSConstant0[8];            // C0 for each stage
   DWORD    PSConstant1[8];            // C1 for each stage
   DWORD    PSAlphaOutputs[8];         // Alpha output for each stage
   DWORD    PSRGBInputs[8];            // RGB inputs for each stage
   DWORD    PSCompareMode;             // Compare modes for clipplane texture mode
   DWORD    PSFinalCombinerConstant0;  // C0 in final combiner
   DWORD    PSFinalCombinerConstant1;  // C1 in final combiner
   DWORD    PSRGBOutputs[8];           // Stage 0 RGB outputs
   DWORD    PSCombinerCount;           // Active combiner count (Stages 0-7)
   DWORD    PSTextureModes;            // Texture addressing modes
   DWORD    PSDotMapping;              // Input mapping for dot product modes
   DWORD    PSInputTexture;            // Texture source for some texture modes
   DWORD    PSC0Mapping;               // Mapping of c0 regs to D3D constants
   DWORD    PSC1Mapping;               // Mapping of c1 regs to D3D constants
   DWORD    PSFinalCombinerConstants;  // Final combiner constant mapping
} D3DPIXELSHADERDEF;

/*---------------------------------------------------------------------------*/
/*  Texture configuration - The following members of the D3DPixelShaderDef   */
/*  structure define the addressing modes of each of the four texture stages:*/
/*      PSTextureModes                                                       */
/*      PSDotMapping                                                         */
/*      PSInputTexture                                                       */
/*      PSCompareMode                                                        */
/*---------------------------------------------------------------------------*/

// =========================================================================================================
// PSTextureModes
// --------.--------.--------.---xxxxx stage0
// --------.--------.------xx.xxx----- stage1
// --------.--------.-xxxxx--.-------- stage2
// --------.----xxxx.x-------.-------- stage3

#define PS_TEXTUREMODES(t0,t1,t2,t3) (((t3)<<15)|((t2)<<10)|((t1)<<5)|(t0))

/*
Texture modes:
NONE           :stage inactive
PROJECT2D      :argb = texture(s/q, t/q)
PROJECT3D      :argb = texture(s/q, t/q, r/q)
CUBEMAP        :argb = cubemap(s,t,r)
PASSTHRU       :argb = s,t,r,q
CLIPPLANE      :pixel not drawn if s,t,r, or q < 0.  PSCompareMode affects comparison
BUMPENVMAP     :argb=texture(s+mat00*src.r+mat01*src.g,
                             t+mat10*src.r+mat11*src.g)
                mat00 set via D3DTSS_BUMPENVMAT00, etc.
BUMPENVMAP_LUM :argb=texture(s+mat00*src.r+mat01*src.g, 
                             t+mat10*src.r+mat11*src.g) * (lum_scale*src.b + lum_bias)
                lum_scale set by D3DTSS_BUMPENVLSCALE
                lum_bias set by D3DTSS_BUMPENVLOFFSET
                mat00 set via D3DTSS_BUMPENVMAT00, etc.
BRDF           :argb = texture(eyeSigma, lightSigma, dPhi)
                       eyeSigma = Sigma of eye vector in spherical coordinates
                       lightSigma = Sigma of light vector in spherical coordinates
                       dPhi = Phi of eye - Phi of light
DOT_ST         :argb = texture(<DotResult of stage-1>, (s,t,r).(src.r,src.g,src.b))
DOT_ZW         :frag depth = (<DotResult of stage-1>/((s,t,r).(src.r,src.g,src.b))
DOT_RFLCT_DIFF :n = (<DotResult of stage-1>,(s,t,r).(src.r,src.g,src.b),<DotResult of stage+1>)
                argb = cubemap(n)
DOT_RFLCT_SPEC :n = (<DotResult of stage-2>,<DotResult of stage-1>,(s,t,r).(src.r,src.g,src.b))
                r = 2*n*(n.e)/(n.n) - e where e is eye vector built from q coord of each stage
                argb = cubemap(r)
DOT_STR_3D     :argb=texture((<DotResult of stage-2>,<DotResult of stage-1>,(s,t,r).(src.r,src.g,src.b)))
DOT_STR_CUBE   :argb=cubemap((<DotResult of stage-2>,<DotResult of stage-1>,(s,t,r).(src.r,src.g,src.b)))
DEPENDENT_AR   :argb = texture(src.a, src.r) 
DEPENDENT_GB   :argb = texture(src.g, src.b)
DOTPRODUCT     :argb = (s,t,r).(src.r,src.g,src.b)
DOT_RFLCT_SPEC_CONST :n = (<DotResult of stage-2>,<DotResult of stage-1>,(s,t,r).(src.r,src.g,src.b))
                r = 2*n*(n.e)/(n.n) - e where e is eye vector set via SetEyeVector()
                argb = cubemap(r)
*/

enum PS_TEXTUREMODES
{                                 // valid in stage 0 1 2 3
    PS_TEXTUREMODES_NONE=                 0x00L, // * * * *
    PS_TEXTUREMODES_PROJECT2D=            0x01L, // * * * *
    PS_TEXTUREMODES_PROJECT3D=            0x02L, // * * * *
    PS_TEXTUREMODES_CUBEMAP=              0x03L, // * * * *
    PS_TEXTUREMODES_PASSTHRU=             0x04L, // * * * *
    PS_TEXTUREMODES_CLIPPLANE=            0x05L, // * * * *
    PS_TEXTUREMODES_BUMPENVMAP=           0x06L, // - * * *
    PS_TEXTUREMODES_BUMPENVMAP_LUM=       0x07L, // - * * *
    PS_TEXTUREMODES_BRDF=                 0x08L, // - - * *
    PS_TEXTUREMODES_DOT_ST=               0x09L, // - - * *
    PS_TEXTUREMODES_DOT_ZW=               0x0aL, // - - * *
    PS_TEXTUREMODES_DOT_RFLCT_DIFF=       0x0bL, // - - * -
    PS_TEXTUREMODES_DOT_RFLCT_SPEC=       0x0cL, // - - - *
    PS_TEXTUREMODES_DOT_STR_3D=           0x0dL, // - - - *
    PS_TEXTUREMODES_DOT_STR_CUBE=         0x0eL, // - - - *
    PS_TEXTUREMODES_DPNDNT_AR=            0x0fL, // - * * *
    PS_TEXTUREMODES_DPNDNT_GB=            0x10L, // - * * *
    PS_TEXTUREMODES_DOTPRODUCT=           0x11L, // - * * -
    PS_TEXTUREMODES_DOT_RFLCT_SPEC_CONST= 0x12L, // - - - *
    // 0x13-0x1f reserved
};


// =========================================================================================================
// PSDotMapping
// --------.--------.--------.-----xxx // stage1
// --------.--------.--------.-xxx---- // stage2
// --------.--------.-----xxx.-------- // stage3

#define PS_DOTMAPPING(t0,t1,t2,t3) (((t3)<<8)|((t2)<<4)|(t1))

// Mappings:
// ZERO_TO_ONE         :rgb->(r,g,b): 0x0=>0.0, 0xff=>1.0
// MINUS1_TO_1_D3D     :rgb->(r,g,b): 0x0=>-128/127, 0x01=>-1.0, 0x80=>0.0, 0xff=>1.0
// MINUS1_TO_1_GL      :rgb->(r,g,b): 0x80=>-1.0, 0x7f=>1.0
// MINUS1_TO_1         :rgb->(r,g,b): 0x80=>-128/127, 0x81=>-1.0, 0x0=>0.0, 0x7f=>1.0
// HILO_1              :HL->(H,L,1.0): 0x0000=>0.0, 0xffff=>1.0
// HILO_HEMISPHERE_D3D :HL->(H,L,sqrt(1-H*H-L*L)): 0x8000=>-1.0, 0x0=>0.0, 0x7fff=32767/32768
// HILO_HEMISPHERE_GL  :HL->(H,L,sqrt(1-H*H-L*L)): 0x8000=>-1.0, 0x7fff=>1.0
// HILO_HEMISPHERE     :HL->(H,L,sqrt(1-H*H-L*L)): 0x8001=>-1.0, 0x0=>0.0, 0x7fff=>1.0, 0x8000=>-32768/32767

enum PS_DOTMAPPING
{                              // valid in stage 0 1 2 3
    PS_DOTMAPPING_ZERO_TO_ONE=         0x00L, // - * * *
    PS_DOTMAPPING_MINUS1_TO_1_D3D=     0x01L, // - * * *
    PS_DOTMAPPING_MINUS1_TO_1_GL=      0x02L, // - * * *
    PS_DOTMAPPING_MINUS1_TO_1=         0x03L, // - * * *
    PS_DOTMAPPING_HILO_1=              0x04L, // - * * *
    PS_DOTMAPPING_HILO_HEMISPHERE_D3D= 0x05L, // - * * *
    PS_DOTMAPPING_HILO_HEMISPHERE_GL=  0x06L, // - * * *
    PS_DOTMAPPING_HILO_HEMISPHERE=     0x07L, // - * * *
};

// =========================================================================================================
// PSCompareMode
// --------.--------.--------.----xxxx // stage0
// --------.--------.--------.xxxx---- // stage1
// --------.--------.----xxxx.-------- // stage2
// --------.--------.xxxx----.-------- // stage3

#define PS_COMPAREMODE(t0,t1,t2,t3) (((t3)<<12)|((t2)<<8)|((t1)<<4)|(t0))

enum PS_COMPAREMODE
{
    PS_COMPAREMODE_S_LT= 0x00L,
    PS_COMPAREMODE_S_GE= 0x01L,
    
    PS_COMPAREMODE_T_LT= 0x00L,
    PS_COMPAREMODE_T_GE= 0x02L,
    
    PS_COMPAREMODE_R_LT= 0x00L,
    PS_COMPAREMODE_R_GE= 0x04L,
    
    PS_COMPAREMODE_Q_LT= 0x00L,
    PS_COMPAREMODE_Q_GE= 0x08L,
};

// =========================================================================================================
// PSInputTexture
// --------.-------x.--------.-------- // stage2
// --------.--xx----.--------.-------- // stage3
//
// Selects the other texture to use as an input in the following texture modes:
// DOT_ST, DOT_STR_3D, DOT_STR_CUBE, DOT_ZW, DOT_RFLCT_SPEC, 
// DOT_RFLCT_DIFF, DPNDNT_AR, DPNDNT_GB, BUMPENVMAP,
// BUMPENVMAP_LUM, DOT_PRODUCT

#define PS_INPUTTEXTURE(t0,t1,t2,t3) (((t3)<<20)|((t2)<<16))


/*---------------------------------------------------------------------------------*/
/*  Color combiners - The following members of the D3DPixelShaderDef structure     */
/*  define the state for the eight stages of color combiners:                      */
/*      PSCombinerCount - Number of stages                                         */
/*      PSAlphaInputs[8] - Inputs for alpha portion of each stage                  */
/*      PSRGBInputs[8] - Inputs for RGB portion of each stage                      */
/*      PSConstant0[8] - Constant 0 for each stage                                 */
/*      PSConstant1[8] - Constant 1 for each stage                                 */
/*      PSFinalCombinerConstant0 - Constant 0 for final combiner                   */
/*      PSFinalCombinerConstant1 - Constant 1 for final combiner                   */
/*      PSAlphaOutputs[8] - Outputs for alpha portion of each stage                */
/*      PSRGBOutputs[8] - Outputs for RGB portion of each stage                    */
/*---------------------------------------------------------------------------------*/


// =========================================================================================================
// PSCombinerCount
// --------.--------.--------.----xxxx // number of combiners (1-8)
// --------.--------.-------x.-------- // mux bit (0= LSB, 1= MSB)
// --------.--------.---x----.-------- // separate C0
// --------.-------x.--------.-------- // separate C1

#define PS_COMBINERCOUNT(count, flags) (((flags)<<8)|(count))
// count is 1-8, flags contains one or more values from PS_COMBINERCOUNTFLAGS

enum PS_COMBINERCOUNTFLAGS
{
    PS_COMBINERCOUNT_MUX_LSB=     0x0000L, // mux on r0.a lsb
    PS_COMBINERCOUNT_MUX_MSB=     0x0001L, // mux on r0.a msb
    
    PS_COMBINERCOUNT_SAME_C0=     0x0000L, // c0 same in each stage
    PS_COMBINERCOUNT_UNIQUE_C0=   0x0010L, // c0 unique in each stage
    
    PS_COMBINERCOUNT_SAME_C1=     0x0000L, // c1 same in each stage
    PS_COMBINERCOUNT_UNIQUE_C1=   0x0100L  // c1 unique in each stage
};


// =========================================================================================================
// PSRGBInputs[0-7]
// PSAlphaInputs[0-7]
// PSFinalCombinerInputsABCD
// PSFinalCombinerInputsEFG
// --------.--------.--------.----xxxx // D register
// --------.--------.--------.---x---- // D channel (0= RGB/BLUE, 1= ALPHA)
// --------.--------.--------.xxx----- // D input mapping
// --------.--------.----xxxx.-------- // C register
// --------.--------.---x----.-------- // C channel (0= RGB/BLUE, 1= ALPHA)
// --------.--------.xxx-----.-------- // C input mapping
// --------.----xxxx.--------.-------- // B register
// --------.---x----.--------.-------- // B channel (0= RGB/BLUE, 1= ALPHA)
// --------.xxx-----.--------.-------- // B input mapping
// ----xxxx.--------.--------.-------- // A register
// ---x----.--------.--------.-------- // A channel (0= RGB/BLUE, 1= ALPHA)
// xxx-----.--------.--------.-------- // A input mapping

// examples:
// 
// shader.PSRGBInputs[3]= PS_COMBINERINPUTS(
//     PS_REGISTER_T0 | PS_INPUTMAPPING_EXPAND_NORMAL     | PS_CHANNEL_RGB,
//     PS_REGISTER_C0 | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_ALPHA,
//     PS_REGISTER_ZERO,
//     PS_REGISTER_ZERO);
// 
// shader.PSFinalCombinerInputsABCD= PS_COMBINERINPUTS(
//     PS_REGISTER_T0     | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_ALPHA,
//     PS_REGISTER_ZERO   | PS_INPUTMAPPING_EXPAND_NORMAL     | PS_CHANNEL_RGB,
//     PS_REGISTER_EFPROD | PS_INPUTMAPPING_UNSIGNED_INVERT   | PS_CHANNEL_RGB,
//     PS_REGISTER_ZERO);
//
// PS_FINALCOMBINERSETTING is set in 4th field of PSFinalCombinerInputsEFG with PS_COMBINERINPUTS
// example:
// 
// shader.PSFinalCombinerInputsEFG= PS_COMBINERINPUTS(
//     PS_REGISTER_R0 | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_RGB,
//     PS_REGISTER_R1 | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_RGB,
//     PS_REGISTER_R1 | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_BLUE,
//    PS_FINALCOMBINERSETTING_CLAMP_SUM | PS_FINALCOMBINERSETTING_COMPLEMENT_R0);

#define PS_COMBINERINPUTS(a,b,c,d) (((a)<<24)|((b)<<16)|((c)<<8)|(d))
// For PSFinalCombinerInputsEFG,
//     a,b,c contain a value from PS_REGISTER, PS_CHANNEL, and PS_INPUTMAPPING for input E,F, and G
//     d contains values from PS_FINALCOMBINERSETTING
// For all other inputs,
//     a,b,c,d each contain a value from PS_REGISTER, PS_CHANNEL, and PS_INPUTMAPPING

enum PS_INPUTMAPPING
{
    PS_INPUTMAPPING_UNSIGNED_IDENTITY= 0x00L, // max(0,x)         OK for final combiner
    PS_INPUTMAPPING_UNSIGNED_INVERT=   0x20L, // 1 - max(0,x)     OK for final combiner
    PS_INPUTMAPPING_EXPAND_NORMAL=     0x40L, // 2*max(0,x) - 1   invalid for final combiner
    PS_INPUTMAPPING_EXPAND_NEGATE=     0x60L, // 1 - 2*max(0,x)   invalid for final combiner
    PS_INPUTMAPPING_HALFBIAS_NORMAL=   0x80L, // max(0,x) - 1/2   invalid for final combiner
    PS_INPUTMAPPING_HALFBIAS_NEGATE=   0xa0L, // 1/2 - max(0,x)   invalid for final combiner
    PS_INPUTMAPPING_SIGNED_IDENTITY=   0xc0L, // x                invalid for final combiner
    PS_INPUTMAPPING_SIGNED_NEGATE=     0xe0L, // -x               invalid for final combiner
};

enum PS_REGISTER
{
    PS_REGISTER_ZERO=              0x00L, // r    
    PS_REGISTER_DISCARD=           0x00L, // w
    PS_REGISTER_C0=                0x01L, // r
    PS_REGISTER_C1=                0x02L, // r
    PS_REGISTER_FOG=               0x03L, // r
    PS_REGISTER_V0=                0x04L, // r/w  
    PS_REGISTER_V1=                0x05L, // r/w
    PS_REGISTER_T0=                0x08L, // r/w
    PS_REGISTER_T1=                0x09L, // r/w
    PS_REGISTER_T2=                0x0aL, // r/w
    PS_REGISTER_T3=                0x0bL, // r/w
    PS_REGISTER_R0=                0x0cL, // r/w
    PS_REGISTER_R1=                0x0dL, // r/w
    PS_REGISTER_V1R0_SUM=          0x0eL, // r
    PS_REGISTER_EF_PROD=           0x0fL, // r
    
    PS_REGISTER_ONE=               PS_REGISTER_ZERO | PS_INPUTMAPPING_UNSIGNED_INVERT, // OK for final combiner
    PS_REGISTER_NEGATIVE_ONE=      PS_REGISTER_ZERO | PS_INPUTMAPPING_EXPAND_NORMAL,   // invalid for final combiner
    PS_REGISTER_ONE_HALF=          PS_REGISTER_ZERO | PS_INPUTMAPPING_HALFBIAS_NEGATE, // invalid for final combiner
    PS_REGISTER_NEGATIVE_ONE_HALF= PS_REGISTER_ZERO | PS_INPUTMAPPING_HALFBIAS_NORMAL, // invalid for final combiner
};

// FOG ALPHA is only available in final combiner
// V1R0_SUM and EF_PROD are only available in final combiner (A,B,C,D inputs only)
// V1R0_SUM_ALPHA and EF_PROD_ALPHA are not available
// R0_ALPHA is initialized to T0_ALPHA in stage0

enum PS_CHANNEL
{
    PS_CHANNEL_RGB=   0x00, // used as RGB source
    PS_CHANNEL_BLUE=  0x00, // used as ALPHA source
    PS_CHANNEL_ALPHA= 0x10, // used as RGB or ALPHA source
};


enum PS_FINALCOMBINERSETTING
{
    PS_FINALCOMBINERSETTING_CLAMP_SUM=     0x80, // V1+R0 sum clamped to [0,1]
    
    PS_FINALCOMBINERSETTING_COMPLEMENT_V1= 0x40, // unsigned invert mapping
    
    PS_FINALCOMBINERSETTING_COMPLEMENT_R0= 0x20, // unsigned invert mapping
};

// =========================================================================================================
// PSRGBOutputs[0-7]
// PSAlphaOutputs[0-7]
// --------.--------.--------.----xxxx // CD register
// --------.--------.--------.xxxx---- // AB register
// --------.--------.----xxxx.-------- // SUM register
// --------.--------.---x----.-------- // CD output (0= multiply, 1= dot product)
// --------.--------.--x-----.-------- // AB output (0= multiply, 1= dot product)
// --------.--------.-x------.-------- // AB_CD mux/sum select (0= sum, 1= mux)
// --------.------xx.x-------.-------- // Output mapping
// --------.-----x--.--------.-------- // CD blue to alpha
// --------.----x---.--------.-------- // AB blue to alpha

#define PS_COMBINEROUTPUTS(ab,cd,mux_sum,flags) (((flags)<<12)|((mux_sum)<<8)|((ab)<<4)|(cd))
// ab,cd,mux_sum contain a value from PS_REGISTER
// flags contains values from PS_COMBINEROUTPUT

enum PS_COMBINEROUTPUT
{
    PS_COMBINEROUTPUT_IDENTITY=            0x00L, // y = x        
    PS_COMBINEROUTPUT_BIAS=                0x08L, // y = x - 0.5  
    PS_COMBINEROUTPUT_SHIFTLEFT_1=         0x10L, // y = x*2      
    PS_COMBINEROUTPUT_SHIFTLEFT_1_BIAS=    0x18L, // y = (x - 0.5)*2
    PS_COMBINEROUTPUT_SHIFTLEFT_2=         0x20L, // y = x*4      
    PS_COMBINEROUTPUT_SHIFTRIGHT_1=        0x30L, // y = x/2      
    
    PS_COMBINEROUTPUT_AB_BLUE_TO_ALPHA=    0x80L, // RGB only
    
    PS_COMBINEROUTPUT_CD_BLUE_TO_ALPHA=    0x40L, // RGB only
    
    PS_COMBINEROUTPUT_AB_MULTIPLY=         0x00L,
    PS_COMBINEROUTPUT_AB_DOT_PRODUCT=      0x02L, // RGB only
    
    PS_COMBINEROUTPUT_CD_MULTIPLY=         0x00L,
    PS_COMBINEROUTPUT_CD_DOT_PRODUCT=      0x01L, // RGB only
    
    PS_COMBINEROUTPUT_AB_CD_SUM=           0x00L, // 3rd output is AB+CD
    PS_COMBINEROUTPUT_AB_CD_MUX=           0x04L, // 3rd output is MUX(AB,CD) based on R0.a
};

// AB_CD register output must be DISCARD if either AB_DOT_PRODUCT or CD_DOT_PRODUCT are set

// =========================================================================================================
// PSC0Mapping
// PSC1Mapping
// --------.--------.--------.----xxxx // offset of D3D constant for stage 0
// --------.--------.--------.xxxx---- // offset of D3D constant for stage 1
// --------.--------.----xxxx.-------- // offset of D3D constant for stage 2
// --------.--------.xxxx----.-------- // offset of D3D constant for stage 3
// --------.----xxxx.--------.-------- // offset of D3D constant for stage 4
// --------.xxxx----.--------.-------- // offset of D3D constant for stage 5
// ----xxxx.--------.--------.-------- // offset of D3D constant for stage 6
// xxxx----.--------.--------.-------- // offset of D3D constant for stage 7

#define PS_CONSTANTMAPPING(s0,s1,s2,s3,s4,s5,s6,s7) \
     (((DWORD)(s0)&0xf)<< 0) | (((DWORD)(s1)&0xf)<< 4) | \
     (((DWORD)(s2)&0xf)<< 8) | (((DWORD)(s3)&0xf)<<12) | \
     (((DWORD)(s4)&0xf)<<16) | (((DWORD)(s5)&0xf)<<20) | \
     (((DWORD)(s6)&0xf)<<24) | (((DWORD)(s7)&0xf)<<28) 
// s0-s7 contain the offset of the D3D constant that corresponds to the 
// c0 or c1 constant in stages 0 through 7.  These mappings are only used in 
// SetPixelShaderConstant().
   
// =========================================================================================================
// PSFinalCombinerConstants
// --------.--------.--------.----xxxx // offset of D3D constant for C0
// --------.--------.--------.xxxx---- // offset of D3D constant for C1
// --------.--------.-------x.-------- // Adjust texture flag

#define PS_FINALCOMBINERCONSTANTS(c0,c1,flags) (((DWORD)(flags) << 8) | ((DWORD)(c0)&0xf)<< 0) | (((DWORD)(c1)&0xf)<< 4)
// c0 and c1 contain the offset of the D3D constant that corresponds to the
// constants in the final combiner.  These mappings are only used in 
// SetPixelShaderConstant().  Flags contains values from PS_GLOBALFLAGS

enum PS_GLOBALFLAGS
{
    // if this flag is set, the texture mode for each texture stage is adjusted as follows:
    //     if set texture is a cubemap, 
    //         change PS_TEXTUREMODES_PROJECT2D to PS_TEXTUREMODES_CUBEMAP
    //         change PS_TEXTUREMODES_PROJECT3D to PS_TEXTUREMODES_CUBEMAP
    //         change PS_TEXTUREMODES_DOT_STR_3D to PS_TEXTUREMODES_DOT_STR_CUBE
    //     if set texture is a volume texture, 
    //         change PS_TEXTUREMODES_PROJECT2D to PS_TEXTUREMODES_PROJECT3D
    //         change PS_TEXTUREMODES_CUBEMAP to PS_TEXTUREMODES_PROJECT3D
    //         change PS_TEXTUREMODES_DOT_STR_CUBE to PS_TEXTUREMODES_DOT_STR_3D
    //     if set texture is neither cubemap or volume texture, 
    //         change PS_TEXTUREMODES_PROJECT3D to PS_TEXTUREMODES_PROJECT2D
    //         change PS_TEXTUREMODES_CUBEMAP to PS_TEXTUREMODES_PROJECT2D

    PS_GLOBALFLAGS_NO_TEXMODE_ADJUST=     0x0000L, // don't adjust texture modes
    PS_GLOBALFLAGS_TEXMODE_ADJUST=        0x0001L, // adjust texture modes according to set texture
};

   
typedef struct _D3DPixelShaderDefFile
{
    DWORD               FileID;         // Uniquely identifies the file as pixel shader binary
    D3DPIXELSHADERDEF   Psd;            // The pixel shader def structure
} D3DPIXELSHADERDEF_FILE;

#define D3DPIXELSHADERDEF_FILE_ID   0x30425350  // "PSB0"

/*----------------------- End of Pixel Shader Defines -----------------------*/

/*----------------------------------------------
/* Push-Buffer Binary Format
/*----------------------------------------------

/*---------------------------------------------------*/
/*  These defines describe the binary format of the  */
/*  push-buffer.  They may be used in conjunction    */
/*  with BeginPush/EndPush and RunPushBuffer.        */
/*---------------------------------------------------*/

/* Encoding support */

#define D3DPUSH_ENCODE(Method, Count)   (((Count) << 18) + (Method))
#define D3DPUSH_NOINCREMENT_FLAG        0x40000000

/* Methods */

#define D3DPUSH_SET_BEGIN_END           0x000017fc      // D3DPRIMITIVETYPE or 0 to end
#define D3DPUSH_INLINE_ARRAY            0x00001818


/*----------------------- End of Push-Buffer Defines -----------------------*/


#pragma pack()
#pragma warning(default:4201)

#endif /* (DIRECT3D_VERSION >= 0x0800) */
#endif /* _D3D8TYPES(P)_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dxg\obj\i386\xfont.h ===
//****************************************************************************
//
// XBox font library
//
//****************************************************************************

// NOTE: You need to #define "XFONT_TRUETYPE" before including this
//  : file if you're planning on using the TypeType font scaler.  This 
//  : really should be a rare case and using it does bring in a whole
//  : wad of code. 

#pragma once

// The errors returned from these methods are generally fatal.  Close the 
// current font if you get one.

//****************************************************************************
// Structure definitions.
//****************************************************************************

typedef struct IDirect3DSurface8 IDirect3DSurface8;

//============================================================================
// An opaque structure which holds an active font.  The consumer can get
// and set this structure to allow it to use multiple fonts without 
// unloading them.
//============================================================================
              
typedef struct XFONT XFONT;

#if defined(__cplusplus)

struct XFONT
{
    void    __stdcall AddRef();
    void    __stdcall Release();

    unsigned __stdcall GetTextHeight();
    HRESULT  __stdcall SetTextHeight(unsigned uHeight);

    unsigned __stdcall GetTextAntialiasLevel();
    HRESULT  __stdcall SetTextAntialiasLevel(unsigned uAntialiasLevel);

    unsigned __stdcall GetRLEWidth();
    HRESULT  __stdcall SetRLEWidth(unsigned uRLEWidth);

    unsigned __stdcall GetTextStyle();
    HRESULT  __stdcall SetTextStyle(unsigned uStyle);

    unsigned __stdcall GetTextAlignment();
    void     __stdcall SetTextAlignment(unsigned uMode);

    D3DCOLOR __stdcall GetTextColor();
    void     __stdcall SetTextColor(D3DCOLOR color);

    D3DCOLOR __stdcall GetBkColor();
    void     __stdcall SetBkColor(D3DCOLOR color);

    int      __stdcall GetBkMode();
    void     __stdcall SetBkMode(int iBkMode);

    unsigned __stdcall GetIntercharacterSpacing();
    void     __stdcall SetIntercharacterSpacing(unsigned uSpaces);

    D3DRECT *__stdcall GetClippingRectangle();
    void     __stdcall SetClippingRectangle(D3DRECT *pRectangle);

    void     __stdcall GetFontMetrics(unsigned *puCellHeight, unsigned *puDescent);
    HRESULT  __stdcall GetTextExtent(LPCWSTR wstr,   unsigned cch, unsigned *puWidth);
    HRESULT  __stdcall TextOutToMemory(LPCVOID pBits, unsigned Pitch, unsigned Width, unsigned Height, D3DFORMAT Format, LPCWSTR wstr, unsigned cch, long x, long y);
    HRESULT  __stdcall TextOut(IDirect3DSurface8 *pSurface, LPCWSTR wstr, unsigned cch, long x, long y);
};

#endif !defined(__cplusplus)

//****************************************************************************
// The APIs
//****************************************************************************

#if defined(__cplusplus)

extern "C" {

#endif !defined(__cplusplus)

//============================================================================
// Loads a bitmap font of the format defined in xfontformat.h from a file.
//
// This method always allocates ~112 bytes for each font to store the
// font's state.  Additional memory will be allocated depending on the
// value of the uCacheSize parameter:
//
//    0                            - an allocation to hold the bitmap for the 
//                                   last drawn glyph.  The glyph information
//                                   is ready directly out of the file as
//                                   each glyph is drawn.  Very slow.
//
//    uCacheSize < font file size  - a block of memory of size uCacheSize 
//                                   holds the most recently drawn glyphs.  
//                                   The glyph information is ready directly 
//                                   out of the file.  This can perform 
//                                   reasonably if the cache is sized
//                                   correctly via experimentation.
//
//    uCacheSize >= font file size - a block of memory just large enough to 
//                                   hold the contents of the file will be 
//                                   allocated and the entire font file will 
//                                   be loaded into it.  Very fast.
//
//============================================================================

HRESULT __stdcall XFONT_OpenBitmapFont
(
    LPCWSTR wszFileName,    // [in] The file name of the font
    unsigned uCacheSize,    // [in] The size of the font cache, in bytes.
    XFONT **ppFont          // [out] The font identifier
);

//============================================================================
// Loads a bitmap font of the format defined in xfontformat.h from a block
// of memory, either one that has been loaded into memory by the caller
// or one that is compiled into the title from a source code file
// generated by makefont.exe.
//
// This method always allocates ~112 bytes for each font to store the font's
// current state.  No additional memory will be allocated throughout the 
// lifetime of the font.
//
// The caller must ensure that the memory block that contains the font data
// will live at least as long as the font as it will keep referencing that
// data when it draws.
// 
//============================================================================

HRESULT __stdcall XFONT_OpenBitmapFontFromMemory
(
    CONST void *pFontData,  // [in] The block of font data
    unsigned uFontDataSize, // [in] The size of the font data
    XFONT **ppFont          // [out] The font identifier
);

//============================================================================
// Loads the default bitmap font that is compiled directy into the library.
// This is a 24 pixel hight= arial font the contains only the western 
// character set and is intended as a convenience for titles that just need a 
// quick way of displaying information.
//
// This will also allocate ~112 bytes of memory each time this method is 
// called but will never allocate any more memory throughout the lifetime
// of the font.
//
//============================================================================

HRESULT __stdcall XFONT_OpenDefaultFont
(
    XFONT **ppFont          // [out] The font identifier
);

#if defined(XFONT_TRUETYPE)

//============================================================================
// Load a TrueType font into the scan converter.  
//
// This call will use more memory than just the the cache because the 
// TrueType scan converter needs a bit of workspace to process the font.  If 
// memory is a concern, use a bitmap font instead.
//
// This automatically sets the opened font as the one that is currently
// active.  The attributes of the font are all set to their defaults.
//============================================================================

HRESULT __stdcall XFONT_OpenTrueTypeFont
(
    LPCWSTR wszFileName,    // [in] The path name to the font
    unsigned uCacheSize,    // [in] The size of the font cache, in bytes.
    XFONT **ppFont          // [out] The font identifier
);

#endif 

//============================================================================
// Add a refcount to the font.
//============================================================================

void __stdcall XFONT_AddRef
(
    XFONT *pXFont           // [in] The id of the font
);

//============================================================================
// Unload a font and free all of its memory.  The XFONT identifier will be 
// invalidated.
//============================================================================

void __stdcall XFONT_Release
(
    XFONT *pXFont           // [in] The id of the font to unload
);

//============================================================================
// Sets the height of the text cell, in pixels, for the current font.
//
// Defaults to 16 pixels high.  This may only be set on a TrueType font.
//============================================================================

unsigned __stdcall XFONT_GetTextHeight
(
    XFONT *pXFont           // [in] The id of the font
);

HRESULT __stdcall XFONT_SetTextHeight
(
    XFONT *pXFont,          // [in] The id of the font
    unsigned uHeight        // [in] The total height of the text cell   
);

//============================================================================
// Sets the amount of antialias information to include in the bitmap with
// valid values of 0 (no information), 2, or 4 (lots of information).
//
// The antialiasing works best for larger or bold fonts whose strokes are 
// more the one pixel wide.  
//
// This may only be set on a TrueType font.  Defaults to 0.
//============================================================================

unsigned __stdcall XFONT_GetTextAntialiasLevel
(
    XFONT *pXFont           // [in] The id of the font
);

HRESULT __stdcall XFONT_SetTextAntialiasLevel
(
    XFONT *pXFont,          // [in] The id of the font
    unsigned uAntialiasLevel
);

//============================================================================
// Sets the size of the RLE packet used to compress the internal bitmaps
// used by the font.  This may effect the number of bitmaps that can fit
// in the internal cache depending on the size and characteristics of your
// font.  May be 2-8.
//
// This may only be set on a TrueType font.  Defaults to 2.
//============================================================================

unsigned __stdcall XFONT_GetRLEWidth
(
    XFONT *pXFont           // [in] The id of the font
);

HRESULT __stdcall XFONT_SetRLEWidth
(
    XFONT *pXFont,          // [in] The id of the font
    unsigned uRLEWidth
);

//============================================================================
// Sets the style for the text, one of NORMAL, BOLD, ITALICS or BOLDITALICS.
// This will cause the TrueType font scaler to simulate these styles when
// generating the bitmaps for the font.  If the font defines the different
// styles in separate TTF files then load each individually instead of 
// using this method.
//
// Defaults to XFONT_NORMAL.  This may only be set on a TrueType font.
//============================================================================

#define XFONT_NORMAL          1
#define XFONT_BOLD            2
#define XFONT_ITALICS         3
#define XFONT_BOLDITALICS     4

unsigned __stdcall XFONT_GetTextStyle
(
    XFONT *pXFont           // [in] The id of the font
);

HRESULT __stdcall XFONT_SetTextStyle
(
    XFONT *pXFont,          // [in] The id of the font
    unsigned uStyle
);

//============================================================================
// Sets to what part of the text the coordinates passed to XFONT_TextOut refers.
//
// The only parameter must contain one vertical value ORed with one 
// horizontal value.
//
// The vertical alignment value specifies which part of the text is pointed
// to by the y coordinate:
//
//      XFONT_BASELINE  - the baseline of the text
//      XFONT_BOTTOM    - the bottom of the character cell
//      XFONT_TOP       - the top of the character cell
//
// The horizontal alignment value specifies which part of the text is pointed
// to by the x coordinate:
//
//      XFONT_CENTER    - the center of the text
//      XFONT_LEFT      - the leftmost edge of the text
//      XFONT_RIGHT     - the rightmost edge of the text
//
// Defaults to XFONT__TOP | XFONT__LEFT.
//============================================================================

#define XFONT_LEFT                      0
#define XFONT_RIGHT                     2
#define XFONT_CENTER                    6

#define XFONT_TOP                       0
#define XFONT_BOTTOM                    8
#define XFONT_BASELINE                  24

unsigned __stdcall XFONT_GetTextAlignment
(
    XFONT *pXFont           // [in] The id of the font
);

void __stdcall XFONT_SetTextAlignment
(
    XFONT *pXFont,          // [in] The id of the font
    unsigned uMode
);

//============================================================================
// Sets the color for the text.
//
// Defaults to white.
//============================================================================

D3DCOLOR __stdcall XFONT_GetTextColor
(
    XFONT *pXFont           // [in] The id of the font
);

void __stdcall XFONT_SetTextColor
(
    XFONT *pXFont,          // [in] The id of the font
    D3DCOLOR color          // [in] The color of the text
);

//============================================================================
// Sets the color with which to fill the background of the text.  The format
// of the color must match the format of the surfacing being drawn on.
//
// Defaults to black.
//============================================================================

D3DCOLOR __stdcall XFONT_GetBkColor
(
    XFONT *pXFont           // [in] The id of the font
);

void __stdcall XFONT_SetBkColor
(
    XFONT *pXFont,          // [in] The id of the font
    D3DCOLOR color          // [in] The color of the text
);

//============================================================================
// Sets whether to fill the background of the text cell with the background
// color.
//
// Defaults to XFONT_TRANSPARENT because it is faster.
//============================================================================

#define XFONT_TRANSPARENT         1
#define XFONT_OPAQUE              2

int __stdcall XFONT_GetBkMode
(
    XFONT *pXFont           // [in] The id of the font
);

void __stdcall XFONT_SetBkMode
(
    XFONT *pXFont,          // [in] The id of the font
    int iBkMode             // [in] Either XFONT_OPAQUE or XFONT_TRANSPARENT
);

//============================================================================
// Sets the number of additional pixels to put between each character.
//============================================================================

unsigned __stdcall XFONT_GetIntercharacterSpacing
(
    XFONT *pXFont           // [in] The id of the font
);

void __stdcall XFONT_SetIntercharacterSpacing
(
    XFONT *pXFont,          // [in] The id of the font
    unsigned uSpaces        // [in] Extra pixels between each character
);

//============================================================================
// Sets the clipping rectangle.  Pass NULL to clear.
//============================================================================

// Returns NULL if no clipping rectangle is set.  The memory returned gets
// overwritten each time this method is called.
//
D3DRECT *__stdcall XFONT_GetClippingRectangle
(
    XFONT *pXFont           // [in] The id of the font
);

void __stdcall XFONT_SetClippingRectangle
(
    XFONT *pXFont,          // [in] The id of the font
    D3DRECT *pRectangle     // [in] Clipping rectangle
);

//============================================================================
// Get the vertical metrics for the current font settings.  
//============================================================================

void __stdcall XFONT_GetFontMetrics
(
    XFONT *pXFont,          // [in] The id of the font
    unsigned *puCellHeight,     
    unsigned *puDescent
);

//============================================================================
// Get the width of a string in pixels. This method applies any 
// intercharacter spacing.
//============================================================================

HRESULT __stdcall XFONT_GetTextExtent
(
    XFONT *pXFont,          // [in] The id of the font
    LPCWSTR wstr,           // [in] The string
    unsigned cch,           // [in] The length of the string, -1 for a zero 
                            //      terminated string
    unsigned *puWidth       // [out] The width of the string in pixels
);

//============================================================================
// Draw the text in a chunk of memory.  See XFONT_SetTextAlignment for the 
// meaning of the x and y coordinates.
//============================================================================
                        
HRESULT __stdcall XFONT_TextOutToMemory
(
    XFONT *pXFont,          // [in] The id of the font to unload
    LPCVOID pBits,          // [in] Memory to write to.
    unsigned Pitch,         // [in] The pitch of that memory.
    unsigned Width,         // [in] Width, in pixels, of the memory
    unsigned Height,        // [in] Hight, in pixels, of the memory.
    D3DFORMAT Format,       // [in] Format of the pixels in the memory.
    LPCWSTR wstr,           // [in] The string
    unsigned cch,           // [in] The length of the string, -1 for a zero terminated string
    long x,                 // [in] The x coordinate of the string
    long y                  // [in] The y coordinate of the string
);


//============================================================================
// Draw the text on a surface.  See XFONT_SetTextAlignment for the meaning of
// the x and y coordinates.  This does not work for swizzled surfaces!
//============================================================================

HRESULT __stdcall XFONT_TextOut
(
    XFONT *pXFont,          // [in] The id of the font
    IDirect3DSurface8 *pSurface,    // [in] The surface to draw the text on
    LPCWSTR wstr,           // [in] The string
    unsigned cch,           // [in] The length of the string, -1 for a zero terminated string
    long x,                 // [in] The x coordinate of the string
    long y                  // [in] The y coordinate of the string
);


#if defined(__cplusplus)

};

#endif defined(__cplusplus)


#if defined(__cplusplus)

__forceinline void     __stdcall XFONT::AddRef() { XFONT_AddRef(this); }
__forceinline void     __stdcall XFONT::Release() { XFONT_Release(this); }

__forceinline unsigned __stdcall XFONT::GetTextHeight() { return XFONT_GetTextHeight(this); }
__forceinline HRESULT  __stdcall XFONT::SetTextHeight(unsigned uHeight) { return XFONT_SetTextHeight(this, uHeight); }
__forceinline unsigned __stdcall XFONT::GetTextAntialiasLevel() { return XFONT_GetTextAntialiasLevel(this); }
__forceinline HRESULT  __stdcall XFONT::SetTextAntialiasLevel(unsigned uAntialiasLevel) { return XFONT_SetTextAntialiasLevel(this, uAntialiasLevel); }
__forceinline unsigned __stdcall XFONT::GetRLEWidth() { return XFONT_GetRLEWidth(this); }
__forceinline HRESULT  __stdcall XFONT::SetRLEWidth(unsigned uRLEWidth) { return XFONT_SetRLEWidth(this, uRLEWidth); }
__forceinline unsigned __stdcall XFONT::GetTextStyle() { return XFONT_GetTextStyle(this); }
__forceinline HRESULT  __stdcall XFONT::SetTextStyle(unsigned uStyle) { return XFONT_SetTextStyle(this, uStyle); }
__forceinline unsigned __stdcall XFONT::GetTextAlignment() { return XFONT_GetTextAlignment(this); }
__forceinline void     __stdcall XFONT::SetTextAlignment(unsigned uMode) { XFONT_SetTextAlignment(this, uMode); }
__forceinline D3DCOLOR __stdcall XFONT::GetTextColor() { return XFONT_GetTextColor(this); }
__forceinline void     __stdcall XFONT::SetTextColor(D3DCOLOR color) { XFONT_SetTextColor(this, color); }
__forceinline D3DCOLOR __stdcall XFONT::GetBkColor() { return XFONT_GetBkColor(this); }
__forceinline void     __stdcall XFONT::SetBkColor(D3DCOLOR color) { XFONT_SetBkColor(this, color); }
__forceinline int      __stdcall XFONT::GetBkMode() { return XFONT_GetBkMode(this); }
__forceinline void     __stdcall XFONT::SetBkMode(int iBkMode) { XFONT_SetBkMode(this, iBkMode); }
__forceinline unsigned __stdcall XFONT::GetIntercharacterSpacing() { return XFONT_GetIntercharacterSpacing(this); }
__forceinline void     __stdcall XFONT::SetIntercharacterSpacing(unsigned uSpaces) { XFONT_SetIntercharacterSpacing(this, uSpaces); }
__forceinline D3DRECT *__stdcall XFONT::GetClippingRectangle() { return XFONT_GetClippingRectangle(this); }
__forceinline void     __stdcall XFONT::SetClippingRectangle(D3DRECT *pRectangle) { XFONT_SetClippingRectangle(this, pRectangle); }

__forceinline void     __stdcall XFONT::GetFontMetrics(unsigned *puCellHeight, unsigned *puDescent) { XFONT_GetFontMetrics(this, puCellHeight, puDescent); }
__forceinline HRESULT  __stdcall XFONT::GetTextExtent(LPCWSTR wstr, unsigned cch, unsigned *puWidth) { return XFONT_GetTextExtent(this, wstr, cch, puWidth); }
__forceinline HRESULT  __stdcall XFONT::TextOutToMemory(LPCVOID pBits, unsigned Pitch, unsigned Width, unsigned Height, D3DFORMAT Format, LPCWSTR wstr, unsigned cch, long x, long y) { return XFONT_TextOutToMemory(this, pBits, Pitch, Width, Height, Format, wstr, cch, x, y); }
__forceinline HRESULT  __stdcall XFONT::TextOut(IDirect3DSurface8 *pSurface, LPCWSTR wstr, unsigned cch, long x, long y) { return XFONT_TextOut(this, pSurface, wstr, cch, x, y); }

#endif defined(__cplusplus)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dxg\obj\i386\xfontformat.h ===
//****************************************************************************
//
// XBox font file format description.
//
//****************************************************************************

#pragma once

#define FILE_VERSION	2 

//============================================================================
// Characters are processed in two separate parts, the character segment
// and the character offset.  The segment consists of the top 12 bits
// and are used as the index into the various tables.  The offset is the
// lower four bits.  We do this to take advanage of the properties of the 
// Kanji unicode character set which has a contigous run of segments but a 
// random distribution of offsets.
//
// This file format is optimized for fonts containing the Kanji unicode
// glyphs.  It is not as efficient for fonts that only contain western, 
// Hiragana and Katakana glyphs because of the extra overhead of the
// segment table which is not needed in those cases.  It should not be
// difficult fix.
//
// This file format does not support multiple styles in the same file
// (i.e. bold, italics, etc).  We can easily add that by having separate
// glyph tables for each included style.  This allows the segment run
// and segment tables to be shared (no big deal).
//
// The file is organized as follows:
//
//  Header
//  GlyphTable - array of offsets to each glyph
//  SegmentRun Table
//  Segment Table
//  Glyphs
//
// The header is 4 byte aligned, the glyph table is 4 byte aligned, 
// the segment run table and the segment table are 2 byte aligned.  The
// Glyphs are 1-byte aligned.  
//============================================================================

//============================================================================
// The following macros figure out these segment/offset for a character.
//============================================================================

#define CHAR_SEGMENT(x) (x >> 4)
#define CHAR_OFFSET(x) (x & 0xF)
#define MAKE_CHAR(x, y) (x << 4 | y)

#define CHAR_SEGMENT_MAX	0xFFF
#define CHAR_OFFSET_MAX		16

//============================================================================
// Initial header at offset 0 of the file, describes some of the global
// information about the font. 
//============================================================================

typedef struct _FontHeader
{
	WORD wSignature;		// Identifies this is actually a font, must be 'XFNT'
	WORD wVersion;			// The FILE_VERSION the font was written with

	// Descriptions of other structures in this file.

    WORD cGlyphs;           // The number of entries in the glyph offset
                            // table.  This actually has one extra entry so
                            // we can use this table to calculate the size
                            // of the glyph before we read it.
                            
	WORD cSegmentRunTable;	// The number of entries in the segment run table.

	// Font metrics, all of the following values are in pixels.

	WORD wDefaultChar;		// The character to use if the requested character
	                        // does not have a glyph in the font.

	BYTE uCellHeight;		// The height of the character cell.
	BYTE uDescent;			// Distance from the bottom of the cell to the 
                            // baseline.

    BYTE uAntialiasLevel;   // Amount of antialias information (0, 2, 4)
    BYTE uRLEWidth;         // Width of each RLE 'packet', 2, 4, 8

    BYTE uMaxBitmapHeight;  // Height of the tallest bitmap
    BYTE uMaxBitmapWidth;   // Width of the widest bitmap

} FontHeader;

//============================================================================
// Keeps track of 'runs' of segment values for the character set in this
// font.  Fonts will typically have very few of these.
//============================================================================

typedef struct _SegmentRun
{
	WORD wFirstSegment;		// The segment that starts the run.
	WORD cSegments;			// The number of segments in the run.

	WORD iSegmentTable;		// Index into the segment table where the 
	                        // descriptors for this run live.  That table
	                        // is allocated immediately after the segment 
	                        // run table.
} SegmentRun;

//============================================================================
// Describes the characters that are available in the current segment.
//============================================================================

typedef struct _SegmentDescriptor
{
	WORD iGlyph;		// The index into the glyph data array which is at
						// offset zero in one of the glyph data areas.  This
						// refers to the glyph for the first character in this
						// segment that is defined in the font.

	WORD wCharMask;     // A bit-mask of the character offset for each character
	                    // defined in this character segment.  The glyph data
	                    // for a character will be at iGlyph + n where n is the
	                    // number of characters defined in this segment with
	                    // as smaller character offset.
} SegmentDescriptor;

//============================================================================
// Holds the spacing and drawing information for a glyph.
//============================================================================

typedef struct _Glyph
{
	// Describes the bitmap for the glyph.

	BYTE uBitmapHeight;
	BYTE uBitmapWidth;

	// Describes the metrics for the bitmap.  All of these values
	// are relative to the current cursor position.

	BYTE uAdvance;		// # of pixels to advance to get to the next character
	char iBearingX;     // horizontal offset to the left side of the bitmap, may be negative
	char iBearingY;     // vertical offset to the top of the bitmap, may be negative

    // The bitmap immediately follows this structure.
} Glyph;

//============================================================================
// Bitmap format
//
// Bitmaps are stored using a simple RLE algorithm which encodes the lengths
// of alternating off and on pixel runs.  The values of partially-on pixels
// for antialiasing are stored via a simple escape mechanism.
//
// The algorithm always starts at the top-left corner of the glyph and 
// treats the glyph as if it was a simple bitmap with a pitch that is exactly
// the same as the bitmap width.  The encoder will count pixels across row
// boundaries.
//
// A pixel can be in one of three states:
// 
//   off          - the pixel is not part of the glyph
//   on           - the color of the text should fully overwrite the 
//                  background on this pixel
//   partially on - the text color should be blended with the background
//                  color, used for antialiasing
// 
// The encoding algorithm in a human-understandable format.  See the
// PackBitmap method in truetype.cpp for the actual implementation.
//
//   loop
//
//     set the pixel count to 0
//
//     while not at the end of the bitmap and the pixel is off
//       increment the pixel count
//       move to the next pixel
//    
//     encode pixel count into an RLE packet
//
//     quit if at the end of the bitmap
//
//     while not at the end of the bitmap and the pixel is neither on nor off
//       encode pixel value into an RLE packet
//       move to next pixel
//
//     quit if at the end of the bitmap
//
//     set the pixel count to 0
//
//     while not at the end of the bitmap and the pixel is on
//       increment the pixel count
//       move to the next pixel
//
//     encode pixel count into an RLE packet
//
//     quit if at the end of the bitmap
//
//     while not at the end of the bitmap and the pixel is neither on nor off
//       encode pixel value into an RLE packet
//       move to next pixel
//
//     quit if at the end of the bitmap
//
//   end loop
//
// There are two kinds of RLE packets.  The first encodes a count of a run of
// either off or on pixels and consists of a set of integers of uRLEWidth
// bits, where uRLEWidth is set in the font header file and is the same for
// all glyphs in the font.  The second kind of packet encodes the value
// of a partially on pixel or a zero count of an on or off pixel and
// consists of an integer with uRLEWidth bits that is always zero and
// an integer of uAntialiaslevel bits, also set in the font headerfile,
// which contains either zero for a zero count or the value of the partially
// on pixel.
// 
// For the count encoding, if the count is equal to or greater than the
// maximum value that will fit in the integer then it needs to be
// encoded in multiple integers where all of the integers are added
// together to get the final value.
//
//    while count is greater than or equal to zero
//      write the lesser of the count or the maximum value
//      subtract the maximum value from the count
//
// For example, assuming 3 bit RLE width and 4 bit antialias width...
//
// Counts of either on or off pixels:
//
//   a count of 1 pixel    : 001
//   a count of 6 pixels   : 110
//   a count of 7 pixels   : 111 000
//   a count of 8 pixels   : 111 001
//   a count of 21 pixels  : 111 111 111 000
//   a count of zero pixels: 000 0000  <-- uses the paritially on format
// 
// The value of a partially on pixel:
//
//   a value of 1          : 000 0001
//   a value of 7          : 000 0111
//   a value of 15 (max)   : 000 1111
//
// NOTES:
//
//   * the value for a partially-on pixel must fit in the size of the value
//     portion of the partially on RLE packet.
//
//   * if the font does not contain any antialiasing information than
//     a count of zero pixels is encoded just as a count, zero is not used
//     as an escape sequence to the paritially on packet format because there
//     are no partially on packets
//
//   * the values we get for the antialias information is actually from 
//     0 to 2 ^ antialiaslevel _inclusive_ which means we have to encode
//     2^n + 1 discrete values to avoid losing any of the information.  This
//     format works because the count RLE packet can encode 2 of the values 
//     (on or off) and the partially on RLE packet can encode the 2^n - 1
//     other values (the value can hold 2^n minus the one value used to
//     represent a zero count.
//
//============================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dxg\obj\i386\dx7todx8.h ===
/*==========================================================================;
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   dx7todx8.h
 *  Content:    DX7 to DX8 Direct3D aliases to aid porting DX7 apps to DX8
 *
 ***************************************************************************/

#ifndef _DX7TODX8_H_

///////////////////////////////////////////////////////////////////////////////
//
// d3d8types.h
//
///////////////////////////////////////////////////////////////////////////////

#define D3DTRANSFORMSTATE_WORLD                 D3DTS_WORLD
#define D3DTRANSFORMSTATE_VIEW                  D3DTS_VIEW
#define D3DTRANSFORMSTATE_PROJECTION            D3DTS_PROJECTION
#define D3DTRANSFORMSTATE_WORLD1                D3DTS_WORLD1
#define D3DTRANSFORMSTATE_WORLD2                D3DTS_WORLD2
#define D3DTRANSFORMSTATE_WORLD3                D3DTS_WORLD3
#define D3DTRANSFORMSTATE_TEXTURE0              D3DTS_TEXTURE0
#define D3DTRANSFORMSTATE_TEXTURE1              D3DTS_TEXTURE1
#define D3DTRANSFORMSTATE_TEXTURE2              D3DTS_TEXTURE2
#define D3DTRANSFORMSTATE_TEXTURE3              D3DTS_TEXTURE3
#define D3DTRANSFORMSTATE_TEXTURE4              D3DTS_TEXTURE4
#define D3DTRANSFORMSTATE_TEXTURE5              D3DTS_TEXTURE5
#define D3DTRANSFORMSTATE_TEXTURE6              D3DTS_TEXTURE6
#define D3DTRANSFORMSTATE_TEXTURE7              D3DTS_TEXTURE7
#define D3DTRANSFORMSTATE_FORCE_DWORD           D3DTS_FORCE_DWORD

#define D3DRENDERSTATE_ZENABLE                  D3DRS_ZENABLE
#define D3DRENDERSTATE_FILLMODE                 D3DRS_FILLMODE
#define D3DRENDERSTATE_SHADEMODE                D3DRS_SHADEMODE
#define D3DRENDERSTATE_LINEPATTERN              D3DRS_LINEPATTERN
#define D3DRENDERSTATE_ZWRITEENABLE             D3DRS_ZWRITEENABLE
#define D3DRENDERSTATE_ALPHATESTENABLE          D3DRS_ALPHATESTENABLE
#define D3DRENDERSTATE_LASTPIXEL                D3DRS_LASTPIXEL
#define D3DRENDERSTATE_SRCBLEND                 D3DRS_SRCBLEND
#define D3DRENDERSTATE_DESTBLEND                D3DRS_DESTBLEND
#define D3DRENDERSTATE_CULLMODE                 D3DRS_CULLMODE
#define D3DRENDERSTATE_ZFUNC                    D3DRS_ZFUNC
#define D3DRENDERSTATE_ALPHAREF                 D3DRS_ALPHAREF
#define D3DRENDERSTATE_ALPHAFUNC                D3DRS_ALPHAFUNC
#define D3DRENDERSTATE_DITHERENABLE             D3DRS_DITHERENABLE
#define D3DRENDERSTATE_ALPHABLENDENABLE         D3DRS_ALPHABLENDENABLE
#define D3DRENDERSTATE_FOGENABLE                D3DRS_FOGENABLE
#define D3DRENDERSTATE_SPECULARENABLE           D3DRS_SPECULARENABLE
#define D3DRENDERSTATE_ZVISIBLE                 D3DRS_ZVISIBLE
#define D3DRENDERSTATE_FOGCOLOR                 D3DRS_FOGCOLOR
#define D3DRENDERSTATE_FOGTABLEMODE             D3DRS_FOGTABLEMODE
#define D3DRENDERSTATE_FOGSTART                 D3DRS_FOGSTART
#define D3DRENDERSTATE_FOGEND                   D3DRS_FOGEND
#define D3DRENDERSTATE_FOGDENSITY               D3DRS_FOGDENSITY
#define D3DRENDERSTATE_EDGEANTIALIAS            D3DRS_EDGEANTIALIAS
#define D3DRENDERSTATE_ZBIAS                    D3DRS_ZBIAS
#define D3DRENDERSTATE_RANGEFOGENABLE           D3DRS_RANGEFOGENABLE
#define D3DRENDERSTATE_STENCILENABLE            D3DRS_STENCILENABLE
#define D3DRENDERSTATE_STENCILFAIL              D3DRS_STENCILFAIL
#define D3DRENDERSTATE_STENCILZFAIL             D3DRS_STENCILZFAIL
#define D3DRENDERSTATE_STENCILPASS              D3DRS_STENCILPASS
#define D3DRENDERSTATE_STENCILFUNC              D3DRS_STENCILFUNC
#define D3DRENDERSTATE_STENCILREF               D3DRS_STENCILREF
#define D3DRENDERSTATE_STENCILMASK              D3DRS_STENCILMASK
#define D3DRENDERSTATE_STENCILWRITEMASK         D3DRS_STENCILWRITEMASK
#define D3DRENDERSTATE_TEXTUREFACTOR            D3DRS_TEXTUREFACTOR
#define D3DRENDERSTATE_WRAP0                    D3DRS_WRAP0
#define D3DRENDERSTATE_WRAP1                    D3DRS_WRAP1
#define D3DRENDERSTATE_WRAP2                    D3DRS_WRAP2
#define D3DRENDERSTATE_WRAP3                    D3DRS_WRAP3
#define D3DRENDERSTATE_WRAP4                    D3DRS_WRAP4
#define D3DRENDERSTATE_WRAP5                    D3DRS_WRAP5
#define D3DRENDERSTATE_WRAP6                    D3DRS_WRAP6
#define D3DRENDERSTATE_WRAP7                    D3DRS_WRAP7
#define D3DRENDERSTATE_CLIPPING                 D3DRS_CLIPPING
#define D3DRENDERSTATE_LIGHTING                 D3DRS_LIGHTING
#define D3DRENDERSTATE_EXTENTS                  D3DRS_EXTENTS
#define D3DRENDERSTATE_AMBIENT                  D3DRS_AMBIENT
#define D3DRENDERSTATE_FOGVERTEXMODE            D3DRS_FOGVERTEXMODE
#define D3DRENDERSTATE_COLORVERTEX              D3DRS_COLORVERTEX
#define D3DRENDERSTATE_LOCALVIEWER              D3DRS_LOCALVIEWER
#define D3DRENDERSTATE_NORMALIZENORMALS         D3DRS_NORMALIZENORMALS
#define D3DRENDERSTATE_DIFFUSEMATERIALSOURCE    D3DRS_DIFFUSEMATERIALSOURCE
#define D3DRENDERSTATE_SPECULARMATERIALSOURCE   D3DRS_SPECULARMATERIALSOURCE
#define D3DRENDERSTATE_AMBIENTMATERIALSOURCE    D3DRS_AMBIENTMATERIALSOURCE
#define D3DRENDERSTATE_EMISSIVEMATERIALSOURCE   D3DRS_EMISSIVEMATERIALSOURCE
#define D3DRENDERSTATE_VERTEXBLEND              D3DRS_VERTEXBLEND
#define D3DRENDERSTATE_CLIPPLANEENABLE          D3DRS_CLIPPLANEENABLE

#define RGBA_MAKE                               D3DCOLOR_RGBA
#define RGB_MAKE                                D3DCOLOR_XRGB
#define D3DRGBA                                 D3DCOLOR_COLORVALUE
#define D3DRGB(_r,_g,_b)                        D3DCOLOR_COLORVALUE(_r,_g,_b,1.f)

#define _DX7TODX8_H_
#endif //_DX7TODX8_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dxg\obj\i386\xmetal.h ===
/*==========================================================================;
 *
 *  Copyright (C) 2000 - 2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       xmetal.h
 *  Content:    Xbox low-level graphics helpers
 *
 ****************************************************************************/

#ifndef _XMETAL_H_
#define _XMETAL_H_

#ifdef __cplusplus
extern "C"
{
#endif

/****************************************************************************
 *
 * Debug helpers
 *
 ****************************************************************************/

#if DBG

    ULONG _cdecl DbgPrint(PCH Format, ...);

    #define ERROR(msg)            \
        {                       \
            DbgPrint msg;       \
            DbgPrint("\n");     \
            _asm { int 3 };     \
        }

#else !DBG

    #define ERROR(x) {}

#endif !DBG

/****************************************************************************
 *
 * Memory
 *
 ****************************************************************************/

#ifdef FASTPUSHER

#define XMETAL_MEMORY_TYPE_VIDEO           0x80000000
#define XMETAL_MEMORY_TYPE_CONTIGUOUS      0x80000000

#else

#define XMETAL_MEMORY_TYPE_VIDEO           0xF0000000
#define XMETAL_MEMORY_TYPE_CONTIGUOUS      0xF0000000

#endif

#define XMETAL_MAX_PHYSICAL_OFFSET         0x08000000

#if DBG

// Verify that the memory address is a virtual address to a write
// combined mapping of contiguous memory.
//
static __forceinline void XMETAL_DebugVerifyContiguous(
    void *pv
    )
{
    DWORD Type = (DWORD)pv & 0xF0000000;

    if (Type != XMETAL_MEMORY_TYPE_CONTIGUOUS && 
        Type != XMETAL_MEMORY_TYPE_VIDEO)
    {
        ERROR(("DebugVerifyContiguous - the address is not a write combined mapping to contiguous memory."));
    }

    if (((DWORD)pv & 0x0FFFFFFF) > XMETAL_MAX_PHYSICAL_OFFSET)
    {
        ERROR(("DebugVerifyContiguous - the address is not a write combined mapping to contiguous memory."));
    }
}

// Verify that the offset is a valid physical memory offset and can be
// accessed by the graphics processor.
//
static __forceinline void XMETAL_DebugVerifyPhysical(
    DWORD Offset
    )
{
    if (Offset > XMETAL_MAX_PHYSICAL_OFFSET)
    {
        ERROR(("DebugVerifyPhysical - Not a valid physical memory offset."));
    }
}

#else !DBG

static __forceinline void XMETAL_DebugVerifyContiguous(void *pv) { }
static __forceinline void XMETAL_DebugVerifyPhysical(DWORD offset) { }

#endif !DBG

// Map from a write-combined pointer to a physical memory offset.
static __forceinline DWORD XMETAL_MapToPhysicalOffset(
    void *pv
    )
{
    XMETAL_DebugVerifyContiguous(pv);

    return ((DWORD)pv) & (XMETAL_MAX_PHYSICAL_OFFSET - 1);
}

// Map from a physical memory offset to a contiguous memory
// address.
//
static __forceinline void *XMETAL_MapToContiguousAddress(
    DWORD Offset
    )
{
    XMETAL_DebugVerifyPhysical(Offset);

    return (void *)(XMETAL_MEMORY_TYPE_CONTIGUOUS | Offset);
}

// Map from a physical memory offset to a video memory address.  This method
// is temporary and will change to return the exact same value at the
// contiguous address on the final hardware.
//
static __forceinline void *XMETAL_MapToVideoAddress(
    DWORD Offset
    )
{
    XMETAL_DebugVerifyPhysical(Offset);

    return (void *)(XMETAL_MEMORY_TYPE_VIDEO | Offset);
}

/****************************************************************************
 *
 * Push Buffer
 *
 ****************************************************************************/

//
// DOC: Push buffer usage.
//
// All graphics processor commands are queued up in the push buffer.  This 
// buffer is created by Direct3D_CreateDevice at is set to the size specified
// by Direct3D_SetPushBufferSize.  The push buffer is a circular queue.
//
// All commands are pushed as a 4-byte method descriptor which contains the
// command value and a count, followed by that number of 4 byte values.
// Consecutively-numbered commands can be combined simply by providing
// extra values on the end of the first command.
//
// Space in the push buffer can be reserved by calling XMETAL_StartPush,
// which returns a pointer where the commands should be stored.  The space
// is actually committed by calling XMETAL_EndPush.  Not all of the
// reserved space needs to be used and, in fact, will not be used most of
// the time.
//
// The XMETAL_Push* methods write information into the push buffer.  They
// must be used as all of the push buffer methods perform debug checks
// (in the debug build only) to ensure that the reserved space is not
// overrun, that there are no holes, etc.
//
// Multiple commands can be written into the push buffer at a time but the
// push buffer pointer must be manually incremented for each command.
//
// Example:
//
// void PushStuff()
// {
//     XMETAL_PushBuffer *pPusher = g_pPushBuffer;
//
//     PPUSH pPush = XMETAL_StartPush(pPusher);  /* reserves 128 DWORDS */
//
//     XMETAL_Push1(pPush,     CMD_1, 0);         /* method, value */
//     XMETAL_Push2(pPush + 2, CMD_3, 1, 2);      /* method, value, value */
//
//     XMETAL_PushCount(pPush + 5, CMD_10, 3);    /* method, 3 values */
//
//     *(pPush + 6) = 0;    // Value for CMD_10
//     *(pPush + 7) = 1;    // Value for CMD_11
//     *(pPush + 8) = 2;    // Value for CMD_12
//
//     XMETAL_EndPush(pPusher, pPush + 9);        /* commits 9 dwords */
// }
//

//
/*
 * Push buffer allocator
 */

// All writes to the push-buffer should be using a 'volatile' type, 
// otherwise the compiler may be allowed to do the writes out-of-order,
// which is bad for write-combining performance.
//
typedef volatile DWORD* PPUSH;

// Describes the available space in the push buffer.  This structure should
// never be manipulated directly; space should be allocated through the
// StartPush/EndPush methods.
//
typedef struct _XMETAL_PushBuffer 
{
    PPUSH m_pPut;
    PPUSH m_pThreshold;
} XMETAL_PushBuffer;

// The global push buffer pointer.  This pointer is set when 
// Direct3D_CreateDevice is called and will not change unless the device is 
// destroyed.
//
extern XMETAL_PushBuffer *g_pPushBuffer;

// Reserve a specific number of DWORDs in the push buffer and return a pointer
// to the beginning of the reserved block.  This method is not as efficient
// as XMETAL_StartPush and should only be called if more than 128 DWORDs are
// required.
//
// This method cannot fail but may block until there is enough space
// in the push buffer to process the reservation.
//
DWORD * WINAPI XMETAL_StartPushCount(XMETAL_PushBuffer *pPushBuffer, DWORD count);

// Commit the space actually used in the push buffer.  Pass in the pointer
// in the push buffer immediately after the last pushed command.  It is not
// necessary to use all of the space reserved in the push buffer.
//
#if DBG

void WINAPI XMETAL_EndPush(XMETAL_PushBuffer *pPushBuffer, PPUSH pPush);

#else !DBG

static __forceinline void XMETAL_EndPush(XMETAL_PushBuffer *pPushBuffer, PPUSH pPush)
{
    pPushBuffer->m_pPut = pPush;
}

#endif !DBG

/*
 * Method pushing helpers.  This uses '+' instead of '|' because it's more
 * friendly to macros that include add operations.
 */

#define XMETAL_PUSHER_METHOD(method, count) \
            (((count) << 18) + (method))
         
#if !DBG

//----------------------------------------------------------------------------
// PushedRaw - Call this to advance the push pointer after having copied
//             raw data into the pusher buffer
//
static __forceinline VOID XMETAL_PushedRaw(
    PPUSH pPushNext)
{
}

//----------------------------------------------------------------------------
// Push1 - Push one dword
//
static __forceinline VOID XMETAL_Push1(
    PPUSH pPush,
    DWORD method,
    DWORD value)
{
    pPush[0] = XMETAL_PUSHER_METHOD(method, 1);
    pPush[1] = value;
}

//----------------------------------------------------------------------------
// Push2 - Push two dwords
//
static __forceinline VOID XMETAL_Push2(
    PPUSH pPush,
    DWORD method,
    DWORD a,
    DWORD b)
{
    pPush[0] = XMETAL_PUSHER_METHOD(method, 2);
    pPush[1] = a;
    pPush[2] = b;
}

//----------------------------------------------------------------------------
// Push3 - Push three dwords
//
static __forceinline VOID XMETAL_Push3(
    PPUSH pPush,
    DWORD method,
    DWORD a,
    DWORD b,
    DWORD c)
{
    pPush[0] = XMETAL_PUSHER_METHOD(method, 3);
    pPush[1] = a;
    pPush[2] = b;
    pPush[3] = c;
}

//----------------------------------------------------------------------------
// Push4 - Push four dwords
//
static __forceinline VOID XMETAL_Push4(
    PPUSH pPush,
    DWORD method,
    DWORD a,
    DWORD b,
    DWORD c,
    DWORD d)
{
    pPush[0] = XMETAL_PUSHER_METHOD(method, 4);
    pPush[1] = a;
    pPush[2] = b;
    pPush[3] = c;
    pPush[4] = d;
}

//----------------------------------------------------------------------------
// Push1f - Push one float
//
static __forceinline VOID XMETAL_Push1f(
    PPUSH pPush,
    DWORD method,
    FLOAT value)
{
    pPush[0] = XMETAL_PUSHER_METHOD(method, 1);
    ((FLOAT*) pPush)[1] = value;
}

//----------------------------------------------------------------------------
// Push2f - Push two floats
//
static __forceinline VOID XMETAL_Push2f(
    PPUSH pPush,
    DWORD method,
    FLOAT a,
    FLOAT b)
{
    pPush[0] = XMETAL_PUSHER_METHOD(method, 2);
    ((FLOAT*) pPush)[1] = a;
    ((FLOAT*) pPush)[2] = b;
}

//----------------------------------------------------------------------------
// Push3f - Push three floats
//
static __forceinline VOID XMETAL_Push3f(
    PPUSH pPush,
    DWORD method,
    FLOAT a,
    FLOAT b,
    FLOAT c)
{
    pPush[0] = XMETAL_PUSHER_METHOD(method, 3);
    ((FLOAT*) pPush)[1] = a;
    ((FLOAT*) pPush)[2] = b;
    ((FLOAT*) pPush)[3] = c;
}

//----------------------------------------------------------------------------
// Push4f - Push four floats
//
static __forceinline VOID XMETAL_Push4f(
    PPUSH pPush,
    DWORD method,
    FLOAT a,
    FLOAT b,
    FLOAT c,
    FLOAT d)
{
    pPush[0] = XMETAL_PUSHER_METHOD(method, 4);
    ((FLOAT*) pPush)[1] = a;
    ((FLOAT*) pPush)[2] = b;
    ((FLOAT*) pPush)[3] = c;
    ((FLOAT*) pPush)[4] = d;
}

//----------------------------------------------------------------------------
// PushCount - Just push the method, with a specified count of data to follow
//
static __forceinline VOID XMETAL_PushCount(
    PPUSH pPush,
    DWORD method,
    DWORD count)
{
    pPush[0] = XMETAL_PUSHER_METHOD(method, count);
}

#else DBG

//----------------------------------------------------------------------------
// For debug, we have out-of-line routines which do a bunch of extra checks:
//
VOID WINAPI XMETAL_PushedRaw(PPUSH pPushNext);
VOID WINAPI XMETAL_Push1(PPUSH pPush, DWORD method, DWORD value);
VOID WINAPI XMETAL_Push2(PPUSH pPush, DWORD method, DWORD a, DWORD b);
VOID WINAPI XMETAL_Push3(PPUSH pPush, DWORD method, DWORD a, DWORD b, DWORD c);
VOID WINAPI XMETAL_Push4(PPUSH pPush, DWORD method, DWORD a, DWORD b, DWORD c, DWORD d);
VOID WINAPI XMETAL_Push1f(PPUSH pPush, DWORD method, FLOAT value);
VOID WINAPI XMETAL_Push2f(PPUSH pPush, DWORD method, FLOAT a, FLOAT b);
VOID WINAPI XMETAL_Push3f(PPUSH pPush, DWORD method, FLOAT a, FLOAT b, FLOAT c);
VOID WINAPI XMETAL_Push4f(PPUSH pPush, DWORD method, FLOAT a, FLOAT b, FLOAT c, FLOAT d);
VOID WINAPI XMETAL_PushCount(PPUSH pPush, DWORD method, DWORD count);

#endif DBG

#ifdef __cplusplus
}
#endif __cplusplus

#endif _XMETAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\xvoice\inc\xvoice.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       xvoice.h
 *  Content:    Voice include file
 ***************************************************************************/

#ifndef __XVOICE__
#define __XVOICE__

#ifdef __cplusplus
extern "C" {
#endif

const HRESULT QUEUE_S_OK             = S_OK;
const HRESULT QUEUE_E_FAIL           = E_FAIL;
const HRESULT QUEUE_E_OUTOFMEMORY    = E_OUTOFMEMORY;
const HRESULT QUEUE_E_NOINPUTYET     = 0x8000000A;
const HRESULT QUEUE_E_HWMNOTREACHED  = 0x8000000B;
const HRESULT QUEUE_E_FULL           = 0x8000000C;

XBOXAPI
HRESULT
WINAPI 
XVoiceCreateMediaObject(
       IN PXPP_DEVICE_TYPE XppDeviceType, 
	   IN DWORD dwPort, 
	   IN DWORD dwMaxAttachedPackets,
	   IN LPWAVEFORMATEX pwfxFormat, 
	   OUT LPXMEDIAOBJECT *ppMediaObject
	   );

XBOXAPI
HRESULT
WINAPI 
XVoiceEncoderCreateMediaObject(
       IN BOOL fAutoMode, 
	   IN DWORD dwCodecTag, 
	   IN LPWAVEFORMATEX pwfxEncoded, 
	   IN DWORD dwThreshold, 
	   OUT LPXMEDIAOBJECT *ppMediaObject
	   );

XBOXAPI
HRESULT
WINAPI 
XVoiceDecoderCreateMediaObject(
	   IN DWORD dwCodecTag, 
	   IN LPWAVEFORMATEX pwfxDecoded, 
	   OUT LPXMEDIAOBJECT *ppMediaObject
	   );

typedef struct _QUEUE_XMO_CONFIG {

	BYTE	cbSize;
	WORD    wVoiceSamplingRate;    
	DWORD   dwCodecTag;    
	WORD    wMsOfDataPerPacket;   
	WORD	wMaxDelay;				     
	WORD	wMinDelay;				     
	WORD	wInitialHighWaterMark;       	                                     
	DOUBLE  dIdealQuality;               
	DOUBLE  dInitialFrameStrength;       	                                     
}QUEUE_XMO_CONFIG , *LPQUEUE_XMO_CONFIG;

typedef struct _PCM_INFO {

	BYTE	cbSize;		
	INT     nMaxPower;  
}PCM_INFO , *LPPCM_INFO;

typedef struct XVoiceQueueMediaObject XVoiceQueueMediaObject , *LPXVOICEQUEUEMEDIAOBJECT;

XBOXAPI 
HRESULT 
WINAPI 
XVoiceQueueCreateMediaObject(
       IN LPQUEUE_XMO_CONFIG pConfig , 
	   OUT LPXVOICEQUEUEMEDIAOBJECT *ppVoiceQueueMediaObject
	   );

XBOXAPI
HRESULT
WINAPI 
XVoiceGetCodecBufferSize( 
       IN const LPXMEDIAOBJECT pCodecMediaObject, 
	   IN WORD wPCMBufferSize , 
	   OUT WORD *pwCodecBufferSize
	   );

#undef INTERFACE
#define INTERFACE XVoiceQueueMediaObject

DECLARE_INTERFACE_(XVoiceQueueMediaObject, XMediaObject)
{
    // IUnknown methods
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // XMediaObject methods
    STDMETHOD(GetInfo)(THIS_ LPXMEDIAINFO pInfo) PURE;
    STDMETHOD(GetStatus)(THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Process)(THIS_ LPCXMEDIAPACKET pInputPacket, LPCXMEDIAPACKET pOutputPacket) PURE;
    STDMETHOD(Discontinuity)(THIS) PURE;
    STDMETHOD(Flush)(THIS) PURE;

    // XVoiceQueueMediaObject methods
    STDMETHOD(GetLastOutputInfo)(THIS_ LPPCM_INFO pPCMInfo) PURE;
};

#define XVoiceQueueMediaObject_AddRef             IUnknown_AddRef
#define XVoiceQueueMediaObject_Release            IUnknown_Release

#define XVoiceQueueMediaObject_GetInfo            XMediaObject_GetInfo
#define XVoiceQueueMediaObject_GetStatus          XMediaObject_GetStatus
#define XVoiceQueueMediaObject_Process            XMediaObject_Process
#define XVoiceQueueMediaObject_Discontinuity      XMediaObject_Discontinuity
#define XVoiceQueueMediaObject_Flush              XMediaObject_Flush

#if defined(__cplusplus) && !defined(CINTERFACE)

#define XVoiceQueueMediaObject_GetLastOutputInfo(p, a)    p->GetLastOutputInfo(a)

#else // defined(__cplusplus) && !defined(CINTERFACE)

#define XVoiceQueueMediaObject_GetLastOutputInfo(p, a)    p->lpVtbl->GetLastOutputInfo(p, a)

#endif // defined(__cplusplus) && !defined(CINTERFACE)

#ifdef __cplusplus
}
#endif

#endif  // __XVOICE__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\dxg\obj\i386\d3dx8mesh.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1998 - 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8mesh.h
//  Content:    D3DX mesh types and functions
//
//////////////////////////////////////////////////////////////////////////////

#include "d3dx8.h"

#ifndef __D3DX8MESH_H__
#define __D3DX8MESH_H__

#include "dxfile.h"     // defines LPDIRECTXFILEDATA

// {A69BA991-1F7D-11d3-B929-00C04F68DC23}
DEFINE_GUID(IID_ID3DXBaseMesh,
0xa69ba991, 0x1f7d, 0x11d3, 0xb9, 0x29, 0x0, 0xc0, 0x4f, 0x68, 0xdc, 0x23);

// {9D84AC46-6B90-49a9-A721-085C7A3E3DAE}
DEFINE_GUID(IID_ID3DXMesh,
0x9d84ac46, 0x6b90, 0x49a9, 0xa7, 0x21, 0x8, 0x5c, 0x7a, 0x3e, 0x3d, 0xae);

// {15981AA8-1A05-48e3-BBE7-FF5D49654E3F}
DEFINE_GUID(IID_ID3DXPMesh,
0x15981aa8, 0x1a05, 0x48e3, 0xbb, 0xe7, 0xff, 0x5d, 0x49, 0x65, 0x4e, 0x3f);

// {BC3BBDE2-1F7D-11d3-B929-00C04F68DC23}
DEFINE_GUID(IID_ID3DXSPMesh,
0xbc3bbde2, 0x1f7d, 0x11d3, 0xb9, 0x29, 0x0, 0xc0, 0x4f, 0x68, 0xdc, 0x23);

// {82A53844-F322-409e-A2E9-992E1104069D}
DEFINE_GUID(IID_ID3DXSkinMesh,
0x82a53844, 0xf322, 0x409e, 0xa2, 0xe9, 0x99, 0x2e, 0x11, 0x4, 0x6, 0x9d);


enum _D3DXMESH {
    D3DXMESH_32BIT                  = 0x001, // If set, then use 32 bit indices, if not set use 16 bit indices. 32BIT meshes currently not supported on ID3DXSkinMesh object
    D3DXMESH_DONOTCLIP              = 0x002, // Use D3DUSAGE_DONOTCLIP for VB & IB.
    D3DXMESH_POINTS                 = 0x004, // Use D3DUSAGE_POINTS for VB & IB.
    D3DXMESH_RTPATCHES              = 0x008, // Use D3DUSAGE_RTPATCHES for VB & IB.
    D3DXMESH_NPATCHES               = 0x4000,// Use D3DUSAGE_NPATCHES for VB & IB.
    D3DXMESH_VB_SYSTEMMEM           = 0x010, // Use D3DPOOL_SYSTEMMEM for VB. Overrides D3DXMESH_MANAGEDVERTEXBUFFER
    D3DXMESH_VB_MANAGED             = 0x020, // Use D3DPOOL_MANAGED for VB.
    D3DXMESH_VB_WRITEONLY           = 0x040, // Use D3DUSAGE_WRITEONLY for VB.
    D3DXMESH_VB_DYNAMIC             = 0x080, // Use D3DUSAGE_DYNAMIC for VB.
    D3DXMESH_IB_SYSTEMMEM           = 0x100, // Use D3DPOOL_SYSTEMMEM for IB. Overrides D3DXMESH_MANAGEDINDEXBUFFER
    D3DXMESH_IB_MANAGED             = 0x200, // Use D3DPOOL_MANAGED for IB.
    D3DXMESH_IB_WRITEONLY           = 0x400, // Use D3DUSAGE_WRITEONLY for IB.
    D3DXMESH_IB_DYNAMIC             = 0x800, // Use D3DUSAGE_DYNAMIC for IB.

    D3DXMESH_VB_SHARE               = 0x1000, // Valid for Clone* calls only, forces cloned mesh/pmesh to share vertex buffer

    D3DXMESH_USEHWONLY              = 0x2000, // Valid for ID3DXSkinMesh::ConvertToBlendedMesh

    // Helper options
    D3DXMESH_SYSTEMMEM              = 0x110, // D3DXMESH_VB_SYSTEMMEM | D3DXMESH_IB_SYSTEMMEM
    D3DXMESH_MANAGED                = 0x220, // D3DXMESH_VB_MANAGED | D3DXMESH_IB_MANAGED
    D3DXMESH_WRITEONLY              = 0x440, // D3DXMESH_VB_WRITEONLY | D3DXMESH_IB_WRITEONLY
    D3DXMESH_DYNAMIC                = 0x880, // D3DXMESH_VB_DYNAMIC | D3DXMESH_IB_DYNAMIC

};

// option field values for specifying min value in D3DXGeneratePMesh and D3DXSimplifyMesh
enum _D3DXMESHSIMP
{
    D3DXMESHSIMP_VERTEX   = 0x1,
    D3DXMESHSIMP_FACE     = 0x2,

};

enum _MAX_FVF_DECL_SIZE
{
    MAX_FVF_DECL_SIZE = 20
};

typedef struct ID3DXBaseMesh *LPD3DXBASEMESH;
typedef struct ID3DXMesh *LPD3DXMESH;
typedef struct ID3DXPMesh *LPD3DXPMESH;
typedef struct ID3DXSPMesh *LPD3DXSPMESH;
typedef struct ID3DXSkinMesh *LPD3DXSKINMESH;

typedef struct _D3DXATTRIBUTERANGE
{
    DWORD AttribId;
    DWORD FaceStart;
    DWORD FaceCount;
    DWORD VertexStart;
    DWORD VertexCount;
} D3DXATTRIBUTERANGE;

typedef D3DXATTRIBUTERANGE* LPD3DXATTRIBUTERANGE;

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus
struct D3DXMATERIAL
{
    D3DMATERIAL8  MatD3D;
    LPSTR         pTextureFilename;
};
typedef struct D3DXMATERIAL *LPD3DXMATERIAL;
#ifdef __cplusplus
}
#endif //__cplusplus

typedef struct _D3DXATTRIBUTEWEIGHTS
{
    FLOAT Position;
    FLOAT Boundary;
    FLOAT Normal;
    FLOAT Diffuse;
    FLOAT Specular;
    FLOAT Tex[8];
} D3DXATTRIBUTEWEIGHTS;

typedef D3DXATTRIBUTEWEIGHTS* LPD3DXATTRIBUTEWEIGHTS;

DECLARE_INTERFACE_(ID3DXBaseMesh, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXBaseMesh
    STDMETHOD(DrawSubset)(THIS_ DWORD AttribId) PURE;
    STDMETHOD_(DWORD, GetNumFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetNumVertices)(THIS) PURE;
    STDMETHOD_(DWORD, GetFVF)(THIS) PURE;
    STDMETHOD(GetDeclaration)(THIS_ DWORD Declaration[MAX_FVF_DECL_SIZE]) PURE;
    STDMETHOD_(DWORD, GetOptions)(THIS) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(CloneMeshFVF)(THIS_ DWORD Options,
                DWORD FVF, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(CloneMesh)(THIS_ DWORD Options,
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(GetVertexBuffer)(THIS_ LPDIRECT3DVERTEXBUFFER8* ppVB) PURE;
    STDMETHOD(GetIndexBuffer)(THIS_ LPDIRECT3DINDEXBUFFER8* ppIB) PURE;
    STDMETHOD(LockVertexBuffer)(THIS_ DWORD Flags, BYTE** ppData) PURE;
    STDMETHOD(UnlockVertexBuffer)(THIS) PURE;
    STDMETHOD(LockIndexBuffer)(THIS_ DWORD Flags, BYTE** ppData) PURE;
    STDMETHOD(UnlockIndexBuffer)(THIS) PURE;
    STDMETHOD(GetAttributeTable)(
                THIS_ D3DXATTRIBUTERANGE *pAttribTable, DWORD* pAttribTableSize) PURE;
};

DECLARE_INTERFACE_(ID3DXMesh, ID3DXBaseMesh)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXBaseMesh
    STDMETHOD(DrawSubset)(THIS_ DWORD AttribId) PURE;
    STDMETHOD_(DWORD, GetNumFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetNumVertices)(THIS) PURE;
    STDMETHOD_(DWORD, GetFVF)(THIS) PURE;
    STDMETHOD(GetDeclaration)(THIS_ DWORD Declaration[MAX_FVF_DECL_SIZE]) PURE;
    STDMETHOD_(DWORD, GetOptions)(THIS) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(CloneMeshFVF)(THIS_ DWORD Options,
                DWORD FVF, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(CloneMesh)(THIS_ DWORD Options,
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(GetVertexBuffer)(THIS_ LPDIRECT3DVERTEXBUFFER8* ppVB) PURE;
    STDMETHOD(GetIndexBuffer)(THIS_ LPDIRECT3DINDEXBUFFER8* ppIB) PURE;
    STDMETHOD(LockVertexBuffer)(THIS_ DWORD Flags, BYTE** ppData) PURE;
    STDMETHOD(UnlockVertexBuffer)(THIS) PURE;
    STDMETHOD(LockIndexBuffer)(THIS_ DWORD Flags, BYTE** ppData) PURE;
    STDMETHOD(UnlockIndexBuffer)(THIS) PURE;
    STDMETHOD(GetAttributeTable)(
                THIS_ D3DXATTRIBUTERANGE *pAttribTable, DWORD* pAttribTableSize) PURE;

    // ID3DXMesh
    STDMETHOD(LockAttributeBuffer)(THIS_ DWORD Flags, DWORD** ppData) PURE;
    STDMETHOD(UnlockAttributeBuffer)(THIS) PURE;
    STDMETHOD(ConvertPointRepsToAdjacency)(THIS_ CONST DWORD* pPRep, DWORD* pAdjacency) PURE;
    STDMETHOD(ConvertAdjacencyToPointReps)(THIS_ CONST DWORD* pAdjacency, DWORD* pPRep) PURE;
    STDMETHOD(GenerateAdjacency)(THIS_ FLOAT fEpsilon, DWORD* pAdjacency) PURE;
    STDMETHOD(Optimize)(THIS_ DWORD Flags, CONST DWORD* pAdjacencyIn, DWORD* pAdjacencyOut,
                     DWORD* pFaceRemap, LPD3DXBUFFER *ppVertexRemap,
                     LPD3DXMESH* ppOptMesh) PURE;
    STDMETHOD(OptimizeInplace)(THIS_ DWORD Flags, CONST DWORD* pAdjacencyIn, DWORD* pAdjacencyOut,
                     DWORD* pFaceRemap, LPD3DXBUFFER *ppVertexRemap) PURE;
};

DECLARE_INTERFACE_(ID3DXPMesh, ID3DXBaseMesh)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXBaseMesh
    STDMETHOD(DrawSubset)(THIS_ DWORD AttribId) PURE;
    STDMETHOD_(DWORD, GetNumFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetNumVertices)(THIS) PURE;
    STDMETHOD_(DWORD, GetFVF)(THIS) PURE;
    STDMETHOD(GetDeclaration)(THIS_ DWORD Declaration[MAX_FVF_DECL_SIZE]) PURE;
    STDMETHOD_(DWORD, GetOptions)(THIS) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(CloneMeshFVF)(THIS_ DWORD Options,
                DWORD FVF, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(CloneMesh)(THIS_ DWORD Options,
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(GetVertexBuffer)(THIS_ LPDIRECT3DVERTEXBUFFER8* ppVB) PURE;
    STDMETHOD(GetIndexBuffer)(THIS_ LPDIRECT3DINDEXBUFFER8* ppIB) PURE;
    STDMETHOD(LockVertexBuffer)(THIS_ DWORD Flags, BYTE** ppData) PURE;
    STDMETHOD(UnlockVertexBuffer)(THIS) PURE;
    STDMETHOD(LockIndexBuffer)(THIS_ DWORD Flags, BYTE** ppData) PURE;
    STDMETHOD(UnlockIndexBuffer)(THIS) PURE;
    STDMETHOD(GetAttributeTable)(
                THIS_ D3DXATTRIBUTERANGE *pAttribTable, DWORD* pAttribTableSize) PURE;

    // ID3DXPMesh
    STDMETHOD(ClonePMeshFVF)(THIS_ DWORD Options,
                DWORD FVF, LPDIRECT3DDEVICE8 pD3D, LPD3DXPMESH* ppCloneMesh) PURE;
    STDMETHOD(ClonePMesh)(THIS_ DWORD Options,
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3D, LPD3DXPMESH* ppCloneMesh) PURE;
    STDMETHOD(SetNumFaces)(THIS_ DWORD Faces) PURE;
    STDMETHOD(SetNumVertices)(THIS_ DWORD Vertices) PURE;
    STDMETHOD_(DWORD, GetMaxFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetMinFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetMaxVertices)(THIS) PURE;
    STDMETHOD_(DWORD, GetMinVertices)(THIS) PURE;
    STDMETHOD(Save)(THIS_ IStream *pStream, LPD3DXMATERIAL pMaterials, DWORD NumMaterials) PURE;

    STDMETHOD(Optimize)(THIS_ DWORD Flags, DWORD* pAdjacencyOut,
                     DWORD* pFaceRemap, LPD3DXBUFFER *ppVertexRemap,
                     LPD3DXMESH* ppOptMesh) PURE;
    STDMETHOD(GetAdjacency)(THIS_ DWORD* pAdjacency) PURE;
};

DECLARE_INTERFACE_(ID3DXSPMesh, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXSPMesh
    STDMETHOD_(DWORD, GetNumFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetNumVertices)(THIS) PURE;
    STDMETHOD_(DWORD, GetFVF)(THIS) PURE;
    STDMETHOD(GetDeclaration)(THIS_ DWORD Declaration[MAX_FVF_DECL_SIZE]) PURE;
    STDMETHOD_(DWORD, GetOptions)(THIS) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(CloneMeshFVF)(THIS_ DWORD Options,
                DWORD FVF, LPDIRECT3DDEVICE8 pD3D, DWORD *pAdjacencyOut, DWORD *pVertexRemapOut, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(CloneMesh)(THIS_ DWORD Options,
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3DDevice, DWORD *pAdjacencyOut, DWORD *pVertexRemapOut, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(ClonePMeshFVF)(THIS_ DWORD Options,
                DWORD FVF, LPDIRECT3DDEVICE8 pD3D, DWORD *pVertexRemapOut, LPD3DXPMESH* ppCloneMesh) PURE;
    STDMETHOD(ClonePMesh)(THIS_ DWORD Options,
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3D, DWORD *pVertexRemapOut, LPD3DXPMESH* ppCloneMesh) PURE;
    STDMETHOD(ReduceFaces)(THIS_ DWORD Faces) PURE;
    STDMETHOD(ReduceVertices)(THIS_ DWORD Vertices) PURE;
    STDMETHOD_(DWORD, GetMaxFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetMaxVertices)(THIS) PURE;
};

#define UNUSED16 (0xffff)
#define UNUSED32 (0xffffffff)

// ID3DXMesh::Optimize options
enum _D3DXMESHOPT {
    D3DXMESHOPT_COMPACT       = 0x001,
    D3DXMESHOPT_ATTRSORT      = 0x002,
    D3DXMESHOPT_VERTEXCACHE   = 0x004,
    D3DXMESHOPT_STRIPREORDER  = 0x008,
    D3DXMESHOPT_IGNOREVERTS   = 0x010,  // optimize faces only, don't touch vertices
    D3DXMESHOPT_SHAREVB       = 0x020,
};

// Subset of the mesh that has the same attribute and bone combination.
// This subset can be rendered in a single draw call
typedef struct _D3DXBONECOMBINATION
{
    DWORD AttribId;
    DWORD FaceStart;
    DWORD FaceCount;
    DWORD VertexStart;
    DWORD VertexCount;
    DWORD* BoneId;
} D3DXBONECOMBINATION, *LPD3DXBONECOMBINATION;

DECLARE_INTERFACE_(ID3DXSkinMesh, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXMesh
    STDMETHOD_(DWORD, GetNumFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetNumVertices)(THIS) PURE;
    STDMETHOD_(DWORD, GetFVF)(THIS) PURE;
    STDMETHOD(GetDeclaration)(THIS_ DWORD Declaration[MAX_FVF_DECL_SIZE]) PURE;
    STDMETHOD_(DWORD, GetOptions)(THIS) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(GetVertexBuffer)(THIS_ LPDIRECT3DVERTEXBUFFER8* ppVB) PURE;
    STDMETHOD(GetIndexBuffer)(THIS_ LPDIRECT3DINDEXBUFFER8* ppIB) PURE;
    STDMETHOD(LockVertexBuffer)(THIS_ DWORD flags, BYTE** ppData) PURE;
    STDMETHOD(UnlockVertexBuffer)(THIS) PURE;
    STDMETHOD(LockIndexBuffer)(THIS_ DWORD flags, BYTE** ppData) PURE;
    STDMETHOD(UnlockIndexBuffer)(THIS) PURE;
    STDMETHOD(LockAttributeBuffer)(THIS_ DWORD flags, DWORD** ppData) PURE;
    STDMETHOD(UnlockAttributeBuffer)(THIS) PURE;
    // ID3DXSkinMesh
    STDMETHOD_(DWORD, GetNumBones)(THIS) PURE;
    STDMETHOD(GetOriginalMesh)(THIS_ LPD3DXMESH* ppMesh) PURE;
    STDMETHOD(SetBoneInfluence)(THIS_ DWORD bone, DWORD numInfluences, CONST DWORD* vertices, CONST FLOAT* weights) PURE;
    STDMETHOD_(DWORD, GetNumBoneInfluences)(THIS_ DWORD bone) PURE;
    STDMETHOD(GetBoneInfluence)(THIS_ DWORD bone, DWORD* vertices, FLOAT* weights) PURE;
    STDMETHOD(GetMaxVertexInfluences)(THIS_ DWORD* maxVertexInfluences) PURE;
    STDMETHOD(GetMaxFaceInfluences)(THIS_ DWORD* maxFaceInfluences) PURE;
    STDMETHOD(ConvertToBlendedMesh)(THIS_ DWORD options, CONST LPDWORD pAdjacencyIn, LPDWORD pAdjacencyOut,
                            DWORD* pNumBoneCombinations, LPD3DXBUFFER* ppBoneCombinationTable, LPD3DXMESH* ppMesh) PURE;
    STDMETHOD(ConvertToIndexedBlendedMesh)(THIS_ DWORD options,
                                           CONST LPDWORD pAdjacencyIn,
                                           DWORD paletteSize,
                                           LPDWORD pAdjacencyOut,
                                           DWORD* pNumBoneCombinations,
                                           LPD3DXBUFFER* ppBoneCombinationTable,
                                           LPD3DXMESH* ppMesh) PURE;
    STDMETHOD(GenerateSkinnedMesh)(THIS_ DWORD options, FLOAT minWeight, CONST LPDWORD pAdjacencyIn, LPDWORD pAdjacencyOut, LPD3DXMESH* ppMesh) PURE;
    STDMETHOD(UpdateSkinnedMesh)(THIS_ CONST D3DXMATRIX* pBoneTransforms, LPD3DXMESH pMesh) PURE;
};

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

HRESULT WINAPI
    D3DXCreateMesh(
        DWORD NumFaces,
        DWORD NumVertices,
        DWORD Options,
        CONST DWORD *pDeclaration,
        LPDIRECT3DDEVICE8 pD3D,
        LPD3DXMESH* ppMesh);

HRESULT WINAPI
    D3DXCreateMeshFVF(
        DWORD NumFaces,
        DWORD NumVertices,
        DWORD Options,
        DWORD FVF,
        LPDIRECT3DDEVICE8 pD3D,
        LPD3DXMESH* ppMesh);

HRESULT WINAPI
    D3DXCreateSPMesh(
        LPD3DXMESH pMesh,
        CONST DWORD* pAdjacency,
        CONST LPD3DXATTRIBUTEWEIGHTS pVertexAttributeWeights,
        CONST FLOAT *pVertexWeights,
        LPD3DXSPMESH* ppSMesh);

// clean a mesh up for simplification, try to make manifold
HRESULT WINAPI
    D3DXCleanMesh(
    LPD3DXMESH pMeshIn,
    CONST DWORD* pAdjacency,
    LPD3DXMESH* ppMeshOut);

HRESULT WINAPI
    D3DXValidMesh(
    LPD3DXMESH pMeshIn,
    CONST DWORD* pAdjacency);

HRESULT WINAPI
    D3DXGeneratePMesh(
        LPD3DXMESH pMesh,
        CONST DWORD* pAdjacency,
        CONST LPD3DXATTRIBUTEWEIGHTS pVertexAttributeWeights,
        CONST FLOAT *pVertexWeights,
        DWORD MinValue,
        DWORD Options,
        LPD3DXPMESH* ppPMesh);

HRESULT WINAPI
    D3DXSimplifyMesh(
        LPD3DXMESH pMesh,
        CONST DWORD* pAdjacency,
        CONST LPD3DXATTRIBUTEWEIGHTS pVertexAttributeWeights,
        CONST FLOAT *pVertexWeights,
        DWORD MinValue,
        DWORD Options,
        LPD3DXMESH* ppMesh);

HRESULT WINAPI
    D3DXComputeBoundingSphere(
        PVOID pPointsFVF,
        DWORD NumVertices,
        DWORD FVF,
        D3DXVECTOR3 *pCenter,
        FLOAT *pRadius);

HRESULT WINAPI
    D3DXComputeBoundingBox(
        PVOID pPointsFVF,
        DWORD NumVertices,
        DWORD FVF,
        D3DXVECTOR3 *pMin,
        D3DXVECTOR3 *pMax);

HRESULT WINAPI
    D3DXComputeNormals(
        LPD3DXBASEMESH pMesh);

HRESULT WINAPI
    D3DXCreateBuffer(
        DWORD NumBytes,
        LPD3DXBUFFER *ppBuffer);


HRESULT WINAPI
    D3DXLoadMeshFromX(
        LPSTR pFilename,
        DWORD Options,
        LPDIRECT3DDEVICE8 pD3D,
        LPD3DXBUFFER *ppAdjacency,
        LPD3DXBUFFER *ppMaterials,
        PDWORD pNumMaterials,
        LPD3DXMESH *ppMesh);

HRESULT WINAPI
    D3DXSaveMeshToX(
        LPSTR pFilename,
        LPD3DXMESH pMesh,
        CONST DWORD* pAdjacency,
        CONST LPD3DXMATERIAL pMaterials,
        DWORD NumMaterials,
        DWORD Format
        );

HRESULT WINAPI
    D3DXCreatePMeshFromStream(
        IStream *pStream,
    DWORD Options,
        LPDIRECT3DDEVICE8 pD3DDevice,
        LPD3DXBUFFER *ppMaterials,
        DWORD* pNumMaterials,
        LPD3DXPMESH *ppPMesh);

HRESULT WINAPI
    D3DXCreateSkinMesh(
        DWORD numFaces,
        DWORD numVertices,
        DWORD numBones,
        DWORD options,
        CONST DWORD *pDeclaration,
        LPDIRECT3DDEVICE8 pD3D,
        LPD3DXSKINMESH* ppSkinMesh);

HRESULT WINAPI
    D3DXCreateSkinMeshFVF(
        DWORD numFaces,
        DWORD numVertices,
        DWORD numBones,
        DWORD options,
        DWORD fvf,
        LPDIRECT3DDEVICE8 pD3D,
        LPD3DXSKINMESH* ppSkinMesh);

HRESULT WINAPI
    D3DXCreateSkinMeshFromMesh(
        LPD3DXMESH pMesh,
        DWORD numBones,
        LPD3DXSKINMESH* ppSkinMesh);

HRESULT WINAPI
    D3DXLoadMeshFromXof(
        LPDIRECTXFILEDATA pXofObjMesh,
        DWORD Options,
        LPDIRECT3DDEVICE8 pD3DDevice,
        LPD3DXBUFFER *ppAdjacency,
        LPD3DXBUFFER *ppMaterials,
        PDWORD pNumMaterials,
        LPD3DXMESH *ppMesh);

HRESULT WINAPI
    D3DXLoadSkinMeshFromXof(
        LPDIRECTXFILEDATA pxofobjMesh,
        DWORD options,
        LPDIRECT3DDEVICE8 pD3D,
        LPD3DXBUFFER* ppAdjacency,
        LPD3DXBUFFER* ppMaterials,
        PDWORD pMatOut,
        LPD3DXBUFFER* ppBoneNames,
        LPD3DXBUFFER* ppBoneTransforms,
        LPD3DXSKINMESH* ppMesh);

HRESULT WINAPI
    D3DXTesselateMesh(
        LPD3DXMESH pMeshIn,
        CONST DWORD* pAdjacency,
        FLOAT NumSegs,
        BOOL  QuadraticInterpNormals,     // if false use linear intrep for normals, if true use quadratic
        LPD3DXMESH *ppMeshOut);

HRESULT WINAPI
    D3DXDeclaratorFromFVF(
        DWORD FVF,
        DWORD Declaration[MAX_FVF_DECL_SIZE]);

HRESULT WINAPI
    D3DXFVFFromDeclarator(
        CONST DWORD *pDeclarator,
        DWORD *pFVF);

HRESULT WINAPI
    D3DXWeldVertices(
        CONST LPD3DXMESH pMesh,
        float fEpsilon,
        CONST DWORD *rgdwAdjacencyIn,
        DWORD *rgdwAdjacencyOut,
        DWORD* pFaceRemap,
        LPD3DXBUFFER *ppbufVertexRemap);

HRESULT WINAPI
    D3DXIntersect(
        LPD3DXBASEMESH pMesh,
        CONST D3DXVECTOR3 *pRayPos,
        CONST D3DXVECTOR3 *pRayDir,
        BOOL    *pHit,
        DWORD   *pFaceIndex,
        FLOAT   *pU,
        FLOAT   *pV,
        FLOAT   *pDist);

BOOL WINAPI
    D3DXSphereBoundProbe(
        CONST D3DXVECTOR3 *pvCenter,
        FLOAT fRadius,
        D3DXVECTOR3 *pvRayPosition,
        D3DXVECTOR3 *pvRayDirection);

BOOL WINAPI
    D3DXBoxBoundProbe(
        CONST D3DXVECTOR3 *pvMin,
        CONST D3DXVECTOR3 *pvMax,
        D3DXVECTOR3 *pvRayPosition,
        D3DXVECTOR3 *pvRayDirection);

enum _D3DXERR {
    D3DXERR_CANNOTMODIFYINDEXBUFFER     = MAKE_DDHRESULT(2900),
    D3DXERR_INVALIDMESH                 = MAKE_DDHRESULT(2901),
    D3DXERR_CANNOTATTRSORT              = MAKE_DDHRESULT(2902),
    D3DXERR_SKINNINGNOTSUPPORTED        = MAKE_DDHRESULT(2903),
    D3DXERR_TOOMANYINFLUENCES           = MAKE_DDHRESULT(2904),
    D3DXERR_INVALIDDATA                 = MAKE_DDHRESULT(2905),
};

#ifdef __cplusplus
}
#endif //__cplusplus

#endif //__D3DX8MESH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\xvchat\inc\makefile.inc ===
xvchat.h: xvchat.x
    sed "/@@BEGIN_MSINTERNAL/,/@@END_MSINTERNAL/D" $? > $@

$(PRIVATE_INC_PATH)\xvchatp.h: xvchat.x
    copy $? $@

{}.h{$(SDK_INC_PATH)}.h:
    copy $** $@

{}.h{$(XDK_INC_PATH)}.h:
    copy $** $@

clean:
	del /F /Q $(NTTARGETFILE0)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\xvoice\inc\makefile.inc ===
xvoice.h: xvoice.x
    sed "/@@BEGIN_MSINTERNAL/,/@@END_MSINTERNAL/D" $? > $@

$(PRIVATE_INC_PATH)\xvoicep.h: xvoice.x
    copy $? $@

{}.h{$(SDK_INC_PATH)}.h:
    copy $** $@

{}.h{$(XDK_INC_PATH)}.h:
    copy $** $@

clean:
	del /F /Q $(NTTARGETFILE0)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\directx\xact\inc\makefile.inc ===
headers: clean \
         $(PRIVATE_INC_PATH)\xactp.h \
         $(SDK_INC_PATH)\xact.h \
         $(XDK_INC_PATH)\xact.h 

$(PRIVATE_INC_PATH)\xactp.h: xact.x
    copy $? $@

$(SDK_INC_PATH)\xact.h: xact.x
    sed "/@@BEGIN_MSINTERNAL/,/@@END_MSINTERNAL/D" $? > $@

$(XDK_INC_PATH)\xact.h: xact.x
    sed "/@@BEGIN_MSINTERNAL/,/@@END_MSINTERNAL/D" $? > $@

clean:
    if exist $(PRIVATE_INC_PATH)\xactp.h      del /f /q $(PRIVATE_INC_PATH)\xactp.h
    if exist $(SDK_INC_PATH)\xact.h           del /f /q $(SDK_INC_PATH)\xact.h
    if exist $(XDK_INC_PATH)\xact.h           del /f /q $(XDK_INC_PATH)\xact.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\nlsmsg\makefile.inc ===
WINERROR_TARGETS=$(SDK_INC_PATH)\winerror.h   \
                 $(SDK_INC_PATH)\winerror.dbg \
                 $(XDK_INC_PATH)\winerror.h   \
                 $(O)\msg00001.bin            \
                 $(O)\winerror.rc

clean:
    del /Q /F $(WINERROR_TARGETS)

$(SDK_INC_PATH)\winerror.h : $(O)\winerror.h
    copy $** $@

$(XDK_INC_PATH)\winerror.h : $(O)\winerror.h
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\nls\makefile.inc ===
NTSTATUS=    $(SDK_INC_PATH)\ntstatus.h \
             $(SDK_INC_PATH)\ntstatus.dbg \
             $(O)\msg00001.bin \
             $(O)\ntstatus.rc

clean:
    -del /Q /F $(NTSTATUS)

$(SDK_INC_PATH)\ntstatus.h : $(O)\ntstatus.h
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\ntos\nls\makefile.inc ===
clean:
    -del /f /q $(NTTARGETFILES)

$(BASEDIR)\public\sdk\inc\bugcodes.h : $(O)\bugcodes.h
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\genx\nls\obj\i386\ntstatus.h ===
/*++ BUILD Version: 0005    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    ntstatus.h

Abstract:

    Constant definitions for the NTSTATUS values.

Author:

    Portable Systems Group 30-Mar-1989

Revision History:

Notes:

    This file is generated by the MC tool from the winerror.msg file.

    Please add new error values to the end of the file. To do otherwise
    will jumble the error values.

--*/

#ifndef _NTSTATUS_
#define _NTSTATUS_

#ifndef WIN32_NO_STATUS // winnt
// begin_ntsecapi

/*lint -save -e767 */  // Don't complain about different definitions // winnt



/////////////////////////////////////////////////////////////////////////
//
// Standard Success values
//
//
/////////////////////////////////////////////////////////////////////////


//
// The success status codes 0 - 63 are reserved for wait completion status.
// FacilityCodes 0x5 - 0xF have been allocated by various drivers.
//
#define STATUS_SUCCESS                          ((NTSTATUS)0x00000000L) // ntsubauth

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_XBOX_ERROR_CODE         0x5
#define FACILITY_USB_ERROR_CODE          0x10
#define FACILITY_RPC_STUBS               0x3
#define FACILITY_RPC_RUNTIME             0x2
#define FACILITY_IO_ERROR_CODE           0x4
#define FACILITY_HID_ERROR_CODE          0x11
#define FACILITY_DEBUGGER                0x1


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: STATUS_WAIT_0
//
// MessageText:
//
//  STATUS_WAIT_0
//
#define STATUS_WAIT_0                    ((NTSTATUS)0x00000000L)    // winnt

//
// MessageId: STATUS_WAIT_1
//
// MessageText:
//
//  STATUS_WAIT_1
//
#define STATUS_WAIT_1                    ((NTSTATUS)0x00000001L)

//
// MessageId: STATUS_WAIT_2
//
// MessageText:
//
//  STATUS_WAIT_2
//
#define STATUS_WAIT_2                    ((NTSTATUS)0x00000002L)

//
// MessageId: STATUS_WAIT_3
//
// MessageText:
//
//  STATUS_WAIT_3
//
#define STATUS_WAIT_3                    ((NTSTATUS)0x00000003L)

//
// MessageId: STATUS_WAIT_63
//
// MessageText:
//
//  STATUS_WAIT_63
//
#define STATUS_WAIT_63                   ((NTSTATUS)0x0000003FL)


//
// The success status codes 128 - 191 are reserved for wait completion
// status with an abandoned mutant object.
//
#define STATUS_ABANDONED                        ((NTSTATUS)0x00000080L)

//
// MessageId: STATUS_ABANDONED_WAIT_0
//
// MessageText:
//
//  STATUS_ABANDONED_WAIT_0
//
#define STATUS_ABANDONED_WAIT_0          ((NTSTATUS)0x00000080L)    // winnt

//
// MessageId: STATUS_ABANDONED_WAIT_63
//
// MessageText:
//
//  STATUS_ABANDONED_WAIT_63
//
#define STATUS_ABANDONED_WAIT_63         ((NTSTATUS)0x000000BFL)


//
// The success status codes 256, 257, 258, and 258 are reserved for
// User APC, Kernel APC, Alerted, and Timeout.
//
//
// MessageId: STATUS_USER_APC
//
// MessageText:
//
//  STATUS_USER_APC
//
#define STATUS_USER_APC                  ((NTSTATUS)0x000000C0L)    // winnt

//
// MessageId: STATUS_KERNEL_APC
//
// MessageText:
//
//  STATUS_KERNEL_APC
//
#define STATUS_KERNEL_APC                ((NTSTATUS)0x00000100L)

//
// MessageId: STATUS_ALERTED
//
// MessageText:
//
//  STATUS_ALERTED
//
#define STATUS_ALERTED                   ((NTSTATUS)0x00000101L)

//
// MessageId: STATUS_TIMEOUT
//
// MessageText:
//
//  STATUS_TIMEOUT
//
#define STATUS_TIMEOUT                   ((NTSTATUS)0x00000102L)    // winnt

//
// MessageId: STATUS_PENDING
//
// MessageText:
//
//  The operation that was requested is pending completion.
//
#define STATUS_PENDING                   ((NTSTATUS)0x00000103L)    // winnt

//
// MessageId: STATUS_REPARSE
//
// MessageText:
//
//  A reparse should be performed by the Object Manager since the name of the file resulted in a symbolic link.
//
#define STATUS_REPARSE                   ((NTSTATUS)0x00000104L)

//
// MessageId: STATUS_MORE_ENTRIES
//
// MessageText:
//
//  Returned by enumeration APIs to indicate more information is available to successive calls.
//
#define STATUS_MORE_ENTRIES              ((NTSTATUS)0x00000105L)

//
// MessageId: STATUS_NOT_ALL_ASSIGNED
//
// MessageText:
//
//  Indicates not all privileges referenced are assigned to the caller.
//  This allows, for example, all privileges to be disabled without having to know exactly which privileges are assigned.
//
#define STATUS_NOT_ALL_ASSIGNED          ((NTSTATUS)0x00000106L)

//
// MessageId: STATUS_SOME_NOT_MAPPED
//
// MessageText:
//
//  Some of the information to be translated has not been translated.
//
#define STATUS_SOME_NOT_MAPPED           ((NTSTATUS)0x00000107L)

//
// MessageId: STATUS_OPLOCK_BREAK_IN_PROGRESS
//
// MessageText:
//
//  An open/create operation completed while an oplock break is underway.
//
#define STATUS_OPLOCK_BREAK_IN_PROGRESS  ((NTSTATUS)0x00000108L)

//
// MessageId: STATUS_VOLUME_MOUNTED
//
// MessageText:
//
//  A new volume has been mounted by a file system.
//
#define STATUS_VOLUME_MOUNTED            ((NTSTATUS)0x00000109L)

//
// MessageId: STATUS_RXACT_COMMITTED
//
// MessageText:
//
//  This success level status indicates that the transaction state already exists for the registry sub-tree,
//  but that a transaction commit was previously aborted.
//  The commit has now been completed.
//
#define STATUS_RXACT_COMMITTED           ((NTSTATUS)0x0000010AL)

//
// MessageId: STATUS_NOTIFY_CLEANUP
//
// MessageText:
//
//  This indicates that a notify change request has been completed due to closing the handle
//  which made the notify change request.
//
#define STATUS_NOTIFY_CLEANUP            ((NTSTATUS)0x0000010BL)

//
// MessageId: STATUS_NOTIFY_ENUM_DIR
//
// MessageText:
//
//  This indicates that a notify change request is being completed and that the information
//  is not being returned in the caller's buffer.
//  The caller now needs to enumerate the files to find the changes.
//
#define STATUS_NOTIFY_ENUM_DIR           ((NTSTATUS)0x0000010CL)

//
// MessageId: STATUS_NO_QUOTAS_FOR_ACCOUNT
//
// MessageText:
//
//  {No Quotas}
//  No system quota limits are specifically set for this account.
//
#define STATUS_NO_QUOTAS_FOR_ACCOUNT     ((NTSTATUS)0x0000010DL)

//
// MessageId: STATUS_PRIMARY_TRANSPORT_CONNECT_FAILED
//
// MessageText:
//
//  {Connect Failure on Primary Transport}
//  An attempt was made to connect to the remote server %hs on the primary transport, but the connection failed.
//  The computer WAS able to connect on a secondary transport.
//
#define STATUS_PRIMARY_TRANSPORT_CONNECT_FAILED ((NTSTATUS)0x0000010EL)

//
// MessageId: STATUS_PAGE_FAULT_TRANSITION
//
// MessageText:
//
//  Page fault was a transition fault.
//
#define STATUS_PAGE_FAULT_TRANSITION     ((NTSTATUS)0x00000110L)

//
// MessageId: STATUS_PAGE_FAULT_DEMAND_ZERO
//
// MessageText:
//
//  Page fault was a demand zero fault.
//
#define STATUS_PAGE_FAULT_DEMAND_ZERO    ((NTSTATUS)0x00000111L)

//
// MessageId: STATUS_PAGE_FAULT_COPY_ON_WRITE
//
// MessageText:
//
//  Page fault was a demand zero fault.
//
#define STATUS_PAGE_FAULT_COPY_ON_WRITE  ((NTSTATUS)0x00000112L)

//
// MessageId: STATUS_PAGE_FAULT_GUARD_PAGE
//
// MessageText:
//
//  Page fault was a demand zero fault.
//
#define STATUS_PAGE_FAULT_GUARD_PAGE     ((NTSTATUS)0x00000113L)

//
// MessageId: STATUS_PAGE_FAULT_PAGING_FILE
//
// MessageText:
//
//  Page fault was satisfied by reading from a secondary storage device.
//
#define STATUS_PAGE_FAULT_PAGING_FILE    ((NTSTATUS)0x00000114L)

//
// MessageId: STATUS_CACHE_PAGE_LOCKED
//
// MessageText:
//
//  Cached page was locked during operation.
//
#define STATUS_CACHE_PAGE_LOCKED         ((NTSTATUS)0x00000115L)

//
// MessageId: STATUS_CRASH_DUMP
//
// MessageText:
//
//  Crash dump exists in paging file.
//
#define STATUS_CRASH_DUMP                ((NTSTATUS)0x00000116L)

//
// MessageId: STATUS_BUFFER_ALL_ZEROS
//
// MessageText:
//
//  Specified buffer contains all zeros.
//
#define STATUS_BUFFER_ALL_ZEROS          ((NTSTATUS)0x00000117L)

//
// MessageId: STATUS_REPARSE_OBJECT
//
// MessageText:
//
//  A reparse should be performed by the Object Manager since the name of the file resulted in a symbolic link.
//
#define STATUS_REPARSE_OBJECT            ((NTSTATUS)0x00000118L)

//
// MessageId: STATUS_RESOURCE_REQUIREMENTS_CHANGED
//
// MessageText:
//
//  The device has succeeded a query-stop and its resource requirements have changed.
//
#define STATUS_RESOURCE_REQUIREMENTS_CHANGED ((NTSTATUS)0x00000119L)

//
// MessageId: STATUS_TRANSLATION_COMPLETE
//
// MessageText:
//
//  The translator has translated these resources into the global space and no further translations should be performed.
//
#define STATUS_TRANSLATION_COMPLETE      ((NTSTATUS)0x00000120L)

//
// MessageId: DBG_EXCEPTION_HANDLED
//
// MessageText:
//
//  Debugger handled exception
//
#define DBG_EXCEPTION_HANDLED            ((NTSTATUS)0x00010001L)    // windbgkd

//
// MessageId: DBG_CONTINUE
//
// MessageText:
//
//  Debugger continued
//
#define DBG_CONTINUE                     ((NTSTATUS)0x00010002L)    // winnt



/////////////////////////////////////////////////////////////////////////
//
// Standard Information values
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: STATUS_OBJECT_NAME_EXISTS
//
// MessageText:
//
//  {Object Exists}
//  An attempt was made to create an object and the object name already existed.
//
#define STATUS_OBJECT_NAME_EXISTS        ((NTSTATUS)0x40000000L)

//
// MessageId: STATUS_THREAD_WAS_SUSPENDED
//
// MessageText:
//
//  {Thread Suspended}
//  A thread termination occurred while the thread was suspended. The thread was resumed, and termination proceeded.
//
#define STATUS_THREAD_WAS_SUSPENDED      ((NTSTATUS)0x40000001L)

//
// MessageId: STATUS_WORKING_SET_LIMIT_RANGE
//
// MessageText:
//
//  {Working Set Range Error}
//  An attempt was made to set the working set minimum or maximum to values which are outside of the allowable range.
//
#define STATUS_WORKING_SET_LIMIT_RANGE   ((NTSTATUS)0x40000002L)

//
// MessageId: STATUS_IMAGE_NOT_AT_BASE
//
// MessageText:
//
//  {Image Relocated}
//  An image file could not be mapped at the address specified in the image file. Local fixups must be performed on this image.
//
#define STATUS_IMAGE_NOT_AT_BASE         ((NTSTATUS)0x40000003L)

//
// MessageId: STATUS_LOCAL_USER_SESSION_KEY
//
// MessageText:
//
//  {Local Session Key}
//  A user session key was requested for a local RPC connection. The session key returned is a constant value and not unique to this connection.
//
#define STATUS_LOCAL_USER_SESSION_KEY    ((NTSTATUS)0x40000006L)

//
// MessageId: STATUS_BAD_CURRENT_DIRECTORY
//
// MessageText:
//
//  {Invalid Current Directory}
//  The process cannot switch to the startup current directory %hs.
//  Select OK to set current directory to %hs, or select CANCEL to exit.
//
#define STATUS_BAD_CURRENT_DIRECTORY     ((NTSTATUS)0x40000007L)

//
// MessageId: STATUS_SERIAL_MORE_WRITES
//
// MessageText:
//
//  {Serial IOCTL Complete}
//  A serial I/O operation was completed by another write to a serial port.
//  (The IOCTL_SERIAL_XOFF_COUNTER reached zero.)
//
#define STATUS_SERIAL_MORE_WRITES        ((NTSTATUS)0x40000008L)

//
// MessageId: STATUS_REGISTRY_RECOVERED
//
// MessageText:
//
//  {Registry Recovery}
//  One of the files containing the system's Registry data had to be recovered by use of a log or alternate copy.
//  The recovery was successful.
//
#define STATUS_REGISTRY_RECOVERED        ((NTSTATUS)0x40000009L)

//
// MessageId: STATUS_SERIAL_COUNTER_TIMEOUT
//
// MessageText:
//
//  {Serial IOCTL Timeout}
//  A serial I/O operation completed because the time-out period expired.
//  (The IOCTL_SERIAL_XOFF_COUNTER had not reached zero.)
//
#define STATUS_SERIAL_COUNTER_TIMEOUT    ((NTSTATUS)0x4000000CL)

//
// MessageId: STATUS_NULL_LM_PASSWORD
//
// MessageText:
//
//  {Password Too Complex}
//  The Windows password is too complex to be converted to a LAN Manager password.
//  The LAN Manager password returned is a NULL string.
//
#define STATUS_NULL_LM_PASSWORD          ((NTSTATUS)0x4000000DL)

//
// MessageId: STATUS_IMAGE_MACHINE_TYPE_MISMATCH
//
// MessageText:
//
//  {Machine Type Mismatch}
//  The image file %hs is valid, but is for a machine type other than the current machine. Select OK to continue, or CANCEL to fail the DLL load.
//
#define STATUS_IMAGE_MACHINE_TYPE_MISMATCH ((NTSTATUS)0x4000000EL)

//
// MessageId: STATUS_RECEIVE_PARTIAL
//
// MessageText:
//
//  {Partial Data Received}
//  The network transport returned partial data to its client. The remaining data will be sent later.
//
#define STATUS_RECEIVE_PARTIAL           ((NTSTATUS)0x4000000FL)

//
// MessageId: STATUS_RECEIVE_EXPEDITED
//
// MessageText:
//
//  {Expedited Data Received}
//  The network transport returned data to its client that was marked as expedited by the remote system.
//
#define STATUS_RECEIVE_EXPEDITED         ((NTSTATUS)0x40000010L)

//
// MessageId: STATUS_RECEIVE_PARTIAL_EXPEDITED
//
// MessageText:
//
//  {Partial Expedited Data Received}
//  The network transport returned partial data to its client and this data was marked as expedited by the remote system. The remaining data will be sent later.
//
#define STATUS_RECEIVE_PARTIAL_EXPEDITED ((NTSTATUS)0x40000011L)

//
// MessageId: STATUS_EVENT_DONE
//
// MessageText:
//
//  {TDI Event Done}
//  The TDI indication has completed successfully.
//
#define STATUS_EVENT_DONE                ((NTSTATUS)0x40000012L)

//
// MessageId: STATUS_EVENT_PENDING
//
// MessageText:
//
//  {TDI Event Pending}
//  The TDI indication has entered the pending state.
//
#define STATUS_EVENT_PENDING             ((NTSTATUS)0x40000013L)

//
// MessageId: STATUS_CHECKING_FILE_SYSTEM
//
// MessageText:
//
//  Checking file system on %wZ
//
#define STATUS_CHECKING_FILE_SYSTEM      ((NTSTATUS)0x40000014L)

//
// MessageId: STATUS_FATAL_APP_EXIT
//
// MessageText:
//
//  {Fatal Application Exit}
//  %hs
//
#define STATUS_FATAL_APP_EXIT            ((NTSTATUS)0x40000015L)

//
// MessageId: STATUS_PREDEFINED_HANDLE
//
// MessageText:
//
//  The specified registry key is referenced by a predefined handle.
//
#define STATUS_PREDEFINED_HANDLE         ((NTSTATUS)0x40000016L)

//
// MessageId: STATUS_WAS_UNLOCKED
//
// MessageText:
//
//  {Page Unlocked}
//  The page protection of a locked page was changed to 'No Access' and the page was unlocked from memory and from the process.
//
#define STATUS_WAS_UNLOCKED              ((NTSTATUS)0x40000017L)

//
// MessageId: STATUS_SERVICE_NOTIFICATION
//
// MessageText:
//
//  %hs
//
#define STATUS_SERVICE_NOTIFICATION      ((NTSTATUS)0x40000018L)

//
// MessageId: STATUS_WAS_LOCKED
//
// MessageText:
//
//  {Page Locked}
//  One of the pages to lock was already locked.
//
#define STATUS_WAS_LOCKED                ((NTSTATUS)0x40000019L)

//
// MessageId: STATUS_LOG_HARD_ERROR
//
// MessageText:
//
//  Application popup: %1 : %2
//
#define STATUS_LOG_HARD_ERROR            ((NTSTATUS)0x4000001AL)

//
// MessageId: STATUS_ALREADY_WIN32
//
// MessageText:
//
//  STATUS_ALREADY_WIN32
//
#define STATUS_ALREADY_WIN32             ((NTSTATUS)0x4000001BL)

//
// MessageId: STATUS_WX86_UNSIMULATE
//
// MessageText:
//
//  Exception status code used by Win32 x86 emulation subsystem.
//
#define STATUS_WX86_UNSIMULATE           ((NTSTATUS)0x4000001CL)

//
// MessageId: STATUS_WX86_CONTINUE
//
// MessageText:
//
//  Exception status code used by Win32 x86 emulation subsystem.
//
#define STATUS_WX86_CONTINUE             ((NTSTATUS)0x4000001DL)

//
// MessageId: STATUS_WX86_SINGLE_STEP
//
// MessageText:
//
//  Exception status code used by Win32 x86 emulation subsystem.
//
#define STATUS_WX86_SINGLE_STEP          ((NTSTATUS)0x4000001EL)

//
// MessageId: STATUS_WX86_BREAKPOINT
//
// MessageText:
//
//  Exception status code used by Win32 x86 emulation subsystem.
//
#define STATUS_WX86_BREAKPOINT           ((NTSTATUS)0x4000001FL)

//
// MessageId: STATUS_WX86_EXCEPTION_CONTINUE
//
// MessageText:
//
//  Exception status code used by Win32 x86 emulation subsystem.
//
#define STATUS_WX86_EXCEPTION_CONTINUE   ((NTSTATUS)0x40000020L)

//
// MessageId: STATUS_WX86_EXCEPTION_LASTCHANCE
//
// MessageText:
//
//  Exception status code used by Win32 x86 emulation subsystem.
//
#define STATUS_WX86_EXCEPTION_LASTCHANCE ((NTSTATUS)0x40000021L)

//
// MessageId: STATUS_WX86_EXCEPTION_CHAIN
//
// MessageText:
//
//  Exception status code used by Win32 x86 emulation subsystem.
//
#define STATUS_WX86_EXCEPTION_CHAIN      ((NTSTATUS)0x40000022L)

//
// MessageId: STATUS_IMAGE_MACHINE_TYPE_MISMATCH_EXE
//
// MessageText:
//
//  {Machine Type Mismatch}
//  The image file %hs is valid, but is for a machine type other than the current machine.
//
#define STATUS_IMAGE_MACHINE_TYPE_MISMATCH_EXE ((NTSTATUS)0x40000023L)

//
// MessageId: STATUS_NO_YIELD_PERFORMED
//
// MessageText:
//
//  A yield execution was performed and no thread was available to run.
//
#define STATUS_NO_YIELD_PERFORMED        ((NTSTATUS)0x40000024L)

//
// MessageId: STATUS_TIMER_RESUME_IGNORED
//
// MessageText:
//
//  The resumable flag to a timer API was ignored.
//
#define STATUS_TIMER_RESUME_IGNORED      ((NTSTATUS)0x40000025L)

//
// MessageId: STATUS_ARBITRATION_UNHANDLED
//
// MessageText:
//
//  The arbiter has deferred arbitration of these resources to its parent
//
#define STATUS_ARBITRATION_UNHANDLED     ((NTSTATUS)0x40000026L)

//
// MessageId: STATUS_CARDBUS_NOT_SUPPORTED
//
// MessageText:
//
//  The device "%hs" has detected a CardBus card in its slot, but the firmware on this system is not configured to allow the CardBus controller to be run in CardBus mode.
//  The operating system will currently accept only 16-bit (R2) pc-cards on this controller.
//
#define STATUS_CARDBUS_NOT_SUPPORTED     ((NTSTATUS)0x40000027L)

//
// MessageId: STATUS_WX86_CREATEWX86TIB
//
// MessageText:
//
//  Exception status code used by Win32 x86 emulation subsystem.
//
#define STATUS_WX86_CREATEWX86TIB        ((NTSTATUS)0x40000028L)

//
// MessageId: STATUS_MP_PROCESSOR_MISMATCH
//
// MessageText:
//
//  The CPUs in this multiprocessor system are not all the same revision level.  To use all processors the operating system restricts itself to the features of the least capable processor in the system.  Should problems occur with this system, contact the CPU manufacturer to see if this mix of processors is supported. 
//
#define STATUS_MP_PROCESSOR_MISMATCH     ((NTSTATUS)0x40000029L)

//
// MessageId: DBG_REPLY_LATER
//
// MessageText:
//
//  Debugger will reply later.
//
#define DBG_REPLY_LATER                  ((NTSTATUS)0x40010001L)

//
// MessageId: DBG_UNABLE_TO_PROVIDE_HANDLE
//
// MessageText:
//
//  Debugger can not provide handle.
//
#define DBG_UNABLE_TO_PROVIDE_HANDLE     ((NTSTATUS)0x40010002L)

//
// MessageId: DBG_TERMINATE_THREAD
//
// MessageText:
//
//  Debugger terminated thread.
//
#define DBG_TERMINATE_THREAD             ((NTSTATUS)0x40010003L)    // winnt

//
// MessageId: DBG_TERMINATE_PROCESS
//
// MessageText:
//
//  Debugger terminated process.
//
#define DBG_TERMINATE_PROCESS            ((NTSTATUS)0x40010004L)    // winnt

//
// MessageId: DBG_CONTROL_C
//
// MessageText:
//
//  Debugger got control C.
//
#define DBG_CONTROL_C                    ((NTSTATUS)0x40010005L)    // winnt

//
// MessageId: DBG_PRINTEXCEPTION_C
//
// MessageText:
//
//  Debugger printerd exception on control C.
//
#define DBG_PRINTEXCEPTION_C             ((NTSTATUS)0x40010006L)

//
// MessageId: DBG_RIPEXCEPTION
//
// MessageText:
//
//  Debugger recevice RIP exception.
//
#define DBG_RIPEXCEPTION                 ((NTSTATUS)0x40010007L)

//
// MessageId: DBG_CONTROL_BREAK
//
// MessageText:
//
//  Debugger received control break.
//
#define DBG_CONTROL_BREAK                ((NTSTATUS)0x40010008L)    // winnt



/////////////////////////////////////////////////////////////////////////
//
// Standard Warning values
//
//
// Note:  Do NOT use the value 0x80000000L, as this is a non-portable value
//        for the NT_SUCCESS macro. Warning values start with a code of 1.
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: STATUS_GUARD_PAGE_VIOLATION
//
// MessageText:
//
//  {EXCEPTION}
//  Guard Page Exception
//  A page of memory that marks the end of a data structure, such as a stack or an array, has been accessed.
//
#define STATUS_GUARD_PAGE_VIOLATION      ((NTSTATUS)0x80000001L)    // winnt

//
// MessageId: STATUS_DATATYPE_MISALIGNMENT
//
// MessageText:
//
//  {EXCEPTION}
//  Alignment Fault
//  A datatype misalignment was detected in a load or store instruction.
//
#define STATUS_DATATYPE_MISALIGNMENT     ((NTSTATUS)0x80000002L)    // winnt

//
// MessageId: STATUS_BREAKPOINT
//
// MessageText:
//
//  {EXCEPTION}
//  Breakpoint
//  A breakpoint has been reached.
//
#define STATUS_BREAKPOINT                ((NTSTATUS)0x80000003L)    // winnt

//
// MessageId: STATUS_SINGLE_STEP
//
// MessageText:
//
//  {EXCEPTION}
//  Single Step
//  A single step or trace operation has just been completed.
//
#define STATUS_SINGLE_STEP               ((NTSTATUS)0x80000004L)    // winnt

//
// MessageId: STATUS_BUFFER_OVERFLOW
//
// MessageText:
//
//  {Buffer Overflow}
//  The data was too large to fit into the specified buffer.
//
#define STATUS_BUFFER_OVERFLOW           ((NTSTATUS)0x80000005L)

//
// MessageId: STATUS_NO_MORE_FILES
//
// MessageText:
//
//  {No More Files}
//  No more files were found which match the file specification.
//
#define STATUS_NO_MORE_FILES             ((NTSTATUS)0x80000006L)

//
// MessageId: STATUS_WAKE_SYSTEM_DEBUGGER
//
// MessageText:
//
//  {Kernel Debugger Awakened}
//  the system debugger was awakened by an interrupt.
//
#define STATUS_WAKE_SYSTEM_DEBUGGER      ((NTSTATUS)0x80000007L)

//
// MessageId: STATUS_HANDLES_CLOSED
//
// MessageText:
//
//  {Handles Closed}
//  Handles to objects have been automatically closed as a result of the requested operation.
//
#define STATUS_HANDLES_CLOSED            ((NTSTATUS)0x8000000AL)

//
// MessageId: STATUS_NO_INHERITANCE
//
// MessageText:
//
//  {Non-Inheritable ACL}
//  An access control list (ACL) contains no components that can be inherited.
//
#define STATUS_NO_INHERITANCE            ((NTSTATUS)0x8000000BL)

//
// MessageId: STATUS_GUID_SUBSTITUTION_MADE
//
// MessageText:
//
//  {GUID Substitution}
//  During the translation of a global identifier (GUID) to a Windows security ID (SID), no administratively-defined GUID prefix was found.
//  A substitute prefix was used, which will not compromise system security.
//  However, this may provide a more restrictive access than intended.
//
#define STATUS_GUID_SUBSTITUTION_MADE    ((NTSTATUS)0x8000000CL)

//
// MessageId: STATUS_PARTIAL_COPY
//
// MessageText:
//
//  {Partial Copy}
//  Due to protection conflicts not all the requested bytes could be copied.
//
#define STATUS_PARTIAL_COPY              ((NTSTATUS)0x8000000DL)

//
// MessageId: STATUS_DEVICE_PAPER_EMPTY
//
// MessageText:
//
//  {Out of Paper}
//  The printer is out of paper.
//
#define STATUS_DEVICE_PAPER_EMPTY        ((NTSTATUS)0x8000000EL)

//
// MessageId: STATUS_DEVICE_POWERED_OFF
//
// MessageText:
//
//  {Device Power Is Off}
//  The printer power has been turned off.
//
#define STATUS_DEVICE_POWERED_OFF        ((NTSTATUS)0x8000000FL)

//
// MessageId: STATUS_DEVICE_OFF_LINE
//
// MessageText:
//
//  {Device Offline}
//  The printer has been taken offline.
//
#define STATUS_DEVICE_OFF_LINE           ((NTSTATUS)0x80000010L)

//
// MessageId: STATUS_DEVICE_BUSY
//
// MessageText:
//
//  {Device Busy}
//  The device is currently busy.
//
#define STATUS_DEVICE_BUSY               ((NTSTATUS)0x80000011L)

//
// MessageId: STATUS_NO_MORE_EAS
//
// MessageText:
//
//  {No More EAs}
//  No more extended attributes (EAs) were found for the file.
//
#define STATUS_NO_MORE_EAS               ((NTSTATUS)0x80000012L)

//
// MessageId: STATUS_INVALID_EA_NAME
//
// MessageText:
//
//  {Illegal EA}
//  The specified extended attribute (EA) name contains at least one illegal character.
//
#define STATUS_INVALID_EA_NAME           ((NTSTATUS)0x80000013L)

//
// MessageId: STATUS_EA_LIST_INCONSISTENT
//
// MessageText:
//
//  {Inconsistent EA List}
//  The extended attribute (EA) list is inconsistent.
//
#define STATUS_EA_LIST_INCONSISTENT      ((NTSTATUS)0x80000014L)

//
// MessageId: STATUS_INVALID_EA_FLAG
//
// MessageText:
//
//  {Invalid EA Flag}
//  An invalid extended attribute (EA) flag was set.
//
#define STATUS_INVALID_EA_FLAG           ((NTSTATUS)0x80000015L)

//
// MessageId: STATUS_VERIFY_REQUIRED
//
// MessageText:
//
//  {Verifying Disk}
//  The media has changed and a verify operation is in progress so no reads or writes may be performed to the device, except those used in the verify operation.
//
#define STATUS_VERIFY_REQUIRED           ((NTSTATUS)0x80000016L)

//
// MessageId: STATUS_EXTRANEOUS_INFORMATION
//
// MessageText:
//
//  {Too Much Information}
//  The specified access control list (ACL) contained more information than was expected.
//
#define STATUS_EXTRANEOUS_INFORMATION    ((NTSTATUS)0x80000017L)

//
// MessageId: STATUS_RXACT_COMMIT_NECESSARY
//
// MessageText:
//
//  This warning level status indicates that the transaction state already exists for the registry sub-tree, but that a transaction commit was previously aborted.
//  The commit has NOT been completed, but has not been rolled back either (so it may still be committed if desired).
//
#define STATUS_RXACT_COMMIT_NECESSARY    ((NTSTATUS)0x80000018L)

//
// MessageId: STATUS_NO_MORE_ENTRIES
//
// MessageText:
//
//  {No More Entries}
//  No more entries are available from an enumeration operation.
//
#define STATUS_NO_MORE_ENTRIES           ((NTSTATUS)0x8000001AL)

//
// MessageId: STATUS_FILEMARK_DETECTED
//
// MessageText:
//
//  {Filemark Found}
//  A filemark was detected.
//
#define STATUS_FILEMARK_DETECTED         ((NTSTATUS)0x8000001BL)

//
// MessageId: STATUS_MEDIA_CHANGED
//
// MessageText:
//
//  {Media Changed}
//  The media may have changed.
//
#define STATUS_MEDIA_CHANGED             ((NTSTATUS)0x8000001CL)

//
// MessageId: STATUS_BUS_RESET
//
// MessageText:
//
//  {I/O Bus Reset}
//  An I/O bus reset was detected.
//
#define STATUS_BUS_RESET                 ((NTSTATUS)0x8000001DL)

//
// MessageId: STATUS_END_OF_MEDIA
//
// MessageText:
//
//  {End of Media}
//  The end of the media was encountered.
//
#define STATUS_END_OF_MEDIA              ((NTSTATUS)0x8000001EL)

//
// MessageId: STATUS_BEGINNING_OF_MEDIA
//
// MessageText:
//
//  Beginning of tape or partition has been detected.
//
#define STATUS_BEGINNING_OF_MEDIA        ((NTSTATUS)0x8000001FL)

//
// MessageId: STATUS_MEDIA_CHECK
//
// MessageText:
//
//  {Media Changed}
//  The media may have changed.
//
#define STATUS_MEDIA_CHECK               ((NTSTATUS)0x80000020L)

//
// MessageId: STATUS_SETMARK_DETECTED
//
// MessageText:
//
//  A tape access reached a setmark.
//
#define STATUS_SETMARK_DETECTED          ((NTSTATUS)0x80000021L)

//
// MessageId: STATUS_NO_DATA_DETECTED
//
// MessageText:
//
//  During a tape access, the end of the data written is reached.
//
#define STATUS_NO_DATA_DETECTED          ((NTSTATUS)0x80000022L)

//
// MessageId: STATUS_REDIRECTOR_HAS_OPEN_HANDLES
//
// MessageText:
//
//  The redirector is in use and cannot be unloaded.
//
#define STATUS_REDIRECTOR_HAS_OPEN_HANDLES ((NTSTATUS)0x80000023L)

//
// MessageId: STATUS_SERVER_HAS_OPEN_HANDLES
//
// MessageText:
//
//  The server is in use and cannot be unloaded.
//
#define STATUS_SERVER_HAS_OPEN_HANDLES   ((NTSTATUS)0x80000024L)

//
// MessageId: STATUS_ALREADY_DISCONNECTED
//
// MessageText:
//
//  The specified connection has already been disconnected.
//
#define STATUS_ALREADY_DISCONNECTED      ((NTSTATUS)0x80000025L)

//
// MessageId: STATUS_LONGJUMP
//
// MessageText:
//
//  A long jump has been executed.
//
#define STATUS_LONGJUMP                  ((NTSTATUS)0x80000026L)

//
// MessageId: DBG_EXCEPTION_NOT_HANDLED
//
// MessageText:
//
//  Debugger did not handle the exception.
//
#define DBG_EXCEPTION_NOT_HANDLED        ((NTSTATUS)0x80010001L)    // winnt



/////////////////////////////////////////////////////////////////////////
//
//  Standard Error values
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: STATUS_UNSUCCESSFUL
//
// MessageText:
//
//  {Operation Failed}
//  The requested operation was unsuccessful.
//
#define STATUS_UNSUCCESSFUL              ((NTSTATUS)0xC0000001L)

//
// MessageId: STATUS_NOT_IMPLEMENTED
//
// MessageText:
//
//  {Not Implemented}
//  The requested operation is not implemented.
//
#define STATUS_NOT_IMPLEMENTED           ((NTSTATUS)0xC0000002L)

//
// MessageId: STATUS_INVALID_INFO_CLASS
//
// MessageText:
//
//  {Invalid Parameter}
//  The specified information class is not a valid information class for the specified object.
//
#define STATUS_INVALID_INFO_CLASS        ((NTSTATUS)0xC0000003L)    // ntsubauth

//
// MessageId: STATUS_INFO_LENGTH_MISMATCH
//
// MessageText:
//
//  The specified information record length does not match the length required for the specified information class.
//
#define STATUS_INFO_LENGTH_MISMATCH      ((NTSTATUS)0xC0000004L)

//
// MessageId: STATUS_ACCESS_VIOLATION
//
// MessageText:
//
//  The instruction at "0x%08lx" referenced memory at "0x%08lx". The memory could not be "%s".
//
#define STATUS_ACCESS_VIOLATION          ((NTSTATUS)0xC0000005L)    // winnt

//
// MessageId: STATUS_IN_PAGE_ERROR
//
// MessageText:
//
//  The instruction at "0x%08lx" referenced memory at "0x%08lx". The required data was not placed into memory because of an I/O error status of "0x%08lx".
//
#define STATUS_IN_PAGE_ERROR             ((NTSTATUS)0xC0000006L)    // winnt

//
// MessageId: STATUS_PAGEFILE_QUOTA
//
// MessageText:
//
//  The pagefile quota for the process has been exhausted.
//
#define STATUS_PAGEFILE_QUOTA            ((NTSTATUS)0xC0000007L)

//
// MessageId: STATUS_INVALID_HANDLE
//
// MessageText:
//
//  An invalid HANDLE was specified.
//
#define STATUS_INVALID_HANDLE            ((NTSTATUS)0xC0000008L)    // winnt

//
// MessageId: STATUS_BAD_INITIAL_STACK
//
// MessageText:
//
//  An invalid initial stack was specified in a call to NtCreateThread.
//
#define STATUS_BAD_INITIAL_STACK         ((NTSTATUS)0xC0000009L)

//
// MessageId: STATUS_BAD_INITIAL_PC
//
// MessageText:
//
//  An invalid initial start address was specified in a call to NtCreateThread.
//
#define STATUS_BAD_INITIAL_PC            ((NTSTATUS)0xC000000AL)

//
// MessageId: STATUS_INVALID_CID
//
// MessageText:
//
//  An invalid Client ID was specified.
//
#define STATUS_INVALID_CID               ((NTSTATUS)0xC000000BL)

//
// MessageId: STATUS_TIMER_NOT_CANCELED
//
// MessageText:
//
//  An attempt was made to cancel or set a timer that has an associated APC and the subject thread is not the thread that originally set the timer with an associated APC routine.
//
#define STATUS_TIMER_NOT_CANCELED        ((NTSTATUS)0xC000000CL)

//
// MessageId: STATUS_INVALID_PARAMETER
//
// MessageText:
//
//  An invalid parameter was passed to a service or function.
//
#define STATUS_INVALID_PARAMETER         ((NTSTATUS)0xC000000DL)

//
// MessageId: STATUS_NO_SUCH_DEVICE
//
// MessageText:
//
//  A device which does not exist was specified.
//
#define STATUS_NO_SUCH_DEVICE            ((NTSTATUS)0xC000000EL)

//
// MessageId: STATUS_NO_SUCH_FILE
//
// MessageText:
//
//  {File Not Found}
//  The file %hs does not exist.
//
#define STATUS_NO_SUCH_FILE              ((NTSTATUS)0xC000000FL)

//
// MessageId: STATUS_INVALID_DEVICE_REQUEST
//
// MessageText:
//
//  The specified request is not a valid operation for the target device.
//
#define STATUS_INVALID_DEVICE_REQUEST    ((NTSTATUS)0xC0000010L)

//
// MessageId: STATUS_END_OF_FILE
//
// MessageText:
//
//  The end-of-file marker has been reached. There is no valid data in the file beyond this marker.
//
#define STATUS_END_OF_FILE               ((NTSTATUS)0xC0000011L)

//
// MessageId: STATUS_WRONG_VOLUME
//
// MessageText:
//
//  {Wrong Volume}
//  The wrong volume is in the drive.
//  Please insert volume %hs into drive %hs.
//
#define STATUS_WRONG_VOLUME              ((NTSTATUS)0xC0000012L)

//
// MessageId: STATUS_NO_MEDIA_IN_DEVICE
//
// MessageText:
//
//  {No Disk}
//  There is no disk in the drive.
//  Please insert a disk into drive %hs.
//
#define STATUS_NO_MEDIA_IN_DEVICE        ((NTSTATUS)0xC0000013L)

//
// MessageId: STATUS_UNRECOGNIZED_MEDIA
//
// MessageText:
//
//  {Unknown Disk Format}
//  The disk in drive %hs is not formatted properly.
//  Please check the disk, and reformat if necessary.
//
#define STATUS_UNRECOGNIZED_MEDIA        ((NTSTATUS)0xC0000014L)

//
// MessageId: STATUS_NONEXISTENT_SECTOR
//
// MessageText:
//
//  {Sector Not Found}
//  The specified sector does not exist.
//
#define STATUS_NONEXISTENT_SECTOR        ((NTSTATUS)0xC0000015L)

//
// MessageId: STATUS_MORE_PROCESSING_REQUIRED
//
// MessageText:
//
//  {Still Busy}
//  The specified I/O request packet (IRP) cannot be disposed of because the I/O operation is not complete.
//
#define STATUS_MORE_PROCESSING_REQUIRED  ((NTSTATUS)0xC0000016L)

//
// MessageId: STATUS_NO_MEMORY
//
// MessageText:
//
//  {Not Enough Quota}
//  Not enough virtual memory or paging file quota is available to complete the specified operation.
//
#define STATUS_NO_MEMORY                 ((NTSTATUS)0xC0000017L)    // winnt

//
// MessageId: STATUS_CONFLICTING_ADDRESSES
//
// MessageText:
//
//  {Conflicting Address Range}
//  The specified address range conflicts with the address space.
//
#define STATUS_CONFLICTING_ADDRESSES     ((NTSTATUS)0xC0000018L)

//
// MessageId: STATUS_NOT_MAPPED_VIEW
//
// MessageText:
//
//  Address range to unmap is not a mapped view.
//
#define STATUS_NOT_MAPPED_VIEW           ((NTSTATUS)0xC0000019L)

//
// MessageId: STATUS_UNABLE_TO_FREE_VM
//
// MessageText:
//
//  Virtual memory cannot be freed.
//
#define STATUS_UNABLE_TO_FREE_VM         ((NTSTATUS)0xC000001AL)

//
// MessageId: STATUS_UNABLE_TO_DELETE_SECTION
//
// MessageText:
//
//  Specified section cannot be deleted.
//
#define STATUS_UNABLE_TO_DELETE_SECTION  ((NTSTATUS)0xC000001BL)

//
// MessageId: STATUS_INVALID_SYSTEM_SERVICE
//
// MessageText:
//
//  An invalid system service was specified in a system service call.
//
#define STATUS_INVALID_SYSTEM_SERVICE    ((NTSTATUS)0xC000001CL)

//
// MessageId: STATUS_ILLEGAL_INSTRUCTION
//
// MessageText:
//
//  {EXCEPTION}
//  Illegal Instruction
//  An attempt was made to execute an illegal instruction.
//
#define STATUS_ILLEGAL_INSTRUCTION       ((NTSTATUS)0xC000001DL)    // winnt

//
// MessageId: STATUS_INVALID_LOCK_SEQUENCE
//
// MessageText:
//
//  {Invalid Lock Sequence}
//  An attempt was made to execute an invalid lock sequence.
//
#define STATUS_INVALID_LOCK_SEQUENCE     ((NTSTATUS)0xC000001EL)

//
// MessageId: STATUS_INVALID_VIEW_SIZE
//
// MessageText:
//
//  {Invalid Mapping}
//  An attempt was made to create a view for a section which is bigger than the section.
//
#define STATUS_INVALID_VIEW_SIZE         ((NTSTATUS)0xC000001FL)

//
// MessageId: STATUS_INVALID_FILE_FOR_SECTION
//
// MessageText:
//
//  {Bad File}
//  The attributes of the specified mapping file for a section of memory cannot be read.
//
#define STATUS_INVALID_FILE_FOR_SECTION  ((NTSTATUS)0xC0000020L)

//
// MessageId: STATUS_ALREADY_COMMITTED
//
// MessageText:
//
//  {Already Committed}
//  The specified address range is already committed.
//
#define STATUS_ALREADY_COMMITTED         ((NTSTATUS)0xC0000021L)

//
// MessageId: STATUS_ACCESS_DENIED
//
// MessageText:
//
//  {Access Denied}
//  A process has requested access to an object, but has not been granted those access rights.
//
#define STATUS_ACCESS_DENIED             ((NTSTATUS)0xC0000022L)

//
// MessageId: STATUS_BUFFER_TOO_SMALL
//
// MessageText:
//
//  {Buffer Too Small}
//  The buffer is too small to contain the entry. No information has been written to the buffer.
//
#define STATUS_BUFFER_TOO_SMALL          ((NTSTATUS)0xC0000023L)

//
// MessageId: STATUS_OBJECT_TYPE_MISMATCH
//
// MessageText:
//
//  {Wrong Type}
//  There is a mismatch between the type of object required by the requested operation and the type of object that is specified in the request.
//
#define STATUS_OBJECT_TYPE_MISMATCH      ((NTSTATUS)0xC0000024L)

//
// MessageId: STATUS_NONCONTINUABLE_EXCEPTION
//
// MessageText:
//
//  {EXCEPTION}
//  Cannot Continue
//  Windows cannot continue from this exception.
//
#define STATUS_NONCONTINUABLE_EXCEPTION  ((NTSTATUS)0xC0000025L)    // winnt

//
// MessageId: STATUS_INVALID_DISPOSITION
//
// MessageText:
//
//  An invalid exception disposition was returned by an exception handler.
//
#define STATUS_INVALID_DISPOSITION       ((NTSTATUS)0xC0000026L)    // winnt

//
// MessageId: STATUS_UNWIND
//
// MessageText:
//
//  Unwind exception code.
//
#define STATUS_UNWIND                    ((NTSTATUS)0xC0000027L)

//
// MessageId: STATUS_BAD_STACK
//
// MessageText:
//
//  An invalid or unaligned stack was encountered during an unwind operation.
//
#define STATUS_BAD_STACK                 ((NTSTATUS)0xC0000028L)

//
// MessageId: STATUS_INVALID_UNWIND_TARGET
//
// MessageText:
//
//  An invalid unwind target was encountered during an unwind operation.
//
#define STATUS_INVALID_UNWIND_TARGET     ((NTSTATUS)0xC0000029L)

//
// MessageId: STATUS_NOT_LOCKED
//
// MessageText:
//
//  An attempt was made to unlock a page of memory which was not locked.
//
#define STATUS_NOT_LOCKED                ((NTSTATUS)0xC000002AL)

//
// MessageId: STATUS_PARITY_ERROR
//
// MessageText:
//
//  Device parity error on I/O operation.
//
#define STATUS_PARITY_ERROR              ((NTSTATUS)0xC000002BL)

//
// MessageId: STATUS_UNABLE_TO_DECOMMIT_VM
//
// MessageText:
//
//  An attempt was made to decommit uncommitted virtual memory.
//
#define STATUS_UNABLE_TO_DECOMMIT_VM     ((NTSTATUS)0xC000002CL)

//
// MessageId: STATUS_NOT_COMMITTED
//
// MessageText:
//
//  An attempt was made to change the attributes on memory that has not been committed.
//
#define STATUS_NOT_COMMITTED             ((NTSTATUS)0xC000002DL)

//
// MessageId: STATUS_INVALID_PORT_ATTRIBUTES
//
// MessageText:
//
//  Invalid Object Attributes specified to NtCreatePort or invalid Port Attributes specified to NtConnectPort
//
#define STATUS_INVALID_PORT_ATTRIBUTES   ((NTSTATUS)0xC000002EL)

//
// MessageId: STATUS_PORT_MESSAGE_TOO_LONG
//
// MessageText:
//
//  Length of message passed to NtRequestPort or NtRequestWaitReplyPort was longer than the maximum message allowed by the port.
//
#define STATUS_PORT_MESSAGE_TOO_LONG     ((NTSTATUS)0xC000002FL)

//
// MessageId: STATUS_INVALID_PARAMETER_MIX
//
// MessageText:
//
//  An invalid combination of parameters was specified.
//
#define STATUS_INVALID_PARAMETER_MIX     ((NTSTATUS)0xC0000030L)

//
// MessageId: STATUS_INVALID_QUOTA_LOWER
//
// MessageText:
//
//  An attempt was made to lower a quota limit below the current usage.
//
#define STATUS_INVALID_QUOTA_LOWER       ((NTSTATUS)0xC0000031L)

//
// MessageId: STATUS_DISK_CORRUPT_ERROR
//
// MessageText:
//
//  {Corrupt Disk}
//  The file system structure on the disk is corrupt and unusable.
//  Please run the Chkdsk utility on the volume %hs.
//
#define STATUS_DISK_CORRUPT_ERROR        ((NTSTATUS)0xC0000032L)

//
// MessageId: STATUS_OBJECT_NAME_INVALID
//
// MessageText:
//
//  Object Name invalid.
//
#define STATUS_OBJECT_NAME_INVALID       ((NTSTATUS)0xC0000033L)

//
// MessageId: STATUS_OBJECT_NAME_NOT_FOUND
//
// MessageText:
//
//  Object Name not found.
//
#define STATUS_OBJECT_NAME_NOT_FOUND     ((NTSTATUS)0xC0000034L)

//
// MessageId: STATUS_OBJECT_NAME_COLLISION
//
// MessageText:
//
//  Object Name already exists.
//
#define STATUS_OBJECT_NAME_COLLISION     ((NTSTATUS)0xC0000035L)

//
// MessageId: STATUS_PORT_DISCONNECTED
//
// MessageText:
//
//  Attempt to send a message to a disconnected communication port.
//
#define STATUS_PORT_DISCONNECTED         ((NTSTATUS)0xC0000037L)

//
// MessageId: STATUS_DEVICE_ALREADY_ATTACHED
//
// MessageText:
//
//  An attempt was made to attach to a device that was already attached to another device.
//
#define STATUS_DEVICE_ALREADY_ATTACHED   ((NTSTATUS)0xC0000038L)

//
// MessageId: STATUS_OBJECT_PATH_INVALID
//
// MessageText:
//
//  Object Path Component was not a directory object.
//
#define STATUS_OBJECT_PATH_INVALID       ((NTSTATUS)0xC0000039L)

//
// MessageId: STATUS_OBJECT_PATH_NOT_FOUND
//
// MessageText:
//
//  {Path Not Found}
//  The path %hs does not exist.
//
#define STATUS_OBJECT_PATH_NOT_FOUND     ((NTSTATUS)0xC000003AL)

//
// MessageId: STATUS_OBJECT_PATH_SYNTAX_BAD
//
// MessageText:
//
//  Object Path Component was not a directory object.
//
#define STATUS_OBJECT_PATH_SYNTAX_BAD    ((NTSTATUS)0xC000003BL)

//
// MessageId: STATUS_DATA_OVERRUN
//
// MessageText:
//
//  {Data Overrun}
//  A data overrun error occurred.
//
#define STATUS_DATA_OVERRUN              ((NTSTATUS)0xC000003CL)

//
// MessageId: STATUS_DATA_LATE_ERROR
//
// MessageText:
//
//  {Data Late}
//  A data late error occurred.
//
#define STATUS_DATA_LATE_ERROR           ((NTSTATUS)0xC000003DL)

//
// MessageId: STATUS_DATA_ERROR
//
// MessageText:
//
//  {Data Error}
//  An error in reading or writing data occurred.
//
#define STATUS_DATA_ERROR                ((NTSTATUS)0xC000003EL)

//
// MessageId: STATUS_CRC_ERROR
//
// MessageText:
//
//  {Bad CRC}
//  A cyclic redundancy check (CRC) checksum error occurred.
//
#define STATUS_CRC_ERROR                 ((NTSTATUS)0xC000003FL)

//
// MessageId: STATUS_SECTION_TOO_BIG
//
// MessageText:
//
//  {Section Too Large}
//  The specified section is too big to map the file.
//
#define STATUS_SECTION_TOO_BIG           ((NTSTATUS)0xC0000040L)

//
// MessageId: STATUS_PORT_CONNECTION_REFUSED
//
// MessageText:
//
//  The NtConnectPort request is refused.
//
#define STATUS_PORT_CONNECTION_REFUSED   ((NTSTATUS)0xC0000041L)

//
// MessageId: STATUS_INVALID_PORT_HANDLE
//
// MessageText:
//
//  The type of port handle is invalid for the operation requested.
//
#define STATUS_INVALID_PORT_HANDLE       ((NTSTATUS)0xC0000042L)

//
// MessageId: STATUS_SHARING_VIOLATION
//
// MessageText:
//
//  A file cannot be opened because the share access flags are incompatible.
//
#define STATUS_SHARING_VIOLATION         ((NTSTATUS)0xC0000043L)

//
// MessageId: STATUS_QUOTA_EXCEEDED
//
// MessageText:
//
//  Insufficient quota exists to complete the operation
//
#define STATUS_QUOTA_EXCEEDED            ((NTSTATUS)0xC0000044L)

//
// MessageId: STATUS_INVALID_PAGE_PROTECTION
//
// MessageText:
//
//  The specified page protection was not valid.
//
#define STATUS_INVALID_PAGE_PROTECTION   ((NTSTATUS)0xC0000045L)

//
// MessageId: STATUS_MUTANT_NOT_OWNED
//
// MessageText:
//
//  An attempt to release a mutant object was made by a thread that was not the owner of the mutant object.
//
#define STATUS_MUTANT_NOT_OWNED          ((NTSTATUS)0xC0000046L)

//
// MessageId: STATUS_SEMAPHORE_LIMIT_EXCEEDED
//
// MessageText:
//
//  An attempt was made to release a semaphore such that its maximum count would have been exceeded.
//
#define STATUS_SEMAPHORE_LIMIT_EXCEEDED  ((NTSTATUS)0xC0000047L)

//
// MessageId: STATUS_PORT_ALREADY_SET
//
// MessageText:
//
//  An attempt to set a processes DebugPort or ExceptionPort was made, but a port already exists in the process.
//
#define STATUS_PORT_ALREADY_SET          ((NTSTATUS)0xC0000048L)

//
// MessageId: STATUS_SECTION_NOT_IMAGE
//
// MessageText:
//
//  An attempt was made to query image information on a section which does not map an image.
//
#define STATUS_SECTION_NOT_IMAGE         ((NTSTATUS)0xC0000049L)

//
// MessageId: STATUS_SUSPEND_COUNT_EXCEEDED
//
// MessageText:
//
//  An attempt was made to suspend a thread whose suspend count was at its maximum.
//
#define STATUS_SUSPEND_COUNT_EXCEEDED    ((NTSTATUS)0xC000004AL)

//
// MessageId: STATUS_THREAD_IS_TERMINATING
//
// MessageText:
//
//  An attempt was made to suspend a thread that has begun termination.
//
#define STATUS_THREAD_IS_TERMINATING     ((NTSTATUS)0xC000004BL)

//
// MessageId: STATUS_BAD_WORKING_SET_LIMIT
//
// MessageText:
//
//  An attempt was made to set the working set limit to an invalid value (minimum greater than maximum, etc).
//
#define STATUS_BAD_WORKING_SET_LIMIT     ((NTSTATUS)0xC000004CL)

//
// MessageId: STATUS_INCOMPATIBLE_FILE_MAP
//
// MessageText:
//
//  A section was created to map a file which is not compatible to an already existing section which maps the same file.
//
#define STATUS_INCOMPATIBLE_FILE_MAP     ((NTSTATUS)0xC000004DL)

//
// MessageId: STATUS_SECTION_PROTECTION
//
// MessageText:
//
//  A view to a section specifies a protection which is incompatible with the initial view's protection.
//
#define STATUS_SECTION_PROTECTION        ((NTSTATUS)0xC000004EL)

//
// MessageId: STATUS_EAS_NOT_SUPPORTED
//
// MessageText:
//
//  An operation involving EAs failed because the file system does not support EAs.
//
#define STATUS_EAS_NOT_SUPPORTED         ((NTSTATUS)0xC000004FL)

//
// MessageId: STATUS_EA_TOO_LARGE
//
// MessageText:
//
//  An EA operation failed because EA set is too large.
//
#define STATUS_EA_TOO_LARGE              ((NTSTATUS)0xC0000050L)

//
// MessageId: STATUS_NONEXISTENT_EA_ENTRY
//
// MessageText:
//
//  An EA operation failed because the name or EA index is invalid.
//
#define STATUS_NONEXISTENT_EA_ENTRY      ((NTSTATUS)0xC0000051L)

//
// MessageId: STATUS_NO_EAS_ON_FILE
//
// MessageText:
//
//  The file for which EAs were requested has no EAs.
//
#define STATUS_NO_EAS_ON_FILE            ((NTSTATUS)0xC0000052L)

//
// MessageId: STATUS_EA_CORRUPT_ERROR
//
// MessageText:
//
//  The EA is corrupt and non-readable.
//
#define STATUS_EA_CORRUPT_ERROR          ((NTSTATUS)0xC0000053L)

//
// MessageId: STATUS_FILE_LOCK_CONFLICT
//
// MessageText:
//
//  A requested read/write cannot be granted due to a conflicting file lock.
//
#define STATUS_FILE_LOCK_CONFLICT        ((NTSTATUS)0xC0000054L)

//
// MessageId: STATUS_LOCK_NOT_GRANTED
//
// MessageText:
//
//  A requested file lock cannot be granted due to other existing locks.
//
#define STATUS_LOCK_NOT_GRANTED          ((NTSTATUS)0xC0000055L)

//
// MessageId: STATUS_DELETE_PENDING
//
// MessageText:
//
//  A non close operation has been requested of a file object with a delete pending.
//
#define STATUS_DELETE_PENDING            ((NTSTATUS)0xC0000056L)

//
// MessageId: STATUS_CTL_FILE_NOT_SUPPORTED
//
// MessageText:
//
//  An attempt was made to set the control attribute on a file. This attribute is not supported in the target file system.
//
#define STATUS_CTL_FILE_NOT_SUPPORTED    ((NTSTATUS)0xC0000057L)

//
// MessageId: STATUS_UNKNOWN_REVISION
//
// MessageText:
//
//  Indicates a revision number encountered or specified is not one known by the service. It may be a more recent revision than the service is aware of.
//
#define STATUS_UNKNOWN_REVISION          ((NTSTATUS)0xC0000058L)

//
// MessageId: STATUS_REVISION_MISMATCH
//
// MessageText:
//
//  Indicates two revision levels are incompatible.
//
#define STATUS_REVISION_MISMATCH         ((NTSTATUS)0xC0000059L)

//
// MessageId: STATUS_INVALID_OWNER
//
// MessageText:
//
//  Indicates a particular Security ID may not be assigned as the owner of an object.
//
#define STATUS_INVALID_OWNER             ((NTSTATUS)0xC000005AL)

//
// MessageId: STATUS_INVALID_PRIMARY_GROUP
//
// MessageText:
//
//  Indicates a particular Security ID may not be assigned as the primary group of an object.
//
#define STATUS_INVALID_PRIMARY_GROUP     ((NTSTATUS)0xC000005BL)

//
// MessageId: STATUS_NO_IMPERSONATION_TOKEN
//
// MessageText:
//
//  An attempt has been made to operate on an impersonation token by a thread that is not currently impersonating a client.
//
#define STATUS_NO_IMPERSONATION_TOKEN    ((NTSTATUS)0xC000005CL)

//
// MessageId: STATUS_CANT_DISABLE_MANDATORY
//
// MessageText:
//
//  A mandatory group may not be disabled.
//
#define STATUS_CANT_DISABLE_MANDATORY    ((NTSTATUS)0xC000005DL)

//
// MessageId: STATUS_NO_LOGON_SERVERS
//
// MessageText:
//
//  There are currently no logon servers available to service the logon request.
//
#define STATUS_NO_LOGON_SERVERS          ((NTSTATUS)0xC000005EL)

//
// MessageId: STATUS_NO_SUCH_LOGON_SESSION
//
// MessageText:
//
//  A specified logon session does not exist. It may already have been terminated.
//
#define STATUS_NO_SUCH_LOGON_SESSION     ((NTSTATUS)0xC000005FL)

//
// MessageId: STATUS_NO_SUCH_PRIVILEGE
//
// MessageText:
//
//  A specified privilege does not exist.
//
#define STATUS_NO_SUCH_PRIVILEGE         ((NTSTATUS)0xC0000060L)

//
// MessageId: STATUS_PRIVILEGE_NOT_HELD
//
// MessageText:
//
//  A required privilege is not held by the client.
//
#define STATUS_PRIVILEGE_NOT_HELD        ((NTSTATUS)0xC0000061L)

//
// MessageId: STATUS_INVALID_ACCOUNT_NAME
//
// MessageText:
//
//  The name provided is not a properly formed account name.
//
#define STATUS_INVALID_ACCOUNT_NAME      ((NTSTATUS)0xC0000062L)

//
// MessageId: STATUS_USER_EXISTS
//
// MessageText:
//
//  The specified user already exists.
//
#define STATUS_USER_EXISTS               ((NTSTATUS)0xC0000063L)

//
// MessageId: STATUS_NO_SUCH_USER
//
// MessageText:
//
//  The specified user does not exist.
//
#define STATUS_NO_SUCH_USER              ((NTSTATUS)0xC0000064L)     // ntsubauth

//
// MessageId: STATUS_GROUP_EXISTS
//
// MessageText:
//
//  The specified group already exists.
//
#define STATUS_GROUP_EXISTS              ((NTSTATUS)0xC0000065L)

//
// MessageId: STATUS_NO_SUCH_GROUP
//
// MessageText:
//
//  The specified group does not exist.
//
#define STATUS_NO_SUCH_GROUP             ((NTSTATUS)0xC0000066L)

//
// MessageId: STATUS_MEMBER_IN_GROUP
//
// MessageText:
//
//  The specified user account is already in the specified group account.
//  Also used to indicate a group cannot be deleted because it contains a member.
//
#define STATUS_MEMBER_IN_GROUP           ((NTSTATUS)0xC0000067L)

//
// MessageId: STATUS_MEMBER_NOT_IN_GROUP
//
// MessageText:
//
//  The specified user account is not a member of the specified group account.
//
#define STATUS_MEMBER_NOT_IN_GROUP       ((NTSTATUS)0xC0000068L)

//
// MessageId: STATUS_LAST_ADMIN
//
// MessageText:
//
//  Indicates the requested operation would disable or delete the last remaining administration account.
//  This is not allowed to prevent creating a situation in which the system cannot be administrated.
//
#define STATUS_LAST_ADMIN                ((NTSTATUS)0xC0000069L)

//
// MessageId: STATUS_WRONG_PASSWORD
//
// MessageText:
//
//  When trying to update a password, this return status indicates that the value provided as the current password is not correct.
//
#define STATUS_WRONG_PASSWORD            ((NTSTATUS)0xC000006AL)     // ntsubauth

//
// MessageId: STATUS_ILL_FORMED_PASSWORD
//
// MessageText:
//
//  When trying to update a password, this return status indicates that the value provided for the new password contains values that are not allowed in passwords.
//
#define STATUS_ILL_FORMED_PASSWORD       ((NTSTATUS)0xC000006BL)

//
// MessageId: STATUS_PASSWORD_RESTRICTION
//
// MessageText:
//
//  When trying to update a password, this status indicates that some password update rule has been violated. For example, the password may not meet length criteria.
//
#define STATUS_PASSWORD_RESTRICTION      ((NTSTATUS)0xC000006CL)     // ntsubauth

//
// MessageId: STATUS_LOGON_FAILURE
//
// MessageText:
//
//  The attempted logon is invalid. This is either due to a bad username or authentication information.
//
#define STATUS_LOGON_FAILURE             ((NTSTATUS)0xC000006DL)     // ntsubauth

//
// MessageId: STATUS_ACCOUNT_RESTRICTION
//
// MessageText:
//
//  Indicates a referenced user name and authentication information are valid, but some user account restriction has prevented successful authentication (such as time-of-day restrictions).
//
#define STATUS_ACCOUNT_RESTRICTION       ((NTSTATUS)0xC000006EL)     // ntsubauth

//
// MessageId: STATUS_INVALID_LOGON_HOURS
//
// MessageText:
//
//  The user account has time restrictions and may not be logged onto at this time.
//
#define STATUS_INVALID_LOGON_HOURS       ((NTSTATUS)0xC000006FL)     // ntsubauth

//
// MessageId: STATUS_INVALID_WORKSTATION
//
// MessageText:
//
//  The user account is restricted such that it may not be used to log on from the source workstation.
//
#define STATUS_INVALID_WORKSTATION       ((NTSTATUS)0xC0000070L)     // ntsubauth

//
// MessageId: STATUS_PASSWORD_EXPIRED
//
// MessageText:
//
//  The user account's password has expired.
//
#define STATUS_PASSWORD_EXPIRED          ((NTSTATUS)0xC0000071L)     // ntsubauth

//
// MessageId: STATUS_ACCOUNT_DISABLED
//
// MessageText:
//
//  The referenced account is currently disabled and may not be logged on to.
//
#define STATUS_ACCOUNT_DISABLED          ((NTSTATUS)0xC0000072L)     // ntsubauth

//
// MessageId: STATUS_NONE_MAPPED
//
// MessageText:
//
//  None of the information to be translated has been translated.
//
#define STATUS_NONE_MAPPED               ((NTSTATUS)0xC0000073L)

//
// MessageId: STATUS_TOO_MANY_LUIDS_REQUESTED
//
// MessageText:
//
//  The number of LUIDs requested may not be allocated with a single allocation.
//
#define STATUS_TOO_MANY_LUIDS_REQUESTED  ((NTSTATUS)0xC0000074L)

//
// MessageId: STATUS_LUIDS_EXHAUSTED
//
// MessageText:
//
//  Indicates there are no more LUIDs to allocate.
//
#define STATUS_LUIDS_EXHAUSTED           ((NTSTATUS)0xC0000075L)

//
// MessageId: STATUS_INVALID_SUB_AUTHORITY
//
// MessageText:
//
//  Indicates the sub-authority value is invalid for the particular use.
//
#define STATUS_INVALID_SUB_AUTHORITY     ((NTSTATUS)0xC0000076L)

//
// MessageId: STATUS_INVALID_ACL
//
// MessageText:
//
//  Indicates the ACL structure is not valid.
//
#define STATUS_INVALID_ACL               ((NTSTATUS)0xC0000077L)

//
// MessageId: STATUS_INVALID_SID
//
// MessageText:
//
//  Indicates the SID structure is not valid.
//
#define STATUS_INVALID_SID               ((NTSTATUS)0xC0000078L)

//
// MessageId: STATUS_INVALID_SECURITY_DESCR
//
// MessageText:
//
//  Indicates the SECURITY_DESCRIPTOR structure is not valid.
//
#define STATUS_INVALID_SECURITY_DESCR    ((NTSTATUS)0xC0000079L)

//
// MessageId: STATUS_PROCEDURE_NOT_FOUND
//
// MessageText:
//
//  Indicates the specified procedure address cannot be found in the DLL.
//
#define STATUS_PROCEDURE_NOT_FOUND       ((NTSTATUS)0xC000007AL)

//
// MessageId: STATUS_INVALID_IMAGE_FORMAT
//
// MessageText:
//
//  {Bad Image}
//  The application or DLL %hs is not a valid Windows image. Please check this against your installation diskette.
//
#define STATUS_INVALID_IMAGE_FORMAT      ((NTSTATUS)0xC000007BL)

//
// MessageId: STATUS_NO_TOKEN
//
// MessageText:
//
//  An attempt was made to reference a token that doesn't exist.
//  This is typically done by referencing the token associated with a thread when the thread is not impersonating a client.
//
#define STATUS_NO_TOKEN                  ((NTSTATUS)0xC000007CL)

//
// MessageId: STATUS_BAD_INHERITANCE_ACL
//
// MessageText:
//
//  Indicates that an attempt to build either an inherited ACL or ACE was not successful.
//  This can be caused by a number of things. One of the more probable causes is the replacement of a CreatorId with an SID that didn't fit into the ACE or ACL.
//
#define STATUS_BAD_INHERITANCE_ACL       ((NTSTATUS)0xC000007DL)

//
// MessageId: STATUS_RANGE_NOT_LOCKED
//
// MessageText:
//
//  The range specified in NtUnlockFile was not locked.
//
#define STATUS_RANGE_NOT_LOCKED          ((NTSTATUS)0xC000007EL)

//
// MessageId: STATUS_DISK_FULL
//
// MessageText:
//
//  An operation failed because the disk was full.
//
#define STATUS_DISK_FULL                 ((NTSTATUS)0xC000007FL)

//
// MessageId: STATUS_SERVER_DISABLED
//
// MessageText:
//
//  The GUID allocation server is [already] disabled at the moment.
//
#define STATUS_SERVER_DISABLED           ((NTSTATUS)0xC0000080L)

//
// MessageId: STATUS_SERVER_NOT_DISABLED
//
// MessageText:
//
//  The GUID allocation server is [already] enabled at the moment.
//
#define STATUS_SERVER_NOT_DISABLED       ((NTSTATUS)0xC0000081L)

//
// MessageId: STATUS_TOO_MANY_GUIDS_REQUESTED
//
// MessageText:
//
//  Too many GUIDs were requested from the allocation server at once.
//
#define STATUS_TOO_MANY_GUIDS_REQUESTED  ((NTSTATUS)0xC0000082L)

//
// MessageId: STATUS_GUIDS_EXHAUSTED
//
// MessageText:
//
//  The GUIDs could not be allocated because the Authority Agent was exhausted.
//
#define STATUS_GUIDS_EXHAUSTED           ((NTSTATUS)0xC0000083L)

//
// MessageId: STATUS_INVALID_ID_AUTHORITY
//
// MessageText:
//
//  The value provided was an invalid value for an identifier authority.
//
#define STATUS_INVALID_ID_AUTHORITY      ((NTSTATUS)0xC0000084L)

//
// MessageId: STATUS_AGENTS_EXHAUSTED
//
// MessageText:
//
//  There are no more authority agent values available for the given identifier authority value.
//
#define STATUS_AGENTS_EXHAUSTED          ((NTSTATUS)0xC0000085L)

//
// MessageId: STATUS_INVALID_VOLUME_LABEL
//
// MessageText:
//
//  An invalid volume label has been specified.
//
#define STATUS_INVALID_VOLUME_LABEL      ((NTSTATUS)0xC0000086L)

//
// MessageId: STATUS_SECTION_NOT_EXTENDED
//
// MessageText:
//
//  A mapped section could not be extended.
//
#define STATUS_SECTION_NOT_EXTENDED      ((NTSTATUS)0xC0000087L)

//
// MessageId: STATUS_NOT_MAPPED_DATA
//
// MessageText:
//
//  Specified section to flush does not map a data file.
//
#define STATUS_NOT_MAPPED_DATA           ((NTSTATUS)0xC0000088L)

//
// MessageId: STATUS_RESOURCE_DATA_NOT_FOUND
//
// MessageText:
//
//  Indicates the specified image file did not contain a resource section.
//
#define STATUS_RESOURCE_DATA_NOT_FOUND   ((NTSTATUS)0xC0000089L)

//
// MessageId: STATUS_RESOURCE_TYPE_NOT_FOUND
//
// MessageText:
//
//  Indicates the specified resource type cannot be found in the image file.
//
#define STATUS_RESOURCE_TYPE_NOT_FOUND   ((NTSTATUS)0xC000008AL)

//
// MessageId: STATUS_RESOURCE_NAME_NOT_FOUND
//
// MessageText:
//
//  Indicates the specified resource name cannot be found in the image file.
//
#define STATUS_RESOURCE_NAME_NOT_FOUND   ((NTSTATUS)0xC000008BL)

//
// MessageId: STATUS_ARRAY_BOUNDS_EXCEEDED
//
// MessageText:
//
//  {EXCEPTION}
//  Array bounds exceeded.
//
#define STATUS_ARRAY_BOUNDS_EXCEEDED     ((NTSTATUS)0xC000008CL)    // winnt

//
// MessageId: STATUS_FLOAT_DENORMAL_OPERAND
//
// MessageText:
//
//  {EXCEPTION}
//  Floating-point denormal operand.
//
#define STATUS_FLOAT_DENORMAL_OPERAND    ((NTSTATUS)0xC000008DL)    // winnt

//
// MessageId: STATUS_FLOAT_DIVIDE_BY_ZERO
//
// MessageText:
//
//  {EXCEPTION}
//  Floating-point division by zero.
//
#define STATUS_FLOAT_DIVIDE_BY_ZERO      ((NTSTATUS)0xC000008EL)    // winnt

//
// MessageId: STATUS_FLOAT_INEXACT_RESULT
//
// MessageText:
//
//  {EXCEPTION}
//  Floating-point inexact result.
//
#define STATUS_FLOAT_INEXACT_RESULT      ((NTSTATUS)0xC000008FL)    // winnt

//
// MessageId: STATUS_FLOAT_INVALID_OPERATION
//
// MessageText:
//
//  {EXCEPTION}
//  Floating-point invalid operation.
//
#define STATUS_FLOAT_INVALID_OPERATION   ((NTSTATUS)0xC0000090L)    // winnt

//
// MessageId: STATUS_FLOAT_OVERFLOW
//
// MessageText:
//
//  {EXCEPTION}
//  Floating-point overflow.
//
#define STATUS_FLOAT_OVERFLOW            ((NTSTATUS)0xC0000091L)    // winnt

//
// MessageId: STATUS_FLOAT_STACK_CHECK
//
// MessageText:
//
//  {EXCEPTION}
//  Floating-point stack check.
//
#define STATUS_FLOAT_STACK_CHECK         ((NTSTATUS)0xC0000092L)    // winnt

//
// MessageId: STATUS_FLOAT_UNDERFLOW
//
// MessageText:
//
//  {EXCEPTION}
//  Floating-point underflow.
//
#define STATUS_FLOAT_UNDERFLOW           ((NTSTATUS)0xC0000093L)    // winnt

//
// MessageId: STATUS_INTEGER_DIVIDE_BY_ZERO
//
// MessageText:
//
//  {EXCEPTION}
//  Integer division by zero.
//
#define STATUS_INTEGER_DIVIDE_BY_ZERO    ((NTSTATUS)0xC0000094L)    // winnt

//
// MessageId: STATUS_INTEGER_OVERFLOW
//
// MessageText:
//
//  {EXCEPTION}
//  Integer overflow.
//
#define STATUS_INTEGER_OVERFLOW          ((NTSTATUS)0xC0000095L)    // winnt

//
// MessageId: STATUS_PRIVILEGED_INSTRUCTION
//
// MessageText:
//
//  {EXCEPTION}
//  Privileged instruction.
//
#define STATUS_PRIVILEGED_INSTRUCTION    ((NTSTATUS)0xC0000096L)    // winnt

//
// MessageId: STATUS_TOO_MANY_PAGING_FILES
//
// MessageText:
//
//  An attempt was made to install more paging files than the system supports.
//
#define STATUS_TOO_MANY_PAGING_FILES     ((NTSTATUS)0xC0000097L)

//
// MessageId: STATUS_FILE_INVALID
//
// MessageText:
//
//  The volume for a file has been externally altered such that the opened file is no longer valid.
//
#define STATUS_FILE_INVALID              ((NTSTATUS)0xC0000098L)

//
// MessageId: STATUS_ALLOTTED_SPACE_EXCEEDED
//
// MessageText:
//
//  When a block of memory is allotted for future updates, such as the memory
//  allocated to hold discretionary access control and primary group information, successive updates may exceed the amount of memory originally allotted.
//  Since quota may already have been charged to several processes which have handles to the object, it is not reasonable to alter the size of the allocated memory.
//  Instead, a request that requires more memory than has been allotted must fail and the STATUS_ALLOTED_SPACE_EXCEEDED error returned.
//
#define STATUS_ALLOTTED_SPACE_EXCEEDED   ((NTSTATUS)0xC0000099L)

//
// MessageId: STATUS_INSUFFICIENT_RESOURCES
//
// MessageText:
//
//  Insufficient system resources exist to complete the API.
//
#define STATUS_INSUFFICIENT_RESOURCES    ((NTSTATUS)0xC000009AL)     // ntsubauth

//
// MessageId: STATUS_DFS_EXIT_PATH_FOUND
//
// MessageText:
//
//  An attempt has been made to open a DFS exit path control file.
//
#define STATUS_DFS_EXIT_PATH_FOUND       ((NTSTATUS)0xC000009BL)

//
// MessageId: STATUS_DEVICE_DATA_ERROR
//
// MessageText:
//
//  STATUS_DEVICE_DATA_ERROR
//
#define STATUS_DEVICE_DATA_ERROR         ((NTSTATUS)0xC000009CL)

//
// MessageId: STATUS_DEVICE_NOT_CONNECTED
//
// MessageText:
//
//  STATUS_DEVICE_NOT_CONNECTED
//
#define STATUS_DEVICE_NOT_CONNECTED      ((NTSTATUS)0xC000009DL)

//
// MessageId: STATUS_DEVICE_POWER_FAILURE
//
// MessageText:
//
//  STATUS_DEVICE_POWER_FAILURE
//
#define STATUS_DEVICE_POWER_FAILURE      ((NTSTATUS)0xC000009EL)

//
// MessageId: STATUS_FREE_VM_NOT_AT_BASE
//
// MessageText:
//
//  Virtual memory cannot be freed as base address is not the base of the region and a region size of zero was specified.
//
#define STATUS_FREE_VM_NOT_AT_BASE       ((NTSTATUS)0xC000009FL)

//
// MessageId: STATUS_MEMORY_NOT_ALLOCATED
//
// MessageText:
//
//  An attempt was made to free virtual memory which is not allocated.
//
#define STATUS_MEMORY_NOT_ALLOCATED      ((NTSTATUS)0xC00000A0L)

//
// MessageId: STATUS_WORKING_SET_QUOTA
//
// MessageText:
//
//  The working set is not big enough to allow the requested pages to be locked.
//
#define STATUS_WORKING_SET_QUOTA         ((NTSTATUS)0xC00000A1L)

//
// MessageId: STATUS_MEDIA_WRITE_PROTECTED
//
// MessageText:
//
//  {Write Protect Error}
//  The disk cannot be written to because it is write protected.
//  Please remove the write protection from the volume %hs in drive %hs.
//
#define STATUS_MEDIA_WRITE_PROTECTED     ((NTSTATUS)0xC00000A2L)

//
// MessageId: STATUS_DEVICE_NOT_READY
//
// MessageText:
//
//  {Drive Not Ready}
//  The drive is not ready for use; its door may be open.
//  Please check drive %hs and make sure that a disk is inserted and that the drive door is closed.
//
#define STATUS_DEVICE_NOT_READY          ((NTSTATUS)0xC00000A3L)

//
// MessageId: STATUS_INVALID_GROUP_ATTRIBUTES
//
// MessageText:
//
//  The specified attributes are invalid, or incompatible with the attributes for the group as a whole.
//
#define STATUS_INVALID_GROUP_ATTRIBUTES  ((NTSTATUS)0xC00000A4L)

//
// MessageId: STATUS_BAD_IMPERSONATION_LEVEL
//
// MessageText:
//
//  A specified impersonation level is invalid.
//  Also used to indicate a required impersonation level was not provided.
//
#define STATUS_BAD_IMPERSONATION_LEVEL   ((NTSTATUS)0xC00000A5L)

//
// MessageId: STATUS_CANT_OPEN_ANONYMOUS
//
// MessageText:
//
//  An attempt was made to open an Anonymous level token.
//  Anonymous tokens may not be opened.
//
#define STATUS_CANT_OPEN_ANONYMOUS       ((NTSTATUS)0xC00000A6L)

//
// MessageId: STATUS_BAD_VALIDATION_CLASS
//
// MessageText:
//
//  The validation information class requested was invalid.
//
#define STATUS_BAD_VALIDATION_CLASS      ((NTSTATUS)0xC00000A7L)

//
// MessageId: STATUS_BAD_TOKEN_TYPE
//
// MessageText:
//
//  The type of a token object is inappropriate for its attempted use.
//
#define STATUS_BAD_TOKEN_TYPE            ((NTSTATUS)0xC00000A8L)

//
// MessageId: STATUS_BAD_MASTER_BOOT_RECORD
//
// MessageText:
//
//  The type of a token object is inappropriate for its attempted use.
//
#define STATUS_BAD_MASTER_BOOT_RECORD    ((NTSTATUS)0xC00000A9L)

//
// MessageId: STATUS_INSTRUCTION_MISALIGNMENT
//
// MessageText:
//
//  An attempt was made to execute an instruction at an unaligned address and the host system does not support unaligned instruction references.
//
#define STATUS_INSTRUCTION_MISALIGNMENT  ((NTSTATUS)0xC00000AAL)

//
// MessageId: STATUS_INSTANCE_NOT_AVAILABLE
//
// MessageText:
//
//  The maximum named pipe instance count has been reached.
//
#define STATUS_INSTANCE_NOT_AVAILABLE    ((NTSTATUS)0xC00000ABL)

//
// MessageId: STATUS_PIPE_NOT_AVAILABLE
//
// MessageText:
//
//  An instance of a named pipe cannot be found in the listening state.
//
#define STATUS_PIPE_NOT_AVAILABLE        ((NTSTATUS)0xC00000ACL)

//
// MessageId: STATUS_INVALID_PIPE_STATE
//
// MessageText:
//
//  The named pipe is not in the connected or closing state.
//
#define STATUS_INVALID_PIPE_STATE        ((NTSTATUS)0xC00000ADL)

//
// MessageId: STATUS_PIPE_BUSY
//
// MessageText:
//
//  The specified pipe is set to complete operations and there are current I/O operations queued so it cannot be changed to queue operations.
//
#define STATUS_PIPE_BUSY                 ((NTSTATUS)0xC00000AEL)

//
// MessageId: STATUS_ILLEGAL_FUNCTION
//
// MessageText:
//
//  The specified handle is not open to the server end of the named pipe.
//
#define STATUS_ILLEGAL_FUNCTION          ((NTSTATUS)0xC00000AFL)

//
// MessageId: STATUS_PIPE_DISCONNECTED
//
// MessageText:
//
//  The specified named pipe is in the disconnected state.
//
#define STATUS_PIPE_DISCONNECTED         ((NTSTATUS)0xC00000B0L)

//
// MessageId: STATUS_PIPE_CLOSING
//
// MessageText:
//
//  The specified named pipe is in the closing state.
//
#define STATUS_PIPE_CLOSING              ((NTSTATUS)0xC00000B1L)

//
// MessageId: STATUS_PIPE_CONNECTED
//
// MessageText:
//
//  The specified named pipe is in the connected state.
//
#define STATUS_PIPE_CONNECTED            ((NTSTATUS)0xC00000B2L)

//
// MessageId: STATUS_PIPE_LISTENING
//
// MessageText:
//
//  The specified named pipe is in the listening state.
//
#define STATUS_PIPE_LISTENING            ((NTSTATUS)0xC00000B3L)

//
// MessageId: STATUS_INVALID_READ_MODE
//
// MessageText:
//
//  The specified named pipe is not in message mode.
//
#define STATUS_INVALID_READ_MODE         ((NTSTATUS)0xC00000B4L)

//
// MessageId: STATUS_IO_TIMEOUT
//
// MessageText:
//
//  {Device Timeout}
//  The specified I/O operation on %hs was not completed before the time-out period expired.
//
#define STATUS_IO_TIMEOUT                ((NTSTATUS)0xC00000B5L)

//
// MessageId: STATUS_FILE_FORCED_CLOSED
//
// MessageText:
//
//  The specified file has been closed by another process.
//
#define STATUS_FILE_FORCED_CLOSED        ((NTSTATUS)0xC00000B6L)

//
// MessageId: STATUS_PROFILING_NOT_STARTED
//
// MessageText:
//
//  Profiling not started.
//
#define STATUS_PROFILING_NOT_STARTED     ((NTSTATUS)0xC00000B7L)

//
// MessageId: STATUS_PROFILING_NOT_STOPPED
//
// MessageText:
//
//  Profiling not stopped.
//
#define STATUS_PROFILING_NOT_STOPPED     ((NTSTATUS)0xC00000B8L)

//
// MessageId: STATUS_COULD_NOT_INTERPRET
//
// MessageText:
//
//  The passed ACL did not contain the minimum required information.
//
#define STATUS_COULD_NOT_INTERPRET       ((NTSTATUS)0xC00000B9L)

//
// MessageId: STATUS_FILE_IS_A_DIRECTORY
//
// MessageText:
//
//  The file that was specified as a target is a directory and the caller specified that it could be anything but a directory.
//
#define STATUS_FILE_IS_A_DIRECTORY       ((NTSTATUS)0xC00000BAL)

//
// Network specific errors.
//
//
//
// MessageId: STATUS_NOT_SUPPORTED
//
// MessageText:
//
//  The network request is not supported.
//
#define STATUS_NOT_SUPPORTED             ((NTSTATUS)0xC00000BBL)

//
// MessageId: STATUS_REMOTE_NOT_LISTENING
//
// MessageText:
//
//  This remote computer is not listening.
//
#define STATUS_REMOTE_NOT_LISTENING      ((NTSTATUS)0xC00000BCL)

//
// MessageId: STATUS_DUPLICATE_NAME
//
// MessageText:
//
//  A duplicate name exists on the network.
//
#define STATUS_DUPLICATE_NAME            ((NTSTATUS)0xC00000BDL)

//
// MessageId: STATUS_BAD_NETWORK_PATH
//
// MessageText:
//
//  The network path cannot be located.
//
#define STATUS_BAD_NETWORK_PATH          ((NTSTATUS)0xC00000BEL)

//
// MessageId: STATUS_NETWORK_BUSY
//
// MessageText:
//
//  The network is busy.
//
#define STATUS_NETWORK_BUSY              ((NTSTATUS)0xC00000BFL)

//
// MessageId: STATUS_DEVICE_DOES_NOT_EXIST
//
// MessageText:
//
//  This device does not exist.
//
#define STATUS_DEVICE_DOES_NOT_EXIST     ((NTSTATUS)0xC00000C0L)

//
// MessageId: STATUS_TOO_MANY_COMMANDS
//
// MessageText:
//
//  The network BIOS command limit has been reached.
//
#define STATUS_TOO_MANY_COMMANDS         ((NTSTATUS)0xC00000C1L)

//
// MessageId: STATUS_ADAPTER_HARDWARE_ERROR
//
// MessageText:
//
//  An I/O adapter hardware error has occurred.
//
#define STATUS_ADAPTER_HARDWARE_ERROR    ((NTSTATUS)0xC00000C2L)

//
// MessageId: STATUS_INVALID_NETWORK_RESPONSE
//
// MessageText:
//
//  The network responded incorrectly.
//
#define STATUS_INVALID_NETWORK_RESPONSE  ((NTSTATUS)0xC00000C3L)

//
// MessageId: STATUS_UNEXPECTED_NETWORK_ERROR
//
// MessageText:
//
//  An unexpected network error occurred.
//
#define STATUS_UNEXPECTED_NETWORK_ERROR  ((NTSTATUS)0xC00000C4L)

//
// MessageId: STATUS_BAD_REMOTE_ADAPTER
//
// MessageText:
//
//  The remote adapter is not compatible.
//
#define STATUS_BAD_REMOTE_ADAPTER        ((NTSTATUS)0xC00000C5L)

//
// MessageId: STATUS_PRINT_QUEUE_FULL
//
// MessageText:
//
//  The printer queue is full.
//
#define STATUS_PRINT_QUEUE_FULL          ((NTSTATUS)0xC00000C6L)

//
// MessageId: STATUS_NO_SPOOL_SPACE
//
// MessageText:
//
//  Space to store the file waiting to be printed is not available on the server.
//
#define STATUS_NO_SPOOL_SPACE            ((NTSTATUS)0xC00000C7L)

//
// MessageId: STATUS_PRINT_CANCELLED
//
// MessageText:
//
//  The requested print file has been canceled.
//
#define STATUS_PRINT_CANCELLED           ((NTSTATUS)0xC00000C8L)

//
// MessageId: STATUS_NETWORK_NAME_DELETED
//
// MessageText:
//
//  The network name was deleted.
//
#define STATUS_NETWORK_NAME_DELETED      ((NTSTATUS)0xC00000C9L)

//
// MessageId: STATUS_NETWORK_ACCESS_DENIED
//
// MessageText:
//
//  Network access is denied.
//
#define STATUS_NETWORK_ACCESS_DENIED     ((NTSTATUS)0xC00000CAL)

//
// MessageId: STATUS_BAD_DEVICE_TYPE
//
// MessageText:
//
//  {Incorrect Network Resource Type}
//  The specified device type (LPT, for example) conflicts with the actual device type on the remote resource.
//
#define STATUS_BAD_DEVICE_TYPE           ((NTSTATUS)0xC00000CBL)

//
// MessageId: STATUS_BAD_NETWORK_NAME
//
// MessageText:
//
//  {Network Name Not Found}
//  The specified share name cannot be found on the remote server.
//
#define STATUS_BAD_NETWORK_NAME          ((NTSTATUS)0xC00000CCL)

//
// MessageId: STATUS_TOO_MANY_NAMES
//
// MessageText:
//
//  The name limit for the local computer network adapter card was exceeded.
//
#define STATUS_TOO_MANY_NAMES            ((NTSTATUS)0xC00000CDL)

//
// MessageId: STATUS_TOO_MANY_SESSIONS
//
// MessageText:
//
//  The network BIOS session limit was exceeded.
//
#define STATUS_TOO_MANY_SESSIONS         ((NTSTATUS)0xC00000CEL)

//
// MessageId: STATUS_SHARING_PAUSED
//
// MessageText:
//
//  File sharing has been temporarily paused.
//
#define STATUS_SHARING_PAUSED            ((NTSTATUS)0xC00000CFL)

//
// MessageId: STATUS_REQUEST_NOT_ACCEPTED
//
// MessageText:
//
//  No more connections can be made to this remote computer at this time because there are already as many connections as the computer can accept.
//
#define STATUS_REQUEST_NOT_ACCEPTED      ((NTSTATUS)0xC00000D0L)

//
// MessageId: STATUS_REDIRECTOR_PAUSED
//
// MessageText:
//
//  Print or disk redirection is temporarily paused.
//
#define STATUS_REDIRECTOR_PAUSED         ((NTSTATUS)0xC00000D1L)

//
// MessageId: STATUS_NET_WRITE_FAULT
//
// MessageText:
//
//  A network data fault occurred.
//
#define STATUS_NET_WRITE_FAULT           ((NTSTATUS)0xC00000D2L)

//
// MessageId: STATUS_PROFILING_AT_LIMIT
//
// MessageText:
//
//  The number of active profiling objects is at the maximum and no more may be started.
//
#define STATUS_PROFILING_AT_LIMIT        ((NTSTATUS)0xC00000D3L)

//
// MessageId: STATUS_NOT_SAME_DEVICE
//
// MessageText:
//
//  {Incorrect Volume}
//  The target file of a rename request is located on a different device than the source of the rename request.
//
#define STATUS_NOT_SAME_DEVICE           ((NTSTATUS)0xC00000D4L)

//
// MessageId: STATUS_FILE_RENAMED
//
// MessageText:
//
//  The file specified has been renamed and thus cannot be modified.
//
#define STATUS_FILE_RENAMED              ((NTSTATUS)0xC00000D5L)

//
// MessageId: STATUS_VIRTUAL_CIRCUIT_CLOSED
//
// MessageText:
//
//  {Network Request Timeout}
//  The session with a remote server has been disconnected because the time-out interval for a request has expired.
//
#define STATUS_VIRTUAL_CIRCUIT_CLOSED    ((NTSTATUS)0xC00000D6L)

//
// MessageId: STATUS_NO_SECURITY_ON_OBJECT
//
// MessageText:
//
//  Indicates an attempt was made to operate on the security of an object that does not have security associated with it.
//
#define STATUS_NO_SECURITY_ON_OBJECT     ((NTSTATUS)0xC00000D7L)

//
// MessageId: STATUS_CANT_WAIT
//
// MessageText:
//
//  Used to indicate that an operation cannot continue without blocking for I/O.
//
#define STATUS_CANT_WAIT                 ((NTSTATUS)0xC00000D8L)

//
// MessageId: STATUS_PIPE_EMPTY
//
// MessageText:
//
//  Used to indicate that a read operation was done on an empty pipe.
//
#define STATUS_PIPE_EMPTY                ((NTSTATUS)0xC00000D9L)

//
// MessageId: STATUS_CANT_ACCESS_DOMAIN_INFO
//
// MessageText:
//
//  Configuration information could not be read from the domain controller, either because the machine is unavailable, or access has been denied.
//
#define STATUS_CANT_ACCESS_DOMAIN_INFO   ((NTSTATUS)0xC00000DAL)

//
// MessageId: STATUS_CANT_TERMINATE_SELF
//
// MessageText:
//
//  Indicates that a thread attempted to terminate itself by default (called NtTerminateThread with NULL) and it was the last thread in the current process.
//
#define STATUS_CANT_TERMINATE_SELF       ((NTSTATUS)0xC00000DBL)

//
// MessageId: STATUS_INVALID_SERVER_STATE
//
// MessageText:
//
//  Indicates the Sam Server was in the wrong state to perform the desired operation.
//
#define STATUS_INVALID_SERVER_STATE      ((NTSTATUS)0xC00000DCL)

//
// MessageId: STATUS_INVALID_DOMAIN_STATE
//
// MessageText:
//
//  Indicates the Domain was in the wrong state to perform the desired operation.
//
#define STATUS_INVALID_DOMAIN_STATE      ((NTSTATUS)0xC00000DDL)

//
// MessageId: STATUS_INVALID_DOMAIN_ROLE
//
// MessageText:
//
//  This operation is only allowed for the Primary Domain Controller of the domain.
//
#define STATUS_INVALID_DOMAIN_ROLE       ((NTSTATUS)0xC00000DEL)

//
// MessageId: STATUS_NO_SUCH_DOMAIN
//
// MessageText:
//
//  The specified Domain did not exist.
//
#define STATUS_NO_SUCH_DOMAIN            ((NTSTATUS)0xC00000DFL)

//
// MessageId: STATUS_DOMAIN_EXISTS
//
// MessageText:
//
//  The specified Domain already exists.
//
#define STATUS_DOMAIN_EXISTS             ((NTSTATUS)0xC00000E0L)

//
// MessageId: STATUS_DOMAIN_LIMIT_EXCEEDED
//
// MessageText:
//
//  An attempt was made to exceed the limit on the number of domains per server for this release.
//
#define STATUS_DOMAIN_LIMIT_EXCEEDED     ((NTSTATUS)0xC00000E1L)

//
// MessageId: STATUS_OPLOCK_NOT_GRANTED
//
// MessageText:
//
//  Error status returned when oplock request is denied.
//
#define STATUS_OPLOCK_NOT_GRANTED        ((NTSTATUS)0xC00000E2L)

//
// MessageId: STATUS_INVALID_OPLOCK_PROTOCOL
//
// MessageText:
//
//  Error status returned when an invalid oplock acknowledgment is received by a file system.
//
#define STATUS_INVALID_OPLOCK_PROTOCOL   ((NTSTATUS)0xC00000E3L)

//
// MessageId: STATUS_INTERNAL_DB_CORRUPTION
//
// MessageText:
//
//  This error indicates that the requested operation cannot be completed due to a catastrophic media failure or on-disk data structure corruption.
//
#define STATUS_INTERNAL_DB_CORRUPTION    ((NTSTATUS)0xC00000E4L)

//
// MessageId: STATUS_INTERNAL_ERROR
//
// MessageText:
//
//  An internal error occurred.
//
#define STATUS_INTERNAL_ERROR            ((NTSTATUS)0xC00000E5L)

//
// MessageId: STATUS_GENERIC_NOT_MAPPED
//
// MessageText:
//
//  Indicates generic access types were contained in an access mask which should already be mapped to non-generic access types.
//
#define STATUS_GENERIC_NOT_MAPPED        ((NTSTATUS)0xC00000E6L)

//
// MessageId: STATUS_BAD_DESCRIPTOR_FORMAT
//
// MessageText:
//
//  Indicates a security descriptor is not in the necessary format (absolute or self-relative).
//
#define STATUS_BAD_DESCRIPTOR_FORMAT     ((NTSTATUS)0xC00000E7L)

//
// Status codes raised by the Cache Manager which must be considered as
// "expected" by its callers.
//
//
// MessageId: STATUS_INVALID_USER_BUFFER
//
// MessageText:
//
//  An access to a user buffer failed at an "expected" point in time.
//  This code is defined since the caller does not want to accept STATUS_ACCESS_VIOLATION in its filter.
//
#define STATUS_INVALID_USER_BUFFER       ((NTSTATUS)0xC00000E8L)

//
// MessageId: STATUS_UNEXPECTED_IO_ERROR
//
// MessageText:
//
//  If an I/O error is returned which is not defined in the standard FsRtl filter, it is converted to the following error which is guaranteed to be in the filter.
//  In this case information is lost, however, the filter correctly handles the exception.
//
#define STATUS_UNEXPECTED_IO_ERROR       ((NTSTATUS)0xC00000E9L)

//
// MessageId: STATUS_UNEXPECTED_MM_CREATE_ERR
//
// MessageText:
//
//  If an MM error is returned which is not defined in the standard FsRtl filter, it is converted to one of the following errors which is guaranteed to be in the filter.
//  In this case information is lost, however, the filter correctly handles the exception.
//
#define STATUS_UNEXPECTED_MM_CREATE_ERR  ((NTSTATUS)0xC00000EAL)

//
// MessageId: STATUS_UNEXPECTED_MM_MAP_ERROR
//
// MessageText:
//
//  If an MM error is returned which is not defined in the standard FsRtl filter, it is converted to one of the following errors which is guaranteed to be in the filter.
//  In this case information is lost, however, the filter correctly handles the exception.
//
#define STATUS_UNEXPECTED_MM_MAP_ERROR   ((NTSTATUS)0xC00000EBL)

//
// MessageId: STATUS_UNEXPECTED_MM_EXTEND_ERR
//
// MessageText:
//
//  If an MM error is returned which is not defined in the standard FsRtl filter, it is converted to one of the following errors which is guaranteed to be in the filter.
//  In this case information is lost, however, the filter correctly handles the exception.
//
#define STATUS_UNEXPECTED_MM_EXTEND_ERR  ((NTSTATUS)0xC00000ECL)

//
// MessageId: STATUS_NOT_LOGON_PROCESS
//
// MessageText:
//
//  The requested action is restricted for use by logon processes only. The calling process has not registered as a logon process.
//
#define STATUS_NOT_LOGON_PROCESS         ((NTSTATUS)0xC00000EDL)

//
// MessageId: STATUS_LOGON_SESSION_EXISTS
//
// MessageText:
//
//  An attempt has been made to start a new session manager or LSA logon session with an ID that is already in use.
//
#define STATUS_LOGON_SESSION_EXISTS      ((NTSTATUS)0xC00000EEL)

//
// MessageId: STATUS_INVALID_PARAMETER_1
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as the first argument.
//
#define STATUS_INVALID_PARAMETER_1       ((NTSTATUS)0xC00000EFL)

//
// MessageId: STATUS_INVALID_PARAMETER_2
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as the second argument.
//
#define STATUS_INVALID_PARAMETER_2       ((NTSTATUS)0xC00000F0L)

//
// MessageId: STATUS_INVALID_PARAMETER_3
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as the third argument.
//
#define STATUS_INVALID_PARAMETER_3       ((NTSTATUS)0xC00000F1L)

//
// MessageId: STATUS_INVALID_PARAMETER_4
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as the fourth argument.
//
#define STATUS_INVALID_PARAMETER_4       ((NTSTATUS)0xC00000F2L)

//
// MessageId: STATUS_INVALID_PARAMETER_5
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as the fifth argument.
//
#define STATUS_INVALID_PARAMETER_5       ((NTSTATUS)0xC00000F3L)

//
// MessageId: STATUS_INVALID_PARAMETER_6
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as the sixth argument.
//
#define STATUS_INVALID_PARAMETER_6       ((NTSTATUS)0xC00000F4L)

//
// MessageId: STATUS_INVALID_PARAMETER_7
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as the seventh argument.
//
#define STATUS_INVALID_PARAMETER_7       ((NTSTATUS)0xC00000F5L)

//
// MessageId: STATUS_INVALID_PARAMETER_8
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as the eighth argument.
//
#define STATUS_INVALID_PARAMETER_8       ((NTSTATUS)0xC00000F6L)

//
// MessageId: STATUS_INVALID_PARAMETER_9
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as the ninth argument.
//
#define STATUS_INVALID_PARAMETER_9       ((NTSTATUS)0xC00000F7L)

//
// MessageId: STATUS_INVALID_PARAMETER_10
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as the tenth argument.
//
#define STATUS_INVALID_PARAMETER_10      ((NTSTATUS)0xC00000F8L)

//
// MessageId: STATUS_INVALID_PARAMETER_11
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as the eleventh argument.
//
#define STATUS_INVALID_PARAMETER_11      ((NTSTATUS)0xC00000F9L)

//
// MessageId: STATUS_INVALID_PARAMETER_12
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as the twelfth argument.
//
#define STATUS_INVALID_PARAMETER_12      ((NTSTATUS)0xC00000FAL)

//
// MessageId: STATUS_REDIRECTOR_NOT_STARTED
//
// MessageText:
//
//  An attempt was made to access a network file, but the network software was not yet started.
//
#define STATUS_REDIRECTOR_NOT_STARTED    ((NTSTATUS)0xC00000FBL)

//
// MessageId: STATUS_REDIRECTOR_STARTED
//
// MessageText:
//
//  An attempt was made to start the redirector, but the redirector has already been started.
//
#define STATUS_REDIRECTOR_STARTED        ((NTSTATUS)0xC00000FCL)

//
// MessageId: STATUS_STACK_OVERFLOW
//
// MessageText:
//
//  A new guard page for the stack cannot be created.
//
#define STATUS_STACK_OVERFLOW            ((NTSTATUS)0xC00000FDL)    // winnt

//
// MessageId: STATUS_NO_SUCH_PACKAGE
//
// MessageText:
//
//  A specified authentication package is unknown.
//
#define STATUS_NO_SUCH_PACKAGE           ((NTSTATUS)0xC00000FEL)

//
// MessageId: STATUS_BAD_FUNCTION_TABLE
//
// MessageText:
//
//  A malformed function table was encountered during an unwind operation.
//
#define STATUS_BAD_FUNCTION_TABLE        ((NTSTATUS)0xC00000FFL)

//
// MessageId: STATUS_VARIABLE_NOT_FOUND
//
// MessageText:
//
//  Indicates the specified environment variable name was not found in the specified environment block.
//
#define STATUS_VARIABLE_NOT_FOUND        ((NTSTATUS)0xC0000100L)

//
// MessageId: STATUS_DIRECTORY_NOT_EMPTY
//
// MessageText:
//
//  Indicates that the directory trying to be deleted is not empty.
//
#define STATUS_DIRECTORY_NOT_EMPTY       ((NTSTATUS)0xC0000101L)

//
// MessageId: STATUS_FILE_CORRUPT_ERROR
//
// MessageText:
//
//  {Corrupt File}
//  The file or directory %hs is corrupt and unreadable.
//  Please run the Chkdsk utility.
//
#define STATUS_FILE_CORRUPT_ERROR        ((NTSTATUS)0xC0000102L)

//
// MessageId: STATUS_NOT_A_DIRECTORY
//
// MessageText:
//
//  A requested opened file is not a directory.
//
#define STATUS_NOT_A_DIRECTORY           ((NTSTATUS)0xC0000103L)

//
// MessageId: STATUS_BAD_LOGON_SESSION_STATE
//
// MessageText:
//
//  The logon session is not in a state that is consistent with the requested operation.
//
#define STATUS_BAD_LOGON_SESSION_STATE   ((NTSTATUS)0xC0000104L)

//
// MessageId: STATUS_LOGON_SESSION_COLLISION
//
// MessageText:
//
//  An internal LSA error has occurred. An authentication package has requested the creation of a Logon Session but the ID of an already existing Logon Session has been specified.
//
#define STATUS_LOGON_SESSION_COLLISION   ((NTSTATUS)0xC0000105L)

//
// MessageId: STATUS_NAME_TOO_LONG
//
// MessageText:
//
//  A specified name string is too long for its intended use.
//
#define STATUS_NAME_TOO_LONG             ((NTSTATUS)0xC0000106L)

//
// MessageId: STATUS_FILES_OPEN
//
// MessageText:
//
//  The user attempted to force close the files on a redirected drive, but there were opened files on the drive, and the user did not specify a sufficient level of force.
//
#define STATUS_FILES_OPEN                ((NTSTATUS)0xC0000107L)

//
// MessageId: STATUS_CONNECTION_IN_USE
//
// MessageText:
//
//  The user attempted to force close the files on a redirected drive, but there were opened directories on the drive, and the user did not specify a sufficient level of force.
//
#define STATUS_CONNECTION_IN_USE         ((NTSTATUS)0xC0000108L)

//
// MessageId: STATUS_MESSAGE_NOT_FOUND
//
// MessageText:
//
//  RtlFindMessage could not locate the requested message ID in the message table resource.
//
#define STATUS_MESSAGE_NOT_FOUND         ((NTSTATUS)0xC0000109L)

//
// MessageId: STATUS_PROCESS_IS_TERMINATING
//
// MessageText:
//
//  An attempt was made to duplicate an object handle into or out of an exiting process.
//
#define STATUS_PROCESS_IS_TERMINATING    ((NTSTATUS)0xC000010AL)

//
// MessageId: STATUS_INVALID_LOGON_TYPE
//
// MessageText:
//
//  Indicates an invalid value has been provided for the LogonType requested.
//
#define STATUS_INVALID_LOGON_TYPE        ((NTSTATUS)0xC000010BL)

//
// MessageId: STATUS_NO_GUID_TRANSLATION
//
// MessageText:
//
//  Indicates that an attempt was made to assign protection to a file system file or directory and one of the SIDs in the security descriptor could not be translated into a GUID that could be stored by the file system.
//  This causes the protection attempt to fail, which may cause a file creation attempt to fail.
//
#define STATUS_NO_GUID_TRANSLATION       ((NTSTATUS)0xC000010CL)

//
// MessageId: STATUS_CANNOT_IMPERSONATE
//
// MessageText:
//
//  Indicates that an attempt has been made to impersonate via a named pipe that has not yet been read from.
//
#define STATUS_CANNOT_IMPERSONATE        ((NTSTATUS)0xC000010DL)

//
// MessageId: STATUS_IMAGE_ALREADY_LOADED
//
// MessageText:
//
//  Indicates that the specified image is already loaded.
//
#define STATUS_IMAGE_ALREADY_LOADED      ((NTSTATUS)0xC000010EL)


//
// ============================================================
// NOTE: The following ABIOS error code should be reserved on
//       non ABIOS kernel. Eventually, I will remove the ifdef
//       ABIOS.
// ============================================================
//
//
// MessageId: STATUS_ABIOS_NOT_PRESENT
//
// MessageText:
//
//  STATUS_ABIOS_NOT_PRESENT
//
#define STATUS_ABIOS_NOT_PRESENT         ((NTSTATUS)0xC000010FL)

//
// MessageId: STATUS_ABIOS_LID_NOT_EXIST
//
// MessageText:
//
//  STATUS_ABIOS_LID_NOT_EXIST
//
#define STATUS_ABIOS_LID_NOT_EXIST       ((NTSTATUS)0xC0000110L)

//
// MessageId: STATUS_ABIOS_LID_ALREADY_OWNED
//
// MessageText:
//
//  STATUS_ABIOS_LID_ALREADY_OWNED
//
#define STATUS_ABIOS_LID_ALREADY_OWNED   ((NTSTATUS)0xC0000111L)

//
// MessageId: STATUS_ABIOS_NOT_LID_OWNER
//
// MessageText:
//
//  STATUS_ABIOS_NOT_LID_OWNER
//
#define STATUS_ABIOS_NOT_LID_OWNER       ((NTSTATUS)0xC0000112L)

//
// MessageId: STATUS_ABIOS_INVALID_COMMAND
//
// MessageText:
//
//  STATUS_ABIOS_INVALID_COMMAND
//
#define STATUS_ABIOS_INVALID_COMMAND     ((NTSTATUS)0xC0000113L)

//
// MessageId: STATUS_ABIOS_INVALID_LID
//
// MessageText:
//
//  STATUS_ABIOS_INVALID_LID
//
#define STATUS_ABIOS_INVALID_LID         ((NTSTATUS)0xC0000114L)

//
// MessageId: STATUS_ABIOS_SELECTOR_NOT_AVAILABLE
//
// MessageText:
//
//  STATUS_ABIOS_SELECTOR_NOT_AVAILABLE
//
#define STATUS_ABIOS_SELECTOR_NOT_AVAILABLE ((NTSTATUS)0xC0000115L)

//
// MessageId: STATUS_ABIOS_INVALID_SELECTOR
//
// MessageText:
//
//  STATUS_ABIOS_INVALID_SELECTOR
//
#define STATUS_ABIOS_INVALID_SELECTOR    ((NTSTATUS)0xC0000116L)

//
// MessageId: STATUS_NO_LDT
//
// MessageText:
//
//  Indicates that an attempt was made to change the size of the LDT for a process that has no LDT.
//
#define STATUS_NO_LDT                    ((NTSTATUS)0xC0000117L)

//
// MessageId: STATUS_INVALID_LDT_SIZE
//
// MessageText:
//
//  Indicates that an attempt was made to grow an LDT by setting its size, or that the size was not an even number of selectors.
//
#define STATUS_INVALID_LDT_SIZE          ((NTSTATUS)0xC0000118L)

//
// MessageId: STATUS_INVALID_LDT_OFFSET
//
// MessageText:
//
//  Indicates that the starting value for the LDT information was not an integral multiple of the selector size.
//
#define STATUS_INVALID_LDT_OFFSET        ((NTSTATUS)0xC0000119L)

//
// MessageId: STATUS_INVALID_LDT_DESCRIPTOR
//
// MessageText:
//
//  Indicates that the user supplied an invalid descriptor when trying to set up Ldt descriptors.
//
#define STATUS_INVALID_LDT_DESCRIPTOR    ((NTSTATUS)0xC000011AL)

//
// MessageId: STATUS_MAPPED_FILE_SIZE_ZERO
//
// MessageText:
//
//  An attempt was made to map a file of size zero with the maximum size specified as zero.
//
#define STATUS_MAPPED_FILE_SIZE_ZERO     ((NTSTATUS)0xC000011EL)

//
// MessageId: STATUS_TOO_MANY_OPENED_FILES
//
// MessageText:
//
//  Too many files are opened on a remote server.
//  This error should only be returned by the Windows redirector on a remote drive.
//
#define STATUS_TOO_MANY_OPENED_FILES     ((NTSTATUS)0xC000011FL)

//
// MessageId: STATUS_CANCELLED
//
// MessageText:
//
//  The I/O request was canceled.
//
#define STATUS_CANCELLED                 ((NTSTATUS)0xC0000120L)

//
// MessageId: STATUS_CANNOT_DELETE
//
// MessageText:
//
//  An attempt has been made to remove a file or directory that cannot be deleted.
//
#define STATUS_CANNOT_DELETE             ((NTSTATUS)0xC0000121L)

//
// MessageId: STATUS_INVALID_COMPUTER_NAME
//
// MessageText:
//
//  Indicates a name specified as a remote computer name is syntactically invalid.
//
#define STATUS_INVALID_COMPUTER_NAME     ((NTSTATUS)0xC0000122L)

//
// MessageId: STATUS_FILE_DELETED
//
// MessageText:
//
//  An I/O request other than close was performed on a file after it has been deleted,
//  which can only happen to a request which did not complete before the last handle was closed via NtClose.
//
#define STATUS_FILE_DELETED              ((NTSTATUS)0xC0000123L)

//
// MessageId: STATUS_SPECIAL_ACCOUNT
//
// MessageText:
//
//  Indicates an operation has been attempted on a built-in (special) SAM account which is incompatible with built-in accounts.
//  For example, built-in accounts cannot be deleted.
//
#define STATUS_SPECIAL_ACCOUNT           ((NTSTATUS)0xC0000124L)

//
// MessageId: STATUS_SPECIAL_GROUP
//
// MessageText:
//
//  The operation requested may not be performed on the specified group because it is a built-in special group.
//
#define STATUS_SPECIAL_GROUP             ((NTSTATUS)0xC0000125L)

//
// MessageId: STATUS_SPECIAL_USER
//
// MessageText:
//
//  The operation requested may not be performed on the specified user because it is a built-in special user.
//
#define STATUS_SPECIAL_USER              ((NTSTATUS)0xC0000126L)

//
// MessageId: STATUS_MEMBERS_PRIMARY_GROUP
//
// MessageText:
//
//  Indicates a member cannot be removed from a group because the group is currently the member's primary group.
//
#define STATUS_MEMBERS_PRIMARY_GROUP     ((NTSTATUS)0xC0000127L)

//
// MessageId: STATUS_FILE_CLOSED
//
// MessageText:
//
//  An I/O request other than close and several other special case operations was attempted using a file object that had already been closed.
//
#define STATUS_FILE_CLOSED               ((NTSTATUS)0xC0000128L)

//
// MessageId: STATUS_TOO_MANY_THREADS
//
// MessageText:
//
//  Indicates a process has too many threads to perform the requested action. For example, assignment of a primary token may only be performed when a process has zero or one threads.
//
#define STATUS_TOO_MANY_THREADS          ((NTSTATUS)0xC0000129L)

//
// MessageId: STATUS_THREAD_NOT_IN_PROCESS
//
// MessageText:
//
//  An attempt was made to operate on a thread within a specific process, but the thread specified is not in the process specified.
//
#define STATUS_THREAD_NOT_IN_PROCESS     ((NTSTATUS)0xC000012AL)

//
// MessageId: STATUS_TOKEN_ALREADY_IN_USE
//
// MessageText:
//
//  An attempt was made to establish a token for use as a primary token but the token is already in use. A token can only be the primary token of one process at a time.
//
#define STATUS_TOKEN_ALREADY_IN_USE      ((NTSTATUS)0xC000012BL)

//
// MessageId: STATUS_PAGEFILE_QUOTA_EXCEEDED
//
// MessageText:
//
//  Page file quota was exceeded.
//
#define STATUS_PAGEFILE_QUOTA_EXCEEDED   ((NTSTATUS)0xC000012CL)

//
// MessageId: STATUS_COMMITMENT_LIMIT
//
// MessageText:
//
//  {Out of Virtual Memory}
//  Your system is low on virtual memory. To ensure that Windows runs properly, increase the size of your virtual memory paging file. For more information, see Help.
//
#define STATUS_COMMITMENT_LIMIT          ((NTSTATUS)0xC000012DL)

//
// MessageId: STATUS_INVALID_IMAGE_PROTECT
//
// MessageText:
//
//  The specified image file did not have the correct format, it did not have a proper e_lfarlc in the MZ header.
//
#define STATUS_INVALID_IMAGE_PROTECT     ((NTSTATUS)0xC0000130L)

//
// MessageId: STATUS_LOGON_SERVER_CONFLICT
//
// MessageText:
//
//  The Netlogon service cannot start because another Netlogon service running in the domain conflicts with the specified role.
//
#define STATUS_LOGON_SERVER_CONFLICT     ((NTSTATUS)0xC0000132L)

//
// MessageId: STATUS_TIME_DIFFERENCE_AT_DC
//
// MessageText:
//
//  The time at the Primary Domain Controller is different than the time at the Backup Domain Controller or member server by too large an amount.
//
#define STATUS_TIME_DIFFERENCE_AT_DC     ((NTSTATUS)0xC0000133L)

//
// MessageId: STATUS_SYNCHRONIZATION_REQUIRED
//
// MessageText:
//
//  The SAM database on a Windows Server is significantly out of synchronization with the copy on the Domain Controller. A complete synchronization is required.
//
#define STATUS_SYNCHRONIZATION_REQUIRED  ((NTSTATUS)0xC0000134L)

//
// MessageId: STATUS_DLL_NOT_FOUND
//
// MessageText:
//
//  {Unable To Locate DLL}
//  The dynamic link library %hs could not be found in the specified path %hs.
//
#define STATUS_DLL_NOT_FOUND             ((NTSTATUS)0xC0000135L)

//
// MessageId: STATUS_OPEN_FAILED
//
// MessageText:
//
//  The NtCreateFile API failed. This error should never be returned to an application, it is a place holder for the Windows Lan Manager Redirector to use in its internal error mapping routines.
//
#define STATUS_OPEN_FAILED               ((NTSTATUS)0xC0000136L)

//
// MessageId: STATUS_IO_PRIVILEGE_FAILED
//
// MessageText:
//
//  {Privilege Failed}
//  The I/O permissions for the process could not be changed.
//
#define STATUS_IO_PRIVILEGE_FAILED       ((NTSTATUS)0xC0000137L)

//
// MessageId: STATUS_ORDINAL_NOT_FOUND
//
// MessageText:
//
//  {Ordinal Not Found}
//  The ordinal %ld could not be located in the dynamic link library %hs.
//
#define STATUS_ORDINAL_NOT_FOUND         ((NTSTATUS)0xC0000138L)

//
// MessageId: STATUS_ENTRYPOINT_NOT_FOUND
//
// MessageText:
//
//  {Entry Point Not Found}
//  The procedure entry point %hs could not be located in the dynamic link library %hs.
//
#define STATUS_ENTRYPOINT_NOT_FOUND      ((NTSTATUS)0xC0000139L)

//
// MessageId: STATUS_CONTROL_C_EXIT
//
// MessageText:
//
//  {Application Exit by CTRL+C}
//  The application terminated as a result of a CTRL+C.
//
#define STATUS_CONTROL_C_EXIT            ((NTSTATUS)0xC000013AL)    // winnt

//
// MessageId: STATUS_LOCAL_DISCONNECT
//
// MessageText:
//
//  {Virtual Circuit Closed}
//  The network transport on your computer has closed a network connection. There may or may not be I/O requests outstanding.
//
#define STATUS_LOCAL_DISCONNECT          ((NTSTATUS)0xC000013BL)

//
// MessageId: STATUS_REMOTE_DISCONNECT
//
// MessageText:
//
//  {Virtual Circuit Closed}
//  The network transport on a remote computer has closed a network connection. There may or may not be I/O requests outstanding.
//
#define STATUS_REMOTE_DISCONNECT         ((NTSTATUS)0xC000013CL)

//
// MessageId: STATUS_REMOTE_RESOURCES
//
// MessageText:
//
//  {Insufficient Resources on Remote Computer}
//  The remote computer has insufficient resources to complete the network request. For instance, there may not be enough memory available on the remote computer to carry out the request at this time.
//
#define STATUS_REMOTE_RESOURCES          ((NTSTATUS)0xC000013DL)

//
// MessageId: STATUS_LINK_FAILED
//
// MessageText:
//
//  {Virtual Circuit Closed}
//  An existing connection (virtual circuit) has been broken at the remote computer. There is probably something wrong with the network software protocol or the network hardware on the remote computer.
//
#define STATUS_LINK_FAILED               ((NTSTATUS)0xC000013EL)

//
// MessageId: STATUS_LINK_TIMEOUT
//
// MessageText:
//
//  {Virtual Circuit Closed}
//  The network transport on your computer has closed a network connection because it had to wait too long for a response from the remote computer.
//
#define STATUS_LINK_TIMEOUT              ((NTSTATUS)0xC000013FL)

//
// MessageId: STATUS_INVALID_CONNECTION
//
// MessageText:
//
//  The connection handle given to the transport was invalid.
//
#define STATUS_INVALID_CONNECTION        ((NTSTATUS)0xC0000140L)

//
// MessageId: STATUS_INVALID_ADDRESS
//
// MessageText:
//
//  The address handle given to the transport was invalid.
//
#define STATUS_INVALID_ADDRESS           ((NTSTATUS)0xC0000141L)

//
// MessageId: STATUS_DLL_INIT_FAILED
//
// MessageText:
//
//  {DLL Initialization Failed}
//  Initialization of the dynamic link library %hs failed. The process is terminating abnormally.
//
#define STATUS_DLL_INIT_FAILED           ((NTSTATUS)0xC0000142L)

//
// MessageId: STATUS_MISSING_SYSTEMFILE
//
// MessageText:
//
//  {Missing System File}
//  The required system file %hs is bad or missing.
//
#define STATUS_MISSING_SYSTEMFILE        ((NTSTATUS)0xC0000143L)

//
// MessageId: STATUS_UNHANDLED_EXCEPTION
//
// MessageText:
//
//  {Application Error}
//  The exception %s (0x%08lx) occurred in the application at location 0x%08lx.
//
#define STATUS_UNHANDLED_EXCEPTION       ((NTSTATUS)0xC0000144L)

//
// MessageId: STATUS_APP_INIT_FAILURE
//
// MessageText:
//
//  {Application Error}
//  The application failed to initialize properly (0x%lx). Click on OK to terminate the application.
//
#define STATUS_APP_INIT_FAILURE          ((NTSTATUS)0xC0000145L)

//
// MessageId: STATUS_PAGEFILE_CREATE_FAILED
//
// MessageText:
//
//  {Unable to Create Paging File}
//  The creation of the paging file %hs failed (%lx). The requested size was %ld.
//
#define STATUS_PAGEFILE_CREATE_FAILED    ((NTSTATUS)0xC0000146L)

//
// MessageId: STATUS_NO_PAGEFILE
//
// MessageText:
//
//  {No Paging File Specified}
//  No paging file was specified in the system configuration.
//
#define STATUS_NO_PAGEFILE               ((NTSTATUS)0xC0000147L)

//
// MessageId: STATUS_INVALID_LEVEL
//
// MessageText:
//
//  {Incorrect System Call Level}
//  An invalid level was passed into the specified system call.
//
#define STATUS_INVALID_LEVEL             ((NTSTATUS)0xC0000148L)

//
// MessageId: STATUS_WRONG_PASSWORD_CORE
//
// MessageText:
//
//  {Incorrect Password to LAN Manager Server}
//  You specified an incorrect password to a LAN Manager 2.x or MS-NET server.
//
#define STATUS_WRONG_PASSWORD_CORE       ((NTSTATUS)0xC0000149L)

//
// MessageId: STATUS_ILLEGAL_FLOAT_CONTEXT
//
// MessageText:
//
//  {EXCEPTION}
//  A real-mode application issued a floating-point instruction and floating-point hardware is not present.
//
#define STATUS_ILLEGAL_FLOAT_CONTEXT     ((NTSTATUS)0xC000014AL)

//
// MessageId: STATUS_PIPE_BROKEN
//
// MessageText:
//
//  The pipe operation has failed because the other end of the pipe has been closed.
//
#define STATUS_PIPE_BROKEN               ((NTSTATUS)0xC000014BL)

//
// MessageId: STATUS_REGISTRY_CORRUPT
//
// MessageText:
//
//  {The Registry Is Corrupt}
//  The structure of one of the files that contains Registry data is corrupt, or the image of the file in memory is corrupt, or the file could not be recovered because the alternate copy or log was absent or corrupt.
//
#define STATUS_REGISTRY_CORRUPT          ((NTSTATUS)0xC000014CL)

//
// MessageId: STATUS_REGISTRY_IO_FAILED
//
// MessageText:
//
//  An I/O operation initiated by the Registry failed unrecoverably.
//  The Registry could not read in, or write out, or flush, one of the files that contain the system's image of the Registry.
//
#define STATUS_REGISTRY_IO_FAILED        ((NTSTATUS)0xC000014DL)

//
// MessageId: STATUS_NO_EVENT_PAIR
//
// MessageText:
//
//  An event pair synchronization operation was performed using the thread specific client/server event pair object, but no event pair object was associated with the thread.
//
#define STATUS_NO_EVENT_PAIR             ((NTSTATUS)0xC000014EL)

//
// MessageId: STATUS_UNRECOGNIZED_VOLUME
//
// MessageText:
//
//  The volume does not contain a recognized file system.
//  Please make sure that all required file system drivers are loaded and that the volume is not corrupt.
//
#define STATUS_UNRECOGNIZED_VOLUME       ((NTSTATUS)0xC000014FL)

//
// MessageId: STATUS_SERIAL_NO_DEVICE_INITED
//
// MessageText:
//
//  No serial device was successfully initialized. The serial driver will unload.
//
#define STATUS_SERIAL_NO_DEVICE_INITED   ((NTSTATUS)0xC0000150L)

//
// MessageId: STATUS_NO_SUCH_ALIAS
//
// MessageText:
//
//  The specified local group does not exist.
//
#define STATUS_NO_SUCH_ALIAS             ((NTSTATUS)0xC0000151L)

//
// MessageId: STATUS_MEMBER_NOT_IN_ALIAS
//
// MessageText:
//
//  The specified account name is not a member of the local group.
//
#define STATUS_MEMBER_NOT_IN_ALIAS       ((NTSTATUS)0xC0000152L)

//
// MessageId: STATUS_MEMBER_IN_ALIAS
//
// MessageText:
//
//  The specified account name is already a member of the local group.
//
#define STATUS_MEMBER_IN_ALIAS           ((NTSTATUS)0xC0000153L)

//
// MessageId: STATUS_ALIAS_EXISTS
//
// MessageText:
//
//  The specified local group already exists.
//
#define STATUS_ALIAS_EXISTS              ((NTSTATUS)0xC0000154L)

//
// MessageId: STATUS_LOGON_NOT_GRANTED
//
// MessageText:
//
//  A requested type of logon (e.g., Interactive, Network, Service) is not granted by the target system's local security policy.
//  Please ask the system administrator to grant the necessary form of logon.
//
#define STATUS_LOGON_NOT_GRANTED         ((NTSTATUS)0xC0000155L)

//
// MessageId: STATUS_TOO_MANY_SECRETS
//
// MessageText:
//
//  The maximum number of secrets that may be stored in a single system has been exceeded. The length and number of secrets is limited to satisfy United States State Department export restrictions.
//
#define STATUS_TOO_MANY_SECRETS          ((NTSTATUS)0xC0000156L)

//
// MessageId: STATUS_SECRET_TOO_LONG
//
// MessageText:
//
//  The length of a secret exceeds the maximum length allowed. The length and number of secrets is limited to satisfy United States State Department export restrictions.
//
#define STATUS_SECRET_TOO_LONG           ((NTSTATUS)0xC0000157L)

//
// MessageId: STATUS_INTERNAL_DB_ERROR
//
// MessageText:
//
//  The Local Security Authority (LSA) database contains an internal inconsistency.
//
#define STATUS_INTERNAL_DB_ERROR         ((NTSTATUS)0xC0000158L)

//
// MessageId: STATUS_FULLSCREEN_MODE
//
// MessageText:
//
//  The requested operation cannot be performed in fullscreen mode.
//
#define STATUS_FULLSCREEN_MODE           ((NTSTATUS)0xC0000159L)

//
// MessageId: STATUS_TOO_MANY_CONTEXT_IDS
//
// MessageText:
//
//  During a logon attempt, the user's security context accumulated too many security IDs. This is a very unusual situation.
//  Remove the user from some global or local groups to reduce the number of security ids to incorporate into the security context.
//
#define STATUS_TOO_MANY_CONTEXT_IDS      ((NTSTATUS)0xC000015AL)

//
// MessageId: STATUS_LOGON_TYPE_NOT_GRANTED
//
// MessageText:
//
//  A user has requested a type of logon (e.g., interactive or network) that has not been granted. An administrator has control over who may logon interactively and through the network.
//
#define STATUS_LOGON_TYPE_NOT_GRANTED    ((NTSTATUS)0xC000015BL)

//
// MessageId: STATUS_NOT_REGISTRY_FILE
//
// MessageText:
//
//  The system has attempted to load or restore a file into the registry, and the specified file is not in the format of a registry file.
//
#define STATUS_NOT_REGISTRY_FILE         ((NTSTATUS)0xC000015CL)

//
// MessageId: STATUS_NT_CROSS_ENCRYPTION_REQUIRED
//
// MessageText:
//
//  An attempt was made to change a user password in the security account manager without providing the necessary Windows cross-encrypted password.
//
#define STATUS_NT_CROSS_ENCRYPTION_REQUIRED ((NTSTATUS)0xC000015DL)

//
// MessageId: STATUS_DOMAIN_CTRLR_CONFIG_ERROR
//
// MessageText:
//
//  A Windows Server has an incorrect configuration.
//
#define STATUS_DOMAIN_CTRLR_CONFIG_ERROR ((NTSTATUS)0xC000015EL)

//
// MessageId: STATUS_ILL_FORMED_SERVICE_ENTRY
//
// MessageText:
//
//  A configuration registry node representing a driver service entry was ill-formed and did not contain required value entries.
//
#define STATUS_ILL_FORMED_SERVICE_ENTRY  ((NTSTATUS)0xC0000160L)

//
// MessageId: STATUS_ILLEGAL_CHARACTER
//
// MessageText:
//
//  An illegal character was encountered. For a multi-byte character set this includes a lead byte without a succeeding trail byte. For the Unicode character set this includes the characters 0xFFFF and 0xFFFE.
//
#define STATUS_ILLEGAL_CHARACTER         ((NTSTATUS)0xC0000161L)

//
// MessageId: STATUS_UNMAPPABLE_CHARACTER
//
// MessageText:
//
//  No mapping for the Unicode character exists in the target multi-byte code page.
//
#define STATUS_UNMAPPABLE_CHARACTER      ((NTSTATUS)0xC0000162L)

//
// MessageId: STATUS_UNDEFINED_CHARACTER
//
// MessageText:
//
//  The Unicode character is not defined in the Unicode character set installed on the system.
//
#define STATUS_UNDEFINED_CHARACTER       ((NTSTATUS)0xC0000163L)

//
// MessageId: STATUS_FLOPPY_VOLUME
//
// MessageText:
//
//  The paging file cannot be created on a floppy diskette.
//
#define STATUS_FLOPPY_VOLUME             ((NTSTATUS)0xC0000164L)

//
// MessageId: STATUS_FLOPPY_ID_MARK_NOT_FOUND
//
// MessageText:
//
//  {Floppy Disk Error}
//  While accessing a floppy disk, an ID address mark was not found.
//
#define STATUS_FLOPPY_ID_MARK_NOT_FOUND  ((NTSTATUS)0xC0000165L)

//
// MessageId: STATUS_FLOPPY_WRONG_CYLINDER
//
// MessageText:
//
//  {Floppy Disk Error}
//  While accessing a floppy disk, the track address from the sector ID field was found to be different than the track address maintained by the controller.
//
#define STATUS_FLOPPY_WRONG_CYLINDER     ((NTSTATUS)0xC0000166L)

//
// MessageId: STATUS_FLOPPY_UNKNOWN_ERROR
//
// MessageText:
//
//  {Floppy Disk Error}
//  The floppy disk controller reported an error that is not recognized by the floppy disk driver.
//
#define STATUS_FLOPPY_UNKNOWN_ERROR      ((NTSTATUS)0xC0000167L)

//
// MessageId: STATUS_FLOPPY_BAD_REGISTERS
//
// MessageText:
//
//  {Floppy Disk Error}
//  While accessing a floppy-disk, the controller returned inconsistent results via its registers.
//
#define STATUS_FLOPPY_BAD_REGISTERS      ((NTSTATUS)0xC0000168L)

//
// MessageId: STATUS_DISK_RECALIBRATE_FAILED
//
// MessageText:
//
//  {Hard Disk Error}
//  While accessing the hard disk, a recalibrate operation failed, even after retries.
//
#define STATUS_DISK_RECALIBRATE_FAILED   ((NTSTATUS)0xC0000169L)

//
// MessageId: STATUS_DISK_OPERATION_FAILED
//
// MessageText:
//
//  {Hard Disk Error}
//  While accessing the hard disk, a disk operation failed even after retries.
//
#define STATUS_DISK_OPERATION_FAILED     ((NTSTATUS)0xC000016AL)

//
// MessageId: STATUS_DISK_RESET_FAILED
//
// MessageText:
//
//  {Hard Disk Error}
//  While accessing the hard disk, a disk controller reset was needed, but even that failed.
//
#define STATUS_DISK_RESET_FAILED         ((NTSTATUS)0xC000016BL)

//
// MessageId: STATUS_SHARED_IRQ_BUSY
//
// MessageText:
//
//  An attempt was made to open a device that was sharing an IRQ with other devices.
//  At least one other device that uses that IRQ was already opened.
//  Two concurrent opens of devices that share an IRQ and only work via interrupts is not supported for the particular bus type that the devices use.
//
#define STATUS_SHARED_IRQ_BUSY           ((NTSTATUS)0xC000016CL)

//
// MessageId: STATUS_BIOS_FAILED_TO_CONNECT_INTERRUPT
//
// MessageText:
//
//  The system bios failed to connect a system interrupt to the device or bus for
//  which the device is connected.
//
#define STATUS_BIOS_FAILED_TO_CONNECT_INTERRUPT ((NTSTATUS)0xC000016EL)

//
// MessageId: STATUS_PARTITION_FAILURE
//
// MessageText:
//
//  Tape could not be partitioned.
//
#define STATUS_PARTITION_FAILURE         ((NTSTATUS)0xC0000172L)

//
// MessageId: STATUS_INVALID_BLOCK_LENGTH
//
// MessageText:
//
//  When accessing a new tape of a multivolume partition, the current blocksize is incorrect.
//
#define STATUS_INVALID_BLOCK_LENGTH      ((NTSTATUS)0xC0000173L)

//
// MessageId: STATUS_DEVICE_NOT_PARTITIONED
//
// MessageText:
//
//  Tape partition information could not be found when loading a tape.
//
#define STATUS_DEVICE_NOT_PARTITIONED    ((NTSTATUS)0xC0000174L)

//
// MessageId: STATUS_UNABLE_TO_LOCK_MEDIA
//
// MessageText:
//
//  Attempt to lock the eject media mechanism fails.
//
#define STATUS_UNABLE_TO_LOCK_MEDIA      ((NTSTATUS)0xC0000175L)

//
// MessageId: STATUS_UNABLE_TO_UNLOAD_MEDIA
//
// MessageText:
//
//  Unload media fails.
//
#define STATUS_UNABLE_TO_UNLOAD_MEDIA    ((NTSTATUS)0xC0000176L)

//
// MessageId: STATUS_EOM_OVERFLOW
//
// MessageText:
//
//  Physical end of tape was detected.
//
#define STATUS_EOM_OVERFLOW              ((NTSTATUS)0xC0000177L)

//
// MessageId: STATUS_NO_MEDIA
//
// MessageText:
//
//  {No Media}
//  There is no media in the drive.
//  Please insert media into drive %hs.
//
#define STATUS_NO_MEDIA                  ((NTSTATUS)0xC0000178L)

//
// MessageId: STATUS_NO_SUCH_MEMBER
//
// MessageText:
//
//  A member could not be added to or removed from the local group because the member does not exist.
//
#define STATUS_NO_SUCH_MEMBER            ((NTSTATUS)0xC000017AL)

//
// MessageId: STATUS_INVALID_MEMBER
//
// MessageText:
//
//  A new member could not be added to a local group because the member has the wrong account type.
//
#define STATUS_INVALID_MEMBER            ((NTSTATUS)0xC000017BL)

//
// MessageId: STATUS_KEY_DELETED
//
// MessageText:
//
//  Illegal operation attempted on a registry key which has been marked for deletion.
//
#define STATUS_KEY_DELETED               ((NTSTATUS)0xC000017CL)

//
// MessageId: STATUS_NO_LOG_SPACE
//
// MessageText:
//
//  System could not allocate required space in a registry log.
//
#define STATUS_NO_LOG_SPACE              ((NTSTATUS)0xC000017DL)

//
// MessageId: STATUS_TOO_MANY_SIDS
//
// MessageText:
//
//  Too many Sids have been specified.
//
#define STATUS_TOO_MANY_SIDS             ((NTSTATUS)0xC000017EL)

//
// MessageId: STATUS_LM_CROSS_ENCRYPTION_REQUIRED
//
// MessageText:
//
//  An attempt was made to change a user password in the security account manager without providing the necessary LM cross-encrypted password.
//
#define STATUS_LM_CROSS_ENCRYPTION_REQUIRED ((NTSTATUS)0xC000017FL)

//
// MessageId: STATUS_KEY_HAS_CHILDREN
//
// MessageText:
//
//  An attempt was made to create a symbolic link in a registry key that already has subkeys or values.
//
#define STATUS_KEY_HAS_CHILDREN          ((NTSTATUS)0xC0000180L)

//
// MessageId: STATUS_CHILD_MUST_BE_VOLATILE
//
// MessageText:
//
//  An attempt was made to create a Stable subkey under a Volatile parent key.
//
#define STATUS_CHILD_MUST_BE_VOLATILE    ((NTSTATUS)0xC0000181L)

//
// MessageId: STATUS_DEVICE_CONFIGURATION_ERROR
//
// MessageText:
//
//  The I/O device is configured incorrectly or the configuration parameters to the driver are incorrect.
//
#define STATUS_DEVICE_CONFIGURATION_ERROR ((NTSTATUS)0xC0000182L)

//
// MessageId: STATUS_DRIVER_INTERNAL_ERROR
//
// MessageText:
//
//  An error was detected between two drivers or within an I/O driver.
//
#define STATUS_DRIVER_INTERNAL_ERROR     ((NTSTATUS)0xC0000183L)

//
// MessageId: STATUS_INVALID_DEVICE_STATE
//
// MessageText:
//
//  The device is not in a valid state to perform this request.
//
#define STATUS_INVALID_DEVICE_STATE      ((NTSTATUS)0xC0000184L)

//
// MessageId: STATUS_IO_DEVICE_ERROR
//
// MessageText:
//
//  The I/O device reported an I/O error.
//
#define STATUS_IO_DEVICE_ERROR           ((NTSTATUS)0xC0000185L)

//
// MessageId: STATUS_DEVICE_PROTOCOL_ERROR
//
// MessageText:
//
//  A protocol error was detected between the driver and the device.
//
#define STATUS_DEVICE_PROTOCOL_ERROR     ((NTSTATUS)0xC0000186L)

//
// MessageId: STATUS_BACKUP_CONTROLLER
//
// MessageText:
//
//  This operation is only allowed for the Primary Domain Controller of the domain.
//
#define STATUS_BACKUP_CONTROLLER         ((NTSTATUS)0xC0000187L)

//
// MessageId: STATUS_LOG_FILE_FULL
//
// MessageText:
//
//  Log file space is insufficient to support this operation.
//
#define STATUS_LOG_FILE_FULL             ((NTSTATUS)0xC0000188L)

//
// MessageId: STATUS_TOO_LATE
//
// MessageText:
//
//  A write operation was attempted to a volume after it was dismounted.
//
#define STATUS_TOO_LATE                  ((NTSTATUS)0xC0000189L)

//
// MessageId: STATUS_NO_TRUST_LSA_SECRET
//
// MessageText:
//
//  The workstation does not have a trust secret for the primary domain in the local LSA database.
//
#define STATUS_NO_TRUST_LSA_SECRET       ((NTSTATUS)0xC000018AL)

//
// MessageId: STATUS_NO_TRUST_SAM_ACCOUNT
//
// MessageText:
//
//  The SAM database on the Windows Server does not have a computer account for this workstation trust relationship.
//
#define STATUS_NO_TRUST_SAM_ACCOUNT      ((NTSTATUS)0xC000018BL)

//
// MessageId: STATUS_TRUSTED_DOMAIN_FAILURE
//
// MessageText:
//
//  The logon request failed because the trust relationship between the primary domain and the trusted domain failed.
//
#define STATUS_TRUSTED_DOMAIN_FAILURE    ((NTSTATUS)0xC000018CL)

//
// MessageId: STATUS_TRUSTED_RELATIONSHIP_FAILURE
//
// MessageText:
//
//  The logon request failed because the trust relationship between this workstation and the primary domain failed.
//
#define STATUS_TRUSTED_RELATIONSHIP_FAILURE ((NTSTATUS)0xC000018DL)

//
// MessageId: STATUS_EVENTLOG_FILE_CORRUPT
//
// MessageText:
//
//  The Eventlog log file is corrupt.
//
#define STATUS_EVENTLOG_FILE_CORRUPT     ((NTSTATUS)0xC000018EL)

//
// MessageId: STATUS_EVENTLOG_CANT_START
//
// MessageText:
//
//  No Eventlog log file could be opened. The Eventlog service did not start.
//
#define STATUS_EVENTLOG_CANT_START       ((NTSTATUS)0xC000018FL)

//
// MessageId: STATUS_TRUST_FAILURE
//
// MessageText:
//
//  The network logon failed. This may be because the validation authority can't be reached.
//
#define STATUS_TRUST_FAILURE             ((NTSTATUS)0xC0000190L)

//
// MessageId: STATUS_MUTANT_LIMIT_EXCEEDED
//
// MessageText:
//
//  An attempt was made to acquire a mutant such that its maximum count would have been exceeded.
//
#define STATUS_MUTANT_LIMIT_EXCEEDED     ((NTSTATUS)0xC0000191L)

//
// MessageId: STATUS_NETLOGON_NOT_STARTED
//
// MessageText:
//
//  An attempt was made to logon, but the netlogon service was not started.
//
#define STATUS_NETLOGON_NOT_STARTED      ((NTSTATUS)0xC0000192L)

//
// MessageId: STATUS_ACCOUNT_EXPIRED
//
// MessageText:
//
//  The user's account has expired.
//
#define STATUS_ACCOUNT_EXPIRED           ((NTSTATUS)0xC0000193L)    // ntsubauth

//
// MessageId: STATUS_POSSIBLE_DEADLOCK
//
// MessageText:
//
//  {EXCEPTION}
//  Possible deadlock condition.
//
#define STATUS_POSSIBLE_DEADLOCK         ((NTSTATUS)0xC0000194L)

//
// MessageId: STATUS_NETWORK_CREDENTIAL_CONFLICT
//
// MessageText:
//
//  The credentials supplied conflict with an existing set of credentials.
//
#define STATUS_NETWORK_CREDENTIAL_CONFLICT ((NTSTATUS)0xC0000195L)

//
// MessageId: STATUS_REMOTE_SESSION_LIMIT
//
// MessageText:
//
//  An attempt was made to establish a session to a network server, but there are already too many sessions established to that server.
//
#define STATUS_REMOTE_SESSION_LIMIT      ((NTSTATUS)0xC0000196L)

//
// MessageId: STATUS_EVENTLOG_FILE_CHANGED
//
// MessageText:
//
//  The log file has changed between reads.
//
#define STATUS_EVENTLOG_FILE_CHANGED     ((NTSTATUS)0xC0000197L)

//
// MessageId: STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT
//
// MessageText:
//
//  The account used is an Interdomain Trust account. Use your global user account or local user account to access this server.
//
#define STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT ((NTSTATUS)0xC0000198L)

//
// MessageId: STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT
//
// MessageText:
//
//  The account used is a Computer Account. Use your global user account or local user account to access this server.
//
#define STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT ((NTSTATUS)0xC0000199L)

//
// MessageId: STATUS_NOLOGON_SERVER_TRUST_ACCOUNT
//
// MessageText:
//
//  The account used is an Server Trust account. Use your global user account or local user account to access this server.
//
#define STATUS_NOLOGON_SERVER_TRUST_ACCOUNT ((NTSTATUS)0xC000019AL)

//
// MessageId: STATUS_DOMAIN_TRUST_INCONSISTENT
//
// MessageText:
//
//  The name or SID of the domain specified is inconsistent with the trust information for that domain.
//
#define STATUS_DOMAIN_TRUST_INCONSISTENT ((NTSTATUS)0xC000019BL)

//
// MessageId: STATUS_FS_DRIVER_REQUIRED
//
// MessageText:
//
//  A volume has been accessed for which a file system driver is required that has not yet been loaded.
//
#define STATUS_FS_DRIVER_REQUIRED        ((NTSTATUS)0xC000019CL)

//
// MessageId: STATUS_NO_USER_SESSION_KEY
//
// MessageText:
//
//  There is no user session key for the specified logon session.
//
#define STATUS_NO_USER_SESSION_KEY       ((NTSTATUS)0xC0000202L)

//
// MessageId: STATUS_USER_SESSION_DELETED
//
// MessageText:
//
//  The remote user session has been deleted.
//
#define STATUS_USER_SESSION_DELETED      ((NTSTATUS)0xC0000203L)

//
// MessageId: STATUS_RESOURCE_LANG_NOT_FOUND
//
// MessageText:
//
//  Indicates the specified resource language ID cannot be found in the
//  image file.
//
#define STATUS_RESOURCE_LANG_NOT_FOUND   ((NTSTATUS)0xC0000204L)

//
// MessageId: STATUS_INSUFF_SERVER_RESOURCES
//
// MessageText:
//
//  Insufficient server resources exist to complete the request.
//
#define STATUS_INSUFF_SERVER_RESOURCES   ((NTSTATUS)0xC0000205L)

//
// MessageId: STATUS_INVALID_BUFFER_SIZE
//
// MessageText:
//
//  The size of the buffer is invalid for the specified operation.
//
#define STATUS_INVALID_BUFFER_SIZE       ((NTSTATUS)0xC0000206L)

//
// MessageId: STATUS_INVALID_ADDRESS_COMPONENT
//
// MessageText:
//
//  The transport rejected the network address specified as invalid.
//
#define STATUS_INVALID_ADDRESS_COMPONENT ((NTSTATUS)0xC0000207L)

//
// MessageId: STATUS_INVALID_ADDRESS_WILDCARD
//
// MessageText:
//
//  The transport rejected the network address specified due to an
//  invalid use of a wildcard.
//
#define STATUS_INVALID_ADDRESS_WILDCARD  ((NTSTATUS)0xC0000208L)

//
// MessageId: STATUS_TOO_MANY_ADDRESSES
//
// MessageText:
//
//  The transport address could not be opened because all the available
//  addresses are in use.
//
#define STATUS_TOO_MANY_ADDRESSES        ((NTSTATUS)0xC0000209L)

//
// MessageId: STATUS_ADDRESS_ALREADY_EXISTS
//
// MessageText:
//
//  The transport address could not be opened because it already exists.
//
#define STATUS_ADDRESS_ALREADY_EXISTS    ((NTSTATUS)0xC000020AL)

//
// MessageId: STATUS_ADDRESS_CLOSED
//
// MessageText:
//
//  The transport address is now closed.
//
#define STATUS_ADDRESS_CLOSED            ((NTSTATUS)0xC000020BL)

//
// MessageId: STATUS_CONNECTION_DISCONNECTED
//
// MessageText:
//
//  The transport connection is now disconnected.
//
#define STATUS_CONNECTION_DISCONNECTED   ((NTSTATUS)0xC000020CL)

//
// MessageId: STATUS_CONNECTION_RESET
//
// MessageText:
//
//  The transport connection has been reset.
//
#define STATUS_CONNECTION_RESET          ((NTSTATUS)0xC000020DL)

//
// MessageId: STATUS_TOO_MANY_NODES
//
// MessageText:
//
//  The transport cannot dynamically acquire any more nodes.
//
#define STATUS_TOO_MANY_NODES            ((NTSTATUS)0xC000020EL)

//
// MessageId: STATUS_TRANSACTION_ABORTED
//
// MessageText:
//
//  The transport aborted a pending transaction.
//
#define STATUS_TRANSACTION_ABORTED       ((NTSTATUS)0xC000020FL)

//
// MessageId: STATUS_TRANSACTION_TIMED_OUT
//
// MessageText:
//
//  The transport timed out a request waiting for a response.
//
#define STATUS_TRANSACTION_TIMED_OUT     ((NTSTATUS)0xC0000210L)

//
// MessageId: STATUS_TRANSACTION_NO_RELEASE
//
// MessageText:
//
//  The transport did not receive a release for a pending response.
//
#define STATUS_TRANSACTION_NO_RELEASE    ((NTSTATUS)0xC0000211L)

//
// MessageId: STATUS_TRANSACTION_NO_MATCH
//
// MessageText:
//
//  The transport did not find a transaction matching the specific
//  token.
//
#define STATUS_TRANSACTION_NO_MATCH      ((NTSTATUS)0xC0000212L)

//
// MessageId: STATUS_TRANSACTION_RESPONDED
//
// MessageText:
//
//  The transport had previously responded to a transaction request.
//
#define STATUS_TRANSACTION_RESPONDED     ((NTSTATUS)0xC0000213L)

//
// MessageId: STATUS_TRANSACTION_INVALID_ID
//
// MessageText:
//
//  The transport does not recognized the transaction request identifier specified.
//
#define STATUS_TRANSACTION_INVALID_ID    ((NTSTATUS)0xC0000214L)

//
// MessageId: STATUS_TRANSACTION_INVALID_TYPE
//
// MessageText:
//
//  The transport does not recognize the transaction request type specified.
//
#define STATUS_TRANSACTION_INVALID_TYPE  ((NTSTATUS)0xC0000215L)

//
// MessageId: STATUS_NOT_SERVER_SESSION
//
// MessageText:
//
//  The transport can only process the specified request on the server side of a session.
//
#define STATUS_NOT_SERVER_SESSION        ((NTSTATUS)0xC0000216L)

//
// MessageId: STATUS_NOT_CLIENT_SESSION
//
// MessageText:
//
//  The transport can only process the specified request on the client side of a session.
//
#define STATUS_NOT_CLIENT_SESSION        ((NTSTATUS)0xC0000217L)

//
// MessageId: STATUS_CANNOT_LOAD_REGISTRY_FILE
//
// MessageText:
//
//  {Registry File Failure}
//  The registry cannot load the hive (file):
//  %hs
//  or its log or alternate.
//  It is corrupt, absent, or not writable.
//
#define STATUS_CANNOT_LOAD_REGISTRY_FILE ((NTSTATUS)0xC0000218L)

//
// MessageId: STATUS_DEBUG_ATTACH_FAILED
//
// MessageText:
//
//  {Unexpected Failure in DebugActiveProcess}
//  An unexpected failure occurred while processing a DebugActiveProcess API request. You may choose OK to terminate the process, or Cancel to ignore the error.
//
#define STATUS_DEBUG_ATTACH_FAILED       ((NTSTATUS)0xC0000219L)

//
// MessageId: STATUS_SYSTEM_PROCESS_TERMINATED
//
// MessageText:
//
//  {Fatal System Error}
//  The %hs system process terminated unexpectedly
//  with a status of 0x%08x (0x%08x 0x%08x).
//  The system has been shut down.
//
#define STATUS_SYSTEM_PROCESS_TERMINATED ((NTSTATUS)0xC000021AL)

//
// MessageId: STATUS_DATA_NOT_ACCEPTED
//
// MessageText:
//
//  {Data Not Accepted}
//  The TDI client could not handle the data received during an indication.
//
#define STATUS_DATA_NOT_ACCEPTED         ((NTSTATUS)0xC000021BL)

//
// MessageId: STATUS_NO_BROWSER_SERVERS_FOUND
//
// MessageText:
//
//  {Unable to Retrieve Browser Server List}
//  The list of servers for this workgroup is not currently available.
//
#define STATUS_NO_BROWSER_SERVERS_FOUND  ((NTSTATUS)0xC000021CL)

//
// MessageId: STATUS_VDM_HARD_ERROR
//
// MessageText:
//
//  NTVDM encountered a hard error.
//
#define STATUS_VDM_HARD_ERROR            ((NTSTATUS)0xC000021DL)

//
// MessageId: STATUS_DRIVER_CANCEL_TIMEOUT
//
// MessageText:
//
//  {Cancel Timeout}
//  The driver %hs failed to complete a cancelled I/O request in the allotted time.
//
#define STATUS_DRIVER_CANCEL_TIMEOUT     ((NTSTATUS)0xC000021EL)

//
// MessageId: STATUS_REPLY_MESSAGE_MISMATCH
//
// MessageText:
//
//  {Reply Message Mismatch}
//  An attempt was made to reply to an LPC message, but the thread specified by the client ID in the message was not waiting on that message.
//
#define STATUS_REPLY_MESSAGE_MISMATCH    ((NTSTATUS)0xC000021FL)

//
// MessageId: STATUS_MAPPED_ALIGNMENT
//
// MessageText:
//
//  {Mapped View Alignment Incorrect}
//  An attempt was made to map a view of a file, but either the specified base address or the offset into the file were not aligned on the proper allocation granularity.
//
#define STATUS_MAPPED_ALIGNMENT          ((NTSTATUS)0xC0000220L)

//
// MessageId: STATUS_IMAGE_CHECKSUM_MISMATCH
//
// MessageText:
//
//  {Bad Image Checksum}
//  The image %hs is possibly corrupt. The header checksum does not match the computed checksum.
//
#define STATUS_IMAGE_CHECKSUM_MISMATCH   ((NTSTATUS)0xC0000221L)

//
// MessageId: STATUS_LOST_WRITEBEHIND_DATA
//
// MessageText:
//
//  {Delayed Write Failed}
//  Windows was unable to save all the data for the file %hs. The data has been lost.
//  This error may be caused by a failure of your computer hardware or network connection. Please try to save this file elsewhere.
//
#define STATUS_LOST_WRITEBEHIND_DATA     ((NTSTATUS)0xC0000222L)

//
// MessageId: STATUS_CLIENT_SERVER_PARAMETERS_INVALID
//
// MessageText:
//
//  The parameter(s) passed to the server in the client/server shared memory
//  window were invalid. Too much data may have been put in the shared memory window.
//
#define STATUS_CLIENT_SERVER_PARAMETERS_INVALID ((NTSTATUS)0xC0000223L)

//
// MessageId: STATUS_PASSWORD_MUST_CHANGE
//
// MessageText:
//
//  The user's password must be changed before logging on the first time.
//
#define STATUS_PASSWORD_MUST_CHANGE      ((NTSTATUS)0xC0000224L)    // ntsubauth

//
// MessageId: STATUS_NOT_FOUND
//
// MessageText:
//
//  The object was not found.
//
#define STATUS_NOT_FOUND                 ((NTSTATUS)0xC0000225L)

//
// MessageId: STATUS_NOT_TINY_STREAM
//
// MessageText:
//
//  The stream is not a tiny stream.
//
#define STATUS_NOT_TINY_STREAM           ((NTSTATUS)0xC0000226L)

//
// MessageId: STATUS_RECOVERY_FAILURE
//
// MessageText:
//
//  A transaction recover failed.
//
#define STATUS_RECOVERY_FAILURE          ((NTSTATUS)0xC0000227L)

//
// MessageId: STATUS_STACK_OVERFLOW_READ
//
// MessageText:
//
//  The request must be handled by the stack overflow code.
//
#define STATUS_STACK_OVERFLOW_READ       ((NTSTATUS)0xC0000228L)

//
// MessageId: STATUS_FAIL_CHECK
//
// MessageText:
//
//  A consistency check failed.
//
#define STATUS_FAIL_CHECK                ((NTSTATUS)0xC0000229L)

//
// MessageId: STATUS_DUPLICATE_OBJECTID
//
// MessageText:
//
//  The attempt to insert the ID in the index failed because the ID is already in the index.
//
#define STATUS_DUPLICATE_OBJECTID        ((NTSTATUS)0xC000022AL)

//
// MessageId: STATUS_OBJECTID_EXISTS
//
// MessageText:
//
//  The attempt to set the object's ID failed because the object already has an ID.
//
#define STATUS_OBJECTID_EXISTS           ((NTSTATUS)0xC000022BL)

//
// MessageId: STATUS_CONVERT_TO_LARGE
//
// MessageText:
//
//  Internal OFS status codes indicating how an allocation operation is handled. Either it is retried after the containing onode is moved or the extent stream is converted to a large stream.
//
#define STATUS_CONVERT_TO_LARGE          ((NTSTATUS)0xC000022CL)

//
// MessageId: STATUS_RETRY
//
// MessageText:
//
//  The request needs to be retried.
//
#define STATUS_RETRY                     ((NTSTATUS)0xC000022DL)

//
// MessageId: STATUS_FOUND_OUT_OF_SCOPE
//
// MessageText:
//
//  The attempt to find the object found an object matching by ID on the volume but it is out of the scope of the handle used for the operation.
//
#define STATUS_FOUND_OUT_OF_SCOPE        ((NTSTATUS)0xC000022EL)

//
// MessageId: STATUS_ALLOCATE_BUCKET
//
// MessageText:
//
//  The bucket array must be grown. Retry transaction after doing so.
//
#define STATUS_ALLOCATE_BUCKET           ((NTSTATUS)0xC000022FL)

//
// MessageId: STATUS_PROPSET_NOT_FOUND
//
// MessageText:
//
//  The property set specified does not exist on the object.
//
#define STATUS_PROPSET_NOT_FOUND         ((NTSTATUS)0xC0000230L)

//
// MessageId: STATUS_MARSHALL_OVERFLOW
//
// MessageText:
//
//  The user/kernel marshalling buffer has overflowed.
//
#define STATUS_MARSHALL_OVERFLOW         ((NTSTATUS)0xC0000231L)

//
// MessageId: STATUS_INVALID_VARIANT
//
// MessageText:
//
//  The supplied variant structure contains invalid data.
//
#define STATUS_INVALID_VARIANT           ((NTSTATUS)0xC0000232L)

//
// MessageId: STATUS_DOMAIN_CONTROLLER_NOT_FOUND
//
// MessageText:
//
//  Could not find a domain controller for this domain.
//
#define STATUS_DOMAIN_CONTROLLER_NOT_FOUND ((NTSTATUS)0xC0000233L)

//
// MessageId: STATUS_ACCOUNT_LOCKED_OUT
//
// MessageText:
//
//  The user account has been automatically locked because too many invalid logon attempts or password change attempts have been requested.
//
#define STATUS_ACCOUNT_LOCKED_OUT        ((NTSTATUS)0xC0000234L)    // ntsubauth

//
// MessageId: STATUS_HANDLE_NOT_CLOSABLE
//
// MessageText:
//
//  NtClose was called on a handle that was protected from close via NtSetInformationObject.
//
#define STATUS_HANDLE_NOT_CLOSABLE       ((NTSTATUS)0xC0000235L)

//
// MessageId: STATUS_CONNECTION_REFUSED
//
// MessageText:
//
//  The transport connection attempt was refused by the remote system.
//
#define STATUS_CONNECTION_REFUSED        ((NTSTATUS)0xC0000236L)

//
// MessageId: STATUS_GRACEFUL_DISCONNECT
//
// MessageText:
//
//  The transport connection was gracefully closed.
//
#define STATUS_GRACEFUL_DISCONNECT       ((NTSTATUS)0xC0000237L)

//
// MessageId: STATUS_ADDRESS_ALREADY_ASSOCIATED
//
// MessageText:
//
//  The transport endpoint already has an address associated with it.
//
#define STATUS_ADDRESS_ALREADY_ASSOCIATED ((NTSTATUS)0xC0000238L)

//
// MessageId: STATUS_ADDRESS_NOT_ASSOCIATED
//
// MessageText:
//
//  An address has not yet been associated with the transport endpoint.
//
#define STATUS_ADDRESS_NOT_ASSOCIATED    ((NTSTATUS)0xC0000239L)

//
// MessageId: STATUS_CONNECTION_INVALID
//
// MessageText:
//
//  An operation was attempted on a nonexistent transport connection.
//
#define STATUS_CONNECTION_INVALID        ((NTSTATUS)0xC000023AL)

//
// MessageId: STATUS_CONNECTION_ACTIVE
//
// MessageText:
//
//  An invalid operation was attempted on an active transport connection.
//
#define STATUS_CONNECTION_ACTIVE         ((NTSTATUS)0xC000023BL)

//
// MessageId: STATUS_NETWORK_UNREACHABLE
//
// MessageText:
//
//  The remote network is not reachable by the transport.
//
#define STATUS_NETWORK_UNREACHABLE       ((NTSTATUS)0xC000023CL)

//
// MessageId: STATUS_HOST_UNREACHABLE
//
// MessageText:
//
//  The remote system is not reachable by the transport.
//
#define STATUS_HOST_UNREACHABLE          ((NTSTATUS)0xC000023DL)

//
// MessageId: STATUS_PROTOCOL_UNREACHABLE
//
// MessageText:
//
//  The remote system does not support the transport protocol.
//
#define STATUS_PROTOCOL_UNREACHABLE      ((NTSTATUS)0xC000023EL)

//
// MessageId: STATUS_PORT_UNREACHABLE
//
// MessageText:
//
//  No service is operating at the destination port of the transport on the remote system.
//
#define STATUS_PORT_UNREACHABLE          ((NTSTATUS)0xC000023FL)

//
// MessageId: STATUS_REQUEST_ABORTED
//
// MessageText:
//
//  The request was aborted.
//
#define STATUS_REQUEST_ABORTED           ((NTSTATUS)0xC0000240L)

//
// MessageId: STATUS_CONNECTION_ABORTED
//
// MessageText:
//
//  The transport connection was aborted by the local system.
//
#define STATUS_CONNECTION_ABORTED        ((NTSTATUS)0xC0000241L)

//
// MessageId: STATUS_BAD_COMPRESSION_BUFFER
//
// MessageText:
//
//  The specified buffer contains ill-formed data.
//
#define STATUS_BAD_COMPRESSION_BUFFER    ((NTSTATUS)0xC0000242L)

//
// MessageId: STATUS_USER_MAPPED_FILE
//
// MessageText:
//
//  The requested operation cannot be performed on a file with a user mapped section open.
//
#define STATUS_USER_MAPPED_FILE          ((NTSTATUS)0xC0000243L)

//
// MessageId: STATUS_AUDIT_FAILED
//
// MessageText:
//
//  {Audit Failed}
//  An attempt to generate a security audit failed.
//
#define STATUS_AUDIT_FAILED              ((NTSTATUS)0xC0000244L)

//
// MessageId: STATUS_TIMER_RESOLUTION_NOT_SET
//
// MessageText:
//
//  The timer resolution was not previously set by the current process.
//
#define STATUS_TIMER_RESOLUTION_NOT_SET  ((NTSTATUS)0xC0000245L)

//
// MessageId: STATUS_CONNECTION_COUNT_LIMIT
//
// MessageText:
//
//  A connection to the server could not be made because the limit on the number of concurrent connections for this account has been reached.
//
#define STATUS_CONNECTION_COUNT_LIMIT    ((NTSTATUS)0xC0000246L)

//
// MessageId: STATUS_LOGIN_TIME_RESTRICTION
//
// MessageText:
//
//  Attempting to login during an unauthorized time of day for this account.
//
#define STATUS_LOGIN_TIME_RESTRICTION    ((NTSTATUS)0xC0000247L)

//
// MessageId: STATUS_LOGIN_WKSTA_RESTRICTION
//
// MessageText:
//
//  The account is not authorized to login from this station.
//
#define STATUS_LOGIN_WKSTA_RESTRICTION   ((NTSTATUS)0xC0000248L)

//
// MessageId: STATUS_IMAGE_MP_UP_MISMATCH
//
// MessageText:
//
//  {UP/MP Image Mismatch}
//  The image %hs has been modified for use on a uniprocessor system, but you are running it on a multiprocessor machine.
//  Please reinstall the image file.
//
#define STATUS_IMAGE_MP_UP_MISMATCH      ((NTSTATUS)0xC0000249L)

//
// MessageId: STATUS_INSUFFICIENT_LOGON_INFO
//
// MessageText:
//
//  There is insufficient account information to log you on.
//
#define STATUS_INSUFFICIENT_LOGON_INFO   ((NTSTATUS)0xC0000250L)

//
// MessageId: STATUS_BAD_DLL_ENTRYPOINT
//
// MessageText:
//
//  {Invalid DLL Entrypoint}
//  The dynamic link library %hs is not written correctly. The stack pointer has been left in an inconsistent state.
//  The entrypoint should be declared as WINAPI or STDCALL. Select YES to fail the DLL load. Select NO to continue
//  execution. Selecting NO may cause the application to operate incorrectly.
//
#define STATUS_BAD_DLL_ENTRYPOINT        ((NTSTATUS)0xC0000251L)

//
// MessageId: STATUS_BAD_SERVICE_ENTRYPOINT
//
// MessageText:
//
//  {Invalid Service Callback Entrypoint}
//  The %hs service is not written correctly. The stack pointer has been left in an inconsistent state.
//  The callback entrypoint should be declared as WINAPI or STDCALL. Selecting OK will cause the
//  service to continue operation. However, the service process may operate incorrectly.
//
#define STATUS_BAD_SERVICE_ENTRYPOINT    ((NTSTATUS)0xC0000252L)

//
// MessageId: STATUS_LPC_REPLY_LOST
//
// MessageText:
//
//  The server received the messages but did not send a reply.
//
#define STATUS_LPC_REPLY_LOST            ((NTSTATUS)0xC0000253L)

//
// MessageId: STATUS_IP_ADDRESS_CONFLICT1
//
// MessageText:
//
//  The system has detected an IP address conflict with another system on the network. The local interface has been disabled.
//  More details are available in the system event log.
//  Consult your network administrator to resolve the conflict.
//
#define STATUS_IP_ADDRESS_CONFLICT1      ((NTSTATUS)0xC0000254L)

//
// MessageId: STATUS_IP_ADDRESS_CONFLICT2
//
// MessageText:
//
//  The system has detected an IP address conflict with another system on the network. Network operations on this system may be disrupted as a result.
//  More details are available in the system event log.
//  Consult your network administrator immediately to resolve the conflict.
//
#define STATUS_IP_ADDRESS_CONFLICT2      ((NTSTATUS)0xC0000255L)

//
// MessageId: STATUS_REGISTRY_QUOTA_LIMIT
//
// MessageText:
//
//  {Low On Registry Space}
//  Your maximum registry size is too small. To ensure that Windows runs properly, increase your maximum registry size. For more information, see Help.
//
#define STATUS_REGISTRY_QUOTA_LIMIT      ((NTSTATUS)0xC0000256L)

//
// MessageId: STATUS_PATH_NOT_COVERED
//
// MessageText:
//
//  The contacted server does not support the indicated part of the DFS namespace.
//
#define STATUS_PATH_NOT_COVERED          ((NTSTATUS)0xC0000257L)

//
// MessageId: STATUS_NO_CALLBACK_ACTIVE
//
// MessageText:
//
//  A callback return system service cannot be executed when no callback is active.
//
#define STATUS_NO_CALLBACK_ACTIVE        ((NTSTATUS)0xC0000258L)

//
// MessageId: STATUS_LICENSE_QUOTA_EXCEEDED
//
// MessageText:
//
//  The service being accessed is licensed for a particular number of connections.
//  No more connections can be made to the service at this time because there are already as many connections as the service can accept.
//
#define STATUS_LICENSE_QUOTA_EXCEEDED    ((NTSTATUS)0xC0000259L)

//
// MessageId: STATUS_PWD_TOO_SHORT
//
// MessageText:
//
//  The password provided is too short to meet the policy of your user account.
//  Please choose a longer password.
//
#define STATUS_PWD_TOO_SHORT             ((NTSTATUS)0xC000025AL)

//
// MessageId: STATUS_PWD_TOO_RECENT
//
// MessageText:
//
//  The policy of your user account does not allow you to change passwords too frequently.
//  This is done to prevent users from changing back to a familiar, but potentially discovered, password.
//  If you feel your password has been compromised then please contact your administrator immediately to have a new one assigned.
//
#define STATUS_PWD_TOO_RECENT            ((NTSTATUS)0xC000025BL)

//
// MessageId: STATUS_PWD_HISTORY_CONFLICT
//
// MessageText:
//
//  You have attempted to change your password to one that you have used in the past.
//  The policy of your user account does not allow this. Please select a password that you have not previously used.
//
#define STATUS_PWD_HISTORY_CONFLICT      ((NTSTATUS)0xC000025CL)

//
// MessageId: STATUS_PLUGPLAY_NO_DEVICE
//
// MessageText:
//
//  You have attempted to load a legacy device driver while its device instance had been disabled.
//
#define STATUS_PLUGPLAY_NO_DEVICE        ((NTSTATUS)0xC000025EL)

//
// MessageId: STATUS_UNSUPPORTED_COMPRESSION
//
// MessageText:
//
//  The specified compression format is unsupported.
//
#define STATUS_UNSUPPORTED_COMPRESSION   ((NTSTATUS)0xC000025FL)

//
// MessageId: STATUS_INVALID_HW_PROFILE
//
// MessageText:
//
//  The specified hardware profile configuration is invalid.
//
#define STATUS_INVALID_HW_PROFILE        ((NTSTATUS)0xC0000260L)

//
// MessageId: STATUS_INVALID_PLUGPLAY_DEVICE_PATH
//
// MessageText:
//
//  The specified Plug and Play registry device path is invalid.
//
#define STATUS_INVALID_PLUGPLAY_DEVICE_PATH ((NTSTATUS)0xC0000261L)

//
// MessageId: STATUS_DRIVER_ORDINAL_NOT_FOUND
//
// MessageText:
//
//  {Driver Entry Point Not Found}
//  The %hs device driver could not locate the ordinal %ld in driver %hs.
//
#define STATUS_DRIVER_ORDINAL_NOT_FOUND  ((NTSTATUS)0xC0000262L)

//
// MessageId: STATUS_DRIVER