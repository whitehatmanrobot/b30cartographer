( column2 <= 0 )		// <0 means end of line
	{
		MST.DoKeys("+{end}");
		return;
	}
	else if( column2 > column1 )			// select to column2
		wsprintf(acBuf, "+{right %d}", column2 - column1);
	else if( column2 < column1 )
		wsprintf(acBuf, "+{left %d}", column1 - column2);
	if( column2 != column1 )
		MST.DoKeys( acBuf );

	while( GetCurrentColumn() > column2 )	// adjust for tabs
		MST.DoKeys("+{left}");
	ThisLine = GetCurrentLine();  // To stop runaway right keys
	while(( GetCurrentColumn() < column2 ) && ( GetCurrentLine() == ThisLine ))
		MST.DoKeys("+{right}");
	if ( GetCurrentLine() != ThisLine ) 
		LOG->RecordInfo("Column %d not available",column2);
}


// BEGIN_HELP_COMMENT
// Function: void COSource::SelectLines(int startline /* 0 */, int count /* 1 */)
// Description: Select one or more lines in the source editor.
// Return: none
// Param: startline An integer that contains the starting line of the block to select (0 represents the current line).
// Param: count An integer that contains the number of lines to select.
// END_HELP_COMMENT
void COSource::SelectLines(int startline /* 0 */, int count /* 1 */)

{
	// 0 represents the current line.
	if(startline > 0)
		GoToLine(startline);
	
	// hit the HOME key until we are in column 1 (with indentation it shouldn't take more than twice).
	while(GetCurrentColumn() != 1)
		MST.DoKeyshWnd(m_editor.HWnd(), "{HOME}");

	// select the line(s).
	for(int i = 0; i < count; i++)
		MST.DoKeyshWnd(m_editor.HWnd(), "+({DOWN})");
}


// BEGIN_HELP_COMMENT
// Function: void COSource::SetCursor(int line, int column)
// Description: Set the caret to the given line and column in the source editor.
// Return: none
// Param: line An integer containing the line to set the caret to.
// Param: column An integer containing the column to set the caret to.
// END_HELP_COMMENT
void COSource::SetCursor(int line, int column)
{
	int ThisLine = 0;

	MUST_BE_ACTIVE_V();

	if( line <= 0 )
        MST.DoKeys("^{end}{home}");    // beginning of last line in file
	else
		GoToLine(line);

	char acBuf[16] = "{end}";		// end of line
	if( column <= 0 )
	{
		MST.DoKeys(acBuf);
		return;
	}

	wsprintf(acBuf, "{right %d}", column - 1);	// or to a specific column
	MST.DoKeys(acBuf);

	while( GetCurrentColumn() > column )	// adjust for tabs
		MST.DoKeys("{left}");
	ThisLine = GetCurrentLine();  // To stop runaway right keys
	while(( GetCurrentColumn() < column ) && ( GetCurrentLine() == ThisLine ))
		MST.DoKeys("{right}");
	if ( GetCurrentLine() != ThisLine ) 
		LOG->RecordInfo("Column %d not available",column);
}

// BEGIN_HELP_COMMENT
// Function: void COSource::InsertText(LPCSTR szText, int line, int column, BOOL bLiteral /*=FALSE*/)
// Description: Insert the given text at the given line and column in the source editor.
// Return: none
// Param: szText A pointer to a string that contains the text to insert into the source editor.
// Param: line An integer that contains the line where the text should be inserted.
// Param: column An integer that contains the column where the text should be inserted.
// Param: bLiteral A Boolean value that indicates whether the string (szText) should be interpreted literally (TRUE) or following MS-Test's DoKeys intepretation. (The default value is FALSE.)
// END_HELP_COMMENT
void COSource::InsertText(LPCSTR szText, int line, int column, BOOL bLiteral /*=FALSE*/)
{
	MUST_BE_ACTIVE_V();

	SetCursor(line, column);
	MST.DoKeyshWnd(m_editor.HWnd(), szText, bLiteral);
}

// BEGIN_HELP_COMMENT
// Function: void COSource::TypeTextAtCursor(LPCSTR szText, BOOL bLiteral /*=FALSE*/)
// Description: Type the given text at the current caret location in the source editor.
// Return: none
// Param: szText A pointer to a string that contains the text to type at the caret location.
// Param: bLiteral A Boolean value that indicates whether the string (szText) should be interpreted literally (TRUE) or following MS-Test's DoKeys intepretation. (The default value is FALSE.)
// END_HELP_COMMENT
void COSource::TypeTextAtCursor(LPCSTR szText, BOOL bLiteral /*=FALSE*/)
{
	MUST_BE_ACTIVE_V();

	MST.DoKeyshWnd(m_editor.HWnd(), szText, bLiteral);
}

// BEGIN_HELP_COMMENT
// Function: BOOL COSource::GoToLine(LPCSTR szLine)
// Description: Go to the given line in the source editor.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: szLine A pointer to a string containing the line number to go to.
// Param: bCloseAfter A Boolean value that indicates if dialog should be closed after the command was implemented (TRUE).
// END_HELP_COMMENT
BOOL COSource::GoToLine(LPCSTR szLine, BOOL bCloseAfter /* TRUE */)
{
	UIWB.DoCommand(IDM_GOTO_LINE, DC_MNEMONIC);
	UIDialog gd(GetLocString(IDSS_GOTO_TITLE));
	if( !gd.WaitAttachActive(10000) )
	{
		LOG->RecordInfo("Could not open the Goto dialog");
		return FALSE;
	}

	MST.DoKeyshWnd(gd.HWnd(), szLine);
	Sleep(500);
	MST.DoKeyshWnd(gd.HWnd(), "{ENTER}");

	if(bCloseAfter)
	{
		gd.Close();
		gd.WaitUntilGone(1000);
//		UIWB.DoCommand(IDM_CURSOR_BEGINLINE, DC_MNEMONIC);
		MST.DoKeys("{ESC}");
	}

	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL COSource::GoToLine(int nLine)
// Description: Go to the given line in the source editor.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: nLine An integer containing the line number to go to.
// Param: bCloseAfter A Boolean value that indicates if dialog should be closed after the command was implemented (TRUE).
// END_HELP_COMMENT
BOOL COSource::GoToLine(int nLine, BOOL bCloseAfter /* TRUE */)
{
	char szLine[7];
	_itoa(nLine, szLine, 10);
	return GoToLine(szLine, bCloseAfter);
}

// BEGIN_HELP_COMMENT
// Function: BOOL COSource::Find(LPCSTR szFind, BOOL bMatchWord, BOOL bMatchCase, BOOL bRegExpr, int fd)
// Description: Find the given string (szFind) in this source editor window.
// Return: TRUE if successful; FALSE otherwise.
// Param: szFind A pointer to a string containing the text to find in this window.
// Param: bMatchWord A Boolean value that indicates how to match words: TRUE to only find whole words; FALSE to find partial words. (Default value is FALSE.)
// Param: bMatchCase A Boolean value that indicates how to match case: TRUE to match the case exactly; FALSE to ignore case. (Default value is FALSE.)
// Param: bRegExpr A Boolean value that indicates whether the find string is a regular expression (TRUE) or not. (Default value is FALSE.)
// Param: fd A value that indicates the search direction: FD_DOWN to search toward the end of the file; FD_UP to search toward the top of the file. (Default value is FD_DOWN.)
// END_HELP_COMMENT
BOOL COSource::Find(LPCSTR szFind, BOOL bMatchWord /*= FALSE*/, BOOL bMatchCase /*= FALSE*/, BOOL bRegExpr /*= FALSE*/, int fd /*= FD_DOWN*/)
{
	UIFindDlg uiFind;

	//REVIEW: (michma)
	// requiring an active editor that UIEditor knows about excludes
	// files that are loaded via the debugger.  but debugger tests
	// need this Find function. recommendation is to enhance CODebug
	// and COSource classes to automatically maintain UIEditor objects
	// for any source files loaded while debugging.  temporarily we will
	// activate the editor if it exists , but we won't require a valid editor
	// to use this function.
	//MUST_BE_ACTIVE_B();
	m_editor.Activate();

	// open the find dialog
	uiFind.Activate();

	// set the find string
	uiFind.SetFindString(szFind);
	// set match word
	uiFind.SetMatchWord(bMatchWord);
	// set match case
	uiFind.SetMatchCase(bMatchCase);
	// set regular expression
	uiFind.SetRegularExpression(bRegExpr);
	// set find direction
	uiFind.SetDirection(fd == FD_UP ? UIFindDlg::FD_UP : UIFindDlg::FD_DOWN);

	// do the find
	uiFind.FindNext();

	// must look for "OK" button string rather than ctrl id because
	// while debugging there apparently is another control with the same id
	// which causes this function to incorrectly fail. (michma)
	if(MST.WFndWndWaitC(GetLocString(IDSS_OK), "Button", FW_PART | FW_ACTIVE, 3))
		{     
		if(MST.WFndWndC(GetLocString(IDSS_NOT_FOUND), "Static", FW_PART )) 
			LOG->RecordInfo("Could not find %s ",szFind);

		MST.DoKeys("{ESC}") ;  // get rid of OK message
		MST.DoKeys("{ESC}") ;  // get rid of menu
		return(FALSE);  // move on to next test
		}

	else
		return (TRUE);

}

// BEGIN_HELP_COMMENT
// Function: int COSource::Replace(LPCSTR szFind, LPCSTR szReplace, BOOL bMatchWord, BOOL bMatchCase, BOOL bRegExpr, COSource::ReplaceScope rs, BOOL bAll /*= FALSE*/)
// Description: Find (szFind) and replace (szReplace) in this source editor window.
// Return: An integer that specifies the number of occurences that were replaced by the operation.
// Param: szFind A pointer to a string containing the text to find in this window.
// Param: szReplace A pointer to a string containing the text to replace the found string within this window.
// Param: bMatchWord A Boolean value that indicates how to match words: TRUE to only find whole words; FALSE to find partial words. (Default value is FALSE.)
// Param: bMatchCase A Boolean value that indicates how to match case: TRUE to match the case exactly; FALSE to ignore case. (Default value is FALSE.)
// Param: bRegExpr A Boolean value that indicates whether the find string is a regular expression (TRUE) or not. (Default value is FALSE.)
// Param: rs A value that indicates the scope of the replace operation: COSource::RS_WHOLEFILE to search and replace across the entire file; COSource::RS_SELECTION to search and replace within the selection. (Default value is COSource::RS_WHOLEFILE.)
// Param: bAll A Boolean value that indicates whether to replace all occurences in the file/selection (TRUE) or just the first one. (Default value is FALSE.)
// END_HELP_COMMENT
int COSource::Replace(LPCSTR szFind, LPCSTR szReplace, BOOL bMatchWord /*= FALSE*/, BOOL bMatchCase /*= FALSE*/, BOOL bRegExpr /*= FALSE*/, COSource::ReplaceScope rs /*= RS_WHOLEFILE*/, BOOL bAll /*= FALSE*/)
{
	UIReplaceDlg uiReplace;

	MUST_BE_ACTIVE_B();

	// open the replace dialog
	uiReplace.Activate();

	// set the find string
	uiReplace.SetFindString(szFind);
	// set the replace string
	uiReplace.SetReplaceString(szReplace);
	// set match word
	uiReplace.SetMatchWord(bMatchWord);
	// set match case
	uiReplace.SetMatchCase(bMatchCase);
	// set regular expression
	uiReplace.SetRegularExpression(bRegExpr);
	// set replace scope
	uiReplace.SetReplaceScope(rs == RS_WHOLEFILE ? UIReplaceDlg::RS_WHOLEFILE : UIReplaceDlg::RS_SELECTION);

	// are replacing one occurence or all of them
	if (bAll) {
		// replace all
		int nReplaced = uiReplace.ReplaceAll();
		// close the dialog
		uiReplace.Close();
		return nReplaced;
	}
	else {
		// find the next occurance
		uiReplace.FindNext();
		// do the replace
		uiReplace.Replace();
		// close the dialog
		uiReplace.Close();
		return 1;
	}
}


// BEGIN_HELP_COMMENT
// Function: SelectEmulations(int EMULATE_EDITOR)
// Description: Select Editor to emulate from Tools.Options.Compatibility
// Return: TRUE if successful; FALSE otherwise.
// Param: EMULATE_EDITOR The editor to emulate from: EMULATE_VC3, EMULATE_VC2, EMULATE_BRIEF, EMULATE_EPSILON, EMULATE_CUSTOM 
// END_HELP_COMMENT
BOOL COSource::SelectEmulations(EmulationType eEM)
{

// REVIEW we need a UIDialog Class for this	
	UIOptionsTabDlg OptionsTools;
	OptionsTools.ShowPage("Compatibility");
	OptionsTools.ChangeCompatility(eEM) ;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\src\export.h ===
///////////////////////////////////////////////////////////////////////////////
//	export.h (SRC export)
//
//	Created by :			Date :
//		ScotF			06/20/97
//
//	Description :
//		SRC DLL defines
//

#ifndef __SRCXPRT_H__
#define __SRCXPRT_H__

#ifdef EXPORT_SRC
	#define SRC_CLASS AFX_EXT_CLASS
	#define SRC_API   AFX_EXT_API
	#define SRC_DATA  AFX_EXT_DATA
#else
	#define SRC_CLASS __declspec(dllimport)
	#define SRC_API   __declspec(dllimport)
	#define SRC_DATA  __declspec(dllimport)

	#ifdef _DEBUG 
		#pragma comment(lib, "srcd.lib")
	#else
		#pragma comment(lib, "src.lib")
	#endif
#endif

#endif // __SRCXPRT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\src\cosource.h ===
///////////////////////////////////////////////////////////////////////////////
//	COSOURCE.H
//
//	Created by :			Date :
//		DavidGa					1/10/94
//
//	Description :
//		Declaration of the COSource component object class
//

#ifndef __COSOURCE_H__
#define __COSOURCE_H__

#include "..\eds\cofile.h"

#include "export.h"
#include "..\shl\uioptdlg.h"

#define ERROR_ERROR	-1	// REVIEW: define this in a better place

///////////////////////////////////////////////////////////////////////////////
// SOURCE_CREATE_STRUCT class

struct SOURCE_CREATE_STRUCT		// REVIEW: what else?
{
	LPCSTR szFileName;
};

typedef enum { SELECT_NORMAL, SELECT_COLUMN, SELECT_BRIEF_COLUMN } SelectionType;

///////////////////////////////////////////////////////////////////////////////
// COSource class

// BEGIN_CLASS_HELP
// ClassName: COSource
// BaseClass: COFile
// Category: Editors
// END_CLASS_HELP
class SRC_CLASS COSource : public COFile
{
public:
// data types
	enum FindDirection { FD_UP, FD_DOWN };
	enum ReplaceScope { RS_WHOLEFILE, RS_SELECTION };
// defines for Compatibility choices

public:
	COSource();

// Data
protected:

// File Operations
public:
	int Create(LPCSTR szSaveAs = NULL);
	virtual int Open(LPCSTR szFileName, LPCSTR szChDir = NULL, EOpenAs oa = OA_AUTO);

// Editor Attributes
public:
	BOOL GetReadOnly(void);
	int GetCurrentLine(void);
	int GetCurrentColumn(void);
	CString GetSelectedText(void);

// Selection Operations
public:
	void SelectText(int line1, int column1, int line2, int column2, BOOL bColumnSelect = SELECT_NORMAL);
	void SelectLines(int startline = 0, int count = 1);
	void SetCursor(int line, int column);
	void InsertText(LPCSTR szText, int line, int column, BOOL bLiteral=FALSE);
	void TypeTextAtCursor(LPCSTR szText,BOOL bLiteral=FALSE);

// operations
public:
	BOOL GoToLine(LPCSTR szLine, BOOL bCloseAfter = TRUE);
	BOOL GoToLine(int nLine, BOOL bCloseAfter = TRUE);

	BOOL SetFont(LPCSTR pszFontName = NULL, int iFontSize = 0, LPCSTR pszFontStyle = NULL);

// Emulation Selection
	BOOL SelectEmulations(EmulationType eEM);

// search and replace operations
	BOOL Find(LPCSTR szFind, BOOL bMatchWord = FALSE, BOOL bMatchCase = FALSE, BOOL bRegExpr = FALSE, int fd = FD_DOWN);
	BOOL Replace(LPCSTR szFind, LPCSTR szReplace, BOOL bMatchWord = FALSE, BOOL bMatchCase = FALSE, BOOL bRegExpr = FALSE, ReplaceScope rs = RS_WHOLEFILE, BOOL bAll = FALSE);

//	TODO: Bookmark functions, if anyone needs them

};

enum FIND_DIRECTION {FIND_UP = COSource::FD_UP, FIND_DOWN = COSource::FD_DOWN };

#endif //__COSOURCE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\src\ufindrep.h ===
///////////////////////////////////////////////////////////////////////////////
//	UFINDREP.H
//
//	Created by :			Date :
//		DavidGa					4/13/94
//
//	Description :
//		Declaration of the UIFindDlg and UIReplaceDlg classes
//

#ifndef __UIFINDREP_H__
#define __UIFINDREP_H__

#include "..\..\udialog.h"

#include "export.h"

#ifndef __UIDIALOG_H__
	#error include 'udialog.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
//	UIFindDlg class

//enum { DIR_DOWN = FALSE, DIR_UP = TRUE };

// BEGIN_CLASS_HELP
// ClassName: UIFindDlg
// BaseClass: UIDialog
// Category: Editors
// END_CLASS_HELP
class SRC_CLASS UIFindDlg : public UIDialog
{
// data types
public:
	enum FindDirection { FD_DOWN, FD_UP };

// base class overrides
public:	
	UIWND_COPY_CTOR(UIFindDlg, UIDialog);

	virtual BOOL VerifyUnique(void) const;
	virtual BOOL Activate(void);
	virtual HWND Close(void);

// operations
public:
	BOOL SetFindString(LPCSTR szFind);
	BOOL SetMatchWord(BOOL bMatchWord = FALSE);
	BOOL SetMatchCase(BOOL bMatchCase = FALSE);
	BOOL SetRegularExpression(BOOL bRegExpr = FALSE);
	BOOL SetDirection(FindDirection fd = FD_DOWN);

	BOOL FindNext(void);
	BOOL SetBookmarks(void);
};

///////////////////////////////////////////////////////////////////////////////
//	UIReplaceDlg class

// BEGIN_CLASS_HELP
// ClassName: UIReplaceDlg
// BaseClass: UIDialog
// Category: Editors
// END_CLASS_HELP
class SRC_CLASS UIReplaceDlg : public UIDialog
{
// data types
public:
	enum ReplaceScope { RS_WHOLEFILE, RS_SELECTION };

// base class overrides
public:
	UIWND_COPY_CTOR(UIReplaceDlg, UIDialog);
	virtual BOOL VerifyUnique(void) const;
	virtual BOOL Activate(void);
	virtual HWND Close(void);

// operations
public:
	BOOL SetFindString(LPCSTR szFind);
	BOOL SetReplaceString(LPCSTR szReplace);
	BOOL SetMatchWord(BOOL bMatchWord = FALSE);
	BOOL SetMatchCase(BOOL bMatchCase = FALSE);
	BOOL SetRegularExpression(BOOL bRegExpr = FALSE);
	BOOL SetReplaceScope(ReplaceScope rs = RS_WHOLEFILE);

	BOOL FindNext(void);
	BOOL Replace(void);
	int ReplaceAll(void);
};

#endif //__UIFINDREP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\src\ufindrep.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	UFINDREP.CPP
//
//	Created by :			Date :
//		DavidGa					4/13/94
//
//	Description :
//		Implementation of the UIFindDlg and UIReplaceDlg classes
//

#include "stdafx.h"
#include "ufindrep.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "..\sym\cmdids.h"
#include "..\sym\vcpp32.h"
#include "..\sym\vshell.h"
#include "..\shl\uwbframe.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

///////////////////////////////////////////////////////////////////////////////
//	UIFindDlg class

// base class overrides
BOOL UIFindDlg::VerifyUnique(void) const
{
	return VerifyDlgItemClass(VSHELL_IDC_FIND_WHAT, GL_COMBOBOX);
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIFindDlg::Activate(void)
// Description: Open the Find dialog.
// Return: A Boolean that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIFindDlg::Activate(void)
{
	UIWB.DoCommand(ID_EDIT_FIND_DLG, DC_MNEMONIC);
	if (WaitAttachActive(5000)) {
		return TRUE;
	}
	return FALSE;
}

// BEGIN_HELP_COMMENT
// Function: HWND UIFindDlg::Close(void)
// Description: Close the Find dialog.
// Return: NULL, if successful; the HWND of the Find dialog, if it failed to close.
// END_HELP_COMMENT
HWND UIFindDlg::Close(void)
{
	return UIDialog::Cancel();
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIFindDlg::SetFindString(LPCSTR szFind)
// Description: Set the text given in szFind in the Find What edit box in the Find dialog.
// Return: A Boolean that indicates success. TRUE if successful; FALSE otherwise.
// Param: szFind A pointer to a string containing the text to enter in the Find What edit box in the Find dialog.
// END_HELP_COMMENT
BOOL UIFindDlg::SetFindString(LPCSTR szFind)
{
	MST.WComboSetText(GetLabel(VSHELL_IDC_FIND_WHAT), szFind);
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIFindDlg::SetMatchWord(BOOL bMatchWord)
// Description: Check or uncheck the Match Whole Word Only checkbox based on the value of bMatchWord.
// Return: A Boolean that indicates success. TRUE if successful; FALSE otherwise.
// Param: bMatchWord A Boolean value that, if TRUE means check the Match Whole Word Only checkbox, and if FALSE means uncheck it. (Default value is FALSE.)
// END_HELP_COMMENT
BOOL UIFindDlg::SetMatchWord(BOOL bMatchWord /*= FALSE*/)
{
	if (bMatchWord) {
		MST.WCheckCheck(GetLabel(VSHELL_IDC_FIND_WHOLEWORD));
	}
	else {
		MST.WCheckUnCheck(GetLabel(VSHELL_IDC_FIND_WHOLEWORD));
	}
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIFindDlg::SetMatchCase(BOOL bMatchCase)
// Description: Check or uncheck the Match Case checkbox based on the value of bMatchCase.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: bMatchCase A Boolean value that, if TRUE means check the Match Case checkbox, and if FALSE means uncheck it. (Default value is FALSE.)
// END_HELP_COMMENT
BOOL UIFindDlg::SetMatchCase(BOOL bMatchCase /*= FALSE*/)
{
	if (bMatchCase) {
		MST.WCheckCheck(GetLabel(VSHELL_IDC_FIND_MATCHUPLO));
	}
	else {
		MST.WCheckUnCheck(GetLabel(VSHELL_IDC_FIND_MATCHUPLO));
	}
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIFindDlg::SetRegularExpression(BOOL bRegExpr)
// Description: Check or uncheck the Regular Expression checkbox based on the value of bRegExpr.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: bRegExpr A Boolean value that, if TRUE means check the Regular Expression checkbox, and if FALSE means uncheck it. (Default value is FALSE.)
// END_HELP_COMMENT
BOOL UIFindDlg::SetRegularExpression(BOOL bRegExpr)
{
	if (bRegExpr) {
		MST.WCheckCheck(GetLabel(VSHELL_IDC_FIND_REGEXP));
	}
	else {
		MST.WCheckUnCheck(GetLabel(VSHELL_IDC_FIND_REGEXP));
	}
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIFindDlg::SetDirection(UIFindDlg::FindDirection fd)
// Description: Set the find direction in the Find dialog box.
// Return: A Boolean value that indicates succees. TRUE if successful; FALSE otherwise.
// Param: fd A value that indicates the find direction. FD_UP to set the find direction to up; FD_DOWN to set the find direction to down. (Default value is FD_DOWN.)
// END_HELP_COMMENT
BOOL UIFindDlg::SetDirection(UIFindDlg::FindDirection fd /*= FD_DOWN*/)
{
	if (fd == FD_UP) {
		MST.WOptionClick(GetLabel(VSHELL_IDC_FIND_UP));
	}
	else {
		if (fd == FD_DOWN) {
			MST.WOptionClick(GetLabel(VSHELL_IDC_FIND_DOWN));
		}
		else {
			ASSERT(0);
			// REVIEW(briancr): we need to set an the error type and string here
			return FALSE;
		}
	}
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIFindDlg::FindNext(void)
// Description: Perform the find operation by clicking the Find Next button in the Find dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIFindDlg::FindNext(void)
{
	MST.WButtonClick(GetLabel(VSHELL_IDC_FIND_NEXT));
	// REVIEW(briancr): we need to set an error type and string here if the dialog doesn't go away
	return WaitUntilGone(1000);
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIFindDlg::SetBookmarks(void)
// Description: Perform the set bookmarks operation by clicking on the Set Bookmarks on All button in the Find dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIFindDlg::SetBookmarks(void)
{
	MST.WButtonClick(GetLabel(VSHELL_IDC_FIND_MARK_ALL));
	// REVIEW(briancr): we need to set an error type and string here if the dialog doesn't go away
	return WaitUntilGone(1000);
}

///////////////////////////////////////////////////////////////////////////////
//	UIReplaceDlg class

// base class overrides
BOOL UIReplaceDlg::VerifyUnique(void) const
{
	return VerifyDlgItemClass(VCPP32_ID_REPLACE_REPLACEWITH, GL_COMBOBOX);
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIReplaceDlg::Activate(void)
// Description: Open the Replace dialog.
// Return: NULL, if successful; the HWND of the Replace dialog, if it failed to close.
// END_HELP_COMMENT
BOOL UIReplaceDlg::Activate(void)
{
	UIWB.DoCommand(ID_EDIT_REPLACE, DC_MNEMONIC);
	if (WaitAttachActive(5000)) {
		return TRUE;
	}
	return FALSE;
}

// BEGIN_HELP_COMMENT
// Function: HWND UIReplaceDlg::Close(void)
// Description: Close the Replace dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
HWND UIReplaceDlg::Close(void)
{
	return UIDialog::Cancel();
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIReplaceDlg::SetFindString(LPCSTR szFind)
// Description: Enter the text given in szFind in the Find What edit box in the Replace dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: szFind A pointer to a string that contains the text to enter in the Find What edit box in the Replace dialog.
// END_HELP_COMMENT
BOOL UIReplaceDlg::SetFindString(LPCSTR szFind)
{
	MST.WComboSetText(GetLabel(VCPP32_ID_REPLACE_WHAT), szFind);
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIReplaceDlg::SetReplaceString(LPCSTR szReplace)
// Description: Enter the text given in szReplace in the Replace With edit box in the Replace dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: szReplace A pointer to a string that contains the text to enter in the Replace With edit box in the Replace dialog.
// END_HELP_COMMENT
BOOL UIReplaceDlg::SetReplaceString(LPCSTR szReplace)
{
	MST.WComboSetText(GetLabel(VCPP32_ID_REPLACE_REPLACEWITH), szReplace);
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIReplaceDlg::SetMatchWord(BOOL bMatchWord)
// Description: Check or uncheck the Match Whole Word Only checkbox based on the value of bMatchWord.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: bMatchWord A Boolean value that, if TRUE means check the Match Whole Word Only checkbox, and if FALSE means uncheck it. (Default value is FALSE.)
// END_HELP_COMMENT
BOOL UIReplaceDlg::SetMatchWord(BOOL bMatchWord /*= FALSE*/)
{
	if (bMatchWord) {
		MST.WCheckCheck(GetLabel(VCPP32_ID_REPLACE_WHOLEWORD));
	}
	else {
		MST.WCheckUnCheck(GetLabel(VCPP32_ID_REPLACE_WHOLEWORD));
	}
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIReplaceDlg::SetMatchCase(BOOL bMatchCase)
// Description: Check or uncheck the Match Case checkbox based on the value of bMatchCase.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: bMatchCase A Boolean value that, if TRUE means check the Match Case checkbox, and if FALSE means uncheck it. (Default value is FALSE.)
// END_HELP_COMMENT
BOOL UIReplaceDlg::SetMatchCase(BOOL bMatchCase /*= FALSE*/)
{
	if (bMatchCase) {
		MST.WCheckCheck(GetLabel(VCPP32_ID_REPLACE_MATCHUPLO));
	}
	else {
		MST.WCheckUnCheck(GetLabel(VCPP32_ID_REPLACE_MATCHUPLO));
	}
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIReplaceDlg::SetRegularExpression(BOOL bRegExpr)
// Description: Check or uncheck the Regular Expression checkbox based on the value of bRegExpr.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: bRegExpr A Boolean value that, if TRUE means check the Regular Expression checkbox, and if FALSE means uncheck it. (Default value is FALSE.)
// END_HELP_COMMENT
BOOL UIReplaceDlg::SetRegularExpression(BOOL bRegExpr)
{
	if (bRegExpr) {
		MST.WCheckCheck(GetLabel(VCPP32_ID_REPLACE_REGEXP));
	}
	else {
		MST.WCheckUnCheck(GetLabel(VCPP32_ID_REPLACE_REGEXP));
	}
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIReplaceDlg::SetReplaceScope(UIReplaceDlg::ReplaceScope rs)
// Description: Set the replace scope in the Replace dialog box.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: fd A value that indicates the scope of the find and replace operation: RS_WHOLEFILE to set the replace scope to the whole file; RS_SELECTION to set the replace scope to the selection. (Default value is RS_WHOLEFILE.)
// END_HELP_COMMENT
BOOL UIReplaceDlg::SetReplaceScope(UIReplaceDlg::ReplaceScope rs)
{
	if (rs == UIReplaceDlg::RS_WHOLEFILE) {
		MST.WOptionClick(GetLabel(VCPP32_IDC_REPLACEMODEWHOLEFILE));
	}
	else {
		if (rs == UIReplaceDlg::RS_SELECTION) {
			MST.WOptionClick(GetLabel(VCPP32_IDC_REPLACEMODESELECTION));
		}
		else {
			ASSERT(0);
			// REVIEW(briancr): we need to set the error type and string here
			return FALSE;
		}
	}
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIReplaceDlg::FindNext(void)
// Description: Perform the find operation by clicking the Find Next button in the Replace dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIReplaceDlg::FindNext(void)
{
	if (!MST.WButtonEnabled(GetLabel(VCPP32_ID_REPLACE_FINDNEXT))) {
		// REVIEW(briancr): we need to set the error type and string here
		return FALSE;
	}
	MST.WButtonClick(GetLabel(VCPP32_ID_REPLACE_FINDNEXT));
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIReplaceDlg::Replace(void)
// Description: Perform the replace operation by clicking the Replace button in the Replace dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIReplaceDlg::Replace(void)
{
	if (!MST.WButtonEnabled(GetLabel(VCPP32_ID_REPLACE_REPLACE))) {
		// REVIEW(briancr): we need to set the error type and string here
		return FALSE;
	}
	MST.WButtonClick(GetLabel(VCPP32_ID_REPLACE_REPLACE));
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIReplaceDlg::ReplaceAll(void)
// Description: Perform the replace all operation by clicking the Replace All button in the Replace dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
int UIReplaceDlg::ReplaceAll(void)
{
	MST.WButtonClick(GetLabel(VCPP32_ID_REPLACE_REPLACEALL));
	CString str = UIWB.GetStatusText();		// X occurance(s) have been replaced
	int n;
	sscanf(str, "%d", &n);
	return n;	// return how many were replaced
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\src\uinsctrl.h ===
///////////////////////////////////////////////////////////////////////////////
//  UINSCTRL.H
//
//  Created by :            Date :
//      MichMa					5/28/97
//
//  Description :
//  	Declaration of the UIInsertCtrlDlg class
//

#ifndef __UINSCTRL_H__
#define __UINSCTRL_H__

#include "..\..\udialog.h"
#include "..\shl\wbutil.h"

#include "export.h"

#ifndef __UIDIALOG_H__
	#error include 'udialog.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
//  UIInsertCtrlDlg class

// BEGIN_CLASS_HELP
// ClassName: UIInsertCtrlDlg
// BaseClass: UIDialog
// Category: Editor
// END_CLASS_HELP
class SRC_CLASS UIInsertCtrlDlg : public UIDialog

	{
// base class overrides
public:
	UIWND_COPY_CTOR(UIInsertCtrlDlg, UIDialog);
	CString ExpectedTitle(void) const {return GetLocString(IDSS_INSERT_CTRL_DLG_TITLE);}
	virtual BOOL Activate(void);

	// Utilities
	public:
		BOOL SetControl(LPCSTR szCtrl);
	};

#endif //__UINSCTRL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\src\uinsctrl.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UINSCTRL.CPP
//
//  Created by :            Date :
//      MichMa					5/28/97
//
//  Description :
//      Implementation of the UIInsertCtrlDlg class
//

#include "stdafx.h"
#include "uinsctrl.h"
#include "mstwrap.h"
#include "guiv1.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: BOOL UIInsertCtrlDlg::Activate(void)
// Description: Open the "Insert ActiveX Control" dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIInsertCtrlDlg::Activate(void)
{

	// TODO(michma): must be localized.
	// how to add this command to cmdarray.cpp?
	MST.DoKeys("%ihx");

	// wait for "Insert ActiveX Control" dlg to show up (which could take
	// a while if there are lots of controls registered).
	if(WaitAttachActive(10000))
		return TRUE;

	return FALSE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIInsertCtrlDlg::SetControl(LPCSTR szCtrl)
// Description: Sets the control in the "Insert ActiveX Control" dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: exp A pointer to a string that contains the control to set in the "Insert ActiveX Control" dialog.
// END_HELP_COMMENT
BOOL UIInsertCtrlDlg::SetControl(LPCSTR szCtrl)

{
	
	// make sure the dlg is active.
	if(!IsActive()) 
	{
			LOG->RecordInfo("ERROR! UIInsertCtrlDlg::SetControl - %s dlg is not active.", ExpectedTitle());
	 		return FALSE;
	}

	// make sure the list of controls is enabled.
	if(!MST.WListEnabled("@1")) 
	{
			LOG->RecordInfo("ERROR! UIInsertCtrlDlg::SetControl - control list is not enabled.");
	 		return FALSE;
	}

	// make sure the list of controls exists.
	if(!MST.WListExists("@1")) 
	{
			LOG->RecordInfo("ERROR! UIInsertCtrlDlg::SetControl - control list does not exist.");
	 		return FALSE;
	}

	// make sure the list of controls is enabled.
	if(!MST.WListEnabled("@1")) 
	{
			LOG->RecordInfo("ERROR! UIInsertCtrlDlg::SetControl - control list is not enabled.");
	 		return FALSE;
	}

	// select the control.
	// TODO(michma): because the ide stores the guid for the controls in the listbox,
	// even though they don't get displayed, ms-test cannot seem to verify they exist.
	// so we just type out the name which scrolls the listbox to the appropriate item.
	// we need some better verification for this though.
	MST.DoKeys(szCtrl);	

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\sym\auto1.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by aut1.rc
//
#define AUTO1_IDCT_AUTOMATION1PACKAGE         7040
#define AUTO1_IDD_AUTOMATION1_CUSTOMIZE       7040
#define AUTO1_IDD_AUTOMATION1_OPTIONS         7041
#define AUTO1_IDD_COMMANDS_CUSTOMIZE          7041
#define AUTO1_IDDP_AUTOMATION1_PROP_GENERAL   7042
#define AUTO1_IDB_AUTOMATION1_PANEGLYPH       7043
#define AUTO1_IDB_AUTOMATION1_TOOLS           7044
#define AUTO1_IDB_AUTOMATION1_WELL            7045
#define AUTO1_IDI_AUTOMATION1_DOCK            7046
#define AUTO1_IDC_AUTOMATION1_TITLENAME       7047
#define AUTO1_IDR_AUTOMATION1_ACCEL           7048
#define AUTO1_IDS_AUTOMATION1                 7049
#define AUTO1_IDS_AUTOMATION1_PROP_GENERAL    7050
#define AUTO1_IDS_AUTO_BADCOOKIE              7051
#define AUTO1_IDS_AUTOMATION1_DOC             7052
#define AUTO1_IDS_AUTOMATION1_PRODUCT_ID      7053
#define AUTO1_IDS_NO_DESCRIPTION              7053
#define AUTO1_IDS_AUTOMATION1_GOTOITEM        7054
#define AUTO1_IDS_MACRO_ERROR                 7054
#define AUTO1_IDS_AUTOMATION1_GOTOITEM_PROMPT 7055
#define AUTO1_IDS_MACRO_ERROR_FORMAT          7055
#define AUTO1_IDS_AUTOMATION1_GOTOITEM_HELP   7056
#define AUTO1_IDS_AUTO_BADCMDISP              7056
#define AUTO1_IDS_AUTOMATION1_FILTER          7057
#define AUTO1_IDS_REGISTER_ADDIN              7057
#define AUTO1_IDD_ADDINS                      7058
#define AUTO1_IDC_ADDINS                      7058
#define AUTO1_IDD_MACRO                       7058
#define AUTO1_IDC_MACROS                      7058
#define AUTO1_IDS_CANT_LOADLIB                7058
#define AUTO1_IDC_TYPE                        7059
#define AUTO1_IDC_MACROFILE                   7059
#define AUTO1_IDS_NO_DLLREGSRV                7059
#define AUTO1_IDD_INPUT                       7059
#define AUTO1_IDB_STATES                      7060
#define AUTO1_IDS_DLLREGSRV_ERRS              7060
#define AUTO1_IDC_DESCRIPTION                 7061
#define AUTO1_IDB_TYPES                       7061
#define AUTO1_IDS_NO_PROGID                   7061
#define AUTO1_IDC_CUSTOMIZE_DESCRIPTION       7061
#define AUTO1_IDC_LIST                        7062
#define AUTO1_IDS_CANT_CREATE_ADDIN           7062
#define AUTO1_IDB_AUTOMATION1_LARGETOOLS      7063
#define AUTO1_IDS_ONCONNECTION_FAILED         7063
#define AUTO1_IDC_BROWSE                      7064
#define AUTO1_IDS_BROWSE_ADDIN                7064
#define AUTO1_IDS_BROWSEDLG_TITLE             7064
#define AUTO1_IDB_ADDINDEF_LARGETOOLS         7064
#define AUTO1_IDS_FILTER_ADDINS               7065
#define AUTO1_IDB_ADDINDEF_TOOLS              7065
#define AUTO1_IDS_FILTER_MACROFILES           7066
#define AUTO1_IDC_NEW_FILE                    7066
#define AUTO1_IDC_CURSOR_RECORD               7066
#define AUTO1_IDS_ADDIN_ALREADY_REGISTERED    7067
#define AUTO1_IDC_NAME                        7067
#define AUTO1_IDS_STALE_ADDIN_ENTRY           7068
#define AUTO1_IDC_RECORD                      7068
#define AUTO1_IDD_TERMINATE                   7068
#define AUTO1_IDC_EDIT                        7069
#define AUTO1_IDS_RECORD                      7069
#define AUTO1_IDS_RECORD_BUTTON               7070
#define AUTO1_IDS_STOP_RECORD_BUTTON          7071
#define AUTO1_IDC_MOREPANE                    7071
#define AUTO1_IDC_MORE                        7072
#define AUTO1_IDC_TERMINATE                   7072
#define AUTO1_IDS_COMMANDS                    7073
#define AUTO1_IDC_NEVERRELOAD                 7073
#define AUTO1_IDS_REC_CANT_MAKE_TEMP          7074
#define AUTO1_IDC_ALWAYSRELOAD                7074
#define AUTO1_IDS_REC_CANT_WRITE_TEMP         7075
#define AUTO1_IDC_ALWAYSASK                   7075
#define AUTO1_IDS_FILTER_SOURCE               7076
#define AUTO1_IDC_ADDINSANDMACROFILES         7076
#define AUTO1_IDS_DEF_VBS                     7077
#define AUTO1_IDC_COMMANDS                    7077
#define AUTO1_IDS_MACRO_ERROR_FORMAT_EDIT     7078
#define AUTO1_IDC_KEYBOARD                    7078
#define AUTO1_IDC_INPUT_DESCRIPTION           7078
#define AUTO1_IDS_MACRO_QUERY_RELOAD_FORMAT   7079
#define AUTO1_IDS_MACRO_QUERY_RELOAD          7079
#define AUTO1_IDC_MACRO_DESCRIPTION           7079
#define AUTO1_IDS_DUPLICATE_COMMAND_FORMAT    7080
#define AUTO1_IDS_UNREGISTER_FORMAT           7081
#define AUTO1_IDS_MACRO_FILE_PROMPT           7082
#define AUTO1_IDS_MACRO_PROMPT                7083
#define AUTO1_IDP_OLD_CMDBAR_VERSION          7085
#define AUTO1_IDS_STALE_CMDBAR_MACRO          7086
#define AUTO1_IDS_STALE_CMDBAR_ADDIN          7087
#define AUTO1_IDS_INVALID_MACRO_NAME          7088
#define AUTO1_IDS_MACRO_NOT_FOUND             7089
#define AUTO1_IDS_INVALID_MACRO_FILE_NAME     7090
#define AUTO1_IDS_MORE                        7091
#define AUTO1_IDS_LESS                        7092
#define AUTO1_IDS_DEFAULT_DESCRIPTION         7093
#define AUTO1_IDS_OVERWRITE_MACRO_FILE        7094
#define AUTO1_IDS_INVALID_MACRO_FILE          7095
#define AUTO1_IDS_MACRO_ALREADY_LOADED        7096
#define AUTO1_IDS_ADD_MACRO                   7097
#define AUTO1_IDS_RELOAD_MACROS               7098
#define AUTO1_IDS_NO_UNDERSCORE_IN_MACRO      7099
#define AUTO1_IDS_RESERVED_NAME               7100
#define AUTO1_IDR_VBS                         7101
#define AUTO1_ID_RUN                          57671

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        7070
#define _APS_NEXT_COMMAND_VALUE         7058
#define _APS_NEXT_CONTROL_VALUE         7080
#define _APS_NEXT_SYMED_VALUE           7058
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\sym\awx.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by extwiz.rc
//
#define IDP_BAD_PROJDIR                 1
#define IDP_ZAP_CANT_OPEN_FILE          2
#define IDP_ZAP_CANT_GET_SIZE           3
#define IDP_ZAP_NOT_TEXT                4
#define IDC_PROJ_NAME                   100
#define IDD_PAGE1                       129
#define IDD_ZAP                         129
#define IDD_PAGE2                       130
#define IDD_AWX_TYPE                    130
#define IDD_APWZ_TYPE                   148
#define IDD_APWZ_SEQUENCE               148
#define IDB_APWZSRC                     161
#define IDB_DEST                        162
#define IDB_WAND                        163
#define IDB_YELLOW_PATTERN              164
#define IDB_PROJSRC                     165
#define IDB_CUSTOMSRC                   166
#define IDB_ZAP                         167
#define IDB_BOTTOMEXE                   168
#define IDB_SEQTOP                      169
#define IDB_BOTTOMDLL                   170
#define IDC_BUTTON1                     1000
#define IDC_BROWSE                      1000
#define IDC_YELLOW                      1000
#define IDC_BUTTON2                     1001
#define IDC_BUTTON3                     1002
#define IDC_BUTTON4                     1003
#define IDC_SCROLLBAR1                  1004
#define IDC_RADIO1                      1005
#define IDC_APWZ_SEQ                    1005
#define IDC_RADIO2                      1006
#define IDC_APWZ_SEQ2                   1006
#define IDC_SCROLLBAR2                  1007
#define IDC_CHECK2                      1009
#define IDC_CHECK3                      1010
#define IDC_CHECK4                      1011
#define IDC_CHECK5                      1012
#define IDC_CHECK6                      1013
#define IDC_CHECK7                      1014
#define IDC_RADIO3                      1016
#define IDC_SEQUENCE                    1016
#define IDC_EDIT1                       1019
#define IDC_PAGES                       1019
#define IDC_CUSTOM                      1022
#define IDC_ZAP                         1023
#define IDC_STC_PAGES                   1024
#define IDC_LANGS                       1025
#define IDC_LIST1                       1025

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        171
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1026
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\sym\appwz.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mfcappwz.rc
//
#define APPWZ_PO_PROJ_COUNT                   2
#define APPWZ_OTHER_VIEWS_COUNT               3
#define APPWZ_IDC_DONE                        3
#define APPWZ_IDCANCEL2                       3
#define APPWZ_PODLG_OPTION_COUNT              4
#define APPWZ_DEFAULT_VIEWS_COUNT             6
#define APPWZ_PO_OPTION_COUNT                 7
#define APPWZ_PO_TOTAL_COUNT                  8
#define APPWZ_OPTION_COUNT                    8
#define APPWZ_IDC_PROJ_SUBDIR                 22
#define APPWZ_IDCD_BASE                       64
#define APPWZ_IDCD_MDI                        64
#define APPWZ_IDCD_TOOLBAR                    65
#define APPWZ_IDCD_PRINT                      66
#define APPWZ_IDCD_HELP                       67
#define APPWZ_IDCD_DB                         68
#define APPWZ_IDCD_EXTMAK                     69
#define APPWZ_IDCD_VERBOSE                    70
#define APPWZ_IDCD_VBX                        80
#define APPWZ_IDC_CLASS_LIST                  100
#define APPWZ_IDC_CLASS_NAME                  101
#define APPWZ_IDC_BASE_CLASS                  102
#define APPWZ_IDC_HFILE                       103
#define APPWZ_IDC_IFILE                       104
#define APPWZ_IDC_BUILD_INFO                  105
#define APPWZ_IDC_MFCICON                     106
#define APPWZ_IDC_REG_ID                      106
#define APPWZ_IDC_REG_NAME                    107
#define APPWZ_IDC_FILE_NEW                    108
#define APPWZ_IDC_FILTER                      109
#define APPWZ_IDC_DOCFIELD_FIRST              200
#define APPWZ_IDC_DOC_EXT                     200
#define APPWZ_IDC_DOC_TYPE                    201
#define APPWZ_IDC_DOC_LABEL1                  202
#define APPWZ_IDC_DOC_LABEL2                  203
#define APPWZ_IDC_DOCFIELD_LAST               203
#define APPWZ_IDC_DOC_LABEL3                  204
#define APPWZ_IDC_DOC_LABEL4                  205
#define APPWZ_IDC_DOC_LABEL6                  207
#define APPWZ_IDC_DOC_LABEL7                  208
#define APPWZ_IDC_OUTPUT                      300
#define APPWZ_IDC_CONFIRM_DIR                 301
#define APPWZ_IDC_OUTFILE                     301
#define APPWZ_IDC_OUTPROJ                     302
#define APPWZ_IDC_BASE_CLASS_COMBO            402
#define APPWZ_OLEBASE                         414
#define APPWZ_IDC_CONTAINER                   414
#define APPWZ_IDC_MSERVER                     415
#define APPWZ_IDC_FSERVER                     416
#define APPWZ_IDC_CSERVER                     417
#define APPWZ_OLELAST                         417
#define APPWZ_IDC_USE_DLL                     418
#define APPWZ_IDC_LARGE                       420
#define APPWZ_IDC_NO_INPLACE                  422
#define APPWZ_IDC_DATA_SOURCE                 424
#define APPWZ_IDC_OLEBOX                      425
#define APPWZ_IDC_DB_RADIO                    430
#define APPWZ_IDC_DB_HEADER                   431
#define APPWZ_IDC_DB_SIMPLE                   432
#define APPWZ_IDC_PROJTYPE                    433
#define APPWZ_IDC_DB_DOCVIEW                  433
#define APPWZ_IDC_RADIO2                      434
#define APPWZ_IDC_RADIO3                      435
#define APPWZ_IDC_DOCSTREECTL                 436
#define APPWZ_IDC_NEWDOC                      437
#define APPWZ_IDC_NEWVIEW                     438
#define APPWZ_IDC_BEGINNING                   439
#define APPWZ_IDC_END                         440
#define APPWZ_IDC_BACK                        441
#define APPWZ_IDC_NEXT                        442
#define APPWZ_IDC_PONOTDLL                    443
#define APPWZ_IDCD_PONOTDLL                   443
#define APPWZ_IDCD_POBASE                     444
#define APPWZ_IDCD_POMAPI                     444
#define APPWZ_IDCD_PICBASE                    445
#define APPWZ_IDCD_POTOOLBAR                  445
#define APPWZ_IDCD_POSTATUSBAR                446
#define APPWZ_IDCD_POPRINT                    447
#define APPWZ_IDCD_PODLGBASE                  448
#define APPWZ_IDCD_POHELP                     448
#define APPWZ_IDC_PTCOMBO                     448
#define APPWZ_IDCD_POPROJBASE                 449
#define APPWZ_IDCD_POSOCKETS                  449
#define APPWZ_IDCD_POVERBOSE                  449
#define APPWZ_IDCD_PO3D                       450
#define APPWZ_IDCD_PODLL                      450
#define APPWZ_IDCD_POABOUT                    451
#define APPWZ_IDC_PTSTATIC                    465
#define APPWZ_IDC_RADIO1                      469
#define APPWZ_IDC_PTRADIO                     469
#define APPWZ_IDC_AUTOMATION_RADIO2           469
#define APPWZ_IDC_PTMDI                       470
#define APPWZ_IDC_STATIC_HEADER               470
#define APPWZ_IDC_COMPFILE_RADIO2             470
#define APPWZ_IDC_PTDLG                       471
#define APPWZ_IDC_STATIC_IMP                  471
#define APPWZ_IDC_PTMODULES                   472
#define APPWZ_IDC_AUTOMATION_RADIO            474
#define APPWZ_IDCD_AUTOMATION                 474
#define APPWZ_IDC_DATASOURCE_TEXT             475
#define APPWZ_IDC_COMPFILE_RADIO              475
#define APPWZ_IDC_BOGUS_DEFBTN                476
#define APPWZ_IDC_BASE_STATIC                 477
#define APPWZ_IDC_APP_TITLE                   478
#define APPWZ_IDC_RSC_LANG                    479
#define APPWZ_IDC_FRAME_STYLES                481
#define APPWZ_IDC_DOC_STRINGS                 482
#define APPWZ_FRAME_STYLES_START              484
#define APPWZ_IDC_THICKFRAME                  484
#define APPWZ_IDC_SYSMENU                     485
#define APPWZ_IDC_MINIMIZEBOX                 486
#define APPWZ_IDC_MINIMIZE                    487
#define APPWZ_IDC_MAXIMIZEBOX                 488
#define APPWZ_IDC_MAXIMIZE                    489
#define APPWZ_FRAME_STYLES_END                489
#define APPWZ_CHILD_FRAME_STYLES_START        490
#define APPWZ_IDC_CHILD_THICKFRAME            490
#define APPWZ_IDC_CHILD_MINIMIZEBOX           491
#define APPWZ_IDC_CHILD_MINIMIZE              492
#define APPWZ_IDC_CHILD_MAXIMIZEBOX           493
#define APPWZ_IDC_CHILD_MAXIMIZE              494
#define APPWZ_CHILD_FRAME_STYLES_END          494
#define APPWZ_IDC_CHILD_SPLITTER              496
#define APPWZ_IDC_EDIT2                       497
#define APPWZ_IDC_EDIT3                       498
#define APPWZ_IDC_EDIT4                       499
#define APPWZ_IDC_ADVANCED                    501
#define APPWZ_IDC_DOC_CREATOR                 502
#define APPWZ_IDC_MAIN_SPLITTER               508
#define APPWZ_IDC_PLATFORMS_LIST              509
#define APPWZ_IDC_BUTTON1                     510
#define APPWZ_IDC_BROWSE                      510
#define APPWZ_IDC_PROJ_NAME2                  511
#define APPWZ_IDC_PROJ_DIR                    512
#define APPWZ_IDC_DIRECTORY_LABEL             513
#define APPWZ_IDC_SUBIDR_STATIC               514
#define APPWZ_IDC_FILE_TYPE                   515
#define APPWZ_IDC_STATIC1                     516
#define APPWZ_IDC_STATIC2                     517
#define APPWZ_IDC_MESSAGE_TEXT                518
#define APPWZ_IDC_MODULES_COMBO               519
#define APPWZ_IDC_MODULES_STATIC              520
#define APPWZ_IDC_WOSA_BOX                    521
#define APPWZ_IDC_LANG_COMBO                  522
#define APPWZ_IDC_WOSA_STATIC                 522
#define APPWZ_IDC_CHILD_STATIC                524
#define APPWZ_IDCD_SOCKETS                    524
#define APPWZ_IDC_WOSA_QUESTION               525
#define APPWZ_IDC_STATIC3                     525
#define APPWZ_IDC_STATIC_CREATION             526
#define APPWZ_IDC_SPIN1                       528
#define APPWZ_IDC_SPINMRU                     528
#define APPWZ_IDC_CHECK1                      529
#define APPWZ_IDCD_OCX                        530
#define APPWZ_IDC_OCX_STATIC                  531
#define APPWZ_IDC_NOMACDAO                    532
#define APPWZ_IDC_DLLTYPE                     533
#define APPWZ_IDC_SUBDIR_STATIC               1000
#define APPWZ_IDC_POSTATUSBAR                 1000
#define APPWZ_IDC_EDIT1                       1001
#define APPWZ_IDC_MRU                         1001
#define APPWZ_IDC_SOURCES                     1008
#define APPWZ_IDC_SOURCE                      1017
#define APPWZ_IDC_BIGICON                     2030
#define APPWZ_IDC_LICENSEE_NAME               2031
#define APPWZ_IDC_LICENSEE_COMPANY            2032
#define APPWZ_IDC_AVAIL_MEM                   2034
#define APPWZ_IDC_MATH_COPR                   2037
#define APPWZ_IDC_DISK_SPACE                  2040
#define APPWZ_IDR_AFXLOGO                     17000
#define APPWZ_IDB_FOLDERS                     17001
#define APPWZ_IDB_EXPANDNODES                 17002
#define APPWZ_IDB_YELLOW_PATTERN              17003
#define APPWZ_IDB_B2200                       17004
#define APPWZ_IDB_B11001                      17004
#define APPWZ_IDB_B11010                      17005
#define APPWZ_IDB_B11100                      17006
#define APPWZ_IDB_B120001                     17007
#define APPWZ_IDB_B120010                     17008
#define APPWZ_IDB_B120100                     17009
#define APPWZ_IDB_B121000                     17010
#define APPWZ_IDB_B130001                     17011
#define APPWZ_IDB_B130010                     17012
#define APPWZ_IDB_B130100                     17013
#define APPWZ_IDB_B131000                     17014
#define APPWZ_IDB_B13NONE                     17015
#define APPWZ_IDB_B140000                     17016
#define APPWZ_IDB_B140001                     17017
#define APPWZ_IDB_B140010                     17018
#define APPWZ_IDB_B140011                     17019
#define APPWZ_IDB_B140100                     17020
#define APPWZ_IDB_B141101                     17021
#define APPWZ_IDB_B141110                     17022
#define APPWZ_IDB_B141111                     17023
#define APPWZ_IDB_B2201                       17024
#define APPWZ_IDB_B2210                       17025
#define APPWZ_IDB_B2211                       17026
#define APPWZ_IDB_B140101                     17027
#define APPWZ_IDB_B140110                     17028
#define APPWZ_IDB_B140111                     17029
#define APPWZ_IDB_B141000                     17030
#define APPWZ_IDB_B141001                     17031
#define APPWZ_IDB_B141010                     17032
#define APPWZ_IDB_B141011                     17033
#define APPWZ_IDB_B141100                     17034
#define APPWZ_IDB_B150101                     17035
#define APPWZ_IDB_B150110                     17036
#define APPWZ_IDB_B151001                     17037
#define APPWZ_IDB_B151010                     17038
#define APPWZ_IDB_B143DNO                     17039
#define APPWZ_IDB_B143DON                     17040
#define APPWZ_IDB_FLAG                        17041
#define APPWZ_IDB_B110001                     17042
#define APPWZ_IDB_SCROLL                      17043
#define APPWZ_IDB_SCROLL_L                    17044
#define APPWZ_IDB_SCROLL_R                    17045
#define APPWZ_IDB_SCROLL_RD                   17046
#define APPWZ_IDB_SCROLL_LD                   17047
#define APPWZ_IDD_PROGRESS                    17050
#define APPWZ_IDD_DB_OPTIONS                  17051
#define APPWZ_IDD_PROJTYPE                    17052
#define APPWZ_IDD_MAINDLG                     17053
#define APPWZ_IDD_OLE_OPTIONS                 17054
#define APPWZ_IDD_DOCSTRINGS                  17055
#define APPWZ_IDD_FRAME_STYLES                17056
#define APPWZ_IDD_CHILD_FRAME_STYLES          17057
#define APPWZ_IDD_MAC                         17058
#define APPWZ_IDD_NEWAPP                      17060
#define APPWZ_IDD_NAMES                       17061
#define APPWZ_IDD_CONFIRM                     17062
#define APPWZ_IDD_NOHELPFILE                  17064
#define APPWZ_IDD_DLGAPP_OPTIONS              17065
#define APPWZ_IDD_DOCAPP_OPTIONS              17066
#define APPWZ_IDD_PROJ_OPTIONS                17067
#define APPWZ_IDD_PROJOPTIONS_ALT             17068
#define APPWZ_IDD_NAMES_ALT                   17078
#define APPWZ_IDD_OBSOLETE2                   17079
#define APPWZ_IDD_OBSOLETE                    17080
#define APPWZ_IDD_NEWAPP2                     17081
#define APPWZ_IDD_DLLPROJ_OPTIONS             17081
#define APPWZ_IDS_LNCOLPRMPT                  17082
#define APPWZ_IDS_GETTING_SOURCES             17083
#define APPWZ_IDS_GETTING_COLS                17084
#define APPWZ_IDS_GETTING_SOURCES2            17085
#define APPWZ_IDS_ERR_COCREATEGUID_FAILED     17086
#define APPWZ_IDS_ERR_NOTABLES                17087
#define APPWZ_IDS_ERR_DBOPEN_FAILED           17088
#define APPWZ_IDS_SELECT_TABLE                17089
#define APPWZ_IDS_NEED_OLE_201                17090
#define APPWZ_IDS_AVAIL_MEM                   17091
#define APPWZ_IDS_MATH_COPR_PRESENT           17092
#define APPWZ_IDS_MATH_COPR_NOTPRESENT        17093
#define APPWZ_IDS_DISK_SPACE                  17094
#define APPWZ_IDP_GENERAL_BAGOUT              17095
#define APPWZ_IDP_FILE_EXISTS                 17095
#define APPWZ_IDP_FILE_IS_DIRECT              17095
#define APPWZ_IDP_GENERAL_ERROR               17096
#define APPWZ_IDP_DIRECT_CHANGE               17097
#define APPWZ_IDP_DIRECT_CREATE               17098
#define APPWZ_IDP_FILE_CREATE                 17099
#define APPWZ_IDP_FILE_WRITE                  17100
#define APPWZ_IDP_CURDIR_GONE                 17101
#define APPWZ_IDP_PROJFILE_EXISTS             17102
#define APPWZ_IDP_RESERVED_CLASS              17103
#define APPWZ_IDP_DUPLICATE_CLASS             17104
#define APPWZ_IDP_DUPLICATE_FILE              17105
#define APPWZ_IDP_INVALID_PROJ                17106
#define APPWZ_IDP_INVALID_SUBDIR              17107
#define APPWZ_IDP_INVALID_SYMBOL              17108
#define APPWZ_IDP_INVALID_FILENAME            17109
#define APPWZ_IDP_INVALID_EXTENSION           17110
#define APPWZ_IDP_GUID_ERROR                  17111
#define APPWZ_IDP_GUID_REGISTERED             17112
#define APPWZ_IDP_GENERAL_BAGOUT2             17113
#define APPWZ_IDP_OVERWRITE_FILE              17114
#define APPWZ_IDP_FILE_IS_READONLY            17115
#define APPWZ_IDP_CANT_DELETE_FILE            17116
#define APPWZ_IDS_DATASOURCE_TEXT             17117
#define APPWZ_IDS_NODATASOURCE_TEXT           17118
#define APPWZ_IDP_DIRECT_IS_FILE              17119
#define APPWZ_IDP_FILE_INTERFERE_DEFAULTS     17120
#define APPWZ_IDP_NO_PERMISSION               17121
#define APPWZ_IDP_SUBDIR_ERROR                17122
#define APPWZ_IDP_BAD_TITLE                   17123
#define APPWZ_IDP_ERROR_LOAD_DLL              17124
#define APPWZ_IDP_INVALID_PROGID              17125
#define APPWZ_IDS_ADVANCED                    17126
#define APPWZ_IDS_FRAME_STYLES                17127
#define APPWZ_IDS_DOC_STRINGS                 17128
#define APPWZ_IDS_CHILD_FRAME_STYLES          17129
#define APPWZ_IDS_MAC                         17130
#define APPWZ_IDP_EXACT_CHARS                 17131
#define APPWZ_IDP_BAD_LANG_DLL                17132
#define APPWZ_IDP_RESCAN_LANGDLL              17133
#define APPWZ_IDP_OLE_THEN_SIMPLE             17134
#define APPWZ_IDP_SIMPLE_THEN_OLE             17135
#define APPWZ_IDP_EDITVIEW_THEN_OLE           17136
#define APPWZ_IDP_DB_NO_DATA_SOURCE           17137
#define APPWZ_IDP_SIMPLE_THEN_MDI             17138
#define APPWZ_IDP_MSERVER_THEN_MDI            17139
#define APPWZ_IDS_HELP_DEFAULTDIR             17140
#define APPWZ_IDS_ERROR_HELP_NOFILE           17141
#define APPWZ_IDS_DISK_SPACE_UNAVAIL          17142
#define APPWZ_IDS_SELECT_PLATFORM             17143
#define APPWZ_IDS_APPWIZ_EXE                  17144
#define APPWZ_IDS_APPWIZ_DLL                  17145
#define APPWZ_IDS_CREATE_DOTS                 17146
#define APPWZ_IDS_CREATE_NODOTS               17147
#define APPWZ_IDS_HEADERF_ACC                 17148
#define APPWZ_IDS_HEADERF_NOACC               17149
#define APPWZ_IDS_IMPLF_ACC                   17150
#define APPWZ_IDS_IMPLF_NOACC                 17151
#define APPWZ_IDS_BASEC_ACC                   17152
#define APPWZ_IDS_BASEC_NOACC                 17153
#define APPWZ_IDS_ENGLISH                     17154
#define APPWZ_IDS_UNKNOWN                     17155
#define APPWZ_IDS_TITLE_MAXSTEP               17156
#define APPWZ_IDS_TITLE_NOMAXSTEP             17157
#define APPWZ_IDP_EDITVIEW_THEN_SPLITTER      17158
#define APPWZ_IDS_FILE_IS_DIRECT              17159
#define APPWZ_IDP_NO_MAC_MFCDLL               17160
#define APPWZ_IDP_DB_GENERAL_ERROR            17161
#define APPWZ_IDS_FILES                       17162
#define APPWZ_IDP_SPACE_IN_PATH               17163
#define APPWZ_IDS_NO_ODBC                     17164
#define APPWZ_IDP_PATH_TOO_LONG               17165
#define APPWZ_IDS_NO_MACODBC                  17166
#define APPWZ_IDS_NO_MACOLE                   17167
#define APPWZ_IDS_NO_OLE                      17168
#define APPWZ_IDS_CG_IF_TOO_DEEP              17169
#define APPWZ_IDS_CG_BAD_IF                   17170
#define APPWZ_IDS_CG_BAD_ELIF                 17171
#define APPWZ_IDS_CG_BAD_ELSE                 17172
#define APPWZ_IDS_CG_BAD_ENDIF                17173
#define APPWZ_IDS_CG_MISSING_DLR              17174
#define APPWZ_IDS_CG_UNDEFINED_SYMBOL         17175
#define APPWZ_IDS_CG_MISSING_DATA_RSC         17176
#define APPWZ_IDS_CG_ERROR_LOADING            17177
#define APPWZ_IDS_CG_MISSING_EOL              17178
#define APPWZ_IDS_CG_BAD_ITEM                 17179
#define APPWZ_IDP_CANT_LOAD_MODULE            17179
#define APPWZ_IDS_CG_STRAY_NULL               17180
#define APPWZ_IDP_EXTENSION_NO_EXPORT         17181
#define APPWZ_IDP_FILE_INTERFERE_DEFAULTS_OCX 17181
#define APPWZ_IDP_GETEXTCLS_RETURNS_NULL      17182
#define APPWZ_IDP_SETAWX_WITH_NULL            17182
#define APPWZ_IDP_CANT_LOAD_EXTENSION         17183
#define APPWZ_IDP_CANT_LOAD_LOC_TPL           17184
#define APPWZ_IDS_CG_CANT_LOAD_TPL            17184
#define APPWZ_IDP_NULL_TEMPLATE               17185
#define APPWZ_IDS_CG_LOOP_IN_LOOP             17186
#define APPWZ_IDS_CG_BAD_BEGINLOOP            17187
#define APPWZ_IDS_CG_UNDEF_IN_BEGINLOOP       17188
#define APPWZ_IDS_CG_BAD_ITERATIONS           17189
#define APPWZ_IDS_CG_EOF_IN_LOOP              17190
#define APPWZ_IDS_CG_NO_ENDIF                 17191
#define APPWZ_IDS_CG_EL_NO_BL                 17192
#define APPWZ_IDS_CG_BAD_WL_ITEM              17193
#define APPWZ_IDP_BAD_0STEP_AWX               17194
#define APPWZ_IDP_EXTENSION_ERROR             17195
#define APPWZ_IDS_CG_0SIZE_RSC                17196
#define APPWZ_IDS_CG_CANT_FIND_TPL            17197
#define APPWZ_IDS_CG_BAD_RSC                  17198
#define APPWZ_IDS_GETDLG_BAD_RANGE            17199
#define APPWZ_IDS_CG_BAD_INCLUDE              17200
#define APPWZ_IDS_CG_UNDEF_IN_INCLUDE         17201
#define APPWZ_IDP_SIMPLE_THEN_MAPI            17202
#define APPWZ_IDP_MAPI_THEN_SIMPLE            17203
#define APPWZ_IDS_APPWIZ_TITLE                17204
#define APPWZ_IDS_CG_NO_NEWPROJ_INF           17205
#define APPWZ_IDS_CG_BAD_SETDEFLANG           17206
#define APPWZ_IDS_CG_UNDEF_IN_SETDEFLANG      17207
#define APPWZ_IDS_CG_BADLANG_IN_SETDEFLANG    17208
#define APPWZ_IDP_AWX_CALLED_BAD_CONSTRUCTOR  17209
#define APPWZ_IDP_AWX_CALLED_BAD_DESCRUCTOR   17210
#define APPWZ_IDS_BACK                        17211
#define APPWZ_IDP_EXT_NOT_CALL_SETAWX         17212
#define APPWZ_IDP_FILE_WILL_EXIST             17213
#define APPWZ_IDS_CG_RECURSIVE_INCLUDE        17214
#define APPWZ_IDS_APPWIZ_OCX                  17215
#define APPWZ_IDS_CTLWIZ_TITLE                17215
#define APPWZ_IDP_DUPLICATE_FILEGEN           17216
#define APPWZ_IDS_CREATION                    17217
#define APPWZ_IDS_APPWIZ_TITLE_CREATION       17218
#define APPWZ_IDS_PSEUDO_DEBUG                17219
#define APPWZ_IDS_UNICODE                     17220
#define APPWZ_IDS_COPY_LIC                    17221
#define APPWZ_IDS_COPY_AWX                    17222
#define APPWZ_IDS_MAKEHELP                    17223
#define APPWZ_IDS_NO_MACOCX                   17224
#define APPWZ_IDS_REGISTER_CONTROL            17225
#define APPWZ_IDP_NOOLE_THEN_RICHEDIT         17226
#define APPWZ_IDP_RICHEDIT_THEN_NOOLE         17227
#define APPWZ_IDC_HELPPATH1                   20647
#define APPWZ_IDC_HELPPATH2                   20648
#define APPWZ_IDC_ERRORTEXT                   20649
#define APPWZ_IDC_INFO_ICON                   20656
#define APPWZ_IDC_OPTIONS                     0x8001
#define APPWZ_IDC_NAMES                       0x8002
#define APPWZ_ID_INIT_SOURCES                 0x8009

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define APPWZ__APS_3D_CONTROLS                     1
#define APPWZ__APS_NEXT_RESOURCE_VALUE        17215
#define APPWZ__APS_NEXT_COMMAND_VALUE         40001
#define APPWZ__APS_NEXT_CONTROL_VALUE         534
#define APPWZ__APS_NEXT_SYMED_VALUE           109
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\sym\ctrlwz.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by mfcctlwz.rc
//
#define IDS_CTLNAMEPROMPT               1
#define IDS_YOURCONTROL                 2
#define IDS_CTLNUMBER                   3
#define IDS_CTLNAME                     4
#define IDS_CONTROL                     5
#define IDS_CONTROLS                    6
#define IDS_INVALID_FILENAME            50
#define IDS_INVALID_EXTENSION           51
#define IDS_DUPLICATE_FILENAME          52
#define IDS_INVALID_CLASS               53
#define IDS_DUPLICATE_CLASSNAME         54
#define IDS_DUPLICATE_CONTROLNAME       55
#define IDS_INVALID_SYMBOL              102
#define IDD_SUMMARYINFO                 118
#define IDD_CUSTOM1                     129
#define IDD_HOWMANY                     129
#define IDD_CUSTOM2                     130
#define IDD_PROJOPTIONS                 130
#define IDD_CUSTOM3                     131
#define IDD_NAMES                       131
#define IDD_CUSTOM4                     132
#define IDD_CTLOPTIONS                  132
#define IDD_NAMES1                      133
#define IDD_CTLOPTIONS2                 133
#define IDD_SUMMARYINFOOLD              500
#define IDC_NUMCONTROLS                 1000
#define IDC_ACTIVATEWHENVISIBLE         1000
#define IDC_LICENSE                     1001
#define IDC_INVISIBLEATRUNTIME          1001
#define IDC_NOLICENSE                   1002
#define IDC_INSERTABLE                  1002
#define IDC_CTLNAME                     1003
#define IDC_CTLNAMEPROMPT               1004
#define IDC_ABOUTBOX                    1004
#define IDC_COMMENTS                    1005
#define IDC_EDIT2                       1005
#define IDC_NOCOMMENTS                  1006
#define IDC_EDIT3                       1006
#define IDC_HELPFILES                   1007
#define IDC_EDIT4                       1007
#define IDC_NOHELPFILES                 1008
#define IDC_EDIT5                       1008
#define IDC_EDIT6                       1009
#define IDC_SUBCLASS                    1009
#define IDC_EDIT7                       1010
#define IDC_NOSUBCLASS                  1010
#define IDC_COMBO1                      1011
#define IDC_BASECLASS                   1011
#define IDC_BASECLASSPROMPT             1012
#define IDC_SIMPLEFRAME                 1013
#define IDC_COMBO2                      1014
#define IDC_CTLCOMBO                    1014
#define IDC_SUMMARY                     1015
#define IDC_NAMES                       1015
#define IDC_SPIN1                       1017
#define FIRST_NAME_FIELD                1020
#define IDC_CTLCLASS                    1020
#define IDC_CTLHFILE                    1021
#define IDC_CTLIFILE                    1022
#define IDC_CTLTYPENAME                 1023
#define IDC_CTLPROGID                   1024
#define IDC_PPGCLASS                    1025
#define IDC_PPGHFILE                    1026
#define IDC_PPGIFILE                    1027
#define IDC_PPGTYPENAME                 1028
#define IDC_PPGPROGID                   1029
#define IDP_INVALID_PROGID              4126
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\sym\clswiz.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mfcclswz.rc
//
#define CLSWIZ_IDC_RETURN_TYPE_STATIC          1087
#define CLSWIZ_IDC_PARAM_NAME_STATIC           1088
#define CLSWIZ_IDC_PARAM_TYPE_STATIC           1089
#define CLSWIZ_IDC_INTERNAL_NAME_STATIC        1090
#define CLSWIZ_IDC_RESOURCE_MSG                1092
#define CLSWIZ_IDC_OLE_MSG                     1093
#define CLSWIZ_IDC_CLW_HELP                    1100
#define CLSWIZ_IDC_ADD_TO_OG                   1104
#define CLSWIZ_IDC_ADDCLASS_HELPER             1115
#define CLSWIZ_IDC_DESCRIPTION_STATIC          1117
#define CLSWIZ_IDC_ODBC                        1117
#define CLSWIZ_IDC_DAO                         1118
#define CLSWIZ_IDC_ODBC_SOURCES                1119
#define CLSWIZ_IDC_STATIC_REGEN                1120
#define CLSWIZ_IDC_DAO_SOURCE                  1120
#define CLSWIZ_IDC_SNAPSHOT                    1124
#define CLSWIZ_IDC_DYNASET                     1125
#define CLSWIZ_IDC_TABLE                       1126
#define CLSWIZ_IDC_AUTODETECT                  1128
#define CLSWIZ_IDC_BIND_ALL                    1129
#define CLSWIZ_IDC_MULTIPLE_TABLE_LIST         1130
#define CLSWIZ_IDC_PROPSTATIC                  1131
#define CLSWIZ_IDC_CLASS_CHECKLIST             1132
#define CLSWIZ_IDC_PROJECTS                    1132
#define CLSWIZ_IDC_FILESHEADER                 1133
#define CLSWIZ_IDC_READONLY                    1134
#define CLSWIZ_IDC_SINGLE_TABLE_LIST           1135
#define CLSWIZ_ID_ADDFILE                      1138
#define CLSWIZ_ID_REMOVEFILE                   1139
#define CLSWIZ_ID_ADDVAR                       1140
#define CLSWIZ_ID_NEW                          1141
#define CLSWIZ_ID_ADDMETHOD                    1142
#define CLSWIZ_ID_REMOVE_EVENT                 1143
#define CLSWIZ_ID_DELETEVAR                    1144
#define CLSWIZ_ID_DELETE                       1145
#define CLSWIZ_IDC_THINGS                      1146
#define CLSWIZ_IDC_FILE_DETAILS                1147
#define CLSWIZ_IDC_OLEAUTO_GROUP               1148
#define CLSWIZ_IDC_DATASOURCE_GROUP            1149
#define CLSWIZ_IDC_RECORDSET_TYPE_GROUP        1150
#define CLSWIZ_IDC_SELECT_CLASS                1151
#define CLSWIZ_IDC_CLASSBOX                    2000
#define CLSWIZ_ID_ADD_CUSTOM                   12000
#define CLSWIZ_ID_ADD_PROP                     12001
#define CLSWIZ_ID_ADDALL                       12002
#define CLSWIZ_ID_BIND_ALL                     12003
#define CLSWIZ_ID_CLOSE                        12004
#define CLSWIZ_ID_UPDATE_COLS                  12005
#define CLSWIZ_IDC_ADD_TYPELIB                 12010
#define CLSWIZ_IDC_BASE_CLASS                  12011
#define CLSWIZ_IDC_BASECLASSNAME               12012
#define CLSWIZ_IDC_BOUND_PROPERTY              12013
#define CLSWIZ_IDC_BROWSE_HEADER               12014
#define CLSWIZ_IDC_BROWSE_IMPL                 12015
#define CLSWIZ_IDC_BROWSE1                     12016
#define CLSWIZ_IDC_BROWSE2                     12017
#define CLSWIZ_IDC_CLASS_LIST                  12018
#define CLSWIZ_IDC_CLASS_NAME                  12019
#define CLSWIZ_IDC_CLASSES                     12021
#define CLSWIZ_IDC_CLASSLIST                   12022
#define CLSWIZ_IDC_CLASSNAME                   12023
#define CLSWIZ_IDC_CLASSTEMPLATE               12024
#define CLSWIZ_IDC_CPPFILENAME                 12025
#define CLSWIZ_IDC_CUSTOM                      12027
#define CLSWIZ_IDC_DATA_BINDING                12028
#define CLSWIZ_IDC_DDX_COMMENT                 12029
#define CLSWIZ_IDC_DEF_PROP                    12030
#define CLSWIZ_IDC_DEFAULT_BIND                12031
#define CLSWIZ_IDC_DELETE                      12032
#define CLSWIZ_IDC_DESCRIPTION                 12033
#define CLSWIZ_IDC_DISPATCHED                  12034
#define CLSWIZ_IDC_DISPLAY_BIND                12035
#define CLSWIZ_IDC_ERRORTEXT                   12036
#define CLSWIZ_IDC_EVENTS                      12037
#define CLSWIZ_IDC_EXTERNAL_NAME               12038
#define CLSWIZ_IDC_FILENAME                    12039
#define CLSWIZ_IDC_FILES                       12040
#define CLSWIZ_IDC_FILTERTYPE                  12041
#define CLSWIZ_IDC_FOR_RESOURCE                12042
#define CLSWIZ_IDC_FILESSOURCE                 12042
#define CLSWIZ_IDC_FOREIGN_CLASS               12043
#define CLSWIZ_IDC_FOREIGN_VAR                 12044
#define CLSWIZ_IDC_GET_STATIC                  12045
#define CLSWIZ_IDC_GETNAME                     12046
#define CLSWIZ_IDC_GETSET_METHODS              12047
#define CLSWIZ_IDC_HELPPATH1                   12048
#define CLSWIZ_IDC_HELPPATH2                   12049
#define CLSWIZ_IDC_HFILE                       12050
#define CLSWIZ_IDC_HFILENAME                   12051
#define CLSWIZ_IDC_ID_TEXT                     12052
#define CLSWIZ_IDC_IFILE                       12053
#define CLSWIZ_IDC_INFO_ICON                   12055
#define CLSWIZ_IDC_INFOPANE                    12056
#define CLSWIZ_IDC_MAPPEDLIST                  12057
#define CLSWIZ_IDC_MEMBERNAME                  12058
#define CLSWIZ_IDC_MEMBERNAME_EDIT             12059
#define CLSWIZ_IDC_MEMBERVAR                   12060
#define CLSWIZ_IDC_MESSAGELIST                 12061
#define CLSWIZ_IDC_NAME                        12062
#define CLSWIZ_IDC_NAME_STATIC                 12063
#define CLSWIZ_IDC_NOTIFY_FUNC                 12065
#define CLSWIZ_IDC_NOTIFY_STATIC               12066
#define CLSWIZ_IDC_OLE_NAME                    12068
#define CLSWIZ_IDC_OLEPROPBOX                  12069
#define CLSWIZ_IDC_OLEPROPTITLE                12070
#define CLSWIZ_IDC_PARAM_LIST                  12071
#define CLSWIZ_IDC_PARAM_NAME                  12072
#define CLSWIZ_IDC_PARAM_STATIC                12073
#define CLSWIZ_IDC_PARAM_TYPE                  12074
#define CLSWIZ_IDC_PREIMPLEMENT                12075
#define CLSWIZ_IDC_PROJLIST                    12076
#define CLSWIZ_IDC_PROPBOX                     12077
#define CLSWIZ_IDC_REPAIR_DESC                 12078
#define CLSWIZ_IDC_REQUEST_EDIT                12079
#define CLSWIZ_IDC_RESOURCE                    12080
#define CLSWIZ_IDC_RESOURCENAME                12081
#define CLSWIZ_IDC_RETURN_TYPE                 12082
#define CLSWIZ_IDC_SET_STATIC                  12084
#define CLSWIZ_IDC_SETNAME                     12085
#define CLSWIZ_IDC_SOURCE                      12087
#define CLSWIZ_IDC_SOURCES                     12088
#define CLSWIZ_IDC_THINGLIST                   12089
#define CLSWIZ_IDC_TYPEBOX                     12090
#define CLSWIZ_IDC_VALIDEDIT0                  12091
#define CLSWIZ_IDC_VALIDEDIT1                  12092
#define CLSWIZ_IDC_VALIDLABEL0                 12093
#define CLSWIZ_IDC_VALIDLABEL1                 12094
#define CLSWIZ_IDC_NO_OLE                      12127
#define CLSWIZ_IDC_OLE_AUTO                    12128
#define CLSWIZ_IDC_OLE_CREATE                  12129
#define CLSWIZ_IDC_CHANGE_FILES                12131
#define CLSWIZ_IDB_HANDLED                     17500
#define CLSWIZ_IDD_ADDEVENT                    17508
#define CLSWIZ_IDD_ADDMEMBER                   17509
#define CLSWIZ_IDD_ADDMETHOD                   17510
#define CLSWIZ_IDD_ADDPROP                     17512
#define CLSWIZ_IDD_ADDVARIABLE                 17513
#define CLSWIZ_IDD_BROWSE_TYPES                17514
#define CLSWIZ_IDD_CLASSINFO                   17515
#define CLSWIZ_IDD_CONFIRM_CLASSES             17516
#define CLSWIZ_IDD_DATA_BINDING                17517
#define CLSWIZ_IDD_DATAMAP                     17518
#define CLSWIZ_IDD_DATASOURCES                 17519
#define CLSWIZ_IDD_FILELIST                    17520
#define CLSWIZ_IDD_FINDCLASS                   17521
#define CLSWIZ_IDD_MSGMAP                      17522
#define CLSWIZ_IDD_NOHELPFILE                  17523
#define CLSWIZ_IDD_OLE_AUTOMATION              17524
#define CLSWIZ_IDD_OLE_EVENTS                  17525
#define CLSWIZ_IDD_REPAIRCLASS                 17526
#define CLSWIZ_IDD_SELECT_RECSET               17527
#define CLSWIZ_IDD_SELECTCLASS                 17528
#define CLSWIZ_IDD_FILE_BROWSE                 17529
#define CLSWIZ_IDD_CREATE_CLASS                17530
#define CLSWIZ_IDD_CHANGE_FILES                17531
#define CLSWIZ_IDP_ADDPROJFILES                17532
#define CLSWIZ_IDP_ALREADY_IN_PROJECT          17533
#define CLSWIZ_IDP_BAD_PARAM                   17534
#define CLSWIZ_IDP_BAD_STDEVENT                17535
#define CLSWIZ_IDP_BAD_STDMETH                 17536
#define CLSWIZ_IDP_BAD_STDPROP                 17537
#define CLSWIZ_IDP_CANNOT_FIND_CPP             17538
#define CLSWIZ_IDP_CANNOT_FIND_HEADER          17539
#define CLSWIZ_IDP_CHANGE_CLASS                17540
#define CLSWIZ_IDP_CHANGE_IDD                  17541
#define CLSWIZ_IDP_CHANGE_VAR                  17542
#define CLSWIZ_IDP_CLASS_ALREADY_USED          17543
#define CLSWIZ_IDP_CLASS_IS_STANDARD           17544
#define CLSWIZ_IDP_CLWWRITE                    17545
#define CLSWIZ_IDP_CREATE_DIALOG_DUP_RESOURCE  17546
#define CLSWIZ_IDP_CREATE_DIALOG_NO_RESOURCE   17547
#define CLSWIZ_IDP_CREATE_DIALOG_QUOTE_RESOURCE 17548
#define CLSWIZ_IDP_DDP_MISMATCH                17549
#define CLSWIZ_IDP_DDV_MUST_FOLLOW_DDX         17550
#define CLSWIZ_IDP_DDV_MUST_FOLLOW_DDX_FOR_SAME 17551
#define CLSWIZ_IDP_DDX_ALREADY_EXISTS          17552
#define CLSWIZ_IDP_DELETING_EVENT              17553
#define CLSWIZ_IDP_DELETING_HANDLER            17554
#define CLSWIZ_IDP_DELETING_PROP               17555
#define CLSWIZ_IDP_DELETING_PROP_NOTIFY        17556
#define CLSWIZ_IDP_DUP_INSERT                  17557
#define CLSWIZ_IDP_DELETING_PROP2              17558
#define CLSWIZ_IDP_ERR_CHANGE_DIR              17559
#define CLSWIZ_IDP_ERR_CHANGED_FILES           17560
#define CLSWIZ_IDP_ERR_CLASS_FILENAMES         17561
#define CLSWIZ_IDP_ERR_CLASS_REMNANTS          17562
#define CLSWIZ_IDP_ERR_CREATE_FILES            17563
#define CLSWIZ_IDP_ERR_DUP_FORMAL              17564
#define CLSWIZ_IDP_ERR_FIND_CLASS              17565
#define CLSWIZ_IDP_ERR_GOTOCODE                17566
#define CLSWIZ_IDP_ERR_INVALID_FILENAMES       17567
#define CLSWIZ_IDP_ERR_MISSING_BLOCK           17568
#define CLSWIZ_IDP_ERR_ODL_ADD                 17569
#define CLSWIZ_IDP_ERR_ODL_DELETE              17570
#define CLSWIZ_IDP_ERR_ODL_GETBINDINGS         17571
#define CLSWIZ_IDP_ERR_ODL_READ                17572
#define CLSWIZ_IDP_ERR_ODL_SETBINDINGS         17573
#define CLSWIZ_IDP_ERR_ODL_SETID               17574
#define CLSWIZ_IDP_ERR_OPEN_CLASS              17575
#define CLSWIZ_IDP_ERR_OPEN_DATABASE           17576
#define CLSWIZ_IDP_ERR_OPEN_FILE               17577
#define CLSWIZ_IDP_ERR_OPEN_FILENAMES          17578
#define CLSWIZ_IDP_ERR_OPEN_ODLFILE            17579
#define CLSWIZ_IDP_ERR_READ_CLASS              17580
#define CLSWIZ_IDP_ERR_READING_FILE            17581
#define CLSWIZ_IDP_ERR_READONLY_FILES          17582
#define CLSWIZ_IDP_ERR_UPDATE_CLASS            17583
#define CLSWIZ_IDP_ERR_UPDATE_ODLFILE          17584
#define CLSWIZ_IDP_ERR_WRITE_FILES             17585
#define CLSWIZ_IDP_EXPECTED_ARGUMENTS          17586
#define CLSWIZ_IDP_EXPECTED_EOL                17587
#define CLSWIZ_IDP_EXPECTED_FOO                17588
#define CLSWIZ_IDP_GUID_REGISTERED             17589
#define CLSWIZ_IDP_IDENTIFIER_EXPECTED         17590
#define CLSWIZ_IDP_ILLEGAL_LINE                17591
#define CLSWIZ_IDP_INVALID_FILENAME            17592
#define CLSWIZ_IDP_INVALID_SYMBOL              17593
#define CLSWIZ_IDP_INVALID_TYPE                17594
#define CLSWIZ_IDP_INVALID_VALIDATION_ARGUMENT 17595
#define CLSWIZ_IDP_MEMBER_NAME_ALREADY_USED    17596
#define CLSWIZ_IDP_MISMATCH_PARAM              17597
#define CLSWIZ_IDP_MISSING_OLE_NAME            17598
#define CLSWIZ_IDP_MULTIPLE_FILES              17599
#define CLSWIZ_IDP_NEW_INVALID_FILENAMES       17600
#define CLSWIZ_IDP_NEW_READONLY_FILENAMES      17601
#define CLSWIZ_IDP_NO_CONTROLS                 17602
#define CLSWIZ_IDP_NO_DISPATCH_TYPES           17603
#define CLSWIZ_IDP_NO_KNOWN_DATA_TYPES         17604
#define CLSWIZ_IDP_NO_VARNAME                  17605
#define CLSWIZ_IDP_NEW_READONLY_ODLFILE        17606
#define CLSWIZ_IDP_NOCLASS                     17607
#define CLSWIZ_IDP_INVALID_OLE_SYMBOL          17608
#define CLSWIZ_IDP_NUMBER_OR_IDENTIFIER_EXPECTED 17609
#define CLSWIZ_IDP_ODL_FILE_SEEN               17610
#define CLSWIZ_IDP_OUT_OF_MEMORY               17611
#define CLSWIZ_IDP_PARSE_ERROR                 17612
#define CLSWIZ_IDP_REBUILD_DATABASE            17613
#define CLSWIZ_IDP_REBUILD_DATABASE_CORRUPT    17614
#define CLSWIZ_IDP_RESOURCE_ID_ALREADY_DEFINED 17615
#define CLSWIZ_IDP_SELECT_BASE                 17616
#define CLSWIZ_IDP_STRING_EXPECTED             17617
#define CLSWIZ_IDP_TOKEN_EXPECTED              17618
#define CLSWIZ_IDP_TOO_MANY_ARGUMENTS          17619
#define CLSWIZ_IDP_TOO_MANY_CLASSES            17620
#define CLSWIZ_IDP_TYPELIB_ERROR               17621
#define CLSWIZ_IDP_UNEXPECTED_EOL              17622
#define CLSWIZ_IDP_UNRECOGNIZED_MACRO          17623
#define CLSWIZ_IDP_WARN_CHANGED_FILES          17624
#define CLSWIZ_IDP_WARN_SAVE_CHANGES           17625
#define CLSWIZ_IDP_WILL_NOT_INIT_DDX           17626
#define CLSWIZ_IDP_NODATABASE                  17627
#define CLSWIZ_IDP_DATABASE_RO                 17630
#define CLSWIZ_IDP_NODATABASE_NT               17631
#define CLSWIZ_IDP_LINK_DIALOG                 17632
#define CLSWIZ_IDP_DUPLICATE_NOTIFY            17633
#define CLSWIZ_IDP_MINMAX_ERROR                17634
#define ERR_File_NoExist                17635
#define CLSWIZ_IDS_NOTIFY_TODO                 17636
#define CLSWIZ_IDS_FILESAVE_OK                 17637
#define CLSWIZ_IDS_TABDLG_CANCEL               17638
#define CLSWIZ_IDS_TABDLG_CLOSE                17639
#define CLSWIZ_IDS_TABDLG_HELP                 17640
#define CLSWIZ_IDS_BROWSE_TYPELIB              17640
#define CLSWIZ_IDS_CANT_APPEND_ODL             17641
#define CLSWIZ_IDS_AUTOMATION                  17642
#define CLSWIZ_IDS_AVAIL_MEM                   17643
#define CLSWIZ_IDS_BAD_COLUMNS                 17644
#define CLSWIZ_IDS_BAD_PARAMETER               17645
#define CLSWIZ_IDS_BROWSE_FILES                17646
#define CLSWIZ_IDS_CLASS                       17647
#define CLSWIZ_IDS_CLASS_INFO                  17648
#define CLSWIZ_IDS_CLASS_WIZARD                17649
#define CLSWIZ_IDS_COLUMN_NAMES                17650
#define CLSWIZ_IDS_COMMAND_ADDED               17651
#define CLSWIZ_IDS_CONTROL_IDS                 17652
#define CLSWIZ_IDS_DISK_SPACE                  17653
#define CLSWIZ_IDS_DISK_SPACE_UNAVAIL          17654
#define CLSWIZ_IDS_DISPATCH_BODY               17655
#define CLSWIZ_IDS_DISPATCH_TODO               17656
#define CLSWIZ_IDS_EMPTY_PARAMETER             17657
#define CLSWIZ_IDS_ERR_BAD_MAPPINGS            17658
#define CLSWIZ_IDS_ERR_BOGUS_ID                17659
#define CLSWIZ_IDS_ERR_COCREATEGUID_FAILED     17660
#define CLSWIZ_IDS_ERR_CONFLICTING_PROP        17661
#define CLSWIZ_IDS_ERR_DBOPEN_FAILED           17662
#define CLSWIZ_IDS_ERR_GETSET_EMPTY            17663
#define CLSWIZ_IDS_ERR_EXT_NAME_LENGTH         17664
#define CLSWIZ_IDS_ERR_NO_EXT_NAME             17665
#define CLSWIZ_IDS_ERR_EXT_NAME_INVALID        17665
#define CLSWIZ_IDS_ERR_NO_FUNCTION             17666
#define CLSWIZ_IDS_ERR_NO_INT_NAME             17667
#define CLSWIZ_IDS_ERR_NO_TYPE                 17668
#define CLSWIZ_IDS_ERR_NO_VARNAME              17669
#define CLSWIZ_IDS_ERR_NOTABLES                17670
#define CLSWIZ_IDS_ERR_OLE_NAME_ALREADY_USED   17671
#define CLSWIZ_IDS_ERR_PARAM_NAME_ALREADY_USED 17672
#define CLSWIZ_IDS_ERROR_HELP_NOFILE           17673
#define CLSWIZ_IDS_EVENT                       17674
#define CLSWIZ_IDS_EVENT_BODY                  17675
#define CLSWIZ_IDS_EVENT_TODO                  17676
#define CLSWIZ_IDS_EVENTPARAM                  17677
#define CLSWIZ_IDS_FILE_HEADER                 17678
#define CLSWIZ_IDS_FILTER_CPP                  17679
#define CLSWIZ_IDS_FILTER_H                    17680
#define CLSWIZ_IDS_FOREIGN_VAR                 17681
#define CLSWIZ_IDS_GETTING_COLS                17682
#define CLSWIZ_IDS_GETTING_SOURCES             17683
#define CLSWIZ_IDS_HELP_BUTTON                 17684
#define CLSWIZ_IDS_DAO_EXT1                    17684
#define CLSWIZ_IDS_HELP_DEFAULTDIR             17685
#define CLSWIZ_IDS_MANUALLY_EDIT_CLASS         17686
#define CLSWIZ_IDS_MATH_COPR_NOTPRESENT        17687
#define CLSWIZ_IDS_MATH_COPR_PRESENT           17688
#define CLSWIZ_IDS_MEMBER_VARIABLES            17689
#define CLSWIZ_IDS_MESSAGE_MAP                 17690
#define CLSWIZ_IDS_METHOD                      17691
#define CLSWIZ_IDS_METHODPARAM                 17692
#define CLSWIZ_IDS_MISMATCH_PROPERTY           17693
#define CLSWIZ_IDS_NAME                        17694
#define CLSWIZ_IDS_NO_GETSET                   17695
#define CLSWIZ_IDS_NO_NOTIFY                   17696
#define CLSWIZ_IDS_NONE                        17697
#define CLSWIZ_IDS_OLE_EVENTS                  17698
#define CLSWIZ_IDS_OPERATIONS_COMMENT          17699
#define CLSWIZ_IDS_PARAMETER                   17700
#define CLSWIZ_IDS_PROPERTIES_COMMENT          17701
#define CLSWIZ_IDS_PROPERTY                    17702
#define CLSWIZ_IDS_PROPERTY_TODO               17703
#define CLSWIZ_IDS_PROPERTYPARAM               17704
#define CLSWIZ_IDS_READONLY                    17705
#define CLSWIZ_IDS_SAME_H_CPP                  17706
#define CLSWIZ_IDS_SELECT_TABLE                17707
#define CLSWIZ_IDS_NOODLFILE                   17708
#define CLSWIZ_IDS_TYPE                        17709
#define CLSWIZ_IDS_VALUE                       17710
#define CLSWIZ_IDS_MUST_SELECT_SOURCE          17711
#define CLSWIZ_IDS_CREATECLASS                 17712
#define CLSWIZ_IDS_IMPORTCLASS                 17713
#define CLSWIZ_IDD_CREATEIMPORT                17714
#define CLSWIZ_IDS_READTYPELIB                 17714
#define CLSWIZ_IDS_NEWRESOURCE                 17715
#define CLSWIZ_IDS_NEWRESOURCE2                17716
#define CLSWIZ_IDD_CREATEIMPORTSELECT          17716
#define CLSWIZ_IDD_PICK_DATASOURCE             17717
#define CLSWIZ_IDS_NEWRESOURCE3                17717
#define CLSWIZ_IDS_DAO_EXT                     17718
#define CLSWIZ_IDD_PICK_TABLES                 17718
#define CLSWIZ_IDS_NEWRESOURCE4                17718
#define CLSWIZ_IDS_DAO_FILTER                  17719
#define CLSWIZ_IDS_DAO_DEFFILE                 17720
#define CLSWIZ_IDS_MUST_SELECT_TABLE           17721
#define CLSWIZ_IDD_IMPORTCLASS                 17722
#define CLSWIZ_IDS_ERR_LONG_OLE_NAME           17722
#define CLSWIZ_IDS_WIZBAR_HANDLE               17723
#define CLSWIZ_IDS_CONFIRM_DISPATCH            17724
#define CLSWIZ_IDS_CONFIRM_CONTROL             17725
#define CLSWIZ_IDP_FILE_EXISTS                 17726
#define CLSWIZ_IDP_UNIQUE_CLASS                17727
#define CLSWIZ_IDP_CANT_WRITE_FILE             17728
#define CLSWIZ_IDP_CTL_NOT_IN_REG              17729
#define CLSWIZ_IDP_TLB_NOT_IN_REG              17730
#define CLSWIZ_IDP_CANT_LOAD_TLB               17731
#define CLSWIZ_IDS_BROWSETL_FILTERS            17732
#define CLSWIZ_IDP_NO_GALLERY                  17733
#define CLSWIZ_IDP_TLB_UNCOOL                  17734
#define CLSWIZ_IDP_NODATABASE_NOARG            17735
#define CLSWIZ_IDS_OCX_REGISTER_FAIL           17736
#define CLSWIZ_IDS_OCX_INVALID_FILE            17737
#define CLSWIZ_IDS_OCX_LOAD_FAIL               17738
#define CLSWIZ_IDS_REGISTER                    17739
#define CLSWIZ_IDS_REIMPORT                    17740
#define CLSWIZ_IDP_CTL_NOT_INSTALLED           17741
#define CLSWIZ_IDP_NO_DB_INFO                  17742
#define CLSWIZ_IDS_REFLECTED                   17743
#define CLSWIZ_IDP_FILE_DUPE                   17744
#define CLSWIZ_IDP_NO_CTL_CHECKED              17745
#define CLSWIZ_IDS_RESOURCE_PROSE              17746
#define CLSWIZ_IDS_NEED_INCLUDE                17750
#define CLSWIZ_IDS_INSERT_CONTROL              17751
#define CLSWIZ_IDC_CREATECLASS                 17752
#define CLSWIZ_IDS_READONLY_VAR                17752
#define CLSWIZ_IDP_ERR_REBUILD_CLASS           17753
#define CLSWIZ_IDC_IMPORT                      17753
#define CLSWIZ_IDC_SELECT                      17754
#define CLSWIZ_IDP_RTBRACK_EXPECTED            17754
#define CLSWIZ_ID_ADDCLASS                     17755
#define CLSWIZ_IDP_COLNAME_EXPECTED            17755
#define CLSWIZ_IDD_REBUILD_CLW                 17756
#define CLSWIZ_IDD_BROWSE_FILE                 17757
#define CLSWIZ_IDD_OPEN_TYPELIB                17758
#define CLSWIZ_IDD_BROWSE_DAO                  17759
#define CLSWIZ_IDS_MUST_SELECT_TABLES          17760
#define CLSWIZ_IDP_ERR_WRITE_ADDL_INCL         17761
#define CLSWIZ_IDP_ERR_NOSEL_MSG               17762
#define CLSWIZ_IDP_ERR_NO_MSG_HELP             17763
#define CLSWIZ_IDS_DATAPATH_TODO               17764
#define CLSWIZ_ID_ADD                          0x8001
#define CLSWIZ_ID_REMOVE                       0x8002
#define CLSWIZ_ID_GOTOCODE                     0x8003
#define CLSWIZ_ID_MSGHELP                      0x8004
#define CLSWIZ_ID_UPDATE                       0x8007
#define CLSWIZ_ID_ADDCLASS_INIT                0x8008
#define CLSWIZ_ID_INIT_SOURCES                 0x8009

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        17756
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1152
#define _APS_NEXT_SYMED_VALUE           17756
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\sym\cmdids.h ===
//{{NO_DEPENDENCIES}}
//
// Command IDs for the SHELL and all packages
//
//Reserved Ranges:  (All commands > 0x7FFF 
//                                      -- All non-command strings < 0x8000)
//

/////////////////////////////////////////////////////////////////////////////
// *All VC IDE Packages    0x8000-0x9FFF
//
//  Shell
#define MIN_SHELL_COMMAND_ID    0x8000
#define MAX_SHELL_COMMAND_ID    0x83FF
//  Build package
#define MIN_BUILD_COMMAND_ID    0x8400
#define MAX_BUILD_COMMAND_ID    0x85FF
//  Res package
#define MIN_RES_COMMAND_ID      0x8600
#define MAX_RES_COMMAND_ID      0x86FF
//  Src
#define MIN_SOURCE_COMMAND_ID   0x8700
#define MAX_SOURCE_COMMAND_ID   0x88FF
//  Wizards
#define MIN_WIZARD_COMMAND_ID   0x8900
#define MAX_WIZARD_COMMAND_ID   0x89FF
//  MSIN
#define MIN_MSIN_COMMAND_ID     0x8A00
#define MAX_MSIN_COMMAND_ID     0x8BFF
//  VBA                         (BUG: Also using 0x8800-0x880F)
#define MIN_VBA_COMMAND_ID      0x8C00
#define MAX_VBA_COMMAND_ID      0x8EFF
//  Proj
#define MIN_PROJECT_COMMAND_ID  0x8F00
#define MAX_PROJECT_COMMAND_ID  0x8FFF
// IV
// MarcI: Added commands for IV5
#define MIN_IV_COMMAND_ID   0x90A0
#define MAX_IV_COMMAND_ID   0x9FFF
//
// *External Packages      0xA000-0xDFFF
//
//  Fortran
#define MIN_FORTRAN_COMMAND_ID  0xA000
#define MAX_FORTRAN_COMMAND_ID  0xA1FF
//  Test
#define MIN_TEST_COMMAND_ID     0xA200
#define MAX_TEST_COMMAND_ID     0xA3FF
//  Espresso
#define MIN_ESPRESSO_COMMAND_ID 0xA400
#define MAX_ESPRESSO_COMMAND_ID 0xA5FF
//  Sample Package
#define MIN_SAMPLE_COMMAND_ID 0xDF00
#define MAX_SAMPLE_COMMAND_ID 0xDFFF
//
// *MFC
#define MIN_MFC_COMMAND_ID      0xE000
#define MAX_MFC_COMMAND_ID      0xFFFF
/////////////////////////////////////////////////////////////////////////////

// Major group ID's
#define IDG_FILE                                1
#define IDG_EDIT                                2
#define IDG_SEARCH                      3
#define IDG_PROJECT_MAJOR       4
#define IDG_BUILD_MAJOR                 5
#define IDG_RESOURCE                    6
#define IDG_IMAGE                               7
#define IDG_LAYOUT                      8
#define IDG_DEBUG                               9
#define IDG_TOOLS                               10
#define IDG_WINDOW                      11
#define IDG_HELP                                12
#define IDG_MACRO                               13
#define IDG_VIEW                        14
#define IDG_RUN                                 15
#define IDG_INSERT              16
#define IDG_ISEARCH             17

#define IDG_TEST                                50      // MSTest package menu.

// Minor Command groups
//
#define IDG_FILEOPS             1
#define IDG_FILESAVE            2
#define IDG_PRINT               3
#define IDG_MRU                 4
#define IDG_EXIT                5
#define IDG_MAIL                        6
#define IDG_PROJ_MRU        7
#define IDG_FILE_FIND       8
#define IDG_MSINOPEN        9

#define IDG_UNDO                        10
#define IDG_CLIPBOARD           11
#define IDG_FIND                        12
#define IDG_FIND_COMBO          13
#define IDG_GOTO                        14
#define IDG_BOOKMARK            15
#define IDG_EDITPROPS           16
#define IDG_OLE                         17
#define IDG_BREAKPOINTS                 18

#define IDG_PROJECTOPS          20
#define IDG_BUILD                       21
#define IDG_ERROR                       22
#define IDG_DEPENDENCIES        23
#define IDG_PROJECTCLOSE        24
#define IDG_PROJECTOPS_STD      25
#define IDG_PROJECT_ADD         26
#define IDG_PROJECTOPS_ADD      27
#define IDG_PROJECTOPS_SCAN     28
#define IDG_PROJECTOPS_SCHM     29
#define IDG_ERROR                       22
#define IDG_PROJECTOPS_ADD      27
#define IDG_PROJECTOPS_SCAN     28
#define IDG_PROJECTOPS_SCHM     29

#define IDG_RESOURCENEW         30
#define IDG_RESOURCEIMPORT      31
#define IDG_SYMBOLS                     32
#define IDG_VIEW_AS_POPUP       33
#define IDG_NEWRES                      34
#define IDG_CLASSWIZARD     35
#define IDG_LAYOUTOPT     36

#define IDG_DEBUGRUN            40
#define IDG_DEBUGSTEP           41
#define IDG_DEBUGSHOW           42
#define IDG_DEBUGTHREADS        43
#define IDG_CODECOVER           46
#define IDG_COVERITEMS          47
#define IDG_DEBUGOPTS       48
#define IDG_DEBUGACTIVE     49

#define IDG_TOOLOPS                     50
#define IDG_OPTIONS                     52
#define IDG_TOOLS_SEARCH                                53
#define IDG_USERTOOLS           54

#define IDG_WINDOWOPS           60
#define IDG_WINDOWALL           61
#define IDG_WINDOW_WINDOWS      62
#define IDG_WINDOWLIST          63

#define IDG_HELPGENERAL         70
#define IDG_HELPDOCS            71
#define IDG_HELPPSS             72
#define IDG_HELPINSTALLED       73
#define IDG_HELP_SUBSETCOMBO    74
#define IDG_HELPABOUT           75
#define IDG_HELP_OPENCOMBO      76
#define IDG_CONTENTS                    77
#define IDG_HELP_CONTENTS               78
#define IDG_HELP_BROWSE         79

#define IDG_IMAGEOPS            80
#define IDG_IMAGECOLORS         81
#define IDG_IMAGEGRID           82
#define IDG_IMAGETOOLS      83
#define IDG_IMAGE_DEVICE    84

#define IDG_LAYOUTOPS           90
#define IDG_LAYOUTGRID          91
#define IDG_LAYOUTTAB           92
#define IDG_RULER_CONTEXT       93

#define IDG_ALIGNEDGE           94
#define IDG_ALIGNCENTER         95
#define IDG_SPACEEVENLY         96
#define IDG_CENTERDIALOG        97
#define IDG_ARRANGEBUTTONS      98
#define IDG_SAMESIZE            99

#define IDG_BROWSE                      100
#define IDG_KEY                         101

#define IDG_MACRORUN            110
#define IDG_MACROBROWSE         111

#define IDG_PROJECT                     130
#define IDG_PARSER                      134
#define IDG_PRJSYS_OPS      135
#define IDG_BLDSYS_TOOL         136
#define IDG_TARGET_COMBO    137
#define IDG_BUILD_1         138
#define IDG_BUILD_2         139

#define IDG_VIEW_WINDOWS        141
#define IDG_VIEW_MSIN1                  142
#define IDG_VIEW_MSIN2                  143
#define IDG_VIEW_MSIN3                  144
#define IDG_MSIN_PRINT                  145

#define IDG_SCC_POPUP           150
#define IDG_SCC_OPS1            151
#define IDG_SCC_OPS2            152
#define IDG_SCC_OPS3            153
#define IDG_SCC_RUN             154

#define IDG_BROWSE_OPS          160
#define IDG_BROWSE_QUERY        161

#define IDG_VIEW_VBA            170

#define IDG_VIEW_FULLSCREEN 190
#define IDG_INSERT_1        191
#define IDG_INSERT_2        192
#define IDG_INSERT_3        193
#define IDG_INSERT_4        194
#define IDG_BUILD_DEBUG     196
#define IDG_BUILD_SETTINGS  197
#define IDG_VIEW_TOOLBARS   198
#define IDG_TOOLS_REMOTE    199

#define IDG_DEBUG_1         300
#define IDG_DEBUG_2         301
#define IDG_DEBUG_3         302
#define IDG_DEBUG_4         303
#define IDG_DEBUG_5         304
#define IDG_DEBUG_6         305
#define IDG_DEBUG_7         306
#define IDG_DEBUG_8         307

#define IDG_TEST_DEBUG          500
#define IDG_TEST_RECORD         501
#define IDG_TEST_SCREENS        502
#define IDG_TEST_DIALOGS        503
#define IDG_TEST_DRIVER         504

/////////////////////////////////////////////////////////////////////
// SUSHI Frame Commands
//
#define IDM_TOOLBAR_EDIT                0x8000
#define IDM_CUSTOMIZE                   0x8001
#define ID_WINDOW_CLOSE_ALL             0x8002
#define IDM_OPTIONS                             0x8003
#define IDM_TOGGLE_MDI                  0x8004
#define IDM_TOOLBAR_CUSTOMIZE   0x8005
#define ID_WINDOW_FULLSCREEN    0x8006
#define ID_FILE_SAVE_ALL_EXIT   0x8007

#define IDM_DOCKSHOW_BASE               0x8200
#define IDM_DOCKSHOW_LAST               0x8218  //24 possible show commands for all dockable windows.

#define IDM_ACTIVATE_PROJECT               0x8280
#define IDM_TOGGLE_PROJECT                 0x8281

#define IDMX_IDPROP                     0x8290
#define IDMX_PROPGENERAL                0x8291
#define IDMX_PROPSTYLES                 0x8292
#define ID_FASTHELP                     0x8298

#define IDM_USERTOOLS_BASE              0x82A0
#define IDM_USERTOOLS_0                 (IDM_USERTOOLS_BASE + 0)
#define IDM_USERTOOLS_1                 (IDM_USERTOOLS_BASE + 1)
#define IDM_USERTOOLS_2                 (IDM_USERTOOLS_BASE + 2)
#define IDM_USERTOOLS_3                 (IDM_USERTOOLS_BASE + 3)
#define IDM_USERTOOLS_4                 (IDM_USERTOOLS_BASE + 4)
#define IDM_USERTOOLS_5                 (IDM_USERTOOLS_BASE + 5)
#define IDM_USERTOOLS_6                 (IDM_USERTOOLS_BASE + 6)
#define IDM_USERTOOLS_7                 (IDM_USERTOOLS_BASE + 7)
#define IDM_USERTOOLS_8                 (IDM_USERTOOLS_BASE + 8)
#define IDM_USERTOOLS_9                 (IDM_USERTOOLS_BASE + 9)
#define IDM_USERTOOLS_10                (IDM_USERTOOLS_BASE + 10)
#define IDM_USERTOOLS_11                (IDM_USERTOOLS_BASE + 11)
#define IDM_USERTOOLS_12                (IDM_USERTOOLS_BASE + 12)
#define IDM_USERTOOLS_13                (IDM_USERTOOLS_BASE + 13)
#define IDM_USERTOOLS_14                (IDM_USERTOOLS_BASE + 14)
#define IDM_USERTOOLS_15                (IDM_USERTOOLS_BASE + 15)
#define IDM_USERTOOLS_LAST              0x82AF  //16 user tools on Tools menu

#define ID_PROJ_MRU_FIRST                               0x8C10
#define ID_PROJ_MRU_FILE1               (ID_PROJ_MRU_FIRST)
#define ID_PROJ_MRU_FILE2               (ID_PROJ_MRU_FIRST + 1)
#define ID_PROJ_MRU_FILE3               (ID_PROJ_MRU_FIRST + 2)
#define ID_PROJ_MRU_FILE4               (ID_PROJ_MRU_FIRST + 3)
#define ID_PROJ_MRU_FILE5               (ID_PROJ_MRU_FIRST + 4)
#define ID_PROJ_MRU_FILE6               (ID_PROJ_MRU_FIRST + 5)
#define ID_PROJ_MRU_FILE7               (ID_PROJ_MRU_FIRST + 6)
#define ID_PROJ_MRU_FILE8               (ID_PROJ_MRU_FIRST + 7)
#define ID_PROJ_MRU_FILE9               (ID_PROJ_MRU_FIRST + 8)
#define ID_PROJ_MRU_FILE10              (ID_PROJ_MRU_FIRST + 9)
#define ID_PROJ_MRU_FILE11              (ID_PROJ_MRU_FIRST + 10)
#define ID_PROJ_MRU_FILE12              (ID_PROJ_MRU_FIRST + 11)
#define ID_PROJ_MRU_FILE13              (ID_PROJ_MRU_FIRST + 12)
#define ID_PROJ_MRU_FILE14              (ID_PROJ_MRU_FIRST + 13)
#define ID_PROJ_MRU_FILE15              (ID_PROJ_MRU_FIRST + 14)
#define ID_PROJ_MRU_FILE16              (ID_PROJ_MRU_FIRST + 15)
#define ID_PROJ_MRU_LAST                                0x8C1F

#ifdef _DEBUG
#define IDM_OPENLAYOUT                  0x8300
#endif

#define ID_TOOLS_RECORD                 0x8302
#define ID_TOOLS_PLAYBACK               0x8303
#define ID_FILE_NEW_SOURCE              0x8304
#define ID_FILE_NEW_RC                  0x8305
#define IDM_WINDOW_SHOWPROPERTIES       0x8306
#define IDM_WINDOW_HSPROPERTIES         0x8307
#define ID_WINDOW_HIDE                          0x8308
#define ID_WINDOW_POPUP_HIDE            0x8309
#define ID_FILE_NEW_BITMAP                      0x830A
#define IDM_TOOLS_RUNMENU						0x830B
#define IDM_QUERY_GROUPBYMENU					0x830C
#define IDM_QUERY_VERIFYMENU					0x830D

#define ID_PROP_PUSHPIN                         0x8320
#define MIN_ID_REPEAT_CMD                                               0x8321
#define ID_REPEAT_CMD                           0x8321
#define ID_REPEAT_CMD0                                                  0x8322
#define ID_REPEAT_CMD1                                                  0x8323
#define ID_REPEAT_CMD2                                                  0x8324
#define ID_REPEAT_CMD3                                                  0x8325
#define ID_REPEAT_CMD4                                                  0x8326
#define ID_REPEAT_CMD5                                                  0x8327
#define ID_REPEAT_CMD6                                                  0x8328
#define ID_REPEAT_CMD7                                                  0x8329
#define ID_REPEAT_CMD8                                                  0x832A
#define ID_REPEAT_CMD9                                                  0x832B
#define MAX_ID_REPEAT_CMD                                               0x832B

#define ID_DRAG_MOVE                            0x8330
#define ID_DRAG_COPY                            0x8331
#define ID_DRAG_CANCEL                          0x8332

#define ID_CANCEL                                               0x8333
#define ID_MDI_CYCLE_FORWARD                                    0x8334

/////////////////////////////////////////////////////////////////////
// VPROJ Commands
//
#define IDM_PROJITEM_FIRST              0x8400
#define IDM_PROJITEM_NEW                0x8400
#define IDM_PROJITEM_MOVE               0x8401
#define IDM_PROJITEM_COPY               0x8402
#define IDM_PROJITEM_DELETE             0x8403
#define IDM_PROJITEM_OPEN               0x8404
#define IDM_PROJ_ADD_DATASOURCE         0x8405
#define IDM_PROJITEM_ADD_FILES          0x8406
#define IDM_PROJITEM_ADD_RC             0x8416
#define IDM_PROJITEM_ADD_GROUP          0x8407
#define IDM_PROJITEM_ADD_SUBPROJ        0x8408
#define IDM_PROJITEM_SCAN               0x8409
#define IDM_PROJECT_SCAN_ALL            0x840a
#define IDM_PROJITEM_BUILD              0x840b
#define IDM_PROJITEM_COMPILE            0x840c
#define IDM_PROJITEM_PRINT              0x840d
#define IDM_PROJITEM_REBUILD_ALL        0x840e
#define IDM_PROJECT_EXECUTE             0x840f
#define IDM_PROJITEM_BATCH_BUILD        0x8410
#define IDM_PROJITEM_CBUILD             0x841c
#define IDM_PROJITEM_CCOMPILE           0x841f
#define IDM_PROJECT_SET_AS_DEFAULT      0x8420
#define IDM_PROJITEM_LAST               0x84ff
#define IDM_PROJ_FIRST                  0x8500
#define IDM_PROJECT_SETTINGS            0x8500
#define IDM_PROJECT_STOP_BUILD          0x8501
#define IDM_PROJECT_CLOSEBSC            0x8502
#define IDM_PROJECT_TOOL_MECR           0x8503
#define IDM_PROJECT_CONFIGURATIONS      0x8504
#define IDM_PROJITEM_EXPORT_MAKEFILE	0x8505
#define IDM_PROJECT_TOOL_CMD_FIRST      0x8510
#define IDM_PROJECT_TOOL_CMD0           0x8510
#define IDM_PROJECT_TOOL_CMD1           0x8511
#define IDM_PROJECT_TOOL_CMD2           0x8512
#define IDM_PROJECT_TOOL_CMD3           0x8513
#define IDM_PROJECT_TOOL_CMD4           0x8514
#define IDM_PROJECT_TOOL_CMD5           0x8515
#define IDM_PROJECT_TOOL_CMD6           0x8516
#define IDM_PROJECT_TOOL_CMD_LAST       0x8516
#define IDM_PROJECT_TARGET              0x8517
#define IDM_PROJECT_TOOLS               0x8519
#define IDM_PROJECT_SETTINGS_POP        0x851a
#define IDM_PROJECT_BUILDGRAPH          0x851b
#define IDM_PROJECT_CLEAN               0x851c
#define IDM_PROJECT_EXPORT_MAKEFILE		0x8522
#define IDM_PROJ_ACTIVEPROJMENU			0x8523
// adding user-defined messages for PostMessage()
// this is to avoid buttons being depressed during duration of the cmd.
#define ID_PROJITEM_COMPILE             0x851d
#define ID_PROJITEM_BUILD               0x851e 
#define ID_PROJITEM_REBUILD_ALL         0x851f
#define ID_PROJITEM_BATCH_BUILD         0x8520

#define ID_TARGET_COMBO                 0x8521

// -> custom build tool output specification macros ->
#define IDM_BLDTOOL_DIRMACRO1           0x8550
#define IDM_BLDTOOL_DIRMACRO2           0x8551
#define IDM_BLDTOOL_DIRMACRO3           0x8552
#define IDM_BLDTOOL_DIRMACRO4           0x8553
#define IDM_BLDTOOL_DIRMACRO5           0x8554
#define IDM_BLDTOOL_DIRMACRO6           0x8555
#define IDM_BLDTOOL_DIRMACRO7           0x8556
#define IDM_BLDTOOL_DIRMACRO8           0x8557
#define IDM_BLDTOOL_FILEMACRO1          0x8558
#define IDM_BLDTOOL_FILEMACRO2          0x8559
#define IDM_BLDTOOL_FILEMACRO3          0x855a
#define IDM_BLDTOOL_FILEMACRO4          0x855b
#define IDM_BLDTOOL_FILEMACRO5          0x855c
#define IDM_BLDTOOL_FILEMACRO6          0x855d

#define IDM_BLDTOOL_FIRSTMACRO          IDM_BLDTOOL_DIRMACRO1
#define IDM_BLDTOOL_LASTMACRO           IDM_BLDTOOL_FILEMACRO6
// <- custom build tool output specification macros <-

#define IDM_PROJECT_DEFAULT_PROJ        0x852c

#define IDM_CTL_PROJ_TARGET                     0x85F0
#define IDM_PROJ_LAST                           0x85FF

/////////////////////////////////////////////////////////////////////
// VRES Commands
//
#define IDM_FILE_SETINCLUDES            0x8600
#define IDM_FILE_INSTALLCONTROLS        0x8601
#define IDM_EDIT_SYMBOLS                        0x8602
#define IDM_RESOURCE_NEW            0x8603
#define IDM_RESOURCE_OPEN                       0x8604
#define IDM_RESOURCE_OPENBINARY         0x8605
#define IDM_RESOURCE_IMPORT                     0x8606
#define IDM_RESOURCE_EXPORT                     0x8607
#define IDM_TOOLBAR_WIZARD                      0x8608
#define IDMY_CLASSWIZARD            0x8609
#define IDMB_NEW_DIALOG             0x860A
#define IDMB_NEW_CURSOR             0x860B
#define IDMB_NEW_ICON               0x860C
#define IDMB_NEW_BITMAP             0x860D
#define IDMB_NEW_MENUBAR            0x860E
#define IDMB_NEW_STRINGTABLE        0x860F
#define IDMB_NEW_ACCTABLE           0x8610
#define IDMB_NEWRC                  0x8611
#define IDMB_NEW_VERSION            0x8612
#define ID_CANCEL_EDIT              0x8613
#define IDM_RESOURCE_ADD            0x8614
#define IDM_RESOURCE_NEWCOPY        0x8615
#define IDMB_NEW_TOOLBAR                        0x8616

// special commands for specific VRES resource types
#define IDM_FIND_STRING             0x8650
#define IDM_FIND_NEXT               0x8651
#define IDM_NEW_STRING              0x8652
#define IDM_NEW_ACCELERATOR         0x8653
#define IDM_NEW_STRINGBLOCK         0x8654
#define IDM_DELETE_STRINGBLOCK      0x8655
#define IDMY_TEST                   0x8656
#define IDM_SETTABORDER             0x8657
#define IDMY_ALIGNLEFT              0x8658
#define IDMY_ALIGNRIGHT             0x8659
#define IDMY_ALIGNTOP               0x865A
#define IDMY_ALIGNBOTTOM            0x865B
#define IDMY_SPACEACROSS            0x865C
#define IDMY_SPACEDOWN              0x865D
#define IDM_BUTTONRIGHT             0x865E
#define IDM_BUTTONBOTTOM            0x865F
#define IDMY_MAKESAMEWIDTH          0x8660
#define IDMY_MAKESAMEHEIGHT         0x8661
#define IDMY_MAKESAMEBOTH           0x8662
#define IDM_SIZETOTEXT              0x8663
#define IDM_GRIDSETTINGS            0x8664
#define IDMB_SHOWGRID               0x8665
#define IDM_VIEWASPOPUP             0x8666
#define IDMY_PICKCOLOR              0x8667
#define IDM_FLIPBSHH                0x8668
#define IDM_FLIPBSHV                0x8669
#define IDM_MAGNIFY                 0x866A
#define IDM_NEWDEVIMG               0x866B
#define IDM_OPENDEVIMG              0x866C
#define IDM_DELDEVIMG               0x866D
#define IDM_INVERTCOLORS            0x866E
#define IDM_TGLOPAQUE               0x866F
#define IDM_EDITCOLORS              0x8670
#define IDM_LOADCOLORS              0x8671
#define IDM_SAVECOLORS              0x8672
#define IDM_SETHOTSPOT              0x8673
#define IDM_ALIGNCVERT              0x8674
#define IDM_ALIGNCHORZ              0x8675
#define IDMY_CENTERVERT             0x8676
#define IDMY_CENTERHORZ             0x8677
#define IDM_INSTALLCONTROLS         0x8678
#define IDMY_CHECKHOTKEYS           0x8679
#define IDMZ_IMGSEPARATOR           0x8680
#define IDMX_ZOOMIN                 0x8681
#define IDMX_ZOOMOUT                0x8682
#define IDMX_SMALLERBRUSH           0x8683
#define IDMX_LARGERBRUSH            0x8684
#define IDMB_RECTTOOL               0x8685
#define IDMB_FRECTTOOL              0x8686
#define IDMB_ELLIPSETOOL            0x8687
#define IDMB_FELLIPSETOOL           0x8688
#define IDMZ_BRUSHTOOL              0x8689
#define IDMB_FILLTOOL               0x868A
#define IDMB_LINETOOL               0x868B
#define IDMB_PICKTOOL               0x868C
#define IDMX_PREVCOLOR              0x868D
#define IDMX_NEXTCOLOR              0x868E
#define IDMX_PREVECOLOR             0x868F
#define IDMB_3DRECTTOOL             0x8690
#define IDMX_NEXTECOLOR             0x8691
#define IDMX_TEXTTOOL               0x8692
#define IDMB_CURVETOOL              0x8693
#define IDMB_ORECTTOOL              0x8694
#define IDMB_ORNDRECTTOOL           0x8695
#define IDMB_OELLIPSETOOL           0x8696
#define IDMB_POLYGONTOOL            0x8697
#define IDMB_FPOLYGONTOOL           0x8698
#define IDMB_OPOLYGONTOOL           0x8699
#define IDMB_PICKRGNTOOL            0x869A
#define IDMX_OUTLINEBSH             0x869B
#define IDMB_AIRBSHTOOL             0x869C
#define IDMX_SMALLBRUSH             0x869D
#define IDMX_SEL2BSH                0x869E
#define IDMB_RNDRECTTOOL            0x869F
#define IDMB_FRNDRECTTOOL           0x86A1
#define IDMB_PENCILTOOL             0x86A2
#define IDMB_ERASERTOOL             0x86A3
#define IDMB_ZOOMTOOL               0x86A4
#define IDMB_CBRUSHTOOL             0x86A5
#define IDM_GRIDOPT                 0x86A6
#define IDMX_SHOWTILEGRID           0x86A7
#define IDM_ROT90                   0x86A8
#define IDMX_OTHERPANE              0x86A9
#define IDM_SHOWIMAGEGRID           0x86AA
#define IDMB_SHOWRULER              0x86AB
#define IDMB_TOGGLEGUIDES           0x86AC
#define IDM_GUIDE_ATTACH_LEFT       0x86AD
#define IDM_GUIDE_ATTACH_RIGHT      0x86AE
#define IDM_GUIDE_ATTACH_PROPORTIONAL 0x86AF
#define IDM_GUIDE_CLEAR             0x86B0
#define IDM_GUIDE_CLEAR_ALL         0x86B1
#define IDM_WINDOWRECTTOOL          0x86B3
#define IDMY_FLIPDIALOG             0x86B4

#define IDM_CTL_POSFIRST                        0x86B5
	#define IDM_CTL_MOVELEFT                        0x86B5
	#define IDM_CTL_MOVEUP                          0x86B6
	#define IDM_CTL_MOVERIGHT                       0x86B7
	#define IDM_CTL_MOVEDOWN                        0x86B8
#define IDM_CTL_SIZEFIRST                       0x86B9
	#define IDM_CTL_SIZELEFT                        0x86B9
	#define IDM_CTL_SIZEUP                          0x86BA
	#define IDM_CTL_SIZERIGHT                       0x86BB
	#define IDM_CTL_SIZEDOWN                        0x86BC
#define IDM_CTL_POSLAST                         0x86BC

#define IDM_CTL_HOTSPOT_LOC         0x86F0
#define IDM_CTL_INSERT                          0x86F1


/////////////////////////////////////////////////////////////////////
// VCPP Commands
//
// Many of the standard ones (FileOpen, etc) now use the MFC
// predefined IDs.
//
#define IDM_FILE_SAVE_ALL               0x8700
#define ID_EDIT_FIND_DLG        0x8701 // invoke find dialog
#define IDM_EDIT_GREP                   0x8702
#define IDM_EDIT_FINDMATCH              0x8703
#define IDM_EDIT_READONLY               0x8704
#define ID_CUT_LINE             0x8705
#define ID_EDIT_FIND_NEXT       0x8706
#define ID_EDIT_FIND_PREV       0x8707
#define ID_EDIT_FIND_COMBO      0x8708 // activate find combo
#define IDM_ADDTOPROJECT                0x8709
#define IDM_EDIT_CLEAR_OUTPUT   0x870A
#define IDM_FILE_SEND                   0x870B
#define IDM_FILE_REVERT                 0x870C
#define IDM_FILE_LIST_DOCS              0x870D

#define IDM_GOTO_LINE                   0x8711
#define IDM_VIEW_MIXEDMODE              0x8712
#define IDM_GOTO_DISASSY                0x8713
#define IDM_GOTO_SOURCE                 0x8714
#define IDM_GOTO_CURRENTERROR			0x8715
#define IDM_VIEW_NEXTERROR              0x8716
#define IDM_VIEW_PREVIOUSERROR			0x8717
#define IDM_VIEW_TOGGLETAG              0x8718
#define IDM_VIEW_NEXTTAG                0x8719
#define IDM_VIEW_PREVIOUSTAG			0x871A
#define IDM_VIEW_CLEARALLTAGS			0x871B
#define IDM_GOTO_FILE                   0x871C
#define IDM_VIEW_OUTTOOLS               0x871D
#define IDM_BOOKMARKS                   0x871E
#define IDM_GOTO_CODE                   0x871F
#define IDM_BROWSE_GOTOREF              0x8720
#define IDM_BROWSE_GOTODEF              0x8721
#define IDM_BROWSE_NEXT                 0x8722
#define IDM_BROWSE_PREVIOUS             0x8723
#define IDM_BROWSE_OPEN                 0x8724
#define IDM_BROWSE_POP                  0x8725
#define IDM_BROWSE_SYM                  0x8726
#define IDM_BROWSE_OUTLINE              0x8727
#define IDM_BROWSE_FGRAPH               0x8728
#define IDM_BROWSE_CGRAPH               0x8729
#define IDM_BROWSE_FGRAPH_R             0x872A
#define IDM_BROWSE_CGRAPH_R             0x872B
#define IDM_BROWSE_QUERY                0x872C
#define IDM_BROWSE_FILES                0x872D

#define IDM_RUN_GO                      0x8730
#define IDM_RUN_RESTART                 0x8731
#define IDM_RUN_STOPDEBUGGING           0x8732
#define IDM_RUN_BREAK                   0x8733
#define IDM_RUN_TOCURSOR                0x8734
#define IDM_RUN_TRACEINTO               0x8735
#define IDM_RUN_STEPOVER                0x8736
#define IDM_RUN_STOPAFTERRETURN         0x8737
#define IDM_RUN_CALLS                   0x8738
#define IDM_RUN_SETBREAK                0x8739
#define IDM_RUN_QUICKWATCH              0x873A
#define IDM_RUN_EXCEPTIONS              0x873B
#define IDM_RUN_THREADS                 0x873C
#define IDM_RUN_PROFILE                 0x873D
#define IDM_RUN_COVER_TOGGLE            0x873E
#define IDM_RUN_COVER_CLEAR             0x873F
#define IDM_RUN_SETNEXTSTMT             0x8740
#define IDM_RUN_CLEARALLBREAK           0x8741
#define IDM_RUN_SRC_TRACEINTO           0x8742
#define IDM_RUN_SRC_STEPOVER            0x8743
#define IDM_RUN_FLIPHACK                0x8744 // not used in release build
#define IDM_RUN_REMOTEDEBUGGER          0x8745
#define IDM_RUN_JIT_GO                  0x8746
#define IDM_DEBUG_ACTIVE                0x8747
#define IDM_RUN_TRACEFUNCTION           0x8749
#define IDM_RUN_SRC_TRACEFUNCTION       0x874A
#define IDM_RUN_ENABLEBREAK             0x874B
#define IDM_RUN_TOGGLEBREAK             0x874C

#define IDM_OUTPUT_EXECTOOL             0x8750
#define IDM_OUTPUT_CLEAR                0x8751
#define IDM_OUTPUT_GOTO_TAG             0x8752
#define IDM_DEBUG_DEREF                 0x8753
#define IDM_DEBUG_GOTOSOURCE			0x8754
#define IDM_DBGSHOW_FLOAT               0x8755
#define IDM_DBGSHOW_STACKTYPES			0x8756
#define IDM_DBGSHOW_STACKVALUES			0x8757
#define IDM_DBGSHOW_SOURCE              0x8758
#define IDM_DBGSHOW_MEMBYTE             0x8759
#define IDM_DBGSHOW_MEMSHORT			0x875A
#define IDM_DBGSHOW_MEMLONG             0x875B
#define IDM_DBGSHOW_LOCALS_BAR			0x875C
#define IDM_DBGSHOW_WATCH_BAR			0x875D
#define IDM_DBGSHOW_MEMORY_BAR			0x875E
#define IDM_DBGSHOW_TYPE_COLUMN			0x875F
#define IDM_INDENT						0x8760
#define IDM_UNINDENT					0x8761
#define IDM_DBGSHOW_VARS_BAR			0x8762
#define IDM_KEYBOARDINDENT				0x8763
#define IDM_KEYBOARDUNINDENT			0x8764
#define IDM_TOOL_STOP					0x8765
#define IDM_FIRST_TOOL					0x8766
#define IDM_MACROS						0x8767
#define IDM_MACRO_PLAY					0x8768
#define IDM_MACRO_PAUSE					0x8769
#define IDM_MACRO_STOP					0x876A
#define IDM_WINDOW_ERRORS				0x876C
#define IDM_WINDOWCHILD					0x876D

#define IDM_HELP_FULLTEXT				0x8770
#define IDM_HELP_LANGUAGE				0x8771
#define IDM_HELP_MFC					0x8772
#define IDM_HELP_WIN32					0x8773
#define IDM_HELP_MSPROD					0x8774
#define IDM_HELP_RETRY					0x8775
#define IDM_HELP_CONTENTS               0x8776
#define IDM_HELP_INDEX                  0x8777
#define IDM_HELP_SEARCH					0x8778
#define IDM_HELP_EXTHELP				0x8779
//#define IDM_HELP_BOOKS          0x8779
//#define IDM_HELP_CRT            0x877A
#define IDM_HELP_TIPOFTHEDAY			0x877b

#define IDM_REFORMAT                    0x877f
#define IDM_UPPERCASE                   0x8780
#define IDM_NEWLINE                     0x8781
#define IDM_NEXTLINE                    0x8782
#define IDM_NEWLINEABOVE                0x8783
#define IDM_LOWERCASE                   0x8784
#define IDM_CLEARSELECTION              0x8785
#define IDM_SCROLL_LINEUP               0x8786
#define IDM_SCROLL_LINEDOWN             0x8787
#define ID_EDIT_FIND_NEXTCURRENTWORD    0x8788
#define ID_EDIT_FIND_PREVCURRENTWORD    0x8789
#define IDM_EDIT_DELETEWORDRIGHT        0x878a
#define IDM_EDIT_DELETELEFT             0x878b
#define IDM_FIND_IFDEF_UP               0x878c
#define IDM_FIND_IFDEF_DOWN             0x878d
#define IDM_EXTEND_FIND_IFDEF_UP        0x878e
#define IDM_EXTEND_FIND_IFDEF_DOWN      0x878f
#define IDM_CURSOR_STARTNEXTLINE        0x8790
#define ID_COL_SELECT                   0x8791
#define IDM_INSERT                      0x8792

#define ID_RUN_GO                               0x8793
#define ID_RUN_RESTART                          0x8794
#define ID_RUN_TOCURSOR                         0x8795
#define ID_RUN_TRACEINTO                        0x8796
#define ID_RUN_STEPOVER                         0x8797
#define ID_RUN_STOPAFTERRETURN                  0x8798
#define ID_RUN_SRC_TRACEINTO                    0x8799
#define ID_RUN_SRC_STEPOVER                     0x879a
#define ID_RUN_STOPDEBUGGING                    0x879b
#define IDM_VIEW_EPSDROPBOOKMARK                0x879c
#define IDM_VIEW_EPSNEXTBOOKMARK                0x879d
#define IDM_VIEW_BRF_DROPBOOKMARK1              0x879e
#define IDM_VIEW_BRF_DROPBOOKMARK2              0x879f
#define IDM_VIEW_BRF_DROPBOOKMARK3              0x87a0
#define IDM_VIEW_BRF_DROPBOOKMARK4              0x87a1
#define IDM_VIEW_BRF_DROPBOOKMARK5              0x87a2
#define IDM_VIEW_BRF_DROPBOOKMARK6              0x87a3
#define IDM_VIEW_BRF_DROPBOOKMARK7              0x87a4
#define IDM_VIEW_BRF_DROPBOOKMARK8              0x87a5
#define IDM_VIEW_BRF_DROPBOOKMARK9              0x87a6
#define IDM_VIEW_BRF_DROPBOOKMARK10             0x87a7
#define ID_RUN_TRACEFUNCTION                    0x87a8
#define ID_RUN_SRC_TRACEFUNCTION                0x87a9

#define IDM_ACTIVATE_SRCFIRST                   0x87B0
#define IDM_ACTIVATE_OUTPUT                     0x87B0
#define IDM_ACTIVATE_WATCH                      0x87B1
#define IDM_ACTIVATE_VARIABLES                  0x87B2
#define IDM_ACTIVATE_REGISTERS                  0x87B3
#define IDM_ACTIVATE_MEMORY                     0x87B4
#define IDM_ACTIVATE_CALLSTACK                  0x87B5
#define IDM_ACTIVATE_DISASSEMBLY                0x87B6
// ...
#define IDM_ACTIVATE_SRCLAST                                    0x87BF

#define IDM_TOGGLE_SRCFIRST                                             0x87B0
#define IDM_TOGGLE_OUTPUT                       0x87C0
#define IDM_TOGGLE_WATCH                        0x87C1
#define IDM_TOGGLE_VARIABLES                    0x87C2
#define IDM_TOGGLE_REGISTERS                    0x87C3
#define IDM_TOGGLE_MEMORY                       0x87C4
#define IDM_TOGGLE_CALLSTACK                    0x87C5
#define IDM_TOGGLE_DISASSEMBLY                  0x87C6
// ...
#define IDM_TOGGLE_SRCLAST                      0x87CF

#define IDM_VIEW_TOPIC							0x87D0	// Added by DougMan for InfoViewer Mnemonics
#define IDM_VIEW_RESULTS						0x87D1	// Added by DougMan for InfoViewer Mnemonics
#define IDM_HELP_IVBOOKMARKS					0x87D2	// Added by DougMan for InfoViewer Mnemonics
#define IDM_HELP_DEFINESUBSETS					0x87D3	// Added by DougMan for InfoViewer Mnemonics
#define IDM_HELP_SELECTSUBSETS					0x87D4	// Added by DougMan for InfoViewer Mnemonics


#define IDM_CTL_LOCAL_FUNCS                     0x87E0
#define IDM_CTL_WATCH_EDIT                      0x87E1
#define IDM_CTL_WATCH_DELETE                    0x87E2
#define IDM_CTL_BROWSE_CLASS                    0x6403
#define IDM_CTL_BROWSE_FUNCMEM                  0x6404
#define IDM_CTL_BROWSE_DATAMEM                  0x6405
#define IDM_CTL_BROWSE_MACRO                    0x6406
#define IDM_CTL_BROWSE_TYPE                     0x6407
#define IDM_CTL_BROWSE_FUNCS                    0x6408
#define IDM_CTL_BROWSE_DATA                     0x6409
#define IDM_CTL_MEMORY_EDIT                     0x87EA
#define IDM_CTL_VARS_FUNCS                      0x87EB

#define IDM_PARSER_PARSE                0x87F0
#define IDM_PARSER_INFO                 0x87F1
#define IDM_PARSER_PARSEPROJ    0x87F2
#define IDM_PARSER_OPENDBASE    0x87F3
#define IDM_PARSER_CLOSEDBASE   0x87F4

#define ID_DELETE_LINE                  0x8800
#define ID_EDIT_REPLACE_DLG             0x8801
#define ID_NEXT_WINDOW          0x8802
#define ID_PREV_WINDOW          0x8803
#define ID_EDIT_BRF_FIND_FWD    0x8804
#define ID_EDIT_BRF_FIND_BACK   0x8805
#define ID_TOGGLE_RESTORE               0x8806
#define ID_SEARCH_AGAIN                 0x8807

#define IDM_CURSOR_CHARLEFT     0x8808
#define IDM_CURSOR_CHARRIGHT    0x8809
#define IDM_CURSOR_LINEUP               0x880A
#define IDM_CURSOR_LINEDOWN             0x880B
#define IDM_CURSOR_WORDLEFT             0x880C
#define IDM_CURSOR_WORDRIGHT    0x880D
#define IDM_CURSOR_SCREENUP             0x880E
#define IDM_CURSOR_SCREENDOWN   0x880F
#define IDM_EPSILON_ESCAPE              0x8810
#define IDM_CURSOR_LINESTART    0x8811
#define IDM_CURSOR_LINEEND              0x8812
#define IDM_CURSOR_FILESTART    0x8813
#define IDM_CURSOR_FILEEND              0x8814
#define IDM_CURSOR_BEGINPANE    0x8815
#define IDM_CURSOR_ENDPANE              0x8816
#define IDM_CURSOR_LEFTPANE             0x8817
#define IDM_CURSOR_RIGHTPANE    0x8818
#define IDM_CURSOR_BEGINLINE    0x8819
#define IDM_CURSOR_BRIEFHOME    0x881A
#define IDM_CURSOR_BRIEFEND             0x881B
#define IDM_TABIFYREGION        0x881C
#define IDM_UNTABIFYREGION      0x881D
#define IDM_HIGHLIGHTREGION             0x881E
#define IDM_EPSILON_INDENT_REGION       0x881F
#define IDM_EPSILON_KILLREGION  0x8820
#define IDM_EDIT_DELETEBRIEFEOLN        0x8821
#define IDM_EPSILON_FWDPARAGRAPH        0x8822
#define IDM_EPSILON_BCKPARAGRAPH        0x8823
#define IDM_EPSILON_FWDSENTENCE 0x8824
#define IDM_EPSILON_BCKSENTENCE 0x8825
#define IDM_EPSILON_DELSENTENCE 0x8826
#define IDM_EDIT_DELETEBRIEFBOLN        0x8827
#define IDM_EPSILON_TRANSPOSECH 0x8828
#define IDM_EPSILON_TRANSPOSEWD 0x8829
#define IDM_EPSILON_TRANSPOSELN 0x882A
#define IDM_EPSILON_CAPWORD             0x882B
#define IDM_EPSILON_LOWERWORD   0x882C
#define IDM_EPSILON_UPPERWORD   0x882D
#define ID_CMD_INVALID                  0x882E
#define IDM_NEWLINEBELOW                0x882F
#define ID_EDIT_REDOCHANGES             0x8830
#define ID_EDIT_UNDOCHANGES             0x8831
#define IDM_EPSILON_MARKPARAGRAPH       0x8832
#define IDM_EPSILON_CENTERWINDOW        0x8833
#define IDM_EPSILON_DELHORZSPACE        0x8834
#define IDM_EPSILON_DELBLANKLINES       0x8835
#define IDM_EDIT_TOGGLE_CASE    0x8836
#define IDM_EDIT_TOGGLE_RE              0x8837
#define IDM_EDIT_TOGGLE_WORD    0x8838
#define IDM_EPSILON_APPENDNEXTKILL      0x8839
#define IDM_EPSILON_TOINDENT    0x883A
#define IDM_FORMAT_REGION               0x883B
#define IDM_INDENT_UNDER                0x883C
#define IDM_INSERT_FROM_FILE    0x883D
#define IDM_REGEX_SRCH_FWD              0x883E
#define IDM_REGEX_SRCH_BCK              0x883F
#define IDM_BP_CURRENT_ADDR                             0x8840
#define IDM_BP_CURRENT_LINE                             0x8841
#define IDM_BP_CURRENT_FUNC                             0x8842
#define IDM_BP_ADVANCED                                 0x8843
#define ID_EDIT_RE_REPLACE                              0x8844
#define IDM_SEARCH_ISEARCH_FWD                  0x8845
#define IDM_SEARCH_ISEARCH_BACK                 0x8846
#define IDM_SEARCH_ISEARCH_REFWD        0x8847
#define IDM_SEARCH_ISEARCH_REBACK       0x8848
#define IDM_ISEARCH_ISEARCH_FWD         0x8849
#define IDM_ISEARCH_ISEARCH_BACK        0x884A
#define IDM_ISEARCH_TOGGLE_CASE         0x884B
#define IDM_ISEARCH_TOGGLE_WORD         0x884C
#define IDM_ISEARCH_TOGGLE_REGEX        0x884D
#define ID_QUOTED_INSERT                                0x884E
#define ID_CHANGE_PANE_UP                               0x884F
#define ID_CHANGE_PANE_DOWN                             0x8850
#define ID_CHANGE_PANE_LEFT                             0x8851
#define ID_CHANGE_PANE_RIGHT                    0x8852
#define ID_DELETE_ROW_UP                                0x8853
#define ID_DELETE_ROW_DOWN                              0x8854
#define ID_DELETE_COL_LEFT                              0x8855
#define ID_DELETE_COL_RIGHT                             0x8856
#define ID_LINE_TO_TOP                                  0x8857
#define ID_LINE_TO_BOTTOM                               0x8858

#define ID_FILESET_FIRST                                                                0x8859
#define ID_FILESET0                                                                             ID_FILESET_FIRST + 0
#define ID_FILESET1                                                                             ID_FILESET_FIRST + 1
#define ID_FILESET2                                                                             ID_FILESET_FIRST + 2
#define ID_FILESET3                                                                             ID_FILESET_FIRST + 3
#define ID_FILESET4                                                                             ID_FILESET_FIRST + 4
#define ID_FILESET5                                                                             ID_FILESET_FIRST + 5
#define ID_FILESET6                                                                             ID_FILESET_FIRST + 6
#define ID_FILESET7                                                                             ID_FILESET_FIRST + 7
#define ID_FILESET8                                                                             ID_FILESET_FIRST + 8
#define ID_FILESET9                                                                             ID_FILESET_FIRST + 9
#define ID_FILESET10                                                                    ID_FILESET_FIRST + 10
#define ID_FILESET11                                                                    ID_FILESET_FIRST + 11
#define ID_FILESET12                                                                    ID_FILESET_FIRST + 12
#define ID_FILESET13                                                                    ID_FILESET_FIRST + 13
#define ID_FILESET14                                                                    ID_FILESET_FIRST + 14
#define ID_FILESET15                                                                    ID_FILESET_FIRST + 15
#define ID_FILESET_LAST                                                                 0x8868
#define ID_EDIT_BACKWARD_LEVEL                  0x8869
#define ID_EDIT_FORWARD_LEVEL                   0x8870
#define ID_EDIT_KILL_LEVEL                              0x8871
#define ID_EDIT_BACKWARD_KILL_LEVEL             0x8872

#define IDM_STRING_TO_RESOURCE          0x8873

/////////////////////////////////////////////////////////////////////
// MSIN Commands
//
#define IDM_MSIN                        0x8a00
#define ID_SEARCH                       0x8a01
#define ID_QUERY_RESULTS                0x8a02
#define ID_SELECT_TITLE                 0x8a10
#define ID_SELECT_SUBSET                0x8a11
#define ID_FIND_FIND                    0x8a12
#define ID_FIND_KEYWORD                 0x8a13
#define ID_RESULTS_FIND                 0x8a14
#define ID_RESULTS_HISTORY              0x8a15
#define ID_BACK                         0x8a16
#define ID_NEXT                         0x8a17
#define ID_PREV                         0x8a18
#define ID_FIND_NEXT                    0x8a19
#define ID_BOOK_NEXT                    0x8a1a
#define ID_FIND_PREV                    0x8a1b
#define ID_BOOK_PREV                    0x8a1c
#define ID_PRINT_TOPIC                  0x8a1d
#define ID_PRINT_TOC                    0x8a1e
#define ID_SYNC                         0x8a1f
#define ID_TOGGLE_HIGHLIGHTS            0x8a20
#define ID_ADD_BOOKMARK                 0x8a21
#define ID_EDIT_BOOKMARK                0x8a22
#define ID_WHATSNEW                     0x8a24
#define ID_COPYTOPIC                    0x8a25
#define ID_SELECTION_RIGHT              0x8a26
#define ID_SELECTION_LEFT               0x8a27
#define ID_SELECTION_UP                 0x8a28
#define ID_SELECTION_DOWN               0x8a29
#define ID_SELECTION_ENTIRE             0x8a2a
#define ID_SEEALSO                      0x8a2b
#define ID_FIRST_TOPIC                  0x8a2c
#define ID_HOME_SCREEN                  0x8a2d
#define ID_EDIT_HELPBOOKMARKS           0x8a2e
#define ID_EDIT_ANNOTATION              0x8a30
#define ID_ADD_ANNOTATION               0x8a31
#define ID_NEXT_BOOKMARK                0x8a32
#define ID_PREV_BOOKMARK                0x8a33
#define ID_NEXT_LIST                    0x8a34
#define ID_PREV_LIST                    0x8a35
#define ID_SHOWBAR                      0x8a37
#define ID_SHOWNSR                      0x8a38
#define ID_DISPLAY_OPTIONS              0x8a39
#define ID_FIND_OPTIONS                 0x8a3a
#define ID_DEFINE_SUBSETS               0x8a3b
#define ID_SWITCHMVB                    0x8a3c
#define ID_NEXT_BOOKMARK_LIST           0x8a3d
#define ID_PREV_BOOKMARK_LIST           0x8a3e
#define ID_HELP_QUERY_RESULTS           0x8a3f
#define ID_HELP_BOOKMARK_LIST           0x8a40
#define ID_NEXT_JUMP                    0x8a41
#define ID_SEEALSOP                     0x8a42
#define ID_BACKP                        0x8a43
#define ID_HELPP                        0x8a44
#define ID_TOPIC                        0x8a45
#define ID_MSIN_OPEN                    0x8a46
#define ID_MSIN_ABOUT                   0x8a47
#define ID_NEXT_HIGHLIGHT               0x8b48
#define ID_PREV_HIGHLIGHT               0x8b49
#define ID_MSIN_PRINT_SETUP             0x8b4a
#define ID_HELP_KEYBOARD				0x8a4b

// The following commands are handled by the MSIN macro system
//
#define IDM_MSIN_MACRO_FIRST    0x8b00  //ID of first one
#define IDM_NEXT_HIGHLIGHT              0x8b00
#define IDM_PREV_HIGHLIGHT              0x8b01
#define IDM_ANNOTATION                  0x8b02
#define IDM_MSIN_MACRO_LAST             0x8b02  //ID of last one


//////////////////////////////////////////////////////////
//
// New IV command defines here.
//
#define ID_IV_TOPIC                        MIN_IV_COMMAND_ID + 1
#define ID_IV_URL_EC                       MIN_IV_COMMAND_ID + 2
#define ID_IV_OPEN_URL                     MIN_IV_COMMAND_ID + 3 
#define ID_IV_SYNC                         MIN_IV_COMMAND_ID + 4 
#define ID_IV_BACK                         MIN_IV_COMMAND_ID + 5 
#define ID_IV_NEXT                         MIN_IV_COMMAND_ID + 6 
#define ID_IV_PREV                         MIN_IV_COMMAND_ID + 7
#define ID_IV_FORWARD                      MIN_IV_COMMAND_ID + 8
#define ID_IV_REFRESH                      MIN_IV_COMMAND_ID + 9
#define ID_IV_STOP_DOWNLOAD                MIN_IV_COMMAND_ID + 10
#define ID_IV_LIST_BOOKMARKS               MIN_IV_COMMAND_ID + 11
#define ID_IV_ADD_BOOKMARK                 MIN_IV_COMMAND_ID + 12
#define ID_IV_PREV_BOOKMARK                MIN_IV_COMMAND_ID + 13
#define ID_IV_NEXT_BOOKMARK                MIN_IV_COMMAND_ID + 14
#define ID_IV_DEF_SUBSET                   MIN_IV_COMMAND_ID + 15


/////////////////////////////////////////////////////////////////////
// Wizard Commands
//
#define IDM_WIZARD_FIRST                0x8900
#define IDM_WIZARDBAR_VISIBLE			(IDM_WIZARD_FIRST+0)
#define IDM_ADDCLASS                    (IDM_WIZARD_FIRST+1)
#define IDM_GALLERY						(IDM_WIZARD_FIRST+2)
#define ID_WIZBAR_HEADERFILE            (IDM_WIZARD_FIRST+3)
// michma 2/20/98 - this isn't inherited from the ide but just a command we needed.
#define IDM_NEW_ATL_OBJECT				(IDM_WIZARD_FIRST+4)
#define IDM_WIZARD_LAST                 0x89ff

// Commands which are dynamically bound to actions via the CDynCT instance in CTheApp.
#define IDM_DYNAMIC_BASE                0x8d00
#define IDM_DYNAMIC_LAST                0x8eff


/////////////////////////////////////////////////////////////////////
// Project Window Commands
//
#define IDM_PRJWIN_FIRST                        0x8f00
#define IDM_ADDFOLDER               (IDM_PRJWIN_FIRST+0)
#define IDM_ADDSUBFOLDER            (IDM_PRJWIN_FIRST+1)
#define IDM_ADDMENU                 (IDM_PRJWIN_FIRST+2)
#define IDM_ADDSELECTEDNODE         (IDM_PRJWIN_FIRST+3)
#define IDM_ADDPANE                 (IDM_PRJWIN_FIRST+4)
#define IDM_DELETEPANE              (IDM_PRJWIN_FIRST+5)
#define IDM_ADDPROVIDEDNODE1        (IDM_PRJWIN_FIRST+6)
#define IDM_ADDPROVIDEDNODE2        (IDM_PRJWIN_FIRST+7)
#define IDM_ADDPROVIDEDNODE3        (IDM_PRJWIN_FIRST+8)
#define IDM_ADDPROVIDEDNODE4        (IDM_PRJWIN_FIRST+9)
#define IDM_ADDPROVIDEDNODE5        (IDM_PRJWIN_FIRST+10)
#define IDM_ADDPROVIDEDNODE6        (IDM_PRJWIN_FIRST+11)
#define IDM_ADDPROVIDEDNODE7        (IDM_PRJWIN_FIRST+12)
#define IDM_ADDPROVIDEDNODE8        (IDM_PRJWIN_FIRST+13)
#define IDM_ADDPROVIDEDNODE9        (IDM_PRJWIN_FIRST+14)
#define IDM_ADDPROVIDEDNODE10       (IDM_PRJWIN_FIRST+15)
#define IDM_ADDPROVIDEDNODE11       (IDM_PRJWIN_FIRST+16)
#define IDM_ADDPROVIDEDNODE12       (IDM_PRJWIN_FIRST+17)
#define IDM_ADDPROVIDEDNODE13       (IDM_PRJWIN_FIRST+18)
#define IDM_ADDPROVIDEDNODE14       (IDM_PRJWIN_FIRST+19)
#define IDM_ADDPROVIDEDNODE15       (IDM_PRJWIN_FIRST+20)
#define IDM_ADDPROVIDEDNODE16       (IDM_PRJWIN_FIRST+21)
#define IDM_SLOB_DEFAULTCMD         (IDM_PRJWIN_FIRST+22)
#define IDM_TOGGLE_TITLETIPS        (IDM_PRJWIN_FIRST+23)
#define IDM_OPEN_WORKSPACE          (IDM_PRJWIN_FIRST+24)
#define IDM_SAVE_WORKSPACE			(IDM_PRJWIN_FIRST+25)
#define IDM_CLOSE_WORKSPACE         (IDM_PRJWIN_FIRST+26)
// Begin Class View specific
#define IDM_CLSVIEW_GOTO_DECL       (IDM_PRJWIN_FIRST+50)
#define IDM_CLSVIEW_DERIVED_CLASSES (IDM_PRJWIN_FIRST+51)
#define IDM_CLSVIEW_BASE_CLASSES    (IDM_PRJWIN_FIRST+52)
#define IDM_CLSVIEW_REFS                    (IDM_PRJWIN_FIRST+53)
#define IDM_CLSVIEW_CALLED_FUNCS    (IDM_PRJWIN_FIRST+54)
#define IDM_CLSVIEW_CALLING_FUNCS   (IDM_PRJWIN_FIRST+55)
#define IDM_CLSVIEW_ADD_MF          (IDM_PRJWIN_FIRST+56)
#define IDM_CLSVIEW_ADD_MV          (IDM_PRJWIN_FIRST+57)
#define IDM_GROUPBYACCESS			(IDM_PRJWIN_FIRST+58)
// End Class View specific
// Begin Source Control specific
#define IDM_SCC_FIRST               (IDM_PRJWIN_FIRST+80)
#define IDM_SCC_POP                 (IDM_SCC_FIRST+0)
#define IDM_SCC_GET                 (IDM_SCC_FIRST+1)
#define IDM_SCC_OUT                 (IDM_SCC_FIRST+2)
#define IDM_SCC_IN                  (IDM_SCC_FIRST+3)
#define IDM_SCC_UNOUT               (IDM_SCC_FIRST+4)
#define IDM_SCC_ADD                 (IDM_SCC_FIRST+5)
#define IDM_SCC_REMOVE              (IDM_SCC_FIRST+6)
#define IDM_SCC_HISTORY             (IDM_SCC_FIRST+7)
#define IDM_SCC_DIFF                (IDM_SCC_FIRST+8)
#define IDM_SCC_PROPS               (IDM_SCC_FIRST+9)
#define IDM_SCC_SHARE    			(IDM_SCC_FIRST+10)
#define IDM_SCC_ADMIN               (IDM_SCC_FIRST+11)
#define IDM_SCC_LAST                (IDM_SCC_FIRST+19) // (IDM_PRJWIN_FIRST+99)
// End Source Control specific
#define IDM_PRJWIN_LAST                 0x8fff  // (IDM_PRJWIN_FIRST + 255)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\sym\optnbsc.h ===
//{{NO_DEPENDENCIES}}
// bscmake option control IDs

// 'General' Category IDs
#define OPTNBSC_IDDP_PROJ_BSCMAKE	18441
#define OPTNBSC_IDC_BSCNOLOGO	0x4A10
#define OPTNBSC_IDC_BSCOUTNAME	0x4A11
#define OPTNBSC_IDC_BSCT1	0x4A20
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\sym\optncplr.h ===
//{{NO_DEPENDENCIES}}
// compiler option control IDs

// 'General' Category IDs
#define OPTNCPLR_IDDP_PROJ_COMPILER	18443

// 'Custom Options' Category IDs
#define OPTNCPLR_IDDP_COMPILER_CUSTOM	18433
#define OPTNCPLR_IDC_OPTEXT		0x4920	// Za, Ze
#define OPTNCPLR_IDC_OPTINCLINK	0x4921	// Gy
#define OPTNCPLR_IDC_STRPOOL		0x4922	// Gf
#define OPTNCPLR_IDC_OPTWARN		0x4923	// W0, W1, ...
#define OPTNCPLR_IDC_WARNASERR	0x4924	// WX
#define OPTNCPLR_IDC_CPLRNOLOGO	0x4925	// nologo
#define OPTNCPLR_IDC_ENABLE_GI	0x4926	// Gi
#define OPTNCPLR_IDC_ENABLE_MR	0x4927	// Gm
#define OPTNCPLR_IDC_TXT_WARN	0x4930

// 'Custom Options (C++)' Category IDs
#define OPTNCPLR_IDDP_COMPILER_CUSTOMCPP	18434
#define OPTNCPLR_IDC_PTRMBR1		0x4940	// (representation method)
#define OPTNCPLR_IDC_PTRMBR2		0x4941	// (general-purpose representation)
#define OPTNCPLR_IDC_PTRGEN		0x4942	// pseudo flag (not user selectable)
#define OPTNCPLR_IDC_VTORDISP	0x4943
/* temporarily reverse the logic for PDC (BamBam) 'cos the compiler default will be /GX- for this
** release .. ie. we need [X] Enable EH in the options dialog
#define OPTNCPLR_IDC_DISABLE_EH	0x4944
*/
#define OPTNCPLR_IDC_ENABLE_EH	0x4944
#define OPTNCPLR_IDC_ENABLE_RTTI	0x4945
#define OPTNCPLR_IDC_TXT_PTRMBR1	0x4950
#define OPTNCPLR_IDC_TXT_PTRMBR2	0x4951
#define OPTNCPLR_IDC_TXT_PTRGRP	0x4952

// 'Debug and Runtime Options' Category IDs
#define OPTNCPLR_IDDP_COMPILER_DEBUG	18435
#define OPTNCPLR_IDC_DEBUG		0x4960	// Zd, Z7, Zi
#define OPTNCPLR_IDC_TXT_DEBUG	0x4970

// 'Listing Files' Category IDs
#define OPTNCPLR_IDDP_COMPILER_LISTFILE	18436
#define OPTNCPLR_IDC_LISTBSC		0x4980	// FR
#define OPTNCPLR_IDC_LISTLOCAL	0x4981	// Fr
#define OPTNCPLR_IDC_LISTBSC_NME	0x4983	// FR<file>
#define OPTNCPLR_IDC_LISTASM		0x4984	// FA, FAc, FAs, FASc
#define OPTNCPLR_IDC_LISTASM_NME	0x4985	// Fa<file>
#define OPTNCPLR_IDC_TXT_LISTASM	0x498A	// 
#define OPTNCPLR_IDC_TXT_LISTASM1 0x498B
#define OPTNCPLR_IDC_TXT_LISTBSC 0x498C

// 'Optimizations' Category IDs
#define OPTNCPLR_IDDP_COMPILER_OPTIMIZE	18437
#define OPTNCPLR_IDC_OPTIMIZE	0x4990	// O? etc. for Native Code
#define OPTNCPLR_IDC_INLINECTRL	0x4991	// Ob
#define OPTNCPLR_IDC_OPTIMIZE2	0x4992	// O2, /O1, /O? enabled
#define OPTNCPLR_IDC_TXT_OPTIMIZE 0x49A0
#define OPTNCPLR_IDC_TXT_INLINE	0x49A1

// 'Pre-compiled Headers' Category IDs
#define OPTNCPLR_IDDP_COMPILER_PCH		18438
#define OPTNCPLR_IDC_NOPCH		0x49B0
#define OPTNCPLR_IDC_AUTOPCH		0x49B1	// YX
#define OPTNCPLR_IDC_CREATEPCH	0x49B2	// Yc
#define OPTNCPLR_IDC_USEPCH		0x49B3	// Yu
#define OPTNCPLR_IDC_TXT_AUTOPCH 0x49B4
#define OPTNCPLR_IDC_AUTOPCHNAME	0x49B5	// YX<file>
#define OPTNCPLR_IDC_TXT_CREATE	0x49B6
#define OPTNCPLR_IDC_CREATENAME	0x49B7	// Yc<file>
#define OPTNCPLR_IDC_TXT_USE		0x49B8
#define OPTNCPLR_IDC_USENAME		0x49B9	// Yu<file>

// 'Preprocessor' Category IDs
#define OPTNCPLR_IDDP_COMPILER_PREPROCESS	18439
#define OPTNCPLR_IDC_MACROS		0x49D0	// D<macro>
#define OPTNCPLR_IDC_UNDEFS		0x49D1	// U<macro>
#define OPTNCPLR_IDC_UNDEFINE	0x49D2	// u
#define OPTNCPLR_IDC_IGNINC		0x49D3	// X
#define OPTNCPLR_IDC_INCLUDE		0x49D4	// I<path>
#define OPTNCPLR_IDC_TXT_MACROS	0x49E0
#define OPTNCPLR_IDC_TXT_UNDEFS	0x49E1
#define OPTNCPLR_IDC_TXT_INCS	0x49E2
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\sym\menuids.h ===
///////////////////////////////////////////////////////////////////////////////
//	MENUIDS.H
//
//	Created by :			Date :
//		EnriqueP				8/19/93
//
//	Description :
//		Contains constants for menu item captions
//

#ifndef __MENUIDS_H__
#define __MENUIDS_H__

#define SYSTEM_SYSTEM  " "
#define SYSTEM_CLOSE   "&Close"

#define FILE_FILE      "&File"
#define FILE_NEW       "&New..."
#define FILE_OPEN      "&Open..."
#define FILE_CLOSE     "&Close"
#define FILE_SAVE      "&Save"
#define FILE_SAVEAS    "Save &As..."
#define FILE_SAVEALL   "Sav&e All"
#define FILE_PAGESETUP	"Page Set&up..."
#define FILE_PRINT		"&Print..."
#define FILE_INSTALLCONTROLS  "Ins&tall Controls..."
#define FILE_EXIT      "E&xit"

#define EDIT_EDIT      "&Edit"
#define EDIT_UNDO		"&Undo"
#define EDIT_REDO		"&Redo"
#define EDIT_CUT       "Cu&t"
#define EDIT_COPY      "&Copy"
#define EDIT_PASTE     "&Paste"
#define EDIT_PASTESPECIAL  "Paste &Special..."
#define EDIT_CLEAR     "C&lear"
#define EDIT_DELETE    "&Delete"
#define EDIT_SYMBOLS   "&Symbols..."
#define EDIT_SETTABORDER  "Set Tab &Order"

#define VIEW_VIEW		"&View"
#define VIEW_TOOLBARS	"&Toolbars..."

#define SEARCH_SEARCH	"&Search"
#define SEARCH_TOGGLE_BOOKMARK	"Toggle &Bookmark"
#define SEARCH_NEXT_BOOKMARK	"Ne&xt Bookmark"
#define SEARCH_PREV_BOOKMARK	"Pre&vious Bookmark"
#define SEARCH_CLEAR_ALL_BOOK	"&Clear All Bookmarks"


#define RESOURCE_RESOURCE      "&Resource"
#define RESOURCE_NEW           "&New..."
#define RESOURCE_OPEN          "&Open"
#define RESOURCE_OPENBINARY    "Open &Binary Data"
#define RESOURCE_PROPERTIES    "&Properties..."
#define RESOURCE_SETINCLUDES      "Set &Includes..."
#define RESOURCE_IMPORT        "&Import..."
#define RESOURCE_EXPORT        "&Export..."
#define RESOURCE_NEWDEVICE     "New De&vice Image..."
#define RESOURCE_OPENDEVICE    "Open Devi&ce Image..."
#define RESOURCE_DELETEDEVICE  "De&lete Device Image"
#define RESOURCE_CLASS         "Class&Wizard..."
#define RESOURCE_TEST          "&Test"
#define RESOURCE_VIEWASPOPUP	"&View as Popup"	

#define TOOLS_TOOLS				"&Tools"
#define TOOLS_CUSTOMIZE			"&Customize..."

#define  LAYOUT_LAYOUT           "&Layout"
#define  LAYOUT_ALIGN            "&Align Controls"
#define  LAYOUT_ALIGN_LEFT       "&Left"
#define  LAYOUT_ALIGN_RIGHT      "&Right"
#define  LAYOUT_ALIGN_TOP        "&Top"
#define  LAYOUT_ALIGN_BOTTOM     "&Bottom"
#define  LAYOUT_ALIGN_VERT       "&Vert. Center"
#define  LAYOUT_ALIGN_HORZ       "&Horiz. Center"
#define  LAYOUT_SPACE            "&Space Evenly"
#define  LAYOUT_SPACE_ACROSS     "&Across"
#define  LAYOUT_SPACE_DOWN       "&Down"
#define  LAYOUT_CENTER           "&Center in Dialog"
#define  LAYOUT_CENTER_VERT      "&Vertical"
#define  LAYOUT_CENTER_HOR       "&Horizontal"
#define  LAYOUT_ARRANGE          "Arrange &Buttons"
#define  LAYOUT_ARRANGE_RIGHT    "&Right"
#define  LAYOUT_ARRANGE_BOTTOM   "&Bottom"
#define  LAYOUT_SAMESIZE         "&Make Same Size"
#define  LAYOUT_SAMESIZE_WIDTH   "&Width"
#define  LAYOUT_SAMESIZE_HEIGHT  "&Height"
#define  LAYOUT_SAMESIZE_BOTH    "&Both"
#define  LAYOUT_SIZECONTENT      "S&ize to Content"
#define  LAYOUT_GRID             "&Grid Settings..."
#define  LAYOUT_SETTAB           "Set Tab &Order"

#define  IMAGE_IMAGE            "I&mage"
#define  IMAGE_ZOOM             "&Zoom In\Out"
#define  IMAGE_PICKUPCOLOR      "&Pickup Color"
#define  IMAGE_SETHOTSPOT       "Set &Hotspot"
#define  IMAGE_INVERTCOLORS     "&Invert Colors"
#define  IMAGE_FLIPVERTICAL     "Flip &Vertical"
#define  IMAGE_FLIPHORIZONTAL   "Flip Ho&rizontal"
#define  IMAGE_EDITCOLORS       "&Edit Foreground Color..."
#define  IMAGE_GETPALETTE       "Ge&t Palette Colors..."
#define  IMAGE_SAVEPALETTE      "&Save Palette Colors..."
#define  IMAGE_DRAWOPAQUE       "Draw &Opaque"
#define  IMAGE_PIXELGRID        "&Grid Settings..."

#define WINDOW_WINDOW          "&Window"
#define WINDOW_CASCADE         "&Cascade"
#define WINDOW_TILEHORIZONTAL  "&Tile Horizontal"
#define WINDOW_TILEVERTICAL    "Tile &Vertical"
#define WINDOW_ARRANGEICONS    "&Arrange Icons"
#define WINDOW_TOOLBAR         "Tool&bar"
#define WINDOW_STATUSBAR       "&Status Bar"
#define WINDOW_SHOWCONTROLS    "Show &Control Palette"
#define WINDOW_SHOWGRAPHICS    "Show &Graphics Palette"
#define WINDOW_SHOWPROPERTIES  "Show &Properties"
#define WINDOW_HIDECONTROLS    "Hide &Control Palette"
#define WINDOW_HIDEGRAPHICS    "Hide &Graphics Palette"
#define WINDOW_HIDEPROPERTIES  "Hide &Properties"

#define HELP_HELP              "&Help"
#define HELP_SEARCH            "&Search..."
#define HELP_PSS               "&Technical Support"
#define HELP_ABOUTAPPSTUDIO    "&About App Studio..."


#endif //__MENUIDS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\sym\optnlib.h ===
//{{NO_DEPENDENCIES}}
// library manager option control IDs

// 'General' Category IDs
#define OPTNLIB_IDDP_PROJ_LIB	18450
#define OPTNLIB_IDC_LIBOUT		0x4AF0
#define OPTNLIB_IDC_LIBDEF		0x4AF1
#define OPTNLIB_IDC_LIBNOLOGO		0x4AF2
#define OPTNLIB_IDC_N50			0x4B00
#define OPTNLIB_IDC_N51			0x4B01
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\sym\dockids.h ===
///////////////////////////////////////////////////////////////////////////////
//      DOCKIDS.H
//              contains the hard coded IDs for the standard dock windows that will
//              registered by our packages.  Some day we may generate these more
//              dynamically.  Windows based off of IDDW_BASE should be of type dtEdit,
//              all others show up in the Options/Toolbars dialog and are hence
//              considered toolbars in terms of ordering and grouping in the UI.

#ifndef __DOCKIDS_H__
#define __DOCKIDS_H__


// Added by MarcI, taken from sym\shlsrvc.h
#define IDDW_SHELL_BASE         0x7000
#define IDDW_SHELL_MAX			(IDDW_SHELL_BASE + 0x00FF)
#define IDDW_PACKAGE_BASE		(IDDW_SHELL_MAX + 1)
// End addition by MarcI

#define IDDW_BASE               (IDDW_SHELL_BASE)

#define IDDW_SUSHI_BASE         (IDDW_BASE + 0x0000)
#define IDDW_VRES_BASE          (IDDW_BASE + 0x0100)
#define IDDW_VCPP_BASE          (IDDW_BASE + 0x0200)
#define IDDW_VPROJ_BASE         (IDDW_BASE + 0x0300)
#define IDDW_PROJECT_BASE       (IDDW_BASE + 0x0310)
#define IDDW_MSIN_BASE          (IDDW_BASE + 0x0320) // PLEASE LEAVE 30 IDS for MSIN
#define IDDW_MSTEST_BASE                (IDDW_BASE + 0x0350)
#define IDDW_ESPRESSO_BASE              (IDDW_BASE + 0x0358)
#define IDDW_IV_BASE			(IDDW_PACKAGE_BASE + 0x0240)

#define IDTB_BASE               (IDDW_BASE + 0x0400)
#define IDTB_SUSHI_BASE         (IDTB_BASE + 0x0000)
#define IDTB_VRES_BASE          (IDTB_BASE + 0x0100)
#define IDTB_VCPP_BASE          (IDTB_BASE + 0x0200)
#define IDTB_VPROJ_BASE         (IDTB_BASE + 0x0300)
#define IDTB_PROJECT_BASE       (IDTB_BASE + 0x0310)
#define IDTB_MSTEST_BASE                (IDTB_BASE + 0x0320)
#define IDTB_ESPRESSO_BASE              (IDTB_BASE + 0x0328)
#define IDTB_MSIN_BASE          (IDTB_BASE + 0x0340)
#define IDTB_CUSTOM_BASE        (IDTB_BASE + 0x0400)
#define IDTB_PACKAGE_BASE       (IDDW_BASE + 0x0500)

///////////////////////////////////////////////////////////////////////////////
//      SUSHI docked windows.

// Offsets from IDTB_SUSHI_BASE
#define IDTB_SUSHI_STANDARD (IDTB_SUSHI_BASE+1)
#define IDTB_SUSHI_EDIT     (IDTB_SUSHI_BASE+2)
#define IDTB_SUSHI_FULLSCREEN (IDTB_SUSHI_BASE+3)

///////////////////////////////////////////////////////////////////////////////
//      VRES docked windows.

// Offsets from IDTB_VRES_BASE
#define IDTB_VRES_RESOURCE (IDTB_VRES_BASE+3)
#define IDTB_VRES_DIALOG   (IDTB_VRES_BASE+4)
#define IDDW_CONTROLS      (IDTB_VRES_BASE+5)   // Show up in toolbar dialog.
#define IDDW_GRAPHICS      (IDTB_VRES_BASE+6)
#define IDDW_COLORS        (IDTB_VRES_BASE+7)
#define IDDW_TEXTTOOL      (IDTB_VRES_BASE+8)

///////////////////////////////////////////////////////////////////////////////
//      VPROJ docked windows.

// Offsets from IDTB_VPROJ_BASE
#define IDTB_VPROJ_BUILD (IDTB_VPROJ_BASE+0)
#define IDTB_SOURCE_CONTROL     (IDTB_VPROJ_BASE+1)

///////////////////////////////////////////////////////////////////////////////
//      VCPP docked windows.

// Offsets from IDDW_VCPP_BASE
#define IDDW_VCPP_ERROR_WIN      (IDDW_VCPP_BASE+0)
#define IDDW_VCPP_WATCH_WIN      (IDDW_VCPP_BASE+1)
#define IDDW_VCPP_VARIABLES_WIN  (IDDW_VCPP_BASE+2)
#define IDDW_VCPP_CPU_WIN        (IDDW_VCPP_BASE+3)
#define IDDW_VCPP_MEMORY_WIN     (IDDW_VCPP_BASE+4)
#define IDDW_VCPP_CALLS_WIN      (IDDW_VCPP_BASE+5)
//#define IDDW_VCPP_BROWSE_WIN     (IDDW_VCPP_BASE+6)
#define IDDW_VCPP_DISASSY_WIN    (IDDW_VCPP_BASE+7)
#define IDDW_VCPP_BREAKPT_WIN    (IDDW_VCPP_BASE+8)
#define IDDW_VCPP_OLDWATCH_WIN  (IDDW_VCPP_BASE+9)
#define IDDW_VCPP_LOCALS_WIN    (IDDW_VCPP_BASE+10)

// Offsets from IDTB_VCPP_BASE
#define IDTB_VCPP_DEBUG (IDTB_VCPP_BASE+0)
#define IDTB_VCPP_BROWSE (IDTB_VCPP_BASE+1)
#define IDTB_VCPP_MACRO (IDTB_VCPP_BASE+2)

///////////////////////////////////////////////////////////////////////////////
//      PROJECT docked window(s).

// Offsets from IDDW_PROJECT_BASE
#define IDDW_PROJECT            (IDDW_PROJECT_BASE+0)
#define IDDW_GLOBAL				(IDDW_PROJECT_BASE+1)

// Offsets from IDTB_PROJECT_BASE
#define IDTB_PROJECT            (IDTB_PROJECT_BASE+0)

///////////////////////////////////////////////////////////////////////////////
//      MSIN docked window(s).

// Offsets from IDDW_MSIN_BASE
#define IDDW_MSIN               (IDDW_MSIN_BASE+0)
#define IDTB_MSIN               (IDTB_MSIN_BASE+0)
#define IDTB_CONTENTS           (IDTB_MSIN_BASE+1)


///////////////////////////////////////////////////////////////////////////////
//      IV5 docked window(s).
// Package defines actually used in the shell for things like hiding the
// output and topic windows when the Esc key is pressed.  Do not add to these.
#define IDDW_IV                IDDW_IV_BASE
#define IDDW_IVTOPIC          (IDDW_IV_BASE+0)
#define IDDW_IVRESULTS        (IDDW_IV_BASE+1)


///////////////////////////////////////////////////////////////////////////////
//      ClassView/WizardBar docked window(s).

// Offsets from IDTB_PACKAGE_BASE
#define IDTB_CLASSVIEW_WIZBARU      (IDTB_PACKAGE_BASE+0x0288)


#endif  // __DOCKIDS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\sym\optnmtl.h ===
//{{NO_DEPENDENCIES}}
// resource compiler control IDs

// 'General' Category IDs
#define OPTNMTL_IDDP_PROJ_MKTYPLIB	18448
#define OPTNMTL_IDC_MTLINCLUDES		0x4B02
#define OPTNMTL_IDC_MTLMACROS		0x4B03
#define OPTNMTL_IDC_MTLOUTPUTTLB	0x4B04
#define OPTNMTL_IDC_MTLOUTPUTINC	0x4B05
#define OPTNMTL_IDC_MTLNOLOGO		0x4B06
#define OPTNMTL_IDC_MTLTEXT1		0x4B07
#define OPTNMTL_IDC_MTLTEXT2		0x4B08
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\sym\optnlink.h ===
//{{NO_DEPENDENCIES}}
// linker option control IDs

// 'General' Category IDs
#define OPTNLINK_IDDP_PROJ_LINKER		18444
#define OPTNLINK_IDC_PROFILE			0x4A41

// 'Debug' Category IDs
#define OPTNLINK_IDDP_LINKER_DEBUG			18445
#define OPTNLINK_IDC_MAPNAME			0x4A50
#define OPTNLINK_IDC_MAPGEN			0x4A51
#define OPTNLINK_IDC_LNK_DBGFULL     0x4A52
#define OPTNLINK_IDC_LNK_DBGCV		0x4A53
#define OPTNLINK_IDC_LNK_DBGCOFF		0x4A54
#define OPTNLINK_IDC_LNK_DBGBOTH		0x4A55
#define OPTNLINK_IDC_TXT_MAPNAME		0x4A60
#define OPTNLINK_IDC_TXT_DBGGRP		0x4A61

// 'Input' Category IDs
#define OPTNLINK_IDDP_LINKER_INPUT		18447
#define OPTNLINK_IDC_LIBS		0x4A90
#define OPTNLINK_IDC_EXLIB		0x4A91
#define OPTNLINK_IDC_IGNLIBS		0x4A92
#define OPTNLINK_IDC_INCLSYM		0x4A93
#define OPTNLINK_IDC_STUB		0x4A94
#define OPTNLINK_IDC_TXT_LIBS	0x4AA0
#define OPTNLINK_IDC_TXT_IGNLIBS	0x4AA1
#define OPTNLINK_IDC_TXT_INCLSYM	0x4AA2
#define OPTNLINK_IDC_TXT_STUB	0x4AA3

// 'Customize' Category IDs
#define OPTNLINK_IDDP_LINKER_CUSTOM	18449
#define OPTNLINK_IDC_VERBOSE		0x4AD0
#define OPTNLINK_IDC_LINKNOLOGO	0x4AD1
#define OPTNLINK_IDC_PDBNAME		0x4AD2
#define OPTNLINK_IDC_USEPDB		0x4AD3
#define OPTNLINK_IDC_INCLINK		0x4AD4
#define OPTNLINK_IDC_FORCE		0x4AD5
#define OPTNLINK_IDC_OUT			0x4AD6
#define OPTNLINK_IDC_TXT_PERF	0x4AE0
#define OPTNLINK_IDC_TXT_PDBNAME	0x4AE1
#define OPTNLINK_IDC_TXT_OUTNAME	0x4AE2

// 'Win32 Output' Category IDs
#define OPTNLINK_IDDP_LINKER_WIN32_OUTPUT	18446
#define OPTNLINK_IDC_BASEADDR		0x4A70
#define OPTNLINK_IDC_ENTRYPOINT		0x4A71
#define OPTNLINK_IDC_STACKRESERVE	0x4A72
#define OPTNLINK_IDC_STACKCOMMIT		0x4A73
#define OPTNLINK_IDC_VERMAJOR		0x4A74
#define OPTNLINK_IDC_VERMINOR		0x4A80
#define OPTNLINK_IDC_TXT_BASE		0x4A81
#define OPTNLINK_IDC_TXT_ENTRY		0x4A82
#define OPTNLINK_IDC_TXT_STACKGRP	0x4A83
#define OPTNLINK_IDC_TXT_STK_RES		0x4A84
#define OPTNLINK_IDC_TXT_STK_COM		0x4A85
#define OPTNLINK_IDC_TXT_VERGRP		0x4A86
#define OPTNLINK_IDC_TXT_VERMAJ		0x4A87
#define OPTNLINK_IDC_TXT_VERMIN		0x4A88
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\sym\optnrc.h ===
//{{NO_DEPENDENCIES}}
// resource compiler control IDs

// 'General' Category IDs
#define OPTNRC_IDDP_PROJ_RESCOMPILE 18442
#define OPTNRC_IDC_RESIGNPATH	0x4A31
#define OPTNRC_IDC_RESOUTNAME	0x4A32
#define OPTNRC_IDC_RESINCLUDES	0x4A33
#define OPTNRC_IDC_RESMACNAMES	0x4A34
#define OPTNRC_IDC_RESLANGID	0x4A35
#define OPTNRC_IDC_REST1	0x4A40
#define OPTNRC_IDC_REST2	0x4A41
#define OPTNRC_IDC_REST3	0x4A42
#define OPTNRC_IDC_REST4	0x4A43
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\sym\parseres.c ===
/*
    parseress.c                                                 1/18/94

    Usage:  parseres infile outfile

    Purpose:  General frame for performing a conversion on a file on a
              per line basis, output goes to the outfile.  A filter.

              If outfile is unspecified, output go to stdout by default.

			  Specifically, this utility parses out #define strings
			  which appear as the first token
*/
//#define	_MBCS
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <stdarg.h>
#include <tchar.h>

void main(int,char*[]);
void usage(void);
void mainline(void);
void parse_command_line(int,char*[]);
void initialize_globals(void);
int  getline(void);
TCHAR *get_basename(TCHAR *);
FILE *openfile(TCHAR *,char *);
void open_input(void);
void open_output(void);
void close_input(void);
void close_output(void);
void error(char *,char *,...);
void user_error(int,char *,char *,...);

#define     BUF_SIZE      1024
#define     MAX_FIELDS      50

/*
    These extensions should not exceed 3 characters in length, most
    filesystems on an Intel based computer do not support file extensions
    greater than 3 characters.
*/
#define     INFILE_DEFAULT_EXT      _T("in")
#define     OUTFILE_DEFAULT_EXT     _T("out")

/*
    Variables used with _splitpath(), in get_basename().
*/
TCHAR drive[ _MAX_DRIVE ];
TCHAR dir  [ _MAX_DIR   ];
TCHAR bname[ _MAX_FNAME ];
TCHAR ext  [ _MAX_EXT ];

FILE    *fin, *fout;

short   verbose;                        // verbose flag

TCHAR    buf[BUF_SIZE], tbuf[BUF_SIZE], outbuf[BUF_SIZE];
TCHAR    *prefix_string;

TCHAR    *input_file;
TCHAR    *output_file;
TCHAR    *program_name;

void main( int argc, char *argv[] )
{
program_name = argv[0];
if( argc < 2 ) usage();

initialize_globals();

parse_command_line( argc, argv );

mainline();


} /* main */


void usage()
{
_tprintf( "Usage:  %s <switches> infile outfile \n", program_name );
_tprintf( "        [-hs?]\n" );
_tprintf( "        s     prefix string         Prepend to macronames.\n" );
// _tprintf( "        v     verbose\n" );
_tprintf( "        h, ?  help                  This text.\n\n" );
_tprintf( "        If outfile is omitted, then output is sent to stdout.\n\n" );
_tprintf( "    This utility will parse through a text file searching for \"#define\"\n" );
_tprintf( "strings.  If found, the \"prefix string\" will be prepended on the macro name.\n" );
_tprintf( "The insertion occurs only if the #define string is the first token on the line.\n" );

exit( 0 );

} /* usage */


void mainline()
{
open_input();
open_output();

while( getline() )
    {
    /*
        Code to tokenize a line into individual fields.  Uncomment to use.
    */
    TCHAR *field_delimeters = _T(" \t\n");
    TCHAR *t, *token0, *token1;
	int  line_length = _tcslen( buf );		// Line length of current buf, in TCHAR's

	_tcscpy( outbuf, buf );
	
	token0 = buf+_tcsspn( buf, field_delimeters );	// Consume any initial delimeters
	if( *token0 != '\0' )
		{
    	t = _tcspbrk( token0, field_delimeters );    // Get the first token
		/*
			Case of #define
		*/
		if( *token0 != '\0' && !_tcsncmp( token0, _T( "#define" ), 7 ) )
			{
			/*
				First token is "#define"
			*/
			token1 = t+_tcsspn( t, field_delimeters );	// Consume any initial delimeters
			if( *token1 != '\0' )
				{
				_tcsncpy( outbuf, buf, token1-buf-1 );// Copy up to macroname to the output buffer
				*(outbuf+(token1-buf)) = '\0';		// Add the null terminator
				_tcscat( outbuf, prefix_string );	// Append the prefix_string
 				_tcscat( outbuf, token1 );			// Append the macroname and rest of string
				}
			}
	 	}
    _ftprintf( fout, "%s", outbuf );
    }

close_input();
close_output();


} /* mainline */


void parse_command_line( int argc, char *argv[] )
{
TCHAR   *p;
int     i = 0;
short   input_file_set  = 0;
short   output_file_set = 0;

while( ++i, (p = argv[ i ]) != NULL )
    {
    if( *p == _T('-') || *p == _T('/') )
        {
        switch( *(p+sizeof(TCHAR)) )
            {
            case 's': prefix_string = argv[++i];
					  if( prefix_string == NULL )
					      user_error( 3, "%s", "No prefix string specified.\n" );

				      if( verbose )
                          _tprintf( "parse_command_line(): prefix_string = %s\n", prefix_string );
                      break;
/*
            case 'v': verbose = 1;
                      _tprintf( "parse_command_line( argc = %d, *argv[] ):  "
                          "Enter function.\n", argc );
                      break;
*/
            case '?':
            case 'h': usage();

            default:
                _ftprintf( stderr, "Warning: Unknown switch '%s' ignored.\n", p );
            } /* switch */

        }
    else
        {
        /* TCHAR *p;        This variable conflicts with 'p' in this fct. */

        _tcscpy( buf, argv[i] );

        if( (p = _tcschr( buf, _T('.') )) == NULL )
            {
            _tcscat( buf, _T(".") );

            if( !input_file_set )
                _tcscat( buf, INFILE_DEFAULT_EXT );
            else if( !output_file_set )
                _tcscat( buf, OUTFILE_DEFAULT_EXT );
            }

        if( !input_file_set )
            {
            input_file = _tcsdup( buf );
            input_file_set = 1;
            }
        else if( !output_file_set )
            {
            output_file = _tcsdup( buf );
            output_file_set = 1;
            }

        /*
            Uncomment to use the input file's basename for your output file.
			NOTE:  basename uses splitpath(), which is not MBCS enabled!

        p = get_basename( buf );
        p = _tcschr( buf, _T('.') );

        _tcscpy( p, _T(".") );
        _tcscat( p, OUTFILE_DEFAULT_EXT );

        output_file = _tcsdup( buf );
        */
        }
    }

if( !input_file_set )
    user_error( 2, "%s", "No input file specified.\n" );

if( verbose )
    _tprintf( "parse_command_line():  Exit function.\n" );

} /* parse_command_line */



/*
    Initialize global variables
*/
void initialize_globals()
{
verbose = 0;                            // clear verbose flag

input_file      = NULL;
output_file     = NULL;

prefix_string   = "";


} /* initialize_globals */


int getline()
{
TCHAR *eof;

#ifdef _MBCS
eof = _fgetts( buf, BUF_SIZE-1, fin );
#else
eof = fgets( buf, BUF_SIZE-1, fin );
#endif

if( eof == NULL )
    {
    return 0;
    }
return 1;

} /* getline */


TCHAR *get_basename( TCHAR *path )
{
_splitpath( path, drive, dir, bname, ext );

#if VERBOSE
printf( "get_basename: %s\n", bname );
#endif

return bname;

} /* get_basename */


FILE *openfile( TCHAR *fname, char *mode )
{
FILE *fp;

fp = fopen( fname, mode );
if( fp == NULL )
    error( "openfile", "Could not open \"%s\" with mode %s.\n", fname, mode );

return fp;

} /* openfile */


void open_input()
{
if( verbose )
    _tprintf( "open_input():  input_file = \"%s\"\n", input_file );

fin = openfile( input_file, "r" );

} /* open_input */


void open_output()
{
if( verbose )
    _tprintf( "open_output():  output_file = \"%s\"\n",
        output_file == NULL
            ? "stdout"
            : output_file );

fout = output_file != NULL ? fopen( output_file, "w" ) : stdout;

if( fout == NULL )
    {
    user_error( 1, "Could not open '%s' with write priviliges.",
        output_file );
    }

} /* open_output */


void close_input()
{
fclose( fin );

} /* close_input */


void close_output()
{
fclose( fout );

} /* close_output */


void error( char *funcname, char *format, ... )
{
static char error_buf[256];     // error messages
va_list arg_ptr;

va_start( arg_ptr, format );

#ifdef  DEBUG
_stprintf( error_buf, "%s():  Error -> %s\n", funcname, format );
#else
_stprintf( error_buf, "Error -> %s\n", format );
#endif

_vftprintf( stderr, error_buf, arg_ptr );

va_end( arg_ptr );

exit( -1 );                     // die

} /* error */


void user_error( int error_no, char *funcname, char *format, ... )
{
static char error_buf[256];     // error messages
va_list arg_ptr;

va_start( arg_ptr, format );

#ifdef  DEBUG
_stprintf( error_buf, "%s():  Error(%d) -> %s\n", funcname, error_no, format );
#else
_stprintf( error_buf, "Error(%d) -> %s\n", error_no, format );
#endif

_vftprintf( stderr, error_buf, arg_ptr );

va_end( arg_ptr );

exit( error_no );

} /* user_error */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\sym\qcqp.h ===
///////////////////////////////////////////////////////////////////////////////
//	QCQP.H
//
//	Created by :			Date :
//		DavidGa					10/13/93
//
//	Description :
//		IDs for dockable windows, not found in dockids.h
//

#ifndef __QCQP_H__
#define __QCQP_H__

#include "dockids.h"

#ifndef IDDW_VCPP_BASE
	#error include 'dockids.h' before including this file
#endif

// the following are ids for the dockable windows
// I've munged this together from information in
// qcqp.c and qcqp.h (BrianCr)

#define IDW_OUTPUT_WIN	(IDDW_VCPP_BASE + 0)
#define IDW_WATCH_WIN	(IDDW_VCPP_BASE + 1)
#define IDW_LOCALS_WIN	(IDDW_VCPP_BASE + 2)
#define IDW_CPU_WIN		(IDDW_VCPP_BASE + 3)
#define IDW_MEMORY_WIN	(IDDW_VCPP_BASE + 4)
#define IDW_CALLS_WIN	(IDDW_VCPP_BASE + 5)
#define IDW_BROWSE_WIN	(IDDW_VCPP_BASE + 6)
#define IDW_DISASSY_WIN	(IDDW_VCPP_BASE + 7)
#define IDW_BREAKPT_WIN	(IDDW_VCPP_BASE + 8)

#endif //__QCQP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\sym\shrdres.h ===
#ifndef __SHRDRES_H__
#define SHRDRES___SHRDRES_H__

/////////////////////////////////////////////////////////////////////////////
// ID ranges assigned to packages for resources and string IDs
//

//  Sample Package
#define SHRDRES_MIN_SAMPLE_RESOURCE_ID	0
#define SHRDRES_MAX_SAMPLE_RESOURCE_ID	499

//
// *External Packages
//
//	Espresso
#define SHRDRES_MIN_ESPRESSO_RESOURCE_ID 12000
#define SHRDRES_MAX_ESPRESSO_RESOURCE_ID 12999
//  Test
#define SHRDRES_MIN_TEST_RESOURCE_ID	13000
#define SHRDRES_MAX_TEST_RESOURCE_ID	13999
//  Fortran
#define SHRDRES_MIN_FORTRAN_RESOURCE_ID	14000
#define SHRDRES_MAX_FORTRAN_RESOURCE_ID	14999

//
// Internal Packages
//
//  Build package
#define SHRDRES_MIN_BUILD_RESOURCE_ID	16000
#define SHRDRES_MAX_BUILD_RESOURCE_ID	16999
// App wizard
#define SHRDRES_MIN_APP_WIZARD_ID		17000
#define SHRDRES_MAX_APP_WIZARD_ID		17499
// Class wizard
#define SHRDRES_MIN_CLASS_WIZARD_ID		17500
#define SHRDRES_MAX_CLASS_WIZARD_ID		17999

//  Shell
#define SHRDRES_MIN_SHARED_RESOURCE_ID	20000
#define SHRDRES_MAX_SHARED_RESOURCE_ID	20199
#define SHRDRES_MIN_EXE_RESOURCE_ID		20200
#define SHRDRES_MAX_EXE_RESOURCE_ID		20299
#define SHRDRES_MIN_SHELL_RESOURCE_ID	20300
#define SHRDRES_MAX_SHELL_RESOURCE_ID	21999
//  Object Gallery
#define SHRDRES_MIN_GALLERY_RESOURCE_ID	22000
#define SHRDRES_MAX_GALLERY_RESOURCE_ID	22499

//  VBA
#define SHRDRES_MIN_VBA_RESOURCE_ID 	23000
#define SHRDRES_MAX_VBA_RESOURCE_ID 	23999
//  Source
#define SHRDRES_MIN_SOURCE_RESOURCE_ID	24000
#define SHRDRES_MAX_SOURCE_RESOURCE_ID	25951
//  CPP LangPackage
#define SHRDRES_MIN_CPP_RESOURCE_ID		25952
#define SHRDRES_MAX_CPP_RESOURCE_ID		25999
//  Resource package
#define SHRDRES_MIN_RES_RESOURCE_ID 	26000
#define SHRDRES_MAX_RES_RESOURCE_ID 	27999
//  MSIN
#define SHRDRES_MIN_MSIN_RESOURCE_ID	29000
#define SHRDRES_MAX_MSIN_RESOURCE_ID	29999
//  Proj
#define SHRDRES_MIN_PROJECT_RESOURCE_ID	31000
#define SHRDRES_MAX_PROJECT_RESOURCE_ID	31999
//  ClsView
#define SHRDRES_MIN_CLSVIEW_RESOURCE_ID	32000
#define SHRDRES_MAX_CLSVIEW_RESOURCE_ID	32100

/////////////////////////////////////////////////////////////////////////////

//
// IDs for shared resources.
//

// Dialog controls
#define SHRDRES_IDC_CAPTION                     102
#define SHRDRES_IDC_RIGHT_ARROW                 103
#define SHRDRES_IDC_SIZE_BAR_HORZ               104
#define SHRDRES_IDC_ID_CAP                      221
#define SHRDRES_IDC_ID                          222
#define SHRDRES_IDC_SCC_STATUS                  16830
#define SHRDRES_IDC_SCC_STATUS_TEXT             16831

// Resources
#define SHRDRES_IDR_MAINFRAME                   20000

#define SHRDRES_IDB_SPLASH                      20001
#define SHRDRES_IDB_SPLASH16                    20002
#define SHRDRES_IDB_ABOUT                       20003

#define SHRDRES_IDD_ABOUTBOX                    20001
#define SHRDRES_IDD_GOTODIALOG                  20002
#define SHRDRES_IDD_PUSHPIN_DIALOGBAR           20003
#define SHRDRES_IDD_GOTODLG						20004

// Strings
#define SHRDRES_IDS_DEBUG_CONFIG				20001
#define SHRDRES_IDS_RELEASE_CONFIG				20002
#define SHRDRES_IDS_UNDO_PROPEDIT               20003
#define SHRDRES_IDS_UNDO_MOVE                   20004
#define SHRDRES_IDS_UNDO_COPY                   20005
#define SHRDRES_IDS_UNDO_PASTE                  20006
#define SHRDRES_IDS_UNDO_CUT                    20007
#define SHRDRES_IDS_UNDO_DELETE                 20008
#define SHRDRES_IDS_ABOUTTITLE                  20009
#define SHRDRES_IDS_COPYRIGHT                   20010
#define SHRDRES_IDS_PRODUCTLICENSEDTO           20011
#define SHRDRES_IDS_SERIALNUMBER                20012
#define SHRDRES_IDS_ADDITIONS                   20013
#define SHRDRES_IDS_MAC_ADDON                   20014
#define SHRDRES_IDS_WARNING1                    20015
#define SHRDRES_IDS_WARNING2                    20016
#define SHRDRES_IDS_WARNING3                    20017
#define SHRDRES_IDS_WARNING4                    20018
#define SHRDRES_IDS_WARNING5                    20019
#define SHRDRES_IDS_WARNING6                    20020
#define SHRDRES_IDS_WARNING7                    20021
#define SHRDRES_IDS_NOMATHCHIP                  20022
#define SHRDRES_IDS_HASMATHCHIP                 20023
#define SHRDRES_IDS_FMTFREESPACE                20024
#define SHRDRES_IDS_UNAVAILABLE                 20025
#define SHRDRES_IDS_FMTAVAILMEM                 20026
#define SHRDRES_IDS_CANT_LOAD_PACKAGE           20027
#define SHRDRES_IDS_CANT_LOAD_MAC               20028
#define SHRDRES_IDS_LICENSEDTO                  20029
#define SHRDRES_IDS_GENERAL                     20030
#define SHRDRES_IDS_STYLES						20031
#define SHRDRES_IDS_EXSTYLES					20032

// DocTemplateID's (strings and icons)
#define SHRDRES_IDR_RC_TEMPLATE                 20048
#define SHRDRES_IDR_RCT_TEMPLATE                20049
#define SHRDRES_IDR_RES_TEMPLATE                20050
#define SHRDRES_IDR_EXE_TEMPLATE                20051
#define SHRDRES_IDR_PE_TEMPLATE                 20052
#define SHRDRES_IDR_BIN_TEMPLATE                20053
#define SHRDRES_IDR_BMP_TEMPLATE                20054
#define SHRDRES_IDR_CUR_TEMPLATE                20055
#define SHRDRES_IDR_ICO_TEMPLATE                20056
#define SHRDRES_IDR_TEXT_TEMPLATE               20057
#define SHRDRES_IDR_BSC_TEMPLATE                20058
#define SHRDRES_IDR_PRJ_TEMPLATE                20059
#define SHRDRES_IDR_PRJWKS_TEMPLATE             20060
#define SHRDRES_IDR_MSIN_TEMPLATE               20061

#endif //__SHRDRES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\sym\projprop.h ===
// Sushi Project Properties

#ifndef __PROJPROP__
#define __PROJPROP__

//
// CSlob notitifications
//
// Disable passing on of OnInform messages
#define SN_HOLD_UPDATES 8
// Re-enable OnInform messages. Assume property based caches must be refreshed.
#define SN_RELEASE_UPDATES 9
// Re-enable OnInform messages. Do not update cached info or set dirty state.
#define SN_RELEASE_UPDATES_NO_CHANGES 10
#define SN_PARENT_PROPERTY 11	// Some property of a parents parent changed.
#define SN_SAVED        12		// Slob was just serialized
// Filename that slob is saved in has changed
// (not a property since its not undoable)
#define SN_FILE_NAME    13
#define SN_LOADED       14		// Slob was just deserialized
#define SN_DIRTY        15		// Slob state force to clean
#define SN_CLEAN        16		// Slob state forced to dirty
#define SN_NEW_TREE     17		// Slob's tree has moved, ie the Slob's container
#define SN_DESTROY_OPTNODE	18	// Destroying an option tree node
#define SN_DESTROY_CONFIG   19  // Destroying a config

//
//	Special properties for build items (should be move to PROPS.H).
//	These are deivded into two sets: private props that get written into the
//	VCP file and public props that go in the make file:
//
#define PROJ_PROPS						1500
#define PROJ_PRIVATE_FIRST				PROJ_PROPS

#define P_BuildExcluded       			PROJ_PROPS + 2		// Per-config (currently NYI)
#define P_BuildFrozen       			PROJ_PROPS + 3		// Per-config (currently NYI)
#define P_BuildLocked					PROJ_PROPS + 4		// Per-config (currently NYI)
#define P_ExtOpts_CmdLine				PROJ_PROPS + 5		// Per-config, ext. makefiles only
#define P_ExtOpts_RebuildOpt			PROJ_PROPS + 6		// Per-config, ext. makefiles only
#define P_ExtOpts_Targ					PROJ_PROPS + 7		// Per-config, ext. makefiles only
#define P_ExtOpts_BscName				PROJ_PROPS + 8		// Per-config, ext. makefiles only
#define P_ExtOpts_Platform				PROJ_PROPS + 9		// Per-config, ext. makefiles only	// "Win32 (80x86), "Macintosh (680x0), etc.
//#define P_ExtOpts_ClsWzdName			PROJ_PROPS + 10		// Per-config, ext. makefiles only
#define P_ProjActiveConfiguration		PROJ_PROPS + 11		// Only CProject object has this
#define P_Caller						PROJ_PROPS + 12		// Per-config
#define P_Args							PROJ_PROPS + 13		// Per-config
#define P_PromptForDlls					PROJ_PROPS + 14  	// Per-config
#define P_RemoteTarget					PROJ_PROPS + 15		// Per-config
#define P_WorkingDirectory				PROJ_PROPS + 16		// Per-config
#define P_ItemOptState					PROJ_PROPS + 17  	// Per-config
#define P_ExtOpts_WorkingDir			PROJ_PROPS + 18 		// Per-config, ext. makefiles only


#define PROJ_PRIVATE_LAST				PROJ_PROPS + 49

//
// Properties in this range are NOT per configuration.
//
#define PROJ_NOT_PER_CONFIG_FIRST		PROJ_PROPS + 50

#define P_GroupName						PROJ_NOT_PER_CONFIG_FIRST + 0
#define P_ProjTargetLastScanned			PROJ_NOT_PER_CONFIG_FIRST + 1
#define P_TargetName					PROJ_NOT_PER_CONFIG_FIRST + 2	

#define P_ProjSccProjName				PROJ_NOT_PER_CONFIG_FIRST + 3
#define P_ProjSccProjAux				PROJ_NOT_PER_CONFIG_FIRST + 4

#define PROJ_NOT_PER_CONFIG_LAST		PROJ_PROPS + 75

//
// Properties in this range are PER CONFIGURATION
// (meaning they go into property bags).
//
#define PROJ_PER_CONFIG_FIRST		PROJ_PROPS + 76

#define P_ProjConfiguration			PROJ_PER_CONFIG_FIRST + 0	// Only CProject object has this
#define P_ProjOriginalType			PROJ_PER_CONFIG_FIRST + 1	// Only CProject object has this
#define P_OutDirs_Intermediate		PROJ_PER_CONFIG_FIRST + 2
#define P_OutDirs_Target			PROJ_PER_CONFIG_FIRST + 3
#define P_ItemExcludedFromBuild		PROJ_PER_CONFIG_FIRST + 4 	// All CProjItems have this
#define P_GroupHasPerGroupFlags		PROJ_PER_CONFIG_FIRST + 5	// Only CProjGroup objects have this
#define P_ProjUseMFC				PROJ_PER_CONFIG_FIRST + 6	// Only CProject object has this
#define P_UseDebugLibs				PROJ_PER_CONFIG_FIRST + 7	// Only CProject object has this
#define P_Proj_CmdLine				PROJ_PER_CONFIG_FIRST + 8	// Only CProject object has this (on external targets)
#define P_Proj_RebuildOpt			PROJ_PER_CONFIG_FIRST + 9	// Only CProject object has this (on external targets)
#define P_Proj_Targ					PROJ_PER_CONFIG_FIRST + 10	// Only CProject object has this (on external targets)
#define P_Proj_BscName				PROJ_PER_CONFIG_FIRST + 11	// Only CProject object has this (on external targets)
//#define P_Proj_WorkingDir           PROJ_PER_CONFIG_FIRST + 12  // Only CProject object has this
#define P_ProjClsWzdName			PROJ_PER_CONFIG_FIRST + 12  // Only CProject object has this
#define P_Proj_TargDefExt			PROJ_PER_CONFIG_FIRST + 13	// Only CProject object has this
#define P_Proj_TargDir				PROJ_PER_CONFIG_FIRST + 14	// Only CProject object has this

#define NoUseMFC					0 // not using MFC
#define UseMFCInLibrary				1 // using MFC by static link eg. nafxcwd.lib
#define UseMFCInDll					2 // using MFC in shared DLL eg. mfc300d.dll
#define UseMFCDefault				UseMFCInDll // default

#define PROJ_PER_CONFIG_UNKNOWN			PROJ_PROPS + 150
#define PROJ_PER_CONFIG_LAST			PROJ_PROPS + 399
#define PROJ_OPT_UNKNOWN				PROJ_PROPS + 400

// Build system option handler components are allocated a property range
// where all ids in the range are >= PROJ_BUILD_OPTION_FIRST and < PROJ_BUILD_OPTION_PRIVATE_FIRST
// There are PROJ_BUILD_OPTION_RANGE props that can be allocated
#define PROJ_BUILD_OPTION_FIRST			PROJ_OPT_UNKNOWN + 100
#define PROJ_BUILD_OPTION_PRIVATE_FIRST 0x8000
#define PROJ_BUILD_OPTION_RANGE			PROJ_BUILD_OPTION_PRIVATE_FIRST - PROJ_BUILD_OPTION_FIRST
// Deferred tool option props.
// 0 = Don't defer, 1 = Defer, 2 = Never build
#define P_DeferredMecr					PROJ_BUILD_OPTION_PRIVATE_FIRST + 0
#define P_DeferredBscmake				PROJ_BUILD_OPTION_PRIVATE_FIRST + 1
#define PROJ_BUILD_OPTION_PRIVATE_LAST	PROJ_BUILD_OPTION_PRIVATE_FIRST + 99

#define PROJ_BUILD_OPTION_LAST			PROJ_BUILD_OPTION_FIRST + PROJ_BUILD_OPTION_RANGE + 100 

//
// General properties
//
#define PROJ_GENERAL					PROJ_BUILD_OPTION_LAST + 1

//
// Tool Component Props
//
#define P_CompName					PROJ_GENERAL + 0
#define P_ToolExeName				PROJ_GENERAL + 1
#define P_ToolMenuText				PROJ_GENERAL + 2
#define P_ToolPerProject			PROJ_GENERAL + 3
#define P_ToolInternal				PROJ_GENERAL + 4
#define P_ToolInput					PROJ_GENERAL + 5
#define P_ToolOutput				PROJ_GENERAL + 6
#define P_ToolCommand				PROJ_GENERAL + 7
#define P_ToolPrefix				PROJ_GENERAL + 8
#define P_CustomDescription			PROJ_GENERAL + 9
#define P_CustomOutputSpec			PROJ_GENERAL + 10
#define P_CustomCommand				PROJ_GENERAL + 11
#define PROJ_BUILD_TOOL_FIRST		P_CompName
#define PROJ_BUILD_TOOL_LAST		P_CustomCommand

#define PROJ_GENERAL_LAST			PROJ_GENERAL + 99

//
// Faked properties
//
#define PROJ_FAKE					PROJ_GENERAL_LAST + 1
#define P_ProjItemName				PROJ_FAKE + 0
#define P_ProjItemIconWell			PROJ_FAKE + 1
#define P_ProjItemIconIdx			PROJ_FAKE + 2
#define P_ProjItemFullPath			PROJ_FAKE + 3
#define P_ProjItemDate				PROJ_FAKE + 4
#define P_ProjMainTarget			PROJ_FAKE + 5
#define P_ProjMainTargetDate		PROJ_FAKE + 6
#define P_ProjAppWizUseMFC			PROJ_FAKE + 7
#define P_ItemOptChanged			PROJ_FAKE + 8
#define P_BldrFileName				PROJ_FAKE + 9

//
// Target reference name
#define P_TargetRefName				PROJ_FAKE + 10

//
// Tools property page
#define P_ItemTools					PROJ_FAKE + 11
#define P_ItemSettings				PROJ_FAKE + 12
#define P_ItemInput					PROJ_FAKE + 13
#define P_ItemOutput				PROJ_FAKE + 14
#define P_ItemDependency			PROJ_FAKE + 15

#ifdef _DEBUG
// These props are used to support the "project info" prop pages (debug only).
#define P_D_Target					PROJ_FAKE + 90
#define P_D_PropList				PROJ_FAKE + 91
#define P_D_PropType				PROJ_FAKE + 92
#define P_D_PropValue				PROJ_FAKE + 93
#define P_D_PropBag					PROJ_FAKE + 94
#endif

#if !defined(_SHIP)
// These props are used exclusively by QA to inquire about project item props.
#define P_QA_ProjItemType			PROJ_FAKE + 95
#define QA_TypeIs_Target			0
#define QA_TypeIs_Group				1
#define QA_TypeIs_File				2
#define QA_TypeIs_DepGroup			3
#define QA_TypeIs_DepFile			4
#endif

#define PROJ_FAKE_LAST				PROJ_FAKE + 99

//
// Properties for the CBuildSlobs & CBuildViewSlobs
//
// REVIEW (colint): These should be moved elsewhere

#define PROJ_BLDSLOB                PROJ_FAKE_LAST
#define P_ConfigName                PROJ_BLDSLOB + 0

#define PROJ_BLDSLOB_LAST           PROJ_BLDSLOB + 99

//
// Scecial props that get read in, but never written:
//
#define P_ProjMarkedForScan			PROJ_BLDSLOB_LAST + 1
#define P_ProjMarkedForSave			PROJ_BLDSLOB_LAST + 2
#define P_ProjHasNoVCPFile			PROJ_BLDSLOB_LAST + 3

// Helper functions for determining what kind of prop something is:
__inline BOOL IsPropPrivate(int nProp)
{
	// o in our private range?
	// o one of our tool option private props?
	if ((nProp >= PROJ_PRIVATE_FIRST && nProp <= PROJ_PRIVATE_LAST) ||
		(nProp >= PROJ_BUILD_OPTION_PRIVATE_FIRST && nProp <= PROJ_BUILD_OPTION_PRIVATE_LAST))
		return TRUE;	// private

	return FALSE; // public
}

__inline BOOL IsPropPublic(int nProp)
{
	// is this not in  our private range?
	if (nProp > PROJ_PRIVATE_LAST && nProp <= PROJ_GENERAL_LAST)
	{
		// make sure it's not a tool option private prop!
		if (nProp >= PROJ_BUILD_OPTION_PRIVATE_FIRST && nProp <= PROJ_BUILD_OPTION_PRIVATE_LAST)
			return FALSE;	// private!

		return TRUE;	// public
	}

	return FALSE;	// private
}

#endif // __PROJPROP__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\sym\props.h ===
/////////////////////////////////////////////////////////////////////////////
//	PROPS.H
//		Resource editor property IDs

#define P_QuoteValue                131
#define P_FullTitle			        132
#define P_ClsWizTitle		        133	// For ClassWiz/Res interaction.
#define P_String    		        136
#define P_Preload    		        137
#define P_Moveable    		        138
#define P_Discardable               139
#define P_Pure                      140
#define P_Preview					141
#define P_Autolayout	            300
#define P_Wrap			            301
#define P_Border		            302
#define P_LeftMargin	            303
#define P_TopMargin		            304
#define P_RightMargin	            305
#define P_BottomMargin	            306
#define P_Columns		            307
#define P_WindowStyle	            308
#define P_Caption		            312
#define P_Popup			            313
#define P_Separator		            314
#define P_Checked		            315
#define P_Inactive		            316
#define P_Break			            317
#define P_Help			            318
#define P_MenuBar		            319
#define P_Default    	            320
#define P_HorizontalAlignment       321
#define P_VerticalAlignment         322
#define P_AutoSizeToContent         323
#define P_ShowKeyboardShortcuts     324
#define P_Grayed		            325
#define P_ShowPropertyWindow        326
#define P_ShowControlPalette        327
#define P_DetectDuplicateIDs        328
#define P_BuildOnSave	            329
#define P_DefaultHelpContext        330
#define P_MinimumResourceID         331
#define P_MinimumCommandID          332
#define P_MinimumStringID           333
#define P_MinimumAcceleratorID      334
#define P_OwnerDraw		            336
#define P_DefaultButton	            337
#define P_InitiallyChecked          338
#define P_Order			            339
#define P_CaptionLocation           340
#define P_DropHeight	            341
#define P_Position		            342
#define P_LogUndo		            344
#define P_Image			            345
#define P_Width			            346
#define P_Height		            347
#define P_Colors		            348
#define P_Hotspot		            349
#define P_Size			            350
#define P_Compressed	            351
#define P_Ctrl			            352
#define P_Alt			            353
#define P_Shift			            354
#define P_Type			            355
#define P_Key			            357
#define P_HelpID                    359
#define P_Visible                   360
#define P_Disabled                  361
#define P_Group                     362
#define P_Tabstop                   363
#define P_TextAlign 	            364
#define P_NoPrefix		            365
#define P_NoWrap		            366
#define P_GfxType		            367
#define P_GfxColor		            368
#define P_GfxIcon		            369
#define P_Auto			            370
#define P_LeftText		            371
#define P_3State		            372
#define P_Context		            374
#define P_FontFace		            375
#define P_FontSize		            376
#define P_Menu			            377
#define P_Choices		            378
#define P_NewItem		            379
#define P_KeyValue		            380
#define P_BtnIcon		            381
#define P_BtnBitmap		            382
#define P_Flat			            383
#define P_HAlign		            384
#define P_VAlign		            385
#define P_Pushlike		            386
#define P_Sunken		            387
#define P_CenterImage	            388
#define P_RealSizeImage	            389
#define P_RightJust		            390
#define P_NoData		            391
#define P_Ellipsis					392
#define P_HotTrack					393
#define P_OwnerData					394
#define P_CheckBoxes				395
#define P_TrackSelect				396
#define P_Timer						397
#define P_ScrollOpposite			398
#define P_Bottom					399
#define P_Standard		            500
#define P_Sort			            502
#define P_Notify		            503
#define P_Keyin			            504
#define P_VScroll		            505
#define P_HScroll		            506
#define P_Tabstops		            507
#define	P_NoRedraw		            508
#define P_NoIntHeight	            509
#define P_MultiCol		            510
#define P_HasStrings	            511
#define P_Selection		            512
#define P_AutoHScroll	            515
#define P_AutoVScroll	            516
#define P_Password		            517
#define P_NoHideSel		            518
#define P_OEMConvert	            519
#define P_MultiLine		            520
#define P_Number		            521
#define P_UpperCase		            522
#define P_LowerCase		            523
#define P_AlignText		            524
#define P_Shrink		            525
#define P_AddToCaption	            526
#define P_AcceleratorTable          527
#define P_TitleBar		            529
#define P_State			            530
#define P_ClipSiblings	            531
#define P_ClipChildren	            532
#define P_SystemModal	            533
#define P_NoIdleMsg		            534
#define P_LocalEdit		            535
#define P_SystemMenu	            536
#define P_MinimizeBox	            537
#define P_MaximizeBox 	            538
#define P_Style			            539
#define P_ThickFrame	            540
#define P_Class			            545
#define P_LayoutBorder	            546
#define P_FrameType		            547
#define P_AbsAlign		            548
#define P_Show			            550
#define P_Message		            551
#define P_MsgClass		            552
#define P_Function		            553
#define P_CmdMessage	            561
#define P_CmdSlob		            562
#define P_ShowStatusbar	            563
#define P_ShowToolbar	            564
#define P_PosX			            565
#define P_PosY			            566
#define P_Grid			            567
#define P_GridX			            568
#define P_GridY			            569
#define P_Rulers		            570
#define P_DisableNoScroll           572
#define P_ScrAlign                  573
#define P_WantReturn                574
#define P_ReadOnly                  575
#define P_ExternFile                578
#define P_Simple                    580
#define P_DlgInit                   581
#define P_MfcMode                   582
#define P_Test3d                    583
#define P_Val                       600
#define P_Debug                     601
#define P_InfoInferred              602
#define P_Patched                   603
#define P_Prerelease                604
#define P_PrivateBuild              605
#define P_SpecialBuild              606
#define P_LangID                    607
#define P_CharSet                   608
#define P_ShowSelAlways             610
#define P_SetBuddyInt               611
#define P_NoThousands               614
#define P_AutoBuddy                 615
#define P_ArrowKeys                 616
#define P_Orientation               617
#define P_AutoTicks                 618
#define P_TickMarks                 619
#define P_Point                     620
#define P_SelRange                  621
#define P_ShowPercent               622
#define P_ShowPos                   623
#define P_View                      624
#define P_SingleSel                 625
#define P_ListSort                  626
#define P_ShareImageLists           627
#define P_NoLabelWrap               628
#define P_AutoArrange               629
#define P_EditLabels                630
#define P_Align                     631
#define P_OwnerDrawFixed            632
#define P_NoScroll                  634
#define P_NoColumnHeader            635
#define P_NoSortHeader		        636
#define P_HasButtons		        637
#define P_HasLines                  638
#define P_LinesAtRoot               639
#define P_DisableDragDrop           640
#define P_ToolWindow                650
#define P_ClientEdge                651
#define P_StaticEdge                652
#define P_WindowEdge                653
#define P_Transparent               654
#define P_AcceptFiles               655
#define P_ControlParent             656
#define P_ContextHelp               657
#define P_NoParentNotify            658
#define P_TopMost                   659
#define P_DlgModalFrame             660
#define P_MDIChild                  661
#define P_AppWindow                 662
#define P_RTLReading                663
#define P_Right                     664
#define P_LeftScrollbar             665
#define P_RTLRightMenu              666
#define P_NoCallOleInit             667
#define P_SetForeground             670
#define P_3DLook                    671
#define P_FixedSys                  672
#define P_NoFailCreate              673
#define P_Control                   674
#define P_CenterMouse               675
#define P_WindowsUI                 676
#define P_SpecifyFont               677
#define P_FontNameSize              678
#define P_SaveSel                   679
#define P_SelectionBar              680
#define P_Vertical                  681
#define P_NoIME                     682
#define P_SelfIME                   683
#define P_DlgContextHelp            684
#define P_Condition                 749
#define P_Language                  750
#define P_Characteristics           751
#define P_Version                   752
#define P_ExStyle                   760
#define P_Buttons                   781
#define P_ToolTips                  782
#define P_ForceIconLeft             785
#define P_ForceLabelLeft            786
#define P_Focus                     787
#define P_Center                    791
#define P_AniTransparent            792
#define P_Autoplay                  793

// Actions
#define A_ImageChange              1000
#define A_HexChange                1003
#define A_DependentList            1004
#define A_DeleteButton             1005
#define A_PaletteChange            1006
#define A_PaletteReplace           1007
#define A_DIBChange                1008
#define A_OleItemChange            1009
#define A_Guidelines               1010
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\sym\vcpp32.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by src.rc
//
#define VCPP32_RESOURCE_H                      1
#define VCPP32_IDC_LBINCL                      1000
#define VCPP32_ID_FIND_ANYCHARACTER            21000
#define VCPP32_ID_FIELDS_FILENAME              21000
#define VCPP32_ID_FIND_RANGE                   21001
#define VCPP32_ID_FIELDS_PAGENUMBER            21001
#define VCPP32_ID_FIND_NOTRANGE                21002
#define VCPP32_ID_FIELDS_CURRENTTIME           21002
#define VCPP32_ID_FIND_LINE_BEGIN              21003
#define VCPP32_ID_FIELDS_CURRENTDATE           21003
#define VCPP32_ID_FIND_LINE_END                21004
#define VCPP32_ID_FIELDS_LEFTALIGN             21004
#define VCPP32_ID_FIND_TAG                     21005
#define VCPP32_ID_FIELDS_CENTER                21005
#define VCPP32_ID_FIND_NOT                     21006
#define VCPP32_ID_FIELDS_RIGHTALIGN            21006
#define VCPP32_ID_FIND_OR                      21007
#define VCPP32_ID_FIND_CLOSURE_ZERO            21008
#define VCPP32_ID_FIND_CLOSURE_ONE             21009
#define VCPP32_ID_FIND_GROUP                   21010
#define VCPP32_ID_FIND_ALPHANUM                21011
#define VCPP32_ID_FIND_WHITESPACE              21012
#define VCPP32_ID_FIND_ALPHA                   21013
#define VCPP32_ID_FIND_DECIMAL                 21014
#define VCPP32_ID_FIND_HEX                     21015
#define VCPP32_ID_FIND_NUMBER                  21016
#define VCPP32_ID_FIND_INTEGER                 21017
#define VCPP32_ID_FIND_IDENTIFIER              21018
#define VCPP32_ID_FIND_WORD                    21019
#define VCPP32_ID_FIND_STRING                  21020
#define VCPP32_ID_REPLACE_FINDWHATTEXT         21021
#define VCPP32_ID_REPLACE_TAG_1                21022
#define VCPP32_ID_REPLACE_TAG_2                21023
#define VCPP32_ID_REPLACE_TAG_3                21024
#define VCPP32_ID_REPLACE_TAG_4                21025
#define VCPP32_ID_REPLACE_TAG_5                21026
#define VCPP32_ID_REPLACE_TAG_6                21027
#define VCPP32_ID_REPLACE_TAG_7                21028
#define VCPP32_ID_REPLACE_TAG_8                21029
#define VCPP32_ID_REPLACE_TAG_9                21030
#define VCPP32_IDC_DIRNAME                     24000
#define VCPP32_ID_REPLACE_FINDNEXT             24001
#define VCPP32_ID_FIND_WHAT                    24001
#define VCPP32_IDC_BOOKMARK_NAME               24001
#define VCPP32_ID_AMB_LIST                     24001
#define VCPP32_ID_ENVIRON_HORIZSCROLL          24001
#define VCPP32_ID_PRINTABORT_DEVICE            24001
#define VCPP32_ID_PAGESETUP_HEADER             24001
#define VCPP32_ID_PRINT_PRINTER                24001
#define VCPP32_IDC_DIRPROMPT                   24001
#define VCPP32_ID_REPLACE_WHAT                 24002
#define VCPP32_IDC_FIND_NEXT                   24002
#define VCPP32_IDC_BOOKMARK_LIST               24002
#define VCPP32_ID_AMB_SYM                      24002
#define VCPP32_ID_ENVIRON_PROMPT               24002
#define VCPP32_ID_PRINTABORT_FILENAME          24002
#define VCPP32_ID_PAGESETUP_FOOTER             24002
#define VCPP32_ID_PRINT_ALL                    24002
#define VCPP32_IDC_QUERY                       24002
#define VCPP32_ID_REPLACE_WHOLEWORD            24003
#define VCPP32_ID_FIND_WHOLEWORD               24003
#define VCPP32_IDC_BOOKMARK_ADD                24003
#define VCPP32_ID_AMB_OK                       24003
#define VCPP32_ID_ENVIRON_SAVEBEFORE           24003
#define VCPP32_ID_PAGESETUP_LEFT               24003
#define VCPP32_ID_PRINT_SELECTION              24003
#define VCPP32_IDC_FILENAME                    24003
#define VCPP32_ID_REPLACE_MATCHUPLO            24004
#define VCPP32_ID_FIND_MATCHUPLO               24004
#define VCPP32_IDC_BOOKMARK_DELETE             24004
#define VCPP32_ID_AMB_CANCEL                   24004
#define VCPP32_ID_ENVIRON_CREATEBACKUP         24004
#define VCPP32_ID_PAGESETUP_RIGHT              24004
#define VCPP32_ID_PRINT_SETUP                  24004
#define VCPP32_IDC_LANGUAGE                    24004
#define VCPP32_ID_REPLACE_REGEXP               24005
#define VCPP32_ID_FIND_REGEXP                  24005
#define VCPP32_IDC_BOOKMARK_GOTO               24005
#define VCPP32_ID_AMB_SRC                      24005
#define VCPP32_ID_ENVIRON_VERTSCROLL           24005
#define VCPP32_ID_PAGESETUP_TOP                24005
#define VCPP32_IDC_BACKUP_NAME                 24005
#define VCPP32_ID_REPLACE_REPLACE              24006
#define VCPP32_ID_FIND_TAGALL                  24006
#define VCPP32_IDC_BOOKMARK_FILE               24006
#define VCPP32_ID_ENVIRON_VIRTSPACE            24006
#define VCPP32_ID_PAGESETUP_BOTTOM             24006
#define VCPP32_IDC_FILENAMECAP                 24006
#define VCPP32_ID_REPLACE_REPLACEWITH          24007
#define VCPP32_ID_FIND_UP                      24007
#define VCPP32_IDC_BOOKMARK_LINE               24007
#define VCPP32_ID_ENVIRON_TEXTDRAG             24007
#define VCPP32_IDC_FOOTER_FIELDS               24007
#define VCPP32_IDC_EDIT_INDENT_STOP            24007
#define VCPP32_ID_REPLACE_REPLACEALL           24008
#define VCPP32_ID_FIND_DOWN                    24008
#define VCPP32_ID_ENVIRON_MARGIN               24008
#define VCPP32_IDC_OPEN_DOCUMENTS_LIST         24008
#define VCPP32_IDC_REPLACEMODE                 24009
#define VCPP32_IDC_ENVIRON_AUTORELOAD          24009
#define VCPP32_IDC_OPEN_DOCUMENTS_CLOSE        24009
#define VCPP32_IDC_REPLACEMODESELECTION        24010
#define VCPP32_IDC_AUTOWIN                     24010
#define VCPP32_IDC_OPEN_DOCUMENTS_SAVE         24010
#define VCPP32_ID_TOOLARGS_ARGUMENTS           24010
#define VCPP32_groupType                       24010
#define VCPP32_IDC_REPLACEMODEWHOLEFILE        24011
#define VCPP32_IDC_OPEN_DOCUMENTS_PRINT        24011
#define VCPP32_radioFTime                      24011
#define VCPP32_IDC_REPLACE_SPECIAL             24012
#define VCPP32_IDC_EDIT_FILETAB_STOP           24012
#define VCPP32_radioFSample                    24012
#define VCPP32_IDC_LANGUAGES                   24013
#define VCPP32_radioFCover                     24013
#define VCPP32_IDC_LINES_SCAN_BACK             24014
#define VCPP32_radioLCover                     24014
#define VCPP32_IDC_QY_NAME                     24015
#define VCPP32_radioMerge                      24015
#define VCPP32_IDC_STD_AUTOINDENT              24016
#define VCPP32_radioCustom                     24016
#define VCPP32_IDC_SMART_AUTOINDENT            24017
#define VCPP32_IDC_SETTINGDEFAULT              24018
#define VCPP32_IDC_NO_AUTOINDENT               24019
#define VCPP32_pushBrowse                      24019
#define VCPP32_IDC_INDENT_OPENBRACE            24020
#define VCPP32_ID_TOOLARGS_REDIRECT            24020
#define VCPP32_listCustom                      24020
#define VCPP32_IDC_INDENT_CLOSEBRACE           24021
#define VCPP32_IDC_ADD                         24022
#define VCPP32_IDC_REMOVE                      24023
#define VCPP32_IDC_UP                          24024
#define VCPP32_IDC_DOWN                        24025
#define VCPP32_IDC_TABS_INSERTSPACES           24026
#define VCPP32_IDC_TABS_KEEPTABS               24027
#define VCPP32_IDC_TRACK_DEFAULT               24028
#define VCPP32_IDC_CURRENT_SIZE                24029
#define VCPP32_IDC_SAVED_TIME                  24030
#define VCPP32_IDC_MODIFIED_STATE              24031
#define VCPP32_lblAdvanced                     24031
#define VCPP32_IDC_BACKUP_TIME                 24032
#define VCPP32_editAdvanced                    24032
#define VCPP32_IDC_EMULATION                   24033
#define VCPP32_IDC_EMULATION_OPTIONS           24034
#define VCPP32_IDC_PLACEHOLDER                 24035
#define VCPP32_IDC_SPECIAL                     24036
#define VCPP32_IDC_FIELDS                      24037
#define VCPP32_IDC_CASESENS                    24038
#define VCPP32_IDC_SETTINGS_TEXT               24039
#define VCPP32_IDC_PROMPT                      24040
#define VCPP32_IDC_FIF_INFOLDER                24041
#define VCPP32_IDC_FIF_ADVANCED                24042

#define VCPP32_IDC_EDITEXIST                   24043
#define VCPP32_IDC_LBVERBEXIST                 24044
#define VCPP32_IDC_LBVIRT                      24045
#define VCPP32_IDC_LBVERB                      24046
#define VCPP32_IDC_LBVIRTEXIST                 24047
#define VCPP32_IDC_EDIT_NAME                   24092

#define VCPP32_IDA_VIEW_MIXEDMODE              24502
#define VCPP32_IDA_VIEW_NEXTERROR              24503
#define VCPP32_IDA_VIEW_PREVIOUSERROR          24504
#define VCPP32_IDA_VIEW_TOGGLETAG              24505
#define VCPP32_IDA_VIEW_NEXTTAG                24506
#define VCPP32_IDA_VIEW_PREVIOUSTAG            24507
#define VCPP32_IDA_RUN_GO                      24508
#define VCPP32_IDA_RUN_RESTART                 24509
#define VCPP32_IDA_RUN_STOPDEBUGGING           24510
#define VCPP32_IDA_RUN_TOCURSOR                24511
#define VCPP32_IDA_RUN_TRACEINTO               24512
#define VCPP32_IDA_RUN_SRC_STEPOVER            24513
#define VCPP32_IDA_RUN_SRC_TRACEINTO           24514
#define VCPP32_IDA_RUN_STEPOVER                24515
#define VCPP32_IDA_RUN_STOPAFTERRETURN         24516
#define VCPP32_IDA_RUN_CALLS                   24517
#define VCPP32_IDA_RUN_QUICKWATCH              24518
#define VCPP32_IDA_ZAPINT3                     24519
#define VCPP32_IDA_VIEWTABS                    24520
#define VCPP32_IDA_MAXIMIZE_MDI                24521
#define VCPP32_IDA_RESTORE_MDI                 24522
#define VCPP32_IDA_DEBUG_ASSEMBLY              24523
#define VCPP32_IDA_DEBUG_RADIX                 24524
#define VCPP32_IDA_DELWORD_BACK                24525
#define VCPP32_IDA_DUMP_UNDO                   24526
#define VCPP32_IDA_DUMP_REDO                   24527
#define VCPP32_IDA_COMPACT_DOC                 24528
#define VCPP32_IDA_TOOL_STOP                   24529
#define VCPP32_IDA_MEMORY_NEXTFORMAT           24530
#define VCPP32_IDA_MEMORY_PREVFORMAT           24531
#define VCPP32_IDA_WINDOWCHILD                 24532
#define VCPP32_IDA_RUN_TRACEFUNCTION           24533
#define VCPP32_IDA_RUN_SRC_TRACEFUNCTION       24534
#define VCPP32_IDM_TEXTVIEW_HELP               24535
#define VCPP32_IDM_FILE_GOTO                   24536
#define VCPP32_IDM_CURSOR_SCREENLEFT           24537
#define VCPP32_IDM_CURSOR_SCREENRIGHT          24538
#define VCPP32_IDM_EXTENDSELECT_CHARLEFT       24539
#define VCPP32_IDM_EXTENDSELECT_CHARRIGHT      24540
#define VCPP32_IDM_EXTENDSELECT_FILEEND        24541
#define VCPP32_IDM_EXTENDSELECT_FILESTART      24542
#define VCPP32_IDM_EXTENDSELECT_LINEDOWN       24543
#define VCPP32_IDM_EXTENDSELECT_LINEEND        24544
#define VCPP32_IDM_EXTENDSELECT_LINESTART      24545
#define VCPP32_IDM_EXTENDSELECT_LINEUP         24546
#define VCPP32_IDM_EXTENDSELECT_SCREENDOWN     24547
#define VCPP32_IDM_EXTENDSELECT_SCREENUP       24548
#define VCPP32_IDM_EXTENDSELECT_WORDLEFT       24549
#define VCPP32_IDM_EXTENDSELECT_WORDRIGHT      24550
#define VCPP32_ID_LINE_SELECT                  24551
#define VCPP32_ID_SWAP_ANCHOR_POINT            24552
#define VCPP32_ID_STREAM_SELECT_INCLUSIVE      24553
#define VCPP32_ID_STREAM_SELECT_EXCLUSIVE      24554
#define VCPP32_ID_SINGLE_PANE                  24555
#define VCPP32_ID_KILL_PANE                    24556
#define VCPP32_ID_HORIZONTAL_SPLIT             24557
#define VCPP32_ID_VERTICAL_SPLIT               24558
#define VCPP32_IDS_TargetOutOfdate             24692
#define VCPP32_IDC_TOOL_MACROS                 25457
#define VCPP32_IDC_FIF_SPECIAL                 25457
#define VCPP32_IDC_FIF_WHOLEWORD               25478
#define VCPP32_IDC_FIF_REGEX                   25479
#define VCPP32_IDC_FIF_MATCHCASE               25480
#define VCPP32_IDC_FIF_RECURSIVE               25481
#define VCPP32_IDC_FIF_FILESTOSEARCH           25482
#define VCPP32_IDC_FIF_FINDWHAT                25483
#define VCPP32_IDC_FIF_PLACEHOLDER             25484
#define VCPP32_IDC_FIF_BROWSE_INFOLDER         25485
#define VCPP32_IDC_FIF_APPEND                  25486
#define VCPP32_ID_BUTTON25490                  25490
#define VCPP32_ID_BUTTON25491                  25491
#define VCPP32_ID_BUTTON25492                  25492
#define VCPP32_ID_BUTTON25493                  25493
#define VCPP32_IDC_FIF_SRCPATH                 25493
#define VCPP32_ID_BUTTON25494                  25494
#define VCPP32_IDC_FIF_INCPATH                 25494
#define VCPP32_ID_BUTTON25495                  25495
#define VCPP32_ID_BUTTON25496                  25496
#define VCPP32_ID_BUTTON25497                  25497
#define VCPP32_ID_BUTTON25498                  25498
#define VCPP32_ID_BUTTON25499                  25499
#define VCPP32_ID_BUTTON25500                  25500
#define VCPP32_ID_BUTTON25501                  25501
#define VCPP32_IDC_LBNOUN                      25501
#define VCPP32_ID_BUTTON25502                  25502
#define VCPP32_IDC_NOHANDLER                   25502
#define VCPP32_ID_BUTTON25503                  25503
#define VCPP32_ID_BUTTON25504                  25504
#define VCPP32_ID_BUTTON25505                  25505
#define VCPP32_ID_BUTTON25506                  25506
#define VCPP32_ID_BUTTON25507                  25507
#define VCPP32_ID_BUTTON25508                  25508
#define VCPP32_ID_BUTTON25509                  25509
#define VCPP32_ID_BUTTON25510                  25510
#define VCPP32_ID_BUTTON25511                  25511
#define VCPP32_ID_BUTTON25512                  25512
#define VCPP32_ID_BUTTON25513                  25513
#define VCPP32_ID_BUTTON25514                  25514
#define VCPP32_ID_BUTTON25515                  25515
#define VCPP32_ID_BUTTON25516                  25516
#define VCPP32_ID_BUTTON25517                  25517
#define VCPP32_ID_BUTTON25518                  25518
#define VCPP32_ID_BUTTON25519                  25519
#define VCPP32_ID_BUTTON25520                  25520
#define VCPP32_ID_BUTTON25521                  25521
#define VCPP32_ID_BUTTON25522                  25522
#define VCPP32_ID_BUTTON25523                  25523
#define VCPP32_ID_BUTTON25524                  25524
#define VCPP32_ID_BUTTON25525                  25525
#define VCPP32_ID_BUTTON25526                  25526
#define VCPP32_ID_BUTTON25527                  25527
#define VCPP32_ID_BUTTON25528                  25528
#define VCPP32_ID_BUTTON25529                  25529
#define VCPP32_ID_BUTTON25530                  25530
#define VCPP32_ID_BUTTON25531                  25531
#define VCPP32_ID_BUTTON25532                  25532
#define VCPP32_ID_BUTTON25533                  25533
#define VCPP32_ID_BUTTON25534                  25534
#define VCPP32_ID_BUTTON25535                  25535
#define VCPP32_ID_BUTTON25536                  25536
#define VCPP32_ID_BUTTON25537                  25537
#define VCPP32_ID_BUTTON25538                  25538
#define VCPP32_ID_BUTTON25539                  25539
#define VCPP32_ID_BUTTON25540                  25540
#define VCPP32_ID_BUTTON25554                  25554
#define VCPP32_ID_BUTTON25555                  25555
#define VCPP32_ID_BUTTON25556                  25556
#define VCPP32_ID_BUTTON25560                  25560
#define VCPP32_IDD_OPENINCL                    25569
#define VCPP32_IDCT_SRCPACKAGE                 28000
#define VCPP32_IDCT_SRCDOC                     28001
#define VCPP32_IDR_FIND_SPECIAL                28000
#define VCPP32_IDR_PAGE_SETUP_FIELDS           28001
#define VCPP32_IDR_HEADER_TYPE                 28002
#define VCPP32_IDR_BROWSE_TYPE                 28003
#define VCPP32_IDR_DEFAULT_GLOBAL              28004
#define VCPP32_IDR_DEFAULT_EDIT                28005
#define VCPP32_IDR_ACCELERATOR1                28006
#define VCPP32_IDR_OLD_STD_GLOBAL_KEYS         28007
#define VCPP32_IDR_STD_GLOBAL_KEYS             28008
#define VCPP32_IDR_GLOBAL_DEBUGGER_KEYS        28009
#define VCPP32_IDR_GLOBAL_BROWSE_KEYS          28010
#define VCPP32_IDR_GLOBAL_TOOL_KEYS            28011
#define VCPP32_IDR_TEXT_VIEW_BOOKMARK_KEYS     28012
#define VCPP32_IDR_TEXT_VIEW_SCROLL_KEYS       28013
#define VCPP32_IDR_TEXT_VIEW_CURSOR_KEYS       28014
#define VCPP32_IDR_TEXT_VIEW_EDIT_KEYS         28015
#define VCPP32_IDR_TEXT_VIEW_SEARCH_KEYS       28016
#define VCPP32_IDR_TEXT_VIEW_MISC_KEYS         28017
#define VCPP32_IDR_TEXT_TEMPLATE               28018
#define VCPP32_IDR_BSC_TEMPLATE                28019
#define VCPP32_IDD_OUTLINEVIEW_DIALOGBAR_NOCPP 28020
#define VCPP32_IDD_BRSQUERY_DIALOG             28021
#define VCPP32_IDD_CLASSVIEW_DIALOGBAR         28022
#define VCPP32_IDD_OUTLINEVIEW_DIALOGBAR       28023
#define VCPP32_IDD_AMBIG_SRCLINES              28024
#define VCPP32_IDD_RESOLVEAMBIGUITY            28025
#define VCPP32_IDD_PAGESETUP                   28026
#define VCPP32_IDD_PRINT                       28027
#define VCPP32_IDD_PRINTABORT                  28028
#define VCPP32_IDD_INSERT_FILE                 28029
#define VCPP32_IDD_PROFILE                     28030
#define VCPP32_IDD_REPLACE                     28031
#define VCPP32_IDD_FILE_OPEN                   28032
#define VCPP32_IDD_FIND_SRC                    28033
#define VCPP32_IDD_TRANSPORT_SELECT            28034
#define VCPP32_IDD_BROWSE_FILES                28035
#define VCPP32_IDD_MEMORYVIEW_DIALOGBAR        28036
#define VCPP32_IDD_BOOKMARKS                   28037
#define VCPP32_IDDP_OPTIONS_EMULATIONS         28038
#define VCPP32_IDDP_OPTIONS_TABS               28039
#define VCPP32_IDDP_DEBUG                      28040
#define VCPP32_IDDP_OPTIONS_EDITOR             28041
#define VCPP32_IDDP_TEXT_GEN                   28042
#define VCPP32_IDB_MAINTOOLS                   28043
#define VCPP32_IDB_WIZBAR                      28044
#define VCPP32_IDB_MAINLARGETOOLS              28045
#define VCPP32_IDC_TEXTDRAG                    28050
#define VCPP32_IDC_TEXTDRAG_COPY               28051
#define VCPP32_IDC_CURSOR_RECORD               28052
#define VCPP32_IDC_SMALL_I                     28053
#define VCPP32_IDS_GOTOLINE_PROMPT             28096
#define VCPP32_IDS_ISEARCH                     28097
#define VCPP32_IDS_QUOTED_INSERT               28098
#define VCPP32_IDS_BAD_DIR_SPEC                28099
#define VCPP32_IDS_DIR_NOT_EXIST               28100
#define VCPP32_IDS_GOTOLINE_HELP               28101
#define VCPP32_IDS_GOTOLINE_WHAT               28102
#define VCPP32_IDS_GOTOBM_WHAT                 28103
#define VCPP32_IDS_GOTOBM_PROMPT               28104
#define VCPP32_IDS_GOTOBM_HELP                 28105
#define VCPP32_IDS_GOTODEF_PROMPT              28106
#define VCPP32_IDS_GOTODEF_HELP                28107
#define VCPP32_IDS_GOTODEF_WHAT                28108
#define VCPP32_IDS_GOTOREF_PROMPT              28109
#define VCPP32_IDS_GOTOREF_HELP                28110
#define VCPP32_IDS_GOTOREF_WHAT                28111
#define VCPP32_IDS_DisableReadOnlyFileEdits    28112
#define VCPP32_IDS_DRAG_MOVE                   28113
#define VCPP32_IDS_DRAG_COPY                   28114
#define VCPP32_IDS_DRAG_CANCEL                 28115
#define VCPP32_IDS_InsertFileDlg               28116
#define VCPP32_IDS_PlaybackRecording           28117
#define VCPP32_IDS_IfdefFound                  28118
#define VCPP32_IDS_Matching                    28119
#define VCPP32_IDS_Enclosing                   28120
#define VCPP32_IDS_WIZBAR_OBJECTCOMBO          28121
#define VCPP32_IDS_WIZBAR_MESSAGECOMBO         28122
#define VCPP32_IDS_FILE_CURRENT_SIZE           28123
#define VCPP32_IDS_LINE_SINGULAR               28124
#define VCPP32_IDS_LINE_PLURAL                 28125
#define VCPP32_IDS_EMULATION_RESET_WARNING     28126
#define VCPP32_IDS_DEFREF                      28127
#define VCPP32_IDS_FILEOUTLINE                 28128
#define VCPP32_IDS_BASEGRAPH                   28129
#define VCPP32_IDS_DERVGRAPH                   28130
#define VCPP32_IDS_CALLGRAPH                   28131
#define VCPP32_IDS_REVCALLGRAPH                28132
#define VCPP32_IDS_COL_NAME                    28133
#define VCPP32_IDS_COL_VALUE                   28134
#define VCPP32_IDS_COL_TYPE                    28135
#define VCPP32_IDS_ASKPATH_GETPATH             28136
#define VCPP32_IDS_ASKPATH_CAPTION             28137
#define VCPP32_IDS_REPLACETOOLONG              28138
#define VCPP32_IDS_EMULATION                   28139
#define VCPP32_IDS_GetIncludePrivMsg           28140
#define VCPP32_IDS_FILTER_BROWSE               28141
#define VCPP32_IDS_FILTER_ODL                  28142
#define VCPP32_IDS_OPENAS_TEXT                 28143
#define VCPP32_IDS_FSTYLE_REGULAR              28144
#define VCPP32_IDS_NO_SOURCE                   28145
#define VCPP32_IDS_CPOP_TRACEFUNCTION          28146
#define VCPP32_IDS_CPOP_GOTOFILE               28147
#define VCPP32_IDS_CPOP_QUICKWATCH             28148
#define VCPP32_IDS_CPOP_GOTODEF                28149
#define VCPP32_IDS_CPOP_GOTOREF                28150
#define VCPP32_IDS_DEFINITIONS                 28151
#define VCPP32_IDS_REFERENCES                  28152
#define VCPP32_IDS_BROWSE_NEXT_DEF             28153
#define VCPP32_IDS_BROWSE_PREV_DEF             28154
#define VCPP32_IDS_BROWSE_NEXT_REF             28155
#define VCPP32_IDS_BROWSE_PREV_REF             28156
#define VCPP32_IDS_REC_STOP                    28157
#define VCPP32_IDS_REC_START                   28158
#define VCPP32_IDS_TEXT_FILE                   28159
#define VCPP32_IDS_EDITOR                      28160
#define VCPP32_IDS_REC_PAUSE                   28161
#define VCPP32_IDS_REC_UNPAUSE                 28162
#define VCPP32_IDS_TEXTEDITOR                  28163
#define VCPP32_IDS_PROJMENU_EXECUTE            28164
#define VCPP32_IDS_ACTIVE_PROJ_REQUIRED        28165
#define VCPP32_IDS_SEARCHING_FOR               28166
#define VCPP32_IDS_EDIT                        28167
#define VCPP32_IDS_BRS_CLOSE                   28168
#define VCPP32_IDS_BRS_SPLIT_HORZ              28169
#define VCPP32_IDS_BRS_SPLIT_VERT              28170
#define VCPP32_IDS_PUBLIC                      28171
#define VCPP32_IDS_PROTECTED                   28172
#define VCPP32_IDS_PRIVATE                     28173
#define VCPP32_IDS_GOTOLINE                    28174
#define VCPP32_IDS_CAP_DEBUG                   28175
#define VCPP32_IDS_SOURCE_DIFFERS              28176
#define VCPP32_IDS_BROWSE_CLOSE                28177
#define VCPP32_IDS_BROWSE_CLOSE_GENERIC        28178
#define VCPP32_IDS_FIND_IN_FILES               28179
#define VCPP32_IDS_STOP_FIND_IN_FILES          28180
#define VCPP32_IDS_NoIfdefFound                28181
#define VCPP32_IDS_CLOSE_BUTTON                28182
#define VCPP32_IDS_No_More_Occurrences         28183
#define VCPP32_IDS_BrsFuncAll                  28184
#define VCPP32_IDS_BrsFuncVirt                 28185
#define VCPP32_IDS_BrsFuncStat                 28186
#define VCPP32_IDS_BrsFuncNVirt                28187
#define VCPP32_IDS_BrsFuncNStat                28188
#define VCPP32_IDS_BrsFuncNVirtNStat           28189
#define VCPP32_IDS_BrsFuncNone                 28190
#define VCPP32_IDS_BrsDataAll                  28191
#define VCPP32_IDS_BrsDataStat                 28192
#define VCPP32_IDS_BrsDataNStat                28193
#define VCPP32_IDS_BrsDataNone                 28194
#define VCPP32_IDS_BROWSE                      28195
#define VCPP32_IDS_RECORD                      28196
#define VCPP32_IDS_SYNTAX_NONE                 28197
#define VCPP32_IDS_SAVE_UNNAMED_FILE           28198
#define VCPP32_IDS_Whole_File_Searched         28199
#define VCPP32_IDS_TABS                        28200
#define VCPP32_IDS_DEFAULT                     28201
#define VCPP32_IDS_UndoTyping                  28202
#define VCPP32_IDS_UndoPaste                   28203
#define VCPP32_IDS_UndoDelete                  28204
#define VCPP32_IDS_UndoReplaceAll              28205
#define VCPP32_IDS_UndoChangeCase              28206
#define VCPP32_IDS_UndoTranspose               28207
#define VCPP32_IDS_UndoModifyWord              28208
#define VCPP32_IDS_UndoReformat                28209
#define VCPP32_IDS_UndoMove                    28210
#define VCPP32_IDS_UndoOvertype                28211
#define VCPP32_IDS_UndoReplaceOne              28212
#define VCPP32_IDS_VC30                        28213
#define VCPP32_IDS_VC20                        28214
#define VCPP32_IDS_Brief                       28215
#define VCPP32_IDS_Epsilon                     28216
#define VCPP32_IDS_CustomEditor                28217
#define VCPP32_IDS_VirtualSpace                28218
#define VCPP32_IDS_IndentsSeparateParagraphs   28219
#define VCPP32_IDS_DisableBacksp               28220
#define VCPP32_IDS_IncMovesInUndo              28221
#define VCPP32_IDS_CopyWOSelection             28222
#define VCPP32_IDS_LineModePaste               28223
#define VCPP32_IDS_FIND                        28224
#define VCPP32_IDS_REPLACE                     28225
#define VCPP32_IDS_BRIEF_FINDWHAT              28226
#define VCPP32_IDS_UseBriefRESyntax            28227
#define VCPP32_IDS_UndoAutomatedEdit           28228
#define VCPP32_IDS_UndoFileInsert              28229
#define VCPP32_IDS_LOAD_NCB                    28230
#define VCPP32_IDS_OPEN_NCB_ERROR              28231
#define VCPP32_IDS_OVERWRITE_NCB               28232
#define VCPP32_IDS_DEF_TEXT                    28233
#define VCPP32_IDS_INVALID_BOOKMARK            28234
#define VCPP32_ERR_Tool_Path_Invalid           28235
#define VCPP32_ERR_Wrap_Lines                  28236
#define VCPP32_ERR_No_Disk_Image               28237
#define VCPP32_ERR_Tab_Out_Of_Range            28238
#define VCPP32_ERR_MACRO_NO_BOOKMARK           28239
#define VCPP32_ERR_MACRO_BOOKMARK_EXISTS       28240
#define VCPP32_ERR_Save_MakeTempName           28241
#define VCPP32_ERR_Save_TempFileCreate         28242
#define VCPP32_ERR_Save_CreateBackupFile       28243
#define VCPP32_ERR_Save_RenameTempFile         28244
#define VCPP32_ERR_File_Open                   28245
#define VCPP32_ERR_File_Disk_Full              28246
#define VCPP32_ERR_File_Unicode                28247
#define VCPP32_ERR_File_Binary                 28248
#define VCPP32_ERR_File_Name_Is_Not_Valid      28249
#define VCPP32_ERR_File_Already_Loaded         28250
#define VCPP32_ERR_Not_A_Text_File             28251
#define VCPP32_ERR_Cannot_Print                28252
#define VCPP32_ERR_Unable_Start_Print_Job      28253
#define VCPP32_ERR_Bad_File_Spec               28254
#define VCPP32_ERR_Change_Directory            28255
#define VCPP32_ERR_Change_Drive                28256
#define VCPP32_ERR_CANT_PRINT                  28257
#define VCPP32_ERR_Clipboard_Overflow          28258
#define VCPP32_ERR_Line_Too_Long               28259
#define VCPP32_ERR_UndoRedoBufferTooSmall      28260
#define VCPP32_ERR_String_Not_Found            28261
#define VCPP32_ERR_No_RegExp_Match             28262
#define VCPP32_ERR_Close_When_Debugging        28263
#define VCPP32_ERR_RegExpr_Invalid             28264
#define VCPP32_ERR_RegExpr_Undef               28265
#define VCPP32_ERR_Line_OutOfRange             28266
#define VCPP32_ERR_Cannot_Quit                 28267
#define VCPP32_ERR_Tab_Too_Big                 28268
#define VCPP32_ERR_Memory_Is_Low               28269
#define VCPP32_ERR_Memory_Is_Low_2             28270
#define VCPP32_ERR_Bad_Margin                  28271
#define VCPP32_ERR_Bad_BSC_File                28272
#define VCPP32_ERR_NoDefinition                28273
#define VCPP32_ERR_NotAClass                   28274
#define VCPP32_ERR_NoReference                 28275
#define VCPP32_ERR_NoSymInfo                   28276
#define VCPP32_ERR_NoFileInfo                  28277
#define VCPP32_ERR_NoClassName                 28278
#define VCPP32_ERR_NoFuncName                  28279
#define VCPP32_ERR_NotAFunc                    28280
#define VCPP32_ERR_MACRO_GENERAL_STOP          28281
#define VCPP32_ERR_MACRO_NO_VIEW               28282
#define VCPP32_ERR_MACRO_NO_INSERT             28283
#define VCPP32_ERR_MACRO_NO_SWITCH             28284
#define VCPP32_ERR_File_Open_NoCRLF            28285
#define VCPP32_ERR_File_Unicode_NoCRLF         28286
#define VCPP32_ERR_FileNotFound                28287
#define VCPP32_ERR_PathNotFound                28288
#define VCPP32_ERR_BadExeFormat                28289
#define VCPP32_ERR_Expand_Macro                28290
#define VCPP32_ERR_Close_When_Building         28291
#define VCPP32_ERR_Cannot_Insert               28292
#define VCPP32_ERR_Cannot_Exchange             28293
#define VCPP32_ERR_Unknown                     28294
#define VCPP32_ERR_No_TargetName               28295
#define VCPP32_ERR_No_App_Debugging            28296
#define VCPP32_ERR_UnallowedCharsInFilename_2  28297
#define VCPP32_WARN_Advise_Wrap_Lines          28298
#define VCPP32_WARN_File_Modified              28299
#define VCPP32_WARN_CR_MODIFIED                28300
#define VCPP32_SYS_File_Revert                 28301
#define VCPP32_SYS_StatusISearchFolding        28302
#define VCPP32_SYS_StatusISearchReverse        28303
#define VCPP32_SYS_StatusISearchWord           28304
#define VCPP32_SYS_StatusISearchRE             28305
#define VCPP32_SYS_Ini_FileExt                 28306
#define VCPP32_SYS_Does_Not_Exist_Create       28307
#define VCPP32_SYS_Profile_Windows_Title       28308
#define VCPP32_SYS_Profile_Device_Param        28309
#define VCPP32_SYS_Profile_Printers_Title      28310
#define VCPP32_SYS_Print_Device                28311
#define VCPP32_SYS_Print_Setup_Device          28312
#define VCPP32_SYS_StatusNextError             28313
#define VCPP32_SYS_StatusClear                 28314
#define VCPP32_SYS_Nb_Of_Occurrences_Replaced  28315
#define VCPP32_SYS_Nb_Of_Occurrences_Found     28316
#define VCPP32_SYS_File_Changed                28317
#define VCPP32_SYS_Save_Changes_To             28318
#define VCPP32_SYS_My_String                   28319
#define VCPP32_SYS_File_Filter                 28320
#define VCPP32_SYS_Allocate_Memory             28321
#define VCPP32_SYS_Free_Memory                 28322
#define VCPP32_SYS_Lock_Memory                 28323
#define VCPP32_SYS_Untitled_File               28324
#define VCPP32_SYS_RedoBufferOverflow          28325
#define VCPP32_SYS_RegExpr_StackOverflow       28326
#define VCPP32_SYS_RegExpr_CompileAction       28327
#define VCPP32_SYS_RegExpr_EstimateAction      28328
#define VCPP32_SYS_OrgIni_FileExt              28329
#define VCPP32_SYS_MSVCColSelect               28330
#define VCPP32_SYS_MSVCLine                    28331
#define VCPP32_SYS_File_Edited                 28332
#define VCPP32_SYS_FileReload                  28333
#define VCPP32_SYS_StatusISearch               28334
#define VCPP32_SYS_StatusISearchFailed         28335
#define VCPP32_SYS_StatusISearchExact          28336
#define VCPP32_SYS_FileSaved                   28337
#define VCPP32_SYS_BookmarkSet                 28338
#define VCPP32_SYS_MarkSet                     28339
#define VCPP32_SYS_RegionCopied                28340
#define VCPP32_DLG_Open_Filebox_Title          28341
#define VCPP32_DLG_SaveAs_Filebox_Title        28342
#define VCPP32_DLG_Open_Project_Title          28343
#define VCPP32_DLG_Edit_Project_Title          28344
#define VCPP32_DLG_Add_Tool_Title              28345
#define VCPP32_DLG_NewProject_Title            28346
#define VCPP32_DLG_Grep_Title                  28347
#define VCPP32_DLG_ProfileBrowse_Title         28348
#define VCPP32_DLG_Cols_First                  28349
#define VCPP32_DLG_Cols_Operator               28350
#define VCPP32_DLG_Cols_BreakpointLine         28351
#define VCPP32_DLG_Cols_CurrentLine            28352
#define VCPP32_DLG_Cols_ErrorLine              28353
#define VCPP32_DLG_Cols_TaggedLine             28354
#define VCPP32_DLG_Cols_Selection              28355
#define VCPP32_DLG_Cols_SourceWindow           28356
#define VCPP32_DLG_Cols_Keyword                28357
#define VCPP32_DLG_Cols_CPPKeyword             28358
#define VCPP32_DLG_Cols_Identifier             28359
#define VCPP32_DLG_Cols_Comment                28360
#define VCPP32_DLG_Cols_Number                 28361
#define VCPP32_DLG_Cols_Real                   28362
#define VCPP32_DLG_Cols_String                 28363
#define VCPP32_DLG_Cols_AFX_Modified           28364
#define VCPP32_DLG_Cols_User_Types             28365
#define VCPP32_DLG_Cols_SourceBrowser          28366
#define VCPP32_DLG_Cols_BrowseWindow           28367
#define VCPP32_DLG_Cols_SourceWindows          28368
#define VCPP32_DLG_Exception_Action_First      28369
#define VCPP32_DLG_Exception_1stChance         28370
#define VCPP32_DLG_Exception_2ndChance         28371
#define VCPP32_ID_FILE_LOADSAMEWINDOW          28372
#define VCPP32_ID_FILE_OPENNEWWINDOW           28373
#define VCPP32_ID_INDICATOR_COL                28374
#define VCPP32_ID_INDICATOR_MACRO              28375
#define VCPP32_ID_INDICATOR_MACROPLAY          28376
#define VCPP32_ID_INDICATOR_MACRORECORD        28377
#define VCPP32_ID_INDICATOR_MACROPAUSE         28378
#define VCPP32_ID_WIZBAR_DELETE                28379
#define VCPP32_ID_WIZBAR_CB_MSG                28380
#define VCPP32_ID_WIZBAR_CB_OBJECT             28381
#define VCPP32_STA_Undo                        28382
#define VCPP32_STA_Redo                        28383
#define VCPP32_STA_End_Of_Undo                 28384
#define VCPP32_STA_End_Of_Redo                 28385
#define VCPP32_STA_Find_Hit_EOF                28386
#define VCPP32_STA_End_Of_ErrorList            28387
#define VCPP32_STA_StatusHelpDlg               28388
#define VCPP32_STA_MatchWordOff                28389
#define VCPP32_STA_MatchCaseOn                 28390
#define VCPP32_STA_MatchCaseOff                28391
#define VCPP32_STA_MatchREOn                   28392
#define VCPP32_STA_MatchREOff                  28393
#define VCPP32_STA_MatchWordOn                 28394
#define VCPP32_STS_MESSAGE_OVERTYPE            28395
#define VCPP32_STS_MESSAGE_READONLY            28396
#define VCPP32_STS_MESSAGE_LINE                28397
#define VCPP32_STS_MESSAGE_COLUMN              28398
#define VCPP32_STS_MESSAGE_TID                 28399
#define VCPP32_STS_MESSAGE_COLSEL              28400
#define VCPP32_TYP_File_BAT                    28401
#define VCPP32_TYP_File_ALL                    28402
#define VCPP32_TYP_Generic_Text                28403
#define VCPP32_DEF_Ext_Header                  28404
#define VCPP32_DEF_Ext_C                       28405
#define VCPP32_DEF_Ext_H                       28406
#define VCPP32_DEF_Ext_MAK                     28407
#define VCPP32_DEF_Ext_LIB                     28408
#define VCPP32_DEF_Ext_OBJ                     28409
#define VCPP32_DEF_Ext_DEF                     28410
#define VCPP32_DEF_Ext_RC                      28411
#define VCPP32_DEF_Ext_DLG                     28412
#define VCPP32_DEF_Ext_ICO                     28413
#define VCPP32_DEF_Ext_CUR                     28414
#define VCPP32_DEF_Ext_BMP                     28415
#define VCPP32_DEF_Ext_FNT                     28416
#define VCPP32_DEF_Ext_INC                     28417
#define VCPP32_DEF_Ext_EXE                     28418
#define VCPP32_DEF_Ext_COM                     28419
#define VCPP32_DEF_Ext_DLL                     28420
#define VCPP32_DEF_Ext_PIF                     28421
#define VCPP32_DEF_Ext_BAT                     28422
#define VCPP32_DEF_Ext_ALL                     28423
#define VCPP32_DEF_Ext_CPP                     28424
#define VCPP32_DEF_Ext_CXX                     28425
#define VCPP32_DEF_Ext_HPP                     28426
#define VCPP32_DEF_Ext_HXX                     28427
#define VCPP32_DEF_Ext_BSC                     28428
#define VCPP32_DEF_Ext_Source                  28429
#define VCPP32_ENV_MFC_Name                    28430
#define VCPP32_INI_DataTips                    28450
#define VCPP32_INI_FindRE                      28451
#define VCPP32_INI_FindWholeWord               28452
#define VCPP32_INI_FindMatchCase               28453
#define VCPP32_INI_EnableTextDragging          28454
#define VCPP32_INI_EnableMarginGlyphs          28455
#define VCPP32_INI_SelectMarginWidth           28456
#define VCPP32_INI_Setup                       28457
#define VCPP32_INI_Version                     28458
#define VCPP32_INI_PageSetup                   28459
#define VCPP32_INI_Font                        28460
#define VCPP32_INI_Find                        28461
#define VCPP32_INI_Replace                     28462
#define VCPP32_INI_VertScroll                  28463
#define VCPP32_INI_HorizScroll                 28464
#define VCPP32_INI_SaveBeforeBuild             28465
#define VCPP32_INI_PromptBeforeSave            28466
#define VCPP32_INI_UndoRedoSize                28467
#define VCPP32_INI_MFCPath                     28468
#define VCPP32_INI_LastExtension               28469
#define VCPP32_INI_CallParams                  28470
#define VCPP32_INI_EnableVirtualSpaces         28471
#define VCPP32_INI_ShowWizardBar               28472
#define VCPP32_INI_UndoMoves                   28473
#define VCPP32_INI_DisableBacksp               28474
#define VCPP32_INI_IndentsSepParagraphs        28475
#define VCPP32_INI_DisableROFileEdits          28476
#define VCPP32_INI_OpenNewSrcWindow            28477
#define VCPP32_INI_CreateBackupFiles           28478
#define VCPP32_INI_ReturnValues                28479
#define VCPP32_INI_EnableLineModePastes        28480
#define VCPP32_INI_AUTORELOAD                  28481
#define VCPP32_INI_UnixRESyntax                28482
#define VCPP32_INI_PreserveExistingTabs        28483

#define VCPP32_IDC_FIF_GRID                    29000
#define VCPP32_DLG_Cols_ErrorsWindow           29000
#define VCPP32_IDS_SOUND_OUTPUT_ERROR          29001
#define VCPP32_IDS_SOUND_OUTPUT_WARNING        29002
#define VCPP32_IDS_SOUND_OUTPUT_WARNING2       29003
#define VCPP32_IDS_SOUND_OUTPUT_ERROR2         29004
#define VCPP32_SYS_ErrorsWin_Title             29005
#define VCPP32_IDS_GOTOERROR_WHAT              29006
#define VCPP32_IDS_GOTOERROR_PROMPT            29007
#define VCPP32_IDS_GOTOERROR_HELP              29008
#define VCPP32_INI_SrcPathFIF                  29009
#define VCPP32_INI_IncPathFIF                  29010
#define VCPP32_INI_ProfilerInstalled           29011
#define VCPP32_IDS_DUPE_DIR_SPEC               29012
#define VCPP32_INI_RecursiveFIF                29013
#define VCPP32_INI_FIF_Dirs                    29014
#define VCPP32_INI_FIF_Filter                  29015
#define VCPP32_INI_FIF_InFolder                29016
#define VCPP32_INI_FIF_CurDir                  29017
#define VCPP32_ERR_Dir_Required_FIF            29018
#define VCPP32_ERR_FIF_File_Binary             29019
#define VCPP32_INI_AdvancedFIF                 29020
#define VCPP32_IDS_FIF_ADVANCED                29021
#define VCPP32_ERR_Filename_Invalid            29022
#define VCPP32_MAK_Error                       29023
#define VCPP32_MAK_Warning                     29024
#define VCPP32_ERR_NTSPAWN_NotFound            29025
#define VCPP32_ERR_CantSpawnTool               29026
#define VCPP32_IDS_TOOL_STOP_MSG               29027
#define VCPP32_ENV_Inc_Name                    29028
#define VCPP32_ENV_Lib_Name                    29029
#define VCPP32_ENV_Path_Name                   29030
#define VCPP32_ENV_Help_Name                   29031
#define VCPP32_ERR_FIF_NOEXIST_NOSEARCH        29032
#define VCPP32_ERR_Pathname_Too_Long           29033
#define VCPP32_IDR_OUTPUT_TYPE                 29034
#define VCPP32_SYS_OutputWin_Title             29035
#define VCPP32_INI_OwinSplitterPref            29036
#define VCPP32_INI_OwinMaxLength               29037
#define VCPP32_IDS_STOP_PROFILE                29038
#define VCPP32_IDS_PROFILE                     29039
#define VCPP32_IDS_NO_PROFILE                  29040
#define VCPP32_IDD_TOOLARGS                    29041
#define VCPP32_IDD_FINDINFILES                 29042
#define VCPP32_STA_Begin_Of_ErrorList          29043
#define VCPP32_ERR_File_Not_Found              29044
#define VCPP32_ERR_Invalid_Window              29045
#define VCPP32_ERR_Cant_StartTool              29046
#define VCPP32_ERR_NotEnoughMemory             29047
#define VCPP32_ERR_ToolReturn                  29048

#define VCPP32_IDR_TOOL_MACRO                  29050

#define VCPP32_IDS_TOOL_First                  29051
#define VCPP32_IDS_TOOL_FilePath               29051
#define VCPP32_IDS_TOOL_FileDir        		29052
#define VCPP32_IDS_TOOL_FileName       		29053
#define VCPP32_IDS_TOOL_FileExt        		29054
#define VCPP32_IDS_TOOL_Line           		29055
#define VCPP32_IDS_TOOL_Col            		29056
#define VCPP32_IDS_TOOL_CurText        		29057
#define VCPP32_IDS_TOOL_Dir            		29058
#define VCPP32_IDS_TOOL_TargetPath     		29059
#define VCPP32_IDS_TOOL_TargetDir      		29060
#define VCPP32_IDS_TOOL_TargetName     		29061
#define VCPP32_IDS_TOOL_TargetExt      		29062
#define VCPP32_IDS_TOOL_TargetArgs     		29063
#define VCPP32_IDS_TOOL_WkspDir        		29064
#define VCPP32_IDS_TOOL_WkspName       		29065
#define VCPP32_IDS_TOOL_FileNameExt    		29066
#define VCPP32_IDS_TOOL_RCFile         		29067
#define VCPP32_IDS_TOOL_Last                   29068
#define VCPP32_IDS_MACRO_First                 29068
#define VCPP32_IDS_MACRO_FilePath              29068
#define VCPP32_IDS_MACRO_FileDir        		29069
#define VCPP32_IDS_MACRO_FileName       		29070
#define VCPP32_IDS_MACRO_FileExt        		29071
#define VCPP32_IDS_MACRO_Line           		29072
#define VCPP32_IDS_MACRO_Col            		29073
#define VCPP32_IDS_MACRO_CurText        		29074
#define VCPP32_IDS_MACRO_Dir            		29075
#define VCPP32_IDS_MACRO_TargetPath     		29076
#define VCPP32_IDS_MACRO_TargetDir      		29077
#define VCPP32_IDS_MACRO_TargetName     		29078
#define VCPP32_IDS_MACRO_TargetExt      		29079
#define VCPP32_IDS_MACRO_TargetArgs     		29080
#define VCPP32_IDS_MACRO_WkspDir        		29081
#define VCPP32_IDS_MACRO_WkspName       		29082
#define VCPP32_IDS_MACRO_FileNameExt    		29083
#define VCPP32_IDS_MACRO_Last					29084
#define VCPP32_OWIN_BUILD                      29085
#define VCPP32_OWIN_GREP                       29086
#define VCPP32_OWIN_PROFILE                    29087
#define VCPP32_OWIN_DEBUG                      29088
#define VCPP32_IDD_NEWVIRTUAL                  29089
#define VCPP32_IDD_NEWWINMSG                   29090


// Debug ids
#define VCPP32_IDC_DEBUG_SHOWFPU               24088
#define VCPP32_IDC_DEBUG_SHOWARGS              24090
#define VCPP32_IDC_DEBUG_SHOWTYPES             24091
#define VCPP32_IDC_DEBUG_ADDRESS               24094
#define VCPP32_IDC_DEBUG_FORMAT                24095
#define VCPP32_IDC_DEBUG_LIVE                  24096
#define VCPP32_IDC_DEBUG_RAW                   24097
#define VCPP32_IDC_DEBUG_WIDTH                 24098
#define VCPP32_IDC_DEBUG_ANNOTATE              24099
#define VCPP32_IDC_DEBUG_CODEBYTES             24100
#define VCPP32_IDC_DEBUG_NEWWINDOW             24102
#define VCPP32_IDC_DEBUG_OLERPC                24103
#define VCPP32_IDC_DEBUG_JIT                   24104
#define VCPP32_IDC_DEBUG_FIXEDWIDTH            24105
#define VCPP32_IDC_DEBUG_HEXMODE               24106
#define VCPP32_IDC_DEBUG_REMOTE                24119
#define VCPP32_IDC_DEBUG_CONFIG                24120

#define VCPP32_IDC_SETUP                       24123
#define VCPP32_DLG_EXCEP_LIST                  24010
#define VCPP32_IDC_PLATFORM_LIST               24121
#define VCPP32_IDC_TRANSPORT_LIST              24122

#define VCPP32_DLG_EXCEP_NUMBER_LABEL          24001
#define VCPP32_DLG_THREAD_LIST                 24002
#define VCPP32_DLG_EXCEP_NUMBER                24002
#define VCPP32_DLG_EXCEP_NAME_LABEL            24003
#define VCPP32_DLG_EXCEP_NAME                  24004
#define VCPP32_DLG_EXCEP_ACTION                24005
#define VCPP32_DLG_EXCEP_DEFAULT               24006
#define VCPP32_DLG_EXCEP_ADD                   24007
#define VCPP32_DLG_EXCEP_CHANGE                24008
#define VCPP32_DLG_EXCEP_DELETE                24009
#define VCPP32_DLG_EXCEP_1STCHANCE             24011
#define VCPP32_DLG_EXCEP_2NDCHANCE             24012
#define VCPP32_DLG_EXCEP_LIST_BACKUP           24166
#define VCPP32_DLG_SYSTEM_EXCEP_LIST           24167

#define VCPP32_IDD_THREADS                     25222
#define VCPP32_DLG_THREAD_SUSPEND              24001
#define VCPP32_DLG_THREAD_RESUME               24003
#define VCPP32_DLG_THREAD_FOCUS                24004
#define VCPP32_DLG_THREAD_NAME                 24005
#define VCPP32_DLG_THREAD_ADDRESS              24006
#define VCPP32_DLG_THREAD_ID                   24007
#define VCPP32_DLG_THREAD_STATE                24008
#define VCPP32_DLG_THREAD_PRIORITY             24009
#define VCPP32_DLG_THREAD_LOCATION             24010
#define VCPP32_DBG_Thread_Term                 24382

#define VCPP32_IDD_QUICKWATCH                  25218
#define VCPP32_ID_QUICKW_ADD                   24001
#define VCPP32_ID_QUICKW_VALUE                 24002
#define VCPP32_ID_QUICKW_MODIFY                24005
#define VCPP32_ID_QUICKW_EXPRESSION            24006
#define VCPP32_ID_QUICKW_NEWEXPR               24007
#define VCPP32_ID_QUICKW_TXT_VALUE             24126
#define VCPP32_ID_QUICKW_TXT_MEMBERS           24127
#define VCPP32_IDC_QW_GRID			           24163


#define VCPP32_DLG_GREP_FINDWHAT               24003
#define VCPP32_DLG_GREP_SELECTEDFILES          24004
#define VCPP32_DLG_GREP_MATCHWORD              24006
#define VCPP32_DLG_GREP_MATCHCASE              24007
#define VCPP32_DLG_GREP_REGULAR                24008
#define VCPP32_DLG_GREP_ADDALL                 24009
#define VCPP32_DLG_GREP_ADD                    24016
#define VCPP32_DLG_GREP_DELETE                 24024
#define VCPP32_DLG_GREP_DELETEALL              24025
#define VCPP32_DLG_GREP_PROJFILES              24118
#define VCPP32_DLG_GREP_SELECTEDFILESTEXT      24128

#define VCPP32_IDC_COMBO_FUNS                  24107
#define VCPP32_IDC_COMBO_DATA                  24108

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define VCPP32__APS_3D_CONTROLS                     1
#define VCPP32__APS_NEXT_RESOURCE_VALUE        28450
#define VCPP32__APS_NEXT_COMMAND_VALUE         28000
#define VCPP32__APS_NEXT_CONTROL_VALUE         25503
#define VCPP32__APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\sym\reg.h ===
// reg.h : this file contains definitions needed to register packages
//         and packets with SUSHI.  This file is intended to be usable
//         by either C or C++ programs; no C++ specific language
//         features should be used.
//
//////////////////////////////////////////////////////////////////////////

// [w-amilt] 20 May 1993.  The resource compiler doesn't like #pragma's,
//                         and doesn't care about this file.
#ifndef RC_INVOKED
#ifndef __REG_H__
#define __REG_H__

#pragma pack(2)

// Package IDs
//
// Please do not modify or re-order the following #defines unless you
// know what you are doing.
//
#define PACKAGE_SUSHI		1   // Must be first
#define PACKAGE_VCPP		2
#define PACKAGE_VRES		3
#define PACKAGE_VPROJ		4
#define PACKAGE_PRJSYS		5
#define PACKAGE_MSIN		6
#define PACKAGE_LANGCPP		7
#define PACKAGE_LANGFOR		8
#define PACKAGE_VBA			9
#define PACKAGE_GALLERY     10
#define PACKAGE_LANGMST		11
#define PACKAGE_CLASSVIEW	12
#define PACKAGE_ENT			13
#define PACKAGE_LANGHTML	14
#define PACKAGE_BIN			15
#define PACAKGE_IMG			16
#define PACKAGE_NUMEGA		17
#define PACKAGE_DEBUG           25   // DEVDBG
#define PACKAGE_SIMPLE		90

#define PACKET_NIL      UINT(-1)    // For dockable windows with no part ui.

// Packet IDs for VSHELL
//
#define PACKET_DOCOBJECT 1

// Packet IDs for VRES
//
#define PACKET_COMPVIEW 1
#define PACKET_IMAGE    2
#define PACKET_DIALOG   3
#define PACKET_MENU     4
#define PACKET_STRING   5
#define PACKET_ACCEL    6
#define PACKET_BINARY   7
#define PACKET_VERSION  8

// Packet IDs for VCPP
//
#define PACKET_TEXTEDIT  1
#define PACKET_BASE      2
#define PACKET_MULTI     3

// Packet IDs for PRJSYS
//
#define PACKET_PRJSYS   1

// Packet IDs for MSIN
//
#define PACKET_TOPIC   1

// Packet IDs for ENTerprise edition
//
#define PACKET_SCHEMA			1
#define PACKET_DATASCOPE_TOOL	2
#define PACKET_CUSTOM			3

//  Streams used in a project's MSF file.  Since we use 512 byte pages, these
//  numbers must be  between 0 and 256
//
#define PROJ_MSF_PROJINTINFO    0   // Internal project info
#define PROJ_MSF_PROJEXTINFO    1   // External project info
#define PROJ_MSF_WORKSPACE      2
#define PROJ_MSF_VCPPINFO       3
#define PROJ_MSF_BRSINFO        4
#define PROJ_MSF_PROJSYSINFO    5   // new project system info
#define PROJ_MSF_PROJSCCINFO    6   // project source control info
#define PROJ_MSF_HELPINFO       7   // help system info
#define PROJ_MSF_VBA			8	// VBA state associated with the project
#define PROJ_MSF_ENT			9	// Enterprise package info
#define PROJ_MSF_DBASE          50  // no-compile browse info
                                    // this must be the last one
//
// Packet IDs for no-compile database. The first stream is for a
// a directory/list of files, and the subsequent numbers are reserved
// for file information
//
#define LANGCPP_DBASEINFO 0

#pragma pack()

#endif // __REG_H__
#endif // RC_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\sym\slob.h ===
#ifndef __SLOB_H__
#define __SLOB_H__

#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA

#pragma warning (disable : 4242)

class CSlobDragger;
class CSlobWnd;
class CSlobSequence;
class CPropBag;
class C3dPropertyPage;

class CPath;
class CFileRegEntry;
typedef CFileRegEntry * FileRegHandle;

// Slobs (Selection Objects) provide a basis for CEditor and CSelection
// that includes a standard property access mechanism with change
// notifications.
//
// Using this standard property mechanism, editors are isolated from
// the user interface of the property sheet.
//
// By making CSelection derive from CSlob and having it mirror the
// properties of all selected objects as well as broadcast any property
// changes it receives to all of the selected objects, handling setting
// properties on multiple selections becomes much easier.


// Special property identifiers
//
#define P_BEGIN_MAP                          0  // Pseudo-prop for marking the start of a map
#define P_END_MAP                            1   // Pseudo-prop for marking the end of a map
#define P_Container                          2   // Container property supported by all slobs
#define P_ID                         3
#define P_Value                      4
#define P_QuoteName                  5

#define P_Title                      6
#define P_FileName                   7
#define P_FileDisplay                8

#define P_CurrentSlob                9
#define P_PoppingProperties         10

// Properties for workspace window folder slobs
#define P_IsExpanded                    32
#define P_IsExpandable                  33
#define P_IsInvisibleNode           34
#define P_HasGlyphTipText               35
#define P_BoldWorkspaceText             36
#define P_ProjWinTitle                  37
#define P_ProxyContainer                38
#define P_SccStatus                             39
#define P_PanePriorityIndex         40
#define P_PaneIsIndependent         41
#define P_SortPaneRootNodes         42
#define P_FileSaveCallBack          43

// Standard Slob Notifications
#define SN_DESTROY                           0   // Dependancy has been destroyed
#define SN_ALL                               1   // All properties of dependancy (may) have changed
#define SN_CONTENT                          64   // The CSlob content has changed
#define SN_ADD                      65   // A CSlob was added to the content list
#define SN_REMOVE                   66   // A CSlob was removed from the content list

// Actions
#define A_PostSel                  100
#define A_PreSel                   101

// Commands and Verbs
#define C_COMMAND                  126
#define V_VERB                     127

#define P_MinPackage               128  // Minimum safe package property ID.

enum PROP_TYPE { null, action, integer, booln, longint, number, string, 
				slob, rect, point, verb, command };

// Property Descriptor
struct PRD
{
	UINT nProp;
	const void* pbOffset;
	// Note correspondence with CUndoSlob
	enum PROP_TYPE { null, action, integer, booln, longint, number, string, 
		slob, rect, point, verb, command } nType;
	LPCTSTR szName;
};


#define BEGIN_PROP_MAP(thisClass, parentClass) \
	PRD AFX_EXT_DATADEF thisClass::m_rgprd [] = { \
		{ P_BEGIN_MAP, &parentClass::m_rgprd[0], PRD::null, #thisClass },

#define END_PROP_MAP() \
	{ P_END_MAP, NULL, PRD::null, NULL } };

#define ACTION_PROP(name, memberFxn) \
	{ P_##name, &((theClass*)0)->memberFxn, PRD::action, #name },

#define BOOL_PROP(name) \
	{ P_##name, &((theClass*)0)->m_b##name, PRD::booln, #name },

#define FAKE_BOOL_PROP(name) \
	{ P_##name, NULL, PRD::booln, #name },

#define INT_PROP(name) \
	{ P_##name, &((theClass*)0)->m_n##name, PRD::integer, #name },

#define FAKE_INT_PROP(name) \
	{ P_##name, NULL, PRD::integer, #name },

#define LONG_PROP(name) \
	{ P_##name, &((theClass*)0)->m_l##name, PRD::longint, #name },

#define FAKE_LONG_PROP(name) \
	{ P_##name, NULL, PRD::longint, #name },

#define DBL_PROP(name) \
	{ P_##name, &((theClass*)0)->m_num##name, PRD::number, #name },

#define STR_PROP(name) \
	{ P_##name, &((theClass*)0)->m_str##name, PRD::string, #name },

#define FAKE_STR_PROP(name) \
	{ P_##name, NULL, PRD::string, #name },

#define RECT_PROP(name) \
	{ P_##name, &((theClass*)0)->m_rc##name, PRD::rect, #name },

#define POINT_PROP(name) \
	{ P_##name, &((theClass*)0)->m_pt##name, PRD::point, #name },

#define FAKE_POINT_PROP(name) \
	{ P_##name, NULL, PRD::point, #name },

#define SLOB_PROP(name) \
	{ P_##name, &((theClass*)0)->m_p##name, PRD::slob, #name },

#define VERB_PROP(verbID) \
	{ V_VERB, (const void*)(0x0000ffff & verbID), PRD::verb, _T("Verb") },

#define COMMAND_PROP(cmdID) \
	{ C_COMMAND, (const void*)(0x0000ffff & cmdID), PRD::command, _T("Command") },

#define DECLARE_PROP_MAP() \
	public: \
		static PRD AFX_DATA m_rgprd []; \
		virtual const PRD FAR* GetPropMap() const \
		{ return &m_rgprd[0]; }


// Get*Prop return type
//      In a multiple-selection, a lower code has precedence over a higher code.
//
enum GPT
{
	avoid = -1,             // Like invisible, but is overriding in multiple selections
	invalid = 0,    // Not a known property or disabled
	ambiguous,              // Multiple selection with different values
	valid,                  // Value is correct
	invisible,              // Hide this property's UI on prop pages
};

//
//      Schema version for slob implemenetation.  Used in IMPLEMENT_SERIAL:
#define SLOB_SCHEMA_VERSION     1

//      Find a propery in a propery map:
const PRD* PrdFindProp(const PRD* propMap, UINT idProp);

enum SORT_TYPE { no_sort, alpha_sort, override_sort };

// act_insert_into_undo_slob: when the undo mechanism records the
// post-action selection it will only remember those slobs who return
// TRUE for this action type.

enum ACTION_TYPE { act_delete, act_cut, act_copy, act_paste, act_drag, act_drop, act_insert_into_undo_slob };

#define S_ON_COMMAND(n, f) case (n): (f)(); return TRUE;
#define S_ON_UPDATE_COMMAND_UI(n, f) case (n): (f)(pCmdUI); return TRUE;

// Object of _many_ uses
//
class CSlob : public CObject
{
	DECLARE_SERIAL(CSlob)

public:
	CSlob();

	virtual ~CSlob();

	// Return a container-less, symbol-less, clone of 'this'
	virtual CSlob* Clone();

	// Copy properties only for 'this', doesn't copy properties
	// of contained slobs, both map and bag properties are copied
	virtual void CopyProps(CSlob *);

	// Clone an existing property bag into 'this' property bag
	virtual void ClonePropBag(CPropBag * pBag, int nBag = -1, BOOL fEmpty = TRUE);

	// Standard MFC serialization:
	virtual void Serialize(CArchive& ar);

	void SerializePropMap (CArchive& ar);
	virtual BOOL SerializePropMapFilter (int nIdProp) {return TRUE;}

	// Dependant Management
	void AddDependant(CSlob* newDependant);
	void RemoveDependant(CSlob* oldDepentant);
	virtual void InformDependants(UINT idChange, DWORD dwHint = 0);

	// Container Access
	inline CSlob* GetContainer() const
			{ return m_pContainer; }
	CSlob *GetRootContainer();

	// Move 'this' into pNewContainer.
	inline BOOL MoveInto(CSlob* pNewContainer)
			{ return SetSlobProp(P_Container, pNewContainer); }
	
	// Command enabling
	virtual BOOL CanAct(ACTION_TYPE action) { return TRUE; }
	// NYI: A final chance to refuse before the action
	virtual BOOL PreAct(ACTION_TYPE action) { return TRUE; }

#ifdef _DEBUG
	// Intentionally changed from BOOL to void returning functions to cause
	// compile errors in any code that still uses these.  You need to override
	// CanAct instead.

	virtual void CanDelete() {}
	virtual void CanCut() {}
	virtual void CanCopy() {}
	virtual void CanPaste() {}
	virtual void CanDrag() {}
#endif

	// Content Access (only valid for compound slobs!)
	virtual CObList* GetContentList();
	inline POSITION GetHeadPosition()
				{ CObList* p = GetContentList();
				  ASSERT(p != NULL);
				  return p->GetHeadPosition(); }
	inline CSlob* GetNext(POSITION& pos)
				{ CObList* p = GetContentList();
				  ASSERT(p != NULL);
				  return (CSlob*)p->GetNext(pos); }

	virtual void PrepareAddList(class CMultiSlob* pAddList, BOOL fPasting);

	virtual void Add(CSlob* pSlob);
	virtual void Remove(CSlob* pSlob);

	virtual BOOL CanAdd(CSlob* pAddSlob);
	virtual BOOL CanRemove(CSlob* pRemoveSlob);

#ifdef SLOB_REFERENCING
	// routines for creating a 'short-cut' to a slob
	// REVIEW: [patbr] the default 'reference' to a slob is just the slob itself
	virtual void CanReference() { return TRUE; }
	virtual CSlob *Reference()                                      // create a 'short-cut' to the slob
		{ return(this); }
	virtual void RefSerialize(CArchive& ar)         // serialize the 'reference'
		{ Serialize(ar); }
#endif

	// Notification Callback
	virtual void OnInform(CSlob* pChangedSlob, UINT idChange, DWORD dwHint);

	// Property Management
	virtual BOOL SetDoubleProp(UINT idProp, double val);
	virtual BOOL SetIntProp(UINT idProp, int val);
	virtual BOOL SetLongProp(UINT idProp, long val);
	virtual BOOL SetStrProp(UINT idProp, const CString& val);
	virtual BOOL SetSlobProp(UINT idProp, CSlob* val);
	virtual BOOL SetRectProp(UINT idProp, const CRect& val);
	virtual BOOL SetPointProp(UINT idProp, const CPoint& val);
	virtual GPT GetDoubleProp(UINT idProp, double& val);
	virtual GPT GetIntProp(UINT idProp, int& val);
	virtual GPT GetLongProp(UINT idProp, long& val);
	virtual GPT GetStrProp(UINT idProp, CString& val);
	virtual GPT GetSlobProp(UINT idProp, CSlob*& val);
	virtual GPT GetRectProp(UINT idProp, CRect& val);
	virtual GPT GetPointProp(UINT idProp, CPoint& val);

	// Property Bag Management
	virtual int GetPropBagCount() const;
	virtual CPropBag* GetPropBag(int nBag = -1);

	// Custom undo support hooks
	virtual void UndoAction(CSlobSequence* pSeq, UINT idAction);
	virtual void DeleteUndoAction(CSlobSequence* pSeq, UINT idAction);
	virtual void BeginUndo(UINT nID);
	virtual void EndUndo(BOOL bAbort = FALSE);

	// Return window viewing this slob if any
	virtual CSlobWnd* GetSlobWnd() const;

	// Property Window Interface...
	virtual BOOL SetupPropertyPages(CSlob* pNewSel, BOOL bSetCaption = TRUE);

	// Drag and Drop
	static  CSlob*  DropTargetFromPoint (CPoint screenPoint);
	virtual int GetCursorIndex();

#define DDC_SINGLE              0
#define DDC_COPY_SINGLE 1
#define DDC_MULTI               2
#define DDC_COPY_MULTI  3

	virtual HCURSOR GetCursor(int ddcCursorStyle);

	virtual void PrepareDrop(class CDragNDrop* pInfo);

	virtual CSlobDragger* CreateDragger(CSlob *pDragObject, 
		CPoint screenPoint);
	virtual void DoDrop(CSlob* pSlob, CSlobDragger* pDragger);
	virtual void DoDrag(CSlob* pSlob, CSlobDragger* pDragger, 
		CPoint screenPoint);

#ifdef _DEBUG
public:
	virtual void AssertValid() const;
	virtual void GetSlobName(CString& strName) const;
#endif

	//  Get filename associated with this slob, if any:
	virtual const CPath *GetFilePath () const { return NULL; } 
	virtual FileRegHandle GetFileRegHandle () const { return NULL; }
	virtual int GetAssociatedFiles(CStringArray &);

protected:

	// CSlob data size is currently 16 bytes.

	// WARNING!!  Think twice before adding data to CSlob.  We use many,
	// many, many of these in the product.

	CSlob* m_pContainer;

	// NOTE:  Because of 4 byte alignment we have 3 unused bytes here,
	// that we might want to use in the future, perhaps we could add
	// a style word...

	// Dependencies optimized for the 99% case, 2 or fewer dependants.
	// We keep 2 dependencies on the CSlob, and if nDep gets bigger than 2,
	// then all dependencies are moved into a CObList, and assign it
	// to m_aDep[0].

	BYTE m_cDep;
	CObject* m_aDep[2];

public:         // properties

	DECLARE_PROP_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CProjSlob -- root project slob class 
// REVIEW(scotg)  if you move any functions from CSlob into this class,  you
// will need to verify that ALL classes that inherit from CProjSlob that provide
// and implementation of the function you just moved, call the correct base class
// member function.  Since a large number of classes already inherited from CSlob
// before we introduced CProjSlob, these classes call CSlob member functions when 
// looking for their base class implementation and not CProjSlob.  Only the member
// functions moved into CProjSlob have had their base class calls change to 
// call CProjSlob implementations and not CSlob implementations.
class CProjSlob : public CSlob
{
	DECLARE_DYNAMIC(CProjSlob)

public:
	CProjSlob();
	virtual ~CProjSlob();


	// allow slobs to override text displayed when mouse pauses on glyph.
	// only called if P_HasGlyphTipText property is set for the slob.
	virtual void GetGlyphTipText(CString &strTip);

	// routines related to visually sorting the slob's contents
	// REVIEW: [patbr] are default behaviors here appropriate?
	virtual SORT_TYPE GetSortType()                         // get type of sorting slob desires on contents
		{ return(alpha_sort); }
	virtual int CompareSlob(CSlob *pCmpSlob);       // returns -1, 0, 1 for <, ==, >

	// Cmds that can be handled by this slob
	virtual void GetCmdIDs(CWordArray& aVerbs, CWordArray& aCmds);
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo) { return FALSE; }     // Override to handle commands

	// Standard Display routine
	virtual BOOL DrawGlyph(CDC* pDC, LPCRECT lpRect);

};


/////////////////////////////////////////////////////////////////////////////
// CMultiSlob -- selection manager

class CMultiSlob : public CSlob
{
	DECLARE_DYNCREATE(CMultiSlob)

public:
	CMultiSlob();
	virtual ~CMultiSlob();

// Selection manipulation

	void Single(CSlob*, BOOL bSolo = FALSE);  // replace selection
	virtual void Clear(); // clear selection, remove all items
	virtual void Add(CSlob* pSlob);
	virtual void Remove(CSlob* pSlob);
	virtual void EnsureValidSelection();
	
// Select information

	BOOL IsSelected(CSlob* pSlob) const;
	BOOL IsOnlySelected(CSlob* pSlob) const;
	BOOL IsDominantSelected(CSlob* pSlob) const;
	CSlob* GetDominant() const;
	
// Slob Overrides
	
	virtual CObList* GetContentList();
	virtual CSlobWnd* GetSlobWnd() const;
	virtual int GetCursorIndex();
	virtual HCURSOR GetCursor(int ddcCursorStyle);
	virtual BOOL CanAdd(CSlob* pAddSlob);
	virtual BOOL CanAct(ACTION_TYPE action);
	virtual BOOL PreAct(ACTION_TYPE action);
	virtual BOOL Delete(BOOL bClip = FALSE, CSlob** ppNextSlob = NULL);
	virtual void UndoAction(CSlobSequence* pSeq, UINT idAction);
	virtual void OnInform(CSlob* pChangedSlob, UINT idChange, DWORD dwHint);

	virtual BOOL SetDoubleProp(UINT idProp, double val);
	virtual BOOL SetIntProp(UINT idProp, int val);
	virtual BOOL SetLongProp(UINT idProp, long val);
	virtual BOOL SetStrProp(UINT idProp, const CString& val);
	virtual BOOL SetSlobProp(UINT idProp, CSlob* val);
	virtual BOOL SetRectProp(UINT idProp, const CRect& val);
	virtual BOOL SetPointProp(UINT idProp, const CPoint& val);
	
	virtual GPT GetDoubleProp(UINT idProp, double& valReturn);
	virtual GPT GetIntProp(UINT idProp, int& valReturn);
	virtual GPT GetLongProp(UINT idProp, long& val);
	virtual GPT GetStrProp(UINT idProp, CString& valReturn);
	virtual GPT GetSlobProp(UINT idProp, CSlob*& val);
	virtual GPT GetRectProp(UINT idProp, CRect& val);
	virtual GPT GetPointProp(UINT idProp, CPoint& val);

	// Property Window Interface...
	virtual BOOL SetupPropertyPages(CSlob* pNewSel, BOOL bSetCaption = TRUE);

	CSlobWnd*       m_pSlobWnd;// the owner of this selection
	CObList m_objects;      // list of selected objects
	BOOL m_bSolo:1; // can the selected obj be part of a multiple selection?
	BOOL m_bAllowEmpty:1; // the this selection be empty?
	BOOL m_bAllowMultipleContainers:1; // can selection cross containers?
};


/////////////////////////////////////////////////////////////////////////////
// CSlobDragger -- base class for objects used to drag slobs around

class CSlobDragger : public CObject
{
public:
	virtual void Show(BOOL bShow = TRUE) = 0;
	void Hide()
		{ Show(FALSE); }
	virtual CRect GetRect() = 0;
	virtual void Move(const CRect& newRect, BOOL bForceShow = FALSE) = 0;
};

class CSlobDraggerEx : public CSlobDragger
{
public:
	virtual void AddItem(CSlob* pSlob) = 0;
};

/////////////////////////////////////////////////////////////////////////////
// CClipboardSlob -- guess what this is???

class CClipboardSlob : public CSlob
{
	DECLARE_DYNAMIC(CClipboardSlob)

public:
	CClipboardSlob();
	~CClipboardSlob();

	void Copy(CSlob *pCopySlob);
	void Paste(CSlob *pDestSlob, CMultiSlob* pSelection = NULL, BOOL bClearSelection = TRUE);
	void ClearContents();
	
	BOOL CanAct(ACTION_TYPE action);
	
	virtual CObList* GetContentList()
		{ return &m_objects; }

	CObList m_objects;
};

extern CClipboardSlob AFX_DATA theClipboardSlob;


class CProp
{
public:
	static void DeleteCProp (CProp *pPRop);
	PROP_TYPE m_nType;
};

class CIntProp : public CProp
{
public:
	CIntProp(int val = 0)
		{ m_nVal = val; m_nType = integer; }

	int m_nVal;
};

class CBoolProp : public CProp
{
public:
	CBoolProp(int val = FALSE)
		{ m_bVal = val; m_nType = booln; }

	int m_bVal;
};

class CNumberProp : public CProp
{
public:
	CNumberProp(double val = 0.)
		{ m_numVal = val; m_nType = number; }

	double m_numVal;
};

class CStringProp : public CProp
{
public:
	CStringProp(const char* szVal = "")
		{ m_strVal = szVal; m_nType = string; }

	CString m_strVal;
};

inline void CProp::DeleteCProp (CProp *pPRop)
{
	switch (pPRop->m_nType)
	{
		case integer:
			delete ( (CIntProp *) pPRop );
			break;
		case booln:
			delete ( (CBoolProp *) pPRop );
			break;
		case number:
			delete ( (CNumberProp *) pPRop );
			break;
		case string:
			delete ( (CStringProp *) pPRop );
			break;
		default:
			ASSERT(FALSE);                          
	}
}

class CPropBag
{
	friend class CSlob;

public:
	CPropBag () : m_props(11) {};           // Use small block size.
	CPropBag (UINT nHash) : m_props(11) {m_props.InitHashTable(nHash, FALSE);}
	~CPropBag () {Empty();}

	// Enumerate props -- same as CMapWordToPtr's methods
	__inline POSITION GetStartPosition() const
		{return m_props.GetStartPosition();}

	__inline void GetNextAssoc(POSITION & pos, UINT & nPropID, CProp * & pProp) const
		{nPropID = (UINT)0; m_props.GetNextAssoc(pos, (WORD &)nPropID, (void * &)pProp);}

	__inline int GetPropCount () const
		{return m_props.GetCount();}

	// Setting of prop values.
	void SetIntProp(CSlob* pSlob, UINT nPropID, int val);
	void SetStrProp(CSlob* pSlob, UINT nPropID, CString & str);

	// TODO: add SetProp functions for other types...
	__inline CProp * FindProp(UINT nPropID) const
		{CProp * pProp; return m_props.Lookup(nPropID, (void*&)pProp) ? pProp : (CProp *)NULL;}
	__inline void AddProp(UINT nPropID, CProp* pProp)
		{m_props[nPropID] = pProp;}
	void RemoveProp(UINT nPropID);
	void RemovePropAndInform(UINT nPropID, CSlob * pSlob);

	void Empty();
	void Clone(CSlob * pSlob, CPropBag * pBag, BOOL fEmpty = TRUE);

	// Serialize the props in this bag.  If the slob pointer is provided
	// the slob's serialize SerializePropMapFilter filter is used:
	void Serialize(CArchive & ar, CSlob *pFilterSlob = NULL);

protected:
	CMapWordToPtr m_props;
};

__inline void CPropBag::RemovePropAndInform(UINT nPropID, CSlob * pSlob)
{
	CProp * pProp;
	if (m_props.Lookup(nPropID, (void*&)pProp))
	{
		CProp::DeleteCProp(pProp);
		VERIFY(m_props.RemoveKey(nPropID));
		pSlob->InformDependants(nPropID);
	}
}

__inline void CPropBag::RemoveProp(UINT nPropID)
{
	// only do removal if we find it
	// N.B. we don't VERIFY this op. 'cos it is more efficient
	// for clients of this class to call
	//
	//      pBag->RemoveProp(idProp);
	//
	// rather than
	//
	//  if (pBag->FindProp(idProp))
	//              pBag->RemoveProp(idProp));
	//
	// , for the case where the client doesn't care about the prop
	// value, in order to prevent the VERIFY() firing
	CProp * pProp;
	if (m_props.Lookup(nPropID, (void*&)pProp))
	{
		CProp::DeleteCProp(pProp);
		VERIFY(m_props.RemoveKey(nPropID));
	}
}

/////////////////////////////////////////////////////////////////////////////

#ifndef __UNDO_H__
#include "undo.h"
#endif

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA NEAR

#pragma warning (default : 4242)

#endif // __SLOB_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\sym\vres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by vres.rc
//
#define VRES_IDS_NULL                        0
#define VRES_IDMB_ARROW                      479
#define VRES_IDMB_BUTTON                     480
#define VRES_IDMB_CHECKBOX                   481
#define VRES_IDMB_EDIT                       482
#define VRES_IDMB_COMBO                      483
#define VRES_IDMB_LISTBOX                    484
#define VRES_IDMB_GROUPBOX                   485
#define VRES_IDMB_RADIO                      486
#define VRES_IDMB_TEXT                       487
#define VRES_IDMB_PICTURE                    488
#define VRES_IDMB_HSCROLL                    489
#define VRES_IDMB_VSCROLL                    490
#define VRES_IDMB_TRACKBAR                   491
#define VRES_IDMB_UPDOWN                     492
#define VRES_IDMB_PROGRESS                   493
#define VRES_IDMB_HOTKEY                     494
#define VRES_IDMB_LISTVIEW                   495
#define VRES_IDMB_TREEVIEW                   496
#define VRES_IDMB_SYSTAB                     497
#define VRES_IDMB_ANIMATE                    498
#define VRES_IDMB_USERBTN                    499
#define VRES_IDMB_OLEFIRST                   500
#define VRES_IDC_NETWORK                     0x40d
#define VRES_chx1                            0x0410
#define VRES_stc1                            0x0440
#define VRES_stc2                            0x0441
#define VRES_stc3                            0x0442
#define VRES_stc4                            0x0443
#define VRES_stc32                           0x045f
#define VRES_lst1                            0x0460
#define VRES_lst2                            0x0461
#define VRES_cmb1                            0x0470
#define VRES_cmb2                            0x0471
#define VRES_edt1                            0x0480
#define VRES_IDC_EDITOR                      20531
#define VRES_IDC_EDITOR_CAP                  20532
#define VRES_IDC_TEXT1                       26000
#define VRES_IDC_TEXT2                       26001
#define VRES_ID_LISTCAPTION                  26002
#define VRES_IDP_OLE_INIT_FAILED             26002
#define VRES_ID_LIST                         26003
#define VRES_IDC_CAPTION_CAP                 26003
#define VRES_IDC_DESCRIPTION                 26003
#define VRES_IDC_AVAIL_MEM                   26003
#define VRES_IDC_DISK_SPACE                  26004
#define VRES_IDP_FAILED_TO_CREATE            26004
#define VRES_IDC_LICENSEE_COMPANY            26005
#define VRES_IDC_LICENSEE_NAME               26006
#define VRES_IDC_MATH_COPR                   26007
#define VRES_IDR_AFXLOGO                     26008
#define VRES_IDC_NCOLORS                     26009
#define VRES_IDC_OPTIMAL                     26010
#define VRES_IDB_COLORTOOLS                  26010
#define VRES_IDC_OPTIMALSEL                  26011
#define VRES_IDC_TRUNCATED                   26012
#define VRES_IDC_FILE                        26013
#define VRES_IDB_RAINBOW                     26013
#define VRES_IDC_DITHER                      26014
#define VRES_IDC_APPLY                       26015
#define VRES_IDB_RULERTAB                    26016
#define VRES_IDD_NEWRESCOPY                  26017
#define VRES_IDB_SAMPLE_IMAGELIST_SMALL      26018
#define VRES_IDB_SAMPLE_IMAGELIST_BIG        26019
#define VRES_IDB_SAMPLE_IMAGELIST_SMALLMASK  26020
#define VRES_IDB_SAMPLE_IMAGELIST_BIGMASK    26021
#define VRES_IDC_PRELOAD                     26022
#define VRES_IDC_MOVEABLE                    26023
#define VRES_IDC_DISCARDABLE                 26024
#define VRES_IDC_PURE                        26025
#define VRES_IDC_COMPRESSED                  26026
#define VRES_IDC_WIDTH_CAP                   26027
#define VRES_IDC_WIDTH                       26028
#define VRES_IDC_HEIGHT_CAP                  26029
#define VRES_IDC_HEIGHT                      26030
#define VRES_IDC_COLORS_CAP                  26031
#define VRES_IDC_COLORS                      26032
#define VRES_IDC_BOGUS                       26033
#define VRES_IDC_PREVIEW_CAP                 26034
#define VRES_IDC_PREVIEW                     26035
#define VRES_IDC_KEY                         26036
#define VRES_IDC_CTRL                        26037
#define VRES_IDC_SHIFT                       26038
#define VRES_IDC_ALT                         26039
#define VRES_IDC_ASCII                       26040
#define VRES_IDC_VIRTKEY                     26041
#define VRES_IDC_NEXTKEY                     26042
#define VRES_IDS_WINDOW_LIST                 26042
#define VRES_IDC_DEFAULT                     26043
#define VRES_IDS_ERROR_STRING_NOT_FOUND      26043
#define VRES_IDS_CANCELING                   26044
#define VRES_IDC_HOT_CAP                     26044
#define VRES_IDC_OWNERDRAW                   26045
#define VRES_IDS_OCXTYPE                     26045
#define VRES_IDC_HOTX                        26046
#define VRES_IDS_OC_GENERAL                  26046
#define VRES_IDC_VISIBLE                     26047
#define VRES_IDS_OC_ALL                      26047
#define VRES_IDC_DISABLED                    26048
#define VRES_IDS_REGISTER_CONTROL            26048
#define VRES_IDC_GROUP                       26049
#define VRES_IDS_SETTINGHOTSPOT              26049
#define VRES_IDS_PICKINGCOLOR                26050
#define VRES_IDS_SETTINGTABS                 26051
#define VRES_IDC_TABSTOP                     26052
#define VRES_IDS_RESOURCES_PANE              26052
#define VRES_IDC_AUTO                        26053
#define VRES_IDC_SIZEGRIP                    26053
#define VRES_IDS_STYLES2                     26053
#define VRES_IDC_LEFTTEXT                    26054
#define VRES_IDC_3STATE                      26055
#define VRES_IDC_TXTALIGNC                   26056
#define VRES_IDC_TXTALIGN                    26057
#define VRES_IDC_NOPREFIX                    26058
#define VRES_IDC_NOWRAP                      26059
#define VRES_IDC_STYLES                      26060
#define VRES_IDC_SUNKEN                      26060
#define VRES_IDC_MENU_CAP                    26061
#define VRES_IDC_EXSTYLES                    26061
#define VRES_IDC_MENU                        26062
#define VRES_IDC_REGCLASSCAP                 26063
#define VRES_IDC_REGCLASS                    26064
#define VRES_IDC_FONTFACE                    26065
#define VRES_IDC_FONTSIZE                    26066
#define VRES_IDC_GFXTYPECAP                  26067
#define VRES_IDC_GFXTYPE                     26068
#define VRES_IDC_GFXCOLORCAP                 26069
#define VRES_IDC_GFXCOLOR                    26070
#define VRES_IDC_GFXICONCAP                  26071
#define VRES_IDC_GFXICON                     26072
#define VRES_IDC_STYLE_CAP                   26073
#define VRES_IDC_STYLE                       26074
#define VRES_IDC_BORDER                      26075
#define VRES_IDC_TITLEBAR                    26076
#define VRES_IDC_NOIDLEMSG                   26077
#define VRES_IDC_LOCALEDIT                   26078
#define VRES_IDC_SETFOREGROUND               26079
#define VRES_IDC_BREAK_CAP                   26079
#define VRES_IDC_3DLOOK                      26080
#define VRES_IDC_BREAK                       26080
#define VRES_IDC_FIXEDSYS                    26081
#define VRES_IDC_SEPARATOR                   26081
#define VRES_IDC_NOFAILCREATE                26082
#define VRES_IDC_CHECKED                     26082
#define VRES_IDC_CONTROL                     26083
#define VRES_IDC_POPUP                       26083
#define VRES_IDC_CENTERMOUSE                 26084
#define VRES_IDC_GRAYED                      26084
#define VRES_IDC_CONTEXTHELP                 26085
#define VRES_IDC_INACTIVE                    26085
#define VRES_IDC_WINDOWSUI                   26086
#define VRES_IDC_HELPMENU                    26086
#define VRES_IDC_PROPNAME                    26087
#define VRES_IDC_PROPVAL                     26088
#define VRES_IDC_PROPDLG                     26089
#define VRES_IDC_PROPDLIST                   26090
#define VRES_IDC_PROPDDOWN                   26091
#define VRES_IDC_STANDARD                    26092
#define VRES_IDC_SORT                        26093
#define VRES_IDC_NOTIFY                      26094
#define VRES_IDC_KEYIN                       26095
#define VRES_IDC_CENTERIMAGE                 26095
#define VRES_IDC_VSCROLL                     26096
#define VRES_IDC_RIGHTJUST                   26096
#define VRES_IDC_HSCROLL                     26097
#define VRES_IDC_REALSIZEIMAGE               26097
#define VRES_IDC_TABSTOPS                    26098
#define VRES_IDC_NOREDRAW                    26099
#define VRES_IDC_NOINTHEIGHT                 26100
#define VRES_IDC_MULTICOL                    26101
#define VRES_IDC_HASSTRINGS                  26102
#define VRES_IDC_SELECTION                   26103
#define VRES_IDC_AUTOHSCROLL                 26104
#define VRES_IDC_NODATA                      26104
#define VRES_IDC_AUTOVSCROLL                 26105
#define VRES_IDC_PASSWORD                    26106
#define VRES_IDC_NOHIDESEL                   26107
#define VRES_IDC_OEMCONVERT                  26108
#define VRES_IDC_MULTILINE                   26109
#define VRES_IDC_UPPERCASE                   26110
#define VRES_IDC_LOWERCASE                   26111
#define VRES_IDC_ALIGNTEXTC                  26112
#define VRES_IDC_ALIGNTEXT                   26113
#define VRES_IDC_TYPE                        26114
#define VRES_IDC_MINIMIZEBOX                 26115
#define VRES_IDC_MAXIMIZEBOX                 26116
#define VRES_IDC_SYSTEMMENU                  26117
#define VRES_IDC_CLIPSIBLINGS                26118
#define VRES_IDC_CLIPCHILDREN                26119
#define VRES_IDC_SYSTEMMODAL                 26120
#define VRES_IDC_CLASS                       26121
#define VRES_IDC_CHOICESCAP                  26122
#define VRES_IDC_CHOICES                     26123
#define VRES_IDC_ABSALIGN                    26124
#define VRES_IDC_SHOW                        26125
#define VRES_IDC_EDITCODE                    26126
#define VRES_IDC_CMDMESSAGE_CAP              26127
#define VRES_IDC_CMDMESSAGE                  26128
#define VRES_IDC_TILEGRID                    26129
#define VRES_IDC_PIXELGRID                   26130
#define VRES_IDC_LEFTSCROLLBAR               26140
#define VRES_IDC_RTLREADING                  26141
#define VRES_IDC_RIGHT                       26142
#define VRES_IDC_RTLREADING2                 26142
#define VRES_IDC_RTLRIGHTMENU                26143
#define VRES_IDC_PUSHLIKE                    26143
#define VRES_IDC_ACCEPTFILES                 26143
#define VRES_IDC_CLIENTEDGE                  26144
#define VRES_IDC_CONTROLPARENT               26145
#define VRES_IDC_FLAT                        26146
#define VRES_IDC_WINDOWEDGE                  26146
#define VRES_IDC_NOPARENTNOTIFY              26147
#define VRES_IDC_TOOLWINDOW                  26148
#define VRES_IDC_STATICEDGE                  26150
#define VRES_IDS_ERROR_PIC_BADREF            26153
#define VRES_IDS_ERROR_PIC_HEXFF             26154
#define VRES_IDS_POINT_BOTH                  26155
#define VRES_IDS_POINT_TOPLEFT               26156
#define VRES_IDS_POINT_BOTTOMRIGHT           26157
#define VRES_IDS_ENUM_UD_UNATTACHED          26158
#define VRES_IDS_ENUM_UD_ALIGNLEFT           26159
#define VRES_IDS_ENUM_UD_ALIGNRIGHT          26160
#define VRES_IDC_DDBUTTON                    26160
#define VRES_IDS_ENUM_HORIZONTAL             26161
#define VRES_IDC_SETFONT                     26161
#define VRES_IDS_ENUM_VERTICAL               26162
#define VRES_IDC_DDCHECKBOX                  26162
#define VRES_IDS_ENUM_TC_RIGHT               26163
#define VRES_IDC_DDEDIT                      26163
#define VRES_IDS_ENUM_TC_FIXED               26164
#define VRES_IDC_DDCOMBO                     26164
#define VRES_IDS_ENUM_TC_RAGGED              26165
#define VRES_IDC_DDLISTBOX                   26165
#define VRES_IDS_ENUM_TC_NORMAL              26166
#define VRES_IDC_DDGROUPBOX                  26166
#define VRES_IDS_ENUM_TC_BTNDOWN             26167
#define VRES_IDC_DDRADIO                     26167
#define VRES_IDS_ENUM_TC_NEVER               26168
#define VRES_IDC_DDTEXT                      26168
#define VRES_IDB_CARET0                      26169
#define VRES_IDC_DDPICTURE                   26169
#define VRES_IDB_CARET1                      26170
#define VRES_IDC_DDVSCROLL                   26170
#define VRES_IDB_CARET2                      26171
#define VRES_IDC_DDHSCROLL                   26171
#define VRES_IDB_CARET3                      26172
#define VRES_IDC_DDVBX                       26172
#define VRES_IDB_DROPARROW                   26173
#define VRES_IDC_DDMULTIPLE                  26173
#define VRES_IDB_ELLIPSE1                    26174
#define VRES_IDC_DDMENUITEM                  26174
#define VRES_IDB_ELLIPSE2                    26175
#define VRES_IDC_DDRESOURCE                  26175
#define VRES_IDB_ELLIPSE3                    26176
#define VRES_IDC_DDMULTIRES                  26176
#define VRES_IDB_ELLIPSE4                    26177
#define VRES_IDC_DDCOPYBUTTON                26177
#define VRES_IDB_ELLIPSE5                    26178
#define VRES_IDC_DDCOPYCHECKBOX              26178
#define VRES_IDB_ELLIPSE6                    26179
#define VRES_IDC_DDCOPYEDIT                  26179
#define VRES_IDB_ELLIPSE7                    26180
#define VRES_IDC_DDCOPYCOMBO                 26180
#define VRES_IDB_ELLIPSE8                    26181
#define VRES_IDC_DDCOPYLISTBOX               26181
#define VRES_IDB_IMGTOOLS                    26182
#define VRES_IDC_DDCOPYGROUPBOX              26182
#define VRES_IDB_MAINTOOLS                   26183
#define VRES_IDC_DDCOPYRADIO                 26183
#define VRES_IDB_DLGTOOLS                    26184
#define VRES_IDC_DDCOPYTEXT                  26184
#define VRES_IDB_ZOOMOPT                     26185
#define VRES_IDC_DDCOPYPICTURE               26185
#define VRES_IDB_SELOPT                      26186
#define VRES_IDC_DDCOPYVSCROLL               26186
#define VRES_IDB_AIROPT                      26187
#define VRES_IDC_DDCOPYHSCROLL               26187
#define VRES_IDC_DDCOPYVBX                   26188
#define VRES_IDC_DDCOPYMULTIPLE              26189
#define VRES_IDC_DDCOPYMENUITEM              26190
#define VRES_IDC_DDCOPYRESOURCE              26191
#define VRES_IDC_DDCOPYMULTIRES              26192
#define VRES_IDC_DDCOPYARROW                 26193
#define VRES_IDC_DDUSER                      26194
#define VRES_IDC_DDCOPYUSER                  26195
#define VRES_IDC_DDSTRING                    26196
#define VRES_IDC_DDMULTISTR                  26197
#define VRES_IDC_DDACCEL                     26198
#define VRES_IDC_DDMULTIACC                  26199
#define VRES_IDC_DDCOPYSTRING                26200
#define VRES_IDC_DDCOPYMULTISTR              26201
#define VRES_IDC_DDCOPYACCEL                 26202
#define VRES_IDC_DDCOPYMULTIACC              26203
#define VRES_IDC_DDNODROP                    26204
#define VRES_IDC_DDANIMATE                   26205
#define VRES_IDC_DDCOPYSYSTAB                26206
#define VRES_IDC_DDCOPYANIMATE               26207
#define VRES_IDC_DDSYSTAB                    26208
#define VRES_IDDP_SYSTAB_STYLES              26209
#define VRES_IDDP_SYSTAB_GENERAL             26210
#define VRES_IDDP_ANIMATE_GENERAL            26211
#define VRES_IDC_FILENAMECAP                 26212
#define VRES_IDC_SCRALIGN                    26213
#define VRES_IDC_SYMHEADER                   26213
#define VRES_IDC_XPOS                        26213
#define VRES_IDC_FILENAME                    26213
#define VRES_IDC_DISABLENOSCROLL             26213
#define VRES_IDC_OBJECT_TYPES                26213
#define VRES_IDS_LOAD_OLEBMPS                26213
#define VRES_IDC_RO_INC                      26214
#define VRES_IDS_MSG_MAP                     26214
#define VRES_IDC_PROJNAME                    26214
#define VRES_IDC_BUTTONWIDTH                 26214
#define VRES_IDC_COMPILE_INC                 26215
#define VRES_IDC_YPOS                        26215
#define VRES_IDS_CTL_LAY                     26215
#define VRES_IDC_BUILTBY                     26215
#define VRES_IDC_BUTTONHEIGHT                26215
#define VRES_IDC_DATE                        26216
#define VRES_IDS_RESOURCE                    26216
#define VRES_IDOK2                           26216
#define VRES_IDC_REGISTER                    26216
#define VRES_IDC_HIDDEN                      26217
#define VRES_IDS_TAB_RESOURCE                26217
#define VRES_IDS_CAP_RESOURCE                26218
#define VRES_IDMB_OLECONTROL                 26219
#define VRES_IDS_NOMFCNO_OLE                 26220
#define VRES_IDS_DISK_SPACE_UNAVAIL          26221
#define VRES_IDC_BIGICON                     26221
#define VRES_IDC_SAMPLE                      26221
#define VRES_IDS_DISK_SPACE                  26222
#define VRES_IDS_MATH_COPR_NOTPRESENT        26223
#define VRES_IDS_MATH_COPR_PRESENT           26224
#define VRES_IDS_AVAIL_MEM                   26225
#define VRES_IDC_MFCICON                     26226
#define VRES_IDS_UPDOWN_CONTROL              26226
#define VRES_IDS_PROGRESS_CONTROL            26227
#define VRES_IDS_TRACKBAR_CONTROL            26228
#define VRES_IDS_PALETTE                     26229
#define VRES_IDC_SIMPLE                      26229
#define VRES_IDS_TEXTTOOL                    26230
#define VRES_IDS_HOTKEY_CONTROL              26231
#define VRES_IDC_TYPE_NAME                   26232
#define VRES_IDS_LISTVIEW_CONTROL            26232
#define VRES_IDS_TREEVIEW_CONTROL            26233
#define VRES_IDC_EXTERN_FILE                 26234
#define VRES_IDS_SYSTAB_CONTROL              26234
#define VRES_IDS_ANIMATE_CONTROL             26235
#define VRES_IDC_VS_FF_DEBUG                 26235
#define VRES_IDS_OLE_CONTROL                 26236
#define VRES_IDC_VS_FF_PRERELEASE            26236
#define VRES_IDC_LANGID                      26237
#define VRES_IDS_TIP_LEFTMARGIN              26238
#define VRES_IDC_CODEPAGE                    26238
#define VRES_IDS_TIP_RIGHTMARGIN             26239
#define VRES_IDC_USES_MFC                    26239
#define VRES_IDS_TIP_TOPMARGIN               26240
#define VRES_IDC_TEST_3D                     26240
#define VRES_IDS_TIP_BOTTOMMARGIN            26241
#define VRES_IDC_AUTOTICKS                   26241
#define VRES_IDS_TIP_VERTGUIDE               26242
#define VRES_IDC_SELRANGE                    26242
#define VRES_IDS_TIP_HORZGUIDE               26243
#define VRES_IDC_AUTOBUDDY                   26243
#define VRES_IDS_TIP_LEFTTGUIDE              26244
#define VRES_IDC_NOTHOUSANDS                 26244
#define VRES_IDS_TIP_LEFTGUIDE               26245
#define VRES_IDC_VERTICAL                    26245
#define VRES_IDS_TIP_RIGHTGUIDE              26246
#define VRES_IDC_HORIZONTAL                  26246
#define VRES_IDS_TIP_VPROPGUIDE              26247
#define VRES_IDC_WRAP                        26247
#define VRES_IDS_TIP_TOPGUIDE                26248
#define VRES_IDC_ALIGNRIGHT                  26248
#define VRES_IDS_TIP_BOTTOMGUIDE             26249
#define VRES_IDC_ALIGNLEFT                   26249
#define VRES_IDS_TIP_HPROPGUIDE              26250
#define VRES_IDC_SETBUDDYINT                 26250
#define VRES_IDS_TIP_GUIDETYPE               26251
#define VRES_IDC_PERCENTAGE                  26251
#define VRES_IDC_POSITION                    26252
#define VRES_IDC_ARROWKEYS                   26253
#define VRES_IDC_POINT                       26254
#define VRES_IDC_TICKMARKS                   26255
#define VRES_IDC_HASBUTTONS                  26256
#define VRES_IDC_ORIENTATION                 26256
#define VRES_IDC_HASLINES                    26257
#define VRES_IDC_LINESATROOT                 26258
#define VRES_IDC_SINGLESEL                   26260
#define VRES_IDC_DISABLEDRAGDROP             26260
#define VRES_IDC_SHOWSELALWAYS               26261
#define VRES_IDC_SHAREIMAGELISTS             26262
#define VRES_IDC_NOLABELWRAP                 26263
#define VRES_IDC_AUTOARRANGE                 26264
#define VRES_IDC_EDITLABELS                  26265
#define VRES_IDC_NOSCROLL                    26266
#define VRES_IDC_OWNERDRAWFIXED              26267
#define VRES_IDC_NOSORTHEADER                26268
#define VRES_IDC_NOCOLUMNHEADER              26269
#define VRES_IDC_VIEW_LBL                    26270
#define VRES_IDC_VIEW                        26271
#define VRES_IDC_LISTSORT_LBL                26272
#define VRES_IDC_LISTSORT                    26273
#define VRES_IDC_ALIGN_LBL                   26274
#define VRES_IDC_ALIGN                       26275
#define VRES_IDC_CONTROL_PATH                26276
#define VRES_IDC_LANGUAGE                    26276
#define VRES_IDC_CONDITION_CAP               26277
#define VRES_IDC_CONDITION                   26278
#define VRES_IDC_LANGUAGE_CAP                26280
#define VRES_IDC_SHOWGRID                    26282
#define VRES_IDC_SHOWRULERS                  26284
#define VRES_IDC_DRAGTOOL                    26285
#define VRES_IDC_CLEAR_ALL_GUIDES            26285
#define VRES_IDC_CLEAR_HORZ_GUIDES           26287
#define VRES_IDC_CLEAR_VERT_GUIDES           26288
#define VRES_IDC_FORCEICONLEFT               26288
#define VRES_IDC_FORCELABELLEFT              26289
#define VRES_IDC_FIXEDWIDTH                  26291
#define VRES_IDC_FOCUSONBUTTONDOWN           26292
#define VRES_IDC_TOOLTIPS                    26294
#define VRES_IDC_DDUPDOWN                    26295
#define VRES_IDC_FOCUSNEVER                  26295
#define VRES_IDC_DDCOPYUPDOWN                26296
#define VRES_IDC_DDTRACKBAR                  26297
#define VRES_IDC_BUTTONS                     26297
#define VRES_IDC_DDCOPYTRACKBAR              26298
#define VRES_IDC_RAGGEDRIGHT                 26298
#define VRES_IDC_DDPROGRESS                  26299
#define VRES_IDC_CENTER                      26299
#define VRES_IDC_DDCOPYPROGRESS              26300
#define VRES_IDC_TRANSPARENT                 26300
#define VRES_IDC_DDHOTKEY                    26301
#define VRES_IDC_AUTOPLAY                    26301
#define VRES_IDC_DDCOPYHOTKEY                26302
#define VRES_IDC_FOCUS                       26302
#define VRES_IDC_CUSTOMTYPE                  26302
#define VRES_IDC_DDLISTVIEW                  26303
#define VRES_IDC_RESTREE                     26303
#define VRES_IDC_DDCOPYLISTVIEW              26304
#define VRES_IDC_DDCOPYTREEVIEW              26305
#define VRES_IDC_DDTREEVIEW                  26306
#define VRES_IDC_HSPLIT                      26307
#define VRES_IDC_BRUSH                       26308
#define VRES_IDC_BULLSEYE                    26309
#define VRES_IDC_CROSSHAIR                   26310
#define VRES_IDC_EYEDROP                     26311
#define VRES_IDC_FLOOD                       26312
#define VRES_IDC_PENCIL                      26313
#define VRES_IDC_ZOOMIN                      26314
#define VRES_IDC_RED                         26339
#define VRES_IDC_GREEN                       26340
#define VRES_IDC_BLUE                        26341
#define VRES_IDC_HUE                         26342
#define VRES_IDC_SAT                         26343
#define VRES_IDC_LUM                         26344
#define VRES_IDC_RAINBOW                     26345
#define VRES_IDC_LUMSCROLL                   26346
#define VRES_IDC_CURRENT                     26347
#define VRES_IDC_HUESPIN                     26348
#define VRES_IDC_SATSPIN                     26349
#define VRES_IDC_LUMSPIN                     26350
#define VRES_IDC_REDSPIN                     26351
#define VRES_IDC_GREENSPIN                   26352
#define VRES_IDC_BLUESPIN                    26353
#define VRES_IDS_ERROR                       26354
#define VRES_IDS_ERROR_NOTVALID              26355
#define VRES_IDS_ERROR_BAD_DRIVE             26356
#define VRES_IDS_ERROR_OPEN                  26357
#define VRES_IDS_ERROR_READLOAD              26358
#define VRES_IDS_ERROR_SAVEOK                26359
#define VRES_IDS_ERROR_SAVERO                26360
#define VRES_IDS_ERROR_EXISTS                26361
#define VRES_IDS_ERROR_COMPEX                26362
#define VRES_IDS_ERROR_DOES_NOT_EXIST        26363
#define VRES_IDS_ERROR_BADLANGCP             26364
#define VRES_IDS_ERROR_NEEDCP                26365
#define VRES_IDS_ERROR_NEEDCPTOOPEN          26366
#define VRES_IDS_ERROR_RCPROB                26367
#define VRES_IDS_ERROR_INCPROB               26368
#define VRES_IDS_ERROR_WHAAAT                26369
#define VRES_IDS_ERROR_RCWRITE               26370
#define VRES_IDS_ERROR_INCNOT                26371
#define VRES_IDS_ERROR_SAVEOVEROPEN          26372
#define VRES_IDS_ERROR_RCOVERWRITE           26373
#define VRES_IDS_ERROR_NOUPDATERESOURCE      26374
#define VRES_IDS_ERROR_NEED_RCXDTI           26375
#define VRES_IDS_ERROR_FILE_TEMPLATE         26376
#define VRES_IDS_CONVERTIMAGE                26377
#define VRES_IDS_PALINDEX                    26378
#define VRES_IDS_RED                         26379
#define VRES_IDS_GREEN                       26380
#define VRES_IDS_BLUE                        26381
#define VRES_IDS_ERROR_IMPORTSTDRES          26382
#define VRES_IDS_ERROR_NOTVALID_RC           26383
#define VRES_IDS_ERROR_NOTVALID_EXE          26384
#define VRES_IDS_ERROR_NOTVALID_RES          26385
#define VRES_IDS_ERROR_NOTVALID_BMP          26386
#define VRES_IDS_ERROR_NOTVALID_ICO          26387
#define VRES_IDS_ERROR_NOTVALID_CUR          26388
#define VRES_IDS_ERROR_EMPTYSTRING           26389
#define VRES_IDS_ERROR_EMPTYKEY              26390
#define VRES_IDS_ERROR_SAVE_ABORTED          26391
#define VRES_IDS_ERROR_NT_RES                26392
#define VRES_IDS_NOPALETTES                  26393
#define VRES_IDS_ERROR_UNKNOWN_FILE_TYPE     26394
#define VRES_IDS_ERROR_TEMPLATE_CHANGE       26395
#define VRES_IDS_ERROR_EXE_INUSE             26396
#define VRES_IDS_ERROR_EXE_EMPTY             26397
#define VRES_IDS_ERROR_EXE_HDR               26398
#define VRES_IDS_ERROR_EXE_HDRMZ             26399
#define VRES_IDS_ERROR_EXE_HDRWV             26400
#define VRES_IDS_ERROR_EXE_HDRNW             26401
#define VRES_IDS_ERROR_EXE_SAVE              26402
#define VRES_IDS_ERROR_EXE_ALIGN             26403
#define VRES_IDS_ERROR_EXE_ALLOC             26404
#define VRES_IDS_ERROR_RES_SAVE              26405
#define VRES_IDS_ERROR_SAVE                  26406
#define VRES_IDS_ERROR_NOCONVERT             26407
#define VRES_IDS_ERROR_RES_OPEN              26408
#define VRES_IDS_ERROR_SED_SAMEID            26409
#define VRES_IDS_ERROR_SAMENAME              26410
#define VRES_IDS_ERROR_HEADERLOOP            26411
#define VRES_IDS_ERROR_DLGINIT_COMBOID       26412
#define VRES_IDS_ERROR_DLGINIT_OCXID         26413
#define VRES_IDS_PRJ_RESSCRIPT_NOT_EXIST     26414
#define VRES_IDS_ERROR_SYM_DUPNAME           26415
#define VRES_IDS_ERROR_SYM_BADNAME           26416
#define VRES_IDS_ERROR_ID_DUPVALUE           26417
#define VRES_IDS_ERROR_SYM_INUSE             26418
#define VRES_IDS_ERROR_SYM_INUSE2            26419
#define VRES_IDS_ERROR_SYM_NOSYMS            26420
#define VRES_IDS_ERROR_SYM_EXISTS            26421
#define VRES_IDS_ERROR_SYM_READONLY          26422
#define VRES_IDS_ERROR_BAD_ACCKEY            26423
#define VRES_IDS_ERROR_BINARY_WARN           26424
#define VRES_IDS_ERROR_TABLE_FULL            26425
#define VRES_IDS_ERROR_BADVK                 26426
#define VRES_IDS_ERROR_TABLE_TOO_BIG         26427
#define VRES_IDS_ERROR_ID_NONE               26428
#define VRES_IDS_ERROR_ID_BADCHARS           26429
#define VRES_IDS_ERROR_ID_RANGE              26430
#define VRES_IDS_ERROR_ID_RESRANGE           26431
#define VRES_IDS_ERROR_ID_ILLEGAL            26432
#define VRES_IDS_ERROR_ID_RESDUP             26433
#define VRES_IDS_ERROR_ID_RESHEX             26434
#define VRES_IDS_ERROR_ID_DUPSYM             26435
#define VRES_ID_ERROR_ID_TYPERANGE           26436
#define VRES_IDS_ERROR_GRIDRANGE             26437
#define VRES_IDS_ERROR_NEWCOPYCONFLICT       26438
#define VRES_IDS_ERROR_NOMEMORY              26439
#define VRES_IDS_ERROR_LOWMEMORY             26440
#define VRES_IDS_ERROR_DELETEDEVRES          26441
#define VRES_IDS_ERROR_DISABLEPOPUP          26442
#define VRES_IDS_ERROR_DELETEPOPUP           26443
#define VRES_IDS_ERROR_GROUP                 26444
#define VRES_IDS_ERROR_INVALIDSTYLE          26445
#define VRES_IDS_ERROR_DUP_VERBLOCK          26446
#define VRES_IDS_ERROR_VEREXISTS             26447
#define VRES_IDS_ERROR_CANTDISPLAYIMAGE      26448
#define VRES_IDS_ERROR_EMPTYICON             26449
#define VRES_IDS_ERROR_EMPTYCURSOR           26450
#define VRES_IDS_ERROR_BITMAPFORMAT          26451
#define VRES_IDS_ERROR_BITMAPCOLORS          26452
#define VRES_IDS_ERROR_BITMAP_TOOMANYCOLORS  26454
#define VRES_IDS_ERROR_PE_CANTLOADRES        26455
#define VRES_IDS_ERROR_PE_CANTUPDATERES      26456
#define VRES_IDS_ERROR_PE_CANTLOADLIB        26457
#define VRES_IDS_ERROR_PE_CANTENUMRES        26458
#define VRES_IDS_ERROR_NEWCOPYSAME           26459
#define VRES_IDS_ERROR_CONDITION_BADNAME     26460
#define VRES_IDS_ERROR_DLGINIT_LOAD          26461
#define VRES_IDS_DOING_RC                    26462
#define VRES_IDS_ERROR_NORCDLL               26463
#define VRES_IDS_ERROR_LOADVBX               26464
#define VRES_IDS_INSTALLCLOSE                26465
#define VRES_IDS_ERROR_LOADDLGWITHVBX        26466
#define VRES_IDS_ERROR_NOTOCXFILE            26467
#define VRES_IDS_ERROR_VBXNOINIT             26468
#define VRES_IDS_ERROR_VBXINUSE              26469
#define VRES_IDS_ERROR_VBXNOTAVAIL           26470
#define VRES_IDS_ERROR_OCXREGFAIL            26471
#define VRES_IDS_ERROR_DLGINIT_OLEID         26472
#define VRES_IDS_ERROR_TOOLBUTTONID          26473
#define VRES_IDS_READONLY                    26474
#define VRES_IDS_STRINGSEG                   26475
#define VRES_IDS_LOADING                     26476
#define VRES_IDS_EXE_LOAD                    26477
#define VRES_IDS_EXE_NAMETABLE               26478
#define VRES_IDS_EXE_GROUPS                  26479
#define VRES_IDS_EXE_SAVE_HDR                26480
#define VRES_IDS_EXE_SAVE_SEG1               26481
#define VRES_IDS_EXE_SAVE_RES1               26482
#define VRES_IDS_EXE_SAVE_RES2               26483
#define VRES_IDS_EXE_SAVE_SEG2               26484
#define VRES_IDS_EXE_SAVE_DEB                26485
#define VRES_IDS_RES_LOAD                    26486
#define VRES_IDS_RES_LOAD_SYM                26487
#define VRES_IDS_RES_LOAD_FNAME              26488
#define VRES_IDS_RES_LOAD_NAMTAB             26489
#define VRES_IDS_RES_LOAD_GRP                26490
#define VRES_IDS_RES_SAVE                    26491
#define VRES_IDS_RC_SAVE                     26492
#define VRES_IDS_RC_PREPROCESS               26493
#define VRES_IDS_STRED_VALUE                 26494
#define VRES_IDS_STRED_CAPTION               26495
#define VRES_IDS_RC_COMPILE                  26496
#define VRES_IDS_STRED_LOADST                26497
#define VRES_IDS_ACCED_LOADACC               26498
#define VRES_IDS_STRED_LISTBOX               26499
#define VRES_IDS_ACCED_KEY                   26500
#define VRES_IDS_ACCED_TYPE                  26501
#define VRES_IDS_SYMED_NOT_USED              26502
#define VRES_IDS_SYMED_NEW_SYMBOL            26503
#define VRES_IDS_ACCED_NEXTKEY               26504
#define VRES_IDS_ERROR_BADFONTSIZE           26505
#define VRES_IDS_STRING_SEARCHING            26506
#define VRES_IDS_ERROR_BADFONTFACE           26507
#define VRES_IDS_SAVE_RC                     26508
#define VRES_IDS_SAVE_RCT                    26509
#define VRES_IDS_SAVE_RES32                  26510
#define VRES_IDS_SAVE_RES16                  26511
#define VRES_IDS_SAVE_EXE32                  26512
#define VRES_IDS_SAVE_EXE16                  26513
#define VRES_IDS_SAVE_GENERIC_BINARY         26514
#define VRES_IDS_SAVE_BITMAP                 26515
#define VRES_IDS_SAVE_ICON                   26516
#define VRES_IDS_SAVE_CURSOR                 26517
#define VRES_IDCS_GROUP_STRING               26518
#define VRES_IDCS_NEW                        26519
#define VRES_IDCS_CUSTOM                     26520
#define VRES_IDCS_HWB                        26521
#define VRES_IDCS_CURSOR                     26522
#define VRES_IDCS_BITMAP                     26523
#define VRES_IDCS_ICON                       26524
#define VRES_IDCS_MENU                       26525
#define VRES_IDCS_DIALOG                     26526
#define VRES_IDCS_STRING                     26527
#define VRES_IDCS_ACCELERATOR                26528
#define VRES_IDCS_RCDATA                     26529
#define VRES_IDCS_FONTDIR                    26530
#define VRES_IDCS_FONT                       26531
#define VRES_IDCS_GROUP_ICON                 26532
#define VRES_IDCS_GROUP_CURSOR               26533
#define VRES_IDCS_NAME_TABLE                 26534
#define VRES_IDDP_MENUITEM_GENERAL           26535
#define VRES_IDCS_VERSION                    26536
#define VRES_IDCS_TOOLBAR                    26537
#define VRES_IDB_BDRBAR                      26538
#define VRES_IDCS_DLGINFO                    26539
#define VRES_IDCS_FRAMEWND                   26540
#define VRES_IDB_CTL_LAY                     26541
#define VRES_IDCS_MASKEDDIB                  26542
#define VRES_IDDP_ICON_GENERAL               26543
#define VRES_IDCS_GROUP_MASKEDDIB            26544
#define VRES_IDDP_RESOURCE                   26545
#define VRES_IDDP_STRING_GENERAL             26546
#define VRES_IDS_PC_MENUITEM                 26547
#define VRES_IDCS_DEFAULT                    26548
#define VRES_IDDP_MENU_GENERAL               26549
#define VRES_IDCS_ACCELTABLE                 26550
#define VRES_IDCS_ACCEL                      26551
#define VRES_IDDP_BITMAP_GENERAL             26552
#define VRES_IDCS_TEXTINCLUDE                26553
#define VRES_IDDP_CURSOR_GENERAL             26554
#define VRES_IDDP_ACCEL                      26555
#define VRES_IDCS_BINARY                     26556
#define VRES_IDDP_STRINGTABLE                26557
#define VRES_IDS_CAP_ACCEL                   26558
#define VRES_IDS_PC_MENU                     26559
#define VRES_IDDP_EMPTY                      26561
#define VRES_IDCS_DTI                        26562
#define VRES_IDS_ID                          26564
#define VRES_IDS_IDR                         26565
#define VRES_IDS_IDC                         26566
#define VRES_IDS_IDI                         26567
#define VRES_IDS_IDB                         26568
#define VRES_IDS_IDS                         26569
#define VRES_IDS_IDD                         26570
#define VRES_IDS_STRING                      26571
#define VRES_IDS_PC_STRING                   26572
#define VRES_IDS_INSTALL_ALL                 26573
#define VRES_IDS_INSTALL_CONTROLS            26574
#define VRES_IDS_INSTALL_DOCS                26575
#define VRES_IDCS_TBBUTTON                   26576
#define VRES_IDB_SBSIZE                      26577
#define VRES_IDS_NO_RESOURCES                26577
#define VRES_IDS_RESNODE_LOADFAILED          26578
#define VRES_IDB_SBPOS                       26578
#define VRES_IDDP_BUTTON_GENERAL             26579
#define VRES_IDDP_CTRLCAP_GENERAL            26579
#define VRES_IDDP_RADIO_GENERAL              26580
#define VRES_IDDP_CHECK_GENERAL              26581
#define VRES_IDDP_EDIT_GENERAL               26582
#define VRES_IDDP_CTRLNOCAP_GENERAL          26582
#define VRES_IDDP_GROUPBOX_GENERAL           26583
#define VRES_IDDP_STATICTEXT_GENERAL         26584
#define VRES_IDDP_PICTURE_GENERAL            26585
#define VRES_IDDP_SCROLL_GENERAL             26586
#define VRES_IDDP_DIALOG_GENERAL             26587
#define VRES_IDDP_OC_GENERAL                 26588
#define VRES_IDDP_VB_STYLES                  26589
#define VRES_IDDP_OC_ALLPROP                 26590
#define VRES_IDDP_COMBO_GENERAL              26591
#define VRES_IDDP_LIST_STYLES                26592
#define VRES_IDS_FILTER_COMMON_RES           26592
#define VRES_IDDP_EDIT_STYLES                26593
#define VRES_IDS_FILTER_RESOURCES            26593
#define VRES_IDDP_COMBO_STYLES               26594
#define VRES_IDS_FILTER_IMAGES               26594
#define VRES_IDDP_USER_CTL_GENERAL           26595
#define VRES_IDS_FILTER_EXERES               26595
#define VRES_IDDP_RESOURCE_BITMAP            26596
#define VRES_IDS_FILTER_BITMAPS              26596
#define VRES_IDDP_RESOURCE_DIALOG            26597
#define VRES_IDS_FILTER_ICONS                26597
#define VRES_IDDP_DIALOG_STYLES              26598
#define VRES_IDS_FILTER_CURSORS              26598
#define VRES_IDDP_ACCEL_RESOURCE             26599
#define VRES_IDS_FILTER_WAVES                26599
#define VRES_IDDP_MENU_RESOURCE              26600
#define VRES_IDS_FILTER_FIND_RC              26600
#define VRES_IDDP_DIALOG_RESOURCE            26601
#define VRES_IDDP_LIST_GENERAL               26602
#define VRES_IDD_INSTALLCONTROLS             26603
#define VRES_IDD_SETINCLUDE                  26604
#define VRES_IDS_OPENAS_RESOURCES            26604
#define VRES_IDD_RC_ERROR                    26605
#define VRES_IDS_OPENAS_BINARY               26605
#define VRES_IDD_ACCELNEXTKEY                26606
#define VRES_IDD_NEWRESDLG                   26607
#define VRES_IDD_SYMBOLCHANGE                26608
#define VRES_IDD_SYMBOLBROWSER               26609
#define VRES_IDS_NEWICOIMAGE                 26610
#define VRES_IDD_IMAGE                       26611
#define VRES_IDD_IMGGRIDSETTINGS             26612
#define VRES_IDS_NEWCURIMAGE                 26613
#define VRES_IDS_OPENICOIMAGE                26614
#define VRES_IDS_OPENCURIMAGE                26615
#define VRES_IDS_TARGDEV                     26616
#define VRES_IDS_DUP_IMAGE                   26617
#define VRES_IDS_CURIMAGES                   26618
#define VRES_IDD_GETPALETTE                  26620
#define VRES_IDD_SAVEPALETTE                 26621
#define VRES_IDD_TEST                        26622
#define VRES_IDD_SYMBOLGOTO2                 26623
#define VRES_IDD_SYMBOLGOTO                  26624
#define VRES_IDS_HELP_BUTTON                 26625
#define VRES_IDS_RESOURCE_NEW                26626
#define VRES_IDS_RESOURCE_NEWCOPY            26627
#define VRES_IDS_EDIT_CLEAR                  26628
#define VRES_IDS_ERROR_ALREADYRESEDITING     26639
#define VRES_IDS_ERROR_ALREADYOPEN           26640
#define VRES_IDS_ERROR_CANTRUN               26641
#define VRES_IDS_ERROR_BADFILE               26642
#define VRES_IDS_ERROR_NOFILEFORCW           26643
#define VRES_IDC_SYM_LIST                    26644
#define VRES_IDC_SYM_USEDBY                  26645
#define VRES_IDC_SYM_NAME                    26646
#define VRES_IDS_ERROR_BITMAPSIZE1           26646
#define VRES_IDC_SYM_VALUE                   26647
#define VRES_IDS_ERROR_BITMAPSIZE2           26647
#define VRES_ID_SYM_DONE                     26648
#define VRES_IDS_ERROR_BITMAPSIZE3           26648
#define VRES_ID_SYM_HELP                     26649
#define VRES_ID_SYM_NEW                      26650
#define VRES_ID_SYM_CHANGE                   26651
#define VRES_ID_SYM_DELETE                   26652
#define VRES_ID_SYM_VIEWUSE                  26653
#define VRES_ID_SYM_SHOWREADONLY             26654
#define VRES_IDC_SYM_NAME_STATIC             26655
#define VRES_IDC_SYM_VALUE_STATIC            26656
#define VRES_IDC_READONLY                    26657
#define VRES_IDS_CPOP_ALIGNLEFT              26658
#define VRES_IDS_CPOP_ALIGNTOP               26659
#define VRES_IDS_CPOP_ADDRESOURCE            26660
#define VRES_IDBM_COMPWELL                   26661
#define VRES_IDS_UNDO_GUIDELINES             26662
#define VRES_IDS_PROMPT_RULER_ALT            26663
#define VRES_IDS_PROMPT_RULER_SHIFT          26664
#define VRES_IDS_PROMPT_CONTROL_ALT          26665
#define VRES_IDS_GUIDE_ATTACH_GENERIC        26666
#define VRES_IDS_GUIDE_ATTACH_LEFT           26667
#define VRES_IDS_GUIDE_ATTACH_TOP            26668
#define VRES_IDS_GUIDE_ATTACH_RIGHT          26669
#define VRES_IDS_GUIDE_ATTACH_BOTTOM         26670
#define VRES_IDS_GUIDE_ATTACH_PROPORTIONAL   26671
#define VRES_IDS_GUIDE_ATTACH_RIGHT4         26672
#define VRES_IDS_UNDO_NEW_ACCEL              26673
#define VRES_IDS_STRED_STRINGEDITOR          26674
#define VRES_IDS_UNDO_NEWSTRING              26675
#define VRES_IDS_BORDERBAR                   26676
#define VRES_IDS_DEVICE                      26677
#define VRES_IDS_HOTSPOT                     26678
#define VRES_IDS_UNDO_ROTATE                 26679
#define VRES_IDS_UNDO_RESIZEBITMAP           26680
#define VRES_IDS_UNDO_OLE_PROPS              26681
#define VRES_IDS_UNDO_OLE_CHANGE             26682
#define VRES_IDS_PROMPT_ESCTOCANCEL          26683
#define VRES_IDS_TITLEBAR_FILETYPE           26684
#define VRES_IDS_PUSHBUTTON                  26685
#define VRES_IDS_CTRLCAP_BUTTON              26686
#define VRES_IDS_CHECKBOX                    26687
#define VRES_IDS_CTRLCAP_CHECK               26688
#define VRES_IDS_RADIOBUTTON                 26689
#define VRES_IDS_CTRLCAP_RADIO               26690
#define VRES_IDS_EDIT                        26691
#define VRES_IDS_CTRLCAP_EDIT                26692
#define VRES_IDS_COMBOBOX                    26693
#define VRES_IDS_CTRLCAP_COMBO               26694
#define VRES_IDS_CTRLCAP_LIST                26695
#define VRES_IDS_LISTBOX                     26696
#define VRES_IDS_CTRLCAP_STATIC              26697
#define VRES_IDS_GROUPBOX                    26698
#define VRES_IDS_TEXT                        26699
#define VRES_IDS_PICTURE                     26700
#define VRES_IDS_CTRLCAP_SCROLLBAR           26701
#define VRES_IDS_SCROLLBAR                   26702
#define VRES_IDS_USERCONTROL                 26703
#define VRES_IDS_CTRLCAP_USER                26704
#define VRES_IDS_CTRLCAP_GENERIC             26705
#define VRES_IDS_STATIC                      26706
#define VRES_IDS_UNDO_TYPING                 26707
#define VRES_IDS_DIALOG                      26708
#define VRES_IDS_UNDO_SETFONT                26709
#define VRES_IDS_OK                          26710
#define VRES_IDS_CANCEL                      26711
#define VRES_IDS_UNDO_LAYOUT                 26712
#define VRES_IDS_PROMPT_ESCTEST              26713
#define VRES_IDS_UNDO_SETTAB                 26714
#define VRES_IDS_UNDO_RESIZE                 26715
#define VRES_IDS_UNDO_INSERT                 26716
#define VRES_IDS_CONTROLS                    26717
#define VRES_IDS_GRAPHICS                    26718
#define VRES_IDS_IMAGEEDITOR                 26719
#define VRES_IDS_DIALOGEDITOR                26720
#define VRES_IDS_UNDO_PROPERTYEDIT           26721
#define VRES_IDS_UNDO_NEWDEVICEIMAGE         26722
#define VRES_IDS_UNDO_DELETEDEVICEIMAGE      26723
#define VRES_IDS_PALETTEFILTER               26724
#define VRES_IDS_GETPALETTE                  26725
#define VRES_IDS_UNTITLEDPAL                 26726
#define VRES_IDS_REDUCEPALETTE               26727
#define VRES_IDS_PROPCAP_ICON                26728
#define VRES_IDS_ENUM_CC_MONO                26729
#define VRES_IDS_ENUM_CC_16                  26730
#define VRES_IDS_ENUM_CC_256                 26731
#define VRES_IDS_PROPCAP_CURSOR              26732
#define VRES_IDS_PROPCAP_BITMAP              26733
#define VRES_IDS_ERROR_FILERDONLY            26734
#define VRES_IDS_TRUECOLOR                   26735
#define VRES_IDS_DEVDESC_COLOR               26736
#define VRES_IDS_DEVDESC_MONO                26737
#define VRES_IDS_DEFDEV_STANDARD             26738
#define VRES_IDS_DEFDEV_MONO                 26739
#define VRES_IDS_DEFDEV_SMALL                26740
#define VRES_IDS_DEFDEV_UNKNOWN              26741
#define VRES_IDS_FONTBTN                     26742
#define VRES_IDS_UNDO_SETHOTSPOT             26743
#define VRES_IDS_UNDO_PAINTING               26744
#define VRES_IDS_UNDO_NEWRESOURCE            26745
#define VRES_IDS_OLECONTROL                  26746
#define VRES_IDS_PROPCAP_OLECONTROL          26747
#define VRES_IDS_UNDO_CREATE                 26748
#define VRES_IDS_TITLEBAR_STYLE3             26749
#define VRES_IDS_TITLEBAR_STYLE2             26750
#define VRES_IDS_WINDOW                      26751
#define VRES_IDS_UNDO_VERSIONUPDATE          26752
#define VRES_IDS_VERED_LICENSECOMPANY        26753
#define VRES_IDS_VERED_COPYRIGHT             26754
#define VRES_IDS_ENUM_BS_0                   26755
#define VRES_IDS_ENUM_BS_1                   26756
#define VRES_IDS_ENUM_BS_2                   26757
#define VRES_IDS_ENUM_BS_3                   26758
#define VRES_IDS_ENUM_BS_4                   26759
#define VRES_IDS_ENUM_BS_5                   26760
#define VRES_IDS_ENUM_BHA_0                  26761
#define VRES_IDS_ENUM_BHA_1                  26762
#define VRES_IDS_ENUM_BHA_2                  26763
#define VRES_IDS_ENUM_BHA_3                  26764
#define VRES_IDS_ENUM_BVA_0                  26765
#define VRES_IDS_ENUM_BVA_1                  26766
#define VRES_IDS_ENUM_BVA_2                  26767
#define VRES_IDS_ENUM_BVA_3                  26768
#define VRES_IDS_ENUM_THA_0                  26769
#define VRES_IDS_ENUM_THA_1                  26770
#define VRES_IDS_ENUM_THA_2                  26771
#define VRES_IDS_ENUM_CO_0                   26772
#define VRES_IDS_ENUM_CO_1                   26773
#define VRES_IDS_ENUM_CO_2                   26774
#define VRES_IDS_ENUM_CT_0                   26775
#define VRES_IDS_ENUM_CT_1                   26776
#define VRES_IDS_ENUM_CT_2                   26777
#define VRES_IDS_ENUM_LO_0                   26778
#define VRES_IDS_ENUM_LO_1                   26779
#define VRES_IDS_ENUM_LO_2                   26780
#define VRES_IDS_ENUM_LS_0                   26781
#define VRES_IDS_ENUM_LS_1                   26782
#define VRES_IDS_ENUM_LS_2                   26783
#define VRES_IDS_ENUM_LS_3                   26784
#define VRES_IDS_ENUM_TAH_0                  26785
#define VRES_IDS_ENUM_TAH_1                  26786
#define VRES_IDS_ENUM_TAH_2                  26787
#define VRES_IDS_ENUM_GRFXT_0                26788
#define VRES_IDS_ENUM_GRFXT_1                26789
#define VRES_IDS_ENUM_GRFXT_2                26790
#define VRES_IDS_ENUM_GRFXC_0                26791
#define VRES_IDS_ENUM_GRFXC_1                26792
#define VRES_IDS_ENUM_GRFXC_2                26793
#define VRES_IDS_ENUM_SCRA_0                 26794
#define VRES_IDS_ENUM_SCRA_1                 26795
#define VRES_IDS_ENUM_SCRA_2                 26796
#define VRES_IDS_ENUM_DS_0                   26797
#define VRES_IDS_ENUM_DS_1                   26798
#define VRES_IDS_ENUM_DS_2                   26799
#define VRES_IDS_ENUM_DB_0                   26800
#define VRES_IDS_ENUM_DB_1                   26801
#define VRES_IDS_ENUM_DB_2                   26802
#define VRES_IDS_ENUM_DB_3                   26803
#define VRES_IDS_ENUM_MB_0                   26804
#define VRES_IDS_ENUM_MB_1                   26805
#define VRES_IDS_ENUM_MB_2                   26806
#define VRES_IDS_TITLEBAR_STYLE4             26807
#define VRES_IDS_COLORS                      26808
#define VRES_IDS_ENUM_CS_0                   26809
#define VRES_IDS_ENUM_CS_1                   26810
#define VRES_IDS_ENUM_CS_2                   26811
#define VRES_IDS_ENUM_CS_3                   26812
#define VRES_IDS_ENUM_CS_4                   26813
#define VRES_IDS_ENUM_CS_5                   26814
#define VRES_IDS_ENUM_CS_6                   26815
#define VRES_IDS_ENUM_CS_7                   26816
#define VRES_IDS_ENUM_CS_8                   26817
#define VRES_IDS_ENUM_CS_9                   26818
#define VRES_IDS_ENUM_CS_10                  26819
#define VRES_IDS_ENUM_CS_11                  26820
#define VRES_IDS_UNKNOWN                     26821
#define VRES_IDS_PROPCAP_TLBBTN              26822
#define VRES_IDS_ENUM_LV_ICON                26823
#define VRES_IDS_ENUM_LV_SMALLICON           26824
#define VRES_IDS_ENUM_LV_LIST                26825
#define VRES_IDS_ENUM_LV_REPORT              26826
#define VRES_IDS_ENUM_LV_NONE                26827
#define VRES_IDS_ENUM_LV_ASCENDING           26828
#define VRES_IDS_ENUM_LV_DESCENDING          26829
#define VRES_IDS_ENUM_LV_TOP                 26830
#define VRES_IDS_ENUM_LV_BOTTOM              26831
#define VRES_IDS_ENUM_LV_LEFT                26832
#define VRES_IDS_ENUM_LV_RIGHT               26833
#define VRES_IDS_TOOLBAR_MENUITEM            26834
#define VRES_IDS_CTRLCAP_UPDOWN              26835
#define VRES_IDS_CTRLCAP_PROGRESS            26836
#define VRES_IDS_CTRLCAP_TRACKBAR            26837
#define VRES_IDS_CTRLCAP_HOTKEY              26838
#define VRES_IDS_CTRLCAP_LISTVIEW            26839
#define VRES_IDS_CTRLCAP_TREEVIEW            26840
#define VRES_IDS_CTRLCAP_SYSTAB              26841
#define VRES_IDS_CTRLCAP_ANIMATE             26842
#define VRES_IDS_ERROR_MAXSTRLEN             26843
#define VRES_IDS_ERROR_BAD_OFFSET            26844
#define VRES_IDS_GOTO_OFFSET                 26845
#define VRES_IDS_SAVEPALETTE                 26846
#define VRES_IDS_NEUTRAL                     26847
#define VRES_IDS_NEUTRAL_DEFAULT             26848
#define VRES_IDS_NEUTRAL_SYS_DEFAULT         26849
#define VRES_IDS_ALBANIAN                    26850
#define VRES_IDS_ARABIC                      26851
#define VRES_IDS_BAHASA                      26852
#define VRES_IDS_BULGARIAN                   26853
#define VRES_IDS_CATALAN                     26854
#define VRES_IDS_CHINESE_TAIWAN              26855
#define VRES_IDS_CHINESE_PRC                 26856
#define VRES_IDS_CHINESE_HONG_KONG           26857
#define VRES_IDS_CHINESE_SINGAPORE           26858
#define VRES_IDS_CROATIAN                    26859
#define VRES_IDS_CZECH                       26860
#define VRES_IDS_DANISH                      26861
#define VRES_IDS_DUTCH_NETHERLANDS           26862
#define VRES_IDS_DUTCH_BELGIUM               26863
#define VRES_IDS_ENGLISH_US                  26864
#define VRES_IDS_ENGLISH_UK                  26865
#define VRES_IDS_ENGLISH_AUSTRALIA           26866
#define VRES_IDS_ENGLISH_CANADA              26867
#define VRES_IDS_ENGLISH_NZ                  26868
#define VRES_IDS_ENGLISH_IRELAND             26869
#define VRES_IDS_FINNISH                     26870
#define VRES_IDS_FRENCH_FRANCE               26871
#define VRES_IDS_FRENCH_BELGIUM              26872
#define VRES_IDS_FRENCH_CANADA               26873
#define VRES_IDS_FRENCH_SWITZERLAND          26874
#define VRES_IDS_GERMAN_GERMANY              26875
#define VRES_IDS_GERMAN_SWITZERLAND          26876
#define VRES_IDS_GERMAN_AUSTRIA              26877
#define VRES_IDS_GREEK                       26878
#define VRES_IDS_HEBREW                      26879
#define VRES_IDS_HUNGARIAN                   26880
#define VRES_IDS_ICELANDIC                   26881
#define VRES_IDS_ITALIAN_ITALY               26882
#define VRES_IDS_ITALIAN_SWITZERLAND         26883
#define VRES_IDS_JAPANESE                    26884
#define VRES_IDS_KOREAN                      26885
#define VRES_IDS_NORWEGIAN_BOKMAL            26886
#define VRES_IDS_NORWEGIAN_NYNORSK           26887
#define VRES_IDS_POLISH                      26888
#define VRES_IDS_PORTUGUESE_BRAZIL           26889
#define VRES_IDS_PORTUGUESE_PORTUGAL         26890
#define VRES_IDS_RHAETO_ROMAN                26891
#define VRES_IDS_ROMANIAN                    26892
#define VRES_IDS_RUSSIAN                     26893
#define VRES_IDS_SERBOCROATIAN_CYRILLIC      26894
#define VRES_IDS_SERBOCROATIAN_LATIN         26895
#define VRES_IDS_SLOVAK                      26896
#define VRES_IDS_SLOVENIAN                   26897
#define VRES_IDS_SPANISH_CASTILIAN           26898
#define VRES_IDS_SPANISH_MEXICAN             26899
#define VRES_IDS_SPANISH_MODERN              26900
#define VRES_IDS_SWEDISH                     26901
#define VRES_IDS_THAI                        26902
#define VRES_IDS_TURKISH                     26903
#define VRES_IDS_URDU                        26904
#define VRES_IDS_DEFDEV_256                  26905
#define VRES_IDS_DEFDEV_48                   26906
#define VRES_IDS_ENUM_GRFXT_3                26907
#define VRES_IDS_ENUM_GRFXT_4                26908
#define VRES_IDS_ENUM_GRFXT_5                26909
#define VRES_IDACCEL_ACCELED                 26910
#define VRES_IDS_ENUM_GRFXC_3                26910
#define VRES_IDACCEL_MAIN                    26911
#define VRES_IDACCEL_WNDFRAME                26912
#define VRES_IDACCEL_IMAGE                   26913
#define VRES_IDACCEL_STRED                   26914
#define VRES_IDACCEL_COMPVIEW                26915
#define VRES_IDCUR_MOVE                      26916
#define VRES_IDBM_DRAGHANDLE                 26917
#define VRES_IDBM_DRAGHANDLE2                26918
#define VRES_IDCUR_SIZENWSE                  26919
#define VRES_IDCUR_SIZENESW                  26920
#define VRES_IDCUR_SIZEWE                    26921
#define VRES_IDCUR_SIZENS                    26922
#define VRES_IDCUR_AIRBRUSH                  26923
#define VRES_IDICON_MENU                     26927
#define VRES_IDICON_DLG                      26928
#define VRES_IDICON_STRINGTABLE              26929
#define VRES_IDICON_ACCEL                    26930
#define VRES_IDICON_VERINFO                  26932
#define VRES_IDR_TLBTYPE                     26935
#define VRES_IDS_ENLAGEBITMAPFORCLIP         27184
#define VRES_IDS_ERROR_RESCONFLICT           27185
#define VRES_IDS_ERROR_BARCOLOR              27186
#define VRES_IDS_ERROR_BARSIZECOLOR          27187
#define VRES_IDS_ERROR_BARSIZE               27188
#define VRES_IDS_ERROR_EMPTYBARIMAGE         27189
#define VRES_IDS_ERROR_OPEN_PROJRC           27190
#define VRES_IDS_ERROR_NOEDIT_PROJRC         27191
#define VRES_IDS_ERROR_BARBITMAP             27192
#define VRES_IDS_ERROR_EDITINC               27200
#define VRES_IDS_ZOOMING                     27201
#define VRES_IDS_ERROR_BOGUSFILE             27202
#define VRES_IDS_VER_STRINGFILEINFO          27203
#define VRES_IDS_VER_VARFILEINFO             27204
#define VRES_IDS_VER_KEY                     27205
#define VRES_IDS_VER_VALUE                   27206
#define VRES_IDS_VER_DELCONFIRM              27207
#define VRES_IDS_VER_INITIALPRODNAME         27208
#define VRES_IDC_WANTRETURN                  27210
#define VRES_IDB_OLEDEFAULT                  27211
#define VRES_IDS_ERROR_DUP_SEG               27212
#define VRES_IDB_DROPARROW95                 27212
#define VRES_IDS_ALLFILTER                   27213
#define VRES_IDS_CURFILTER                   27214
#define VRES_IDS_ICOFILTER                   27215
#define VRES_IDS_BMPFILTER                   27216
#define VRES_IDS_WAVFILTER                   27217
#define VRES_IDD_DIALOGBAR_ICON              27218
#define VRES_IDD_DIALOGFONT                  27219
#define VRES_IDDP_RES_CUSTOM                 27220
#define VRES_IDDP_RES_FILE                   27221
#define VRES_IDDP_BITMAP_PALETTE             27222
#define VRES_IDD_COLORSELECTOR               27223
#define VRES_IDD_REDUCECOLORS                27224
#define VRES_IDDP_VER_FILEFLAGS              27225
#define VRES_IDDP_VER_BLOCKHEADER            27226
#define VRES_IDDP_RC_GENERAL                 27227
#define VRES_IDDP_TOOLBAR_BUTTON             27228
#define VRES_IDDP_BITMAP_FILE                27229
#define VRES_IDDP_CURSOR_FILE                27230
#define VRES_IDDP_ICON_FILE                  27231
#define VRES_IDDP_RES_CUSTOM_FILE            27232
#define VRES_IDD_DIALOGBAR_CURSOR            27233
#define VRES_IDDP_TRACKBAR_GENERAL           27234
#define VRES_IDDP_PROGRESS_GENERAL           27235
#define VRES_IDDP_HOTKEY_GENERAL             27236
#define VRES_IDDP_UPDOWN_GENERAL             27237
#define VRES_IDDP_LISTVIEW_GENERAL           27238
#define VRES_IDDP_LISTVIEW_STYLES            27239
#define VRES_IDDP_TREEVIEW_GENERAL           27240
#define VRES_IDD_GUIDELINES                  27241
#define VRES_IDDP_STRING_LANGUAGE            27242
#define VRES_IDD_NEWRESCUSTOM                27243
#define VRES_IDD_CUSTOMTYPE                  27244
#define VRES_IDD_NEWRESDLG_SMALL             27245
#define VRES_IDD_CREATETOOLBAR               27246
#define VRES_IDDP_TOOLBAR                    27247
#define VRES_IDS_ERROR_IMPORT                27250
#define VRES_IDS_ERROR_EXPORT                27251
#define VRES_IDS_ERROR_FILENAMEINUSE         27252
#define VRES_IDS_ERROR_ACCKEY_TO_BIG         27253
#define VRES_IDS_QUERY_MKDIR                 27254
#define VRES_IDS_ERROR_LAUNCH_IDE            27255
#define VRES_IDS_IMPORTING                   27256
#define VRES_IDS_EXPORTING                   27257
#define VRES_IDS_OPENING                     27258
#define VRES_IDS_IMPORTRESOURCE              27259
#define VRES_IDS_EXPORTRESOURCE              27260
#define VRES_IDS_RC_FILE                     27261
#define VRES_IDS_NOCOPYSTRTBL                27262
#define VRES_IDS_NONEWSTRTBL                 27263
#define VRES_IDC_GUIDES0                     27263
#define VRES_IDS_ERROR_TOOLBAR_LOAD          27264
#define VRES_IDC_GUIDES1                     27264
#define VRES_IDC_IMPORT                      27264
#define VRES_IDS_UNDO_NEWBUTTON              27265
#define VRES_IDC_GUIDES2                     27265
#define VRES_IDD_SUSHI_FILEOPEN              27266
#define VRES_IDS_OPENAS_AUTO                 27266
#define VRES_IDD_CHICAGO_FILEOPEN            27267
#define VRES_IDS_OPENAS_CUSTOM               27267
#define VRES_IDS_WARNING_DUPLICATEHK         27268
#define VRES_IDS_MSG_NODUPLICATEHK           27269
#define VRES_IDDP_MENUITEM_EXSTYLES          27270
#define VRES_IDS_IMPORT_OK                   27270
#define VRES_IDDP_BUTTON_EXSTYLES            27271
#define VRES_IDS_EXPORT_OK                   27271
#define VRES_IDDP_RADIO_EXSTYLES             27272
#define VRES_IDDP_CHECK_EXSTYLES             27273
#define VRES_IDDP_LIST_EXSTYLES              27274
#define VRES_IDDP_EDIT_EXSTYLES              27275
#define VRES_IDDP_COMBO_EXSTYLES             27276
#define VRES_IDDP_STATICTEXT_EXSTYLES        27277
#define VRES_IDDP_GROUPBOX_EXSTYLES          27278
#define VRES_IDDP_DIALOG_EXSTYLES            27279
#define VRES_IDS_UNDO_FLIPDIALOG             27280
#define VRES_IDD_NEW_IMAGE                   27280
#define VRES_IDC_NOTE                        27281
#define VRES_IDD_CUSTOM_IMAGE                27281
#define VRES_IDS_ERROR_CP_STRING_INVALID     27281
#define VRES_IDD_SUSHI_FILESAVE              27282
#define VRES_IDDP_BUTTON_STYLES              27283
#define VRES_IDDP_CHECK_STYLES               27284
#define VRES_IDDP_RADIO_STYLES               27285
#define VRES_IDDP_STATICTEXT_STYLES          27286
#define VRES_IDDP_PICTURE_STYLES             27287
#define VRES_IDDP_UPDOWN_STYLES              27288
#define VRES_IDDP_TREEVIEW_STYLES            27289
#define VRES_IDDP_TRACKBAR_STYLES            27290
#define VRES_IDDP_DIALOG_STYLES2             27291
#define VRES_IDDP_PICTURE_EXSTYLES           27292
#define VRES_IDDP_SYSTAB_EXSTYLES            27293
#define VRES_IDDP_GROUPBOX_STYLES            27294
#define VRES_IDS_FILTER_VBFORMS              27326
#define VRES_IDS_VBSYNTAXERROR               27327
#define VRES_ID_CUSTOM                       27329
#define VRES_IDDP_UPDOWN_EXSTYLES            27331
#define VRES_IDDP_PROGRESS_EXSTYLES          27332
#define VRES_IDDP_TRACKBAR_EXSTYLES          27333
#define VRES_IDC_HELPID                      27334
#define VRES_IDDP_HOTKEY_EXSTYLES            27334
#define VRES_IDC_HORZALIGN_LBL               27335
#define VRES_IDDP_LISTVIEW_EXSTYLES          27335
#define VRES_IDC_HORZALIGN                   27336
#define VRES_IDDP_TREEVIEW_EXSTYLES          27336
#define VRES_IDS_VBERR_OC_NOT_INSTALLED      27337
#define VRES_IDC_VERTALIGN_LBL               27337
#define VRES_IDDP_ANIMATE_EXSTYLES           27337
#define VRES_IDS_CANTOPENFRX                 27338
#define VRES_IDC_VERTALIGN                   27338
#define VRES_IDS_ERROR_UNLICENSED_OC         27339
#define VRES_IDC_ICONBITMAP_LBL              27339
#define VRES_IDB_STATIC_BITMAP               27339
#define VRES_IDB_PANEGLYPH_BITMAP            27340
#define VRES_IDS_ERROR_INVPROP               27340
#define VRES_IDC_ICONBITMAP                  27340
#define VRES_IDC_NUMBER                      27341
#define VRES_IDS_GOTOOFFSET_WHAT             27341
#define VRES_IDC_HALIGN_LBL                  27342
#define VRES_IDS_GOTOOFFSET_PROMPT           27342
#define VRES_IDC_HALIGN                      27343
#define VRES_IDS_GOTOOFFSET_HELP             27343
#define VRES_IDC_BTNBITMAP                   27344
#define VRES_IDC_BTNICON                     27345
#define VRES_IDC_DLGMODALFRAME               27346
#define VRES_IDC_DEFAULT_APP_ICON            27347
#define VRES_IDD_CHOOSE_OC                   27349
#define VRES_IDC_OCLIST                      27350
#define VRES_IDC_STATIC_OC_NAME              27351
#define VRES_AFX_IDC_CONTEXTHELP             30977
#define VRES_AFX_IDP_FAILED_TO_LAUNCH_HELP   0xF107

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define VRES__APS_3D_CONTROLS                     1
#define VRES__APS_NEXT_RESOURCE_VALUE        27341
#define VRES__APS_NEXT_COMMAND_VALUE         27329
#define VRES__APS_NEXT_CONTROL_VALUE         27352
#define VRES__APS_NEXT_SYMED_VALUE           27329
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\sym\68k\optncplr.h ===
//{{NO_DEPENDENCIES}}
// compiler option control IDs

// 'Macintosh 68k' Category IDs
#define OPTNCPLR_IDDP_COMPILER_MAC68K	18452
#define OPTNCPLR_IDC_MODEL68K		0x4C00
#define OPTNCPLR_IDC_CPLR_Q68S		0x4c01
#define OPTNCPLR_IDC_CPLR_Q68B		0x4c02
#define OPTNCPLR_IDC_CPLR_Q68M		0x4c03
#define OPTNCPLR_IDC_CALLCONV_MAC	0x4c04
#define OPTNCPLR_IDC_INSTTYPE		0x4c05

#define OPTNCPLR_IDC_TXT_MODEL68K	0x4C10
#define OPTNCPLR_IDC_TXT_CALLCONV	0x4C11
#define OPTNCPLR_IDC_TXT_INSTTYPE	0x4C12
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\sym\vshell.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by vshell.rc
//
#define VSHELL_IDC_PROJ_NAME                   100
#define VSHELL_IDC_WORKSPACE_NAME              101
#define VSHELL_IDC_LISTFILES                   101
#define VSHELL_IDC_CHANGE                      102
#define VSHELL_IDC_FIND_WHAT                   102
#define VSHELL_IDC_PROJ_TYPE                   103
#define VSHELL_IDC_FIND_NEXT                   103
#define VSHELL_IDC_FIND_WHOLEWORD              104
#define VSHELL_IDC_FIND_MATCHUPLO              105
#define VSHELL_IDC_FIND_REGEXP                 107
#define VSHELL_IDC_KEYWORD                     108
#define VSHELL_IDC_FIND_UP                     113
#define VSHELL_IDC_FIND_DOWN                   114
#define VSHELL_IDC_BARTEXT                     212
#define VSHELL_IDC_STATIC_WINDOW               1001
#define VSHELL_IDC_TIP_SHOW                    1001
#define VSHELL_IDC_TIP_NEXT                    1002
#define VSHELL_IDC_STATIC_SIZE                 1003
#define VSHELL_IDC_COMBO_FONT_NAME             1004
#define VSHELL_IDC_COMBO_FONT_SIZE             1005
#define VSHELL_IDC_LIST_ELEMENTS               1007
#define VSHELL_IDC_COMBO_FORE_COLOR            1008
#define VSHELL_IDC_COMBO_BACK_COLOR            1009
#define VSHELL_IDC_COLOR_GROUP                 1014
#define VSHELL_IDC_STATIC_FORE_COLOR           1018
#define VSHELL_IDC_STATIC_BACK_COLOR           1019
#define VSHELL_IDC_SAMPLE                      1030
#define VSHELL_IDC_EDITOR_LIST                 1031
#define VSHELL_IDC_NETWORK                     0x40d
#define VSHELL_ID_PAGESETUP_HEADER             1161
#define VSHELL_ID_PAGESETUP_FOOTER             1162
#define VSHELL_ID_PAGESETUP_LEFT               1163
#define VSHELL_ID_PAGESETUP_RIGHT              1164
#define VSHELL_ID_PAGESETUP_TOP                1165
#define VSHELL_ID_PAGESETUP_BOTTOM             1166
#define VSHELL_ID_PAGESETUP_FIELDS             1167
#define VSHELL_IDD_BWIZ_ENUM                   20179
#define VSHELL_IDS_PROP_GENERAL                20180
#define VSHELL_IDS_PROP_CONTROL                20181
#define VSHELL_IDS_PROP_ERROR_INVPROP          20182
#define VSHELL_IDS_PROP_NOPROP                 20183
#define VSHELL_IDS_PROP_TRUE                   20184
#define VSHELL_IDS_PROP_FALSE                  20185
#define VSHELL_IDS_PROP_ERROR_NOPAGEHELP       20186
#define VSHELL_IDS_PROP_ALL                    20187
#define VSHELL_IDS_UNDO_OLE_PROPS              20188
#define VSHELL_IDS_PROP_UNKNOWNPROP            20189
#define VSHELL_ID_SBAR_PROGRESS                20398
#define VSHELL_IDCT_SHELLPACKAGE               20398
#define VSHELL_IDS_ERROR_FILE_TEMPLATE         20399
#define VSHELL_IDS_ERROR_FILE                  20400
#define VSHELL_IDS_ERROR_CANT_SAVETEMP         20432
#define VSHELL_IDS_ERROR_CANT_SAVERO           20433
#define VSHELL_IDS_ERROR_TOOLBAR_CREATE        20434
#define VSHELL_IDS_ERROR_CANT_DELETE_FILE      20435
#define VSHELL_IDS_INVALID_PROJECT_NAME        20436
#define VSHELL_IDS_SUBDIR_ERROR                20437
#define VSHELL_IDS_ERROR_NEED_FULL_PATH        20438
#define VSHELL_IDS_PATH_TOO_LONG               20439
#define VSHELL_IDS_ERR_OLDPKG                  20440
#define VSHELL_IDS_ERROR_DUPLICATE_TOOLBAR_NAME 20441
#define VSHELL_IDS_RESETTOOLBAR                20481
#define VSHELL_IDS_DELETETOOLBAR               20482
#define VSHELL_IDS_RepeatCount                 20483
#define VSHELL_IDS_SAMPLE_LINE                 20484
#define VSHELL_IDS_AUTOMATIC                   20485
#define VSHELL_IDS_ALLWINDOWS                  20486
#define VSHELL_IDS_MULTIPLE_FONTS              20487
#define VSHELL_IDS_BUTTONLABEL                 20488
#define VSHELL_IDS_TEXTBUTTON                  20489
#define VSHELL_IDS_NOT_WIN32S                  20490
#define VSHELL_IDS_SAMPLE_TURKISH              20491
#define VSHELL_IDS_SAMPLE_HEBREW               20492
#define VSHELL_IDC_TOOLBAR                     20504
#define VSHELL_IDC_DELETE                      20505
#define VSHELL_IDC_PLACEHOLDER                 20506
#define VSHELL_IDC_RESET                       20506
#define VSHELL_IDC_CUSTOM                      20507
#define VSHELL_IDB_BITMAP_TRUETYPE             20509
#define VSHELL_IDC_ASSIGN                      20510
#define VSHELL_IDC_NAME                        20511
#define VSHELL_IDC_REMOVE                      20512
#define VSHELL_IDC_CATEGORIES                  20514
#define VSHELL_IDC_RESET_ALL                   20515
#define VSHELL_IDC_TOOLS                       20516
#define VSHELL_IDC_CAT_LIST                    20517
#define VSHELL_IDC_DESCRIPTION                 20518
#define VSHELL_IDC_CMD_LIST                    20519
#define VSHELL_IDC_NEW                         20520
#define VSHELL_IDC_KEY_LIST                    20521
#define VSHELL_IDD_NEWTYPEDLG                  20521
#define VSHELL_IDD_SUSHI_FILEOPEN              20522
#define VSHELL_IDS_RESETALLKEYS                20522
#define VSHELL_IDS_MENUACCESS                  20523
#define VSHELL_IDD_CHICAGO_FILEOPEN            20523
#define VSHELL_IDC_AVAILABLE                   20524
#define VSHELL_IDD_CHICAGO_WRKSPCOPEN          20524
#define VSHELL_IDC_USEDBY                      20525
#define VSHELL_IDC_USEDBY_CAP                  20526
#define VSHELL_IDB_CHECKLISTBOXES              20528
#define VSHELL_IDR_ACCEL_PROP                  20530
#define VSHELL_IDC_EDITOR                      20531
#define VSHELL_IDC_EDITOR_CAP                  20532
#define VSHELL_IDC_SHORTCUTKEY                 20535
#define VSHELL_IDS_UNDO_CANCEL                 20536
#define VSHELL_IDS_UNDO_ONE                    20537
#define VSHELL_IDS_UNDO_N                      20538
#define VSHELL_IDS_REDO_ONE                    20539
#define VSHELL_IDS_REDO_N                      20540
#define VSHELL_IDB_MAINTOOLS                   20543
#define VSHELL_IDS_POPUP_TOOLBARS              20544
#define VSHELL_IDS_POPUP_CUSTOMIZE             20545
#define VSHELL_IDS_POPUP_CLOSE                 20546
#define VSHELL_IDCUR_BLACKARROW                20549
#define VSHELL_IDS_NODOCK_WINDOW               20550
#define VSHELL_IDDP_CUSTOMIZE_TOOLBARS         20551
#define VSHELL_IDD_NEWTOOLBAR                  20552
#define VSHELL_IDD_TOOLBARS                    20553
#define VSHELL_IDDP_CUSTOMIZE_KEYBOARD         20554
#define VSHELL_IDS_FEXCEP_NONE                 20558
#define VSHELL_IDS_FEXCEP_GENERIC              20559
#define VSHELL_IDS_FEXCEP_NOTFOUND             20560
#define VSHELL_IDS_FEXCEP_BADPATH              20561
#define VSHELL_IDS_FEXCEP_2MANYFILES           20562
#define VSHELL_IDS_FEXCEP_DENIED               20563
#define VSHELL_IDS_FEXCEP_INVALIDFILE          20564
#define VSHELL_IDS_FEXCEP_RDCURRENT            20565
#define VSHELL_IDS_FEXCEP_DIRFULL              20566
#define VSHELL_IDS_FEXCEP_BADSEEK              20567
#define VSHELL_IDS_FEXCEP_IOERR                20568
#define VSHELL_IDS_FEXCEP_SHARING              20569
#define VSHELL_IDS_FEXCEP_LOCK                 20570
#define VSHELL_IDS_FEXCEP_DISKFULL             20571
#define VSHELL_IDS_FEXCEP_EOF                  20572
#define VSHELL_IDS_FILE_ERROR_FORMAT           20575
#define VSHELL_IDS_INTERNAL_ERROR              20576
#define VSHELL_IDS_AUTOSAVE_DETECTED_BACKUP    20577
#define VSHELL_IDS_AUTOSAVE_ERROR              20578
#define VSHELL_IDS_AUTOSAVE_READONLY           20579
#define VSHELL_IDS_AUTOSAVE_BAD_INTERVAL       20580
#define VSHELL_IDDP_NOPAGE                     20581
#define VSHELL_IDDP_MUL                        20582
#define VSHELL_IDDP_NUL                        20583
#define VSHELL_IDMX_NEXTPAGE                   20584
#define VSHELL_IDMX_PREVPAGE                   20585
#define VSHELL_IDMX_OKPAGE                     20589
#define VSHELL_IDMX_CANCELPAGE                 20590
#define VSHELL_IDB_UNDO                        20591
#define VSHELL_IDB_REDO                        20592
#define VSHELL_IDB_REDODISABLED                20593
#define VSHELL_IDB_UNDODISABLED                20594
#define VSHELL_IDDP_OPTIONS_WORKSPACE          20595
#define VSHELL_IDC_AUTO_WORKSPACE              20596
#define VSHELL_IDS_DOCKABLE_MOVE               20597
#define VSHELL_IDS_DOCKABLE_SIZE               20598
#define VSHELL_IDS_DOCKABLE_CLOSE              20599
#define VSHELL_IDS_DRAG_MOVE                   20600
#define VSHELL_IDS_DRAG_COPY                   20601
#define VSHELL_IDC_VIEWS                       20602
#define VSHELL_IDS_DRAG_CANCEL                 20602
#define VSHELL_ID_TOOLS_MENUCONTENTS           20603
#define VSHELL_ID_TOOLS_MENUTEXT               20604
#define VSHELL_ID_TOOLS_PATHNAME               20605
#define VSHELL_ID_TOOLS_ARGUMENTS              20606
#define VSHELL_ID_TOOLS_INITDIR                20607
#define VSHELL_ID_TOOLS_STAT_MENUTEXT          20608
#define VSHELL_ID_TOOLS_STAT_PATHNAME          20609
#define VSHELL_ID_TOOLS_STAT_ARGUMENTS         20610
#define VSHELL_ID_TOOLS_STAT_INITDIR           20611
#define VSHELL_ID_TOOLS_ASKARGUMENTS           20612
#define VSHELL_ID_TOOLS_MOVEUP                 20613
#define VSHELL_ID_TOOLS_MOVEDOWN               20614
#define VSHELL_ID_TOOLS_ADD                    20615
#define VSHELL_ID_TOOLS_DELETE                 20616
#define VSHELL_ID_TOOLS_REDIRECT               20617
#define VSHELL_ID_TOOLS_CLOSE                  20618
#define VSHELL_IDS_ERR_EXPAND_MACRO            20619
#define VSHELL_ERR_File_Not_Found              20624
#define VSHELL_ERR_Workspace_Window            20625
#define VSHELL_IDDP_CUSTOMIZE_TOOLS            20625
#define VSHELL_IDB_PPBAR_PINNED                20626
#define VSHELL_ERR_Other_Type_Open             20626
#define VSHELL_IDC_DIRNAME                     20626
#define VSHELL_IDB_PPBAR_UNPINNED              20627
#define VSHELL_IDC_DIRPROMPT                   20627
#define VSHELL_IDS_TOOLBARS                    20628
#define VSHELL_IDS_KEYBOARD                    20629
#define VSHELL_IDS_WORKSPACE                   20630
#define VSHELL_IDS_TOOLS                       20631
#define VSHELL_IDD_MTTF                        20632
#define VSHELL_IDC_UNEXPECTED                  20633
#define VSHELL_IDS_ERROR_HELP_NOFILE           20633
#define VSHELL_IDC_ASSERT                      20634
#define VSHELL_IDS_ERROR_HELP_NOKEYWORD        20634
#define VSHELL_IDC_EXCEPTION                   20635
#define VSHELL_IDD_NOHELPFILE                  20635
#define VSHELL_IDS_HELP                        20635
#define VSHELL_IDC_HANG                        20636
#define VSHELL_IDS_FONTSANDCOLORS              20636
#define VSHELL_IDC_OTHER                       20637
#define VSHELL_IDD_HELP_SEARCH                 20637
#define VSHELL_IDS_DIRECTORY_NAME              20637
#define VSHELL_IDC_FEATURE                     20638
#define VSHELL_IDD_OPENDIR                     20638
#define VSHELL_IDS_DIRNOEXIST                  20638
#define VSHELL_IDC_INFORMATION                 20639
#define VSHELL_IDB_SCROLL                      20639
#define VSHELL_IDC_STATUSBAR                   20640
#define VSHELL_IDB_SCROLL_L                    20640
#define VSHELL_IDB_SCROLL_R                    20641
#define VSHELL_IDD_TOOLS_ADD                   20642
#define VSHELL_IDB_SCROLL_RD                   20642
#define VSHELL_IDC_GOTOEDIT                    20643
#define VSHELL_IDB_SCROLL_LD                   20643
#define VSHELL_IDC_GOTOTEXT                    20644
#define VSHELL_IDB_TREECTL                     20644
#define VSHELL_IDC_NAME_TEXT                   20646
#define VSHELL_IDB_MENUBTN_ARROW               20646
#define VSHELL_IDC_HELPPATH1                   20647
#define VSHELL_IDC_HELPPATH2                   20648
#define VSHELL_IDC_ERRORTEXT                   20649
#define VSHELL_ERR_SlashP_NoPidNumber          20650
#define VSHELL_ERR_SlashE_NoEventNumber        20651
#define VSHELL_ERR_Switch_TwiceP               20652
#define VSHELL_ERR_Missing_Jit_SwitchP         20653
#define VSHELL_ERR_Switch_TwiceE               20654
#define VSHELL_ERR_Missing_Jit_SwitchE         20655
#define VSHELL_IDS_FILE_TYPE_DLG               20656
#define VSHELL_IDC_INFO_ICON                   20658
#define VSHELL_IDS_ADDTOOL_DLG_TITLE           20659
#define VSHELL_IDC_AUTOSAVE_ENABLE             20660
#define VSHELL_ERR_Change_Drive                20660
#define VSHELL_IDC_AUTOSAVE_INTERVAL           20661
#define VSHELL_ERR_Change_Directory            20661
#define VSHELL_IDC_AUTOSAVETEXT1               20662
#define VSHELL_ERR_File_NoExist                20662
#define VSHELL_IDC_AUTOSAVETEXT2               20663
#define VSHELL_ERR_File_Already_Open           20663
#define VSHELL_IDC_DDNODROP                    20664
#define VSHELL_ERR_File_Buffer_Overflow        20664
#define VSHELL_ERR_File_Read_Only              20665
#define VSHELL_ERR_File_Exists                 20666
#define VSHELL_ID_TOOLS_ADD_BROWSE             20667
#define VSHELL_ERR_Idx_Corrupt                 20667
#define VSHELL_ERR_MultipleMakes               20668
#define VSHELL_ID_TOOLS_ADD_PATHNAME           20669
#define VSHELL_ERR_Duplicate_AddItem           20669
#define VSHELL_ERR_Goto_Busy                   20670
#define VSHELL_IDS_SAVE_FILE_AS_TYPE           20800
#define VSHELL_IDS_RESOURCETREE                20801
#define VSHELL_IDS_IMAGE                       20802
#define VSHELL_ID_HDR_FIELD_FILE               20803
#define VSHELL_ID_HDR_FIELD_PAGE               20804
#define VSHELL_ID_HDR_FIELD_TIME               20805
#define VSHELL_ID_HDR_FIELD_DATE               20806
#define VSHELL_ID_HDR_FIELD_LEFT               20807
#define VSHELL_ID_HDR_FIELD_CENTER             20808
#define VSHELL_ID_HDR_FIELD_RIGHT              20809
#define VSHELL_ID_FIND_ANYCHARACTER            21000
#define VSHELL_IDS_MULTISEL                    21000
#define VSHELL_IDS_PROPERTIES                  21001
#define VSHELL_ID_FIND_RANGE                   21001
#define VSHELL_ID_FIND_NOTRANGE                21002
#define VSHELL_IDS_BUILDDATE                   21003
#define VSHELL_ID_FIND_LINE_BEGIN              21003
#define VSHELL_IDS_DEFTBTITLE                  21004
#define VSHELL_ID_FIND_LINE_END                21004
#define VSHELL_IDS_UNDESCRIBED                 21005
#define VSHELL_ID_FIND_TAG                     21005
#define VSHELL_IDS_CANNOTOPEN                  21006
#define VSHELL_ID_FIND_NOT                     21006
#define VSHELL_IDS_MAIN                        21007
#define VSHELL_ID_FIND_OR                      21007
#define VSHELL_IDS_ROCOMMENT                   21008
#define VSHELL_ID_FIND_CLOSURE_ZERO            21008
#define VSHELL_IDS_ROBUTTONS2                  21009
#define VSHELL_IDS_ROCOMMENT2                  21009
#define VSHELL_ID_FIND_CLOSURE_ONE             21009
#define VSHELL_IDS_ROBUTTONS3                  21010
#define VSHELL_IDS_ROLOCKED                    21010
#define VSHELL_ID_FIND_GROUP                   21010
#define VSHELL_IDS_LNCOLPRMPT                  21011
#define VSHELL_ID_FIND_ALPHANUM                21011
#define VSHELL_ID_FIND_WHITESPACE              21012
#define VSHELL_IDS_PROPERTIES2                 21013
#define VSHELL_ID_FIND_ALPHA                   21013
#define VSHELL_ID_FIND_DECIMAL                 21014
#define VSHELL_ID_FIND_HEX                     21015
#define VSHELL_ID_FIND_NUMBER                  21016
#define VSHELL_ID_FIND_INTEGER                 21017
#define VSHELL_IDS_MOVETO                      21018
#define VSHELL_ID_FIND_IDENTIFIER              21018
#define VSHELL_IDS_LOADINGWRKSPC               21019
#define VSHELL_ID_FIND_WORD                    21019
#define VSHELL_IDS_SAVINGWRKSPC                21020
#define VSHELL_ID_FIND_STRING                  21020
#define VSHELL_ID_REPLACE_FINDWHATTEXT         21021
#define VSHELL_IDS_UNASSIGNED                  21022
#define VSHELL_ID_REPLACE_TAG_1                21022
#define VSHELL_IDS_PREFIXKEY                   21023
#define VSHELL_ID_REPLACE_TAG_2                21023
#define VSHELL_IDS_FILTER_0                    21024
#define VSHELL_IDS_HELPLESS                    21024
#define VSHELL_ID_REPLACE_TAG_3                21024
#define VSHELL_IDS_FILTER_1                    21025
#define VSHELL_ID_REPLACE_TAG_4                21025
#define VSHELL_IDS_FILTER_2                    21026
#define VSHELL_ID_REPLACE_TAG_5                21026
#define VSHELL_IDS_FILTER_3                    21027
#define VSHELL_ID_REPLACE_TAG_6                21027
#define VSHELL_IDS_FILTER_4                    21028
#define VSHELL_ID_REPLACE_TAG_7                21028
#define VSHELL_IDS_FILTER_5                    21029
#define VSHELL_ID_REPLACE_TAG_8                21029
#define VSHELL_IDS_FILTER_6                    21030
#define VSHELL_ID_REPLACE_TAG_9                21030
#define VSHELL_IDS_FILTER_7                    21031
#define VSHELL_IDS_FILTER_8                    21033
#define VSHELL_IDS_STANDARD                    21034
#define VSHELL_IDS_UNDOLIST                    21036
#define VSHELL_IDS_AUTO                        21037
#define VSHELL_IDS_TEXT                        21038
#define VSHELL_IDS_BINARY                      21039
#define VSHELL_IDS_MAKEFILE                    21040
#define VSHELL_IDS_DEFAULTCHOOSERTITLE         21041
#define VSHELL_IDS_DEFAULTCHOOSERPROMPT        21042
#define VSHELL_IDS_RESOURCESCRIPT              21055
#define VSHELL_IDS_HELP_DEFAULTDIR             21056
#define VSHELL_IDS_TABDLG_OK                   21057
#define VSHELL_IDS_TABDLG_CANCEL               21058
#define VSHELL_IDS_TABDLG_CLOSE                21059
#define VSHELL_IDS_TABDLG_HELP                 21060
#define VSHELL_IDS_CUSTOMIZE                   21061
#define VSHELL_IDS_OPTIONS                     21062
#define VSHELL_IDS_STOP_TOOL_PREFIX            21063
#define VSHELL_IDS_TOOL_PATH_INVALID           21068
#define VSHELL_IDS_NO_ARGS_IN_PATH             21069
#define VSHELL_IDD_FIND                        21070
#define VSHELL_IDS_FULLSCREEN                  21070
#define VSHELL_IDS_NO_EXT_HELP                 21071
#define VSHELL_IDS_LAST_TIP                    21072
#define VSHELL_IDS_DIDYA                       21073
#define VSHELL_IDS_FOR_FILTER_0                21074
#define VSHELL_IDS_SORRY_NO_TIP                21074
#define VSHELL_IDS_FOR_FILTER_1                21075
#define VSHELL_IDS_TIP_OF_THE_DAY              21075
#define VSHELL_IDS_FOR_FILTER_2                21076
#define VSHELL_IDS_GOTO_GOTO                   21076
#define VSHELL_IDS_FOR_FILTER_3                21077
#define VSHELL_IDS_GOTO_NEXT                   21077
#define VSHELL_IDS_ALL_FILTER_0                21078
#define VSHELL_IDS_NOT_A_WKSPACE               21078
#define VSHELL_IDS_ALL_FILTER_1                21079
#define VSHELL_IDC_TOOLTIPS                    21080
#define VSHELL_IDC_BTN_DEFAULTS                21081
#define VSHELL_IDC_LIST1                       21081
#define VSHELL_IDC_LARGETOOLBARS               21081
#define VSHELL_IDC_TEXTLIST                    21081
#define VSHELL_IDC_PROPLIST                    21081
#define VSHELL_IDC_ALLPROP_PROPLIST            21081
#define VSHELL_IDC_LIST                        21081
#define VSHELL_IDC_FILETYPES                   21081
#define VSHELL_IDB_WIDGETBAR_ARROWS            21082
#define VSHELL_IDD_PAGESETUP                   21084
#define VSHELL_ID_PREVIOUS                     21084
#define VSHELL_IDC_LIST_WINDOWS                21085
#define VSHELL_IDC_STATIC_FONT                 21086
#define VSHELL_IDB_TIPOFTHEDAY                 21087
#define VSHELL_IDC_STATIC_SAMPLE               21088
#define VSHELL_IDD_TIPOFTHEDAY                 21088
#define VSHELL_IDS_ALL_FILTER_2                21089
#define VSHELL_IDS_ALL_FILTER_3                21090
#define VSHELL_IDC_RENAME                      21090
#define VSHELL_IDC_OVERWRITE                   21091
#define VSHELL_IDC_MESSAGE                     21092
#define VSHELL_IDD_FILE_IS_READONLY            21092
#define VSHELL_IDC_ICON_EXCLAMATION            21093
#define VSHELL_IDR_FIND_SPECIAL                21093
#define VSHELL_IDC_SCC                         21094
#define VSHELL_IDB_MENUBTN_ARROWD              21094
#define VSHELL_IDC_CLOCK                       21095
#define VSHELL_IDI_VAGUE                       21095
#define VSHELL_IDC_RELOAD_PROJECT              21096
#define VSHELL_IDC_ARG_MACROS                  21097
#define VSHELL_IDC_DIR_MACROS                  21098
#define VSHELL_IDI_PRJ_TEST                    21098
#define VSHELL_IDC_STATIC_SCRIPT               21099
#define VSHELL_IDB_MENUBTN_NOTEXT_ARROW        21099
#define VSHELL_IDC_TM_BROWSE                   21099
#define VSHELL_IDC_COMBO_FONT_SCRIPT           21100
#define VSHELL_IDC_KEYS                        21100
#define VSHELL_IDB_MENUBTN_NOTEXT_ARROWD       21100
#define VSHELL_IDC_GOTOHELPTEXT                21101
#define VSHELL_IDC_SCC_HELPERTEXT              21101
#define VSHELL_IDC_GOTOCAPTION                 21102
#define VSHELL_IDC_SCC_SEPARATOR               21102
#define VSHELL_IDC_GOTOWHAT                    21103
#define VSHELL_IDC_GOTOLIST                    21104
#define VSHELL_IDC_GOTOCOMBO                   21105
#define VSHELL_IDC_GOTO_PUSHPIN                21107
#define VSHELL_IDS_TOOLMACRO_First             21111
#define VSHELL_IDS_TOOLMACRO_FilePath          21111
#define VSHELL_IDS_TOOLMACRO_FileNameExt       21112
#define VSHELL_IDS_TOOLMACRO_FileDir           21113
#define VSHELL_IDS_TOOLMACRO_FileName          21114
#define VSHELL_IDS_TOOLMACRO_FileExt           21115
#define VSHELL_IDS_TOOLMACRO_Line              21116
#define VSHELL_IDS_TOOLMACRO_Col               21117
#define VSHELL_IDS_TOOLMACRO_CurText           21118
#define VSHELL_IDS_TOOLMACRO_Dir               21119
#define VSHELL_IDS_TOOLMACRO_TargetPath        21120
#define VSHELL_IDS_TOOLMACRO_TargetDir         21121
#define VSHELL_IDS_TOOLMACRO_TargetName        21122
#define VSHELL_IDS_TOOLMACRO_TargetExt         21123
#define VSHELL_IDS_TOOLMACRO_TargetArgs        21124
#define VSHELL_IDS_TOOLMACRO_WkspDir           21125
#define VSHELL_IDS_TOOLMACRO_WkspName          21126
#define VSHELL_IDS_TOOLMACRO_RCFile            21127
#define VSHELL_IDS_TOOLMACRO_Last              21127
#define VSHELL_IDS_TOOLMACRODIR_First          21128
#define VSHELL_IDS_TOOLMACRODIR_FileDir        21128
#define VSHELL_IDS_TOOLMACRODIR_FileName       21129
#define VSHELL_IDS_TOOLMACRODIR_Dir            21130
#define VSHELL_IDS_TOOLMACRODIR_TargetDir      21131
#define VSHELL_IDS_TOOLMACRODIR_TargetName     21132
#define VSHELL_IDS_TOOLMACRODIR_WkspDir        21133
#define VSHELL_IDS_TOOLMACRODIR_WkspName       21134
#define VSHELL_IDS_TOOLMACRODIR_Last           21134
#define VSHELL_IDR_TOOL_MACRO                  21140
#define VSHELL_IDR_HELP_KEYBOARD               21141
#define VSHELL_IDR_GRD_TOOLBAR                 21142
#define VSHELL_IDR_GRD_TB_DELETE               21143
#define VSHELL_IDR_DOCOBJECT                   21144
#define VSHELL_IDD_OPEN_DOCUMENTS              21145
#define VSHELL_IDC_OPEN_DOCUMENTS_LIST         21146
#define VSHELL_IDC_OPEN_DOCUMENTS_CLOSE        21147
#define VSHELL_IDC_OPEN_DOCUMENTS_SAVE         21148
#define VSHELL_IDC_OPEN_DOCUMENTS_PRINT        21149
#define VSHELL_IDD_NEW_WKSP                    21150
#define VSHELL_IDS_ERR_NTSPAWN_NOT_FOUND       21151
#define VSHELL_IDS_ERR_CANNOT_SPAWN_TOOL       21152
#define VSHELL_IDS_ERR_TOOL_PATH_INVALID       21153
#define VSHELL_IDS_ERR_CANNOT_START_TOOL       21154
#define VSHELL_IDS_ERR_TOOL_RETURN             21155
#define VSHELL_IDS_ERR_PATH_NOT_FOUND          21156
#define VSHELL_IDS_ERR_FILE_NOT_FOUND          21157
#define VSHELL_IDS_ERR_BAD_EXE_FORMAT          21158
#define VSHELL_IDS_ERR_NOT_ENOUGH_MEMORY       21159
#define VSHELL_IDS_TOOL_STOP_MSG               21160
#define VSHELL_IDS_SOUND_OUTPUT_ERROR          21161
#define VSHELL_IDS_SOUND_OUTPUT_WARNING        21162
#define VSHELL_IDD_TOOLARGUMENTS               21163
#define VSHELL_IDS_ERROR_BOGUSFILE             21163
#define VSHELL_IDC_TOOLARGUMENTS_ARGS          21164
#define VSHELL_IDC_TOOLARGUMENTS_MACROS        21165
#define VSHELL_IDC_TOOLARGUMENTS_REDIRECT      21166
#define VSHELL_IDS_OUTPUT_ERROR                21167
#define VSHELL_IDS_OUTPUT_WARNING              21168
#define VSHELL_IDS_ERR_CHANGE_DRIVE            21169
#define VSHELL_IDS_ERR_CHANGE_DIR              21170
#define VSHELL_IDS_ERR_NO_DISK_IMAGE           21171
#define VSHELL_IDC_ALLPROP_LABEL               21172
#define VSHELL_IDC_ALLPROP_PROPVAL             21173
#define VSHELL_IDC_ALLPROP_PROPDLG             21174
#define VSHELL_IDC_ALLPROP_PROPDLIST           21175
#define VSHELL_IDC_ALLPROP_PROPDDOWN           21176
#define VSHELL_IDC_ALLPROP_PROPNAME            21177
#define VSHELL_IDDP_ALLPROP                    21178
#define VSHELL_IDB_ALLPROP_DROPARROW95         21179
#define VSHELL_IDDP_CUSTOMIZE_TOOLSMENU        21179
#define VSHELL_IDD_CUSTOMBUTTON                21180
#define VSHELL_IDB_ALLPROP_DROPARROW           21180
#define VSHELL_IDS_OC_GENERAL                  21181
#define VSHELL_IDB_MAINLARGETOOLS              21181
#define VSHELL_IDS_ERR_CANT_LOAD_PKG           21183
#define VSHELL_IDS_ERR_CANT_LOAD_PKG_VER       21184
#define VSHELL_IDS_AUTOCOL_NOMEM               21185
#define VSHELL_IDC_TM_PLACEHOLDER              21185
#define VSHELL_IDC_IMAGE_EDIT                  21186
#define VSHELL_IDS_AUTOCOL_BADPARAM            21186
#define VSHELL_IDC_TM_COMMAND_LABEL            21186
#define VSHELL_IDS_AUTOAPP_NODEVAUT1           21187
#define VSHELL_IDC_BUTTON_NAME                 21187
#define VSHELL_IDC_TM_COMMAND                  21187
#define VSHELL_IDC_BUTTON_TEXT                 21188
#define VSHELL_IDC_TM_ARGUMENTS_LABEL          21188
#define VSHELL_IDS_AUTOAPP_NAME                21188
#define VSHELL_IDC_TM_ARGUMENTS                21189
#define VSHELL_IDS_AUTOAPP_VERSION             21189
#define VSHELL_IDB_REDOLARGE                   21190
#define VSHELL_IDC_TM_INITDIR_LABEL            21190
#define VSHELL_IDS_STRING_NOT_FOUND            21190
#define VSHELL_IDB_UNDOLARGE                   21191
#define VSHELL_IDC_TM_INITDIR                  21191
#define VSHELL_IDS_REG_EXPR_NOT_FOUND          21191
#define VSHELL_IDB_REDODISABLEDLARGE           21192
#define VSHELL_IDC_TM_PROMPTFORARGS            21192
#define VSHELL_IDS_REGEXPR_INVALID             21192
#define VSHELL_IDB_UNDODISABLEDLARGE           21193
#define VSHELL_IDS_ERR_TOOL_RUNNING            21193
#define VSHELL_IDC_TM_REDIRECTOUTPUT           21193
#define VSHELL_IDC_TM_CLOSEONEXIT              21194
#define VSHELL_IDB_TOOL_CUSTOMIZE              21194
#define VSHELL_IDS_AUTOAPP_BADFIRSTKEY         21194
#define VSHELL_IDC_TM_ARGMACROS                21195
#define VSHELL_IDDP_ALLPROP_NEW                21195
#define VSHELL_IDS_AUTOAPP_BADSECONDKEY        21195
#define VSHELL_IDB_MENUBTN_ARROWV              21195
#define VSHELL_IDC_TM_DIRMACROS                21196
#define VSHELL_IDB_ALLPROP_ARROWS              21196
#define VSHELL_IDS_AUTOAPP_TOOMANYKEYS         21196
#define VSHELL_IDDP_FILENEW_FILES              21196
#define VSHELL_IDB_MENUBTN_ARROWVD             21197
#define VSHELL_IDC_TM_TOOLSGRID                21197
#define VSHELL_IDS_AUTOAPP_INVALIDCOMMAND      21197
#define VSHELL_IDDP_FILENEW_PROJECTS           21197
#define VSHELL_IDC_ALLPROP_NOBROWSEABLE        21198
#define VSHELL_IDB_CUSTOMGLYPHSLARGE           21198
#define VSHELL_IDS_AUTOAPP_INVALIDEDITOR       21198
#define VSHELL_IDDP_FILENEW_WORKSPACES         21198
#define VSHELL_IDC_IMAGE_RESET                 21199
#define VSHELL_IDC_FIND_MARK_ALL               21199
#define VSHELL_IDB_CUSTOMGLYPHS                21199
#define VSHELL_IDI_BUILDER                     21199
#define VSHELL_IDDP_FILENEW_OTHERDOCS          21199
#define VSHELL_IDC_RADIO1                      21200
#define VSHELL_IDC_FIND_SEARCH_ALL             21200
#define VSHELL_IDI_CATEGORY                    21200
#define VSHELL_IDC_LARGEICONVIEW               21200
#define VSHELL_IDDP_FILENEW_TEMPLATES          21200
#define VSHELL_IDS_ZOOM_PAGE_WIDTH             21201
#define VSHELL_IDC_PROP_BUTTON                 21201
#define VSHELL_IDC_OPEN_DOCUMENTS_ACTIVATE     21201
#define VSHELL_IDS_ZOOM_ONE_PAGE               21202
#define VSHELL_IDC_PROP_LISTBOX                21202
#define VSHELL_IDS_ZOOM_TWO_PAGES              21203
#define VSHELL_IDC_PROP_EDIT                   21203
#define VSHELL_IDC_SPECIAL                     21204
#define VSHELL_IDS_ZOOM_SELECTION              21204
#define VSHELL_IDS_ZOOM_FIT                    21205
#define VSHELL_IDC_BUTTONGROUP                 21205
#define VSHELL_IDS_ERR_BAD_CMD                 21206
#define VSHELL_IDC_COMMANDS                    21206
#define VSHELL_IDC_STATIC_DIRECTION            21207
#define VSHELL_IDS_ALLCOMMANDS                 21208
#define VSHELL_IDC_BWIZ_TREE                   21208
#define VSHELL_IDS_MENUS                       21209
#define VSHELL_IDC_SMALLICONVIEW               21209
#define VSHELL_IDC_LISTVIEW                    21210
#define VSHELL_IDC_ADDTOPROJECT                21211
#define VSHELL_IDC_PROJECTFORFILE              21212
#define VSHELL_IDC_NAMEFORFILE                 21214
#define VSHELL_IDC_LOCATIONFORFILE             21215
#define VSHELL_IDS_HELP_KEY_CAPTION            21216
#define VSHELL_IDC_BROWSE                      21216
#define VSHELL_IDS_HELP_KEY_CATEGORY           21217
#define VSHELL_IDC_CREATENEWWORKSPACE          21217
#define VSHELL_IDS_HELP_KEY_COMMAND            21218
#define VSHELL_IDC_ADDTOCURRENTWORKSPACE       21218
#define VSHELL_IDS_HELP_KEY_KEYS               21219
#define VSHELL_IDC_DEPENDENCYOF                21219
#define VSHELL_IDS_HELP_KEY_DESCRIPTION        21220
#define VSHELL_IDC_DEPENDENCYPROJECT           21220
#define VSHELL_IDS_HELP_KEY_BOUND              21221
#define VSHELL_IDC_PLATFORMS                   21221
#define VSHELL_IDS_HELP_KEY_ALL                21222
#define VSHELL_IDC_NAMEFORPROJECT              21222
#define VSHELL_IDS_HELP_KEY_PRINT_TITLE        21223
#define VSHELL_IDC_LOCATIONFORPROJECT          21223
#define VSHELL_IDS_HELP_KEY_PRINT_CRIGHT       21224
#define VSHELL_IDS_HELP_KEY_PRINT_PAGE         21225
#define VSHELL_IDC_NAMEFORWORKSPACE            21225
#define VSHELL_IDS_HELP_KEY_PRINT_FOOTER       21226
#define VSHELL_IDC_LOCATIONFORWORKSPACE        21226
#define VSHELL_IDS_HELP_KEY_EDITOR             21227
#define VSHELL_IDC_WORKSPACETYPES              21227
#define VSHELL_ID_HELP_KEY_CATEGORY_COMBO      21228
#define VSHELL_IDC_PROJECTTYPES                21228
#define VSHELL_IDC_OTHERDOCTYPES               21229
#define VSHELL_IDC_PROJECTFOROTHERFILE         21230
#define VSHELL_IDC_NAMEFOROTHERFILE            21231
#define VSHELL_IDC_LOCATIONFOROTHERFILE        21232
#define VSHELL_IDC_PROJECTFORTEMPLATE          21233
#define VSHELL_IDC_NAMEFORTEMPLATE             21234
#define VSHELL_IDC_LOCATIONFORTEMPLATE         21235
#define VSHELL_IDC_TEMPLATETYPES               21236
#define VSHELL_ID_GOTO_GOTOANDNEXT             21237
#define VSHELL_IDS_OLE2UICONVERT               21240
#define VSHELL_IDS_OLE2UIEDITLINKCMD_1VERB     21241
#define VSHELL_IDS_OLE2UIEDITOBJECTCMD_1VERB   21242
#define VSHELL_IDS_OLE2UIEDITLINKCMD_NVERB     21243
#define VSHELL_IDS_OLE2UIEDITOBJECTCMD_NVERB   21244
#define VSHELL_IDS_OLE2UIEDITNOOBJCMD          21245
#define VSHELL_IDS_OLE2UIUNKNOWN               21246
#define VSHELL_IDS_ERR_BAD_PARAM_VALUE         21250
#define VSHELL_IDS_ERR_DOC_RELEASED            21251
#define VSHELL_IDS_ERR_WINDOW_RELEASED         21252
#define VSHELL_IDS_AUTOAPP_NOBLD               21253
#define VSHELL_IDS_NOFILENEWWIZSUPPORT         21254
#define VSHELL_IDS_REGISTRYCORRUPTED           21255
#define VSHELL_IDS_MISSINGWIZARD               21256
#define VSHELL_IDI_DEVSTUDIO_FOLDER            21257
#define VSHELL_IDS_DOCKWNDS_UNAVAILABLE        21257
#define VSHELL_IDS_FILESTAB                    21258
#define VSHELL_IDS_TEMPLATESTAB                21259
#define VSHELL_IDS_PROJECTSTAB                 21260
#define VSHELL_IDS_WORKSPACESTAB               21261
#define VSHELL_IDS_OTHERDOCSTAB                21262
#define VSHELL_IDS_NEW                         21263
#define VSHELL_IDS_ERROR_CANT_CREATE_IPCMPDOC  21264

#define VSHELL_IDS_ERR_UNKNOWN                 33604
#define VSHELL_IDC_IMAGE_CHOOSE                57671
#define VSHELL_IDC_IMAGE_PASTE                 57673
#define VSHELL_ID_HELP3                        57674
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define VSHELL__APS_NEXT_RESOURCE_VALUE        21202
#define VSHELL__APS_NEXT_COMMAND_VALUE         21185
#define VSHELL__APS_NEXT_CONTROL_VALUE         21238
#define VSHELL__APS_NEXT_SYMED_VALUE           21185
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\sym\vproj.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by vproj.rc
//
#define VPROJ_IDC_PROJ_NAME                   100
#define VPROJ_IDC_WORKSPACE_NAME              101
#define VPROJ_IDD_CONFIGURATIONS              102
#define VPROJ_IDC_CHANGE                      102
#define VPROJ_IDC_PROJ_TYPE                   103
#define VPROJ_IDC_CONFIGURATIONS_TREE         1000
#define VPROJ_IDC_NETWORK                     0x40d
#define VPROJ_IDS_TARGET_FOLDER               16000
#define VPROJ_IDC_GROUPNAME                   16001
#define VPROJ_IDS_LIBMGR_TOOL_UI              16001
#define VPROJ_IDC_RADIO1                      16002
#define VPROJ_IDC_TARGETOPTIONS_FILESDEFAULT  16002
#define VPROJ_IDC_TARGETOPTS_FILESDEF         16002
#define VPROJ_IDD_EDIT_TOOL                   16002
#define VPROJ_IDS_DIRS_SOURCE                 16002
#define VPROJ_IDC_NEWTARGET_DEF               16003
#define VPROJ_IDB_SCC_STATUS                  16003
#define VPROJ_IDS_OUTDIR_NULL                 16003
#define VPROJ_IDC_RADIO2                      16004
#define VPROJ_IDC_TARGETOPTIONS_FILESMIRROR   16004
#define VPROJ_IDC_TARGETOPTS_FILESMIRROR      16004
#define VPROJ_IDB_FOLDERS                     16004
#define VPROJ_IDS_DEL_CONFIG                  16004
#define VPROJ_IDC_STATIC1                     16005
#define VPROJ_IDB_EXPANDNODES                 16005
#define VPROJ_IDS_NO_VALID_CFG_DEPS           16005
#define VPROJ_IDC_EDITPROJ_DELETE             16006
#define VPROJ_IDB_LRGITEM                     16006
#define VPROJ_IDC_EDITPROJ_PROJLABEL          16007
#define VPROJ_IDB_LRGITEM_SDW                 16007
#define VPROJ_IDC_EDITPROJ_PROJECT            16008
#define VPROJ_IDC_ADDFILES_TARGETS            16008
#define VPROJ_IDDP_OPTIONS_DIRECTORIES        16008
#define VPROJ_IDD_PROGRESS_DLG                16009
#define VPROJ_IDB_PANEGLYPH_BITMAP            16009
#define VPROJ_IDC_APPLY                       16010
#define VPROJ_IDD_EDITPROJECT                 16010
#define VPROJ_IDC_EDITPROJ_GROUPLABEL         16011
#define VPROJ_IDC_EDITPROJ_TARGETLABEL        16011
#define VPROJ_IDD_ADD_FILES                   16011
#define VPROJ_IDC_EDITPROJ_ADDALL             16012
#define VPROJ_IDD_NEW_PROJ_GRP                16012
#define VPROJ_IDC_NEWPROJTYPE                 16013
#define VPROJ_IDDP_PROJ_GENERAL               16013
#define VPROJ_IDC_NEWPROJ_USEMFC              16014
#define VPROJ_IDDP_TARGET_GENERAL             16014
#define VPROJ_IDC_NEWPROJ_WIZARDS             16015
#define VPROJ_IDS_ALL_LETTERS                 16015
#define VPROJ_IDD_CHICAGO_ADD_FILES           16015
#define VPROJ_IDC_PROJCONFIG                  16016
#define VPROJ_IDS_WARN_PROJ_READ_ONLY         16016
#define VPROJ_IDC_OPTSTR                      16017
#define VPROJ_IDS_CONVERT_MAKEFILE            16017
#define VPROJ_IDC_CONFIG_ADD                  16018
#define VPROJ_IDS_WARN_DEP_DOES_NOT_EXIST     16018
#define VPROJ_IDC_CONFIG_DELETE               16019
#define VPROJ_IDS_PREBUILD_TIMESTAMP_CHECK    16019
#define VPROJ_IDC_CONFIG_COPY                 16020
#define VPROJ_IDS_PREBUILD_DUP_CHECK          16020
#define VPROJ_IDC_CONFIG_CLONE                16021
#define VPROJ_IDS_GET_REMTARG_BUILD           16021
#define VPROJ_IDC_CONFIG_NAME                 16022
#define VPROJ_IDS_UPDATING_DEPENDENCIES       16022
#define VPROJ_IDC_CONFIGPROJTYPE              16023
#define VPROJ_IDS_UPDATING_DEPENDENCIES_OWIN  16023
#define VPROJ_IDC_CONFIG_DBG_NAME             16024
#define VPROJ_IDS_EXTTYPE_DLL                 16024
#define VPROJ_IDS_BUILD_TOOLBAR               16024
#define VPROJ_IDC_CONFIG_REL_NAME             16025
#define VPROJ_IDS_ERROR_NO_PLATFORMS          16025
#define VPROJ_IDC_STATIC2                     16026
#define VPROJ_IDS_EXTTYPE_OTHER               16026
#define VPROJ_IDS_ADDFILES_OK                 16026
#define VPROJ_IDC_EXT_REMOTE_TARGET_TXT       16027
#define VPROJ_IDC_REMOTE_TARGET_TXT           16027
#define VPROJ_IDS_EXE_NOT_SUPPORTED           16027
#define VPROJ_IDC_STATIC4                     16028
#define VPROJ_IDS_SAME_TARGET                 16028
#define VPROJ_IDC_STATIC5                     16029
#define VPROJ_IDS_ADD_TARG_DEP                16029
#define VPROJ_IDC_TOOLSET_1                   16030
#define VPROJ_IDS_BASE_GROUP_NAME             16030
#define VPROJ_IDC_TOOLSET_2                   16031
#define VPROJ_IDS_GROUP_CUSTOMIZER            16031
#define VPROJ_IDC_TOOLSET_3                   16032
#define VPROJ_IDS_GROUP_CUSTOMIZER_KEY        16032
#define VPROJ_IDC_DIRS_PATH                   16033
#define VPROJ_IDS_OPEN_FOR_SCAN_FAILED        16033
#define VPROJ_IDC_DIRS_INCLUDE                16034
#define VPROJ_IDS_SCAN_ERROR                  16034
#define VPROJ_IDC_DIRS_LIB                    16035
#define VPROJ_IDS_INCLUDE_NOT_FOUND           16035
#define VPROJ_IDC_DIRS_HELP                   16036
#define VPROJ_IDS_READ_PROJECT_FILE           16036
#define VPROJ_IDC_DIRS_LIST                   16037
#define VPROJ_IDS_OPEN_PROJECT_FILE           16037
#define VPROJ_IDC_PLACEHOLDER2                16038
#define VPROJ_IDS_CONFIG_HEADER1              16038
#define VPROJ_IDC_DIRS_DELETE                 16039
#define VPROJ_IDS_CONFIG_HEADER2              16039
#define VPROJ_IDC_DIRS_MOVEUP                 16040
#define VPROJ_IDS_CONFIG_HEADER3              16040
#define VPROJ_IDC_DIRS_MOVEDOWN               16041
#define VPROJ_IDS_CONFIG_HEADER4              16041
#define VPROJ_IDC_DIRS_DIRNAME                16042
#define VPROJ_IDS_CONFIG_HEADER5              16042
#define VPROJ_IDC_OUTDIRS_INT                 16043
#define VPROJ_IDS_CONFIG_HEADER6              16043
#define VPROJ_IDC_OUTDIRS_TRGTXT              16044
#define VPROJ_IDS_MAKEFILE_SIG_STRING         16044
#define VPROJ_IDC_OUTDIRS_TRG                 16045
#define VPROJ_IDS_MAKEFILE_BAD_FORMAT         16045
#define VPROJ_IDC_OUTDIRS_INTTXT              16046
#define VPROJ_IDS_MAKEFILE_UNKNOWN_BASE       16046
#define VPROJ_IDC_EXTOPTS_CMDLINE             16047
#define VPROJ_IDS_VCP_UNKNOWN_CONFIG          16047
#define VPROJ_IDC_EXTOPTS_REBUILDOPT          16048
#define VPROJ_IDS_PROJ_DELETEING_FILES        16048
#define VPROJ_IDC_EXTOPTS_TARGET              16049
#define VPROJ_IDS_PROJ_COULD_NOT_DELETE_FILE  16049
#define VPROJ_IDC_EXTOPTS_BSCNAME             16050
#define VPROJ_IDS_PROJ_SUGGEST_REBUILD        16050
#define VPROJ_IDC_EXTOPTS_CLSWZD_NAME         16051
#define VPROJ_IDS_DIR_NOT_EXIST               16051
#define VPROJ_IDS_BAD_DIR_SPEC                16052
#define VPROJ_IDC_MAKPROGBAR                  16053
#define VPROJ_IDS_BUILD_COMPLETE              16053
#define VPROJ_IDC_MAKNAME                     16054
#define VPROJ_IDS_COMPILER32                  16054
#define VPROJ_IDC_OPTIONTXT                   16055
#define VPROJ_IDS_LINKCOFF                    16055
#define VPROJ_IDC_GRP_NAME                    16056
#define VPROJ_IDS_RESCOMPILER32               16056
#define VPROJ_IDC_GRP_EXCLUDE                 16057
#define VPROJ_IDS_MFC_NONE                    16057
#define VPROJ_IDC_ITEM_EXCLUDE                16058
#define VPROJ_IDS_MFC_LIBRARY                 16058
#define VPROJ_IDC_GRP_ALLOW_PERGRP            16059
#define VPROJ_IDS_MFC_DLL                     16059
#define VPROJ_IDC_EXT_PROGARGS_OR_CALLER_LABEL2 16060
#define VPROJ_IDS_CONFIG_HEADER0              16060
#define VPROJ_IDC_EXT_PROGARGS_OR_CALLER_LABEL1 16061
#define VPROJ_IDS_TOOLS                       16061
#define VPROJ_IDC_ADVANCED_OPT                16062
#define VPROJ_IDS_DEPENDENCIES                16062
#define VPROJ_IDC_DIRS_OPTIONS                16063
#define VPROJ_IDS_RESOURCES                   16063
#define VPROJ_IDC_PROJ_CONFIG                 16064
#define VPROJ_IDS_GROUP                       16064
#define VPROJ_IDC_PROG_ARGS                   16065
#define VPROJ_IDS_FILE_INCL_TOGGLE            16065
#define VPROJ_IDC_PROG_WORKDIR                16066
#define VPROJ_IDS_INPUTS                      16066
#define VPROJ_IDC_PROG_ARGS_TXT               16067
#define VPROJ_IDS_OUTPUTS                     16067
#define VPROJ_IDC_EXT_CONFIG                  16068
#define VPROJ_IDS_FILE_TYPE_EXISTS            16068
#define VPROJ_IDC_CALLING_PROG_TXT            16069
#define VPROJ_IDS_BSCMAKE                     16069
#define VPROJ_IDC_CALLING_PROG                16070
#define VPROJ_IDS_BAD_PLATFORMS               16070
#define VPROJ_IDC_BSCMAKE_ALWAYS              16071
#define VPROJ_IDS_LIBMGR                      16071
#define VPROJ_IDC_BSCMAKE_DEFERRED            16072
#define VPROJ_IDS_DESC_COMPILING              16072
#define VPROJ_IDC_BSCMAKE_NEVER               16073
#define VPROJ_IDS_DESC_RC_COMPILING           16073
#define VPROJ_IDC_SET_DEFAULT                 16074
#define VPROJ_IDS_DESC_LINKING                16074
#define VPROJ_IDC_PROJ_USEMFC                 16075
#define VPROJ_IDS_DESC_BSCMAKING              16075
#define VPROJ_IDC_REBUILDALL_TEXT             16076
#define VPROJ_IDS_DESC_LIBING                 16076
#define VPROJ_IDC_BUILDCMD_TEXT               16077
#define VPROJ_IDS_ERROR_SAVING_VCP            16077
#define VPROJ_IDC_DIR_CHOOSER_PATH            16078
#define VPROJ_IDC_CHECK1                      16078
#define VPROJ_IDC_NEWTARGET_COPY              16078
#define VPROJ_IDC_TARGETOPTIONS_DEBUG         16078
#define VPROJ_IDC_TARGETOPTS_DEBUG            16078
#define VPROJ_IDC_FIND_MODULE_PROMPT          16078
#define VPROJ_IDS_DEFFERED_MECR               16078
#define VPROJ_IDC_GRAPH_SHOWDEPS              16078
#define VPROJ_IDC_SUPPRESS_BSC                16078
#define VPROJ_IDC_DIRS_BROWSE                 16079
#define VPROJ_IDC_CHECK2                      16079
#define VPROJ_IDC_NEWTARGET_DEBUG             16079
#define VPROJ_IDC_LOAD_DLL_PROMPT             16079
#define VPROJ_IDS_BATCH_BLD_NO_MECR           16079
#define VPROJ_IDC_DDCOPYFILE                  16080
#define VPROJ_IDS_RESSCRIPT_CANT_OPEN         16080
#define VPROJ_IDC_DDCOPYMULTIFILE             16081
#define VPROJ_IDS_CONFIG_DEFAULT_HEADER0      16081
#define VPROJ_IDC_BUTTON1                     16082
#define VPROJ_IDC_DDFILE                      16082
#define VPROJ_IDC_MECR_CONNECTION             16082
#define VPROJ_IDC_NEWTARGET_OPTIONS           16082
#define VPROJ_IDC_EDITTOOL_DIRMACRO           16082
#define VPROJ_IDS_CONV_SRCGRP                 16082
#define VPROJ_IDC_DIR_MACRO                   16082
#define VPROJ_IDC_ADD                         16082
#define VPROJ_IDC_BUTTON2                     16083
#define VPROJ_IDC_NEW_TARGET                  16083
#define VPROJ_IDC_DDMULTIFILE                 16083
#define VPROJ_IDC_EDITTOOL_FILEMACRO          16083
#define VPROJ_IDS_CONFIG_DEFAULT_HEADER1      16083
#define VPROJ_IDC_FILE_MACRO                  16083
#define VPROJ_IDC_REMOVE                      16083
#define VPROJ_IDC_BUTTON3                     16084
#define VPROJ_IDC_DELETE_TARGET               16084
#define VPROJ_IDS_NO_BUILD_UNAMED_PROJECT     16084
#define VPROJ_IDC_DEPENDENCIES                16084
#define VPROJ_IDC_BUTTON4                     16085
#define VPROJ_IDC_CHANGE_TARGET               16085
#define VPROJ_IDS_NO_EXIT_SPAWN_ACTIVE        16085
#define VPROJ_IDC_BUTTON5                     16086
#define VPROJ_IDC_OPTION_TARGET               16086
#define VPROJ_IDS_CANNOT_DELETE_TOP_PROJECT   16086
#define VPROJ_IDC_LIST1                       16087
#define VPROJ_IDC_TARGET_LIST                 16087
#define VPROJ_IDC_NEWTARGET_PLATFORMS         16087
#define VPROJ_IDC_LOCAL_DLL_LIST              16087
#define VPROJ_IDS_NO_SOURCE_FILE_BUILD        16087
#define VPROJ_IDC_PLATFORM_TYPE               16088
#define VPROJ_IDS_COULD_NOT_CREATE_DIR        16088
#define VPROJ_IDC_PLATFORM_STATIC             16089
#define VPROJ_IDS_DEFFERED_BSCMAKE            16089
#define VPROJ_IDC_NEWTARGET_NAME              16090
#define VPROJ_IDS_USERCANCELED                16090
#define VPROJ_IDC_NEWTARGET_PLATFORM          16091
#define VPROJ_IDC_NEWTARGET_TARGETTYPE        16091
#define VPROJ_IDS_SOURCE_MISSING              16091
#define VPROJ_IDC_NEWTARGET_TARGETLIST        16092
#define VPROJ_IDS_DO_NOT_EDIT_MAKEFILE        16092
#define VPROJ_IDC_NEWTARGET_STATICPLATFORM    16093
#define VPROJ_IDS_OPTIONTXT                   16093
#define VPROJ_IDC_OLD_TARGET                  16094
#define VPROJ_IDS_DELETE_TARGET_REFS          16094
#define VPROJ_IDC_RENAME_NEWTARGET            16095
#define VPROJ_IDS_CAT_CUSTOM                  16095
#define VPROJ_IDC_STATIC_OLDTARGET            16096
#define VPROJ_IDB_PROJITEM_ICONS              16096
#define VPROJ_IDS_CUSTOMBUILD_TOOL            16096
#define VPROJ_IDC_DIRS_TOOLSETS               16097
#define VPROJ_IDB_SINGLE_ITEM                 16097
#define VPROJ_IDS_CUSTOMBUILD_DESC            16097
#define VPROJ_IDC_REBUILD_BATCH               16098
#define VPROJ_IDDP_EXTERNALMAKE_OPTIONS       16098
#define VPROJ_IDS_BSCMAKE_TOOL_UI             16098
#define VPROJ_IDC_COMBO1                      16099
#define VPROJ_IDC_TARGETOPTS_COPYSETSFROM     16099
#define VPROJ_IDC_TOOLS                       16099
#define VPROJ_IDDP_GRP_GENERAL                16099
#define VPROJ_IDS_MKTYPLIB_TOOL_UI            16099
#define VPROJ_IDC_PAGE_CATEGORY               16100
#define VPROJ_IDD_MAKPROGRESS                 16100
#define VPROJ_IDS_RESCOMPILER32_TOOL_UI       16100
#define VPROJ_IDC_USEMFC_TEXT                 16101
#define VPROJ_IDS_CAT_LISTFILE                16101
#define VPROJ_IDC_FILE_NAME                   16102
#define VPROJ_IDS_CAT_PREPROCESS              16102
#define VPROJ_IDC_FILE_DATE                   16103
#define VPROJ_IDS_WARN_KILL_PERGRP            16103
#define VPROJ_IDS_DESC_CLEANING               16103
#define VPROJ_IDS_MECR                        16104
#define VPROJ_IDC_TARGET_NAME                 16105
#define VPROJ_IDS_NO_OPEN_SPAWN_ACTIVE        16105
#define VPROJ_IDC_TARGET_DATE                 16106
#define VPROJ_IDS_DIRS_EXECUTABLE             16106
#define VPROJ_IDC_PROJ_DATE                   16107
#define VPROJ_IDS_ADD_FILE_AS_REF             16107
#define VPROJ_IDC_TARGET_TXT                  16108
#define VPROJ_IDS_DIRS_LIB                    16108
#define VPROJ_IDC_EXTOPTS_PLATFORM            16109
#define VPROJ_IDS_DIRS_HELP                   16109
#define VPROJ_IDC_PROJ_TARGET_DUMMY           16110
#define VPROJ_IDS_CAT_DEBUGOPT                16110
#define VPROJ_IDC_PROG_WORKDIR_TXT            16111
#define VPROJ_IDS_CAT_INPUT                   16111
#define VPROJ_IDC_MINI_PAGE                   16112
#define VPROJ_IDS_CAT_OPTIMIZE                16112
#define VPROJ_IDC_TOOLS_LIST                  16113
#define VPROJ_IDS_DIRS_INCLUDE                16113
#define VPROJ_IDC_BUILDER_SPECIFIC            16114
#define VPROJ_IDS_CANNOT_DELETE_DEPS          16114
#define VPROJ_IDC_NEW_TOOL                    16115
#define VPROJ_IDS_CAT_PCH                     16115
#define VPROJ_IDC_EDIT_TOOL                   16116
#define VPROJ_IDS_CAT_CUSTOMCPP               16116
#define VPROJ_IDC_DELETE_TOOL                 16117
#define VPROJ_IDS_CAT_CUSTOMLINK              16117
#define VPROJ_IDS_CAT_OUTPUT                  16118
#define VPROJ_IDC_EDITTOOL_NAME               16119
#define VPROJ_IDS_COULD_NOT_GET_TEMP_PATH     16119
#define VPROJ_IDC_EDITTOOL_EXE                16120
#define VPROJ_IDS_COULD_NOT_GET_CWD           16120
#define VPROJ_IDC_EDITTOOL_MENU               16121
#define VPROJ_IDS_COULD_NOT_GET_TEMP_NAME     16121
#define VPROJ_IDC_EDITTOOL_INPUT              16122
#define VPROJ_IDS_COULD_NOT_OPEN_TEMP_FILE    16122
#define VPROJ_IDC_EDITTOOL_OUTPUT             16123
#define VPROJ_IDS_COULD_NOT_DELETE_TEMP_FILE  16123
#define VPROJ_IDC_EDITTOOL_BROWSE             16124
#define VPROJ_IDS_GET_COMMAND_LINE_FAILED     16124
#define VPROJ_IDC_REMOTE_TARGET               16125
#define VPROJ_IDS_DIR_CHANGE_IN_BUILD         16125
#define VPROJ_IDC_REMOTE_CREATOR              16126
#define VPROJ_IDS_PROJ_SAVING_FAILED          16126
#define VPROJ_IDC_CALLING_PROG_TXT2           16127
#define VPROJ_IDC_DLLS_LIST                   16127
#define VPROJ_IDS_TAKE_BUILD_SNAPSHOT         16127
#define VPROJ_IDC_TARGET_STATIC               16128
#define VPROJ_IDS_LOAD_PROJECT_STATE          16128
#define VPROJ_IDC_TARGETOPTIONS_FILESCOPY     16129
#define VPROJ_IDC_TARGETOPTS_FILESCOPY        16129
#define VPROJ_IDS_SAVE_PROJECT_STATE          16129
#define VPROJ_IDC_TARGETOPTIONS_SETTINGSDEFAULT 16130
#define VPROJ_IDC_TARGETOPTS_SETTINGSDEF      16130
#define VPROJ_IDS_CONFIG_DEFAULT_HEADER2      16130
#define VPROJ_IDC_TARGETOPTIONS_SETTINGSCOPY  16131
#define VPROJ_IDC_TARGETOPTS_SETTINGSCOPY     16131
#define VPROJ_IDS_FILE_ALREADY_PRESENT        16131
#define VPROJ_IDC_COMBO2                      16132
#define VPROJ_IDC_TARGETOPTS_MIRRORFROM       16132
#define VPROJ_IDS_ADD_FILE_ANYWAY             16132
#define VPROJ_IDC_COMBO3                      16133
#define VPROJ_IDC_TARGETOPTS_COPYFROM         16133
#define VPROJ_IDS_EXTTARG_BAD_PROJ_NAME       16133
#define VPROJ_IDC_TARGETOPTIONS_SETTINGSDEFAULT_TXT 16134
#define VPROJ_IDACCEL_PROJECT                 16134
#define VPROJ_IDC_TARGETOPTIONS_FILESDEFAULT_TXT 16135
#define VPROJ_IDDP_EXTERNALMAKE_DEBUG_OPTIONS 16135
#define VPROJ_IDDP_DEBUG_OPTIONS              16136
#define VPROJ_IDDP_TOOL_GENERAL               16137
#define VPROJ_IDS_CLOSE_ALL_WINDOWS           16138
#define VPROJ_IDS_CAT_WIN32_OUTPUT            16139
#define VPROJ_IDS_DIRECTORIES                 16140
#define VPROJ_IDS_CAT_DEBUG                   16141
#define VPROJ_IDS_NO_PROPS                    16142
#define VPROJ_IDS_PROJMENU_COMPILE            16143
#define VPROJ_IDS_PROJMENU_BUILD              16144
#define VPROJ_IDS_DLL_COL_PRELOAD             16145
#define VPROJ_IDS_DEBUG_OPTIONS               16146
#define VPROJ_IDS_DEBUG_ADD_DLL               16147
#define VPROJ_IDS_NO_EMPTY_GROUP              16148
#define VPROJ_IDS_CMD_REQUIRES_PROJ           16149
#define VPROJ_IDS_WARN_OVERWRITE_EXISTING_PROJ 16150
#define VPROJ_IDS_CONV_PROJLIBGROUP           16151
#define VPROJ_IDS_READING_PROJECT             16152
#define VPROJ_IDS_WRITING_PROJECT             16153
#define VPROJ_IDS_NOT_IN_PROJ_QUERY_ADD       16154
#define VPROJ_IDS_FILE_NOT_IN_PROJ_CANT_SCAN  16155
#define VPROJ_IDS_FILE_NOT_IN_PROJ_CANT_COMPILE 16156
#define VPROJ_IDS_DLL_COL_LOCALNAME           16157
#define VPROJ_IDS_TXT_DEF_OPT                 16158
#define VPROJ_IDS_DLL_COL_REMOTENAME          16159
#define VPROJ_IDS_TXT_PRJ_OPT                 16160
#define VPROJ_IDS_TXT_GRP_OPT                 16161
#define VPROJ_IDS_FILTER_DLLS                 16162
#define VPROJ_IDS_NO_EMPTY_TARGET             16163
#define VPROJ_IDS_DEST_CANNOT_BE_DIR          16164
#define VPROJ_IDS_DEST_IS_DIR                 16165
#define VPROJ_IDC_GRID_HOLDER                 16166
#define VPROJ_IDS_DROP_DURING_BUILD           16166
#define VPROJ_IDC_TARGREF_EXCLUDE             16167
#define VPROJ_IDS_DEST_BAD_EXTENSION          16167
#define VPROJ_IDS_DEST_BAD_PATH               16168
#define VPROJ_IDS_DEST_SBR                    16169
#define VPROJ_IDS_DEST_RES                    16170
#define VPROJ_IDS_DEST_BSC                    16171
#define VPROJ_IDS_DEST_TRG                    16172
#define VPROJ_IDS_DEST_MAP                    16173
#define VPROJ_IDS_ExcludeHeaderFile           16174
#define VPROJ_IDC_TOOL_FILES                  16175
#define VPROJ_IDB_PROJTOOLS                   16175
#define VPROJ_IDC_TOOLS_TXT                   16176
#define VPROJ_IDS_SysExcludeHeaderFile        16176
#define VPROJ_IDC_OUTPUTS_TXT                 16177
#define VPROJ_IDS_WARN_RESET_DEFAULT_PROPERTIES 16177
#define VPROJ_IDC_TOOL_FILES_TXT              16178
#define VPROJ_IDS_CANT_COMPILE_NO_TOOL        16178
#define VPROJ_IDC_TOOL_FILES_PHOLDER          16179
#define VPROJ_IDS_SAVE_VCP_FOR_EXEPROJ        16179
#define VPROJ_IDS_MULTIPLE_DEFS               16180
#define VPROJ_IDS_BUILD_PREP                  16181
#define VPROJ_IDC_PLATFORM_TEXT               16182
#define VPROJ_IDS_BAD_HEX_NUMBER              16182
#define VPROJ_IDC_PLATFORMS                   16183
#define VPROJ_IDS_BAD_DEC_NUMBER              16183
#define VPROJ_IDC_TARGET                      16184
#define VPROJ_IDS_BAD_OCT_NUMBER              16184
#define VPROJ_IDS_BUILD_UPTODATE              16185
#define VPROJ_IDS_INVALID_NEWTARGET           16186
#define VPROJ_IDS_DELETE_TARGET               16187
#define VPROJ_IDS_MKTYPLIB                    16188
#define VPROJ_IDS_DESC_MKTYPLIB_COMPILING     16189
#define VPROJ_IDS_DEST_TLB                    16190
#define VPROJ_IDS_DEST_INCLUDE                16191
#define VPROJ_IDS_BUILD_TARGETNAME            16193
#define VPROJ_IDS_BUILD_BATCH_CONTINUE        16194
#define VPROJ_IDS_WarnLevel0                  16195
#define VPROJ_IDS_WarnLevel1                  16196
#define VPROJ_IDS_WarnLevel2                  16197
#define VPROJ_IDS_WarnLevel3                  16198
#define VPROJ_IDS_WarnLevel4                  16199
#define VPROJ_IDS_Optimize0                   16200
#define VPROJ_IDS_Optimize1                   16201
#define VPROJ_IDS_Optimize2                   16202
#define VPROJ_IDS_Optimize3                   16203
#define VPROJ_IDS_Optimize4                   16204
#define VPROJ_IDS_DebugInfo0                  16205
#define VPROJ_IDS_DebugInfo1                  16206
#define VPROJ_IDS_DebugInfo2                  16207
#define VPROJ_IDS_DebugInfo3                  16208
#define VPROJ_IDS_ListAsm0                    16209
#define VPROJ_IDS_ListAsm1                    16210
#define VPROJ_IDS_ListAsm2                    16211
#define VPROJ_IDS_ListAsm3                    16212
#define VPROJ_IDS_ListAsm4                    16213
#define VPROJ_IDDP_PROJECT_TARGET             16214
#define VPROJ_IDS_SOUND_BUILD_ERROR           16214
#define VPROJ_IDD_PROJECT_TARGET              16215
#define VPROJ_IDS_SOUND_BUILD_ERROR2          16215
#define VPROJ_IDD_RENAME_TARGET               16216
#define VPROJ_IDS_SOUND_BUILD_WARNING         16216
#define VPROJ_IDD_PROJECT_OPTIONS             16217
#define VPROJ_IDS_SOUND_BUILD_WARNING2        16217
#define VPROJ_IDD_PROJECT_BATCH_BUILD         16218
#define VPROJ_IDS_SOUND_BUILD_COMPLETE        16218
#define VPROJ_IDD_DIALOGBAR_PROJECT           16219
#define VPROJ_IDS_SOUND_BUILD_COMPLETE2       16219
#define VPROJ_IDD_TOOL_OPTION_TAB             16220
#define VPROJ_IDS_SOUND_BUILD_UPTODATE        16220
#define VPROJ_IDDP_FILE_GENERAL               16221
#define VPROJ_IDS_SOUND_BUILD_UPTODATE2       16221
#define VPROJ_IDDP_DEP_GENERAL                16222
#define VPROJ_IDI_ICON1                       16223
#define VPROJ_IDS_Inline0                     16224
#define VPROJ_IDS_Inline1                     16225
#define VPROJ_IDS_Inline2                     16226
#define VPROJ_IDS_OptimizeOpt0                16227
#define VPROJ_IDS_OptimizeOpt1                16228
#define VPROJ_IDS_OptimizeOpt2                16229
#define VPROJ_IDS_OptimizeOpt3                16230
#define VPROJ_IDS_OptimizeOpt4                16231
#define VPROJ_IDS_OptimizeOpt5                16232
#define VPROJ_IDS_OptimizeOpt6                16233
#define VPROJ_IDS_OptimizeOpt7                16234
#define VPROJ_IDS_OptimizeOpt8                16235
#define VPROJ_IDS_PtrMbr10                    16236
#define VPROJ_IDS_PtrMbr11                    16237
#define VPROJ_IDS_PtrMbr20                    16238
#define VPROJ_IDS_PtrMbr21                    16239
#define VPROJ_IDS_PtrMbr22                    16240
#define VPROJ_IDS_PROJ_OPEN_FOR_WRITE_FAIL    16241
#define VPROJ_IDS_TOOL_OPT                    16242
#define VPROJ_IDS_REG_TOOLPERFIFABLE          16243
#define VPROJ_IDS_COMMON                      16244
#define VPROJ_IDS_REG_TOOLINTERNAL            16245
#define VPROJ_IDS_REG_TOOLEXE                 16246
#define VPROJ_IDS_REG_TOOLMENU                16247
#define VPROJ_IDS_REG_TOOLDEFERRED            16248
#define VPROJ_IDS_DEST_CLW                    16249
#define VPROJ_IDS_OPTIONSFOR                  16250
#define VPROJ_IDS_MFC_NOT_INSTALLED           16251
#define VPROJ_IDS_REG_PLATCURRENTTL           16252
#define VPROJ_IDS_MAKEFILE_NO_KNOWN_TARGETS   16253
#define VPROJ_IDS_MAKEFILE_UNKNOWN_TARGETS    16254
#define VPROJ_IDS_CREATE_FILE                 16255
#define VPROJ_IDS_CANNOT_CREATE_FILE          16256
#define VPROJ_IDS_ERR_OPENING_MAK_AS_TEXT     16257
#define VPROJ_IDS_GET_REMTARG                 16258
#define VPROJ_IDS_GET_CALLING_PROG_DEBUG      16259
#define VPROJ_IDS_GET_CALLING_PROG            16260
#define VPROJ_IDS_NO_PARTIAL_PATHNAMES        16261
#define VPROJ_IDS_MUST_SPECIFY_VOLUME_NAME    16262
#define VPROJ_IDS_DESC_INCR_LINKING           16263
#define VPROJ_IDS_REG_PLATTRANSPORTS          16264
#define VPROJ_IDS_REG_PLATTL                  16265
#define VPROJ_IDS_FILEREG_STATUS_ERROR        16266
#define VPROJ_IDS_FILEREG_STATUS_ERROR_EX     16267
#define VPROJ_IDS_REG_TOOLDBG                 16269
#define VPROJ_IDS_NO_TARGET_DEPS_TO_ADD       16270
#define VPROJ_IDS_REG_TOOLINPUT               16271
#define VPROJ_IDD_ADD_DIRECTORY               16272
#define VPROJ_IDD_NO_CMN_OPTIONS              16273
#define VPROJ_IDD_CUSTOM_TOOLS                16274
#define VPROJ_IDS_REG_TOOLOUTPUT              16275
#define VPROJ_IDS_DESC_PERFORMING             16276
#define VPROJ_IDS_PROJ_TRG_NONEXISTANT        16277
#define VPROJ_IDS_FILE_ITEM_NONEXISTANT       16278
#define VPROJ_IDS_NO_TOOL_OUTPUT              16279
#define VPROJ_IDS_PEROPT_NA                   16280
#define VPROJ_IDS_UNSUPPORTED                 16282
#define VPROJ_IDS_FAIL_SPAWN                  16283
#define VPROJ_IDS_TERMINATE_USER_REQ          16284
#define VPROJ_IDS_FAIL_EXECUTE                16285
#define VPROJ_IDS_TOOL_HAS_NO_RSP_SUPPORT     16286
#define VPROJ_IDS_BSCMAKE_TOOL                16287
#define VPROJ_IDS_LIBMGR_TOOL                 16288
#define VPROJ_IDS_LINKCOFF_TOOL               16289
#define VPROJ_IDS_MKTYPLIB_TOOL               16290
#define VPROJ_IDS_RESCOMPILER32_TOOL          16291
#define VPROJ_IDS_REG_PLATATTRIBTL            16292
#define VPROJ_IDS_REG_PLATDESCTL              16293
#define VPROJ_IDS_REG_PLATNM                  16294
#define VPROJ_IDS_REG_PLATEE                  16295
#define VPROJ_IDS_REG_PLATEM                  16296
#define VPROJ_IDS_REG_PLATATTRIBNM            16297
#define VPROJ_IDS_REG_PLATCURRENTEE           16298
#define VPROJ_IDS_REG_PLATCURRENTEM           16299
#define VPROJ_IDS_REG_PLATCURRENTSH           16300
#define VPROJ_IDS_REG_PLATSH                  16301
#define VPROJ_IDS_NO_TOOL_INPUT               16302
#define VPROJ_IDS_CPOP_BUILD                  16303
#define VPROJ_IDS_CPOP_COMPILE                16304
#define VPROJ_IDS_CPOP_PROJSETTINGS           16305
#define VPROJ_IDS_PROJECT_OPTIONS             16306
#define VPROJ_IDS_EXTTYPE_EXE                 16307
#define VPROJ_IDS_PROJECT_AND                 16308
#define VPROJ_IDS_PROJECT_ANDNOT              16309
#define VPROJ_IDS_PROJECT_REPLACES            16310
#define VPROJ_IDS_PREVFOLDER                  16311
#define VPROJ_IDS_PROJECT                     16312
#define VPROJ_IDS_FILEITEM                    16313
#define VPROJ_IDS_DEPFILE                     16314
#define VPROJ_IDS_DUPES_IN_SELECTION          16315
#define VPROJ_IDS_UNDO_ADD_FILES              16316
#define VPROJ_IDS_UNDO_ADD_GROUP              16317
#define VPROJ_IDS_UNDO_DROP                   16318
#define VPROJ_IDS_PROJECT_FILES               16319
#define VPROJ_IDS_BLD_FILTER_0                16320
#define VPROJ_IDS_BLD_FILTER_1                16321
#define VPROJ_IDS_BLD_FILTER_2                16322
#define VPROJ_IDS_BLD_FILTER_3                16323
#define VPROJ_IDS_BLD_FILTER_4                16324
#define VPROJ_IDS_BLD_FILTER_5                16325
#define VPROJ_IDS_BLD_FILTER_6                16326
#define VPROJ_IDS_BLD_FILTER_7                16327
#define VPROJ_IDS_BLD_FILTER_8                16328
#define VPROJ_IDS_EXTTARG_PROJTYPE            16329
#define VPROJ_IDS_BUILD_DUPTARGET             16330
#define VPROJ_IDDP_PROJ_NO_PROPS              16330
#define VPROJ_IDS_SAVE_READ_ONLY              16331
#define VPROJ_IDD_NEW_TARGET                  16331
#define VPROJ_IDD_EDITPROJECT_DBCS            16332
#define VPROJ_IDDP_DEBUG_ADD_DLL              16333
#define VPROJ_IDD_REMOTE_TARG_NAME            16334
#define VPROJ_IDD_EXE_FOR_DEBUG               16335
#define VPROJ_IDD_TARGETOPTIONS               16336
#define VPROJ_IDS_FILTER_COMMON_BLD           16336
#define VPROJ_IDD_TARGET_OPTIONS              16337
#define VPROJ_IDS_FILTER_PROJECTS             16337
#define VPROJ_IDS_FILTER_EXECUTABLES          16338
#define VPROJ_IDS_FILTER_ODL                  16339
#define VPROJ_IDS_FILTER_LIB                  16340
#define VPROJ_IDS_FILTER_OBJ                  16341
#define VPROJ_IDD_SELECT_TARGET               16342
#define VPROJ_IDDP_TARGREF_GENERAL            16343
#define VPROJ_IDS_OPENAS_PROJECT              16346
#define VPROJ_IDS_SAVING_FILES                16347
#define VPROJ_IDDP_EXTTARGET_OPTIONS          16348
#define VPROJ_IDD_PLATFORMS                   16349
#define VPROJ_IDDP_PROPERTIES_TARGETS         16350
#define VPROJ_IDD_FIND_MODULE                 16351
#define VPROJ_IDDP_DEBUG_CATEGORY             16352
#define VPROJ_IDDP_DEBUG_ADD_DLL1             16353
#define VPROJ_IDDP_TOOL_FILES                 16354
#define VPROJ_IDDP_DEBUG_ADD_DLL2             16355
#define VPROJ_IDS_SOURCE_CONTROL              16357
#define VPROJ_IDS_ERROR_DIR_NOT_EXIST         16358
#define VPROJ_IDS_PROPERTIES_TARGETS          16373
#define VPROJ_IDS_SELECT_TARGET               16374
#define VPROJ_IDS_MBCS_DEFINE                 16375
#define VPROJ_IDS_WIN32_LIBS                  16376
#define VPROJ_IDS_OLE2_LIBS                   16377
#define VPROJ_IDS_MFCDLL_DEFINE               16378
#define VPROJ_IDS_WINDLL_DEFINE               16379
#define VPROJ_IDS_MFCUSRDLL_DEFINE            16380
#define VPROJ_IDS_ODBC_LIBS                   16381
#define VPROJ_IDS_NO_CPP_EXCEPTIONS           16382
#define VPROJ_IDS_WIN32_LIBS_CORE             16382
#define VPROJ_IDS_BROWSEDLG_TITLE             16383
#define VPROJ_IDS_REG_TOOLPREFIX              16384
#define VPROJ_IDS_INVALID_PROJECT_LOCALPATH   16385
#define VPROJ_IDC_EDITTOOL_PREFIX             16386
#define VPROJ_IDD_CUSTOM_BUILD_TAB            16387
#define VPROJ_IDS_CUSTOM_BUILD_TITLE          16388
#define VPROJ_IDS_CANNOT_BUILD_DEP            16390
#define VPROJ_IDS_BLDFOR_FILTER_0             16391
#define VPROJ_IDC_GRAPH_VSCRL                 16391
#define VPROJ_IDC_TXT_MODULES                 16391
#define VPROJ_IDS_BLDFOR_FILTER_1             16392
#define VPROJ_IDC_GRAPH_HSCRL                 16392
#define VPROJ_IDS_BLDFOR_FILTER_2             16393
#define VPROJ_IDC_GRAPH_FRAME                 16393
#define VPROJ_IDS_BLDFOR_FILTER_3             16394
#define VPROJ_IDC_GRAPH_LEGEND                16394
#define VPROJ_IDS_BLDALL_FILTER_0             16395
#define VPROJ_IDS_BLDALL_FILTER_1             16396
#define VPROJ_IDS_BLDALL_FILTER_2             16397
#define VPROJ_IDS_NO_TOOL_DEP                 16398
#define VPROJ_IDC_CUSTOM_INPUT                16399
#define VPROJ_IDC_CUSTOM_CMDS                 16400
#define VPROJ_IDC_CUSTOM_OUTPUT               16401
#define VPROJ_IDD_GRAPH_DIALOG                16402
#define VPROJ_IDC_CUSTOM_CMDS_PHOLDER         16403
#define VPROJ_IDC_CUSTOM_OUTPUT_PHOLDER       16404
#define VPROJ_IDS_MULTI_SELECTION             16405
#define VPROJ_IDC_CUSTOM_DESC                 16406
#define VPROJ_IDDP_TOOL_INPUTS                16407
#define VPROJ_IDDP_TOOL_OUTPUTS               16408
#define VPROJ_IDDP_TOOL_DEPENDENCIES          16409
#define VPROJ_IDC_PROJ_SUBDIR                 16410
#define VPROJ_IDC_PLATFORM_LIST               16411
#define VPROJ_IDC_PROJ_NEW_NAME               16412
#define VPROJ_IDC_SCC                         16414
#define VPROJ_IDC_SUBDIR_STATIC               16415
#define VPROJ_IDS_CREATE_DOTS                 16416
#define VPROJ_IDS_CREATE_NODOTS               16417
#define VPROJ_IDS_OVERWRITE_FILE              16418
#define VPROJ_IDS_CANT_DELETE_FILE            16419
#define VPROJ_IDS_SELECT_PLATFORM             16420
#define VPROJ_IDS_PATH_TOO_LONG               16421
#define VPROJ_IDS_SUBDIR_ERROR                16422
#define VPROJ_IDS_DIRECT_IS_FILE              16423
#define VPROJ_IDS_NO_PERMISSION               16424
#define VPROJ_IDS_INVALID_SUBDIR              16425
#define VPROJ_IDS_INVALID_PROJ                16426
#define VPROJ_IDS_DIRECT_CHANGE               16427
#define VPROJ_IDS_INVALID_NAME                16428
#define VPROJ_IDC_STATIC_TRACKING_TXT         16429
#define VPROJ_IDS_DUPE_DIR_SPEC               16429
#define VPROJ_IDD_NEW_WORKSPACE               16431
#define VPROJ_IDD_INSERT_PROJECT              16432
#define VPROJ_IDD_INSERTPROJ_COPY             16433
#define VPROJ_IDC_TARGET_LISTCOMBO            16434
#define VPROJ_IDC_TARGET_PLATFORM             16435
#define VPROJ_IDC_PROJECT_NAME                16436
#define VPROJ_IDC_BSCNAME                     16439
#define VPROJ_IDC_UPATE_BROWSE_ICON           16440
#define VPROJ_IDD_UPDATE_ALLDEP               16459
#define VPROJ_IDS_NULL                        16466
#define VPROJ_IDS_WIN95_NULL                  16467
#define VPROJ_IDS_DIR_CREATE                  16468
#define VPROJ_IDS_ERROR_OPEN                  16469
#define VPROJ_IDB_FOLDER_ITEM                 16469
#define VPROJ_IDS_V2_WIN32MIPS_PLATFORM       16470
#define VPROJ_IDS_V2_WIN32X86_PLATFORM        16471
#define VPROJ_IDS_V2_MAC68K_PLATFORM          16472
#define VPROJ_IDS_V2_WIN32_PLATFORM           16473
#define VPROJ_IDS_V2_MACPPC_PLATFORM          16474
#define VPROJ_IDS_PROJNAME_EXISTS             16475
#define VPROJ_IDS_CANT_LOAD_WORKSPACE         16476
#define VPROJ_IDS_VCP_NOT_FOUND               16477
#define VPROJ_IDD_UPDATE_BROWSE               16478
#define VPROJ_IDS_TURN_OFF_BROWSE             16478
#define VPROJ_IDS_CONVERT_PORT2               16479
#define VPROJ_IDD_ADD_CFG_DEP                 18451

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define VPROJ__APS_3D_CONTROLS                     1
#define VPROJ__APS_NEXT_RESOURCE_VALUE        16480
#define VPROJ__APS_NEXT_COMMAND_VALUE         16434
#define VPROJ__APS_NEXT_CONTROL_VALUE         16441
#define VPROJ__APS_NEXT_SYMED_VALUE           16434
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\sym\68k\optnlink.h ===
//{{NO_DEPENDENCIES}}
// compiler option control IDs

// 'Macintosh 68k' Category IDs
#define OPTNLINK_IDDP_LINKER_MAC68K		18454
#define OPTNLINK_IDC_MECR_DEFERRED		0x4c30
#define OPTNLINK_IDC_FILE_TYPE			0x4c31
#define OPTNLINK_IDC_FILE_CREATOR		0x4c32
#define OPTNLINK_IDC_MACDATA			0x4c33
#define OPTNLINK_IDC_BUNDLE_BIT			0x4c34

#define OPTNLINK_IDC_TXT_FILE_TYPE		0x4c40
#define OPTNLINK_IDC_TXT_FILE_CREATOR		0x4c41
#define OPTNLINK_IDC_TXT_MACDATA			0x4c42
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\wrk\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		BrianCr				09/06/94
//
//	Description :
//		Precompiled header for all of the core MFC files
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\sym\68k\optnmrc.h ===
//{{NO_DEPENDENCIES}}
// resource compiler control IDs

// 'Macintosh Resource Compiler' Category IDs
#define OPTNRC_IDDP_PROJ_MRC		18453
#define OPTNRC_IDC_MRES_OUTNAME	0x4c21
#define OPTNRC_IDC_MRES_ALIGN		0x4c22
#define OPTNRC_IDC_MRES_INCL		0x4c23
#define OPTNRC_IDC_MRES_MACINCL	0x4c24
#define OPTNRC_IDC_MRES_DEF		0x4c25
#define OPTNRC_IDC_MRES_UNDEF		0x4c26
#define OPTNRC_IDC_MRES_MAPRO		0x4c27

#define OPTNRC_IDC_MREST1		0x4c2a
#define OPTNRC_IDC_MREST2		0x4c2b
#define OPTNRC_IDC_MREST3		0x4c2c
#define OPTNRC_IDC_MREST4		0x4c2d
#define OPTNRC_IDC_MREST5		0x4c2e
#define OPTNRC_IDC_MREST6		0x4c2f
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\wrk\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			Date :
//		BrianCr				09/06/94
//
//	Description :
//		source file that includes just the standard includes
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\sym\xboxsyms.h ===
#ifndef __XBOXSYMS_H__
#define __XBOXSYMS_H__

// emmang@xbox

#define IMAGEBLD_IDC_CATEGORY		16112 /*VPROJ_IDC_MINI_PAGE*/	 	// Combo box
#define IMAGEBLD_IDC_DEFAULT		16074 /*VPROJ_IDC_SET_DEFAULT*/	// Button
#define IMAGEBLD_IDC_OPTIONS		16017 /*VPROJ_IDC_OPTSTR*/	 	// Multi line Edit box

// extracted from xboxdbg.pkg
// using resource hacker tool

#define IMAGEBLD_IDC_XBE_NAME       0x3D05  // Edit Box
#define IMAGEBLD_IDC_XBE_FLAGS      0x3D18  // Edit Box
#define IMAGEBLD_IDC_STACK_SIZE     0x3CFB  // Edit Box
#define IMAGEBLD_IDC_XBE_DEBUG      0x3CFC  // Check button
#define IMAGEBLD_IDC_AUTOCOPY_OFF   0x3D04  // Check button
#define IMAGEBLD_IDC_64MB_MEM       0x3D10  // Check button

#define IMAGEBLD_IDC_TITLE_ID       0x3CF7  // Edit Box
#define IMAGEBLD_IDC_TITLE_NAME     0x3CF8  // Edit Box
#define IMAGEBLD_IDC_PUBLISHER_NAME 0x3CF9  // Edit Box
#define IMAGEBLD_IDC_TITLE_IMAGE    0x3D12  // Edit Box
#define IMAGEBLD_IDC_TITLE_NAME2    0x3D14  // Edit Box
#define IMAGEBLD_IDC_DEFSAVE_IMAG   0x3D16  // Edit Box

// category indices for Xbox Image (ImageBld) tab
#define IMAGEBLD_GENERAL		1		
#define IMAGEBLD_TITLE			2

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\wrk\dllmain.cpp ===
/////////////////////////////////////////////////////////////////////////////
// dllmain.cpp
//
// email	date		change
// michma	06/11/97	created
//
// copyright 1997 Microsoft

#include "stdafx.h"
#include "afxdllx.h"

#define new DEBUG_NEW

///////////////////////////////////////////////////////////////////////////////
//	DLL support

static AFX_EXTENSION_MODULE extensionDLL = { NULL, NULL };

extern "C" __declspec(dllexport) int APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		TRACE0("Wrk DLL Initializing!\n");
		
		// Extension DLL one-time initialization
		AfxInitExtensionModule(extensionDLL, hInstance);

		// Insert this DLL into the resource chain
		new CDynLinkLibrary(extensionDLL);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		TRACE0("Wrk DLL Terminating!\n");
		// Terminate the library before destructors are called
		AfxTermExtensionModule(extensionDLL);
	}
	return 1;   // ok

	UNREFERENCED_PARAMETER(lpReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\APIWiz\apiwidlg.cpp ===
// apiwidlg.cpp : implementation file
//

#include "stdafx.h"
#include "apiwiz.h"
#include "apiwidlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CApiwizDlg  Tabbed dialog

IMPLEMENT_DYNAMIC( CApiwizDlg, CPropertySheet )


CApiwizDlg::CApiwizDlg(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);	//Review: (Delete)
}

CApiwizDlg::CApiwizDlg(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);	//Review: (Delete)
}

CApiwizDlg::~CApiwizDlg()
{
}


BEGIN_MESSAGE_MAP(CApiwizDlg, CPropertySheet)
	//{{AFX_MSG_MAP(CApiwizDlg)
		ON_WM_PAINT()
		ON_WM_QUERYDRAGICON()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CApiwizDlg message handlers


// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CApiwizDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CPropertySheet::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CApiwizDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\wrk\export.h ===
///////////////////////////////////////////////////////////////////////////////
//	export.h (WRK export)
//
//	Created by :			Date :
//		ScotF				06/20/97
//
//	Description :
//		WRK DLL defines
//

#ifndef __WRKXPRT_H__
#define __WRKXPRT_H__

#ifdef EXPORT_WRK
	#define WRK_CLASS AFX_EXT_CLASS
	#define WRK_API   AFX_EXT_API
	#define WRK_DATA  AFX_EXT_DATA
#else
	#define WRK_CLASS __declspec(dllimport)
	#define WRK_API   __declspec(dllimport)
	#define WRK_DATA  __declspec(dllimport)

	#ifdef _DEBUG 
		#pragma comment(lib, "wrkd.lib")
	#else
		#pragma comment(lib, "wrk.lib")
	#endif
#endif

#endif // __WRKXPRT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\wrk\uiwrkspc.h ===
///////////////////////////////////////////////////////////////////////////////
//  UIWKSPC.H
//
//  Created by :            Date :
//      JimGries            4/25/95
//
//  Description :
//      Declaration for the dockable Workspace window.
//

#ifndef __UIWRKSPC_H__
#define __UIWRKSPC_H__

#include "..\shl\udockwnd.h"
#include "..\sym\dockids.h"
#include "..\src\cosource.h"

#include "export.h"

#ifndef __UIWRKSPC_H__
    #error include 'udockwnd.h' before including this file
#endif

// The following are error codes returned by UIWorkspaceWindow member functions.
#define SUCCESS					 0
#define ERROR_ERROR				-1
#define ERROR_NO_PROJECT		-2
#define ERROR_NO_RESFILE		-3
#define ERROR_NO_CLASS			-4
#define	ERROR_NO_MEMBER			-5
#define ERROR_NO_RESOURCE		-6
#define ERROR_NO_FILE			-7
#define ERROR_NO_GLOBAL			-8
#define ERROR_NO_DECLARATION	-9
#define ERROR_NO_DEFINITION		-10
#define ERROR_GOTO			    -11

// The following defines are control IDs that are used to acces information on
// property dialogs.  See IDE source Clsview/resource.h
#define IDC_CLASSNAME 1012
#define IDC_FUNCTNAME 1009
#define IDC_DATANAME  1010
#define IDC_TARGNAME  1017

///////////////////////////////////////////////////////////////////////////////
//  UIWorkspaceWindow

// BEGIN_CLASS_HELP
// ClassName: UIWorkspaceWindow
// BaseClass: UIDockWindow
// Category: Workspace
// END_CLASS_HELP
class WRK_CLASS UIWorkspaceWindow : public UIDockWindow
{
public:
	void RemoveCharFromString(CString *, char);

	enum MEMBER_TYPE { Function, Data };
	typedef MEMBER_TYPE GLOBAL_TYPE;

    UIWorkspaceWindow();
	operator HWND ( ) {return HWnd();} ;
	operator BOOL() {return  HWnd() == 0;} ;

    virtual BOOL Activate(void);
    UINT GetID(void) const;

	BOOL ActivateBuildPane();
	BOOL ActivateDataPane();
	BOOL ActivateHelpPane();
	BOOL ActivateClassPane();
	BOOL ActivateResourcePane();

	int SelectProject(LPCSTR);
	int SelectClass(LPCSTR, LPCSTR = NULL);
	int SelectGlobal(LPCSTR, GLOBAL_TYPE, LPCSTR = NULL);
	int SelectClassMember(LPCSTR, MEMBER_TYPE, LPCSTR = NULL, LPCSTR = NULL);
	int SelectResource(LPCSTR, LPCSTR, LPCSTR = NULL);
	int SelectResource2(LPCSTR, LPCSTR, LPCSTR = NULL);
	int SelectFile(LPCSTR, LPCSTR = NULL);


	int GotoClassMemberDeclaration(LPCSTR, MEMBER_TYPE, COSource*, LPCSTR = NULL, LPCSTR = NULL);
	int GotoClassMemberDefinition(LPCSTR, MEMBER_TYPE, COSource*, LPCSTR = NULL, LPCSTR = NULL);
	int GotoGlobalDefinition(LPCSTR, GLOBAL_TYPE, COSource*, LPCSTR = NULL);
	int GotoClassDefinition(LPCSTR, COSource*, LPCSTR = NULL);
	int GotoClassDeclaration(LPCSTR, COSource*, LPCSTR = NULL);
	int GotoDefinitionFromHere(LPCSTR);
	int GotoDeclarationFromHere(LPCSTR);

	BOOL SetActiveProject(LPCSTR projName);

};

#endif //__UIWRKSPC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\APIWiz\apipage.h ===
// apipage.h : header file
//
#include "areaslb.h"
#include "data.h"

/////////////////////////////////////////////////////////////////////////////
// CAPIPage dialog

#ifndef _CAPIPAGE_
#define _CAPIPAGE_

#define API_FT_TEXT 0x0001

class CAPIPage : public CPropertyPage
{
    DECLARE_DYNCREATE(CAPIPage)
// Construction
public:
	CAPIPage(); 
    ~CAPIPage();
// Dialog Data
	CAreasLB  m_areaList;
	//{{AFX_DATA(CAPIPage)
	enum { IDD = IDD_API };
	CEdit		m_ApiCallCtrl;
	CStatic		m_apiDescription;
	CListBox	m_parameterList;
	CListBox	m_apiList;
	CComboBox	m_categoryCB;
	CString		m_category;
	int		m_iDisplayClassNames;
	int		m_iDisplayReturnType;
	int		m_iDisplayParams;
	//}}AFX_DATA


// Attributes
public:
	CStringList     m_stringList;
	CAPIArray       m_apiArray;
    CAreaArray      m_areaArray;
	
	CString			m_strCurrentCategory;
    CString         m_strCurrentArea;
    CString         m_strCurrentSubarea;
	CString			m_strCurrentAPI;

	BOOL			m_bIsOldFormat;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CAPIPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	virtual void OnOK() ;

// Operations
public:
    UINT    OpenAPIData(LPCSTR szFileName, UINT nFileType = API_FT_TEXT);
    void    LoadAPIList(void);
    void    DisplayAreas(void);

    BOOL    InterpretLine(LPCSTR szNewLine);
    char*  RemoveExtraChars(char* pchLine);

    void    FillStructures( LPCSTR szLine );
	LPCSTR	SetCurrentCategory( LPCSTR szLine);
    LPCSTR  FillAreaStruct(LPCSTR szLine);
	LPCSTR  FillBaseClassStruct(LPCSTR szLine);
	LPCSTR  FillClassStruct(LPCSTR szLine);
    LPCSTR  FillSubareaStruct(LPCSTR szLine);
    LPCSTR  FillAPIStruct(LPCSTR szLine );
	LPCSTR  FillDescStruct(LPCSTR szLine);
	LPCSTR  FillReturnStruct(LPCSTR szLine);
	LPCSTR	FillParamStruct(LPCSTR szLine, CAPI* pAPI = NULL);
	LPCSTR  FillParamDescStruct(LPCSTR szLine);

    int     FindArea(LPCSTR szArea = NULL);
	BOOL	IsArea(int index);
	void	ExpandArea(int index, BOOL bExpand = TRUE);
	void	DisplaySubareas( int index, int i=-1 );
	void	HideSubareas( int index, int i=-1 );
	void	DisplayAreaAPIs( int index );
	void	DisplaySubareaAPIs( int index );
	CString	GetAreaName( int index );
	void	DisplayParameters( int index, BOOL bAddedToScript = FALSE );
	void	DisplayAPIDescription( int index );
	void	DisplayParamDescription( int index );
	CString CreateVarFromClassName(CString& strClassName);
	void 	OnInsert(); 


// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CAPIPage)
	afx_msg void OnSelchangeCategory();
	virtual BOOL OnInitDialog();
	afx_msg void OnDblclkListAreas();
	afx_msg void OnSelchangeListAreas();
	afx_msg void OnSelchangeListApi();
	afx_msg void OnDblclkListApi();
	afx_msg void OnSetfocusListApi();
	afx_msg void OnKillfocusListApi();
	afx_msg void OnSelchangeListParameters();
	afx_msg void OnDisplayClassnames();
	afx_msg void OnDisplayReturnType();
	afx_msg void OnDisplayParams();
	afx_msg void OnAddApi();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif // _CAPIPAGE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\APIWiz\apipage.cpp ===
// apipage.cpp : implementation file
//

#include "stdafx.h"
#include "apiwiz.h"
#include "data.h"
#include "apipage.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAPIPage property page

extern TEXTMETRIC tm ;
extern int cxChar, cxCaps, cyChar ;

// Pens and Brushes we need to show selections.
extern CBrush brSelRect ;
extern CBrush brUnSelRect ;
extern CPen   penUnSelRect ;
extern CPen   penSelRect ;
extern CBitmap bmapUnCheck, bmapCheck, bmapTriangle, bmapNone , bmapTestCase;								 

IMPLEMENT_DYNCREATE(CAPIPage, CPropertyPage)

CAPIPage::CAPIPage()
	: CPropertyPage(CAPIPage::IDD)
{
	//{{AFX_DATA_INIT(CAPIPage)
	m_iDisplayClassNames = FALSE;
	m_iDisplayReturnType = FALSE;
	m_iDisplayParams = TRUE;
	//}}AFX_DATA_INIT
}

CAPIPage::~CAPIPage()
{
}

void CAPIPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAPIPage)
	DDX_Control(pDX, IDC_API_CALL, m_ApiCallCtrl);
	DDX_Control(pDX, IDC_DESCRIPTION, m_apiDescription);
	DDX_Control(pDX, IDC_LIST_PARAMETERS, m_parameterList);
	DDX_Control(pDX, IDC_LIST_API, m_apiList);
	DDX_Control(pDX, IDC_CATEGORY, m_categoryCB);
	DDX_CBString(pDX, IDC_CATEGORY, m_category);  
	DDX_Check(pDX, IDC_DISPLAY_CLASSNAMES, m_iDisplayClassNames);
	DDX_Check(pDX, IDC_DISPLAY_RETURN_TYPE, m_iDisplayReturnType);
	DDX_Check(pDX, IDC_DISPLAY_PARAMS, m_iDisplayParams);
	//}}AFX_DATA_MAP
}



BEGIN_MESSAGE_MAP(CAPIPage, CPropertyPage)

	//{{AFX_MSG_MAP(CAPIPage)
	ON_CBN_SELCHANGE(IDC_CATEGORY, OnSelchangeCategory)
	ON_LBN_DBLCLK(IDC_LIST_AREAS, OnDblclkListAreas)
	ON_LBN_SELCHANGE(IDC_LIST_AREAS, OnSelchangeListAreas)
	ON_LBN_SELCHANGE(IDC_LIST_API, OnSelchangeListApi)
	ON_LBN_DBLCLK(IDC_LIST_API, OnDblclkListApi)
	ON_LBN_SETFOCUS(IDC_LIST_API, OnSetfocusListApi)
	ON_LBN_KILLFOCUS(IDC_LIST_API, OnKillfocusListApi)
	ON_LBN_SELCHANGE(IDC_LIST_PARAMETERS, OnSelchangeListParameters)
	ON_BN_CLICKED(IDC_DISPLAY_CLASSNAMES, OnDisplayClassnames)
	ON_BN_CLICKED(IDC_DISPLAY_RETURN_TYPE, OnDisplayReturnType)
	ON_BN_CLICKED(IDC_DISPLAY_PARAMS, OnDisplayParams)
	ON_BN_CLICKED(IDC_ADD_API, OnAddApi)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAPIPage operations

void CAPIPage::DisplayAreas()
{
    m_areaList.ResetContent();	// Clear Area List box
    CString str;
	int nAreas = m_areaArray.GetUpperBound();
	for (int i=0; i <= nAreas; i++) 
	{
		str = m_areaArray[i]->m_strName;
		if (m_category == m_areaArray[i]->m_strCategory)
		{
			int index = m_areaList.AddString(str);
			m_areaList.SetItemData(index,(DWORD)bmapUnCheck.GetSafeHandle());
		}
	}
    m_areaList.SetCurSel(0);
}

UINT CAPIPage::OpenAPIData(LPCSTR szFileName, UINT nFileType /*= API_FT_TEXT */)
{
	ASSERT( szFileName != NULL );
    ASSERT( m_apiArray.GetSize() == 0 );
   
	TRY                             // REVIEW:Use true exceptions
	{
		CStdioFile file(szFileName, CFile::modeRead | CFile::typeText);
		char acLine[512];
		while( file.ReadString(acLine, 511) != NULL )
			InterpretLine(acLine);
	}
	CATCH(CFileException, e)
	{
		AfxMessageBox(IDS_ERROR_CANT_OPEN);
		return FALSE;
	}
	END_CATCH;
	return TRUE;
}   

BOOL CAPIPage::InterpretLine(LPCSTR szNewLine)
{
	char* sz = new char[strlen(szNewLine) + 1];		 
	strcpy(sz, szNewLine);
	char* pCleanStr = sz;
	pCleanStr = RemoveExtraChars( pCleanStr );

	if (pCleanStr[0] == '\0')       // delete string if is empty line
	{
		delete[] sz;
		return FALSE;
	}

    FillStructures(pCleanStr);
	return TRUE;
}

char* CAPIPage::RemoveExtraChars(char* pchLine) 	  // REVIEW (EnriqueP): Move this code to CFileTableLine::CFileTableLine(pchStr)
{
	int iCRLF = strcspn(pchLine, "\'\r\n");	 // remove trailing comments , CR or LF
	pchLine[iCRLF] = '\0';
	pchLine += strspn(pchLine, "\t /");	// Remove leading spaces, tabs or '//' comments
	return pchLine;
}


void CAPIPage::FillStructures( LPCSTR szLine )
{
    ASSERT(szLine[0] != '\0');


	while( szLine[0] != '\0' )
	{
		int nSeparator = strcspn(szLine, ": \t");
        CString strLineType =  CString(szLine, nSeparator);	// Get first word
        szLine = szLine + nSeparator + strspn(szLine + nSeparator, ": \t");  // Advance to next word

		strLineType.MakeUpper();

		if (strLineType == "CLASSNAME")			
            szLine = FillClassStruct(szLine);
	    if (strLineType == "BASECLASS")
            szLine = FillBaseClassStruct(szLine);
		if (strLineType == "CATEGORY")
            szLine = SetCurrentCategory(szLine);	

        if (strLineType == "FUNCTION" )
            szLine = FillAPIStruct(szLine);
		if (strLineType == "DESCRIPTION" )
            szLine = FillDescStruct(szLine);
        if (strLineType == "RETURN" )
            szLine = FillReturnStruct(szLine);
		if (strLineType == "PARAM" )
			if (m_bIsOldFormat)
				szLine = FillParamStruct(szLine);		
			else
				szLine = FillParamDescStruct(szLine);
//		Old formats
		if (strLineType == "API" )
		{
			m_bIsOldFormat = TRUE;
            szLine = FillAPIStruct(szLine);
		}
		if (strLineType == "AREA")
		{
			m_bIsOldFormat = TRUE;
            szLine = FillAreaStruct(szLine);
		}
        if (strLineType == "SUBAREA" )
		{
			m_bIsOldFormat = TRUE;
            szLine = FillSubareaStruct(szLine);
		}
// We skip any BEGIN_ OR END_ keywords
	}	
		
}

LPCSTR CAPIPage::SetCurrentCategory(LPCSTR szLine)	//REVIEW: Change to FillCategoryStruct()
{
	//DefaultAreaCtor();  
    ASSERT(szLine[0] != '\0');
	int nSeparator = strcspn(szLine, "\0 ");
	m_strCurrentCategory = CString(szLine,nSeparator);

    // REVIEW: Remove string table.

	// Check category is not already in combobox.
	int nStartAt = m_categoryCB.GetCount() - 1;
	int index = m_categoryCB.FindStringExact( nStartAt, m_strCurrentCategory.GetBuffer(m_strCurrentCategory.GetLength()) );
	m_strCurrentCategory.ReleaseBuffer();

	if (index == CB_ERR)
		m_categoryCB.AddString(m_strCurrentCategory);	// Add to Combo box if is not already there
	
	index = FindArea();  
    m_areaArray[index]->m_strCategory = m_strCurrentCategory;   
    
	szLine = szLine + nSeparator;  // REVIEW: Is this needed?

    return (szLine);
}


LPCSTR CAPIPage::FillAreaStruct(LPCSTR szLine)
{
	//DefaultAreaCtor();  
    ASSERT(szLine[0] != '\0');
	int nSeparator = strcspn(szLine, "\0 ");
	m_strCurrentArea = CString(szLine,nSeparator);

    // REVIEW: Search to see if the area has already been entered
    CArea* pArea = new CArea;
	pArea->m_strCategory = m_strCurrentCategory;
    pArea->m_strName = m_strCurrentArea;   //REVIEW: Possible bug
    m_areaArray.Add(pArea);
    
    szLine = szLine + nSeparator;  // REVIEW: Is this needed?

    return (szLine);
	
}

LPCSTR CAPIPage::FillClassStruct(LPCSTR szLine)
{
    ASSERT(szLine[0] != '\0');
	int nSeparator = strcspn(szLine, "\0 ");
	m_strCurrentArea = CString(szLine,nSeparator);	// current class

    CArea* pArea = new CArea;
//	pArea->m_strCategory = m_strCurrentCategory;
    // REVIEW: Search to see if the area has already been entered

    pArea->m_strName = m_strCurrentArea;   
    m_areaArray.Add(pArea);
    
    szLine = szLine + nSeparator;  // REVIEW: Is this needed?

    return (szLine);
	
}

LPCSTR CAPIPage::FillBaseClassStruct(LPCSTR szLine)
{
    ASSERT(szLine[0] != '\0');
	int nSeparator = strcspn(szLine, "\0 ");
	CString strBaseClass = CString(szLine,nSeparator);
    

    // Search for current area (class) and add subarea to its list of subareas.
    int index = FindArea();  
    m_areaArray[index]->m_strBaseClass = strBaseClass;   
  
  	szLine = szLine + nSeparator;  // REVIEW: Is this needed?
    return (szLine);
}



LPCSTR CAPIPage::FillSubareaStruct(LPCSTR szLine)
{
	//DefaultAreaCtor();  
    ASSERT(szLine[0] != '\0');
	int nSeparator = strcspn(szLine, "\0 ");
	CString strSubarea = CString(szLine,nSeparator);
    m_strCurrentSubarea = strSubarea; 
    
    szLine = szLine + nSeparator;  

    // REVIEW: Search for current area and add subarea to its list of subareas.
    int index = FindArea();
    ASSERT(index != -1); // There should be a matching Area in the array
    /* BOOL b = m_arreaArray[index].FindSubarea(m_currentSubArea);  
    if (b) 
        return (szLine); // if subarea already in list don't add another one.  */

    m_areaArray[index]->m_strListSubarea.AddTail(strSubarea);   //REVIEW: Possible bug
    
    return (szLine);
	
 }

LPCSTR CAPIPage::FillAPIStruct(LPCSTR szLine)
{
    ASSERT(szLine[0] != '\0');

	CAPI* pAPI = new CAPI;
	
	if (m_bIsOldFormat)
	{
		pAPI->m_strArea = m_strCurrentArea;			// Old Format
		pAPI->m_strSubarea = m_strCurrentSubarea;
	}
	else
	{
		pAPI->m_strArea = "Unassigned";	// There are no matching Class Names for this API
	}

    int iToken = 0;
	int nSeparator;
	while( szLine[0] != '\0' )
	{
		nSeparator = strcspn(szLine, "(: \t");
		switch( iToken++ )
		{
			case 0:		// parameter 1 : return value
				pAPI->m_strReturnVal += CString(szLine, nSeparator);
				if ( (pAPI->m_strReturnVal == "static") || (pAPI->m_strReturnVal == "virtual") || (pAPI->m_strReturnVal == "const"))
				{
					pAPI->m_strReturnVal+=' ';  // add modifier + return value,ei. virtual int
					iToken = 0;					// the next word is the actual type
				}
				break;
			case 1:		// parameter 2 : class name
				if (szLine[nSeparator] != ':')		// See if the separator is a :: 
				{
					pAPI->m_strClass.Empty();	// No class name, it's not a member function
					if (!m_bIsOldFormat)
						pAPI->m_strArea = "Globals";
					pAPI->m_strName = CString(szLine, nSeparator);
					m_strCurrentAPI = pAPI->m_strName;
					iToken++;
				}
				else
				{
					pAPI->m_strClass = CString(szLine, nSeparator);
					if (!m_bIsOldFormat)
						pAPI->m_strArea = CString(szLine, nSeparator);
				}
				break;
			case 2:		// parameter 3 : API name
				pAPI->m_strName = CString(szLine, nSeparator);
				m_strCurrentAPI = pAPI->m_strName;
				break;
			case 3:		// parameter 4 : Parameters		
				szLine = FillParamStruct(szLine, pAPI);
				nSeparator = 0;  // szLine already points to ')'
				// REVIEW: Add code here to fill param struct if necessary
				break;
			case 4:		// parameter 5 : Description 
				nSeparator = strcspn(szLine, "\0");
				pAPI->m_strDesc = CString(szLine, nSeparator);
				break;
		}
		szLine = szLine + nSeparator + strspn(szLine + nSeparator, "(,:) \t;");   
	}
	
	ASSERT(iToken >= 3);   // Make sure API line is not incomplete;   

	m_apiArray.Add(pAPI);

    // REVIEW: Add class to class list if not already there.
    
    return (szLine);
}


LPCSTR CAPIPage::FillDescStruct(LPCSTR szLine)
{
	int nSeparator = strcspn(szLine, "\0");
	CString strDescription = CString(szLine,nSeparator);

	ASSERT(m_apiArray.GetSize() != 0);

	CAPI* pAPI = m_apiArray[m_apiArray.GetUpperBound()];	// Last api in array is the current one

	ASSERT(pAPI->m_strName == m_strCurrentAPI);				
	
	pAPI->m_strDesc = strDescription;

	szLine = szLine + nSeparator;  // REVIEW: Is this needed?
    return (szLine);
}


LPCSTR CAPIPage::FillReturnStruct(LPCSTR szLine)
{
	int nSeparator = strcspn(szLine, "\0");
	CString strReturnDesc = CString(szLine,nSeparator);

	ASSERT(m_apiArray.GetSize() != 0);

	CAPI* pAPI = m_apiArray[m_apiArray.GetUpperBound()];	// Last api in array is the current one

	ASSERT(pAPI->m_strName == m_strCurrentAPI);				
	
	pAPI->m_strReturnDesc = strReturnDesc;

	szLine = szLine + nSeparator;  // REVIEW: Is this needed?
    return (szLine);
}



LPCSTR CAPIPage::FillParamStruct(LPCSTR szLine, CAPI* pAPI)
{
    ASSERT(szLine[0] != '\0');
	
    int iParam = 0;
	int nSeparator = strcspn(szLine, ")");
	CString strParam = 	CString(szLine, nSeparator);
	if ( (strParam.Find("void") != -1) || ( strParam.Find("params") != -1 ))
		return szLine + nSeparator;			// takes no parameters	or uses PARAM to fill them in
	
	while( szLine[0] != ')' && szLine[0] != '\0')
	{
		CParam* pParam = new CParam;
		while ( (iParam % 3) < 2)		// Only do this loop 2 times
		{
			nSeparator = strcspn(szLine, ", \t/=)");
			switch( (iParam++) & (0x0001) )				  // REVIEW: We assume only 1 param type
			{
				case 0:		// parameter type
					pParam->m_strType = CString(szLine, nSeparator);
					break;
				case 1:		// parameter name
					pParam->m_strName = CString(szLine, nSeparator);
					break;
			}
			szLine = szLine + nSeparator + strspn(szLine + nSeparator, ", \t");	 // advance to next '=' or param type
			if (szLine[0] == '*')		// Is pointer type
			{
				pParam->m_strType += '*';
				szLine += strspn(szLine, " \t"); // advance to param name
			}
			if (szLine[0] == '=')			// old default value format
			{
				szLine += strspn(szLine, "= \t");  // advance to beginning of  default value
				nSeparator = strcspn(szLine, ", \t)");
				pParam->m_strValue = CString(szLine, nSeparator);
				szLine = szLine + nSeparator + strspn(szLine + nSeparator, ", \t");	 // advance to next param type
			}  

			if (szLine[0] == '/')			//  default value 
			{
				szLine += strspn(szLine, "=*/ \t");  // advance to beginning of  default value
				nSeparator = strcspn(szLine, ", \t*)");
				pParam->m_strValue = CString(szLine, nSeparator);
				szLine = szLine + nSeparator + strspn(szLine + nSeparator, "*/, \t");	 // advance to next param type
			}  
			
		 }
		 if (pAPI == NULL)		// Old format: From PARAM line, API is already in array
		 {
		 	ASSERT(m_apiArray.GetSize() != 0);
			m_apiArray[m_apiArray.GetUpperBound()]->m_paramList.AddTail(pParam); 
		 }
		 else
		 	pAPI->m_paramList.AddTail(pParam);		   // 	API object is created on the fly

		iParam = 0;									// Reset so more parameters can be read.
	}
	
    return (szLine);
	
 }

LPCSTR CAPIPage::FillParamDescStruct(LPCSTR szLine)
{
	ASSERT(m_apiArray.GetSize() != 0);

	CAPI* pAPI = m_apiArray[m_apiArray.GetUpperBound()];	// Last api in array is the current one

	ASSERT(pAPI->m_strName == m_strCurrentAPI);				
	

	int nSeparator = strcspn(szLine, "\0");
	CString strDesc = CString (szLine, nSeparator);

	szLine = szLine + nSeparator;  // REVIEW: Is this needed?

	CString strParamDesc;

	POSITION pos = pAPI->m_paramList.GetHeadPosition(); 
	
	while (pos != NULL)
	{
		strParamDesc = pAPI->m_paramList.GetAt(pos)->m_strName;
		if ( strDesc.Find(strParamDesc.GetBuffer(strParamDesc.GetLength() ) ) != -1 )	// Search for parameter name
		{
			pAPI->m_paramList.GetAt(pos)->m_strDesc = strDesc;		// Parameter found, assign description
			return szLine;
		}
		strParamDesc.ReleaseBuffer();
		pAPI->m_paramList.GetNext(pos);
	}
	
	ASSERT(TRUE);

	return szLine;
}


int CAPIPage::FindArea(LPCSTR szArea)
{
    CString strArea;
    if (szArea == NULL)
        strArea = m_strCurrentArea;
    else
        strArea = szArea;

    int nAreas = m_areaArray.GetUpperBound();
    for (int i=0; i <= nAreas; i++)
    {
        if (m_areaArray[i]->m_strName == strArea)
			return i;
    }

    return -1;  // Area not found
}

BOOL CAPIPage::IsArea(int index)
{
	CBitmap * curpbmap ;
	curpbmap = CBitmap::FromHandle((HBITMAP)m_areaList.GetItemData(index)) ;
	if (curpbmap->GetSafeHandle() != bmapTriangle.GetSafeHandle() )
		return TRUE;
	else
		return FALSE;
}

void CAPIPage::ExpandArea(int index, BOOL bExpand)
{
	if (bExpand)
	{
		m_areaList.SetItemData(index,(DWORD)bmapCheck.GetSafeHandle());
		DisplaySubareas(index);
	}
	else
	{
		m_areaList.SetItemData(index,(DWORD)bmapUnCheck.GetSafeHandle());
		HideSubareas(index);
	}
}

void CAPIPage::DisplaySubareas( int index, int i )
{
	CString	strText;
	m_areaList.GetText(index, strText);
	if (i == -1)
		i = FindArea(strText); 
	ASSERT( i != -1 );
	CString strNew;
	POSITION pos = m_areaArray[i]->m_strListSubarea.GetHeadPosition();
	while (pos != NULL )
	{
		strNew =  m_areaArray[i]->m_strListSubarea.GetNext(pos);
		index++;
		index = m_areaList.InsertString(index, strNew );
	 	m_areaList.SetItemData(index, (DWORD)bmapTriangle.GetSafeHandle()) ;	
	}
}

void CAPIPage::HideSubareas( int index, int i )
{
	CString	strText;
	m_areaList.GetText(index, strText);
	if (i == -1)
		i = FindArea(strText);
	POSITION pos = m_areaArray[i]->m_strListSubarea.GetHeadPosition();
	index++;
	while (pos != NULL)
	{
		m_areaList.DeleteString(index);
		m_areaArray[i]->m_strListSubarea.GetNext(pos);
	}
}

void CAPIPage::DisplayAreaAPIs( int index )
{
	CString	strArea;
	CString strNew;
	CString strClass;
	m_areaList.GetText(index, strArea);
	int nLast = m_apiArray.GetUpperBound();

	m_apiList.ResetContent();
	for (int i=0; i <= nLast; i++)
	{
		if (m_apiArray[i]->m_strArea == strArea)
		{
			strNew.Empty();		// Reset string
			strClass = 	m_apiArray[i]->m_strClass;
			if (!m_apiArray[i]->m_strClass.IsEmpty()) // Add "::" if it has a class
				strClass += "::";
			// Verify display flags
			if ( m_iDisplayReturnType )
			{
				strNew = m_apiArray[i]->m_strReturnVal+ ' ';
			}
			if ( m_iDisplayClassNames )
			{
				strNew += " " + strClass;
			}
			
			strNew += m_apiArray[i]->m_strName;

			if (m_iDisplayParams)
			{
				
				strNew += '(';
				POSITION pos = m_apiArray[i]->m_paramList.GetHeadPosition();
				int nParam = 0;
				while (pos != NULL )
				{  	
					CParam* pParam =  m_apiArray[i]->m_paramList.GetNext(pos);
					if(nParam++ == 0)
						strNew += ' ' + pParam->m_strName;
					else
						strNew += ", " + pParam->m_strName;
				}
				strNew += " )";
			}
			else
			{
				strNew += "()"; // 
			}

			index = m_apiList.AddString( strNew );	
			m_apiList.SetItemData( index, (DWORD)i );
		}
	}
}
			
void CAPIPage::DisplaySubareaAPIs( int index )
{
	CString	strArea;
	CString strSubarea;
	CString strNew;
	m_areaList.GetText(index, strSubarea);
	strArea = GetAreaName(index);
	int nLast = m_apiArray.GetUpperBound();

	m_apiList.ResetContent();
	for (int i=0; i <= nLast; i++)
	{
		if ( (m_apiArray[i]->m_strArea == strArea) && (m_apiArray[i]->m_strSubarea == strSubarea))
		{
			strNew = m_apiArray[i]->m_strReturnVal + " " + m_apiArray[i]->m_strClass + "::" + m_apiArray[i]->m_strName + "()";
			index = m_apiList.AddString( strNew );
			m_apiList.SetItemData( index, (DWORD)i );
		}
	}
}
			
CString CAPIPage::GetAreaName( int index )
{
	CString	strArea;
	while ( !IsArea(index) )
		index--;	  // Go up the list to find the Area
	ASSERT (index >= 0);
	m_areaList.GetText(index, strArea);
	
	return strArea;
}

void CAPIPage::DisplayParameters( int index, BOOL bAddedToScript )
{
	m_parameterList.ResetContent();

	int i = index;

	if (!bAddedToScript)
		i = m_apiList.GetItemData(index);  // If Selected API is in API List
		
	POSITION pos = m_apiArray[i]->m_paramList.GetHeadPosition();
	
	while (pos != NULL )
	{  	
		CParam* pParam =  m_apiArray[i]->m_paramList.GetNext(pos);
		CString strParam = pParam->m_strType + "\t" + pParam->m_strName + "\t" + pParam->m_strValue;
		int index = m_parameterList.AddString( strParam );
		m_parameterList.SetItemDataPtr(index, pParam);
	}
}

void CAPIPage::DisplayAPIDescription( int index )
{
	
	int i = m_apiList.GetItemData(index);
	CString strDesc = m_apiArray[i]->m_strDesc;
	strDesc += "\n\n Return Type Info: " + m_apiArray[i]->m_strReturnDesc;
	m_apiDescription.SetWindowText( strDesc );
}

void CAPIPage::DisplayParamDescription( int index )
{
	
	CParam* pParam = (CParam*)m_parameterList.GetItemDataPtr(index);
	CString strDesc = pParam->m_strDesc;
	m_apiDescription.SetWindowText( strDesc );
}



CString CAPIPage::CreateVarFromClassName(CString& strClassName)
{
	int nLength = strClassName.GetLength();
	ASSERT (nLength > 0);					//REVIEW: Handle this error condition gracefully

	int  i = 0;
	int  nLastUpper = i;
	while ( isupper(strClassName[i]) )
	{
		nLastUpper = i++;
		if (i >= nLength)
			break;	
	}

	CString strVar;
	if ( (nLength - nLastUpper) < 5 )
		strVar = strClassName.Mid(nLastUpper);
	else
		strVar = strClassName.Mid(nLastUpper, 5);
	
	strVar.MakeLower();

	return strVar;
}	

/////////////////////////////////////////////////////////////////////////////
// CAPIPage message handlers


void CAPIPage::OnSelchangeCategory() 
{
    CString strCurrentText;
	int index = m_categoryCB.GetCurSel() ;
	if (LB_ERR ==index || 0 > index) // If an error or no items in the listbo.
		return ;  
	m_categoryCB.GetLBText( index , strCurrentText );
    m_category = strCurrentText;
	DisplayAreas();
	OnSelchangeListAreas();
}


BOOL CAPIPage::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();

   	CString path("0",250) ;
	GetModuleFileName(NULL,path.GetBuffer(250),250) ;
	path = path.Left(path.ReverseFind('\\') + 1) ;
	path =path +"appwiz\\apidata.txt" ;

	m_bIsOldFormat = FALSE;


    if (m_apiArray.GetSize() == 0)
        OpenAPIData(path.GetBuffer(250));

	CClientDC ccldc(this) ;         
 	// Add Custom listbox
	// subclass the control	 

	VERIFY(m_areaList.SubclassDlgItem(IDC_LIST_AREAS, this));

	// Set column sizes for Parameter Listbox
	CRect rect;
	m_parameterList.GetClientRect(rect);
	LPRECT pRectParam = rect;
	int nTabStop = (pRectParam->right - pRectParam->left) / 5;
	m_parameterList.SetTabStops( nTabStop  );
	// Display Api's
	
	m_categoryCB.SetCurSel(0);	// Select first category
	OnSelchangeCategory();	
	DisplayAreas();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CAPIPage::OnDblclkListAreas() 
{
	int index =  m_areaList.GetCurSel() ;
	if (LB_ERR ==index || 0 > index) // If an error or no items in the listbox.
		return ;  
	if ( IsArea(index) )
	{
		//Expand or collapse Area 
		CBitmap * curpbmap ;
		curpbmap = CBitmap::FromHandle((HBITMAP)m_areaList.GetItemData(index)) ;
		if (curpbmap->GetSafeHandle() == bmapCheck.GetSafeHandle()) // if currently checked
			ExpandArea(index, FALSE);
		else 
			ExpandArea(index);

		m_areaList.SetCurSel(index) ;
	}
}


void CAPIPage::OnSelchangeListAreas() 
{
    CString strCurrentText;
    int index = m_areaList.GetCurSel();
	if (LB_ERR ==index || 0 > index) // If an error or no items in the listbox.
		return ;  

	if ( IsArea(index) )
		DisplayAreaAPIs(index);
	else
		DisplaySubareaAPIs(index);
}

void CAPIPage::OnSelchangeListApi() 
{
    int index = m_apiList.GetCurSel();
	if (LB_ERR ==index || 0 > index) // If an error or no items in the listbo.
		return ;  

	DisplayParameters( index );
	DisplayAPIDescription( index );
}

void CAPIPage::OnDblclkListApi()	// Write API Call to Edit box
{
	int index = m_apiList.GetCurSel();
	if (LB_ERR ==index || 0 > index) // If an error or no items in the listbox.
		return ;  
	int i = m_apiList.GetItemData(index);

	CString strAPICall = m_apiArray[i]->m_strName + '(';
	
	POSITION pos = m_apiArray[i]->m_paramList.GetHeadPosition();
	int nParam = 0;
	while (pos != NULL )
	{  	
		CParam* pParam =  m_apiArray[i]->m_paramList.GetNext(pos);
		if(pParam->m_strValue.IsEmpty())
		{
			if(nParam == 0)
				strAPICall += pParam->m_strName;
			else
				strAPICall += ", " + pParam->m_strName;
		}
		else
		{
			if(nParam == 0)
				strAPICall += pParam->m_strValue;
			else
				strAPICall += ", " + pParam->m_strValue;
		}
		nParam++;
	}
	strAPICall += ");";

	m_ApiCallCtrl.SetWindowText(strAPICall.GetBuffer( strAPICall.GetLength() ));
	strAPICall.ReleaseBuffer();		
}



void CAPIPage::OnOK()
{

}


void CAPIPage::OnSetfocusListApi() 
{
	// Enable Add button only when this listbox has focus
	
}

void CAPIPage::OnKillfocusListApi() 
{
	
}


void CAPIPage::OnSelchangeListParameters() 
{
	int index = m_parameterList.GetCurSel();
	if (LB_ERR ==index || 0 > index) // If an error or no items in the listbo.
		return ;  

	DisplayParamDescription( index );
}


void CAPIPage::OnDisplayClassnames() 
{
	m_iDisplayClassNames = !m_iDisplayClassNames;
	OnSelchangeListAreas();
}

void CAPIPage::OnDisplayReturnType() 
{
	m_iDisplayReturnType = !m_iDisplayReturnType;
	OnSelchangeListAreas();
}

void CAPIPage::OnDisplayParams() 
{
	m_iDisplayParams = !m_iDisplayParams;
	OnSelchangeListAreas();
}

void CAPIPage::OnAddApi() 
{
	int index = m_apiList.GetCurSel();
	if (LB_ERR ==index || 0 > index) // If an error or no items in the listbox.
		return ;  
	int i = m_apiList.GetItemData(index);

	CString strAPICall = m_apiArray[i]->m_strName + '(';
	
	POSITION pos = m_apiArray[i]->m_paramList.GetHeadPosition();
	int nParam = 0;
	while (pos != NULL )
	{  	
		CParam* pParam =  m_apiArray[i]->m_paramList.GetNext(pos);
		if(pParam->m_strValue.IsEmpty())
		{
			if(nParam == 0)
				strAPICall += pParam->m_strName;
			else
				strAPICall += ", " + pParam->m_strName;
		}
		else
		{
			if(nParam == 0)
				strAPICall += pParam->m_strValue;
			else
				strAPICall += ", " + pParam->m_strValue;
		}
		nParam++;
	}
	strAPICall += ");";

	m_ApiCallCtrl.SetWindowText(strAPICall.GetBuffer( strAPICall.GetLength() ));
	strAPICall.ReleaseBuffer();		
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\wrk\uiwrkspc.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UIWRKSPC.CPP
//
//  Created by :            Date :
//      JimGries            4/25/95         
//
//  Description :
//      Implementation for the UIWorkspaceWindow
//

#include "stdafx.h"
#include "uiwrkspc.h"
#include "..\..\testutil.h"
#include "..\shl\uwbframe.h"
#include "..\shl\upropwnd.h"
#include "..\shl\wbutil.h"
#include "..\sym\cmdids.h"
#include "guiv1.h"
#include "guitarg.h"
#include "mstwrap.h"
#include "..\..\umsgbox.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: UIWorkspaceWindow::UIWorkspaceWindow(void)
// Description: Constructor for Workspace window object.
// END_HELP_COMMENT
UIWorkspaceWindow::UIWorkspaceWindow()
{
    Activate();
    Attach(FindFirstChild(UIWB.HWnd(), IDDW_PROJECT));
}


// BEGIN_HELP_COMMENT
// Function: UIWorkspaceWindow::GetID(void) const
// Return: The ID of the UIWorkspaceWindow.
// END_HELP_COMMENT
UINT UIWorkspaceWindow::GetID(void) const
{
	return IDDW_PROJECT;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIWorkspaceWindow::Activate(void)
// Description: Activates the Workspace window.
// Return: TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWorkspaceWindow::Activate(void)
{
    return UIWB.DoCommand(IDM_VIEW_WORKSPACE, DC_MNEMONIC);
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIWorkspaceWindow::ActivateBuildPane()
// Description: Activates the Build pane in the workspace window.
// Return: TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWorkspaceWindow::ActivateBuildPane()
{
    return ActivatePane(GetLocString(IDSS_WRKSPC_BUILD_PANE));
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIWorkspaceWindow::ActivateDataPane()
// Description: Activates the Data pane in the workspace window.
// Return: TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWorkspaceWindow::ActivateDataPane()
{
    return ActivatePane(GetLocString(IDSS_WRKSPC_DATA_PANE));
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIWorkspaceWindow::ActivateHelpPane()
// Description: Activates the Help pane in the workspace window.
// Return: TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWorkspaceWindow::ActivateHelpPane()
{
    return ActivatePane(GetLocString(IDSS_WRKSPC_HELP_PANE));
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIWorkspaceWindow::ActivateClassPane()
// Description: Activates the Class browser pane in the workspace window.
// Return: TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWorkspaceWindow::ActivateClassPane()
{
    return ActivatePane(GetLocString(IDSS_WRKSPC_CLASS_PANE));
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIWorkspaceWindow::ActivateResourcePane()
// Description: Activates the Resource pane in the workspace window.
// Return: TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWorkspaceWindow::ActivateResourcePane()
{
    return ActivatePane(GetLocString(IDSS_WRKSPC_RESOURCE_PANE));
}

// BEGIN_HELP_COMMENT
// Function: int UIWorkspaceWindow::SelectProject(LPCSTR pszProjectName)
// Description: Selects the given project in the workspace window.  It assumes that the ClassView or FileView is currently the active view.
// Parameter: pszProjectName Name of project to select.
// Return: SUCCESS if successful, or ERROR_ERROR if some other problem occurred.
// END_HELP_COMMENT
int UIWorkspaceWindow::SelectProject(LPCSTR pszProjectName)
{
	ASSERT(pszProjectName);

	// Contract all children.
	MST.DoKeyshWnd(HWnd(),"{Home}{Left}");

	// Type the name of the item to find.
	MST.DoKeyshWnd(HWnd(),pszProjectName, TRUE);

	// Popup the property page for the currently active item.
	MST.DoKeyshWnd(HWnd(),"%({Enter})");

	int ret = SUCCESS;
//REVIEW(chriskoz) use the true UIProperty class here
	HWND hprop=MST.WGetActWnd(0);
	CStatic wndStatic;
	if (wndStatic.Attach(FindFirstChild(hprop, IDC_TARGNAME)) == 0)
		ret = ERROR_NO_PROJECT;
	else
	{
		CString strFoundName;
		wndStatic.GetWindowText(strFoundName);

		if (strnicmp(strFoundName, pszProjectName, strlen(pszProjectName)))
			 ret = ERROR_NO_PROJECT; 

		wndStatic.Detach();
	}

	// Dismiss the properties dialog.	
	MST.DoKeyshWnd(hprop,"{Escape}");

	return ret;
}
// BEGIN_HELP_COMMENT
// Function: int UIWorkspaceWindow::SelectClass(LPCSTR pszClassName, LPCSTR pszProjectName = NULL)
// Description: Selects the given class in the workspace window.  It assumes that the ClassView is currently the active view.  It currently does not support nested classes.  This function leaves the class view in a state suitable for use by SelectClassMember.
// Parameter: pszClassName Name of class to find in the workspace window.
// Parameter: pszProjectName Name of project in which the class resides.  If NULL it assumes the current project.
// Return: SUCCESS if successful; ERROR_NO_CLASS if class wasn't found, or ERROR_ERROR if some other problem occurred.
// END_HELP_COMMENT
int UIWorkspaceWindow::SelectClass(LPCSTR pszClassName, LPCSTR pszProjectName /* = NULL */)
{
	ASSERT(pszClassName);

	int ret = SUCCESS;

	if (pszProjectName)
		ret = SelectProject(pszProjectName);

	if (ret == SUCCESS)
	{
		// We have to wait here until the ClassView is able to display the class
		// information.  WaitForInputIdle() does not work here.  This loop assumes
		// that there will be some selectable node underneath the project node at
		// all times!
		BOOL bReady = FALSE;
		int nSec = 30;
		while (!bReady && ret == SUCCESS)
		{
			// Attempt to open the property page for the first class or the Globals node.
	Sleep(2000); //Wait for ClassView to expand (WaitForInputIdle doesn't work
			MST.DoKeyshWnd(HWnd(),"{Left}{Left}{Right}{Right}");
			
			MST.DoKeyshWnd(HWnd(),"%({Enter})");

//REVIEW(chriskoz) use the true UIProperty class here
			CString str;
			HWND hprop=MST.WGetActWnd(0);
			MST.WGetText(hprop, str);
			MST.DoKeyshWnd(hprop,"{Escape}");

			if (str.Find(GetLocString(IDSS_WRKSPC_CLASS_PROP_PAGE)) != -1 || 
				str.Find(GetLocString(IDSS_WRKSPC_GLOBALS_PROP_PAGE)) != -1 ||
				str.Find(GetLocString(IDSS_WRKSPC_INTERFACE_PROP_PAGE)) != -1)
			{
				bReady = TRUE;
				MST.DoKeyshWnd(HWnd(),"{Left}");	// Go back to project node.
			}
			else
			{
				if (--nSec != 0)	// If we still have some waiting time...
				{
					LOG->RecordInfo("Waiting up to %d more second(s) for project node to display classes...", nSec);
					Sleep(1000);
				}
				else				// We've timed out.
				{
					LOG->RecordFailure("Timeout waiting for project node to open.");
					ret = ERROR_ERROR;
				}
			}
		}

		if (ret == SUCCESS)	// If classes are now expanded in the ClassView...
		{
			// Expand the immediate children of this project, wait up to 30 seconds for response.
			MST.DoKeyshWnd(HWnd(),"{Left}{Right}", FALSE, 30000);

			// Type the name of the item to find.
			MST.DoKeyshWnd(HWnd(),pszClassName, TRUE, 10000);

			// Popup the property page for the currently active item.
			MST.DoKeyshWnd(HWnd(),"%({Enter})");
//REVIEW(chriskoz) use thetur IUProperty here
			HWND hprop=MST.WGetActWnd(0);
			CStatic wndStatic;
			if (wndStatic.Attach(FindFirstChild(hprop, IDC_CLASSNAME)) == 0)
				ret = ERROR_NO_CLASS;
			else
			{
				CString strFoundName;
				wndStatic.GetWindowText(strFoundName);

				if (strncmp(strFoundName, pszClassName, strlen(pszClassName)))
					 ret = ERROR_NO_CLASS; 

				wndStatic.Detach();
			}

			// Dismiss the properties dialog.	
			MST.DoKeyshWnd(hprop,"{Escape}");
		}
	}

	WaitForInputIdle(g_hTargetProc, 10000);

	return ret;
}

// BEGIN_HELP_COMMENT
// Function: int UIWorkspaceWindow::SelectGlobal(LPCSTR pszGlobalName, LPCSTR pszProjectName = NULL)
// Description: Selects the given global symbol in the workspace window.  It assumes that the ClassView is currently the active view.  
// Parameter: pszGlobalName Name of global symbol to find in the workspace window.
// Parameter: type Is this a function or data global?
// Parameter: pszProjectName Name of project in which the global resides.  If NULL it assumes the current project.
// Return: SUCCESS if successful; ERROR_NO_GLOBAL if class wasn't found, or ERROR_ERROR if some other problem occurred.
// END_HELP_COMMENT
int UIWorkspaceWindow::SelectGlobal(LPCSTR pszGlobalName, GLOBAL_TYPE type, LPCSTR pszProjectName /* = NULL */)
{
	ASSERT(pszGlobalName);
	CString strGlobalName(pszGlobalName);

	int ret = SUCCESS;

	if (pszProjectName)
		ret = SelectProject(pszProjectName);

	if (ret == SUCCESS)
	{
		// Expand the globals node of this project.  We may have to search for it since, a project could define a "Globals" class.
		MST.DoKeys("{Left}{Right}", FALSE, 30000);

		int nCountDown = 3;
		BOOL bFound = FALSE;
		while(bFound == FALSE && ret == SUCCESS)
		{
			MST.DoKeys(GetLocString(IDSS_WRKSPC_GLOBALS_ITEM_NAME));

			// Popup the property page for this globals node.
			MST.DoKeys("%({Enter})");

			if (MST.WStaticExists(GetLocString(IDSS_WRKSPC_NO_PROPERTIES)))
				bFound = TRUE;
			else
			{
				if (--nCountDown != 0)
				{
					Sleep(1000);	// Give time for property dialog to go away, if not found yet.
					LOG->RecordInfo("Trying up to %d more times to find the Globals node", nCountDown);
				}
				else
				{
					LOG->RecordFailure("Timeout trying to find globals node.");
					ret = ERROR_ERROR;
				}
			}

			// Dismiss the properties dialog.	
			MST.DoKeys("{Escape}");
		}
	}

	if (ret == SUCCESS)
	{
		// We must've found it by now, so expand it.
		MST.DoKeys("{Right}");

		// Type the name of the item to find.
		MST.DoKeys(pszGlobalName, TRUE);

		// Popup the property page for the currently active item.
		MST.DoKeys("%({Enter})");
		
		CStatic wndStatic;
		for (int i = 0; i < 5; i++)
		{
			if  (wndStatic.Attach(FindFirstChild(MST.WGetActWnd(0), type == Function? IDC_FUNCTNAME : IDC_DATANAME)))
				break;
			Sleep(200);
		}

		if (wndStatic.m_hWnd == NULL)
			ret = ERROR_ERROR;
		else
		{			
			CString strFoundName;
			wndStatic.GetWindowText(strFoundName);

			RemoveCharFromString(&strFoundName, ' ');
			RemoveCharFromString(&strGlobalName, ' ');

//			if (strGlobalName.Find(strFoundName) == -1)
			if (strFoundName.Find(strGlobalName) == -1)
				 ret = ERROR_NO_GLOBAL; 

			wndStatic.Detach();
		}

		// Dismiss the properties dialog.	
		MST.DoKeys("{Escape}");
	}

	WaitForInputIdle(g_hTargetProc, 10000);

	return ret;
}
// BEGIN_HELP_COMMENT
// Function: int UIWorkspaceWindow::SelectClassMember(LPCSTR pszMemberName, LPCSTR pszClassName = NULL, LPCSTR pszProjectName = NULL)
// Description: Selects the given item in the workspace window.  It assumes that the ClassView is currently the active view and that the class whose member your looking for is currently selected and not expanded.  If another class is currently expanded you could get an erroneous success if the member your trying to select is in the other class as well.
// Parameter: pszMemberName Name of class member to find in the workspace window.
// Parameter: type Is this a function or data member?
// Parameter: pszClassName Name of class in which to find this member.  If NULL, the function assumes the desired class is currently selected and unexpanded.
// Parameter: pszProjectName Name of project in which the class resides.  This parameter must be supplied if pszClassName is not NULL.
// Return: SUCCESS if successful.  ERROR_NO_MEMBER if member wasn't found. Or the return code from SelectClass() or SelectProject().
// END_HELP_COMMENT
int UIWorkspaceWindow::SelectClassMember(LPCSTR pszMemberName, MEMBER_TYPE type, LPCSTR pszClassName /*= NULL */, LPCSTR pszProjectName /* = NULL */)
{
	ASSERT(pszMemberName);
	CString strMemberName(pszMemberName);

	// Make sure that either both the classname and project name is specified or neither is.
	ASSERT(!((!!pszClassName) ^ (!!pszProjectName)));

	int ret = SUCCESS;

	if (pszClassName != NULL)
		ret = SelectClass(pszClassName, pszProjectName);

	if (ret == SUCCESS)
	{
		// Expand the children of the class.
		MST.DoKeys("{Right}");

		// Type the name of the item to find.
		MST.DoKeys(pszMemberName, TRUE);

		// Popup the property page for the currently active item.
		MST.DoKeys("%({Enter})");

		CStatic wndStatic;
		for (int i = 0; i < 5; i++)
		{
			if  (wndStatic.Attach(FindFirstChild(MST.WGetActWnd(0), type == Function? IDC_FUNCTNAME : IDC_DATANAME)))
				break;
			Sleep(200);
		}

		if (wndStatic.m_hWnd == NULL)
			ret = ERROR_ERROR;
		else
		{
			CString strFoundName;
			wndStatic.GetWindowText(strFoundName);

			RemoveCharFromString(&strFoundName, ' ');
			RemoveCharFromString(&strMemberName, ' ');

			if (strMemberName.Find(strFoundName) == -1)
				 ret = ERROR_NO_MEMBER; 

			wndStatic.Detach();
		}

		// Dismiss the properties dialog.	
		MST.DoKeys("{Escape}");
	}

	WaitForInputIdle(g_hTargetProc, 10000);

	return ret;
}

// BEGIN_HELP_COMMENT
// Function: int UIWorkspaceWindow::SelectResource(LPCSTR pszResourceType, LPCSTR pszResourceName)
// Description: Selects the given item in the workspace window.  It sets ResourceView as currently the active view.
// Parameter: pszResourceType Type of resource.  Dialog, Accelerator, etc.  This parameter is a string in order to support user defined resources.
// Parameter: pszResourceName Name of class member to find in the workspace window.
// Parameter: pszResourceFile Name of resource file to search.
// Return: SUCCESS if successful.  ERROR_NO_RESFILE, ERROR_NO_RESOURCE.
// END_HELP_COMMENT
int UIWorkspaceWindow::SelectResource(LPCSTR pszResourceType, LPCSTR pszResourceName, LPCSTR pszResourceFile /* = NULL */)
{
	ASSERT(pszResourceType && pszResourceName);
	
	if(ActivateResourcePane()==FALSE)
		return ERROR_NO_RESOURCE;

	int ret = SUCCESS;
	Sleep(1000); //XTRA SAFETY
	// Close all of the resources of the topmost folder.
	MST.DoKeys("{Home}{Left}{Right}", FALSE);
	Sleep(2000); //XTRA SAFETY
	WaitForInputIdle(g_hTargetProc, 10000); //wait for idle if resources are expanding

	MST.DoKeys(pszResourceType, TRUE);	// Type the name of the resource type to search.
	Sleep(2000); //XTRA SAFETY
	MST.DoKeys("{NUMPAD+}");			// Expand the resources for the given type.
	Sleep(2000); //XTRA SAFETY
	MST.DoKeys(pszResourceName, TRUE);	// Type the name of the resource.
	Sleep(2000); //extra safety
	// Popup the property page for the currently active item.
	UIControlProp prop = UIWB.ShowPropPage(TRUE);
	BOOL bvalid=prop.IsValid();

	if(prop.GetID()!=pszResourceName)
		ret = ERROR_NO_RESOURCE;	

	// Dismiss the properties dialog.	
	MST.DoKeys("{Escape}");

	return ret;
}


// BEGIN_HELP_COMMENT
// Function: int UIWorkspaceWindow::SelectResource(LPCSTR pszResourceType, LPCSTR pszResourceName)
// Description: Selects the given item in the workspace window.  It sets ResourceView as currently the active view.
// Parameter: pszResourceType Type of resource.  Dialog, Accelerator, etc.  This parameter is a string in order to support user defined resources.
// Parameter: pszResourceName Name of resource to find in the workspace window.
// Parameter: pszResourceFile Name of resource file to search.
// Return: SUCCESS if successful.  ERROR_NO_RESFILE, ERROR_NO_RESOURCE, ERROR_ERROR if it fails to open the property page.
// END_HELP_COMMENT
int UIWorkspaceWindow::SelectResource2(LPCSTR pszResourceType, LPCSTR pszResourceName, LPCSTR pszResourceFile /* = NULL */)
{
	ASSERT(pszResourceType && pszResourceName);
	
	if(ActivateResourcePane()==FALSE)
		return ERROR_NO_RESOURCE;

	int ret = SUCCESS;

	// Loop through all resources of given type until it finds or fails

	CString szType = (CString)pszResourceType;
	UIControlProp prop;
	BOOL bReady = FALSE;
	int nodeNumber = 0;

	while( !bReady )
	{
		// Close all of the resources of the topmost folder.
		MST.DoKeys("{Home}{Left}{Right}", FALSE, 10000); //wait for idle if resources are expanding

		MST.DoKeys(pszResourceType, TRUE);	// Type the name of the resource type to search.
		MST.DoKeys("{Right}");			// Expand the resources for the given type.
		nodeNumber++;
		for( int j = 0; j < nodeNumber; j++ )
		{
			MST.DoKeys("{Down}", FALSE, 500);
		}

		// Popup the property page for the currently active item.
		prop = UIWB.ShowPropPage(TRUE);
		if(!prop.IsValid())
		{
			LOG->RecordInfo("The Property Page is not valid");
		}
		MST.WGetText(NULL, szType);
		if (szType.Find(pszResourceType) != -1)
		{
		 	if(prop.GetID() == pszResourceName)
				bReady = TRUE;
		}
		else
		{
			ret = ERROR_NO_RESOURCE;
			bReady = TRUE;
		}
		// Dismiss the properties dialog.	
		MST.DoKeys("{Escape}");
	}	

	return ret;
}


// BEGIN_HELP_COMMENT
// Function: int UIWorkspaceWindow::SelectFile(LPCSTR pszFilename, LPCSTR pszProjectName = NULL)
// Description: Selects the given file workspace window's FileView.  It assumes that the FileView is currently the active view.
// Parameter: pszFilename Name of file to select in the workspace window.
// Parameter: pszProjectName Name of project in which the class resides.  If NULL it assumes the current project.
// Return: SUCCESS if successful, ERROR_NO_FILE if file wasn't found, or the return code from SelectProject().
// END_HELP_COMMENT
int UIWorkspaceWindow::SelectFile(LPCSTR pszFilename, LPCSTR pszProjectName /* = NULL */)
{
	ASSERT(FALSE);	// NOT FULLY IMPLEMENTED YET!
	ASSERT(pszFilename);

	int ret = SUCCESS;

	if (pszProjectName)
		ret = SelectProject(pszProjectName);
		
	if (ret == SUCCESS)
	{
		// Fully expand the children of the selected project folder.
		MST.DoKeys("*", TRUE);

		// Type the name of the item to find.
		MST.DoKeys(pszFilename, TRUE);

		// Popup the property page for the currently active item.
		MST.DoKeys("%({Enter})");
		
		// Assume property dialog is up.  Check for any static control on that window that
		// contains the validation string.  

		ret = ERROR_NO_FILE;// control ID of static control containing filename is VPROJ_IDC_FILE_NAME	

		// Dismiss the properties dialog.	
		MST.DoKeys("{Escape}");
	}
	return ret;
}

// BEGIN_HELP_COMMENT
// Function: void UIWorkspaceWindow::RemoveCharFromString(CString *pStr, char c)
// Description: Removes all instances of the char specified from the string given
// Parameter: pStr - The string to remove the character from.
// Parameter: c - The character to remove
// END_HELP_COMMENT
void UIWorkspaceWindow::RemoveCharFromString(CString *pStr, char c)
{
	char* pBuf = new char[pStr->GetLength()+1];

	int i, j;
	for (i = j = 0; i < pStr->GetLength(); i++)
		if (pStr->GetAt(i) != c)
			pBuf[j++] = pStr->GetAt(i);

	pBuf[j] = '\0';

	*pStr = pBuf;

	delete [] pBuf;
}

// BEGIN_HELP_COMMENT
// Function: int UIWorkspaceWindow::GotoClassDefinition(LPCSTR pszClassName, COSource* pSrcFile = NULL, LPCSTR pszProjectName = NULL)
// Description: Navigates to definition of the given class in the workspace window.  It assumes that the ClassView is currently the active view.  It currently does not support nested classes.
// Parameter: pszClassName Name of class to find in the workspace window.
// Parameter: pSrcFile - Input: Ptr to an allocated COSource object.  Output: Object is attached to source file that was activated by the Goto.  If NULL the parameter is ignored.
// Parameter: pszProjectName Name of project in which the class resides.  If NULL it assumes the current project.
// Return: SUCCESS if successful;  ERROR_NO_DEFINITION if declaration couldn't be found, or whatever GotoDefinitionFromHere(), or SelectClass() returns.
// END_HELP_COMMENT
int UIWorkspaceWindow::GotoClassDefinition(LPCSTR pszClassName, COSource* pSrcFile/* = NULL*/, LPCSTR pszProjectName /*= NULL*/)
{
	int ret;

	ret = SelectClass(pszClassName, pszProjectName);

	if (ret == SUCCESS)
		ret = GotoDefinitionFromHere(pszClassName);

	if (ret == SUCCESS)
	{
		if (pSrcFile != NULL)
			pSrcFile->AttachActiveEditor();
	}

	return ret;
}

// BEGIN_HELP_COMMENT
// Function: int UIWorkspaceWindow::GotoGlobalDefinition(LPCSTR pszGlobalName, COSource* pSrcFile = NULL, LPCSTR pszProjectName = NULL)
// Description: Navigates to the definition of the given global symbol in the workspace window.  It assumes that the ClassView is currently the active view.  
// Parameter: pszGlobalName Name of global symbol to find in the workspace window.
// Parameter: type Is this a function or data global?
// Parameter: pSrcFile - Input: Ptr to an allocated COSource object.  Output: Object is attached to source file that was activated by the Goto.  If NULL, the parameter is ignored.
// Parameter: pszProjectName Name of project in which the global resides.  If NULL it assumes the current project.
// Return: SUCCESS if successful; ERROR_NO_GLOBAL if class wasn't found; Whatever SelectGlobal() or GotoDefinitionFromHere() return.
// END_HELP_COMMENT
int UIWorkspaceWindow::GotoGlobalDefinition(LPCSTR pszGlobalName, GLOBAL_TYPE type, COSource* pSrcFile/* = NULL*/, LPCSTR pszProjectName /* = NULL */)
{
	int ret;

	ret = SelectGlobal(pszGlobalName, type, pszProjectName);

	if (ret == SUCCESS)
		ret = GotoDefinitionFromHere(pszGlobalName);

	if (ret == SUCCESS)
	{
		if (pSrcFile != NULL)
			pSrcFile->AttachActiveEditor();
	}

	return ret;

}

// BEGIN_HELP_COMMENT
// Function: int UIWorkspaceWindow::GotoClassMemberDefinition(LPCSTR pszMemberName, MEMBER_TYPE type, COSource* pSrcFile = NULL, LPCSTR pszClassName = NULL, LPCSTR pszProjectName = NULL)
// Description: Navigates to the definition of the given class member.  It assumes that the ClassView is currently the active view.  
// Parameter: pszMemberName Name of class member to find in the workspace window.
// Parameter: type Is this a function or data member?
// Parameter: pSrcFile - Input: Ptr to an allocated COSource object.  Output: Object is attached to source file that was activated by the Goto.  If NULL, the parameter is ignored.
// Parameter: pszClassName Name of class in which to find this member.  If NULL, the function assumes the desired class is currently selected and unexpanded.
// Parameter: pszProjectName Name of project in which the class resides.  This parameter must be supplied if pszClassName is not NULL.
// Return: SUCCESS if successful; ERROR_NO_MEMBER if member wasn't found. Or the return code from SelectClassMember() or GotoDefinitionFromHere().
// END_HELP_COMMENT
int UIWorkspaceWindow::GotoClassMemberDefinition(LPCSTR pszMemberName, MEMBER_TYPE type, COSource* pSrcFile, LPCSTR pszClassName /*= NULL */, LPCSTR pszProjectName /* = NULL */)
{
	int ret;

	ret = SelectClassMember(pszMemberName, type, pszClassName, pszProjectName);

	if (ret == SUCCESS)
		ret = GotoDefinitionFromHere(pszMemberName);

	if (ret == SUCCESS)
	{
		if (pSrcFile != NULL)
			pSrcFile->AttachActiveEditor();
	}

	return ret;
}

// BEGIN_HELP_COMMENT
// Function: int UIWorkspaceWindow::GotoClassMemberDeclaration(LPCSTR pszMemberName, MEMBER_TYPE type, COSource* pSrcFile = NULL, LPCSTR pszClassName = NULL, LPCSTR pszProjectName = NULL)
// Description: Navigates to the declaration of the given class member.  It assumes that the ClassView is currently the active view.  
// Parameter: pszMemberName Name of class member to find in the workspace window.
// Parameter: type Is this a function or data member?
// Parameter: pSrcFile - Input: Ptr to an allocated COSource object.  Output: Object is attached to source file that was activated by the Goto.  If NULL, the parameter is ignored.
// Parameter: pszClassName Name of class in which to find this member.  If NULL, the function assumes the desired class is currently selected and unexpanded.
// Parameter: pszProjectName Name of project in which the class resides.  This parameter must be supplied if pszClassName is not NULL.
// Return: SUCCESS if successful. ERROR_NO_MEMBER if member wasn't found. Or the return code from GotoDeclarationFromHere() or SelectClassMember().
// END_HELP_COMMENT
int UIWorkspaceWindow::GotoClassMemberDeclaration(LPCSTR pszMemberName, MEMBER_TYPE type, COSource* pSrcFile, LPCSTR pszClassName /*= NULL */, LPCSTR pszProjectName /* = NULL */)
{
	int ret;

	ret = SelectClass(pszClassName, pszProjectName);
	if (ret == SUCCESS)
		ret = GotoDeclarationFromHere(pszMemberName);

	if (ret == SUCCESS)
	{
		if (pSrcFile != NULL)
			pSrcFile->AttachActiveEditor();
	}
		
	return ret;
}

// BEGIN_HELP_COMMENT
// Function: int UIWorkspaceWindow::GotoDefinitionFromHere(LPCSTR pszName)
// Description: Navigates to the definition of the currently selected item in the workspace window.  It assumes that the ClassView is currently the active view.  This function is useful for calling right after successfully calling one of the SelectXXX functions.
// Parameter: pszName Name that should appear in source line navigated to.
// Return: SUCCESS if successful; ERROR_GOTO if definition wasn't gone to; ERROR_NO_DEFINITION if definition couldn't be found.
// END_HELP_COMMENT
int UIWorkspaceWindow::GotoDefinitionFromHere(LPCSTR pszName)
{
	static BOOL bFirst = 1;	// Need to maximize a MDI Child window the first time
	if(bFirst)
	{
		COSource JunkFile;	// Open text file that will be maximized and then closed.
		JunkFile.Create();
		UIWB.DoCommand(MENU_FILE, DC_MENU);
		MST.DoKeys("{esc}");
		MST.DoKeys("{left}{down 5}{enter}");
		JunkFile.Close();
		UIWB.DoCommand(IDM_WINDOW_ERRORS, DC_MNEMONIC);		// Open Output window
		UIWB.DoCommand(IDM_VIEW_WORKSPACE, DC_MNEMONIC);	// Set focus back to workspace window
		bFirst = 0;
	}
	
	CString szCaption, szTestCaption ;
	MST.WGetText(NULL, szCaption) ;			// Get current MDI Main Frame caption for compare
	int ret = SUCCESS;
	MST.DoKeys("+({F10})");		// Bring up the popup context menu.

	CString strGotoMenuItem = GetLocString(IDSS_WRKSPC_GOTO_DEFINITION);

	if (!MST.WMenuExists(strGotoMenuItem))
		ret = ERROR_NO_DEFINITION;

	MST.WMenu(strGotoMenuItem);
		
	WaitForInputIdle(g_hTargetProc, 5000);	// Wait for processing to end.
	// Sleep(5000);				// Wait for message box to arrive.

	int nCount = 0;
	MST.WGetText(NULL, szTestCaption);		// Test MDI Main Frame caption until it changes
	while (szCaption == szTestCaption && nCount < 7)
	{
		LOG->RecordInfo("Trying up to %d more times to find the Editor", nCount);
		LOG->RecordInfo("Current caption is %s and original caption is %s ", szTestCaption.GetBuffer(szTestCaption.GetLength()), szCaption.GetBuffer(szCaption.GetLength()));
		Sleep(1000);
		nCount += 1;
		MST.WGetText(NULL, szTestCaption);
	}

	UIMessageBox wndMsgBox;
	
	if (wndMsgBox.AttachActive())			// If we can attach, then an error must've occurred.
	{
		LOG->RecordInfo("ERROR in UIWorkspaceWindow::GotoDefinitionFromHere. Got a message box when we shouldn't have.\n");
		CString str;
		MST.WStaticText("@1", str);
		LOG->RecordInfo("Text field #1 is \"%s\".", str);
		MST.WStaticText("@2", str);
		LOG->RecordInfo("Text field #2 is \"%s\".", str);
		MST.WStaticText("@3", str);
		LOG->RecordInfo("Text field #3 is \"%s\".", str);
		ret = ERROR_NO_DEFINITION;
		wndMsgBox.ButtonClick();
	}
	
	else									// A source window must've become active.
	{
		COSource SrcFile;
		
		SrcFile.AttachActiveEditor();

		// Select to end of line.
//		MST.DoKeys("+({End})");
		// We need to select 2 lines since users often split it in 2 lines
		MST.DoKeys("+({Down}{End})");

		CString strFound = SrcFile.GetSelectedText();
		CString strBase = pszName;

		// Remove spaces from both the source and target strings for comparison.
		RemoveCharFromString(&strBase, ' ');
		RemoveCharFromString(&strFound, ' ');

		if (strFound.Find(strBase) == -1)
		{
			TRACE("UIWorkspaceWindow::GotoDefinitionFromHere() Found: %s\n", (LPCSTR)strFound);
			TRACE("UIWorkspaceWindow::GotoDefinitionFromHere() Looking for: %s\n", (LPCSTR)strBase);
			ret = ERROR_GOTO;
		}
	}
	
	return ret;
}

// BEGIN_HELP_COMMENT
// Function: int UIWorkspaceWindow::GotoDeclarationFromHere(LPCSTR pszName)
// Description: Navigates to the declaration of the currently selected item in the workspace window.  It assumes that the ClassView is currently the active view.  This function is useful for calling right after successfully calling one of the SelectXXX functions.
// Parameter: pszName Name that should appear in source line navigated to.
// Return: SUCCESS if successful;  ERROR_GOTO if definition wasn't gone to; ERROR_NO_DECLARATION if declaration couldn't be found.
// END_HELP_COMMENT
int UIWorkspaceWindow::GotoDeclarationFromHere(LPCSTR pszName)
{
	int ret = SUCCESS;
	MST.DoKeys("+({F10})");		// Bring up the popup context menu.

	CString strGotoMenuItem = GetLocString(IDSS_WRKSPC_GOTO_DECLARATION);

	/* GAC looking for non-existant menu breaks javasys sniff
	if (!MST.WMenuExists(strGotoMenuItem))
		ret = ERROR_NO_DECLARATION;
	*/

	MST.WMenu(strGotoMenuItem);

	WaitForInputIdle(g_hTargetProc, 5000);
	Sleep(1000) ;
	UIMessageBox wndMsgBox;
	if (wndMsgBox.AttachActive())
	{
		ret = ERROR_NO_DECLARATION;
		wndMsgBox.ButtonClick();
	}
	else
	{
		COSource SrcFile;
		
		SrcFile.AttachActiveEditor();

		// Select to end of line.
//		MST.DoKeys("+({End})");
		// We need to select 2 lines since users often split it in 2 lines
		MST.DoKeys("+({Down}{End})");

		CString strFound = SrcFile.GetSelectedText();
		CString strBase = pszName;

		// Remove spaces from both the source and target strings for comparison.
		RemoveCharFromString(&strBase, ' ');
		RemoveCharFromString(&strFound, ' ');

		if (strFound.Find(strBase) == -1)
		{
			TRACE("UIWorkspaceWindow::GotoDeclarationFromHere() Found: %s\n", (LPCSTR)strFound);
			TRACE("UIWorkspaceWindow::GotoDeclarationFromHere() Looking for: %s\n", (LPCSTR)strBase);
			ret = ERROR_GOTO;
		}
	}
	
	return ret;
}

// BEGIN_HELP_COMMENT
// Function: int UIWorkspaceWindow::SetActiveProject(LPCSTR projName)
// Description: Sets the active project inside the workspace 
// Return: none
// END_HELP_COMMENT
BOOL UIWorkspaceWindow::SetActiveProject(LPCSTR projName)
{
	ASSERT(projName);
	if(ActivateBuildPane()==FALSE)
		return FALSE;

	int ret = TRUE;
	// Close all tree and expands projects only
	MST.DoKeyshWnd(HWnd(),"{Home}{Left}{Right}", FALSE, 10000); //wait for idle
	MST.DoKeyshWnd(HWnd(), projName, TRUE);	// Type the name of the project to search.
	Sleep(500); //xtra safety
	MST.DoKeyshWnd(HWnd(),"+{F10}");
	Sleep(1000); //xtra safety
	MST.DoKeyshWnd(HWnd(),"v", FALSE, 1000);
	return ret;
} // SetActiveProject
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\APIWiz\custpage.cpp ===
// custabdl.cpp : implementation file
//

#include "stdafx.h"
#include "apiwiz.h"
#include "custpage.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCustomizePage property page

IMPLEMENT_DYNCREATE(CCustomizePage, CPropertyPage)

CCustomizePage::CCustomizePage() : CPropertyPage(CCustomizePage::IDD)
{
	//{{AFX_DATA_INIT(CCustomizePage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CCustomizePage::~CCustomizePage()
{
}

void CCustomizePage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCustomizePage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCustomizePage, CPropertyPage)
	//{{AFX_MSG_MAP(CCustomizePage)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CCustomizePage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\APIWiz\apiwidlg.h ===
// apiwidlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CApiwizDlg Tabbed Dialog

class CApiwizDlg : public CPropertySheet
{
	DECLARE_DYNAMIC(CApiwizDlg)

// Construction
public:
	CApiwizDlg(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	CApiwizDlg(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CApiwizDlg)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CApiwizDlg();
protected:
	HICON m_hIcon;	// Review: (Delete)
	

	// Generated message map functions
	//{{AFX_MSG(CApiwizDlg)
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\APIWiz\areaslb.cpp ===
// areaslb.cpp : Ownerdraw listbox 

#include "stdafx.h"
#include "areaslb.h"
/////////////////////////////////////////////////////////////////////////////
// Custom Listbox 
#define XBITMAP 30
#define YBITMAP 20

extern TEXTMETRIC tm ;
extern int cxChar, cxCaps, cyChar ;

// Pens and Brushes we need to show selections.
extern CBrush brSelRect ;
extern CBrush brUnSelRect ;
extern CPen   penUnSelRect ;
extern CPen   penSelRect ;
extern CBitmap bmapUnCheck, bmapCheck, bmapTriangle;								 

////////////////////////////////////////////////////////////////////////////

#define COLOR_ITEM_HEIGHT   20

void CAreasLB::MeasureItem(LPMEASUREITEMSTRUCT lpMIS)
{
	// all items are of fixed size
	// must use LBS_OWNERDRAWVARIABLE for this to work
	lpMIS->itemHeight = COLOR_ITEM_HEIGHT;
}

void CAreasLB::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
{
	if (lpDrawItemStruct->itemID >= 0) // Only if we have an item in the listbox 
	 {
	 	CDC* cdc = CDC::FromHandle(lpDrawItemStruct->hDC);
		CBitmap  *pbmap, *poldbmap;
		RECT sel ;

	 	CString cs ;
		CString &refcs = cs ;
	 	CDC compDC ;
		compDC.CreateCompatibleDC(cdc);

		GetText(lpDrawItemStruct->itemID,refcs) ;
	
		sel = lpDrawItemStruct->rcItem ;
		sel.left = sel.left ; // + XBITMAP ;

		if( ODA_DRAWENTIRE == lpDrawItemStruct->itemAction)
		{ //createcompatibleDC

		  	CDC compDC ;
			compDC.CreateCompatibleDC(cdc);

			pbmap = CBitmap::FromHandle((HBITMAP)GetItemData(lpDrawItemStruct->itemID)) ;
		 	poldbmap = compDC.SelectObject(pbmap) ;
			//Draw the bitmap
			cdc->BitBlt(lpDrawItemStruct->rcItem.left ,lpDrawItemStruct->rcItem.top,
						lpDrawItemStruct->rcItem.right - lpDrawItemStruct->rcItem.left,
						lpDrawItemStruct->rcItem.bottom - lpDrawItemStruct->rcItem.top ,
						&compDC,0,0,SRCCOPY);
			//Draw the text 
		   	cdc->TextOut(XBITMAP,lpDrawItemStruct->rcItem.top,refcs ) ;
			cdc->SelectObject(poldbmap) ;
			compDC.DeleteDC() ;
			
		}

		// If selectced 
		if ((lpDrawItemStruct->itemState & ODS_SELECTED) &&
			(lpDrawItemStruct->itemAction & (ODA_SELECT | ODA_DRAWENTIRE)))
		{
			// Draw text with highlight color and background
			cdc->SelectObject(&brSelRect) ; 
  			cdc->SelectObject(&penSelRect) ;
  			cdc->Rectangle(&sel) ;
		
			cdc->SetTextColor(GetSysColor(COLOR_HIGHLIGHTTEXT)) ;
			cdc->SetBkColor(GetSysColor(COLOR_HIGHLIGHT)) ;
	     	
			// Bitmap 
			CDC compDC ;
			compDC.CreateCompatibleDC(cdc);

			pbmap = CBitmap::FromHandle((HBITMAP)GetItemData(lpDrawItemStruct->itemID)) ;
		 	poldbmap = compDC.SelectObject(pbmap) ;
			cdc->BitBlt(lpDrawItemStruct->rcItem.left ,lpDrawItemStruct->rcItem.top,
						lpDrawItemStruct->rcItem.right - lpDrawItemStruct->rcItem.left,
						lpDrawItemStruct->rcItem.bottom - lpDrawItemStruct->rcItem.top ,
						&compDC,0,0,SRCCOPY);
		
		   	cdc->TextOut(XBITMAP, lpDrawItemStruct->rcItem.top, refcs) ;
					
			//restore text colors
			cdc->SetTextColor(GetSysColor(COLOR_WINDOWTEXT)) ;
			cdc->SetBkColor(GetSysColor(COLOR_WINDOW)) ;
			//restore objects
			cdc->SelectObject(poldbmap) ;
			compDC.DeleteDC() ;


	   	}  
	 	
		if (!(lpDrawItemStruct->itemState & ODS_SELECTED) &&
			(lpDrawItemStruct->itemAction & ODA_SELECT))
		{
			// Item has been de-selected -- remove frame
			cdc->SelectObject(&brUnSelRect) ; 
			cdc->SelectObject(&penUnSelRect) ;
			cdc->Rectangle(&sel) ;

			// Draw bitmap
			pbmap = CBitmap::FromHandle((HBITMAP)GetItemData(lpDrawItemStruct->itemID)) ;
			poldbmap = compDC.SelectObject(pbmap) ;
			cdc->BitBlt(lpDrawItemStruct->rcItem.left ,lpDrawItemStruct->rcItem.top,
						lpDrawItemStruct->rcItem.right - lpDrawItemStruct->rcItem.left,
						lpDrawItemStruct->rcItem.bottom - lpDrawItemStruct->rcItem.top ,
						&compDC,0,0,SRCCOPY);
						
			cdc->SetTextColor(GetSysColor(COLOR_WINDOWTEXT)) ;
			cdc->SetBkColor(GetSysColor(COLOR_WINDOW)) ;
	     	
			cdc->TextOut(XBITMAP,lpDrawItemStruct->rcItem.top, refcs) ;
			//restore objects
			cdc->SelectObject(poldbmap) ;
			compDC.DeleteDC() ;

		}  
	 }
}

// Not yet implemented, still has the sample code from the color listbox.
int CAreasLB::CompareItem(LPCOMPAREITEMSTRUCT lpCIS)
{
	COLORREF cr1 = (COLORREF)lpCIS->itemData1;
	COLORREF cr2 = (COLORREF)lpCIS->itemData2;
	if (cr1 == cr2)
		return 0;       // exact match

	// first do an intensity sort, lower intensities go first
	int intensity1 = GetRValue(cr1) + GetGValue(cr1) + GetBValue(cr1);
	int intensity2 = GetRValue(cr2) + GetGValue(cr2) + GetBValue(cr2);
	if (intensity1 < intensity2)
		return -1;      // lower intensity goes first
	else if (intensity1 > intensity2)
		return 1;       // higher intensity goes second

	// if same intensity, sort by color (blues first, reds last)
	if (GetBValue(cr1) > GetBValue(cr2))
		return -1;
	else if (GetGValue(cr1) > GetGValue(cr2))
		return -1;
	else if (GetRValue(cr1) > GetRValue(cr2))
		return -1;
	else
		return 1;
}

/////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\APIWiz\areaslb.h ===
// areaslb.h : Ownerdraw listbox 

#include "stdafx.h"

#ifndef _AREALISTBOX_
#define _AREALISTBOX_

class CAreasLB : public CListBox
{
public:
// Implementation
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMIS);
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDIS);
	virtual int CompareItem(LPCOMPAREITEMSTRUCT lpCIS);
};

#endif // _CUSTOMLISTBOX_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\APIWiz\apiwiz.cpp ===
// apiwiz.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "apiwiz.h"
#include "apiwidlg.h"
#include "apipage.h"
#include "custpage.h"


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

TEXTMETRIC tm ;
int cxChar, cxCaps, cyChar ;

// Pens and Brushes we need to show selections.
CBrush brSelRect ;
CBrush brUnSelRect ;
CPen   penUnSelRect ;
CPen   penSelRect ;
CBitmap bmapUnCheck, bmapCheck, bmapNone, bmapTriangle;							 


/////////////////////////////////////////////////////////////////////////////
// CApiwizApp

BEGIN_MESSAGE_MAP(CApiwizApp, CWinApp)
	//{{AFX_MSG_MAP(CApiwizApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CApiwizApp construction

CApiwizApp::CApiwizApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CApiwizApp object

CApiwizApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CApiwizApp initialization

BOOL CApiwizApp::InitDrawingObjects() 
{
	static int FirstTime = 1 ;
	// Only do this stuff once.
	
/*	CClientDC ccldc(this) ;         
    ccldc.GetTextMetrics(&tm);
    cxChar = tm.tmAveCharWidth ;
    cxCaps = (tm.tmPitchAndFamily &1 ? 3 : 2) * cxChar/ 2 ;
    cyChar = tm.tmHeight + tm.tmExternalLeading ;
*/  
	// Create the brushes we need.
	// Only do this stuff once.
	if(FirstTime)
	{ 
		brSelRect.CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT)) ;
	 	brUnSelRect.CreateSolidBrush(GetSysColor(COLOR_WINDOW)) ; 
	   	penUnSelRect.CreatePen(PS_SOLID,2,GetSysColor(COLOR_WINDOW)) ;
	   	penSelRect.CreatePen(PS_SOLID,1,GetSysColor(COLOR_WINDOWFRAME)) ; 

		bmapUnCheck.LoadBitmap(IDB_UNCHECK) ;
		bmapCheck.LoadBitmap(IDB_MYCHECK);
		bmapNone.LoadBitmap(IDB_BLANKBITMAP);
		bmapTriangle.LoadBitmap(IDB_TRIANGLE);

		FirstTime = 0 ;
	}

	return TRUE; 
}


BOOL CApiwizApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

	Enable3dControls();
	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	// Construct API Wizard Tabbed Dialog

	CCustomizePage CustomizePage ;
	CAPIPage	ApiPage ;

	CApiwizDlg APITabDlg("CAFE Browser") ;
	m_pMainWnd = &APITabDlg;

	APITabDlg.AddPage(&ApiPage) ;
	APITabDlg.AddPage(&CustomizePage) ;

	InitDrawingObjects() ;// Sets up the pens, brushes, and loads the bitmaps.

	if(APITabDlg.DoModal() == IDOK)
	{

		//Cleanup all the allocated memory.
	}
	else 
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\APIWiz\apiwiz.h ===
// apiwiz.h : main header file for the APIWIZ application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CApiwizApp:
// See apiwiz.cpp for the implementation of this class
//

class CApiwizApp : public CWinApp
{
public:
	CApiwizApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CApiwizApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation
 BOOL InitDrawingObjects() ;


	//{{AFX_MSG(CApiwizApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\APIWiz\custpage.h ===
// custpage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCustomizePage class definition
#ifndef _CUSTOMIZETAB_
#define _CUSTOMIZETAB_

class CCustomizePage : public CPropertyPage
{
	DECLARE_DYNCREATE(CCustomizePage)

// Construction
public:
	CCustomizePage();
	~CCustomizePage();

// Dialog Data
	//{{AFX_DATA(CCustomizePage)
	enum { IDD = IDD_CUSTOMIZE };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CCustomizePage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CCustomizePage)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

#endif ; //_CUSTOMIZETAB_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\APIWiz\data.cpp ===
// data.cpp : implementation of collection classes
//

#include "stdafx.h"
#include "data.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CParam
CParam::CParam()
{
}

CParam::~CParam()
{
}

/////////////////////////////////////////////////////////////////////////////
// CAPI

CAPI::CAPI()
{
}


CAPI::~CAPI()
{
}

/////////////////////////////////////////////////////////////////////////////
// CArea

CArea::CArea()
{
}


CArea::~CArea()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\APIWiz\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	apiwiz.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\APIWiz\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by apiwiz.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_APIWIZ_DIALOG               102
#define IDR_MAINFRAME                   128
#define IDB_MYCHECK                     129
#define IDB_UNCHECK                     130
#define IDD_CUSTOMIZE                   134
#define IDD_API                         135
#define IDB_BLANKBITMAP                 136
#define IDI_ICON1                       146
#define IDI_ICON2                       147
#define IDB_TRIANGLE                    162
#define IDC_CURSOR1                     170
#define IDS_BUILD_CATEGORY              1000
#define IDC_ADD_API                     1000
#define IDS_CO_BP                       1001
#define IDS_CO_BROWSER                  1002
#define IDS_CO_DEBUG                    1003
#define IDC_RETURN_DESC                 1003
#define IDS_CO_EXCEPT                   1004
#define IDS_CO_PROJECT                  1005
#define IDC_BASE_CLASS                  1005
#define IDC_DISPLAY_CLASSNAMES          1006
#define IDC_DISPLAY_RETURN_TYPE         1007
#define IDC_DISPLAY_PARAMS              1008
#define IDC_CATEGORY                    1009
#define IDC_LIST_AREAS                  1020
#define IDC_LIST_API                    1021
#define IDC_LIST_PARAMETERS             1022
#define IDC_DESCRIPTION                 1026
#define IDC_API_CALL                    1033
#define IDS_EDITORS_CATEGORY            2000
#define IDS_CO_DLG                      2001
#define IDS_CO_MENU                     2002
#define IDS_CO_RES                      2003
#define IDS_CO_SRC                      2004
#define IDS_IDE_CATEGORY                3000
#define IDS_UI_TOOLBAR                  3001
#define IDS_UI_TLS_CUST_DLG             3002
#define IDS_UI_TLS_OPT_DLG              3003
#define IDS_UI_WINDOW                   3004
#define IDS_END_CATEGORY                4000
#define IDS_ERROR_CANT_OPEN             59142

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1009
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\APIWiz\data.h ===
// data.h 
//
/////////////////////////////////////////////////////////////////////////////


//  Data structure classes
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _APIDATA_
#define _APIDATA_
class CParam
{
public:
    CParam();
    ~CParam();
// Attributes
public:
	CString m_strName;
    CString m_strType;
    CString m_strValue;
	CString m_strDesc;

// Operations
};

typedef CTypedPtrList<CPtrList, CParam*> CParamList;

/////////////////////////////////////////////////////////////////////////////

class CAPI : public CObject
{
public:
	CAPI();

// Attributes
public:
    CString m_strArea;          // AppWiz, Image Ed, Src Ed, or Class 
	CString m_strSubarea;       // Creation, Navigation, Search... Matches index in listbox.
	CString m_strClass;         // Class API belongs to
	CString m_strName;          // Open()
    CString m_strDesc;          // description
    CString m_strReturnVal;     // Return Value
	CString m_strReturnDesc;	// Return Value description
    CParamList m_paramList;     // List of pointers

// Operations

// Implementation
public:
	virtual ~CAPI();
};

typedef CTypedPtrArray<CObArray,CAPI*> CAPIArray;

/////////////////////////////////////////////////////////////////////////////

class CArea : public CObject
{
public:
    CArea();

// Attributes
public:
	CString m_strCategory;
	CString m_strBaseClass;
    CString m_strName;
    CStringList m_strListSubarea;
// Operations

// Implementation
public:
	virtual ~CArea();
};

typedef CTypedPtrArray<CObArray,CArea*> CAreaArray;


#endif //_APIDATA_

/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\APIWiz\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxtempl.h>		// MFC Templates
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\CafeBld\cafebld.h ===
// cafebld.h : main header file for the CAFEBLD application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CCAFEBuildApp:
// See cafebld.cpp for the implementation of this class
//

class CCAFEBuildApp : public CWinApp
{
public:
	CCAFEBuildApp();

// operations
public:
	CString GetRegistryKeyName(void)				{ return m_strRegistryKey; }

// operations
protected:
	void ParseCmdLine(LPCSTR pszCmdLine);
	void EliminateLeadingChars(CString &str, CString strSet);
	CString GetToken(CString &str);

	void Usage(LPCSTR pszMessage = NULL);
// data
protected:
	CString m_strRegistryKey;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCAFEBuildApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CCAFEBuildApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\CafeBld\cafedlg.cpp ===
// cafedlg.cpp : implementation file
//

#include "stdafx.h"
#include "cafebld.h"
#include "cafedlg.h"
#include "settings.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//{{AFX_MSG(CAboutDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg message handlers

BOOL CAboutDlg::OnInitDialog()
{
	CDialog::OnInitDialog();
	CenterWindow();
	
	// TODO: Add extra about dlg initialization here
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

/////////////////////////////////////////////////////////////////////////////
// CCAFEBuildDlg dialog

char* CCAFEBuildDlg::m_szTargets[][2] = {	{ "All targets",					"all" },
											{ "------------------------------------------", "" },
											{ "CAFE system",					"cafe" },
											{ "Sniff tests",					"sniffs" },
											{ "------------------------------------------", "" },
											{ "CAFE driver",					"cafedrv" },
											{ "Target portion of support",		"target" },
											{ "GUI portion of support",			"gui" },
											{ "Shell portion of support",		"shl" },
											{ "Editors portion of support",		"eds" },
											{ "Project portion of support",		"prj" },
											{ "Debugger portion of support",	"dbg" },
											{ "IDE portion of support",			"ide" },
											{ "Toolset portion of support",		"toolset" },
											{ "Build tools portion of support",	"bldtools" },
											{ "SubSuite library",				"subsuite" },
											{ "Log system",						"log" },
											{ "------------------------------------------", "" },
											{ "Browser sniff test",				"browser" },
											{ "Debugger sniff test",			"debugger" },
											{ "Debugger MBC sniff test",		"dbg_mbc" },
											{ "Edit 'n Go sniff test",			"editgo" },
											{ "Editor sniff test",				"editor" },
											{ "Fortran sniff test",				"fortran" },
											{ "SYS sniff test",					"sys" },
											{ "VProj sniff test",				"vproj" },
											{ "VRes sniff test",				"vres" },
											{ "VShell sniff test",				"vshell" },
											{ "Wizards sniff test",				"wizards" },
											{ NULL, NULL } };

CCAFEBuildDlg::CCAFEBuildDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CCAFEBuildDlg::IDD, pParent),
	  m_nBuilding(0),
	  m_bCancelled(FALSE),
	  m_heventTerminate(NULL),
	  m_pthreadReadPipe(NULL),
	  m_strMoreCmdLine("VERB=2")
{
	//{{AFX_DATA_INIT(CCAFEBuildDlg)
	m_bBrowse = FALSE;
	m_bClean = FALSE;
	m_iDebug = FALSE;
	m_bDepend = TRUE;
	m_bSLMIn = FALSE;
	m_bSLMOut = FALSE;
	m_bSsync = FALSE;
	m_bBuild = TRUE;
	//}}AFX_DATA_INIT

	CCAFEBuildApp *pApp = ((CCAFEBuildApp*)AfxGetApp());

	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = pApp->LoadIcon(IDR_MAINFRAME);

	// get the registry key
	m_strRegistryKey = pApp->GetRegistryKeyName();

	// initialize settings
	::GetEnvironmentVariable("CAFEDIR", m_strCAFEDIR.GetBuffer(1024), 1024);
	m_strCAFEDIR.ReleaseBuffer();
	::GetEnvironmentVariable("SNIFFDIR", m_strSNIFFDIR.GetBuffer(1024), 1024);
	m_strSNIFFDIR.ReleaseBuffer();
	::GetEnvironmentVariable("IDESRCDIR", m_strIDESRCDIR.GetBuffer(1024), 1024);
	m_strIDESRCDIR.ReleaseBuffer();
	::GetEnvironmentVariable("PATH", m_strPATH.GetBuffer(1024), 1024);
	m_strPATH.ReleaseBuffer();
	::GetEnvironmentVariable("INCLUDE", m_strINCLUDE.GetBuffer(1024), 1024);
	m_strINCLUDE.ReleaseBuffer();
	::GetEnvironmentVariable("LIB", m_strLIB.GetBuffer(1024), 1024);
	m_strLIB.ReleaseBuffer();

	m_strMakefile = "cafebld.mak";

	// read settings from the registry
	ReadRegistry();
}

CCAFEBuildDlg::~CCAFEBuildDlg()
{
	// write settings to the registry
	WriteRegistry();
}

void CCAFEBuildDlg::ReadRegistry(void)
{
	HKEY hKey;
	DWORD dwType;
	DWORD dwDataSize;

	// open the registry key, if it exists
	if (::RegOpenKeyEx(HKEY_CURRENT_USER, BASEREGISTRYKEY + m_strRegistryKey, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS) {
		// read browse value
		dwDataSize = sizeof(m_bBrowse);
		::RegQueryValueEx(hKey, "Browse", NULL, &dwType, (unsigned char*)&m_bBrowse, &dwDataSize);
		// read Build value
		dwDataSize = sizeof(m_bBuild);
		::RegQueryValueEx(hKey, "Build", NULL, &dwType, (unsigned char*)&m_bBuild, &dwDataSize);
		// read clean value
		dwDataSize = sizeof(m_bClean);
		::RegQueryValueEx(hKey, "Clean", NULL, &dwType, (unsigned char*)&m_bClean, &dwDataSize);
		// read debug value
		dwDataSize = sizeof(m_iDebug);
		::RegQueryValueEx(hKey, "Debug", NULL, &dwType, (unsigned char*)&m_iDebug, &dwDataSize);
		// read depend value
		dwDataSize = sizeof(m_bDepend);
		::RegQueryValueEx(hKey, "Depend", NULL, &dwType, (unsigned char*)&m_bDepend, &dwDataSize);
		// read SLMIn value
		dwDataSize = sizeof(m_bSLMIn);
		::RegQueryValueEx(hKey, "SLMIn", NULL, &dwType, (unsigned char*)&m_bSLMIn, &dwDataSize);
		// read SLMOut value
		dwDataSize = sizeof(m_bSLMOut);
		::RegQueryValueEx(hKey, "SLMOut", NULL, &dwType, (unsigned char*)&m_bSLMOut, &dwDataSize);
		// read Ssync value
		dwDataSize = sizeof(m_bSsync);
		::RegQueryValueEx(hKey, "Ssync", NULL, &dwType, (unsigned char*)&m_bSsync, &dwDataSize);

		char acBuf[1024];
		// read CAFEDIR value
		dwDataSize = 1024;
		if (::RegQueryValueEx(hKey, "CAFEDIR", NULL, &dwType, (unsigned char*)acBuf, &dwDataSize) == ERROR_SUCCESS) {
			acBuf[dwDataSize] = '\0';
			m_strCAFEDIR = CString(acBuf);
		}
		// read SNIFFDIR value
		dwDataSize = 1024;
		if (::RegQueryValueEx(hKey, "SNIFFDIR", NULL, &dwType, (unsigned char*)acBuf, &dwDataSize) == ERROR_SUCCESS) {
			acBuf[dwDataSize] = '\0';
			m_strSNIFFDIR = CString(acBuf);
		}
		// read IDESRCDIR value
		dwDataSize = 1024;
		if (::RegQueryValueEx(hKey, "IDESRCDIR", NULL, &dwType, (unsigned char*)acBuf, &dwDataSize) == ERROR_SUCCESS) {
			acBuf[dwDataSize] = '\0';
			m_strIDESRCDIR = CString(acBuf);
		}
		// read PATH value
		dwDataSize = 1024;
		if (::RegQueryValueEx(hKey, "PATH", NULL, &dwType, (unsigned char*)acBuf, &dwDataSize) == ERROR_SUCCESS) {
			acBuf[dwDataSize] = '\0';
			m_strPATH = CString(acBuf);
		}
		// read INCLUDE value
		dwDataSize = 1024;
		if (::RegQueryValueEx(hKey, "INCLUDE", NULL, &dwType, (unsigned char*)acBuf, &dwDataSize) == ERROR_SUCCESS) {
			acBuf[dwDataSize] = '\0';
			m_strINCLUDE = CString(acBuf);
		}
		// read LIB value
		dwDataSize = 1024;
		if (::RegQueryValueEx(hKey, "LIB", NULL, &dwType, (unsigned char*)acBuf, &dwDataSize) == ERROR_SUCCESS) {
			acBuf[dwDataSize] = '\0';
			m_strLIB = CString(acBuf);
		}
		// read makefile value
		dwDataSize = 1024;
		if (::RegQueryValueEx(hKey, "Makefile", NULL, &dwType, (unsigned char*)acBuf, &dwDataSize) == ERROR_SUCCESS) {
			acBuf[dwDataSize] = '\0';
			m_strMakefile = CString(acBuf);
		}
		// read additional command line value
		dwDataSize = 1024;
		if (::RegQueryValueEx(hKey, "MoreCmdLine", NULL, &dwType, (unsigned char*)acBuf, &dwDataSize) == ERROR_SUCCESS) {
			acBuf[dwDataSize] = '\0';
			m_strMoreCmdLine = CString(acBuf);
		}

		// close the key
		::RegCloseKey(hKey);
	}
}

void CCAFEBuildDlg::WriteRegistry(void)
{
	HKEY hKey;
	DWORD dwDisposition;

	// create the registry key
	if (::RegCreateKeyEx(HKEY_CURRENT_USER, BASEREGISTRYKEY + m_strRegistryKey, 0, "CAFEBuild", REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dwDisposition) == ERROR_SUCCESS) {
		// write browse value
		::RegSetValueEx(hKey, "Browse", 0, REG_BINARY, (unsigned char*)&m_bBrowse, sizeof(m_bBrowse));
		::RegSetValueEx(hKey, "Build", 0, REG_BINARY, (unsigned char*)&m_bBuild, sizeof(m_bBuild));
		::RegSetValueEx(hKey, "Clean", 0, REG_BINARY, (unsigned char*)&m_bClean, sizeof(m_bClean));
		::RegSetValueEx(hKey, "Debug", 0, REG_BINARY, (unsigned char*)&m_iDebug, sizeof(m_iDebug));
		::RegSetValueEx(hKey, "Depend", 0, REG_BINARY, (unsigned char*)&m_bDepend, sizeof(m_bDepend));
		::RegSetValueEx(hKey, "SLMIn", 0, REG_BINARY, (unsigned char*)&m_bSLMIn, sizeof(m_bSLMIn));
		::RegSetValueEx(hKey, "SLMOut", 0, REG_BINARY, (unsigned char*)&m_bSLMOut, sizeof(m_bSLMOut));
		::RegSetValueEx(hKey, "Ssync", 0, REG_BINARY, (unsigned char*)&m_bSsync, sizeof(m_bSsync));

		::RegSetValueEx(hKey, "CAFEDIR", 0, REG_SZ, (const unsigned char*)(LPCTSTR)m_strCAFEDIR, m_strCAFEDIR.GetLength());
		::RegSetValueEx(hKey, "SNIFFDIR", 0, REG_SZ, (const unsigned char*)(LPCTSTR)m_strSNIFFDIR, m_strSNIFFDIR.GetLength());
		::RegSetValueEx(hKey, "IDESRCDIR", 0, REG_SZ, (const unsigned char*)(LPCTSTR)m_strIDESRCDIR, m_strIDESRCDIR.GetLength());
		::RegSetValueEx(hKey, "PATH", 0, REG_SZ, (const unsigned char*)(LPCTSTR)m_strPATH, m_strPATH.GetLength());
		::RegSetValueEx(hKey, "INCLUDE", 0, REG_SZ, (const unsigned char*)(LPCTSTR)m_strINCLUDE, m_strINCLUDE.GetLength());
		::RegSetValueEx(hKey, "LIB", 0, REG_SZ, (const unsigned char*)(LPCTSTR)m_strLIB, m_strLIB.GetLength());
		::RegSetValueEx(hKey, "Makefile", 0, REG_SZ, (const unsigned char*)(LPCTSTR)m_strMakefile, m_strMakefile.GetLength());
		::RegSetValueEx(hKey, "MoreCmdLine", 0, REG_SZ, (const unsigned char*)(LPCTSTR)m_strMoreCmdLine, m_strMoreCmdLine.GetLength());

		// close the key
		::RegCloseKey(hKey);
	}
}

void CCAFEBuildDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCAFEBuildDlg)
	DDX_Control(pDX, IDE_Output, m_editOutput);
	DDX_Control(pDX, IDL_Targets, m_listTargets);
	DDX_Check(pDX, IDC_Browse, m_bBrowse);
	DDX_Check(pDX, IDC_Clean, m_bClean);
	DDX_Check(pDX, IDC_Debug, m_iDebug);
	DDX_Check(pDX, IDC_Depend, m_bDepend);
	DDX_Check(pDX, IDC_SLMIn, m_bSLMIn);
	DDX_Check(pDX, IDC_SLMOut, m_bSLMOut);
	DDX_Check(pDX, IDC_Ssync, m_bSsync);
	DDX_Check(pDX, IDC_Build, m_bBuild);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CCAFEBuildDlg, CDialog)
	//{{AFX_MSG_MAP(CCAFEBuildDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDOK, OnBuild)
	ON_BN_CLICKED(IDB_CancelBuild, OnCancelBuild)
	ON_BN_CLICKED(IDCANCEL, OnExit)
	ON_BN_CLICKED(IDB_Settings, OnSettings)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_UPDATEOUTPUT, OnUpdateOutput)
	ON_MESSAGE(WM_BUILDCOMPLETE, OnBuildComplete)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCAFEBuildDlg message handlers

BOOL CCAFEBuildDlg::OnInitDialog()
{
	CDialog::OnInitDialog();
	CenterWindow();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	CString strAboutMenu;
	strAboutMenu.LoadString(IDS_ABOUTBOX);
	if (!strAboutMenu.IsEmpty())
	{
		pSysMenu->AppendMenu(MF_SEPARATOR);
		pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
	}
	
	// fill in the target list box
	for (int i = 0; m_szTargets[i][0] != NULL; i++) {
		m_listTargets.AddString(m_szTargets[i][0]);
	}

	UpdateData(FALSE);

	// enable/disable buttons
	UpdateButtons();
		
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CCAFEBuildDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CCAFEBuildDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CCAFEBuildDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CCAFEBuildDlg::OnBuild() 
{
	LPCSTR pszCmdLine = "vcspawn -e %lu nmake -f %s BROWSE=%d BUILD=%d CLEAN=%d DEBUG=%d DEPEND=%d SLMIN=%d SLMOUT=%d SSYNC=%d %s ";
	char acCmdLine[1024];
	const cnBuf = 50;
	int anSelTargets[cnBuf];
	int nSel;
	DWORD dwWritten;
	LPCSTR pszBanner1 = "============================================\r\n";
	LPCSTR pszBanner2 = "==== CAFE Build System -- %s -- %s ====\r\n";
	BOOL bProcess;
	SECURITY_ATTRIBUTES	sa = { sizeof(SECURITY_ATTRIBUTES), NULL, TRUE };
	char acBuf[1024];

	// update member vars with data from dialog
	UpdateData(TRUE);

	// getting ready to build
	m_nBuilding = 2;
	UpdateButtons();

	// at least one target must be selected
	nSel = m_listTargets.GetSelCount();
	if (nSel > 0) {

		// clear the edit control
		m_editOutput.SetReadOnly(FALSE);
		m_editOutput.SetSel(0, -1, TRUE);
		m_editOutput.Clear();
		m_editOutput.SetReadOnly(TRUE);

		// create an event to use for terminating the build
		m_heventTerminate = ::CreateEvent(&sa, TRUE, FALSE, NULL);
		if (m_heventTerminate) {

			// build command line
			sprintf(acCmdLine, pszCmdLine, (DWORD)m_heventTerminate, (LPCSTR)m_strMakefile, m_bBrowse, m_bBuild, m_bClean, m_iDebug, m_bDepend, m_bSLMIn, m_bSLMOut, m_bSsync, (LPCSTR)m_strMoreCmdLine);

			// get the selected items from the list box
			m_listTargets.GetSelItems(cnBuf, anSelTargets);

			// add the targets to the command line
			for (int i = 0; i < nSel; i++) {
				strcat(acCmdLine, m_szTargets[anSelTargets[i]][1]);
				strcat(acCmdLine, " ");
			}

			// create an anonymous pipe
			if (::CreatePipe(&m_hpipeRead, &m_hpipeWrite, &sa, 0)) {

				// we need to mark the read end of the pipe as noninheritable,
				// so the child process doesn't inherit a "garbage" handle
				// that is unclosable.
				::DuplicateHandle(GetCurrentProcess(), m_hpipeRead, GetCurrentProcess(), NULL, 0, FALSE, DUPLICATE_SAME_ACCESS);

				// duplicate the write handle so it can also be used as a write
				// handle for stderr. If we use the same handle, and the child
				// process closes either one, both close and the anonymous pipe
				// closes.
				::DuplicateHandle(GetCurrentProcess(), m_hpipeWrite, GetCurrentProcess(), &m_hpipeWriteErr, 0, TRUE, DUPLICATE_SAME_ACCESS);

				// start a thread to read from the pipe
				m_pthreadReadPipe = AfxBeginThread(WrapReadPipe, this);

				// write out starting banner
				char acTime[10];
				char acDate[10];
				char acBannerSig[100];
				_strtime(acTime);
				_strdate(acDate);
				sprintf(acBannerSig, pszBanner2, acTime, acDate);
				::WriteFile(m_hpipeWrite, pszBanner1, strlen(pszBanner1), &dwWritten, NULL);
				::WriteFile(m_hpipeWrite, acBannerSig, strlen(acBannerSig), &dwWritten, NULL);
				::WriteFile(m_hpipeWrite, pszBanner1, strlen(pszBanner1), &dwWritten, NULL);

				// set additional environment var settings for build
				::SetEnvironmentVariable("CAFEDIR", m_strCAFEDIR);
				::SetEnvironmentVariable("SNIFFDIR", m_strSNIFFDIR);
				::SetEnvironmentVariable("IDESRCDIR", m_strIDESRCDIR);
				::SetEnvironmentVariable("PATH", m_strPATH);
				::SetEnvironmentVariable("INCLUDE", m_strINCLUDE);
				::SetEnvironmentVariable("LIB", m_strLIB);

				// fill in startup info structure for CreateProcess
				STARTUPINFO si = {	sizeof(STARTUPINFO),		// cb
									NULL,						// lpReserved
									NULL,						// lpDesktop
									NULL,						// lpTitle
									0, 0,						// dwX, dwY
									0, 0,						// dwXSize, dwYSize
									0, 0,						// dwXCountChars, dwYCountChars
									0,							// dwFillAttribute
									STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES,		// dwFlags
									SW_HIDE,					// wShowWindow
									0,							// cbReserved2
									NULL,						// lpReserved2
									NULL,						// hStdInput
									m_hpipeWrite,				// hStdOutput
									m_hpipeWriteErr };			// hStdError

				// spawn the build command line
				bProcess = ::CreateProcess(	NULL,				// lpszImageName
											acCmdLine,			// lpszCommandLine
											NULL,				// lpsaProcess
											NULL,				// lpsaThread
											TRUE,				// fInheritHandles
											NORMAL_PRIORITY_CLASS | CREATE_NEW_PROCESS_GROUP, // fdwCreate
											NULL,				// lpvEnvironment
											NULL,				// lpszCurDir
											&si,				// lpsiStartInfo
											&m_procinfo );		// lppiProcInfo

				// was CreateProcess successful?
				if (bProcess) {
					sprintf(acBuf, "Spawning build engine: %s...\r\n", acCmdLine);
					::WriteFile(m_hpipeWrite, acBuf, strlen(acBuf), &dwWritten, NULL);

					m_nBuilding = 1;
				}
				else {
					// CreateProcess not successful
					char acBuf[80];
					sprintf(acBuf, "Error (%d) spawning build engine: %s.\r\n", ::GetLastError(), acCmdLine);
					::WriteFile(m_hpipeWrite, acBuf, strlen(acBuf), &dwWritten, NULL);

					m_nBuilding = 0;
				}

				// close our handles to the write end of the pipe, 
				// so that when the child process does, the pipe will close
				::CloseHandle(m_hpipeWrite);
				::CloseHandle(m_hpipeWriteErr);
			}
			else {
				// creating anonymous pipe was not successful
				AfxMessageBox("Creating anonymous pipe was not successful. Unable to build.");
				m_nBuilding = 0;
			}
		}
		else {
			// unable to create event to signal vcspawn
			AfxMessageBox("Unable to create termination event. Unable to build.");
			m_nBuilding = 0;
		}
	}
	else {
		// no targets were selected
		AfxMessageBox("At least one target must be selected.");
		m_nBuilding = 0;
	}

	UpdateButtons();
}

UINT CCAFEBuildDlg::WrapReadPipe(LPVOID pParam)
{
	return ((CCAFEBuildDlg*)pParam)->ReadPipe();
}

UINT CCAFEBuildDlg::ReadPipe(void)
{
	const DWORD ccBuf = 10;
	char acBuf[ccBuf+1];
	DWORD ccRead;

	// read from the pipe until it's broken
	for (BOOL bDone = FALSE; !bDone; ) {
		if (::ReadFile(m_hpipeRead, acBuf, ccBuf, &ccRead, NULL)) {
			// put end of string marker after last char read
			acBuf[ccRead] = '\0';
			// display the data
			m_strOutput = CString(acBuf);
			SendMessage(WM_UPDATEOUTPUT);
		}
		else {
			switch (::GetLastError()) {
				case ERROR_BROKEN_PIPE: {
					PostMessage(WM_BUILDCOMPLETE);
					bDone = TRUE;
					break;
				}
			}
		}
	}
	return 0;
}

void CCAFEBuildDlg::UpdateButtons(void)
{
	// gray Build if building; gray Cancel Build if not
	((CButton*)GetDlgItem(IDOK))->EnableWindow((m_nBuilding == 0));
	((CButton*)GetDlgItem(IDB_CancelBuild))->EnableWindow((m_nBuilding == 1));

	// gray check boxes if building
	for (int i = IDC_Build; i <= IDC_Browse; i++) {
		((CWnd*)GetDlgItem(i))->EnableWindow((m_nBuilding == 0));
	}

	// gray target list box if building
	((CWnd*)GetDlgItem(IDL_Targets))->EnableWindow((m_nBuilding == 0));

	// gray settings button if building
	((CWnd*)GetDlgItem(IDB_Settings))->EnableWindow((m_nBuilding == 0));
}

void CCAFEBuildDlg::OnCancelBuild() 
{
	// set the flag that indicates we're cancelling the build
	m_bCancelled = TRUE;

	// is the event valid (did we spawn vcspawn?)
	if (m_heventTerminate) {
		// signal vcspawn that we want to terminate the build
		::SetEvent(m_heventTerminate);

		// wait for vcspawn to terminate
		if (::WaitForSingleObject(m_procinfo.hProcess, 25000) == WAIT_TIMEOUT) {
			m_editOutput.ReplaceSel("VCSpawn never terminated; terminating it.\r\n");
			::TerminateProcess(m_procinfo.hProcess, 0);
		}
	}

	// is the pipe thread valid?
	if (m_pthreadReadPipe) {
		// wait for read pipe thread to exit
		if (::WaitForSingleObject(m_pthreadReadPipe->m_hThread, 1000) == WAIT_TIMEOUT) {
			m_editOutput.ReplaceSel("Build cancelled, but read pipe thread didn't exit; terminating it.\r\n");
			::TerminateThread(m_pthreadReadPipe->m_hThread, 0);

			// since we had to terminate the read pipe thread, OnBuildComplete will never be called,
			// so we'll fix things up here

			// we're no longer building
			m_nBuilding = 0;
			UpdateButtons();
			UpdateData(FALSE);

			// no longer cancelled
			m_bCancelled = FALSE;
		}
		else {
			m_editOutput.ReplaceSel("Build cancelled.\r\n");
		}
		delete m_pthreadReadPipe; //release thread data
	}
}

LONG CCAFEBuildDlg::OnUpdateOutput(UINT wParam, LONG lParam)
{
	// display the text
	m_editOutput.ReplaceSel(m_strOutput);

	m_strOutput.Empty();

	return 0;
}

LONG CCAFEBuildDlg::OnBuildComplete(UINT wParam, LONG lParam)
{
	// close the terminate event
	::CloseHandle(m_heventTerminate);

	// if the build wasn't cancelled, it completed
	if (!m_bCancelled) {
		// wait for the read pipe thread to exit
		if (::WaitForSingleObject(m_pthreadReadPipe->m_hThread, 2000) == WAIT_TIMEOUT) {
			m_editOutput.ReplaceSel("Build complete, but read pipe thread didn't exit; terminating it.\r\n");
			::TerminateThread(m_pthreadReadPipe->m_hThread, 0);
		}
		else {
			m_editOutput.ReplaceSel("Build complete.\r\n");
		}
		delete m_pthreadReadPipe; //release thread data
	}

	// clear build cancelled flag
	m_bCancelled = FALSE;

	// we're no longer building
	m_nBuilding = 0;
	UpdateButtons();
	UpdateData(FALSE);

	return 0;
}

void CCAFEBuildDlg::OnExit() 
{
	// cancel the build
	OnCancelBuild();

	// call the base class
	CDialog::OnCancel();
}

void CCAFEBuildDlg::OnSettings()
{
	// instantiate the settings dialog
	CSettingsDlg dlgSettings;

	// fill in member variables
	dlgSettings.m_strCAFEDIR = m_strCAFEDIR;
	dlgSettings.m_strSNIFFDIR = m_strSNIFFDIR;
	dlgSettings.m_strIDESRCDIR = m_strIDESRCDIR;
	dlgSettings.m_strMakefile = m_strMakefile;
	dlgSettings.m_strPATH = m_strPATH;
	dlgSettings.m_strINCLUDE = m_strINCLUDE;
	dlgSettings.m_strLIB = m_strLIB;
	dlgSettings.m_strParameters = m_strMoreCmdLine;
	dlgSettings.m_strRegistryKey = m_strRegistryKey;

	// display the dialog
	if (dlgSettings.DoModal() == IDOK) {
		// retrieve settings from dialog
		m_strCAFEDIR = dlgSettings.m_strCAFEDIR;
		m_strSNIFFDIR = dlgSettings.m_strSNIFFDIR;
		m_strIDESRCDIR = dlgSettings.m_strIDESRCDIR;
		m_strMakefile = dlgSettings.m_strMakefile;
		m_strPATH = dlgSettings.m_strPATH;
		m_strINCLUDE = dlgSettings.m_strINCLUDE;
		m_strLIB = dlgSettings.m_strLIB;
		m_strMoreCmdLine = dlgSettings.m_strParameters;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\CafeBld\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cafebld.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_CAFEBLD_DIALOG              102
#define IDR_MAINFRAME                   128
#define IDD_Settings                    129
#define IDL_Targets                     1001
#define IDE_Output                      1009
#define IDB_CancelBuild                 1011
#define IDE_EnvCAFEDIR                  1013
#define IDE_EnvSNIFFDIR                 1014
#define IDE_EnvIDESRCDIR                1015
#define IDE_Makefile                    1016
#define IDE_EnvPATH                     1017
#define IDE_EnvINCLUDE                  1018
#define IDB_Settings                    1019
#define IDE_EnvLIB                      1019
#define IDE_RegistryKey                 1020
#define IDE_Parameters                  1021
#define IDC_Build                       2000
#define IDC_Clean                       2001
#define IDC_Ssync                       2002
#define IDC_SLMOut                      2003
#define IDC_SLMIn                       2004
#define IDC_Debug                       2005
#define IDC_Depend                      2006
#define IDC_Browse                      2007

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1022
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\CafeBld\cafedlg.h ===
// cafedlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCAFEBuildDlg dialog

#define WM_UPDATEOUTPUT (WM_USER+1)
#define WM_BUILDCOMPLETE (WM_USER+2)

#define BASEREGISTRYKEY "Software\\Microsoft\\"
#define DEFAULTREGISTRYKEY "CAFE Build System"

class CCAFEBuildDlg : public CDialog
{
// Construction
public:
	CCAFEBuildDlg(CWnd* pParent = NULL);	// standard constructor
	~CCAFEBuildDlg();

// Dialog Data
	//{{AFX_DATA(CCAFEBuildDlg)
	enum { IDD = IDD_CAFEBLD_DIALOG };
	CEdit	m_editOutput;
	CListBox	m_listTargets;
	BOOL	m_bBrowse;
	BOOL	m_bClean;
	int 	m_iDebug;
	BOOL	m_bDepend;
	BOOL	m_bSLMIn;
	BOOL	m_bSLMOut;
	BOOL	m_bSsync;
	BOOL	m_bBuild;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCAFEBuildDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Data
protected:
	static char* m_szTargets[][2];

	// pointer to the read pipe thread
	CWinThread* m_pthreadReadPipe;

	// pipe handles
	HANDLE m_hpipeRead;
	HANDLE m_hpipeWrite;
	HANDLE m_hpipeWriteErr;

	// process information structure for spawning nmake
	PROCESS_INFORMATION m_procinfo;

	// event to signal vcspawn if we want to terminate the build
	HANDLE m_heventTerminate;

	// flag to indicate whether we're building (1), getting ready to build (2) or not (0)
	int m_nBuilding;

	// flag to indicate if build was cancelled or not
	BOOL m_bCancelled;

	// string that's filled in by the read pipe thread
	CString m_strOutput;

	// storage for settings data
	CString m_strCAFEDIR;
	CString m_strSNIFFDIR;
	CString m_strIDESRCDIR;
	CString m_strMakefile;
	CString m_strPATH;
	CString m_strINCLUDE;
	CString m_strLIB;

	// additional command line to pass to nmake
	CString m_strMoreCmdLine;

	// registry key name
	CString m_strRegistryKey;

// Internal Operations
protected:
	void ReadRegistry(void);
	void WriteRegistry(void);

	static UINT WrapReadPipe(LPVOID pParam);
	UINT ReadPipe(void);

	void UpdateButtons(void);

// Implementation
protected:
	HICON m_hIcon;

	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnBuild();
	afx_msg void OnCancelBuild();
	afx_msg void OnExit();
	afx_msg void OnSettings();
	//}}AFX_MSG
	//}}AFX_MSG
	afx_msg LONG OnUpdateOutput(UINT wParam, LONG lParam);
	afx_msg LONG OnBuildComplete(UINT wParam, LONG lParam);
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\CafeBld\cafebld.cpp ===
// cafebld.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "cafebld.h"
#include "cafedlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCAFEBuildApp

BEGIN_MESSAGE_MAP(CCAFEBuildApp, CWinApp)
	//{{AFX_MSG_MAP(CCAFEBuildApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCAFEBuildApp construction

CCAFEBuildApp::CCAFEBuildApp()
: m_strRegistryKey("CAFE Build System")
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CCAFEBuildApp object

CCAFEBuildApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CCAFEBuildApp initialization

BOOL CCAFEBuildApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

	Enable3dControls();
//	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	// parse the command line
	ParseCmdLine(m_lpCmdLine);

	CCAFEBuildDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}

void CCAFEBuildApp::ParseCmdLine(LPCSTR pszCmdLine)
{
	CString strCmdLine = pszCmdLine;

	// eliminate any leading white space
	EliminateLeadingChars(strCmdLine, " \t");
	// iterate through all command line parameters
	while (!strCmdLine.IsEmpty()) {
		if (strCmdLine[0] == '-') {
			switch (strCmdLine[1]) {
				case 'k':
				case 'K': {
					strCmdLine = strCmdLine.Mid(2);
					m_strRegistryKey = GetToken(strCmdLine);
					break;
				}
				case '?': {
					strCmdLine = strCmdLine.Mid(2);
					Usage();
					break;
				}
				default: {
					Usage("Unrecognized command line switch '" + GetToken(strCmdLine) + "'.");
					break;
				}
			}
		}
		else {
			Usage("Invalid command line parameter '" + GetToken(strCmdLine) + "'.");
		}
		EliminateLeadingChars(strCmdLine, " \t");
	}
}

void CCAFEBuildApp::EliminateLeadingChars(CString &str, CString strSet)
{
    // the set string should not be empty
    ASSERT(!strSet.IsEmpty());

    while (str.FindOneOf(strSet) == 0) {
        str = str.Mid(1);
    }
}

// this function returns the next token in str (assuming it starts at the beginning of str
// and also changes str so that it points to the next character immediately following the token delimeter
CString CCAFEBuildApp::GetToken(CString &str)
{
	CString strToken;
	int nDelimeter;

	// find the end of the token (assume the token starts at the beginning of the string
	nDelimeter = str.FindOneOf(" \t");
	// if no delimeter found, the token is the entire string
	if (nDelimeter == -1) {
		strToken = str;
		str.Empty();
	}
	// the token goes from the beginning of the string to the position of the delimeter
	else {
		strToken = str.Left(nDelimeter);
		str = str.Mid(nDelimeter+1);
	}

	return strToken;
}

void CCAFEBuildApp::Usage(LPCSTR pszMessage /*= NULL*/)
{
	CString strUsage = "CAFE Build System Application.\nUsage: cafebld [-k<keyname>]\n-k: Specify the registry key to use.";

	if (pszMessage != NULL) {
		strUsage = CString(pszMessage) + "\n\n" + strUsage;
	}

	AfxMessageBox(strUsage);
	exit(1);
	::PostQuitMessage(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\CafeBld\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	cafebld.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\CafeBld\settings.cpp ===
// Settings.cpp : implementation file
//

#include "stdafx.h"
#include "cafebld.h"
#include "Settings.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSettingsDlg dialog


CSettingsDlg::CSettingsDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CSettingsDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSettingsDlg)
	m_strCAFEDIR = _T("");
	m_strIDESRCDIR = _T("");
	m_strSNIFFDIR = _T("");
	m_strMakefile = _T("");
	m_strPATH = _T("");
	m_strINCLUDE = _T("");
	m_strLIB = _T("");
	m_strParameters = _T("");
	m_strRegistryKey = _T("");
	//}}AFX_DATA_INIT
}


void CSettingsDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSettingsDlg)
	DDX_Text(pDX, IDE_EnvCAFEDIR, m_strCAFEDIR);
	DDX_Text(pDX, IDE_EnvIDESRCDIR, m_strIDESRCDIR);
	DDX_Text(pDX, IDE_EnvSNIFFDIR, m_strSNIFFDIR);
	DDX_Text(pDX, IDE_Makefile, m_strMakefile);
	DDX_Text(pDX, IDE_EnvPATH, m_strPATH);
	DDX_Text(pDX, IDE_EnvINCLUDE, m_strINCLUDE);
	DDX_Text(pDX, IDE_EnvLIB, m_strLIB);
	DDX_Text(pDX, IDE_Parameters, m_strParameters);
	DDX_Text(pDX, IDE_RegistryKey, m_strRegistryKey);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CSettingsDlg, CDialog)
	//{{AFX_MSG_MAP(CSettingsDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CSettingsDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\CafeBld\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\CafeBld\settings.h ===
// Settings.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSettingsDlg dialog

class CSettingsDlg : public CDialog
{
// Construction
public:
	CSettingsDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSettingsDlg)
	enum { IDD = IDD_Settings };
	CString	m_strCAFEDIR;
	CString	m_strIDESRCDIR;
	CString	m_strSNIFFDIR;
	CString	m_strMakefile;
	CString m_strPATH;
	CString m_strINCLUDE;
	CString m_strLIB;
	CString m_strParameters;
	CString m_strRegistryKey;
	//}}AFX_DATA

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSettingsDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSettingsDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\ConvertRCs\ConvertRCs.cpp ===
#include <afx.h>

void main(int argc, char *argv[])

{
	/*
	FILE *pfIn = fopen("StringsJapanese.rc", "r");
	FILE *pfOut = fopen("StringsJapanese2.rc", "w");
	char szLine[1024];
	CString cstrLine;
	CString cstrPostNumber;
	int intNumberIndex;
	int intNumber;

	while(!feof(pfIn))

	{
		fgets(szLine, 1023, pfIn);
		cstrLine = szLine;
		intNumberIndex = cstrLine.FindOneOf("0123456789");
		
		if(intNumberIndex != -1)
		
		{
			intNumber = atoi(cstrLine.Mid(intNumberIndex, 5));
			intNumber -= 5000;
			fprintf(pfOut, "    %d %s", intNumber, cstrLine.Mid(intNumberIndex + 5));
		}

		else
			fprintf(pfOut, "%s", szLine);
	}

	fclose(pfIn);
	fclose(pfOut);
	*/

	FILE *pfIn = fopen("c:\\cafe6\\include\\Strings.h", "r");
	char szLine[1024];
	CString cstrLine;
	CString cstrSymbolName;
	CString cstrSymbolNames[551];
	CString cstrSymbolIDs[551];
	int intSpaceIndex;

	for(int i = 0; i < 551; i++)	
	{
		fgets(szLine, 1023, pfIn);
		cstrLine = szLine;
		cstrLine.TrimRight();
		cstrSymbolName = cstrLine.Mid(8);
		intSpaceIndex = cstrSymbolName.FindOneOf(" \t");
		cstrSymbolNames[i] = cstrLine.Mid(8, intSpaceIndex);
		cstrSymbolIDs[i] = cstrLine.Right(4);
	}

	fclose(pfIn);
	pfIn = fopen("StringsJapanese2.rc", "r");
	FILE *pfOut = fopen("StringsJapanese.rc", "w");
	int intNumberIndex;
	int intTabs;
	CString cstrNumber;
	CString cstrPostNumber;

	while(!feof(pfIn))

	{
		fgets(szLine, 1023, pfIn);
		cstrLine = szLine;
		intNumberIndex = cstrLine.FindOneOf("0123456789");
		
		if(intNumberIndex != -1)
		
		{
			cstrNumber = cstrLine.Mid(intNumberIndex, 4);
			cstrPostNumber = cstrLine.Mid(intNumberIndex + 4);
			cstrPostNumber.TrimLeft();

			for(i = 0; i < 551; i++)
			{
				if(cstrNumber == cstrSymbolIDs[i])
				{
					intTabs = 11 - (cstrSymbolNames[i].GetLength() / 4);
					fprintf(pfOut, "    %s", cstrSymbolNames[i]);
					
					for(int j = 0; j < intTabs; j++)
						fprintf(pfOut, "\t");
					
					fprintf(pfOut, " %s", cstrPostNumber);
				}
			}
		}

		else
			fprintf(pfOut, "%s", szLine);
	}

	fclose(pfIn);
	fclose(pfOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\APIText\apitext.cpp ===
/////////////////////////////////////////////////////////////////////////////
// apitext.cpp
//
// email		date		change
// enriquep		10/28/94	created
//
// copyright 1994 Microsoft

// apitext will take a list of files with comments (see specification below)
// and generate a text file that can be read by test wizard and cafehelp.

// comment specification:
// BEGIN_HELP_COMMENT
// Function: <return type> <class name::><function name>(<parameter list>)
// Description: <description to eol>
// Return: <return value description to eol>
// Param: <param name> <param description to eol>
// END_HELP_COMMENT

#include "stdafx.h"
#include "apitext.h"

CParamList paramList;
CStringArray strParamArray;
CStringArray strFinalParamArray;

void main(int argc, char **argv)
{
	CStringList listFiles;
	CStdioFile fTXT;

	// process cmd line args
	if (ProcessCmdLine(argc, argv))
	{

		// read the list of files
		if (ReadFileList(strListFile, listFiles))
		{

			// open the TXT file
			if (fTXT.Open(strTXTFile, CFile::modeCreate | CFile::modeWrite))
			{

				// iterate through each file in the list and read all comment blocks
				for (POSITION pos = listFiles.GetHeadPosition(); pos != NULL; )
				{
					ProcessCommentBlocks(listFiles.GetNext(pos), fTXT);
				}

				// close the TXT file
				fTXT.Close();
			}
			else 
			{
				Error("Unable to open the TXT file (%s).", (LPCTSTR)strTXTFile);
			}
		}
		else {
			Error("Unable to open the list of files (%s).", (LPCTSTR)strListFile);
		}
	}
	else {
		Usage();
	}

	// success
	// exit(0);
}

BOOL ReadFileList(CString strFilename, CStringList &listFiles)
{
	CStdioFile fList;
	CString strBuffer;

	// clear the list of files
	listFiles.RemoveAll();

	Debug("Reading file list (%s)", (LPCTSTR)strFilename);

	// open the file list file for reading
	if (fList.Open(strFilename, CFile::modeRead))
	{

		// read each line from the file until eof is reached
		while (fList.ReadString(strBuffer.GetBuffer(512), 511))
		{
			strBuffer.ReleaseBuffer();

			// allow a semicolon (;) as the first character to denote the line as a comment
			if (strBuffer.GetAt(0) != ';')
			{

				// remove trailing \n
				strBuffer = EliminateTrailingChars(strBuffer, "\n");

				// add this filename to the list of files
				listFiles.AddTail(strBuffer);
			}
		}

		// close the file list file
		fList.Close();

		return TRUE;
	}

	return FALSE;
}

void ProcessCommentBlocks(CString strFilename, CStdioFile &fTXT)
{
	Debug("Processing file (%s)", (LPCTSTR)strFilename);

	CStdioFile fSrc;
	BOOL bComment = FALSE;
	BOOL bReadingComment = FALSE;
	BOOL bLookingForFunctionDecl = FALSE;

	CString strFuncBlock;
	CString strReturnBlock;
	CString strDescBlock;
	CString strParamBlock;

	// open the file
	if (fSrc.Open(strFilename, CFile::modeRead))
	{
		int nLine = 0;
		CString strLine;
		BOOL fFunction = FALSE;
		BOOL fDescription = FALSE;
		BOOL fReturn = FALSE;
		int nParams = 0;	// Counts the number of Param lines in a block

		// read each line from the file until eof
		while (fSrc.ReadString(strLine.GetBuffer(512), 511))
		{
			strLine.ReleaseBuffer();
			nLine++;

			// are we currently reading a comment?
			if (bReadingComment)
			{

				// figure out which description it is
				
				// ClassName or BaseClass or Category?
				if ( (strLine.Find(cstrClassName) != -1) || (strLine.Find(cstrBaseClass) != -1) || (strLine.Find(cstrCategory) != -1) )
				{
					fTXT.WriteString(strLine);
					continue;
				}
				// End of Class Help comment
				if ( strLine.Find(cstrEndClassHelp) != -1 )
				{
					bReadingComment = FALSE;
					// REVIEW: Compare block info with class declaration
					bLookingForFunctionDecl = FALSE; 
					fTXT.WriteString(strLine);
					continue;
				}
					 
		
				// end of API comment?
				if (strLine.Find(cstrEndComment) != -1)
				{
					bReadingComment = FALSE;
					// Compare block info with function declaration
					bLookingForFunctionDecl = TRUE; 
				}
				else 
				{
					// function?
					if (strLine.Find(cstrFunction) != -1)
					{
						// be sure this line isn't entered twice in the same block
						if (!fFunction)
						{
							strFuncBlock = strLine;
							fFunction = TRUE;
						}
						// function line occured more than once in the same block
						else 
						{
							Warning("Multiple %s entries, ignoring this entry (%s, %d).", (LPCTSTR)cstrFunction, (LPCTSTR)strFilename, nLine);
						}
					}
					else 
					{
						// description?
						if (strLine.Find(cstrDescription) != -1) 
						{
							// we must have a function line before a description
							if (fFunction) 
							{
								// be sure this line isn't entered twice in the same block
								if (!fDescription) 
								{
									strDescBlock = strLine;
									fDescription = TRUE;
								}
								// description line occurs more than once in the same block
								else 
								{
									Warning("Multiple %s entries, ignoring this entry (%s, %d).", (LPCTSTR)cstrDescription, (LPCTSTR)strFilename, nLine);
								}
							}
							// must have function line before description
							else 
							{
								Warning("%s line before %s, ignoring this entry (%s, %d).", (LPCTSTR)cstrDescription, (LPCTSTR)cstrFunction, (LPCTSTR)strFilename, nLine);
							}
						}
						else 
						{
							// return?
							if (strLine.Find(cstrReturn) != -1) 
							{
								// we must have a function line before return
								if (fFunction) 
								{
									// be sure this line isn't entered twice in the same block
									if (!fReturn) 
									{
										strReturnBlock = strLine;
										fReturn = TRUE;
									}
									// return line occurs more than once in the same block
									else 
									{
										Warning("Multiple %s entries, ignoring this entry (%s, %d).", (LPCTSTR)cstrReturn, (LPCTSTR)strFilename, nLine);
									}
								}
								// must have function line before return
								else 
								{
									Warning("%s line before %s, ignoring this entry (%s, %d).", (LPCTSTR)cstrReturn, (LPCTSTR)cstrFunction, (LPCTSTR)strFilename, nLine);
								}
							}
							else 
							{
								// parameter?
								if (strLine.Find(cstrParam) != -1) 
								{
									// we must have a function line before a parameter
									if (fFunction) 
									{
										CString str = strLine;
										strParamArray.Add(str);
										nParams++;
									}
									// must have function line before parameter
									else 
									{
										Warning("%s line before %s, ignoring this entry (%s, %d).", (LPCTSTR)cstrParam, (LPCTSTR)cstrFunction, (LPCTSTR)strFilename, nLine);
									}
								}
								else 
								{
									// begin comment?
									if (strLine.Find(cstrBeginComment) != -1) 
									{
										Warning("%s found within comment block (%s, %d).", (LPCTSTR)cstrBeginComment, (LPCTSTR)strFilename, nLine);
									}
									else 
									{
										Warning("Unknown line (%s, %d).", (LPCTSTR)strFilename, nLine);
									}
								}
							}
						}
					}
				}
			}
			// we're not currently reading a comment
			else 
			{
				// Are we looking for a function declaration?
				if ( bLookingForFunctionDecl && ( !strLine.IsEmpty() ) )
				{
					strFuncBlock = VerifyFuncBlockIsUpToDate(strLine, strFuncBlock);
					strReturnBlock = VerifyReturnBlockIsUpToDate(strLine, strReturnBlock);
					VerifyParamBlockIsUpToDate( strLine );

					// write out block
					fTXT.WriteString(strFuncBlock);
					fTXT.WriteString(strDescBlock);
					fTXT.WriteString(strReturnBlock);
					WriteParams(fTXT);
					fTXT.WriteString("// " + cstrEndComment + '\n');

					strFinalParamArray.RemoveAll();
					strParamArray.RemoveAll();


					bLookingForFunctionDecl = FALSE;
				}

						
				// does this line mark the beginning of a comment?
				if ( (strLine.Find(cstrBeginComment) != -1) || (strLine.Find(cstrBeginClassHelp) != -1) )
				{
					// start of a comment block
					// mark that we found at least one comment in this file
					bComment = TRUE;
					// mark that we're now reading a comment
					bReadingComment = TRUE;
					// write out begin comment indicator
					fTXT.WriteString(strLine);
					// mark indicators as false
					fFunction = FALSE;
					fDescription = FALSE;
					fReturn = FALSE;
					nParams = 0;
				}
			}
		}

		// close the file
		fSrc.Close();

		// if we still think we're reading a comment, let the user know
		if (bReadingComment) 
		{
			Warning("No %s found before reaching end of file (%s).", (LPCTSTR)cstrEndComment, (LPCTSTR)strFilename);
		}

		// if we didn't find any comment blocks in the file, let the user know
		if (!bComment) 
		{
			Warning("No comment blocks found in file (%s).", (LPCTSTR)strFilename);
		}
	}
	// unable to open the file
	else 
	{
		Warning("Unable to open file to read comment blocks (%s).", (LPCTSTR)strFilename);
	}
}

void ReadParams(CString strLine)
{
	Debug("Reading Params in function: %s", (LPCSTR)strLine);
	
	ASSERT(!strLine.IsEmpty());
	
	paramList.RemoveAll();

    int iParam = 0;
	int nSeparator = strLine.Find("(");
	strLine = strLine.Mid(nSeparator + 1);   //  skip to open parenthesis
	nSeparator = strLine.SpanIncluding(" ").GetLength();
	strLine = strLine.Mid(nSeparator);   //  skip all spaces 

	if ( (strLine.Find("void") != -1) && (strLine.Find("*") == -1) )	// REVIEW: Will this work with params of type void
		return;			// takes no parameters	or uses PARAM to fill them in
	
	while( strLine[0] != ')' && strLine[0] != '\0' )
	{
		CParam* pParam = new CParam;
		while ( (iParam % 3) < 2)		// Only do this loop 2 times
		{
			nSeparator = strLine.FindOneOf(", \t=/)");
			if (nSeparator == -1)
			{
				Warning("Unexpected end of parameter list in (%s)", strLine);
				goto IncompleteParams;
			}
			switch( (iParam++) & (0x0001) )				  // REVIEW: We assume only 1 param type
			{
				case 0:		// parameter type
					pParam->m_strType = strLine.Left(nSeparator);
					break;
				case 1:		// parameter name
					pParam->m_strName = strLine.Left(nSeparator);
					break;
			}
			
			strLine = strLine.Mid(nSeparator);
			nSeparator = strLine.SpanIncluding(", \t").GetLength();	// advance to next '=' '*' '/' or param type
			strLine = strLine.Mid(nSeparator);

			while (strLine[0] == '*')
			{
				pParam->m_strType += '*';
				strLine = strLine.Mid(1); // Skip '*'
			}

			if ((strLine[0] == '=') || (strLine[0] == '/'))	// Look for default values
			{
				nSeparator = strLine.SpanIncluding("= /*\t").GetLength();	// advance to next '=' '*' '/' or param type
				strLine = strLine.Mid(nSeparator);
				nSeparator = strLine.FindOneOf(" *\t)");		
				pParam->m_strValue = strLine.Left(nSeparator);		// Store Default Value
				strLine = strLine.Mid(nSeparator);
				nSeparator = strLine.SpanIncluding(",*/ \t").GetLength();	// advance to next '=' '*' '/' or param type
				strLine = strLine.Mid(nSeparator);
			}  
		}
		paramList.AddTail(pParam);					// Add Param to list.
		iParam = 0;									// Reset so more parameters can be read.
	}
	IncompleteParams:	iParam = 0;
}

void WriteParams( CStdioFile &fTXT )
{
	Debug("Writing Parameters:");
	
	int nParam = strFinalParamArray.GetSize();
	
	for ( int i=0; i< nParam; i++)
	{
		fTXT.WriteString(strFinalParamArray[i]);
	}	
}

CString VerifyFuncBlockIsUpToDate(CString strLine, CString strFuncBlock)
{
	// Get Function Declaration, assumes it comes after END_HELP_COMMENT

	// Compare Function declarations
	int nStart = 0;

	if( strFuncBlock.Find("Function:") != -1)
	{
		nStart = strFuncBlock.Find(':');
		strFuncBlock = strFuncBlock.Mid( nStart + 1);
		//  skip all spaces to the Function return type
		nStart = strFuncBlock.SpanIncluding(" \t").GetLength();
		strFuncBlock = strFuncBlock.Mid(nStart);
		   
		//  skip all spaces to the Function return type
		nStart = strLine.SpanIncluding(" ").GetLength();
		strLine = strLine.Mid(nStart);   
		
		if (strLine != strFuncBlock)		// If they don't match update block with latest declaration
			Warning("Function block (%s) was out of date", strFuncBlock);
	}
	else
		Warning("Invalid Function block: (%s)", strFuncBlock);  // The key word Function: is not in block
	strFuncBlock = "// Function: " + strLine;  // Update Function block with latest declaration.
	return( strFuncBlock );
}

CString VerifyReturnBlockIsUpToDate(CString strLine, CString strReturnBlock)
{
	// Get Function Declaration, assumes it comes after END_HELP_COMMENT

	int nStart = 0;
		
	//  skip all spaces to the Function return type
	nStart = strLine.SpanIncluding(" \t").GetLength();
	strLine = strLine.Mid(nStart);
	//  get type
	nStart = strLine.FindOneOf(" \t");
	ASSERT( nStart >= 0);
	CString strReturn = strLine.Left( nStart );
	strLine = strLine.Mid ( nStart );
	//  skip spaces and look if the next char is *
	nStart = strLine.SpanIncluding(" \t").GetLength();
	strLine = strLine.Mid(nStart);
	if (strLine[0] == '*')
		strReturn = strReturn + '*';  // It is a * return type
	
	// Search for Return type in Return block
	if (strReturnBlock.Find(strReturn.GetBuffer( strReturn.GetLength() )) == -1)
	{
		Warning("Return type (%s) not found in Return Block", strReturn);
		strReturnBlock = "// Return: " + strReturn + '\n';  // Update Return type
	}

	if( strReturnBlock.Find("Return:") == -1)
	{
		Warning("Invalid Return block in cpp file: (%s)", strReturnBlock);  // The key word Return: is not in block
		strReturnBlock = "// Return: " + strReturn + '\n';  // Correct problem
	}
	
	return (strReturnBlock);
}

void VerifyParamBlockIsUpToDate( CString strLine )
{
	// Get Function Declaration, assumes it comes after END_HELP_COMMENT

	ReadParams(strLine);	// Loads declared params into Param List
	
	POSITION pos = paramList.GetHeadPosition();
	int nParam = strParamArray.GetSize();
	BOOL bIsListed = FALSE;
	int index = 0;

	if (paramList.IsEmpty())
	{
		CString str = "// Param: void, takes no parameters \n";
		strFinalParamArray.Add( str );  // Create new param block
		return;
	}
	
	while (pos != NULL)
	{
		CParam* pParam =  paramList.GetNext(pos);
		for (int i = 0; i < nParam; i++)
		{
			if (strParamArray[i].Find( pParam->m_strName.GetBuffer(pParam->m_strName.GetLength())) != -1 )
			{
				bIsListed = TRUE;
				index = i;
				break;
			}
		}

		if (bIsListed)
		{
			CString str = strParamArray[index];
			strFinalParamArray.Add( str );   // Keep param block
		}
		else
		{
			CString str = "// Param: "+pParam->m_strName + '\n';
			strFinalParamArray.Add( str );  // Create new param block
		}
		
		bIsListed = FALSE;
	}
}
			

CString EliminateLeadingChars(CString str, CString strSet)
{
	while (str.FindOneOf(strSet) == 0) {
		str = str.Mid(1);
	}
	return str;
}

CString EliminateTrailingChars(CString str, CString strSet)
{
	while (str.FindOneOf(strSet) == str.GetLength()-1) {
		str = str.Left(str.GetLength()-1);
	}
	return str;
}


void Error(LPCSTR szMsg, ...)
{
	char szBuf[512];

	va_list marker;
	va_start(marker, szMsg);
	_vsnprintf(szBuf, 512, szMsg, marker);
	va_end(marker);

	fprintf(stderr, "apitext Error: %s\n", szBuf);
	//exit(-2);  This is causing a crash
}

void Warning(LPCSTR szMsg, ...)
{
	char szBuf[512];

	va_list marker;
	va_start(marker, szMsg);
	_vsnprintf(szBuf, 512, szMsg, marker);
	va_end(marker);

	fprintf(stderr, "apitext Warning: %s\n", szBuf);
}

void Debug(LPCSTR szMsg, ...)
{
	#ifdef _DEBUG

		char szBuf[512];

		va_list marker;
		va_start(marker, szMsg);
		_vsnprintf(szBuf, 512, szMsg, marker);
		va_end(marker);

		fprintf(stderr, "apitext Debug: %s\n", szBuf);
	#else
		UNREFERENCED_PARAMETER(szMsg);
	#endif // _DEBUG
}

BOOL ProcessCmdLine(int argc, char **argv)
{
	Debug("Processing command line args.");

	int i;

	// loop through args
	for (i = 1; i < argc; i++) {

		// ignore preceeding - or / by looking at second char
		switch (argv[i][1]) {
			// set the list file
			case 'l': {
				// parameter following this switch is the filename
				i++;
				if (i < argc) {
					strListFile = argv[i];
				}
				else {
					Usage();
					return FALSE;
				}
				break;
			}
			// set the output file
			case 'o': {
				// parameter following this switch is the filename
				i++;
				if (i < argc) {
					strTXTFile = argv[i];
				}
				else {
					Usage();
					return FALSE;
				}
				break;
			}
			case '?': {
				// display usage information
				Usage();
				return FALSE;
			}
			default: {
				Warning("Unrecognized switch: %s", argv[i]);
				Usage();
				return FALSE;
			}
		}
	}

	Debug("File list filename = %s", strListFile);
	Debug("RTF filename = %s", strTXTFile);

	return TRUE;
}

void Usage(void)
{
	fprintf(stdout, "\nCAFE API Text File Generation System\n");
	fprintf(stdout, "Copyright 1994 Microsoft\n\n");
	fprintf(stdout, "Usage: apitext [-l <filename> -o <filename> -?]\n");
	fprintf(stdout, "-l <filename> : specify filename of file containing list of files to parse\n");
	fprintf(stdout, "  (defaults to apitext.lst)\n");
	fprintf(stdout, "-o <filename> : specify filename of output file\n");
	fprintf(stdout, "  (defaults to apidata.txt)\n");
	fprintf(stdout, "-? : displays this usage message\n");
	#ifdef _DEBUG
		fprintf(stdout, "\n(debug build)\n");
	#endif // _DEBUG

	exit(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\APIText\stdafx.cpp ===
/////////////////////////////////////////////////////////////////////////////
// stdafx.cpp
//
// email	date		change
// enriquep	10/28/94	created
//
// copyright 1994 Microsoft

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Bin\Test\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__
#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\APIText\stdafx.h ===
/////////////////////////////////////////////////////////////////////////////
// stdafx.h
//
// email	date		change
// enriquep	10/28/94	created
//
// copyright 1994 Microsoft

#include <afx.h>
#include <afxcoll.h>
// #include <afxext.h>         // MFC extensions
#include <afxtempl.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Bin\Test\testcase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	testcase.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "testcase.h"					 	 
											   
#define VERIFY_TEST_SUCCESS(TestCase)\
	TestCase == ERROR_SUCCESS
												 
IMPLEMENT_GET_NAME(TestTestSet, "TestWizard Generated script", NULL)
IMPLEMENT_GET_NUM_TESTS(TestTestSet, 1, 1)

TestTestSet::TestTestSet()
{
}

int TestTestSet::Run(void* pData /*=NULL*/)
{
BEGIN_TESTSET();


TestCase1( );

return EndTestSet();	// returns how many failed in this test set
}


 

BOOL TestTestSet::TestCase1( )
{
	COProject  proje;
	proje.New( szProjName, ProjType );
	proje.GetErrorCount( );
	proje.Save( );
	WriteWarning("");
	 
	return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Bin\Test\testcase.h ===
///////////////////////////////////////////////////////////////////////////////
//	testcase.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the TestTestSet Class
//

#ifndef __CLWCASES_H__
#define __CLWCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
//	TestTestSet class

class TestTestSet : public CTestSet
{
public:
	TestTestSet();

// Attributes
public:
	DECLARE_GET_NAME();
	DECLARE_GET_NUM_TESTS();

// Operations
public:
	virtual int Run(void* pData = NULL);

// Data
protected:

// Test Cases
protected:

	virtual BOOL TestCase1( );
};

#endif //__CLWCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Bin\Test\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\APIText\apitext.h ===
/////////////////////////////////////////////////////////////////////////////
// apitext.h
//
// email	date		change
// enriquep	10/28/94	created
//
// copyright 1994 Microsoft


// RTF filename
CString strListFile = "apitext.lst";
CString strTXTFile = "apidata.txt";

// comment block constants

const CString cstrBeginClassHelp = "BEGIN_CLASS_HELP";
const CString cstrEndClassHelp = "END_CLASS_HELP";
const CString cstrClassName = "ClassName:";
const CString cstrBaseClass = "BaseClass:";
const CString cstrCategory = "Category:";

const CString cstrBeginComment = "BEGIN_HELP_COMMENT";
const CString cstrEndComment = "END_HELP_COMMENT";
const CString cstrFunction = "Function:";
const CString cstrDescription = "Description:";
const CString cstrReturn = "Return:";
const CString cstrParam = "Param:";

// prototypes
void Error(LPCSTR szMsg, ...);
void Warning(LPCSTR szMsg, ...);
void Debug(LPCSTR szMsg, ...);
BOOL ProcessCmdLine(int argc, char **argv);
void Usage(void);

BOOL ReadFileList(CString strFilename, CStringList &listFiles);
void ProcessCommentBlocks(CString strFilename, CStdioFile &file);
CString EliminateLeadingChars(CString str, CString strSet);
CString EliminateTrailingChars(CString str, CString strSet);
void ReadParams(CString strLine);
void WriteParams(CStdioFile &fTXT);
CString VerifyFuncBlockIsUpToDate(CString strLine, CString strFuncBlock);
CString VerifyReturnBlockIsUpToDate(CString strLine, CString strReturnBlock);
void VerifyParamBlockIsUpToDate( CString strLine );

/////////////////////////////////////////////////////////////////////////////
// CParam

class CParam
{
public:
    CParam();
    ~CParam();
// Attributes
public:
	CString m_strName;
    CString m_strType;
    CString m_strValue;

// Operations
};

typedef CTypedPtrList<CPtrList, CParam*> CParamList;

CParam::CParam()
{
}

CParam::~CParam()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Bin\Test\testtype.h ===
///////////////////////////////////////////////////////////////////////////////
//	testtype.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the TestDriver class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __WBDRV_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// TestDriver class

class TestDriver : public CWBDriver
{
public:
	TestDriver();

	DECLARE_TESTSET_MAP();

// Event Sequence
public:
 	virtual BOOL InitializeTest( void );
	virtual BOOL RunTests( void );
	virtual BOOL FinalizeTest( void );

// Internal Workings
protected:

// Utility Functions
protected:

// Generated message map functions
protected:
	//{{AFX_MSG(TestDriver)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Bin\Test\testtype.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	testcase.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the TestDriver class
//

#include "stdafx.h"
#include "testtype.h"

#include "testcase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// The one and only TestDriver object

TestDriver NEAR theApp;
CWBDebugThread NEAR theDebugThread;

/////////////////////////////////////////////////////////////////////////////
// TestDriver

BEGIN_TESTSET_MAP(TestDriver)
	TESTSET(TestTestSet, TRUE)
END_TESTSET_MAP()

TestDriver::TestDriver()
{
}

BOOL TestDriver::InitializeTest( void )
{
	if( !CWBDriver::InitializeTest() )
		return FALSE;
	//TODO: Replace XXX with name of sniff test (e.g. VPROJ, VRES, etc.)
	//TODO: Replace OWNER with email name of owner
	return m_Log.BeginLog( "TestWizard Generated script", "VCBU QA", "BVT", m_bDebug, m_bPost );
}

BOOL TestDriver::RunTests()
{
	return RunTestsInOrder() == 0;
}

BOOL TestDriver::FinalizeTest( void )
{
	m_Log.EndLog();
	return CWBDriver::FinalizeTest();
}

BEGIN_MESSAGE_MAP(TestDriver, CWBDriver)
	//{{AFX_MSG_MAP(TestDriver)
	//}}AFX_MSG_MAP
	// Standard file based document commands
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Src\apitabdl.cpp ===
// apitabdl.cpp : implementation file
//

#include "stdafx.h"
#include "testwiz.h"
#include "data.h"
#include "scriptr.h"
#include "apitabdl.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// ApiTabdlg property page

extern TEXTMETRIC tm ;
extern int cxChar, cxCaps, cyChar ;

// Pens and Brushes we need to show selections.
extern CBrush brSelRect ;
extern CBrush brUnSelRect ;
extern CPen   penUnSelRect ;
extern CPen   penSelRect ;
extern CBitmap bmapUnCheck, bmapCheck, bmapTriangle, bmapNomoreItems, bmapMoreItems, bmapNone , bmapTestCase, bmapWarn;								 
CRect CasesListRect ;
BOOL MoveStartedInScriptBox = FALSE ;
BOOL WasInMotion = FALSE ;	

IMPLEMENT_DYNCREATE(ApiTabdlg, CPropertyPage)

ApiTabdlg::ApiTabdlg()
	: CPropertyPage(ApiTabdlg::IDD)
{
	//{{AFX_DATA_INIT(ApiTabdlg)
	m_HideVarsBraces = FALSE;
	m_ScriptItemTxt = _T("");
	m_iDisplayClassNames = FALSE;
	//}}AFX_DATA_INIT
}

ApiTabdlg::~ApiTabdlg()
{
}

void ApiTabdlg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(ApiTabdlg)
	DDX_Control(pDX, IDC_SCRIPTTEXT, m_ScriptItemCtrl);
	DDX_Control(pDX, IDC_DIRECTIVES, m_directivesList);
	DDX_Control(pDX, IDC_ADD, m_AddButton);
	DDX_Check(pDX, IDC_HIDE, m_HideVarsBraces);
	DDX_Control(pDX, IDC_DESCRIPTION, m_apiDescription);
	DDX_Control(pDX, IDC_LIST_PARAMETERS, m_parameterList);
	DDX_Control(pDX, IDC_LIST_API, m_apiList);
	DDX_Control(pDX, IDC_CATEGORY, m_categoryCB);
	DDX_CBString(pDX, IDC_CATEGORY, m_category);  
	DDX_Text(pDX, IDC_SCRIPTTEXT, m_ScriptItemTxt);
	DDX_Check(pDX, IDC_CLASS_NAME, m_iDisplayClassNames);
	//}}AFX_DATA_MAP
}



BEGIN_MESSAGE_MAP(ApiTabdlg, CPropertyPage)

	//{{AFX_MSG_MAP(ApiTabdlg)
	ON_CBN_SELCHANGE(IDC_CATEGORY, OnSelchangeCategory)
	ON_LBN_DBLCLK(IDC_LIST_AREAS, OnDblclkListAreas)
	ON_LBN_SELCHANGE(IDC_LIST_AREAS, OnSelchangeListAreas)
	ON_LBN_SELCHANGE(IDC_LIST_API, OnSelchangeListApi)
	ON_LBN_DBLCLK(IDC_LIST_API, OnDblclkListApi)
	ON_BN_CLICKED(IDC_ADD, OnAdd)
	ON_LBN_DBLCLK(IDC_SCRIPTLIST, OnDblclkScriptlist)
	ON_WM_RBUTTONDOWN()
	ON_WM_PARENTNOTIFY()
	ON_COMMAND(ID_POPUP_DELETE, OnPopupDelete)
	ON_COMMAND(ID_POPUP_WARN, OnPopuupWarnings)
	ON_BN_CLICKED(IDC_HIDE, OnHideVarsAndBraces)
	ON_WM_PAINT()
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONUP()
	ON_WM_LBUTTONDOWN()
	ON_BN_CLICKED(IDC_MOVE_DOWN, OnMoveDown)
	ON_BN_CLICKED(IDC_MOVE_UP, OnMoveUp)
	ON_LBN_DBLCLK(IDC_DIRECTIVES, OnDblclkDirectives)
	ON_BN_CLICKED(IDC_NEWTESTCASE, OnNewtestcase)
	ON_LBN_SELCHANGE(IDC_SCRIPTLIST, OnSelchangeScriptlist)
	ON_WM_VKEYTOITEM()
	ON_WM_KEYDOWN()
	ON_LBN_SETFOCUS(IDC_LIST_API, OnSetfocusListApi)
	ON_LBN_KILLFOCUS(IDC_LIST_API, OnKillfocusListApi)
	ON_BN_CLICKED(IDC_CLASS_NAME, OnDisplayClassNames)
	ON_LBN_SELCHANGE(IDC_LIST_PARAMETERS, OnSelchangeListParameters)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// ApiTabdlg operations


void ApiTabdlg::DisplayAreas()
{
    m_areaList.ResetContent();
    CString str;
	int nAreas = m_areaArray.GetUpperBound();
	for (int i=0; i <= nAreas; i++) 
	{
		str = m_areaArray[i]->m_strName;
		if (m_category == m_areaArray[i]->m_strCategory)
		{
			int index = m_areaList.AddString(str);
			m_areaList.SetItemData(index,(DWORD)bmapUnCheck.GetSafeHandle());
		}
	}
    m_areaList.SetCurSel(0);
}

UINT ApiTabdlg::OpenAPIData(LPCSTR szFileName, UINT nFileType /*= API_FT_TEXT */)
{
	ASSERT( szFileName != NULL );
    ASSERT( m_apiArray.GetSize() == 0 );
   
	TRY                             // REVIEW:Use true exceptions
	{
		CStdioFile file(szFileName, CFile::modeRead | CFile::typeText);
		char acLine[512];
		while( file.ReadString(acLine, 511) != NULL )
			InterpretLine(acLine);
	}
	CATCH(CFileException, e)
	{
		AfxMessageBox(IDS_ERROR_CANT_OPEN);
		return FALSE;
	}
	END_CATCH;
	return TRUE;
}   

BOOL ApiTabdlg::InterpretLine(LPCSTR szNewLine)
{
	char* sz = new char[strlen(szNewLine) + 1];		 
	strcpy(sz, szNewLine);
	char* pCleanStr = sz;
	pCleanStr = RemoveExtraChars( pCleanStr );

	if (pCleanStr[0] == '\0')       // delete string if is empty line
	{
		delete[] sz;
		return FALSE;
	}

    FillStructures(pCleanStr);
	return TRUE;
}

char* ApiTabdlg::RemoveExtraChars(char* pchLine) 	  // REVIEW (EnriqueP): Move this code to CFileTableLine::CFileTableLine(pchStr)
{
	int iCRLF = strcspn(pchLine, "\'\r\n");	 // remove trailing comments , CR or LF
	pchLine[iCRLF] = '\0';
	pchLine += strspn(pchLine, "\t /");	// Remove leading spaces, tabs or "//"
	return pchLine;
}


void ApiTabdlg::FillStructures( LPCSTR szLine )
{
    ASSERT(szLine[0] != '\0');
	while( szLine[0] != '\0' )
	{
		int nSeparator = strcspn(szLine, ": \t");
        CString strLineType =  CString(szLine, nSeparator); // Get first word
        szLine = szLine + nSeparator + strspn(szLine + nSeparator, ": \t");  // Advance to next word
		strLineType.MakeUpper();
		
		if (strLineType == "CLASSNAME")			
            szLine = FillClassStruct(szLine);
	    if (strLineType == "BASECLASS")
            szLine = FillBaseClassStruct(szLine);
		if (strLineType == "CATEGORY")
            szLine = SetCurrentCategory(szLine);	

        if (strLineType == "FUNCTION" )
            szLine = FillAPIStruct(szLine);
		if (strLineType == "DESCRIPTION" )
            szLine = FillDescStruct(szLine);
        if (strLineType == "RETURN" )
            szLine = FillReturnStruct(szLine);
		if (strLineType == "PARAM" )
			if (m_bIsOldFormat)
				szLine = FillParamStruct(szLine);		
			else
				szLine = FillParamDescStruct(szLine);
//		Old formats
		if (strLineType == "API" )
		{
			m_bIsOldFormat = TRUE;
            szLine = FillAPIStruct(szLine);
		}
		if (strLineType == "AREA")
		{
			m_bIsOldFormat = TRUE;
            szLine = FillAreaStruct(szLine);
		}
        if (strLineType == "SUBAREA" )
		{
			m_bIsOldFormat = TRUE;
            szLine = FillSubareaStruct(szLine);
		}
// We skip any BEGIN_ OR END_ keywords
	}	
		
}

LPCSTR ApiTabdlg::SetCurrentCategory(LPCSTR szLine)	//REVIEW: Change to FillCategoryStruct()
{
	//DefaultAreaCtor();  
    ASSERT(szLine[0] != '\0');
	int nSeparator = strcspn(szLine, "\0 ");
	m_strCurrentCategory = CString(szLine,nSeparator);

    // REVIEW: Remove string table.

	// Check category is not already in combobox.
	int nStartAt = m_categoryCB.GetCount() - 1;
	int index = m_categoryCB.FindStringExact( nStartAt, m_strCurrentCategory.GetBuffer(m_strCurrentCategory.GetLength()) );
	m_strCurrentCategory.ReleaseBuffer();

	if (index == CB_ERR)
		m_categoryCB.AddString(m_strCurrentCategory);	// Add to Combo box if is not already there
	
	index = FindArea();  // REVIEW: Make sure index is not invalid. Old format will make it fail
    m_areaArray[index]->m_strCategory = m_strCurrentCategory;   
    
	szLine = szLine + nSeparator;  // REVIEW: Is this needed?

    return (szLine);
}


LPCSTR ApiTabdlg::FillAreaStruct(LPCSTR szLine)
{
	//DefaultAreaCtor();  
    ASSERT(szLine[0] != '\0');
	int nSeparator = strcspn(szLine, "\0 ");
	m_strCurrentArea = CString(szLine,nSeparator);

    // REVIEW: Search to see if the area has already been entered
    CArea* pArea = new CArea;
	pArea->m_strCategory = m_strCurrentCategory;
    pArea->m_strName = m_strCurrentArea;   
    m_areaArray.Add(pArea);
    
    szLine = szLine + nSeparator;  

    return (szLine);
	
}


LPCSTR ApiTabdlg::FillClassStruct(LPCSTR szLine)
{
    ASSERT(szLine[0] != '\0');
	int nSeparator = strcspn(szLine, "\0 ");
	m_strCurrentArea = CString(szLine,nSeparator);	// current class

    CArea* pArea = new CArea;
//	pArea->m_strCategory = m_strCurrentCategory;
    // REVIEW: Search to see if the area has already been entered

    pArea->m_strName = m_strCurrentArea;   
    m_areaArray.Add(pArea);
    
    szLine = szLine + nSeparator;  // REVIEW: Is this needed?

    return (szLine);
	
}

LPCSTR ApiTabdlg::FillBaseClassStruct(LPCSTR szLine)
{
    ASSERT(szLine[0] != '\0');
	int nSeparator = strcspn(szLine, "\0 ");
	CString strBaseClass = CString(szLine,nSeparator);
    

    // Search for current area (class) and add subarea to its list of subareas.
    int index = FindArea();  
    m_areaArray[index]->m_strBaseClass = strBaseClass;   
  
  	szLine = szLine + nSeparator;  // REVIEW: Is this needed?
    return (szLine);
}


LPCSTR ApiTabdlg::FillSubareaStruct(LPCSTR szLine)
{
    ASSERT(szLine[0] != '\0');
	int nSeparator = strcspn(szLine, "\0 ");
	CString strSubarea = CString(szLine,nSeparator);
    m_strCurrentSubarea = strSubarea; 
    
    szLine = szLine + nSeparator;  

    // REVIEW: Search for current area and add subarea to its list of subareas.
    int index = FindArea();
    ASSERT(index != -1); // There should be a matching Area in the array
    /* BOOL b = m_arreaArray[index].FindSubarea(m_currentSubArea);  
    if (b) 
        return (szLine); // if subarea already in list don't add another one.  */

    m_areaArray[index]->m_strListSubarea.AddTail(strSubarea);   //REVIEW: Possible bug
    
    return (szLine);
	
 }

LPCSTR ApiTabdlg::FillAPIStruct(LPCSTR szLine)
{
    ASSERT(szLine[0] != '\0');

	CAPI* pAPI = new CAPI;

	if (m_bIsOldFormat)
	{
		pAPI->m_strArea = m_strCurrentArea;			// Old Format
		pAPI->m_strSubarea = m_strCurrentSubarea;
	}
	else
	{
		pAPI->m_strArea = "Unassigned";	// There are no matching Class Names for this API
	}

    int iToken = 0;
	int nSeparator;
	while( szLine[0] != '\0' )
	{
		nSeparator = strcspn(szLine, "(: \t");
		switch( iToken++ )
		{
			case 0:		// parameter 1 : return value
				pAPI->m_strReturnVal += CString(szLine, nSeparator);
				if ( (pAPI->m_strReturnVal == "static") || (pAPI->m_strReturnVal == "virtual") || (pAPI->m_strReturnVal == "const"))
				{
					pAPI->m_strReturnVal+=' ';  // add modifier + return value,ei. virtual int
					iToken = 0;					// the next word is the actual type
				}
				break;
			case 1:		// parameter 2 : class name
				if (szLine[nSeparator] != ':')		// See if the separator is a :: 
				{
					pAPI->m_strClass.Empty();	// No class name, it's not a member function
					if (!m_bIsOldFormat)
						pAPI->m_strArea = "Globals";
					pAPI->m_strName = CString(szLine, nSeparator);
					m_strCurrentAPI = pAPI->m_strName;
					iToken++;
				}
				else
				{
					pAPI->m_strClass = CString(szLine, nSeparator);
					if (!m_bIsOldFormat)
						pAPI->m_strArea = CString(szLine, nSeparator);
				}
				break;
			case 2:		// parameter 3 : API name
				pAPI->m_strName = CString(szLine, nSeparator);
				m_strCurrentAPI = pAPI->m_strName;
				break;
			case 3:		// parameter 4 : Parameters		
				szLine = FillParamStruct(szLine, pAPI);
				nSeparator = 0;  // szLine already points to ')'
				// REVIEW: Add code here to fill param struct if necessary
				break;
			case 4:		// parameter 5 : Description 
				nSeparator = strcspn(szLine, "\0");
				pAPI->m_strDesc = CString(szLine, nSeparator);
				break;
		}
		szLine = szLine + nSeparator + strspn(szLine + nSeparator, "(,:) \t;");   
	}
	
	ASSERT(iToken >= 3);   // Make sure API line is not incomplete;   

	m_apiArray.Add(pAPI);

    // REVIEW: Add class to class list if not already there.
 	CString strClass = pAPI->m_strClass;
    
    return (szLine);
}

LPCSTR ApiTabdlg::FillDescStruct(LPCSTR szLine)
{
	int nSeparator = strcspn(szLine, "\0");
	CString strDescription = CString(szLine,nSeparator);

	ASSERT(m_apiArray.GetSize() != 0);

	CAPI* pAPI = m_apiArray[m_apiArray.GetUpperBound()];	// Last api in array is the current one

	ASSERT(pAPI->m_strName == m_strCurrentAPI);				
	
	pAPI->m_strDesc = strDescription;

	szLine = szLine + nSeparator;  // REVIEW: Is this needed?
    return (szLine);
}


LPCSTR ApiTabdlg::FillReturnStruct(LPCSTR szLine)
{
	int nSeparator = strcspn(szLine, "\0");
	CString strReturnDesc = CString(szLine,nSeparator);

	ASSERT(m_apiArray.GetSize() != 0);

	CAPI* pAPI = m_apiArray[m_apiArray.GetUpperBound()];	// Last api in array is the current one

	ASSERT(pAPI->m_strName == m_strCurrentAPI);				
	
	pAPI->m_strReturnDesc = strReturnDesc;

	szLine = szLine + nSeparator;  // REVIEW: Is this needed?
    return (szLine);
}



LPCSTR ApiTabdlg::FillParamStruct(LPCSTR szLine, CAPI* pAPI)
{
    ASSERT(szLine[0] != '\0');
	if (pAPI == NULL)
		ASSERT(m_apiArray.GetSize() != 0);

    int iParam = 0;
	int nSeparator = strcspn(szLine, ")");
	CString strParam = 	CString(szLine, nSeparator);
	if ( (strParam.Find("void") != -1) || ( strParam.Find("params") != -1 ))
		return szLine + nSeparator;			// takes no parameters	or uses PARAM to fill them in
	
	while( szLine[0] != ')' && szLine[0] != '\0')
	{
		CParam* pParam = new CParam;
		while ( (iParam % 3) < 2)		// Only do this loop 2 times
		{
			nSeparator = strcspn(szLine, ", \t/=)");
			switch( (iParam++) & (0x0001) )				  // REVIEW: We assume only 1 param type
			{
				case 0:		// parameter type
					pParam->m_strType = CString(szLine, nSeparator);
					break;
				case 1:		// parameter name
					pParam->m_strName = CString(szLine, nSeparator);
					break;
			}
			szLine = szLine + nSeparator + strspn(szLine + nSeparator, ", \t");	 // advance to next '=' or param type
			if (szLine[0] == '*')		// Is pointer type
			{
				pParam->m_strType += '*';
				szLine += strspn(szLine, " \t"); // advance to param name
			}
			if (szLine[0] == '=')			// old default value format
			{
				szLine += strspn(szLine, "= \t");  // advance to beginning of  default value
				nSeparator = strcspn(szLine, ", \t)");
				pParam->m_strValue = CString(szLine, nSeparator);
				szLine = szLine + nSeparator + strspn(szLine + nSeparator, ", \t");	 // advance to next param type
			}  

			if (szLine[0] == '/')			//  default value 
			{
				szLine += strspn(szLine, "=*/ \t");  // advance to beginning of  default value
				nSeparator = strcspn(szLine, ", \t*)");
				pParam->m_strValue = CString(szLine, nSeparator);
				szLine = szLine + nSeparator + strspn(szLine + nSeparator, "*/, \t");	 // advance to next param type
			}  
			
		 }
		 if (pAPI == NULL)		// Old format: From PARAM line, API is already in array
		 {
		 	ASSERT(m_apiArray.GetSize() != 0);
			m_apiArray[m_apiArray.GetUpperBound()]->m_paramList.AddTail(pParam); 
		 }
		 else
		 	pAPI->m_paramList.AddTail(pParam);		   // 	API object is created on the fly

		iParam = 0;									// Reset so more parameters can be read.
	}
	
    return (szLine);
	
 }


LPCSTR ApiTabdlg::FillParamDescStruct(LPCSTR szLine)
{
	ASSERT(m_apiArray.GetSize() != 0);

	CAPI* pAPI = m_apiArray[m_apiArray.GetUpperBound()];	// Last api in array is the current one

	ASSERT(pAPI->m_strName == m_strCurrentAPI);				
	

	int nSeparator = strcspn(szLine, "\0");
	CString strDesc = CString (szLine, nSeparator);

	szLine = szLine + nSeparator;  // REVIEW: Is this needed?

	CString strParamDesc;

	POSITION pos = pAPI->m_paramList.GetHeadPosition(); 
	
	while (pos != NULL)
	{
		strParamDesc = pAPI->m_paramList.GetAt(pos)->m_strName;
		if ( strDesc.Find(strParamDesc.GetBuffer(strParamDesc.GetLength() ) ) != -1 )	// Search for parameter name
		{
			pAPI->m_paramList.GetAt(pos)->m_strDesc = strDesc;		// Parameter found, assign description
			return szLine;
		}
		strParamDesc.ReleaseBuffer();
		pAPI->m_paramList.GetNext(pos);
	}
	
	ASSERT(TRUE);

	return szLine;
}


int ApiTabdlg::FindArea(LPCSTR szArea)
{
    CString strArea;
    if (szArea == NULL)
        strArea = m_strCurrentArea;
    else
        strArea = szArea;

    int nAreas = m_areaArray.GetUpperBound();
    for (int i=0; i <= nAreas; i++)
    {
        if (m_areaArray[i]->m_strName == strArea)
        return i;
    }

    return -1;  // Area not found
}

BOOL ApiTabdlg::IsArea(int index)
{
	CBitmap * curpbmap ;
	curpbmap = CBitmap::FromHandle((HBITMAP)m_areaList.GetItemData(index)) ;
	if (curpbmap->GetSafeHandle() != bmapTriangle.GetSafeHandle() )
		return TRUE;
	else
		return FALSE;
}

void ApiTabdlg::ExpandArea(int index, BOOL bExpand)
{
	if (bExpand)
	{
		m_areaList.SetItemData(index,(DWORD)bmapCheck.GetSafeHandle());
		DisplaySubareas(index);
	}
	else
	{
		m_areaList.SetItemData(index,(DWORD)bmapUnCheck.GetSafeHandle());
		HideSubareas(index);
	}
}

void ApiTabdlg::DisplaySubareas( int index, int i )
{
	CString	strText;
	m_areaList.GetText(index, strText);
	if (i == -1)
		i = FindArea(strText); 
	ASSERT( i != -1 );
	CString strNew;
	POSITION pos = m_areaArray[i]->m_strListSubarea.GetHeadPosition();
	while (pos != NULL )
	{
		strNew =  m_areaArray[i]->m_strListSubarea.GetNext(pos);
		index++;
		index = m_areaList.InsertString(index, strNew );
	 	m_areaList.SetItemData(index, (DWORD)bmapTriangle.GetSafeHandle()) ;	
	}
}

void ApiTabdlg::HideSubareas( int index, int i )
{
	CString	strText;
	m_areaList.GetText(index, strText);
	if (i == -1)
		i = FindArea(strText);
	POSITION pos = m_areaArray[i]->m_strListSubarea.GetHeadPosition();
	index++;
	while (pos != NULL)
	{
		m_areaList.DeleteString(index);
		m_areaArray[i]->m_strListSubarea.GetNext(pos);
	}
}

void ApiTabdlg::DisplayAreaAPIs( int index )
{
	CString	strArea;
	CString strNew;
	CString strClass;
	m_areaList.GetText(index, strArea);
	int nLast = m_apiArray.GetUpperBound();

	m_apiList.ResetContent();
	for (int i=0; i <= nLast; i++)
	{
		if (m_apiArray[i]->m_strArea == strArea)
		{
			strClass = 	m_apiArray[i]->m_strClass;
			if (!m_apiArray[i]->m_strClass.IsEmpty()) // If is a member function
				strClass += "::";
			if ( m_iDisplayClassNames )
			{
				strNew = m_apiArray[i]->m_strReturnVal + " " + strClass + m_apiArray[i]->m_strName + "()";
			}
			else
			{
				strNew = m_apiArray[i]->m_strReturnVal + " " + m_apiArray[i]->m_strName + "()"; // Don't display Class Name
			}
			index = m_apiList.AddString( strNew );
			m_apiList.SetItemData( index, (DWORD)i );
		}
	}
}
			
void ApiTabdlg::DisplaySubareaAPIs( int index )
{
	CString	strArea;
	CString strSubarea;
	CString strNew;
	m_areaList.GetText(index, strSubarea);
	strArea = GetAreaName(index);
	int nLast = m_apiArray.GetUpperBound();

	m_apiList.ResetContent();
	for (int i=0; i <= nLast; i++)
	{
		if ( (m_apiArray[i]->m_strArea == strArea) && (m_apiArray[i]->m_strSubarea == strSubarea))
		{
			strNew = m_apiArray[i]->m_strReturnVal + " " + m_apiArray[i]->m_strClass + "::" + m_apiArray[i]->m_strName + "()";
			index = m_apiList.AddString( strNew );
			m_apiList.SetItemData( index, (DWORD)i );
		}
	}
}
			
CString ApiTabdlg::GetAreaName( int index )
{
	CString	strArea;
	while ( !IsArea(index) )
		index--;	  // Go up the list to find the Area
	ASSERT (index >= 0);
	m_areaList.GetText(index, strArea);
	
	return strArea;
}

void ApiTabdlg::DisplayParameters( int index, BOOL bAddedToScript )
{
	m_parameterList.ResetContent();

	int i = index;

	if (!bAddedToScript)
		i = m_apiList.GetItemData(index);  // If Selected API is in API List
		
	POSITION pos = m_apiArray[i]->m_paramList.GetHeadPosition();
	
	while (pos != NULL )
	{  	
		CParam* pParam =  m_apiArray[i]->m_paramList.GetNext(pos);
		CString strParam = pParam->m_strType + "\t" + pParam->m_strName + "\t" + pParam->m_strValue;
		int index = m_parameterList.AddString( strParam );
		m_parameterList.SetItemDataPtr(index, pParam);
	}
}

void ApiTabdlg::DisplayAPIDescription( int index )
{
	
	int i = m_apiList.GetItemData(index);
	CString strDesc = m_apiArray[i]->m_strDesc;
	m_apiDescription.SetWindowText( strDesc );
}


void ApiTabdlg::DisplayParamDescription( int index )
{
	
	CParam* pParam = (CParam*)m_parameterList.GetItemDataPtr(index);
	CString strDesc = pParam->m_strDesc;
	m_apiDescription.SetWindowText( strDesc );
}


CString ApiTabdlg::CreateVarFromClassName(CString& strClassName)
{
	int nLength = strClassName.GetLength();
	ASSERT (nLength > 0);					//REVIEW: Handle this error condition gracefully

	int  i = 0;
	int  nLastUpper = i;
	while ( isupper(strClassName[i]) )
	{
		nLastUpper = i++;
		if (i >= nLength)
			break;	
	}

	CString strVar;
	if ( (nLength - nLastUpper) < 5 )
		strVar = strClassName.Mid(nLastUpper);
	else
		strVar = strClassName.Mid(nLastUpper, 5);
	
	strVar.MakeLower();

	return strVar;
}	

/////////////////////////////////////////////////////////////////////////////
// ApiTabdlg message handlers

BOOL ApiTabdlg::OnSetActive()
{

    BOOL bReturn = CPropertyPage::OnSetActive();
/*	
	CString path("0",250) ;
	GetModuleFileName(NULL,path.GetBuffer(250),250) ;
	path = path.Left(path.ReverseFind('\\') + 1) ;
	path =path +"appwiz\\apidata.txt" ;

    if (m_apiArray.GetSize() == 0)
        OpenAPIData(path.GetBuffer(250));
  */

    return  bReturn;
}


void ApiTabdlg::OnSelchangeCategory() 
{
    CString strCurrentText;
	int index = m_categoryCB.GetCurSel() ;
	if (LB_ERR ==index || 0 > index) // If an error or no items in the listbo.
		return ;  
	m_categoryCB.GetLBText( index , strCurrentText );
    m_category = strCurrentText;
	DisplayAreas();
	OnSelchangeListAreas();
}


BOOL ApiTabdlg::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();

   	CString path("0",250) ;
	GetModuleFileName(NULL,path.GetBuffer(250),250) ;
	path = path.Left(path.ReverseFind('\\') + 1) ;
	
//	Debug version uses the ided directory
	#ifdef _DEBUG
	path =path +"ided\\apidata.txt" ;
	#else
	path =path +"ide\\apidata.txt" ;
	#endif

    m_bIsOldFormat = FALSE;
	
	if (m_apiArray.GetSize() == 0)
        OpenAPIData(path.GetBuffer(250));

	CClientDC ccldc(this) ;         
 	// Add Custom listbox
	// subclass the control	 
	VERIFY(m_ScriptList.SubclassDlgItem(IDC_SCRIPTLIST, this));

	VERIFY(m_areaList.SubclassDlgItem(IDC_LIST_AREAS, this));

   // init the directives combo box
	int index = m_directivesList.AddString("if ( ) ") ;
	index = m_directivesList.AddString("else (  )") ;
	index = m_directivesList.AddString("for ( ) ") ;
	index = m_directivesList.AddString("m_pLog->RecordFailure(\" \")") ;
	index = m_directivesList.AddString("m_pLog->RecordInfo(\" \")") ;
	index = m_directivesList.AddString("m_pLog->Comment(\" \")") ;
	
	//Setup the Script listbox.
	CScriptTree::ScriptHead = new CScriptTree ;
	CScriptTree::ScriptHead->m_level = 0 ; 
	CScriptTree::ScriptHead->SetIndex(0) ;
	CScriptTree::ScriptHead->SetListBox(&m_ScriptList) ;
	CScriptTree::ScriptHead->SetText("TEST SCRIPT") ;
	CScriptTree::ScriptHead->SetBitmap((HBITMAP)bmapNomoreItems.GetSafeHandle()) ;
	// Insert an empty string.
	CScriptTree * empty = new CScriptTree ;
	
	empty->SetListBox(&m_ScriptList) ;
	empty->SetText(" ") ;
	empty->SetBitmap((HBITMAP)bmapNone.GetSafeHandle()) ;
	CScriptTree::ScriptHead->AddNode(empty) ;
	
   	CScriptTree::ScriptHead->DrawScript() ;

	OnNewtestcase() ; 
	// Set column sizes for Parameter Listbox
	CRect rect;
	m_parameterList.GetClientRect(rect);
	LPRECT pRectParam = rect;
	int nTabStop = (pRectParam->right - pRectParam->left) / 6;
	m_parameterList.SetTabStops( nTabStop  );
	// Display Api's
	
	m_categoryCB.SetCurSel(0);	// Select first category
	OnSelchangeCategory();	
	DisplayAreas();

	m_AddButton.EnableWindow(FALSE);
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void ApiTabdlg::OnDblclkListAreas() 
{
	int index =  m_areaList.GetCurSel() ;
	if (LB_ERR ==index || 0 > index) // If an error or no items in the listbox.
		return ;  
	if ( IsArea(index) )
	{
		//Expand or collapse Area 
		CBitmap * curpbmap ;
		curpbmap = CBitmap::FromHandle((HBITMAP)m_areaList.GetItemData(index)) ;
		if (curpbmap->GetSafeHandle() == bmapCheck.GetSafeHandle()) // if currently checked
			ExpandArea(index, FALSE);
		else 
			ExpandArea(index);

		m_areaList.SetCurSel(index) ;
	}
}


void ApiTabdlg::OnSelchangeListAreas() 
{
    CString strCurrentText;
    int index = m_areaList.GetCurSel();
	if (LB_ERR ==index || 0 > index) // If an error or no items in the listbox.
		return ;  

	if ( IsArea(index) )
		DisplayAreaAPIs(index);
	else
		DisplaySubareaAPIs(index);
}

void ApiTabdlg::OnSelchangeListApi() 
{
    int index = m_apiList.GetCurSel();
	if (LB_ERR ==index || 0 > index) // If an error or no items in the listbo.
		return ;  

	DisplayParameters( index );
	DisplayAPIDescription( index );
}

void ApiTabdlg::OnDblclkListApi() 
{
	int index = m_ScriptList.GetCurSel() ;
	if (LB_ERR ==index || 0 > index)
		index = 0 ;
	int iApi = m_apiList.GetCurSel() ;
	if (LB_ERR ==iApi || 0 > iApi) // If an error or no items is selected in listbox.
		return ;  				   // Possible because we call this function when Add button clicked 
  	//Fill prepare an item to be added to the script. 
	CScriptTree *strNode ;
	strNode = new CScriptTree ;
	
	//Associate the listbox with the script tree.
	strNode->SetListBox(&m_ScriptList) ;
	strNode->SetBitmap((HBITMAP)bmapNone.GetSafeHandle()) ;
	/* Get class type, api name and parameter names */
	int i = m_apiList.GetItemData(iApi);
	strNode->m_apiIndex = i;
	CString strAPI = m_apiArray[i]->m_strName;  // REVIEW: Add Parameters
	CString strClassName = m_apiArray[i]->m_strClass ;
	POSITION pos = m_apiArray[i]->m_paramList.GetHeadPosition();
	CString strParams ='(';
	CString strSeparator = " ";
	while (pos != NULL )
	{
		// Since the API has arguments, give it a warning bitmap
		strNode->SetBitmap((HBITMAP)bmapWarn.GetSafeHandle()) ;
		CParam* pParam =  m_apiArray[i]->m_paramList.GetNext(pos);
		if ( pParam->m_strValue.IsEmpty())
			strParams = strParams + strSeparator + pParam->m_strName;
		else
			break;	   // If is default value don't add to string
		strSeparator = ", ";
	}
	strParams = strParams + " )";

	// Add the new string node to the currently selected parent.
	CScriptTree * SelectedNode = ((CScriptTree* )m_ScriptList.GetItemData(index));
	int nodeID = SelectedNode->m_index ;
	CScriptTree * temp = CScriptTree::ScriptHead->FindParent(nodeID) ;;
	CString strVarName ;
	if(0 == nodeID) // Cant insert at index 0, reserved for Test Tree keyword.
		nodeID++ ;

	// If no varible of this type is declared yet, declare one.
	if ((strVarName = temp->GetObjectName(strClassName)) == "NULL") 
	{
		
		CScriptTree *varNode ;
		varNode = new CScriptTree ;
	    
		if(!m_HideVarsBraces)
			varNode->m_Hidable = NOTHIDDEN ;
		else
			varNode->m_Hidable = HIDDEN ;
		//Create a variable declaration.
		 CVariable * pNewVar = new CVariable ;

		int iVar ;
		if(temp == CScriptTree::ScriptHead)	   //Choosing a position for the variable.
		 	iVar = temp->m_index +1 ;
		else iVar = temp->m_index + 2 ; 

		varNode->SetListBox(&m_ScriptList) ;
		varNode->SetBitmap((HBITMAP)bmapNone.GetSafeHandle()) ;
	  	
		pNewVar->ClsName = strClassName; 
		pNewVar->VarName = CreateVarFromClassName(strClassName) ;
		temp->AddToVarsInScope(pNewVar) ;
		
		varNode->SetText(strClassName + "  " + pNewVar->VarName +";"  ) ;// Var declaration
		strNode->SetText(pNewVar->VarName + '.' + strAPI + strParams +";" ) ; 			// Var.API 			
	
		temp->AddNode(strNode,nodeID) ;
		temp->AddNode(varNode,iVar) ;
		index++ ; //Need to move selection down two positions if a veriable was added.	
	}
	else
	{
		strNode->SetText(strVarName + '.' + strAPI + strParams +";" );
		temp->AddNode(strNode,nodeID) ;
	}
	
	CScriptTree::ScriptHead->DrawScript() ; // Redraw the tree. 
	m_ScriptList.SetCurSel(index + 1) ;
	
}

void ApiTabdlg::OnDblclkScriptlist() 
{
	// TODO: Add your control notification handler code here
	int index =  m_ScriptList.GetCurSel() ;
	int nodeID ;
	// Find the node which contains the clicked item.
	CScriptTree * SelectedNode = ((CScriptTree* )m_ScriptList.GetItemData(index));
	nodeID = SelectedNode->m_index ;

	if(SelectedNode->IsExpanded())
		{SelectedNode->CollapseTree() ;}
	else 
		if(SelectedNode->IsCollapsed())
	 		{SelectedNode->ExpandTree(nodeID) ;}
		else
			return ;
	CScriptTree::ScriptHead->DrawScript() ;
	m_ScriptList.SetCurSel(index) ;
}

void ApiTabdlg::OnRButtonDown(UINT nFlags, CPoint point) 
{		
	// Convert the client coordinates to screen cordinates.
	RECT rect ;
	rect.top = point.y ;
	rect.left = point.x;
	rect.bottom = 0 ;
	rect.right = 0;
	ClientToScreen(&rect) ;
	point.x =rect.left ; 
	point.y =rect.top ;

	// TODO: Add your message handler code here and/or call default	 Cwinapp
	if (CasesListRect.PtInRect(point))	 // If we were inside the Cases listbox 
	{
		CMenu mnPopup ;
		mnPopup.CreatePopupMenu() ;
		mnPopup.AppendMenu(MF_STRING,IDC_MOVE_UP,"&Move Up") ;
		mnPopup.AppendMenu(MF_STRING,IDC_MOVE_DOWN,"&Move Down") ;
		mnPopup.AppendMenu(MF_STRING,ID_POPUP_DELETE,"&Delete") ;
		mnPopup.AppendMenu(MF_STRING,ID_POPUP_WARN,"&Warnings") ;
		
		mnPopup.TrackPopupMenu(TPM_LEFTALIGN|TPM_LEFTBUTTON,rect.left,rect.top,(this),NULL) ;
		CPropertyPage::OnRButtonDown(nFlags, point);
	}
}


void ApiTabdlg::OnParentNotify(UINT message, LPARAM lParam) 
{
	// Needed to trap the left mouse click on listbox.
	CPoint point(LOWORD(lParam),HIWORD(lParam)) ;
  	if(WM_RBUTTONDOWN == message)
	{
		OnRButtonDown(0,point) ;
	}
	else
		if(WM_LBUTTONDOWN == message)
		{
			OnLButtonDown(0,point) ;	
		}
		else
			if(WM_MOUSEMOVE == message)
			{
			 OnMouseMove(0,point);
			}

	CPropertyPage::OnParentNotify(message, lParam);
}

void ApiTabdlg::OnPopupDelete() 
{
     int icursel =  m_ScriptList.GetCurSel() ;
	if (LB_ERR ==icursel || 0 > icursel)
	{
		MessageBox("First select an item to delete.","Delete Item",MB_OK|MB_ICONINFORMATION) ;
		CScriptTree::ScriptHead->SetFocusOnListBox() ;
		return ;
	}
	if (0 ==icursel)
	{
		MessageBox("You cannot delete this item.","Delete Item",MB_OK|MB_ICONSTOP) ;
		CScriptTree::ScriptHead->SetFocusOnListBox() ;
		return ;
	}
	CString itemTxt("0",30) ;
	m_ScriptList.GetText(icursel,itemTxt) ;
	if((itemTxt.SpanExcluding("{}")).IsEmpty())
	{
		MessageBox("Cannot delete a block character.","Delete Error",MB_OK|MB_ICONSTOP) ;
		CScriptTree::ScriptHead->SetFocusOnListBox() ;
		return ;
	}
	// Find the node which contains the clicked item.
	CScriptTree * temp,  * SelectedNode = ((CScriptTree* )m_ScriptList.GetItemData(icursel));
	int nodeID = SelectedNode->m_index ;

	if(SelectedNode->m_Children.GetSize())
	 if(MessageBox("Delete the selected item with its children?","Comfirm Delete",MB_OKCANCEL|MB_ICONQUESTION)!= IDOK)
	 	return ;
	temp =  CScriptTree::ScriptHead->FindParent(nodeID) ;
	temp->DeleteChild(nodeID);
	CScriptTree::ScriptHead->DrawScript() ;

	//Select an item
	if(m_ScriptList.GetCount() < icursel)
		icursel-- ;
   	m_ScriptList.SetCurSel(icursel)	;
	CScriptTree::ScriptHead->SetFocusOnListBox() ;
}	

void ApiTabdlg::OnPopuupWarnings() 
{
    int icursel =  m_ScriptList.GetCurSel() ;
	if (LB_ERR ==icursel || 0 > icursel)
		icursel = 0 ;
	if (0 ==icursel)
		return ;
	CString itemTxt("0",30) ;
	m_ScriptList.GetText(icursel,itemTxt) ;
	
	if((itemTxt.SpanExcluding("{}")).IsEmpty())
	return ;
	// Find the currently selected node.
	CScriptTree * SelectedNode = ((CScriptTree* )m_ScriptList.GetItemData(icursel));
    if(SelectedNode->IsWarningON())
		{SelectedNode->WarningOFF() ;}
	else 
		if(SelectedNode->IsWarningOFF())
			{SelectedNode->WarningON() ;}
		else 
			return;
	CScriptTree::ScriptHead->DrawScript() ;
	m_ScriptList.SetCurSel(icursel)	;
	CScriptTree::ScriptHead->SetFocusOnListBox() ;
}

void ApiTabdlg::OnHideVarsAndBraces() 
{
	UpdateData() ;
	//Toggles hiding and displaying variable declarations and braces. 
	CScriptTree::ScriptHead->HideVars_Blocks(m_HideVarsBraces) ;
	CScriptTree::ScriptHead->DrawScript() ;
	
}


void ApiTabdlg::OnAdd() 	// Add API to Script
{
	OnDblclkListApi();
}


BOOL ApiTabdlg::OnKillActive()
{
	CWnd *focus = GetFocus() ;
	CWnd *TxtEdt = GetDlgItem(IDC_SCRIPTTEXT) ;	// If the user pressed Enter after editing 

	if(focus->m_hWnd == TxtEdt->m_hWnd)
	{
		int icursel =  m_ScriptList.GetCurSel() ;
		if (LB_ERR ==icursel || 0 > icursel)
			icursel = 0 ;
		
		if (0 ==icursel) //Can't edit first item
			return FALSE;
			
		CString itemTxt("0",100) ;
		m_ScriptList.GetText(icursel,itemTxt) ;
	
		if((itemTxt.SpanExcluding("{}")).IsEmpty()) //Can't edit block characters.
			return FALSE ;
			
		// Find the node which contains the clicked item.
		CScriptTree * SelectedNode = ((CScriptTree* )m_ScriptList.GetItemData(icursel));
		
		UpdateData(TRUE); 
		SelectedNode->SetText(m_ScriptItemTxt) ;
	
		CScriptTree::ScriptHead->DrawScript() ;
		//Select an item
		m_ScriptList.SetCurSel(icursel)	;
		CScriptTree::ScriptHead->SetFocusOnListBox() ;
		return FALSE ;
	}
	else 
	 return (MessageBox("Do you want to apply your changes?","Comfirm close",MB_OKCANCEL|MB_ICONQUESTION)== IDOK) ;
	//return TRUE ;
		
}


void ApiTabdlg::OnOK()
{
	// Get all the script text and stick it in a CString object ;
	CString ScriptBuffer ;
	CScriptTree::ScriptHead->DumpIntoString(&ScriptBuffer) ;

	// Add the string object to the dictionary.
	awx.m_Dictionary.SetAt("Script_Text",ScriptBuffer) ;

// create the header for the TestCase class 


//Create the header for the Driver class.	
}

void ApiTabdlg::OnPaint() 
{
	CPaintDC dc(this); // device context for painting

	// Get the sorrounding rect of the CasesListbox
   	CWnd	*hNameCtl ;
   	hNameCtl = (this->GetDlgItem(IDC_SCRIPTLIST)) ;
   	hNameCtl->GetWindowRect(&CasesListRect) ;

	// TODO: Add your message handler code here
	
	// Do not call CPropertyPage::OnPaint() for painting messages
}

void ApiTabdlg::OnMouseMove(UINT nFlags, CPoint point) 
{
	// TODO: Add your message handler code here and/or call default
		RECT rect ;
	rect.top = point.y ;
	rect.left = point.x;
	rect.bottom = 0 ;
	rect.right = 0;
	ClientToScreen(&rect) ;
	point.x =rect.left ; 
	point.y =rect.top ;

	//if the Leftmouse button is down, then we might be trying to move something
	if(MoveStartedInScriptBox)
	{
		WasInMotion = TRUE ;
			
		if (CasesListRect.PtInRect(point))	 // If we were inside the Cases listbox 
		{
			//CHANGE CURSOR.	
		}
	}
	WasInMotion = FALSE ;
	CPropertyPage::OnMouseMove(nFlags, point);
}

void ApiTabdlg::OnLButtonUp(UINT nFlags, CPoint point) 
{
	// TODO: Add your message handler code here and/or call default
		// TODO: Add your message handler code here and/or call default
	RECT rect ;
	rect.top = point.y ;
	rect.left = point.x;
	rect.bottom = 0 ;
	rect.right = 0;
	ClientToScreen(&rect) ;
	point.x =rect.left ; 
	point.y =rect.top ;

	//if the mouse had moved with the left button down
	if(WasInMotion && MoveStartedInScriptBox)
	{	
		if (CasesListRect.PtInRect(point))	 // If we were inside the Cases listbox 
		{
			//Get currently selected item
				AfxMessageBox("Could move this item");
			// Make previously selected item child of currently selected one.

		}
	}
	MoveStartedInScriptBox = FALSE ;
	WasInMotion = FALSE ;	
	CPropertyPage::OnLButtonUp(nFlags, point);
} 

void ApiTabdlg::OnLButtonDown(UINT nFlags, CPoint point) 
{
	// TODO: Add your message handler code here and/or call default
			// TODO: Add your message handler code here and/or call default
	RECT rect ;
	rect.top = point.y ;
	rect.left = point.x;
	rect.bottom = 0 ;
	rect.right = 0;
	ClientToScreen(&rect) ;
	point.x =rect.left ; 
	point.y =rect.top ;

	if (CasesListRect.PtInRect(point))	 // If we were inside the Cases listbox 
	{
		//Get currently selected item
		MoveStartedInScriptBox = TRUE ;
	}
	else
		MoveStartedInScriptBox = FALSE ;

	CPropertyPage::OnLButtonDown(nFlags, point);
}

void ApiTabdlg::OnMoveDown() 
{
 	int icursel =  m_ScriptList.GetCurSel() ;
	if (LB_ERR ==icursel || 0 >= icursel )
	{
		MessageBox("Cannot move this item.","Move Item",MB_OK|MB_ICONINFORMATION) ;
		return ;
	}
	if (m_ScriptList.GetCount() ==icursel+1)
	{
		return ;
	} 
	CString itemTxt("0",30) ;
	m_ScriptList.GetText(icursel,itemTxt) ;
	CString bellowTxt("0",30) ;
	m_ScriptList.GetText(icursel+1,bellowTxt) ;
	if((itemTxt.SpanExcluding("{}")).IsEmpty())
	{
		MessageBox("Cannot move a block character.","Move Error",MB_OK|MB_ICONSTOP) ;
		return ;
	}
	if((bellowTxt.SpanExcluding("{}")).IsEmpty())
	{
		MessageBox("Cannot move this item down.","Move Error",MB_OK|MB_ICONSTOP) ;
		return ;
	}
	 //Select the node bellow and move it up.
  	m_ScriptList.SetCurSel(icursel+1) ;
  	OnMoveUp() ;	
	m_ScriptList.SetCurSel(icursel+1) ;
}

void ApiTabdlg::OnMoveUp() 
{	
	int icursel =  m_ScriptList.GetCurSel() ;
	CString itemTxt("0",30) ;
	m_ScriptList.GetText(icursel,itemTxt) ;
	CString aboveTxt("0",30) ;
	m_ScriptList.GetText(icursel -1,aboveTxt) ;
		
	if (LB_ERR ==icursel || 0 >= icursel )
	{
		MessageBox("Cannot move this item.","Move Item",MB_OK|MB_ICONINFORMATION) ;
		return ;
	}
	if (icursel == 1)
	{
		MessageBox("You cannot move this item up.","Move Error",MB_OK|MB_ICONSTOP) ;
		return ;
	}
	if((itemTxt.SpanExcluding("{}")).IsEmpty())
	{
		MessageBox("Cannot move a block character.","Move Error",MB_OK|MB_ICONSTOP) ;
		return ;
	}
	if((aboveTxt.SpanExcluding("{}")).IsEmpty())
	{
		MessageBox("Cannot move this item up.","Move Error",MB_OK|MB_ICONSTOP) ;
		return ;
	}
	// Find the node which contains the clicked item.
	CScriptTree * prevNode,  * SelectedNode = ((CScriptTree* )m_ScriptList.GetItemData(icursel));
	int nodeID = SelectedNode->m_index ;
	//Find parent of clicked item so she can dissown the node we want to move.
	CScriptTree * Parent = CScriptTree::ScriptHead->FindParent(nodeID) ;
	Parent->DissownChild(nodeID) ;
	SelectedNode->MoveUp() ;
	//Find the previous node since its going to move down.
	prevNode = ((CScriptTree* )m_ScriptList.GetItemData(icursel-1));
	prevNode->MoveDown() ;
	// Find the parent of the node above since that's the new parent of the moved node.
	Parent = CScriptTree::ScriptHead->FindParent(prevNode->m_index) ;
	//Readd the child.
	Parent->AddNode(SelectedNode,prevNode->m_index) ;
	//Select an item
	icursel-- ;
   	CScriptTree::ScriptHead->DrawScript() ;
	m_ScriptList.SetCurSel(icursel)	;
}

void ApiTabdlg::OnDblclkDirectives() 
{
	int index =  m_directivesList.GetCurSel() ;
   //	UpdateData() ;
																	 
	CString strDirective("0",30) ;									 
	m_directivesList.GetText(index,strDirective) ; 					 
	strDirective = strDirective.SpanExcluding(".") ;
 
 	index = m_ScriptList.GetCurSel() ;
	if (LB_ERR ==index || 0 > index)
		index = 0 ;

	//Fill in a ScriptTree node ;
	CScriptTree * keyWord, *ltbrace, *rtbrace, *empty ;

	if ((strDirective == "m_pLog->RecordFailure(\" \")")
		||(strDirective == "m_pLog->RecordInfo(\" \")") //
		||(strDirective == "m_pLog->Comment(\" \")") ) // These three don't need block characters.
	{
	 	keyWord = new CScriptTree ; //Works for all three 
		keyWord->SetListBox(&m_ScriptList) ;
		keyWord->SetText(strDirective +";") ;
		keyWord->SetBitmap((HBITMAP)bmapNone.GetSafeHandle()) ;

		//Find parent of the node they clicked inside of.
		CScriptTree * SelectedNode = ((CScriptTree* )m_ScriptList.GetItemData(index));
		int nodeID = SelectedNode->m_index ;

		CScriptTree * temp = CScriptTree::ScriptHead->FindParent(nodeID) ;
	
		//Add the directive node.
		if(0 == nodeID) // Cant insert at index 0, reserved for Test Tree keyword.
		nodeID++ ;
		temp->AddNode(keyWord,nodeID) ;
	
	}
	else 
	{
		ltbrace = new CScriptTree ;
		rtbrace = new CScriptTree ;
		empty = new CScriptTree ;
		keyWord= new CScriptTree ;
		//Associate the listbox with the script tree.

		empty->SetListBox(&m_ScriptList) ;
		ltbrace->SetListBox(&m_ScriptList) ;
		rtbrace->SetListBox(&m_ScriptList) ;
		keyWord->SetListBox(&m_ScriptList) ;
	
		keyWord->SetText(strDirective) ;
		ltbrace->SetText("{") ;
		empty->SetText(" ") ;
		rtbrace->SetText("}") ;

		// Turn the braces on
		if(!m_HideVarsBraces)
		{
			ltbrace->m_Hidable = NOTHIDDEN ;
			rtbrace->m_Hidable = NOTHIDDEN ;
		}
		else
		{
			ltbrace->m_Hidable = HIDDEN ;
			rtbrace->m_Hidable = HIDDEN ;
		}
		empty->SetBitmap((HBITMAP)bmapNone.GetSafeHandle()) ;
		ltbrace->SetBitmap((HBITMAP)bmapNone.GetSafeHandle()) ;
		rtbrace->SetBitmap((HBITMAP)bmapNone.GetSafeHandle()) ;
		
		//TestCase keyword is of special interest since it's a function name. CString
	/*	if (strDirective == "TestCase ( )")
		{ 	static icount =1 ;
			CString num ;
			num.Format("%d",icount);
			keyWord->SetText(strDirective.SpanExcluding(" ")+num+"( )");
			keyWord->m_TestCase = TRUE ;
			icount++ ;
		} */
									
		keyWord->SetBitmap((HBITMAP)bmapNomoreItems.GetSafeHandle()) ;
		//Find parent of the node they clicked inside of.
		CScriptTree * SelectedNode = ((CScriptTree* )m_ScriptList.GetItemData(index));
		int nodeID = SelectedNode->m_index ;

		CScriptTree * temp = CScriptTree::ScriptHead->FindParent(nodeID) ;
	
		//Add the directive node.
		if(0 == nodeID) // Cant insert at index 0, reserved for Test Tree keyword.
		nodeID++ ;
		temp->AddNode(keyWord,nodeID) ;
	
		keyWord->AddNode(ltbrace) ;
		keyWord->AddNode(empty) ;
		keyWord->AddNode(rtbrace) ;
	}
	CScriptTree::ScriptHead->DrawScript() ;
	m_ScriptList.SetCurSel(index) ;	
}

void ApiTabdlg::OnNewtestcase() 
{
	// TODO: Add your control notification handler code here
	//Fill in a ScriptTree node ;
	int index = m_ScriptList.GetCurSel() ;
	if (LB_ERR ==index || 0 > index)
		index = 0 ;

	CString strDirective = "TestCase ( )" ;
	CScriptTree * keyWord, *ltbrace, *rtbrace, *empty, *Return ;
	
	Return = new CScriptTree ;
	ltbrace = new CScriptTree ;
	rtbrace = new CScriptTree ;
	empty = new CScriptTree ;
	keyWord= new CScriptTree ;
	//Associate the listbox with the script tree.
	Return->SetListBox(&m_ScriptList) ;
	empty->SetListBox(&m_ScriptList) ;
	ltbrace->SetListBox(&m_ScriptList) ;
	rtbrace->SetListBox(&m_ScriptList) ;
	keyWord->SetListBox(&m_ScriptList) ;

	//keyWord->SetText("TestCase) ;
	Return->SetText("return;") ;
	ltbrace->SetText("{") ;
	empty->SetText(" ") ;
	rtbrace->SetText("}") ;

	// Turn the braces on
	if(!m_HideVarsBraces)
	{
		ltbrace->m_Hidable = NOTHIDDEN ;
		rtbrace->m_Hidable = NOTHIDDEN ;
	}
	else
	{
		ltbrace->m_Hidable = HIDDEN ;
		rtbrace->m_Hidable = HIDDEN ;
	}
	empty->SetBitmap((HBITMAP)bmapNone.GetSafeHandle()) ;
	ltbrace->SetBitmap((HBITMAP)bmapNone.GetSafeHandle()) ;
	rtbrace->SetBitmap((HBITMAP)bmapNone.GetSafeHandle()) ;
	Return->SetBitmap((HBITMAP)bmapNone.GetSafeHandle()) ;
	
	//TestCase keyword is of special interest since it's a function name. CString
	static icount =1 ;
	CString num ;
	num.Format("%d",icount);
	keyWord->SetText(strDirective.SpanExcluding(" ")+num+"( )");
	keyWord->m_TestCase = TRUE ;
	icount++ ;
	
	keyWord->SetBitmap((HBITMAP)bmapNomoreItems.GetSafeHandle()) ;
	//A new TestCase always goes at the bottom of the listbox, and is a child of the Head.
	int nodeID = m_ScriptList.GetCount() ;
  	//Add the directive node.
	CScriptTree::ScriptHead->AddNode(keyWord,nodeID) ;

	keyWord->AddNode(ltbrace) ;
	keyWord->AddNode(empty) ;
	keyWord->AddNode(Return) ;	
	keyWord->AddNode(rtbrace) ;

	CScriptTree::ScriptHead->DrawScript() ;
	m_ScriptList.SetCurSel(nodeID + 2) ;	

}

void ApiTabdlg::OnSelchangeScriptlist() 
{
	//Get the currently selected item text and insert it in the editcontrol on the top of the listbox.

  	int icursel =  m_ScriptList.GetCurSel() ;
	if (LB_ERR ==icursel || 0 > icursel)
		icursel = 0 ;
		
	if (0 ==icursel)
		return ; //Ignore the first item.

		
	CString itemTxt("0",30) ;
	m_ScriptList.GetText(icursel,itemTxt) ;
	
	if((itemTxt.SpanExcluding("{}")).IsEmpty())
		return ; //Can't edit the braces
		
	// Find the node which contains the clicked item.
	CScriptTree * SelectedNode = ((CScriptTree* )m_ScriptList.GetItemData(icursel));
	m_ScriptItemTxt =  SelectedNode->m_Text ;
	// Display Parameters if an API is selected
	int iAPI = SelectedNode->m_apiIndex;
	if (iAPI != -1)
		DisplayParameters(iAPI, TRUE);

	UpdateData(FALSE) ;
}

int ApiTabdlg::OnVKeyToItem(UINT nKey, CListBox* pListBox, UINT nIndex) 
{
  	CWnd* EditCtrl = GetDlgItem(IDC_SCRIPTLIST) ;

	if(pListBox->m_hWnd == EditCtrl->m_hWnd)
	{
		// If the pressed key is an Insert, add a blank line to the script 
		if(nKey == VK_INSERT)
		{
			OnInsert();
		}
		// If the pressed key is a Delete, delete the selected lineir 
		if(nKey == VK_DELETE)
		{
		 	OnPopupDelete() ;
		}
		CScriptTree::ScriptHead->SetFocusOnListBox() ;
	}
	return -1 ;

	//return CPropertyPage::OnVKeyToItem(nKey, pListBox, nIndex);
}

void ApiTabdlg::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	// TODO: Add your message handler code here and/or call default
	
	CPropertyPage::OnKeyDown(nChar, nRepCnt, nFlags);
}

void ApiTabdlg::OnSetfocusListApi() 
{
	// Enable Add button only when this listbox has focus
	m_AddButton.EnableWindow();
	
}

void ApiTabdlg::OnKillfocusListApi() 
{
//	m_AddButton.EnableWindow(FALSE);
	
}

void ApiTabdlg::OnInsert() 
{
	int index = m_ScriptList.GetCurSel() ;
	if (LB_ERR ==index || 0 > index)
		index = 0 ;

	//Fill in a ScriptTree node ;
	CScriptTree  *empty ;
	empty = new CScriptTree ;
	empty->SetListBox(&m_ScriptList) ;
	empty->SetText(" ") ;
	empty->SetBitmap((HBITMAP)bmapNone.GetSafeHandle()) ;
	//Find parent of the node they clicked inside of.
	CScriptTree * SelectedNode = ((CScriptTree* )m_ScriptList.GetItemData(index));
	int nodeID = SelectedNode->m_index ;

	CScriptTree * temp = CScriptTree::ScriptHead->FindParent(nodeID) ;
	
	//Add the directive node.
	if(0 == nodeID) // Cant insert at index 0, reserved for Test Tree keyword.
		nodeID++ ;
	temp->AddNode(empty,nodeID) ;
	CScriptTree::ScriptHead->DrawScript() ;
	m_ScriptList.SetCurSel(index) ;	
}

void ApiTabdlg::OnDisplayClassNames() 
{
	m_iDisplayClassNames = !m_iDisplayClassNames;
	OnSelchangeListAreas();
}

void ApiTabdlg::OnSelchangeListParameters() 
{
	int index = m_parameterList.GetCurSel();
	if (LB_ERR ==index || 0 > index) // If an error or no items in the listbo.
		return ;  

	DisplayParamDescription( index );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Src\chooser.cpp ===
// chooser.cpp : Defines the initialization routines for the DLL.
//

#include "stdafx.h"
#include "TestWiz.h"
#include "chooser.h"
#include "page1dlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

CDialogChooser::CDialogChooser()
{
	pDlgs[0] = NULL;

	pDlgs[1] = new CPage1Dlg;
//	pDlgs[2] = new CPage2Dlg;
//	pDlgs[2] = GetDialog(APWZDLG_DATABASE);
//	pDlgs[3] = GetDialog(APWZDLG_OLE);
//Dlgs[2] = GetDialog(APWZDLG_DOCAPPOPTIONS);

	nCurrDlg = 0;
}

CDialogChooser::~CDialogChooser()
{
	const int LAST_TestWiz_DLG = 1;
	for (int i=1; i <= LAST_TestWiz_DLG; i++)
	{
		ASSERT(pDlgs[i] != NULL);
		delete pDlgs[i];
	}
}

CAppWizStepDlg* CDialogChooser::Next(CAppWizStepDlg* pDlg)
{
	ASSERT(0 <= nCurrDlg && nCurrDlg < NUM_DLGS);
	ASSERT(pDlg == pDlgs[nCurrDlg]);

	nCurrDlg++;
	return pDlgs[nCurrDlg];
}

CAppWizStepDlg* CDialogChooser::Back(CAppWizStepDlg* pDlg)
{
	ASSERT(1 <= nCurrDlg && nCurrDlg <= NUM_DLGS);
	ASSERT(pDlg == pDlgs[nCurrDlg]);

	nCurrDlg--;
	return pDlgs[nCurrDlg];
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Src\chooser.h ===
#ifndef __CHOOSER_H__
#define __CHOOSER_H__

#define NUM_DLGS 1

class CDialogChooser
{
public:
	CDialogChooser();
	~CDialogChooser();
	CAppWizStepDlg* Next(CAppWizStepDlg* pDlg);
	CAppWizStepDlg* Back(CAppWizStepDlg* pDlg);

protected:
	int nCurrDlg;
	CAppWizStepDlg* pDlgs[NUM_DLGS+1];
};

#endif //__CHOOSER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Src\data.cpp ===
// data.cpp : implementation of collection classes
//

#include "stdafx.h"
#include "testwiz.h"
#include "data.h"
#include "resource.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CParam
CParam::CParam()
{
}

CParam::~CParam()
{
}

/////////////////////////////////////////////////////////////////////////////
// CAPI

CAPI::CAPI()
{
}


CAPI::~CAPI()
{
}

/////////////////////////////////////////////////////////////////////////////
// CArea

CArea::CArea()
{
}


CArea::~CArea()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Src\apitabdl.h ===
// apipage.h : header file
//
#include "treelist.h"
#include "owdlist.h"
#include "data.h"
#include "testawx.h"

/////////////////////////////////////////////////////////////////////////////
// ApiTabdlg dialog

#ifndef _APITABDLG_
#define _APITABDLG_

#define API_FT_TEXT 0x0001

class ApiTabdlg : public CPropertyPage
{
    DECLARE_DYNCREATE(ApiTabdlg)
// Construction
public:
	ApiTabdlg(); 
    ~ApiTabdlg();
// Dialog Data
	CAreasLB  m_areaList;
	OwnerDrawLB  m_ScriptList ;
	//{{AFX_DATA(ApiTabdlg)
	enum { IDD = IDD_API };
	CEdit	m_ScriptItemCtrl;
	CListBox	m_directivesList;
		CButton	m_AddButton;
		BOOL	m_HideVarsBraces;
		CStatic	m_apiDescription;
		CListBox	m_parameterList;
		CListBox	m_apiList;
		CComboBox	m_categoryCB;
		CString		m_category;
	CString	m_ScriptItemTxt;
	int		m_iDisplayClassNames;
	//}}AFX_DATA


// Attributes
public:
	CStringList     m_stringList;
	CAPIArray       m_apiArray;
    CAreaArray      m_areaArray;

	CString			m_strCurrentCategory;
    CString         m_strCurrentArea;
    CString         m_strCurrentSubarea;
	CString			m_strCurrentAPI;

	BOOL			m_bIsOldFormat;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(ApiTabdlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

    virtual BOOL OnSetActive(void);
	virtual void OnOK() ;
	virtual BOOL OnKillActive() ;

// Operations
public:
    UINT    OpenAPIData(LPCSTR szFileName, UINT nFileType = API_FT_TEXT);
    void    LoadAPIList(void);
    void    DisplayAreas(void);

    BOOL    InterpretLine(LPCSTR szNewLine);
    char*  RemoveExtraChars(char* pchLine);
    
	void    FillStructures( LPCSTR szLine );
	LPCSTR	SetCurrentCategory( LPCSTR szLine);
    LPCSTR  FillAreaStruct(LPCSTR szLine);
 	LPCSTR  FillBaseClassStruct(LPCSTR szLine);
	LPCSTR  FillClassStruct(LPCSTR szLine);
	LPCSTR  FillSubareaStruct(LPCSTR szLine);
    LPCSTR  FillAPIStruct(LPCSTR szLine );
	LPCSTR  FillDescStruct(LPCSTR szLine);
	LPCSTR  FillReturnStruct(LPCSTR szLine);
	LPCSTR	FillParamStruct(LPCSTR szLine, CAPI* pAPI = NULL);
	LPCSTR  FillParamDescStruct(LPCSTR szLine);

    int     FindArea(LPCSTR szArea = NULL);
	BOOL	IsArea(int index);
	void	ExpandArea(int index, BOOL bExpand = TRUE);
	void	DisplaySubareas( int index, int i=-1 );
	void	HideSubareas( int index, int i=-1 );
	void	DisplayAreaAPIs( int index );
	void	DisplaySubareaAPIs( int index );
	CString	GetAreaName( int index );
	void	DisplayParameters( int index, BOOL bAddedToScript = FALSE );
	void	DisplayAPIDescription( int index );
	void	DisplayParamDescription( int index );
	CString CreateVarFromClassName(CString& strClassName);
	void 	OnInsert(); 


// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(ApiTabdlg)
	afx_msg void OnSelchangeCategory();
	virtual BOOL OnInitDialog();
	afx_msg void OnDblclkListAreas();
	afx_msg void OnSelchangeListAreas();
	afx_msg void OnSelchangeListApi();
	afx_msg void OnDblclkListApi();
	afx_msg void OnAdd();
	afx_msg void OnDblclkScriptlist();
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnParentNotify(UINT message, LPARAM lParam);
	afx_msg void OnPopupDelete();
	afx_msg void OnPopuupWarnings();
	afx_msg void OnHideVarsAndBraces();
	afx_msg void OnPaint();
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnMoveDown();
	afx_msg void OnMoveUp();
	afx_msg void OnDblclkDirectives();
	afx_msg void OnNewtestcase();
	afx_msg void OnSelchangeScriptlist();
	afx_msg int OnVKeyToItem(UINT nKey, CListBox* pListBox, UINT nIndex);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSetfocusListApi();
	afx_msg void OnKillfocusListApi();
	afx_msg void OnDisplayClassNames();
	afx_msg void OnSelchangeListParameters();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif // _APITABDLG_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Src\data.h ===
// data.h 
//
/////////////////////////////////////////////////////////////////////////////


//  Data structure classes
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _APIDATA_
#define _APIDATA_
class CParam
{
public:
    CParam();
    ~CParam();
// Attributes
public:
	CString m_strName;
    CString m_strType;
    CString m_strValue;
	CString m_strDesc;

// Operations
};

typedef CTypedPtrList<CPtrList, CParam*> CParamList;

/////////////////////////////////////////////////////////////////////////////

class CAPI : public CObject
{
public:
	CAPI();

// Attributes
public:
    CString m_strArea;          // AppWiz, Image Ed, Src Ed, etc...
	CString m_strSubarea;       // Creation, Navigation, Search... Matches index in listbox.
	CString m_strClass;         // Class API belongs to
	CString m_strName;          // Open()
    CString m_strDesc;          // description
    CString m_strReturnVal;     // Return Value
	CString m_strReturnDesc;	// Return Value description
    CParamList m_paramList;     // List of pointers

// Operations

// Implementation
public:
	virtual ~CAPI();
};

typedef CTypedPtrArray<CObArray,CAPI*> CAPIArray;

/////////////////////////////////////////////////////////////////////////////

class CArea : public CObject
{
public:
    CArea();

// Attributes
public:
	CString m_strCategory;
	CString m_strBaseClass;
    CString m_strName;
    CStringList m_strListSubarea;
// Operations

// Implementation
public:
	virtual ~CArea();
};

typedef CTypedPtrArray<CObArray,CArea*> CAreaArray;


#endif //_APIDATA_

/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Src\dummymen.cpp ===
// dummymen.cpp : implementation file
//

#include "stdafx.h"
#include "dummymen.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// DUMMYMENU

DUMMYMENU::DUMMYMENU()
{
}

DUMMYMENU::~DUMMYMENU()
{
}


BEGIN_MESSAGE_MAP(DUMMYMENU, CWnd)
	//{{AFX_MSG_MAP(DUMMYMENU)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// DUMMYMENU message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Src\owdlist.h ===
// owdlist.cpp : Ownerdraw listbox 

#include "stdafx.h"

#ifndef _CUSTOMLISTBOX_
#define _CUSTOMLISTBOX_

class OwnerDrawLB : public CListBox
{
public:
// Implementation
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMIS);
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDIS);
	virtual int CompareItem(LPCOMPAREITEMSTRUCT lpCIS);
};

#endif // _CUSTOMLISTBOX_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Src\page1dlg.cpp ===
// page1dlg.cpp : implementation file
//

#include "stdafx.h"
#include "TestWiz.h"
#include "testawx.h"
#include "page1dlg.h"
#include "tabcusto.h"
#include "apitabdl.h"
#include "scriptr.h"
#include "scriptpr.h"


#ifdef _DEBUG						  
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPage1Dlg dialog

TEXTMETRIC tm ;
int cxChar, cxCaps, cyChar ;

// Pens and Brushes we need to show selections.
CBrush brSelRect ;
CBrush brUnSelRect ;
CPen   penUnSelRect ;
CPen   penSelRect ;
CBitmap bmapUnCheck, bmapCheck, bmapNomoreItems, bmapMoreItems,	bmapNone, bmapTriangle, bmapTestCase, bmapWarn ;							 


CPage1Dlg::CPage1Dlg()
	: CAppWizStepDlg(CPage1Dlg::IDD)
{
	//{{AFX_DATA_INIT(CPage1Dlg)
	m_DriverClass = _T("");
	m_DriverH = _T("");
	m_DriverCpp = _T("");
	m_TestOwner = _T("");
	m_TestSetClass = _T("");
	m_TestSetCpp = _T("");
	m_TestSetH = _T("");
	m_TestTitle = _T("");
	//}}AFX_DATA_INIT
}


void CPage1Dlg::DoDataExchange(CDataExchange* pDX)
{
	CAppWizStepDlg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPage1Dlg)
	DDX_Control(pDX, IDC_EDITSCRIPT, m_EditScriptButton);
	DDX_Control(pDX, IDC_DRIVER, m_DriverCtrl);
	DDX_Control(pDX, IDC_TESTSET, m_TestSetCtrl);
	DDX_Text(pDX, IDC_DRIVER, m_DriverClass);
	DDX_Text(pDX, IDC_DRIVER_H, m_DriverH);
	DDV_MaxChars(pDX, m_DriverH, 12);
	DDX_Text(pDX, IDC_DRIVERC_PP, m_DriverCpp);
	DDV_MaxChars(pDX, m_DriverCpp, 12);
	DDX_Text(pDX, IDC_OWNER, m_TestOwner);
	DDX_Text(pDX, IDC_TESTSET, m_TestSetClass);
	DDX_Text(pDX, IDC_TESTSET_CPP, m_TestSetCpp);
	DDV_MaxChars(pDX, m_TestSetCpp, 12);
	DDX_Text(pDX, IDC_TESTSET_H, m_TestSetH);
	DDV_MaxChars(pDX, m_TestSetH, 12);
	DDX_Text(pDX, IDC_TITLE, m_TestTitle);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPage1Dlg, CAppWizStepDlg)
	//{{AFX_MSG_MAP(CPage1Dlg)
	ON_BN_CLICKED(IDC_EDITSCRIPT, OnEditscript)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CPage1Dlg message handlers

BOOL CPage1Dlg::OnInitDialog() 
{
	CAppWizStepDlg::OnInitDialog();

	// Get project name
	CString strRoot, Rootpart ;

	awx.m_Dictionary.Lookup("Root",strRoot) ;

	// If the name is greater than 4 chars, just use the first 4.
	if(strRoot.GetLength() - 4)
	{
		Rootpart = strRoot.Left(4) ;
	}
	else
		Rootpart = strRoot ;
	// Generate the driver Classname.
	CString strValue ;

	awx.m_Dictionary.SetAt("cases_cpp",Rootpart+"case") ;
	awx.m_Dictionary.SetAt("cases_h",Rootpart+"case");
	awx.m_Dictionary.SetAt("type_cpp",Rootpart+"sub") ;
	awx.m_Dictionary.SetAt("type_h",Rootpart+"sub") ;
	awx.m_Dictionary.SetAt("PROJTYPE_DLL","1") ;

//  Insert the default values in the dialog. 
	awx.m_Dictionary.Lookup("type_h",strValue);     
	m_DriverH = strValue + ".h";     
	
	awx.m_Dictionary.Lookup("type_cpp",strValue);     
	m_DriverCpp  = strValue +".cpp";     

	m_TestOwner = "VCBU QA";      
 
	awx.m_Dictionary.Lookup("cases_cpp",strValue);     
	m_TestSetCpp  = strValue +".cpp";     

	awx.m_Dictionary.Lookup("cases_h",strValue);     
	m_TestSetH  = strValue +".h";     

	m_TestTitle= "TestWizard Generated script"; 
	
	//Uppercase first letter.
	CString ch = "C" ;
	strRoot = ch + strRoot ;
	//ch.MakeUpper() ;
	//strRoot = ch+strRoot.Right(strRoot.GetLength() -1) ;

	m_TestSetClass = strRoot+"IDETest"; 
    m_DriverClass = strRoot+"SubSuite" ;
    
    // Initialize the generated code values to empty so we can create a default empty script.
    awx.m_Dictionary.SetAt("Script_Text","") ; 
    awx.m_Dictionary.SetAt("TestFunctions",""); 
    awx.m_Dictionary.SetAt("ConfDeclarations", "") ; 
    awx.m_Dictionary.SetAt("FuncDeclarations","") ; 

   	CString numCases ;
   	numCases.Format("%d",0);
	awx.m_Dictionary.SetAt("NumCases",numCases) ;
        
   	UpdateData(FALSE) ;

   	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CPage1Dlg::OnDismiss()
{
	UpdateData(TRUE) ;

	if(m_DriverClass.IsEmpty())
	{
		MessageBox("More info is needed on this dialog","Missing Infomation",MB_OK|MB_ICONSTOP) ;
		return FALSE ;
	}

	//All these items need have to have a valid string.
	if(m_DriverH.IsEmpty()||
		m_DriverCpp.IsEmpty()||
		m_TestSetCpp.IsEmpty()||
		m_TestSetH.IsEmpty()||
		m_TestSetClass.IsEmpty()||
		m_DriverClass.IsEmpty())
	{
		MessageBox("All the editcontrols need a valid string.","Missing Infomation",MB_OK|MB_ICONSTOP) ;
		return FALSE ;
	}

	awx.m_Dictionary.SetAt("cases_cpp",m_TestSetCpp.SpanExcluding(".")) ;
	awx.m_Dictionary.SetAt("cases_h",m_TestSetH.SpanExcluding("."));
	awx.m_Dictionary.SetAt("type_cpp",m_DriverCpp.SpanExcluding(".")) ;
	awx.m_Dictionary.SetAt("type_h",m_DriverH.SpanExcluding(".")) ;
	awx.m_Dictionary.SetAt("TestOwner",m_TestOwner) ;
	awx.m_Dictionary.SetAt("TestClass",m_TestSetClass.SpanExcluding(".")) ;
	awx.m_Dictionary.SetAt("TestTitle",m_TestTitle) ;
	awx.m_Dictionary.SetAt("DriverClass",m_DriverClass) ;

	return TRUE ;
}
							 
BOOL CPage1Dlg::InitDrawingObjects() 
{
	static int FirstTime = 1 ;
	// Only do this stuff once.
	
	CClientDC ccldc(this) ;         
    ccldc.GetTextMetrics(&tm);
    cxChar = tm.tmAveCharWidth ;
    cxCaps = (tm.tmPitchAndFamily &1 ? 3 : 2) * cxChar/ 2 ;
    cyChar = tm.tmHeight + tm.tmExternalLeading ;

	// Create the brushes we need.
	// Only do this stuff once.
	if(FirstTime)
	{ 
		brSelRect.CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT)) ;
	 	brUnSelRect.CreateSolidBrush(GetSysColor(COLOR_WINDOW)) ; 
	   	penUnSelRect.CreatePen(PS_SOLID,2,GetSysColor(COLOR_WINDOW)) ;
	   	penSelRect.CreatePen(PS_SOLID,1,GetSysColor(COLOR_WINDOWFRAME)) ; 

		bmapTestCase.LoadBitmap(IDB_MOREITEMS) ; // Specifically for the TestCase tree. 
		bmapUnCheck.LoadBitmap(IDB_UNCHECK) ;
		bmapCheck.LoadBitmap(IDB_MYCHECK);
		bmapNomoreItems.LoadBitmap(IDB_NOMOREITEMS);
		bmapMoreItems.LoadBitmap(IDB_MOREITEMS);
		bmapNone.LoadBitmap(IDB_BLANKBITMAP);
		bmapTriangle.LoadBitmap(IDB_TRIANGLE);
		bmapWarn.LoadBitmap(IDB_WARNING);

		FirstTime = 0 ;
	}

	return TRUE; 
}

void CPage1Dlg::OnEditscript() 
{
	// TODO: Add your control notification handler code here
	TabCustomize CustomizePage ;
	ApiTabdlg	ApiPage ;

	ScriptPropSheet ScriptEditor("TestCase script editor",GetParent()) ;
	
	ScriptEditor.AddPage(&ApiPage) ;
	ScriptEditor.AddPage(&CustomizePage) ;

	OnDismiss(); //Updates the dictionary before bringing up the script dialog.
	
	InitDrawingObjects() ;// Sets up the pens, brushes, and loads the bitmaps.

	if(ScriptEditor.DoModal() == IDOK)
	{	//Disable the class editcontrols, since the user has made some script commitments which they can't change.
		m_TestSetCtrl.EnableWindow(FALSE) ;
		m_DriverCtrl.EnableWindow(FALSE) ;
		m_EditScriptButton.EnableWindow(FALSE) ;

		//Cleanup all the allocated memory.
		CScriptTree::ScriptHead->DeleteChild(ALL) ;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Src\owdlist.cpp ===
// owdlist.cpp : Ownerdraw listbox 

#include "stdafx.h"
#include "owdlist.h"
#include "scriptr.h"

/////////////////////////////////////////////////////////////////////////////
// Custom Listbox 
#define XBITMAP 20
#define YBITMAP 20

extern TEXTMETRIC tm ;
extern int cxChar, cxCaps, cyChar ;

// Pens and Brushes we need to show selections.
extern CBrush brSelRect ;
extern CBrush brUnSelRect ;
extern CPen   penUnSelRect ;
extern CPen   penSelRect ;
extern CBitmap bmapUnCheck, bmapCheck, bmapNomoreItems, bmapMoreItems,bmapNone ;								 

////////////////////////////////////////////////////////////////////////////

#define COLOR_ITEM_HEIGHT   20

void OwnerDrawLB::MeasureItem(LPMEASUREITEMSTRUCT lpMIS)
{
	// all items are of fixed size
	// must use LBS_OWNERDRAWVARIABLE for this to work
	lpMIS->itemHeight = COLOR_ITEM_HEIGHT;
}

void OwnerDrawLB::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
{
	if (lpDrawItemStruct->itemID >= 0) // Only if we have an item in the listbox 
	 {
	 	CDC* cdc = CDC::FromHandle(lpDrawItemStruct->hDC);
		CBitmap  *pbmap, *poldbmap;
		RECT sel ;

	 	CString cs ;
		CString &refcs = cs ;
	 	CDC compDC ;
		compDC.CreateCompatibleDC(cdc);

		GetText(lpDrawItemStruct->itemID,refcs) ;
		int indent =((CScriptTree* )GetItemData(lpDrawItemStruct->itemID))->m_level ;

		sel = lpDrawItemStruct->rcItem ;
		sel.left = sel.left + (XBITMAP * indent);

		if( ODA_DRAWENTIRE == lpDrawItemStruct->itemAction)
		{ //createcompatibleDC

		  	CDC compDC ;
			compDC.CreateCompatibleDC(cdc);

		 	if (!indent) 
				indent =1 ;
			pbmap = CBitmap::FromHandle((HBITMAP)((CScriptTree* )GetItemData(lpDrawItemStruct->itemID))->m_bmap->GetSafeHandle())/*(HBITMAP)GetItemData(lpDrawItemStruct->itemID*/ ;
		 	poldbmap = compDC.SelectObject(pbmap) ;

			// If the bitmap is NONE  then don't draw it.
			if(!(bmapNone.GetSafeHandle() == pbmap->GetSafeHandle()))
			{
				cdc->BitBlt(lpDrawItemStruct->rcItem.left ,lpDrawItemStruct->rcItem.top,
						lpDrawItemStruct->rcItem.right - lpDrawItemStruct->rcItem.left,
						lpDrawItemStruct->rcItem.bottom - lpDrawItemStruct->rcItem.top ,
						&compDC,0,0,SRCCOPY);
			}
		
			// If its a directive, color code it. Necessary just for the Script listbox in TestWizard
			//rip it out if not working in that context.
		  
			//	if((bmapNomoreItems.GetSafeHandle() == pbmap->GetSafeHandle()) || (bmapMoreItems.GetSafeHandle() == pbmap->GetSafeHandle()))
			if(!(bmapNone.GetSafeHandle() == pbmap->GetSafeHandle()))
			{
				cdc->SetTextColor(GetSysColor(COLOR_HIGHLIGHT)) ;
			}

		   	cdc->TextOut(XBITMAP * indent, /*lpDrawItemStruct->rcItem.left+lpDrawItemStruct->itemID*/ lpDrawItemStruct->rcItem.top,refcs ) ;
			cdc->SelectObject(poldbmap) ;
			cdc->SetTextColor(GetSysColor(COLOR_WINDOWTEXT)) ;
			compDC.DeleteDC() ;
			
		}

		// If selectced 
		if ((lpDrawItemStruct->itemState & ODS_SELECTED) &&
			(lpDrawItemStruct->itemAction & (ODA_SELECT | ODA_DRAWENTIRE)))
		{
			// Draw text with highlight color and background
			cdc->SelectObject(&brSelRect) ; 
  			cdc->SelectObject(&penSelRect) ;
  			cdc->Rectangle(&sel) ;
		
			cdc->SetTextColor(GetSysColor(COLOR_HIGHLIGHTTEXT)) ;
			cdc->SetBkColor(GetSysColor(COLOR_HIGHLIGHT)) ;
	     	
			// Bitmap 
			CDC compDC ;
			compDC.CreateCompatibleDC(cdc);

		  	pbmap = CBitmap::FromHandle((HBITMAP)((CScriptTree* )GetItemData(lpDrawItemStruct->itemID))->m_bmap->GetSafeHandle())/*(HBITMAP)GetItemData(lpDrawItemStruct->itemID*/ ;
			//pbmap = CBitmap::FromHandle((HBITMAP)GetItemData(lpDrawItemStruct->itemID)) ;
		 	poldbmap = compDC.SelectObject(pbmap) ;
			
			// If the bitmap is NONE  then don't draw it.
			if(!(bmapNone.GetSafeHandle() == pbmap->GetSafeHandle()))
			{
				cdc->BitBlt(lpDrawItemStruct->rcItem.left ,lpDrawItemStruct->rcItem.top,
						lpDrawItemStruct->rcItem.right - lpDrawItemStruct->rcItem.left,
						lpDrawItemStruct->rcItem.bottom - lpDrawItemStruct->rcItem.top ,
						&compDC,0,0,SRCCOPY);
			}
			if (!indent) 
				indent =1 ;
		   	cdc->TextOut(XBITMAP *indent, /*lpDrawItemStruct->rcItem.left+lpDrawItemStruct->itemID*/ lpDrawItemStruct->rcItem.top, refcs) ;
					
			//restore text colors
			cdc->SetTextColor(GetSysColor(COLOR_WINDOWTEXT)) ;
			cdc->SetBkColor(GetSysColor(COLOR_WINDOW)) ;
			//restore objects
			cdc->SelectObject(poldbmap) ;
			compDC.DeleteDC() ;
	   	}  
	 	
		if (!(lpDrawItemStruct->itemState & ODS_SELECTED) &&
			(lpDrawItemStruct->itemAction & ODA_SELECT))
		{
			// Item has been de-selected -- remove frame
		//	cdc->DrawFocusRect(&lpDrawItemStruct->rcItem) ;
			cdc->SelectObject(&brUnSelRect) ; 
			cdc->SelectObject(&penUnSelRect) ;
			cdc->Rectangle(&sel) ;

			// Draw bitmap
			pbmap = CBitmap::FromHandle((HBITMAP)((CScriptTree* )GetItemData(lpDrawItemStruct->itemID))->m_bmap->GetSafeHandle())/*(HBITMAP)GetItemData(lpDrawItemStruct->itemID*/ ;
			poldbmap = compDC.SelectObject(pbmap) ;
			
			// If the bitmap is NONE  then don't draw it.
			if(!(bmapNone.GetSafeHandle() == pbmap->GetSafeHandle()))
			{
					cdc->BitBlt(lpDrawItemStruct->rcItem.left ,lpDrawItemStruct->rcItem.top,
						lpDrawItemStruct->rcItem.right - lpDrawItemStruct->rcItem.left,
						lpDrawItemStruct->rcItem.bottom - lpDrawItemStruct->rcItem.top ,
						&compDC,0,0,SRCCOPY);
			}

			cdc->SetTextColor(GetSysColor(COLOR_WINDOWTEXT)) ;
			cdc->SetBkColor(GetSysColor(COLOR_WINDOW)) ;
	     	
			if (!(indent =((CScriptTree* )GetItemData(lpDrawItemStruct->itemID))->m_level))
				indent =1 ;

			
			// If its a directive, color code it. Necessary just for the Script listbox in TestWizard
			//rip it out if not working in that context.

			//if((bmapNomoreItems.GetSafeHandle() == pbmap->GetSafeHandle()) || (bmapMoreItems.GetSafeHandle() == pbmap->GetSafeHandle()))
			if(!(bmapNone.GetSafeHandle() == pbmap->GetSafeHandle()))
			{
				cdc->SetTextColor(GetSysColor(COLOR_HIGHLIGHT)) ;
			}

			cdc->TextOut(XBITMAP * indent, /*lpDrawItemStruct->rcItem.left+lpDrawItemStruct->itemID*/ lpDrawItemStruct->rcItem.top, refcs) ;
			//restore objects
			cdc->SelectObject(poldbmap) ;
			cdc->SetTextColor(GetSysColor(COLOR_WINDOWTEXT)) ;
			compDC.DeleteDC() ;

		}  
	 }
}

// Not yet implemented, still has the sample code from the color listbox.
int OwnerDrawLB::CompareItem(LPCOMPAREITEMSTRUCT lpCIS)
{
	COLORREF cr1 = (COLORREF)lpCIS->itemData1;
	COLORREF cr2 = (COLORREF)lpCIS->itemData2;
	if (cr1 == cr2)
		return 0;       // exact match

	// first do an intensity sort, lower intensities go first
	int intensity1 = GetRValue(cr1) + GetGValue(cr1) + GetBValue(cr1);
	int intensity2 = GetRValue(cr2) + GetGValue(cr2) + GetBValue(cr2);
	if (intensity1 < intensity2)
		return -1;      // lower intensity goes first
	else if (intensity1 > intensity2)
		return 1;       // higher intensity goes second

	// if same intensity, sort by color (blues first, reds last)
	if (GetBValue(cr1) > GetBValue(cr2))
		return -1;
	else if (GetGValue(cr1) > GetGValue(cr2))
		return -1;
	else if (GetRValue(cr1) > GetRValue(cr2))
		return -1;
	else
		return 1;
}

/////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Src\scriptpr.cpp ===
// scriptpr.cpp : implementation file
//

#include "stdafx.h"
#include "testwiz.h"
#include "scriptpr.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// ScriptPropSheet

IMPLEMENT_DYNAMIC(ScriptPropSheet, CPropertySheet)

ScriptPropSheet::ScriptPropSheet(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
}

ScriptPropSheet::ScriptPropSheet(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{
}

ScriptPropSheet::~ScriptPropSheet()
{
}


BEGIN_MESSAGE_MAP(ScriptPropSheet, CPropertySheet)
	//{{AFX_MSG_MAP(ScriptPropSheet)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// ScriptPropSheet message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Src\scriptpr.h ===
// scriptpr.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// ScriptPropSheet

class ScriptPropSheet : public CPropertySheet
{
	DECLARE_DYNAMIC(ScriptPropSheet)

// Construction
public:
	ScriptPropSheet(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	ScriptPropSheet(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(ScriptPropSheet)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~ScriptPropSheet();

	// Generated message map functions
protected:
	//{{AFX_MSG(ScriptPropSheet)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Src\dummymen.h ===
// dummymen.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// DUMMYMENU window

class DUMMYMENU : public CWnd
{
// Construction
public:
	DUMMYMENU();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(DUMMYMENU)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~DUMMYMENU();

	// Generated message map functions
protected:
	//{{AFX_MSG(DUMMYMENU)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Src\page1dlg.h ===
// page1dlg.h : header file
//


/////////////////////////////////////////////////////////////////////////////
// CPage1Dlg dialog

class CPage1Dlg : public CAppWizStepDlg
{
// Construction
public:
	CPage1Dlg();   // standard constructor

 virtual BOOL OnDismiss();
 BOOL InitDrawingObjects() ;
// Dialog Data
	//{{AFX_DATA(CPage1Dlg)
	enum { IDD = IDD_PAGE1 };
	CButton	m_EditScriptButton;
	CEdit	m_DriverCtrl;
	CEdit	m_TestSetCtrl;
	CString	m_DriverClass;
	CString	m_DriverH;
	CString	m_DriverCpp;
	CString	m_TestOwner;
	CString	m_TestSetClass;
	CString	m_TestSetCpp;
	CString	m_TestSetH;
	CString	m_TestTitle;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPage1Dlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CPage1Dlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnEditscript();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by testwiz.rc
//
#define IDC_SCRIPT_POPUP                101
#define IDS_ABOUTBOX                    101
#define ID_POPUP_WARN                   102
#define ID_POPUP_UP                     103
#define ID_POPUP_DOWN                   104
#define ID_POPUP_DELETE                 105
#define IDD_EDIT1                       106
#define IDD_EDITITEMTXT                 107
#define IDD_PAGE1                       129
#define IDB_MYCHECK                     129
#define IDD_PAGE2                       130
#define IDB_UNCHECK                     130
#define IDB_UNCHECK1                    132
#define IDD_API2                        133
#define IDB_MYCHECK1                    133
#define IDD_CUSTOMIZE                   134
#define IDB_MOREITEMS                   134
#define IDB_NOMOREITEMS                 135
#define IDD_API1                        135
#define IDD_API                         135
#define IDB_BLANKBITMAP                 136
#define IDR_MENU1                       138
#define IDD_DIALOG1                     140
#define IDI_ICON1                       146
#define IDI_ICON2                       147
#define IDB_TRIANGLE                    162
#define IDB_WARNING                     167
#define IDD_DIALOG2                     169
#define IDC_CURSOR1                     170
#define IDC_BUTTON1                     1000
#define IDC_EDIT1                       1000
#define IDS_BUILD_CATEGORY              1000
#define IDC_NEWTESTCASE                 1000
#define IDC_BUTTON2                     1001
#define IDC_ADD                         1001
#define IDC_TESTSET                     1001
#define IDS_CO_BP                       1001
#define IDC_BUTTON3                     1002
#define IDS_CO_BROWSER                  1002
#define IDC_BUTTON4                     1003
#define IDC_LIST1                       1003
#define IDS_CO_DEBUG                    1003
#define IDC_SCROLLBAR1                  1004
#define IDS_CO_EXCEPT                   1004
#define IDC_RADIO1                      1005
#define IDS_CO_PROJECT                  1005
#define IDC_RADIO2                      1006
#define IDC_SCROLLBAR2                  1007
#define IDC_MOVE_UP                     1007
#define IDC_MOVE_DOWN                   1008
#define IDC_CHECK2                      1009
#define IDC_CATEGORY                    1009
#define IDC_MOVE_UP2                    1009
#define IDC_CHECK3                      1010
#define IDC_CHECK4                      1011
#define IDC_EDIT3                       1011
#define IDC_CHECK5                      1012
#define IDC_CHECK6                      1013
#define IDC_CHECK7                      1014
#define IDC_RADIO3                      1014
#define IDC_OWDLIST                     1015
#define IDC_RADIO4                      1015
#define IDC_LIST2                       1016
#define IDC_DIRECTIVES1                 1017
#define IDC_REMOVE                      1018
#define IDC_SCRIPTLIST                  1019
#define IDC_LIST_COMPONENTS             1020
#define IDC_EDITSCRIPT                  1020
#define IDC_LIST_AREAS                  1020
#define IDC_LIST_API                    1021
#define IDC_LIST_PARAMETERS             1022
#define IDC_HIDE1                       1023
#define IDC_DRIVERC_PP                  1024
#define IDC_HID                         1024
#define IDC_HIDE                        1024
#define IDC_TESTSET_CPP                 1025
#define IDC_DRIVER_H                    1026
#define IDC_DESCRIPTION                 1026
#define IDC_TESTSET_H                   1027
#define IDC_OWNER                       1028
#define IDC_TITLE                       1029
#define IDC_DRIVER                      1030
#define IDC_DIRECTIVES                  1031
#define IDC_SCRIPTTEXT                  1033
#define IDC_CLASS_NAME                  1035
#define IDS_EDITORS_CATEGORY            2000
#define IDS_CO_DLG                      2001
#define IDS_CO_MENU                     2002
#define IDS_CO_RES                      2003
#define IDS_CO_SRC                      2004
#define IDS_IDE_CATEGORY                3000
#define IDS_UI_TOOLBAR                  3001
#define IDS_UI_TLS_CUST_DLG             3002
#define IDS_UI_TLS_OPT_DLG              3003
#define IDS_UI_WINDOW                   3004
#define IDS_END_CATEGORY                4000
#define IDS_ERROR_CANT_OPEN             59142

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        175
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1036
#define _APS_NEXT_SYMED_VALUE           108
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Src\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	again.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Src\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxtempl.h>
#include "testawx.h"		//AppWiz extension definitions.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Src\scriptr.h ===
//scriptr.h : Tree structure for the testcase structure.

#include "stdafx.h"

#ifndef _SCRIPT_TREE_
#define _SCRIPT_TREE_

#define HIDDEN 1
#define NOTHIDDEN 2
#define ALL -999
      
extern CBitmap bmapUnCheck, bmapCheck, bmapNomoreItems, bmapMoreItems,	bmapNone, bmapWarn ;								 

class CVariable: public CObject 
{
	public:
	CString ClsName ;
	CString VarName ;
} ;

class CScriptTree: public CObject
{
	public:
		CScriptTree(){m_Show = TRUE ; m_Hidable = FALSE ; m_TestCase = FALSE ; m_apiIndex = -1; }

		static CScriptTree * ScriptHead ;
		CListBox * m_Listbx ;
		int m_Hidable ;
		int m_level ;
		int m_index ;
		int m_parent ;
		int m_apiIndex;
		CBitmap *m_bmap ;
		CString m_Text ;
		CObArray m_Children ;
		CObArray m_VarInScope ;
		BOOL m_Show ;
		BOOL m_TestCase ;

		BOOL IsFocusOnListBox() ;
		void SetFocusOnListBox() ;
		BOOL IsTestCase() {return m_TestCase; } ;
		void HideVars_Blocks(int index = 0 ) ; 
		void AddToVarsInScope(CVariable * Var) {m_VarInScope.Add(Var);} ;
		void SetListBox(CWnd *plb) {m_Listbx = (CListBox *) plb ;} ;
		void SetBitmap(HBITMAP hbmap) {m_bmap =  CBitmap::FromHandle(hbmap); } ;
		void SetText(CString text) {m_Text = text ;} ;
		void SetIndex(int Index) {m_index = Index ;} ;
		void NotifyHeadofAddition(CScriptTree * head, int index) ;
		void NotifyHeadofDelete(CScriptTree * head, int index );//collapse = false, delete = true
		void CollapseTree(BOOL KillSelf = FALSE);
		void AddNode(CScriptTree * NewNode,int at = -999) ; //Update a node spacified by the index i.
		void ExpandTree(int index);
		void DeleteChild(int childIndex) ;
		void DumpIntoString(CString * buffer) ;
		void DrawScript(int index = 0)  ;
		void AddChild(CScriptTree * Child) ;
		void MakeUniqueEntries(CString * buffer, CString FuncName ) ;
		void MoveNode(int UpOrDown);
		void MoveUp(){MoveNode(-1) ;} ;
		void MoveDown(){MoveNode(1);} ;
		void DissownChild(int childIndex ); 


		CString GetObjectName(CString Class) ;
		CScriptTree * FindNode(int index) ;
		CScriptTree * FindParent(int index,CScriptTree * parent = ScriptHead) ;
		void ClearListbox() ;
		BOOL IsIndexInTree() ;
		BOOL IsTree() {return !((HBITMAP)bmapNone.GetSafeHandle() == (HBITMAP) m_bmap->GetSafeHandle());} ;
		BOOL IsExpanded() {return ((HBITMAP)bmapNomoreItems.GetSafeHandle()== (HBITMAP) m_bmap->GetSafeHandle());} ;
		BOOL IsCollapsed() {return ((HBITMAP)bmapMoreItems.GetSafeHandle()== (HBITMAP) m_bmap->GetSafeHandle());} ;
		BOOL IsWarningOFF() {return ((HBITMAP)bmapNone.GetSafeHandle()== (HBITMAP) m_bmap->GetSafeHandle());} ;
		BOOL IsWarningON() {return ((HBITMAP)bmapWarn.GetSafeHandle()== (HBITMAP) m_bmap->GetSafeHandle());} ;
		void WarningOFF() {SetBitmap((HBITMAP)bmapNone.GetSafeHandle());} ;
		void WarningON() {SetBitmap((HBITMAP)bmapWarn.GetSafeHandle());} ;


} ;

#endif // _SCRIPT_TREE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Src\testawx.cpp ===
#include "stdafx.h"
#include "TestWiz.h"
#include "testawx.h"
#include "chooser.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

void CTestWizAppWizExtension::InitCustomAppWiz()
{
	m_pChooser = new CDialogChooser;
	SetNumberOfSteps(NUM_DLGS);
}

void CTestWizAppWizExtension::ExitCustomAppWiz()
{
	ASSERT(m_pChooser != NULL);
	delete m_pChooser;
	m_pChooser = NULL;
}

CAppWizStepDlg* CTestWizAppWizExtension::Next(CAppWizStepDlg* rpDlg)
{
	return m_pChooser->Next(rpDlg);
}

CAppWizStepDlg* CTestWizAppWizExtension::Back(CAppWizStepDlg* rpDlg)
{
	return m_pChooser->Back(rpDlg);
}

CTestWizAppWizExtension awx;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Src\testawx.h ===
#include "customaw.h"
#ifndef _AWX_
#define _AWX_

class CDialogChooser;

class CTestWizAppWizExtension : public CCustomAppWiz
{
public:
	virtual CAppWizStepDlg* Next(CAppWizStepDlg* pDlg);
	virtual CAppWizStepDlg* Back(CAppWizStepDlg* pDlg);
		
	virtual void InitCustomAppWiz();
	virtual void ExitCustomAppWiz();
													  
protected:
	CDialogChooser* m_pChooser;
};

extern CTestWizAppWizExtension awx;

#endif //_AWX_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Src\tabcusto.h ===
// tabcusto.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// TabCustomize dialog
#ifndef _CUSTOMIZETAB_
#define _CUSTOMIZETAB_

class TabCustomize : public CPropertyPage
{
	DECLARE_DYNCREATE(TabCustomize)

// Construction
public:
	TabCustomize();
	~TabCustomize();

// Dialog Data
	//{{AFX_DATA(TabCustomize)
	enum { IDD = IDD_CUSTOMIZE };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(TabCustomize)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(TabCustomize)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

#endif ; //_CUSTOMIZETAB_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Src\scriptr.cpp ===
#include "stdafx.h"
#include "scriptr.h"

extern CBitmap  bmapTestCase;								 
//Implementation for the Script listbox tree .
CScriptTree *  CScriptTree::ScriptHead = NULL ; //Initialize head.

CString CScriptTree::GetObjectName(CString ClassName)
{	
	 CScriptTree * tmp ;
	int varCount = m_VarInScope.GetSize() ;
	for(int i = 0 ; i < varCount ; i++)
	{
		CVariable * var = (CVariable *) m_VarInScope.GetAt(i) ;
		if(var->ClsName == ClassName)
		{
			return var->VarName ;
		}
	}
	if (this == (CScriptTree::ScriptHead)) //We've come to the root of the tree in this scope
		return "NULL" ;
	
		tmp = CScriptTree::ScriptHead->FindParent(m_parent) ;
		CString result ;
		if ((result = tmp->GetObjectName(ClassName)) != "NULL")
	   	{
	   		return result ;
		}
	
		return "NULL" ;
}


CScriptTree * CScriptTree::FindParent(int index, CScriptTree * parent /*  = ScriptHead */)
{
	// The index passed in the index of the child. Use FindNode if you need to find a node before 
	// getting the parent index. 

	int children = m_Children.GetSize() ;

	if(m_index == index)
		return parent ;
	// Find a node with the given index
   	for(int i = 0 ; i < children; i++)
	{
		CScriptTree *Node ;
		Node = (CScriptTree *)(m_Children.GetAt(i)) ; 	
	   	if (Node = Node->FindParent(index, this)) 
			return Node ; 
	}

	return NULL ;
}

void CScriptTree::NotifyHeadofAddition(CScriptTree * head, int index) 
{
	int children = head->m_Children.GetSize() ;
  	// Find all nodes which are bellow the added one and update their location
  	for(int i = 0 ; i < children; i++)
	 {
		CScriptTree *Node ;
		Node = (CScriptTree *)(head->m_Children.GetAt(i)) ;		
	   	if(Node->m_index >= index ) // If the added node is above this in the listbox
		{	
			Node->m_index++ ;
			if(Node->m_parent >= index )  //Update the parent too if the new item is above.
				Node->m_parent++ ;
		}

		Node->NotifyHeadofAddition(Node,index);
	 }
}

void CScriptTree::NotifyHeadofDelete(CScriptTree * head, int index) 
{
	int children = head->m_Children.GetSize() ;
  	// Find all nodes which are bellow the deleted one and update their location
   	for(int i = 0 ; i < children; i++)
	 {
		CScriptTree *Node ;
		Node = (CScriptTree *)(head->m_Children.GetAt(i)) ;		
	   	if(Node->m_index > index ) // If the deleted node was above the this in the listbox
		{	
			Node->m_index-- ;
			if(Node->m_parent > index )  //Update the parent too if the new item is above.
				Node->m_parent-- ;

		}

		Node->NotifyHeadofDelete(Node,index);
	 }
}

CScriptTree * CScriptTree::FindNode(int index)
{
	int children = m_Children.GetSize() ;

	if(m_index == index)
		return this ;
	// Find a node with the given index
   	for(int i = 0 ; i < children; i++)
	{
		CScriptTree *Node ;
		Node = (CScriptTree *)(m_Children.GetAt(i)) ;		
	   	if (Node = Node->FindNode(index)) 
			return Node ;
	}

	return NULL ;
}

void CScriptTree::CollapseTree(BOOL KillSelf /* = FALSE*/)
{	
	int index = m_Listbx->GetCurSel() ;
	
	if(KillSelf) //We don't delete an item that the user clicked on.
	{
		index++ ; 
		m_Show = FALSE ;
		//m_Listbx->DeleteString(index+1) ;	
	}
		// If its just a leaf, ignore it.
	if(IsTree())
	{	// Only care about expanded trees, else just delete them.
	    if(IsExpanded())
		{	
		  	SetBitmap((HBITMAP)bmapMoreItems.GetSafeHandle());
			// How many children does it have?
			int children = m_Children.GetSize() ;
			CScriptTree *Node ;
			//If an item is a tree object collapse it, else delete the item
			for(int i = 0 ; i < children; i++)
			{
				Node = (CScriptTree *)(m_Children.GetAt(i)) ;		
				Node->CollapseTree(TRUE);
			}
		}
	   //Don't delete the item we are trying to collapse
		if(KillSelf)
		{
		//	m_Listbx->DeleteString(index) ;	
			m_Show = FALSE ;
		//	NotifyHeadofDelete(CScriptTree::ScriptHead,index); //Notify head 
		}
		else
		{ 
		//	m_Listbx->SetCurSel(index+1);
		//	SetBitmap((HBITMAP)bmapMoreItems.GetSafeHandle()) ;
		}
	}
	//Don't delete the item we are trying to collapse
	if(KillSelf)
	{
	//	m_Listbx->DeleteString(index) ;
		m_Show = FALSE ;	
	//	NotifyHeadofDelete(CScriptTree::ScriptHead,index); //Notify head 
	}


}

void CScriptTree::AddNode(CScriptTree * NewNode,int at /* = -999 */)
{
	int children = m_Children.GetSize() ;
	int index = m_index ;
	// Insert Node text 
	if ( -999 == at)
	{
		if(((NewNode->m_Text).SpanExcluding("{}")).IsEmpty()) // Don't indent braces from the parent.
			NewNode->m_level = m_level  ;
		else
			NewNode->m_level = m_level +1  ;	

		NewNode->m_parent = m_index ;
 		NewNode->SetIndex(m_index+children +1) ;  // Offset all the children from the parent index
		NotifyHeadofAddition(CScriptTree::ScriptHead,NewNode->m_index /*m_index+children +1*/) ;
   		m_Children.Add(NewNode) ;
  	}
	else
	{
		//Find a slot for the new node
		int i ;
		for(i = 0; i < children; i++)
		{
			CScriptTree *Node ;
			Node = (CScriptTree *)(m_Children.GetAt(i)) ;
			
			if (Node->m_index >= at) //WAS == not >= but changed for moving stuff.
				break ;		
		}
		NewNode->m_level = m_level + 1 ;
		NewNode->m_parent = m_index ;
		NewNode->SetIndex(at) ;
		NotifyHeadofAddition(CScriptTree::ScriptHead,at) ;
		m_Children.InsertAt(i ,NewNode) ;
	}
}


void CScriptTree::ExpandTree(int index ) //index = Current selection.
{
//	static int index = m_Listbx->GetCurSel() ;
 	int children = m_Children.GetSize() ;

	index++ ; // Expand the items under the parent!
	// Change the bitmap.
	if(IsCollapsed())
	{
		SetBitmap((HBITMAP)bmapNomoreItems.GetSafeHandle());
	}
	//Expand all the children of the clicked item.
	for(int i = 0 ; i < children; i++)
	{
		CScriptTree * Node ;
		Node = (CScriptTree *) m_Children.GetAt(i) ;
		Node->m_Show = TRUE ;
		Node->ExpandTree(index);
	}


}

void CScriptTree::DumpIntoString(CString * buffer)
{
	// Dumps the script text into the CString object pointer provided.
	//Start entering text from the 2nd level.
	if(m_level)
	{ 	//Insert a newline 
		*buffer = *buffer + "\n" ;
			for(int tabs = 1; tabs < m_level; tabs++)
			{
				*buffer = *buffer + "\t" ;
			}

		//If this is a TestCase item, prepend the className
		if(IsTestCase())
		{
			MakeUniqueEntries(buffer,m_Text) ;
		}
	/*	if((m_Text.SpanExcluding("{}").IsEmpty())||IsTestCase() || m_Text == " ")
		{
		  	*buffer = *buffer + m_Text ;  //No ";" on braces.
		}
		else */
	  	*buffer = *buffer + m_Text ; 
	}
	int children =m_Children.GetSize() ;
	for(int i = 0 ; i < children; i++)
	{
		CScriptTree *Node ;
		Node = (CScriptTree *)(m_Children.GetAt(i)) ;
	  	Node->DumpIntoString(buffer) ; 
	}
}

void CScriptTree::MakeUniqueEntries(CString * buffer, CString FuncName )
{
   	//Get the Testcase classname.
	static int iCases = 1 ;	 //used in IMPLEMENT_GET_NUM_TESTS macro in cases.cpp
	CString TestClass, numCases ;
	awx.m_Dictionary.Lookup("TestClass",TestClass) ;
	*buffer = *buffer +"void "+TestClass + "::" ; 

	// Make an entry into the Run function.
	CString TestFuncs ;
	awx.m_Dictionary.Lookup("TestFunctions",TestFuncs) ;
	TestFuncs = TestFuncs+"\n"+FuncName +";" ;
	awx.m_Dictionary.SetAt("TestFunctions",TestFuncs);

	//Make an entry in the header file and for the confirmation dialog.
	CString FuncDecs ; //declarations	  
	CString confDecs ;

	awx.m_Dictionary.Lookup("ConfDeclarations",confDecs) ;
	confDecs = confDecs+"\n"+"\t"+FuncName ;
	awx.m_Dictionary.SetAt("ConfDeclarations", confDecs) ;

	awx.m_Dictionary.Lookup("FuncDeclarations",FuncDecs) ;
	FuncDecs = FuncDecs+"\n"+"\t"+"void " + FuncName +";" ;
	awx.m_Dictionary.SetAt("FuncDeclarations",FuncDecs) ;

	numCases.Format("%d",iCases);
	awx.m_Dictionary.SetAt("NumCases",numCases) ;
	iCases++ ;

}


void CScriptTree::DrawScript(int index /* = 0 */) 
{
	if (m_Show &&(m_Hidable != HIDDEN)) 
	{ 
	   if(!index)
			ClearListbox() ;
	  	int count = m_Listbx->AddString(m_Text) ; //addstring GetCount
		// Attach Node bitmap 
		m_Listbx->SetItemData(count,(DWORD)this/*(DWORD)m_bmap->GetSafeHandle()*/) ;
  		index++ ;
		int children =m_Children.GetSize() ;
		for(int i = 0 ; i < children; i++)
		{
			CScriptTree *Node ;
			Node = (CScriptTree *)(m_Children.GetAt(i)) ;
	   		Node->DrawScript(index) ; 
		}
	}
}

// Tuggles the showing of Variables and block makers in the testscript.
void CScriptTree::HideVars_Blocks(int iHide/* = 0 */) 
{
	if(m_Hidable)
	{	
		if(!iHide)
			m_Hidable = NOTHIDDEN ;
		else
			m_Hidable = HIDDEN ;
	}
   	int children =m_Children.GetSize() ;
	for(int i = 0 ; i < children; i++)
	{
		CScriptTree *Node ;
		Node = (CScriptTree *)(m_Children.GetAt(i)) ;
   		Node->HideVars_Blocks(iHide) ; 
	}
}

void CScriptTree::ClearListbox() 
{			   
	m_Listbx->ResetContent() ;
}

void CScriptTree::MoveNode(int UpOrDown)  //ALL deletes all children
{
	int children ;
	CScriptTree * Child ; 

	m_index = m_index + UpOrDown ; 
	//Find the node to delete
	children = m_Children.GetSize();
	for(int i = 0 ; i < children; i++)
	{
		Child  = (CScriptTree *)m_Children.GetAt(i) ;
	    Child->MoveNode(UpOrDown) ;
	}
	return ; 
}

void CScriptTree::DissownChild(int childIndex ) 
{
	int children ;
	CScriptTree * Target ; 
	children = m_Children.GetSize();
	for(int i = 0 ; i < children; i++)
	{
		Target  = (CScriptTree *)m_Children.GetAt(i) ;
		if (childIndex == Target->m_index)
		{
			m_Children.RemoveAt(i) ;
			break ;
		}
	}
	
}

void CScriptTree::SetFocusOnListBox() 
{
	m_Listbx->SetFocus() ;	
}

BOOL CScriptTree::IsFocusOnListBox()
{
	 HWND focus = GetFocus() ;
	 return (focus == m_Listbx->m_hWnd) ;
} 


void CScriptTree::DeleteChild(int childIndex /* = ALL*/ )  //ALL deletes all children
{
	int children ;
	CScriptTree * Target ; 
	//Find the node to delete
	if(childIndex != ALL)
	{
		Target = FindNode(childIndex) ;
		Target->DeleteChild(ALL) ;
		//Delete the Variables in this node 
		int varCount = Target->m_VarInScope.GetSize() ;
		if(varCount)
		{
			for(int i = 0 ;i < varCount; i++)
			{
				delete Target->m_VarInScope.GetAt(i) ;
			}
		}
		//fix up the indices after a delete
		NotifyHeadofDelete(CScriptTree::ScriptHead, Target->m_index) ;

		// Remove the item from the chilren's array.
		children = m_Children.GetSize();
		for(int i = 0 ; i < children; i++)
		{
			Target  = (CScriptTree *)m_Children.GetAt(i) ;
			if (childIndex == Target->m_index)
			{
				m_Children.RemoveAt(i) ;
				break ;
			}
		}
		delete Target ;
		return ;
	}
	else
	{
		children = m_Children.GetSize();
		for(int i = 0 ; i < children; i++)
		{
			Target  = (CScriptTree *)m_Children.GetAt(i) ;
		    Target->DeleteChild(ALL) ;
		
			//Delete the Variables in this node 
			int varCount = Target->m_VarInScope.GetSize() ;
			if(varCount)
			{
				for(int i = 0 ;i < varCount; i++)
				{
					delete Target->m_VarInScope.GetAt(i) ;
				}
			}
			//fix up the indices after a delete
			NotifyHeadofDelete(CScriptTree::ScriptHead, Target->m_index) ;
			//Remove item from the array
			m_Children.RemoveAt(i) ;
			delete Target ;
			return ;
		}
	} 
}

BOOL CScriptTree::IsIndexInTree() 
{ 
	return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Src\tabcusto.cpp ===
// tabcusto.cpp : implementation file
//

#include "stdafx.h"
#include "testwiz.h"
#include "tabcusto.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// TabCustomize property page

IMPLEMENT_DYNCREATE(TabCustomize, CPropertyPage)

TabCustomize::TabCustomize() : CPropertyPage(TabCustomize::IDD)
{
	//{{AFX_DATA_INIT(TabCustomize)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

TabCustomize::~TabCustomize()
{
}

void TabCustomize::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(TabCustomize)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(TabCustomize, CPropertyPage)
	//{{AFX_MSG_MAP(TabCustomize)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// TabCustomize message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Src\testwiz.cpp ===
// TestWiz.cpp : Defines the initialization routines for the DLL.
//

#include "stdafx.h"
#include "TestWiz.h"
#include "chooser.h"
#include "testawx.h"
#include <afxdllx.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

static AFX_EXTENSION_MODULE TestWizDLL = { NULL, NULL };

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		TRACE0("TestWiz.DLL Initializing!\n");
		
		// Extension DLL one-time initialization
		AfxInitExtensionModule(TestWizDLL, hInstance);

		// Insert this DLL into the resource chain
		new CDynLinkLibrary(TestWizDLL);
		SetCustomAppWizClass(&awx);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		TRACE0("TestWiz.DLL Terminating!\n");
	}
	return 1;   // ok
}

/*HINSTANCE GetResourceHandle()
{
	return TestWizDLL.hModule;
}
 */
/*extern "C" APWZ_EXPORT CTestWizAppWizExtension* GetCustomAppWizClass()
{
	return &awx;
} */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Src\testwiz.h ===
#ifndef __TESTWIZ_H__
#define __TESTWIZ_H__

#include "resource.h"

#define APWZ_EXPORT	__declspec(dllexport)


#endif //__TESTWIZ_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Src\treelist.h ===
// treelist.h : Ownerdraw listbox 

#include "stdafx.h"

#ifndef _AREALISTBOX_
#define _AREALISTBOX_

class CAreasLB : public CListBox
{
public:
// Implementation
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMIS);
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDIS);
	virtual int CompareItem(LPCOMPAREITEMSTRUCT lpCIS);
};

#endif // _CUSTOMLISTBOX_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Src\Template\clwcases.h ===
///////////////////////////////////////////////////////////////////////////////
//	$$cases_h$$.h
//
//	Created by :			
//		$$TestOwner$$
//
//	Description :
//		Declaration of the $$TestClass$$ Class
//

#ifndef __CLWCASES_H__
#define __CLWCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif
#include "$$type_cpp$$.h"

///////////////////////////////////////////////////////////////////////////////
//	$$TestClass$$ class

class $$TestClass$$ : public CTest
{
    DECLARE_TEST($$TestClass$$, $$DriverClass$$)

// Operations
public:
	virtual void Run(void);

// Data
protected:

// Test Cases
protected:
$$FuncDeclarations$$
};

#endif //__CLWCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Src\Template\clwcases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	$$cases_cpp$$.CPP
//											 
//	Created by :			
//		$$TestOwner$$		
//
//	Description :								 
//		$$TestTitle$$		 

#include "stdafx.h"
#include "$$cases_cpp$$.h"					 	 
											   
#define VERIFY_TEST_SUCCESS(TestCase)\
	TestCase == ERROR_SUCCESS

IMPLEMENT_TEST($$TestClass$$, CTest, "$$TestTitle$$", -1, $$DriverClass$$)
												 
void $$TestClass$$::Run(void)
{
$$TestFunctions$$

}

$$Script_Text$$
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Src\Template\clwsnif.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	$$cases_cpp$$.CPP
//
//	Created by :			
//		$$TestOwner$$		
//
//	Description :
//		implementation of the $$DriverClass$$ class
//

#include "stdafx.h"
#include "$$type_cpp$$.h"

#include "$$cases_cpp$$.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// The $$DriverClass$$ object

IMPLEMENT_SUBSUITE($$DriverClass$$, CIDESubSuite, "$$TestTitle$$", "$$TestOwner$$")

BEGIN_TESTLIST($$DriverClass$$)
	TEST($$TestClass$$, RUN)
END_TESTLIST()


void $$DriverClass$$::SetUp(BOOL bCleanUp)
{
	// call the base class
	CIDESubSuite::SetUp(bCleanUp);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Src\Template\clwsnif.h ===
///////////////////////////////////////////////////////////////////////////////
//	$$type_h$$.h
//
//	Created by :			
//		$$TestOwner$$
//
//	Description :
//		Declaration of the $$DriverClass$$ class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__
			 
#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// $$DriverClass$$ class

class $$DriverClass$$ : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE($$DriverClass$$)

	DECLARE_TESTLIST();

	virtual void SetUp(BOOL bCleanUp);
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Src\treelist.cpp ===
// treelist.cpp : Ownerdraw listbox 

#include "stdafx.h"
#include "treelist.h"
/////////////////////////////////////////////////////////////////////////////
// Custom Listbox 
#define XBITMAP 30
#define YBITMAP 20

extern TEXTMETRIC tm ;
extern int cxChar, cxCaps, cyChar ;

// Pens and Brushes we need to show selections.
extern CBrush brSelRect ;
extern CBrush brUnSelRect ;
extern CPen   penUnSelRect ;
extern CPen   penSelRect ;
extern CBitmap bmapUnCheck, bmapCheck, bmapTriangle;								 

////////////////////////////////////////////////////////////////////////////

#define COLOR_ITEM_HEIGHT   20

void CAreasLB::MeasureItem(LPMEASUREITEMSTRUCT lpMIS)
{
	// all items are of fixed size
	// must use LBS_OWNERDRAWVARIABLE for this to work
	lpMIS->itemHeight = COLOR_ITEM_HEIGHT;
}

void CAreasLB::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
{
	if (lpDrawItemStruct->itemID >= 0) // Only if we have an item in the listbox 
	 {
	 	CDC* cdc = CDC::FromHandle(lpDrawItemStruct->hDC);
		CBitmap  *pbmap, *poldbmap;
		RECT sel ;

	 	CString cs ;
		CString &refcs = cs ;
	 	CDC compDC ;
		compDC.CreateCompatibleDC(cdc);

		GetText(lpDrawItemStruct->itemID,refcs) ;
	
		sel = lpDrawItemStruct->rcItem ;
		sel.left = sel.left ; // + XBITMAP ;

		if( ODA_DRAWENTIRE == lpDrawItemStruct->itemAction)
		{ //createcompatibleDC

		  	CDC compDC ;
			compDC.CreateCompatibleDC(cdc);

			pbmap = CBitmap::FromHandle((HBITMAP)GetItemData(lpDrawItemStruct->itemID)) ;
		 	poldbmap = compDC.SelectObject(pbmap) ;
			//Draw the bitmap
			cdc->BitBlt(lpDrawItemStruct->rcItem.left ,lpDrawItemStruct->rcItem.top,
						lpDrawItemStruct->rcItem.right - lpDrawItemStruct->rcItem.left,
						lpDrawItemStruct->rcItem.bottom - lpDrawItemStruct->rcItem.top ,
						&compDC,0,0,SRCCOPY);
			//Draw the text 
		   	cdc->TextOut(XBITMAP,lpDrawItemStruct->rcItem.top,refcs ) ;
			cdc->SelectObject(poldbmap) ;
			compDC.DeleteDC() ;
			
		}

		// If selectced 
		if ((lpDrawItemStruct->itemState & ODS_SELECTED) &&
			(lpDrawItemStruct->itemAction & (ODA_SELECT | ODA_DRAWENTIRE)))
		{
			// Draw text with highlight color and background
			cdc->SelectObject(&brSelRect) ; 
  			cdc->SelectObject(&penSelRect) ;
  			cdc->Rectangle(&sel) ;
		
			cdc->SetTextColor(GetSysColor(COLOR_HIGHLIGHTTEXT)) ;
			cdc->SetBkColor(GetSysColor(COLOR_HIGHLIGHT)) ;
	     	
			// Bitmap 
			CDC compDC ;
			compDC.CreateCompatibleDC(cdc);

			pbmap = CBitmap::FromHandle((HBITMAP)GetItemData(lpDrawItemStruct->itemID)) ;
		 	poldbmap = compDC.SelectObject(pbmap) ;
			cdc->BitBlt(lpDrawItemStruct->rcItem.left ,lpDrawItemStruct->rcItem.top,
						lpDrawItemStruct->rcItem.right - lpDrawItemStruct->rcItem.left,
						lpDrawItemStruct->rcItem.bottom - lpDrawItemStruct->rcItem.top ,
						&compDC,0,0,SRCCOPY);
		
		   	cdc->TextOut(XBITMAP, lpDrawItemStruct->rcItem.top, refcs) ;
					
			//restore text colors
			cdc->SetTextColor(GetSysColor(COLOR_WINDOWTEXT)) ;
			cdc->SetBkColor(GetSysColor(COLOR_WINDOW)) ;
			//restore objects
			cdc->SelectObject(poldbmap) ;
			compDC.DeleteDC() ;


	   	}  
	 	
		if (!(lpDrawItemStruct->itemState & ODS_SELECTED) &&
			(lpDrawItemStruct->itemAction & ODA_SELECT))
		{
			// Item has been de-selected -- remove frame
			cdc->SelectObject(&brUnSelRect) ; 
			cdc->SelectObject(&penUnSelRect) ;
			cdc->Rectangle(&sel) ;

			// Draw bitmap
			pbmap = CBitmap::FromHandle((HBITMAP)GetItemData(lpDrawItemStruct->itemID)) ;
			poldbmap = compDC.SelectObject(pbmap) ;
			cdc->BitBlt(lpDrawItemStruct->rcItem.left ,lpDrawItemStruct->rcItem.top,
						lpDrawItemStruct->rcItem.right - lpDrawItemStruct->rcItem.left,
						lpDrawItemStruct->rcItem.bottom - lpDrawItemStruct->rcItem.top ,
						&compDC,0,0,SRCCOPY);
						
			cdc->SetTextColor(GetSysColor(COLOR_WINDOWTEXT)) ;
			cdc->SetBkColor(GetSysColor(COLOR_WINDOW)) ;
	     	
			cdc->TextOut(XBITMAP,lpDrawItemStruct->rcItem.top, refcs) ;
			//restore objects
			cdc->SelectObject(poldbmap) ;
			compDC.DeleteDC() ;

		}  
	 }
}

// Not yet implemented, still has the sample code from the color listbox.
int CAreasLB::CompareItem(LPCOMPAREITEMSTRUCT lpCIS)
{
	COLORREF cr1 = (COLORREF)lpCIS->itemData1;
	COLORREF cr2 = (COLORREF)lpCIS->itemData2;
	if (cr1 == cr2)
		return 0;       // exact match

	// first do an intensity sort, lower intensities go first
	int intensity1 = GetRValue(cr1) + GetGValue(cr1) + GetBValue(cr1);
	int intensity2 = GetRValue(cr2) + GetGValue(cr2) + GetBValue(cr2);
	if (intensity1 < intensity2)
		return -1;      // lower intensity goes first
	else if (intensity1 > intensity2)
		return 1;       // higher intensity goes second

	// if same intensity, sort by color (blues first, reds last)
	if (GetBValue(cr1) > GetBValue(cr2))
		return -1;
	else if (GetGValue(cr1) > GetGValue(cr2))
		return -1;
	else if (GetRValue(cr1) > GetRValue(cr2))
		return -1;
	else
		return 1;
}

/////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Src\Template\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		$$TestOwner$$		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\TestWiz\Src\Template\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		$$TestOwner$$		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\AutoComplete\Sniff\Src\AutoCompleteCases.h ===
///////////////////////////////////////////////////////////////////////////////
//	AutoCompleteCases.H
//
//	Description :
//		Declaration of the CAutoCompleteCases class
//

#ifndef __AutoCompleteCases_H__
#define __AutoCompleteCases_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "AutoCompleteSuite.h"

///////////////////////////////////////////////////////////////////////////////
//	CAutoCompleteCases class

class CAutoCompleteCases : public CTest
{
	DECLARE_TEST(CAutoCompleteCases, CAutoCompleteSuite)

// Operations
public:
	virtual void Run(void);
	BOOL EditSource();

// Member variables
public:
	COSource  src;
};

#endif //__AutoCompleteCases_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\AutoComplete\Sniff\Src\AutoCompleteSuite.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	AutoCompleteSuite.Cpp
//
//	Description :
//		Implementation of the CAutoCompleteSuite class
//

#include "stdafx.h"
#include "afxdllx.h"
#include "AutoCompleteSuite.h"

// ADD INCLUDES FOR CASES HERE
// EXAMPLE: #include "Feature1Cases.h"
#include "AutoCompleteCases.h"
#include "ParameterHelpCases.h"
#include "CodeCommentsCases.h"
#include "TypeInfoCases.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CAutoCompleteSuite

IMPLEMENT_SUBSUITE(CAutoCompleteSuite, CIDESubSuite, "AutoComplete", "a-JohnC x27223")

BEGIN_TESTLIST(CAutoCompleteSuite)
// ADD "TEST" ENTRY FOR CASES HERE
// EXAMPLE: TEST(CFeature1Cases, RUN)
	TEST(CAutoCompleteCases, RUN)
	TEST(CParameterHelpCases, RUN)
	TEST(CCodeCommentsCases, RUN)
	TEST(CTypeInfoCases, RUN)
END_TESTLIST()

void CAutoCompleteSuite::SetUp(BOOL bCleanUp)
{

	int nResult;
	int nCount;

	KillAllFiles(m_strCWD + "baseln\\AutoComp01");
	nResult = prj.NewProject(UIAW_PT_APPWIZ, "AutoComp01", m_strCWD + "baseln\\AutoComp01", PLATFORM_WIN32_X86);

	if (nResult == ERROR_SUCCESS) {
		m_pLog->RecordSuccess("Created the project.");

		// Expand the ClassView tree
		MST.DoKeys("%0");
		Sleep(2000);
		MST.DoKeys("{UP}");
		Sleep(2000);
		MST.DoKeys("*");
		Sleep(2000);
		MST.DoKeys("*");
		Sleep(2000);
	}
	else {
		m_pLog->RecordFailure("Failed creating project %sbaseln\\AutoComp01", m_strCWD);
	}

	// Open a source file
	nResult = src.Open(m_strCWD + "baseln\\AutoComp01\\"+"AutoComp01.cpp");
	Sleep(1000);

	if (nResult == ERROR_ERROR) {
		m_pLog->RecordFailure("Couldn't open source file AutoComp01.cpp");
	}
	else {
		// Make some modifications to the CAboutDlg class
		src.GoToLine(112);
	
		// Wait for Go To dialog to go away
		nCount = 0;
		while ((MST.WFndWnd("Go To", FW_DEFAULT)) && (nCount < 1000)) {
			nCount++;
		}

		MST.DoKeys("{END}{ENTER 2}");
		MST.DoKeys("// Nonsense function for testing purposes{ENTER}");
		MST.DoKeys("void foo{(}int i, float f, char* str{)};{ENTER}");

		src.GoToLine(148);
	
		// Wait for Go To dialog to go away
		nCount = 0;
		while ((MST.WFndWnd("Go To", FW_DEFAULT)) && (nCount < 1000)) {
			nCount++;
		}

		MST.DoKeys("{END}{ENTER 2}");
		MST.DoKeys("void CAboutDlg::foo{(}int i, float f, char* str{)}{ENTER}");
		MST.DoKeys("{{}");
		MST.DoKeys("{ENTER}");
		MST.DoKeys("return;{ENTER}");
		MST.DoKeys("{}}");
		MST.DoKeys("{ENTER}");
		Sleep(1000);

		// Save changes and close source
		src.Save();
		src.Close(TRUE);
	}
}

void CAutoCompleteSuite::CleanUp(void)
{

	int nResult;

	// Close the project;
	nResult = prj.Close(FALSE);

	if (nResult != ERROR_SUCCESS) {
		m_pLog->RecordFailure(_T("Failed closing the project."));
	}
	else {
		m_pLog->RecordSuccess(_T("Closed the project."));
	}

	CIDESubSuite::CleanUp();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\VC6TestRunner\VC6TestRunner.cpp ===
#include <afxwin.h>
#include <windowsx.h>
#include "resource.h"


BOOL CALLBACK MainDlgProc(HWND hWndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK LoadRunDlgProc(HWND hWndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
void CreateWebPageName(void);
void CreateWebPage(void);
void DetermineWhichTestsPassed(void);
void InstallTests(void);
void RunTests(void);
void SetCafeEnvironment(void);
void DeleteRegistryKey(LPCSTR pszKeyName);
void DeleteRegistrySubKeys(HKEY hKey);
void DeleteTree(CString strPath);
void AppendToLogs(CString strLogNew);
void GetRunsListViewDisplayInfo(NMLVDISPINFO *plvDispInfo);


// the different types of tests.
typedef enum {SNIFFS, SNAPS} TEST_TYPE;


// holds all the information about a test run.
class CTestRun
{
public:
	CString		m_strTitle;
	TEST_TYPE	m_TestType;
	BOOL		m_boolPublishOnWeb;
	BOOL		m_boolRerunFailedTests;
	CString		m_strVCRelease;
	CString		m_strVCLang;
	CString		m_strOS;
	CString		m_strOSRelease;
	CString		m_strOSLang;
	CString		m_strCPU;
	CString		m_strNumCPU;
	CString		m_strSpeed;
	CString		m_strRAM;
	CString		m_strDelay;
	CString		m_strPeriod;
	CString		m_strStepSleep;
	CString		m_strTestDir;
	int			m_intFirstTest;
	int			m_intLastTest;
	CString		m_strWebPageName;
} TestRun;


// holds all the information about a test run that can be loaded.
class CTestRunToLoad
{
public:
	CString			m_strTitle;
	CString			m_strVCRelease;
	CString			m_strVCLang;
	CString			m_strOS;
	CString			m_strOSLang;
	CString			m_strCPU;
	CString			m_strNumCPU;
	CString			m_strSpeed;
	CString			m_strRAM;
	CTestRunToLoad	*m_pNext;
};


// always points to the first run in the list so we can traverse it.
CTestRunToLoad *pTestRunsToLoadHome = NULL;
// points to the test run the user chose to load.
CTestRunToLoad *pTestRunChosen;


// holds all the information about a test.
class CTest
{
public:
	LPCSTR	m_szName;
	BOOL	m_boolPassed;
	LPCSTR	m_szGroup;
	LPCSTR	m_szDllPath;
};


// count of sniffs and snaps.
#define SNIFF_COUNT 11
#define SNAP_COUNT	13


// information on the sniffs and snaps.
CTest Tests[] =

{
	// sniffs.
	{"AutoComplete",			FALSE,	"Sniffs",			"AutoComplete\\AutoComplete.dll"},
	{"Browser",					FALSE,	"Sniffs",			"Browser\\Browser.dll"},	
	{"Data",					FALSE,	"Sniffs",			"Data\\Data.dll"},
	{"Debugger",				FALSE,	"Sniffs",			"Debugger\\Debugger.dll"},
	{"Editor",					FALSE,	"Sniffs",			"Editor\\Editor.dll"},
	{"ProjBld",					FALSE,	"Sniffs",			"ProjBld\\ProjBld.dll"},
	{"SDI",						FALSE,	"Sniffs",			"SDI\\SDI.dll"},
	{"Sys",						FALSE,	"Sniffs",			"Sys\\Sys.dll"},
	{"VRes",					FALSE,	"Sniffs",			"VRes\\VRes.dll"},
	{"VShell",					FALSE,	"Sniffs",			"VShell\\VShell.dll"},
	{"Wizards",					FALSE,	"Sniffs",			"Wizards\\Wizards.dll"},
	// debugger snaps.
	{"Breakpoints",				FALSE,	"Debugger Snaps",	"Debugger\\Core\\Breakpoints.dll"},
	{"CallStack",				FALSE,	"Debugger Snaps",	"Debugger\\Core\\CallStack.dll"},
	{"Disassembly",				FALSE,	"Debugger Snaps",	"Debugger\\Core\\Disassembly.dll"},
	{"ExpressionEvaluation",	FALSE,	"Debugger Snaps",	"Debugger\\Core\\EE.dll"},
	{"Execution",				FALSE,	"Debugger Snaps",	"Debugger\\Core\\Execution.dll"},
	{"Memory",					FALSE,	"Debugger Snaps",	"Debugger\\Core\\Memory.dll"},
	{"Namespaces",				FALSE,	"Debugger Snaps",	"Debugger\\Core\\Namespaces.dll"},
	{"NLG",						FALSE,	"Debugger Snaps",	"Debugger\\Core\\NLG.dll"},
	{"Registers",				FALSE,	"Debugger Snaps",	"Debugger\\Core\\Registers.dll"},
	{"ReturnValues",			FALSE,	"Debugger Snaps",	"Debugger\\Core\\ReturnValues.dll"},
	{"Threads",					FALSE,	"Debugger Snaps",	"Debugger\\Core\\Threads.dll"},
	{"Templates",				FALSE,	"Debugger Snaps",	"Debugger\\Core\\Templates.dll"},
	{"Variables",				FALSE,	"Debugger Snaps",	"Debugger\\Core\\Variables.dll"},
/*
	TODO: need to enable these when we have support for picking specific groups of snaps.
	// projbld snaps.
	{"BatchBuild",				FALSE,	"ProjBld Snaps",	"ProjBld\\batchbld.dll"},
	{"Build",					FALSE,	"ProjBld Snaps",	"ProjBld\\build.dll"},
	{"Conversion",				FALSE,	"ProjBld Snaps",	"ProjBld\\convers.dll"},
	{"CustomBuild",				FALSE,	"ProjBld Snaps",	"ProjBld\\customb.dll"},
	{"DefaultProject",			FALSE,	"ProjBld Snaps",	"ProjBld\\defaultp.dll"},
	{"Dependencies",			FALSE,	"ProjBld Snaps",	"ProjBld\\depend.dll"},
	{"ExportMakefile",			FALSE,	"ProjBld Snaps",	"ProjBld\\exportmf.dll"},
	{"External",				FALSE,	"ProjBld Snaps",	"ProjBld\\external.dll"},
	{"Options",					FALSE,	"ProjBld Snaps",	"ProjBld\\options.dll"},
	{"Sub-projects",			FALSE,	"ProjBld Snaps",	"ProjBld\\subprjs.dll"},
	// resedit snaps.
	{"BindCtrl",				FALSE,	"ResEdit Snaps",	"ResEdit\\BindCtrl.dll"},
	// wizards snaps.
	{"Components",				FALSE,	"Wizards Snaps",	"Wizards\\Components.dll"},
*/
};


// count of various main dlg combo box items.
#define TEST_TYPE_COUNT		2
#define VC_RELEASE_COUNT	6
#define LANG_COUNT			3
#define OS_COUNT			7
#define OS_RELEASE_COUNT	9
#define CPU_COUNT			7


// the options for various combo boxes in the dlg.
char *szTestType[TEST_TYPE_COUNT]	= {"Sniffs", "Snaps"};
char *szVCRelease[VC_RELEASE_COUNT]	= {"", "SP1", "SP2", "SP3", "SP4", "SP4-PP"};
char *szLang[LANG_COUNT]			= {"English", "German", "Japanese"};
char *szOS[OS_COUNT]				= {"Millennium", "NT4 Workstation", "NT4 Server",
									   "Win2k Pro", "Win2k Server", "Win95", "Win98"};
char *szOSRelease[OS_RELEASE_COUNT]	= {"", "OSR2", "SE", "SP1", "SP2", "SP3", "SP4", "SP5", "SP6"};
char *szCPU[CPU_COUNT]				= {"Itanium", "K6", "K7", "Pentium", "Pentium II", "Pentium III", "WNI"};


// for referencing each control on the main dlg in the MainControls array below.
enum
{
	EDIT_TITLE,
	RADIO_SNIFFS,
	RADIO_SNAPS,
	CHECK_INSTALL_TESTS,
	CHECK_PUBLISH_RESULTS_ON_WEB,
	CHECK_RERUN_FAILED_TESTS,
	COMBO_VC_RELEASE,
	COMBO_VC_LANG,
	COMBO_OS,
	COMBO_OS_RELEASE,
	COMBO_OS_LANG,
	COMBO_CPU,
	EDIT_NUM_CPU,
	EDIT_SPEED,
	EDIT_RAM,
	EDIT_DELAY,
	EDIT_PERIOD,
	EDIT_STEPSLEEP,
	EDIT_LOG,
} MAIN_CONTROLS;


// holds all the information about a dlg control.
class CControl
{
public:
	HWND	m_hWnd;
	int		m_intID;
};


// count of the controls on the main dlg.
#define MAIN_CONTROL_COUNT 19


// information on the controls on the main dlg.
CControl MainControls[] = 
{
	{NULL, IDC_EDIT_TITLE},
	{NULL, IDC_RADIO_SNIFFS},
	{NULL, IDC_RADIO_SNAPS},
	{NULL, IDC_CHECK_INSTALL_TESTS},
	{NULL, IDC_CHECK_PUBLISH_RESULTS_ON_WEB},
	{NULL, IDC_CHECK_RERUN_FAILED_TESTS},
	{NULL, IDC_COMBO_VC_RELEASE},
	{NULL, IDC_COMBO_VC_LANG},
	{NULL, IDC_COMBO_OS},
	{NULL, IDC_COMBO_OS_RELEASE},
	{NULL, IDC_COMBO_OS_LANG},
	{NULL, IDC_COMBO_CPU},
	{NULL, IDC_EDIT_NUM_CPU},
	{NULL, IDC_EDIT_SPEED},
	{NULL, IDC_EDIT_RAM},
	{NULL, IDC_EDIT_DELAY},
	{NULL, IDC_EDIT_PERIOD},
	{NULL, IDC_EDIT_STEPSLEEP},
	{NULL, IDC_EDIT_LOG},
};


// we want to log all over the place so it's just easier to make these global rather than passing them around.
FILE *pfileDebugLog;
CString strLog, strLogNew;
// the main dlg proc needs this to invoke the Load Run dlg.
HINSTANCE ghInstance;

int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)
{
	ghInstance = hInstance;
	return DialogBox(hInstance, MAKEINTRESOURCE(IDD_VC6_TEST_RUNNER), NULL, MainDlgProc);
}


BOOL CALLBACK MainDlgProc(HWND hWndDlg, UINT msg, WPARAM wParam, LPARAM lParam)

{
	int i;

	switch(msg)		

	{
		case WM_INITDIALOG:
		{
			// get the handles to the windows of all the controls so we can get and set their values.
			for(i = 0; i < MAIN_CONTROL_COUNT; i++)
				MainControls[i].m_hWnd = GetDlgItem(hWndDlg, MainControls[i].m_intID);
			// populate all the combo boxes.
			for(i = 0; i < VC_RELEASE_COUNT; i++)
				SendMessage(MainControls[COMBO_VC_RELEASE].m_hWnd, CB_ADDSTRING, 0, (LPARAM)szVCRelease[i]);
			for(i = 0; i < LANG_COUNT; i++)
				SendMessage(MainControls[COMBO_VC_LANG].m_hWnd, CB_ADDSTRING, 0, (LPARAM)szLang[i]);
			for(i = 0; i < OS_COUNT; i++)
				SendMessage(MainControls[COMBO_OS].m_hWnd, CB_ADDSTRING, 0, (LPARAM)szOS[i]);
			for(i = 0; i < OS_RELEASE_COUNT; i++)
				SendMessage(MainControls[COMBO_OS_RELEASE].m_hWnd, CB_ADDSTRING, 0, (LPARAM)szOSRelease[i]);
			for(i = 0; i < LANG_COUNT; i++)
				SendMessage(MainControls[COMBO_OS_LANG].m_hWnd, CB_ADDSTRING, 0, (LPARAM)szLang[i]);
			for(i = 0; i < CPU_COUNT; i++)
				SendMessage(MainControls[COMBO_CPU].m_hWnd, CB_ADDSTRING, 0, (LPARAM)szCPU[i]);
			// make installing the tests the default.
			SendMessage(MainControls[CHECK_INSTALL_TESTS].m_hWnd, BM_SETCHECK, 1, 0);
			// pre-select the sniffs option, and pre-set the timing settings to the most popular values.
			CheckRadioButton(hWndDlg, IDC_RADIO_SNIFFS, IDC_RADIO_SNAPS, IDC_RADIO_SNIFFS);
			SetWindowText(MainControls[EDIT_DELAY].m_hWnd, "40");
			SetWindowText(MainControls[EDIT_PERIOD].m_hWnd, "45");
			SetWindowText(MainControls[EDIT_STEPSLEEP].m_hWnd, "100");
			return TRUE;
		}

		case WM_COMMAND:
		
		{
			switch(LOWORD(wParam))
			
			{
				case IDOK:

				{
					// get the system directory so we know what the system drive root is, 
					// which is where tests are installed and the debug log is written.
					CString strSystemDir; 
					GetSystemDirectory(strSystemDir.GetBuffer(_MAX_PATH), _MAX_PATH);
					strSystemDir.ReleaseBuffer();
					// the system drive is the first 2 characters of the system directory.
					CString strSystemDrive = strSystemDir.Left(2);
					// this is for debugging problems with runs.
					pfileDebugLog = fopen(strSystemDrive + "\\VC6TestRunner.log", "w");
					AppendToLogs("Starting Run.");

					// get the test type (Sniffs or Snaps).
					TestRun.m_TestType = (TEST_TYPE)SendMessage(MainControls[RADIO_SNAPS].m_hWnd, BM_GETCHECK, 0, 0);
					// we create either VC6Sniffs or VC6Snaps at the system drive root.
					TestRun.m_strTestDir = strSystemDrive + "\\VC6" + szTestType[TestRun.m_TestType];
					// get the timing settings.
					GetWindowText(MainControls[EDIT_DELAY].m_hWnd, TestRun.m_strDelay.GetBuffer(1024), 1023);
					TestRun.m_strDelay.ReleaseBuffer();
					GetWindowText(MainControls[EDIT_PERIOD].m_hWnd, TestRun.m_strPeriod.GetBuffer(1024), 1023);
					TestRun.m_strPeriod.ReleaseBuffer();
					GetWindowText(MainControls[EDIT_STEPSLEEP].m_hWnd, TestRun.m_strStepSleep.GetBuffer(1024), 1023);
					TestRun.m_strStepSleep.ReleaseBuffer();
					// determine whether or not the results will be published on the web.
					TestRun.m_boolPublishOnWeb = 
						SendMessage(MainControls[CHECK_PUBLISH_RESULTS_ON_WEB].m_hWnd, BM_GETCHECK, 0, 0);
					// determine whether or not we are only re-running tests that failed.
					TestRun.m_boolRerunFailedTests = 
						SendMessage(MainControls[CHECK_RERUN_FAILED_TESTS].m_hWnd, BM_GETCHECK, 0, 0);
					
					// if we are re-running failed tests, then publishing on the web is implied.
					if(TestRun.m_boolRerunFailedTests)
						TestRun.m_boolPublishOnWeb = TRUE;

					// get the language of vc that we are targetting. check for a blank entry.
					int intComboItem;

					if((intComboItem = SendMessage(MainControls[COMBO_VC_LANG].m_hWnd, CB_GETCURSEL, 0, 0)) != -1)
						TestRun.m_strVCLang	= szLang[intComboItem];

					// we only need the other info if we publish results on the web.
					if(TestRun.m_boolPublishOnWeb)	
					
					{
						// get the edit box settings.
						GetWindowText(MainControls[EDIT_TITLE].m_hWnd, TestRun.m_strTitle.GetBuffer(1024), 1023);
						TestRun.m_strTitle.ReleaseBuffer();
						GetWindowText(MainControls[EDIT_NUM_CPU].m_hWnd, TestRun.m_strNumCPU.GetBuffer(1024), 1023);
						TestRun.m_strNumCPU.ReleaseBuffer();
						GetWindowText(MainControls[EDIT_SPEED].m_hWnd, TestRun.m_strSpeed.GetBuffer(1024), 1023);
						TestRun.m_strSpeed.ReleaseBuffer();
						GetWindowText(MainControls[EDIT_RAM].m_hWnd, TestRun.m_strRAM.GetBuffer(1024), 1023);
						TestRun.m_strRAM.ReleaseBuffer();		
						// get the combo box settings. check for a blank entry.						
						if((intComboItem = SendMessage(MainControls[COMBO_VC_RELEASE].m_hWnd, CB_GETCURSEL, 0, 0)) != -1)
							TestRun.m_strVCRelease = szVCRelease[intComboItem];
						if((intComboItem = SendMessage(MainControls[COMBO_OS].m_hWnd, CB_GETCURSEL, 0, 0)) != -1)
							TestRun.m_strOS = szOS[intComboItem];
						if((intComboItem = SendMessage(MainControls[COMBO_OS_RELEASE].m_hWnd, CB_GETCURSEL, 0, 0)) != -1)
							TestRun.m_strOSRelease = szOSRelease[intComboItem];
						if((intComboItem = SendMessage(MainControls[COMBO_OS_LANG].m_hWnd, CB_GETCURSEL, 0, 0)) != -1)
							TestRun.m_strOSLang = szLang[intComboItem];
						if((intComboItem = SendMessage(MainControls[COMBO_CPU].m_hWnd, CB_GETCURSEL, 0, 0)) != -1)
							TestRun.m_strCPU = szCPU[intComboItem];
					
						// create the name of the webpage from the info specified for the run.
						CreateWebPageName();
						
						// calculate the first and last test to run from the Tests list (above), 
						// based on which group of tests were chosen.
						TestRun.m_intFirstTest = (TestRun.m_TestType == SNIFFS) ? 0 : SNIFF_COUNT;
						TestRun.m_intLastTest = (TestRun.m_TestType == SNIFFS) ? SNIFF_COUNT : SNIFF_COUNT + SNAP_COUNT;

						// if we're not re-running failed tests, then we need to create a new page for a new run.
						// otherwise we need to scan at the existing page to see which tests passed and only run 
						// the failed ones.
						if(!TestRun.m_boolRerunFailedTests)
							CreateWebPage();
						else
							DetermineWhichTestsPassed();
					}

					// install the tests if specified.
					if(SendMessage(MainControls[CHECK_INSTALL_TESTS].m_hWnd, BM_GETCHECK, 0, 0))
						InstallTests();

					RunTests();

					// close the debug log.
					fclose(pfileDebugLog);
					return TRUE;
				}
				
				case IDC_BUTTON_LOAD_RUN:

					// the Load Run dlg uses a list view control, so we have to initialize the common controls dll.
					INITCOMMONCONTROLSEX icex;
					icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
					icex.dwICC  = ICC_LISTVIEW_CLASSES;
					InitCommonControlsEx(&icex); 

					DialogBox(ghInstance, MAKEINTRESOURCE(IDD_LOAD_RUN), NULL, LoadRunDlgProc);
				
					if(pTestRunChosen)

					{
						// populate the main dlg controls with the details of the run the user chose to load.
						SetWindowText(MainControls[EDIT_TITLE].m_hWnd, pTestRunChosen->m_strTitle);
						ComboBox_SelectString(MainControls[COMBO_VC_RELEASE].m_hWnd, -1, pTestRunChosen->m_strVCRelease);
						ComboBox_SelectString(MainControls[COMBO_VC_LANG].m_hWnd, -1, pTestRunChosen->m_strVCLang);

						// we store the os and os release as one field in the html page, so we need to break it up here
						// in order to populate the os and os release controls of the main dlgs.
						int intSpaceBetweenOSAndRelease;
						int intOSLength;

						// search for each of the release strings to see if one is specified.
						for(i = 1; i < 9; i++)
						{
							if((intSpaceBetweenOSAndRelease = 
								pTestRunChosen->m_strOS.Find(CString(" ") + szOSRelease[i])) != -1)
								break;
						}
						
						// check if we found one of the release strings.
						if(intSpaceBetweenOSAndRelease == -1)
						{
							// no release string was found, so the os is the entire length of the string.
							intOSLength = pTestRunChosen->m_strOS.GetLength();
							// 0 index specifies no os release ("").
							ComboBox_SetCurSel(MainControls[COMBO_OS_RELEASE].m_hWnd, 0);
						}
						
						else
						
						{
							// a release string was found, so the os is the part of the string up to the space
							// that separates the os from the release.
							intOSLength = intSpaceBetweenOSAndRelease;

							// the release is the rest of the string after the space that separates the os from the release.
							ComboBox_SelectString(
								MainControls[COMBO_OS_RELEASE].m_hWnd, -1, 
								pTestRunChosen->m_strOS.Mid(intSpaceBetweenOSAndRelease + 1));
						}

						// populate the os control based on the length of the os string calculated above.
						ComboBox_SelectString(
							MainControls[COMBO_OS].m_hWnd, -1, pTestRunChosen->m_strOS.Mid(0, intOSLength));

						// populate the rest of the main dlg controls with the details of the run the user chose to load.
						ComboBox_SelectString(MainControls[COMBO_OS_LANG].m_hWnd, -1, pTestRunChosen->m_strOSLang);
						ComboBox_SelectString(MainControls[COMBO_CPU].m_hWnd, -1, pTestRunChosen->m_strCPU);
						SetWindowText(MainControls[EDIT_NUM_CPU].m_hWnd, pTestRunChosen->m_strNumCPU);
						SetWindowText(MainControls[EDIT_SPEED].m_hWnd, pTestRunChosen->m_strSpeed);
						SetWindowText(MainControls[EDIT_RAM].m_hWnd, pTestRunChosen->m_strRAM);
					}

					// clean-up the runs to load list.
					CTestRunToLoad *pTestRunToLoad1;
					pTestRunToLoad1 = pTestRunsToLoadHome;
					CTestRunToLoad *pTestRunToLoad2;

					while(pTestRunToLoad1)
					{
						pTestRunToLoad2 = pTestRunToLoad1;
						pTestRunToLoad1 = pTestRunToLoad1->m_pNext;
						delete pTestRunToLoad2;
					}

					return TRUE;

				case IDCANCEL:
					return SendMessage(hWndDlg, WM_CLOSE, 0, 0);
				default:
					return 0;
			}
		}
		case WM_CLOSE:
			return EndDialog(hWndDlg, 0);
		default:
			return 0;
	}
}


BOOL CALLBACK LoadRunDlgProc(HWND hWndDlg, UINT msg, WPARAM wParam, LPARAM lParam)

{
	static HWND hWndListRuns;

	switch(msg)		

	{
		case WM_INITDIALOG:
		
		{
			// get the handle for the Runs listview so we can add columns and items to it.
			hWndListRuns = GetDlgItem(hWndDlg, IDC_LIST_RUNS);
			
			// settings common to all the columns.
			LV_COLUMN ListViewColumn;
			ListViewColumn.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
			ListViewColumn.fmt = LVCFMT_LEFT;
			// add each column.
			ListViewColumn.pszText = "RAM";
			ListViewColumn.iSubItem = 8;
			ListViewColumn.cx = 40;
			ListView_InsertColumn(hWndListRuns, 0, &ListViewColumn);
			ListViewColumn.pszText = "SPEED";
			ListViewColumn.iSubItem = 7;
			ListViewColumn.cx = 50;
			ListView_InsertColumn(hWndListRuns, 0, &ListViewColumn);
			ListViewColumn.pszText = "# CPU";
			ListViewColumn.iSubItem = 6;
			ListViewColumn.cx = 50;
			ListView_InsertColumn(hWndListRuns, 0, &ListViewColumn);
			ListViewColumn.pszText = "CPU";
			ListViewColumn.iSubItem = 5;
			ListViewColumn.cx = 75;
			ListView_InsertColumn(hWndListRuns, 0, &ListViewColumn);
			ListViewColumn.pszText = "OS LANG";
			ListViewColumn.iSubItem = 4;
			ListViewColumn.cx = 75;
			ListView_InsertColumn(hWndListRuns, 0, &ListViewColumn);
			ListViewColumn.pszText = "OS";
			ListViewColumn.iSubItem = 3;
			ListViewColumn.cx = 150;
			ListView_InsertColumn(hWndListRuns, 0, &ListViewColumn);
			ListViewColumn.pszText = "VC6 LANG";
			ListViewColumn.iSubItem = 2;
			ListViewColumn.cx = 75;
			ListView_InsertColumn(hWndListRuns, 0, &ListViewColumn);
			ListViewColumn.pszText = "VC6";
			ListViewColumn.iSubItem = 1;
			ListViewColumn.cx = 75;
			ListView_InsertColumn(hWndListRuns, 0, &ListViewColumn);
			ListViewColumn.pszText = "TITLE";
			ListViewColumn.iSubItem = 0;
			ListViewColumn.cx = 295;
			ListView_InsertColumn(hWndListRuns, 0, &ListViewColumn);
	
			// settings common to each item in the list.
			LV_ITEM ListViewItem;
			ListViewItem.mask = LVIF_TEXT | LVIF_STATE;
			ListViewItem.state = 0;
			ListViewItem.stateMask = 0;
			ListViewItem.iSubItem = 0;
			ListViewItem.pszText = LPSTR_TEXTCALLBACK;
		
			// the first run to load hasn't been allocated yet.
			pTestRunsToLoadHome = NULL;
			CTestRunToLoad *pTestRunToLoad = NULL;
			// the index of the nex t item to add to the listview.
			int intListViewItemIndex = 0;

			// open the runs page so we can read in the info for all the runs.
			FILE *pfileRunsPage = fopen("\\\\MSVC\\VCQA\\VC6TestRuns\\VC6TestRuns.htm", "r");					
			CString strLine;
			int intDelimLeft, intDelimRight;

			// read all the lines up until the section where the runs get added.
			while(strLine.Find("add run here") == -1)	
			{
				fgets(strLine.GetBuffer(1024), 1023, pfileRunsPage);
				strLine.ReleaseBuffer();
			}

			// look for runs until we reach the end of the file.
			while(!feof(pfileRunsPage))
			
			{
				// read until we find the beginning of a run (each row is a run).
				while((strLine.Find("<tr>") == -1) && !feof(pfileRunsPage))	
				{
					fgets(strLine.GetBuffer(1024), 1023, pfileRunsPage);
					strLine.ReleaseBuffer();
				}

				// if we didn't reach the end of the file, then we found a run.
				if(!feof(pfileRunsPage))
				
				{
					// insert an item for it in the list view.
					ListViewItem.iItem = intListViewItemIndex++;
					ListView_InsertItem(hWndListRuns, &ListViewItem);

					// allocate the new run to load.
					if(!pTestRunsToLoadHome)
					{
						pTestRunToLoad = new CTestRunToLoad();
						pTestRunsToLoadHome = pTestRunToLoad;
					}
					else
					{
						pTestRunToLoad->m_pNext = new CTestRunToLoad();
						pTestRunToLoad = pTestRunToLoad->m_pNext;
					}

					pTestRunToLoad->m_pNext = NULL;

					// read the title line.
					fgets(strLine.GetBuffer(1024), 1023, pfileRunsPage);
					strLine.ReleaseBuffer();

					// preceding the title will be either "<font color=red>" or "<font color=green>".
					// we want the text between that and the "</font>".
					intDelimLeft = strLine.Find("red>");
					
					if(intDelimLeft == -1)
						intDelimLeft = strLine.Find("een>");

					intDelimRight = strLine.Find("</font>");
					pTestRunToLoad->m_strTitle = strLine.Mid(intDelimLeft + 4, intDelimRight - (intDelimLeft + 4));
					// read the vc release line.
					fgets(strLine.GetBuffer(1024), 1023, pfileRunsPage);
					strLine.ReleaseBuffer();
					intDelimRight = strLine.Find("</td>");
					pTestRunToLoad->m_strVCRelease = strLine.Mid(4, intDelimRight - 4);
					// read the vc lang line.
					fgets(strLine.GetBuffer(1024), 1023, pfileRunsPage);
					strLine.ReleaseBuffer();
					intDelimRight = strLine.Find("</td>");
					pTestRunToLoad->m_strVCLang = strLine.Mid(4, intDelimRight - 4);
					// read the os line.
					fgets(strLine.GetBuffer(1024), 1023, pfileRunsPage);
					strLine.ReleaseBuffer();
					intDelimRight = strLine.Find("</td>");
					pTestRunToLoad->m_strOS = strLine.Mid(4, intDelimRight - 4);
					// read the os lang line.
					fgets(strLine.GetBuffer(1024), 1023, pfileRunsPage);
					strLine.ReleaseBuffer();
					intDelimRight = strLine.Find("</td>");
					pTestRunToLoad->m_strOSLang = strLine.Mid(4, intDelimRight - 4);
					// read the cpu line.
					fgets(strLine.GetBuffer(1024), 1023, pfileRunsPage);
					strLine.ReleaseBuffer();
					intDelimRight = strLine.Find("</td>");
					pTestRunToLoad->m_strCPU = strLine.Mid(4, intDelimRight - 4);
					// read the num cpu line.
					fgets(strLine.GetBuffer(1024), 1023, pfileRunsPage);
					strLine.ReleaseBuffer();
					intDelimRight = strLine.Find("</td>");
					pTestRunToLoad->m_strNumCPU = strLine.Mid(4, intDelimRight - 4);
					// read the speed line.
					fgets(strLine.GetBuffer(1024), 1023, pfileRunsPage);
					strLine.ReleaseBuffer();							
					intDelimRight = strLine.Find("</td>");
					pTestRunToLoad->m_strSpeed = strLine.Mid(4, intDelimRight - 4);
					// read the ram line.
					fgets(strLine.GetBuffer(1024), 1023, pfileRunsPage);
					strLine.ReleaseBuffer();							
					intDelimRight = strLine.Find("</td>");
					pTestRunToLoad->m_strRAM = strLine.Mid(4, intDelimRight - 4);
				}
			}

			fclose(pfileRunsPage);
			return TRUE;
		}
		
		case WM_NOTIFY:
		{
			switch(((LPNMHDR)lParam)->code) 
			{ 
			// fill in the items of the listview on the Load Run dlg.
			case LVN_GETDISPINFO: 
				GetRunsListViewDisplayInfo((NMLVDISPINFO *)lParam);
				return 0;
			default:
				return 0;
			}			
		}

		case WM_COMMAND:
		
		{
			switch(LOWORD(wParam))
			
			{
				case IDOK:
				
				{
					// get the run that was chosen to load.
					int intItem = ListView_GetSelectionMark(hWndListRuns);

					if(intItem >= 0)

					{
						pTestRunChosen = pTestRunsToLoadHome;
						
						// the main dlg procedure will extract info from pTestRunChosen to populate the main dlg.
						for(int i = 0; i < intItem; i++)
							pTestRunChosen = pTestRunChosen->m_pNext;

						return SendMessage(hWndDlg, WM_CLOSE, 0, 0);
					}

					return TRUE;
				}

				case IDCANCEL:
					return SendMessage(hWndDlg, WM_CLOSE, 0, 0);
				default:
					return 0;
			}
		}

		case WM_CLOSE:
			return EndDialog(hWndDlg, 0);
		default:
			return 0;
	}
}


void GetRunsListViewDisplayInfo(NMLVDISPINFO *plvDispInfo) 

{
	static char sz[1024];
	CTestRunToLoad *pTestRunsToLoad = pTestRunsToLoadHome;

	// advance to the run that we need to get display info for.
	for(int i = 0; i < plvDispInfo->item.iItem; i++)
		pTestRunsToLoad = pTestRunsToLoad->m_pNext;

	switch(plvDispInfo->item.iSubItem)
	{
	case 0:
		strcpy(sz, pTestRunsToLoad->m_strTitle);
		break;
	case 1:
		strcpy(sz, pTestRunsToLoad->m_strVCRelease);
		break;
	case 2:
		strcpy(sz, pTestRunsToLoad->m_strVCLang);
		break;
	case 3:
		strcpy(sz, pTestRunsToLoad->m_strOS);
		break;
	case 4:
		strcpy(sz, pTestRunsToLoad->m_strOSLang);
		break;
	case 5:
		strcpy(sz, pTestRunsToLoad->m_strCPU);
		break;
	case 6:
		strcpy(sz, pTestRunsToLoad->m_strNumCPU);
		break;
	case 7:
		strcpy(sz, pTestRunsToLoad->m_strSpeed);
		break;
	case 8:
		strcpy(sz, pTestRunsToLoad->m_strRAM);
		break;
	}

	plvDispInfo->item.pszText = sz;
} 


void CreateWebPageName()

{
	// remove spaces from the title, os, and cpu fields since they are used in the web page name, and we don't
	// want it to have spaces since it can sometimes be a pain in ie.
	int i;
	CString strTitleWithoutSpaces = TestRun.m_strTitle;
	CString strOSWithoutSpaces = TestRun.m_strOS;
	CString strCPUWithoutSpaces = TestRun.m_strCPU;

	for(i = 0; i < strTitleWithoutSpaces.GetLength(); i++)
	{
		if(strTitleWithoutSpaces[i] == ' ')
			strTitleWithoutSpaces.Delete(i, 1);
	}

	for(i = 0; i < strOSWithoutSpaces.GetLength(); i++)
	{
		if(strOSWithoutSpaces[i] == ' ')
			strOSWithoutSpaces.Delete(i, 1);
	}

	for(i = 0; i < strCPUWithoutSpaces.GetLength(); i++)
	{
		if(strCPUWithoutSpaces[i] == ' ')
			strCPUWithoutSpaces.Delete(i, 1);
	}

	// create the webpage name.
	CString strWebPageName;
	
	strWebPageName.Format("%s_VC6%s%s_%s%s%s_%s%s%smhz%smb", strTitleWithoutSpaces, TestRun.m_strVCRelease, 
		TestRun.m_strVCLang, strOSWithoutSpaces, TestRun.m_strOSRelease, TestRun.m_strOSLang, TestRun.m_strNumCPU,
		strCPUWithoutSpaces, TestRun.m_strSpeed, TestRun.m_strRAM);

	// we need the web page name later in RunTests() in order to copy logs out to the website.
	TestRun.m_strWebPageName = strWebPageName;
}


void CreateWebPage()

{
	// create the webpage's directory and the webpage.
	CreateDirectory("\\\\MSVC\\VCQA\\VC6TestRuns\\" + TestRun.m_strWebPageName, NULL);

	FILE *pfileWebPage = fopen(
		"\\\\MSVC\\VCQA\\VC6TestRuns\\" + TestRun.m_strWebPageName + "\\" + TestRun.m_strWebPageName + ".htm", "w");

	// write the header information.
	fprintf(pfileWebPage, "<html>\n");
	fprintf(pfileWebPage, "<center>\n");
	fprintf(pfileWebPage, "<h1>%s</h1>\n", TestRun.m_strTitle);
	fprintf(pfileWebPage, "<b>VC6 %s %s</b><br>\n", TestRun.m_strVCRelease, TestRun.m_strVCLang);
	fprintf(pfileWebPage, "<b>%s %s %s</b><br>\n", TestRun.m_strOS, TestRun.m_strOSRelease, TestRun.m_strOSLang);
	fprintf(pfileWebPage, "<b>%s %s %smhz %smb</b><br>\n", 
		TestRun.m_strNumCPU, TestRun.m_strCPU, TestRun.m_strSpeed, TestRun.m_strRAM);
	fprintf(pfileWebPage, "</center>\n");
	fprintf(pfileWebPage, "<hr>\n");
	// initialize the group to the first group of tests.
	CString strGroup = Tests[TestRun.m_intFirstTest].m_szGroup;
	// write out the header and start the results table for the first group of tests.
	fprintf(pfileWebPage, "<b><h3>%s</h3></b>\n", strGroup);
	fprintf(pfileWebPage, "<table width=25%% border=1>\n");
	fprintf(pfileWebPage, "<tr><td><b>Test</b></td><td><b>Result</b></td></tr>\n");

	// loop through the list of tests to write on the webpage.
	for(int intTest = TestRun.m_intFirstTest; intTest < TestRun.m_intLastTest; intTest++)
	
	{
		// check if we've entered a new group of tests (applies to snaps only).
		if(Tests[intTest].m_szGroup != strGroup)
		{
			// terminate the table for the previous group of tests.
			fprintf(pfileWebPage, "</table>\n\n");
			fprintf(pfileWebPage, "<br>\n");
			// write the header and initiate the results table for the next group.
			fprintf(pfileWebPage, "<b><h3>%s</h3></b>\n", Tests[intTest].m_szGroup);
			fprintf(pfileWebPage, "<table width=25%% border=1>\n");
			fprintf(pfileWebPage, "<tr><td><b>Test</b></td><td><b>Result</b></td></tr>\n");
			// update the current group.
			strGroup = Tests[intTest].m_szGroup;
		}

		// write the test's name.
		fprintf(pfileWebPage, "<tr><td>%s</td><td>\?\?\?</td></tr>\n", Tests[intTest].m_szName);
	}

	// terminate the last results table and close the webpage.
	fprintf(pfileWebPage, "</table>\n");
	fclose(pfileWebPage);

	// add the run to the VC6TestRuns.htm page. we create a new page with the new entry based on the old page.
	CopyFile("\\\\MSVC\\VCQA\\VC6TestRuns\\VC6TestRuns.htm", "\\\\MSVC\\VCQA\\VC6TestRuns\\VC6TestRuns.old", FALSE);
	FILE *pfileRunsPageOld = fopen("\\\\MSVC\\VCQA\\VC6TestRuns\\VC6TestRuns.old", "r");
	FILE *pfileRunsPageNew = fopen("\\\\MSVC\\VCQA\\VC6TestRuns\\VC6TestRuns.htm", "w");
	// read the first line of the old page to get started.
	CString strLine;
	fgets(strLine.GetBuffer(1024), 1023, pfileRunsPageOld);
	strLine.ReleaseBuffer();

	// copy all the lines from the old page that occur before we need to add the run.
	while(strLine.Find("add run here") == -1)	
	{
		fprintf(pfileRunsPageNew, "%s", strLine);
		fgets(strLine.GetBuffer(1024), 1023, pfileRunsPageOld);
		strLine.ReleaseBuffer();
	}

	// copy the line with the "add run here" comment for next time a run is added.
	fprintf(pfileRunsPageNew, "%s", strLine);
	// insert the new run.
	fprintf(pfileRunsPageNew, "\n");
	fprintf(pfileRunsPageNew, "<tr>\n");

	fprintf(pfileRunsPageNew, "<td><a href=\"%s\\%s.htm\"><font color=red>%s</font></a></td>\n", 
		TestRun.m_strWebPageName, TestRun.m_strWebPageName, TestRun.m_strTitle);

	fprintf(pfileRunsPageNew, "<td>%s</td>\n", TestRun.m_strVCRelease);
	fprintf(pfileRunsPageNew, "<td>%s</td>\n", TestRun.m_strVCLang);
	fprintf(pfileRunsPageNew, "<td>%s", TestRun.m_strOS);
		
	if(TestRun.m_strOSRelease != "")
		fprintf(pfileRunsPageNew, " %s</td>\n", TestRun.m_strOSRelease);
	else
		fprintf(pfileRunsPageNew, "</td>\n");

	fprintf(pfileRunsPageNew, "<td>%s</td>\n", TestRun.m_strOSLang);
	fprintf(pfileRunsPageNew, "<td>%s</td>\n", TestRun.m_strCPU);
	fprintf(pfileRunsPageNew, "<td>%s</td>\n", TestRun.m_strNumCPU);
	fprintf(pfileRunsPageNew, "<td>%s</td>\n", TestRun.m_strSpeed);
	fprintf(pfileRunsPageNew, "<td>%s</td>\n", TestRun.m_strRAM);
	fprintf(pfileRunsPageNew, "</tr>\n");

	// read the next line from the old file to get us started again.
	fgets(strLine.GetBuffer(1024), 1023, pfileRunsPageOld);
	strLine.ReleaseBuffer();

	// copy the rest of the lines from the old page.
	while(!feof(pfileRunsPageOld))	
	{
		fprintf(pfileRunsPageNew, strLine);
		fgets(strLine.GetBuffer(1024), 1023, pfileRunsPageOld);
		strLine.ReleaseBuffer();
	}

	// close both the old and new files.
	fclose(pfileRunsPageOld);
	fclose(pfileRunsPageNew);
}


void DetermineWhichTestsPassed()

{
	// open the webpage for the test run for reading.
	FILE *pfileWebPage = fopen(
		"\\\\MSVC\\VCQA\\VC6TestRuns\\" + TestRun.m_strWebPageName + "\\" + TestRun.m_strWebPageName + ".htm", "r");

	CString strLine;

	// read each line of the web page.
	while(!feof(pfileWebPage))
	
	{
		// read the next line.
		fgets(strLine.GetBuffer(1024), 1023, pfileWebPage);
		strLine.ReleaseBuffer();

		// loop through the Tests array, checking if we read a line that contains a test's pass/fail entry.
		for(int intTest = TestRun.m_intFirstTest; intTest < TestRun.m_intLastTest; intTest++)
		{
			if(strLine.Find(CString("<td>") + Tests[intTest].m_szName) != -1)
			{
				// check if this particular test passed.
				if(strLine.Find("<font color=green>PASS") != -1)
					Tests[intTest].m_boolPassed = TRUE;
			}
		}
	}

	fclose(pfileWebPage);
}


void InstallTests()

{
	// clean-up any pre-existing registry.
	DeleteRegistryKey("CAFE v6");
	// clean-up any pre-existing installation of the tests.
	DeleteTree(TestRun.m_strTestDir);
	// create the directory to hold the  newtest tree.
	CreateDirectory(TestRun.m_strTestDir, NULL);

	// structures used by CreateProcess.
	STARTUPINFO			StartupInfo;
	PROCESS_INFORMATION ProcessInfo;
	// not cleaning these structures can lead to problems when calling CreateProcess (0 is a safe default). 
	memset(&StartupInfo, 0, sizeof(StartupInfo));
	memset(&ProcessInfo, 0, sizeof(ProcessInfo));
	// initialize the required STARTUPINFO fields.
	StartupInfo.cb = sizeof(STARTUPINFO);
	
	// create the xcopy command that will copy the test tree.
	CString strCmd = 
		CString("xcopy \\\\VSQAAUTO\\VC6") + szTestType[TestRun.m_TestType] + "\\*.* " + TestRun.m_strTestDir + " /e/s/k";
	
	// allocate a new console to run the command.
	AllocConsole();
	SetConsoleTitle(strCmd);

	// start the xcopy process.
	if(CreateProcess(NULL, strCmd.GetBuffer(0), NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, &StartupInfo, &ProcessInfo))
	{
		// wait for the process to end.
		WaitForSingleObject(ProcessInfo.hProcess, INFINITE);
		CloseHandle(ProcessInfo.hProcess);
		CloseHandle(ProcessInfo.hThread);
	}
	else
	{
		MessageBox(NULL, "Failed to spawn xcopy to copy the test tree!", "VC6 Test Runner", MB_OK);
	}

	strCmd.ReleaseBuffer();
	FreeConsole();

	// modify the environment to include the vc6 directories that we will pass to cafedrv.exe.
	SetCafeEnvironment();
}


void RunTests()

{
	// holds the cafedrv.exe command.
	CString strCmd;
	// some tests require that extra switches be passed to cafedrv.exe.
	CString strExtraSwitches;
	// reads each line of the log.
	CString strLine;
	// for getting cafedrv.exe's exit code so we know when it finished.
	DWORD dwCafeDrvExitCode;
	// for tracking how long the test has been executing.
	int intSeconds;
	// specifies the log we need to examine. this is results.log unless we have to kill cafe, in which case it is details.txt.
	CString strLogName;
	// structures used by CreateProcess.
	STARTUPINFO			StartupInfo;
	PROCESS_INFORMATION ProcessInfo;
	// initialize the required STARTUPINFO fields.
	StartupInfo.cb = sizeof(STARTUPINFO);

	// loop through all the tests and run them.
	for(int intTest = TestRun.m_intFirstTest; intTest < TestRun.m_intLastTest; intTest++)

	{
		// if this test has already passed in a previous run, don't re-run it.
		if(Tests[intTest].m_boolPassed)
			continue;
		
		// the debugger snaps do different tests for the processor pack depending on which processor they are running on.
		if((CString(Tests[intTest].m_szGroup) == "Debugger Snaps") && (TestRun.m_strVCRelease == "SP4-PP"))
		
		{
			if(TestRun.m_strCPU == "Pentium II")
				strExtraSwitches = "-MMX";
			else if(TestRun.m_strCPU == "Pentium III")
				strExtraSwitches = "-MMX -KNI";
			else if(TestRun.m_strCPU == "WNI")
				strExtraSwitches = "-MMX -WNI";
			else if(TestRun.m_strCPU != "Itanium")
				// K6 or K7.
				strExtraSwitches = "-" + TestRun.m_strCPU;
				
			strExtraSwitches = strExtraSwitches + " -PP";
		}
			
		else
			strExtraSwitches = "";

		// delete any pre-existing results.log and details.txt.
		// we don't want the results of this test to be confused with that of the previous test.
		DeleteFile(TestRun.m_strTestDir + "\\results.log");
		DeleteFile(TestRun.m_strTestDir + "\\details.txt");
		// not cleaning these structures can lead to problems when calling CreateProcess (0 is a safe default). 
		memset(&StartupInfo, 0, sizeof(StartupInfo));
		memset(&ProcessInfo, 0, sizeof(ProcessInfo));

		// create the cafedrv.exe command.
		strCmd.Format("%s\\cafedrv.exe -run -Debug=0 -delay=%s -period=%s -StepSleep=%s -lang=%s -stf=%s\\%s %s",
			TestRun.m_strTestDir, TestRun.m_strDelay, TestRun.m_strPeriod, TestRun.m_strStepSleep, TestRun.m_strVCLang,
			TestRun.m_strTestDir, Tests[intTest].m_szDllPath, strExtraSwitches);

		// start the cafedrv.exe process.
		if(CreateProcess(
			NULL, strCmd.GetBuffer(0), NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, 
			NULL, TestRun.m_strTestDir, &StartupInfo, &ProcessInfo))
		{
			strLogNew.Format("Running test %s - %s.", Tests[intTest].m_szGroup, Tests[intTest].m_szName);
			AppendToLogs(strLogNew);

			// wait up to 4 hours for the test to end.
			for(intSeconds = 0; intSeconds < 14400; intSeconds++)
		
			{
				Sleep(1000);
				// get cafedrv.exe's exit code (if it has finished).
				GetExitCodeProcess(ProcessInfo.hProcess, &dwCafeDrvExitCode);
				
				// keep sleeping if cafedrv.exe is still running.
				if(dwCafeDrvExitCode != STILL_ACTIVE)
					break;
			}
		}

		strCmd.ReleaseBuffer();

		// kill the test if it has exceeded the time limit (probably hung).
		if(intSeconds == 14400)
		
		{
			strLogNew.Format("ERROR! Test %s - %s exceeded 4 hour time limit.", 
				Tests[intTest].m_szName, Tests[intTest].m_szGroup);

			AppendToLogs(strLogNew);

			// kill cafedrv.exe (which will also kill the msdev.exe it is debugging).
			TerminateProcess(ProcessInfo.hProcess, 1);
			// if cafedrv.exe doesn't shut down properly, results.log doesn't get create.
			// all the interesting info is in details.txt.
			strLogName = "details.txt";
		}
		else
			strLogName = "results.log";

		// create a test-specific name for the log.
		CString strTestSpecificLogName = CString(Tests[intTest].m_szGroup) + Tests[intTest].m_szName + ".log";
		
		// some of the groups have spaces in them, but we don't want spaces in the name of the log.
		// sometimes spaces in names screws up ie.
		for(int i = 0; i < strTestSpecificLogName.GetLength(); i++)
		{
			if(strTestSpecificLogName[i] == ' ')
				strTestSpecificLogName.Delete(i, 1);
		}
		
		// make a copy of the log file with a test-specific name. overwrite any existing file.
		CopyFile(
			CString(TestRun.m_strTestDir) + "\\" + strLogName, 
			CString(TestRun.m_strTestDir) + "\\" + strTestSpecificLogName, FALSE);
 
		// if results are being published on the web, update the result of the test and copy the log to the webserver.
		if(TestRun.m_boolPublishOnWeb)
		
		{
			// the test hasn't passed until we find "Total Failures:    0" in the log.
			BOOL boolTestFailed = TRUE;
			// open the log file.
			FILE *pfileLog = fopen(TestRun.m_strTestDir + "\\" + strLogName, "r");

			// make sure there was actually a log to open.
			if(pfileLog)
			
			{
				// copy the log to a test-specific name in the webserver directory for this run.
				CopyFile(
					CString(TestRun.m_strTestDir) + "\\" + strLogName,
					CString("\\\\MSVC\\VCQA\\VC6TestRuns\\") + TestRun.m_strWebPageName + "\\" + 
					strTestSpecificLogName, FALSE);

				// scan each line of the log.
				while(!feof(pfileLog))
			
				{
					// read the next line.
					fgets(strLine.GetBuffer(1024), 1023, pfileLog);
					strLine.ReleaseBuffer();

					// check if we found the line saying the test passed.
					if(strLine.Find("Total Failures:    0") != -1)
					{
						boolTestFailed = FALSE;
						break;
					}
				}
			}

			CString strRoughResult;

			// if we were able to get a log, then we can provide a link to it in the result (PASS or FAIL).
			if(pfileLog)
			{
				strRoughResult = "<a href=\"" + strTestSpecificLogName + "\"><b>\?\?\?</b></a>";
				fclose(pfileLog);
			}
			else
				strRoughResult = "<b>\?\?\?</b>";

			// update the test result on the run's webpage. we create a new page based on the old page.
			CString strWebPageNameOld = 
				CString("\\\\MSVC\\VCQA\\VC6TestRuns\\") + TestRun.m_strWebPageName + "\\" + 
				TestRun.m_strWebPageName + ".old";
			CString strWebPageNameNew = 
				CString("\\\\MSVC\\VCQA\\VC6TestRuns\\") + TestRun.m_strWebPageName + "\\" + 
				TestRun.m_strWebPageName + ".htm";

			CopyFile(strWebPageNameNew, strWebPageNameOld, FALSE);
			FILE *pfileWebPageOld = fopen(strWebPageNameOld, "r");
			FILE *pfileWebPageNew = fopen(strWebPageNameNew, "w");
			// read the first line of the old page to get started.
			CString strLine;
			fgets(strLine.GetBuffer(1024), 1023, pfileWebPageOld);
			strLine.ReleaseBuffer();

			// copy all the lines from the old page that occur before the test whose result we need to modify.
			while(strLine.Find(CString("<td>") + Tests[intTest].m_szName) == -1)	
			{
				fprintf(pfileWebPageNew, "%s", strLine);
				fgets(strLine.GetBuffer(1024), 1023, pfileWebPageOld);
				strLine.ReleaseBuffer();
			}

			// initialize the final result with the rough result.
			CString strFinalResult =
				CString("<tr><td>") + Tests[intTest].m_szName + "</td><td>" + strRoughResult + "</td></tr>\n";

			// update the test's result. passes are green, fails are red.
			if(boolTestFailed)
				strFinalResult.Replace("\?\?\?", "<font color=red>FAIL</font>");
			else
				strFinalResult.Replace("\?\?\?", "<font color=green>PASS</font>");

			// write the result.
			fprintf(pfileWebPageNew, "%s", strFinalResult);
			// read the next line from the old file to get us started again.
			fgets(strLine.GetBuffer(1024), 1023, pfileWebPageOld);
			strLine.ReleaseBuffer();

			// copy the rest of the lines from the old page.
			while(!feof(pfileWebPageOld))	
			{
				fprintf(pfileWebPageNew, strLine);
				fgets(strLine.GetBuffer(1024), 1023, pfileWebPageOld);
				strLine.ReleaseBuffer();
			}

			// close both the old and new files.
			fclose(pfileWebPageOld);
			fclose(pfileWebPageNew);
		}
	}
}


void SetCafeEnvironment(void)

{
	HKEY hKey;
	CString strInstallDirsValue;
	DWORD dwValueSize = _MAX_PATH;

	// open the key we need to query.
	RegOpenKeyEx(HKEY_CURRENT_USER, "Software\\Microsoft\\DevStudio\\6.0\\Directories", 0, KEY_READ, &hKey);
	// get the Install Dirs value.
	RegQueryValueEx(hKey, "Install Dirs", 0, NULL, (unsigned char*)strInstallDirsValue.GetBuffer(dwValueSize), &dwValueSize);
	strInstallDirsValue.ReleaseBuffer();
	// close the registry
	RegCloseKey(hKey);

	// we need to search this string, and on some os's it uses mixed case while on others it is all upper-case.
	strInstallDirsValue.MakeUpper();
	// everything is based off of the "MICROSOFT VISUAL STUDIO" directory, which precedes "COMMON" in the string.
	int intCommon = strInstallDirsValue.Find("COMMON");
	CString strVSDir = strInstallDirsValue.Left(intCommon - 1);
	// get the path environment variable value.
	CString strPathValue;
	GetEnvironmentVariable("PATH", strPathValue.GetBuffer(4096), 4095);
	strPathValue.ReleaseBuffer();

	// reset the path environment variable with the new value.
	SetEnvironmentVariable(
		"PATH", 
		strPathValue + ";" + strVSDir + "\\COMMON\\MSDEV98\\BIN;" + 
		strVSDir + "\\COMMON\\TOOLS;" + strVSDir + "\\VC98\\BIN;");

	// set the include and lib environment variables.
	SetEnvironmentVariable(
		"INCLUDE", 
		strVSDir + "\\VC98\\INCLUDE;" + strVSDir + "\\VC98\\MFC\\INCLUDE;" + strVSDir + "\\VC98\\ATL\\INCLUDE;");

	SetEnvironmentVariable("LIB", strVSDir + "\\VC98\\LIB;" + strVSDir + "\\VC98\\MFC\\LIB;");
}


void DeleteRegistryKey(LPCSTR pszKeyName)

{
	const char* const pszBaseKey = "Software\\Microsoft\\";
	HKEY hKey;
	DWORD err;

	// open the key, if it exists.
	if((err = RegOpenKeyEx(HKEY_CURRENT_USER, CString(pszBaseKey) + pszKeyName, 0, KEY_ALL_ACCESS, &hKey)) == ERROR_SUCCESS) 
	
	{
		// delete all the subkeys in this key.
		DeleteRegistrySubKeys(hKey);
		RegCloseKey(hKey);

		// delete the key itself.
		if(RegOpenKeyEx(HKEY_CURRENT_USER, pszBaseKey, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS) 
		
		{
			if(RegDeleteKey(hKey, pszKeyName) != ERROR_SUCCESS) 
			{
				fprintf(pfileDebugLog, "Unable to delete key '%s'.", pszKeyName);
				return;
			}
		
			RegCloseKey(hKey);
		}
	
		else 
		{
			fprintf(pfileDebugLog, "Unable to open key '%s'.\n", pszBaseKey);
			return;
		}
	}
	
	else
	{
		fprintf(pfileDebugLog, "Unable to open key '%s'.", CString(pszBaseKey) + pszKeyName);
		return;
	}
}


void DeleteRegistrySubKeys(HKEY hKey)

{
	TCHAR szSubKey[MAX_PATH + 1];
	CStringArray KeyArray;
	int iSubKey = 0;

	// build an array of subkeys in this key
	while(RegEnumKey(hKey, iSubKey++, szSubKey, MAX_PATH ) == ERROR_SUCCESS)
		KeyArray.Add(szSubKey);

	// iterate through the subkeys in this key
	for(int iCur = 0; iCur < KeyArray.GetSize(); iCur++) 
	
	{
		HKEY hSubKey;

		// open the subkey
		if(RegOpenKeyEx(hKey, KeyArray[iCur], 0, KEY_WRITE | KEY_READ, &hSubKey) == ERROR_SUCCESS)
		{
			// delete all its subkeys
			DeleteRegistrySubKeys(hSubKey);
			RegCloseKey(hSubKey);
		}
		else 
			fprintf(pfileDebugLog, "Unable to open key '%s'.", KeyArray[iCur]);

		// delete the subkey
		if(RegDeleteKey(hKey, KeyArray[iCur]) != ERROR_SUCCESS) 
			fprintf(pfileDebugLog, "Unable to delete key '%s'.", KeyArray[iCur]);
	}
}


void DeleteTree(CString strPath)

{
	WIN32_FIND_DATA Win32FindData;
	CString strFilename;
	CString strFullPath;
	bool boolFolder;

	HANDLE hFile = FindFirstFile(strPath + "\\*.*", &Win32FindData);
	
	if(hFile != INVALID_HANDLE_VALUE)
	
	{
		do
		
		{
			strFilename = Win32FindData.cFileName;
			boolFolder = (Win32FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY;
			strFullPath = strPath + "\\" + strFilename;
			
			if(boolFolder && (strFilename != ".") && (strFilename != ".."))
				DeleteTree(strFullPath);

			else if(!boolFolder)			
			
			{
				if(Win32FindData.dwFileAttributes & FILE_ATTRIBUTE_READONLY)
					SetFileAttributes(strFullPath, FILE_ATTRIBUTE_NORMAL);

				DeleteFile(strFullPath);
			}

		} while (FindNextFile(hFile, &Win32FindData));

		FindClose(hFile);
	}

	RemoveDirectory(strPath);
}


void AppendToLogs(CString strLogNew)
{
	strLog = strLog + strLogNew + "\r\n";
	SetWindowText(MainControls[EDIT_LOG].m_hWnd, strLog);
	fprintf(pfileDebugLog, "%s\n", strLogNew);
	fflush(pfileDebugLog);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Tools\VC6TestRunner\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by VC6TestRunner.rc
//
#define IDD_VC6_TEST_RUNNER             101
#define IDD_LOAD_RUN                    103
#define IDC_COMBO_VC                    1000
#define IDC_COMBO_VC_RELEASE            1000
#define IDC_COMBO_VC_LANG               1001
#define IDC_COMBO_OS                    1002
#define IDC_COMBO_OS_LANG               1003
#define IDC_COMBO_CPU                   1004
#define IDC_CHECK_SINFFS                1009
#define IDC_CHECK_SNAPS                 1010
#define IDC_EDIT1                       1011
#define IDC_EDIT_SPEED                  1011
#define IDC_EDIT2                       1012
#define IDC_EDIT_RAM                    1012
#define IDC_EDIT3                       1013
#define IDC_EDIT_TITLE                  1013
#define IDC_EDIT5                       1015
#define IDC_EDIT_DELAY                  1015
#define IDC_EDIT6                       1016
#define IDC_EDIT_PERIOD                 1016
#define IDC_RADIO_SNIFFS                1017
#define IDC_RADIO_SNAPS                 1018
#define IDC_CHECK_WEB                   1019
#define IDC_CHECK_PUBLISH_ON_WEB        1019
#define IDC_CHECK_PUBLISH_RESULTS_ON_WEB 1019
#define IDC_EDIT_LOG                    1020
#define IDC_COMBO_OS_RELEASE            1021
#define IDC_EDIT_STEPSLEEP              1022
#define IDC_CHECK_RERUN_FAILED_TESTS    1023
#define IDC_CHECK_INSTALL_TESTS         1024
#define IDC_CHECK_DBGSNAPS              1025
#define IDC_CHECK_RESEDITSNAPS          1026
#define IDC_CHECK_PROJBLDSNAPS          1027
#define IDC_CHECK_WIZSNAPS              1028
#define IDC_EDIT_NUM_CPU                1031
#define IDC_LIST_TITLE                  1032
#define IDC_LIST_VC6                    1033
#define IDC_LIST3                       1034
#define IDC_LIST4                       1035
#define IDC_LIST5                       1036
#define IDC_LIST6                       1037
#define IDC_LIST7                       1038
#define IDC_LIST8                       1039
#define IDC_LIST9                       1040
#define IDC_BUTTON_LOAD_RUN             1041
#define IDC_LIST_RUNS                   1042

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1044
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\AutoComplete\Sniff\Src\AutoCompleteSuite.h ===
///////////////////////////////////////////////////////////////////////////////
//	AutoCompleteSuite.H
//
//	Description :
//		Declaration of the CAutoCompleteSuite class
//

#ifndef __AutoCompleteSuite_H__
#define __AutoCompleteSuite_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

// Messages for QA hooks
// See M:\dev\ide\pkgs\edit\tip.cpp

#define WM_GETLISTCOUNT         (WM_USER+401) // Return number of items in completion set
#define WM_GETLISTITEMLEN       (WM_USER+402) // Return length of item (0-based index in wParam)
#define WM_GETLISTITEMTEXT      (WM_USER+403) // Copy text of item (index in wParam) to lParam
#define WM_GETLISTMATCH         (WM_USER+404) // Return index of matched (not necessarily selected) item
#define WM_GETLISTSELECTION     (WM_USER+405) // Return index of selected item (-1 if nothing selected)
#define WM_GETDESCWINDOW        (WM_USER+406) // Return the window handle of the description window (an edit control)
#define WM_SETTITLETOITEM       (WM_USER+407) // Set the window title of the namelist to the current selection

#define WM_GETOVERLOADCOUNT     (WM_USER+501) // Return number of overloaded methods
#define WM_GETMETHODTEXTLEN     (WM_USER+502) // Return length of text of current method (methodtexttype in wParam)
#define WM_GETMETHODTEXT        (WM_USER+503) // Copy text of current method (methodtexttype in wParam) to lParam
#define WM_GETPARMCOUNT         (WM_USER+504) // Return number of parameters in current method
#define WM_GETPARMTEXTLEN       (WM_USER+505) // Return length of parameter text (LOWORD(wParam) = parm#,
                                              //  HIWORD(wParam) = parametertexttype)
#define WM_GETPARMTEXT          (WM_USER+506) // Copy parameter text to lParam (LOWORD(wParam) = parm#,
                                              //  HIWORD(wParam) = parametertexttype)
#define WM_GETCURRENTPARM       (WM_USER+507) // Return index of current (bolded) parameter
#define WM_ISMETHODTIP          (WM_USER+508) // Return non-zero if this is a method tip window
#define WM_SETTITLETOMETHOD     (WM_USER+509) // Set Window Title to Method name
#define WM_SETTITLETOPARAM		(WM_USER+510) // Set Window Title to Param Text

#define WM_SETTITLETOTEXT       (WM_USER+601) // Set the window title to the text in the window


// Titles of Autocomplete windows
#define TITLE_AUTOCOMPLETE		"VsCompletorPane"
#define TITLE_CODE_COMMENTS		"VcTipWindow"
#define TITLE_PARAMETER_HELP	"VsTipWindow"
#define TITLE_TYPE_INFO			"VcTipWindow"

///////////////////////////////////////////////////////////////////////////////
// CAutoCompleteSuite class

class CAutoCompleteSuite : public CIDESubSuite
{
	DECLARE_SUBSUITE(CAutoCompleteSuite)

    DECLARE_TESTLIST();

// overrides
public:
	virtual void SetUp(BOOL bCleanUp);
	virtual void CleanUp(void);

// data members
public:
	COProject prj;
	COSource  src;
};

#endif //__AutoCompleteSuite_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\AutoComplete\Sniff\Src\AutoCompleteCases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//      AutoCompleteCases.CPP
//
//      Description :
//              Implementation of CAutoCompleteCases

#include "stdafx.h"
#include "AutoCompleteCases.h"
#include <afxpriv.h>

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CAutoCompleteCases, CTest, "AutoComplete", -1, CAutoCompleteSuite)

void CAutoCompleteCases::Run(void)
{
	EditSource();
}

BOOL CAutoCompleteCases::EditSource()
{
	BOOL		bReturn = TRUE;
	int			nCount = 0;
	int			nResult;
	HWND		hWnd;
	LRESULT		lIndex;
	LRESULT		lLength;
	TCHAR*		pItem;
	COClipboard clp;
	CString		strClip;
	CString		strRoot = _T("pMainFrame->");
	CString		strFunc = _T("PreCreateWindow");

	m_pLog->Comment("Open a source file.");

	// Open a source file
	nResult = src.Open(m_strCWD + "baseln\\AutoComp01\\"+"AutoComp01.cpp");

	if (nResult == ERROR_ERROR) {
		m_pLog->RecordFailure("Couldn't open source file AutoComp01.cpp");
		bReturn = FALSE;
	}
	else {
	
		// Move down the file to a place where we can enter
		// some AutoComplete code.
		src.GoToLine(101);
	
		// Wait for Go To dialog to go away
		while ((MST.WFndWnd("Go To", FW_DEFAULT)) && (nCount < 1000)) {
			nCount++;
		}

		MST.DoKeys("{TAB}");

		// Invoke AutoComplete
		MST.DoKeys(strRoot);

		hWnd = MST.WFndWndWaitC("", TITLE_AUTOCOMPLETE, FW_DEFAULT, 10);

		if (hWnd == 0) {
			m_pLog->RecordFailure("Couldn't find namelist for AutoComplete on pMainFrame->.");
		}
		else {
			if (MST.WIsVisible(hWnd)) {
				m_pLog->RecordSuccess("Found namelist for AutoComplete on pMainFrame->.");
			}
			else {
				m_pLog->RecordFailure("Namelist is not visible for AutoComplete on pMainFrame->");
			}
		}

		// Type in a partial function name and wait 
		// for the namelist to settle on the choice 
		// we're after (PreCreateWindow)
		MST.DoKeys("PreCreateW");

	// CHECK FOR THE CORRECT NAMELIST CHOICE

		// Get the index of the current selection in the list
		lIndex = SendMessage(hWnd, WM_GETLISTSELECTION, 0, 0);

		if (lIndex >= 0 ) {
			// Tell the IDE to put the selection in the window title
			SendMessage(hWnd, WM_SETTITLETOITEM, lIndex, 0);
			
			// Get the window title
			lLength = GetWindowTextLength(hWnd) + sizeof(TCHAR);
			pItem = new TCHAR[lLength];
			GetWindowText(hWnd, pItem, lLength);
			
			// Check that the selection in the 
			// namelist is the text we expect
			if (strcmp(pItem, strFunc) == 0) {
				m_pLog->RecordSuccess("The correct item was selected in the namelist.");
			}
			else {
				m_pLog->RecordFailure("Item selected does not match expectation.\n\t\tNamelist item = '%s'\n\t\tExpected '%s'", pItem, strFunc);
			}

			delete [] pItem;

			// Select the item in the namelist
			MST.DoKeys("{TAB}");

			// Select the line that was inserted into
			// the editor and copy it to the clipboard
			//MST.DoKeys("{UP}{HOME}");

			// Wait a little to paste the text
			Sleep(1000);
			MST.DoKeys("+{HOME}");
			MST.DoKeys("^c");

			strClip = clp.GetText();

			// Check that the namelist put the 
			// text we expect in the editor
			if (strClip == (strRoot + strFunc)) {
				m_pLog->RecordSuccess("Correct code was inserted by AutoComplete.");
				bReturn = TRUE;
			}
			else {
				m_pLog->RecordFailure("Text inserted into editor by AutoComplete does not match expectation.\n\t\tEditor string = '%s'\n\t\tExpected '%s'", strClip, (strRoot + strFunc));
				bReturn = FALSE;
			}
		}
		else {
			m_pLog->RecordFailure("Couldn't get the index of the item selected in the namelist.");
			bReturn = FALSE;
		}

		src.Close();
	}

	return(bReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\AutoComplete\Sniff\Src\ParameterHelpCases.h ===
///////////////////////////////////////////////////////////////////////////////
//	ParameterHelpCases.H
//
//	Description :
//		Declaration of the CParameterHelpCases class
//

#ifndef __ParameterHelpCases_H__
#define __ParameterHelpCases_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "AutoCompleteSuite.h"

///////////////////////////////////////////////////////////////////////////////
//	CParameterHelpCases class

class CParameterHelpCases : public CTest
{
	DECLARE_TEST(CParameterHelpCases, CAutoCompleteSuite)

// Operations
public:
	virtual void Run(void);
	BOOL EditSource();

// Member variables
public:
	COSource  src;
};

#endif //__ParameterHelpCases_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\AutoComplete\Sniff\Src\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\AutoComplete\Sniff\Src\CodeCommentsCases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//      CodeCommentsCases.CPP
//
//      Description :
//              Implementation of CCodeCommentsCases

#include "stdafx.h"
#include "CodeCommentsCases.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CCodeCommentsCases, CTest, "CodeComments", -1, CAutoCompleteSuite)

void CCodeCommentsCases::Run(void)
{
	EditSource();
}

BOOL CCodeCommentsCases::EditSource()
{
	BOOL	bReturn = TRUE;
	int		nCount = 0;
	int		nResult;
	LRESULT	lLength;
	HWND	hWnd;
	TCHAR*	pText;
	CString strComment = "Nonsense function for testing purposes";		// Need to put this in a string resource

	m_pLog->Comment("Open a source file.");

	// Open a source file
	nResult = src.Open(m_strCWD + "baseln\\AutoComp01\\"+"AutoComp01.cpp");

	if (nResult == ERROR_ERROR) {
		m_pLog->RecordFailure("Couldn't open source file AutoComp01.cpp");
		bReturn = FALSE;
	}
	else {
	
		// Move down the file to a place where 
		// we can enter some AutoComplete code.
		src.GoToLine(167);
		
		// Wait for Go To dialog to go away
		while ((MST.WFndWnd("Go To", FW_DEFAULT)) && (nCount < 1000)) {
			nCount++;
		}

		MST.DoKeys("{ENTER}");
		MST.DoKeys("{UP}");
		MST.DoKeys("{TAB}");
		MST.DoKeys("aboutDlg.");
		Sleep(1000);
		MST.DoKeys("fo");

		hWnd = MST.WFndWndWaitC("", "VcTipWindow", FW_DEFAULT, 10);

		if (hWnd == 0) {
			m_pLog->RecordFailure("Couldn't find CodeComments window.");
			bReturn = FALSE;
		}
		else {
			if (MST.WIsVisible(hWnd)) {
				m_pLog->RecordSuccess("Found CodeComments window.");

				// Tell the IDE to put the text in the window title
				SendMessage(hWnd, WM_SETTITLETOTEXT, 0, 0);
			
				// Get the window title
				lLength = GetWindowTextLength(hWnd) + sizeof(TCHAR);
				pText = new TCHAR[lLength];
				GetWindowText(hWnd, pText, lLength);
			
				if (strcmp(pText, strComment) == 0) {
					m_pLog->RecordSuccess("The comment matches the expected text.");
				}
				else {
					m_pLog->RecordFailure("Comment does not match expectation.\n\t\tComment = '%s'\n\t\tExpected '%s'", pText, strComment);
					bReturn = FALSE;
				}

				delete [] pText;
			}
			else {
				m_pLog->RecordFailure("CodeComments window is not visible.");
				bReturn = FALSE;
			}
		}

		// Dismiss the AutoComplete namelist
		MST.DoKeys("{ESC}");

		src.Close();
	}

	return(bReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\AutoComplete\Sniff\Src\CodeCommentsCases.h ===
///////////////////////////////////////////////////////////////////////////////
//	CodeCommentsCases.H
//
//	Description :
//		Declaration of the CCodeCommentsCases class
//

#ifndef __CodeCommentsCases_H__
#define __CodeCommentsCases_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "AutoCompleteSuite.h"

///////////////////////////////////////////////////////////////////////////////
//	CCodeCommentsCases class

class CCodeCommentsCases : public CTest
{
	DECLARE_TEST(CCodeCommentsCases, CAutoCompleteSuite)

// Operations
public:
	virtual void Run(void);
	BOOL EditSource();

// Member variables
public:
	COSource  src;
};

#endif //__CodeCommentsCases_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\AutoComplete\Sniff\Src\ParameterHelpCases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//      ParameterHelpCases.CPP
//
//      Description :
//              Implementation of CParameterHelpCases

#include "stdafx.h"
#include "ParameterHelpCases.h"

#define new DEBUG_NEW

#define MTT_TYPEPREFIX 0
#define MTT_TYPEPOSTFIX 1
#define MTT_NAME 2
#define MTT_DESCRIPTION 3

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CParameterHelpCases, CTest, "ParameterHelp", -1, CAutoCompleteSuite)

void CParameterHelpCases::Run(void)
{
	EditSource();
}

BOOL CParameterHelpCases::EditSource()
{
	BOOL	bReturn = TRUE;
	int		nCount = 0;
	int		nResult;
	LRESULT lLength;
	HWND	hWnd;
	TCHAR*	pText;
	CString strMethod = "Collate";		// Need to put this in a string resource
	CString strParam = "LPCTSTR lpsz";  // Need to put this in a string resource

	m_pLog->Comment("Open a source file.");

	// Open a source file
	nResult = src.Open(m_strCWD + "baseln\\AutoComp01\\"+"AutoComp01.cpp");

	if (nResult == ERROR_ERROR) {
		m_pLog->RecordFailure("Couldn't open source file AutoComp01.cpp");
		bReturn = FALSE;
	}
	else {
		// Move down the file to a place where 
		// we can enter some AutoComplete code.
		src.GoToLine(165);
		
		// Wait for Go To dialog to go away
		while ((MST.WFndWnd("Go To", FW_DEFAULT)) && (nCount < 1000)) {
			nCount++;
		}

		MST.DoKeys("{ENTER 2}");
		MST.DoKeys("{UP 2}");
		MST.DoKeys("CString str;{ENTER 2}");
		MST.DoKeys("str.");
		MST.DoKeys("Colla");
		MST.DoKeys("{TAB}");
		MST.DoKeys("{(}");

		hWnd = MST.WFndWndWaitC("", "VsTipWindow", FW_DEFAULT, 10);

		if (hWnd == 0) {
			m_pLog->RecordFailure("Couldn't find ParameterHelp window.");
			bReturn = FALSE;
		}
		else {
			if (MST.WIsVisible(hWnd)) {
				m_pLog->RecordSuccess("Found ParameterHelp window.");

				// Get the method name
				SendMessage(hWnd, WM_SETTITLETOMETHOD, MTT_NAME, 0);
				lLength = GetWindowTextLength(hWnd) + sizeof(TCHAR);
				pText = new TCHAR[lLength];
				GetWindowText(hWnd, pText, lLength);
			
				if (strcmp(pText, strMethod) == 0) {
					m_pLog->RecordSuccess("ParameterHelp matches the expected text.");
				}
				else {
					m_pLog->RecordFailure("ParameterHelp does not match expectation.\n\t\tParameterHelp = '%s'\n\t\tExpected '%s'", pText, strMethod);
				}

				delete [] pText;

				// Get the parameter
				SendMessage(hWnd, WM_SETTITLETOPARAM, 0, 0);
				lLength = GetWindowTextLength(hWnd) + sizeof(TCHAR);
				pText = new TCHAR[lLength];
				GetWindowText(hWnd, pText, lLength);
			
				if (strcmp(pText, strParam) == 0) {
					m_pLog->RecordSuccess("ParameterHelp matches the expected text.");
				}
				else {
					m_pLog->RecordFailure("ParameterHelp does not match expectation.\n\t\tParameterHelp = '%s'\n\t\tExpected '%s'", pText, strParam);
					bReturn = FALSE;
				}

				delete [] pText;
			}
			else {
				m_pLog->RecordFailure("ParameterHelp window is not visible.");
				bReturn = FALSE;
			}
		}

		// Dismiss the ParameterHelp window.
		MST.DoKeys("{ESC}");

		src.Close();
	}

	return(bReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\AutoComplete\Sniff\Src\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Description :
//		Precompiled header for a CAFE Test
//
//		Includes core CAFE headers for the target of the test.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\AutoComplete\Sniff\Src\TypeInfoCases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//      TypeInfoCases.CPP
//
//      Description :
//              Implementation of CTypeInfoCases

#include "stdafx.h"
#include "TypeInfoCases.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(CTypeInfoCases, CTest, "TypeInfo", -1, CAutoCompleteSuite)

void CTypeInfoCases::Run(void)
{
	EditSource();
}

BOOL CTypeInfoCases::EditSource()
{
	BOOL	bReturn = TRUE;
	int		nCount = 0;
	int		nResult;
	LRESULT lLength;
	HWND	hWnd;
	char*	pText;
	CString strInfo = "void __cdecl AfxEnableControlContainer(COccManager *)";		// Need to put this in a string resource

	m_pLog->Comment("Open a source file.");

	// Open a source file
	nResult = src.Open(m_strCWD + "baseln\\AutoComp01\\"+"AutoComp01.cpp");

	if (nResult == ERROR_ERROR) {
		m_pLog->RecordFailure("Couldn't open source file AutoComp01.cpp");
		bReturn = FALSE;
	}
	else {
	
		// Move down the file to a place where 
		// we can enter some AutoComplete code.
		src.GoToLine(53);
		
		// Wait for Go To dialog to go away
		while ((MST.WFndWnd("Go To", FW_DEFAULT)) && (nCount < 1000)) {
			nCount++;
		}

		// Move the caret onto the call to AfxEnableControlContainer()
		MST.DoKeys("{RIGHT 6}");
		Sleep(2000);

		// Edit.Type Info menu choice
		//MST.DoKeys("%ey");
		MST.DoKeys("^t");
		Sleep(1000);
		
		// Ctrl+T (Type Info)
		//MST.DoKeys("^t");
		//Sleep(1000);

		hWnd = MST.WFndWndWaitC("", "VcTipWindow", FW_DEFAULT, 10);

		if (hWnd == 0) {
			m_pLog->RecordFailure("Couldn't find TypeInfo window.");
			bReturn = FALSE;
#ifdef _DEBUG
			Beep(440, 10);
			AfxMessageBox("Type Info failed!");
#endif
		}
		else {
			if (MST.WIsVisible(hWnd)) {
				m_pLog->RecordSuccess("Found TypeInfo window.");

				// Tell the IDE to put the text in the window title
				SendMessage(hWnd, WM_SETTITLETOTEXT, 0, 0);
			
				// Get the window title
				lLength = GetWindowTextLength(hWnd) + sizeof(TCHAR);
				pText = new TCHAR[lLength];
				GetWindowText(hWnd, pText, lLength);
			
				if (strcmp(pText, strInfo) == 0) {
					m_pLog->RecordSuccess("The TypeInfo matches the expected text.");
				}
				else {
					m_pLog->RecordFailure("TypeInfo does not match expectation.\n\t\tTypeInfo = '%s'\n\t\tExpected '%s'", pText, strInfo);
					bReturn = FALSE;
				}

				delete [] pText;
			}
			else {
				m_pLog->RecordFailure("TypeInfo window is not visible.");
				bReturn = FALSE;
			}
		}

		// Dismiss the TypeInfo window
		MST.DoKeys("{ESC}");

		src.Close();
	}

	return(bReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Box\Sniff\Src\StdAfx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Box\Sniff\Src\StdAfx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Description :
//		Precompiled header for a CAFE Test
//
//		Includes core CAFE headers for the target of the test.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\AutoComplete\Sniff\Src\TypeInfoCases.h ===
///////////////////////////////////////////////////////////////////////////////
//	TypeInfoCases.H
//
//	Description :
//		Declaration of the CTypeInfoCases class
//

#ifndef __TypeInfoCases_H__
#define __TypeInfoCases_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "AutoCompleteSuite.h"

///////////////////////////////////////////////////////////////////////////////
//	CTypeInfoCases class

class CTypeInfoCases : public CTest
{
	DECLARE_TEST(CTypeInfoCases, CAutoCompleteSuite)

// Operations
public:
	virtual void Run(void);
	BOOL EditSource();

// Member variables
public:
	COSource  src;
};

#endif //__TypeInfoCases_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Box\Sniff\Src\FCompare.h ===
///////////////////////////////////////////////////////////////////////////////
//	FCompare.h
//
//	Created by :			
//		Anushas
//				
//	Description :
//		Declaration of the CFileCompare class
//
#ifndef _FCOMPARE_H
#define _FCOMPARE_H

#pragma warning (disable :4786)

#include <string>
#include <iostream>

#include "windows.h"
#include <fstream>
#include <list>

///////////////////////////////////////////////////////////////////////////////
//				File Compare class

class CFileCompare
{
private:
	OSVERSIONINFO m_OSINFO;
	std::string m_OSinfo;
	std::list<std::string> m_Ctrllist,m_Plist,m_succlist;
	int StoreCtrlList(std::string);//stores the control file info onto a list
	int StorePList(std::string);//stores the Pre/Post  file info onto a list
	void getOSinfo(std::string);//returns the OS info
	std::string getplatform();//returns the platform currently working on
	std::string getLang();//returns system language
	
	//operations
public:
	int CompareFiles(std::string ,std::string,std::string);//compares the ctrl and pre/post file
	std::list<std::string> getCtrllist(){return m_Ctrllist;}//returns the ctrl file list
	std::list<std::string> getPlist(){return m_Plist;}//returns the Pre/post file list
	std::list<std::string> getsucclist(){return m_succlist;}//returns the successful file search list
	std::string getOSinfo(){ return m_OSinfo;}//returns the OSinfo string
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Box\Sniff\Src\FileVerTestcase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	FileVerTestcase.CPP
//											 
//	Created by :			
//		Anushas
//			
//	Description :								 
//		Implements CFileVerTestcase

#include "stdafx.h"
#include "FileVerTestcase.h"					 	 

typedef	std::list<std::string> lstring;
			   
#define VERIFY_TEST_SUCCESS(TestCase)\
	TestCase == ERROR_SUCCESS

IMPLEMENT_TEST(CFileVerTestcase, CTest, "VC6 - File Verification", -1, CVerCheckSuite)
												 
void CFileVerTestcase::Run(void)
{
	//checking for pre file
	m_pLog->RecordInfo("Comparing Control file and the PRE file .........");
	
	std::string pre_file = GetDrive("PRE");
	std::string post_file = GetDrive("POST");
	int flag = fc.CompareFiles(".\\Control.txt",pre_file,"PRE");
	m_pLog->RecordInfo(fc.getOSinfo().c_str());
	if (flag == 1)
	{
		m_pLog->RecordInfo("OS info doesnot exist in the Control file .........");
		m_pLog->RecordFailure("OS info doesnot exist in the :%s","Control file.....");
	}
	else if(flag == 2)
	{
		m_pLog->RecordInfo("File doesnot exist.........");
		m_pLog->RecordFailure(":%s","File does not exist .....");
	}
	else
		WriteLog();//write the results in the log file

	//checking for post file
	m_pLog->RecordInfo("\nComparing Control file and the POST file .........");
	flag = fc.CompareFiles(".\\Control.txt",post_file,"POST");
	m_pLog->RecordInfo(fc.getOSinfo().c_str());
	if (flag == 1)
	{
		m_pLog->RecordInfo("OS info doesnot exist in the Control file .........");
		m_pLog->RecordFailure("OS info doesnot exist in the :%s","Control file.....");
	}
	else if(flag == 2)
	{
		m_pLog->RecordInfo("File doesnot exist.........");
		m_pLog->RecordFailure(":%s","File does not exist .....");
	}
	else
		WriteLog();//write the results in the log file
/*	DeleteFile(pre_file.c_str());
	DeleteFile(post_file.c_str());*/
}

/*///////////////////////////////////////////////////////////
This function extracts the controllist,pre/post list and the
successful file search list and records them as either successes
or as failures 
Input : N/A
Output: N/A
///////////////////////////////////////////////////////////*/

void CFileVerTestcase::WriteLog()
{
	lstring Ctrllist,Plist,succlist;
	lstring::iterator iter;
	Ctrllist = fc.getCtrllist();
	Plist = fc.getPlist();
	succlist = fc.getsucclist();

	//Record Failures
	char buff[20];
	_itoa((Ctrllist.size()+Plist.size()),buff,10);
	std::string temp = "\n\n\nTotal number of failures  : " ;
	temp.append(buff);
	m_pLog->RecordInfo(temp.c_str());
	if(Ctrllist.size() > 0)//if list has data
		for(iter = Ctrllist.begin();iter!=Ctrllist.end();iter++)
			m_pLog->RecordFailure("Additional Files : %s", (*iter).c_str());

	if(Plist.size() > 0)//if list has data
		for(iter = Plist.begin();iter!=Plist.end();iter++)
			m_pLog->RecordFailure("Missing files : %s", (*iter).c_str());

	//record successes
	_itoa(succlist.size(),buff,10);
	temp = "\n\n\nTotal number of successes : " ;
	temp.append(buff);
	
	m_pLog->RecordInfo(temp.c_str());
	if (succlist.size()>0)// if success list has data
		for(iter = succlist.begin();iter!=succlist.end();iter++)
			m_pLog->RecordSuccess("%s", (*iter).c_str());
}//end of function


std::string CFileVerTestcase::GetDrive(std::string pfile)
{
	char* sysdir ;
	sysdir = (char*)malloc(sizeof(char)*20);
	std::string filename;
	GetSystemDirectory(sysdir,256);
	filename = sysdir;
	sysdir[filename.length()]='\0';
	filename = filename.substr(0,3);
	filename.append(pfile);
	filename.append(".txt");
	return filename;	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Box\Sniff\Src\FileVerTestcase.h ===
///////////////////////////////////////////////////////////////////////////////
//	FileVerTestcase.H
//
//	Created by :			
//		Anushas
//				
//	Description :
//		Declaration of the CFileVerTestcase class
//

#ifndef __FileVerTestcase_H__
#define __FileVerTestcase_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "VerCheckSuite.h"
#include "FCompare.h"
#include <string>
#include <list>
///////////////////////////////////////////////////////////////////////////////
//	CAFileVerTestcase class

class CFileVerTestcase : public CTest
{
private:
	DECLARE_TEST(CFileVerTestcase, CVerCheckSuite)
	void WriteLog();//Write into a log file
	CFileCompare fc;//instance of the filecompare object
	std::string GetDrive(std::string);//gets the system dirve attached to teh pre or post file
// Operations
public:
	virtual void Run(void);

};

#endif //__FileVerTestcase_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Box\Sniff\Src\VerCheckSuite.h ===
///////////////////////////////////////////////////////////////////////////////
//	VerCheckSuite.h
//
//	Created by :			
//		VSUpdate QA
//		DougMan
//
//	Description :
//		Declaration of the CVerCheckSuite class

#ifndef __VERCHECKSUITE_H__
#define __VERCHECKSUITE_H__
#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CVerCheckSuite class

class CVerCheckSuite : public CIDESubSuite
{
	DECLARE_SUBSUITE(CVerCheckSuite)

	DECLARE_TESTLIST(); 

public:
	virtual void SetUp(BOOL bCleanUp);
	virtual void CleanUp(void);
};
#endif //__VERCHECKSUITE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Box\Sniff\Src\FCompare.cpp ===
/////////////////////////////////////////////////////////////
//	FCompare.cpp
//
//	Created by :			
//		Anushas


#include "FCompare.h"
#include "winuser.h"
using namespace std;

/*///////////////////////////////////////////////////////////
This function parses the control file and if a block matches 
the system's OS info then extracts that block and stores
the block in a list.
Input : Control file
Output: Flag to if the block is found or not
///////////////////////////////////////////////////////////*/

int CFileCompare::StoreCtrlList(string Ctrlfile)
{
	int flag=1;//flag for if the block is found or not
	ifstream in;
	in.open(Ctrlfile.c_str());
	string line,temp;
	if(in.good() == 0)
		return 2;
	while(in.good() && flag)
	{
		getline(in,line);//get the 1st line
		if (line.compare(m_OSinfo)== 0) //Check if the block is found
		{
			flag =0;//if found set to 0
			while(in.good())		//for the original file
			{
				line ="";
				in >> temp;// exclude the path name
				if(temp.length()>0)// check if current record is empty 
				{//if not empty
					if(temp.find_first_of("[")== 0) // Check if the end of the block is reached
						break;						// If reached break.
										
					for(int i=0;i<4;i++)
					{
						in >> temp;//filename
						line.append(temp);
						line.append(" ");//add delimiter
					}
					m_Ctrllist.push_back(line);//insert the file details in the list
					in>>temp;//exclude the time
					in>>temp;//exclude the CRC comment
				}
				else
					getline(in,line);//next line
			}
		}
	}
	in.close();
	return flag;
}//end of function

/*///////////////////////////////////////////////////////////
This function parses the pre/post file and stores
the block in a list.
Input : pre/Post file
Output: Flag to if the file is found or not
///////////////////////////////////////////////////////////*/
int CFileCompare::StorePList(string pfile)
{
	ifstream in;
	string line,temp;
	in.open(pfile.c_str());
	if(in.good() == 0)
		return 2;
	getline(in,line);// The 1st line is not necessary as it contains the labels
	while(in.good())
	{
		line="";
		in >> temp;//path name we don't need
		if (temp.length() == 0)// check if current record is empty 
			break;				//If so , break	
		for(int i=0;i<4;i++)
		{
			in >> temp;//filename
			line.append(temp);
			line.append(" ");//add delimiter
		}
		m_Plist.push_back(line);//insert the file details in the list
		in>>temp;//exclude the time
		in>>temp;//exclude the CRC comment
	}
	in.close();
	return 1;
}//end of function

/*///////////////////////////////////////////////////////////
This function finds the current system's OS and returns
it
Input : N/A
Output: OS info
///////////////////////////////////////////////////////////*/
string CFileCompare::getplatform()
{
	string plname;
	OSVERSIONINFOEX exOSInfo;
	exOSInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
	GetVersionEx((OSVERSIONINFO *) &exOSInfo);//get the extended OSversion info
	switch (m_OSINFO.dwPlatformId)
	{

	case VER_PLATFORM_WIN32_NT:
		if ( m_OSINFO.dwMajorVersion <= 4 )
			plname = "Microsoft Windows NT";
		else if ( m_OSINFO.dwMajorVersion == 5 )
		{
			/*if(exOSInfo.wProductType == VER_NT_WORKSTATION)
				plname = "Microsoft Windows 2000 Profesional";
			else if ((exOSInfo.wProductType == VER_NT_SERVER) && (exOSInfo.wSuiteMask == VER_SUITE_DATACENTER))
				plname = "Microsoft Windows 2000 DataCenter Server";
			else if ((exOSInfo.wProductType == VER_NT_SERVER) && (exOSInfo.wSuiteMask == VER_SUITE_ENTERPRISE))
				plname = "Microsoft Windows 2000 Advanced Server";
			else*/
				plname = "Microsoft Windows 2000";// Server";
		}
		else
			plname = "Unknown Windows Class (NT)";
		break;

	case VER_PLATFORM_WIN32_WINDOWS:
		if ( (m_OSINFO.dwMajorVersion == 4) && (m_OSINFO.dwMinorVersion > 0) && (m_OSINFO.dwMinorVersion < 90) )
			plname = "Microsoft Windows 98";
		else if ( (m_OSINFO.dwMajorVersion == 4) && (m_OSINFO.dwMinorVersion == 0))
			plname = "Microsoft Windows 95";
		else if ( (m_OSINFO.dwMajorVersion == 4) && (m_OSINFO.dwMinorVersion == 90))
			plname = "Microsoft Windows Millennium";
		else
			plname = "Unknown Windows Class (95/98/ME)";
		break;

	case VER_PLATFORM_WIN32s:
		plname ="Microsoft Win32s ";

	}
	return plname;
}//end of function

/*///////////////////////////////////////////////////////////
This function finds the current system's language and 
returns it
Input : N/A
Output: language
///////////////////////////////////////////////////////////*/

string CFileCompare::getLang()
{
	string lng;
	if( GetSystemDefaultLangID() == 0x0409)
		lng ="English";
	else if (GetSystemDefaultLangID() == 0x0411)
		lng = "Japanese";
	else
		lng = "Unknown";
	return lng;
}//end of function

/*///////////////////////////////////////////////////////////
This function finds the current system's OS info and stores 
it in a private variable
Input : "PRE" or "POST" string
Output: N/A
///////////////////////////////////////////////////////////*/

void CFileCompare::getOSinfo(string msg)
{
	m_OSINFO.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&m_OSINFO);//get the OSversion info
	string plform="[";
	char buff[20];
	plform.append(getplatform());//get OS platform
	_itoa(m_OSINFO.dwMajorVersion,buff,10);//get major version number
	plform.append(" ");
	plform.append(buff);
	_itoa(m_OSINFO.dwMinorVersion,buff,10);//get minor version number
	plform.append(".");
	plform.append(buff);
	_itoa(m_OSINFO.dwBuildNumber,buff,10);//get build number
	plform.append(" Build ");
	plform.append(buff);
	plform.append(" ");
	plform.append(m_OSINFO.szCSDVersion);//get service pack
	plform.append(" ");
	plform.append(getLang());//get language
	m_OSinfo = plform+" "+ msg +"]";
}//end of function

/*///////////////////////////////////////////////////////////
This function gets the control file and the pre/post file
info parses those files and stores them in a list
and compares the 2 lists and finds out teh common files,stores
them in a list and deletes them from the original lists
returns it
Input : Ctrl file name,Pre/Post file name,"PRE" or "POST" msg
Output: 0/1 based on the search was successful or not
///////////////////////////////////////////////////////////*/

int CFileCompare::CompareFiles(string orfile,string pfile,string msg)
{
	list<string>::iterator iter1,iter2,titer1,titer2;
	int flag =0,ctrlflag;
	getOSinfo(msg);//gets the OS info
	ctrlflag = StoreCtrlList(orfile);//store sthe ctrl file info onto a list
	if(ctrlflag == 1)
		return 1;//unsuccessful
	
	if (StorePList(pfile) == 2 || ctrlflag == 2)//store sthe pre/post file info onto a list
		return 2;//file not found

	for(iter1 = m_Ctrllist.begin();iter1!=m_Ctrllist.end();)
	{
		flag =0;
		for(iter2= m_Plist.begin();iter2!=m_Plist.end();)
		{
			titer1 = iter1;
			titer2 = iter2;
			if((*iter1).compare(*iter2) == 0)
			{
				m_succlist.push_back(*iter1);
				iter1++;
				iter2++;
				m_Ctrllist.erase(titer1);//delete the entry
				m_Plist.erase(titer2);//delete the entry
				flag = 1;
				break;
			}
			else
				iter2++;
		}
		if(flag == 0)
			iter1++;
	}
	return 0;//if successful
}//end of function
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Box\Sniff\Src\VerCheckSuite.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	VerCheckSuite.CPP
//	Created by :
//		VSUpdate QA
//		DougMan
//
//	Description :	implementation of the CVerCheckSuite class

#include "stdafx.h"
#include "VerCheckSuite.h"

// Testcase includes
#include "FileVerTestcase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// The CVerCheckSuite object

IMPLEMENT_SUBSUITE(CVerCheckSuite, CIDESubSuite, "VC6 - Verfication Check", "DougMan")

BEGIN_TESTLIST(CVerCheckSuite)
	TEST(CFileVerTestcase, RUN)	// Add a list of all the testcases here. RUN flag selects the case to run by default.
END_TESTLIST()					// Use the NORUN flag to deselect the test by default when the suite is loaded in the driver.

void CVerCheckSuite::SetUp(BOOL bCleanUp)
{
	// call the base class
	CIDESubSuite::SetUp(bCleanUp);
}

void CVerCheckSuite::CleanUp(void)
{
	CIDESubSuite::CleanUp();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\all\diffseg.cpp ===
void diff_seg_func(void)
	{
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\all\lineonly.cpp ===
__declspec(dllexport) void line_only_dll_func(void)
	{
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\DbgTestBase.cpp ===
///////////////////////////////////////////////////////////////////////////////
// DbgTestBase.cpp
//
//	Created by:	MichMa
//	Date:		3/30/98
//
//	Description: Definition of base class for all debugger tests.


#include "stdafx.h"
#include "DbgTestBase.h"
#include "guitarg.h"

IMPLEMENT_DYNAMIC( CSubTestException, CException );

IMPLEMENT_DYNAMIC(CDbgTestBase, CTest)

#define GetSubSuite() ((CIDESubSuite*)m_pSubSuite)

CDbgTestBase::CDbgTestBase(/*int metricID,*/ CIDESubSuite* pSubSuite, LPCSTR szName, int nExpectedCompares, LPCSTR szListFilename /*= NULL*/)
: CTest(/*metricID,*/ pSubSuite, szName, nExpectedCompares, szListFilename)
{
}

BOOL CDbgTestBase::SetProject(LPCSTR projName, PROJECT_TYPE projType /* PROJECT_EXE */, PROJECT_FLAGS flags /* fDefault */, LPCSTR cfgName /*NULL*/)
{
	const char* const THIS_FUNCTION = "SetProject()";
	CString projPathAndName = projName;
	int iName = projPathAndName.ReverseFind('\\');
	if( iName < 0 )
	{
		m_strProjectDir = FullPath("src");
		m_strProjectName = projName;
	}
	else
	{
		m_strProjectDir = (CString)FullPath("src") + "\\" + projPathAndName.Left(iName);
		m_strProjectName = projPathAndName.Mid(iName + 1);
	}

	CIDESubSuite* pSubSuite=GetSubSuite();
	ASSERT(pSubSuite->IsKindOf(RUNTIME_CLASS(CIDESubSuite))); //our tests are IDE tests only
	// build the path, lib, and include environment strings.

	CString cstrPathEnv, cstrLibEnv, cstrIncludeEnv;
	pSubSuite->GetIDE()->GetEnvironmentVar(settingPathEnv, cstrPathEnv);
	cstrPathEnv = settingPathEnv + CString("=") + cstrPathEnv;
	pSubSuite->GetIDE()->GetEnvironmentVar(settingLibEnv, cstrLibEnv);
	cstrLibEnv = settingLibEnv + CString("=") + cstrLibEnv;
	pSubSuite->GetIDE()->GetEnvironmentVar(settingIncludeEnv, cstrIncludeEnv);
	cstrIncludeEnv = settingIncludeEnv + CString("=") + cstrIncludeEnv;

	// get windows and system dir and append to path environment string.
	CString cstrWindowsDir, cstrSystemDir;
	// each dir is prepended with a semi-colon as a separator. 
	char chDirBuf[MAX_PATH] = ";";
 	GetWindowsDirectory(&chDirBuf[1], MAX_PATH);	// &chDirBuf[0] = ';'
	cstrWindowsDir = chDirBuf;
	GetSystemDirectory(&chDirBuf[1], MAX_PATH);		// &chDirBuf[0] = ';'
	cstrSystemDir = chDirBuf;
	cstrPathEnv += cstrWindowsDir + cstrSystemDir;

	// nmake's environment block.
	char chNmakeEnv[1024];
	// pointer to navigate through block.
	char *pchNmakeEnv = chNmakeEnv;

	// put the path, lib, and include environment strings into the block.
	// each string is terminated by null.
	strcpy(pchNmakeEnv, cstrPathEnv);
	pchNmakeEnv += strlen(pchNmakeEnv) + 1;
	strcpy(pchNmakeEnv, cstrLibEnv);
	pchNmakeEnv += strlen(pchNmakeEnv) + 1;
	strcpy(pchNmakeEnv, cstrIncludeEnv);
	// block is terminated by additional null.
	pchNmakeEnv[strlen(pchNmakeEnv) + 1] = 0;
 
	// to find nmake.exe in the toolset path environment, 
	// we'll use cstrPathFrag to search	for and extract directories
	// from cstrPathEnv	(minus first 5 characters which are "PATH=").
	CString cstrPathFrag = cstrPathEnv.Mid(5);
	// stores dir extracted from cstrPathFrag.
	CString cstrDir;
	// stores index of next semi-colon (dir separator) in cstrPathEnv.
	int indexSemi;
	// handle to nmake.exe returned by FindFirstFile().
	HANDLE hNmake;
	// FindFirstFile param.
	WIN32_FIND_DATA fdFindData;

	while(1)
		
		{
		// find the next semi-colon which terminates the next dir to search.
		indexSemi = cstrPathFrag.Find(';');

		// if a semi-colon was found, extract the dir it terminates. otherwise
		// we are at the final dir in the path environment. 
		if(indexSemi != -1)
			cstrDir = cstrPathFrag.Left(indexSemi);
		else
			cstrDir = cstrPathFrag;
			
		// only want to search dirs at least 3 chars long. for example:
		// path  = C:\;
		// index = 0123
		if(cstrDir.GetLength() >= 3)
			hNmake = FindFirstFile(cstrDir + "\\nmake.exe", &fdFindData);
  		
		// stop searching if nmake was found in cstrPathFrag.
		if(hNmake != INVALID_HANDLE_VALUE)
			break;

		// if no semi-colon was found or it was the last char in the path, 
		// then we just searched the final dir in the environment string, 
		// but still haven't found nmake. 
	 	if((indexSemi == -1) || (cstrPathFrag.GetLength() == (indexSemi + 1)))
			{
			m_pLog->RecordInfo("ERROR in %s: could not find nmake.exe in path environment "
							   "specified by CAFE.", THIS_FUNCTION);
			return FALSE;
			}
		else
			// advance to the start of the next dir after the semi-colon.
			cstrPathFrag = cstrPathFrag.Mid(indexSemi + 1);
		}


	// determine the configuration switch that we need to pass to nmake.
	// also set platform member value for easy access by tests.
	if(cfgName==NULL)
	switch(GetUserTargetPlatforms())
		{
        case PLATFORM_WIN32_ALPHA:
            cfgName = "alpha";
            m_platform = PLATFORM_WIN32_ALPHA;
            break;
		case PLATFORM_WIN32_X86:
			cfgName = "x86";
			m_platform = PLATFORM_WIN32_X86;
			break;
		}

	// project name and configuration switch we will pass to nmake.
	// we enclose the project name in quotes to support names with spaces.
	CString cstrProjAndConfig = (CString)"\"" + m_strProjectName + ".mak\" CFG=" + cfgName;
	if( UIWB.GetPcodeSwitch() )
		cstrProjAndConfig += " PCODE=yes";
	// CreateProcess() params.
   	STARTUPINFO siStartInfo;
	PROCESS_INFORMATION piProcInfo;
	// this is the minium initialization of STARTUPINFO required for CreateProcess() to work.
	memset(&siStartInfo, 0, sizeof(STARTUPINFO));
	siStartInfo.cb = sizeof(STARTUPINFO);
	siStartInfo.wShowWindow = SW_SHOWDEFAULT;
	// fully qualified nmake.exe cmd line (cstrDir is directory we found nmake in earlier).
	char chNmakeCmdLine[MAX_PATH];
	strcpy(chNmakeCmdLine, cstrDir + "\\nmake.exe /a /f " + cstrProjAndConfig);

	// before spawning nmake make sure Debugger is not running, so vc50.pdb is released
	if(dbg.GetDebugState() != NotDebugging)
		dbg.StopDebugging();

	// Allocate console to be able to see how the project is built.  If we don't allocate it the window close
	// immediately after build process has finished. *dklem
	WaitStepInstructions("Allocating nmake console");
	AllocConsole();
	SetConsoleTitle(chNmakeCmdLine);

	// spawn nmake in the project dir.
	BOOL bRet = CreateProcess(NULL, chNmakeCmdLine, NULL, NULL, TRUE, NORMAL_PRIORITY_CLASS, chNmakeEnv,
							  m_strProjectDir, &siStartInfo, &piProcInfo);
	
	// verify that nmake was successfully spawned.						  
	if(!bRet)
		{
		m_pLog->RecordInfo("ERROR in %s: nmake.exe found but could not be spawned.", THIS_FUNCTION);
		return FALSE;
		}

	// nmake's exit code returned by GetExitCodeProcess().
	DWORD dwNmakeExitCode;

	// wait up to 60 minutes for nmake to terminate.
	for(int i = 0; i < 3600; i++)
		
		{
		Sleep(1000);
		// get nmake's exit code (if it has finished).
		GetExitCodeProcess(piProcInfo.hProcess, &dwNmakeExitCode);
		
		// keep sleeping if nmake is still running.
		if(dwNmakeExitCode != STILL_ACTIVE)
			break;
		}

	// Say good bye to the console
	WaitStepInstructions("Destroying nmake console");
	FreeConsole();

	// verify that nmake finished within the allotted time.
	if(i == 3600)
		{
		m_pLog->RecordInfo("ERROR in %s: after 60 minutes nmake is still running.", THIS_FUNCTION);
		return FALSE;
		}

	// verify that nmake was successful in building the executable.
	if(dwNmakeExitCode != 0)
		{
		m_pLog->RecordInfo("ERROR in %s: nmake.exe returned error code %d.", THIS_FUNCTION, dwNmakeExitCode);
		return FALSE;
		}

	// wait until nmake's window has gone away.
	if(!MST.WFndWndWait(chNmakeCmdLine, FW_NOEXIST, 5))
		{
		m_pLog->RecordInfo("ERROR in %s: after 5 seconds nmake's window still exists.", THIS_FUNCTION);
		return FALSE;
		}

	// stop here if we only want to build.
	if(flags & fBuildOnly)
		return TRUE;

	// project exe has same base as makefile (i.e. xxx.mak/xxx.exe/xxx.dll)
	// we want to strip out any prepended path and just use the file name
	// because we use this name to set the remote path, and the host
	// path will usually not match the remote path.
	CString cstrProjectExe = m_strProjectName.Right(m_strProjectName.GetLength() -
							 m_strProjectName.ReverseFind('\\') - 1) + 
							 ((projType == PROJECT_EXE) ? ".exe" : ".dll");


	// we need to make sure the debugger isn't running on a previous project
	// or COWorkSpace::CloseAllWindows will fail.
	if(dbg.GetDebugState() != NotDebugging)
		dbg.StopDebugging();

	// we need to close all windows before opening the exe or COProject::Open will fail.
 	COWorkSpace ws;
	ws.CloseAllWindows();

	// open the executable.	
	if(prj.Open(m_strProjectDir + "\\" + cstrProjectExe) != ERROR_SUCCESS)
		{
		m_pLog->RecordInfo("ERROR in %s: could not open \"%s\".", THIS_FUNCTION, 
							m_strProjectDir + "\\" + cstrProjectExe);
		return FALSE;
		}

	// allows us to access ide's connection settings via pconnec.
	COConnection *pconnec = pSubSuite->GetIDE()->GetConnectionInfo();
	
/*	// TODO(michma - 8/12/98): connection stuff has been moved to project settings.
re-enable when support layer has been updated.

	// set the connection as specified by the user.
	if(pconnec->SetAll() != ERROR_SUCCESS)
		{
		m_pLog->RecordInfo("ERROR in %s: could not set connection settings.", THIS_FUNCTION);
		return FALSE;
		}
*/	
	// if indicated, set the remote path and copy the executable to the remote machine.
	if(pconnec->GetUserConnections() != CONNECTION_LOCAL)
		
		{
		if(prj.SetRemotePath(cstrProjectExe) != ERROR_SUCCESS)
			{
			m_pLog->RecordInfo("ERROR in %s: could not set remote path using \"%s\".", 
							   THIS_FUNCTION, cstrProjectExe);
			return FALSE;
			}
		
		if(prj.UpdateRemoteFile(m_strProjectDir + "\\" + cstrProjectExe) != ERROR_SUCCESS)
			{
			m_pLog->RecordInfo("ERROR in %s: could not update remote file using \"%s\".", 
							   THIS_FUNCTION, m_strProjectDir + "\\" + cstrProjectExe);
			return FALSE;
			}
		}
	
	return TRUE;
	}


/*
** start debugging and do some initialization.  
*/

BOOL CDbgTestBase::StartDebugging(void)
{
	BOOL bSuccess; 
	COSource src;	

	bps.ClearAllBreakpoints();		// Clear All Breakpoints Just in case.
	dbg.StepOver(1);				// Start debugging session with initial trace.
	src.AttachActiveEditor();		// WinslowF
	bSuccess = dbg.AtSymbol("WinMain");

	// attach to the editor window the debugger opened
	bSuccess &= src.AttachActiveEditor();

	mem.SetMemoryFormat(MEM_FORMAT_BYTE); 
	dbg.SetSteppingMode(SRC); 		
	return bSuccess;
}


BOOL CDbgTestBase::StopDbgCloseProject(void)
{
	if (dbg.GetDebugState() != NotDebugging)
		dbg.StopDebugging();
	UIWB.CloseAllWindows();
	prj.Close();						

	return TRUE;
}


BOOL CDbgTestBase::VerifyProjectRan(int exitcode /* = 0 */)
{

	// REVIEW: use CODebug::VerifyTermination when it is available.
	// OpenOutputWindow
	UIOutput uow = UIDebug::ShowDockWindow(IDW_OUTPUT_WIN, TRUE);
//	EXPECT( uow.IsActive() );
	// Select the last line, write it to clipboard and look for "exit code 0"
	MST.DoKeys( "^{end}" );
	MST.DoKeys( "{up}" );

	char buffer[10];
	CString	szexcode = "exited with code ";			
	szexcode += itoa(exitcode, buffer, 10 ); // WinslowF - for OEM compatibility now we can specify the exit code to be verified

	if ( UIWB.VerifySubstringAtLine( szexcode ))
	{
		return (TRUE);
	}
	else
	{
		return (FALSE);
	}		
	
	return TRUE;
}


BOOL CDbgTestBase::StepInUntilFrameAdded( CString addframe )
{
	BOOL bResult = TRUE;
	COStack stk;
	CODebug dbg;
	FrameList framelist0;

	// Establish base line
	if(framelist0.CreateFromText( stk.GetAllFunctions() ) == FALSE)
	{
		m_pLog->RecordInfo( "StepInUntilFrameAdded - error retrieving stack frames");
		return FALSE;
	}
	Frame topframe( framelist0[0] );

	while( bResult ) {
		dbg.StepInto();
		FrameList current;
		if(current.CreateFromText( stk.GetAllFunctions() ) == FALSE)
		{
			m_pLog->RecordInfo( "StepInUntilFrameAdded - error retrieving stack frames");
			return FALSE;
		}

		if( current.GetSize() == framelist0.GetSize() ) {
			// Only check function name or image name for top frame.
			CString str0;
			if( topframe.GetFunctionName( str0 ) ) {
				bResult = Frame( current[0] ).Test( str0 );
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameAdded - Mismatch top frame '%s' not in '%s'",
						(LPCTSTR)str0, (LPCTSTR)current[0] );
				}
			}
			else if( topframe.GetImageName( str0 ) ){
				bResult = Frame( current[0] ).Test( str0 );
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameAdded - Mismatch top frame '%s' not in '%s'",
						(LPCTSTR)str0, (LPCTSTR)current[0] );
				}
			}
			else {
				// Bad format
				m_pLog->RecordInfo( "StepInUntilFrameAdded - Bad format for frame '%s'",
					(LPCTSTR)topframe );
				bResult = FALSE;
			}

			// The remaining frames should be identical
			for( int iFrame = 1; bResult && iFrame < framelist0.GetSize(); iFrame++ ) {
				bResult = framelist0[iFrame] == current[iFrame];
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameAdded - Mismatch in frame %d, '%s' != '%s'",
						(LPCTSTR)current[0], (LPCTSTR)framelist0[0] );
				}
			}
		}
		else if( current.GetSize() == framelist0.GetSize() + 1 ) {
			// Test new top frame
			bResult = Frame( current[0] ).Test( addframe );

			// Only check function name or image name for 2nd frame since the line number
			// may change.
			CString str0;
			if( topframe.GetFunctionName( str0 ) ) {
				bResult = Frame( current[1] ).Test( str0 );
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameAdded - Mismatch 2nd frame '%s' not in '%s'",
						(LPCTSTR)str0, (LPCTSTR)current[1] );
				}
			}
			else if( topframe.GetImageName( str0 ) ) {
				bResult = Frame( current[1] ).Test( str0 );
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameAdded - Mismatch 2nd frame '%s' not in '%s'",
						(LPCTSTR)str0, (LPCTSTR)current[1] );
				}
			}
			else {
				// Bad format
				m_pLog->RecordInfo( "StepInUntilFrameAdded - Bad format for frame '%s'",
					(LPCTSTR)topframe );
				bResult = FALSE;
			}

			// The remaining frames should be identical
			for( int iFrame = 1; bResult && iFrame < framelist0.GetSize(); iFrame++ ) {
				bResult = framelist0[iFrame] == current[iFrame+1];
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameAdded - Mismatch in frame %d, '%s' != '%s'",
						(LPCTSTR)current[iFrame+1], (LPCTSTR)framelist0[iFrame] );
				}
			}
			break;	// Get out of loop

		}
		else {
			// Unexpected number of frames
			m_pLog->RecordInfo( "StepInUntilFrameAdded - Expected %d frames, got %d frames",
				framelist0.GetSize() + 1, current.GetSize() );
			bResult = FALSE;
		}
	}

	return bResult;
}

BOOL CDbgTestBase::StepInUntilFrameRemoved() {
	BOOL bResult = TRUE;
	COStack stk;
	CODebug dbg;
	FrameList framelist0;

	// Establish base line
	if(framelist0.CreateFromText( stk.GetAllFunctions() ) == FALSE)
	{
		m_pLog->RecordInfo( "StepInUntilFrameRemoved - error retrieving stack frames");
		return FALSE;
	}
	Frame topframe( framelist0[0] );

	while( bResult ) {
		dbg.StepInto();
		FrameList current;
		if(current.CreateFromText( stk.GetAllFunctions() ) == FALSE)
		{
			m_pLog->RecordInfo( "StepInUntilFrameRemoved - error retrieving stack frames");
			return FALSE;
		}

		//
		// REVIEW: This can be shared with StepInUntilAdded
		//
		if( current.GetSize() == framelist0.GetSize() ) {
			// Only check function name or image name for top frame.
			CString str0;
			if( topframe.GetFunctionName( str0 ) ) {
				CString str1;
				if( topframe.GetParameters( str1 ) ) {
					str0 += "(" + str1 + ")";
				}
				bResult = Frame( current[0] ).Test( str0 );
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameRemoved - Mismatch top frame '%s' not in '%s'",
						(LPCTSTR)str0, (LPCTSTR)current[0] );
				}
			}
			else if( topframe.GetImageName( str0 ) ) {
				bResult = Frame( current[0] ).Test( str0 );
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameRemoved - Mismatch top frame '%s' not in '%s'",
						(LPCTSTR)str0, (LPCTSTR)current[0] );
				}
			}
			else {
				// Bad format
				m_pLog->RecordInfo( "StepInUntilFrameRemoved - Bad format for frame '%s'",
					(LPCTSTR)topframe );
				bResult = FALSE;
			}

			// The remaining frames should be identical
			for( int iFrame = 1; bResult && iFrame < framelist0.GetSize(); iFrame++ ) {
				bResult = framelist0[iFrame] == current[iFrame];
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameRemoved - Mismatch in frame %d, '%s' != '%s'",
						iFrame, (LPCTSTR)current[0], (LPCTSTR)framelist0[0] );
				}
			}
		}
		else if( current.GetSize() == framelist0.GetSize() - 1 ) {
			// The remaining frames should be identical
			for( int iFrame = 0; bResult && iFrame < current.GetSize(); iFrame++ ) {
				bResult = framelist0[iFrame+1] == current[iFrame];
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameRemoved - Mismatch in frame %d, '%s' != '%s'",
						iFrame, (LPCTSTR)current[iFrame], (LPCTSTR)framelist0[iFrame+1] );
				}
			}
			break;	// Get out of loop
		}
		else {
			// Unexpected number of frames
			m_pLog->RecordInfo( "StepInUntilFrameRemoved - Expected %d frames, got %d frames",
				framelist0.GetSize() + 1, current.GetSize() );
			bResult = FALSE;
		}
	}

	return bResult;
}


int ReturnCode =0;
bp  * ReturnBP =0;

void CDbgTestBase::LogResult(int line, int result,LPCSTR szoperation, int code /* 0 */, LPCSTR szComment /* "" */)

	{
	CString szOpCom = (CString)szoperation + "  " + szComment;
	if(result == PASSED)
		m_pLog->RecordSuccess("%s", szOpCom);
	else
		{
		CString szextra;
		char chbuf[24];
		szextra = szextra + "Error Code = " + itoa(code, chbuf, 10);
		m_pLog->RecordFailure("LINE %d %s", line, szextra + szOpCom);
		}
	}


//
//	Returns the current directory of the first time this function was called.
//
LPCSTR CDbgTestBase::HomeDir()
{
	static CString szCurDir;

	if( szCurDir.IsEmpty() )
	{
		char* psz = szCurDir.GetBufferSetLength(_MAX_DIR);

		GetCurrentDirectory(_MAX_DIR - 1, psz);
		szCurDir.ReleaseBuffer(-1);
		if( szCurDir.Right(1) != '\\' )
			szCurDir += "\\";
	}
 	return szCurDir;
}

//
//	Returns the fully qualified path with szAddPath appended to the breadth dir.	
//
LPCSTR CDbgTestBase::FullPath( LPCSTR szAddPath )
{
	static CString szFilespec;

	szFilespec = HomeDir();
	szFilespec += szAddPath;

	return szFilespec;
}


void CDbgTestBase::FillExprInfo(EXPR_INFO &expr_info, 
								 int state, LPCSTR type, LPCSTR name, LPCSTR value)

	{
	expr_info.state = state;
	expr_info.type = type;
	expr_info.name = name;
	expr_info.value = value;
	}


BOOL CDbgTestBase::ExprInfoIs(EXPR_INFO * expr_info_actual, EXPR_INFO * expr_info_expected, 
							   int total_rows /* 1 */)
	
	{
	for(int i = 0; i < total_rows; i++)

		{
		if(expr_info_actual[i].state != expr_info_expected[i].state)
			
			{
			m_pLog->RecordFailure("ERROR in ExprInfoIs(): state is %d instead of %d", 
								  expr_info_actual[i].state, expr_info_expected[i].state);

			return FALSE;
			}

		if(expr_info_actual[i].type != expr_info_expected[i].type)
			
			{
			m_pLog->RecordFailure("ERROR in ExprInfoIs(): type is %s instead of %s", 
								  expr_info_actual[i].type, expr_info_expected[i].type);

			return FALSE;
			}

		if(expr_info_actual[i].name != expr_info_expected[i].name)
			
			{
			m_pLog->RecordFailure("ERROR in ExprInfoIs(): name is %s instead of %s", 
								  expr_info_actual[i].name, expr_info_expected[i].name);

			return FALSE;
			}

		if(expr_info_expected[i].value.Mid(0, 7) != "UNKNOWN") 

			{
			BOOL value_tests_passed;

			if(expr_info_expected[i].value.Mid(0, 7) == "ADDRESS")
				
				{
				value_tests_passed = ValueIsAddress(expr_info_actual[i].value);

				// is extra data besides address expected? (ex. peek at string)
				if(expr_info_expected[i].value != "ADDRESS")
				
					{
					// user must supply extra data to avoid CString assert.
					EXPECT(expr_info_expected[i].value.GetLength() > 8);

					// make sure actual string is long enough so we avoid CString assert.
					if(expr_info_actual[i].value.GetLength() > 10)
					{
						// verify extra data is correct.
						if(expr_info_actual[i].value.Mid(10) ==  (" " + expr_info_expected[i].value.Mid(8)))
							value_tests_passed=TRUE;	
					}
					else
						// actual string wasn't long enough to contain extra data.
						value_tests_passed = FALSE;
					}
				}	 
	
			else	
				value_tests_passed = expr_info_actual[i].value == expr_info_expected[i].value;

			if(!value_tests_passed)
				
				{
				m_pLog->RecordFailure("ERROR in ExprInfoIs(): value is %s instead of %s", 
									  expr_info_actual[i].value, expr_info_expected[i].value);

				return FALSE;
				}
			}
		}

	return TRUE;
	}


BOOL CDbgTestBase::ValueIsAddress(CString str)
	{
	return (str.Mid(0, 2) == "0x") && 
		   (str.Mid(2).SpanIncluding("0123456789abcdef").GetLength() == 8);
	}


void CDbgTestBase::VerifyLocalsWndString(LPCSTR strType, LPCSTR strName,  LPCSTR strValue, int lineNumber)
{
	uivar.Activate();
	EXPECT_TRUE(uivar.SetPane(PANE_LOCALS) == ERROR_SUCCESS);

	EXPR_INFO expr_info;
	uivar.GetAllFields(&expr_info, lineNumber, 1);
	CString csType = expr_info.type;
	CString csName = expr_info.name;
	CString csValue = expr_info.value;


	WriteLog( (csType == strType && csName == strName && 
		csValue.Find(strValue) >= 0) ? PASSED : FAILED,
		"Current Locals line: \"%s %s %s \" Expectation: \"%s %s %s \"", 
		(LPCSTR)csType, (LPCSTR)csName, (LPCSTR)csValue, 
		(LPCSTR)strType, (LPCSTR)strName, (LPCSTR)strValue );
}

BOOL CDbgTestBase::LocalsWndStringIs(LPCSTR strType, LPCSTR strName,  LPCSTR strValue, int lineNumber)
{
	uivar.Activate();
	EXPECT_TRUE(uivar.SetPane(PANE_LOCALS) == ERROR_SUCCESS);
	BOOL ret = FALSE;

	EXPR_INFO expr_info;
	if(uivar.GetAllFields(&expr_info, lineNumber, 1)!=ERROR_SUCCESS)
		return FALSE;
	if(strcmp(strType, expr_info.type)==0 &&
	   strcmp(strName, expr_info.name)==0 &&
	   strstr(strValue,expr_info.value)!=NULL)
		ret = TRUE;

	return ret;
}


BOOL CDbgTestBase::PrepareProject(LPCSTR projName)
{
	const char* const THIS_FUNCTION = "PrepareProject()";
	CString projPathAndName = projName;
	int iName = projPathAndName.ReverseFind('\\');
	if( iName < 0 )
	{
		m_strProjectDir = FullPath("apps");
		m_strProjectName = projName;
	}
	else
	{
		m_strProjectDir = (CString)FullPath("apps") + "\\" + projPathAndName.Left(iName);
		m_strProjectName = projPathAndName.Mid(iName + 1);
	}


	// project exe has same base as makefile (i.e. xxx.mak/xxx.exe/xxx.dll)
	// we want to strip out any prepended path and just use the file name
	// because we use this name to set the remote path, and the host
	// path will usually not match the remote path.
/*	CString cstrProjectExe = m_strProjectName.Right(m_strProjectName.GetLength() -
							 m_strProjectName.ReverseFind('\\') - 1) + 
							 ((projType == PROJECT_EXE) ? ".exe" : ".dll");
*/
	CString cstrProjectExe = m_strProjectName;

	// we need to make sure the debugger isn't running on a previous project
	// or COWorkSpace::CloseAllWindows will fail.
	if(dbg.GetDebugState() != NotDebugging)
		dbg.StopDebugging();

	// we need to close all windows before opening the exe or COProject::Open will fail.
 	COWorkSpace ws;
	ws.CloseAllWindows();

	// open the executable.	
	if(prj.Open(m_strProjectDir + "\\" + cstrProjectExe) != ERROR_SUCCESS)
		{
		m_pLog->RecordInfo("ERROR in %s: could not open \"%s\".", THIS_FUNCTION, 
							m_strProjectDir + "\\" + cstrProjectExe);
		return FALSE;
		}

	CIDESubSuite* pSubSuite=GetSubSuite();
	ASSERT(pSubSuite->IsKindOf(RUNTIME_CLASS(CIDESubSuite))); //our tests are IDE tests only

	// allows us to access ide's connection settings via pconnec.
	COConnection *pconnec = pSubSuite->GetIDE()->GetConnectionInfo();
//	COConnection *pconnec = GetSubSuite()->GetIDE()->GetConnectionInfo();

	// set the connection as specified by the user.
	if(pconnec->SetAll() != ERROR_SUCCESS)
		{
		m_pLog->RecordInfo("ERROR in %s: could not set connection settings.", THIS_FUNCTION);
		return FALSE;
		}
	
	// if indicated, set the remote path and copy the executable to the remote machine.
	if(pconnec->GetUserConnections() != CONNECTION_LOCAL)
		
		{
		if(prj.SetRemotePath(cstrProjectExe) != ERROR_SUCCESS)
			{
			m_pLog->RecordInfo("ERROR in %s: could not set remote path using \"%s\".", 
							   THIS_FUNCTION, cstrProjectExe);
			return FALSE;
			}
		
		if(prj.UpdateRemoteFile(m_strProjectDir + "\\" + cstrProjectExe) != ERROR_SUCCESS)
			{
			m_pLog->RecordInfo("ERROR in %s: could not update remote file using \"%s\".", 
							   THIS_FUNCTION, m_strProjectDir + "\\" + cstrProjectExe);
			return FALSE;
			}
		}
	
	return TRUE;
}


void CDbgTestBase::LogTestHeader(LPCSTR test_desc_str, TestType testtype /* TT_TEST */)
{
	if( testtype == TT_TEST )
		m_pLog->RecordInfo("");
	m_pLog->RecordInfo("");
	CString strTestType;
    switch (testtype)
    {
		case TT_TEST:
			strTestType = "TEST";
			break;

		case TT_SUBTEST:
			strTestType = "SubTest";
			break;

		case TT_TESTCASE:
			strTestType = "TestCase";
			break;
	}

	m_pLog->RecordInfo("%s: %s", strTestType, test_desc_str);
}

void CDbgTestBase::LogTestStartEnd(LPCSTR test_desc_str, StartEndTest startend /* START_TEST */)
{
	CString strTest = "END";

	if( startend == START_TEST)
	{
		strTest = "START";
		m_pLog->RecordInfo("");
	}
 
	strTest += "***TEST";

	m_pLog->RecordInfo("%s: %s", strTest, test_desc_str);
}

void CDbgTestBase::LogTestBegin(LPCSTR test_desc_str)
{
	m_pLog->RecordInfo("");
	m_pLog->RecordInfo("BEGIN***TEST: %s", test_desc_str);
}

void CDbgTestBase::LogTestEnd(LPCSTR test_desc_str)
{
	m_pLog->RecordInfo("END***TEST: %s", test_desc_str);
}

void CDbgTestBase::LogTestEnd(LPCSTR test_desc_str, CTimeSpan elapsed_time, bool timing /* FALSE */)
{
//	GetLog()->RecordInfo("***TEST elapsed time %s", elapsed_time.Format("%H:%M:%S"));
	if( timing )
	{
		m_pLog->RecordInfo("END***TEST: %s  elapsed time %s", test_desc_str, elapsed_time.Format("%H:%M:%S"));
	}
	else
	{
		m_pLog->RecordInfo("END***TEST: %s", test_desc_str);
	}
}

void CDbgTestBase::LogSubTestHeader(LPCSTR test_desc_str)
{
	m_pLog->RecordInfo("");
	m_pLog->RecordInfo("SubTest: %s", test_desc_str);
}


BOOL CDbgTestBase::CopyProjectSources( LPCSTR szSRCFileLoc, LPCSTR szProjLoc )
{
	CString szPattern		= (CString)szSRCFileLoc + "*.*";

	// Copy sources to the project directory
	WIN32_FIND_DATA ffdImgFile;
    HANDLE hFile = FindFirstFile(szPattern, &ffdImgFile);
    if( hFile != INVALID_HANDLE_VALUE )
    {
        do
        {
			CopyFile( (CString)szSRCFileLoc + ffdImgFile.cFileName, (CString)szProjLoc + ffdImgFile.cFileName, FALSE );
			SetFileAttributes((CString)szProjLoc + ffdImgFile.cFileName, FILE_ATTRIBUTE_NORMAL );
		}
        while( FindNextFile(hFile, &ffdImgFile) );
        EXPECT( GetLastError() == ERROR_NO_MORE_FILES );
		return TRUE;
    }
	else
	{
		m_pLog->RecordFailure("Could not copy sources from %s to %s", szSRCFileLoc, szProjLoc);
		return FALSE;
	}
}

void CDbgTestBase::RemoveTestFiles( CString szProjLoc )
{
	KillAllFiles( szProjLoc, TRUE );
}
	
BOOL CDbgTestBase::ModifyCodeLine(LPCSTR szFind, LPCSTR szReplace)
{
	if( src.Find(szFind) )
	{
//		MST.DoKeys("{Delete}");
/* src.TypeTextAtCursor(szReplace, FALSE); doesn't work as well as InsertText():
 for some reason it cannot get the editor 
*/
		MST.DoKeys(szReplace, TRUE);
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL CDbgTestBase::ModifyCode(LPCSTR szFind, LPCSTR szReplace, int nLines /* 1 */)
{
	CString cStr = szReplace;
	CString str1;

	if( src.Find(szFind) )
	{
		MST.DoKeys("{Home}");
		for( int i = 1; i < nLines; i++ )
		{	
			MST.DoKeys("+{down}");
		}
		MST.DoKeys("+{End}");
		int length = cStr.GetLength();
		if( length <= 0)
		{
			MST.DoKeys("{Delete}");
			return TRUE;
		}

		int right;
		while( length )
		{
			right = cStr.Find("{Enter}");
			if( right < 0)
			{
				MST.DoKeys(cStr, TRUE);
				return TRUE;
			}
			else 
			{
				str1 = cStr.Mid(0, right);
				MST.DoKeys(str1, TRUE);
				MST.DoKeys("{Enter}");
				if( length = (length - right - 7) )
				{
					cStr = cStr.Mid(right + 7, length);
				}
			}
		}
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL CDbgTestBase::IsMsgBox(CString strMsg, CString strBtn)
{	
	if( WaitMsgBoxText( strMsg, 10 ) )
	{
		MST.WButtonClick( strBtn );
		return TRUE;
	}
	else
		return FALSE;
}

CString CDbgTestBase::GetBldLog()
{
	CString BuildRecord;
	CString str;
	
	// Get build data
	UIWB.DoCommand(IDM_WINDOW_ERRORS,DC_ACCEL);  // goto output window
	MST.DoKeys("^{END}");			// goto end
	MST.DoKeys("+^{HOME}");			// select whole build record
	MST.DoKeys("^c");				// copy it
	GetClipText(BuildRecord);       // get text from clipboard
	MST.DoKeys("{ESC}");            // return focus from output window
	BuildRecord.MakeLower();
	return (BuildRecord);
	
};


BOOL CDbgTestBase::VerifyBuildOccured( BOOL iBuild )
{
	// iBuild == TRUE  -  project should be rebuilt
	// iBuild == FALSE  -  project should not be rebuilt

	// Get the output window contents
	CString szBldLog = GetBldLog();
	if (szBldLog == "")
	{
		m_pLog->RecordFailure("Incorrect build: Output window is empty");
		return FALSE;
	}

	int iFoundCompiling = szBldLog.Find ("compiling");	// International ?
	int iFoundLinking = szBldLog.Find ("linking");		// International ?

	if( iBuild )
	{
		if( (iFoundCompiling < 0) && (iFoundLinking < 0) )
		{
			m_pLog->RecordFailure("Incorrect build: can't find 'Compiling' or 'Linking");
			return FALSE;
		}
	}
	else
	{
		if ( (iFoundCompiling > 0) || (iFoundLinking > 0) )
		{
			m_pLog->RecordFailure("Nothing change, the project shouldn't be rebuilt.");
			return FALSE;
		}
	}

	return TRUE;
}

int CDbgTestBase::VerifyBuildString( LPCSTR verifyString, BOOL fExist /* TRUE */ )
{
	int iFoundString;

	// Get the output window contents
	CString szBldLog = GetBldLog();
	CString testString = verifyString;

	// For some reason the output window text is always lower case when extracted.

	testString.MakeLower();
	iFoundString = szBldLog.Find(testString);

	if ( (iFoundString < 0) && fExist )
	{
		m_pLog->RecordFailure("Can't find %s", verifyString);
	}
	
	if ( (iFoundString >= 0) && !fExist )
	{
		m_pLog->RecordFailure("Found %s : it should not be there", verifyString);
	}

	return iFoundString;
}

int CDbgTestBase::VerifyDebugOutputString( LPCSTR verifyString, BOOL fExist /* TRUE */ )
{
	int iFoundString;
	CString csLog;
	CString testString = verifyString;

	// Get the output window contents
	// TODO(michma): mismatch with CODebug here. need to merge?
	dbg.SetDebugOutputPane(IDSS_PANE_DEBUG_OUTPUT);
	MST.DoKeys("^{END}");			// goto end
	MST.DoKeys("+^{HOME}");			// select whole build record
	MST.DoKeys("^c");				// copy it
	GetClipText(csLog);       // get text from clipboard
	MST.DoKeys("{ESC}");            // return focus from output window
	csLog.MakeLower();

	// For some reason the output window text is always lower case when extracted.
	testString.MakeLower();
	iFoundString = csLog.Find(testString);

	if ( (iFoundString < 0) && fExist )
	{
		m_pLog->RecordFailure("Can't find %s", verifyString);
	}
	
	if ( (iFoundString >= 0) && !fExist )
	{
		m_pLog->RecordFailure("Found %s : it should not be there", verifyString);
	}

	return iFoundString;
}

void CDbgTestBase::VerifyECSuccess()
{
	if( WaitMsgBoxText("Do you want to save", 10) )
		MST.WButtonClick( "No" );
	EXPECT_TRUE( !IsMsgBox("Code changes caused one or more compile errors", "No") );
	EXPECT_TRUE( !IsMsgBox("Cannot complete Edit and Continue", "No") );
	if( IsMsgBox("Point of execution moved", "OK") )
	{
		MST.WButtonClick( "OK" );
		m_pLog->RecordInfo("OK on message box 'Point of execution moved...'");
	}
	EXPECT_TRUE( VerifyBuildString( "Edit and Continue - 0 error(s)" ) >= 0);
	EXPECT_TRUE( dbg.Wait(WAIT_FOR_BREAK) );
}

void CDbgTestBase::VerifyECUnsupportedEdit()
{
	if( WaitMsgBoxText("Do you want to save", 10) )
		MST.WButtonClick( "No" );
	EXPECT_TRUE( IsMsgBox("Cannot complete Edit and Continue", "No") );
	EXPECT_TRUE( dbg.Wait(WAIT_FOR_BREAK) );
}

void CDbgTestBase::VerifyECCompileError()
{
	if( WaitMsgBoxText("Do you want to save", 10) )
		MST.WButtonClick( "No" );
	EXPECT_TRUE( IsMsgBox("Code changes caused one or more compile errors", "No") );
	EXPECT_TRUE( dbg.Wait(WAIT_FOR_BREAK) );
}

CStartEndTest::CStartEndTest(LPCSTR testName, CDbgTestBase *test, bool timing /*=FALSE*/)
{
	m_testName = testName;
	m_Test = test;
	if( timing )
	{
		m_startTime = CTime::GetCurrentTime();
		m_timing = TRUE;
		m_Test->LogTestBegin( m_testName );
	}
}

CStartEndTest::~CStartEndTest()
{
	if( m_timing )
	{
		m_endTime = CTime::GetCurrentTime();
		CTimeSpan elapsed_time(m_endTime - m_startTime);
		m_Test->LogTestEnd( m_testName, elapsed_time, m_timing );
	}
	else
		m_Test->LogTestEnd( m_testName );
}


char szecEditTypes[6][256] =
{
	"EC_NO_STACK_FRAME",
	"EC_CURRENT_FRAME_AFTER_IP",
	"EC_CURRENT_FRAME_BEFORE_IP",
	"EC_CURRENT_FRAME_AT_IP", 
	"EC_PARENT_FRAME_AFTER_IP", 
	"EC_PARENT_FRAME_BEFORE_IP"
};

BOOL CDbgTestBase::IsProjectReady(ProjType projType)
{
	switch (projType)
	{
	case PT_EXE:
		m_strProjectName = "ecconsol";
		break;
	case PT_EXT:
		m_strProjectName = "ecwinapp";
		break;
	case PT_INT:
		m_strProjectName = "ecmfcapp";
		break;
	}
	
	m_strSrcDir = "ecapp";	//ToDo: We should get the name from file with all languages strings
	m_strProjectLoc  = m_strCWD + "apps\\" + m_strProjectName + "\\";
	CString szSRCFileLoc	= m_strCWD + "src\\" + m_strSrcDir + "\\";
	CString szProjPathName	= (CString)("..\\apps\\") + m_strProjectName + "\\" + m_strProjectName;

	if (projType == PT_INT)	  // MFC app
		RemoveTestFiles( m_strProjectLoc + "res\\");
	RemoveTestFiles( m_strProjectLoc );
	CreateDirectory(m_strProjectLoc, 0);          
	EXPECT_TRUE( CopyProjectSources( szSRCFileLoc, m_strProjectLoc ) );
	if (projType == PT_INT)	   // MFC app
	{
		CreateDirectory(m_strProjectLoc + "res\\", 0);          
		EXPECT_TRUE( CopyProjectSources( szSRCFileLoc + "res\\", m_strProjectLoc + "res\\" ) );
	}
	if (projType == PT_EXE)	   // EXE consol app
	{
		if( SetProject(szProjPathName) )
			return TRUE;
	}
	else
	{
		int iWaitForBuild = 3;	// Minutes to wait for the build to complete
		if( PrepareProject(szProjPathName) && VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)))
		{
			prj.SetExeForDebugSession(m_strProjectName + ".exe");
			return TRUE;
		}
	}
	return FALSE;
}


LPCSTR CDbgTestBase::GetThreadIDStr(LPCSTR szThreadIDVar)

{
	static char szText[12] = "";
	DWORD dwThreadID;
	
	if(!cxx.GetExpressionValue(szThreadIDVar, &dwThreadID))
	{
		LOG->RecordInfo("CDbgTestBase::GetThreadIDStr - GetExpressionValue failed.");
		return (LPCSTR)szText;
	}

	sprintf(szText, "%.8x", dwThreadID);
	return (LPCSTR)szText;
}


void CleanUp(LPCSTR szDirName)

{
	CString strPath;
	strPath = (CString)"src\\" + szDirName + "\\";

	KillFiles(strPath + "*.dsp");
	KillFiles(strPath + "*.dsw");
	KillFiles(strPath + "*.opt");
	KillFiles(strPath + "*.plg");
	KillFiles(strPath + "*.ncb");
	KillFiles(strPath + "*.mak");
	KillFiles(strPath + "*.lnk");
	KillFiles(strPath + "*.mdp");
	KillFiles(strPath + "*.pdb");
	KillFiles(strPath + "*.obj");
	KillFiles(strPath + "*.ilk");
	KillFiles(strPath + "*.dll");
	KillFiles(strPath + "*.exe");
}


void KillFiles(LPCSTR szPathName, LPCSTR szFileName /* NULL */)

{
	WIN32_FIND_DATA ffdImgFile;
	HANDLE hFile;
	CString str, strPattern, strPath = szPathName;

	if(szFileName != NULL)
		
	{
		if((strPath.Right(1) != "\\") && (szFileName[0] != '\\'))
			strPath += "\\";

		strPattern = strPath + szFileName; 
	}

	else
		strPattern = strPath;

	hFile = FindFirstFile(strPattern, &ffdImgFile);
	
	if(hFile != INVALID_HANDLE_VALUE)
	{
		do
		{
			str = strPath + ffdImgFile.cFileName;
			DeleteFile(str);
		} while(FindNextFile(hFile, &ffdImgFile));
	}

	FindClose(hFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\all\nopdb.cpp ===
__declspec(dllexport) void no_pdb_dll_func(void)
	{
	__asm
		{
		int 3
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\all\lineonly.h ===
void line_only_dll_func(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\all\nodebug.cpp ===
int empty_func(void);


void no_debug_func(void)
	{
	empty_func();
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\all\nopdb.h ===
void no_pdb_dll_func(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\DbgTestBase.h ===
///////////////////////////////////////////////////////////////////////////////
// DbgTestBase.h
//
//	Created by:		MichMa
//	Date:			3/30/98
//
//	Description:	Declaration of base class for all debugger tests.


#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#ifndef __DBGTESTBASE_H__
#define __DBGTESTBASE_H__

extern int ReturnCode;
extern bp  * ReturnBP;

#define VERIFY_TEST_SUCCESS(TestCase)\
	TestCase == ERROR_SUCCESS

#define EXPECT_TRUE(f)    ((f)?LogResult(__LINE__, PASSED,#f):LogResult(__LINE__, FAILED,#f));
#define EXPECT_FALSE(f)    ((f)?LogResult(__LINE__, FAILED,#f):LogResult(__LINE__, PASSED,#f));
#define EXPECT_SUCCESS(f) (((ReturnCode=(f))==0)?LogResult(__LINE__, PASSED,#f):LogResult(__LINE__, FAILED,#f,ReturnCode));
#define EXPECT_VALIDBP(f) (((ReturnBP=(f))!=NULL)?LogResult(__LINE__, PASSED,#f):LogResult(__LINE__, FAILED,#f));
#define EXPECT_TRUE_COMMENT(f,comment) ((f)?LogResult(__LINE__, PASSED,#f,0,#comment):LogResult(__LINE__, FAILED,#f,0,#comment));

#define ABORT_SUBTEST() THROW( new CSubTestException )

#define EXPECT_SUBTEST_OLD(f)  if(f) { LogResult(__LINE__, PASSED,#f);} \
				else { LogResult(__LINE__, FAILED,#f); ABORT_SUBTEST(); }

#define EXPECT_SUBTEST(f)   if(f) { LogResult(__LINE__, PASSED,#f);} \
							else {LogResult(__LINE__, FAILED,#f); }

class CSubTestException : public CException {
	DECLARE_DYNAMIC( CSubTestException );
};

#define InitProject SetProject
#define RestoreFocusToSrcWnd() MST.DoKeys("{ESC}")

enum ProjType
{
	PT_EXE,
	PT_EXT,
	PT_INT
};

enum TestType
{
	TT_TEST,
	TT_SUBTEST,
	TT_TESTCASE
};

enum StartEndTest
{
	START_TEST,
	END_TEST
};

typedef enum 
{
	EC_NO_STACK_FRAME, 
	EC_CURRENT_FRAME_AFTER_IP, 
	EC_CURRENT_FRAME_BEFORE_IP, 
	EC_CURRENT_FRAME_AT_IP, 
	EC_PARENT_FRAME_AFTER_IP, 
	EC_PARENT_FRAME_BEFORE_IP
} EC_EDIT_TYPE;

///////////////////////////////////////////////////////////////////////////////
//	class CDbgTestBase used as base for debugging tests

class CDbgTestBase : public CTest

{
	DECLARE_DYNAMIC(CDbgTestBase)
	friend class CStartEndTest;

public:	
	// since this class is a base class for tests, it must have a ctor
	// that takes all test parameters for proper base class initialization
	CDbgTestBase(/*int metricID,*/ CIDESubSuite* pSubSuite, LPCSTR szName, int nExpectedCompares, LPCSTR szListFilename = NULL);

protected: // data
	CString	m_strProjectDir;
	CString	m_strSrcDir;
	CString	m_strProjectName;
	CString	m_strProjectLoc;
	CString	m_szErrorText;
	int m_platform;
	ProjType m_projType;

	COSource src;
	COProject prj;
	CODebug dbg;
	COExpEval cxx;
	COBreakpoints bps;
	COStack stk;
	UIStack uistack;
	UIMemory uimem;
	COMemory mem;
	UIVariables uivar;
	COBrowse browse;
	COFile file;
	UIWatch uiwatch;
	UIQuickWatch uiqw;
	UIDAM uidam;
	UIRegisters uiregs;
	CODAM dam;
	COThreads threads;
	COLocals locals;
	CORegisters regs;
	COExpEval ee;
	COWatch watch;
	COClipboard clipboard;
	COApplication app;
	COAuto coauto;
	COConnection *pConnection;

	typedef enum {PROJECT_EXE, PROJECT_DLL} PROJECT_TYPE;
	typedef enum {fDefault, fBuildOnly} PROJECT_FLAGS;

	BOOL SetProject(LPCSTR projName, PROJECT_TYPE projType = PROJECT_EXE,
					PROJECT_FLAGS = fDefault,LPCSTR cfgName=NULL);

	BOOL PrepareProject(LPCSTR projName);
	BOOL IsProjectReady(ProjType projType);
	BOOL StartDebugging(void);
	BOOL StopDbgCloseProject(void);
	BOOL VerifyProjectRan(int exitcode = 0);
	BOOL StepInUntilFrameAdded(CString addframe);
	BOOL StepInUntilFrameRemoved(void);

	// shorthand method of filling EXPR_INFO object.
	void FillExprInfo(EXPR_INFO &expr_info, int state, LPCSTR type, LPCSTR name, LPCSTR value);

	// compares two EXPR_INFO objects
	BOOL ExprInfoIs(EXPR_INFO * expr_info_actual, EXPR_INFO * expr_info_expected, 
					int total_rows = 1);

	// tells whether string represents an address as displayed in an ee window.
	// for example: 0x1234abcd "xyz"
	// support function for ExprInfoIs()
	BOOL ValueIsAddress(CString str);
	LPCSTR GetThreadIDStr(LPCSTR szThreadIDVar);

	void LogResult(int line, int result,LPCSTR szoperation, int code=0, LPCSTR szComment="");
	LPCSTR HomeDir(void);
	LPCSTR FullPath(LPCSTR szAddPath);

	void LogTestHeader(LPCSTR test_desc_str, TestType testtype = TT_TEST);
	void LogTestStartEnd(LPCSTR test_desc_str, StartEndTest startend = START_TEST);
	void LogSubTestHeader(LPCSTR test_desc_str);
	void LogTestBegin(LPCSTR test_desc_str);
	void LogTestEnd(LPCSTR test_desc_str);
	void LogTestEnd(LPCSTR test_desc_str, CTimeSpan elapsed_time, bool timing);

	void VerifyLocalsWndString(LPCSTR strType, LPCSTR strName,  LPCSTR strValue, int lineNumber = 1);
	BOOL LocalsWndStringIs(LPCSTR strType, LPCSTR strName,  LPCSTR strValue, int lineNumber = 1);

	CString GetBldLog();
	BOOL VerifyBuildOccured( BOOL iBuild );
	int VerifyBuildString( LPCSTR verifyString, BOOL fExist = TRUE );
	int VerifyDebugOutputString( LPCSTR verifyString, BOOL fExist = TRUE  );
	void VerifyECSuccess();
	void VerifyECCompileError();
	void VerifyECUnsupportedEdit();

	BOOL CopyProjectSources( LPCSTR szSRCFileLoc, LPCSTR szProjLoc );
	void RemoveTestFiles( CString szProjLoc );

	BOOL ModifyCodeLine(LPCSTR szFind, LPCSTR szReplace);
	BOOL ModifyCode(LPCSTR szFind, LPCSTR szReplace, int nLines = 1);
	BOOL IsMsgBox(CString strMsg, CString strBtn);
};


class CStartEndTest
{

public:	
	// since this class is a base class for tests, it must have a ctor
	// that takes all test parameters for proper base class initialization
	CStartEndTest(LPCSTR testName, CDbgTestBase *test, bool timing = FALSE);
	~CStartEndTest();

protected: // data
	CString	m_testName;
	bool m_timing;
	CTime m_startTime;
	CTime m_endTime;
	CDbgTestBase *m_Test;
};


void CleanUp(LPCSTR szDirName);
void KillFiles(LPCSTR szPathName, LPCSTR szFileName = NULL);


extern char szecEditTypes[6][256];

#endif	// __DBGTESTBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\all\test.h ===
void header_func(void){}
void inline inline_func(void){}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\automate\automate.cpp ===
#include <windows.h>


void func(void)
	{
START_OF_FUNC:
	return;
	}


void DebuggerObjectTest(void)
	{
	int i = 0;
AFTER_RUN_TO_CURSOR:
	func();
AFTER_STEP_OVER:
	func();
AFTER_STEP_OUT:
	return;
	}


void BreakpointsCollectionTest(void)
	{
	return;
	}


void BreakpointItemTest(void)
	{
	return;
	}


void MacroRecordingTest(void)
	{
	return;
	}


int PASCAL WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR lszCmdLine, int nCmdShow)
	{
	DebuggerObjectTest();
	BreakpointsCollectionTest();
	BreakpointItemTest();
	MacroRecordingTest();
	return 0;		
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\all\test.cpp ===
//#define _UNICODE


#include <afxwin.h>
#include "nopdb.h"
#include "lineonly.h"
#include "test.h"


int global = 0;


class BASE_CLASS
	{
	private:
		int i_priv;
	protected:
		int i_prot;
	public:
		BASE_CLASS(void){i_priv = 1; i_prot = 2;}
		virtual ~BASE_CLASS(void){};
	};


class DERIVED_CLASS1 : public BASE_CLASS
	{
	private:
		char ch;
	public:
		DERIVED_CLASS1(void){ch = 'a';}
	};


class DERIVED_CLASS2 : public DERIVED_CLASS1
	{
	private:
		float f;
	public:
		DERIVED_CLASS2(void){f = 1.0f;}
	};


struct A_STRUCT
	{
	int i;
	};


class A_CLASS
	{
	public:
		virtual void func(unsigned char ch){}
		int i;
	};


void no_debug_func(void);
void diff_seg_func(void);


unsigned long __stdcall thread_func(void * pdata)
		{
		MessageBeep(0xffffffff);       
		while(1);
		return 0;
		}


BOOL CALLBACK EnumWindowsProc(HWND hwnd, LPARAM lparam)
	{
	static i = 0;
	i++;
	if(i == 2)
		return FALSE;
	else
		return TRUE;
	}	


int empty_func(void)
	{
	return 0;
	}


void many_params_func(int* i, CString &cstring, _TCHAR* tchar_array, 
					  float* f, A_STRUCT* a_struct)
	{
	*i = 1;
	cstring = "abc";
	lstrcpy(tchar_array, _TEXT("xyz"));
	*f = 1.0f;
	a_struct->i = 1;
	}


int set_ints_func(int i)
	{
	i++;
	global = 1;
	diff_seg_func();
	return i;
	}


void exception_func(void)	
	{
	int zero = 0;
	int i = 1 / zero;
	}

void overloaded_func(void){}
void overloaded_func(int i){}

int recursive_func(int i)
	
	{
	if(i == 5)
		return i; // most nested return
	else
		{
		recursive_func(i + 1);
		return i;
		} 
	}


int PASCAL WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, 
				   LPSTR lszCmdLine, int nCmdShow)
	
	{
	recursive_func(0);
	header_func();
	inline_func();
	overloaded_func();
	














	
	overloaded_func(0);
		  
	CString cstring = _TEXT("abc");
	_TCHAR tchar_array[sizeof(_TCHAR) * 4] = _TEXT("xyz");
	int i = 1;

	for(int x = 0; x < 100; x++)
		{
		while(0);
		}

	float f = 1.0f;
	
	struct A_STRUCT a_struct;
	a_struct.i = 1;
	
	BASE_CLASS* object_base = new BASE_CLASS();
	BASE_CLASS* object1 = new DERIVED_CLASS1();
	BASE_CLASS* object2 = new DERIVED_CLASS2();
	BASE_CLASS*	object = object1;

	i++;
	
	cstring = "1234";
	cstring = "5678";
	
	lstrcpy(tchar_array, _TEXT("pdz"));
	lstrcpy(tchar_array, _TEXT("pdq"));
	
	empty_func();
	many_params_func(&i, cstring, tchar_array, &f, &a_struct);
	
	object = object2;
	
	char array[4] = "abc";
	strcpy(array, "xyz");
	strcpy(array, "xy3");
	
	A_CLASS obj;
	obj.i = 1;
	obj.func('a');
	
	int (*pfunc)(int) = set_ints_func;
	i = set_ints_func(0);
	i = (*pfunc)(1);
	
	no_debug_func();
	diff_seg_func(); 
	
	HANDLE thread_hdl;
	DWORD thread_id;
	thread_hdl = CreateThread(NULL, 0, thread_func, 0, 0, &thread_id); 

	call_dlls:

	//HINSTANCE hinst_dll = GetModuleHandle("nopdb.dll");
	//BOOL ret = FreeLibrary(hinst_dll);
	//no_pdb_dll_func();

	HINSTANCE hinst_dll = GetModuleHandle("nopdb.dll");
	BOOL ret = FreeLibrary(hinst_dll);
	LoadLibrary("nopdb.dll");
	no_pdb_dll_func();

	line_only_dll_func();
	
	//exception_func();

	EnumWindows(EnumWindowsProc, 0);

	//while(1);

	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\all\wnd.cpp ===
#include <windows.h>

LPARAM CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);


int PASCAL WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR lszCmdLine, int nCmdShow)
	
	{ 				// first line of WinMain()
	MSG msg;
	HWND hwnd;

	if(!hinstPrev)

		{
		WNDCLASS wndclass;
	    wndclass.style = 0;
	    wndclass.lpfnWndProc = WndProc;
	    wndclass.cbClsExtra = 0;
	    wndclass.cbWndExtra = 0;
	    wndclass.hInstance = hinst;
	    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
	    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
	    wndclass.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
	    wndclass.lpszMenuName = NULL;
	    wndclass.lpszClassName = "Wnd";

	    if(!RegisterClass(&wndclass))
	    	return 0;
		}

	hwnd = CreateWindow("Wnd", "Wnd", WS_OVERLAPPEDWINDOW | 
						WS_VISIBLE, CW_USEDEFAULT, CW_USEDEFAULT, 
						CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, hinst, NULL);

	while(GetMessage(&msg, NULL, 0, 0))
		{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
		}

	return msg.wParam;
	}


LPARAM CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
	
	{
	switch(msg)
		{	
		case WM_PAINT:
			{
			PAINTSTRUCT ps;
			BeginPaint(hwnd, &ps);
			EndPaint(hwnd, &ps);
			return 0L;
			}
		case WM_DESTROY:
			{
			PostQuitMessage(0);
			while(1);
			break;
			}
		}

	return DefWindowProc(hwnd, msg, wParam, lParam);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\breakpoints pri2\breakpoints pri2 dll.cpp ===
#include <windows.h>

extern "C"
{

__declspec(dllexport) void DllFunc(void)
{											// first line of DllFunc()
}

}


int WINAPI DllMain(HANDLE hInst, ULONG ulRbc, LPVOID lpReserved)
{
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\breakpoints pri2\breakpoints pri2 exe.cpp ===
#include <windows.h>


typedef void (APIENTRY *PDLLFUNC)(void);


struct FREQ_INFO	// struct returned by DLL function call- yes it's lame to define it here.
{
	unsigned long in_cycles;	// internal clock cycles during test	
	unsigned long ex_ticks;		// microseconds elapsed during test						
	unsigned long raw_freq;		// raw frequency of CPU in MHz
	unsigned long norm_freq;	// normalized frequency of CPU in MHz.
};


typedef FREQ_INFO (FAR *PCPUFUNC)(int BSFclocks);


int iGlobal = 0;
int giDelay = 0;


class CBase

{
public:

	int m_i;
	char m_ch;

	CBase(void)	// first line of CBase::CBase()
	{
		m_i = 0;
		m_ch = 0;
	}

} gCBaseObj;


int GetCPUSpeed(void)

{
	int iCPUSpeed = 0;

	// This function first uses a free distribution Intel DLL to determine CPU speed.  Note
	// that this only works for Intel CPUs!
	HINSTANCE hCpuDll = LoadLibrary("cpuinf32.dll");
	PCPUFUNC pCpuFunc = (PCPUFUNC)GetProcAddress(hCpuDll, "cpuspeed");
	FREQ_INFO CpuInfo = (*pCpuFunc)(0);
	iCPUSpeed = CpuInfo.norm_freq;
	FreeLibrary(hCpuDll);

	// If the DLL fails us, we might find the CPU speed in the registry.
	// WinNT puts it there, but Win95 doesn't.  Win98?  Dunno.
	if(iCPUSpeed <= 0)	// DLL function *should* return 0 if it fails
	
{
		HKEY keyOpen = NULL;
		LONG lRegStatus = ::RegOpenKeyEx(	HKEY_LOCAL_MACHINE,
											"HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0",
											0,
											KEY_ALL_ACCESS, 
											&keyOpen);
		if (lRegStatus == ERROR_SUCCESS)
		{
			DWORD dwBufferSize = sizeof(int);
			lRegStatus = ::RegQueryValueEx(	keyOpen,
											"~MHz",
											NULL,
											NULL,
											(LPBYTE)&iCPUSpeed,
											&dwBufferSize);
		}
	
		if (lRegStatus != ERROR_SUCCESS)
			iCPUSpeed = 0;	// paranoia
	
		::RegCloseKey(keyOpen);
	}

	// If registry lookup fails, the calling routine will have to punt.  Return will be 0.
	return iCPUSpeed;
}

void Func(void)

{						// first line of Func()
	int iLocal = 0;		// init iLocal in Func()

	while(0);			// line within Func()

	iLocal++;
	iGlobal = 1;

MultipleBreakpointsHitLabel:
	while(0);	// multiple breakpoints hit
}


void OverloadedFunc(void)
{							// first line of OverloadedFunc(void)
}

void OverloadedFunc(int i)
{							// first line of OverloadedFunc(int)
}


int FAR PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)

{	// first line of WinMain()
	int iLocal = 0;
	int i;

	Func();
	
	OverloadedFunc();	// line after call to Func()
	OverloadedFunc(1);
	
	gCBaseObj.m_ch = 'a';	
	while(0);	// gCBaseObj change

	HINSTANCE hDll = LoadLibrary("breakpoints pri2 dll.dll");
	PDLLFUNC pDllFunc = (PDLLFUNC)GetProcAddress(hDll, "DllFunc");	// dll loaded

	// We need to 'throttle' the number of iterations that the following for loops perform,
	// since too many iterations can cause Cafe to fail out at 5 min. on a slow machine, and
	// too few can cause both for loops to be executed in about the same span of time on a
	// fast machine.	mke 3/5/98
	int iCPUSpeed = GetCPUSpeed();
	int iLoopNum = 0;
	iCPUSpeed = (iCPUSpeed == 0) ? 133 : iCPUSpeed;	// assume 133 MHz (midrange) if speed test fails
	
	if(iCPUSpeed < 133)
		iLoopNum = 500;
	else if(iCPUSpeed < 200)
		iLoopNum = 3000;
	else
		iLoopNum = 10000;

	for(i = 0; i < iLoopNum; i++)
		pDllFunc();	// line within loop

	iLocal++;
	iGlobal++;

	for(i = 0; i < giDelay; i++)		   
		Sleep(1000);
	
	while(0);	// line within WinMain()

	iGlobal = 100;
	while(0);	// iGlobal = 100

	FreeLibrary(hDll);
	hDll = LoadLibrary("breakpoints pri2 dll.dll");
	pDllFunc = (PDLLFUNC)GetProcAddress(hDll, "DllFunc");
	pDllFunc();

	return 0;	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\dbg\chain1.h ===
int   chain_1(int x);
int   chain_5(int x);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\autopane\autopane.cpp ===
#include <windows.h>

char array[4] = "abc";
int global;
int i;
int *pi = &i;


class base
	{
	private:
		int m_private;
	public:
		virtual void func(int i);
		int m_public;
		char *m_pchar;
	} b;


void base::func(int i)

	// verify that function arguments appear when prolog reached
	{
	// verify that no locals appear after executing prolog
	while(0);

	// verify that only expressions from current statement and previous statement are added
	m_private = i;
	m_public = i;
	}


int PASCAL WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR lszCmdLine, int nCmdShow)
	
	{
	i = 0;
	*pi = 1;
	while(0);

	int *pint = &i;
	while(0);

	// navigate the stack to another function and back
	// verify that function calls arent added
	// step through prolog with this pane active, then select auto pane
	b.func(0);
	while(0);

	// verify that multi-line statements get scanned back 10 lines
	int j[60];

	for(int k = 0; k < 60; k++)
		j[k] = 1;
	
	k = j[1] +
		j[2] +
		j[3] +
		j[4] +
		j[5] + 
		j[6] +
		j[7] +
		j[8] +
		j[9] +
		j[10] +
		j[11] +
		j[12] +
		j[13] +
		j[14] +
		j[15];

	while(0);
	while(0);

	// verify that the unsupported operators are not included
	b.func(j[0]);
	i = (int)(char)j[1];
	j[2]++;
	j[3]--;
	i = !j[4];
	i = ~j[5];
	++j[6];
	--j[7];
	i = sizeof(j[8]);
	j[9] = 1, j[10] = 1;
	i = j[11] * j[12];
	i = j[13] / j[14];
	i = j[15] % j[16];
	i = j[17] + j[18];
	i = j[19] - j[20];
	i = j[21] << j[22];
	i = j[23] >> j[24];
	i = j[25] < j[26];
	i = j[27] <= j[28];
	i = j[29] > j[30];
	i = j[31] >= j[32];
	i = j[33] == j[34];
	i = j[35] != j[36];
	i = j[37] & j[38];
	i = j[39] ^ j[40];
	i = j[41] | j[42];
	i = j[43] && j[44];
	i = j[45] || j[46];
	i = j[47];
	i += j[49];
	i -= j[50];
	i *= j[51];
	i /= j[52];
	i %= j[53];
	i <<= j[54];
	i >>= j[55];
	i &= j[56];
	i ^= j[57];
	i |= j[58];
	i = j[59] ? j[60] : 0;

	array[0] = 'x';
	while(0);
	
	array[(5 + 15) / 10 * 2 - (4 + (int)'\x00')] = '1';
	while(0);

	array[array[4]] = 'a';
	while(0);

	base *pb2;
	base *pb = new base;
	pb2 = pb;

	*pb = *pb;

	//b.*m_pchar = 'a';
	//pb->*m_pchar = 'b';
	//char **ppchar = (char**)&array;
	//*ppchar[0] = 'c';
	//**ppchar = '1';

	pb->m_public = 0;
	pb->func(0);
	while(0);

	b.m_public = 1;
	b.func(1);
	while(0);

	while(0);
	while(0); // no expressions

	int before_comments = 0;
	// pi = 1;
	/* 
	global = 2;
	*/
	while(0);

	int i2 = 0;
	i2 = 1;
	while(0);

	::global = 1;
	while(0);

	// verify that no expressions with error values are added
	i = 1;
	while(1);
	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\crashdump\crashdumpdll.cpp ===
__declspec(dllexport) void dllfunc(void)
{
	int zero = 0;
	int i = zero / zero;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\dbg\chain1.c ===
/*DOC*
**
** Suite : 
** File  : chain1.c
**
** Revision History :
** M001 2-Feb-1994
** - created from chain1.c from old callstack sources.
**
**DOC*/

#include "foo.h"
#include "chain1.h"
#include "chain2.h"


int Global;

///////////////////////////////////////////////////////////////////////////
int   chain_1(int x)
{
    int Sum;
START:
    Sum=x+chain_2(x);
END:;
    return Sum;
};


///////////////////////////////////////////////////////////////////////////
int   chain_5(int x)
{
START:
    x=x*2;
END:;
    return x;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\cons01\cons01.cpp ===
#include <iostream.h>

int main()
{
 	char Char = 's';
 	int  Array1d[3] = {111, 222, 333};
 	long Array2d[3][3] = {11, 22, 33, 44, 55, 66, 77, 88, 99};
 	int Local=17;
 	float Real=(float)2.17;
 	double Double=1.303;
 	long double Ldouble=1.303;
 	char String[28] = "this is a string";
 	long Long=99;
	
	cout << Char;
	cout << Array1d[0] << Array1d[1] << Array1d[2] ;
	int i,j;
	for (i = 0; i < 3; i++)
		for (j = 0; j < 3; j++)
			cout << Array2d[i][j] ;
	cout << String;

	cin >> Char;
	cin >> Array1d[0] >> Array1d[1] >> Array1d[2] ;
	for (i = 0; i < 3; i++)
		for (j = 0; j < 3; j++)
			cin >> Array2d[i][j] ;
	cin >> String;

 	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\crashdump\crashdumpexe.cpp ===
#include <windows.h>

__declspec(dllimport) void dllfunc(void);

int FAR PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)
{
	dllfunc();	
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\dbg\chain0.c ===
/*DOC*
**
** CHAIN0.C
**
** Revision History :
** M001 2-Feb-1994
** - created from chain0.c, old callstack sources
**
**DOC*/


#include <string.h>
#include "foo.h"
#include "chain1.h"


#ifdef DLL                 // define DLL to enable dll tests
#include "chain4.h"
#endif

int Global=0;
int Result=0;
char * String=" Some sample string";


int ChainMain() {
  TagCallChain1:
  Result=chain_1(3);
DONE:
  return 1;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\dbg\chain2.c ===
/*DOC*
**
** Suite : 
** File  : chain2.c.   Intended to be compiled with partial debug info.
**
** Thus have line number information, but do not have information about locals ...
**
** Revision History :
** M001 2-Feb-1994
** - created from chain2.c from old callstack sources.
**
**DOC*/

#include "foo.h"
#include "chain2.h"
#include "chain3.h"


int Global;

///////////////////////////////////////////////////////////////////////////
int   chain_2(int x)
{
    int Sum;
START:
    Sum=x+chain_3(x);
END:;
    return Sum;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\dbg\chain2.h ===
int   chain_2(int x);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\dbg\chain3.h ===
int   chain_3(int x);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\dbg\chain3.c ===
/*DOC*
**
** Suite : 
** File  : chain3.c  intended to be compiled without debug information
**
** Revision History :
** M001 2-Feb-1994
** - created from chain3.c from old callstack sources.
**
**DOC*/


#include "foo.h"
#include "chain3.h"


int Global;


extern int chain_4(int x);

///////////////////////////////////////////////////////////////////////////
int   chain_3(int x)
{
    int Sum;
START:
    Sum=x+chain_4(x);
END:;
    return Sum;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\dbg\chain4.h ===
#include "foox.h"

#if TEST == cBASIC

#ifdef hasPARAMS
#define  fooParams int paramA, int paramB
#else
#define  fooParams
#endif

#ifdef returnsVALUE
#define  fooReturn  int
#else
#define  fooReturn  void
#endif

fooReturn FUNCTYPE chainmain( fooParams );

#endif  // TEST == cBASIC

int  recursive_dll(int lim , int code);
int  chain_4(int x);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\dbg\chain4.c ===
/*DOC*
**
** Suite : 
** File  : chain4.c
**
** Revision History :
** M001 2-Feb-1994
** - created from foodll.c from old callstack sources.
**
**DOC*/

#include <windows.h>
#include "foo.h"
#include "chain1.h"
#include "chain4.h"

int Global;
// external int chain_5();
typedef int PASCAL CallBackFCN();
int callback(CallBackFCN lpfnCallBack, int x);

///////////////////////////////////////////////////////////////////////////
//INT WINAPI DllEntryPoint(HANDLE hInst, ULONG ulRbc, LPVOID lpReserved) {
int  WINAPI DllEntryPoint(HANDLE hInst, ULONG ulRbc, LPVOID lpReserved) {
// ulRbc is reason bieng called
    return 1;
} /* DllEntryPoint */


#if TEST == cBASIC
////////////////////////////////////////////////////////////////////////////
#ifdef hasLOCALS
#define  DeclareLocals   int Sum;
#define  RESULT          Sum
#else
#define  DeclareLocals
#define  RESULT          Global
#endif

#ifdef hasPARAMS
#define  fooAdd          paramA+paramB
#else
#define  fooAdd          Global+3
#endif

#ifdef returnsVALUE
#define  ReturnStmt      return Global
#else
#define  ReturnStmt
#endif

fooReturn FUNCTYPE foo( fooParams )
{
   DeclareLocals;
START:
   Global=3;
   RESULT = fooAdd;
#ifndef _ALPHA_
   ReturnStmt;
#endif
END:;
#ifdef _ALPHA_
// Alpha optimizes away lables without code after them.
   ReturnStmt;
#endif
};
#endif //TEST == BASIC


///////////////////////////////////////////////////////////////////////////
int  recursive_dll(int lim , int reset)
{
    static cnt=0;
    static limit=0;

START:
    if (reset)
    {
        cnt=0;
        limit=lim;
    }
    cnt++;
    if (cnt < limit )
    {
        recursive_dll(cnt, FALSE);
    }
END:;
    return cnt;
}



///////////////////////////////////////////////////////////////////////////
int chain_4(int x)
{
    int Sum_4;
START:
    Sum_4=x+1;
	x=chain_5(x)/2;
END:;
    return Sum_4;
};



int callback(CallBackFCN lpfnCallBack, int x)
{
    int cnt;
    int sum;
    int tmp;

START:
    cnt=0;
    sum=0;
    tmp=0;
    for (cnt=0; cnt < x ; cnt++)
    {
        tmp = (*lpfnCallBack)();
        sum=sum+tmp;
    };
    return sum;
END:;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\dbg\foo0x.h ===
// #pragma warning(disable:4049)  //warning indirection in intializing...

void BPWithLengthTest(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\dbg\cxx.cxx ===
/*DOC*
**
** Suite : 
** File  : cxx.cxx
**
** Revision History :
** M001 2-Feb-1994
** - created from cxx.cxx from old callstack sources.
**
**DOC*/


#include "foo.h"
#include "cxx.h"

int Result=0;

extern "C"
{
void Cxx_Tests();
}

void Cxx_Tests()
{
  CALL_CONSTRUCTOR:
  fooclass foo1;


  CALL_MEMBER_FUNC:
  Result=foo1.getID();
  Result=foo1.getCount();


  CALL_CONVERSION:
  Result=foo1;


  CALL_STATIC:
  Result=fooclass::static_func();
  foo1.clear();  // clear private value

  CALL_INLINE:
  foo1.inline_func();
  Result=foo1;
  foo1.chain1_func();
};

void fooclass::chain1_func() {					// chain1 function
  START:
      unsigned char local_cpp_func='A';
      private_value++;                // increment private value
	  int chain2_return = chain2_func();
      private_value--;                // decrement private value
  END:;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\dbg\eh.cpp ===
/*****************************************************************************
*
*	File:		EH.CPP
*	Project:	THREAD
*	Owner:		briancr
*
*	Description: This is a C++ file that basically throws a C++ exception.
*
*	History:
*		briancr			09/20/93	created
*
*****************************************************************************/

//#include "eh.h"

extern "C" void DoCppException(void);
void ThrowException(void);

void DoCppException(void)
{
	ThrowException();							// dbg:stack_traverse
}

void ThrowException(void)
{
	throw 5;
}												// dbg:eh_stop
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\dbg\foo.h ===
#define TRUE    1
#define FALSE   0

#define cBASIC     0
#define cCHAIN     1
#define cCXX       2
#define cRECURSIVE 3

#ifndef WIN32
  #ifndef FAR
    #define FAR                 _far
  #endif
typedef unsigned long ULONG;
#if !defined( _WINDEF_ )
typedef unsigned long INT;
#endif

#else
  #ifndef FAR
    #define FAR
  #endif
#endif

#pragma warning(disable:4102)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\dbg\cxx.h ===
/*********************** FOOCLASS **********************/
class fooclass {
private:
  int private_value;
  int id;
  static int ref_cnt;
public:

  fooclass();
  ~fooclass();

  static int static_func() {
  START:
     return 9;
  END:;
  };

  void clear() {                       // Clear private value
  START:
     fooclass::private_value=0;
  END:;
  };

  int getID() {                       // return ID
  START:
      return id;
  END:;
  };

  int getCount() {                    // return reference_cnt
  START:
      return ref_cnt;
  END:;
  };

  operator int() {                    // return private value
  START:
      return (int)private_value;      // conversion operator
  END:;
  };

  inline void inline_func() {         // inline function
  START:
      private_value++;                // increment private value
  END:;
  };

  void chain1_func();					// chain1 function
  int chain2_func() {					// chain2 function
  START:
      return private_value+1;
  END:;
  };

};


/******************** define function for fooclass ************/
 int fooclass::ref_cnt=1;

  fooclass::fooclass() {              // constructor for fooclass
  START:
    id=ref_cnt;
    ref_cnt++;
    private_value=-2*id;
  END:;
  };

  fooclass::~fooclass() {             // destructor for fooclass
  START:
    ref_cnt--;
  END:;
  };
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\dbg\foox.c ===
/*DOC*
**
** Suite : 
** File  : foox.c
**
** Revision History :
** M001 2-Feb-1994
** - created from foox.c from old callstack sources.
**
**DOC*/

#include "foo.h"
#include "foox.h"

int Global;


////////////////////////////////////////////////////////////////////////////
//
// foo()
//
//
//      foo is a chamelion function it return value, calling convention,
//      paramters, and use of locals is determined by defining certain
//      FLAGS at compile time (ie hasLOCALS, hasPARAMS, returnsVALUE, DLL)
//
//
//
////////////////////////////////////////////////////////////////////////////
#ifdef hasLOCALS
#define  DeclareLocals   int Sum;
#define  RESULT          Sum
#else
#define  DeclareLocals
#define  RESULT          Global
#endif

#ifdef hasPARAMS
#define  fooAdd          paramA+paramB
#else
#define  fooAdd          Global+3
#endif

#ifdef returnsVALUE
#define  ReturnStmt      return Global
#else
#define  ReturnStmt
#endif

fooReturn	FUNCTYPE foo2(fooParams)
{
   DeclareLocals;
START:
   Global=3;
   RESULT = fooAdd;
   ReturnStmt;
END:;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\dbg\foo0x.c ===
/*DOC*
**
** Suite : 
** File  : foo0x.c
**
** Revision History :
** M001 2-Feb-1994
** - created from foo0x.c from old callstack sources.
**
**DOC*/

#include <string.h>
#include "foo.h"
#include "foo0x.h"

// #if TEST == cBASIC
// #ifdef DLL                                    // define DLL to enable dll tests
#include "chain4.h"
// #else
#include "foox.h"
// #endif //DLL
// #endif //cbasic

#ifdef hasPARAMS
#define  fooArgs  param1, param2
#else
#define  fooArgs
#endif

#ifdef returnsVALUE
#define  fooRet  Result=
#else
#define  fooRet
#endif

#define FOO  fooRet foo(fooArgs);

// #if TEST == cCXX
  void Cxx_Tests();
// #endif

int param1=1;
int param2=2;
int index=0;


extern int Global; // =0;
extern int Result; // =0;
extern char * String; // =" Some sample string";

int gi[5] = {0, 0, 0, 0, 0};

int OtherMain() {
int local;

  local=255;

#if TEST == cBASIC
  callFOO:

  FOO;

  RETURN:;

#endif // TEST == cBASIC



  BPWithLengthTest();
  callCXX:
  Cxx_Tests();
  (void)foo2(7, 1);
  TagStepEH: DoCppException();


  CALL_RUNTIME:;
  Result=strlen(String);


DONE:
  return 1;
};


void BPWithLengthTest(void)
{
	START:	
	gi[4]=99;
	gi[2]=99;  // breakpoint should fire and stop 
	BREAK:     // at the next line of code tagged with the BREAK label
	gi[2]=0; gi[3]=99;  
	END:
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\dbga\cpp.h ===
// base class
class base {
public:
	virtual void vf1() { int i = 5; };
	virtual int  vf2() { return 10; };
	virtual int  vf3(int ind) { return ind*2; };
};


/*********************** FOOCLASS **********************/
class fooclass : public base {
private:
  int private_value;
  int id;
  static int ref_cnt;
public:

  fooclass();
  ~fooclass();

  void vf1() { int i = 7; };
  int  vf2(int j) { return j; };

  static int static_func() {
  START:
     return 9;
  END:;
  };

  void clear() {                       // Clear private value
  START:
     fooclass::private_value=0;
  END:;
  };

  int getID() {                       // return ID
  START:
      return id;
  END:;
  };

  int getCount() {                    // return reference_cnt
  START:
      return ref_cnt;
  END:;
  };

  operator int() {                    // return private value
  START:
      return (int)private_value;      // conversion operator
  END:;
  };

  inline void inline_func() {         // inline function
  START:
      private_value++;                // increment private value
  END:;
  };
};


/******************** define function for fooclass ************/
 int fooclass::ref_cnt=1;

  fooclass::fooclass() {              // constructor for fooclass
  START:
    id=ref_cnt;
    ref_cnt++;
    private_value=-2*id;
  END:;
  };

  fooclass::~fooclass() {             // destructor for fooclass
  START:
    ref_cnt--;
  END:;
  };
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\disasm\disasm.cpp ===
#include <windows.h>

// DAM window test
#include <math.h>

extern "C" 
{
LPTHREAD_START_ROUTINE ThreadRoutine(LPVOID pArg);
}

void OverloadedFunc(int nArg)
{
	return;
}

void OverloadedFunc(void)
{
	return;
}

int Func(double dArg)
{
	return (int) dArg;
}

int FuncWithArg(int nArg)
{
	return nArg + 2;
}

// Template 
template <class T> T TemplateFoo(T tArg)
{
	return ++tArg;					/* TemplateFoo body */
}

int FAR PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)
{
	char	chJustChar = 'a';
	int		nJustInt = 7;
	int		*pJustInt = &nJustInt;
	double	dJustDouble  =9.37;
	float  fJustFloat = 1.00;

	HANDLE hThread;
	DWORD dwThreadId;

	// The next two line should be normally commented.  They are used to ccause GPF and invoke default debugger
	//int *popa;
	//*popa = 65700;

	__asm {
		push eax;
		pop eax;
	}

	int *p = &nJustInt;
	*p = 0;

	TemplateFoo <char>(chJustChar);		/* First line for tests */
	TemplateFoo <int>(nJustInt);

	goto Ku_Ku;
		nJustInt = 7;
	Ku_Ku:
		nJustInt = 17;

	FuncWithArg(1);						/* Second line for tests */
	Func(dJustDouble);

	OverloadedFunc();
	OverloadedFunc(nJustInt);

	hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ThreadRoutine, (void*) pJustInt, 0L,&dwThreadId);
	ResumeThread(hThread);

	while(1)							/* Last line for tests */
		Sleep(5000);

	return 1;							
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\dbg\foox.h ===
#define hasPARAMS
#define FUNCTYPE _stdcall
#define returnsVALUE


#ifdef hasPARAMS
#define  fooParams int paramA, int paramB
#else
#define  fooParams
#endif

#ifdef returnsVALUE
#define  fooReturn  int
#else
#define  fooReturn  void
#endif

fooReturn FUNCTYPE foo( fooParams );
fooReturn FUNCTYPE foo2( fooParams );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\dbg\main.c ===
/*DOC*
**
** Suite : 
** File  : main.c
**
** Revision History :
** M001 2-Feb-1994
** - created from chain1.c from old callstack sources.
**
**DOC*/


#include <windows.h>
#include "chain3.h"

#define IDM_EXIT  100

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM);
int MyPostMessage( HWND hwnd );
extern int ChainMain();
extern int OtherMain();

#if !defined( SAVELABEL )
#define SAVELABEL( l )	if (0) goto l
#endif

#ifdef DLL
extern int callback();
int WINAPI mycallbackfcn();
#endif

char szGExeBuffer[128];

int PASCAL WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                         LPSTR lpszCmdLine, int nCmdShow)
{

     static char szAppName[] = "foo" ;
     HWND        hwnd ;
     MSG         msg ;
     WNDCLASS    wndclass ;

     if (!hPrevInstance)
          {
          wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
          wndclass.lpfnWndProc   = (WNDPROC) WndProc ;
          wndclass.cbClsExtra    = 0 ;
          wndclass.cbWndExtra    = 0 ;
          wndclass.hInstance     = hInstance ;
          wndclass.hIcon         = LoadIcon(NULL, IDI_APPLICATION); 
          wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW);
          wndclass.hbrBackground = GetStockObject (WHITE_BRUSH);
          wndclass.lpszMenuName  = szAppName ;  // MAC?
          wndclass.lpszClassName = szAppName ;

          RegisterClass (&wndclass) ;
          }

     hwnd = CreateWindowEx(
#if defined( _MAC )
					WS_EX_FORCESIZEBOX,
#else
					0,
#endif
     				szAppName,         // window class name
                    szAppName, 				// window caption
                    WS_OVERLAPPEDWINDOW,     // window style
                    CW_USEDEFAULT,           // initial x position
                    0, // CW_USEDEFAULT,           // initial y position
                    CW_USEDEFAULT,           // initial x size
                    0, // CW_USEDEFAULT,           // initial y size
                    NULL,                    // parent window handle
                    NULL,                    // window menu handle
                    hInstance,               // program instance handle
                    NULL) ;                  // creation parameters
     if (hwnd==0) {   //window not created
         return 1;
     }

     ShowWindow (hwnd, nCmdShow) ;
     UpdateWindow (hwnd) ;
//     PostMessage( hwnd, WM_NULL, (WORD)0, (DWORD)0);

     while (GetMessage (&msg, NULL, 0, 0))
          {
          TranslateMessage (&msg) ;
          DispatchMessage (&msg) ;
          }
     return msg.wParam ;
     }


LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
     {
     HDC         hdc ;
     PAINTSTRUCT ps ;
     RECT        rect ;
     static HINSTANCE hInst;
     static FARPROC pCB;
     int x;
	 static int y = -1;

	 SAVELABEL(TagCallNoCVInfo);
	 SAVELABEL(TagCallOtherMain);
	 SAVELABEL(TagCallChainMain);
	 SAVELABEL(TagCreateCase);

     switch (message)
          {
          case WM_CREATE:
TagCreateCase: hInst= ((LPCREATESTRUCT) lParam)->hInstance;

               ////////////// MAKE TESTING CALLS HERE  /////////

TagCallChainMain: ChainMain();

TagCallOtherMain: OtherMain();

TagCallNoCVInfo: y = chain_3(99);

#ifdef DLL
CALL_CALLBACK:;
               pCB = MakeProcInstance(mycallbackfcn, hInst);
               x= callback(pCB, 4);
#endif
               x = 0;
               return 0 ;

          case WM_PAINT:
               hdc = BeginPaint (hwnd, &ps) ;
               GetClientRect (hwnd, &rect) ;
               DrawText (hdc, "Hello, Windows!", -1, &rect,
                          DT_SINGLELINE | DT_CENTER | DT_VCENTER) ;
               EndPaint (hwnd, &ps) ;
               return 0 ;

#if defined( _MAC )
          case WM_SYSCOMMAND:
#endif
          case WM_COMMAND:        /* message: command from application menu */
               switch( wParam )
                  {
                  case IDM_EXIT:
                       DestroyWindow(hwnd);
                       break;
                  }
               break;

          case WM_DESTROY:
               PostQuitMessage (0) ;
               return 0 ;
#if !defined( _MAC )
           case WM_NULL:
               MyPostMessage(hwnd);
               return 0 ;
#endif
          }

     return DefWindowProc (hwnd, message, wParam, lParam) ;
}


int MyPostMessage( HWND hwnd )
{
    static int count = 0;

#if !defined( _MAC )
	SAVELABEL(TagPost);
					 
    if ( count < 5 )
    {
TagPost: PostMessage( hwnd, WM_PAINT, (WORD)0, (DWORD)0);
         PostMessage( hwnd, 0x0040, (WORD)0, (DWORD)0);
    }
    return count++;
#endif 

}


#ifdef DLL
int WINAPI mycallbackfcn()
{
   int x;

START:
   x=1;
   x=x+3;
   return x;
END:;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\dbga\cpp.cpp ===
#include "cpp.h"

int Result=0;

extern "C"
{
void Cxx_Tests();
}

void Cxx_Tests()
{
  CALL_CONSTRUCTOR:
  fooclass foo1;

  foo1.vf1();
  Result = foo1.base::vf2();
  Result = foo1.vf2(7);
  Result = foo1.vf3(9);

  CALL_MEMBER_FUNC:
  Result=foo1.getID();
  Result=foo1.getCount();

  CALL_CONVERSION:
  Result=foo1;

  CALL_STATIC:
  Result=fooclass::static_func();
  foo1.clear();  // clear private value

  CALL_INLINE:
  foo1.inline_func();
  Result=foo1;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\disasm\damthread.c ===
#include <windows.h>
#include <math.h>

double FuncAcA(int nArg)
{
	return (double) (nArg*12);
}

LPTHREAD_START_ROUTINE ThreadRoutine(LPVOID pArg)
{
	int *nArg = (int*) pArg;
	*nArg += 25;
	
	MessageBeep(1);
	while(1)
		sqrt(FuncAcA(*nArg));

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\DisAsm PP\DisAsm PP.cpp ===
#include <windows.h>

const float FLOAT_ZERO = 0;
__int64 GlobalInt64 = 0;

__int64 FloatVal[] =	//	32 bit register values for each integer
{
	3225419779,		//	-3
	3221225474,		//	-2	
	3212836866,		//	-1
	0,				//	0
	1065353218,		//	1
	1073741826,		//	2
	1077936131,		//	3
	1082130434,		//	4
	1084227586,		//	5
	1086324738,		//	6
	1088421890,		//	7	
	1090519041,		//	8
	1091567617,		//	9
	1092616193		//	10
};

__m128 Var128;

const int FLOATVAL_BASE = -3;

void ClearXMMReg(int regid);
void set_GlobalInt64(int Hi, int Low);
void set_XMMRegister(int regid, char upper, int Hi, int Low);
void set_XMMRegister(int regid, int X3, int X2, int X1, int X0);

void set_Register(int regid, __int64 regval);
void Test_MMX();
void Test_3dNow();
void Test_3dNowEnhanced();
void Test_Katmai();
void Test_WNI();

int FAR PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)
{
	//	MMX & 3d Now! tests
	Test_MMX();
	Test_3dNow();
	Test_3dNowEnhanced();
	Test_Katmai();
	Test_WNI();
	
	return 0;							
}


void set_Register(int regid, __int64 regval)
{
	switch (regid)
	{
		case 0:		__asm { MOVQ MM0, regval }
					break;


		case 1:		__asm { MOVQ MM1, regval }
					break;


		case 2:		__asm { MOVQ MM2, regval }
					break;

		case 3:		__asm { MOVQ MM3, regval }
					break;


		case 4:		__asm { MOVQ MM4, regval }
					break;

		case 5:		__asm { MOVQ MM5, regval }
					break;

		case 6:		__asm { MOVQ MM6, regval }
					break;

		case 7:		__asm { MOVQ MM7, regval }
					break;

	}
}


void Test_MMX()
{
	//	MMX tests
	
	__int64 count = 0;
	__int32 iVar32 = 0;

	//	test all registers for visibility
	__asm {	MOVQ MM0,MM1 }
	__asm {	MOVQ MM1,MM2 }
	__asm {	MOVQ MM2,MM3 }
	__asm {	MOVQ MM3,MM4 }
	__asm {	MOVQ MM4,MM5 }
	__asm {	MOVQ MM5,MM6 }
	__asm {	MOVQ MM6,MM7 }
	__asm {	MOVQ MM7,MM0 }

	//	shift left
	__asm {	PSLLW MM0,count }
	__asm {	PSLLW MM0,MM1 }

	//	mov 32 bit
	__asm {	MOVD MM0,iVar32 }
	__asm {	MOVD iVar32,MM0 }
	__asm {	MOVQ MM0,count }	
	__asm {	MOVQ count,MM0 }	

	__asm {	MOVD MM0,eax }
	__asm {	MOVD eax,MM0 }
	__asm {	MOVQ MM0,MM1 }	
	
	//	Pack with Signed Saturation
	__asm {	PACKSSWB MM0,count }
	__asm {	PACKSSDW MM0,count }

	__asm {	PACKSSWB MM0,MM1 }
	__asm {	PACKSSDW MM0,MM1 }

	//	Pack with Unsigned Saturation	
	__asm {	PACKUSWB MM0,count }
	__asm {	PACKUSWB MM0,MM1 }

	//	Packed Add
	__asm {	PADDB MM0,count }
	__asm {	PADDW MM0,count }	
	__asm {	PADDD MM0,count }

	__asm {	PADDB MM0,MM1 }
	__asm {	PADDW MM0,MM1 }	
	__asm {	PADDD MM0,MM1 }

	//	Packed Add with Saturation
	__asm {	PADDSB MM0,count }
	__asm {	PADDSW MM0,count }

	__asm {	PADDSB MM0,MM1 }
	__asm {	PADDSW MM0,MM1 }

	//	Packed Add Unsigned with Saturation 
	__asm {	PADDUSB MM0,count }
	__asm {	PADDUSW MM0,count }

	__asm {	PADDUSB MM0,MM1 }
	__asm {	PADDUSW MM0,MM1 }

	//	Bitwise Logical And 
	__asm {	PAND MM0,count }
	__asm {	PAND MM0,MM1 }

	//	Bitwise Logical And Not 
	__asm {	PANDN MM0,count }
	__asm {	PANDN MM0,MM1 }

	//	Bitwise Logical Or
	__asm {	POR MM0,count }
	__asm {	POR MM0,MM1 }

	//	Compare for Equal 
	__asm {	PCMPEQB MM0,count }
	__asm {	PCMPEQW MM0,count }
	__asm {	PCMPEQD MM0,count }

	__asm {	PCMPEQB MM0,MM1 }
	__asm {	PCMPEQW MM0,MM1 }
	__asm {	PCMPEQD MM0,MM1 }

	//	Compare for Greater Than
	__asm {	PCMPGTB MM0,count }
	__asm {	PCMPGTW MM0,count }
	__asm {	PCMPGTD MM0,count }

	__asm {	PCMPGTB MM0,MM1 }
	__asm {	PCMPGTW MM0,MM1 }
	__asm {	PCMPGTD MM0,MM1 }

	//	Packed Multiply and Add 
	__asm {	PMADDWD MM0,count }
	__asm {	PMADDWD MM0,MM1 }

	//	Packed Multiply High
	__asm {	PMULHW MM0,count }
	__asm {	PMULHW MM0,MM1 }

	//	Packed Multiply Low
	__asm {	PMULLW MM0,count }
	__asm {	PMULLW MM0,MM1 }

	//	Packed Shift Left Logical
	__asm {	PSLLW MM0,count }
	__asm {	PSLLD MM0,count }
	__asm {	PSLLQ MM0,count }

	__asm {	PSLLW MM0,MM1 }
	__asm {	PSLLD MM0,MM1 }
	__asm {	PSLLQ MM0,MM1 }

	__asm {	PSLLW MM0,7 }
	__asm {	PSLLD MM0,7 }
	__asm {	PSLLQ MM0,7 }

	//	Packed Shift Right Arithmetic
	__asm {	PSRAW MM0,count }
	__asm {	PSRAD MM0,count }
	
	__asm {	PSRAW MM0,MM1 }
	__asm {	PSRAD MM0,MM1 }

	__asm {	PSRAW MM0,5 }
	__asm {	PSRAD MM0,5 }

	//	Packed Shift Right Logical
	__asm {	PSRLW MM0,count }
	__asm {	PSRLD MM0,count }
	__asm {	PSRLQ MM0,count }

	__asm {	PSRLW MM0,MM1 }
	__asm {	PSRLD MM0,MM1 }
	__asm {	PSRLQ MM0,MM1 }

	__asm {	PSRLW MM0,6 }
	__asm {	PSRLD MM0,6 }
	__asm {	PSRLQ MM0,6 }

	//	Packed Subtract
	__asm {	PSUBB MM0,count }
	__asm {	PSUBW MM0,count }
	__asm {	PSUBD MM0,count }

	__asm {	PSUBB MM0,MM1 }
	__asm {	PSUBW MM0,MM1 }
	__asm {	PSUBD MM0,MM1 }

	//	Packed Subtract with Saturation
	__asm {	PSUBSB MM0,count }
	__asm {	PSUBSW MM0,count }

	__asm {	PSUBSB MM0,MM1 }
	__asm {	PSUBSW MM0,MM1 }

	//	Packed Subtract Unsigned with Saturation
	__asm {	PSUBUSB MM0,count }
	__asm {	PSUBSW MM0,count }
	
	__asm {	PSUBUSB MM0,MM1 }
	__asm {	PSUBSW MM0,MM1 }
	
	//	Unpack High Packed Data
	__asm {	PUNPCKHBW MM0,count }	
	__asm {	PUNPCKHWD MM0,count }
	__asm {	PUNPCKHDQ MM0,count }
	
	__asm {	PUNPCKHBW MM0,MM1 }	
	__asm {	PUNPCKHWD MM0,MM1 }
	__asm {	PUNPCKHDQ MM0,MM1 }
	
	//	Unpack Low Packed Data
	__asm {	PUNPCKLBW MM0,iVar32 }
	__asm {	PUNPCKLWD MM0,iVar32 }
	__asm {	PUNPCKLDQ MM0,iVar32 }
	
	__asm {	PUNPCKLBW MM0,MM1 }
	__asm {	PUNPCKLWD MM0,MM1 }
	__asm {	PUNPCKLDQ MM0,MM1 }
	
	//	Bitwise Logical Exclusive OR
	__asm {	PXOR MM0,count }
	__asm {	PXOR MM0,MM1 }

}


void Test_3dNow()
{
	//	3d Now Tests

	__int64 count = 0;
	unsigned char int8 = 0;

	//	average of unsigned int bytes
	__asm {	PAVGUSB MM0,count }
	__asm {	PAVGUSB MM0,MM5 }

	//	float to 32 bit signed int
	__asm {	PF2ID MM0,count }
	__asm {	PF2ID MM0,MM5 }

	//	accumulator
	__asm {	PFACC MM0,count }
	__asm {	PFACC MM0,MM5 }

	//	add
	__asm {	PFADD MM0,count }
	__asm {	PFADD MM0,MM5 }

	//	compare for equal
	__asm {	PFCMPEQ MM0,count }
	__asm {	PFCMPEQ MM0,MM5 }

	//	compare for greater than or equal to
	__asm {	PFCMPGE MM0,count }
	__asm {	PFCMPGE MM0,MM5 }

	//	compare for greater than
	__asm {	PFCMPGT MM0,count }
	__asm {	PFCMPGT MM0,MM5 }
	
	//	maximum
	__asm {	PFMAX MM0,count }
	__asm {	PFMAX MM0,MM5 }

	//	minimum
	__asm {	PFMIN MM0,count }
	__asm {	PFMIN MM0,MM5 }

	//	multiply
	__asm {	PFMUL MM0,count }
	__asm {	PFMUL MM0,MM5 }
	
	//	reciprocal
	__asm {	PFRCP MM0,count }
	__asm {	PFRCP MM0,MM5 }

	//	reciprocal, reciprocal intermediate step 1, reciprocal intermediate step 2
	__asm {	PFRCPIT1 MM1,MM0 }
	__asm {	PFRCPIT2 MM0,MM1 }

	__asm {	PFRCPIT1 MM5,count }
	__asm {	PFRCPIT2 MM5,count }

	//	reciprocal sqrt
	__asm {	PFRSQRT MM0,count }
	__asm {	PFRSQRT MM0,MM5 }

	//	reciprocal sqrt, reciprocal sqrt intermediate step 1	
	__asm {	PFRSQIT1 MM1,MM0 }
	__asm {	PFRSQIT1 MM1,count }

	//	subtract
	__asm {	PFSUB MM0,count }
	__asm {	PFSUB MM0,MM5 }

	//	reverse subtraction
	__asm {	PFSUBR MM0,count }
	__asm {	PFSUBR MM0,MM5 }

	//	32 bit signed int to float
	__asm {	PI2FD MM0,count }
	__asm {	PI2FD MM0,MM5 }

	//	multiply high
	__asm {	PMULHRW MM0,count }
	__asm {	PMULHRW MM0,MM5 }

	int8 = 1;

	//	load a processor cache into data cache
	__asm {	PREFETCH int8 }

	//	same, sets MES state to modified
	__asm {	PREFETCHW int8 }

}


void Test_3dNowEnhanced()
{
	//	enhanced 3dnow tests

	__int64 count = 0;
	unsigned char count8 = 0;
	__int16 iVar16 = 0;

	//	packed float to int word with sign extend
	__asm {	PF2IW MM0,count }
	__asm {	PF2IW MM0,MM1 }

	//	packed float negative accumulate
	__asm {	PFNACC MM0,count }
	__asm {	PFNACC MM0,MM1 }

	//	packed float mixed +ve -ve accumulate
	__asm {	PFPNACC MM0,count }
 	__asm {	PFPNACC MM0,MM1 }
    
	//	packed int word to float
	//	somewhat erroneous values
	__asm {	PI2FW MM0,count }
	__asm {	PI2FW MM0,MM1 }

	//	packed swap double word
	__asm {	PSWAPD MM0,count }
	__asm {	PSWAPD MM0,MM1 }
	
	//	streaming store using byte mask
	//	DID NOT UNDERSTAND
	__asm {	MASKMOVQ MM0,MM1 }
	
	//	streaming store
	__asm {	MOVNTQ count,MM0 }
			
	//	packed avg of unsigned byte	
	__asm {	PAVGB MM0,count }
	__asm {	PAVGB MM0,MM1 }
	
	//	packed avg of unsigned word	
	__asm {	PAVGW MM0,count }
	__asm {	PAVGW MM0,MM1 }

	//	extract word into int register
	__asm {	PEXTRW EAX,MM0, 1 }

	//	insert word from int register
	__asm {	PINSRW MM0, EAX, 1 }
	__asm {	PINSRW MM0, iVar16, 1 }

	//	packed max signed word
	__asm {	PMAXSW MM0,count }	//	1431633926
	__asm {	PMAXSW MM0,MM1 }	//	1431633926
	
	//	packed max unsigned byte
	__asm {	PMAXUB MM0,count }	//	1834219928319
	__asm {	PMAXUB MM0,MM1 }	//	1834219928319
	
	//	packed min signed word
	__asm {	PMINSW MM0,count }	//	1431633921
	__asm {	PMINSW MM0,MM1 }	//	1431633921
	
	//	packed min unsigned byte	
	__asm {	PMINUB MM0,count }	//	730396487935
	__asm {	PMINUB MM0,MM1 }	//	730396487935
	
	//	move mask to integer register
	__asm {	PMOVMSKB EAX, MM0 }	//	EAX = 217
	
	//	packed multiply high unsigned word
	__asm {	PMULHUW MM0,count }	//	281474976841729
	__asm {	PMULHUW MM0,MM1 }	//	281474976841729

	//	prefetch non-temporal access
	__asm {	PREFETCHNTA count8 }
	
	//	prefetch to all cache levels
	__asm {	PREFETCHT0 count8 }
	
	//	prefetch to all cache levels except 0
	__asm {	PREFETCHT1 count8 }
	
	//	prefetch to all cache levels except 0 & 1
	__asm {	PREFETCHT2 count8 }

	//	packed sum of absolute byte differences
	__asm {	PSADBW MM0,count }	//	35
	__asm {	PSADBW MM0,MM1 }	//	35
	
	//	packed shuffle word
	__asm {	PSHUFW MM0,count,228 }	//	578437695752307201
	__asm {	PSHUFW MM0,MM1,225 }	//	578437695752307201
	
	// store fence
	__asm {	SFENCE }

}


void Test_Katmai()
{
	//	Katmai (PIII) tests
	
	float fVal = 0.0;
	__m128 mVar128 = {0,0,0,0};
	__int32 i32Val = 0;

	//	test all registers for visibility
	__asm { movss   xmm0, xmm1 }	//	0.0.0.9
	__asm { movss   xmm1, xmm2 }	//	0.0.0.9
	__asm { movss   xmm2, xmm3 }	//	0.0.0.9
	__asm { movss   xmm3, xmm4 }	//	0.0.0.9
	__asm { movss   xmm4, xmm5 }	//	0.0.0.9
	__asm { movss   xmm5, xmm6 }	//	0.0.0.9
	__asm { movss   xmm6, xmm7 }	//	0.0.0.9
	__asm { movss   xmm7, xmm0 }	//	0.0.0.9

	__asm { addps   xmm0, xmm1 }	//	XMM0 - 3,5,7,9
	__asm { addps   xmm0, mVar128 }	//	XMM0 - 3,5,7,9

	__asm { addss   xmm0, xmm1 }	//	1,2,3,9
	__asm { addss   xmm0, i32Val }	//	1,2,3,9

	__asm { andnps   xmm0, xmm1 }
	__asm { andnps   xmm0, mVar128 }

	__asm { andps   xmm0, xmm1 }	//	0
	__asm { andps   xmm0, mVar128 }	//	0

	__asm { cmpps   xmm0, xmm1, 0 }		//	eq
	__asm { cmpps   xmm0, xmm1, 1 }		//	lt
	__asm { cmpps   xmm0, xmm1, 2 }		//	le
	__asm { cmpps   xmm0, xmm1, 3 }		//	unord
	__asm { cmpps   xmm0, xmm1, 4 }		//	neq
	__asm { cmpps   xmm0, xmm1, 5 }		//	nlt
	__asm { cmpps   xmm0, xmm1, 6 }		//	nle
	__asm { cmpps   xmm0, xmm1, 7 }		//	ord
	
	__asm { cmpps   xmm0, mVar128, 0 }
	__asm { cmpps   xmm0, mVar128, 1 }
	__asm { cmpps   xmm0, mVar128, 2 }
	__asm { cmpps   xmm0, mVar128, 3 }
	__asm { cmpps   xmm0, mVar128, 4 }
	__asm { cmpps   xmm0, mVar128, 5 }
	__asm { cmpps   xmm0, mVar128, 6 }
	__asm { cmpps   xmm0, mVar128, 7 }

	__asm { cmpss   xmm0, xmm1, 0 }		//	eq
	__asm { cmpss   xmm0, xmm1, 1 }		//	lt
	__asm { cmpss   xmm0, xmm1, 2 }		//	le
	__asm { cmpss   xmm0, xmm1, 3 }		//	unord
	__asm { cmpss   xmm0, xmm1, 4 }		//	neq
	__asm { cmpss   xmm0, xmm1, 5 }		//	nlt
	__asm { cmpss   xmm0, xmm1, 6 }		//	nle
	__asm { cmpss   xmm0, xmm1, 7 }		//	ord
	
	__asm { cmpss   xmm0, i32Val, 0 }
	__asm { cmpss   xmm0, i32Val, 1 }
	__asm { cmpss   xmm0, i32Val, 2 }
	__asm { cmpss   xmm0, i32Val, 3 }
	__asm { cmpss   xmm0, i32Val, 4 }
	__asm { cmpss   xmm0, i32Val, 5 }
	__asm { cmpss   xmm0, i32Val, 6 }
	__asm { cmpss   xmm0, i32Val, 7 }

	__asm { cmpeqps   xmm0, xmm1 }	//	eq-eq-eq-eq
	__asm { cmpeqss   xmm0, xmm1 }	//	1,2,3,eq
	__asm { cmpltps   xmm0, xmm1 }	//	no-yes-no-no
	__asm { cmpltss   xmm0, xmm1 }	//	1,2,3,yes
	__asm { cmpleps   xmm0, xmm1 }	//	yes,yes,no,no
	__asm { cmpless   xmm0, xmm1 }	//	1,2,3,yes
	__asm { cmpneqps  xmm0, xmm1 }	//	no,y,y,n
	__asm { cmpneqss   xmm0, xmm1 }	//	1,2,3,n
	__asm { cmpnltps   xmm0, xmm1 }	//	n,y,n,y
	__asm { cmpnltss   xmm0, xmm1 }	//	1,2,3,y
	__asm { cmpnleps   xmm0, xmm1 }	//	n,n,n,y
	__asm { cmpnless   xmm0, xmm1 }	//	1,2,3,n

	__asm { comiss   xmm0, xmm1 }	//	1
	__asm { comiss   xmm0, i32Val }	//	1

	__asm { cvtpi2ps   xmm0, GlobalInt64 }	//	1,2,3,4
	__asm { cvtpi2ps   xmm0, mm0 }	//	1,2,3,4

	__asm { cvtps2pi   mm0, xmm0 }	//	MM0 has 2,5
	__asm { cvtps2pi   mm0, GlobalInt64 }	//	MM0 has 2,5

	__asm { cvtsi2ss   xmm0, eax }	//	1,2,3,17
	__asm { cvtsi2ss   xmm0, i32Val }	//	1,2,3,17

	__asm { cvtss2si   eax, xmm0 }	//	eax has 4
	__asm { cvtss2si   eax, i32Val }	//	eax has 4

	__asm { cvttps2pi   mm0, xmm0 }	//	MM0 has 7,5
	__asm { cvttps2pi   mm0, GlobalInt64 }	//	MM0 has 7,5

	__asm { cvttss2si   eax, xmm0 }	//	eax has 7
	__asm { cvttss2si   eax, i32Val }	//	eax has 7

	__asm { divps   xmm0, xmm1 }	//	0.5,1,3,4
	__asm { divps   xmm0, mVar128 }	//	0.5,1,3,4

	__asm { divss   xmm0, xmm1 }	//	1,2,3,5
	__asm { divss   xmm0, i32Val }	//	1,2,3,5

	__asm { maxps   xmm0, xmm1 }	//	5,2,9,5
	__asm { maxps   xmm0, mVar128 }	//	5,2,9,5

	__asm { maxss   xmm0, xmm1 }	//	5,2,7,6
	__asm { maxss   xmm0, i32Val }	//	5,2,7,6

	__asm { minps   xmm0, xmm1 }	//	4,2,7,3
	__asm { minps   xmm0, mVar128 }	//	4,2,7,3

	__asm { minss   xmm0, xmm1 }	//	1.2.3.4
	__asm { minss   xmm0, i32Val }	//	1.2.3.4

	__asm { movaps   xmm0, xmm1 }	//	5.5.5.5
	__asm { movaps   xmm0, mVar128 }	//	5.5.5.5
	__asm { movaps   mVar128, xmm1 }	//	5.5.5.5

	__asm { movhlps	 xmm0, xmm1 }	//	1,2,5,6

	__asm { movhps   xmm0, GlobalInt64 }	//	6.7.3.4
	__asm { movhps   GlobalInt64, xmm0 }	//	6.7.3.4

	__asm { movlps   xmm0, GlobalInt64 }	//	1.2.6.7
	__asm { movlps   GlobalInt64, xmm0 }	//	1.2.6.7

	__asm { movlhps   xmm0, xmm1 }	//	5.6.3.4

	__asm { movmskps   eax, xmm0 }	//	5

	__asm { movntps   mVar128, xmm0 }

	__asm { movss   xmm0, i32Val }	//	0.0.0.9
	__asm { movss   i32Val, xmm0 }	//	0.0.0.9
	__asm { movss   xmm0, xmm1 }	//	0.0.0.9

	__asm { movups   xmm0, xmm1 }	//	5,6,7,8
	__asm { movups   xmm0, mVar128 }	//	5,6,7,8
	__asm { movups   mVar128, xmm1 }	//	5,6,7,8

	__asm { mulps   xmm0, xmm1 }	//	2,6,0,10
	__asm { mulps   xmm0, mVar128 }	//	2,6,0,10

	__asm { mulss   xmm0, xmm1 }	//	1,2,3,8
	__asm { mulss   xmm0, i32Val }	//	1,2,3,8

	__asm { orps   xmm0, xmm1 }	//	1,x,y,z
	__asm { orps   xmm0, mVar128 }	//	1,x,y,z

	__asm { rcpps   xmm0, xmm1 }	//	1/2, 1/3, 1/4, 1/5
	__asm { rcpps   xmm0, mVar128 }	//	1/2, 1/3, 1/4, 1/5

	__asm { rcpss   xmm0, xmm1 }	//	1,2,3,1/2
	__asm { rcpss   xmm0, i32Val }	//	1,2,3,1/2

	__asm { rsqrtps   xmm0, xmm1 }	//	reciprocal 1,1.73,2,3
	__asm { rsqrtps   xmm0, mVar128 }	//	reciprocal 1,1.73,2,3

	__asm { rsqrtss   xmm0, xmm1 }	//	1,2,3, 1/3
	__asm { rsqrtss   xmm0, i32Val }	//	1,2,3, 1/3

	__asm { sfence }

	__asm { shufps   xmm0, xmm1, 114 }
	__asm { shufps   xmm0, mVar128, 115 }

	__asm { sqrtps   xmm0, xmm1 }	//	1,1.73,2,3
	__asm { sqrtps   xmm0, mVar128 }	//	1,1.73,2,3

	__asm { sqrtss   xmm0, xmm1 }	//	1,2,3,3
	__asm { sqrtss   xmm0, i32Val }	//	1,2,3,3

	__asm { stmxcsr  i32Val }
	__asm { ldmxcsr  i32Val }	//	1,2,3,5

	__asm { subps   xmm0, xmm1 }	//	-1,5,1,3
	__asm { subps   xmm0, mVar128 }	//	-1,5,1,3

	__asm { subss   xmm0, xmm1 }	//	1,8,5,-2
	__asm { subss   xmm0, i32Val }	//	1,8,5,-2

	__asm { ucomiss   xmm0, xmm1 }	//	0
	__asm { ucomiss   xmm0, i32Val }	//	0

	__asm { unpckhps   xmm0, xmm1 }	//	interleaved high - 5,1,6,2
	__asm { unpckhps   xmm0, mVar128 }	//	interleaved high - 5,1,6,2

	__asm { unpcklps   xmm0, xmm1 }	//	interleaved low - 7,3,8,4
	__asm { unpcklps   xmm0, mVar128 }	//	interleaved low - 7,3,8,4

	__asm { xorps   xmm0, xmm1 }	//	xor - 0,0,x,y
	__asm { xorps   xmm0, mVar128 }	//	xor - 0,0,x,y

}

void ClearXMMReg(int regid)
{

	switch(regid)
	{

	case 0:
		__asm { MOVSS XMM0, FLOAT_ZERO }
		break;

	case 1:
		__asm { MOVSS XMM1, FLOAT_ZERO }
		break;

	case 2:
		__asm { MOVSS XMM2, FLOAT_ZERO }
		break;

	case 3:
		__asm { MOVSS XMM3, FLOAT_ZERO }
		break;

	case 4:
		__asm { MOVSS XMM4, FLOAT_ZERO }
		break;

	case 5:
		__asm { MOVSS XMM5, FLOAT_ZERO }
		break;

	case 6:
		__asm { MOVSS XMM6, FLOAT_ZERO }
		break;

	case 7:
		__asm { MOVSS XMM7, FLOAT_ZERO }
		break;

	}

}

void set_GlobalInt64(int Hi, int Low)
{
	__int64 HiVal = FloatVal[Hi - FLOATVAL_BASE];
	__int64 LowVal = FloatVal[Low - FLOATVAL_BASE];

	GlobalInt64 = HiVal;
	GlobalInt64  = GlobalInt64 << 32;
	GlobalInt64 |= LowVal;
}

void set_XMMRegister(int regid, char upper, int Hi, int Low)
{

	switch (regid)
	{
		case 0:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM0, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM0, GlobalInt64 }
					}
					break;

		case 1:					
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM1, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM1, GlobalInt64 }
					}
					break;


		case 2:					
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM2, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM2, GlobalInt64 }
					}
					break;

		case 3:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM3, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM3, GlobalInt64 }
					}
					break;


		case 4:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM4, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM4, GlobalInt64 }
					}
					break;

		case 5:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM5, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM5, GlobalInt64 }
					}
					break;

		case 6:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM6, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM6, GlobalInt64 }
					}
					break;

		case 7:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM7, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM7, GlobalInt64 }
					}
					break;
	}
}


void set_XMMRegister(int regid, int X3, int X2, int X1, int X0)
{
	set_XMMRegister(regid, 1, X3, X2);	//	upper 64 bits
	set_XMMRegister(regid, 0, X1, X0);	//	lower 64 bits
}

void Test_WNI()
{
	__m128 mVar128 = {0,0,0,0};
	__m64 mVar64 = {0};

	__int8 mVar8;
	__int16 mVar16;
	__int32 mVar32;
	char arr[32];

	__asm
	{
		EMMS		
		
		ADDPD XMM0,XMM1
		ADDPD XMM2,XMM3
		ADDPD XMM4,XMM5
		ADDPD XMM6,XMM7
		ADDPD XMM1,XMM0
		ADDPD XMM3,XMM2
		ADDPD XMM5,XMM4
		ADDPD XMM7,XMM6
			
		ADDPD XMM0,XMM1
		ADDPD XMM0,mVar128
		
		ADDSD XMM0,XMM1
		ADDSD XMM0,mVar64

		ANDNPD XMM0,XMM1
		ANDNPD XMM0,mVar128
		
		ANDPD XMM0,XMM1
		ANDPD XMM0,mVar128
		
		CMPPD XMM0,XMM1, 0
		CMPPD XMM0,mVar128, 0
		CMPPD XMM0,XMM1, 1
		CMPPD XMM0,mVar128, 1
		CMPPD XMM0,XMM1, 2
		CMPPD XMM0,mVar128, 2
		CMPPD XMM0,XMM1, 3
		CMPPD XMM0,mVar128, 3
		CMPPD XMM0,XMM1, 4
		CMPPD XMM0,mVar128, 4
		CMPPD XMM0,XMM1, 5
		CMPPD XMM0,mVar128, 5
		CMPPD XMM0,XMM1, 6
		CMPPD XMM0,mVar128, 6
		CMPPD XMM0,XMM1, 7
		CMPPD XMM0,mVar128, 7
		
		CMPSD XMM0,XMM1, 0		
		CMPSD XMM0,mVar64, 0
		CMPSD XMM0,XMM1, 1		
		CMPSD XMM0,mVar64, 1
		CMPSD XMM0,XMM1, 2		
		CMPSD XMM0,mVar64, 2
		CMPSD XMM0,XMM1, 3		
		CMPSD XMM0,mVar64, 3
		CMPSD XMM0,XMM1, 4		
		CMPSD XMM0,mVar64, 4
		CMPSD XMM0,XMM1, 5		
		CMPSD XMM0,mVar64, 5
		CMPSD XMM0,XMM1, 6		
		CMPSD XMM0,mVar64, 6
		CMPSD XMM0,XMM1, 7		
		CMPSD XMM0,mVar64, 7
		
		COMISD XMM0,XMM1
		COMISD XMM0,mVar64
		
		CVTDQ2PD XMM0,XMM1
		CVTDQ2PD XMM0,mVar64

		CVTPD2PI MM0,XMM1	
		CVTPD2PI MM0,mVar128	
		
		CVTPD2DQ XMM0,XMM1	
		CVTPD2DQ XMM0,mVar128	

		
		CVTPD2PS XMM0,XMM1
		CVTPD2PS XMM0,mVar128
		
		CVTPI2PD XMM0,MM0
		CVTPI2PD XMM0,mVar64
		
		CVTPS2PD XMM0,XMM1
		CVTPS2PD XMM0,mVar64
		
		CVTSD2SI eax,XMM1
		CVTSD2SI eax,mVar64
		
		CVTSD2SS XMM0,XMM1
		CVTSD2SS XMM0,mVar64
		
		CVTSI2SD XMM0,eax
		CVTSI2SD XMM0,mVar32
		
		CVTSS2SD XMM0,XMM1
		CVTSS2SD XMM0,mVar32
		
		CVTTPD2PI MM0,XMM1
		CVTTPD2PI MM0,mVar128
		
		CVTTPD2DQ XMM0,XMM1
		CVTTPD2DQ XMM0,mVar128
		
		CVTTSD2SI eax,XMM1
		CVTTSD2SI eax,mVar64
		
		DIVPD XMM0,XMM1
		DIVPD XMM0,mVar128
		
		DIVSD XMM0,XMM1
		DIVSD XMM0,mVar64
		
		MAXPD XMM0,XMM1
		MAXPD XMM0,mVar128
		
		MAXSD XMM0,XMM1
		MAXSD XMM0,mVar64
		
		MINPD XMM0,XMM1
		MINPD XMM0,mVar128
		
		MINSD XMM0,XMM1
		MINSD XMM0,mVar64
		
		MOVAPD XMM0,XMM1
		MOVAPD XMM0,mVar128
		MOVAPD mVar128,XMM1
		
		MOVHPD XMM0,mVar64
		MOVHPD mVar64,XMM0
		
		MOVLPD XMM0,mVar64
		MOVLPD mVar64,XMM0
		
		MOVMSKPD eax,XMM1
		
		MOVSD XMM0,XMM1
		MOVSD XMM0,mVar64
		MOVSD mVar64,XMM1
		
		MOVUPD XMM0,XMM1
		MOVUPD XMM0,mVar128
		MOVUPD mVar128,XMM1
		
		MULPD XMM0,XMM1
		MULPD XMM0,mVar128
		
		MULSD XMM0,XMM1
		MULSD XMM0,mVar64
		
		ORPD XMM0,XMM1
		ORPD XMM0,mVar128
		
		SHUFPD XMM0,XMM1,8
		SHUFPD XMM0,mVar128,8
		
		SQRTPD XMM0,XMM1
		SQRTPD XMM0,mVar128
		
		SQRTSD XMM0,XMM1
		SQRTSD XMM0,mVar64
		
		SUBPD XMM0,XMM1
		SUBPD XMM0,mVar128
		
		SUBSD XMM0,XMM1
		SUBSD XMM0,mVar64
		
		UCOMISD XMM0,XMM1
		UCOMISD XMM0,mVar64
		
		UNPCKHPD XMM0,XMM1
		UNPCKHPD XMM0,mVar128
		
		UNPCKLPD XMM0,XMM1
		UNPCKLPD XMM0,mVar128
		
		XORPD XMM0,XMM1
		XORPD XMM0,mVar128

		
		CVTDQ2PS XMM0,XMM1
		CVTDQ2PS XMM0,mVar128

		CVTPS2DQ XMM0,XMM1
		CVTPS2DQ XMM0,mVar128

		CVTTPS2DQ XMM0,XMM1
		CVTTPS2DQ XMM0,mVar128

		//	not in manual
		CVTPI2PS XMM0,MM1
		CVTPI2PS XMM0,MM1

		//	not in manual
		CVTPS2PI MM0,XMM1
		CVTPS2PI MM0,XMM1
		
		//	not in manual
		CVTTPS2PI MM0,XMM1
		CVTTPS2PI MM0,XMM1
		
		MOVD XMM0,eax
		MOVD XMM0,mVar32
		MOVD eax,XMM1
		MOVD mVar32,XMM1
		
		MOVDQA XMM0,XMM1
		MOVDQA XMM0,mVar128
		MOVDQA mVar128,XMM1
		
		MOVDQU XMM0,XMM1
		MOVDQU XMM0,mVar128
		MOVDQU mVar128,XMM1
		
		MOVDQ2Q MM0,XMM1

		MOVQ2DQ XMM0,MM1
		
		MOVQ XMM0,XMM1
		MOVQ XMM0,mVar64
		MOVQ mVar64,XMM1

		PACKSSWB XMM0,XMM1
		PACKSSWB XMM0,mVar128
		
		PACKSSDW XMM0,XMM1
		PACKSSDW XMM0,mVar128
		
		PACKUSWB XMM0,XMM1
		PACKUSWB XMM0,mVar128
		
		PADDB XMM0,XMM1
		PADDB XMM0,mVar128
		
		PADDW XMM0,XMM1
		PADDW XMM0,mVar128
		
		PADDD XMM0,XMM1
		PADDD XMM0,mVar128
		
		PADDQ MM0,MM1
		PADDQ MM0,mVar64
		PADDQ XMM0,XMM1
		PADDQ XMM0,mVar128

		PADDSB XMM0,XMM1
		PADDSB XMM0,mVar128
		
		PADDSW XMM0,XMM1
		PADDSW XMM0,mVar128
		
		PADDUSB XMM0,XMM1
		PADDUSB XMM0,mVar128
		
		PADDUSW XMM0,XMM1
		PADDUSW XMM0,mVar128
		
		PAND XMM0,XMM1
		PAND XMM0,mVar128
		
		PANDN XMM0,XMM1
		PANDN XMM0,mVar128
		
		PAVGB XMM0,XMM1
		PAVGB XMM0,mVar128
		
		PAVGW XMM0,XMM1
		PAVGW XMM0,mVar128
		
		PCMPEQB XMM0,XMM1
		PCMPEQB XMM0,mVar128
		
		PCMPEQW XMM0,XMM1
		PCMPEQW XMM0,mVar128
		
		PCMPEQD XMM0,XMM1
		PCMPEQD XMM0,mVar128
		
		PCMPGTB XMM0,XMM1
		PCMPGTB XMM0,mVar128
		
		PCMPGTW XMM0,XMM1
		PCMPGTW XMM0,mVar128
		
		PCMPGTD XMM0,XMM1
		PCMPGTD XMM0,mVar128

		PEXTRW eax,XMM1,6

		PINSRW XMM0,mVar16,6
		PINSRW XMM0,eax,6
		
		PMADDWD XMM0,XMM1
		PMADDWD XMM0,mVar128

		PMAXSW XMM0,XMM1
		PMAXSW XMM0,mVar128

		PMAXUB XMM0,XMM1
		PMAXUB XMM0,mVar128
		
		PMINSW XMM0,XMM1
		PMINSW XMM0,mVar128
		
		PMINUB XMM0,XMM1
		PMINUB XMM0,mVar128
		
		PMOVMSKB eax,XMM1
		
		PMULHW XMM0,XMM1
		PMULHW XMM0,mVar128
		
		PMULHUW XMM0,XMM1
		PMULHUW XMM0,mVar128
		
		PMULLW XMM0,XMM1
		PMULLW XMM0,mVar128
		
		PMULUDQ MM0,MM1
		PMULUDQ MM0,mVar64
		PMULUDQ XMM0,XMM1
		PMULUDQ XMM0,mVar128
		
		POR XMM0,XMM1
		POR XMM0,mVar128
		
		PSADBW XMM0,XMM1
		PSADBW XMM0,mVar128
		
		PSHUFD XMM0,XMM1,8
		PSHUFD XMM0,mVar128,8
		
		PSHUFHW XMM0,XMM1,8
		PSHUFHW XMM0,mVar128,8
		
		PSHUFLW XMM0,XMM1,8
		PSHUFLW XMM0,mVar128,8
		
		PSLLDQ XMM0,8
		
		PSLLW XMM0,XMM1
		PSLLW XMM0,mVar128
		PSLLW XMM0,8
		
		PSLLD XMM0,XMM1
		PSLLD XMM0,mVar128
		PSLLD XMM0,8
		
		PSLLQ XMM0,XMM1
		PSLLQ XMM0,mVar128
		PSLLQ XMM0,8
		
		PSRAW XMM0,XMM1
		PSRAW XMM0,mVar128
		PSRAW XMM0,8
		
		PSRAD XMM0,XMM1
		PSRAD XMM0,mVar128
		PSRAD XMM0,8
		
		PSRLDQ XMM0,8
		
		PSRLW XMM0,XMM1
		PSRLW XMM0,mVar128
		PSRLW XMM0,8
		
		PSRLD XMM0,XMM1
		PSRLD XMM0,mVar128
		PSRLD XMM0,8
		
		PSRLQ XMM0,XMM1
		PSRLQ XMM0,mVar128
		PSRLQ XMM0,8
		
		PSUBB XMM0,XMM1
		PSUBB XMM0,mVar128
		
		PSUBW XMM0,XMM1
		PSUBW XMM0,mVar128
		
		PSUBD XMM0,XMM1
		PSUBD XMM0,mVar128

		PSUBQ MM0,MM1
		PSUBQ MM0,mVar64
		PSUBQ XMM0,XMM1
		PSUBQ XMM0,mVar128
		
		PSUBSB XMM0,XMM1
		PSUBSB XMM0,mVar128
		
		PSUBSW XMM0,XMM1
		PSUBSW XMM0,mVar128
		
		PSUBUSB XMM0,XMM1
		PSUBUSB XMM0,mVar128
		
		PSUBUSW XMM0,XMM1
		PSUBUSW XMM0,mVar128
		
		PUNPCKHBW XMM0,XMM1
		PUNPCKHBW XMM0,mVar128
		
		PUNPCKHWD XMM0,XMM1
		PUNPCKHWD XMM0,mVar128
		
		PUNPCKHDQ XMM0,XMM1
		PUNPCKHDQ XMM0,mVar128
		
		PUNPCKHQDQ XMM0,XMM1
		PUNPCKHQDQ XMM0,mVar128
		
		PUNPCKLBW XMM0,XMM1
		PUNPCKLBW XMM0,mVar128
		
		PUNPCKLWD XMM0,XMM1
		PUNPCKLWD XMM0,mVar128
		
		PUNPCKLDQ XMM0,XMM1
		PUNPCKLDQ XMM0,mVar128
		
		PUNPCKLQDQ XMM0,XMM1
		PUNPCKLQDQ XMM0,mVar128
		
		PXOR XMM0,XMM1
		PXOR XMM0,mVar128
		
		CLFLUSH mVar8
		push eax
		lea eax, dword ptr arr
		CLFLUSH  [eax]
		pop eax
		
		LFENCE

		MASKMOVDQU XMM0,XMM1
		
		MFENCE

		MOVNTPD mVar128,XMM1
		MOVNTDQ mVar128,XMM1

		MOVNTI mVar32, eax

		PAUSE
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\dbga\main2.c ===
#include <windows.h>

#define IDM_EXIT  100

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM);
int MyPostMessage( HWND hwnd );
//extern int OtherMain();
extern void Cxx_Tests();

#if !defined( SAVELABEL )
#define SAVELABEL( l )	if (0) goto l
#endif

int PASCAL WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                         LPSTR lpszCmdLine, int nCmdShow)
{

     static char szAppName[] = "foo" ;
     HWND        hwnd ;
     MSG         msg ;
     WNDCLASS    wndclass ;

     if (!hPrevInstance)
          {
          wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
          wndclass.lpfnWndProc   = (WNDPROC) WndProc ;
          wndclass.cbClsExtra    = 0 ;
          wndclass.cbWndExtra    = 0 ;
          wndclass.hInstance     = hInstance ;
          wndclass.hIcon         = LoadIcon(NULL, IDI_APPLICATION); 
          wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW);
          wndclass.hbrBackground = GetStockObject (WHITE_BRUSH);
          wndclass.lpszMenuName  = szAppName ;  // MAC?
          wndclass.lpszClassName = szAppName ;

          RegisterClass (&wndclass) ;
          }

     hwnd = CreateWindowEx(
#if defined( _MAC )
					WS_EX_FORCESIZEBOX,
#else
					0,
#endif
     				szAppName,         // window class name
                    szAppName, 				// window caption
                    WS_OVERLAPPEDWINDOW,     // window style
                    CW_USEDEFAULT,           // initial x position
                    0, // CW_USEDEFAULT,           // initial y position
                    CW_USEDEFAULT,           // initial x size
                    0, // CW_USEDEFAULT,           // initial y size
                    NULL,                    // parent window handle
                    NULL,                    // window menu handle
                    hInstance,               // program instance handle
                    NULL) ;                  // creation parameters
     if (hwnd==0) {   //window not created
         return 1;
     }

     ShowWindow (hwnd, nCmdShow) ;
     UpdateWindow (hwnd) ;
     SendMessage( hwnd, WM_PAINT, (WORD)0, (DWORD)0);

     while (GetMessage (&msg, NULL, 0, 0))
          {
          TranslateMessage (&msg) ;
          DispatchMessage (&msg) ;
          }
     return msg.wParam ;
     }


LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
     {
     HDC         hdc ;
     PAINTSTRUCT ps ;
     RECT        rect ;
     static HINSTANCE hInst;
     static FARPROC pCB;
     int x;
	 static int y = -1;

	 SAVELABEL(TagCallOtherMain);
	 SAVELABEL(TagCreateCase);

     switch (message)
          {
          case WM_CREATE:
TagCreateCase: hInst= ((LPCREATESTRUCT) lParam)->hInstance;

               ////////////// MAKE TESTING CALLS HERE  /////////
TagCallOtherMain: // OtherMain();
			   Cxx_Tests();
               x = 0;
               return 0 ;

          case WM_PAINT:
               hdc = BeginPaint (hwnd, &ps) ;
               GetClientRect (hwnd, &rect) ;
               DrawText (hdc, "Hello, Windows!", -1, &rect,
                          DT_SINGLELINE | DT_CENTER | DT_VCENTER) ;
               EndPaint (hwnd, &ps) ;
              return 0 ;

#if defined( _MAC )
          case WM_SYSCOMMAND:
#endif
          case WM_COMMAND:        /* message: command from application menu */
               switch( wParam )
                  {
                  case IDM_EXIT:
                       DestroyWindow(hwnd);
                       break;
                  }
               break;

          case WM_DESTROY:
               PostQuitMessage (0) ;
               return 0 ;
#if !defined( _MAC )
           case WM_NULL:
               MyPostMessage(hwnd);
               return 0 ;
#endif
          }

     return DefWindowProc (hwnd, message, wParam, lParam) ;
}


int MyPostMessage( HWND hwnd )
{
    static int count = 0;

#if !defined( _MAC )
	SAVELABEL(TagPost);
					 
    if ( count < 5 )
    {
TagPost: PostMessage( hwnd, WM_PAINT, (WORD)0, (DWORD)0);
         PostMessage( hwnd, 0x0040, (WORD)0, (DWORD)0);
    }
    return count++;
#endif 

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\dllapp\dec.h ===
/*DOC***
**
** Suite : step
** Test  : dec.h
**
** Purpose : test Codeview stepping model
**
** General : stepping
** Primary : redirect
** Secondy : file comparison
**
** Dependencies : none (no screen dumps)
**
** Products : CV410
**
** Revision History :
**
** Mxxx	dd-Mon-yy	email name
** - description
** M000	28-Jun-92	waltcr
** - created
**
**
**
**DOC***/

#if defined( WIN32 )
#include <windows.h> 
#endif

void WINAPI Dec( LPWORD wBar );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\dllapp\dllapp.h ===
/*DOC***
**
** Suite : step
** Test  : dllapp.h
**
** Purpose : test Codeview stepping model
**
** General : stepping
** Primary : redirect
** Secondy : file comparison
**
** Dependencies : none (no screen dumps)
**
** Products : CV410
**
** Revision History :
**
** Mxxx	dd-Mon-yy	email name
** - description
** M000	28-Jun-92	waltcr
** - created
**
**
**
**DOC***/

#define IDM_EXIT  100
#define IDM_ABOUT 101

BOOL InitApplication(HINSTANCE);
BOOL InitInstance(HINSTANCE, int);
BOOL CenterWindow (HWND hwndChild, HWND hwndParent);

LONG APIENTRY MainWndProc(HWND, UINT, UINT, LONG);
BOOL APIENTRY About(HWND, UINT, UINT, LONG);
void BPWithLengthTest(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\dllapp\inc.h ===
/*DOC***
**
** Suite : step
** Test  : 
**
** Purpose : test Codeview stepping model
**
** General : stepping
** Primary : redirect
** Secondy : file comparison
**
** Dependencies : none (no screen dumps)
**
** Products : CV410
**
** Revision History :
**
** Mxxx	dd-Mon-yy	email name
** - description
** M000	28-Jun-92	waltcr
** - created
**
**
**
**DOC***/

#if defined( WIN32 )
#include <windows.h> 
#endif

void WINAPI Inc( LPWORD wBar );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\dllapp\pow.h ===
/*DOC***
**
** Suite : step
** Test  : 
**
** Purpose : test Codeview stepping model
**
** General : stepping
** Primary : redirect
** Secondy : file comparison
**
** Dependencies : none (no screen dumps)
**
** Products : CV410
**
** Revision History :
**
** Mxxx	dd-Mon-yy	email name
** - description
** M000	28-Jun-92	waltcr
** - created
**
**
**
**DOC***/

#if defined( WIN32 )
#include <windows.h> 
#endif

double WINAPI dPow( int base, int power);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\dllapp\dec2.c ===
/*DOC***
**
** Suite : bvt
** Test  : dec2.c
**
** Purpose : test Codeview stepping model
**
** General : stepping
** Primary : redirect
** Secondy : file comparison
**
** Dependencies : none (no screen dumps)
**
** Products : CV410
**
** Revision History :
**
** Mxxx	dd-Mon-yy	email name
** - description
** M000	28-Jun-92	waltcr
** - created
** M001 30-Jun-92	waltcr
** - add local var
**
**
**
**DOC***/

#if defined( WIN )
#include <windows.h>
#endif //WIN

#include "dec.h"
#include "inc.h"
#include "pow.h"
#include "cvtest.h"

typedef double (APIENTRY *PFNDLL)(int,int);

void WINAPI Dec( LPWORD wBar ) {

	WORD wLocal;
	HANDLE  hDLL;
	PFNDLL dpfnPow;
	double dValue;
	char sz[80];

SAVELABEL( TagDecRet );
SAVELABEL( TagAfterGetProcAddr );
SAVELABEL( TagCallPow );

	wLocal = ++(*wBar);
	--(*wBar);
	Inc(wBar);   // call another implib'd dll.

	/* do a loadlibrary of another dll from this dll */
	TagLoadLib: hDLL = LoadLibrary("POWDLL.DLL");
	if( hDLL != NULL )
	{
		dpfnPow = (PFNDLL) GetProcAddress(hDLL, "dPow");
TagAfterGetProcAddr:
		if (dpfnPow)
		{
TagCallPow:		dValue = dpfnPow( 10, 3 );
TagAfterPow:	dValue = dValue+1;
		}
		FreeLibrary(hDLL);
	}

TagDecRet: ; } /* Dec */


INT WINAPI DllEntryPoint(HANDLE hInst, ULONG ulRbc, LPVOID lpReserved) {
// ulRbc is Reason Being Called
	return 1;
} /* DllEntryPoint */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\dllapp\incdll.c ===
/*DOC***
**
** Suite : 
** Test  : incdll.c
**
** Purpose : test Codeview stepping model
**
** General : stepping
** Primary : redirect
** Secondy : file comparison
**
** Dependencies : none (no screen dumps)
**
** Products : CV410
**
** Revision History :
**
** Mxxx	dd-Mon-yy	email name
** - description
** M000	28-Jun-92	waltcr
** - created
** M001 30-Jun-92	waltcr
** - add local var
**
**
**
**DOC***/

#if defined( WIN )
#include <windows.h>
#endif //WIN

#include "inc.h"
#include "cvtest.h"

void WINAPI Inc( LPWORD wBar ) {

	WORD wLocal;

	wLocal = ++(*wBar);
	++(*wBar);

} /* Inc */


INT WINAPI DllMain(HMODULE hInst, DWORD ulRbc, LPVOID lpReserved) {
// ulRbc is Reason Being Called
	return 1;
} /* IncDllEntryPoint */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\dllapp\cvtest.h ===
/*
** cvtest.h - definitions/declarations for standard codeview testing
** Copyright (c) 1992-1992, Microsoft Corporation. All rights reserved.
**
**Purpose:
**	This file defines the structures, values, macros, and functions
**	used by the codeview tests.
**
**
*/

#if !defined( _INC_CVTEST )

#define CVMAXMSG (80)

#if !defined CDECL 
#define CDECL _cdecl
#endif

#if !defined FASTCALL
#define FASTCALL _fastcall
#endif

#if !defined( SAVELABEL )
#define SAVELABEL( l )	if (0) goto l
#endif

/* prototypes */
void InitCVTest( void );
void EndCVTest( void );
int ChkEQ( int x, int y);
int ChkTrue( int x );
int ChkFalse( int x );
char *PrintIsFalse( int );
char *PrintIsTrue( int );
char *PrintIsEqual( int, int );

#define _INC_CVTEST
#endif	/* _INC_CVTEST */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\dllapp\dllappx.c ===
/*DOC***
**
** Suite : bvt
** Test  : dllappx.c
**
** Purpose : test Codeview stepping model
**
** General : stepping
** Primary : redirect
** Secondy : file comparison
**
** Dependencies : none (no screen dumps)
**
** Products : CV410
**
** Revision History :
**
** Mxxx dd-Mon-yy       email name
** - description
** M000 28-Jun-92       waltcr
** - created
**
**
**
**DOC***/

#include <windows.h>   // required for all Windows applications
#include "dllapp.h"   // specific to this program
#include "dec.h"
#include "cvtest.h"

HINSTANCE hInst;        /* current instance */

char szAppName[] = "DllApp";
char szTitle[]   = "DllApp"; // The title bar text
int gi[5] = {0, 0, 0, 0, 0}; // some data for testing


/***
** for testing
*/

WORD   wValue = 10;
HANDLE hGlobalMem = NULL;
LPSTR  lpstr;

/***
**
**      FUNCTION: WinMain(HINSTANCE, HINSTANCE, LPSTR, int)
**
**      PURPOSE: calls initialization function, processes message loop
**
**      COMMENTS:
**
**              Windows recognizes this function by name as the initial entry point
**              for the program.  This function calls the application initialization
**              routine, if no other instance of the program is running, and always
**              calls the instance initialization routine.      It then executes a message
**              retrieval and dispatch loop that is the top-level control structure
**              for the remainder of execution.  The loop is terminated when a WM_QUIT
**              message is received, at which time this function exits the application
**              instance by returning the value passed by PostQuitMessage().
**
**              If this function must abort before entering the message loop, it
**              returns the conventional value NULL.
**
*/

int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
	MSG msg;        /* message */

	if (!hPrevInstance)             /* Other instances of app running? */
		if (!InitApplication(hInstance))        /* Initialize shared things */
			return (FALSE);         /* Exits if unable to initialize */

	/* Perform initializations that apply to a specific instance */
	if (!InitInstance(hInstance, nCmdShow))
		return (FALSE);

	/* Acquire and dispatch messages until a WM_QUIT message is received. */
	while (GetMessage(&msg,         /* message structure */
		NULL,   /* handle of window receiving the message */
		0,   /* lowest message to examine    */
		0))  /* highest message to examine   */
	{
		TranslateMessage(&msg);         /* Translates virtual key codes           */
		DispatchMessage(&msg);          /* Dispatches message to window           */
	}
	return (msg.wParam);            /* Returns the value from PostQuitMessage */
}


/***
**
**      FUNCTION: InitApplication(HANDLE)
**
**      PURPOSE: Initializes window data and registers window class
**
**      COMMENTS:
**
**              This function is called at initialization time only if no other
**              instances of the application are running.  This function performs
**              initialization tasks that can be done once for any number of running
**              instances.
**
**              In this case, we initialize a window class by filling out a data
**              structure of type WNDCLASS and calling the Windows RegisterClass()
**              function. Since all instances of this application use the same window
**              class, we only need to do this when the first instance is initialized.
**
**
*/

BOOL InitApplication(HINSTANCE hInst) {
	WNDCLASS  wc;

	/* Fill in window class structure with parameters that describe the
		main window. */

	wc.style = 0;                                /* Class style(s) */
	wc.lpfnWndProc = MainWndProc;   /* Func to retrieve msgs for  */
									/* windows of this class */
	wc.cbClsExtra = 0;                              /* No per-class extra data */
	wc.cbWndExtra = 0;                              /* No per-window extra data */
	wc.hInstance = hInst;               /* Application that owns the class */
	wc.hIcon = LoadIcon(hInst, szAppName); // Icon name from .rc
	wc.hCursor = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = GetStockObject(WHITE_BRUSH);
	wc.lpszMenuName =  szAppName;   /* Name of menu resource in .RC file. */
	wc.lpszClassName = szAppName;   /* Name used in call to CreateWindow. */

	/* Register the window class and return success/failure code. */
	return (RegisterClass(&wc));
}

/***
**
**      FUNCTION:  InitInstance(HANDLE, int)
**
**      PURPOSE:  Saves instance handle and creates main window
**
**      COMMENTS:
**
**              This function is called at initialization time for every instance of
**              this application.  This function performs initialization tasks that
**              cannot be shared by multiple instances.
**
**              In this case, we save the instance handle in a static variable and
**              create and display the main program window.
**        
*/

BOOL InitInstance(HINSTANCE hInstance, int nCmdShow) {
	HWND    hWnd;   /* Main window handle */

	/* Save the instance handle in static variable, which will be used in
	   many subsequent calls from this application to Windows.      */

	hInst = hInstance;

	/* Create a main window for this application instance.  */

	hWnd = CreateWindow(
		szAppName,      /* See RegisterClass() call */
		szTitle,        /* Text for window title bar */
		WS_OVERLAPPEDWINDOW,    /* Window style */
		CW_USEDEFAULT,  /* Default horizontal position */
		CW_USEDEFAULT,  /* Default vertical position */
		CW_USEDEFAULT,  /* Default width */
		CW_USEDEFAULT,  /* Default height */
		NULL,   /* Overlapped windows have no parent */
		NULL,   /* Use the window class menu */
		hInstance,      /* This instance owns this window */
		NULL    /* Pointer not needed */
    );

	/* If window could not be created, return "failure" */

	if (!hWnd)
		return (FALSE);

	/* Make the window invisible; update its client area; and return "success" */

	ShowWindow(hWnd, SW_HIDE);             /* Show the window */
	UpdateWindow(hWnd);     /* Sends WM_PAINT message */
	SendMessage(hWnd, WM_NULL, 0, 0);
	return (TRUE);  /* Returns the value from PostQuitMessage */
}

/***
**
**      FUNCTION: MainWndProc(HWND, UINT, UINT, LONG)
**
**      PURPOSE:  Processes messages
**
**      MESSAGES:
**
**              WM_COMMAND        - application menu (About dialog box)
**              WM_DESTROY        - destroy window
**
**      COMMENTS:
**
**              To process the IDM_ABOUT message, call MakeProcInstance() to get the
**              current instance address of the About() function.  Then call Dialog
**              box which will create the box according to the information in your
**              DllApp.rc file and turn control over to the About() function.   When
**              it returns, free the intance address.
**
*/

LONG APIENTRY MainWndProc(HWND hWnd, UINT message, UINT wParam, LONG lParam) {
	FARPROC lpProcAbout;              /* pointer to the "About" function */

    HDC         hdc ;
    PAINTSTRUCT ps ;
	RECT            rect ;

	SAVELABEL( CALLDLLATSTART );
	SAVELABEL( CALLDLLATTERM );
	SAVELABEL( TagEndPaint );

	switch (message)
	{
		case WM_COMMAND:        /* message: command from application menu */
			switch( wParam )
			{
				case IDM_ABOUT:
					lpProcAbout = MakeProcInstance(About, hInst);
	
					DialogBox(hInst,                 /* current instance             */
						"AboutBox",                      /* resource to use              */
						hWnd,                    /* parent handle                */
						lpProcAbout);            /* About() instance address */
		
					FreeProcInstance(lpProcAbout);
					break;
	
				case IDM_EXIT:
					DestroyWindow(hWnd);
					break;
			}
			break;

		case WM_NULL:
TagEndPaint:return 0 ;
			break;	

		case WM_PAINT:
			hdc = BeginPaint (hWnd, &ps) ;
			GetClientRect (hWnd, &rect) ;
			DrawText (hdc, "DLL Application", -1, &rect,
				DT_SINGLELINE | DT_CENTER | DT_VCENTER);
			EndPaint (hWnd, &ps) ;
			return 0;
			break;

		case WM_CREATE:

			// a func call for testing purposes
CALLDLLATSTART:
			Dec( &wValue );

			/*
			** some arbitrary code for testing purposes
			*/
			if ( hGlobalMem = GlobalAlloc( GMEM_MOVEABLE, 100L ) )
			{
				if ( lpstr = GlobalLock( hGlobalMem ) )
				{
					lstrcpy( lpstr, "The Walt-Meister" );
					GlobalUnlock( hGlobalMem );
					// TODO: check return code?
					//
					//  You can display the contents of the string with the 
					//  following sequence of codeview commands:
					// 
					//  >wgh hGlobalMem
					//  0192:6E30
					//  >? *(char far*) 0x0192:0x6E30,s
				}
			}


			BPWithLengthTest();

			break;
	
		case WM_DESTROY:                  /* message: window being destroyed */
			// a func call for testing purposes
CALLDLLATTERM:
			Dec( &wValue );
			if (hGlobalMem)
				GlobalFree(hGlobalMem);
				// TODO: check return code ?
			PostQuitMessage(0);
			break;

		default:                          /* Passes it on if unproccessed        */
			return (DefWindowProc(hWnd, message, wParam, lParam));
	}
	return 0;
}

/***
**
**      FUNCTION: About(HWND, UINT, UINT, LONG)
**
**      PURPOSE:  Processes messages for "About" dialog box
**
**      MESSAGES:
**
**              WM_INITDIALOG - initialize dialog box
**              WM_COMMAND        - Input received
**
**      COMMENTS:
**
**              No initialization is needed for this particular dialog box, but TRUE
**              must be returned to Windows.
**
**              Wait for user to click on "Ok" button, then close the dialog box.
**
*/

BOOL APIENTRY About(HWND hDlg, UINT message, UINT wParam, LONG lParam) {
	switch (message)
	{
		case WM_INITDIALOG:             /* message: initialize dialog box */
		{
			/*
			** some arbitrary code for testing
			*/
			HANDLE hLocalMem = NULL;
			int i;
			char *   pMem;
			char *   pTmp;
			if ( hLocalMem = LocalAlloc( LMEM_MOVEABLE, 100 ) );
			{
				if (pMem = LocalLock( hLocalMem ));
				{
					/* now locked, so mucked with it */
					pTmp = pMem;
					for (i=0; i<20; i++)
					{
						*pTmp = 'w';
						++pTmp;
					}
					LocalUnlock( hLocalMem );
					// TODO: check return code ?
					}
			}
		 
			//  Now, after setting a breakpoint immediately after the call to LocalLock,
			//  the following command displays the array location:
			// 
			//  >dw pnArray
			// 
			//  Outside of this fragment, though, you cannot rely on the value of the
			//  pnArray variable since the actual data in the memory object may move.
			//  Therefore, use the following sequence to display the correct array
			//  location:
			//  >wlh hLocalMem 
			//  0192:100A
			//  dw 0192:100A

			if ( hLocalMem )
				LocalFree( hLocalMem );  //TODO: check return code ?

			CenterWindow (hDlg, GetWindow (hDlg, GW_OWNER));
			return (TRUE);
			break;
		}

		case WM_COMMAND:        /* message: received a command */
			if (wParam == IDOK || wParam == IDCANCEL)
			{
				EndDialog(hDlg, TRUE);  /* Exits the dialog box */
				return (TRUE);
			}
			break;
	}
	return (FALSE);         /* Didn't process a message */
}

/***
**
**      FUNCTION: CenterWindow (HWND, HWND)
**
**      PURPOSE:  Center one window over another
**
**      COMMENTS:
**
**      Used to center the "About" box over application window
**      Dialog boxes take on the screen position that they were designed at,
**      which is not always appropriate. Centering the dialog over a particular
**      window usually results in a better position.
**
**      Used to center the "About" box over application window.
**
*/

BOOL CenterWindow (HWND hwndChild, HWND hwndParent)
{
	RECT    rChild, rParent;
	int     wChild, hChild, wParent, hParent;
	int     wScreen, hScreen, xNew, yNew;
	HDC     hdc;

	// Get the Height and Width of the child window
	GetWindowRect (hwndChild, &rChild);
	wChild = rChild.right - rChild.left;
	hChild = rChild.bottom - rChild.top;

	// Get the Height and Width of the parent window
	GetWindowRect (hwndParent, &rParent);
	wParent = rParent.right - rParent.left;
	hParent = rParent.bottom - rParent.top;

	// Get the display limits
	hdc = GetDC (hwndChild);
	wScreen = GetDeviceCaps (hdc, HORZRES);
	hScreen = GetDeviceCaps (hdc, VERTRES);
	ReleaseDC (hwndChild, hdc);

	// Calculate new X position, then adjust for screen
	xNew = rParent.left + ((wParent - wChild) /2);
	if (xNew < 0) {
		xNew = 0;
	} else if ((xNew+wChild) > wScreen) {
		xNew = wScreen - wChild;
	}

	// Calculate new Y position, then adjust for screen
	yNew = rParent.top  + ((hParent - hChild) /2);
	if (yNew < 0) {
		yNew = 0;
	} else if ((yNew+hChild) > hScreen) {
		yNew = hScreen - hChild;
	}

	// Set it, and return
	return SetWindowPos (hwndChild, NULL,
		xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
}


void BPWithLengthTest(void)
{
	START:  
	gi[4]=99;
	gi[2]=99;  // breakpoint should fire for this line/instruction, but stop on the next line/instruction
	BREAK:     // tagged with the BREAK label
	gi[2]=0; gi[3]=99;  
	END:
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\ee\base1.h ===
class base1
{
protected:
	// inherited member variable.
	int base1_var;
public:
	base1(void){base1_var = 1;}
	int base1_func(int i);
	virtual int base1_virtual_func(int i);
	int base1_overloaded_func(int i);
	int base1_overridden_func(int i);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\ee\base2.h ===
class base2
{
protected:
	int base2_var;
public:
	base2(void){base2_var = 2;}
	// inherited, non-overloaded, non-overridden member function
	int base2_func(int i);
	virtual int base2_virtual_func(int i);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\ee\base2.cpp ===
#include "base2.h"

// inherited, non-overloaded, non-overridden member function
int base2::base2_func(int i)
{
	return base2_var + i;
}

int base2::base2_virtual_func(int i)
{
	return base2_var + i;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\ee\base1.cpp ===
#include "base1.h"

int base1::base1_func(int i)
{
	return base1_var + i;
}

int base1::base1_virtual_func(int i)
{
	return base1_var + i;
}

int base1::base1_overloaded_func(int i)
{
	return base1_var + i;
}

int base1::base1_overridden_func(int i)
{
	return base1_var + i;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\dllapp\powdll.c ===
/*DOC***
**
** Suite : 
** Test  : 
**
** Purpose : test Codeview stepping model
**
** General : stepping
** Primary : redirect
** Secondy : file comparison
**
** Dependencies : none (no screen dumps)
**
** Products : CV410
**
** Revision History :
**
** Mxxx	dd-Mon-yy	email name
** - description
** M000	28-Jun-92	waltcr
** - created
** M001 30-Jun-92	waltcr
** - add local var
**
**
**
**DOC***/

#if defined( WIN )
#include <windows.h>
#endif //WIN

#include "dec.h"
#include "pow.h"
#include "cvtest.h"

double WINAPI dPow(int base, int power) {
	
	int i;
	double result;
	/* note: don't handle zero's */
	if (power==0)
		return 1;
	if (base==0)
		return 0;
	for (result=base,i=1;i<power;i++)
		result *= base;

	return result;
} /* pow */


INT WINAPI DllMain(HMODULE hInst, DWORD ulRbc, LPVOID lpReserved) {
// ulRbc is Reason Being Called
	return 1;
} /* DllMain */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\ee\derived1.cpp ===
#include "derived1.h"

int derived1::derived1_static_var = 1;

derived1::derived1(void)
{
	derived1_public_var = base1_var + base2_var;
	enum_class_var = two_class;
	derived1_private_var = derived1_public_var + 1;
	derived1_protected_var = derived1_private_var + 1;
}

// non-inherited, non-overloaded member function.
int derived1::derived1_public_func(int i)
{
	return derived1_public_var + i;
}

// virtual inherited non-overloaded, overridden member function
int derived1::base1_virtual_func(int i)
{
	return derived1_public_var + i;
}

/*
int derived1::derived1_static_func(int i)
	{
	return derived_static_var + i;
	}
*/

// inherited, overloaded, non-overridden member function
int derived1::base1_overloaded_func(char ch)
{
	return derived1_public_var + ch;
}

// inherited, non-overloaded, overridden member function
int derived1::base1_overridden_func(int i)
{
	return derived1_public_var + i;
}

// protected member function.
int derived1::derived1_protected_func(int i)
{
	return derived1_public_var + i;
}

// private member function.
int derived1::derived1_private_func(int i)
{
	return derived1_public_var + i;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\ee\dll.cpp ===
#include "dll.h"

dll_class::dll_class(void)
{
	dll_class_var = 0;
}

int dll_class::dll_class_func(int i)
{
	dll_class_var = i;
	return dll_class_var;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\ee\derived1.h ===
#include "base1.h"
#include "base2.h"

class derived1 : public base1, public base2
{
private:
	// private member variable.
	int derived1_private_var;
	// private member function.
	int derived1_private_func(int i);
protected:
	// protected member variable.
	int derived1_protected_var;
	// protected member function.
	int derived1_protected_func(int i);
public:
	// public member variable.
	int derived1_public_var;
	// class-nested enum.
	enum enum_class {one_class = 1, two_class, three_class};
	// declaration of class-nested enum var.
	enum_class enum_class_var;
	// static member variable.
	static int derived1_static_var;
	derived1(void);
	// non-inherited, non-overloaded member function.
	// public member function.
	int derived1_public_func(int i);
	// virtual inherited non-overloaded, overridden member function
	virtual int base1_virtual_func(int i);
	//static int derived1_static_func(int i);
	// inherited, overloaded, non-overridden member function
	int base1_overloaded_func(char ch);
	// inherited, non-overloaded, overridden member function
	int base1_overridden_func(int i);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\ee\global.h ===
// global variable.
extern int global_var;

// enum (defined in header).
enum enum1{one = 1, two, three};

// non-overloaded global function.
int global_func(int i);
// overloaded global function.
int overloaded_global_func(int i);
char overloaded_global_func(char ch);
// inline function (defined in header).
inline int inline_func(int i){return global_var + i;};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\ee\global.cpp ===
#include "global.h"

// global variable.
int global_var = 0;

// non-overloaded global function.
int global_func(int i)
{
	return global_var + i;
}

// over-loaded global function.
int overloaded_global_func(int i)
{
	return global_var + i;
}

char overloaded_global_func(char ch)
{
	return global_var + ch;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\ee\pch.cpp ===
#include "pch.h"

class_pch::class_pch(void)
	{
	class_pch_var = 0;
	}

int class_pch::class_pch_func(int i)
	{
	class_pch_var = i;
	return class_pch_var;
	}

struct_pch::struct_pch(void)
	{
	struct_pch_var = 0;
	}

int struct_pch::struct_pch_func(int i)
	{
	struct_pch_var = i;
	return struct_pch_var;
	}

union_pch::union_pch(void)
	{
	union_pch_var = 0;
	}

int union_pch::union_pch_func(int i)
	{
	union_pch_var = i;
	return union_pch_var;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\ee\pch.h ===
// classed declared in .pch file.
class class_pch
	{
	private:
		int class_pch_var;
	public:
		class_pch(void);
		int class_pch_func(int i);
	};

// struct declared in .pch file.
struct struct_pch
	{
	private:
		int struct_pch_var;
	public:
		struct_pch(void);
		int struct_pch_func(int i);
	};

// union declared in .pch file.
union union_pch
	{
	private:
		int union_pch_var;
	public:
		union_pch(void);
		int union_pch_func(int i);
	};

// enum decalred in a .pch file.
enum enum_pch {one_pch = 1, two_pch, three_pch};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\ee\dll.h ===
// class defined in dll
class dll_class
{
private:
	int dll_class_var;
public:
	__declspec(dllexport) dll_class(void);
	__declspec(dllexport) int dll_class_func(int i);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\ee\union1.h ===
// union (declared in header)
union union1
		{
		private:
			int union1_var;
		public:
			union1(void);
			int union1_func(int i);
		};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\ee\struct1.cpp ===
#include "struct1.h"

struct1::struct1(void)
	{
	struct1_var = 0;
	}

int struct1::struct1_func(int i)
	{
	struct1_var = i;
	return struct1_var;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\ee\struct1.h ===
// struct (declared in header)
struct struct1
		{
		private:
			int struct1_var;
		public:
			struct1(void);
			int struct1_func(int i);
		};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\ee\union1.cpp ===
#include "union1.h"

union1::union1(void)
	{
	union1_var = 0;
	}

int union1::union1_func(int i)
	{
	union1_var = i;
	return union1_var;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\execution pri1\execution pri1 exe.cpp ===
// first line of source file


#include <windows.h>


LPARAM CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);


int gintVar = 0;
int gintDenominator = 1;
HWND ghWnd;


void Func(void)

{	// first line of Func().

	gintVar = 1;
	while(0);	// line after expression bp hit.
}


void FuncCalledIndirectly(void)
{	// first line of FuncCalledIndirectly().
}


int InnerFunc(void)
{	// first line of InnerFunc().
	return 0;
}


void OuterFunc(int i)
{	// first line of OuterFunc().
}


void SendMessageFunc(void)
{	// first line of SendMessageFunc().
	SendMessage(ghWnd, WM_NULL, 0, 0);
}


int FAR PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)

{	// first line of WinMain().

	while(0);	// second line of WinMain().

	Func();
	while(0);	// line after call to Func().

	void (*pFuncCalledIndirectly)(void) = FuncCalledIndirectly;
	pFuncCalledIndirectly();

	OuterFunc(InnerFunc());

	_asm
	{
		push eax
		pop eax
	}

	int i = 1 / gintDenominator;

	WNDCLASS wndclass;
	wndclass.style = 0;
	wndclass.lpfnWndProc = WndProc;
	wndclass.cbClsExtra = 0;
	wndclass.cbWndExtra = 0;
	wndclass.hInstance = hInstance;
	wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
	wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
	wndclass.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
	wndclass.lpszMenuName = NULL;
	wndclass.lpszClassName = "exepri1";
	RegisterClass(&wndclass);

	ghWnd = CreateWindow("exepri1", "exepri1", WS_OVERLAPPEDWINDOW, 
						 CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 
						 NULL, NULL, hInstance, NULL);

	SendMessageFunc();
	
	while(1);	// loop line.
	
	return 0;	// return from WinMain().
}


LPARAM CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
	
{	// first line of WndProc().
	switch(msg)
	{	
		case WM_NULL:
			return 0;
		case WM_DESTROY:
			PostQuitMessage(0);
			break;
	}

	return DefWindowProc(hwnd, msg, wParam, lParam);
}



/* 
START: for tests that require scrolling code out of view.












































END: for tests that require scrolling code out of view.
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\ExprEval PP\ExprEval PP.cpp ===
#include <windows.h>

const float FLOAT_ZERO = 0;
__int64 GlobalInt64 = 0;

__int64 FloatVal[] =	//	32 bit register values for each integer
{
3225419779,		//	-3
3221225474,		//	-2	
3212836866,		//	-1
0,				//	0
1065353218,		//	1
1073741826,		//	2
1077936131,		//	3
1082130434,		//	4
1084227586,		//	5
1086324738,		//	6
1088421890,		//	7	
1090519041,		//	8
1091567617,		//	9
1092616193		//	10
};

const int FLOATVAL_BASE = -3;
__m128 Var128;

void ClearXMMReg(int regid);
void set_GlobalInt64(int Hi, int Low);
void set_XMMRegister(int regid, char upper, int Hi, int Low);
void set_XMMRegister(int regid, int X3, int X2, int X1, int X0);

void set_Register(int regid, __int64 regval);
void test_MMX();
void test_3dNow();
void test_3dNowEnhanced();
void test_Katmai();

/*************************************************************************************************
*
*	WinMain()
*
*************************************************************************************************/

int FAR PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)
{
	
	//	3d Now! register tests
	test_MMX();
	test_3dNow();
	test_3dNowEnhanced();
	test_Katmai();

	return 0;
}


/********************************************
*
*	3d Now! - function to set a MMi register
*
*********************************************/

void set_Register(int regid, __int64 regval)
{
	switch (regid)
	{
		case 0:		__asm { MOVQ MM0, regval }
					break;


		case 1:		__asm { MOVQ MM1, regval }
					break;


		case 2:		__asm { MOVQ MM2, regval }
					break;

		case 3:		__asm { MOVQ MM3, regval }
					break;


		case 4:		__asm { MOVQ MM4, regval }
					break;

		case 5:		__asm { MOVQ MM5, regval }
					break;

		case 6:		__asm { MOVQ MM6, regval }
					break;

		case 7:		__asm { MOVQ MM7, regval }
					break;

	}
}

void test_MMX()
{
	//	MMX tests
	
	__int64 count = 0;

	//	test all registers for operability
	count = 1000; 		__asm {	MOVQ MM0,count }
	count = 2000; 		__asm {	MOVQ MM1,count }
	count = 3000; 		__asm {	MOVQ MM2,count }
	count = 4000; 		__asm {	MOVQ MM3,count }
	count = 5000; 		__asm {	MOVQ MM4,count }
	count = 6000; 		__asm {	MOVQ MM5,count }
	count = 7000; 		__asm {	MOVQ MM6,count }
	count = 8000; 		__asm {	MOVQ MM7,count }

	//	shift left
	set_Register(0,400);	count = 2; 	__asm {	PSLLW MM0,count }
	set_Register(0,9);		count = 6; 	__asm {	PSLLW MM0,count }	


	//	mov 32 bit
	count = 123456789; 		__asm {	MOVD MM0,count }	

	count = 4294967296; 	__asm {	MOVD MM0,count }	//	32 bits	
	count = 4294967295; 	__asm {	MOVD MM0,count }	//	32 bits - 1
	count = 4294967297; 	__asm {	MOVD MM0,count }	//	32 bits + 1
	count = 8589934592; 	__asm {	MOVD MM0,count }	//	33 bits


	count = 123456789; 		__asm {	MOVQ MM0,count }
	count = 4294967296; 	__asm {	MOVQ MM0,count }	
	count = 4294967295; 	__asm {	MOVQ MM0,count }	
	count = 4294967297; 	__asm {	MOVQ MM0,count }	
	count = 8589934592; 	__asm {	MOVQ MM0,count }	

	
	//	Pack with Signed Saturation
	set_Register(0,1);	count = 1; 	__asm {	PACKSSWB MM0,count }
	set_Register(0,1);	count = 1; 	__asm {	PACKSSDW MM0,count }

	//	Pack with Unsigned Saturation	
	set_Register(0,1);	count = 1; 	__asm {	PACKUSWB MM0,count }

	//	Packed Add
	set_Register(0,100);	count = 1; 	__asm {	PADDB MM0,count }
	set_Register(0,127);	count = 127; 	__asm {	PADDB MM0,count }
	set_Register(0,128);	count = 128; 	__asm {	PADDB MM0,count }
	set_Register(0,256);	count = 256; 	__asm {	PADDB MM0,count }

	set_Register(0,100);	count = 1; 	__asm {	PADDW MM0,count }
	set_Register(0,65535);	count = 1; 	__asm {	PADDW MM0,count }
	set_Register(0,65536);	count = 65536; 	__asm {	PADDW MM0,count }
	
	set_Register(0,100);	count = 1; 	__asm {	PADDD MM0,count }
	set_Register(0,1);	count = 4294967295; 	__asm {	PADDD MM0,count }
	set_Register(0,4294967296);	count = 4294967296; 	__asm {	PADDD MM0,count }

	//	Packed Add with Saturation
	set_Register(0,150);	count = 100; 	__asm {	PADDSB MM0,count }
	set_Register(0,65470);	count = 100; 	__asm {	PADDSW MM0,count }

	//	Packed Add Unsigned with Saturation 
	set_Register(0,200);	count = 100; 	__asm {	PADDUSB MM0,count }
	set_Register(0,65530);	count = 100; 	__asm {	PADDUSW MM0,count }

	//	Bitwise Logical And 
	set_Register(0,256);	count = 32; 	__asm {	PAND MM0,count }
	set_Register(0,255);	count = 15; 	__asm {	PAND MM0,count }

	//	Bitwise Logical And Not 
	set_Register(0,15);	count = 15; 	__asm {	PANDN MM0,count }
	set_Register(0,1);	count = 15; 	__asm {	PANDN MM0,count }

	//	Bitwise Logical Or
	set_Register(0,64);	count = 15; 	__asm {	POR MM0,count }

	//	Compare for Equal 
	set_Register(0,400);	count = 100; 	__asm {	PCMPEQB MM0,count }
	set_Register(0,200);	count = 100; 	__asm {	PCMPEQB MM0,count }
	set_Register(0,120);	count = 120; 	__asm {	PCMPEQB MM0,count }

	set_Register(0,400);	count = 100; 	__asm {	PCMPEQW MM0,count }
	set_Register(0,120);	count = 120; 	__asm {	PCMPEQW MM0,count }
	
	set_Register(0,400);	count = 100; 	__asm {	PCMPEQD MM0,count }
	set_Register(0,120);	count = 120; 	__asm {	PCMPEQD MM0,count }

	//	Compare for Greater Than
	set_Register(0,200);	count = 100; 	__asm {	PCMPGTB MM0,count }
	set_Register(0,127);	count = 100; 	__asm {	PCMPGTB MM0,count }
	set_Register(0,128);	count = 127; 	__asm {	PCMPGTB MM0,count }
	set_Register(0,127);	count = 128; 	__asm {	PCMPGTB MM0,count }	
	set_Register(0,256);	count = 0; 		__asm {	PCMPGTB MM0,count }
	set_Register(0,350);	count = 100; 		__asm {	PCMPGTB MM0,count }
	
	set_Register(0,400);	count = 100; 	__asm {	PCMPGTW MM0,count }
	set_Register(0,65536);	count = 0; 		__asm {	PCMPGTW MM0,count }
	
	set_Register(0,400);	count = 100; 	__asm {	PCMPGTD MM0,count }
	set_Register(0,4294967296);	count = 0; 	__asm {	PCMPGTD MM0,count }

	//	Packed Multiply and Add 
	set_Register(0,5);	count = 260; 	__asm {	PMADDWD MM0,count }
	set_Register(0,65536);	count = 65536; 	__asm {	PMADDWD MM0,count }

	//	Packed Multiply High
	set_Register(0,400);	count = 100; 	__asm {	PMULHW MM0,count }
	set_Register(0,6556);	count = 10; 	__asm {	PMULHW MM0,count }

	//	Packed Multiply Low
	set_Register(0,6556);	count = 10; 	__asm {	PMULLW MM0,count }
	set_Register(0,655);	count = 10; 	__asm {	PMULLW MM0,count }

	//	Packed Shift Left Logical
	set_Register(0,23);	count = 4; 	__asm {	PSLLW MM0,count }
	set_Register(0,65537);	count = 1; 	__asm {	PSLLW MM0,count }
	set_Register(0,2147483648);	count = 1; 	__asm {	PSLLW MM0,count }
	
	set_Register(0,23);	count = 4; 	__asm {	PSLLD MM0,count }
	set_Register(0,2147483649);	count = 1; 	__asm {	PSLLD MM0,count }
	set_Register(0,4294967296);	count = 1; 	__asm {	PSLLD MM0,count }
	set_Register(0,2147483648);	count = 1; 	__asm {	PSLLD MM0,count }
	
	set_Register(0,23);	count = 4; 	__asm {	PSLLQ MM0,count }

	//	Packed Shift Right Arithmetic
	set_Register(0,400);	count = 3; 		__asm {	PSRAW MM0,count }
	set_Register(0,5);		count = 3; 		__asm {	PSRAW MM0,count }
	set_Register(0,65538);	count = 1; 		__asm {	PSRAW MM0,count }
	set_Register(0,65536);	count = 1; 		__asm {	PSRAW MM0,count }
	set_Register(0,65537);	count = 1; 		__asm {	PSRAW MM0,count }
	
	set_Register(0,400);	count = 3; 		__asm {	PSRAD MM0,count }
	set_Register(0,5);	count = 3; 		__asm {	PSRAD MM0,count }
	set_Register(0,4294967298);	count = 1; 		__asm {	PSRAD MM0,count }
	set_Register(0,4294967296);	count = 1; 		__asm {	PSRAD MM0,count }
	set_Register(0,4294967297);	count = 1; 		__asm {	PSRAD MM0,count }
	
	//	Packed Shift Right Logical
	set_Register(0,256);	count = 4; 		__asm {	PSRLW MM0,count }
	set_Register(0,6);		count = 4; 		__asm {	PSRLW MM0,count }
	set_Register(0,65536);	count = 1; 		__asm {	PSRLW MM0,count }
	set_Register(0,65537);	count = 1; 		__asm {	PSRLW MM0,count }
	set_Register(0,65538);	count = 1; 		__asm {	PSRLW MM0,count }
	
	set_Register(0,256);	count = 4; 		__asm {	PSRLD MM0,count }
	set_Register(0,10);	count = 4; 		__asm {	PSRLD MM0,count }
	set_Register(0,4294967296);	count = 1; 		__asm {	PSRLD MM0,count }
	set_Register(0,4294967298);	count = 1; 		__asm {	PSRLD MM0,count }
	set_Register(0,4294967297);	count = 1; 		__asm {	PSRLD MM0,count }
	
	set_Register(0,256);	count = 4; 		__asm {	PSRLQ MM0,count }
	set_Register(0,15);		count = 4; 		__asm {	PSRLQ MM0,count }
//	set_Register(0,18446744073709551616);	count = 1; 	__asm {	PSLLQ MM0,count }
//	set_Register(0,18446744073709551617);	count = 1; 	__asm {	PSLLQ MM0,count }
//	set_Register(0,18446744073709551618);	count = 1; 	__asm {	PSLLQ MM0,count }
	
	//	Packed Subtract
	set_Register(0,240);	count = 100; 	__asm {	PSUBB MM0,count }
	set_Register(0,340);	count = 100; 	__asm {	PSUBB MM0,count }
	set_Register(0,65736);	count = 100; 	__asm {	PSUBB MM0,count }
	
	set_Register(0,400);	count = 100; 	__asm {	PSUBW MM0,count }
	set_Register(0,65750);	count = 100; 	__asm {	PSUBW MM0,count }
	set_Register(0,4294967496);	count = 100; 	__asm {	PSUBW MM0,count }
	set_Register(0,4294967390);	count = 100; 	__asm {	PSUBW MM0,count }

	set_Register(0,400);	count = 100; 	__asm {	PSUBD MM0,count }
	set_Register(0,4294967496);	count = 100; 	__asm {	PSUBD MM0,count }
//	set_Register(0,18446744073709551816);	count = 100; 	__asm {	PSUBD MM0,count }
	
	//	Packed Subtract with Saturation
	set_Register(0,240);	count = 100; 	__asm {	PSUBSB MM0,count }
	set_Register(0,400);	count = 100; 	__asm {	PSUBSB MM0,count }
	set_Register(0,65736);	count = 100; 	__asm {	PSUBSB MM0,count }
	
	set_Register(0,400);	count = 100; 	__asm {	PSUBSW MM0,count }
	set_Register(0,65750);	count = 100; 	__asm {	PSUBSW MM0,count }
	set_Register(0,4294967496);	count = 100; 	__asm {	PSUBSW MM0,count }

	//	Packed Subtract Unsigned with Saturation
	set_Register(0,240);	count = 100; 	__asm {	PSUBUSB MM0,count }	//	all "correct" values
	set_Register(0,400);	count = 100; 	__asm {	PSUBUSB MM0,count }
	set_Register(0,65736);	count = 100; 	__asm {	PSUBUSB MM0,count }
	
	set_Register(0,400);	count = 100; 	__asm {	PSUBSW MM0,count }
	set_Register(0,65750);	count = 100; 	__asm {	PSUBSW MM0,count }
	set_Register(0,4294967496);	count = 100; 	__asm {	PSUBSW MM0,count }

	
	//	Unpack High Packed Data
	set_Register(0,1);	count = 400; 	__asm {	PUNPCKHBW MM0,count }
	set_Register(0,1);	count = 24600; 	__asm {	PUNPCKHBW MM0,count }
	set_Register(0,1);	count = 4294967496; 	__asm {	PUNPCKHBW MM0,count }
	set_Register(0,4294967496);	count = 1; 	__asm {	PUNPCKHBW MM0,count }
	set_Register(0,4294967496);	count = 4294967496; 	__asm {	PUNPCKHBW MM0,count }
	
	set_Register(0,1);	count = 400; 	__asm {	PUNPCKHWD MM0,count }
	set_Register(0,1);	count = 24600; 	__asm {	PUNPCKHWD MM0,count }
	set_Register(0,1);	count = 4294967296; 	__asm {	PUNPCKHWD MM0,count }
	set_Register(0,4294967296);	count = 1; 	__asm {	PUNPCKHWD MM0,count }
	set_Register(0,4294967296);	count = 4294967296; 	__asm {	PUNPCKHWD MM0,count }
	
	set_Register(0,1);	count = 400; 	__asm {	PUNPCKHDQ MM0,count }
	set_Register(0,1);	count = 24600; 	__asm {	PUNPCKHDQ MM0,count }
	set_Register(0,1);	count = 4294967296; 	__asm {	PUNPCKHDQ MM0,count }
	set_Register(0,4294967296);	count = 1; 	__asm {	PUNPCKHDQ MM0,count }
	set_Register(0,4294967296);	count = 4294967296; 	__asm {	PUNPCKHDQ MM0,count }
	
	//	Unpack Low Packed Data
	set_Register(0,1);	count = 2; 	__asm {	PUNPCKLBW MM0,count }
	set_Register(0,2);	count = 1; 	__asm {	PUNPCKLBW MM0,count }

	set_Register(0,1);	count = 2; 	__asm {	PUNPCKLWD MM0,count }
	set_Register(0,2);	count = 1; 	__asm {	PUNPCKLWD MM0,count }
	
	set_Register(0,1);	count = 2; 	__asm {	PUNPCKLDQ MM0,count }
	set_Register(0,2);	count = 1; 	__asm {	PUNPCKLDQ MM0,count }
	
	//	Bitwise Logical Exclusive OR
	set_Register(0,255);	count = 15; 	__asm {	PXOR MM0,count }
	set_Register(0,15);		count = 15; 	__asm {	PXOR MM0,count }

}

void test_3dNow()
{
	//	3dNow Tests

	__int64 count = 0;
	unsigned char int8 = 0;

	//	average of unsigned int bytes
	set_Register(0,1);	count = 1; 	__asm {	PAVGUSB MM0,count }	//	1
	set_Register(0,1);	count = 0; 	__asm {	PAVGUSB MM0,count }	//	1
	set_Register(0,0);	count = 1; 	__asm {	PAVGUSB MM0,count }	//	1
	set_Register(0,807437600515);	count = 661408385285; 	__asm {	PAVGUSB MM0,count }	//	734423025668

	//	float to 32 bit signed int
	set_Register(0,1);	count = 1610612738; 	__asm {	PF2ID MM0,count }	//	2147483647
	set_Register(0,1);	count = 6917529037841629186; 	__asm {	PF2ID MM0,count }	//	9223372034707292159
	set_Register(0,1);	count = 1065353218; 	__asm {	PF2ID MM0,count }	//	1
	set_Register(0,1);	count = 1082130434; 	__asm {	PF2ID MM0,count }	//	4

	//	accumulator
	set_Register(0,1082130434);	count = 1065353218; 	__asm {	PFACC MM0,count }	//	4575657231080488962
	set_Register(0,1065353218);	count = 1; 	__asm {	PFACC MM0,count }	//	1065353218
	set_Register(0,1);	count = 1065353218; 	__asm {	PFACC MM0,count }	//	4575657229998358528
//	set_Register(0,4575657231080488962);	count = 1065353218; 	__asm {	PFACC MM0,count }	// not understood

	//	add
	set_Register(0,0);	count = 1065353218; 	__asm {	PFADD MM0,count }
	set_Register(0,1065353218);	count = 1073741826; 	__asm {	PFADD MM0,count }	//	1 + 2
	set_Register(0,1077936131);	count = 1082130434; 	__asm {	PFADD MM0,count }	//	3 + 4

	//	compare for equal
	set_Register(0,1);	count = 1; 	__asm {	PFCMPEQ MM0,count }	//	18446744073709551615
	set_Register(0,1065353218);	count = 1; 	__asm {	PFCMPEQ MM0,count }	//	18446744069414584320
	set_Register(0,1065353218);	count = 1065353218; 	__asm {	PFCMPEQ MM0,count } //	18446744073709551615
	set_Register(0,4575657231063711746);	count = 1065353218; 	__asm {	PFCMPEQ MM0,count }	//	4294967295
	set_Register(0,4575657231063711746);	count = 1077936131; 	__asm {	PFCMPEQ MM0,count }	//	0

	//	compare for greater than or equal to
	set_Register(0,1);	count = 1; 	__asm {	PFCMPGE MM0,count }	//	 //	18446744073709551615
	set_Register(0,1065353218);	count = 1065353218; 	__asm {	PFCMPGE MM0,count } //	18446744073709551615
	set_Register(0,4575657231063711746);	count = 1065353218; 	__asm {	PFCMPGE MM0,count }	//	18446744073709551615
	set_Register(0,4575657231063711746);	count = 1077936131; 	__asm {	PFCMPGE MM0,count }	//	18446744069414584320

	//	compare for greater than
	set_Register(0,1);	count = 1; 	__asm {	PFCMPGT MM0,count }
	set_Register(0,1065353218);	count = 1065353218; 	__asm {	PFCMPGT MM0,count } //	0
	set_Register(0,4575657231063711746);	count = 1065353218; 	__asm {	PFCMPGT MM0,count }	//	18446744069414584320
	set_Register(0,4575657231076294659);	count = 1065353218; 	__asm {	PFCMPGT MM0,count }	//	18446744073709551615
	
	//	maximum
	set_Register(0,1);	count = 1; 	__asm {	PFMAX MM0,count }
	set_Register(0,1);	count = 4575657231063711746; 	__asm {	PFMAX MM0,count }
	set_Register(0,4575657231063711746);	count = 1077936131; 	__asm {	PFMAX MM0,count }	//	4575657231076294659
	set_Register(0,4575657231076294659);	count = 4611686028091064322; 	__asm {	PFMAX MM0,count }	//	4611686028095258627

	//	minimum
	set_Register(0,1);	count = 1; 	__asm {	PFMIN MM0,count }
	set_Register(0,1);	count = 4575657231063711746; 	__asm {	PFMIN MM0,count }
	set_Register(0,4575657231076294659);	count = 4611686028091064322; 	__asm {	PFMIN MM0,count }	//	4575657231072100354
	set_Register(0,4575657231076294659);	count = 1065353218; 	__asm {	PFMIN MM0,count }	//	1065353218

	//	multiply
	set_Register(0,1);	count = 1; 	__asm {	PFMUL MM0,count }
	set_Register(0,1);	count = 4575657231076294659; 	__asm {	PFMUL MM0,count }
	set_Register(0,4575657231076294659);	count = 4611686028091064322; 	__asm {	PFMUL MM0,count }
	
	//	reciprocal
	set_Register(0,1);	count = 1; 	__asm {	PFRCP MM0,count } //	9187343237679939583

	set_Register(0,1);	set_Register(1,1073741826);	 __asm {	PFRCP MM0,MM1 }	//	reciprocal of 2 - 4539626226423168512
	count = 1092616193; 	__asm {	PFMUL MM0,count }	//	multiply 10 by 0.5 - 1084227265

	//	reciprocal, reciprocal intermediate step 1, reciprocal intermediate step 2
	set_Register(0,1);	set_Register(1,1073741826);	 __asm {	PFRCP MM0,MM1 }	//	reciprocal of 2 - 4539626226423168512
	__asm {	PFRCPIT1 MM1,MM0 }	//	MM1 - 1065418239
	__asm {	PFRCPIT2 MM0,MM1 }	//	1057029630
	count = 1092616193; 	__asm {	PFMUL MM0,count }	//	multiply 10 by 0.5 - 1084308863
		
	//	reciprocal sqrt
	set_Register(0,1);	count = 1; 	__asm {	PFRSQRT MM0,count }		//	9187343237679939583
	set_Register(0,1);	count = 1082130434; 	__asm {	PFRSQRT MM0,count }	//	4 - 4539627325934796544 (not same as 1/2)
	set_Register(0,1);	count = 1091567617; 	__asm {	PFRSQRT MM0,count }	//	9 - 4515608494420437504 - exact!!

	//	reciprocal sqrt, reciprocal sqrt intermediate step 1	
	set_Register(0,1);	set_Register(1,1082130434); 	__asm {	PFRSQRT MM0,MM1 }	//	4 - 4539627325934796544 (not same as 1/2)
	__asm {	PFRSQIT1 MM1,MM0 }	//	1065369343 - off

	set_Register(0,1);	set_Register(1,1091567617); 	__asm {	PFRSQRT MM0,MM1 }	//	9 - 4515608494420437504 (not same as 1/2)
	__asm {	PFRSQIT1 MM1,MM0 }	//	1065365418 - off
	
	//	subtract
	set_Register(0,1);	count = 1; 	__asm {	PFSUB MM0,count }
	set_Register(0,1065353218);	count = 1065353218; 	__asm {	PFSUB MM0,count }
	set_Register(0,1082130434);	count = 1065353218; 	__asm {	PFSUB MM0,count } //	 4-1 = 1077936131
	set_Register(0,4575657231076294659);	count =1065353218; 	__asm {	PFSUB MM0,count } //	4575657231072100354

	//	reverse subtraction
	set_Register(0,1);	count = 1; 	__asm {	PFSUBR MM0,count }
	set_Register(0,1065353218);	count = 1065353218; 	__asm {	PFSUBR MM0,count }
	set_Register(0,1065353218);	count = 1082130434; 	__asm {	PFSUBR MM0,count } //	 4-1 = 1077936131
	set_Register(0,1065353218);	count =4575657231076294659; 	__asm {	PFSUBR MM0,count } //	4575657231072100354

	//	32 bit signed int to float
	set_Register(0,1);	count = 1; 	__asm {	PI2FD MM0,count }	//	1065353216
	set_Register(0,1);	count = 12884901890; 	__asm {	PI2FD MM0,count }	//	4629700418010611712
	set_Register(0,1);	count = 8589934593; 	__asm {	PI2FD MM0,count }	//	4611686019492741120

	//	multiply high
	set_Register(0,1);	count = 1; 	__asm {	PMULHRW MM0,count }
	set_Register(0,1688858450395145);	count = 1970346312335364; 	__asm {	PMULHRW MM0,count }	//	0!
	set_Register(0,2816897267531808);	count = 28148786178032640; 	__asm {	PMULHRW MM0,count }	//	8590000129!

	int8 = 1;

	//	load a processor cache into data cache
	__asm {	PREFETCH int8 }

	//	same, sets MES state to modified
	__asm {	PREFETCHW int8 }

}


void test_3dNowEnhanced()
{
	//	enhanced 3dnow tests

	__int64 count = 0;
	unsigned char count8 = 0;

	//	packed float to int word with sign extend
	set_Register(0,1);	count = 1; 	__asm {	PF2IW MM0,count }	//	0
	set_Register(0,1);	count = 4674736422882639874; 	__asm {	PF2IW MM0,count }	//	74 - 30064771076
	set_Register(0,1);	count = 4692750816015024128; 	__asm {	PF2IW MM0,count }	//	10-0 - 42949672960
	set_Register(0,1);	count = 13835058067084935170; 	__asm {	PF2IW MM0,count }	//	-2-1 - 18446744069414584319
	set_Register(0,1);	count = 3338666241; 	__asm {	PF2IW MM0,count }		//	4294934528

	//	packed float negative accumulate
	set_Register(0,1);	count = 1; 	__asm {	PFNACC MM0,count }	//	0
	set_Register(0,1);	count = 4647714825124708354; 	__asm {	PFNACC MM0,count }	//	0&47 - 4629700416936869888
	set_Register(0,4647714825120514050);	count = 4665729223629996034; 	__asm {	PFNACC MM0,count }	//	45&65 - 13799029259328552960

	//	packed float mixed +ve -ve accumulate
	set_Register(0,1);	count = 1; 	__asm {	PFPNACC MM0,count }
	set_Register(0,4647714825124708354);	count = 1; 	__asm {	PFPNACC MM0,count }	//	1077936128
	set_Register(0,4647714825124708354);	count = 4647714825120514050; 	__asm {	PFPNACC MM0,count }	//	47,45 - 4688247221760557056
   
	//	packed int word to float
	//	somewhat erroneous values

	set_Register(0,1);	count = 1; 	__asm {	PI2FW MM0,count }	//	1065353216
	set_Register(0,1);	count = 281466386841599; 	__asm {	PI2FW MM0,count }	//	13835058058495000576
	set_Register(0,1);	count = 30064771076; 	__asm {	PI2FW MM0,count }	//	4674736414292705280
 	set_Register(0,1);	count = 42949672960; 	__asm {	PI2FW MM0,count }	//	4692750811720056832
 	set_Register(0,1);	count = 32768; 	__asm {	PI2FW MM0,count }		//	3338665984

	//	packed swap double word
	set_Register(0,1);	count = 1; 	__asm {	PSWAPD MM0,count }  // 4294967296
	set_Register(0,1);	count = 4294967302; 	__asm {	PSWAPD MM0,count }  //	25769803777
	set_Register(0,1);	count = 25769803776; 	__asm {	PSWAPD MM0,count }	//	6

	//	streaming store using byte mask
	set_Register(0,1);	set_Register(1,255); 	__asm {	MASKMOVQ MM0,MM1 }
	set_Register(0,258);	set_Register(1,65535); 	__asm {	MASKMOVQ MM0,MM1 }
	set_Register(0,137561200);	set_Register(1,16777215); 	__asm {	MASKMOVQ MM0,MM1 }
	
	//	streaming store
	set_Register(0,10);	count = 1; 	__asm {	MOVNTQ count,MM0 }	//	count == mm0
	set_Register(0,34359738373);	count = 1; 	__asm {	MOVNTQ count,MM0 }

			
	//	packed avg of unsigned byte	
	set_Register(0,1);	count = 1; 	__asm {	PAVGB MM0,count }	//	1
	set_Register(0,1);	count = 0; 	__asm {	PAVGB MM0,count }	//	1
	set_Register(0,0);	count = 1; 	__asm {	PAVGB MM0,count }	//	1
	set_Register(0,807437600515);	count = 661408385285; 	__asm {	PAVGB MM0,count }	//	734423025668
	
	//	packed avg of unsigned word	
	set_Register(0,1);	count = 1; 	__asm {	PAVGW MM0,count }
	set_Register(0,13527687376553903363);	count = -7388155192895340543; 	__asm {	PAVGW MM0,count }	//	12293138128684057218
	set_Register(0,60000);	count = 50000; 	__asm {	PAVGW MM0,count }	//	55000


	//	extract word into int register
	set_Register(0,1);	__asm {	PEXTRW EAX,MM0,1 }	//	eax = 0
	set_Register(0,65538);	__asm {	PEXTRW EAX,MM0,1 }	//	eax = 1 


	//	insert word from int register

	set_Register(0,65540);	_asm { mov EAX, 2 }	 __asm {	PINSRW MM0, EAX, 1 }	//	MM0 = 131076

	//	packed max signed word
	set_Register(0,533958026541989887);	count = 576742218707042305; 	__asm {	PMAXSW MM0,count }	//	576742223002009601
	set_Register(0,1431633921);	count = 1431633926; 	__asm {	PMAXSW MM0,count }	//	1431633926
	
	//	packed max unsigned byte
	set_Register(0,730413330687);	count = 1834203085567; 	__asm {	PMAXUB MM0,count }	//	1834219928319
	
	//	packed min signed word
	set_Register(0,576742218707042305);	count = 533958026541989887; 	__asm {	PMINSW MM0,count }	//	533958022247022591
	set_Register(0,1431633926);	count = 1431633921; 	__asm {	PMINSW MM0,count }	//	1431633921
	
	//	packed min unsigned byte	
	set_Register(0,1834203085567);	count = 730413330687; 	__asm {	PMINUB MM0,count }	//	730396487935
	
	//	move mask to integer register
	set_Register(0,17356997142132031728);	__asm {	PMOVMSKB EAX, MM0 }	//	EAX = 217
	
	//	packed multiply high unsigned word
	set_Register(0,18446744069427435932);	count = 562954313924618; 	__asm {	PMULHUW MM0,count }	//	281474976841729

	//	prefetch non-temporal access
	__asm {	PREFETCHNTA count8 }
	
	//	prefetch to all cache levels
	__asm {	PREFETCHT0 count8 }
	
	//	prefetch to all cache levels except 0
	__asm {	PREFETCHT1 count8 }
	
	//	prefetch to all cache levels except 0 & 1
	__asm {	PREFETCHT2 count8 }

	//	packed sum of absolute byte differences
	set_Register(0,1300991683403908355);	count = 722835462628311810; 	__asm {	PSADBW MM0,count }	//	35
	set_Register(0,722835462628311810);	count = 1300991683403908355; 	__asm {	PSADBW MM0,count }	//	35
	
	//	packed shuffle word
	set_Register(0,1);	count = 1; 	__asm {	PSHUFW MM0,count,0 }	//	1 in every word 281479271743489
	set_Register(0,1);	count = 578437695752307201; 	__asm {	PSHUFW MM0,count,228 }	//	578437695752307201
	
	// store fence
	__asm {	SFENCE }
}

void test_Katmai()
{
	//	Katmai (PIII) Tests

	float fVal = 0.0;
	__int32 i32Val = 0;

	//	verifying each register for expression evaluation
	set_XMMRegister(0,1,2,3,4);
	set_XMMRegister(1,2,3,4,5);
	set_XMMRegister(2,3,4,5,6);
	set_XMMRegister(3,4,5,6,7);
	set_XMMRegister(4,5,6,7,8);
	set_XMMRegister(5,6,7,8,9);
	set_XMMRegister(6,7,8,9,10);
	set_XMMRegister(7,-1,-2,-3,6);


	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,3,4,5);
	__asm { addps   xmm0, xmm1 }	//	XMM0 - 3,5,7,9

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,3,4,5);
	__asm { addss   xmm0, xmm1 }	//	1,2,3,9

	ClearXMMReg(0); set_XMMRegister(1,0,4,0,1);
	__asm { andnps   xmm0, xmm1 }

	set_XMMRegister(0,1,1,1,1); set_XMMRegister(1,2,2,6,7);
	__asm { andnps   xmm0, xmm1 }

	set_XMMRegister(0,1,2,3,4); ClearXMMReg(1);
	__asm { andps   xmm0, xmm1 }	//	0

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,1,2,3,5);
	__asm { andps   xmm0, xmm1 }	//	1,2,3,4

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,1,2,3,5);
	__asm { cmpeqps   xmm0, xmm1 }	//	eq-eq-eq-neq (neq=>0)

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,1,2,3,4);
	__asm { cmpeqps   xmm0, xmm1 }	//	eq-eq-eq-eq

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,6,2,3,5);
	__asm { cmpeqss   xmm0, xmm1 }	//	1,2,3,0

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,6,2,3,4);
	__asm { cmpeqss   xmm0, xmm1 }	//	1,2,3,eq

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,1,3,1,0);
	__asm { cmpltps   xmm0, xmm1 }	//	no-yes-no-no

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,0,4,0);
	__asm { cmpltss   xmm0, xmm1 }	//	1,2,3,no

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,0,4,4);
	__asm { cmpltss   xmm0, xmm1 }	//	1,2,3,no

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,0,4,5);
	__asm { cmpltss   xmm0, xmm1 }	//	1,2,3,yes

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,1,3,0,0);
	__asm { cmpleps   xmm0, xmm1 }	//	yes,yes,no,no

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,0,4,0);
	__asm { cmpless   xmm0, xmm1 }	//	1,2,3,no

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,0,4,5);
	__asm { cmpless   xmm0, xmm1 }	//	1,2,3,yes

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,0,4,4);
	__asm { cmpless   xmm0, xmm1 }	//	1,2,3,yes

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,1,3,4,4);
	__asm { cmpneqps  xmm0, xmm1 }	//	no,y,y,n

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,3,4,4);
	__asm { cmpneqss   xmm0, xmm1 }	//	1,2,3,n

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,3,4,3);
	__asm { cmpneqss   xmm0, xmm1 }	//	1,2,3,y


	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,2,4,1);
	__asm { cmpnltps   xmm0, xmm1 }	//	n,y,n,y

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,1,4,1);
	__asm { cmpnltss   xmm0, xmm1 }	//	1,2,3,y

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,1,4,5);
	__asm { cmpnltss   xmm0, xmm1 }	//	1,2,3,n

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,1,4,4);
	__asm { cmpnltss   xmm0, xmm1 }	//	1,2,3,y

	set_XMMRegister(0,1,2,3,7); set_XMMRegister(1,2,3,3,5);
	__asm { cmpnleps   xmm0, xmm1 }	//	n,n,n,y

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,3,1,1);
	__asm { cmpnless   xmm0, xmm1 }	//	1,2,3,y

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,3,1,5);
	__asm { cmpnless   xmm0, xmm1 }	//	1,2,3,n

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,3,1,4);
	__asm { cmpnless   xmm0, xmm1 }	//	1,2,3,n


	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,3,4,5);
	__asm { comiss   xmm0, xmm1 }	//	0 (eq last no)

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,3,4,4);
	__asm { comiss   xmm0, xmm1 }	//	1

	set_XMMRegister(0,1,2,0,0); 
	GlobalInt64 = 3;  GlobalInt64  = GlobalInt64 << 32;	GlobalInt64 |= 4;
	__asm { cvtpi2ps   xmm0, GlobalInt64 }	//	1,2,3,4


	set_XMMRegister(0,1,2,2,5);
	__asm { cvtps2pi   mm0, xmm0 }	//	MM0 has 2,5

	set_XMMRegister(0,1,2,3,4); __asm { mov eax, 17 }
	__asm { cvtsi2ss   xmm0, eax }	//	1,2,3,17

	set_XMMRegister(0,1,2,3,4);
	__asm { cvtss2si   eax, xmm0 }	//	eax has 4

	set_XMMRegister(0,1,2,7,5);
	__asm { cvttps2pi   mm0, xmm0 }	//	MM0 has 7,5

	set_XMMRegister(0,1,2,3,7);
	__asm { cvttss2si   eax, xmm0 }	//	eax has 7

	set_XMMRegister(0,1,2,9,8); set_XMMRegister(1,2,2,3,2);
	__asm { divps   xmm0, xmm1 }	//	0.5,1,3,4

	set_XMMRegister(0,1,2,3,10); set_XMMRegister(1,2,2,3,2);
	__asm { divss   xmm0, xmm1 }	//	1,2,3,5

	set_XMMRegister(0,5,2,7,4); set_XMMRegister(1,4,2,9,5);
	__asm { maxps   xmm0, xmm1 }	//	5,2,9,5

	set_XMMRegister(0,5,2,7,4); set_XMMRegister(1,4,2,9,6);
	__asm { maxss   xmm0, xmm1 }	//	5,2,7,6

	set_XMMRegister(0,5,2,7,4); set_XMMRegister(1,4,2,9,2);
	__asm { maxss   xmm0, xmm1 }	//	5,2,7,4


	set_XMMRegister(0,5,2,7,4); set_XMMRegister(1,4,2,9,3);
	__asm { minps   xmm0, xmm1 }	//	4,2,7,3

	set_XMMRegister(0,1,2,3,7); set_XMMRegister(1,4,2,9,6);
	__asm { minss   xmm0, xmm1 }	//	1,2,3,6

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,4,2,9,6);
	__asm { minss   xmm0, xmm1 }	//	1.2.3.4

	set_XMMRegister(0,1,2,3,4);	set_XMMRegister(1,5,6,7,8);
	__asm { movaps   xmm0, xmm1 }	//	5,6,7,8

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,5,6,2,3);
	__asm { movhlps   xmm0, xmm1 }	//	1,2,5,6

	set_XMMRegister(0,1,2,3,4); set_GlobalInt64(6,7);
	__asm { movhps   xmm0, GlobalInt64 }	//	6.7.3.4

	set_XMMRegister(0,1,2,3,4); set_GlobalInt64(6,7);
	__asm { movlps   xmm0, GlobalInt64 }	//	1.2.6.7

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,3,5,6);
	__asm { movlhps   xmm0, xmm1 }	//	5.6.3.4

	set_XMMRegister(0,1,-2,3,-1);
	__asm { movmskps   eax, xmm0 }	//	5

	
	set_XMMRegister(0,7,8,9,-1);
	__asm { movntps	Var128, xmm0 }

	set_XMMRegister(0,1,2,3,4); fVal = 9;
	__asm { movss   xmm0, fVal }	//	0.0.0.9

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,5,6,7,8);
	__asm { movups   xmm0, xmm1 }	//	5,6,7,8

	set_XMMRegister(0,1,2,3,2); set_XMMRegister(1,2,3,0,5);
	__asm { mulps   xmm0, xmm1 }	//	2,6,0,10

	set_XMMRegister(0,1,2,3,2); set_XMMRegister(1,2,3,4,4);
	__asm { mulss   xmm0, xmm1 }	//	1,2,3,8

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,0,3,4,5);
	__asm { orps   xmm0, xmm1 }	//	1,3,6,5

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,3,4,5);
	__asm { rcpps   xmm0, xmm1 }	//	1/2, 1/3, 1/4, 1/5

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,3,4,2);
	__asm { rcpss   xmm0, xmm1 }	//	1,2,3,1/2

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,1,3,4,9);
	__asm { rsqrtps   xmm0, xmm1 }	//	reciprocal 1,1.73,2,3

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,1,3,4,9);
	__asm { rsqrtss   xmm0, xmm1 }	//	1,2,3, 1/3


	__asm { sfence }

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,5,6,7,8);
	__asm { shufps   xmm0, xmm1, 114 }	//	7,5,4,2

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,1,3,4,9);
	__asm { sqrtps   xmm0, xmm1 }	//	1,1.73,2,3

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,1,3,4,9);
	__asm { sqrtss   xmm0, xmm1 }	//	1,2,3,3

	__asm { stmxcsr   i32Val  }		//	8096 - not important

	set_XMMRegister(0,1,8,5,4); set_XMMRegister(1,2,3,4,1);
	__asm { subps   xmm0, xmm1 }	//	-1,5,1,3

	set_XMMRegister(0,1,8,5,4); set_XMMRegister(1,2,3,4,6);
	__asm { subss   xmm0, xmm1 }	//	1,8,5,-2

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,2,3,4,5);
	__asm { ucomiss   xmm0, xmm1 }	//	0

	set_XMMRegister(0,1,2,3,5); set_XMMRegister(1,2,3,4,5);
	__asm { ucomiss   xmm0, xmm1 }	//	1


	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,5,6,7,8);
	__asm { unpckhps   xmm0, xmm1 }	//	interleaved high - 5,1,6,2

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,5,6,7,8);
	__asm { unpcklps   xmm0, xmm1 }	//	interleaved low - 7,3,8,4

	set_XMMRegister(0,1,2,3,4); set_XMMRegister(1,1,2,4,5);
	__asm { xorps   xmm0, xmm1 }	//	xor - 0,0,1.76324e-038,2.93874e-039

}


void ClearXMMReg(int regid)
{

	switch(regid)
	{

	case 0:
		__asm { MOVSS XMM0, FLOAT_ZERO }
		break;

	case 1:
		__asm { MOVSS XMM1, FLOAT_ZERO }
		break;

	case 2:
		__asm { MOVSS XMM2, FLOAT_ZERO }
		break;

	case 3:
		__asm { MOVSS XMM3, FLOAT_ZERO }
		break;

	case 4:
		__asm { MOVSS XMM4, FLOAT_ZERO }
		break;

	case 5:
		__asm { MOVSS XMM5, FLOAT_ZERO }
		break;

	case 6:
		__asm { MOVSS XMM6, FLOAT_ZERO }
		break;

	case 7:
		__asm { MOVSS XMM7, FLOAT_ZERO }
		break;

	}

}

void set_GlobalInt64(int Hi, int Low)
{
	__int64 HiVal = FloatVal[Hi - FLOATVAL_BASE];
	__int64 LowVal = FloatVal[Low - FLOATVAL_BASE];

	GlobalInt64 = HiVal;
	GlobalInt64  = GlobalInt64 << 32;
	GlobalInt64 |= LowVal;
}

void set_XMMRegister(int regid, char upper, int Hi, int Low)
{

	switch (regid)
	{
		case 0:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM0, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM0, GlobalInt64 }
					}
					break;

		case 1:					
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM1, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM1, GlobalInt64 }
					}
					break;


		case 2:					
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM2, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM2, GlobalInt64 }
					}
					break;

		case 3:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM3, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM3, GlobalInt64 }
					}
					break;


		case 4:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM4, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM4, GlobalInt64 }
					}
					break;

		case 5:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM5, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM5, GlobalInt64 }
					}
					break;

		case 6:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM6, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM6, GlobalInt64 }
					}
					break;

		case 7:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM7, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM7, GlobalInt64 }
					}
					break;
	}
}


void set_XMMRegister(int regid, int X3, int X2, int X1, int X0)
{
	set_XMMRegister(regid, 1, X3, X2);	//	upper 64 bits
	set_XMMRegister(regid, 0, X1, X0);	//	lower 64 bits
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\ee\ee.cpp ===
#include <windows.h>
#include "derived1.h"
#include "struct1.h"
#include "union1.h"
#include "global.h"
#include "pch.h"
#include "dll.h"


namespace namespace1
	
{
	// namespace variable.
	int namespace1_var = 1;

	// namespace function.
	int namespace1_func(int i)
	{
		return namespace1_var + i;
	}		
}


// struct declared in .cpp file (rather than header).
struct struct_cpp
	
{
private:
	int struct_cpp_var;

public:

	struct_cpp(void){struct_cpp_var = 0;}

	int struct_cpp_func(int i)
	{
		struct_cpp_var = i;
		return struct_cpp_var;
	}
};


// classed declared in .cpp file (rather than header).
class class_cpp
	
{
private:
	int class_cpp_var;
	
public:

	// const primitive member.
	const int m_const_int;
	const int *m_pconst_int;
	int const m_int_const;
	int const *m_pint_const;

	// const user type member.
	const struct_cpp m_const_struct_cpp;
	const struct_cpp *m_pconst_struct_cpp;
	struct_cpp const m_struct_cpp_const;
	struct_cpp const *m_pstruct_cpp_const;

	class_cpp(void)	:
		m_const_int(0), 
		m_pconst_int(&m_const_int),
		m_int_const(0),
		m_pint_const(&m_int_const),
		m_pconst_struct_cpp(&m_const_struct_cpp),
		m_pstruct_cpp_const(&m_struct_cpp_const)
	{
		class_cpp_var = 0;

	}

	int class_cpp_func(int i)
	{
		class_cpp_var = i;
		return class_cpp_var;
	}

};


// union declared in .cpp file (rather than header).
union union_cpp
	
{
private:
	int union_cpp_var;

public:

	union_cpp(void){union_cpp_var = 0;}

	int union_cpp_func(int i)
	{
		union_cpp_var = i;
		return union_cpp_var;
	}
};


// enum defined in cpp file (rather than header).
enum enum_cpp{one_cpp = 1, two_cpp, three_cpp};


// pointer to member function.
int (derived1::*ptr_to_mem_func)(int i) = &derived1::derived1_public_func;	
// pointer to member variable.
int derived1::*ptr_to_mem_var = &derived1::derived1_public_var;			


// global const primitive.
const int gconst_int = 0;
const int *gpconst_int;
int const gint_const = 0;
int const *gpint_const;


// global const user type.
const struct_cpp gconst_struct_cpp;
const struct_cpp *gpconst_struct_cpp;
struct_cpp const gstruct_cpp_const;
struct_cpp const *gpstruct_cpp_const;


int FAR PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)
	
{
	// global const primitive.
	gpconst_int = &gconst_int;
	gpint_const = &gint_const;

	// global const user type.
	gpconst_struct_cpp = &gconst_struct_cpp;
	gpstruct_cpp_const = &gstruct_cpp_const;

	// local class.
	class class_local
	{
	public:
		int class_local_var;
	};

	// local struct.
	struct struct_local
	{
	public:
		int struct_local_var;
	};

	// local union.
	union union_local
	{
	public:
		int union_local_var;
	};

	// local enum.
	enum enum_local{one_local = 1, two_local, three_local};

	// static and dynamic access to class declared in header.
	derived1 derived1_obj;
	derived1 *derived1_obj_ptr = new derived1;

	// static and dynamic access to class declared in .cpp file.
	class_cpp class_cpp_obj;
	class_cpp *class_cpp_obj_ptr = new class_cpp;

	// static and dynamic access to local class.
	class_local class_local_obj;
	class_local *class_local_obj_ptr = new class_local;
	class_local_obj.class_local_var = 0;
	class_local_obj_ptr->class_local_var = 0;

	// static and dynamic access to class declared in .pch file.
	class_pch class_pch_obj;
	class_pch *class_pch_obj_ptr = new class_pch;
	
	// static and dynamic access to struct declared in header.
	struct1 struct1_obj;
	struct1 *struct1_obj_ptr = new struct1;

	// static and dynamic access to struct declared in .cpp file.
	struct_cpp struct_cpp_obj;
	struct_cpp *struct_cpp_obj_ptr = new struct_cpp;

	// static and dynamic access to local struct.
	struct_local struct_local_obj;
	struct_local *struct_local_obj_ptr = new struct_local;
	struct_local_obj.struct_local_var = 0;
	struct_local_obj_ptr->struct_local_var = 0;

	// static and dynamic access to struct declared in .pch file.
	struct_pch struct_pch_obj;
	struct_pch *struct_pch_obj_ptr = new struct_pch;
	
	// static and dynamic access to union declared in header.
	union1 union1_obj;
	union1 *union1_obj_ptr = new union1;

	// static and dynamic access to union declared in .cpp file.
	union_cpp union_cpp_obj;
	union_cpp *union_cpp_obj_ptr = new union_cpp;

	// static and dynamic access to local union.
	union_local union_local_obj;
	union_local *union_local_obj_ptr = new union_local;
	union_local_obj.union_local_var = 0;
	union_local_obj_ptr->union_local_var = 0;

	// static and dynamic access to union declared in .pch file.
	union_pch union_pch_obj;
	union_pch *union_pch_obj_ptr = new union_pch;

 	// reference to enum declared in header (non-pch).
	enum1 enum1_var = two;
	// reference to enum declared in .cpp file.
	enum_cpp enum_cpp_var = three_cpp;
	// reference to local enum.
	enum_local enum_local_var = one_local;
	// reference to enum declared in a .pch file.
	enum_pch enum_pch_var = two_pch;

	// static local variable.
	static int static_local_var = 0;

	// static and dynamic access to class defined in dll.
	dll_class dll_class_obj;
	dll_class *dll_class_obj_ptr = new dll_class;

	// local const primitive.
	const int const_int = 0;
	const int *pconst_int = &const_int;
	int const int_const = 0;
	int const *pint_const = &int_const;

	// local const user type.
	const struct_cpp const_struct_cpp;
	const struct_cpp *pconst_struct_cpp = &const_struct_cpp;
	struct_cpp const struct_cpp_const;
	struct_cpp const *pstruct_cpp_const = &struct_cpp_const;

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\ee2\eetest.cpp ===
#include <windows.h>
#include <comcat.h>
#include <ocidl.h>
#include <urlmon.h>
#include <ACTIVSCP.H>
#include <OBJSAFE.H>
// test VC5.0 EE failures, so we can test 6.0 and 7.0
// and also new features

typedef void (*PFNINT)(void*, unsigned long);
typedef int (*PFNVAR)(void*, ...);

void afuncint(void*, DWORD)
{
}

int afuncvar(void*, ...)
{
	return 0;
}

int afunvar1(char*, ...)
{
	return 1;
}

int afunvar2(int*, int, ...)
{
	return 2;
}

class AClass
{
public:
	PFNINT pfnint;
	PFNVAR pfnvar;
protected:
	virtual void __cdecl    virt_method1() {};
	virtual void __fastcall virt_method2(long, ...) {};
};

PFNINT fun_return_pfn()
{
	return afuncint;
}

void pointers_to_functions()
{
	AClass aclass;
	AClass *pclass=&aclass;
	AClass class_table[1];

	PFNINT pfunint_table[1];
	PFNVAR pfunvar;

//pointers to functions
	pfunint_table[0] = afuncint; //eval("pfunint_table[0]")=="ADDRESS afuncint(void*, unsigned int)"
	pfunvar = (PFNVAR)afunvar1; //eval("pfunvar")=="ADDRESS afunvar1(char*, <no type>)"

//pointers to functions as members of class
	aclass.pfnint = afuncint; //eval("pclass->pfnint")=="ADDRESS afuncint(void*, unsigned int)"
	aclass.pfnvar = afuncvar; //eval("pclass->pfnvar")=="ADDRESS afuncvar(void*, <No type>)"
	aclass.pfnvar = (PFNVAR)afunvar1;//eval("pclass->pfnvar")=="ADDRESS afunvar1(char*, <no type>)"
	aclass.pfnvar = (PFNVAR)afunvar2;//eval("pclass->pfnvar")=="ADDRESS afunvar2(int*, int, <no type>)"

	(*aclass.pfnint)(NULL,1000);
	int ret=1;
	ret=(*aclass.pfnvar)(&ret,15,&ret);
//vtable pointers correct
	//eval("(class_table[0]).__vfptr[0]")=="ADDRESS AClass::virt_method1"
	//eval("(class_table[0]).__vfptr[1]")=="ADDRESS AClass::virt_method2"
	memset(class_table,0, sizeof(class_table)); //evaluate the NULL pointers (including virtual pointers)
	class_table[0] = aclass; //eval("class_table[0].pfnint")=="ADDRESS afuncint(void*, unsigned int)"
							//eval("class_table[0].pfnvar")=="ADDRESS afuncvar2(int*, int, <no type>)"
//TODO add the invocation of each function through all pointers and check the result
//	(*pfunc)(); //just like that

//vtable pointers
	//eval("(aclass).__vfptr[0]")=="ADDRESS AClass::virt_method1"
	//eval("(aclass).__vfptr[1]")=="ADDRESS AClass::virt_method2"
//vtable pointers corrupted by memset
	//eval("(class_table[0]).__vfptr[0]")=="Error: cannot display value"
	//eval("(class_table[0]).__vfptr[1]")=="Error: cannot display value"
	fun_return_pfn();
}


REFIID return_Unknown()
{
	REFIID unknown=IID_IUnknown;
	return unknown;
}

GUID return_GUIDUnknown()
{
	GUID guidunknown=IID_IUnknown;
	return guidunknown;
}

VARIANT return_variant()
{
	VARIANT variant;
	variant.vt=VT_I4;			//LONG
	variant.lVal = 0xffff;

	return variant;
}

const GUID unKnownGuid = {0xf0ff0ff0, 0xff0f, 0xff0f, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00}; //global, misc. guid
GUID Global_Guid;
REFIID glob_refiid0=IID_IMarshal;
REFIID glob_refiid1=IID_IMalloc;
void guids_and_refguids()
{
//non-static, local
	GUID Guid =IID_IClassFactory;
//global
	Global_Guid =IID_IClassFactory2;
//pointers to GUIDs
	GUID const *pGuid = &Guid;
	GUID *pBadGuid = NULL; //following NULL pointer
	pBadGuid = (GUID *)5;	//following AV
	REFIID pBadrefId = *pBadGuid;	//following AV
//static, local GUID
	static GUID unKnown = unKnownGuid;

	pGuid =&CLSID_FileProtocol;
	pGuid =&CLSID_FtpProtocol;
	Guid =CLSID_GopherProtocol;
	Guid =CLSID_HttpProtocol;

	CATID pCAT= CATID_Control;
	pCAT = CATID_DocObject;


	static REFIID refiid0 =IID_IUnknown;
	static REFIID refiid1 =IID_IDispatch;
	static REFIID refiid2 =IID_IMoniker;
	static REFIID refiid3 =IID_IEnumString;
	static REFIID refiid4 =IID_IStream;
	REFIID refiid5 =IID_IStorage;
	REFIID refiid6 =IID_IPersistStorage;
	REFIID refiid7 =IID_IPersist;
	REFIID refiid8 =IID_IActiveScript;
	REFIID refiid9 =IID_IObjectSafety;
//global REFIIDs impossible to init here, but they shld be checked here
//	REFIID glob_refiid0=IID_IMarshal;
//	REFIID glob_refiid1=IID_IMalloc;

	return_Unknown();
	return_GUIDUnknown();
}


VARIANT glob_variant; //declaration of global VARIANT
void variants()
{
//static local VARIANT
	static VARIANT variant1;

		variant1.vt = ~VT_BYREF|VT_UI1; //non-existent
		::VariantInit(&variant1); //VT_EMPTY
		variant1.vt = VT_I4;			//LONG
		variant1.lVal = 1052;
		
		variant1.vt = VT_UI1;		//BYTE
		variant1.bVal = 255;

		variant1.vt = VT_I2;			//SHORT
		variant1.iVal = 32000;

		variant1.vt = VT_R4;			//FLOAT
		variant1.fltVal = 20.00;

		variant1.vt = VT_R8;			//DOUBLE
		variant1.dblVal = 3.14e100;

		variant1.vt = VT_BOOL;		//VARIANT_BOOL
		variant1.boolVal = TRUE;

		variant1.vt = VT_ERROR;		//SCODE
		variant1.scode = E_FAIL; //variant.scode,hr=="E_FAIL", but variant=="{0x80004005 VT_ERROR}"

		variant1.vt = VT_CY;			//CY
		variant1.cyVal.Lo = 0xffffffff;variant1.cyVal.Hi = 0x7fffffff;	//variant=="{922337203685477.5807 VT_CY}"

		variant1.vt = VT_DATE;		//DATE //variant=="{???}"
		variant1.date = 35065.000000000; //COleDateTime(1996,1,1,0,0,0); == "{1/1/96 12:00:00 AM VT_DATE}"

//non-static local VARIANT
		VARIANT variant2;
		::VariantInit(&variant2);
		variant2.vt = VT_BSTR;		//BSTR
		WCHAR szW[100];MultiByteToWideChar(CP_ACP, 0, "BSTR test", -1, szW, 100);
		variant2.bstrVal = ::SysAllocString(szW);
		::SysFreeString(variant2.bstrVal);

		variant2.vt = VT_UNKNOWN;	//IUnknown*
		variant2.lVal = 255; //punkVal: see if bogus value works here

		variant2.vt = VT_DISPATCH;	//IDispatch*
		variant2.lVal = 255; //ppdispVal see if bogus value works here

		variant2.vt = VT_ARRAY;		//SAFEARRAY*
		variant2.lVal = 255; //pparray

//global VARIANT
		::VariantInit(&glob_variant);
		glob_variant.vt = VT_UI1|VT_BYREF;//BYTE*
		BYTE pbVal=255;glob_variant.pbVal = &pbVal; 

		glob_variant.vt = VT_I2|VT_BYREF;//SHORT*
		SHORT piVal=1000;glob_variant.piVal = &piVal;

		glob_variant.vt = VT_I4|VT_BYREF;//LONG*
		LONG plVal=1000000;glob_variant.plVal = &plVal;

		glob_variant.vt = VT_R4|VT_BYREF;//FLOAT*
		FLOAT pfltVal=20.00;glob_variant.pfltVal = &pfltVal;

		glob_variant.vt = VT_R8|VT_BYREF;//DOUBLE*
		DOUBLE pdblVal=10;glob_variant.pdblVal = &pdblVal;

		glob_variant.vt = VT_BOOL|VT_BYREF;//VARIANT_BOOL*
		VARIANT_BOOL pboolVal=FALSE;glob_variant.pboolVal = &pboolVal;

		glob_variant.vt = VT_ERROR|VT_BYREF;//SCODE*
		SCODE pscode=E_NOTIMPL; glob_variant.pscode = &pscode;

		glob_variant.vt = VT_CY|VT_BYREF;//CY*
		CY pcyVal;pcyVal.int64=0x7fffffffffffffffUL+1;glob_variant.pcyVal = &pcyVal; //variant=="{-922337203685477.5808 VT_CY|VT_BYREF}"

		glob_variant.vt = VT_DATE|VT_BYREF;//DATE*
		DATE pdate=35642.952071759/*COleDateTime(1997,07,31,22,50,59)*/;glob_variant.pdate = &pdate; //=="{7/31/97 10:50:59 PM VT_DATE|VT_BYREF}"

		glob_variant.vt = VT_UNKNOWN|VT_BYREF;//IUnknown **
		glob_variant.lVal = 5; //ppunkVal

		glob_variant.vt = VT_DISPATCH|VT_BYREF;//IDispatch **
		glob_variant.lVal = 5; //ppdispVal

		glob_variant.vt = VT_ARRAY|VT_BYREF;//SAFEARRAY **
		glob_variant.lVal = 5; //pparray

		glob_variant.vt = VT_VARIANT|VT_BYREF;//VARIANT *
		glob_variant.pvarVal = &glob_variant; //circular reference
		glob_variant.pvarVal = &variant2; //non-static,local variant referenced

		glob_variant.vt = VT_BSTR|VT_BYREF;//BSTR*
		//WCHAR szW[100];
		MultiByteToWideChar(CP_ACP, 0, "PBST test", -1, szW, 100);
		BSTR pbstrVal=::SysAllocString(szW);glob_variant.pbstrVal = &pbstrVal;
		SysFreeString(pbstrVal);

//subvariant - non-statc, local variant
		VARIANT subvariant;
		::VariantInit(&subvariant);
		subvariant.vt = VT_I4;
		subvariant.lVal = 10;
		variant2.vt = VT_BYREF;		//PVOID
		void* anyref=&subvariant;variant2.byref = &subvariant;

		variant2.vt = VT_I1;			//CHAR
		variant2.cVal = 'V';

		variant2.vt = VT_UI2;		//USHORT
		variant2.uiVal = 0xffff;

		variant2.vt = VT_UI4;		//ULONG
		variant2.ulVal = 0xffffffff;

		variant2.vt = VT_INT;		//INT
		variant2.intVal = -256;

		variant2.vt = VT_UINT;		//UINT
		variant2.uintVal = 256;

		variant2.vt = VT_DECIMAL|VT_BYREF;//DECIMAL *
		DECIMAL dec; memset(&dec, 0, sizeof(dec)); dec.Hi32=1; dec.scale=28; variant2.pdecVal = &dec;

		variant2.vt = VT_I1|VT_BYREF;//CHAR *
		variant2.pcVal = "char string test";

		variant2.vt = VT_UI2|VT_BYREF;//USHORT *
		variant2.puiVal = (USHORT*)&variant2; //bogus

		variant2.vt = VT_UI4|VT_BYREF;//ULONG *
		variant2.pulVal = (ULONG *)5; //error test

		variant2.vt = VT_INT|VT_BYREF;//INT *
		variant2.pintVal = NULL; //error test

		variant2.vt = VT_UINT|VT_BYREF;//UINT *
		variant2.puintVal = (UINT *)255; //still error

		return_variant();
}


BOOL MMX_Chip()
{
#pragma warning(disable:4035)
	__asm{
		mov eax,1;
		_emit 0x0f; //CPUID
		_emit 0xa2; //CPUID
		mov eax,1;
		test edx,0x0800000;
		jnz Yes
		mov eax,0
Yes:
	}
	return;
#pragma warning(default:4035)
} //MMX_Chip()

#pragma warning(disable:4799)
void MMXRegs()
{
	__int64 qmemory0=
		1+1*0x100000000;
	__int64 qmemory1=
		2+2*0x100000000;
	__int64 qmemory2=
		4+4*0x100000000;
	__int64 qmemory3=
		8+8*0x100000000;
	__int64 qmemory4=
		16+16*0x100000000;
	__int64 qmemory5=
		32+32*0x100000000;
	__int64 qmemory6=
		64+64*0x100000000;
	__int64 qmemory7=
		128+128*0x100000000;
if(MMX_Chip())
{
	int mm0=-10,Mm0=-20,mM0=-30;
	int mm1=-11,Mm1=-21,mM1=-31;
	int mm2=-12,Mm2=-22,mM2=-32;
	int mm3=-13,Mm3=-23,mM3=-33;
	__asm{
		movd mm0,ebx; //long(mm0)==ebx
		movd mm1,edx; //long(mm1)==edx
		movd mm2,esp; //long(mm2)==esp
		movd mm3,ebp; //long(mm3)==ebp

		movq mm0,qmemory0; //mm0==qmemory0
		movq mm1,qmemory1; //...
		movq mm2,qmemory2;
		movq mm3,qmemory3;
		movq mm4,qmemory4;
		movq mm5,qmemory5;
		movq mm6,qmemory6;
		movq mm7,qmemory7;
//the following sequence shldn't change the low words of mm0..mm7
		movd mm0,qmemory0; //mm0==long(qmemory0)
		movd mm1,qmemory1; //...
		movd mm2,qmemory2;
		movd mm3,qmemory3;
		movd mm4,qmemory4;
		movd mm5,qmemory5;
		movd mm6,qmemory6;
		movd mm7,qmemory7;

		movd eax,mm7; //eax==long(mm7)
//change mm0..mm7 manually
		movq qmemory0,mm0;
		movq qmemory1,mm1;
		movq qmemory2,mm2;
		movq qmemory3,mm3;
		movq qmemory4,mm4;
		movq qmemory5,mm5;
		movq qmemory6,mm6;
		movq qmemory7,mm7;
//check if qmemory[0..7] is what you've changed
//TODO some arithmetics (pand paad psub)
	} //__asm

} //if
} //MMXRegs()
#pragma warning(default:4799)

int main(int argc, char *argv[])
{
	pointers_to_functions();
	
	guids_and_refguids();
	
	variants();

	MMXRegs();
//TODO add sth with safearray
//TODO come up with more values (different facilities) & unknown valuses (bad values do not apply)
//hresults & errors & misc (@TIB, @MM)
	HRESULT s_ok = S_OK;

	HRESULT s_err = E_NOINTERFACE;

	HRESULT s_unexp = E_UNEXPECTED;

	HRESULT s_eomem = E_OUTOFMEMORY;

	SetLastError(42);


	_asm int 3;					// stop here
	return 0;
}

//	Eval					Expected			VC5.0 did
//	pfunc					ADDR func			ADDR
//	(aclass).__vfptr[0x0]	ADDR AClass::f1		ADDR
//	@ERR					42					N/A
//	@TIB					ADDR				N/A
//	@MM0					ADDR64				N/A
//	refiid					{IID_IUnknown}		{...}
//	pGuid					{IID_IClassFactory}	{...}
//	variant					{42 VT_I4}			{...}
//	s_ok,hr					S_OK				N/A
//	5,hr					0x00000005 Access is denied.	N/A


/* GLS script
launch ee2\debug\ee2.exe
until EntryPointEvent2 wait
go
until CodeBreakpointEvent2 wait
seval "pfunc","ADDRESS func"
seval "(aclass).__vfptr[0x0]","ADDRESS AClass::f1"
#seval "@ERR","42"
#seval "@TIB,x","ADDRESS "
#seval "@MM0","ADDRESS64 "
seval "refiid","{IID_IUnknown}"
seval "pGuid","{IID_IClassFactory}"
seval "variant","{42 VT_I4}"
seval "s_ok,hr","S_OK"
seval "5,hr","0x00000005 Access is denied. "
seval "pBadGuid","ADDRESS {????????-????-????-????-????????????}"
go
until SessionDestroyEvent2 wait
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\fibon\dll.h ===
enum CALLTYPE{ __INT64=0, UNSIGNED, SIGNEDLONG};

class __declspec(dllexport) dll_class
	{
		private:
			int dll_class_var;

			__int64 fibon(__int64 n);
			long fibon(unsigned int u);
			long fibon(long m);
			long fibon(float f);
			__int64 fibontype(__int64 n, CALLTYPE type = UNSIGNED);
			int average(int first, ...);
			double factorial(double nn);
			void fiboncases(int argc, char *argv[]);

		public:
			/*__declspec(dllexport)*/ dll_class(void);
			/*__declspec(dllexport)*/ int dll_class_func(int i);
	};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\fibon\driverdll.cpp ===
#include "dll.h"


void main(int argc, char *argv[])
{
	dll_class theClass;
	theClass.dll_class_func(5);
	theClass.dll_class_func(1);
	theClass.dll_class_func(10);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\fibon\dll.cpp ===
#include "dll.h"

dll_class::dll_class(void)
{
	dll_class_var = 0;
}

int dll_class::dll_class_func(int i)
{
	dll_class_var = i;
	char *argv[]= {"damn dll", "4", "2"};

	while(i-->0)
		fiboncases(3,argv);

	return dll_class_var;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\fibon\fibon.cpp ===
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <stdarg.h>
//placeholders for types
long g_long=1;
int  g_int=2;
unsigned int g_unsigned=3;
__int64 g__int64=4;
double  g_double=5.0;


#ifdef DLL_CLASS
#include "dll.h"
#else
	enum CALLTYPE{ __INT64=0, UNSIGNED, SIGNEDLONG};
	__int64 fibontype(__int64 n, CALLTYPE type = UNSIGNED);
#endif

__int64
#ifdef DLL_CLASS
	dll_class::
#endif
fibon(__int64 n)
{
	if(n==0)
		return 1;
	if(n==1)
		return 1;
	return fibon(n-2) + fibon(n-1);
}


long
#ifdef DLL_CLASS
	dll_class::
#endif
fibon(float f)
{
	__int64 n=abs(static_cast<__int64>(f));
	return fibon((n));
}

long
#ifdef DLL_CLASS
	dll_class::
#endif
fibon(unsigned int u)
{ //funny thing: return the -fib(u)
	if(u==0)
		return -1;
	if(u==1)
		return -1;
	return -(fibon(u-2) + fibon(u-1));
}


long
#ifdef DLL_CLASS
	dll_class::
#endif
fibon(long m)
{
	if(m==0)
		return 1;
	int fib0=0;
	int fib1=1;

	for(int i=0; i<m; i++)
	{
		long temp = fib0;
		fib0 = fib1;
		fib1 = temp + fib1;
		/* fib0 += fib1; fib1 = fib0 - fib1 */
	}
	return fib1;
}


__int64
#ifdef DLL_CLASS
	dll_class::
#endif
fibontype(__int64 n, CALLTYPE type /*= UNSIGNED*/)
{
	__int64 result=0;
	switch(type)
	{
	case __INT64: result = fibon(__int64(n));
		break;
	case UNSIGNED: result = fibon(unsigned int(n));
		break;
	case SIGNEDLONG: result = fibon(long(n));
	}
	return result;
}


//****************************************************************************
// Purpose:     function returning address and has ... parameter
int
#ifdef DLL_CLASS
	dll_class::
#endif
average(int first, ...)
{
    int count = 0, sum = 0, i = first;
    va_list marker;

    va_start(marker, first);
    while (i != INT_MIN)
    {
        sum += i;
        count++;
        i = va_arg(marker, int);
    }
    va_end(marker);
    return (sum ? (sum/count):(0));
}

/*template <long nn>
long factorial(long  nn)
{ 
	return nn*factorial<nn-1>(nn-1); 
}

template<> long factorial<0>(long n)
{ return 1; }*/
double 
#ifdef DLL_CLASS
	dll_class::
#endif
factorial(double nn)
{
	return (nn<=1)?1:factorial(nn-1)*nn;
}


//long fact(long)
//	long fact = factorial<40>(40);
//	double fact = factorial(m);

void 
#ifdef DLL_CLASS
	dll_class::
#endif
fiboncases(int argc, char *argv[])
{

	__int64 nint64=(argc>1)?atoi(*(argv+1)):0; //arg for recursive fibon
	long nlong=1;
	long m=(argc>2)?atoi(*(argv+2)):0; //arg for norec fibon

	long tlong = fibon(5u);
	__int64 fib=0;
	fib=fibon(4i64);
	fib=fibon(g_unsigned);
	fib=fibon(nlong);
	fib=fibontype(fibon(4u), SIGNEDLONG);
	double dresult = factorial( fibon(nlong));
	fibon((float)dresult);
	printf("fibon(%d):%d\n",nint64,fib);
	fib=fibon(m);
	printf("no rec fibon(%d):%d\n",m,fib);
	printf("Average:%d\n",average(0,fibon(g_unsigned),3,4,5,6,7,8, INT_MIN) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\fibon\fib.cpp ===
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <stdarg.h>
//placeholders for types
long g_long=1;
int  g_int=2;
unsigned int g_unsigned=3;
__int64 g__int64=4;
double  g_double=5.0;

enum CALLTYPE{ __INT64=0, UNSIGNED, SIGNEDLONG};


__int64 fibon(__int64 n)
{
	if(n==0)
		return 1;
	if(n==1)
		return 1;
	return fibon(n-2) + fibon(n-1);
}


long fibon(unsigned int u)
{ //funny thing: return the -fib(u)
	if(u==0)
		return -1;
	if(u==1)
		return -1;
	return -(fibon(u-2) + fibon(u-1));
}


long fibon(long m)
{
	if(m==0)
		return 1;
	int fib0=0;
	int fib1=1;

	for(int i=0; i<m; i++)
	{
		long temp = fib0;
		fib0 = fib1;
		fib1 = temp + fib1;
		/* fib0 += fib1; fib1 = fib0 - fib1 */
	}
	return fib1;
}


__int64 fibontype(__int64 n, CALLTYPE type = UNSIGNED)
{
	__int64 result=0;
	switch(type)
	{
	case __INT64: result = fibon(__int64(n));
		break;
	case UNSIGNED: result = fibon(unsigned int(n));
		break;
	case SIGNEDLONG: result = fibon(long(n));
	}
	return result;
}


//****************************************************************************
// Purpose:     function returning address and has ... parameter
int average(int first, ...)
{
    int count = 0, sum = 0, i = first;
    va_list marker;

    va_start(marker, first);
    while (i != INT_MIN)
    {
        sum += i;
        count++;
        i = va_arg(marker, int);
    }
    va_end(marker);
    return (sum ? (sum/count):(0));
}

/*template <long nn>
long factorial(long  nn)
{ 
	return nn*factorial<nn-1>(nn-1); 
}

template<> long factorial<0>(long n)
{ return 1; }*/
double factorial(double nn)
{
	return (nn<=1)?1:factorial(nn-1)*nn;
}


//long fact(long)
//	long fact = factorial<40>(40);
//	double fact = factorial(m);

void fiboncases(int argc, char *argv[])
{

	__int64 nint64=(argc>1)?atoi(*(argv+1)):0; //arg for recursive fibon
	long nlong=1;
	long m=(argc>2)?atoi(*(argv+2)):0; //arg for norec fibon

	long tlong = fibon(5u);
	__int64 fib=0;
	fib=fibon(4i64);
	fib=fibon(g_unsigned);
	fib=fibon(nlong);
	fib=fibontype(fibon(4u), __INT64);
	double dresult = factorial( fibon(nlong));
	printf("fibon(%d):%d\n",nint64,fib);
	fib=fibon(m);
	printf("no rec fibon(%d):%d\n",m,fib);
	printf("Average:%d\n",average(1,2,3,4,5,6,7,8, INT_MIN) );
}


void main(int argc, char *argv[])
{
	for(int i=0;i<10;i++)
		fiboncases(argc,argv);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\fibon\winmain.cpp ===
#include <windows.h>

extern void fiboncases(int argc, char *argv[]);


int PASCAL WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR lszCmdLine, int nCmdShow)
{
	char *argv[]= {"damn executable", "5", "3"};
	for(int i=0;i<10;i++)
		fiboncases(3,argv);
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\fibon\main.cpp ===
extern void fiboncases(int argc, char *argv[]);


void main(int argc, char *argv[])
{
	for(int i=0;i<10;i++)
		fiboncases(argc,argv);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\namspace\nspace01.cpp ===
#include <windows.h>

int i = 0;
int j = 0;

namespace n1
	
	{
	int i = 1;
	int j = 1;

	void func(void)
		{				// first line of n1::func()
		int local = 3;
		}

	namespace n2
		{
		int i = 2;
		int j = 2;
		}
	}

int PASCAL WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR lszCmdLine, int nCmdShow)
	{
	using namespace n1;
	func();
	if (j==1) {
		j += 2;
	}
	else {
		j *= 10; 
	}
	return 0;		// line after n1::j changed
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\nlg\eh01.cpp ===
#include "ehutil.h"
#include "nlgmain.h"

int counter = 0;
int ctorCounter = 0;
int dtorCounter = 0;

void eh01(void)
{
	int caseNum = 0;
	try 
	{
		++caseNum;
		Case1();   //throws t; no handler
		++caseNum; // should not execute
	}
	catch( ... ) // after Case1
	{
		++caseNum;
		Case2();   // doesn't throw anything
		++caseNum; // should execute

		try {
			++caseNum;
			Case3();   // throws t; doesn't catch it
			++caseNum; // should not execute
		}
		catch( ... ){ // after Case3
			try {
				++caseNum;
				Case4();   // throws t and catches it
				++caseNum; // should execute
			}
			catch( ... ) { // after Case4
				++caseNum; // should not execute
			}
		}
	}

 	try {
		++caseNum;
		Case5();   // throws t and catches it
		++caseNum; // should execute
	}
	catch( ... ) {
		++caseNum; // should not execute
	}

	try {
		++caseNum;
		Case6();   // throws t, rethrows it and catches it
		++caseNum; // should execute
	}
	catch( ... ) {
		++caseNum; // should not execute
	}

	try {
		++caseNum;
		Case7();   // throws t, rethrows it and catches it
		++caseNum; // should execute
	}
	catch( ... ) {
		++caseNum; // should not execute
	}

//	try {
//		++caseNum;
//		Case8();   // throws t, Ctor throws an int, Case8 doesn't catch t ??
//		++caseNum; // should execute ?
//	}
//	catch( ... ) {
//		++caseNum; // should not execute
//	}

	++caseNum; // should execute

}


/////////////////////////////////////////////////////////////////////////////

void Case1() {
	//	Throw without handler.
	ThrowObject t(1);
	throw t;	

	++counter; // Should not execute
}

void Case2() {
	//	try-block without a throw
	try {
		++counter;
	}
	catch( ... ) {
		++counter; // Should not execute
	}
	++counter; // Should execute
}

void Case4() {
	//	try-block with multiple handlers
	try { ++counter; ThrowObject t(4); throw t; }
	catch( int ) {
		++counter; // Should not execute
	}
	catch( ThrowObject c ) { ++counter; /* Should execute */ }
	catch( ... ) {
		++counter; // Should not execute
	}
	++counter; // Should execute
}

void Case5() {
	//	Throw from inner try-block caught in outer handler
	try {
		++counter;
		try {			
			++counter;
			ThrowObject t(5);
			throw t;

			++counter; // Should not execute
		}
		catch( int ) {
			++counter; // Should not execute
		}
		++counter; // Should not execute
	}
	catch( ThrowObject o ) {
		++counter; // Should execute
	}
	++counter; // Should execute
}

void Case6() {
	//	Throw from inner try-block handler caught in outer handler
	try {
		++counter;
		try {
			++counter;
			ThrowObject t(6);
			throw t;

			++counter; // Should not execute
		}
		catch( ThrowObject c ) {			
			++counter; // Should execute
			throw c;

			++counter; // Should not execute
		}
		++counter; // Should not execute
	}
	catch( ThrowObject o ) {
		++counter; // Should execute
	}

	++counter; // Should execute
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\namspace\namspace.cpp ===
#include <windows.h>

int i = 0;
int j = 0;

namespace n1
	
	{
	int i = 1;
	int j = 1;

	void func(void)
		{				// first line of n1::func()
		int local = 3;
		}

	namespace n2
		{
		int i = 2;
		int j = 2;
		}
	}

int PASCAL WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR lszCmdLine, int nCmdShow)
	{
	using namespace n1;
	func();
	n1::j *= 10;
	return 0;		// line after n1::j changed
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\mem\mem.cpp ===
#include <windows.h>

// Memory Window Test

void FuncNoArg(void)
{
	return;
}

int FuncWithArg(int nArg)
{
	return nArg;
}


char FuncWithArg(char chArg)
{
	int		nJustLocalInt = 1;
	double	dJustLocalDouble = 3.14;
	return chArg + 2;
}

										/* Last FuncWithArg line */
int FAR PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)
{
	char			chJustChar = 'M'; 
	char			sJustString[] =  "Mamba-hara-mambu-ru"; /* 19 chars in the string */
	unsigned char	uchJustUnsignedChar = 'u';
	short int		nsJustShort = -123;
	unsigned short	unsJustUnsignedShort = 22987;
	int				nJustInt = -65555;
	unsigned int	unJustUnsignedInt = 655551;
	long int		lJustLongInt = -77777;
	unsigned long	ulJustUnsignedLongInt  = 999999;	
	float			fJustFloat = (float) 123.14;
	double			dJustDouble = -777e50;
	long double		dlJustLongDouble = -999e70;
	__int64			sfJustSixtyFourInt = -1234567890987654909;
	unsigned __int64 sfJustSixtyFourUnsignedInt = 9876543212345678123;

	// Arrays for the Column test
	const int number_of_columns_to_be_tested = 3;

	char			asJustString [number_of_columns_to_be_tested + 2] = "Mamb";
	char			asLongString[8*number_of_columns_to_be_tested + 2] = "Mamba-Tumba-Rumba-Shurum";
	short int		ansJustShort[number_of_columns_to_be_tested + 1] = { -123, 12, -34, 45};
	unsigned short	aunsJustUnsignedShort[number_of_columns_to_be_tested + 1] = { 22987, 126, 334, 645};
	int				anJustInt[number_of_columns_to_be_tested + 1] = { -65555, 112, -354, 4451};
	unsigned int	aunJustUnsignedInt[number_of_columns_to_be_tested + 1] = { 655551, 2112, 9834, 45008};
	long int		alJustLongInt[number_of_columns_to_be_tested + 1] = { -77777, 120087, 3477, 99045};
	unsigned long	aulJustUnsignedLongInt[number_of_columns_to_be_tested + 1]  = { 999999, 77712, 36544, 22245};
	float			afJustFloat[number_of_columns_to_be_tested + 1] = { (float) 123.14, (float) 23.16, (float) 60.70, (float) 2.93};
	double			adJustDouble[number_of_columns_to_be_tested + 1] = { -777e50,  77e22,  12e5,  54e10};
	long double		adlJustLongDouble[number_of_columns_to_be_tested + 1] = { -999e70, 89e3,  18e2,  -4e17};
	__int64			asfJustSixtyFourInt[number_of_columns_to_be_tested + 1] = { -1234567890987654909, 1, -2, -3 };
	unsigned __int64 asfJustSixtyFourUnsignedInt[number_of_columns_to_be_tested + 1] = { 9876543212345678123, 12, 45, 1};

	// Pointers
	int		*pnJustIntPtr = &nJustInt;
	void	*pvJustVoidPtrStr = (void*) &sJustString;
	void	*pvJustVoidPtrShort = (void*) &ansJustShort;
	void	*pvJustVoidPtrInt = (void*) &anJustInt;
	void	*pvJustVoidPtrFloat = (void*) &afJustFloat;
	void	*pvJustVoidPtrDouble = (void*) &adJustDouble;
	void	*pvJustVoidPtrInt64 = (void*) &asfJustSixtyFourUnsignedInt;

	nJustInt++;								/* First line for tests */				
	chJustChar++;

	chJustChar = FuncWithArg(chJustChar);	/* Second line for tests */
	FuncNoArg();							/* Third line for tests */

	return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\fibon\testf.cpp ===
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <stdarg.h>
//placeholders for types
long g_long=1;
int  g_int=2;
unsigned int g_unsigned=3;
__int64 g__int64=4;
double  g_double=5.0;

enum CALLTYPE{ __INT64=0, UNSIGNED, SIGNEDLONG};


__int64 fibon(__int64 n)
{
	if(n==0)
		return 1;
	if(n==1)
		return 1;
	return fibon(n-2) + fibon(n-1);
}


long fibon(unsigned int u)
{ //funny thing: return the -fib(u)
	if(u==0)
		return -1;
	if(u==1)
		return -1;
	return -(fibon(u-2) + fibon(u-1));
}


long fibon(long m)
{
	if(m==0)
		return 1;
	int fib0=0;
	int fib1=1;

	for(int i=0; i<m; i++)
	{
		long temp = fib0;
		fib0 = fib1;
		fib1 = temp + fib1;
		/* fib0 += fib1; fib1 = fib0 - fib1 */
	}
	return fib1;
}


__int64 fibontype(__int64 n, CALLTYPE type = UNSIGNED)
{
	__int64 result=0;
	switch(type)
	{
	case __INT64: result = fibon(__int64(n));
		break;
	case UNSIGNED: result = fibon(unsigned int(n));
		break;
	case SIGNEDLONG: result = fibon(long(n));
	}
	return result;
}


//****************************************************************************
// Purpose:     function returning address and has ... parameter
int average(int first, ...)
{
    int count = 0, sum = 0, i = first;
    va_list marker;

    va_start(marker, first);
    while (i != INT_MIN)
    {
        sum += i;
        count++;
        i = va_arg(marker, int);
    }
    va_end(marker);
    return (sum ? (sum/count):(0));
}

/*template <long nn>
long factorial(long  nn)
{ 
	return nn*factorial<nn-1>(nn-1); 
}

template<> long factorial<0>(long n)
{ return 1; }*/
double factorial(double nn)
{
	return (nn<=1)?1:factorial(nn-1)*nn;
}


//long fact(long)
//	long fact = factorial<40>(40);
//	double fact = factorial(m);

void fiboncases(int argc, char *argv[])
{

	__int64 nint64=(argc>1)?atoi(*(argv+1)):0; //arg for recursive fibon
	long nlong=1;
	long m=(argc>2)?atoi(*(argv+2)):0; //arg for norec fibon

	long tlong = fibon(5u);
	__int64 fib=0;
	fib=fibon(4i64);
	fib=fibon(g_unsigned);
	fib=fibon(nlong);
	fib=fibontype(fibon(4u), SIGNEDLONG);
	double dresult = factorial( fibon(nlong));
	printf("fibon(%d):%d\n",nint64,fib);
	fib=fibon(m);
	printf("no rec fibon(%d):%d\n",m,fib);
	printf("Average:%d\n",average(0,fibon(g_unsigned),3,4,5,6,7,8, INT_MIN) );
}


void main(int argc, char *argv[])
{
	for(int i=0;i<10;i++)
		fiboncases(argc,argv);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\locpane\Locals Application.cpp ===
#include <windows.h>

// Locals Test

void FuncNoArg(void)
{
	return;
}

char FuncWithArg(char chArg)
{
	int		nJustLocalInt = 1;
	double	dJustLocalDouble = 3.14;
	return chArg + 2;
}										/* Last FuncWithArg line */
int FAR PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)
{
	char	chJustChar = 'a'; 
	int		nJustInt = 1965;
	int		&nJustIntRef =  nJustInt;
	double	dJustDouble = 2.92;

	nJustInt++;								/* First line for tests */				
	chJustChar++;

	chJustChar = FuncWithArg(chJustChar);	/* Second line for tests */
	FuncNoArg();							/* Third line for tests */

	return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\nlg\eh01.h ===
#ifndef EH01_H
#define EH01_H

class ThrowObject {
public:
	ThrowObject();
	ThrowObject( int i );
	ThrowObject( const ThrowObject& );
	~ThrowObject();

private:
	int m_i;
};

extern int counter;

void Case1();
void Case2();
void Case3();
void Case4();
void Case5();
void Case6();
void Case7();

#endif // EH01_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\nlg\nlgmain.cpp ===
// nlgmain.cpp 
#include <windows.h>
#include "nlgmain.h"

int PASCAL WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR lszCmdLine, int nCmdShow)
{
	eh01();		// C++ exception handling cases
	//seh01();	// Structured exception handling cases
	ljmp01();		// Setjmp/Longjmp cases

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\nlg\nlgmain.h ===
// nlgmain.h
#include <setjmp.h>
 
#ifndef NLGMAIN_H
#define NLGMAIN_H

void eh01(void);
void seh01(void);
void ljmp01(void);
void ljmp02(jmp_buf mark, int nCase);

void Case1();
void Case2();
void Case3();
void Case4();
void Case5();
void Case6();
void Case7();
void Case8();


#endif // NLGMAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\nlg\ljmp02.cpp ===
#include "nlgmain.h"
#include <setjmp.h>
#include <float.h>
#include <math.h>

//jmp_buf mark;

void ljmp02(jmp_buf mark, int nCase)
{
	int i = (int)(fmod(nCase, 3.0));
	if( i == 0 )
		longjmp( mark, -1 );
	else
		longjmp( mark, i );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\nlg\ehutil.cpp ===
#include "ehutil.h"


ThrowObject::ThrowObject() {
	m_i = 0; m_iCopy = 0;
}


ThrowObject::ThrowObject( int i ) {
	m_i = i; m_iCopy = 0;
}


ThrowObject::ThrowObject( const ThrowObject& src) {
	++ctorCounter;
	m_i = src.m_i; m_iCopy = src.m_iCopy + 1;

	//	Decrement m_i if non-zero and throw exception if m_i 
	//	decrements to 0.
//	if( m_i > 0 ) {
//		m_i--;
//		if( m_i == 0 ) {
//			throw m_i;
//		}
//	}
}


ThrowObject::~ThrowObject() {
	++dtorCounter;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\nlg\eh02.cpp ===
#include "ehutil.h"
#include "nlgmain.h"

extern int counter;

void Case3() {
	//	try-block with unhandled throw
	try {
		++counter;
		ThrowObject t(3);
		throw t;
	}
	catch( int ) {
		++counter; // Should not execute
	}
	++counter; // Should not execute
}

void Case7() {
	//	Rethrow from inner try-block handler caught in outer handler
	try {
		++counter;
		try {
			++counter;
			ThrowObject t(7);
			throw t;
//  int ii=5;
//  throw ii;
			++counter; // Should not execute
		}
		catch( int ) {			
			++counter; // Should execute
			throw;

			++counter; // Should not execute
		}
		catch( ThrowObject& ) {			
			++counter; // Should execute
			throw;

			++counter; // Should not execute
		}
		++counter; // Should not execute
	}
	catch( int ) {
		++counter; // Should execute
	}
	catch( ThrowObject o ) {
		++counter; // Should execute
	}

	++counter; // Should execute

	Case5();   // throws t and catches it
}


void Case8() {
	//	Throw from inner try-block caught in outer handler; Ctor throws an int
	try {
		++counter;
		try {			
			++counter;
			ThrowObject t(8);
			t = ThrowObject(80);
			throw t;

			++counter; // Should not execute
		}
		catch( int ) {
			++counter; // Should execute
		}
		++counter; // Should execute ?
	}
	catch( ThrowObject o ) {
		++counter; // Should execute
	}
	++counter; // Should execute
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\nlg\ljmp01.cpp ===
// fpreset.c 
//#include <stdio.h>
//#include <signal.h>
#include <setjmp.h>
//#include <stdlib.h>
#include <float.h>
#include <math.h>
//#include <string.h>
#include "nlgmain.h"

jmp_buf mark;
int     error;
double check( int i );

//void main( void )
void ljmp01(void)
{
	double n1, n2, r1, r2;
	int jmpret;
#ifndef _68K_
	for( int i = 0; i < 100; i++ )
	{
		jmpret = setjmp( mark );
		if( jmpret == 0 )
		{
			n1 = 0.5 * (i + 3);
			r2 = (i + 7);
			r2 /= 7;
			n2 = modf( r2 , &r1 );
			if( n2 <= 0.0000000001 )
			{
				longjmp( mark, -1 );
			}
			else
			{
				r1 = n1/n2;
			}
		}
		else
			r1 = check(i);
	}

	for( i = 0; i < 100; i++ )
	{
		jmpret = setjmp( mark );
		switch( jmpret )
		{
			case 0:
				n1 = 0.5 * (i + 3);
				r2 = (i + 7);
				r2 /= 7;
				n2 = modf( r2 , &r1 );
				if( n2 <= 0.0000000001 )
				{
					ljmp02( mark, i );
				}
				else
				{
					r1 = n1/n2;
				}
				break;
			case -1:
				r1 = check(i);
				break;
			case 1:
				r1 = check(i) + 2.5;
				break;
			case 2:
				r1 = i * (i + 2) * 1.5;
				break;
			default:
				break;
		}
	}
#endif
}

double check( int i )
{
	return ( 0.7 * (i + 2)	);	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\registers\registers.cpp ===
#include <windows.h>


DWORD dwMainThreadID;
DWORD dwSecondaryThreadID;


LPTHREAD_START_ROUTINE ThreadRoutine(LPVOID pArg)
{
	while(1)
		Sleep(5000);		/* Thread proc */		
	return 0;
}

int Foo(int nArg)
{
	return nArg*2;
}							/* Return form Foo */


int FAR PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)
{

	HANDLE hThread;
	int res = Foo(7);		/* First line for tests */

	double y = 1e-19;
	_asm fld y;
	
	float f1;

	/* check Overflow exception */
	f1 = (float) 1.234567e38;
	f1 *= f1;
	f1 *= f1;	/* Exception should be here for CTRL 277 */
	f1 *= f1;

	/* check divide by zero exception */
	f1 = 10.;
	f1 /= 0;	/* Exception should be here for CTRL 27B */


	dwMainThreadID = GetCurrentThreadId();
	hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ThreadRoutine, (void*) &res, 0L, &dwSecondaryThreadID);
	ResumeThread(hThread);

	while(1)						
		Sleep(5000);

	return 1;							
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\nlg\ehutil.h ===
#ifndef EHUTIL_H
#define EHUTIL_H


class ThrowObject {
public:
	ThrowObject();
	ThrowObject( int i );
	ThrowObject( const ThrowObject& );
	~ThrowObject();

private:
	int m_i;
	int m_iCopy;
};

extern int counter;
extern int ctorCounter;
extern int dtorCounter;


#endif // EHUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\retval\nodebug.cpp ===
int no_debug_info(void)
	{
	return 1;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\retval\lineonly.cpp ===
int line_numbers_only(void)
	{
	return 1;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\seh01\seh01.h ===
#ifndef SEH01_H
#define SEH01_H

void Seh01();
void SehCase1();
void SehCase2();
void SehCase3();
void SehCase4();
void SehCase5();
void SehCase6();
void SehCase7();
void SehCase8();

#endif  // SEH01_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\Registers PP\Registers PP.cpp ===
#include <windows.h>

__int64 GlobalInt64 = 0;

void set_GlobalInt64(int Hi, int Low);
void set_XMMRegister(int regid, char upper, int Hi, int Low);
void set_XMMRegister(int regid, int X3, int X2, int X1, int X0);

__int64 FloatVal[] =	//	32 bit register values for each integer
{
	0,				//	0
	0x3F800000,		//	1
	0x40000000,		//	2
	0x40400000,		//	3
	0x40800000,		//	4
	0x40A00000,		//	5
	0x40C00000,		//	6
	0x40E00000,		//	7	
	0x41000000,		//	8
	0x41100000,		//	9
	0x41200000,		//	10
	0x41300000,		//	11
	0x41400000,		//	12
	0x41500000,		//	13
	0x41600000,		//	14
	0x41700000,		//	15
	0x41800000,		//	16
	0x41880000,		//	17	
	0x41900000,		//	18
	0x41980000,		//	19
	0x41A00000,		//	20
	0x41A80000,		//	21
	0x41B00000,		//	22
	0x41B80000,		//	23
	0x41C00000,		//	24
	0x41C80000,		//	25
	0x41D00000,		//	26
	0x41D80000,		//	27	
	0x41E00000,		//	28
	0x41E80000,		//	29
	0x41F00000,		//	30
	0x41F80000,		//	31
	0x42000000,		//	32
};

void TestMMX()
{
	//	MMX test
	
	__int64 regVal = 0;

	regVal = 100;
	__asm { MOVQ MM0, regVal }

	regVal = 200;
	__asm { MOVQ MM1, regVal }

	regVal = 300;
	__asm { MOVQ MM2, regVal }

	regVal = 400;
	__asm { MOVQ MM3, regVal }

	regVal = 500;
	__asm { MOVQ MM4, regVal }

	regVal = 600;
	__asm { MOVQ MM5, regVal }

	regVal = 700;
	__asm { MOVQ MM6, regVal }

	regVal = 800;
	__asm { MOVQ MM7, regVal }

	regVal = 0;
	regVal = 1;
}

void Test3dNow()
{
	//	3dnow test
	
	__int64 regVal = 0;

	regVal = 4611686019492741120;
	__asm { MOVQ MM0, regVal }

	regVal = 4647714816524288000;
	__asm { MOVQ MM1, regVal }

	regVal = 4665729215040061440;
	__asm { MOVQ MM2, regVal }

	regVal = 4683743613553737728;
	__asm { MOVQ MM3, regVal }

	regVal = 4692750812811624448;
	__asm { MOVQ MM4, regVal }

	regVal = 4701758012068462592;
	__asm { MOVQ MM5, regVal }

	regVal = 4710765211325300736;
	__asm { MOVQ MM6, regVal }

	regVal = 4719772410582138880;
	__asm { MOVQ MM7, regVal }

	regVal = 0;
	regVal = 1;
}

void TestXMM()
{
	//	XMM test
	
	float fVal = 0;

	set_XMMRegister(0,4,3,2,1); 
	set_XMMRegister(1,8,7,6,5);
	set_XMMRegister(2,12,11,10,9); 
	set_XMMRegister(3,16,15,14,13);
	set_XMMRegister(4,20,19,18,17); 
	set_XMMRegister(5,24,23,22,21);
	set_XMMRegister(6,28,27,26,25); 
	set_XMMRegister(7,32,31,30,29);

	fVal = 1.0;
	fVal = 2.0;
	fVal = 3.0;
}


int FAR PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)
{
	//	MMX & MMX2 tests for 3dNow, Katmai
	TestMMX();
	Test3dNow();
	TestXMM();

	return 1;							
}

void set_GlobalInt64(int Hi, int Low)
{
	__int64 HiVal = FloatVal[Hi];
	__int64 LowVal = FloatVal[Low];

	GlobalInt64 = HiVal;
	GlobalInt64  = GlobalInt64 << 32;
	GlobalInt64 |= LowVal;
}

void set_XMMRegister(int regid, char upper, int Hi, int Low)
{

	switch (regid)
	{
		case 0:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM0, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM0, GlobalInt64 }
					}
					break;

		case 1:					
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM1, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM1, GlobalInt64 }
					}
					break;


		case 2:					
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM2, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM2, GlobalInt64 }
					}
					break;

		case 3:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM3, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM3, GlobalInt64 }
					}
					break;


		case 4:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM4, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM4, GlobalInt64 }
					}
					break;

		case 5:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM5, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM5, GlobalInt64 }
					}
					break;

		case 6:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM6, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM6, GlobalInt64 }
					}
					break;

		case 7:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM7, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM7, GlobalInt64 }
					}
					break;
	}
}


void set_XMMRegister(int regid, int X3, int X2, int X1, int X0)
{
	set_XMMRegister(regid, 1, X3, X2);	//	upper 64 bits
	set_XMMRegister(regid, 0, X1, X0);	//	lower 64 bits
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\retval\retval.cpp ===
#include <windows.h>
#include <float.h>
#include <limits.h>
#include <stdlib.h>

void func_void(void)
	{
	}

char func_char(void)
	{
	return CHAR_MAX;
	}

unsigned char func_uchar(void)
	{
	return UCHAR_MAX;
	}

int func_int(void)
	{
	return INT_MAX;
	}

unsigned int func_uint(void)
	{
	return UINT_MAX;
	}

long func_long(void)
	{
	return LONG_MAX;
	}

unsigned long func_ulong(void)
	{
	return ULONG_MAX;
	}

float func_float(void)
	{
	return FLT_MAX;
	}
	
double func_double(void)
	{
	return DBL_MAX;
	}

long double func_ldouble(void)
	{
	return LDBL_MAX;
	}

class base
	{
	public: 
		int m_var;
		virtual int m_func(void){return 0;}
		int overloaded_func(int i){return i;}
	};

class derived : public base
	{
	public:
		virtual int m_func(void){return m_var;}
		char overloaded_func(char ch){return ch;}
	};

base func_class(void)
	{
	base b;
	b.m_var = 1;
	return b;
	}

base *func_pclass(void)
	{
	base *pb = new base;
	pb->m_var = 1;
	return pb;
	}

void func_throw(void)
	{
	throw 0;
	}

int recursive_func(int i)
	
	{
	if(i == 5)
		return i; // most nested return
	else
		{
		recursive_func(i + 1);
		return i;
		} 
	}

#ifndef _MPPC_
int __fastcall fastcall_func(void)
	{
	return 1;
	}
#endif // _MPPC_
		
int	no_debug_info(void);
int	line_numbers_only(void);
int dll_func(void);

int overloaded_func(int i){return i;}
char overloaded_func(char ch){return ch;}


int PASCAL WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR lszCmdLine, int nCmdShow)
	
	{
	func_void();

	for(0;0;0);
	while(0);

	char ch = func_char();
	unsigned char uch = func_uchar();
	int i = func_int();
	unsigned int ui = func_uint();
	long l = func_long();
	unsigned long ul = func_ulong();
	float flt = func_float();
	double dbl = func_double();
	long double ldbl = func_ldouble();

	base b = func_class();
	base *pb = func_pclass();

	GetLastError();
	no_debug_info();
	line_numbers_only();
	recursive_func(1);

#ifndef _MPPC_
	fastcall_func();
#endif // _MPPC_

	abs(-1);
	while(0);

	base *pd = new derived;
	pd->m_var = 1;
	pd->m_func();
	while(0);

	pb->overloaded_func(1);
	pb->overloaded_func('a');
	overloaded_func(2);
	overloaded_func('b');

#ifndef _68K_
	dll_func();
#endif // _68K_

	try
		{
		func_throw();
		}

	catch(...)
		{
		}

	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\seh01\seh01.cpp ===
#include "sehutil.h"
#include "seh01.h"

int main()
{
	Seh01();

	return 0;
}

void Seh01()
{
	SehCase1();
	SehCase2();
	SehCase3();
	SehCase4();
	SehCase6();
	SehCase8();

	SehCase5();
	SehCase7();

}

void SehCase1() 
{
	++counter;

	//	Simple __try/__except with no exception.

	__try {
		++counter;
		RaiseNoException();
	}
	__except( ++counter, ExecuteHandler() ) {
		++counter; // Code should be skipped.
	}
	++counter; // should execute	
}

void SehCase2() 
{
	++counter;

	//	Simple __try/__finally with no exception.

	__try {
		++counter;
		RaiseNoException();
	}
	__finally {
		++counter; // should execute	
	}	
}

void SehCase3() 
{
	++counter;

	//	Simple __try/__except: EXCEPTION_CONTINUE_EXECUTION.

	__try {
		++counter;
		//	Use software exception from RaiseIntDivideByZero() instead of 
		//	hardware exception from IntDivideByZero() since continuing execution
		//	without fixing fault condition causes an infinite loop.

		RaiseIntDivideByZero();

		++counter; // Should continue here
	}
	__except( ++counter, ContinueExecution() ) {
		++counter; // Code should be skipped.
	}	
	++counter; // should execute	
}

void SehCase4() 
{
	++counter;

	//	Simple __try/__except: EXCEPTION_EXECUTE_HANDLER.

	__try {
		++counter;
		IntDivideByZero();
		//	Should no reach here.
		++counter;
	}
	__except( ++counter, ExecuteHandler() ) {
		++counter; // should execute	
	}	
}

void SehCase5() 
{
	++counter;

	//	Simple __try/__except: EXCEPTION_CONTINUE_SEARCH.

	__try {
		++counter;

		IntDivideByZero();
		//	Code could be executed if final handler returns
		//	EXCEPTION_CONTINUE_EXECUTION.
		++counter;
	}
	__except( ++counter, ContinueSearch() ) {
		++counter; // Code should be skipped
	}	
	++counter; // should execute	
}

void SehCase6() 
{
	++counter;

	//	Simple __try/__finally with exception.

	__try {
		++counter;
		__try {
			++counter;
			IntDivideByZero();
			//	Should no reach here.
			++counter;
		}
		__finally {
			++counter; // should execute	
		}
		//	Should not reach here.
		++counter;
	}
	__except( ++counter, ExecuteHandler() ) {
		++counter; // should execute	
	}
}


void SehCase7() 
{
	++counter;

	//	__try/__except: EXCEPTION_CONTINUE_SEARCH.

	__try {
		++counter;
		__try {
			++counter;

			IntDivideByZero();
			//	Code could be executed if final handler returns
			//	EXCEPTION_CONTINUE_EXECUTION.
			++counter;
		}
		__except( ++counter, ContinueSearch() ) {
			++counter; // Code should be skipped
		}	
		++counter; // should execute
	}	
	__except( ++counter, ContinueExecution() ) {
		++counter; // Code should be skipped
	}	
	++counter; // should execute	
}

void SehCase8() 
{
	++counter;

	//	Simple __try/__finally with exception.

	__try {	
		++counter; 
		__try { ++counter; RaiseIntDivideByZero(); /* Should no reach here */ ++counter;}
		__finally { ++counter; /* should execute */ }
		//	Should not reach here.
		++counter;
	}
	__except( ++counter, ExecuteHandler() ) {
		++counter; // should execute	
	}

	__try { ++counter; RaiseIntDivideByZero(); ++counter; /* Should continue here */ }
	__except( ++counter, ContinueExecution() ) { ++counter; /* Code should be skipped */ }	
	++counter; // should execute	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\spcfc01\Spcfc01.h ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static int foo_Include(int number);
int TestG(void);
int func(int);
int recur_func();
void nest_func(int);
typedef int My_typedef;
int main(void);

int foo_Include(int number)
{
	number*=2;
	if(number == 3)
	{
		return (-1);
	}
	return number;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\retval\testdll.cpp ===
_declspec(dllexport) int dll_func(void)
	{
	return 1;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\seh01\sehutil.h ===
//
//	Use counter for tracing execution/setting breakpoints
//
#include <wtypes.h>

extern int counter;

//	Functions for causing exceptions.

void RaiseNoException();
void RaiseIntDivideByZero();
void RaiseControlC();
void IntDivideByZero();


//	Functions used for filter-expressions.

LONG ContinueExecution();
LONG ExecuteHandler();
LONG ContinueSearch();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\seh01\sehutil.cpp ===
//		Utility functions for SEH.

//#include "stdafx.h"
#include <wtypes.h>
#include <excpt.h>
//#include <afxwin.h>
#include "sehutil.h"

//	Use counter for tracing execution/setting breakpoints

int counter = 0;


//	Functions for causing exceptions.

void RaiseNoException() {
	//
	//	Empty function call
	//
}

void RaiseIntDivideByZero() {
	RaiseException( EXCEPTION_INT_DIVIDE_BY_ZERO, 0, 0, NULL );
}

void RaiseControlC() {
	RaiseException( DBG_CONTROL_C, 0, 0, NULL );
	//	GenerateConsoleCtrlEvent(CTRL_C_EVENT, 0)
}

void IntDivideByZero() {
	int i = 1;
	int j = 0;
	int k;
	k = i/j;
}

//
//	Functions used for filter-expressions.
//
LONG ContinueExecution() {
	++counter;
	return EXCEPTION_CONTINUE_EXECUTION;
}

LONG ExecuteHandler() {
	++counter;
	return EXCEPTION_EXECUTE_HANDLER;
}

LONG ContinueSearch() {
	++counter;
	return EXCEPTION_CONTINUE_SEARCH;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\spcfc01\Spcfc02.cpp ===
#include "spcfc01.h"

void nest_func(int N)
{
 	if (func(1)) 
   	func (recur_func() + func(N));
};

int func(int N)
{ 
//		__asm int 3
	return N*2;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\spcfc01\Spcfc01.cpp ===
//#include <afx.h>
#include <iostream.h>
#include <assert.h>

#include "spcfc01.h"
#define ArrayLength 100
#define StructString65 "String65String65String65String65String65String65String65String65"
#define LocalString65  "__local_String65__local_String65__local_String65__local_String65"
#define Flag 1

int Global;

struct Struct 
{
   int IntN;
   char *String65;
} StructG;

union Union 
{
   int Int;
   long Long;
} UnionG;

enum Enum 
{
  zero,
  one,
  two,
  three
} EnumG;


int myAssert(int exp)
{
	__asm int 3
	return 1;
}

static int foo(int Parameter);
int foo(int Parameter)
{
	int i = foo_Include(Parameter);
    return (i + Parameter);
};

int recur_func() 
{
   static x=1;
   x++;
   if (x<9) return recur_func();
   else return x;
};

int TestG()
{
 	int Local;
 	int Int;
 	long Long;
 	double Double;
 	long double Ldouble;
 	float Real;
 	char *String;
 	My_typedef Mine = 99;
 
	struct Struct Struct_local;

 	struct Struct Array_struct[ArrayLength];
 	int  Array1d[3];
 	long Array2d[3][3];
 	char Array3d[3][3][3];

 	if (Flag) 
	{

		for (Int=0; Int < ArrayLength; Int++)
   		{						                      // not executable code line
			Array_struct[Int].IntN = Int;
			Array_struct[Int].String65 = StructString65;
		};	  
 	};

 	for (Int=0; Int<3; Int++) 
	{
		Array1d[Int]=Int;
     	Array2d[Int][Int]=Int;
     	Array3d[Int][Int][Int]=Int;
  	};
	
	Local=17;
 	Array1d[2]=9;
 	StructG.IntN = 1;
 	StructG.String65 = StructString65;
 	Struct_local.IntN = 11;
 	Struct_local.String65 = LocalString65;
 	Int=2;Int=6;Int=9;
 	Real=(float)1.303;
 	Double=1.303;
 	Ldouble=1.303;
 	String="this is a string";
 	Global=77;
 	Long=99;
 	Int=func(3);
 	Int=foo(Local);
	Int = foo_Include(Int);
	Mine = foo_Include(Mine);
 	Int=recur_func();
  	nest_func(foo_Include(foo(Global)));

	Int = foo( foo_Include( foo( func(2) ) ) );
	Int = foo( foo_Include( foo( recur_func() ) ) );
	Int = foo( foo_Include(foo(foo_Include(func(5)))));
	Mine = foo_Include( foo_Include( foo( func(7) ) ) );

if(func(3) == 33)goto LabeL;
	Int = 999;
LabeL: 	return 1;
}



template <class Type> class Array;
template <class Type> ostream& 
	operator<<(ostream&, Array<Type>&);

const int ArraySize = 12;

template <class Type>
class Array 
{
public:
	Array(int sz=ArraySize) { init(0,sz); }
	Array(const Type *ar, int sz) { init(ar,sz); }
	Array(const Array &iA) { init(iA.ia, iA.size); }
	~Array() { delete [] ia; }

	Array& operator=(const Array&);
	int getSize() {return size; }
	void grow();
	Array& ngrow(int = 1);
	void print(ostream& = cout);

	Type& operator[](int ix) { return ia[ix]; }
	int find(Type);
	Type minar();
	Type maxar();
	static void static_func(int);

private:
	void swap(int,int);
	void init(const Type*, int);

	int size;
	Type *ia;

	static int static_int;
};

int Array<int>::static_int = 5;
int Array<double>::static_int = 15;

template <class Type> ostream&
	operator<<(ostream& os, Array<Type>& ar)
{
	ar.print(os);
	return os;
}

template <class Type> 
void Array<Type>::print(ostream& os)
{
	const lineLength = 12;
	
	os << " { " << size << " )< " ;
	for (int ix = 0; ix < size; ++ix)
	{
		if (ix % lineLength == 0 && ix) os << "\n\t";
		os << ia[ix];

		if (ix % lineLength != lineLength - 1 && ix != size - 1)
			os << ", ";
	}
	os << " >\n";
}


template <class Type> Array<Type>&
Array<Type>::operator=(const Array<Type> &iA)
{
	if (this == &iA) return *this;
	delete [] ia;
	init( iA.ia, iA.size );
	return *this;
}

template <class Type> void
Array<Type>::init(const Type *array, int sz)
{
	ia = new Type[size = sz];
	assert( ia != 0 );
					   
	for (int ix = 0; ix < size; ++ix)
		ia[ix] = (array!=0) ?  array[ix] : (Type)0;

	static_int = size;
}

template <class Type> Array<Type>&
Array<Type>::ngrow(int igrow)
{
	for (int i = 0; i < igrow; i++)
	    this->grow();
	return *this;
}

template <class Type> void
Array<Type>::grow()
{
	Type *oldia = ia;
	int oldSize = size;
	int newSize = oldSize + oldSize/2 + 1;

	ia = new Type[size = newSize];
	assert( ia != 0 );
	
	for (int i=0; i<oldSize; ++i) ia[i] = oldia[i];
	for (; i<size; ++i) ia[i] = (Type)0;

	delete oldia;
}


template <class Type> Type 
Array<Type>::minar()
{
	assert( ia != 0 );
	Type min_val = ia[0];
	
	for (int ix=1; ix<size; ++ix)
		if(min_val > ia[ix]) min_val = ia[ix];

	return min_val;
}


template <class Type> 
Type Array<Type>::maxar()
{
	assert( ia != 0 );
	Type max_val = ia[0];
	
	for (int ix=1; ix<size; ++ix)
		if(max_val < ia[ix]) max_val = ia[ix];

	return max_val;
}


template <class Type> 
int Array<Type>::find(Type val)
{
	for (int ix=1; ix<size; ++ix)
		if(val == ia[ix]) return ix;

	return -1;
}


template <class Type> 
void Array<Type>::swap(int i, int j)
{
	Type tmp = ia[i];
	ia[i] = ia[j];
	ia[j] = tmp;
}

template <class Type> void 
Array<Type>::static_func(int par)
{
	int ix = static_int + par;
}

template <class Type>
void try_array( Array<Type> &iA )
{
	Type find_val = iA[2];
	iA[iA.getSize()-1] = iA.minar();

	int mid = iA.getSize()/2;
	iA.static_func(mid);
	iA[0] = iA.maxar();
	iA[mid] = iA[0];

	Array<Type> iA2 =iA;
	iA[mid/2] = iA[mid];

	iA = iA2;

	iA.grow();

	int index = iA.find(find_val);

	if(index < 0)
	;
  	else
	{
		Type value = iA[index];
	}

}

int main(void)
{
	static int ia[] = {12, 7, 14, 9, 128, 17, 6, 3, 27, 5};
	static double da[] = {12.3, 7.9, 14.6, 9.8, 128.0};

	Array<int> iA(ia, sizeof(ia)/sizeof(int));
	Array<double> dA(da, sizeof(da)/sizeof(double));

	cout << "template Array<int> class\n" << endl;
	try_array(iA);
	try_array(iA.ngrow(2));

	cout << "template Array<double> class\n" << endl;
	try_array(dA);
	iA.static_func(iA.getSize());
	dA.static_func(iA.getSize());

	int iGo = TestG();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\stack01\cppstack.cpp ===
#include "cstack.h"
#include <windows.h>

typedef void (*PFNINT)(void*, unsigned long);
typedef int (*PFNVAR)(void*, ...);

void afuncint(void*, DWORD)
{
}

static int afuncvar(void*, ...)
{
	return 0;
}

class AClass
{
public:
	PFNINT pfnint;
	PFNVAR pfnvar;
	static int m_static;
	virtual void __fastcall virt_method() {};
} the_Aclass;

int AClass::m_static = -1;
static AClass static_Aclass;

typedef AClass* PAClass;
typedef class ADerived: public AClass{
	void __fastcall virt_method() {
		int in_derived = 0;
	};
} CLASS_DERIVED;



CLASS_DERIVED the_derived;


static int Result=0;

static PFNVAR globalsecond1;
PFNVAR globalsecond2;

PAClass pclass = &the_Aclass;

//****************************************************************************
// Purpose:     function taking class & pointer to class
int paramclass(AClass the_class, AClass *the_pointer)
{	MIPS_DMY_PROLOG
	return 0;
}

//****************************************************************************
// Purpose:     function taking typedef class & pointer to class
int paramtypedefclass(CLASS_DERIVED the_class, PAClass the_pointer)
{	MIPS_DMY_PROLOG
	return 0;
}

//****************************************************************************
// Purpose:     function taking pointers to a functions as params
PFNINT poniterstofunc(PFNINT first, PFNVAR second)
{	MIPS_DMY_PROLOG
	static PFNINT localfirst=first;
	PFNVAR localsecond=second;
	int i=0;
	return first;
}

//****************************************************************************
// Purpose:     overloaded function taking int
int overloaded_function(int first)
{	MIPS_DMY_PROLOG
	static int i=1;
	static int j=first;
	return first;
}

//****************************************************************************
// Purpose:     overloaded function taking long
int overloaded_function(long first)
{	MIPS_DMY_PROLOG

	return first;
}



//****************************************************************************
// Purpose:     fpo function
double __fastcall fastcall_function(int first,long second, float third)
{	MIPS_DMY_PROLOG

	return first + second + third;
}


//****************************************************************************
// Purpose:     stdcall function
double __stdcall stdcall_function(int first,long second, float third)
{	MIPS_DMY_PROLOG

	return fastcall_function(first, second, third);
}


//****************************************************************************
// Purpose:     cdecl function
double __cdecl cdecl_function(int first,long second, float third)
{	MIPS_DMY_PROLOG

	return stdcall_function(first, second, third);
}
static int foo()
{
	return 10;
}

int Cxx_Tests()
{
	poniterstofunc(afuncint, afuncvar);
	poniterstofunc(afuncint, NULL);

	Result+=overloaded_function(1);
	Result+=overloaded_function(1L);
	static dooubleresult=cdecl_function(1, 2, 3.0);
	Result+=(int)dooubleresult;
	Result += 3;
	return Result==0;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\stack01\cstack.c ===
#include "cstack.h"

//****************************************************************************
// globals

char            test[]      = "CallStack";

char            scharmax    = SCHAR_MAX;
char            scharmin    = SCHAR_MIN;
unsigned char   ucharmax    = UCHAR_MAX;
unsigned char   ucharmin    = 0;
int             intmax      = INT_MAX;
int             intmin      = INT_MIN;
unsigned int    uintmax     = UINT_MAX;
unsigned int    uintmin     = 0;
short           shrtmax     = SHRT_MAX;
short           shrtmin     = SHRT_MIN;
unsigned short  ushrtmax    = USHRT_MAX;
unsigned short  ushrtmin    = 0;
long            longmax     = LONG_MAX;
long            longmin     = LONG_MIN;
unsigned long   ulongmax    = ULONG_MAX;
unsigned long   ulongmin    = 0;
double          dblmax      = DBL_MAX;
double          dblmin      = DBL_MIN;
long double     ldblmax     = LDBL_MAX;
long double     ldblmin     = LDBL_MIN;
float           fltmax      = FLT_MAX;
float           fltmin      = FLT_MIN;

char            *pscharmax  = &scharmax;
char            *pscharmin  = &scharmin;
unsigned char   *pucharmax  = &ucharmax;
unsigned char   *pucharmin  = &ucharmin;
int             *pintmax    = &intmax;
int             *pintmin    = &intmin;
unsigned int    *puintmax   = &uintmax;
unsigned int    *puintmin   = &uintmin;
short           *pshrtmax   = &shrtmax;
short           *pshrtmin   = &shrtmin;
unsigned short  *pushrtmax  = &ushrtmax;
unsigned short  *pushrtmin  = &ushrtmin;
long            *plongmax   = &longmax;
long            *plongmin   = &longmin;
unsigned long   *pulongmax  = &ulongmax;
unsigned long   *pulongmin  = &ulongmin;
double          *pdblmax    = &dblmax;
double          *pdblmin    = &dblmin;
long double     *pldblmax   = &ldblmax;
long double     *pldblmin   = &ldblmin;
float           *pfltmax    = &fltmax;
float           *pfltmin    = &fltmin;

//****************************************************************************
// Purpose:     main program
int main(void)
{
    int     i_main = 4;

    // no parameters
    VoidProcNoParam();
    check(!(CharProcNoParam() == SCHAR_MIN), "CharProcNoParam()");
    check(!(UCharProcNoParam() == UCHAR_MAX), "UCharProcNoParam()");
    check(!(IntProcNoParam() == INT_MIN), "IntProcNoParam()");
    check(!(UIntProcNoParam() == UINT_MAX), "UIntProcNoParam()");
    check(!(ShortProcNoParam() == SHRT_MIN), "ShortProcNoParam()");
    check(!(UShortProcNoParam() == USHRT_MAX), "UShortProcNoParam()");
    check(!(LongProcNoParam() == LONG_MIN), "LongProcNoParam()");
    check(!(ULongProcNoParam() == ULONG_MAX), "ULongProcNoParam()");
    check(!(DoubleProcNoParam() == DBL_MIN), "DoubleProcNoParam()");
    check(!(LDoubleProcNoParam() == LDBL_MAX), "LDoubleProcNoParam()");
    check(!(FloatProcNoParam() == FLT_MIN), "FloatProcNoParam()");

    // at least one parameter
    VoidProc1Param(INT_MAX);
    check(!(CharProc1Param(SCHAR_MIN) == SCHAR_MIN), "CharProc1Param");
    check(!(UCharProc1Param(UCHAR_MAX) == UCHAR_MAX), "UCharProc1Param");
    check(!(IntProc1Param(INT_MIN) == INT_MIN), "IntProc1Param");
    check(!(UIntProc1Param(UINT_MAX) == UINT_MAX), "UIntProc1Param");
    check(!(ShortProc1Param(SHRT_MIN) == SHRT_MIN), "ShortProc1Param");
    check(!(UShortProc1Param(USHRT_MAX) == USHRT_MAX), "UShortProc1Param");
    check(!(LongProc1Param(LONG_MIN) == LONG_MIN), "LongProc1Param");
    check(!(ULongProc1Param(ULONG_MAX) == ULONG_MAX), "ULongProc1Param");
    check(!(DoubleProc1Param(DBL_MAX) == DBL_MAX), "DoubleProc1Param");
    check(!(LDoubleProc1Param(LDBL_MIN) == LDBL_MIN), "LDoubleProc1Param");
    check(!(FloatProc1Param(FLT_MAX) == FLT_MAX), "FloatProc1Param");

    // parameter passed on using global variables
    VoidProc1Param(intmax);
    check(!(CharProc1Param(scharmin) == SCHAR_MIN), "CharProc1Param");
    check(!(UCharProc1Param(ucharmax) == UCHAR_MAX), "UCharProc1Param");
    check(!(IntProc1Param(intmin) == INT_MIN), "IntProc1Param");
    check(!(UIntProc1Param(uintmax) == UINT_MAX), "UIntProc1Param");
    check(!(ShortProc1Param(shrtmin) == SHRT_MIN), "ShortProc1Param");
    check(!(UShortProc1Param(ushrtmax) == USHRT_MAX), "UShortProc1Param");
    check(!(LongProc1Param(longmin) == LONG_MIN), "LongProc1Param");
    check(!(ULongProc1Param(ulongmax) == ULONG_MAX), "ULongProc1Param");
    check(!(DoubleProc1Param(dblmax) == DBL_MAX), "DoubleProc1Param");
    check(!(LDoubleProc1Param(ldblmin) == LDBL_MIN), "LDoubleProc1Param");
    check(!(FloatProc1Param(fltmax) == FLT_MAX), "FloatProc1Param");

    // parameter passed on using pointers
    VoidProc1Param(*pintmax);
    check(!(CharProc1Param(*pscharmin) == SCHAR_MIN), "CharProc1Param*");
    check(!(UCharProc1Param(*pucharmax) == UCHAR_MAX), "UCharProc1Param*");
    check(!(IntProc1Param(*pintmin) == INT_MIN), "IntProc1Param*");
    check(!(UIntProc1Param(*puintmax) == UINT_MAX), "UIntProc1Param*");
    check(!(ShortProc1Param(*pshrtmin) == SHRT_MIN), "ShortProc1Param*");
    check(!(UShortProc1Param(*pushrtmax) == USHRT_MAX), "UShortProc1Param*");
    check(!(LongProc1Param(*plongmin) == LONG_MIN), "LongProc1Param*");
    check(!(ULongProc1Param(*pulongmax) == ULONG_MAX), "ULongProc1Param*");
    check(!(DoubleProc1Param(*pdblmax) == DBL_MAX), "DoubleProc1Param*");
    check(!(LDoubleProc1Param(*pldblmin) == LDBL_MIN), "LDoubleProc1Param*");
    check(!(FloatProc1Param(*pfltmax) == FLT_MAX), "FloatProc1Param*");

    // parameter passed on using near/far/ellipses
    check(!(PShortProc1Param(&shrtmin) == pshrtmin), "PShortProc1Param*");
    check(!(LPIntProc1Param((int *)&intmin) == (int *)pintmin), "LPIntProc1Param*");

    // variable parameters and recursive
    check(!(average(1,2,3,4,5,6,7,8,9, -1) == 5), "average");
    check(!(factorial(9) == (long)362880), "factorial");

    check(!(MultiParam(CHAR_MIN, INT_MAX, SHRT_MAX, LONG_MAX, DBL_MAX, LDBL_MAX, FLT_MAX) == LONG_MAX), "MultiParam");

    // C++ object parameters and template parameters
    check(!(Cxx_Tests() == 0), "C++ objects");

	return i_main;
}

//****************************************************************************
// Purpose:     function returning void and has no parameter
void VoidProcNoParam(void)
{	MIPS_DMY_PROLOG
    return;
}

// Purpose:     function returning char and has no parameter
char CharProcNoParam(void)
{	MIPS_DMY_PROLOG
    return SCHAR_MIN;
}

// Purpose:     function returning unsigned char and has no parameter
unsigned char UCharProcNoParam(void)
{	MIPS_DMY_PROLOG
    return UCHAR_MAX;
}

// Purpose:     function returning int and has no parameter
int IntProcNoParam(void)
{	MIPS_DMY_PROLOG
    return INT_MIN;
}

// Purpose:     function returning unsigned int and has no parameter
unsigned int UIntProcNoParam(void)
{	MIPS_DMY_PROLOG
    return UINT_MAX;
}

// Purpose:     function returning short and has no parameter
short ShortProcNoParam(void)
{	MIPS_DMY_PROLOG
    return SHRT_MIN;
}

// Purpose:     function returning unsigned short and has no parameter
unsigned short UShortProcNoParam(void)
{	MIPS_DMY_PROLOG
    return USHRT_MAX;
}

// Purpose:     function returning long and has no parameter
long LongProcNoParam(void)
{	MIPS_DMY_PROLOG
    return LONG_MIN;
}

// Purpose:     function returning unsigned long and has no parameter
unsigned long ULongProcNoParam(void)
{	MIPS_DMY_PROLOG
    return ULONG_MAX;
}

// Purpose:     function returning float and has no parameter
float FloatProcNoParam(void)
{	MIPS_DMY_PROLOG
    return FLT_MIN;
}

// Purpose:     function returning Double and has no parameter
double DoubleProcNoParam(void)
{	MIPS_DMY_PROLOG
    return DBL_MIN;
}

// Purpose:     function returning long double and has no parameter
long double LDoubleProcNoParam(void)
{	MIPS_DMY_PROLOG
    return LDBL_MAX;
}

//****************************************************************************
// Purpose:     function returning void and has 1 parameter
void VoidProc1Param(int i)
{	MIPS_DMY_PROLOG
    return;
}

// Purpose:     function returning char and has 1 parameter
char CharProc1Param(char c)
{	MIPS_DMY_PROLOG
    return c;
}
// Purpose:     function returning unsigned char and has 1 parameter
unsigned char UCharProc1Param(unsigned char uc)
{	MIPS_DMY_PROLOG
    return uc;
}

// Purpose:     function returning int and has 1 parameter
int IntProc1Param(int i)
{	MIPS_DMY_PROLOG
    return i;
}

// Purpose:     function returning unsigned int and has 1 parameter
unsigned int UIntProc1Param(unsigned int ui)
{	MIPS_DMY_PROLOG
    return ui;
}

// Purpose:     function returning short and has 1 parameter
short ShortProc1Param(short s)
{	MIPS_DMY_PROLOG
    return s;
}

// Purpose:     function returning unsigned short and has 1 parameter
unsigned short UShortProc1Param(unsigned short us)
{	MIPS_DMY_PROLOG
    return us;
}

// Purpose:     function returning long and has 1 parameter
long LongProc1Param(long l)
{	MIPS_DMY_PROLOG
    return l;
}

// Purpose:     function returning unsigned long and has 1 parameter
unsigned long ULongProc1Param(unsigned long ul)
{	MIPS_DMY_PROLOG
    return ul;
}

// Purpose:     function returning float and has 1 parameter
float FloatProc1Param(float f)
{	MIPS_DMY_PROLOG
    return f;
}

// Purpose:     function returning Double and has 1 parameter
double DoubleProc1Param(double d)
{	MIPS_DMY_PROLOG
    return d;
}

// Purpose:     function returning long double and has 1 parameter
long double LDoubleProc1Param(long double ld)
{	MIPS_DMY_PROLOG
    return ld;
}

//****************************************************************************
// Purpose:     function returning address and has 1 parameter
//              as pointer
short * PShortProc1Param(short * ps)
{	MIPS_DMY_PROLOG
    return ps;
}

int * LPIntProc1Param(int * lpi)
{	MIPS_DMY_PROLOG
    return lpi;
}

//****************************************************************************
// Purpose:     function returning address and has ... parameter
int average(int first, ...)
{	MIPS_DMY_PROLOG
    int count = 0, sum = 0, i = first;
    va_list marker;

    va_start(marker, first);
    while (i != -1)
    {
        sum += i;
        count++;
        i = va_arg(marker, int);
    }
    va_end(marker);
    return (sum ? (sum/count):(0));
}

//****************************************************************************
// Purpose:     recursive function
unsigned long factorial(int i)
{	MIPS_DMY_PROLOG
    if (i == 0)
        return 1;
    else
        return (i * factorial(i-1));
}

//****************************************************************************
// Purpose:     function returning long and has many parameters
long MultiParam(char c, int i, short s, long l, double d, long double ld, float f)
{	MIPS_DMY_PROLOG
	long double ldbl = (long double)c + (long double)i + (long double)s + (long double)l + (long double)d + (long double)ld + (long double)f;
	return l;
}

void check(int i, char *pc)
{	MIPS_DMY_PROLOG
	if( !i ) return;
	printf("%s FAILED", pc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\stack01\cstack.h ===
#if defined(_WINDOWS)
#include <windows.h>
#endif

#include <limits.h>
#include <float.h>
#include <stdarg.h>

//#include "test.h"

//***************************************************************************
// prototypes
int                     main(void);

void                    VoidProcNoParam(void);
char                    CharProcNoParam(void);
unsigned char           UCharProcNoParam(void);
int                     IntProcNoParam(void);
unsigned int            UIntProcNoParam(void);
short                   ShortProcNoParam(void);
unsigned short          UShortProcNoParam(void);
long                    LongProcNoParam(void);
unsigned long           ULongProcNoParam(void);
float                   FloatProcNoParam(void);
double                  DoubleProcNoParam(void);
long double             LDoubleProcNoParam(void);

void                    VoidProc1Param(int i);
char                    CharProc1Param(char c);
unsigned char           UCharProc1Param(unsigned char uc);
int                     IntProc1Param(int i);
unsigned int            UIntProc1Param(unsigned int ui);
short                   ShortProc1Param(short s);
unsigned short          UShortProc1Param(unsigned short us);
long                    LongProc1Param(long l);
unsigned long           ULongProc1Param(unsigned long ul);
float                   FloatProc1Param(float f);
double                  DoubleProc1Param(double d);
long double             LDoubleProc1Param(long double ld);

short *            		PShortProc1Param(short * ps);
int * 					LPIntProc1Param(int * lpi);

int                     average(int first, ...);
unsigned long           factorial(int i);

long		            MultiParam(char c, int i, short s, long l, double d, long double ld, float f);

void 					check(int i, char *pc);

#ifdef __cplusplus
extern "C"
{
	int Cxx_Tests();
}
#else
	int Cxx_Tests();
#endif

// for mips
#if defined( _M_MRX000 ) || defined(_M_ALPHA)
#define MIPS_DMY_PROLOG int mip_dummy=0;
#else
#define MIPS_DMY_PROLOG 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\testbp01\bp__dd.c ===
//**********************************************************************
//  Source module for Testbp01 app : Testing of Breakpoints
//***********************************************************************

#include "testbp.h"

extern const char     GCc;
extern const uchar   GCuc;
extern const short    GCs;
extern const ushort  GCus;
extern const long     GCl;
extern const ulong   GCul;
extern const float    GCf;
extern const double   GCd;
extern const ldouble GCld;

extern ushort /*_near*/ GShortNearArray[NEARSIZE];
//extern ushort _far GShortFarArray[FARSIZE];
//extern ushort _huge GShortHugeArray[HUGESIZE];

extern char	Gc;
extern uchar   Guc;
extern short	Gs;
extern ushort  Gus;
extern long	Gl;
extern ulong   Gul;
extern float	Gf;
extern double	Gd;
extern ldouble Gld;
extern short PassTest;

extern struct Gst
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst;

extern union Gun
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun;



double	_cdecl CFncDD(double PSd)
{
    int counter;

    const char	   Cc = (char)1;
    const uchar   Cuc = (uchar)1;
    const short    Cs = (short)1;
    const ushort  Cus = (ushort)1;
    const long	   Cl = (long)1;
    const ulong   Cul = (ulong)1;
    const float    Cf = (float)1;
    const double   Cd = (double)1;
    const ldouble Cld = (ldouble)1;

    char     c, c10[10];
    uchar   uc, uc10[10];
    short    s, s10[10];
    ushort  us, us10[10];
    long     l, l10[10];
    ulong   ul, ul10[10];
    float    f, f10[10];
    double   d, d10[10];
    ldouble ld, ld10[10];
    struct st
    {
	short	s;
	uchar	uc10[10];
    }st, *pst = &st;
    union un
    {
	short	s2[2];
	ulong	 ul;
    }un, *pun = &un;

    for( counter = 0; counter < 10; counter++)
    {
	c  = (char)counter;
	uc = (uchar)counter;
	s  = (short)counter;
	us = (ushort)counter;
	l  = (long)counter;
	ul = (ulong)counter;
	f  = (float)counter;
	d  = (double)counter;
	ld = (ldouble)counter;
	st.s = (short)counter;
	un.s2[0] = (short)counter;
	un.s2[1] = 9 - (short)counter;
	c10[counter]  = (char)counter;
	uc10[counter] = (uchar)counter;
	s10[counter]  = (short)counter;
	us10[counter] = (ushort)counter;
	l10[counter]  = (long)counter;
	ul10[counter] = (ulong)counter;
	f10[counter]  = (float)counter;
	d10[counter]  = (double)counter;
	ld10[counter] = (ldouble)counter;
	pst->uc10[counter] = (uchar)counter;
	pun->ul = (ulong)counter;
	PSd = (double)counter;
    }
    return PSd;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\testbp01\bp__ff.c ===
//**********************************************************************
//  Source module for Testbp01 app : Testing of Breakpoints
//***********************************************************************

#include "testbp.h"

extern const char     GCc;
extern const uchar   GCuc;
extern const short    GCs;
extern const ushort  GCus;
extern const long     GCl;
extern const ulong   GCul;
extern const float    GCf;
extern const double   GCd;
extern const ldouble GCld;

extern ushort /*_near*/ GShortNearArray[NEARSIZE];
//extern ushort _far GShortFarArray[FARSIZE];
//extern ushort _huge GShortHugeArray[HUGESIZE];

extern char	Gc;
extern uchar   Guc;
extern short	Gs;
extern ushort  Gus;
extern long	Gl;
extern ulong   Gul;
extern float	Gf;
extern double	Gd;
extern ldouble Gld;
extern short PassTest;

extern struct Gst
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst;

extern union Gun
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun;



float	_cdecl CFncFF(float PSf)
{
    int counter;

    const char	   Cc = (char)1;
    const uchar   Cuc = (uchar)1;
    const short    Cs = (short)1;
    const ushort  Cus = (ushort)1;
    const long	   Cl = (long)1;
    const ulong   Cul = (ulong)1;
    const float    Cf = (float)1;
    const double   Cd = (double)1;
    const ldouble Cld = (ldouble)1;

    char     c, c10[10];
    uchar   uc, uc10[10];
    short    s, s10[10];
    ushort  us, us10[10];
    long     l, l10[10];
    ulong   ul, ul10[10];
    float    f, f10[10];
    double   d, d10[10];
    ldouble ld, ld10[10];
    struct st
    {
	short	s;
	uchar	uc10[10];
    }st, *pst = &st;
    union un
    {
	short	s2[2];
	ulong	 ul;
    }un, *pun = &un;

    for( counter = 0; counter < 10; counter++)
    {
	Gc  = (char)counter;
	Guc = (uchar)counter;
	Gs  = (short)counter;
	Gus = (ushort)counter;
	Gl  = (long)counter;
	Gul = (ulong)counter;
	Gf  = (float)counter;
	Gd  = (double)counter;
	Gld = (ldouble)counter;
	c  = (char)counter;
	uc = (uchar)counter;
	s  = (short)counter;
	us = (ushort)counter;
	l  = (long)counter;
	ul = (ulong)counter;
	f  = (float)counter;
	d  = (double)counter;
	ld = (ldouble)counter;
	Gst.Gs = (short)counter;
	Gun.Gs2[0] = (short)counter;
	Gun.Gs2[1] = 9 - (short)counter;
	c  = (char)counter;
	uc = (uchar)counter;
	s  = (short)counter;
	us = (ushort)counter;
	l  = (long)counter;
	ul = (ulong)counter;
	f  = (float)counter;
	d  = (double)counter;
	ld = (ldouble)counter;
	st.s = (short)counter;
	un.s2[0] = (short)counter;
	un.s2[1] = 9 - (short)counter;
	c10[counter]  = (char)counter;
	uc10[counter] = (uchar)counter;
	s10[counter]  = (short)counter;
	us10[counter] = (ushort)counter;
	l10[counter]  = (long)counter;
	ul10[counter] = (ulong)counter;
	f10[counter]  = (float)counter;
	d10[counter]  = (double)counter;
	ld10[counter] = (ldouble)counter;
	pst->uc10[counter] = (uchar)counter;
	pun->ul = (ulong)counter;
	PSf = (float)counter;
    }
    return PSf;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\testbp01\bp__cc.c ===
//**********************************************************************
//  Source module for Testbp01 app : Testing of Breakpoints
//***********************************************************************

#include "testbp.h"

extern const char     GCc;
extern const uchar   GCuc;
extern const short    GCs;
extern const ushort  GCus;
extern const long     GCl;
extern const ulong   GCul;
extern const float    GCf;
extern const double   GCd;
extern const ldouble GCld;

extern ushort /*_near*/ GShortNearArray[NEARSIZE];
//extern ushort _far GShortFarArray[FARSIZE];

extern char	Gc;
extern uchar   Guc;
extern short	Gs;
extern ushort  Gus;
extern long	Gl;
extern ulong   Gul;
extern float	Gf;
extern double	Gd;
extern ldouble Gld;
extern short PassTest;

extern struct Gst
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst;

extern union Gun
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun;



char	_cdecl CFncCC (char PSc)
{
    int counter;

    const char	   Cc = (char)1;
    const uchar   Cuc = (uchar)1;
    const short    Cs = (short)1;
    const ushort  Cus = (ushort)1;
    const long	   Cl = (long)1;
    const ulong   Cul = (ulong)1;
    const float    Cf = (float)1;
    const double   Cd = (double)1;
    const ldouble Cld = (ldouble)1;
 
    char     c, c10[10];
    uchar   uc, uc10[10];
    short    s, s10[10];
    ushort  us, us10[10];
    long     l, l10[10];
    ulong   ul, ul10[10];
    float    f, f10[10];
    double   d, d10[10];
    ldouble ld, ld10[10];
    struct st
    {
	short	s;
	uchar	uc10[10];
    }st, *pst = &st;
    union un
    {
	short	s2[2];
	ulong	 ul;
    }un, *pun = &un;

    for( counter = 0; counter < 10; counter++)
    {
		Gc  = (char)counter;
		Guc = (uchar)counter;
		Gs  = (short)counter;
		Gus = (ushort)counter;
		Gl  = (long)counter;
		Gul = (ulong)counter;
		Gf  = (float)counter;
		Gd  = (double)counter;
		Gld = (ldouble)counter;
lab1:		c  = (char)counter;
		uc = (uchar)counter;
		s  = (short)counter;
		us = (ushort)counter;
		l  = (long)counter;
		ul = (ulong)counter;
		f  = (float)counter;
		d  = (double)counter;
		ld = (ldouble)counter;
		Gst.Gs = (short)counter;
		Gun.Gs2[0] = (short)counter;
		Gun.Gs2[1] = 9 - (short)counter;
		c  = (char)counter;
		uc = (uchar)counter;
		s  = (short)counter;
		us = (ushort)counter;
		l  = (long)counter;
		ul = (ulong)counter;
		f  = (float)counter;
		d  = (double)counter;
		ld = (ldouble)counter;
lab2:		st.s = (short)counter;
		un.s2[0] = (short)counter;
		un.s2[1] = 9 - (short)counter;
		c10[counter]  = (char)counter;
		uc10[counter] = (uchar)counter;
		s10[counter]  = (short)counter;
		us10[counter] = (ushort)counter;
lab3:		l10[counter]  = (long)counter;
		ul10[counter] = (ulong)counter;
		f10[counter]  = (float)counter;
		d10[counter]  = (double)counter;
		ld10[counter] = (ldouble)counter;
		pst->uc10[counter] = (uchar)counter;
		pun->ul = (ulong)counter;
		PSc = (char)counter;
    }
    return PSc;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\testbp01\bp__ldld.c ===
//**********************************************************************
//  Source module for Testbp01 app : Testing of Breakpoints
//***********************************************************************

#include "testbp.h"

extern const char     GCc;
extern const uchar   GCuc;
extern const short    GCs;
extern const ushort  GCus;
extern const long     GCl;
extern const ulong   GCul;
extern const float    GCf;
extern const double   GCd;
extern const ldouble GCld;

extern ushort /*_near*/ GShortNearArray[NEARSIZE];
//extern ushort _far GShortFarArray[FARSIZE];
//extern ushort _huge GShortHugeArray[HUGESIZE];

extern char	Gc;
extern uchar   Guc;
extern short	Gs;
extern ushort  Gus;
extern long	Gl;
extern ulong   Gul;
extern float	Gf;
extern double	Gd;
extern ldouble Gld;
extern short PassTest;

extern struct Gst
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst;

extern union Gun
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun;



ldouble _cdecl CFncLDLD(ldouble PSld)
{
    int counter;

    const char	   Cc = (char)1;
    const uchar   Cuc = (uchar)1;
    const short    Cs = (short)1;
    const ushort  Cus = (ushort)1;
    const long	   Cl = (long)1;
    const ulong   Cul = (ulong)1;
    const float    Cf = (float)1;
    const double   Cd = (double)1;
    const ldouble Cld = (ldouble)1;

    char     c, c10[10];
    uchar   uc, uc10[10];
    short    s, s10[10];
    ushort  us, us10[10];
    long     l, l10[10];
    ulong   ul, ul10[10];
    float    f, f10[10];
    double   d, d10[10];
    ldouble ld, ld10[10];
    struct st
    {
	short	s;
	uchar	uc10[10];
    }st, *pst = &st;
    union un
    {
	short	s2[2];
	ulong	 ul;
    }un, *pun = &un;

    for( counter = 0; counter < 10; counter++)
    {
	Gc  = (char)counter;
	Guc = (uchar)counter;
	Gs  = (short)counter;
	Gus = (ushort)counter;
	Gl  = (long)counter;
	Gul = (ulong)counter;
	Gf  = (float)counter;
	Gd  = (double)counter;
	Gld = (ldouble)counter;
	c  = (char)counter;
	uc = (uchar)counter;
	s  = (short)counter;
	us = (ushort)counter;
	l  = (long)counter;
	ul = (ulong)counter;
	f  = (float)counter;
	d  = (double)counter;
	ld = (ldouble)counter;
	Gst.Gs = (short)counter;
	Gun.Gs2[0] = (short)counter;
	Gun.Gs2[1] = 9 - (short)counter;
	c  = (char)counter;
	uc = (uchar)counter;
	s  = (short)counter;
	us = (ushort)counter;
	l  = (long)counter;
	ul = (ulong)counter;
	f  = (float)counter;
	d  = (double)counter;
	ld = (ldouble)counter;
	st.s = (short)counter;
	un.s2[0] = (short)counter;
	un.s2[1] = 9 - (short)counter;
	c10[counter]  = (char)counter;
	uc10[counter] = (uchar)counter;
	s10[counter]  = (short)counter;
	us10[counter] = (ushort)counter;
	l10[counter]  = (long)counter;
	ul10[counter] = (ulong)counter;
	f10[counter]  = (float)counter;
	d10[counter]  = (double)counter;
	ld10[counter] = (ldouble)counter;
	pst->uc10[counter] = (uchar)counter;
	pun->ul = (ulong)counter;
	PSld = (ldouble)counter;
    }
    return PSld;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\testbp01\bp__ll.c ===
//**********************************************************************
//  Source module for Testbp01 app : Testing of Breakpoints
//***********************************************************************

#include "testbp.h"

extern const char     GCc;
extern const uchar   GCuc;
extern const short    GCs;
extern const ushort  GCus;
extern const long     GCl;
extern const ulong   GCul;
extern const float    GCf;
extern const double   GCd;
extern const ldouble GCld;

extern ushort /*_near*/ GShortNearArray[NEARSIZE];
//extern ushort _far GShortFarArray[FARSIZE];
//extern ushort _huge GShortHugeArray[HUGESIZE];

extern char	Gc;
extern uchar   Guc;
extern short	Gs;
extern ushort  Gus;
extern long	Gl;
extern ulong   Gul;
extern float	Gf;
extern double	Gd;
extern ldouble Gld;
extern short PassTest;

extern struct Gst
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst;

extern union Gun
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun;



long	_cdecl CFncLL(long PSl)
{
    int counter;

    const char	   Cc = (char)1;
    const uchar   Cuc = (uchar)1;
    const short    Cs = (short)1;
    const ushort  Cus = (ushort)1;
    const long	   Cl = (long)1;
    const ulong   Cul = (ulong)1;
    const float    Cf = (float)1;
    const double   Cd = (double)1;
    const ldouble Cld = (ldouble)1;

    char     c, c10[10];
    uchar   uc, uc10[10];
    short    s, s10[10];
    ushort  us, us10[10];
    long     l, l10[10];
    ulong   ul, ul10[10];
    float    f, f10[10];
    double   d, d10[10];
    ldouble ld, ld10[10];
    struct st
    {
	short	s;
	uchar	uc10[10];
    }st, *pst = &st;
    union un
    {
	short	s2[2];
	ulong	 ul;
    }un, *pun = &un;

    for( counter = 0; counter < 10; counter++)
    {
	Gc  = (char)counter;
	Guc = (uchar)counter;
	Gs  = (short)counter;
	Gus = (ushort)counter;
	Gl  = (long)counter;
	Gul = (ulong)counter;
	Gf  = (float)counter;
	Gd  = (double)counter;
	Gld = (ldouble)counter;
	c  = (char)counter;
	uc = (uchar)counter;
	s  = (short)counter;
	us = (ushort)counter;
	l  = (long)counter;
	ul = (ulong)counter;
	f  = (float)counter;
	d  = (double)counter;
	ld = (ldouble)counter;
	Gst.Gs = (short)counter;
	Gun.Gs2[0] = (short)counter;
	Gun.Gs2[1] = 9 - (short)counter;
	c  = (char)counter;
	uc = (uchar)counter;
	s  = (short)counter;
	us = (ushort)counter;
	l  = (long)counter;
	ul = (ulong)counter;
	f  = (float)counter;
	d  = (double)counter;
	ld = (ldouble)counter;
	st.s = (short)counter;
	un.s2[0] = (short)counter;
	un.s2[1] = 9 - (short)counter;
	c10[counter]  = (char)counter;
	uc10[counter] = (uchar)counter;
	s10[counter]  = (short)counter;
	us10[counter] = (ushort)counter;
	l10[counter]  = (long)counter;
	ul10[counter] = (ulong)counter;
	f10[counter]  = (float)counter;
	d10[counter]  = (double)counter;
	ld10[counter] = (ldouble)counter;
	pst->uc10[counter] = (uchar)counter;
	pun->ul = (ulong)counter;
	PSl = (long)counter;
    }
    return PSl;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\testbp01\bp__ss.c ===
//**********************************************************************
//  Source module for Testbp01 app : Testing of Breakpoints
//***********************************************************************

#include "testbp.h"

extern const char     GCc;
extern const uchar   GCuc;
extern const short    GCs;
extern const ushort  GCus;
extern const long     GCl;
extern const ulong   GCul;
extern const float    GCf;
extern const double   GCd;
extern const ldouble GCld;

extern ushort /*_near*/ GShortNearArray[NEARSIZE];
//extern ushort _far GShortFarArray[FARSIZE];
//extern ushort _huge GShortHugeArray[HUGESIZE];

extern char	Gc;
extern uchar   Guc;
extern short	Gs;
extern ushort  Gus;
extern long	Gl;
extern ulong   Gul;
extern float	Gf;
extern double	Gd;
extern ldouble Gld;
extern short PassTest;

extern struct Gst
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst;

extern union Gun
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun;



short	_cdecl CFncSS(short PSs)
{
    int counter;

    const char	   Cc = (char)1;
    const uchar   Cuc = (uchar)1;
    const short    Cs = (short)1;
    const ushort  Cus = (ushort)1;
    const long	   Cl = (long)1;
    const ulong   Cul = (ulong)1;
    const float    Cf = (float)1;
    const double   Cd = (double)1;
    const ldouble Cld = (ldouble)1;

    char     c, c10[10];
    uchar   uc, uc10[10];
    short    s, s10[10];
    ushort  us, us10[10];
    long     l, l10[10];
    ulong   ul, ul10[10];
    float    f, f10[10];
    double   d, d10[10];
    ldouble ld, ld10[10];
    struct st
    {
	short	s;
	uchar	uc10[10];
    }st, *pst = &st;
    union un
    {
	short	s2[2];
	ulong	 ul;
    }un, *pun = &un;

    for( counter = 0; counter < 10; counter++)
    {
	Gc  = (char)counter;
	Guc = (uchar)counter;
	Gs  = (short)counter;
	Gus = (ushort)counter;
	Gl  = (long)counter;
	Gul = (ulong)counter;
	Gf  = (float)counter;
	Gd  = (double)counter;
	Gld = (ldouble)counter;
	c  = (char)counter;
	uc = (uchar)counter;
	s  = (short)counter;
	us = (ushort)counter;
	l  = (long)counter;
	ul = (ulong)counter;
	f  = (float)counter;
	d  = (double)counter;
	ld = (ldouble)counter;
	Gst.Gs = (short)counter;
	Gun.Gs2[0] = (short)counter;
	Gun.Gs2[1] = 9 - (short)counter;
	c  = (char)counter;
	uc = (uchar)counter;
	s  = (short)counter;
	us = (ushort)counter;
	l  = (long)counter;
	ul = (ulong)counter;
	f  = (float)counter;
	d  = (double)counter;
	ld = (ldouble)counter;
	st.s = (short)counter;
	un.s2[0] = (short)counter;
	un.s2[1] = 9 - (short)counter;
	c10[counter]  = (char)counter;
	uc10[counter] = (uchar)counter;
	s10[counter]  = (short)counter;
	us10[counter] = (ushort)counter;
	l10[counter]  = (long)counter;
	ul10[counter] = (ulong)counter;
	f10[counter]  = (float)counter;
	d10[counter]  = (double)counter;
	ld10[counter] = (ldouble)counter;
	pst->uc10[counter] = (uchar)counter;
	pun->ul = (ulong)counter;
	PSs = (short)counter;
    }
    return PSs;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\testbp01\bp__narr.c ===
//**********************************************************************
//  Source module for Testbp01 app : Testing of Breakpoints
//***********************************************************************

#include "testbp.h"

extern const char     GCc;
extern const uchar   GCuc;
extern const short    GCs;
extern const ushort  GCus;
extern const long     GCl;
extern const ulong   GCul;
extern const float    GCf;
extern const double   GCd;
extern const ldouble GCld;

extern ushort /*_near*/ GShortNearArray[NEARSIZE];
//extern ushort _far GShortFarArray[FARSIZE];
//extern ushort _huge GShortHugeArray[HUGESIZE];

extern char	Gc;
extern uchar   Guc;
extern short	Gs;
extern ushort  Gus;
extern long	Gl;
extern ulong   Gul;
extern float	Gf;
extern double	Gd;
extern ldouble Gld;
extern short PassTest;

extern struct Gst
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst;

extern union Gun
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun;



void	_cdecl CFncNearArray(void)
{
    short i;

    for( i = 0; i < NEARSIZE; i++ )
	GShortNearArray[i]=i;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\testbp01\bp__ucuc.c ===
//**********************************************************************
//  Source module for Testbp01 app : Testing of Breakpoints
//***********************************************************************

#include "testbp.h"

extern const char     GCc;
extern const uchar   GCuc;
extern const short    GCs;
extern const ushort  GCus;
extern const long     GCl;
extern const ulong   GCul;
extern const float    GCf;
extern const double   GCd;
extern const ldouble GCld;

extern ushort /*_near*/ GShortNearArray[NEARSIZE];
//extern ushort _far GShortFarArray[FARSIZE];
//extern ushort _huge GShortHugeArray[HUGESIZE];

extern char	Gc;
extern uchar   Guc;
extern short	Gs;
extern ushort  Gus;
extern long	Gl;
extern ulong   Gul;
extern float	Gf;
extern double	Gd;
extern ldouble Gld;
extern short PassTest;

extern struct Gst
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst;

extern union Gun
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun;



uchar	_cdecl CFncUCUC(uchar PSuc)
{
    int counter;

    const char	   Cc = (char)1;
    const uchar   Cuc = (uchar)1;
    const short    Cs = (short)1;
    const ushort  Cus = (ushort)1;
    const long	   Cl = (long)1;
    const ulong   Cul = (ulong)1;
    const float    Cf = (float)1;
    const double   Cd = (double)1;
    const ldouble Cld = (ldouble)1;

    char     c, c10[10];
    uchar   uc, uc10[10];
    short    s, s10[10];
    ushort  us, us10[10];
    long     l, l10[10];
    ulong   ul, ul10[10];
    float    f, f10[10];
    double   d, d10[10];
    ldouble ld, ld10[10];
    struct st
    {
	short	s;
	uchar	uc10[10];
    }st, *pst = &st;
    union un
    {
	short	s2[2];
	ulong	 ul;
    }un, *pun = &un;

    for( counter = 0; counter < 10; counter++)
    {
	Gc  = (char)counter;
	Guc = (uchar)counter;
	Gs  = (short)counter;
	Gus = (ushort)counter;
	Gl  = (long)counter;
	Gul = (ulong)counter;
	Gf  = (float)counter;
	Gd  = (double)counter;
	Gld = (ldouble)counter;
	c  = (char)counter;
	uc = (uchar)counter;
	s  = (short)counter;
	us = (ushort)counter;
	l  = (long)counter;
	ul = (ulong)counter;
	f  = (float)counter;
	d  = (double)counter;
	ld = (ldouble)counter;
	Gst.Gs = (short)counter;
	Gun.Gs2[0] = (short)counter;
	Gun.Gs2[1] = 9 - (short)counter;
	c  = (char)counter;
	uc = (uchar)counter;
	s  = (short)counter;
	us = (ushort)counter;
	l  = (long)counter;
	ul = (ulong)counter;
	f  = (float)counter;
	d  = (double)counter;
	ld = (ldouble)counter;
	st.s = (short)counter;
	un.s2[0] = (short)counter;
	un.s2[1] = 9 - (short)counter;
	c10[counter]  = (char)counter;
	uc10[counter] = (uchar)counter;
	s10[counter]  = (short)counter;
	us10[counter] = (ushort)counter;
	l10[counter]  = (long)counter;
	ul10[counter] = (ulong)counter;
	f10[counter]  = (float)counter;
	d10[counter]  = (double)counter;
	ld10[counter] = (ldouble)counter;
	pst->uc10[counter] = (uchar)counter;
	pun->ul = (ulong)counter;
	PSuc = (uchar)counter;
    }
    return PSuc;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\testbp01\bp__rec.c ===
//**********************************************************************
//  Source module for Testbp01 app : Testing of Breakpoints
//***********************************************************************

#include "testbp.h"

extern const char     GCc;
extern const uchar   GCuc;
extern const short    GCs;
extern const ushort  GCus;
extern const long     GCl;
extern const ulong   GCul;
extern const float    GCf;
extern const double   GCd;
extern const ldouble GCld;

extern ushort /*_near*/ GShortNearArray[NEARSIZE];
//extern ushort _far GShortFarArray[FARSIZE];
//extern ushort _huge GShortHugeArray[HUGESIZE];

extern char	Gc;
extern uchar   Guc;
extern short	Gs;
extern ushort  Gus;
extern long	Gl;
extern ulong   Gul;
extern float	Gf;
extern double	Gd;
extern ldouble Gld;
extern short PassTest;

extern struct Gst
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst;

extern union Gun
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun;



short	_cdecl CFncSSRecurse(short NTimes)
{	MIPS_DMY_PROLOG

    const char	   Cc = (char)NTimes;
    const uchar   Cuc = (uchar)NTimes;
    const short    Cs = (short)NTimes;
    const ushort  Cus = (ushort)NTimes;
    const long	   Cl = (long)NTimes;
    const ulong   Cul = (ulong)NTimes;
    const float    Cf = (float)NTimes;
    const double   Cd = (double)NTimes;
    const ldouble Cld = (ldouble)NTimes;

    char     c;
    uchar   uc;
    short    s;
    ushort  us;
    long     l;
    ulong   ul;
    float    f;
    double   d;
    ldouble ld;

    c = (char)NTimes;
    uc = (uchar)NTimes;
    s = (short)NTimes;
    us = (ushort)NTimes;
    l = (long)NTimes;
    ul = (ulong)NTimes;
    f = (float)NTimes;
    d = (double)NTimes;
    ld = (ldouble)NTimes;

    if( NTimes != 0 )
	NTimes = (short)CFncSSRecurse((short)(NTimes-1));
    return(NTimes);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\testbp01\bp__usus.c ===
//**********************************************************************
//  Source module for Testbp01 app : Testing of Breakpoints
//***********************************************************************

#include "testbp.h"

extern const char     GCc;
extern const uchar   GCuc;
extern const short    GCs;
extern const ushort  GCus;
extern const long     GCl;
extern const ulong   GCul;
extern const float    GCf;
extern const double   GCd;
extern const ldouble GCld;

extern ushort /*_near*/ GShortNearArray[NEARSIZE];
//extern ushort _far GShortFarArray[FARSIZE];
//extern ushort _huge GShortHugeArray[HUGESIZE];

extern char	Gc;
extern uchar   Guc;
extern short	Gs;
extern ushort  Gus;
extern long	Gl;
extern ulong   Gul;
extern float	Gf;
extern double	Gd;
extern ldouble Gld;
extern short PassTest;

extern struct Gst
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst;

extern union Gun
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun;



ushort	_cdecl CFncUSUS(ushort PSus)
{
    int counter;

    const char	   Cc = (char)1;
    const uchar   Cuc = (uchar)1;
    const short    Cs = (short)1;
    const ushort  Cus = (ushort)1;
    const long	   Cl = (long)1;
    const ulong   Cul = (ulong)1;
    const float    Cf = (float)1;
    const double   Cd = (double)1;
    const ldouble Cld = (ldouble)1;

    char     c, c10[10];
    uchar   uc, uc10[10];
    short    s, s10[10];
    ushort  us, us10[10];
    long     l, l10[10];
    ulong   ul, ul10[10];
    float    f, f10[10];
    double   d, d10[10];
    ldouble ld, ld10[10];
    struct st
    {
	short	s;
	uchar	uc10[10];
    }st, *pst = &st;
    union un
    {
	short	s2[2];
	ulong	 ul;
    }un, *pun = &un;

    for( counter = 0; counter < 10; counter++)
    {
	Gc  = (char)counter;
	Guc = (uchar)counter;
	Gs  = (short)counter;
	Gus = (ushort)counter;
	Gl  = (long)counter;
	Gul = (ulong)counter;
	Gf  = (float)counter;
	Gd  = (double)counter;
	Gld = (ldouble)counter;
	c  = (char)counter;
	uc = (uchar)counter;
	s  = (short)counter;
	us = (ushort)counter;
	l  = (long)counter;
	ul = (ulong)counter;
	f  = (float)counter;
	d  = (double)counter;
	ld = (ldouble)counter;
	Gst.Gs = (short)counter;
	Gun.Gs2[0] = (short)counter;
	Gun.Gs2[1] = 9 - (short)counter;
	c  = (char)counter;
	uc = (uchar)counter;
	s  = (short)counter;
	us = (ushort)counter;
	l  = (long)counter;
	ul = (ulong)counter;
	f  = (float)counter;
	d  = (double)counter;
	ld = (ldouble)counter;
	st.s = (short)counter;
	un.s2[0] = (short)counter;
	un.s2[1] = 9 - (short)counter;
	c10[counter]  = (char)counter;
	uc10[counter] = (uchar)counter;
	s10[counter]  = (short)counter;
	us10[counter] = (ushort)counter;
	l10[counter]  = (long)counter;
	ul10[counter] = (ulong)counter;
	f10[counter]  = (float)counter;
	d10[counter]  = (double)counter;
	ld10[counter] = (ldouble)counter;
	pst->uc10[counter] = (uchar)counter;
	pun->ul = (ulong)counter;
	PSus = (ushort)counter;
    }
    return PSus;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\testbp01\bp__ulul.c ===
//**********************************************************************
//  Source module for Testbp01 app : Testing of Breakpoints
//***********************************************************************

#include "testbp.h"

extern const char     GCc;
extern const uchar   GCuc;
extern const short    GCs;
extern const ushort  GCus;
extern const long     GCl;
extern const ulong   GCul;
extern const float    GCf;
extern const double   GCd;
extern const ldouble GCld;

extern ushort /*_near*/ GShortNearArray[NEARSIZE];
//extern ushort _far GShortFarArray[FARSIZE];
//extern ushort _huge GShortHugeArray[HUGESIZE];

extern char	Gc;
extern uchar   Guc;
extern short	Gs;
extern ushort  Gus;
extern long	Gl;
extern ulong   Gul;
extern float	Gf;
extern double	Gd;
extern ldouble Gld;
extern short PassTest;

extern struct Gst
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst;

extern union Gun
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun;



ulong	_cdecl CFncULUL(ulong PSul)
{
    int counter;

    const char	   Cc = (char)1;
    const uchar   Cuc = (uchar)1;
    const short    Cs = (short)1;
    const ushort  Cus = (ushort)1;
    const long	   Cl = (long)1;
    const ulong   Cul = (ulong)1;
    const float    Cf = (float)1;
    const double   Cd = (double)1;
    const ldouble Cld = (ldouble)1;

    char     c, c10[10];
    uchar   uc, uc10[10];
    short    s, s10[10];
    ushort  us, us10[10];
    long     l, l10[10];
    ulong   ul, ul10[10];
    float    f, f10[10];
    double   d, d10[10];
    ldouble ld, ld10[10];
    struct st
    {
	short	s;
	uchar	uc10[10];
    }st, *pst = &st;
    union un
    {
	short	s2[2];
	ulong	 ul;
    }un, *pun = &un;

    for( counter = 0; counter < 10; counter++)
    {
	Gc  = (char)counter;
	Guc = (uchar)counter;
	Gs  = (short)counter;
	Gus = (ushort)counter;
	Gl  = (long)counter;
	Gul = (ulong)counter;
	Gf  = (float)counter;
	Gd  = (double)counter;
	Gld = (ldouble)counter;
	c  = (char)counter;
	uc = (uchar)counter;
	s  = (short)counter;
	us = (ushort)counter;
	l  = (long)counter;
	ul = (ulong)counter;
	f  = (float)counter;
	d  = (double)counter;
	ld = (ldouble)counter;
	Gst.Gs = (short)counter;
	Gun.Gs2[0] = (short)counter;
	Gun.Gs2[1] = 9 - (short)counter;
	c  = (char)counter;
	uc = (uchar)counter;
	s  = (short)counter;
	us = (ushort)counter;
	l  = (long)counter;
	ul = (ulong)counter;
	f  = (float)counter;
	d  = (double)counter;
	ld = (ldouble)counter;
	st.s = (short)counter;
	un.s2[0] = (short)counter;
	un.s2[1] = 9 - (short)counter;
	c10[counter]  = (char)counter;
	uc10[counter] = (uchar)counter;
	s10[counter]  = (short)counter;
	us10[counter] = (ushort)counter;
	l10[counter]  = (long)counter;
	ul10[counter] = (ulong)counter;
	f10[counter]  = (float)counter;
	d10[counter]  = (double)counter;
	ld10[counter] = (ldouble)counter;
	pst->uc10[counter] = (uchar)counter;
	pun->ul = (ulong)counter;
	PSul = (ulong)counter;
    }
    return PSul;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\testgo01\testg.h ===
//**********************************************************************
//  Header for Testgo01 app : Testing of Go/Restart/StopDebugging
//***********************************************************************

 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>

void        check();
int         check_int(int a, int b);
float       check_f(float a, float b);
int         check_func(int  a,int  l);
long        checkel_func(long a  ,long b,int  l);
float       checkef_func(float a , float b, int l);
double      checked_func(double a, double b, int l);
long double checkeld_func(long double a, long double b, int l);
char       *check_char(char *s);
char       *check_str(int a);
char       *check_lstr(int a, int b, char *s1, char *s2);

static int foo_Include(int number);

int foo_Include(int number)
{
	number*=2;
	if(number == 3)
	{
		return (-1);
	}
	return number;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\testbp01\testbp.h ===
//**********************************************************************
//  Header for Testbp01 app : Testing of Breakpoints
//***********************************************************************

#define HI 0
#define LO 1

#define FALSE 0
#define TRUE  1

#define NEARSIZE    10000
#define FARSIZE     32767
#define HUGESIZE    75000


typedef unsigned char uchar;
typedef unsigned short ushort;
typedef unsigned long ulong;
typedef long double ldouble;


void	_cdecl CFncVV (void);
char	_cdecl CFncCC (char);
uchar	_cdecl CFncUCUC(uchar);
short	_cdecl CFncSS(short);
ushort	_cdecl CFncUSUS(ushort);
long	_cdecl CFncLL(long);
ulong	_cdecl CFncULUL(ulong);
float	_cdecl CFncFF(float);
double	_cdecl CFncDD(double);
ldouble _cdecl CFncLDLD(ldouble);
short	_cdecl CFncSSRecurse(short);
void	_cdecl CFncNearArray(void);
void	_cdecl Eval( ushort , char *);

//v-katsuf - for mips dmy prolog
#if defined(_M_MRX000) || defined(_M_ALPHA)
#define MIPS_DMY_PROLOG int mip_dummy=0;
#else
#define MIPS_DMY_PROLOG 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\testbp01\testbp.c ===
//**********************************************************************
//  Main source module for Testbp01 app : Testing of Breakpoints
//***********************************************************************

#include "testbp.h"

const char     GCc = (char)1;
const uchar   GCuc = (uchar)1;
const short    GCs = (short)1;
const ushort  GCus = (ushort)1;
const long     GCl = (long)1;
const ulong   GCul = (ulong)1;
const float    GCf = (float)1;
const double   GCd = (double)1;
const ldouble GCld = (ldouble)1;

ushort GShortNearArray[NEARSIZE];
//ushort _near GShortNearArray[NEARSIZE];
//ushort _far GShortFarArray[FARSIZE];
//ushort _huge GShortHugeArray[HUGESIZE];

char	 Gc;
uchar	Guc;
short	 Gs;
ushort	Gus;
long	 Gl;
ulong	Gul;
float	 Gf;
double	 Gd;
ldouble Gld;
short PassTest;

struct Gst
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst = &Gst;
union Gun
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun = &Gun;

int TestBP( void );


int TestBP()
{
#ifdef _M_ALPHA
    MIPS_DMY_PROLOG
#endif
    int counter;

    char     c;
    uchar   uc;
    short    s;
    ushort  us;
    long     l;
    ulong   ul;
    float    f;
    double   d;
    ldouble ld;

	 CFncVV ();
     c = CFncCC (c);
    uc = CFncUCUC(uc);
     s = CFncSS(s);
    us = CFncUSUS(us);
     l = CFncLL(l);
    ul = CFncULUL(ul);
     f = CFncFF(f);
     d = CFncDD(d);
    ld = CFncLDLD(ld);
     s = CFncSSRecurse(10);
	 CFncNearArray();

    for( counter = 0; counter < 10; counter++)
    {
		Gc  = (char)counter;
		Guc = (uchar)counter;
		Gs  = (short)counter;
		Gus = (ushort)counter;
		Gl  = (long)counter;
		Gul = (ulong)counter;
		Gf  = (float)counter;
		Gd  = (double)counter;
label:	c  = (char)counter;
		uc = (uchar)counter;
		s  = (short)counter;
		us = (ushort)counter;
		l  = (long)counter;
		ul = (ulong)counter;
		f  = (float)counter;
		d  = (double)counter;
		ld = (ldouble)counter;
		Gst.Gs = (short)counter;
		Gun.Gs2[0] = (short)counter;
		Gun.Gs2[1] = 9 - (short)counter;
    }
	return (1);
}
#include <windows.h>
int PASCAL WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR lszCmdLine, int nCmdShow)
{
	int iBP = TestBP();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\testgo01\testgo.c ===
/*********************************************/
/* testgo.c                                  */
/*********************************************/
/* CVM : g : Go command                      */
/*********************************************/
#include <stdio.h>
#include "testg.h"
#define ArrayLength 100
#define StructString65 "String65String65String65String65String65String65String65String65"
#define LocalString65  "__local_String65__local_String65__local_String65__local_String65"
#define Flag 1

int TestG(void);
int func();
int recur_func();
int foo(int);
void nest_func();
int Global;
typedef int My_typedef;

struct Struct 
{
   int IntN;
   char *String65;
} Struct;

union Union 
{
   int Int;
   long Long;
} Union;

enum Enum 
{
  one,
  two,
  three
} Enum;

void nest_func()
{
 	if (func()) 
   	foo (func());
};
int func() { 
			return 33;
		   };
int foo(int Parameter) {
    return Parameter;
 };

int recur_func() 
{
   static x=1;
   x++;
   if (x<9) recur_func();
   else return x;
};
#include <windows.h>
int PASCAL WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR lszCmdLine, int nCmdShow)
{
//	char c;
//	unsigned int ui;
	int iGo = TestG();
// 	c = getchar(&ui);
	return 0;
}

int TestG()
{
 	int Local;
 	char Char;
 	int Int;
 	long Long;
 	double Double;
 	long double Ldouble;
 	float Real;
 	char *String;
 	void *Void;
 	My_typedef Mine;
 
	struct Struct Struct_local;
	union  Union Union_local;
	enum   Enum Enum_local;

 	struct Struct Array_struct[ArrayLength];
 	int  Array1d[3];
 	long Array2d[3][3];
 	char Array3d[3][3][3];

 	if (Flag) 
	{
  		for (Int=0; Int < ArrayLength; Int++)
   	{						                      // not executable code line
			Array_struct[Int].IntN = Int;
			Array_struct[Int].String65 = StructString65;
		};	  
 	};

 	for (Int=0; Int<3; Int++) 
	{
     	Array1d[Int]=Int;
     	Array2d[Int][Int]=Int;
     	Array3d[Int][Int][Int]=Int;
  	};

 	Local=17;
 	Array1d[2]=9;
 	Struct.IntN = 1;
 	Struct.String65 = StructString65;
 	Struct_local.IntN = 11;
 	Struct_local.String65 = LocalString65;
 	Int=2;Int=6;Int=9;
 	Real=1.303;
 	Double=1.303;
 	Ldouble=1.303;
 	String="this is a string";
 	Global=77;
 	Long=99;
 	Int=func();

 	if (Local > 0) 
	{
 		while (Local == 1)  
			Real = 9.9999;    // dead code
		if (Local > 1)
   	{							// not executable code line
	 		while (Local == 17)
			{                 // not executable code line
	 			Real = 8.88888;
				break;
			}
		}
 		else
 		 Real = 7.77;		// dead code
	}
 	else						
   {							// dead code
      Real = 6.1;	      // dead code
	}							// dead code

 	if (1 < Local) do { Double = 555.555; } while (Local == 0);

DA_FUNC:	                        // label
 	Int=foo(Local);
	Int = foo_Include(Int);
 	Int=recur_func();
 	Int=0;  Int=check_func(Int,90);
	Void = (void*)Int;
  	nest_func();
if(func() == 33)goto LabeL;
	Int = 999;
LabeL: 	return 1;
}


int check_func( int a, int l )
{
	char test[] = "TestName";
	
   if( !a )
   {
//      printf("%s: Passed , line: %d --- %d != 0\n",test, l, a );
   }
   else
   {
//      printf("%s: Failure, line: %d --- %d = 0\n",test, l, a );
   }
   return a;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\testbp01\bp__vv.c ===
//**********************************************************************
//  Source module for Testbp01 app : Testing of Breakpoints
//***********************************************************************

#include "testbp.h"

extern const char     GCc;
extern const uchar   GCuc;
extern const short    GCs;
extern const ushort  GCus;
extern const long     GCl;
extern const ulong   GCul;
extern const float    GCf;
extern const double   GCd;
extern const ldouble GCld;

extern ushort /*_near*/ GShortNearArray[NEARSIZE];
//extern ushort _far GShortFarArray[FARSIZE];
//extern ushort _huge GShortHugeArray[HUGESIZE];

extern char	Gc;
extern uchar   Guc;
extern short	Gs;
extern ushort  Gus;
extern long	Gl;
extern ulong   Gul;
extern float	Gf;
extern double	Gd;
extern ldouble Gld;
extern short PassTest;

extern struct Gst
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst;

extern union Gun
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun;


void _cdecl CFncVV (void)
{
    int counter;

    const char	   Cc = (char)1;
    const uchar   Cuc = (uchar)1;
    const short    Cs = (short)1;
    const ushort  Cus = (ushort)1;
    const long	   Cl = (long)1;
    const ulong   Cul = (ulong)1;
    const float    Cf = (float)1;
    const double   Cd = (double)1;
    const ldouble Cld = (ldouble)1;

    char     c, c10[10];
    uchar   uc, uc10[10];
    short    s, s10[10];
    ushort  us, us10[10];
    long     l, l10[10];
    ulong   ul, ul10[10];
    float    f, f10[10];
    double   d, d10[10];
    ldouble ld, ld10[10];
    struct st
    {
	short	s;
	uchar	uc10[10];
    }st, *pst = &st;
    union un
    {
	short	s2[2];
	ulong	 ul;
    }un, *pun = &un;

    for( counter = 0; counter < 10; counter++)
    {
	Gc  = (char)counter;
	Guc = (uchar)counter;
	Gs  = (short)counter;
	Gus = (ushort)counter;
	Gl  = (long)counter;
	Gul = (ulong)counter;
	Gf  = (float)counter;
	Gd  = (double)counter;
	c  = (char)counter;
	uc = (uchar)counter;
	s  = (short)counter;
	us = (ushort)counter;
	l  = (long)counter;
	ul = (ulong)counter;
	f  = (float)counter;
	d  = (double)counter;
	ld = (ldouble)counter;
	Gst.Gs = (short)counter;
	Gun.Gs2[0] = (short)counter;
	Gun.Gs2[1] = 9 - (short)counter;
	st.s = (short)counter;
	un.s2[0] = (short)counter;
	un.s2[1] = 9 - (short)counter;
	c10[counter]  = (char)counter;
	uc10[counter] = (uchar)counter;
	s10[counter]  = (short)counter;
	us10[counter] = (ushort)counter;
	l10[counter]  = (long)counter;
	ul10[counter] = (ulong)counter;
	f10[counter]  = (float)counter;
	d10[counter]  = (double)counter;
	ld10[counter] = (ldouble)counter;
	pst->uc10[counter] = (uchar)counter;
	pun->ul = (ulong)counter;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ec breakpoints app\base exe.cpp ===
#include <windows.h>


void ExeFunc1(void);
void ExeFunc2(void);


int FAR PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)
{	// first line of WinMain().
	ExeFunc1();
	while(0);	// line after call to ExeFunc1().
	return 0;	// last line of WinMain().
}


void ExeFunc1(void)
{	// first line of ExeFunc1().
	ExeFunc2();
	while(0);	// line after call to ExeFunc2().
}	// last line of ExeFunc1().


void ExeFunc2(void)
{	// first line of ExeFunc2().
	while(0);
}	// last line of ExeFunc2().
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ec locals app\base dll.cpp ===
#include <windows.h>


extern "C"
{

__declspec(dllexport) void DllFunc2(void)
{	// first line of DllFunc2()
}


__declspec(dllexport) void DllFunc1(void)
{	// first line of DllFunc1()
}

__declspec(dllexport) void DefaultDllFunc(void)
{	// first line of DefaultDllFunc()
}

}


int WINAPI DllMain(HANDLE hInst, ULONG ulRbc, LPVOID lpReserved)
{
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ec locals app\base exe.cpp ===
#include <windows.h>


enum ENUM1{ENUM1_VAL1, ENUM1_VAL2, ENUM1_VAL3};
ENUM1 ENUM1Global = ENUM1_VAL1;


struct STRUCT1
{
	int m_intSTRUCT1;
} STRUCT1Global;


union UNION1
{
	int m_intUNION1;
} UNION1Global;


class CBase
{
public:
	int m_intCBase;
	CBase(void){m_intCBase = 0;}
};


class CDerived : public CBase
{
public:
	int m_intCDerived;
	CDerived(void){m_intCDerived = 0;}
};


void ExeFunc1(void);
void ExeFunc2(void);
void ExeFunc3(void);
void ExeFunc4(void);
void ExeFunc5(void);
void ExeFunc6(void);
void ExeFunc7(void);
void ExeFunc8(void);
void ExeFunc9(void);
void ExeFunc10(void);

/*
extern "C"
{

__declspec(dllimport) void DefaultDllFunc(void);
__declspec(dllimport) void DllFunc1(void);
__declspec(dllimport) void DllFunc2(void);
__declspec(dllimport) void DllFunc3(void);
__declspec(dllimport) void DllFunc4(void);
__declspec(dllimport) void DllFunc5(void);

}
*/

int intGlobal = 0;


int FAR PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)

{	// first line of WinMain().
	
	//DefaultDllFunc();
	ExeFunc1();
	while(0);	// line after call to ExeFunc1().
	ExeFunc2();
	while(0);	// line after call to ExeFunc2().
	ExeFunc3();
	while(0);	// line after call to ExeFunc3().
	ExeFunc4();
	while(0);	// line after call to ExeFunc4().
	ExeFunc5();
	while(0);	// line after call to ExeFunc5().

	return 0;	// last line of WinMain().
}


void ExeFunc1(void)
{	// first line of ExeFunc1().
	ExeFunc6();
	while(0);	// line after call to ExeFunc6().
	// DllFunc1();
}	// last line of ExeFunc1().


void ExeFunc2(void)
{	// first line of ExeFunc2().
	ExeFunc7();
	while(0);	// line after call to ExeFunc7().	
	// DllFunc2();
}	// last line of ExeFunc2().


void ExeFunc3(void)
{	// first line of ExeFunc3().
	ExeFunc8();
	while(0);	// line after call to ExeFunc8().
	// DllFunc3();
}	// last line of ExeFunc3().


void ExeFunc4(void)
{	// first line of ExeFunc4().
	ExeFunc9();
	while(0);	// line after call to ExeFunc9().
	// DllFunc4();
}	// last line of ExeFunc4().


void ExeFunc5(void)
{	// first line of ExeFunc5().
	ExeFunc10();
	while(0);	// line after call to ExeFunc10().
	// DllFunc5();
}	// last line of ExeFunc5().


void ExeFunc6(void)
{	// first line of ExeFunc6().
	while(0);
}	// last line of ExeFunc6().


void ExeFunc7(void)
{	// first line of ExeFunc7().
	while(0);
}	// last line of ExeFunc7().


void ExeFunc8(void)
{	// first line of ExeFunc8().
	while(0);
}	// last line of ExeFunc8().


void ExeFunc9(void)
{	// first line of ExeFunc9().
	while(0);
}	// last line of ExeFunc9().


void ExeFunc10(void)
{	// first line of ExeFunc10().
	while(0);
}	// last line of ExeFunc10().
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\threads\threads.cpp ===
#include <windows.h>


HANDLE hSecondaryThread;
DWORD dwSecondaryThreadID, dwMainThreadID;
int intGlobal = 0;
BOOL bInfiniteLoop = TRUE;


void FuncCalledBySecondaryThreadFunc(void)
{	// first line of FuncCalledBySecondaryThreadFunc().
}


unsigned long __stdcall SecondaryThreadFunc(void * pdata)

{	// first line of SecondaryThreadFunc().

	int intLocalSecondaryThreadFunc = 1;
	intGlobal = 1;
	while(0);							// line after intGlobal changed.
	
	FuncCalledBySecondaryThreadFunc();
	while(0);							// line after call to FuncCalledBySecondaryThreadFunc().

	while(bInfiniteLoop);				// loop inside SecondaryThreadFunc().
	return 1;
}


void CreateThreadFunc(void)
{
	hSecondaryThread = CreateThread(NULL, 0, SecondaryThreadFunc, 0, 0, &dwSecondaryThreadID);
	// sleeping will enure that the thread is created before this function returns.
	Sleep(3000);	// line after call to CreateThread().
}	// last line of CreateThreadFunc().


int PASCAL WinMain(HINSTANCE hInst, HINSTANCE hInstPrev, LPSTR lszCmdLine, int nCmdShow)
{
	dwMainThreadID = GetCurrentThreadId();
	int intLocalWinMain = 0;
	CreateThreadFunc();
	while(bInfiniteLoop);	// loop inside WinMain().
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\chain1.h ===
int   chain_1(int x);
int   chain_5(int x);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\Core\src\tmplates\tmplates.cpp ===
#include <afxwin.h>
#include <map>

//make all data known data types
int global_int = 1;
float global_float = 1.0;


void globalfunc(void){}

template<typename Type>
void globaltemplatefunc(Type var) //ENC: edit template function declaration here: any case, rebuild
{ // first line of globaltemplatefunc
	int var1 = 1; //ENC: edit template function definition here: any case, rebuild
	int var2 = 3;
	int var3 = var1 + var2 + (int)var;
}


template<> void globaltemplatefunc<float>(float var)
{ // first line of float specialization of globaltemplatefunc
	float var1 = 1.0; //ENC: edit explicit template function specialization here: any case, rebuild
	float var2 = 2.0;
	float var3 = 2.0*var1 + 2.0*var2 + var;
}

template void globaltemplatefunc<double>(double); //ENC: edit explicit template function instantiation here: any case, rebuild

template<typename Type> class SomeReallyLongSymbolName; //ENC: edit template class declaration here

template<typename Type> class SomeReallyLongSymbolName
{
    public:
		SomeReallyLongSymbolName(Type var)
		{
			m_Type = var;
		}
		
		void func(Type var)
		{ // first line of template function 'func'
			m_Type = var;
			globalfunc();
			while(0); // in template function 'func'
		}
	//ENC: edit template class definition here, add some variable
		Type m_Type;
};

SomeReallyLongSymbolName<int> intObject(0);
SomeReallyLongSymbolName<char> charObject('a');

template<> class SomeReallyLongSymbolName<double>{}; //ENC: edit explicit class template specialization, add parameter?

typedef std::map<DWORD, SomeReallyLongSymbolName<DWORD> > STLTypeWithLongName;


void FuncWithTemplateClassParam(SomeReallyLongSymbolName<int> intObjectParam)
{ // first line of FuncWithTemplateClassParam
	int test=0;
}


int PASCAL WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR lszCmdLine, int nCmdShow)
{
	SomeReallyLongSymbolName<float> localfloatObject(1.0); //ENC: edit template class instantiation (ex change to double)
	int var1 = 8;
	intObject.func(1);
	while(0); //1
	intObject.func(2);
	while(0); //2

	charObject.func('b');
	while(0); //b
	charObject.func('c');
	while(0); //c

	FuncWithTemplateClassParam(intObject);
	while(0); //intObject

	globaltemplatefunc(1);
	while(0); //::1
	globaltemplatefunc('a');
	while(0); //::a
	globaltemplatefunc(global_float);
	while(0);// ::global_float

	STLTypeWithLongName STLObjectWithLongName;
	if(var1==0)
	{
		var1++;
	}
	else 
		if(var1==4)
	{
		var1=0;
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\chain2.h ===
int   chain_2(int x);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\chain3.h ===
int   chain_3(int x);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\Based.cpp ===
#include "calls.h"

#define VAL1	8
#define VAL2	9	// Removable for testing
#define RG1	{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 }
#define RG2	{ 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 }  // Removable
#define RG  { 65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90}
#define LENGTH 10000

int func1(void);
int func2(void);
int (*pfn1)() = func1;
__int64 func3(void);

#pragma data_seg("_CODE")
char rg_global_base_1[16] = RG1;	// only initialized data ends up here
char  rg_global_char[26] = RG;
int   rg_global_int[26] = RG;
__int64   rg_global_int64[26] = RG;
long  rg_global_long[26] = RG;
float rg_global_float[26] = RG;
double rg_global_double[26] = RG;
long double rg_global_ldouble[26] = RG;

int (*pfn)() = func1;
int (*pfn2)() = func2;
int (*pfn222)();
__int64 (*pfn64)();

long  rg_global_long2[LENGTH] = {0};
int   rg_global_int2[26];

void Based(void)
{
	char	*stack_base_ptr1;

	int i1, i2, i11, i22, ifn, ifn2;
	int i;

	char  *p_global_char;
	int   *p_global_int;
	__int64   *p_global_int64;
	long  *p_global_long;
	long  *p_global_long2;
	float *p_global_float;
	double *p_global_double;
	long double *p_global_ldouble;
	int *p_global_int2;

	int (*pfn11)();
	int (*pfn111)() = func1;
	int (*pfn22)();
	
	p_global_char = &rg_global_char[1];
	p_global_int = &rg_global_int[2];
	p_global_int64 = &rg_global_int64[3];
	p_global_long = &rg_global_long[4];
	p_global_float = &rg_global_float[5];
	p_global_double = &rg_global_double[6];
	p_global_ldouble = &rg_global_ldouble[7];
	p_global_long2 = &rg_global_long2[LENGTH-1];

	pfn11 = func1;
	ifn = pfn();
	i1 = func1(); // Based
	i11 = pfn11();
	i11 = pfn111();
	pfn111 = func2;
	i11 = pfn111();

	__int64 i64 = func3();

	for(i=0; i<26; i++) rg_global_int2[i] = 66;
	p_global_int2 = &rg_global_int2[5];

	pfn22 = func2;
	pfn222 = pfn22;
	ifn2 = pfn222();
	ifn2 = pfn2();
	i2 = func2();
	i22 = pfn22();

	for(i=0; i<LENGTH; i++)
		 rg_global_long2[i] = 50;

	stack_base_ptr1 = &rg_global_base_1[7];

	rg_global_base_1[7] = VAL1;

}


int func1(void)
{
	int i_1;
	i_1 = 5;

	int j_1 = 5;

	for (int i =0; i < 10; i++)	// func1
	{
		j_1 += i;
	}

	return 64;
}

__int64 func3(void)
{
	int j_3 = 5;
	for (int i =0; i < 10; i++)	// func3
	{
		j_3 += i;
	}

	return 3333;
}

int func2(void)
{
	static int (*pfn100)() = func1;

	int i1 = pfn100() + 1;

	int (*pfn101)() = func1;

	int i2 = pfn101() + 2;

	static int rg_static_int[26];
	int *p_2 = &rg_static_int[1];
	int *p_static = &rg_static_int[0];
	rg_static_int[2] = 32;
	i1 = func1(); // func2
	return rg_static_int[2];
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\chain0.c ===
#include <string.h>
#include "chain1.h"

int Global=0;
int Result=0;
char * String=" Some sample string";

int ChainMain() {
  Result=chain_1(3);
  return 1;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\calls.h ===
#if defined(_WINDOWS)
#include <windows.h>
#endif

#include <limits.h>
#include <float.h>
#include <stdarg.h>
//#include "testg.h"

//***************************************************************************
// prototypes
int                     Calls(void);
int                     TestG(void);
void					Based(void);

void                    VoidProcNoParam(void);
char                    CharProcNoParam(void);
unsigned char           UCharProcNoParam(void);
int                     IntProcNoParam(void);
unsigned int            UIntProcNoParam(void);
__int64                 Int64ProcNoParam(void);
unsigned __int64        UInt64ProcNoParam(void);
short                   ShortProcNoParam(void);
unsigned short          UShortProcNoParam(void);
long                    LongProcNoParam(void);
unsigned long           ULongProcNoParam(void);
float                   FloatProcNoParam(void);
double                  DoubleProcNoParam(void);
long double             LDoubleProcNoParam(void);

void                    VoidProc1Param(int i);
char                    CharProc1Param(char c);
unsigned char           UCharProc1Param(unsigned char uc);
int                     IntProc1Param(int i);
unsigned int            UIntProc1Param(unsigned int ui);
__int64                 Int64Proc1Param(__int64 i64);
unsigned __int64        UInt64Proc1Param(unsigned __int64 ui64);
short                   ShortProc1Param(short s);
unsigned short          UShortProc1Param(unsigned short us);
long                    LongProc1Param(long l);
unsigned long           ULongProc1Param(unsigned long ul);
float                   FloatProc1Param(float f);
double                  DoubleProc1Param(double d);
long double             LDoubleProc1Param(long double ld);

short *            		PShortProc1Param(short * ps);
int * 					LPIntProc1Param(int * lpi);

int                     average(int first, ...);
unsigned long           factorial(int i);

long		            MultiParam(char c, int i, short s, long l, double d, long double ld, float f);
void 					check(int i, char *pc);


// for mips
#if defined( _M_MRX000 ) || defined(_M_ALPHA)
#define MIPS_DMY_PROLOG int mip_dummy=0;
#else
#define MIPS_DMY_PROLOG 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\chain3.c ===
#include "chain3.h"

extern int chain_4(int x);

int   chain_3(int x)
{
    int Sum;
    Sum=x+chain_4(x);
    return Sum;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\chain1.c ===
#include "chain1.h"
#include "chain2.h"

int Global;

///////////////////////////////////////////////////////////////////////////
int   chain_1(int x)
{
    int Sum;
    Sum=x+chain_2(x);
    return Sum;
};


///////////////////////////////////////////////////////////////////////////
int   chain_5(int x)
{
    x=x*2;
    return x;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\chain2.c ===
#include "chain2.h"
#include "chain3.h"

int   chain_2(int x)
{
    int Sum;
    Sum=x+chain_3(x);
    return Sum;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\calls.cpp ===
#include <stdio.h>
#include "calls.h"

extern "C"
{
	int main_Calls( void );
}

//****************************************************************************
// globals

char            scharmax    = SCHAR_MAX;
char            scharmin    = SCHAR_MIN;
unsigned char   ucharmax    = UCHAR_MAX;
unsigned char   ucharmin    = 0;
int             intmax      = INT_MAX;
int             intmin      = INT_MIN;
unsigned int    uintmax     = UINT_MAX;
unsigned int    uintmin     = 0;
short           shrtmax     = SHRT_MAX;
short           shrtmin     = SHRT_MIN;
unsigned short  ushrtmax    = USHRT_MAX;
unsigned short  ushrtmin    = 0;
long            longmax     = LONG_MAX;
long            longmin     = LONG_MIN;
unsigned long   ulongmax    = ULONG_MAX;
unsigned long   ulongmin    = 0;
double          dblmax      = DBL_MAX;
double          dblmin      = DBL_MIN;
long double     ldblmax     = LDBL_MAX;
long double     ldblmin     = LDBL_MIN;
float           fltmax      = FLT_MAX;
float           fltmin      = FLT_MIN;
__int64			int64max	= _I64_MAX;
__int64			int64min	= _I64_MIN;
unsigned __int64 uint64max	= _UI64_MAX;

char            *pscharmax  = &scharmax;
char            *pscharmin  = &scharmin;
unsigned char   *pucharmax  = &ucharmax;
unsigned char   *pucharmin  = &ucharmin;
int             *pintmax    = &intmax;
int             *pintmin    = &intmin;
unsigned int    *puintmax   = &uintmax;
unsigned int    *puintmin   = &uintmin;
short           *pshrtmax   = &shrtmax;
short           *pshrtmin   = &shrtmin;
unsigned short  *pushrtmax  = &ushrtmax;
unsigned short  *pushrtmin  = &ushrtmin;
long            *plongmax   = &longmax;
long            *plongmin   = &longmin;
unsigned long   *pulongmax  = &ulongmax;
unsigned long   *pulongmin  = &ulongmin;
double          *pdblmax    = &dblmax;
double          *pdblmin    = &dblmin;
long double     *pldblmax   = &ldblmax;
long double     *pldblmin   = &ldblmin;
float           *pfltmax    = &fltmax;
float           *pfltmin    = &fltmin;
__int64			*pint64max	= &int64max;
__int64			*pint64min	= &int64min;
unsigned __int64 *puint64max	= &uint64max;

//****************************************************************************
int main_Calls(void)
{
	int iCalls = Calls();
	iCalls = TestG();
	Based();

	return 0;
}

int Calls(void)
{
    int  i_main = 4;

    // no parameters
    VoidProcNoParam();
    check(!(CharProcNoParam() == SCHAR_MIN), "CharProcNoParam()");
    check(!(UCharProcNoParam() == UCHAR_MAX), "UCharProcNoParam()");
    check(!(IntProcNoParam() == INT_MIN), "IntProcNoParam()");
    check(!(UIntProcNoParam() == UINT_MAX), "UIntProcNoParam()");
    check(!(ShortProcNoParam() == SHRT_MIN), "ShortProcNoParam()");
    check(!(UShortProcNoParam() == USHRT_MAX), "UShortProcNoParam()");
    check(!(LongProcNoParam() == LONG_MIN), "LongProcNoParam()");
    check(!(ULongProcNoParam() == ULONG_MAX), "ULongProcNoParam()");
    check(!(DoubleProcNoParam() == DBL_MIN), "DoubleProcNoParam()");
    check(!(LDoubleProcNoParam() == LDBL_MAX), "LDoubleProcNoParam()");
    check(!(FloatProcNoParam() == FLT_MIN), "FloatProcNoParam()");
    check(!(Int64ProcNoParam() == _I64_MIN), "Int64ProcNoParam()");
    check(!(UInt64ProcNoParam() == _UI64_MAX), "UInt64ProcNoParam()");

    // at least one parameter
    VoidProc1Param(INT_MAX);
    check(!(CharProc1Param(SCHAR_MIN) == SCHAR_MIN), "CharProc1Param");
    check(!(UCharProc1Param(UCHAR_MAX) == UCHAR_MAX), "UCharProc1Param");
    check(!(IntProc1Param(INT_MIN) == INT_MIN), "IntProc1Param");
    check(!(UIntProc1Param(UINT_MAX) == UINT_MAX), "UIntProc1Param");
    check(!(ShortProc1Param(SHRT_MIN) == SHRT_MIN), "ShortProc1Param");
    check(!(UShortProc1Param(USHRT_MAX) == USHRT_MAX), "UShortProc1Param");
    check(!(LongProc1Param(LONG_MIN) == LONG_MIN), "LongProc1Param");
    check(!(ULongProc1Param(ULONG_MAX) == ULONG_MAX), "ULongProc1Param");
    check(!(DoubleProc1Param(DBL_MAX) == DBL_MAX), "DoubleProc1Param");
    check(!(LDoubleProc1Param(LDBL_MIN) == LDBL_MIN), "LDoubleProc1Param");
    check(!(FloatProc1Param(FLT_MAX) == FLT_MAX), "FloatProc1Param");
    check(!(Int64Proc1Param(_I64_MIN) == _I64_MIN), "Int64Proc1Param");
    check(!(UInt64Proc1Param(_UI64_MAX) == _UI64_MAX), "UInt64Proc1Param");

    // parameter passed on using global variables
    VoidProc1Param(intmax);
    check(!(CharProc1Param(scharmin) == SCHAR_MIN), "CharProc1Param");
    check(!(UCharProc1Param(ucharmax) == UCHAR_MAX), "UCharProc1Param");
    check(!(IntProc1Param(intmin) == INT_MIN), "IntProc1Param");
    check(!(UIntProc1Param(uintmax) == UINT_MAX), "UIntProc1Param");
    check(!(ShortProc1Param(shrtmin) == SHRT_MIN), "ShortProc1Param");
    check(!(UShortProc1Param(ushrtmax) == USHRT_MAX), "UShortProc1Param");
    check(!(LongProc1Param(longmin) == LONG_MIN), "LongProc1Param");
    check(!(ULongProc1Param(ulongmax) == ULONG_MAX), "ULongProc1Param");
    check(!(DoubleProc1Param(dblmax) == DBL_MAX), "DoubleProc1Param");
    check(!(LDoubleProc1Param(ldblmin) == LDBL_MIN), "LDoubleProc1Param");
    check(!(FloatProc1Param(fltmax) == FLT_MAX), "FloatProc1Param");
    check(!(Int64Proc1Param(int64min) == _I64_MIN), "Int64Proc1Param");
    check(!(UInt64Proc1Param(uint64max) == _UI64_MAX), "UInt64Proc1Param");

    // parameter passed on using pointers
    VoidProc1Param(*pintmax);
    check(!(CharProc1Param(*pscharmin) == SCHAR_MIN), "CharProc1Param*");
    check(!(UCharProc1Param(*pucharmax) == UCHAR_MAX), "UCharProc1Param*");
    check(!(IntProc1Param(*pintmin) == INT_MIN), "IntProc1Param*");
    check(!(UIntProc1Param(*puintmax) == UINT_MAX), "UIntProc1Param*");
    check(!(ShortProc1Param(*pshrtmin) == SHRT_MIN), "ShortProc1Param*");
    check(!(UShortProc1Param(*pushrtmax) == USHRT_MAX), "UShortProc1Param*");
    check(!(LongProc1Param(*plongmin) == LONG_MIN), "LongProc1Param*");
    check(!(ULongProc1Param(*pulongmax) == ULONG_MAX), "ULongProc1Param*");
    check(!(DoubleProc1Param(*pdblmax) == DBL_MAX), "DoubleProc1Param*");
    check(!(LDoubleProc1Param(*pldblmin) == LDBL_MIN), "LDoubleProc1Param*");
    check(!(FloatProc1Param(*pfltmax) == FLT_MAX), "FloatProc1Param*");
    check(!(Int64Proc1Param(*pint64min) == _I64_MIN), "Int64Proc1Param");
    check(!(UInt64Proc1Param(*puint64max) == _UI64_MAX), "UInt64Proc1Param");

    // parameter passed on using near/far/ellipses
    check(!(PShortProc1Param(&shrtmin) == pshrtmin), "PShortProc1Param*");
    check(!(LPIntProc1Param((int *)&intmin) == (int *)pintmin), "LPIntProc1Param*");

    // variable parameters and recursive
    check(!(average(1,2,3,4,5,6,7,8,9, -1) == 5), "average");
    check(!(factorial(9) == (long)362880), "factorial");

    check(!(MultiParam(CHAR_MIN, INT_MAX, SHRT_MAX, LONG_MAX, DBL_MAX, LDBL_MAX, FLT_MAX) == LONG_MAX), "MultiParam");

	return i_main;
}

//****************************************************************************
// Purpose:     function returning void and has no parameter
void VoidProcNoParam(void)
{	MIPS_DMY_PROLOG
    return;
}

// Purpose:     function returning char and has no parameter
char CharProcNoParam(void)
{	MIPS_DMY_PROLOG
    return SCHAR_MIN;
}

// Purpose:     function returning unsigned char and has no parameter
unsigned char UCharProcNoParam(void)
{	MIPS_DMY_PROLOG
    return UCHAR_MAX;
}

// Purpose:     function returning int and has no parameter
int IntProcNoParam(void)
{	MIPS_DMY_PROLOG
    return INT_MIN;
}

// Purpose:     function returning unsigned int and has no parameter
unsigned int UIntProcNoParam(void)
{	MIPS_DMY_PROLOG
    return UINT_MAX;
}

// Purpose:     function returning int64 and has no parameter
__int64 Int64ProcNoParam(void)
{	MIPS_DMY_PROLOG
    return _I64_MIN;
}

// Purpose:     function returning unsigned int64 and has no parameter
unsigned __int64 UInt64ProcNoParam(void)
{	MIPS_DMY_PROLOG
    return _UI64_MAX;
}

// Purpose:     function returning short and has no parameter
short ShortProcNoParam(void)
{	MIPS_DMY_PROLOG
    return SHRT_MIN;
}

// Purpose:     function returning unsigned short and has no parameter
unsigned short UShortProcNoParam(void)
{	MIPS_DMY_PROLOG
    return USHRT_MAX;
}

// Purpose:     function returning long and has no parameter
long LongProcNoParam(void)
{	MIPS_DMY_PROLOG
    return LONG_MIN;
}

// Purpose:     function returning unsigned long and has no parameter
unsigned long ULongProcNoParam(void)
{	MIPS_DMY_PROLOG
    return ULONG_MAX;
}

// Purpose:     function returning float and has no parameter
float FloatProcNoParam(void)
{	MIPS_DMY_PROLOG
    return FLT_MIN;
}

// Purpose:     function returning Double and has no parameter
double DoubleProcNoParam(void)
{	MIPS_DMY_PROLOG
    return DBL_MIN;
}

// Purpose:     function returning long double and has no parameter
long double LDoubleProcNoParam(void)
{	MIPS_DMY_PROLOG
    return LDBL_MAX;
}

//****************************************************************************
// Purpose:     function returning void and has 1 parameter
void VoidProc1Param(int i)
{	MIPS_DMY_PROLOG
    return;
}

// Purpose:     function returning char and has 1 parameter
char CharProc1Param(char c)
{	MIPS_DMY_PROLOG
    return c;
}
// Purpose:     function returning unsigned char and has 1 parameter
unsigned char UCharProc1Param(unsigned char uc)
{	MIPS_DMY_PROLOG
    return uc;
}

// Purpose:     function returning int and has 1 parameter
int IntProc1Param(int i)
{	MIPS_DMY_PROLOG
    return i;
}

// Purpose:     function returning unsigned int and has 1 parameter
unsigned int UIntProc1Param(unsigned int ui)
{	MIPS_DMY_PROLOG
    return ui;
}

// Purpose:     function returning int64 and has 1 parameter
__int64 Int64Proc1Param(__int64 i64)
{	MIPS_DMY_PROLOG
    return i64;
}

// Purpose:     function returning unsigned int64 and has 1 parameter
unsigned __int64 UInt64Proc1Param(unsigned __int64 ui64)
{	MIPS_DMY_PROLOG
    return ui64;
}


// Purpose:     function returning short and has 1 parameter
short ShortProc1Param(short s)
{	MIPS_DMY_PROLOG
    return s;
}

// Purpose:     function returning unsigned short and has 1 parameter
unsigned short UShortProc1Param(unsigned short us)
{	MIPS_DMY_PROLOG
    return us;
}

// Purpose:     function returning long and has 1 parameter
long LongProc1Param(long l)
{	MIPS_DMY_PROLOG
    return l;
}

// Purpose:     function returning unsigned long and has 1 parameter
unsigned long ULongProc1Param(unsigned long ul)
{	MIPS_DMY_PROLOG
    return ul;
}

// Purpose:     function returning float and has 1 parameter
float FloatProc1Param(float f)
{	MIPS_DMY_PROLOG
    return f;
}

// Purpose:     function returning Double and has 1 parameter
double DoubleProc1Param(double d)
{	MIPS_DMY_PROLOG
    return d;
}

// Purpose:     function returning long double and has 1 parameter
long double LDoubleProc1Param(long double ld)
{	MIPS_DMY_PROLOG
    return ld;
}

//****************************************************************************
// Purpose:     function returning address and has 1 parameter
//              as pointer
short * PShortProc1Param(short * ps)
{	MIPS_DMY_PROLOG
    return ps;
}

int * LPIntProc1Param(int * lpi)
{	MIPS_DMY_PROLOG
    return lpi;
}

//****************************************************************************
// Purpose:     function returning address and has ... parameter
int average(int first, ...)
{	MIPS_DMY_PROLOG
    int count = 0, sum = 0, i = first;
    va_list marker;

    va_start(marker, first);
    while (i != -1)
    {
        sum += i;
        count++;
        i = va_arg(marker, int);
    }
    va_end(marker);
    return (sum ? (sum/count):(0));
}

//****************************************************************************
// Purpose:     recursive function
unsigned long factorial(int i)
{	MIPS_DMY_PROLOG
    if (i == 0)
        return 1;
    else
        return (i * factorial(i-1));
}

//****************************************************************************
// Purpose:     function returning long and has many parameters
long MultiParam(char c, int i, short s, long l, double d, long double ld, float f)
{	MIPS_DMY_PROLOG
	long double ldbl = (long double)c + (long double)i + (long double)s + (long double)l + (long double)d + (long double)ld + (long double)f;
	return l;
}

void check(int i, char *pc)
{	MIPS_DMY_PROLOG
	if( !i ) return;
	printf("%s FAILED", pc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\chain4.h ===
#include "foo.h"

#if TEST == cBASIC

#ifdef hasPARAMS
#define  fooParams int paramA, int paramB
#else
#define  fooParams
#endif

#ifdef returnsVALUE
#define  fooReturn  int
#else
#define  fooReturn  void
#endif

fooReturn FUNCTYPE chainmain( fooParams );

#endif  // TEST == cBASIC

int  recursive_dll(int lim , int code);
int  chain_4(int x);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\chainx1.c ===
// Intended to be compiled without debug info

#include "chainx1.h"
#include "chainx2.h"
#include "chain3.h"

int chain_x1(int x)
{
    int Sum;

	// call to a function compiled with partial debug info
    Sum=x+chain_x2(x);

	// call to a function compiled without debug info
	Sum+=chain_3(x);

    return Sum;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\chain4.c ===
#include "chain1.h"
#include "chain4.h"

int Global;

#ifdef hasLOCALS
#define  DeclareLocals   int Sum;
#define  RESULT          Sum
#else
#define  DeclareLocals
#define  RESULT          Global
#endif

#ifdef hasPARAMS
#define  fooAdd          paramA+paramB
#else
#define  fooAdd          Global+3
#endif

#ifdef returnsVALUE
#define  ReturnStmt      return Global
#else
#define  ReturnStmt
#endif

fooReturn FUNCTYPE foo( fooParams )
{
   DeclareLocals;
   Global=3;
   RESULT = fooAdd;
   ReturnStmt;
};


///////////////////////////////////////////////////////////////////////////
int chain_4(int x)
{
    int Sum_4;
    Sum_4=x+1;
	x=chain_5(x)/2;
    return Sum_4;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\chainx1.h ===
int   chain_x1(int x);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\chainx2.h ===
int   chain_x2(int x);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\chainx2.c ===
// Intended to be compiled with partial debug info

#include "chainx2.h"
#include "chain4.h"
#include "chain2.h"

int chain_x2(int x)
{
    int Sum;
	// call to a function compiled with partial debug info
    Sum=x+chain_2(x);

	// call to a function compiled with full debug info
	Sum+=chain_4(x);

    return Sum;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\ChildFrm.cpp ===
// ChildFrm.cpp : implementation of the CChildFrame class
//

#include "stdafx.h"
#include "ecmfcapp.h"

#include "ChildFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChildFrame

IMPLEMENT_DYNCREATE(CChildFrame, CMDIChildWnd)

BEGIN_MESSAGE_MAP(CChildFrame, CMDIChildWnd)
	//{{AFX_MSG_MAP(CChildFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChildFrame construction/destruction

CChildFrame::CChildFrame()
{
	// TODO: add member initialization code here
	
}

CChildFrame::~CChildFrame()
{
}

BOOL CChildFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CMDIChildWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CChildFrame diagnostics

#ifdef _DEBUG
void CChildFrame::AssertValid() const
{
	CMDIChildWnd::AssertValid();
}

void CChildFrame::Dump(CDumpContext& dc) const
{
	CMDIChildWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CChildFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\ecconsol.c ===
#include "calls.h"

extern void dbg_main();
extern void Types_Tests(int);
extern int main_Calls();

#if !defined( SAVELABEL )
#define SAVELABEL( l )	if (0) goto l
#endif

int main()
{
	int iCalls, nLoop = 10;

	dbg_main();

	iCalls = main_Calls();

	Types_Tests(nLoop);

 	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\dbg_main.c ===
#include "dbg_main.h"
#include "chainx1.h"

extern int ChainMain();
extern int OtherMain();

#if !defined( SAVELABEL )
#define SAVELABEL( l )	if (0) goto l
#endif

void dbg_main (void)
{
	int x;
	static int y = -1;
	static double z;

	SAVELABEL(TagCallNoCVInfo);
	SAVELABEL(TagCallOtherMain);
	SAVELABEL(TagCallChainMain);

	TagCallChainMain:
	ChainMain();

	TagCallOtherMain: 
	OtherMain();

	TagCallNoCVInfo: 
	y = chain_x1(99);

	x = y;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\ecmfcapp.h ===
// ecmfcapp.h : main header file for the ECMFCAPP application
//

#if !defined(AFX_ECMFCAPP_H__49433FC5_FD1C_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_ECMFCAPP_H__49433FC5_FD1C_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CEcmfcappApp:
// See ecmfcapp.cpp for the implementation of this class
//

class CEcmfcappApp : public CWinApp
{
public:
	CEcmfcappApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEcmfcappApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CEcmfcappApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ECMFCAPP_H__49433FC5_FD1C_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\ecmfcapp.cpp ===
// ecmfcapp.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "ecmfcapp.h"

#include "MainFrm.h"
#include "ChildFrm.h"
#include "ecmfcappDoc.h"
#include "ecmfcappView.h"

EXTERN_C void dbg_main();
EXTERN_C int main_Calls();

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEcmfcappApp

BEGIN_MESSAGE_MAP(CEcmfcappApp, CWinApp)
	//{{AFX_MSG_MAP(CEcmfcappApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
	// Standard print setup command
	ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEcmfcappApp construction

CEcmfcappApp::CEcmfcappApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CEcmfcappApp object

CEcmfcappApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CEcmfcappApp initialization

BOOL CEcmfcappApp::InitInstance()
{
	AfxEnableControlContainer();

int iCalls;
dbg_main();
iCalls = main_Calls();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	// Change the registry key under which our settings are stored.
	// You should modify this string to be something appropriate
	// such as the name of your company or organization.
	SetRegistryKey(_T("Local AppWizard-Generated Applications"));

	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CMultiDocTemplate* pDocTemplate;
	pDocTemplate = new CMultiDocTemplate(
		IDR_ECMFCATYPE,
		RUNTIME_CLASS(CEcmfcappDoc),
		RUNTIME_CLASS(CChildFrame), // custom MDI child frame
		RUNTIME_CLASS(CEcmfcappView));
	AddDocTemplate(pDocTemplate);

	// create main MDI Frame window
	CMainFrame* pMainFrame = new CMainFrame;
	if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
		return FALSE;
	m_pMainWnd = pMainFrame;

	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
		return FALSE;

	// The main window has been initialized, so show and update it.
	pMainFrame->ShowWindow(m_nCmdShow);
	pMainFrame->UpdateWindow();

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CEcmfcappApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CEcmfcappApp commands
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\cxx.cxx ===
#include "cxx.h"
#include "include.cpp"

class base
{
private:
	int m_private;

protected:
	int m_protected;

public: 
	base(void) {m_private = 1; m_protected = 2;}
	virtual ~base(void){};

	int m_public;
	char *m_pchar;
	virtual void virtual_func(int i);
	virtual int m_func(void){return 0;}
	int overloaded_func(int i){return i;}

	virtual void virtual_func1() { int i = 5; };
	virtual int  virtual_func2() { return 10; };
	virtual int  virtual_func3(int ind) { return ind*2; };
};

class derived1 : public base
{
private:
	char ch;

public:
	derived1(void){ch = 'a';}
};

class derived2 : public derived1
{
private:
	float f;

public:
	derived2(void){f = 1.0f;}
};

class A_CLASS
{
public:
	virtual void func(unsigned char ch){}
	int i;
};


class derived : public base
{
private:
	int private_value;
	int id;
	static int ref_cnt;

public:
	derived(); // c-tor
	~derived();

	void virtual_func1() { int i = 7; };
	int  virtual_func2(int j) { return j; };

	static int static_func() {return 9;};
	void clear() { derived::private_value=0;};
	int getID() { return id;};
	int getCount() {return ref_cnt;};
	operator int() { return (int)private_value; };
	inline void inline_func() { private_value++; };

	virtual int m_func(void){return m_public;}
	char overloaded_func(char ch){return ch;}
};

int derived::ref_cnt=1;

derived::derived()
{              
    id=ref_cnt;
    ref_cnt++;
    private_value=-2*id;
};

derived::~derived()
{             
    ref_cnt--;
};


base func_class(void)
{
	base b;
	b.m_public = 1;
	return b;
}

base *func_pclass(void)
{
	base *pb = new base;
	pb->m_public = 1;
	return pb;
}

void base::virtual_func(int i)
{
	m_private = i+1;
	m_public = i;
}

int global = 0;
int result = 0;
int iGlobal;
int *piGlobal = &iGlobal;

int Test_func2 ( )
{
	base1 b1;
	base2 b2;
	derivedm drvm;

	int ib1 = b1.base1_overloaded_func(1);
	ib1 = b1.base1_overridden_func(1);
	ib1 = b1.base1_virtual_func(1);

	int ib2 = b2.base2_virtual_func(1);

	int iderived = drvm.derivedm_public_func(1+2);
	iderived = drvm.base1_virtual_func(1+2);
	iderived = drvm.base1_overloaded_func('C');
	iderived = drvm.base1_overridden_func(1+2);

	return 0;
};

int Test_func ( )
{
	base b = func_class();
	base *pb = func_pclass();
	base *pd = new derived;
	pd->m_public = 1;
	pd->m_func();
	pb->overloaded_func(1);
	pb->overloaded_func('a');

	derived drv1;

	drv1.virtual_func1();
	result = drv1.base::virtual_func2();
	result = drv1.virtual_func2(7);
	result = drv1.virtual_func3(9);

	result = drv1.getID();
	result = drv1.getCount();

	//CALL_CONVERSION:
	result = drv1;

	result = derived::static_func();
	drv1.clear();  // clear private value

	drv1.inline_func();
	result = drv1;

	base* object_base = new base();
	base* object1 = new derived1();
	base* object2 = new derived2();
	base* object = object1;
	
	object = object2; // assignment
	
	A_CLASS obj;
	obj.i = 1;
	obj.func('a');

	iGlobal = 0;
	*piGlobal = 1;
	int *pint = &iGlobal;
	b.virtual_func(0);

	base *pb2;
	base *pb1 = new base;
	pb2 = pb1;
	*pb1 = *pb1;

	pb->m_public = 0;
	pb->virtual_func(0);

	b.m_public = 1;
	b.virtual_func(1);

	::global = 1;

//	return 0;
	return Test_func2();
};

int base1::base1_func(int i)
{
	return base1_var + i;
}

int base1::base1_virtual_func(int i)
{
	return base1_var + i;
}

int base1::base1_overloaded_func(int i)
{
	return base1_var + i;
}

int base1::base1_overridden_func(int i)
{
	return base1_var + i;
}

// inherited, non-overloaded, non-overridden member function
int base2::base2_func(int i)
{
	return base2_var + i;
}

int base2::base2_virtual_func(int i)
{
	return base2_var + i;
}

int derivedm::derivedm_static_var = 1;

derivedm::derivedm(void)
{
	derivedm_public_var = base1_var + base2_var;
	enum_class_var = two_class;
	derivedm_private_var = derivedm_public_var + 1;
	derivedm_protected_var = derivedm_private_var + 1;
}

// non-inherited, non-overloaded member function.
int derivedm::derivedm_public_func(int i)
{
	return derivedm_public_var + derivedm_protected_func(i);
}

// virtual inherited non-overloaded, overridden member function
int derivedm::base1_virtual_func(int i)
{
	return derivedm_public_var + i;
}

/*
int derivedm::derivedm_static_func(int i)
{
	return derived_static_var + i;
}
*/

// inherited, overloaded, non-overridden member function
int derivedm::base1_overloaded_func(char ch)
{
	return derivedm_public_var + ch;
}

// inherited, non-overloaded, overridden member function
int derivedm::base1_overridden_func(int i)
{
	return derivedm_public_var + i;
}

// protected member function.
int derivedm::derivedm_protected_func(int i)
{
	return derivedm_public_var + derivedm_private_func(i);
}

// private member function.
int derivedm::derivedm_private_func(int i)
{
	return derivedm_public_var + i;
}


int Result=0;

extern "C"
{
	void Cxx_Tests();
}

void Cxx_Tests()
{
  //CALL_CONSTRUCTOR:
  fooclass foo1;

  //CALL_MEMBER_FUNC:
  Result=foo1.getID(); // getID
  Result=foo1.getCount();

  //CALL_CONVERSION:
  Result=foo1;

  //CALL_STATIC:
  Result=fooclass::static_func();
  foo1.clear();  // clear private value

  //CALL_INLINE:
  foo1.inline_func();
  Result=foo1;
  foo1.chain1_func();

  int test_include = Test_func();
};

void fooclass::chain1_func()
{					
      unsigned char local_cpp_func='A';
      private_value++;                // increment private value
	  int chain2_return = chain2_func();
      private_value--;                // decrement private value
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\dbg_main.h ===
void dbg_main (void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\ChildFrm.h ===
// ChildFrm.h : interface of the CChildFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_CHILDFRM_H__49433FCB_FD1C_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_CHILDFRM_H__49433FCB_FD1C_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CChildFrame : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CChildFrame)
public:
	CChildFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CChildFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CChildFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CChildFrame)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHILDFRM_H__49433FCB_FD1C_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\cxx.h ===
/*********************** FOOCLASS **********************/
class fooclass {
private:
  int private_value;
  int id;
  static int ref_cnt;

public:

  fooclass();
  ~fooclass();

  static int static_func() { return 9; };

  void clear() 
  {                       // Clear private value
     fooclass::private_value=0;
  };

  int getID() { return id; };

  int getCount() 
  {                    // return reference_cnt
      return ref_cnt;
  };

  operator int() 
  {                    // return private value
      return (int)private_value;      // conversion operator
  };

  inline void inline_func() 
  {         
      private_value++;                // increment private value
  };

  void chain1_func();				
  
  int chain2_func()
  {				
      return private_value + 2;
  };

};


/******************** define function for fooclass ************/
 int fooclass::ref_cnt=1;

  fooclass::fooclass() 
  {              // constructor for fooclass
    id=ref_cnt;
    ref_cnt++;
    private_value=-2*id;
  };

  fooclass::~fooclass() 
  {             // destructor for fooclass
    ref_cnt--;
  };


class base1
{
protected:
	// inherited member variable.
	int base1_var;
public:
	base1(void){base1_var = 1;}
	int base1_func(int i);
	virtual int base1_virtual_func(int i); // base1
	int base1_overloaded_func(int i); // base1
	int base1_overridden_func(int i); // base1
};

class base2
{
protected:
	int base2_var;
public:
	base2(void){base2_var = 2;}
	// inherited, non-overloaded, non-overridden member function
	int base2_func(int i);
	virtual int base2_virtual_func(int i);
};

class derivedm : public base1, public base2
{
private:
	int derivedm_private_var;
	int derivedm_private_func(int i);

protected:
	int derivedm_protected_var;
	int derivedm_protected_func(int i);

public:
	int derivedm_public_var;
	// class-nested enum.
	enum enum_class {one_class = 1, two_class, three_class};
	// declaration of class-nested enum var.
	enum_class enum_class_var;

	static int derivedm_static_var;
	//static int derivedm_static_func(int i);

	derivedm(void);
	// non-inherited, non-overloaded member function.
	int derivedm_public_func(int i);
	// virtual inherited non-overloaded, overridden member function
	virtual int base1_virtual_func(int i); // derivedm
	// inherited, overloaded, non-overridden member function
	int base1_overloaded_func(char ch); // derivedm
	// inherited, non-overloaded, overridden member function
	int base1_overridden_func(int i); // derivedm
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\foo.h ===
#define hasPARAMS
#define FUNCTYPE _stdcall
#define returnsVALUE


#ifdef hasPARAMS
#define  fooParams int paramA, int paramB
#else
#define  fooParams
#endif

#ifdef returnsVALUE
#define  fooReturn  int
#else
#define  fooReturn  void
#endif

fooReturn FUNCTYPE foo( fooParams );
fooReturn FUNCTYPE foo2( fooParams );
void BPWithLengthTest(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\ecmfcappDoc.cpp ===
// ecmfcappDoc.cpp : implementation of the CEcmfcappDoc class
//

#include "stdafx.h"
#include "ecmfcapp.h"

#include "ecmfcappDoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEcmfcappDoc

IMPLEMENT_DYNCREATE(CEcmfcappDoc, CDocument)

BEGIN_MESSAGE_MAP(CEcmfcappDoc, CDocument)
	//{{AFX_MSG_MAP(CEcmfcappDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEcmfcappDoc construction/destruction

CEcmfcappDoc::CEcmfcappDoc()
{
	// TODO: add one-time construction code here

}

CEcmfcappDoc::~CEcmfcappDoc()
{
}

BOOL CEcmfcappDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	// TODO: add reinitialization code here
	// (SDI documents will reuse this document)

	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CEcmfcappDoc serialization

void CEcmfcappDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}

/////////////////////////////////////////////////////////////////////////////
// CEcmfcappDoc diagnostics

#ifdef _DEBUG
void CEcmfcappDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CEcmfcappDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CEcmfcappDoc commands
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\ecmfcappView.cpp ===
// ecmfcappView.cpp : implementation of the CEcmfcappView class
//

#include "stdafx.h"
#include "ecmfcapp.h"

#include "ecmfcappDoc.h"
#include "ecmfcappView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEcmfcappView

IMPLEMENT_DYNCREATE(CEcmfcappView, CView)

BEGIN_MESSAGE_MAP(CEcmfcappView, CView)
	//{{AFX_MSG_MAP(CEcmfcappView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard printing commands
	ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_DIRECT, CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, CView::OnFilePrintPreview)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEcmfcappView construction/destruction

CEcmfcappView::CEcmfcappView()
{
	// TODO: add construction code here

}

CEcmfcappView::~CEcmfcappView()
{
}

BOOL CEcmfcappView::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CEcmfcappView drawing

void CEcmfcappView::OnDraw(CDC* pDC)
{
	CEcmfcappDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	// TODO: add draw code for native data here
}

/////////////////////////////////////////////////////////////////////////////
// CEcmfcappView printing

BOOL CEcmfcappView::OnPreparePrinting(CPrintInfo* pInfo)
{
	// default preparation
	return DoPreparePrinting(pInfo);
}

void CEcmfcappView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add extra initialization before printing
}

void CEcmfcappView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add cleanup after printing
}

/////////////////////////////////////////////////////////////////////////////
// CEcmfcappView diagnostics

#ifdef _DEBUG
void CEcmfcappView::AssertValid() const
{
	CView::AssertValid();
}

void CEcmfcappView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}

CEcmfcappDoc* CEcmfcappView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CEcmfcappDoc)));
	return (CEcmfcappDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CEcmfcappView message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\ecmfcappView.h ===
// ecmfcappView.h : interface of the CEcmfcappView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_ECMFCAPPVIEW_H__49433FCF_FD1C_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_ECMFCAPPVIEW_H__49433FCF_FD1C_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CEcmfcappView : public CView
{
protected: // create from serialization only
	CEcmfcappView();
	DECLARE_DYNCREATE(CEcmfcappView)

// Attributes
public:
	CEcmfcappDoc* GetDocument();

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEcmfcappView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CEcmfcappView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CEcmfcappView)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in ecmfcappView.cpp
inline CEcmfcappDoc* CEcmfcappView::GetDocument()
   { return (CEcmfcappDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ECMFCAPPVIEW_H__49433FCF_FD1C_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\ecmfcappDoc.h ===
// ecmfcappDoc.h : interface of the CEcmfcappDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_ECMFCAPPDOC_H__49433FCD_FD1C_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_ECMFCAPPDOC_H__49433FCD_FD1C_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


class CEcmfcappDoc : public CDocument
{
protected: // create from serialization only
	CEcmfcappDoc();
	DECLARE_DYNCREATE(CEcmfcappDoc)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEcmfcappDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CEcmfcappDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CEcmfcappDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ECMFCAPPDOC_H__49433FCD_FD1C_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\foo.c ===
#include <string.h>
#include "foo.h"
#include "chain4.h"

#ifdef hasLOCALS
#define  DeclareLocals   int Sum;
#define  RESULT          Sum
#else
#define  DeclareLocals
#define  RESULT          Global
#endif

#ifdef hasPARAMS
#define  fooAdd          paramA+paramB
#define  fooArgs  param1, param2
#else
#define  fooAdd          Global+3
#define  fooArgs
#endif

#ifdef returnsVALUE
#define  ReturnStmt      return Global
#define  fooRet  Result=
#else
#define  ReturnStmt
#define  fooRet
#endif

#define FOO  fooRet foo(fooArgs);

void Cxx_Tests();

int param1=1;
int param2=2;
int index=0;

extern int Global; // =0;
extern int Result; // =0;
extern char * String; // =" Some sample string";

int gi[5] = {0, 0, 0, 0, 0};

fooReturn	FUNCTYPE foo2(fooParams)
{
   Global=3;
   Global = fooAdd;
   ReturnStmt;
};

int OtherMain()
{
	int local, i;

	local=255;

	FOO;

	BPWithLengthTest();

	for(i=0; i<9; i++)
	{
		Cxx_Tests();
	}

	(void)foo2(7, 1);

	// CALL_RUNTIME:;
	Result=strlen(String);

	return 1;
}


void BPWithLengthTest(void)
{
	gi[4]=99;
	gi[2]=99;  // breakpoint should fire and stop 
	//BREAK:     // at the next line of code tagged with the BREAK label
	gi[2]=0; gi[3]=99;  
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\f_asm.cpp ===
#include "typetest.h"

extern const char     GCc;
extern const uchar   GCuc;
extern const short    GCs;
extern const ushort  GCus;
extern const long     GCl;
extern const ulong   GCul;
extern const float    GCf;
extern const double   GCd;
extern const ldouble GCld;
extern const int	  GCi;
extern const uint	  GCui;
extern const __int64 GCi64;

extern ushort GShortNearArray[NEARSIZE];

extern char		Gc;
extern uchar   Guc;
extern short	Gs;
extern ushort  Gus;
extern long		Gl;
extern ulong   Gul;
extern float	Gf;
extern double	Gd;
extern ldouble Gld;
extern short PassTest;
extern int		Gi;
extern uint		Gui;
extern __int64	Gi64;

extern struct Gstruct
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst;

extern union Gunion
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun;



void _cdecl CFncAsm(void)
{
    ushort us = 0;

    _asm
	{
	    push ax
	    push bx
	    push cx
	    mov ax, 0xFFFF
	    mov bx, 0x0000
	    mov cx, 0xAAAA
	    mov us, 0xFFFF
	    int 3
	    pop cx
	    pop bx
	    pop ax
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\ecwinapp.cpp ===
#include <windows.h>

#define IDM_EXIT  100

EXTERN_C void dbg_main();
EXTERN_C void Types_Tests(int);
EXTERN_C int main_Calls();

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM);
int MyPostMessage( HWND hwnd );

#if !defined( SAVELABEL )
#define SAVELABEL( l )	if (0) goto l
#endif

char szGExeBuffer[128];

int PASCAL WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                         LPSTR lpszCmdLine, int nCmdShow)
{

     static char szAppName[] = "ecwinapp" ;
     HWND        hwnd ;
     MSG         msg ;
     WNDCLASS    wndclass ;

     if (!hPrevInstance)
          {
          wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
          wndclass.lpfnWndProc   = (WNDPROC) WndProc ;
          wndclass.cbClsExtra    = 0 ;
          wndclass.cbWndExtra    = 0 ;
          wndclass.hInstance     = hInstance ;
          wndclass.hIcon         = LoadIcon(NULL, IDI_APPLICATION); 
          wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW);
          wndclass.hbrBackground = GetStockObject (WHITE_BRUSH);
          wndclass.lpszMenuName  = szAppName ;  // MAC?
          wndclass.lpszClassName = szAppName ;

          RegisterClass (&wndclass) ;
          }

     hwnd = CreateWindowEx(
#if defined( _MAC )
					WS_EX_FORCESIZEBOX,
#else
					0,
#endif
     				szAppName,         // window class name
                    szAppName, 				// window caption
                    WS_OVERLAPPEDWINDOW,     // window style
                    CW_USEDEFAULT,           // initial x position
                    0, // CW_USEDEFAULT,           // initial y position
                    CW_USEDEFAULT,           // initial x size
                    0, // CW_USEDEFAULT,           // initial y size
                    NULL,                    // parent window handle
                    NULL,                    // window menu handle
                    hInstance,               // program instance handle
                    NULL) ;                  // creation parameters
     if (hwnd==0) {   //window not created
         return 1;
     }

     ShowWindow (hwnd, nCmdShow) ;
     UpdateWindow (hwnd) ;
//     PostMessage( hwnd, WM_NULL, (WORD)0, (DWORD)0);

     while (GetMessage (&msg, NULL, 0, 0))
          {
          TranslateMessage (&msg) ;
          DispatchMessage (&msg) ;
          }
     return msg.wParam ;
     }


LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
     {
     HDC         hdc ;
     PAINTSTRUCT ps ;
     RECT        rect ;
     static HINSTANCE hInst;
     static FARPROC pCB;
     int x;
	 static int y = -1;
     int iCalls, nLoop = 10;

	 SAVELABEL(TagCalldbg_main);
	 SAVELABEL(TagCallmain_Calls);
	 SAVELABEL(TagCallTypes_Tests);
	 SAVELABEL(TagCreateCase);

     switch (message)
          {
          case WM_CREATE:
TagCreateCase: hInst= ((LPCREATESTRUCT) lParam)->hInstance;

               ////////////// MAKE TESTING CALLS HERE  /////////


TagCalldbg_main:	dbg_main();

TagCallmain_Calls:	iCalls = main_Calls();

TagCallTypes_Tests:	Types_Tests(nLoop);

               x = 0;
               return 0 ;

          case WM_PAINT:
               hdc = BeginPaint (hwnd, &ps) ;
               GetClientRect (hwnd, &rect) ;
               DrawText (hdc, "Hello, Windows!", -1, &rect,
                          DT_SINGLELINE | DT_CENTER | DT_VCENTER) ;
               EndPaint (hwnd, &ps) ;
               return 0 ;

#if defined( _MAC )
          case WM_SYSCOMMAND:
#endif
          case WM_COMMAND:        /* message: command from application menu */
               switch( wParam )
                  {
                  case IDM_EXIT:
                       DestroyWindow(hwnd);
                       break;
                  }
               break;

          case WM_DESTROY:
               PostQuitMessage (0) ;
               return 0 ;
#if !defined( _MAC )
           case WM_NULL:
               MyPostMessage(hwnd);
               return 0 ;
#endif
          }

     return DefWindowProc (hwnd, message, wParam, lParam) ;
}


int MyPostMessage( HWND hwnd )
{
    static int count = 0;

#if !defined( _MAC )
	SAVELABEL(TagPost);
					 
    if ( count < 5 )
    {
TagPost: PostMessage( hwnd, WM_PAINT, (WORD)0, (DWORD)0);
         PostMessage( hwnd, 0x0040, (WORD)0, (DWORD)0);
    }
    return count++;
#endif 

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\f_long.cpp ===
#include "typetest.h"

extern const char     GCc;
extern const uchar   GCuc;
extern const short    GCs;
extern const ushort  GCus;
extern const long     GCl;
extern const ulong   GCul;
extern const float    GCf;
extern const double   GCd;
extern const ldouble GCld;
extern const int	  GCi;
extern const uint	  GCui;
extern const __int64 GCi64;

extern ushort GShortNearArray[NEARSIZE];

extern char	Gc;
extern uchar   Guc;
extern short	Gs;
extern ushort  Gus;
extern long	Gl;
extern ulong   Gul;
extern float	Gf;
extern double	Gd;
extern ldouble Gld;
extern short PassTest;
extern int	  Gi;
extern uint	  Gui;
extern __int64 Gi64;

extern struct Gstruct
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst;

extern union Gunion
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun;

long	_cdecl CFncLL(long PSl)
{
    int counter;

    const char	   Cc = (char)1;
    const uchar   Cuc = (uchar)1;
    const short    Cs = (short)1;
    const ushort  Cus = (ushort)1;
    const long	   Cl = (long)1;
    const ulong   Cul = (ulong)1;
    const float    Cf = (float)1;
    const double   Cd = (double)1;
    const ldouble Cld = (ldouble)1;
	const int		Ci = (int)1;
	const uint		Cui = (uint)1;
	const __int64	Ci64 = (__int64)1;
 
    char     c, c10[10];
    uchar   uc, uc10[10];
    short    s, s10[10];
    ushort  us, us10[10];
    long     l, l10[10];
    ulong   ul, ul10[10];
    float    f, f10[10];
    double   d, d10[10];
    ldouble ld, ld10[10];
	int		i,	i10[10];
	uint	ui,	ui10[10];
	__int64	i64,	i6410[10];

    struct st
    {
	short	s;
	uchar	uc10[10];
    }st, *pst = &st;
    union un
    {
	short	s2[2];
	ulong	 ul;
    }un, *pun = &un;

    for( counter = 0; counter < 10; counter++)
    {
		Gc  = (char)counter;
		Guc = (uchar)counter;
		Gs  = (short)counter;
		Gus = (ushort)counter;
		Gl  = (long)counter;
		Gul = (ulong)counter;
		Gf  = (float)counter;
		Gd  = (double)counter;
		Gld = (ldouble)counter;
	    Gi = (int)counter;
		Gui = (uint)counter;
	    Gi64 = (__int64)counter;

		Gst.Gs = (short)counter;
		Gun.Gs2[0] = (short)counter;
		Gun.Gs2[1] = 9 - (short)counter;
		
		c  = (char)counter;
		uc = (uchar)counter;
		s  = (short)counter;
		us = (ushort)counter;
		l  = (long)counter;
		ul = (ulong)counter;
		f  = (float)counter;
		d  = (double)counter;
		ld = (ldouble)counter;
	    i = (int)counter;
		ui = (uint)counter;
	    i64 = (__int64)counter;

		st.s = (short)counter;
		un.s2[0] = (short)counter;
		un.s2[1] = 9 - (short)counter;

		c10[counter]  = (char)counter;
		uc10[counter] = (uchar)counter;
		s10[counter]  = (short)counter;
		us10[counter] = (ushort)counter;
		l10[counter]  = (long)counter;
		ul10[counter] = (ulong)counter;
		f10[counter]  = (float)counter;
		d10[counter]  = (double)counter;
		ld10[counter] = (ldouble)counter;
		i10[counter] = (int)counter;
		ui10[counter] = (uint)counter;
		i6410[counter] = (__int64)counter;

		pst->uc10[counter] = (uchar)counter;
		pun->ul = (ulong)counter;
		PSl = (long)counter;
    }
    return PSl;
}

ulong	_cdecl CFncULUL(ulong PSul)
{
    int counter;

    const char	   Cc = (char)1;
    const uchar   Cuc = (uchar)1;
    const short    Cs = (short)1;
    const ushort  Cus = (ushort)1;
    const long	   Cl = (long)1;
    const ulong   Cul = (ulong)1;
    const float    Cf = (float)1;
    const double   Cd = (double)1;
    const ldouble Cld = (ldouble)1;
	const int		Ci = (int)1;
	const uint		Cui = (uint)1;
	const __int64	Ci64 = (__int64)1;

    char     c, c10[10];
    uchar   uc, uc10[10];
    short    s, s10[10];
    ushort  us, us10[10];
    long     l, l10[10];
    ulong   ul, ul10[10];
    float    f, f10[10];
    double   d, d10[10];
    ldouble ld, ld10[10];
	int		i,	i10[10];
	uint	ui,	ui10[10];
	__int64	i64,	i6410[10];

    struct st
    {
	short	s;
	uchar	uc10[10];
    }st, *pst = &st;
    union un
    {
	short	s2[2];
	ulong	 ul;
    }un, *pun = &un;

    for( counter = 0; counter < 10; counter++)
    {
		Gc  = (char)counter;
		Guc = (uchar)counter;
		Gs  = (short)counter;
		Gus = (ushort)counter;
		Gl  = (long)counter;
		Gul = (ulong)counter;
		Gf  = (float)counter;
		Gd  = (double)counter;
		Gld = (ldouble)counter;
	    Gi = (int)counter;
		Gui = (uint)counter;
	    Gi64 = (__int64)counter;
	
		Gst.Gs = (short)counter;
		Gun.Gs2[0] = (short)counter;
		Gun.Gs2[1] = 9 - (short)counter;
		
		c  = (char)counter;
		uc = (uchar)counter;
		s  = (short)counter;
		us = (ushort)counter;
		l  = (long)counter;
		ul = (ulong)counter;
		f  = (float)counter;
		d  = (double)counter;
		ld = (ldouble)counter;
	    i = (int)counter;
		ui = (uint)counter;
	    i64 = (__int64)counter;

		st.s = (short)counter;
		un.s2[0] = (short)counter;
		un.s2[1] = 9 - (short)counter;

		c10[counter]  = (char)counter;
		uc10[counter] = (uchar)counter;
		s10[counter]  = (short)counter;
		us10[counter] = (ushort)counter;
		l10[counter]  = (long)counter;
		ul10[counter] = (ulong)counter;
		f10[counter]  = (float)counter;
		d10[counter]  = (double)counter;
		ld10[counter] = (ldouble)counter;
		i10[counter] = (int)counter;
		ui10[counter] = (uint)counter;
		i6410[counter] = (__int64)counter;

		pst->uc10[counter] = (uchar)counter;
		pun->ul = (ulong)counter;
		PSul = (ulong)counter;
    }
    return PSul;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\f_float.cpp ===
#include "typetest.h"

extern const char     GCc;
extern const uchar   GCuc;
extern const short    GCs;
extern const ushort  GCus;
extern const long     GCl;
extern const ulong   GCul;
extern const float    GCf;
extern const double   GCd;
extern const ldouble GCld;
extern const int	  GCi;
extern const uint	  GCui;
extern const __int64 GCi64;

extern ushort GShortNearArray[NEARSIZE];

extern char	Gc;
extern uchar   Guc;
extern short	Gs;
extern ushort  Gus;
extern long	Gl;
extern ulong   Gul;
extern float	Gf;
extern double	Gd;
extern ldouble Gld;
extern short PassTest;
extern int	  Gi;
extern uint	  Gui;
extern __int64 Gi64;

extern struct Gstruct
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst;

extern union Gunion
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun;


float	_cdecl CFncFF(float PSf)
{
    int counter;

    const char	   Cc = (char)1;
    const uchar   Cuc = (uchar)1;
    const short    Cs = (short)1;
    const ushort  Cus = (ushort)1;
    const long	   Cl = (long)1;
    const ulong   Cul = (ulong)1;
    const float    Cf = (float)1;
    const double   Cd = (double)1;
    const ldouble Cld = (ldouble)1;
	const int		Ci = (int)1;
	const uint		Cui = (uint)1;
	const __int64	Ci64 = (__int64)1;
 
    char     c, c10[10];
    uchar   uc, uc10[10];
    short    s, s10[10];
    ushort  us, us10[10];
    long     l, l10[10];
    ulong   ul, ul10[10];
    float    f, f10[10];
    double   d, d10[10];
    ldouble ld, ld10[10];
	int		i,	i10[10];
	uint	ui,	ui10[10];
	__int64	i64,	i6410[10];

    struct st
    {
	short	s;
	uchar	uc10[10];
    }st, *pst = &st;
    union un
    {
	short	s2[2];
	ulong	 ul;
    }un, *pun = &un;

    for( counter = 0; counter < 10; counter++)
    {
		Gc  = (char)counter;
		Guc = (uchar)counter;
		Gs  = (short)counter;
		Gus = (ushort)counter;
		Gl  = (long)counter;
		Gul = (ulong)counter;
		Gf  = (float)counter;
		Gd  = (double)counter;
		Gld = (ldouble)counter;
	    Gi = (int)counter;
		Gui = (uint)counter;
	    Gi64 = (__int64)counter;

		Gst.Gs = (short)counter;
		Gun.Gs2[0] = (short)counter;
		Gun.Gs2[1] = 9 - (short)counter;
		
		c  = (char)counter;
		uc = (uchar)counter;
		s  = (short)counter;
		us = (ushort)counter;
		l  = (long)counter;
		ul = (ulong)counter;
		f  = (float)counter;
		d  = (double)counter;
		ld = (ldouble)counter;
	    i = (int)counter;
		ui = (uint)counter;
	    i64 = (__int64)counter;

		st.s = (short)counter;
		un.s2[0] = (short)counter;
		un.s2[1] = 9 - (short)counter;

		c10[counter]  = (char)counter;
		uc10[counter] = (uchar)counter;
		s10[counter]  = (short)counter;
		us10[counter] = (ushort)counter;
		l10[counter]  = (long)counter;
		ul10[counter] = (ulong)counter;
		f10[counter]  = (float)counter;
		d10[counter]  = (double)counter;
		ld10[counter] = (ldouble)counter;
		i10[counter] = (int)counter;
		ui10[counter] = (uint)counter;
		i6410[counter] = (__int64)counter;

		pst->uc10[counter] = (uchar)counter;
		pun->ul = (ulong)counter;
		PSf = (float)counter;
    }
    return PSf;
}


double	_cdecl CFncDD(double PSd)
{
    int counter;

    const char	   Cc = (char)1;
    const uchar   Cuc = (uchar)1;
    const short    Cs = (short)1;
    const ushort  Cus = (ushort)1;
    const long	   Cl = (long)1;
    const ulong   Cul = (ulong)1;
    const float    Cf = (float)1;
    const double   Cd = (double)1;
    const ldouble Cld = (ldouble)1;
	const int		Ci = (int)1;
	const uint		Cui = (uint)1;
	const __int64	Ci64 = (__int64)1;
 
    char     c, c10[10];
    uchar   uc, uc10[10];
    short    s, s10[10];
    ushort  us, us10[10];
    long     l, l10[10];
    ulong   ul, ul10[10];
    float    f, f10[10];
    double   d, d10[10];
    ldouble ld, ld10[10];
	int		i,	i10[10];
	uint	ui,	ui10[10];
	__int64	i64,	i6410[10];

    struct st
    {
	short	s;
	uchar	uc10[10];
    }st, *pst = &st;
    union un
    {
	short	s2[2];
	ulong	 ul;
    }un, *pun = &un;

    for( counter = 0; counter < 10; counter++)
    {
		Gc  = (char)counter;
		Guc = (uchar)counter;
		Gs  = (short)counter;
		Gus = (ushort)counter;
		Gl  = (long)counter;
		Gul = (ulong)counter;
		Gf  = (float)counter;
		Gd  = (double)counter;
		Gld = (ldouble)counter;
	    Gi = (int)counter;
		Gui = (uint)counter;
	    Gi64 = (__int64)counter;

		Gst.Gs = (short)counter;
		Gun.Gs2[0] = (short)counter;
		Gun.Gs2[1] = 9 - (short)counter;
		
		c  = (char)counter;
		uc = (uchar)counter;
		s  = (short)counter;
		us = (ushort)counter;
		l  = (long)counter;
		ul = (ulong)counter;
		f  = (float)counter;
		d  = (double)counter;
		ld = (ldouble)counter;
	    i = (int)counter;
		ui = (uint)counter;
	    i64 = (__int64)counter;

		st.s = (short)counter;
		un.s2[0] = (short)counter;
		un.s2[1] = 9 - (short)counter;

		c10[counter]  = (char)counter;
		uc10[counter] = (uchar)counter;
		s10[counter]  = (short)counter;
		us10[counter] = (ushort)counter;
		l10[counter]  = (long)counter;
		ul10[counter] = (ulong)counter;
		f10[counter]  = (float)counter;
		d10[counter]  = (double)counter;
		ld10[counter] = (ldouble)counter;
		i10[counter] = (int)counter;
		ui10[counter] = (uint)counter;
		i6410[counter] = (__int64)counter;

		pst->uc10[counter] = (uchar)counter;
		pun->ul = (ulong)counter;
		PSd = (double)counter;
    }
    return PSd;
}


ldouble _cdecl CFncLDLD(ldouble PSld)
{
    int counter;

    const char	   Cc = (char)1;
    const uchar   Cuc = (uchar)1;
    const short    Cs = (short)1;
    const ushort  Cus = (ushort)1;
    const long	   Cl = (long)1;
    const ulong   Cul = (ulong)1;
    const float    Cf = (float)1;
    const double   Cd = (double)1;
    const ldouble Cld = (ldouble)1;
	const int		Ci = (int)1;
	const uint		Cui = (uint)1;
	const __int64	Ci64 = (__int64)1;
 
    char     c, c10[10];
    uchar   uc, uc10[10];
    short    s, s10[10];
    ushort  us, us10[10];
    long     l, l10[10];
    ulong   ul, ul10[10];
    float    f, f10[10];
    double   d, d10[10];
    ldouble ld, ld10[10];
	int		i,	i10[10];
	uint	ui,	ui10[10];
	__int64	i64,	i6410[10];

    struct st
    {
	short	s;
	uchar	uc10[10];
    }st, *pst = &st;
    union un
    {
	short	s2[2];
	ulong	 ul;
    }un, *pun = &un;

    for( counter = 0; counter < 10; counter++)
    {
		Gc  = (char)counter;
		Guc = (uchar)counter;
		Gs  = (short)counter;
		Gus = (ushort)counter;
		Gl  = (long)counter;
		Gul = (ulong)counter;
		Gf  = (float)counter;
		Gd  = (double)counter;
		Gld = (ldouble)counter;
	    Gi = (int)counter;
		Gui = (uint)counter;
	    Gi64 = (__int64)counter;

		Gst.Gs = (short)counter;
		Gun.Gs2[0] = (short)counter;
		Gun.Gs2[1] = 9 - (short)counter;
		
		c  = (char)counter;
		uc = (uchar)counter;
		s  = (short)counter;
		us = (ushort)counter;
		l  = (long)counter;
		ul = (ulong)counter;
		f  = (float)counter;
		d  = (double)counter;
		ld = (ldouble)counter;
	    i = (int)counter;
		ui = (uint)counter;
	    i64 = (__int64)counter;

		st.s = (short)counter;
		un.s2[0] = (short)counter;
		un.s2[1] = 9 - (short)counter;

		c10[counter]  = (char)counter;
		uc10[counter] = (uchar)counter;
		s10[counter]  = (short)counter;
		us10[counter] = (ushort)counter;
		l10[counter]  = (long)counter;
		ul10[counter] = (ulong)counter;
		f10[counter]  = (float)counter;
		d10[counter]  = (double)counter;
		ld10[counter] = (ldouble)counter;
		i10[counter] = (int)counter;
		ui10[counter] = (uint)counter;
		i6410[counter] = (__int64)counter;

		pst->uc10[counter] = (uchar)counter;
		pun->ul = (ulong)counter;
		PSld = (ldouble)counter;
    }
    return PSld;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\f_short.cpp ===
#include "typetest.h"

extern const char     GCc;
extern const uchar   GCuc;
extern const short    GCs;
extern const ushort  GCus;
extern const long     GCl;
extern const ulong   GCul;
extern const float    GCf;
extern const double   GCd;
extern const ldouble GCld;
extern const int	  GCi;
extern const uint	  GCui;
extern const __int64 GCi64;

extern ushort GShortNearArray[NEARSIZE];

extern char	Gc;
extern uchar   Guc;
extern short	Gs;
extern ushort  Gus;
extern long	Gl;
extern ulong   Gul;
extern float	Gf;
extern double	Gd;
extern ldouble Gld;
extern short PassTest;
extern int	  Gi;
extern uint	  Gui;
extern __int64 Gi64;

extern struct Gstruct
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst;

extern union Gunion
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun;



short	_cdecl CFncSS(short PSs)
{
    int counter;

    const char	   Cc = (char)1;
    const uchar   Cuc = (uchar)1;
    const short    Cs = (short)1;
    const ushort  Cus = (ushort)1;
    const long	   Cl = (long)1;
    const ulong   Cul = (ulong)1;
    const float    Cf = (float)1;
    const double   Cd = (double)1;
    const ldouble Cld = (ldouble)1;
	const int		Ci = (int)1;
	const uint		Cui = (uint)1;
	const __int64	Ci64 = (__int64)1;
 
    char     c, c10[10];
    uchar   uc, uc10[10];
    short    s, s10[10];
    ushort  us, us10[10];
    long     l, l10[10];
    ulong   ul, ul10[10];
    float    f, f10[10];
    double   d, d10[10];
    ldouble ld, ld10[10];
	int		i,	i10[10];
	uint	ui,	ui10[10];
	__int64	i64,	i6410[10];

    struct st
    {
	short	s;
	uchar	uc10[10];
    }st, *pst = &st;
    union un
    {
	short	s2[2];
	ulong	 ul;
    }un, *pun = &un;

    for( counter = 0; counter < 10; counter++)
    {
		Gc  = (char)counter;
		Guc = (uchar)counter;
		Gs  = (short)counter;
		Gus = (ushort)counter;
		Gl  = (long)counter;
		Gul = (ulong)counter;
		Gf  = (float)counter;
		Gd  = (double)counter;
		Gld = (ldouble)counter;
	    Gi = (int)counter;
		Gui = (uint)counter;
	    Gi64 = (__int64)counter;

		Gst.Gs = (short)counter;
		Gun.Gs2[0] = (short)counter;
		Gun.Gs2[1] = 9 - (short)counter;
		
		c  = (char)counter;
		uc = (uchar)counter;
		s  = (short)counter;
		us = (ushort)counter;
		l  = (long)counter;
		ul = (ulong)counter;
		f  = (float)counter;
		d  = (double)counter;
		ld = (ldouble)counter;
	    i = (int)counter;
		ui = (uint)counter;
	    i64 = (__int64)counter;

		st.s = (short)counter;
		un.s2[0] = (short)counter;
		un.s2[1] = 9 - (short)counter;

		c10[counter]  = (char)counter;
		uc10[counter] = (uchar)counter;
		s10[counter]  = (short)counter;
		us10[counter] = (ushort)counter;
		l10[counter]  = (long)counter;
		ul10[counter] = (ulong)counter;
		f10[counter]  = (float)counter;
		d10[counter]  = (double)counter;
		ld10[counter] = (ldouble)counter;
		i10[counter] = (int)counter;
		ui10[counter] = (uint)counter;
		i6410[counter] = (__int64)counter;

		pst->uc10[counter] = (uchar)counter;
		pun->ul = (ulong)counter;
		PSs = (short)counter;
    }
    return PSs;
}

ushort	_cdecl CFncUSUS(ushort PSus)
{
    int counter;

    const char	   Cc = (char)1;
    const uchar   Cuc = (uchar)1;
    const short    Cs = (short)1;
    const ushort  Cus = (ushort)1;
    const long	   Cl = (long)1;
    const ulong   Cul = (ulong)1;
    const float    Cf = (float)1;
    const double   Cd = (double)1;
    const ldouble Cld = (ldouble)1;
	const int		Ci = (int)1;
	const uint		Cui = (uint)1;
	const __int64	Ci64 = (__int64)1;

    char     c, c10[10];
    uchar   uc, uc10[10];
    short    s, s10[10];
    ushort  us, us10[10];
    long     l, l10[10];
    ulong   ul, ul10[10];
    float    f, f10[10];
    double   d, d10[10];
    ldouble ld, ld10[10];
	int		i,	i10[10];
	uint	ui,	ui10[10];
	__int64	i64,	i6410[10];

    struct st
    {
	short	s;
	uchar	uc10[10];
    }st, *pst = &st;
    union un
    {
	short	s2[2];
	ulong	 ul;
    }un, *pun = &un;

    for( counter = 0; counter < 10; counter++)
    {
		Gc  = (char)counter;
		Guc = (uchar)counter;
		Gs  = (short)counter;
		Gus = (ushort)counter;
		Gl  = (long)counter;
		Gul = (ulong)counter;
		Gf  = (float)counter;
		Gd  = (double)counter;
		Gld = (ldouble)counter;
	    Gi = (int)counter;
		Gui = (uint)counter;
	    Gi64 = (__int64)counter;
	
		Gst.Gs = (short)counter;
		Gun.Gs2[0] = (short)counter;
		Gun.Gs2[1] = 9 - (short)counter;
		
		c  = (char)counter;
		uc = (uchar)counter;
		s  = (short)counter;
		us = (ushort)counter;
		l  = (long)counter;
		ul = (ulong)counter;
		f  = (float)counter;
		d  = (double)counter;
		ld = (ldouble)counter;
	    i = (int)counter;
		ui = (uint)counter;
	    i64 = (__int64)counter;

		st.s = (short)counter;
		un.s2[0] = (short)counter;
		un.s2[1] = 9 - (short)counter;

		c10[counter]  = (char)counter;
		uc10[counter] = (uchar)counter;
		s10[counter]  = (short)counter;
		us10[counter] = (ushort)counter;
		l10[counter]  = (long)counter;
		ul10[counter] = (ulong)counter;
		f10[counter]  = (float)counter;
		d10[counter]  = (double)counter;
		ld10[counter] = (ldouble)counter;
		i10[counter] = (int)counter;
		ui10[counter] = (uint)counter;
		i6410[counter] = (__int64)counter;

		pst->uc10[counter] = (uchar)counter;
		pun->ul = (ulong)counter;
		PSus = (short)counter;
    }
    return PSus;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\f_char.cpp ===
#include "typetest.h"

extern const char     GCc;
extern const uchar   GCuc;
extern const short    GCs;
extern const ushort  GCus;
extern const long     GCl;
extern const ulong   GCul;
extern const float    GCf;
extern const double   GCd;
extern const ldouble GCld;
extern const int	  GCi;
extern const uint	  GCui;
extern const __int64 GCi64;

extern ushort GShortNearArray[NEARSIZE];

extern char	Gc;
extern uchar   Guc;
extern short	Gs;
extern ushort  Gus;
extern long	Gl;
extern ulong   Gul;
extern float	Gf;
extern double	Gd;
extern ldouble Gld;
extern short PassTest;
extern int	  Gi;
extern uint	  Gui;
extern __int64 Gi64;

extern struct Gstruct
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst;

extern union Gunion
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun;



char	_cdecl CFncCC (char PSc)
{
    int counter;

    const char	   Cc = (char)1;
    const uchar   Cuc = (uchar)1;
    const short    Cs = (short)1;
    const ushort  Cus = (ushort)1;
    const long	   Cl = (long)1;
    const ulong   Cul = (ulong)1;
    const float    Cf = (float)1;
    const double   Cd = (double)1;
    const ldouble Cld = (ldouble)1;
	const int		Ci = (int)1;
	const uint		Cui = (uint)1;
	const __int64	Ci64 = (__int64)1;
 
    char     c, c10[10];
    uchar   uc, uc10[10];
    short    s, s10[10];
    ushort  us, us10[10];
    long     l, l10[10];
    ulong   ul, ul10[10];
    float    f, f10[10];
    double   d, d10[10];
    ldouble ld, ld10[10];
	int		i,	i10[10];
	uint	ui,	ui10[10];
	__int64	i64,	i6410[10];

    struct st
    {
	short	s;
	uchar	uc10[10];
    }st, *pst = &st;
    union un
    {
	short	s2[2];
	ulong	 ul;
    }un, *pun = &un;

    for( counter = 0; counter < 10; counter++)
    {
		Gc  = (char)counter;
		Guc = (uchar)counter;
		Gs  = (short)counter;
		Gus = (ushort)counter;
		Gl  = (long)counter;
		Gul = (ulong)counter;
		Gf  = (float)counter;
		Gd  = (double)counter;
		Gld = (ldouble)counter;
	    Gi = (int)counter;
		Gui = (uint)counter;
	    Gi64 = (__int64)counter;

		Gst.Gs = (short)counter;
		Gun.Gs2[0] = (short)counter;
		Gun.Gs2[1] = 9 - (short)counter;
		
		c  = (char)counter;
		uc = (uchar)counter;
		s  = (short)counter;
		us = (ushort)counter;
		l  = (long)counter;
		ul = (ulong)counter;
		f  = (float)counter;
		d  = (double)counter;
		ld = (ldouble)counter;
	    i = (int)counter;
		ui = (uint)counter;
	    i64 = (__int64)counter;

		st.s = (short)counter;
		un.s2[0] = (short)counter;
		un.s2[1] = 9 - (short)counter;

		c10[counter]  = (char)counter;
		uc10[counter] = (uchar)counter;
		s10[counter]  = (short)counter;
		us10[counter] = (ushort)counter;
		l10[counter]  = (long)counter;
		ul10[counter] = (ulong)counter;
		f10[counter]  = (float)counter;
		d10[counter]  = (double)counter;
		ld10[counter] = (ldouble)counter;
		i10[counter] = (int)counter;
		ui10[counter] = (uint)counter;
		i6410[counter] = (__int64)counter;

		pst->uc10[counter] = (uchar)counter;
		pun->ul = (ulong)counter;
		PSc = (char)counter;
    }
    return PSc;
}

uchar	_cdecl CFncUCUC(uchar PSuc)
{
    int counter;

    const char	   Cc = (char)1;
    const uchar   Cuc = (uchar)1;
    const short    Cs = (short)1;
    const ushort  Cus = (ushort)1;
    const long	   Cl = (long)1;
    const ulong   Cul = (ulong)1;
    const float    Cf = (float)1;
    const double   Cd = (double)1;
    const ldouble Cld = (ldouble)1;
	const int		Ci = (int)1;
	const uint		Cui = (uint)1;
	const __int64	Ci64 = (__int64)1;

    char     c, c10[10];
    uchar   uc, uc10[10];
    short    s, s10[10];
    ushort  us, us10[10];
    long     l, l10[10];
    ulong   ul, ul10[10];
    float    f, f10[10];
    double   d, d10[10];
    ldouble ld, ld10[10];
	int		i,	i10[10];
	uint	ui,	ui10[10];
	__int64	i64,	i6410[10];

    struct st
    {
	short	s;
	uchar	uc10[10];
    }st, *pst = &st;
    union un
    {
	short	s2[2];
	ulong	 ul;
    }un, *pun = &un;

    for( counter = 0; counter < 10; counter++)
    {
		Gc  = (char)counter;
		Guc = (uchar)counter;
		Gs  = (short)counter;
		Gus = (ushort)counter;
		Gl  = (long)counter;
		Gul = (ulong)counter;
		Gf  = (float)counter;
		Gd  = (double)counter;
		Gld = (ldouble)counter;
	    Gi = (int)counter;
		Gui = (uint)counter;
	    Gi64 = (__int64)counter;
	
		Gst.Gs = (short)counter;
		Gun.Gs2[0] = (short)counter;
		Gun.Gs2[1] = 9 - (short)counter;
		
		c  = (char)counter;
		uc = (uchar)counter;
		s  = (short)counter;
		us = (ushort)counter;
		l  = (long)counter;
		ul = (ulong)counter;
		f  = (float)counter;
		d  = (double)counter;
		ld = (ldouble)counter;
	    i = (int)counter;
		ui = (uint)counter;
	    i64 = (__int64)counter;

		st.s = (short)counter;
		un.s2[0] = (short)counter;
		un.s2[1] = 9 - (short)counter;

		c10[counter]  = (char)counter;
		uc10[counter] = (uchar)counter;
		s10[counter]  = (short)counter;
		us10[counter] = (ushort)counter;
		l10[counter]  = (long)counter;
		ul10[counter] = (ulong)counter;
		f10[counter]  = (float)counter;
		d10[counter]  = (double)counter;
		ld10[counter] = (ldouble)counter;
		i10[counter] = (int)counter;
		ui10[counter] = (uint)counter;
		i6410[counter] = (__int64)counter;

		pst->uc10[counter] = (uchar)counter;
		pun->ul = (ulong)counter;
		PSuc = (uchar)counter;
    }
    return PSuc;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\f_int.cpp ===
#include "typetest.h"

extern const char     GCc;
extern const uchar   GCuc;
extern const short    GCs;
extern const ushort  GCus;
extern const long     GCl;
extern const ulong   GCul;
extern const float    GCf;
extern const double   GCd;
extern const ldouble GCld;
extern const int	  GCi;
extern const uint	  GCui;
extern const __int64 GCi64;

extern ushort GShortNearArray[NEARSIZE];

extern char	Gc;
extern uchar   Guc;
extern short	Gs;
extern ushort  Gus;
extern long	Gl;
extern ulong   Gul;
extern float	Gf;
extern double	Gd;
extern ldouble Gld;
extern short PassTest;
extern int	  Gi;
extern uint	  Gui;
extern __int64 Gi64;

extern struct Gstruct
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst;

extern union Gunion
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun;


int _cdecl CFncInt(int PSi)
{
    int counter;

    const char	   Cc = (char)1;
    const uchar   Cuc = (uchar)1;
    const short    Cs = (short)1;
    const ushort  Cus = (ushort)1;
    const long	   Cl = (long)1;
    const ulong   Cul = (ulong)1;
    const float    Cf = (float)1;
    const double   Cd = (double)1;
    const ldouble Cld = (ldouble)1;
	const int		Ci = (int)1;
	const uint		Cui = (uint)1;
	const __int64	Ci64 = (__int64)1;
 
    char     c, c10[10];
    uchar   uc, uc10[10];
    short    s, s10[10];
    ushort  us, us10[10];
    long     l, l10[10];
    ulong   ul, ul10[10];
    float    f, f10[10];
    double   d, d10[10];
    ldouble ld, ld10[10];
	int		i,	i10[10];
	uint	ui,	ui10[10];
	__int64	i64,	i6410[10];

    struct st
    {
	short	s;
	uchar	uc10[10];
    }st, *pst = &st;
    union un
    {
	short	s2[2];
	ulong	 ul;
    }un, *pun = &un;

    for( counter = 0; counter < 10; counter++)
    {
		Gc  = (char)counter;
		Guc = (uchar)counter;
		Gs  = (short)counter;
		Gus = (ushort)counter;
		Gl  = (long)counter;
		Gul = (ulong)counter;
		Gf  = (float)counter;
		Gd  = (double)counter;
		Gld = (ldouble)counter;
	    Gi = (int)counter;
		Gui = (uint)counter;
	    Gi64 = (__int64)counter;

		Gst.Gs = (short)counter;
		Gun.Gs2[0] = (short)counter;
		Gun.Gs2[1] = 9 - (short)counter;
		
		c  = (char)counter;
		uc = (uchar)counter;
		s  = (short)counter;
		us = (ushort)counter;
		l  = (long)counter;
		ul = (ulong)counter;
		f  = (float)counter;
		d  = (double)counter;
		ld = (ldouble)counter;
	    i = (int)counter;
		ui = (uint)counter;
	    i64 = (__int64)counter;

		st.s = (short)counter;
		un.s2[0] = (short)counter;
		un.s2[1] = 9 - (short)counter;

		c10[counter]  = (char)counter;
		uc10[counter] = (uchar)counter;
		s10[counter]  = (short)counter;
		us10[counter] = (ushort)counter;
		l10[counter]  = (long)counter;
		ul10[counter] = (ulong)counter;
		f10[counter]  = (float)counter;
		d10[counter]  = (double)counter;
		ld10[counter] = (ldouble)counter;
		i10[counter] = (int)counter;
		ui10[counter] = (uint)counter;
		i6410[counter] = (__int64)counter;

		pst->uc10[counter] = (uchar)counter;
		pun->ul = (ulong)counter;
		PSi = (int)counter;
    }
    return PSi;
}


uint _cdecl CFncUInt(uint PSui)
{
    int counter;

    const char	   Cc = (char)1;
    const uchar   Cuc = (uchar)1;
    const short    Cs = (short)1;
    const ushort  Cus = (ushort)1;
    const long	   Cl = (long)1;
    const ulong   Cul = (ulong)1;
    const float    Cf = (float)1;
    const double   Cd = (double)1;
    const ldouble Cld = (ldouble)1;
	const int		Ci = (int)1;
	const uint		Cui = (uint)1;
	const __int64	Ci64 = (__int64)1;
 
    char     c, c10[10];
    uchar   uc, uc10[10];
    short    s, s10[10];
    ushort  us, us10[10];
    long     l, l10[10];
    ulong   ul, ul10[10];
    float    f, f10[10];
    double   d, d10[10];
    ldouble ld, ld10[10];
	int		i,	i10[10];
	uint	ui,	ui10[10];
	__int64	i64,	i6410[10];

    struct st
    {
	short	s;
	uchar	uc10[10];
    }st, *pst = &st;
    union un
    {
	short	s2[2];
	ulong	 ul;
    }un, *pun = &un;

    for( counter = 0; counter < 10; counter++)
    {
		Gc  = (char)counter;
		Guc = (uchar)counter;
		Gs  = (short)counter;
		Gus = (ushort)counter;
		Gl  = (long)counter;
		Gul = (ulong)counter;
		Gf  = (float)counter;
		Gd  = (double)counter;
		Gld = (ldouble)counter;
	    Gi = (int)counter;
		Gui = (uint)counter;
	    Gi64 = (__int64)counter;

		Gst.Gs = (short)counter;
		Gun.Gs2[0] = (short)counter;
		Gun.Gs2[1] = 9 - (short)counter;
		
		c  = (char)counter;
		uc = (uchar)counter;
		s  = (short)counter;
		us = (ushort)counter;
		l  = (long)counter;
		ul = (ulong)counter;
		f  = (float)counter;
		d  = (double)counter;
		ld = (ldouble)counter;
	    i = (int)counter;
		ui = (uint)counter;
	    i64 = (__int64)counter;

		st.s = (short)counter;
		un.s2[0] = (short)counter;
		un.s2[1] = 9 - (short)counter;

		c10[counter]  = (char)counter;
		uc10[counter] = (uchar)counter;
		s10[counter]  = (short)counter;
		us10[counter] = (ushort)counter;
		l10[counter]  = (long)counter;
		ul10[counter] = (ulong)counter;
		f10[counter]  = (float)counter;
		d10[counter]  = (double)counter;
		ld10[counter] = (ldouble)counter;
		i10[counter] = (int)counter;
		ui10[counter] = (uint)counter;
		i6410[counter] = (__int64)counter;

		pst->uc10[counter] = (uchar)counter;
		pun->ul = (ulong)counter;
		PSui = (uint)counter;
    }
    return PSui;
}


__int64 _cdecl CFncInt64(__int64 PSi64)
{
    int counter;

    const char	   Cc = (char)1;
    const uchar   Cuc = (uchar)1;
    const short    Cs = (short)1;
    const ushort  Cus = (ushort)1;
    const long	   Cl = (long)1;
    const ulong   Cul = (ulong)1;
    const float    Cf = (float)1;
    const double   Cd = (double)1;
    const ldouble Cld = (ldouble)1;
	const int		Ci = (int)1;
	const uint		Cui = (uint)1;
	const __int64	Ci64 = (__int64)1;
 
    char     c, c10[10];
    uchar   uc, uc10[10];
    short    s, s10[10];
    ushort  us, us10[10];
    long     l, l10[10];
    ulong   ul, ul10[10];
    float    f, f10[10];
    double   d, d10[10];
    ldouble ld, ld10[10];
	int		i,	i10[10];
	uint	ui,	ui10[10];
	__int64	i64,	i6410[10];

    struct st
    {
	short	s;
	uchar	uc10[10];
    }st, *pst = &st;
    union un
    {
	short	s2[2];
	ulong	 ul;
    }un, *pun = &un;

    for( counter = 0; counter < 10; counter++)
    {
		Gc  = (char)counter;
		Guc = (uchar)counter;
		Gs  = (short)counter;
		Gus = (ushort)counter;
		Gl  = (long)counter;
		Gul = (ulong)counter;
		Gf  = (float)counter;
		Gd  = (double)counter;
		Gld = (ldouble)counter;
	    Gi = (int)counter;
		Gui = (uint)counter;
	    Gi64 = (__int64)counter;

		Gst.Gs = (short)counter;
		Gun.Gs2[0] = (short)counter;
		Gun.Gs2[1] = 9 - (short)counter;
		
		c  = (char)counter;
		uc = (uchar)counter;
		s  = (short)counter;
		us = (ushort)counter;
		l  = (long)counter;
		ul = (ulong)counter;
		f  = (float)counter;
		d  = (double)counter;
		ld = (ldouble)counter;
	    i = (int)counter;
		ui = (uint)counter;
	    i64 = (__int64)counter;

		st.s = (short)counter;
		un.s2[0] = (short)counter;
		un.s2[1] = 9 - (short)counter;

		c10[counter]  = (char)counter;
		uc10[counter] = (uchar)counter;
		s10[counter]  = (short)counter;
		us10[counter] = (ushort)counter;
		l10[counter]  = (long)counter;
		ul10[counter] = (ulong)counter;
		f10[counter]  = (float)counter;
		d10[counter]  = (double)counter;
		ld10[counter] = (ldouble)counter;
		i10[counter] = (int)counter;
		ui10[counter] = (uint)counter;
		i6410[counter] = (__int64)counter;

		pst->uc10[counter] = (uchar)counter;
		pun->ul = (ulong)counter;
		PSi64 = (__int64)counter;
    }
    return PSi64;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\f_recurs.cpp ===
#include "typetest.h"

extern const char     GCc;
extern const uchar   GCuc;
extern const short    GCs;
extern const ushort  GCus;
extern const long     GCl;
extern const ulong   GCul;
extern const float    GCf;
extern const double   GCd;
extern const ldouble GCld;
extern const int	  GCi;
extern const uint	  GCui;
extern const __int64 GCi64;

extern ushort GShortNearArray[NEARSIZE];

extern char	Gc;
extern uchar   Guc;
extern short	Gs;
extern ushort  Gus;
extern long	Gl;
extern ulong   Gul;
extern float	Gf;
extern double	Gd;
extern ldouble Gld;
extern short PassTest;
extern int		Gi;
extern uint		Gui;
extern __int64	Gi64;

extern struct Gstruct
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst;

extern union Gunion
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun;



short	_cdecl CFncSSRecurse(short NTimes)
{

    const char	   Cc = (char)NTimes;
    const uchar   Cuc = (uchar)NTimes;
    const short    Cs = (short)NTimes;
    const ushort  Cus = (ushort)NTimes;
    const long	   Cl = (long)NTimes;
    const ulong   Cul = (ulong)NTimes;
    const float    Cf = (float)NTimes;
    const double   Cd = (double)NTimes;
    const ldouble Cld = (ldouble)NTimes;
	const int		Ci = (int)NTimes;
	const uint		Cui = (uint)NTimes;
	const __int64	Ci64 = (__int64)NTimes;

    char     c;
    uchar   uc;
    short    s;
    ushort  us;
    long     l;
    ulong   ul;
    float    f;
    double   d;
    ldouble ld;
	int		i;
	uint	ui;
	__int64	i64;

    c = (char)NTimes;
    uc = (uchar)NTimes;
    s = (short)NTimes;
    us = (ushort)NTimes;
    l = (long)NTimes;
    ul = (ulong)NTimes;
    f = (float)NTimes;
    d = (double)NTimes;
    ld = (ldouble)NTimes;
    i = (int)NTimes;
    ui = (uint)NTimes;
    i64 = (__int64)NTimes;

    if( NTimes != 0 )
	NTimes = (short)CFncSSRecurse(NTimes-1);
    return(NTimes);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\include.h ===
class baseInclude
{
private:
	int m_private;

protected:
	int m_protected;

public: 
	baseInclude(void) {m_private = 1; m_protected = 2;}
	virtual ~baseInclude(void){};

	int m_public;
	char *m_pchar;
	virtual void virtual_func(int i);
	virtual void virtual_func1() { int i = 5; };
};

class derived1_Include : public baseInclude
{
private:
	char ch;

public:
	derived1_Include(void){ch = 'a';}
};

class derived2_Include : public derived1_Include
{
private:
	float f;

public:
	derived2_Include(void){f = 1.0f;}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	ecmfcapp.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\Resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by ECMFCAPP.RC
//
#define IDR_MAINFRAME				128
#define IDR_ECMFCATYPE				129
#define IDD_ABOUTBOX				100

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS			1
#define _APS_NEXT_RESOURCE_VALUE	130
#define _APS_NEXT_CONTROL_VALUE		1000
#define _APS_NEXT_SYMED_VALUE		101
#define _APS_NEXT_COMMAND_VALUE		32771
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\include.cpp ===
#include "include.h"



void baseInclude::virtual_func(int i)
{
	m_private = i;
	m_public = i;
}
int global2 = 0;
int iGlobal2;
int *piGlobal2 = &iGlobal2;

int Test_func_Include ( )
{
	derived1_Include drv1;
	drv1.virtual_func1();


	iGlobal2 = 0;
	*piGlobal2 = 1;
	int *pint = &iGlobal2;

	baseInclude b;
	b.virtual_func(0);

	baseInclude *pb2;
	baseInclude *pb1 = new baseInclude;
	pb2 = pb1;
	*pb1 = *pb1;

	::global2 = 1;

	return 0;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\MainFrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "ecmfcapp.h"

#include "MainFrm.h"

EXTERN_C void Types_Tests(int);

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
	// TODO: add member initialization code here
	
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{

int nLoop = 10;
Types_Tests(nLoop);

	if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (!m_wndToolBar.Create(this) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	// TODO: Remove this if you don't want tool tips or a resizeable toolbar
	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);

	// TODO: Delete these three lines if you don't want the toolbar to
	//  be dockable
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);

	return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CMDIFrameWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CMDIFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CMDIFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\MainFrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__49433FC9_FD1C_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_MAINFRM_H__49433FC9_FD1C_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CMainFrame : public CMDIFrameWnd
{
	DECLARE_DYNAMIC(CMainFrame)
public:
	CMainFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__49433FC9_FD1C_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\f_void.cpp ===
#include "typetest.h"

extern const char     GCc;
extern const uchar   GCuc;
extern const short    GCs;
extern const ushort  GCus;
extern const long     GCl;
extern const ulong   GCul;
extern const float    GCf;
extern const double   GCd;
extern const ldouble GCld;
extern const int	  GCi;
extern const uint	  GCui;
extern const __int64 GCi64;

extern ushort GShortNearArray[NEARSIZE];

extern char	Gc;
extern uchar   Guc;
extern short	Gs;
extern ushort  Gus;
extern long	Gl;
extern ulong   Gul;
extern float	Gf;
extern double	Gd;
extern ldouble Gld;
extern short PassTest;
extern int	  Gi;
extern uint	  Gui;
extern __int64 Gi64;

extern struct Gstruct
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst;

extern union Gunion
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun;


void _cdecl CFncVV (void)
{
    int counter;

    const char	   Cc = (char)1;
    const uchar   Cuc = (uchar)1;
    const short    Cs = (short)1;
    const ushort  Cus = (ushort)1;
    const long	   Cl = (long)1;
    const ulong   Cul = (ulong)1;
    const float    Cf = (float)1;
    const double   Cd = (double)1;
    const ldouble Cld = (ldouble)1;
	const int		Ci = (int)1;
	const uint		Cui = (uint)1;
	const __int64	Ci64 = (__int64)1;
 
    char     c, c10[10];
    uchar   uc, uc10[10];
    short    s, s10[10];
    ushort  us, us10[10];
    long     l, l10[10];
    ulong   ul, ul10[10];
    float    f, f10[10];
    double   d, d10[10];
    ldouble ld, ld10[10];
	int		i,	i10[10];
	uint	ui,	ui10[10];
	__int64	i64,	i6410[10];

    struct st
    {
	short	s;
	uchar	uc10[10];
    }st, *pst = &st;
    union un
    {
	short	s2[2];
	ulong	 ul;
    }un, *pun = &un;

    for( counter = 0; counter < 10; counter++)
    {
		Gc  = (char)counter;
		Guc = (uchar)counter;
		Gs  = (short)counter;
		Gus = (ushort)counter;
		Gl  = (long)counter;
		Gul = (ulong)counter;
		Gf  = (float)counter;
		Gd  = (double)counter;
		Gld = (ldouble)counter;
	    Gi = (int)counter;
		Gui = (uint)counter;
	    Gi64 = (__int64)counter;

		Gst.Gs = (short)counter;
		Gun.Gs2[0] = (short)counter;
		Gun.Gs2[1] = 9 - (short)counter;
		
		c  = (char)counter;
		uc = (uchar)counter;
		s  = (short)counter;
		us = (ushort)counter;
		l  = (long)counter;
		ul = (ulong)counter;
		f  = (float)counter;
		d  = (double)counter;
		ld = (ldouble)counter;
	    i = (int)counter;
		ui = (uint)counter;
	    i64 = (__int64)counter;

		st.s = (short)counter;
		un.s2[0] = (short)counter;
		un.s2[1] = 9 - (short)counter;

		c10[counter]  = (char)counter;
		uc10[counter] = (uchar)counter;
		s10[counter]  = (short)counter;
		us10[counter] = (ushort)counter;
		l10[counter]  = (long)counter;
		ul10[counter] = (ulong)counter;
		f10[counter]  = (float)counter;
		d10[counter]  = (double)counter;
		ld10[counter] = (ldouble)counter;
		i10[counter] = (int)counter;
		ui10[counter] = (uint)counter;
		i6410[counter] = (__int64)counter;

		pst->uc10[counter] = (uchar)counter;
		pun->ul = (ulong)counter;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\typetest.h ===
#define NEARSIZE    10000
#define FARSIZE     32767
#define HUGESIZE    75000

typedef unsigned char uchar;
typedef unsigned int uint;
typedef unsigned short ushort;
typedef unsigned long ulong;
typedef long double ldouble;



void	_cdecl CFncVV (void);
char	_cdecl CFncCC (char);
uchar	_cdecl CFncUCUC(uchar);
int		_cdecl CFncInt (int);
uint	_cdecl CFncUInt(uint);
__int64	_cdecl CFncInt64(__int64);
short	_cdecl CFncSS(short);
ushort	_cdecl CFncUSUS(ushort);
long	_cdecl CFncLL(long);
ulong	_cdecl CFncULUL(ulong);
float	_cdecl CFncFF(float);
double	_cdecl CFncDD(double);
ldouble _cdecl CFncLDLD(ldouble);
short	_cdecl CFncSSRecurse(short);
void	_cdecl CFncAsm(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\testg.h ===
int check_func(int  a,int  l);

static int foo_Include(int number);

int foo_Include(int number)
{
	number*=2;
	if(number == 3)
	{
		return (-1);
	}
	return number;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__49433FC7_FD1C_11D0_84BF_00AA00C00848__INCLUDED_)
#define AFX_STDAFX_H__49433FC7_FD1C_11D0_84BF_00AA00C00848__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__49433FC7_FD1C_11D0_84BF_00AA00C00848__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\testg.cpp ===
#include <stdio.h>
#include "testg.h"
#define ArrayLength 100
#define StructString65 "String65String65String65String65String65String65String65String65"
#define LocalString65  "__local_String65__local_String65__local_String65__local_String65"
#define Flag 1

int func();
int recur_func();
int func_1param(int);
long func_2param(int, long);
double func_3param(int, long, float);
void nest_func();
int GlobalG;
typedef int My_typedef;

struct Struct 
{
   int IntN;
   char *String65;
} Struct;

union Union 
{
   int Int;
   long Long;
} Union;

enum Enum 
{
  one,
  two,
  three
} Enum;

void nest_func() {
 	if (func()) 
   	func_1param (func());
};

int func() { 
			return 33;
		   };

int func_1param(int Parameter) {
    return Parameter;
 };

long func_2param(int intParam, long longParam) 
{
    return intParam + longParam;
};

double func_3param(int intParam, long longParam, float floatParam)
{
	int i_3p = 1;
	long l_3p = 999;
	float f_3p = (float)2.6;
	double d_3p = intParam + longParam + floatParam;

	i_3p = func();
	i_3p++;
	l_3p += i_3p;
	f_3p = l_3p - i_3p;

	do { //func_3param
		l_3p++;
	}while(l_3p <1050);
 
    return d_3p;
};

int recur_func() {
   static x=1;
   x++;
   if (x<9)
	   recur_func(); // call line
   return x;
};

int TestG()
{
 	int Local;
 	char Char = 'f';
 	int Int;
 	long Long;
 	double Double;
 	long double Ldouble;
 	float Real;
 	char *String;
 	void *Void;
 	My_typedef Mine;
 
	struct Struct Struct_local;
	union  Union Union_local;
	enum   Enum Enum_local;

 	struct Struct Array_struct[ArrayLength];
 	int  Array1d[3];
 	long Array2d[3][3];
 	char Array3d[3][3][3];

	Union_local.Int = 5;
	Union_local.Long = 999;
	Enum_local = one;

 	if (Flag) 
	{
  		for (Int=0; Int < ArrayLength; Int++)
   	{						                      // not executable code line
			Array_struct[Int].IntN = Int;
			Array_struct[Int].String65 = StructString65;
		};	  
 	};

 	for (Int=0; Int<3; Int++) 
	{
     	Array1d[Int]=Int;
     	Array2d[Int][Int]=Int;
     	Array3d[Int][Int][Int]=(char)Int;
  	};

 	Local=17;
 	Array1d[2]=9;
 	Struct.IntN = 1;
 	Struct.String65 = StructString65;
 	Struct_local.IntN = 11;
 	Struct_local.String65 = LocalString65;
 	Int=2;Int=6;Int=9;
 	Real=(float)1.303;
 	Double=1.303;
 	Ldouble=1.303;
 	String="this is a string";
 	GlobalG=77;
 	Long=99;

 	Mine=func();

 	if (Local > 0) 
	{
 		while (Local == 1)  
			Real = (float)9.9999;    // dead code
		if (Local > 1)
   		{							// not executable code line
	 		while (Local == 17)
			{                 // not executable code line
	 			Real = (float)8.88888;
				break;
			}
		}
 		else
 			Real = (float)7.77;		// dead code
	}
 	else						
    {							// dead code
		Real = (float)6.1;	      // dead code
	}							// dead code

 	if (1 < Local) do { GlobalG++; } while (Local == 0);

 	for (int i=0; i<15; i++) 
	{
	 	Int = func_1param(Local);
	 	Long = func_2param(Int, Long);
	 	Double = func_3param(Int, Long, Real);
	 	Ldouble = func_3param(func_1param(Local), func_2param(Int, Long), Real);
		Int = foo_Include(i);
	 	Int = recur_func(); // initial call
  		nest_func(); // nest_func call line
	}

	Int=0;  Int=check_func(Int,90);
	Void = (void*)Int;

	if(func() == 33)goto LabeL;
	Int = 999;
LabeL: 	return 1;

}


int check_func( int a, int l )
{
	char test[] = "TestName";
	
   if( !a )
   {
      printf("%s: Passed , line: %d --- %d != 0\n",test, l, a );
   }
   else
   {
      printf("%s: Failure, line: %d --- %d = 0\n",test, l, a );
   }
   return a;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\bin\EditContinue\src\ecapp\typetest.cpp ===
#include "typetest.h"

extern "C"
{
	void Types_Tests( int );
}

const char     GCc = (char)1;
const uchar   GCuc = (uchar)1;
const short    GCs = (short)1;
const ushort  GCus = (ushort)1;
const long     GCl = (long)1;
const ulong   GCul = (ulong)1;
const float    GCf = (float)1;
const double   GCd = (double)1;
const ldouble GCld = (ldouble)1;
const int	  GCi  = (int)1;
const uint	  GCui = (uint)1;
const __int64 GCi64 = (__int64)1;

ushort GShortNearArray[NEARSIZE];

char	 Gc;
uchar	Guc;
short	 Gs;
ushort	Gus;
long	 Gl;
ulong	Gul;
float	 Gf;
double	 Gd;
ldouble Gld;
short PassTest;
int		Gi;
uint	Gui;
__int64	Gi64;

struct Gstruct
{
    short   Gs;
    uchar   Guc10[10];
}Gst, *Gpst = &Gst;

union Gunion
{
    short   Gs2[2];
    ulong   Gul;
}Gun, *Gpun = &Gun;


void Types_Tests(int nLoop)
{
    int counter;

    char     c;
    uchar   uc;
    short    s;
    ushort  us;
    long     l;
    ulong   ul;
    float    f;
    double   d;
    ldouble ld;
	int		i;
	uint	ui;
	__int64	i64;

    for( counter = 0; counter < nLoop; counter++)
    {
		Gc  = (char)counter;
		Guc = (uchar)counter;
		Gs  = (short)counter;
		Gus = (ushort)counter;
		Gl  = (long)counter;
		Gul = (ulong)counter;
		Gf  = (float)counter;
		Gd  = (double)counter;
		Gi  = (int)counter;
		Gui = (uint)counter;
		Gi64 = (__int64)counter;

		CFncVV ();
		c = CFncCC (c);
	    uc = CFncUCUC(uc);
		i = CFncInt(i);
		ui = CFncUInt(ui);
		i64 = CFncInt64(i64);
		s = CFncSS(s);
	    us = CFncUSUS(us);
		l = CFncLL(l);
	    ul = CFncULUL(ul);
		f = CFncFF(f);
	    d = CFncDD(d);
		ld = CFncLDLD(ld);
	    s = CFncSSRecurse(10);

		Gst.Gs = (short)counter;
		Gun.Gs2[0] = (short)counter;
		Gun.Gs2[1] = 9 - (short)counter;
    }

	CFncAsm();

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\cleanup.h ===
void CleanUp(LPCSTR szDirName);
void OurKillFile(LPCSTR szPathName, LPCSTR szFileName = NULL);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\cleanup.cpp ===
#include <afxwin.h>
#include "cleanup.h"


void CleanUp(LPCSTR szDirName)
	{
	CString strPath;
	strPath = (CString)"src\\" + szDirName + "\\";

	OurKillFile(strPath + "*.dsp");
	OurKillFile(strPath + "*.dsw");
	OurKillFile(strPath + "*.opt");
	OurKillFile(strPath + "*.plg");
	OurKillFile(strPath + "*.ncb");
	OurKillFile(strPath + "*.mak");
	OurKillFile(strPath + "*.lnk");
	OurKillFile(strPath + "*.mdp");
	OurKillFile(strPath + "*.pdb");
	OurKillFile(strPath + "*.obj");
	OurKillFile(strPath + "*.ilk");
	OurKillFile(strPath + "*.dll");
	OurKillFile(strPath + "*.exe");
	}


void OurKillFile(LPCSTR szPathName, LPCSTR szFileName /* NULL */)

	{
	WIN32_FIND_DATA ffdImgFile;
	HANDLE hFile;
	CString str, strPattern, strPath = szPathName;

	if(szFileName != NULL)
		
		{
		if((strPath.Right(1) != "\\") && (szFileName[0] != '\\'))
			strPath += "\\";

		strPattern = strPath + szFileName; 
		}

	else
		strPattern = strPath;

	hFile = FindFirstFile(strPattern, &ffdImgFile);
	
	if(hFile != INVALID_HANDLE_VALUE)
		{
		do
			{
			str = strPath + ffdImgFile.cFileName;
			DeleteFile(str);
			} while(FindNextFile(hFile, &ffdImgFile));
		}

	FindClose(hFile);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\automate\autobps.h ===
///////////////////////////////////////////////////////////////////////////////
//	autobps.h
//
//	Created by : MichMa		Date: 9-17-96			
//		VCBU QA
//
//	Description :
//		Declaration of the CBreakpointsAutomationIDETest Class
//

#ifndef __AUTOBPS_H__
#define __AUTOBPS_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\dbgset.h"
#include "autosub.h"

///////////////////////////////////////////////////////////////////////////////
//	CBreakpointsAutomationIDETest class

class CBreakpointsAutomationIDETest : public CDebugTestSet
	{
		DECLARE_TEST(CBreakpointsAutomationIDETest, CAutomationSubSuite)

	// Operations
	public:
		virtual void PreRun(void);
		virtual void Run(void);
	};

#endif //__AUTOBPS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\dbgset.h ===
//
// dbgset.h
//
//	Created by		Date
//		TomSe		9/2/94
//
//	Description
//		Definition of base class containing common data and methods for all
//		Debug Test Sets.


#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#ifndef __DBGSET_H__
#define __DBGSET_H__

//#include "coresub.h"

extern int ReturnCode;
extern bp  * ReturnBP;

#define EXPECT_TRUE(f)    ((f)?LogResult(__LINE__, PASSED,#f):LogResult(__LINE__, FAILED,#f));
#define EXPECT_SUCCESS(f) (((ReturnCode=(f))==0)?LogResult(__LINE__, PASSED,#f):LogResult(__LINE__, FAILED,#f,ReturnCode));
#define EXPECT_VALIDBP(f) (((ReturnBP=(f))!=NULL)?LogResult(__LINE__, PASSED,#f):LogResult(__LINE__, FAILED,#f));
#define EXPECT_TRUE_COMMENT(f,comment) ((f)?LogResult(__LINE__, PASSED,#f,0,#comment):LogResult(__LINE__, FAILED,#f,0,#comment));

#define ABORT_SUBTEST() THROW( new CSubTestException )

#define EXPECT_SUBTEST_OLD(f)  if(f) { LogResult(__LINE__, PASSED,#f);} \
				else { LogResult(__LINE__, FAILED,#f); ABORT_SUBTEST(); }

#define EXPECT_SUBTEST(f)   if(f) { LogResult(__LINE__, PASSED,#f);} \
							else {LogResult(__LINE__, FAILED,#f); }

class CSubTestException : public CException {
	DECLARE_DYNAMIC( CSubTestException );
};

#define InitProject SetProject
#define RestoreFocusToSrcWnd() MST.DoKeys("{ESC}")


///////////////////////////////////////////////////////////////////////////////
//	class CDebugTestSet used as base for debugging tests

class CDebugTestSet : public CTest
{
//	DECLARE_TEST(CDebugTestSet, CIDESubSuite /*CCORESubSuite*/)
	DECLARE_DYNAMIC(CDebugTestSet)
public:	
	// since this class is a base class for tests, it must have a ctor
	// that takes all test parameters for proper base class initialization
	CDebugTestSet(CSubSuite* pSubSuite, LPCSTR szName, int nExpectedCompares, LPCSTR szListFilename = NULL);

protected: // data
	CString	m_strProjectDir;
	CString	m_strProjectName;
	CString	m_szErrorText;
	int m_platform;

	COSource src;
	COProject proj;
	CODebug dbg;
	COExpEval cxx;
	COBreakpoints bps;
	COStack stk;
	UIMemory uimem;
	COMemory mem;
	UIVariables uivar;
	COBrowse browse;
	COFile file;
	UIWatch uiwatch;
	UIQuickWatch uiqw;
	CODAM dam;
	COThreads threads;
	COLocals locals;
	CORegisters regs;

	typedef enum {PROJECT_EXE, PROJECT_DLL} PROJECT_TYPE;
	typedef enum {fDefault, fBuildOnly} PROJECT_FLAGS;

	BOOL SetProject(LPCSTR projName, PROJECT_TYPE projType = PROJECT_EXE,
					PROJECT_FLAGS = fDefault,LPCSTR cfgName=NULL);

	BOOL StartDebugging(void);
	BOOL StopDbgCloseProject(void);
	BOOL VerifyProjectRan(int exitcode = 0);
	BOOL StepInUntilFrameAdded(CString addframe);
	BOOL StepInUntilFrameRemoved(void);

	// shorthand method of filling EXPR_INFO object.
	void FillExprInfo(EXPR_INFO &expr_info, int state, LPCSTR type, LPCSTR name, LPCSTR value);

	// compares two EXPR_INFO objects
	BOOL ExprInfoIs(EXPR_INFO * expr_info_actual, EXPR_INFO * expr_info_expected, 
					int total_rows = 1);

	// tells whether string represents an address as displayed in an ee window.
	// for example: 0x1234abcd "xyz"
	// support function for ExprInfoIs()
	BOOL ValueIsAddress(CString str);

	void LogResult(int line, int result,LPCSTR szoperation, int code=0, LPCSTR szComment="");
	LPCSTR HomeDir(void);
	LPCSTR FullPath(LPCSTR szAddPath);
	void LogTestHeader(LPCSTR test_desc_str);

	void VerifyLocalsWndString(LPCSTR strType, LPCSTR strName,  LPCSTR strValue, int lineNumber = 1);
	BOOL LocalsWndStringIs(LPCSTR strType, LPCSTR strName,  LPCSTR strValue, int lineNumber = 1);

};

#endif	// __DBGSET_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\automate\autobp.h ===
///////////////////////////////////////////////////////////////////////////////
//	autobp.h
//
//	Created by : MichMa		Date: 9-17-96			
//		VCBU QA
//
//	Description :
//		Declaration of the CBreakpointAutomationIDETest Class
//

#ifndef __AUTOBP_H__
#define __AUTOBP_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\dbgset.h"
#include "autosub.h"

///////////////////////////////////////////////////////////////////////////////
//	CBreakpointAutomationIDETest class

class CBreakpointAutomationIDETest : public CDebugTestSet
	{
		DECLARE_TEST(CBreakpointAutomationIDETest, CAutomationSubSuite)

	// Operations
	public:
		virtual void PreRun(void);
		virtual void Run(void);
	};

#endif //__AUTOBP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\automate\autobp.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	autobp.cpp
//											 
//	Created by : MichMa		Date: 9-17-96			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "autobp.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
IMPLEMENT_TEST(CBreakpointAutomationIDETest, CDebugTestSet, "Breakpoint Item", -1, CAutomationSubSuite)
					   
											 
void CBreakpointAutomationIDETest::PreRun(void)
	{
	// call the base class
	CTest::PreRun();
	}


void CBreakpointAutomationIDETest::Run(void)
	
	{
	/******************
	 * INITIALIZATION *
	 ******************/
	if(!(GetSubSuite()->fProjectReady))
		{
		if(!InitProject("automate", PROJECT_EXE))
			{
			m_pLog->RecordInfo("ERROR: could not init automate project");
			return;
			}
		GetSubSuite()->CloseWorkspaceAndCreateOptionsFile();
		GetSubSuite()->fProjectReady = TRUE;
		GetSubSuite()->LoadMacroFile();
		}

	/*********
	 * TESTS *
	 *********/
	// TODO(michma): use cafe macro class (COMacro?) when available.
	GetSubSuite()->RunMacro("BreakpointItemTest");
	// TODO(michma): use cafe output class (COOutput?) when available.
	GetSubSuite()->WriteOutputWindowToLog();
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\automate\autobps.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	autobps.cpp
//											 
//	Created by : MichMa		Date: 9-17-96			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "autobps.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
IMPLEMENT_TEST(CBreakpointsAutomationIDETest, CDebugTestSet, "Breakpoints Collection", -1, CAutomationSubSuite)
					   
											 
void CBreakpointsAutomationIDETest::PreRun(void)
	{
	// call the base class
	CTest::PreRun();
	}


void CBreakpointsAutomationIDETest::Run(void)
	
	{
	/******************
	 * INITIALIZATION *
	 ******************/
	if(!(GetSubSuite()->fProjectReady))
		{
		if(!InitProject("automate", PROJECT_EXE))
			{
			m_pLog->RecordInfo("ERROR: could not init automate project");
			return;
			}
		GetSubSuite()->CloseWorkspaceAndCreateOptionsFile();
		GetSubSuite()->fProjectReady = TRUE;
		GetSubSuite()->LoadMacroFile();
		}

	/*********
	 * TESTS *
	 *********/
	// TODO(michma): use cafe macro class (COMacro?) when available.
	GetSubSuite()->RunMacro("BreakpointsCollectionTest");
	// TODO(michma): use cafe output class (COOutput?) when available.
	GetSubSuite()->WriteOutputWindowToLog();
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\automate\autodbg.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	autodbg.cpp
//											 
//	Created by : MichMa		Date: 9-17-96			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "autodbg.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
IMPLEMENT_TEST(CDebuggerAutomationIDETest, CDebugTestSet, "Debugger Object", -1, CAutomationSubSuite)
					   
											 
void CDebuggerAutomationIDETest::PreRun(void)
	{
	// call the base class
	CTest::PreRun();
	}


void CDebuggerAutomationIDETest::Run(void)
	
	{
	/******************
	 * INITIALIZATION *
	 ******************/
	if(!(GetSubSuite()->fProjectReady))
		{
		if(!InitProject("automate", PROJECT_EXE))
			{
			m_pLog->RecordInfo("ERROR: could not init automate project");
			return;
			}
		GetSubSuite()->CloseWorkspaceAndCreateOptionsFile();
		GetSubSuite()->fProjectReady = TRUE;
		GetSubSuite()->LoadMacroFile();
		}

	/*********
	 * TESTS *
	 *********/
	// TODO(michma): use cafe macro class (COMacro?) when available.
	GetSubSuite()->RunMacro("DebuggerObjectTest");
	// TODO(michma): use cafe output class (COOutput?) when available.
	GetSubSuite()->WriteOutputWindowToLog();
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\automate\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\dbgset.cpp ===
//
// dbgset.cpp
//
//	Created by		Date
//		TomSe		9/2/94
//
//	Description
//		Definition of base class containing common data and methods for all
//		Debug Test Sets.


#include "stdafx.h"
#include "dbgset.h"
#include "guitarg.h"

IMPLEMENT_DYNAMIC( CSubTestException, CException );

IMPLEMENT_DYNAMIC(CDebugTestSet, CTest)

CDebugTestSet::CDebugTestSet(CSubSuite* pSubSuite, LPCSTR szName, int nExpectedCompares, LPCSTR szListFilename /*= NULL*/)
: CTest(pSubSuite, szName, nExpectedCompares, szListFilename)
{
}

BOOL CDebugTestSet::SetProject(LPCSTR projName, PROJECT_TYPE projType /* PROJECT_EXE */, PROJECT_FLAGS flags /* fDefault */, LPCSTR cfgName /*NULL*/)

	{
	const char* const THIS_FUNCTION = "SetProject()";
	CString projPathAndName = projName;
	int iName = projPathAndName.ReverseFind('\\');
	if( iName < 0 )
	{
		m_strProjectDir = FullPath("src");
		m_strProjectName = projName;
	}
	else
	{
		m_strProjectDir = (CString)FullPath("src") + "\\" + projPathAndName.Left(iName);
		m_strProjectName = projPathAndName.Mid(iName + 1);
	}
	CIDESubSuite* pSubSuite=(CIDESubSuite*)GetSubSuite();
	ASSERT(pSubSuite->IsKindOf(RUNTIME_CLASS(CIDESubSuite))); //our tests are IDE tests only
	// get the toolset environment settings.
	CSettings *settingsToolsetEnv = pSubSuite->GetToolset()->GetEnvSettings();
	// build the path, lib, and include environment strings.

	CString cstrPathEnv = settingPathEnv + CString("=") + settingsToolsetEnv->GetTextValue(settingPathEnv);
	CString cstrLibEnv = settingLibEnv + CString("=") + settingsToolsetEnv->GetTextValue(settingLibEnv);
 	CString cstrIncludeEnv = settingIncludeEnv + CString("=") + settingsToolsetEnv->GetTextValue(settingIncludeEnv);

	// get windows and system dir and append to path environment string.
	CString cstrWindowsDir, cstrSystemDir;
	// each dir is prepended with a semi-colon as a separator. 
	char chDirBuf[MAX_PATH] = ";";
 	GetWindowsDirectory(&chDirBuf[1], MAX_PATH);	// &chDirBuf[0] = ';'
	cstrWindowsDir = chDirBuf;
	GetSystemDirectory(&chDirBuf[1], MAX_PATH);		// &chDirBuf[0] = ';'
	cstrSystemDir = chDirBuf;
	cstrPathEnv += cstrWindowsDir + cstrSystemDir;

	// nmake's environment block.
	char chNmakeEnv[1024];
	// pointer to navigate through block.
	char *pchNmakeEnv = chNmakeEnv;

	// put the path, lib, and include environment strings into the block.
	// each string is terminated by null.
	strcpy(pchNmakeEnv, cstrPathEnv);
	pchNmakeEnv += strlen(pchNmakeEnv) + 1;
	strcpy(pchNmakeEnv, cstrLibEnv);
	pchNmakeEnv += strlen(pchNmakeEnv) + 1;
	strcpy(pchNmakeEnv, cstrIncludeEnv);
	// block is terminated by additional null.
	pchNmakeEnv[strlen(pchNmakeEnv) + 1] = 0;
 
	// to find nmake.exe in the toolset path environment, 
	// we'll use cstrPathFrag to search	for and extract directories
	// from cstrPathEnv	(minus first 5 characters which are "PATH=").
	CString cstrPathFrag = cstrPathEnv.Mid(5);
	// stores dir extracted from cstrPathFrag.
	CString cstrDir;
	// stores index of next semi-colon (dir separator) in cstrPathEnv.
	int indexSemi;
	// handle to nmake.exe returned by FindFirstFile().
	HANDLE hNmake;
	// FindFirstFile param.
	WIN32_FIND_DATA fdFindData;

	while(1)
		
		{
		// find the next semi-colon which terminates the next dir to search.
		indexSemi = cstrPathFrag.Find(';');

		// if a semi-colon was found, extract the dir it terminates. otherwise
		// we are at the final dir in the path environment. 
		if(indexSemi != -1)
			cstrDir = cstrPathFrag.Left(indexSemi);
		else
			cstrDir = cstrPathFrag;
			
		// only want to search dirs at least 3 chars long. for example:
		// path  = C:\;
		// index = 0123
		if(cstrDir.GetLength() >= 3)
			hNmake = FindFirstFile(cstrDir + "\\nmake.exe", &fdFindData);
  		
		// stop searching if nmake was found in cstrPathFrag.
		if(hNmake != INVALID_HANDLE_VALUE)
			break;

		// if no semi-colon was found or it was the last char in the path, 
		// then we just searched the final dir in the environment string, 
		// but still haven't found nmake. 
	 	if((indexSemi == -1) || (cstrPathFrag.GetLength() == (indexSemi + 1)))
			{
			m_pLog->RecordInfo("ERROR in %s: could not find nmake.exe in path environment "
							   "specified by CAFE.", THIS_FUNCTION);
			return FALSE;
			}
		else
			// advance to the start of the next dir after the semi-colon.
			cstrPathFrag = cstrPathFrag.Mid(indexSemi + 1);
		}


	// determine the configuration switch that we need to pass to nmake.
	// also set platform member value for easy access by tests.
	if(cfgName==NULL)
	switch(GetUserTargetPlatforms())
		{
        case PLATFORM_WIN32_ALPHA:
            cfgName = "alpha";
            m_platform = PLATFORM_WIN32_ALPHA;
            break;
		case PLATFORM_WIN32_X86:
			cfgName = "x86";
			m_platform = PLATFORM_WIN32_X86;
			break;
		}

	// project name and configuration switch we will pass to nmake.
	// we enclose the project name in quotes to support names with spaces.
	CString cstrProjAndConfig = (CString)"\"" + m_strProjectName + ".mak\" CFG=" + cfgName;
	if( UIWB.GetPcodeSwitch() )
		cstrProjAndConfig += " PCODE=yes";
	// CreateProcess() params.
   	STARTUPINFO siStartInfo;
	PROCESS_INFORMATION piProcInfo;
	// this is the minium initialization of STARTUPINFO required for CreateProcess() to work.
	memset(&siStartInfo, 0, sizeof(STARTUPINFO));
	siStartInfo.cb = sizeof(STARTUPINFO);
	siStartInfo.wShowWindow = SW_SHOWDEFAULT;
	// fully qualified nmake.exe cmd line (cstrDir is directory we found nmake in earlier).
	char chNmakeCmdLine[MAX_PATH];
	strcpy(chNmakeCmdLine, cstrDir + "\\nmake.exe /a /f " + cstrProjAndConfig);
	
	// before spawning nmake make sure Debugger is not running, so vc50.pdb is released
	if(dbg.GetDebugState() != NotDebugging)
		dbg.StopDebugging();


	// Allocate console to be able to see how the project is built.  If we don't allocate it the window close
	// immediately after build process has finished. *dklem
	AllocConsole();


	// spawn nmake in the project dir.
	BOOL bRet = CreateProcess(NULL, chNmakeCmdLine, NULL, NULL, TRUE, 0, chNmakeEnv,
							  m_strProjectDir, &siStartInfo, &piProcInfo);
	
	// verify that nmake was successfully spawned.						  
	if(!bRet)
		{
		m_pLog->RecordInfo("ERROR in %s: nmake.exe found but could not be spawned.", THIS_FUNCTION);
		return FALSE;
		}

	// nmake's exit code returned by GetExitCodeProcess().
	DWORD dwNmakeExitCode;

	// wait up to 60 minutes for nmake to terminate.
	for(int i = 0; i < 3600; i++)
		
		{
		Sleep(1000);
		// get nmake's exit code (if it has finished).
		GetExitCodeProcess(piProcInfo.hProcess, &dwNmakeExitCode);
		
		// keep sleeping if nmake is still running.
		if(dwNmakeExitCode != STILL_ACTIVE)
			break;
		}

	// Is 5 seconds seconds enough to inspect the output ? *dklem
	Sleep(5000);
	// Say good bye to the console
	FreeConsole();

	// verify that nmake finished within the allotted time.
	if(i == 3600)
		{
		m_pLog->RecordInfo("ERROR in %s: after 60 minutes nmake is still running.", THIS_FUNCTION);
		return FALSE;
		}

	// verify that nmake was successful in building the executable.
	if(dwNmakeExitCode != 0)
		{
		m_pLog->RecordInfo("ERROR in %s: nmake.exe returned error code %d.", THIS_FUNCTION, dwNmakeExitCode);
		return FALSE;
		}

	// wait until nmake's window has gone away.
	if(!MST.WFndWndWait("nmake.exe", FW_PART + FW_NOEXIST, 5))
		{
		m_pLog->RecordInfo("ERROR in %s: after 5 seconds nmake's window still exists.", THIS_FUNCTION);
		return FALSE;
		}

	// stop here if we only want to build.
	if(flags & fBuildOnly)
		return TRUE;

	// project exe has same base as makefile (i.e. xxx.mak/xxx.exe/xxx.dll)
	// we want to strip out any prepended path and just use the file name
	// because we use this name to set the remote path, and the host
	// path will usually not match the remote path.
	CString cstrProjectExe = m_strProjectName.Right(m_strProjectName.GetLength() -
							 m_strProjectName.ReverseFind('\\') - 1) + 
							 ((projType == PROJECT_EXE) ? ".exe" : ".dll");


	// we need to make sure the debugger isn't running on a previous project
	// or COWorkSpace::CloseAllWindows will fail.
	if(dbg.GetDebugState() != NotDebugging)
		dbg.StopDebugging();

	// we need to close all windows before opening the exe or COProject::Open will fail.
 	COWorkSpace ws;
	ws.CloseAllWindows();

	// open the executable.	
	if(proj.Open(m_strProjectDir + "\\" + cstrProjectExe) != ERROR_SUCCESS)
		{
		m_pLog->RecordInfo("ERROR in %s: could not open \"%s\".", THIS_FUNCTION, 
							m_strProjectDir + "\\" + cstrProjectExe);
		return FALSE;
		}

	// allows us to access ide's connection settings via pconnec.
	COConnection *pconnec = pSubSuite->GetIDE()->GetConnectionInfo();

	// set the connection as specified by the user.
	if(pconnec->SetAll() != ERROR_SUCCESS)
		{
		m_pLog->RecordInfo("ERROR in %s: could not set connection settings.", THIS_FUNCTION);
		return FALSE;
		}
	
	// if indicated, set the remote path and copy the executable to the remote machine.
	if(pconnec->GetUserConnections() != CONNECTION_LOCAL)
		
		{
		if(proj.SetRemotePath(cstrProjectExe) != ERROR_SUCCESS)
			{
			m_pLog->RecordInfo("ERROR in %s: could not set remote path using \"%s\".", 
							   THIS_FUNCTION, cstrProjectExe);
			return FALSE;
			}
		
		if(proj.UpdateRemoteFile(m_strProjectDir + "\\" + cstrProjectExe) != ERROR_SUCCESS)
			{
			m_pLog->RecordInfo("ERROR in %s: could not update remote file using \"%s\".", 
							   THIS_FUNCTION, m_strProjectDir + "\\" + cstrProjectExe);
			return FALSE;
			}
		}
	
	return TRUE;
	}


/*
** start debugging and do some initialization.  
*/

BOOL CDebugTestSet::StartDebugging(void)
{
	BOOL bSuccess; 
	COSource src;	

	bps.ClearAllBreakpoints();		// Clear All Breakpoints Just in case.
	dbg.StepOver(1);				// Start debugging session with initial trace.
	src.AttachActiveEditor();		// WinslowF
	bSuccess = dbg.AtSymbol("WinMain");

	// attach to the editor window the debugger opened
	bSuccess &= src.AttachActiveEditor();

	UIWB.SetMemoryFormat(MEM_FORMAT_BYTE); 
	dbg.SetSteppingMode(SRC); 		
	return bSuccess;
}


BOOL CDebugTestSet::StopDbgCloseProject(void)
{
	if (dbg.GetDebugState() != NotDebugging)
		dbg.StopDebugging();
	UIWB.CloseAllWindows();
	proj.Close();						

	return TRUE;
}


BOOL CDebugTestSet::VerifyProjectRan(int exitcode /* = 0 */)
{

	// REVIEW: use CODebug::VerifyTermination when it is available.
	// OpenOutputWindow
	UIOutput uow = UIDebug::ShowDockWindow(IDW_OUTPUT_WIN, TRUE);
//	EXPECT( uow.IsActive() );
	// Select the last line, write it to clipboard and look for "exit code 0"
	MST.DoKeys( "^{end}" );
	MST.DoKeys( "{up}" );

	char buffer[10];
	CString	szexcode = "exited with code ";			
	szexcode += itoa(exitcode, buffer, 10 ); // WinslowF - for OEM compatibility now we can specify the exit code to be verified

	if ( UIWB.VerifySubstringAtLine( szexcode ))
	{
		return (TRUE);
	}
	else
	{
		return (FALSE);
	}		
	
	return TRUE;
}


BOOL CDebugTestSet::StepInUntilFrameAdded( CString addframe )
{
	BOOL bResult = TRUE;
	COStack stk;
	CODebug dbg;
	FrameList framelist0;

	// Establish base line
	framelist0.CreateFromText( stk.GetAllFunctions() );
	Frame topframe( framelist0[0] );

	while( bResult ) {
		dbg.StepInto();
		FrameList current;
		current.CreateFromText( stk.GetAllFunctions() );

		if( current.GetSize() == framelist0.GetSize() ) {
			// Only check function name or image name for top frame.
			CString str0;
			if( topframe.GetFunctionName( str0 ) ) {
				bResult = Frame( current[0] ).Test( str0 );
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameAdded - Mismatch top frame '%s' not in '%s'",
						(LPCTSTR)str0, (LPCTSTR)current[0] );
				}
			}
			else if( topframe.GetImageName( str0 ) ){
				bResult = Frame( current[0] ).Test( str0 );
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameAdded - Mismatch top frame '%s' not in '%s'",
						(LPCTSTR)str0, (LPCTSTR)current[0] );
				}
			}
			else {
				// Bad format
				m_pLog->RecordInfo( "StepInUntilFrameAdded - Bad format for frame '%s'",
					(LPCTSTR)topframe );
				bResult = FALSE;
			}

			// The remaining frames should be identical
			for( int iFrame = 1; bResult && iFrame < framelist0.GetSize(); iFrame++ ) {
				bResult = framelist0[iFrame] == current[iFrame];
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameAdded - Mismatch in frame %d, '%s' != '%s'",
						(LPCTSTR)current[0], (LPCTSTR)framelist0[0] );
				}
			}
		}
		else if( current.GetSize() == framelist0.GetSize() + 1 ) {
			// Test new top frame
			bResult = Frame( current[0] ).Test( addframe );

			// Only check function name or image name for 2nd frame since the line number
			// may change.
			CString str0;
			if( topframe.GetFunctionName( str0 ) ) {
				bResult = Frame( current[1] ).Test( str0 );
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameAdded - Mismatch 2nd frame '%s' not in '%s'",
						(LPCTSTR)str0, (LPCTSTR)current[1] );
				}
			}
			else if( topframe.GetImageName( str0 ) ) {
				bResult = Frame( current[1] ).Test( str0 );
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameAdded - Mismatch 2nd frame '%s' not in '%s'",
						(LPCTSTR)str0, (LPCTSTR)current[1] );
				}
			}
			else {
				// Bad format
				m_pLog->RecordInfo( "StepInUntilFrameAdded - Bad format for frame '%s'",
					(LPCTSTR)topframe );
				bResult = FALSE;
			}

			// The remaining frames should be identical
			for( int iFrame = 1; bResult && iFrame < framelist0.GetSize(); iFrame++ ) {
				bResult = framelist0[iFrame] == current[iFrame+1];
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameAdded - Mismatch in frame %d, '%s' != '%s'",
						(LPCTSTR)current[iFrame+1], (LPCTSTR)framelist0[iFrame] );
				}
			}
			break;	// Get out of loop

		}
		else {
			// Unexpected number of frames
			m_pLog->RecordInfo( "StepInUntilFrameAdded - Expected %d frames, got %d frames",
				framelist0.GetSize() + 1, current.GetSize() );
			bResult = FALSE;
		}
	}

	return bResult;
}

BOOL CDebugTestSet::StepInUntilFrameRemoved() {
	BOOL bResult = TRUE;
	COStack stk;
	CODebug dbg;
	FrameList framelist0;

	// Establish base line

	framelist0.CreateFromText( stk.GetAllFunctions() );
	Frame topframe( framelist0[0] );

	while( bResult ) {
		dbg.StepInto();
		FrameList current;
		current.CreateFromText( stk.GetAllFunctions() );

		//
		// REVIEW: This can be shared with StepInUntilAdded
		//
		if( current.GetSize() == framelist0.GetSize() ) {
			// Only check function name or image name for top frame.
			CString str0;
			if( topframe.GetFunctionName( str0 ) ) {
				CString str1;
				if( topframe.GetParameters( str1 ) ) {
					str0 += "(" + str1 + ")";
				}
				bResult = Frame( current[0] ).Test( str0 );
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameRemoved - Mismatch top frame '%s' not in '%s'",
						(LPCTSTR)str0, (LPCTSTR)current[0] );
				}
			}
			else if( topframe.GetImageName( str0 ) ) {
				bResult = Frame( current[0] ).Test( str0 );
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameRemoved - Mismatch top frame '%s' not in '%s'",
						(LPCTSTR)str0, (LPCTSTR)current[0] );
				}
			}
			else {
				// Bad format
				m_pLog->RecordInfo( "StepInUntilFrameRemoved - Bad format for frame '%s'",
					(LPCTSTR)topframe );
				bResult = FALSE;
			}

			// The remaining frames should be identical
			for( int iFrame = 1; bResult && iFrame < framelist0.GetSize(); iFrame++ ) {
				bResult = framelist0[iFrame] == current[iFrame];
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameRemoved - Mismatch in frame %d, '%s' != '%s'",
						iFrame, (LPCTSTR)current[0], (LPCTSTR)framelist0[0] );
				}
			}
		}
		else if( current.GetSize() == framelist0.GetSize() - 1 ) {
			// The remaining frames should be identical
			for( int iFrame = 0; bResult && iFrame < current.GetSize(); iFrame++ ) {
				bResult = framelist0[iFrame+1] == current[iFrame];
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameRemoved - Mismatch in frame %d, '%s' != '%s'",
						iFrame, (LPCTSTR)current[iFrame], (LPCTSTR)framelist0[iFrame+1] );
				}
			}
			break;	// Get out of loop
		}
		else {
			// Unexpected number of frames
			m_pLog->RecordInfo( "StepInUntilFrameRemoved - Expected %d frames, got %d frames",
				framelist0.GetSize() + 1, current.GetSize() );
			bResult = FALSE;
		}
	}

	return bResult;
}


int ReturnCode =0;
bp  * ReturnBP =0;

void CDebugTestSet::LogResult(int line, int result,LPCSTR szoperation, int code /* 0 */, LPCSTR szComment /* "" */)

	{
	CString szOpCom = (CString)szoperation + "  " + szComment;
	if(result == PASSED)
		m_pLog->RecordSuccess("%s", szOpCom);
	else
		{
		CString szextra;
		char chbuf[24];
		szextra = szextra + "Error Code = " + itoa(code, chbuf, 10);
		m_pLog->RecordFailure("LINE %d %s", line, szextra + szOpCom);
		}
	}


//
//	Returns the current directory of the first time this function was called.
//
LPCSTR CDebugTestSet::HomeDir()
{
	static CString szCurDir;

	if( szCurDir.IsEmpty() )
	{
		char* psz = szCurDir.GetBufferSetLength(_MAX_DIR);

		GetCurrentDirectory(_MAX_DIR - 1, psz);
		szCurDir.ReleaseBuffer(-1);
		if( szCurDir.Right(1) != '\\' )
			szCurDir += "\\";
	}
 	return szCurDir;
}

//
//	Returns the fully qualified path with szAddPath appended to the breadth dir.	
//
LPCSTR CDebugTestSet::FullPath( LPCSTR szAddPath )
{
	static CString szFilespec;

	szFilespec = HomeDir();
	szFilespec += szAddPath;

	return szFilespec;
}


void CDebugTestSet::FillExprInfo(EXPR_INFO &expr_info, 
								 int state, LPCSTR type, LPCSTR name, LPCSTR value)

	{
	expr_info.state = state;
	expr_info.type = type;
	expr_info.name = name;
	expr_info.value = value;
	}


BOOL CDebugTestSet::ExprInfoIs(EXPR_INFO * expr_info_actual, EXPR_INFO * expr_info_expected, 
							   int total_rows /* 1 */)
	
	{
	for(int i = 0; i < total_rows; i++)

		{
		if(expr_info_actual[i].state != expr_info_expected[i].state)
			
			{
			m_pLog->RecordFailure("ERROR in ExprInfoIs(): state is %d instead of %d", 
								  expr_info_actual[i].state, expr_info_expected[i].state);

			return FALSE;
			}

		if(expr_info_actual[i].type != expr_info_expected[i].type)
			
			{
			m_pLog->RecordFailure("ERROR in ExprInfoIs(): type is %s instead of %s", 
								  expr_info_actual[i].type, expr_info_expected[i].type);

			return FALSE;
			}

		if(expr_info_actual[i].name != expr_info_expected[i].name)
			
			{
			m_pLog->RecordFailure("ERROR in ExprInfoIs(): name is %s instead of %s", 
								  expr_info_actual[i].name, expr_info_expected[i].name);

			return FALSE;
			}

		if(expr_info_expected[i].value.Mid(0, 7) != "UNKNOWN") 

			{
			BOOL value_tests_passed;

			if(expr_info_expected[i].value.Mid(0, 7) == "ADDRESS")
				
				{
				value_tests_passed = ValueIsAddress(expr_info_actual[i].value);

				// is extra data besides address expected? (ex. peek at string)
				if(expr_info_expected[i].value != "ADDRESS")
				
					{
					// user must supply extra data to avoid CString assert.
					EXPECT(expr_info_expected[i].value.GetLength() > 8);

					// make sure actual string is long enough so we avoid CString assert.
					if(expr_info_actual[i].value.GetLength() > 10)
					{
						// verify extra data is correct.
						if(expr_info_actual[i].value.Mid(10) ==  (" " + expr_info_expected[i].value.Mid(8)))
							value_tests_passed=TRUE;	
					}
					else
						// actual string wasn't long enough to contain extra data.
						value_tests_passed = FALSE;
					}
				}	 
	
			else	
				value_tests_passed = expr_info_actual[i].value == expr_info_expected[i].value;

			if(!value_tests_passed)
				
				{
				m_pLog->RecordFailure("ERROR in ExprInfoIs(): value is %s instead of %s", 
									  expr_info_actual[i].value, expr_info_expected[i].value);

				return FALSE;
				}
			}
		}

	return TRUE;
	}


BOOL CDebugTestSet::ValueIsAddress(CString str)
	{
	return (str.Mid(0, 2) == "0x") && 
		   (str.Mid(2).SpanIncluding("0123456789abcdef").GetLength() == 8);
	}


void CDebugTestSet::LogTestHeader(LPCSTR test_desc_str)
	{
	m_pLog->RecordInfo("");
	m_pLog->RecordInfo("");
	m_pLog->RecordInfo("TEST: %s", test_desc_str);
	}

void CDebugTestSet::VerifyLocalsWndString(LPCSTR strType, LPCSTR strName,  LPCSTR strValue, int lineNumber)
{
	uivar.Activate();
	EXPECT_TRUE(uivar.SetPane(PANE_LOCALS) == ERROR_SUCCESS);

	EXPR_INFO expr_info;
	uivar.GetAllFields(&expr_info, lineNumber, 1);
	CString csType = expr_info.type;
	CString csName = expr_info.name;
	CString csValue = expr_info.value;


	WriteLog( (csType == strType && csName == strName && 
		csValue.Find(strValue) >= 0) ? PASSED : FAILED,
		"Current Locals line: \"%s %s %s \" Expectation: \"%s %s %s \"", 
		(LPCSTR)csType, (LPCSTR)csName, (LPCSTR)csValue, 
		(LPCSTR)strType, (LPCSTR)strName, (LPCSTR)strValue );

	// return focus from locals window.
	MST.DoKeys("{ESC}");
}

BOOL CDebugTestSet::LocalsWndStringIs(LPCSTR strType, LPCSTR strName,  LPCSTR strValue, int lineNumber)
{
	uivar.Activate();
	EXPECT_TRUE(uivar.SetPane(PANE_LOCALS) == ERROR_SUCCESS);
	BOOL ret = FALSE;

	EXPR_INFO expr_info;
	if(uivar.GetAllFields(&expr_info, lineNumber, 1)!=ERROR_SUCCESS)
		return FALSE;
	if(strcmp(strType, expr_info.type)==0 &&
	   strcmp(strName, expr_info.name)==0 &&
	   strstr(strValue,expr_info.value)!=NULL)
		ret = TRUE;

	return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\automate\autodbg.h ===
///////////////////////////////////////////////////////////////////////////////
//	autodbg.h
//
//	Created by : MichMa		Date: 9-17-96			
//		VCBU QA
//
//	Description :
//		Declaration of the CAutomationIDETest Class
//

#ifndef __AUTODBG_H__
#define __AUTODBG_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\dbgset.h"
#include "autosub.h"

///////////////////////////////////////////////////////////////////////////////
//	CDebuggerAutomationIDETest class

class CDebuggerAutomationIDETest : public CDebugTestSet
	{
		DECLARE_TEST(CDebuggerAutomationIDETest, CAutomationSubSuite)

	// Operations
	public:
		virtual void PreRun(void);
		virtual void Run(void);
	};

#endif //__AUTODBG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\automate\autorec.h ===
///////////////////////////////////////////////////////////////////////////////
//	autorec.h
//
//	Created by : MichMa		Date: 9-17-96			
//		VCBU QA
//
//	Description :
//		Declaration of the CRecordingAutomationIDETest Class
//

#ifndef __AUTOREC_H__
#define __AUTOREC_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\dbgset.h"
#include "autosub.h"

///////////////////////////////////////////////////////////////////////////////
//	CRecordingAutomationIDETest class

class CRecordingAutomationIDETest : public CDebugTestSet
	{
		DECLARE_TEST(CRecordingAutomationIDETest, CAutomationSubSuite)

	// Operations
	public:
		virtual void PreRun(void);
		virtual void Run(void);
	};

#endif //__AUTOREC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\automate\autorec.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	autorec.cpp
//											 
//	Created by : MichMa		Date: 9-17-96			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "autorec.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
IMPLEMENT_TEST(CRecordingAutomationIDETest, CDebugTestSet, "Macro Recording", -1, CAutomationSubSuite)
					   
											 
void CRecordingAutomationIDETest::PreRun(void)
	{
	// call the base class
	CTest::PreRun();
	}


void CRecordingAutomationIDETest::Run(void)
	
	{
	/******************
	 * INITIALIZATION *
	 ******************/
	if(!InitProject("automate", PROJECT_EXE, fBuildOnly))
		{
		m_pLog->RecordInfo("ERROR: could not init automate project");
		return;
		}

	/*********
	 * TESTS *
	 *********/
	// TODO(michma): use cafe macro class (COMacro?) when available.
	GetSubSuite()->LoadMacroFile();
	GetSubSuite()->RunMacro("MacroRecordingTest");
	// TODO(michma): use cafe output class (COOutput?) when available.
	GetSubSuite()->WriteOutputWindowToLog();
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\automate\autosub.h ===
///////////////////////////////////////////////////////////////////////////////
//	autosub.h
//
//	Created by : MichMa		Date: 9-17-96			
//		VCBU QA
//
//	Description :
//		Declaration of the CAutomationSubSuite class
//

#ifndef __AUTOSUB_H__
#define __AUTOSUB_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CAutomationSubSuite class

class CAutomationSubSuite : public CIDESubSuite
	{
	public:
		DECLARE_SUBSUITE(CAutomationSubSuite)
		DECLARE_TESTLIST()
	public:
		BOOL fProjectReady;
		void CleanUp(void);
		void LoadMacroFile(void);
		void RunMacro(LPCSTR macro);
		void WriteOutputWindowToLog(void);
		void CloseWorkspaceAndCreateOptionsFile(void);
	};

#endif //__AUTOSUB_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\automate\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\automate\autosub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	autosub.cpp
//
//	Created by : MichMa		Date: 9-17-96			
//		VCBU QA		
//
//	Description :
//		implementation of the CAutomationSubSuite class
//

#include "stdafx.h"
#include "autosub.h"
#include "afxdllx.h"
#include "..\cleanup.h"

#include "autodbg.h"
#include "autobps.h"
#include "autobp.h"
#include "autorec.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CAutomationSubSuite

IMPLEMENT_SUBSUITE(CAutomationSubSuite, CIDESubSuite, "Automation", "VCQA Debugger")

BEGIN_TESTLIST(CAutomationSubSuite)
	TEST(CDebuggerAutomationIDETest, RUN)
	TEST(CBreakpointsAutomationIDETest, RUN)
	//TEST(CBreakpointAutomationIDETest, RUN)
	//TEST(CRecordingAutomationIDETest, RUN)
END_TESTLIST()


void CAutomationSubSuite::CleanUp(void)
	{
	fProjectReady = FALSE;
	::CleanUp();
	}


void CAutomationSubSuite::LoadMacroFile(void)
	{
	// load macro file
	MST.DoKeys("%tc");
	MST.WFndWndWait("Customize", FW_DEFAULT, 10);
	MST.DoKeys("^({PGDN})");
	MST.DoKeys("^({PGDN})");
	MST.DoKeys("^({PGDN})");
	MST.DoKeys("^({PGDN})");
	MST.WFndWndWaitC("Browse...", "BUTTON", FW_DEFAULT, 10);
	MST.WButtonClick("Browse...");													  
	MST.WFndWndWait("Browse for Macro File or add-in", FW_DEFAULT, 10);
	MST.WEditSetText("@1", "automate.dsm");
	MST.DoKeys("{ENTER}");
	MST.WFndWndWaitC("OK", "BUTTON", FW_DEFAULT, 10);
	MST.WButtonClick("OK");		// in case macro is already loaded
	MST.WButtonClick("Close");
	}


void CAutomationSubSuite::RunMacro(LPCSTR macro)
	{
	MST.DoKeys("%tm");
	MST.WFndWndWaitC("OK", "BUTTON", FW_DEFAULT, 3);
	MST.WButtonClick("OK");		// in case macro file needs to be reloaded
	MST.WFndWndWait("Macro", FW_DEFAULT, 10);
	MST.WComboItemClk("@2", "automate");
	MST.DoKeys("%a");
	MST.DoKeys(macro);
	MST.WButtonClick("Run");

	// macro will throw user exception when done
	if(!MST.WFndWndWaitC("MACRO HAS FINISHED", "Static", FW_PART, 180))
		m_pLog->RecordFailure("THE MACRO DID NOT FINISH WITHIN 3 MINUTES");
		
	MST.WButtonClick("No");
	}


void CAutomationSubSuite::WriteOutputWindowToLog(void)
	{
	UIOutput OutputWnd;
	OutputWnd.Activate();
	MST.DoKeys("^({PGDN})");
	MST.DoKeys("^({PGDN})");
	MST.DoKeys("^({PGDN})");
	MST.DoKeys("^({HOME})");
	MST.DoKeys("+(^({END}))");
	MST.DoKeys("^(c)");
	CString cstrOutputWnd;
	GetClipText(cstrOutputWnd);
	
	if(cstrOutputWnd.Find("FAIL") != -1)
		m_pLog->RecordFailure("THERE IS A FAILURE IN THE FOLLOWING OUTPUT");
	
	m_pLog->RecordInfo("\n%s", cstrOutputWnd);
	}


void CAutomationSubSuite::CloseWorkspaceAndCreateOptionsFile(void)
	{
	// TODO(michma): we need to create a workspace options file for automate
	// via cafe because the vbs project object doesn't support such creation.
	// however, cafe doesn't have a close function that supports this so we
	// need to use ms-test.
	MST.DoKeys("%fk");
	MST.WFndWndWaitC("Yes", "BUTTON", FW_DEFAULT, 3);
	MST.WButtonClick("Yes");
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\bp\bp1cases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	BP1CASES.CPP
//
//	Created by :			Date :
//		YefimS			11/21/93
//
//	Description :
//		Implementation of the BP1Cases
//

#include <process.h>
#include "stdafx.h"
#include "bpcase.h"	

///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////

BOOL CbpIDETest::BreakAtLine(  )
{
 	LogTestHeader( "BreakAtLine" );
	UIBreakpoints bpd;

	CString strSource = "bp__cc.c";
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource );

	CString strLine = "105";
	int nLine = 105;
	CString strLocation = (CString)"{," + strSource + ",}." + strLine;
	EXPECT( src.GoToLine(nLine) );
	DoKeys( KEY_TOGGLE_BREAKPOINT );
	bpd.Activate();
	EXPECT_TRUE_COMMENT( bpd.BreakpointIsSet(strLine, strSource), "F9 * Source Inactive * at line 105" );
	EXPECT( bpd.Close() == NULL );
	EXPECT_TRUE_COMMENT( dbg.Go(NULL, "us = (ushort)counter;"), "F9 * Source Inactive * Break at BP" );

	strLine = "109";
	nLine = 109;
	strLocation = (CString)"{," + strSource + ",}." + strLine;
	EXPECT( src.GoToLine(nLine) );
	DoKeys( KEY_TOGGLE_BREAKPOINT );
	bpd.Activate();
	EXPECT_TRUE_COMMENT( bpd.BreakpointIsSet(strLine, strSource), "F9 * Source Active * at line 109" );
	EXPECT( bpd.Close() == NULL );
	EXPECT_TRUE_COMMENT( dbg.Go(NULL, "d  = (double)counter;"), "F9 * Source Active * Break at BP" );
	
	bps.ClearAllBreakpoints();
	strSource = "bp__ll.c";
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource );
	strLine = "108";
	nLine = 108;
	strLocation = (CString)"{," + strSource + ",}@" + strLine;
	bps.SetBreakpoint(strLocation);
	bpd.Activate();
	EXPECT_TRUE_COMMENT( bpd.BreakpointIsSet(strLine, strSource), "BPDlg * Source Inactive * at line 108" );
	EXPECT( bpd.Close() == NULL );
	EXPECT_TRUE_COMMENT( dbg.Go(NULL, "ul = (ulong)counter;"), "BPDlg * Source Inactive * Break at BP" );
	
	strLine = "125";
	nLine = 125;
	strLocation = (CString)"{," + strSource + ",}@" + strLine;
	bps.SetBreakpoint(strLocation);
	bpd.Activate();
	EXPECT_TRUE_COMMENT( bpd.BreakpointIsSet(strLine, strSource), "BPDlg * Source Active * at line 125" );
	EXPECT( bpd.Close() == NULL );
	EXPECT_TRUE_COMMENT( dbg.Go(NULL, "pun->ul = (ulong)counter;"), "BPDlg * Source Active * Break at BP" );

	dbg.StopDebugging();
	return (TRUE);
}

BOOL CbpIDETest::Disable_Enable()
{
 	LogTestHeader( "Disable_Enable" );
	bps.ClearAllBreakpoints();
	CString strSource = "bp__ll.c";
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource );

	CString strLine = "106";
	CString strLocation = (CString)"{," + strSource + ",}@" + strLine;
	bp *pbp = bps.SetBreakpoint(strLocation);

	UIBreakpoints bpd;
	bpd.Activate();
	EXPECT_TRUE( bpd.BreakpointIsSet(strLine, strSource) );

	bpd.Disable();
	EXPECT_TRUE_COMMENT ( !bpd.BreakpointIsEnabled(strLine, strSource), "Disable BP : at line 106 in bp__ll.c" );

	bpd.Enable();
	EXPECT_TRUE_COMMENT ( bpd.BreakpointIsEnabled(strLine, strSource), "Enable BP : at line 106 in bp__ll.c" );

	EXPECT( bpd.Close() == NULL );
	EXPECT_TRUE_COMMENT( dbg.Go(NULL, "us = (ushort)counter;"), "Break at enabled BP" );

	bpd.Activate();
	bpd.Disable();
	EXPECT_TRUE_COMMENT ( !bpd.BreakpointIsEnabled(strLine, strSource), "Disable BP again: 106" );
	EXPECT( bpd.Close() == NULL );

	bps.ClearAllBreakpoints();
	strLine = "108";
	strLocation = (CString)"{," + strSource + ",}@" + strLine;
	pbp = bps.SetBreakpoint(strLocation);

	bpd.Activate();
	bpd.Disable();
	EXPECT_TRUE_COMMENT ( !bpd.BreakpointIsEnabled(strLine, strSource), "Disable BP : at line 108 in bp__ll.c" );

	EXPECT( bpd.Close() == NULL );
	EXPECT_TRUE_COMMENT ( dbg.Go(NULL,NULL,NULL,WAIT_FOR_TERMINATION) , "The Project testbp01 was run" );

	bpd.Activate();
	bpd.Enable();
	EXPECT_TRUE_COMMENT ( bpd.BreakpointIsEnabled(strLine, strSource), "Enable BP : at line 108 in bp__ll.c" );
	EXPECT( bpd.Close() == NULL );
	EXPECT_TRUE_COMMENT( dbg.Go(NULL, "ul = (ulong)counter;"), "Break at enabled BP: 108" );

	dbg.StopDebugging();
	return (TRUE);
}

BOOL CbpIDETest::BreakOnExpressionStaticVars()
{
 	LogTestHeader( "BreakOnExpressionStaticVars" );
	bps.ClearAllBreakpoints();
	dbg.Restart();

	EXPECT_TRUE( bps.SetBreakOnExpr("{recur_func}x==7", COBP_TYPE_IF_EXP_TRUE) != NULL );
	dbg.Go(NULL,NULL,NULL,0);
	if( WaitMsgBoxText("Break when '{recur_func}x==7'", 280) )
	{
		WriteLog( PASSED, "The MsgBox \"Break when '{recur_func}x==7'\" was found as expected" );
		// REVIEW(michma - 6/3/99): there is this weird problem on w2k where the data breakpoint hit msg box
		// isn't active right away. doesn't repro manually, only when Go is performed through cafe.
		// so we need to reactivate the IDE for the OK button to become active so we can dismiss the dlg.
		UIWB.Activate();
		MST.WButtonClick( "OK" );
		while(MST.WButtonExists("OK"));
		EXPECT_TRUE_COMMENT( TRUE, "BreakOnExprTrue" );	 	
	}
	else
	{
		WriteLog( FAILED, "The MsgBox \"Break when '{recur_func}x==7'\" was not found" );
		EXPECT_TRUE( FALSE );	 	
	}
	EXPECT_TRUE( dbg.CurrentLineIs( "if (x<9) recur_func();" ) );
	EXPECT_TRUE( cxx.ExpressionValueIs("x==7",1) );

	EXPECT_TRUE( bps.SetBreakOnExpr("{recur_func}x", COBP_TYPE_IF_EXP_CHANGED) != NULL );
	dbg.Go(NULL,NULL,NULL,0);
	if( WaitMsgBoxText("Break when '{recur_func}x'", 280) )
	{
		WriteLog( PASSED, "The MsgBox \"Break when '{recur_func}x'\" was found as expected" );
		// REVIEW(michma - 6/3/99): there is this weird problem on w2k where the data breakpoint hit msg box
		// isn't active right away. doesn't repro manually, only when Go is performed through cafe.
		// so we need to reactivate the IDE for the OK button to become active so we can dismiss the dlg.
		UIWB.Activate();
		MST.WButtonClick( "OK" );
		while(MST.WButtonExists("OK"));
		EXPECT_TRUE_COMMENT( TRUE, "BreakOnExprChanged" );	 	
	}
	else
	{
		WriteLog( FAILED, "The MsgBox \"Break when '{recur_func}x'\" was not found" );
		EXPECT_TRUE( FALSE );	 	
	}
	EXPECT_TRUE( cxx.ExpressionValueIs("x==8",1) );

	dbg.Go(NULL,NULL,NULL,0);
	if( WaitMsgBoxText("Break when '{recur_func}x'", 280) )
	{
		WriteLog( PASSED, "The MsgBox \"Break when '{recur_func}x'\" was found as expected" );
		// REVIEW(michma - 6/3/99): there is this weird problem on w2k where the data breakpoint hit msg box
		// isn't active right away. doesn't repro manually, only when Go is performed through cafe.
		// so we need to reactivate the IDE for the OK button to become active so we can dismiss the dlg.
		UIWB.Activate();
		MST.WButtonClick( "OK" );
		while(MST.WButtonExists("OK"));
		EXPECT_TRUE_COMMENT( TRUE, "BreakOnExprChanged" );	 	
	}
	else
	{
		WriteLog( FAILED, "The MsgBox \"Break when '{recur_func}x'\" was not found" );
		EXPECT_TRUE( FALSE );	 	
	}
	EXPECT_TRUE( dbg.CurrentLineIs( "if (x<9) recur_func();" ) );
	EXPECT_TRUE( cxx.ExpressionValueIs("x==9",1) );

	EXPECT_TRUE( dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION) );
	
	return (TRUE);
}

BOOL CbpIDETest::BreakOnCompoundExpression()
{
 	LogTestHeader( "BreakOnCompoundExpression" );
	bps.ClearAllBreakpoints();
 	dbg.Restart();

	EXPECT_TRUE( bps.SetBreakOnExpr("{TestG}(Global*Local+Int/3)==1", COBP_TYPE_IF_EXP_TRUE) != NULL );
	dbg.Go(NULL,NULL,NULL,0);

	if( WaitMsgBoxText("Break when '{TestG}(Global*Local+Int/3)==1'", 280) )
	{
		WriteLog( PASSED, "The MsgBox \"Break when '{TestG}(Global*Local+Int/3)==1'\" was found as expected" );
		// REVIEW(michma - 6/3/99): there is this weird problem on w2k where the data breakpoint hit msg box
		// isn't active right away. doesn't repro manually, only when Go is performed through cafe.
		// so we need to reactivate the IDE for the OK button to become active so we can dismiss the dlg.
		UIWB.Activate();
		MST.WButtonClick( "OK" );
		while(MST.WButtonExists("OK"));
		EXPECT_TRUE_COMMENT( TRUE, "BreakOnExprTrue" );	 	
	}
	else
	{
		WriteLog( FAILED, "The MsgBox \"Break when '{TestG}(Global*Local+Int/3)==1'\" was not found" );
		EXPECT_TRUE( FALSE );	 	
	}
	EXPECT_TRUE( dbg.CurrentLineIs( "for (Int=0; Int < ArrayLength; Int++)" ) );
	EXPECT_TRUE( cxx.ExpressionValueIs("(Global*Local+Int/3)==1",1) );

	dbg.StopDebugging();
	return (TRUE);
}

BOOL CbpIDETest::BreakAtVirtualFunc()
{
 	LogTestHeader( "BreakAtVirtualFunc" );
	bps.ClearAllBreakpoints();

	bps.SetBreakpoint("fooclass::vf1");
	bps.SetBreakpoint("fooclass::vf2");
	bps.SetBreakpoint("base::vf2");
	bps.SetBreakpoint("base::vf3");

	EXPECT_TRUE( dbg.Go(NULL, "void vf1() { int i = 7; };", "fooclass::vf1") );
	EXPECT_TRUE( dbg.Go(NULL, "virtual int  vf2() { return 10; };", "base::vf2") );
	EXPECT_TRUE( dbg.Go(NULL, "int  vf2(int j) { return j; };", "fooclass::vf2") );
	EXPECT_TRUE( dbg.Go(NULL, "virtual int  vf3(int ind) { return ind*2; };", "base::vf3") );

	dbg.StopDebugging();
	return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\bp\bpcase.h ===
///////////////////////////////////////////////////////////////////////////////
//	bpcase.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CbpIDETest Class
//

#ifndef __bpcase_H__
#define __bpcase_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\dbgset.h"
#include "bpsub.h"

///////////////////////////////////////////////////////////////////////////////
//	CbpIDETest class

class CbpIDETest : public CDebugTestSet
{
	DECLARE_TEST(CbpIDETest, CbpSubSuite)

// Attributes
public:

// Operations
public:  
	virtual void PreRun(void);
	virtual void Run();

protected:  // Test Cases
	// BP1Cases
	BOOL BreakAtLine(  );
	BOOL Disable_Enable(  );
	BOOL BreakOnExpressionStaticVars(  );
	BOOL BreakOnCompoundExpression(  );
	BOOL BreakAtVirtualFunc(  );

	// BP2Cases
	// for the static child
	BOOL BPTable(  );
	BOOL LocationBPWithExp(  );
	BOOL MessageBP(  );
	BOOL BreakStepTrace(  );   // stepping, tracing, breakpoints

};

#endif //__bpcase_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\bp\bpcase2.h ===
///////////////////////////////////////////////////////////////////////////////
//	bpcase.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the Cbp2IDETest Class
//

#ifndef __bpcase2_H__
#define __bpcase2_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\dbgset.h"
#include "bpsub.h"

///////////////////////////////////////////////////////////////////////////////
//	CbpIDETest class

class Cbp2IDETest : public CDebugTestSet
{
	DECLARE_TEST(Cbp2IDETest, CbpSubSuite)

// Attributes
public:

// Operations
public:  
	virtual void PreRun(void);
	virtual void Run();

protected:  // Test Cases

	// BP2Cases
	// for the child w/dll's
	BOOL BreakDLLInit(  );
	BOOL BPTableDLL(  );
	BOOL LoadDLLBreak(  );
};

#endif //__bpcase2_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\bp\bpcase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	bpcase.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "bpcase.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
											   
IMPLEMENT_TEST(CbpIDETest, CDebugTestSet, "Breakpoints base", -1, CbpSubSuite)
												 
void CbpIDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();

}

void CbpIDETest::Run()
{
	XSAFETY;
  
	if( SetProject("testbp01\\testbp01") )
	{	  
		XSAFETY;
		BreakAtLine();
		XSAFETY;
		Disable_Enable();
		XSAFETY;
	}
 
	// breakpoints against example x
	// TODO: use coproject to see if it is already open.
	if ( SetProject("dbg\\dbg") )
	{
		XSAFETY;
		StartDebugging();

		EXPECT_TRUE(BPTable());
		XSAFETY;
		EXPECT_TRUE(LocationBPWithExp());
		XSAFETY;
		if(GetUserTargetPlatforms() != PLATFORM_MAC_68K && 
			GetUserTargetPlatforms() != PLATFORM_MAC_PPC)
		{
			EXPECT_TRUE(MessageBP());
			XSAFETY;
		}
		EXPECT_TRUE(BreakStepTrace());
		XSAFETY;
	}
	//	StopDbgCloseProject();
	//	Sleep(1000);
 	
	if( SetProject("testgo01\\testgo01") )
	{	  
		XSAFETY;
		BreakOnExpressionStaticVars();
		XSAFETY;
		BreakOnCompoundExpression();
		XSAFETY;
	}

	if( SetProject("dbga\\dbga") )
	{	  
		XSAFETY;
		BreakAtVirtualFunc();
		XSAFETY;
	}
		
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\bp\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\bp\bp2cases.cpp ===
/*
** BREAK.CPP
**
**	Created by :			Date :
**		waltcr				8/14/94
**
**	Description :
**		breakpoint tests
*/


#include "stdafx.h"
#include "bpcase.h"	
#include "bpcase2.h"	

#if defined(_MIPS_) || defined(_ALPHA_)
#define _CHAIN_2 "chain_2"
#define _CHAIN_3 "chain_3"
#else
#define _CHAIN_2 "_chain_2"
#define _CHAIN_3 "_chain_3"
#endif

int UI2COBP( int x );


///////////////////////////////////////////////////////////////////////////////
//	Test Cases

/*
** Some tests lumped together.  Some involve different level of debug
** information or without debug information.  Also a test or two
** involving step/stepout and breakpoints.
** 
*/

BOOL CbpIDETest::BreakStepTrace(   )
{ 	
 	LogTestHeader( "BreakStepTrace" );

	bp *bp;
	BOOL fOkay = TRUE;
	
	bps.ClearAllBreakpoints();
	dbg.StopDebugging();
	bp=bps.SetBreakpoint("WndProc");
	dbg.Go();  								// execute to function WndProc 
	EXPECT_TRUE ( fOkay &= dbg.AtSymbol("WndProc") );	
	dbg.StepOver(); 						// Step past prolog
	bps.ClearAllBreakpoints();
	bp = bps.SetBreakpoint("TagCallChainMain"); 	// set breakpoint on label
	dbg.Go();  								// execute to bp at label
	EXPECT_TRUE ( fOkay &= dbg.AtSymbol("{WndProc}TagCallChainMain") );
	EXPECT_TRUE ( fOkay &= dbg.StepInto(1,"ChainMain") );
	EXPECT_TRUE ( fOkay &= bps.SetBreakpoint("chain_4") != NULL );
	EXPECT_TRUE ( fOkay &= bps.SetBreakpoint("chain_5") != NULL );
	dbg.Go();
	EXPECT_TRUE( fOkay &= dbg.AtSymbol("chain_4"));
	
	// attempt to step out but fire on breakpoint in nested function call
	// proper location is chain_5
	EXPECT_TRUE_COMMENT ( fOkay &= dbg.StepOut(1, NULL, NULL, "chain_5"), "Break in nested function" );

	dbg.StepInto();
	EXPECT_TRUE ( fOkay &= dbg.StepOut(1, NULL, NULL, "chain_4") );
	EXPECT_TRUE ( fOkay &= dbg.StepOut(1, NULL, NULL, "chain_3") );

	dbg.StopDebugging();
	return fOkay;
}									


/* 
** Execute a number of breakpoint tests defined in a table.
**
*/

BOOL CbpIDETest::BPTable(   )
{	
 	LogTestHeader( "BPTable" );

	BOOL fSuccess = TRUE;

	enum UIType	{ 
				UIBP_TYPE_LOC=1,
				UIBP_TYPE_LOC_IF_EXP_TRUE,
				UIBP_TYPE_LOC_IF_EXP_CHANGED,
				UIBP_TYPE_IF_EXP_TRUE,
				UIBP_TYPE_IF_EXP_CHANGED,
				UIBP_TYPE_WNDPROC_IF_MSG_RECVD 
				}; 

	struct CBreak
	{	
		BOOL fStopDbg;
		BOOL fRestart;
		char *szSymbol;
		char *szExpr;
		int Length;
		UIType Type;
		char *szVerifyWithOtherSymbol;
		char *szVerifyWithOtherExpr;
		BOOL fClear;
		//hmm, consider adding a verify current frame
		//hmmh, consider adding an int to execute n times.
		//hmmm, consider adding a pointer to func arg to call before setting
		//hmmm, consider adding a pointer to func to call after hitting bp.
		//hmmm, consider adding a description field
	} rgBreak[] = { // stop, restart, symbol, expr, length, type, verify_symbol, verify_expr, clear
/*pass*/			TRUE, FALSE, "WinMain", NULL, 0, UIBP_TYPE_LOC, NULL, NULL, TRUE,
/*pass*/			TRUE, FALSE, "WndProc", NULL, 0, UIBP_TYPE_LOC, NULL, NULL, TRUE,
/*pass*/			FALSE, FALSE, "chain_1", NULL, 0, UIBP_TYPE_LOC, NULL, NULL, FALSE,
/*pass*/			FALSE, FALSE, _CHAIN_2, NULL, 0, UIBP_TYPE_LOC, NULL, NULL, FALSE,
/*pass*/			FALSE, FALSE, _CHAIN_3, NULL, 0, UIBP_TYPE_LOC, NULL, NULL, FALSE,
/*pass*/			FALSE, FALSE, "chain_4", NULL, 0, UIBP_TYPE_LOC, NULL, NULL, TRUE,
/*pass*/			FALSE, FALSE, "chain_5", NULL, 0, UIBP_TYPE_LOC, NULL, NULL, FALSE,
/*pass*/		 	TRUE, FALSE, "{BPWithLengthTest}BREAK", "gi[0]", 3, UIBP_TYPE_LOC_IF_EXP_CHANGED, NULL, "*(gi+2)==99", FALSE,
/*pass*/		 	FALSE, FALSE, "{foo2}START", "{foo2}paramA>2", 0, UIBP_TYPE_LOC_IF_EXP_TRUE, "{foo2}START", NULL, FALSE,
					// add additional breakpoints above this line
					FALSE, FALSE, NULL, NULL, 0, UIBP_TYPE_LOC, NULL, NULL, FALSE
					};


	CBreak *rgbp = rgBreak;
	bp *ThisBP;
	int iErrCount = 0;

	bps.ClearAllBreakpoints();

	while ((rgbp->szSymbol != NULL) || (rgbp->szExpr != NULL))
	{

		if (rgbp->fStopDbg)
			dbg.StopDebugging();

		switch (rgbp->Type)
		{	
				case UIBP_TYPE_LOC:
					ThisBP = bps.SetBreakpoint(rgbp->szSymbol);
					break;
				case UIBP_TYPE_LOC_IF_EXP_TRUE:
				case UIBP_TYPE_LOC_IF_EXP_CHANGED:
					if (rgbp->Length != 0)
						ThisBP = bps.SetBreakOnExpr(rgbp->szSymbol,	rgbp->szExpr, UI2COBP(rgbp->Type), rgbp->Length);
					else
						ThisBP = bps.SetBreakOnExpr(rgbp->szSymbol,	rgbp->szExpr, UI2COBP(rgbp->Type));
					break;
				case UIBP_TYPE_IF_EXP_TRUE:
				case UIBP_TYPE_IF_EXP_CHANGED:
					if (rgbp->Length != 0)
						ThisBP = bps.SetBreakOnExpr(rgbp->szExpr, UI2COBP(rgbp->Type), rgbp->Length);
					else
						ThisBP = bps.SetBreakOnExpr(rgbp->szExpr, UI2COBP(rgbp->Type)-4);
					break;
				case UIBP_TYPE_WNDPROC_IF_MSG_RECVD:
					ThisBP = bps.SetBreakOnMsg(
						rgbp->szSymbol, 
						rgbp->szExpr);
					break;
		}

		fSuccess = (ThisBP != NULL);
		if (fSuccess)
		{

			if (rgbp->fRestart)
				dbg.Restart();
	
			dbg.Go();

			// verification 
			// REVIEW: TODO: write better pass/fail messsages!


			fSuccess &= (dbg.GetDebugState() != NotDebugging);
			if (fSuccess && (rgbp->szVerifyWithOtherSymbol != NULL))
			{
				fSuccess &= dbg.AtSymbol(rgbp->szVerifyWithOtherSymbol);
				if (!fSuccess)
					m_pLog->RecordFailure("Not at location \'%s\'", rgbp->szVerifyWithOtherSymbol);
			}
			else if (fSuccess && (rgbp->szSymbol != NULL))
			{
				fSuccess &= dbg.AtSymbol(rgbp->szSymbol);
				if (!fSuccess)
					m_pLog->RecordFailure("Not at bp location \'%s\'", rgbp->szSymbol);
			}
			if ( fSuccess && (rgbp->Type != UIBP_TYPE_WNDPROC_IF_MSG_RECVD) && (rgbp->szVerifyWithOtherExpr != NULL) )
			{
				fSuccess &= cxx.ExpressionValueIs(rgbp->szVerifyWithOtherExpr,1);
			}
			else if ( fSuccess && (rgbp->Type != UIBP_TYPE_WNDPROC_IF_MSG_RECVD) && (rgbp->szExpr != NULL)  )
			{
				fSuccess &= cxx.ExpressionValueIs(rgbp->szExpr, 1);
			}

			// cleanup
			if (rgbp->fClear)
				bps.RemoveBreakpoint(ThisBP);
			else
				bps.DisableBreakpoint(ThisBP);
		}

		WriteLog( fSuccess ? PASSED : FAILED, "breakpoint: loc='%s', exp='%s' ... ", rgbp->szSymbol, rgbp->szExpr);
		if (!fSuccess)
			iErrCount++;

		rgbp++;
	}
	
	return (iErrCount==0);
}


BOOL CbpIDETest::MessageBP(   )
{
 	LogTestHeader( "MessageBP" );

	BOOL fSuccess = TRUE;
	int count;

	/* 
	** attempt Breakpoint when message received.
	*/

	bps.ClearAllBreakpoints();

	EXPECT_TRUE( fSuccess &= (bps.SetBreakOnMsg("WndProc","WM_CREATE") != NULL) );

	dbg.Restart();
	dbg.Go();
	EXPECT_TRUE(fSuccess &= dbg.AtSymbol("WndProc"));

	// try to make sure we broke on the correct message
	count=0;
	int countNumber = 25;
	do 
	{
		count++;
		dbg.StepOver();
	} while( (count < countNumber) && (!dbg.AtSymbol("TagCreateCase")));

	EXPECT_TRUE_COMMENT ( (fSuccess &= dbg.AtSymbol("TagCreateCase")),  "Break on WM_CREATE message")

	return fSuccess;
}

BOOL CbpIDETest::LocationBPWithExp(   )
{	
 	LogTestHeader( "LocationBPWithExp" );

	BOOL fSuccess = TRUE;

	bps.ClearAllBreakpoints();
	dbg.Restart();
	if (bps.SetBreakOnExpr(
		"{foo}END",
		"Global==3",
		COBP_TYPE_IF_EXP_TRUE) == FALSE)
	{
		fSuccess = FALSE;
		m_pLog->RecordFailure("Unable to set location breakpoint w/expression");
	}
	else if (dbg.Go("END",NULL, "foo") == FALSE)
	{
		fSuccess = FALSE;
		m_pLog->RecordFailure("Not at expected location");
	}

	return fSuccess;
}

int UI2COBP(int x)
{
	switch(x)
	{
		case UIBP_TYPE_LOC_IF_EXP_TRUE:
		case UIBP_TYPE_LOC_IF_EXP_CHANGED:
			return x-2;
			
		case UIBP_TYPE_IF_EXP_TRUE:
		case UIBP_TYPE_IF_EXP_CHANGED:
			return x-4;
	}
	return 0;
}


/*
** Break at DllMain() which is executed early i.e. at DLL_PROCESS_ATTACH
**
*/

BOOL Cbp2IDETest::BreakDLLInit(   )
{
 	LogTestHeader( "BreakDLLInit" );

	BOOL bOkay = TRUE;

	dbg.StopDebugging();
	bps.ClearAllBreakpoints();

	EXPECT_TRUE ( bOkay &= (bps.SetBreakpoint("{,,dec2.dll}DllEntryPoint") != NULL) );
	if (bOkay)
	{
		EXPECT_TRUE ( bOkay &= ( dbg.Go() && dbg.VerifyAtSymbol("{,,dec2.dll}DllEntryPoint") ) );
		bps.ClearAllBreakpoints();
	}

#if 0
	// at restart would be semi-interesting too
	FALSE, TRUE, "{,,dec2.dll}DllEntryPoint", NULL, 0, UIBP_TYPE_LOC, NULL, NULL, TRUE,  // hit bp during restart
	TRUE, FALSE, "{,,incdll.dll}DllMain", NULL, 0, UIBP_TYPE_LOC, NULL, NULL, FALSE,
	// how about a virtual dll?
#endif 

	return bOkay;	// WriteLog( bOkay, GetTestDesc() );
}


BOOL Cbp2IDETest::LoadDLLBreak(   )
{
 	LogTestHeader( "LoadDLLBreak" );
	BOOL bOkay = TRUE;
//	bp *ThisBP;

	bps.ClearAllBreakpoints();
	dbg.StopDebugging();
	dbg.StepInto(4);

	EXPECT_TRUE ( bOkay &= (proj.SetAdditionalDLLs("powdll.dll") != ERROR_SUCCESS) );
	if( bOkay )
		dbg.StepInto(4);
/*	if (proj.SetAdditionalDLLs("powdll.dll") != ERROR_SUCCESS)
	{
		m_pLog->RecordFailure("unable to set additional dlls");
		bOkay = FALSE;
	}
	else
	{
	// REVIEW (michma): cannot currently load dll symbols while debugging (menu limitation).
	// however, since proj.SetAdditionalDLLs isn't working yet either, we need
	// to start debugging to load dll symbols to get this test to finish.
	 dbg.StepInto(4);
	}
*/
	EXPECT_TRUE ( bOkay &= (proj.SetAdditionalDLLs("powdll.dll") != ERROR_SUCCESS) );
	if( bOkay )
	{
		EXPECT_TRUE ( bOkay &= (bps.SetBreakpoint("dPow") != NULL) );
		if( bOkay )
		{
			EXPECT_TRUE ( bOkay &= (dbg.Go() && dbg.VerifyAtSymbol("dPow")) );
			bps.ClearAllBreakpoints();
		}
	}
/*	if (proj.SetAdditionalDLLs("powdll.dll") != ERROR_SUCCESS)
	{
		m_pLog->RecordFailure("unable to set additional dlls");
		bOkay = FALSE;
	}
	else
	{
		ThisBP = bps.SetBreakpoint("dPow");
		bOkay &= (ThisBP != NULL);
		if (ThisBP == NULL)
		{
			m_pLog->RecordFailure("unable to set breakpoint after loading symbols");
		}
		else
		{
			dbg.Go();
			if (dbg.VerifyAtSymbol("dPow") == FALSE)
			{
				bOkay &= FALSE;
				m_pLog->RecordFailure("Not at symbol \'%s\'", "dPow" );
			}
			bps.RemoveBreakpoint(ThisBP);
		}
	}
*/
	return bOkay;
}


BOOL Cbp2IDETest::BPTableDLL(   )
{
 	LogTestHeader( "BPTableDLL" );
	BOOL fSuccess = TRUE;

	enum UIType	{ 
				UIBP_TYPE_LOC=1,
				UIBP_TYPE_LOC_IF_EXP_TRUE,
				UIBP_TYPE_LOC_IF_EXP_CHANGED,
				UIBP_TYPE_IF_EXP_TRUE,
				UIBP_TYPE_IF_EXP_CHANGED,
				UIBP_TYPE_WNDPROC_IF_MSG_RECVD 
				}; 

	struct CBreak
	{	
		BOOL fStopDbg;
		BOOL fRestart;
		char *szSymbol;
		char *szExpr;
		int Length;
		UIType Type;
		char *szVerifyWithOtherSymbol;
		char *szVerifyWithOtherExpr;
		BOOL fClear;
		//hmm, consider adding a verify current frame!
		//hmmh, consider adding an int to execute n times.
		//hmmm, consider adding a pointer to func arg to call before setting
		//hmmm, consider adding a pointer to func to call after hitting bp.
		//hmmm, consider adding a description field
	} rgBreak[] = 	{ 
					// stop, restart, symbol, expr, length, type, verify_symbol, verify-expr, clear
/* pass */			TRUE, FALSE, "WinMain", NULL, 0, UIBP_TYPE_LOC, NULL, NULL,  FALSE, 
/* pass */			FALSE, TRUE, "MainWndProc", NULL, 0, UIBP_TYPE_LOC, NULL, NULL, TRUE,
/* pass */			FALSE, FALSE, "MainWndProc", "WM_CREATE", 0, UIBP_TYPE_WNDPROC_IF_MSG_RECVD,  NULL, NULL, FALSE,
/* pass */			TRUE, FALSE, "Dec", NULL, 0, UIBP_TYPE_LOC, NULL, NULL, FALSE, 
/* pass */			FALSE, FALSE, "Inc", NULL, 0, UIBP_TYPE_LOC, NULL, NULL, TRUE,
//					FALSE, TRUE, NULL, "{,,dllappx.exe}wValue", 0, UIBP_TYPE_IF_EXP_CHANGED, NULL, NULL, FALSE,  // TODO: need to be able to check between expressions
/* pass */			TRUE, TRUE, "InitApplication", NULL, 0, UIBP_TYPE_LOC, NULL, NULL, FALSE, 
#if !defined(_ALPHA_) && !defined(_MIPS_)
/* pass bug */	//or#14945 is postponed:		FALSE, FALSE, NULL, "gi[0]", 3, UIBP_TYPE_IF_EXP_CHANGED, "{BPWithLengthTest}BREAK", "*(gi+2)==99", FALSE,
#endif
/* pass */			TRUE, TRUE, "InitInstance", NULL, 0, UIBP_TYPE_LOC, NULL, NULL, TRUE,
/* pass */			FALSE, TRUE, "{MainWndProc,,dllappx.exe}TagEndPaint", "{,,dllappx.exe}hGlobalMem!=0", 0, UIBP_TYPE_LOC_IF_EXP_TRUE, NULL, NULL, FALSE,
/* part a */		TRUE, FALSE, "{Dec,dec2.c,dec2.dll}TagAfterGetProcAddr", NULL, 0, UIBP_TYPE_LOC, NULL, NULL, FALSE,
/* part b */		FALSE, FALSE, "dPow", NULL, 0, UIBP_TYPE_LOC, NULL, NULL, FALSE,
#if !defined(_MIPS_) && !defined(_ALPHA_)
/* pass a,b,c*/	//or#18749:
		// TODO(michma - 1/30/98) - this bp takes longer than 5 minutes to hit, but it hasn't before.
		//TRUE, FALSE, NULL, "{Dec,,dec2.dll}dValue==1000", 0, UIBP_TYPE_IF_EXP_TRUE, "TagAfterPow", "dValue==1000", FALSE,
#endif
/* pass */			TRUE, FALSE, "{,incdll.c,incdll.dll}DllMain", NULL, 0, UIBP_TYPE_LOC, NULL, NULL, FALSE,
//					TRUE, FALSE, NULL, "{DllEntryPoint,,dec2.dll}ulRbc==0", 0, UIBP_TYPE_IF_EXP_TRUE, NULL, "ulRbc==0", FALSE,
					// add additional breakpoints above this line
					FALSE, FALSE, NULL, NULL, 0, UIBP_TYPE_LOC, NULL, NULL, FALSE
					};


	CBreak *rgbp = rgBreak;
	bp *ThisBP;
	int iErrCount = 0;


	bps.ClearAllBreakpoints();

	/* 
	** for portability the following bp tests had to be isolated.
	** attempt Breakpoint when expression true.
	** attempt Breakpoint when expression changed.
	** attempt Breakpoint on global expression.
	** attempt Breakpoint on local expression.
	*/

	while ((rgbp->szSymbol != NULL) || (rgbp->szExpr != NULL))
	{

		if (rgbp->fStopDbg)
			dbg.StopDebugging();

		switch (rgbp->Type)
		{	
				case UIBP_TYPE_LOC:
					ThisBP = bps.SetBreakpoint(rgbp->szSymbol);
					break;
				case UIBP_TYPE_LOC_IF_EXP_TRUE:
				case UIBP_TYPE_LOC_IF_EXP_CHANGED:
					if (rgbp->Length != 0)
						ThisBP = bps.SetBreakOnExpr(rgbp->szSymbol,	rgbp->szExpr, UI2COBP(rgbp->Type), rgbp->Length);
					else
						ThisBP = bps.SetBreakOnExpr(rgbp->szSymbol,	rgbp->szExpr, UI2COBP(rgbp->Type));
					break;
				case UIBP_TYPE_IF_EXP_TRUE:
				case UIBP_TYPE_IF_EXP_CHANGED:
					if (rgbp->Length != 0)
						ThisBP = bps.SetBreakOnExpr(rgbp->szExpr, UI2COBP(rgbp->Type), rgbp->Length);
					else
						ThisBP = bps.SetBreakOnExpr(rgbp->szExpr, UI2COBP(rgbp->Type));
					break;
				case UIBP_TYPE_WNDPROC_IF_MSG_RECVD:
					ThisBP = bps.SetBreakOnMsg(
						rgbp->szSymbol, 
						rgbp->szExpr);
					break;
		}

		
		fSuccess = (ThisBP != NULL);
		if (fSuccess)
		{
			if (rgbp->fRestart)
				dbg.Restart();
	
			dbg.Go();

			// verification 
			fSuccess &= (dbg.GetDebugState() != NotDebugging);
			if (fSuccess && (rgbp->szVerifyWithOtherSymbol != NULL))
			{
				fSuccess &= dbg.AtSymbol(rgbp->szVerifyWithOtherSymbol);
				if (!fSuccess)
					m_pLog->RecordFailure("Not at symbol \'%s\'", rgbp->szVerifyWithOtherSymbol);
			}
			else if (fSuccess && (rgbp->szSymbol != NULL))
			{
				fSuccess &= dbg.AtSymbol(rgbp->szSymbol);
				if (!fSuccess)
					m_pLog->RecordFailure("Not at bp symbol \'%s\'", rgbp->szSymbol);
			}
			if ( fSuccess && (rgbp->Type != UIBP_TYPE_WNDPROC_IF_MSG_RECVD) && (rgbp->szVerifyWithOtherExpr != NULL) )
			{
				fSuccess &= cxx.ExpressionValueIs(rgbp->szVerifyWithOtherExpr,1);
			}
			else if ( fSuccess && (rgbp->Type != UIBP_TYPE_WNDPROC_IF_MSG_RECVD) && (rgbp->szExpr != NULL) )
			{
				fSuccess &= cxx.ExpressionValueIs(rgbp->szExpr, 1);
			}

			// cleanup
			if (rgbp->fClear)
				bps.RemoveBreakpoint(ThisBP);
			else
				bps.DisableBreakpoint(ThisBP);
		}
		WriteLog( fSuccess ? PASSED : FAILED, "breakpoint: loc='%s', exp='%s' ... ", rgbp->szSymbol, rgbp->szExpr);
		if (!fSuccess)
			iErrCount++;

		rgbp++;
	}
	
	
	return (iErrCount==0);	// WriteLog( iErrCount==0, GetTestDesc() );
}


// TODO?

/* 
** attempt to step over function but which fires on a message bp.
*/


/* 
** test Breakpoint at line location.
*/


/* 
** test Breakpoint at func location in primary module.
*/


/* 
** attempt Breakpoint at location when expression changed.
*/


/* 
** test Breakpoint on expression involving static.
*/


/* 
** test Breakpoint on expression involving both local and global.
*/


/* 
** test Breakpoint when expression true with length.
*/


/* 
** attempt Breakpoint when class of message received.
*/


#if 0
/*
** while executing child, set breakpoint which will fire.
*/
	dbg.Go(NOWAIT);
	bps.SetBreakpoint(some location );
#endif


#if 0


/*
** two step_out's, first hitting bp, second should return
*/
	bps.ClearAllBreakpoints();
	dbg.Restart();
	bps.SetBreakOnExpr("{MyPostMessage,,}TagPost","count>1",COBP_TYPE_IF_EXP_TRUE);
	dbg.Go();
	EXPECT_TRUE( dbg.AtSymbol("TagPost"));
#endif

	
/* 
** attempt Breakpoint at func location in secondary module.
*/


/* 
** attempt to step over function but which fires on a message bp.
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\bp\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\bp\bpcase2.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	bpcase.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "bpcase2.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
											   
IMPLEMENT_TEST(Cbp2IDETest, CDebugTestSet, "Breakpoints DLLs", -1, CbpSubSuite)
												 
void Cbp2IDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();

}

void Cbp2IDETest::Run()
{
	XSAFETY;

	if (SetProject("dllapp\\incdll", PROJECT_DLL, fBuildOnly) && SetProject("dllapp\\powdll", PROJECT_DLL, fBuildOnly)
		&& SetProject("dllapp\\dec2", PROJECT_DLL, fBuildOnly) && SetProject("dllapp\\dllappx"))
	{	
		XSAFETY;
		// when makefile is wrapped, wrapper name is dllappx1.mak and exe for debug session 
		// becomes dllappx1.exe, so we must	change it back since we actually build dllappx.exe.
		proj.SetExeForDebugSession("dllappx.exe");

		// dllappx builds 4 files: incdll.dll, dec2.dll, powdll.dll and dllappx.exe.
		// dllappx.exe is copied to remote by SetProject, but we need to do dlls.
		COConnection *pconnec = GetSubSuite()->GetIDE()->GetConnectionInfo();
		if(pconnec->GetUserConnections() != CONNECTION_LOCAL)
		{
			proj.UpdateRemoteFile("src\\dllapp\\incdll.dll");
			proj.UpdateRemoteFile("src\\dllapp\\dec2.dll");
			proj.UpdateRemoteFile("src\\dllapp\\powdll.dll");
		}

		StartDebugging();

		EXPECT_TRUE(BreakDLLInit());
		XSAFETY;
		EXPECT_TRUE(BPTableDLL());	   //bug#14945	postponed: one test is disabled
		XSAFETY;
		// TODO: WinslowF - Load additianal dlls does not work at this time. Need to rewrite the func.
		//	EXPECT_TRUE(LoadDLLBreak());
		//	XSAFETY;
		
		StopDbgCloseProject();
	}

	else
		m_pLog->RecordFailure("Could not initiate incdll, powdll, dec2, or dllappx projects.");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\bp\bpsub.h ===
///////////////////////////////////////////////////////////////////////////////
//	bpsub.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CbpSubSuite class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CbpSubSuite class

class CbpSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CbpSubSuite)
//	CbpSubSuite() { m_strName = "TestWizard Generated script"; m_strOwner = "VCBU QA"; }


	DECLARE_TESTLIST()
protected:
	void CleanUp(void);
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\bp\bpsub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CbpSubSuite class
//

#include "stdafx.h"
#include "bpsub.h"
#include "afxdllx.h"
#include "..\cleanup.h"

#include "bpcase.h"
#include "bpcase2.h"
#include "bpcase3.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


/////////////////////////////////////////////////////////////////////////////
// CbpSubSuite

IMPLEMENT_SUBSUITE(CbpSubSuite, CIDESubSuite, "Breakpoint", "VCQA Debugger")

BEGIN_TESTLIST(CbpSubSuite)
	TEST(CbpIDETest, RUN)
	TEST(Cbp2IDETest, RUN)
	TEST(CBp3Cases, RUN)
END_TESTLIST()

void CbpSubSuite::CleanUp(void)
	{
	::CleanUp("testbp01");
	::CleanUp("testgo01");
	::CleanUp("dbg");
	::CleanUp("dbga");
	::CleanUp("bp3");
	}

///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\crashdump\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\crashdump\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\bp\bpcase3.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	BPCASE3.CPP
//											 
//	Created by:			Date:			
//		MichMa				10/10/97	
//
//	Description:								 
//		Implementation of CBp3Cases		 

#include "stdafx.h"
#include "bpcase3.h"
#include "..\cleanup.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
			 	 
											   
IMPLEMENT_TEST(CBp3Cases, CDebugTestSet, "Breakpoints Pri2", -1, CbpSubSuite)


// each function that runs a test has this prototype.
typedef void (CBp3Cases::*PTR_TEST_FUNC)(void); 

// we randomly pick out of the following list of tests and run them.
// insert functions for new tests to the end of the list.
PTR_TEST_FUNC tests[] = {
	&CBp3Cases::BreakOnGlobalConstructorAndRestart,
	&CBp3Cases::BreakOnFunctionContainingScopeOperator,
	&CBp3Cases::BreakOnOverloadedSymbolSetBeforeStartDebugging,
	&CBp3Cases::BreakOnOverloadedSymbolSetAfterStartDebugging,
	&CBp3Cases::StepOverFunctionThatHitsBp,
	&CBp3Cases::BreakWhenAggregateExpressionChanges,
	&CBp3Cases::BreakOnMultipleBreakpoints,
	&CBp3Cases::BreakOnDllFuncThatWasUnloadedAfterSettingBp,
	&CBp3Cases::CompareGlobalAndLocalDataBpPerformance,
	&CBp3Cases::StepOutOfFunctionThatHitsBp,
	&CBp3Cases::StepToCursorThatHitsBp,
	&CBp3Cases::HitBpInDllSetBeforeStartDebugging,
	&CBp3Cases::HitBpInDllSetAfterStartDebugging,
	&CBp3Cases::HitLocationBpInExeSetWhileDebuggeeRunning,
	&CBp3Cases::HitLocationBpInDllSetWhileDebuggeeRunning,
	&CBp3Cases::HitDataBpInExeSetWhileDebuggeeRunning,
	&CBp3Cases::EditBpCodeWhenSourceIsInForeground,
	&CBp3Cases::EditBpCodeWhenSourceIsOpenButNotInForeground,
	&CBp3Cases::EditBpCodeWhenSourceIsNotOpen,
	// TODO(michma): re-enable when bug vs98:36090 is fixed.
	//&CBp3Cases::EditBpCodeWhenInputIsRequiredToFindSource,
	&CBp3Cases::HitBpWithPassCount,
	&CBp3Cases::HitBpAfterInterruptingPassCountAndRestarting,
	&CBp3Cases::HitBpSetInStack,
	&CBp3Cases::RemoveBpSetInStack,
	&CBp3Cases::HitBpWhenInputRequiredToFindSource
};


void CBp3Cases::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}


void CBp3Cases::Run()

{
	// the base name of the localized directories and files we will use.
	if(GetSystem() & SYSTEM_DBCS)
		m_strProjBase = "[\\]^{|}Aa`@~ breakpoints pri2";
	else
		m_strProjBase = "breakpoints pri2";

	// the location of the unlocalized sources, under which the projects we will use will be located.
	m_strSrcDir = GetCWD() + "src\\breakpoints pri2";
	// the locations of the dll and exe projects, and their localized sources, that we will use for this test.
	m_strDllDir = m_strSrcDir + "\\" + m_strProjBase + " dll";
	m_strExeDir = m_strSrcDir + "\\" + m_strProjBase + " exe";

	// clean-up the dll project from the last run.
	OurKillFile(m_strDllDir + "\\Debug\\", "*.*");
	RemoveDirectory(m_strDllDir + "\\Debug");
	OurKillFile(m_strDllDir + "\\", "*.*");
	RemoveDirectory(m_strDllDir);

	// set the options for the dll project we are building for this test.
	CProjWizOptions *pWin32DllWizOpt = new(CWin32DllWizOptions);
	pWin32DllWizOpt->m_strLocation = m_strSrcDir;
	pWin32DllWizOpt->m_strName = m_strProjBase + " dll";	
	
	// create the dll project.
	EXPECT_SUCCESS(proj.New(pWin32DllWizOpt));
	// create a new localized dll source file in the project dir from the unlocalized dll source file.
	CopyFile(m_strSrcDir + "\\" + "breakpoints pri2 dll.cpp", m_strDllDir + "\\" + m_strProjBase + " dll.cpp", FALSE);
	// this appears to be a win32 timing problem. when running the test over the net, the server seems to keep the file 
	// locked even after CopyFile returns. an immediate call to SetFileAttributes will fail with a sharing violation.
	// so we wait a second here to make sure the server is totally finished processing the CopyFile request.
	Sleep(1000);
	// make it writable so it can be cleaned up later.
	SetFileAttributes(m_strDllDir + "\\" + m_strProjBase + " dll.cpp", FILE_ATTRIBUTE_NORMAL);
	// add the source to the project.
	EXPECT_SUCCESS(proj.AddFiles(m_strProjBase + " dll.cpp"));
	// build and close the project.
	EXPECT_SUCCESS(proj.Build());
	EXPECT_SUCCESS(proj.Close());

	// clean-up the exe project from the last run.
	OurKillFile(m_strExeDir + "\\Debug\\", "*.*");
	RemoveDirectory(m_strExeDir + "\\Debug");
	OurKillFile(m_strExeDir + "\\", "*.*");
	RemoveDirectory(m_strExeDir);

	// set the options for the exe project we are building for this test.
	CProjWizOptions *pWin32AppWizOpt = new(CWin32AppWizOptions);
	pWin32AppWizOpt->m_strLocation = m_strSrcDir;
	pWin32AppWizOpt->m_strName = m_strProjBase + " exe";	
	
	// create the exe project.
	EXPECT_SUCCESS(proj.New(pWin32AppWizOpt));
	// create a new localized exe source file in the project dir from the unlocalized exe source file.
	CopyFile(m_strSrcDir + "\\" + "breakpoints pri2 exe.cpp", m_strExeDir + "\\" + m_strProjBase + " exe.cpp", FALSE);
	// make it writable so it can be cleaned up later.
	SetFileAttributes(m_strExeDir + "\\" + m_strProjBase + " exe.cpp", FILE_ATTRIBUTE_NORMAL);
	// add the source to the project.
	EXPECT_SUCCESS(proj.AddFiles(m_strProjBase + " exe.cpp"));
	// build the project.
	EXPECT_SUCCESS(proj.Build());

	// copy the dll and its symbols to the same dir as the exe so it can load it out of the current directory.
	CopyFile(m_strDllDir + "\\Debug\\" + m_strProjBase + " dll.dll", 
			 m_strExeDir + "\\Debug\\" + m_strProjBase + " dll.dll", FALSE);

	// cpuinf32.dll is a tool used by some tests to identify CPU speed and compensate for it.
	// move it to the same dir as the exe so it can load it out of the current directory.
	CopyFile(m_strSrcDir + "\\" + "Cpuinf32.dll", m_strExeDir + "\\Debug\\" + "Cpuinf32.dll", FALSE);
	// make sure it's writable so we can clean up later!
	SetFileAttributes(m_strExeDir + "\\Debug\\" + "Cpuinf32.dll", FILE_ATTRIBUTE_NORMAL);
	
	
	// all tests expect the ide to be in this initial state.
	EXPECT_TRUE(dbg.Restart());
	// we only want to randomly run each test once.
	RandomNumberCheckList rncl(sizeof(tests) / sizeof(PTR_TEST_FUNC));
	// indexes into the test function array.
	int iTest;
	
	// randomly run each test once.
	while((iTest = rncl.GetNext()) != -1)
		(this->*(tests[iTest]))();
}


void CBp3Cases::BreakOnGlobalConstructorAndRestart(void)
{	
	LogTestHeader("BreakOnGlobalConstructorAndRestart");
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_VALIDBP(bps.SetBreakpoint("CBase::CBase"));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of CBase::CBase()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("CBase::CBase"));
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of CBase::CBase()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("CBase::CBase"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of WinMain()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("WinMain"));
}


// note that the <class>::<function> case is covered by BreakOnGlobalConstructorAndRestart(), so we only
// have to test global functions with scope operators here.
void CBp3Cases::BreakOnFunctionContainingScopeOperator(void)
{  
	LogTestHeader("BreakOnFunctionContainingScopeOperator");
	EXPECT_VALIDBP(bps.SetBreakpoint("::Func"));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of Func()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("Func"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	EXPECT_TRUE(dbg.Restart()); 
}


void CBp3Cases::BreakOnOverloadedSymbolSetBeforeStartDebugging(void)
{
	LogTestHeader("BreakOnOverloadedSymbolSetBeforeStartDebugging");
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_VALIDBP(bps.SetBreakpoint("OverloadedFunc"));
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, NOWAIT));
	EXPECT_TRUE(dbg.ResolveAmbiguity(1));
	EXPECT_TRUE(dbg.Wait(WAIT_FOR_BREAK));
	EXPECT_TRUE(dbg.CurrentLineIs("first line of OverloadedFunc(void)"));
	EXPECT_TRUE(stk.CurrentFunctionIs("OverloadedFunc()"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	EXPECT_TRUE(dbg.Restart()); 
}


void CBp3Cases::BreakOnOverloadedSymbolSetAfterStartDebugging(void)
{
	LogTestHeader("BreakOnOverloadedSymbolSetAfterStartDebugging");
	EXPECT_VALIDBP(bps.SetAmbiguousBreakpoint("OverloadedFunc", 2));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of OverloadedFunc(int)"));
	EXPECT_TRUE(stk.CurrentFunctionIs("OverloadedFunc(int 1)"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	EXPECT_TRUE(dbg.Restart()); 
}


void CBp3Cases::StepOverFunctionThatHitsBp(void)
{
	LogTestHeader("StepOverFunctionThatHitsBp");
	EXPECT_TRUE(src.Find("Func();"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(src.Find("first line of Func()"));
	EXPECT_VALIDBP(bps.SetBreakpoint());
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of Func()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("Func"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION));
	EXPECT_TRUE(dbg.Restart()); 
}


void CBp3Cases::BreakWhenAggregateExpressionChanges(void)
{
	LogTestHeader("BreakWhenAggregateExpressionChanges");
	EXPECT_VALIDBP(bps.SetBreakOnExpr("gCBaseObj", COBP_TYPE_IF_EXP_CHANGED));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("gCBaseObj change"));
	EXPECT_TRUE(stk.CurrentFunctionIs("WinMain"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	EXPECT_TRUE(dbg.Restart()); 
}


void CBp3Cases::BreakOnMultipleBreakpoints(void)
{
	LogTestHeader("BreakOnMultipleBreakpoints");
	EXPECT_TRUE(src.Find("multiple breakpoints hit"));
	EXPECT_VALIDBP(bps.SetBreakpoint());
	EXPECT_TRUE(src.Find("init iLocal in Func()"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_VALIDBP(bps.SetBreakOnExpr("iGlobal + iLocal == 2", COBP_TYPE_IF_EXP_TRUE));
	EXPECT_VALIDBP(bps.SetBreakOnExpr("iGlobal", COBP_TYPE_IF_EXP_CHANGED));
	EXPECT_VALIDBP(bps.SetBreakpoint("MultipleBreakpointsHitLabel"));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(cxx.ExpressionValueIs("iGlobal + iLocal", 2));
	EXPECT_TRUE(dbg.CurrentLineIs("multiple breakpoints hit"));
	EXPECT_TRUE(stk.CurrentFunctionIs("Func"));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("multiple breakpoints hit"));
	EXPECT_TRUE(stk.CurrentFunctionIs("Func"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	// TODO(michma): we need to do this extra step because of bug 38172.
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(dbg.Restart()); 
}


void CBp3Cases::BreakOnDllFuncThatWasUnloadedAfterSettingBp(void)
{
	LogTestHeader("BreakOnDllFuncThatWasUnloadedAfterSettingBp");
	EXPECT_TRUE(src.Find("FreeLibrary(hDll)"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_VALIDBP(bps.SetBreakpoint("DllFunc"));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of DllFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("DllFunc"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	EXPECT_TRUE(dbg.Restart()); 
}


void CBp3Cases::CompareGlobalAndLocalDataBpPerformance(void)
{
	LogTestHeader("CompareGlobalAndLocalDataBpPerformance");
	EXPECT_TRUE(src.Find("for(i = 0; i < iLoopNum; i++)"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_VALIDBP(bps.SetBreakOnExpr("iLocal", COBP_TYPE_IF_EXP_CHANGED));
	time_t timeStart = time(NULL);
	EXPECT_TRUE(dbg.Go());
	int timeLocalBp = time(NULL) - timeStart;
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	EXPECT_TRUE(dbg.Restart()); 
	EXPECT_TRUE(src.Find("for(i = 0; i < iLoopNum; i++)"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_VALIDBP(bps.SetBreakOnExpr("iGlobal", COBP_TYPE_IF_EXP_CHANGED));
	timeStart = time(NULL);
	EXPECT_TRUE(dbg.Go());
	int timeGlobalBp = time(NULL) - timeStart;
	EXPECT_TRUE(timeLocalBp > timeGlobalBp);
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	// TODO(michma): we need to do this extra step because of bug 38172.
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(dbg.Restart()); 
}


void CBp3Cases::StepOutOfFunctionThatHitsBp(void)
{
	LogTestHeader("StepOutOfFunctionThatHitsBp");
	EXPECT_TRUE(src.Find("first line of Func()"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(src.Find("line within Func()"));
	EXPECT_VALIDBP(bps.SetBreakpoint());
	EXPECT_TRUE(dbg.StepOut());
	EXPECT_TRUE(dbg.CurrentLineIs("line within Func()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("Func"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION));
	EXPECT_TRUE(dbg.Restart()); 
}


void CBp3Cases::StepToCursorThatHitsBp(void)
{
	LogTestHeader("StepToCursorThatHitsBp");
	EXPECT_TRUE(src.Find("first line of Func()"));
	EXPECT_VALIDBP(bps.SetBreakpoint());
	EXPECT_TRUE(src.Find("line within Func()"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of Func()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("Func"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION));
	EXPECT_TRUE(dbg.Restart()); 
}


void CBp3Cases::HitBpInDllSetBeforeStartDebugging(void)
{
	LogTestHeader("HitBpInDllSetBeforeStartDebugging");
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_SUCCESS(proj.SetAdditionalDLLs("Debug\\" + m_strProjBase + " dll.dll"));
	EXPECT_VALIDBP(bps.SetBreakpoint("DllFunc"));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of DllFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("DllFunc"));
	EXPECT_TRUE(dbg.Restart()); 	
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of DllFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("DllFunc"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	EXPECT_SUCCESS(proj.RemoveAdditionalDLLs(1));
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_TRUE(dbg.Restart()); 	
}


void CBp3Cases::HitBpInDllSetAfterStartDebugging(void)
{
	LogTestHeader("HitBpInDllSetAfterStartDebugging");
	EXPECT_SUCCESS(proj.SetAdditionalDLLs("Debug\\" + m_strProjBase + " dll.dll"));
	EXPECT_VALIDBP(bps.SetBreakpoint("DllFunc"));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of DllFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("DllFunc"));
	EXPECT_TRUE(dbg.Restart()); 	
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of DllFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("DllFunc"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	EXPECT_SUCCESS(proj.RemoveAdditionalDLLs(1));
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_TRUE(dbg.Restart()); 	
}


void CBp3Cases::HitLocationBpInExeSetWhileDebuggeeRunning(void)
{
	LogTestHeader("HitLocationBpInExeSetWhileDebuggeeRunning");
	EXPECT_TRUE(cxx.SetExpressionValue("giDelay", 60));
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, NOWAIT));
	EXPECT_TRUE(src.Find("line within WinMain()"));
	EXPECT_VALIDBP(bps.SetBreakpoint());
	EXPECT_TRUE(dbg.Wait(WAIT_FOR_BREAK));
	EXPECT_TRUE(dbg.CurrentLineIs("line within WinMain()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("WinMain"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	EXPECT_TRUE(dbg.Restart()); 	
}


void CBp3Cases::HitLocationBpInDllSetWhileDebuggeeRunning(void)
{
	LogTestHeader("HitLocationBpInDllSetWhileDebuggeeRunning");
	EXPECT_TRUE(cxx.SetExpressionValue("giDelay", 60));
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, NOWAIT));
	EXPECT_SUCCESS(proj.SetAdditionalDLLs("Debug\\" + m_strProjBase + " dll.dll"));
	EXPECT_VALIDBP(bps.SetBreakpoint("DllFunc"));
	EXPECT_TRUE(dbg.Wait(WAIT_FOR_BREAK));
	EXPECT_TRUE(dbg.CurrentLineIs("first line of DllFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("DllFunc"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	EXPECT_SUCCESS(proj.RemoveAdditionalDLLs(1));
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_TRUE(dbg.Restart()); 	
}


void CBp3Cases::HitDataBpInExeSetWhileDebuggeeRunning(void)
{
	LogTestHeader("HitDataBpInExeSetWhileDebuggeeRunning");
	EXPECT_TRUE(cxx.SetExpressionValue("giDelay", 60));
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, NOWAIT));
	EXPECT_VALIDBP(bps.SetBreakOnExpr("iGlobal == 100", COBP_TYPE_IF_EXP_TRUE));
	EXPECT_TRUE(dbg.Wait(WAIT_FOR_BREAK));
	EXPECT_TRUE(cxx.ExpressionValueIs("iGlobal", 100));
	EXPECT_TRUE(dbg.CurrentLineIs("iGlobal = 100"));
	EXPECT_TRUE(stk.CurrentFunctionIs("WinMain"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	// TODO(michma): we need to do this extra step because of bug 38172.
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(dbg.Restart()); 	
}


void CBp3Cases::EditBpCodeWhenSourceIsInForeground(void)
{
	LogTestHeader("EditBpCodeWhenSourceIsInForeground");
	bp *pBp = bps.SetBreakpoint("Func");
	EXPECT_TRUE(bps.EditCode(pBp));
	EXPECT_TRUE(dbg.CurrentLineIs("first line of Func()"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
}


void CBp3Cases::EditBpCodeWhenSourceIsOpenButNotInForeground(void)
{
	LogTestHeader("EditBpCodeWhenSourceIsOpenButNotInForeground");
	bp *pBp = bps.SetBreakpoint("Func");
	EXPECT_SUCCESS(src.Create());
	EXPECT_TRUE(bps.EditCode(pBp));
	EXPECT_TRUE(dbg.CurrentLineIs("first line of Func()"));
	EXPECT_SUCCESS(src.Close());
	EXPECT_TRUE(bps.ClearAllBreakpoints());
}


void CBp3Cases::EditBpCodeWhenSourceIsNotOpen(void)
{
	LogTestHeader("EditBpCodeWhenSourceIsNotOpen");
	bp *pBp = bps.SetBreakpoint("Func");
	EXPECT_SUCCESS(src.AttachActive());
	EXPECT_SUCCESS(src.Close());
	EXPECT_TRUE(bps.EditCode(pBp));
	EXPECT_TRUE(dbg.CurrentLineIs("first line of Func()"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
}


void CBp3Cases::EditBpCodeWhenInputIsRequiredToFindSource(void)
{
	LogTestHeader("EditBpCodeWhenInputIsRequiredToFindSource");
	bp *pBp = bps.SetBreakpoint("Func");
	EXPECT_SUCCESS(src.AttachActive());
	EXPECT_SUCCESS(src.Close());
	// need to create a unique directory for moving source in this test, because if source
	// has already been 'found' at the same location by previous test of
	// HitBpWhenInputRequiredToFindSource, no 'Find Source' dialog will be displayed!
	CreateDirectory("\\EditBpCodeWhenInputIsRequiredToFindSource",  NULL);
	EXPECT_TRUE(MoveFile(m_strExeDir + "\\" + m_strProjBase + " exe.cpp", "\\EditBpCodeWhenInputIsRequiredToFindSource\\" + m_strProjBase + " exe.cpp"));
	EXPECT_TRUE(bps.EditCode(pBp, "\\EditBpCodeWhenInputIsRequiredToFindSource"));
	EXPECT_TRUE(dbg.CurrentLineIs("first line of Func()"));
	EXPECT_SUCCESS(src.AttachActive());
	EXPECT_SUCCESS(src.Close());
	EXPECT_TRUE(MoveFile("\\EditBpCodeWhenInputIsRequiredToFindSource\\" + m_strProjBase + " exe.cpp", m_strExeDir + "\\" + m_strProjBase + " exe.cpp"));
	RemoveDirectory("\\EditBpCodeWhenInputIsRequiredToFindSource");
	EXPECT_TRUE(bps.EditCode(pBp));
	EXPECT_TRUE(dbg.CurrentLineIs("first line of Func()"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_SUCCESS(proj.Close());
	EXPECT_SUCCESS(proj.Open(m_strExeDir + "\\" + m_strProjBase + " exe.dsp"));
	EXPECT_TRUE(dbg.Restart());
}


void CBp3Cases::HitBpWithPassCount(void)
{
	LogTestHeader("HitBpWithPassCount");
	EXPECT_TRUE(src.Find("line within loop"));
	EXPECT_SUCCESS(src.AttachActive());
	int iLine = src.GetCurrentLine();
	bp *pBp = bps.SetBreakpoint(iLine, NULL, 100);
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("line within loop"));
	EXPECT_TRUE(stk.CurrentFunctionIs("WinMain"));
	EXPECT_TRUE(cxx.ExpressionValueIs("i", 100));
	EXPECT_TRUE(bps.RemainingPassCountIs(pBp, 0));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	EXPECT_TRUE(dbg.Restart());
}


void CBp3Cases::HitBpAfterInterruptingPassCountAndRestarting(void)

{
	LogTestHeader("HitBpAfterInterruptingPassCountAndRestarting");
	EXPECT_TRUE(src.Find("dll loaded"));
	EXPECT_TRUE(dbg.StepToCursor());
	bp *pBp1 = bps.SetBreakpoint("DllFunc", 50);
	EXPECT_TRUE(src.Find("line within loop"));
	bp *pBp2 = bps.SetBreakpoint();
	
	for(int i = 0; i < 5; i++)
		EXPECT_TRUE(dbg.Go());

	EXPECT_TRUE(dbg.CurrentLineIs("line within loop"));
	EXPECT_TRUE(stk.CurrentFunctionIs("WinMain"));
	EXPECT_TRUE(cxx.ExpressionValueIs("i", 4));
	EXPECT_TRUE(bps.RemainingPassCountIs(pBp1, 46));
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(bps.RemainingPassCountIs(pBp1, 50));
	EXPECT_TRUE(bps.RemoveBreakpoint(pBp2));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of DllFunc"));
	EXPECT_TRUE(stk.CurrentFunctionIs("DllFunc"));
	EXPECT_TRUE(bps.RemainingPassCountIs(pBp1, 0));
	EXPECT_TRUE(dbg.StepOut());
	EXPECT_TRUE(cxx.ExpressionValueIs("i", 50));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	EXPECT_TRUE(dbg.Restart());
}


void CBp3Cases::HitBpSetInStack(void)
{
	LogTestHeader("HitBpSetInStack");
	EXPECT_VALIDBP(bps.SetBreakpoint("Func"));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(stk.ToggleBreakpoint(1));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("line after call to Func()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("WinMain"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	EXPECT_TRUE(dbg.Restart());
}


void CBp3Cases::RemoveBpSetInStack(void)
{
	LogTestHeader("RemoveBpSetInStack");
	EXPECT_VALIDBP(bps.SetBreakpoint("Func"));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(stk.ToggleBreakpoint(1));
	EXPECT_TRUE(stk.ToggleBreakpoint(1));
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	EXPECT_TRUE(dbg.Restart());
}


void CBp3Cases::HitBpWhenInputRequiredToFindSource(void)
{
	LogTestHeader("HitBpWhenInputRequiredToFindSource");
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_TRUE(src.Find("line within WinMain()"));
	EXPECT_VALIDBP(bps.SetBreakpoint());
	EXPECT_SUCCESS(src.AttachActive());
	EXPECT_SUCCESS(src.Close());
	// need to create a unique directory for moving source in this test, because if source
	// has already been 'found' at the same location by previous test of
	// EditBpCodeWhenInputIsRequiredToFindSource, no 'Find Source' dialog will be displayed!
	CreateDirectory("\\HitBpWhenInputRequiredToFindSource",  NULL);
	EXPECT_TRUE(MoveFile(m_strExeDir + "\\" + m_strProjBase + " exe.cpp", "\\HitBpWhenInputRequiredToFindSource\\" + m_strProjBase + " exe.cpp"));
	UIWB.m_pTarget->SetHandleMsgs(FALSE); //handle Find Source manually
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, NOWAIT));
	EXPECT_TRUE(dbg.Wait(WAIT_FOR_BREAK, TRUE));
	EXPECT_TRUE(dbg.SupplySourceLocation("\\HitBpWhenInputRequiredToFindSource"));
	UIWB.m_pTarget->SetHandleMsgs(TRUE); //restore automatic handling of Find Source
	EXPECT_TRUE(dbg.CurrentLineIs("line within WinMain()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("WinMain"));
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_SUCCESS(src.AttachActive());
	EXPECT_SUCCESS(src.Close());
	EXPECT_TRUE(MoveFile("\\HitBpWhenInputRequiredToFindSource\\" + m_strProjBase + " exe.cpp", m_strExeDir + "\\" + m_strProjBase + " exe.cpp"));
	RemoveDirectory("\\HitBpWhenInputRequiredToFindSource");
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("line within WinMain()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("WinMain"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_SUCCESS(proj.Close());
	EXPECT_SUCCESS(proj.Open(m_strExeDir + "\\" + m_strProjBase + " exe.dsp"));
	EXPECT_TRUE(dbg.Restart());
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\bp\bpcase3.h ===
///////////////////////////////////////////////////////////////////////////////
//	bpcase3.h
//
//	Created by:			Date:
//		MichMa				10/10/97
//
//	Description :
//		Declaration of the CBp3Cases Class
//

#ifndef __BPCASE3_H__
#define __BPCASE3_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\dbgset.h"
#include "bpsub.h"


///////////////////////////////////////////////////////////////////////////////
//	CBp3Cases class

class CBp3Cases : public CDebugTestSet

{
	DECLARE_TEST(CBp3Cases, CbpSubSuite)

// Data
private:
	// the base name of the localized directories and files we will use.
	CString m_strProjBase;
	// the location of the unlocalized sources, under which the projects we will use will be located.
	CString m_strSrcDir;
	// the locations of the dll and exe projects, and their localized sources, that we will use for this test.
	CString m_strDllDir;
	CString m_strExeDir;

public:

	// Operations
	virtual void PreRun(void);
	virtual void Run();

	// Test Cases
	void BreakOnGlobalConstructorAndRestart(void);
	void BreakOnFunctionContainingScopeOperator(void);
	void BreakOnOverloadedSymbolSetBeforeStartDebugging(void);
	void BreakOnOverloadedSymbolSetAfterStartDebugging(void);
	void StepOverFunctionThatHitsBp(void);
	void BreakWhenAggregateExpressionChanges(void);
	void BreakOnMultipleBreakpoints(void);
	void BreakOnDllFuncThatWasUnloadedAfterSettingBp(void);
	void CompareGlobalAndLocalDataBpPerformance(void);
	void StepOutOfFunctionThatHitsBp(void);
	void StepToCursorThatHitsBp(void);
	void HitBpInDllSetBeforeStartDebugging(void);
	void HitBpInDllSetAfterStartDebugging(void);
	void HitLocationBpInExeSetWhileDebuggeeRunning(void);
	void HitLocationBpInDllSetWhileDebuggeeRunning(void);
	void HitDataBpInExeSetWhileDebuggeeRunning(void);
	void EditBpCodeWhenSourceIsInForeground(void);
	void EditBpCodeWhenSourceIsOpenButNotInForeground(void);
	void EditBpCodeWhenSourceIsNotOpen(void);
	void EditBpCodeWhenInputIsRequiredToFindSource(void);
	void HitBpWithPassCount(void);
	void HitBpAfterInterruptingPassCountAndRestarting(void);
	void HitBpSetInStack(void);
	void RemoveBpSetInStack(void);
	void HitBpWhenInputRequiredToFindSource(void);
};

#endif //__BPCASE3_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\crashdump\CrashDumpSubsuite.h ===
///////////////////////////////////////////////////////////////////////////////
//	CrashDumpSubsuite.h
//
//	Created by: MichMa		Date: 9/30/97
//
//	Description :
//		Declaration of the CCrashDumpSubsuite class
//

#ifndef __CRASHDUMPSUBSUITE_H__
#define __CRASHDUMPSUBSUITE_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CCrashDumpSubsuite class

class CCrashDumpSubsuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CCrashDumpSubsuite)
	DECLARE_TESTLIST()
protected:
	void CleanUp(void);
};

#endif //__CRASHDUMPSUBSUITE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\crashdump\CrashDumpSubsuite.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	CrashDumpSubsuite.cpp
//
//	Created by: MichMa		Date: 9/30/97
//
//	Description :
//		Implementation of the CCrashDumpSubsuite class
//

#include "stdafx.h"
#include "CrashDumpSubsuite.h"
#include "afxdllx.h"
#include "..\cleanup.h"

#include "CrashDumpCases.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CCrashDumpSubsuite

IMPLEMENT_SUBSUITE(CCrashDumpSubsuite, CIDESubSuite, "Crash Dump", "VCQA Debugger")

BEGIN_TESTLIST(CCrashDumpSubsuite)
	TEST(CCrashDumpCases, RUN)
END_TESTLIST()

void CCrashDumpSubsuite::CleanUp(void)
	{
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\crashdump\CrashDumpCases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	CrashDumpCases.cpp
//											 
//	Created by: MichMa			Date: 9/30/97	
//
//	Description:								 
//		Implementation of the CCrashDumpCases class
		 
#include "stdafx.h"
#include "CrashDumpCases.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
IMPLEMENT_TEST(CCrashDumpCases, CDebugTestSet, "Crash Dump", -1, CCrashDumpSubsuite)
									   
												 
void CCrashDumpCases::PreRun(void)

{
	// call the base class
	CTest::PreRun();

}


void CCrashDumpCases::Run(void)

{
	if(!InitProject("crashdump\\crashdump"))
		{
		m_pLog->RecordInfo("ERROR: could not init crashdump project");
		return;
		}

	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_EXCEPTION));
	EXPECT_TRUE(stk.CurrentFunctionIs("dllfunc()"));
	EXPECT_TRUE(stk.FunctionIs("WinMain", 1));
	EXPECT_TRUE(cxx.ExpressionValueIs("zero", 0));
	EXPECT_TRUE(cxx.SetExpressionValue("zero", 1));
	EXPECT_TRUE(mem.MemoryDataIs("zero", 1));
	EXPECT_TRUE(mem.SetMemoryData("zero", 0));
	EXPECT_TRUE(cxx.ExpressionValueIs("zero", 0));
	EXPECT_TRUE(stk.NavigateStack(1));
	EXPECT_TRUE(cxx.ExpressionValueIs("nCmdShow", 1));
	EXPECT_TRUE(stk.NavigateStack(0));
	EXPECT_TRUE(cxx.ExpressionValueIs("zero", 0)); 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\crashdump\CrashDumpCases.h ===
///////////////////////////////////////////////////////////////////////////////
//	CrashDumpCases.h
//
//	Created by: MichMa		Date: 9/30/97
//
//	Description :
//		Declaration of the CCrashDumpCases class
//

#ifndef __CRASHDUMPCASES_H__
#define __CRASHDUMPCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\dbgset.h"
#include "CrashDumpSubsuite.h"

///////////////////////////////////////////////////////////////////////////////
//	CCrashDumpCases class

class CCrashDumpCases : public CDebugTestSet

{
	DECLARE_TEST(CCrashDumpCases, CCrashDumpSubsuite)

	// Operations
	public:
		virtual void PreRun(void);
		virtual void Run(void);

	// Test cases
	private:
};

#endif //__CRASHDUMPCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\disasm\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\disasm\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\disasm\disacase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	DisAcase.CPP
//											 
//	Created by :			
//		dklem
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "DisAcase.h"	
#include "process.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
											   
IMPLEMENT_TEST(/*999,*/ CDisAsmIDETest, CDbgTestBase, "General", -1, CDisAsmSubSuite)

// each function that runs a test has this prototype.
typedef void (CDisAsmIDETest::*PTR_TEST_FUNC)(void); 

// Information about a test to be put in the test header
#define LOGTESTHEADER(strTestName) 	m_strLogInfo.Format("# - %d.  %s. Total # - %d, Passed - %d %%", ++m_TestNumber, strTestName, m_TotalNumberOfTests, (m_TestNumber*100)/m_TotalNumberOfTests);  \
									LogTestHeader(m_strLogInfo);

// we randomly pick out of the following list of tests and run them.
// insert functions for new tests to the end of the list.

PTR_TEST_FUNC tests[] = {
	&CDisAsmIDETest::HitBreakPoint,
	&CDisAsmIDETest::SourceAnnotation,
	&CDisAsmIDETest::GoToSymbol,
	&CDisAsmIDETest::SwitchDAMtoSRCandBack,
	&CDisAsmIDETest::TraceIntoCall,
	&CDisAsmIDETest::SwitchSRCtoDAMMultiInstance,
	&CDisAsmIDETest::GoToMaxMinAddress,
	&CDisAsmIDETest::GoToInvalidAddress,
	// TODO: (dklem 09/10/98) Uncomment the following 1 line when #7924 get fixed. Fixed!
	// TODO: (dklem 12/03/98) Uncomment the following 1 line and write a new code for this test when #11382 fixed.
	//&CDisAsmIDETest::OpenDAMWhileChildIsRunning,
	&CDisAsmIDETest::CodeBytes,
	&CDisAsmIDETest::SetFocusToThread,
	&CDisAsmIDETest::GoToOverloadedSymbol,
	&CDisAsmIDETest::GoAfterScrollDisassemblyWndModified,
	&CDisAsmIDETest::CheckAsmSourceAndDAMConsistency,
	&CDisAsmIDETest::ToolbarToDAMExpression,
	&CDisAsmIDETest::StepIntoStepOver,
	&CDisAsmIDETest::VerifyDockingView,
};


PTR_TEST_FUNC tests_woutcvinfo[] = {
	
	// TODO: (dklem 11/06/98) Uncomment the following line when #9202 is fixed.  Fixed in 8313.4
	&CDisAsmIDETest::HitBreakPointNoCVINFO,
	&CDisAsmIDETest::NavigateStackNoCVINFO,
	&CDisAsmIDETest::PgUpDownCtrlHomeEndNoCVINFO,
	// TODO: (dklem 12/16/98) Uncomment the following 1 line when #12874 is fixed
	&CDisAsmIDETest::SetNextStatementViaCtrlShiftF7NoCVINFO,
	&CDisAsmIDETest::RedisplayingAfterEditingRegistersAndMemoryWindowsNoCVINFO
	
	
};


// holds the asm we expect to see.
CStringArray csDamWindowTextAtTemplateFooLine;

												 
void CDisAsmIDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();

}

void CDisAsmIDETest::Run()
{	 
	/******************
	 * INITIALIZATION *
	 ******************/
	PopulateDamWindowText();

	// the base name of the localized directories and files we will use.
	if(GetSystem() & SYSTEM_DBCS)
		m_strProjBase = "[\\]^{|}Aa`@~ disasm";
	else
		m_strProjBase = "disasm";

	// the location of the unlocalized sources, under which the projects we will use will be located.
	m_strSrcDir = GetCWD() + "src\\disasm";
	// the locations of the dll and exe projects, and their localized sources, that we will use for this test.
	m_strExeDir = m_strSrcDir + "\\" + m_strProjBase + " exe";

	// clean-up the exe project from the last run.
	KillFiles(m_strExeDir + "\\Debug\\", "*.*");
	KillFiles(m_strExeDir + "\\Release\\", "*.*");
	RemoveDirectory(m_strExeDir + "\\Debug");
	RemoveDirectory(m_strExeDir + "\\Release");
	KillFiles(m_strExeDir + "\\", "*.*");
	RemoveDirectory(m_strExeDir);

	// set the options for the exe project we are building for this test.
	CProjWizOptions *pWin32AppWizOpt = new(CWin32AppWizOptions);
	pWin32AppWizOpt->m_strLocation = m_strSrcDir;
	pWin32AppWizOpt->m_strName = m_strProjBase + " exe";	
	
	// create the exe project.
	EXPECT_SUCCESS(prj.New(pWin32AppWizOpt));
	// create a new localized exe source file in the project dir from the unlocalized exe source file.
	CopyFile(m_strSrcDir + "\\" + "disasm.cpp", m_strExeDir + "\\" + m_strProjBase + " exe.cpp", FALSE);
	CopyFile(m_strSrcDir + "\\" + "damthread.c", m_strExeDir + "\\" + "damthread.c", FALSE);
	// make it writable so it can be cleaned up later.
	SetFileAttributes(m_strExeDir + "\\" + m_strProjBase + " exe.cpp", FILE_ATTRIBUTE_NORMAL);
	SetFileAttributes(m_strExeDir + "\\" + "damthread.c", FILE_ATTRIBUTE_NORMAL);
	// add the source to the project.
	EXPECT_SUCCESS(prj.AddFiles(m_strProjBase + " exe.cpp"));
	EXPECT_SUCCESS(prj.AddFiles(m_strExeDir + "\\" + "damthread.c"));
	// build the project.

	// indexes into the test function array.
	int iTest;
	
	EXPECT_SUCCESS(prj.Build());

	// all tests expect the ide to be in this initial state.
	EXPECT_TRUE(dbg.StepOver());
	
	// In the tests it is assumed that the initial DAM window has Docking View turned on
	EXPECT_TRUE(uidam.EnableDockingView(FALSE));
	EXPECT_TRUE(dbg.ToggleSourceAnnotation(TRUE));

	m_TestNumber = 0;
	m_TotalNumberOfTests = sizeof(tests) / sizeof(PTR_TEST_FUNC) + sizeof(tests_woutcvinfo) / sizeof(PTR_TEST_FUNC) + 2;
	// + 2 = 1 (DebugJIT) + 1 (GoAfterScrollDisassemblyWndModified() contains GoToMaxMinAddress() )

	// we only want to randomly run each test once.
	RandomNumberCheckList rncl(sizeof(tests) / sizeof(PTR_TEST_FUNC));

	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));

	// randomly run each test once.
//	while((iTest = rncl.GetNext()) != -1)
	for(iTest = 0; iTest < sizeof(tests) / sizeof(PTR_TEST_FUNC); iTest++)
		(this->*(tests[iTest]))();


	dbg.StopDebugging(ASSUME_NORMAL_TERMINATION) ;

	// Rebuild without cvinfo
	prj.SetTarget((CString)m_strProjBase + " exe - " + 
						GetLocString(IDSS_PLATFORM_WIN32) + " " +
						GetLocString(IDSS_BUILD_RELEASE));

	EXPECT_SUCCESS(prj.Build());

	// all tests expect the ide to be in this initial state.
	EXPECT_TRUE(dbg.StepOver(1, NULL, NULL, NULL, NOWAIT));

	// The tests that checks if the dialog "exe does not contain debugging information ...Show this message [ ]" comes up
	COApplication appRel;
	if(!appRel.Attach("Microsoft Developer Studio", 5))
	{
	//	TODO: (dklem 09/22/98) Uncomment the following 1 line when #6954 gets fixed.  Fixed in 8310.3
		LOG->RecordFailure("The dialog \"exe does not contain debugging information ...Show this message [ ]\" did not come up");
	}
	else
	{
		MST.WCheckCheck("@1");
		// Click OK on the dialog "exe does not contain debugging information ...Show this message [ ]" 
		appRel.SendKeys("{ENTER}");	
	}

	// we only want to randomly run each test once.
	RandomNumberCheckList rncl1(sizeof(tests_woutcvinfo) / sizeof(PTR_TEST_FUNC));

	if(CMDLINE->GetBooleanValue("random", TRUE))
	{
		// randomly run each test once.
		while((iTest = rncl1.GetNext()) != -1)
			(this->*(tests_woutcvinfo[iTest]))();
	}
	else
	{
		// run each test in sequence.
		for(iTest = 0; iTest < sizeof(tests_woutcvinfo) / sizeof(PTR_TEST_FUNC); iTest++)
			(this->*(tests_woutcvinfo[iTest]))();
	}

	dbg.StopDebugging(ASSUME_NORMAL_TERMINATION) ;
	prj.Close();

	//Debug retail exe.  JIT
	// TODO(michma - 10/22/98): re-enable when mc bug 8150 is fixed. manually verify it before re-enabling this test, since
	// bugs like this tend to not be fixed correctly the first time, and this bug hangs up the whole snap run.
	// remember to make the fixed ide your jit debugger when testing.
	//DebugJIT();

}	

///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////

void CDisAsmIDETest::DebugJIT(void)
{
	
	LOGTESTHEADER("DebugJIT");

	CIDESubSuite* pSubSuite=(CIDESubSuite*)GetSubSuite();

	EXPECT_TRUE(ERROR_SUCCESS == src.Open(m_strProjBase + " exe.cpp"));
	EXPECT_TRUE(src.Replace("//int *popa;", "int *popa;", TRUE, TRUE, FALSE, COSource::RS_WHOLEFILE, FALSE));
	EXPECT_TRUE(src.Replace("//*popa = 65700;", "*popa = 65700;", TRUE, TRUE, FALSE, COSource::RS_WHOLEFILE, FALSE));

	// Close the replace dialog
	MST.DoKeys("{ESC}");
	EXPECT_TRUE(ERROR_SUCCESS == prj.RebuildAll());

	// We need to close the project on order to release ncb file.  Otherwise the dialog "... Can not access the Class View file" will come up
	EXPECT_TRUE(ERROR_SUCCESS == prj.Close(FALSE));
	
   	STARTUPINFO siStartInfo;
	PROCESS_INFORMATION piProcInfo;
	// this is the minium initialization of STARTUPINFO required for CreateProcess() to work.
	memset(&siStartInfo, 0, sizeof(STARTUPINFO));
	siStartInfo.cb = sizeof(STARTUPINFO);
	siStartInfo.wShowWindow = SW_SHOWDEFAULT;
	// fully qualified nmake.exe cmd line (cstrDir is directory we found nmake in earlier).
	char chCmdLine[MAX_PATH];
	strcpy(chCmdLine, m_strExeDir + "\\Release\\" + m_strProjBase + " exe.exe");

	// Disable the "EXCEPTION dialog" error message to be written into the Log file
	CIDE* pCIDE = pSubSuite -> GetIDE();
	pCIDE->DisableExceptionMessageHandling();

	// spawn nmake in the project dir.
	BOOL bRet = CreateProcess(NULL, chCmdLine, NULL, NULL, TRUE, NORMAL_PRIORITY_CLASS, NULL,
							  m_strExeDir + "\\Release\\", &siStartInfo, &piProcInfo);

	
	// TODO: (dklem 09/23/98) Change COApplication.Attach() to BOOL CODebug::HandleMsg()
	COApplication appJIT;
	// Wait 20 seconds for the "Application Error" dialog
	if(!appJIT.Attach("disasm exe.exe - Application Error", 20))
	{
		LOG->RecordFailure("The dialog \"disasm exe.exe - Application Error\" did not come up");
		return;
	}

	// Break to debugger
	appJIT.SendKeys("{ESC}");

	// Enable the "EXCEPTION dialog" error message to be written into the Log file
	pCIDE->EnableExceptionMessageHandling();

	// Wait 20 seconds for the JIT
	if(!appJIT.Attach("disasm exe - Microsoft Visual C++ [break]", 20))
		LOG->RecordFailure("The window \"disasm exe - Microsoft Visual C++ [break]\" did not come up");

	// Wait 5 seconds for the dialog "Unhandeled exception in disasm exe.exe ..."
	if(!appJIT.Attach("Microsoft Visual C++", 5))
		LOG->RecordFailure("The dialog \"Unhandeled exception in disasm exe.exe ...\" did not come up");

	appJIT.SendKeys("{ENTER}");

	// Wait a sec to allow the dialog to disappear anf the focus return to DAM
	EXPECT_TRUE(dam.InstructionContains(0, "mov         dword ptr [eax]", FALSE));
	
	// Close the JIT by Alt-F4
	appJIT.SendKeys("%{F4}");
	
	// Wait 5 seconds for the dialog "This command will stop the debugger"
	if(!appJIT.Attach("Microsoft Visual C++", 5))
		LOG->RecordFailure("The dialog \"This command will stop the debugger\" did not come up");

	appJIT.SendKeys("{ENTER}");

	// Wait 5 seconds for the dialog "Do you want to save workspace information ..."
	if(!appJIT.Attach("Microsoft Visual C++", 5))
		LOG->RecordFailure("The dialog \"Do you want to save workspace information ...\" did not come up");

	appJIT.SendKeys("{RIGHT}"); // 'No' Button
	appJIT.SendKeys("{ENTER}");

	dbg.StopDebugging(ASSUME_NORMAL_TERMINATION) ;

	// This is an old string that appeared because of bug 6853.  I left it here just in case (dklem 09/21/98)
	// TerminateProcess(pCIDE->m_procinfoTarget.hProcess, -1);
}


void CDisAsmIDETest::SourceAnnotation(void)
{

	LOGTESTHEADER("SourceAnnotation");

	bool bInitiallyMaximized;

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	int nLinesInDamCode = sizeof(csDamWindowTextAtTemplateFooLine)/sizeof(csDamWindowTextAtTemplateFooLine[0]);

	uidam.Activate();

	// We need to maximize the DAM window to be able to read all csDamWindowTextAtTemplateFooLine[] instructions
	HWND hwnd = uidam.HWnd();

	if(IsZoomed(hwnd))
		bInitiallyMaximized = TRUE;
	else 
	{
		bInitiallyMaximized = FALSE;
		ShowWindow(hwnd, SW_MAXIMIZE);
	}

	// TODO: (dklem 02/04/99) MSTEST doesn't work correctly on W2K.  If we do {DOWN 50} and then {UP 50 }
	// the caret sometimes doesn't return to the same position 
	// so we check just 10 lines
	nLinesInDamCode = 10;

	// Read instrunctions and compare them with csDamWindowTextAtTemplateFooLine[]
	for(int ii = 0; ii < nLinesInDamCode; ii++) 
		EXPECT_TRUE(dam.InstructionContains(ii - 2, csDamWindowTextAtTemplateFooLine[ii], FALSE));

	// Restore the DAM window before restarting
	if(!bInitiallyMaximized)
		ShowWindow(hwnd, SW_RESTORE);

	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));

	// Check that Source annotation off works
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	// Activate and maximize for the next test
	uidam.Activate();
	hwnd = uidam.HWnd();

	if(IsZoomed(hwnd))
		bInitiallyMaximized = TRUE;
	else 
	{
		bInitiallyMaximized = FALSE;
		ShowWindow(hwnd, SW_MAXIMIZE);
	}


	// Turn Source annotation off
	// TODO: (dklem 09/17/98) Uncomment the following 1 line when #6811 gets fixed
	EXPECT_TRUE(uidam.ChooseContextMenuItem(SOURCE_ANNOTATION));

	// Check that there are no Soure code lines.  We assume that each line in csDamWindowTextAtTemplateFooLine[]
	// which begins with space  or \t is a Source code line
	// Read instrunctions and compare them with csDamWindowTextAtTemplateFooLine[]
	for(int jj = ii = 0; jj < nLinesInDamCode; ii++, jj++) 
	{
		// check if this is a Source code line
		while(csDamWindowTextAtTemplateFooLine[jj].GetAt(0) == (char) ' ' || csDamWindowTextAtTemplateFooLine[jj].GetAt(0) ==  '\t') 
			if(++jj >= nLinesInDamCode - 1)
				break;

	// TODO: (dklem 09/17/98) Uncomment the following 2 lines when #6774 gets fixed.  Fixed in 8337.0
			if(jj < nLinesInDamCode)
				EXPECT_TRUE(dam.InstructionContains(ii - 1, csDamWindowTextAtTemplateFooLine[jj], FALSE));

	}

	// Turn Source annotation on
	// TODO: (dklem 09/17/98) Uncomment the following 1 line when #6811 gets fixed
	EXPECT_TRUE(uidam.ChooseContextMenuItem(SOURCE_ANNOTATION));
	EXPECT_TRUE(dam.GotoSymbol("FuncWithArg"));
	EXPECT_TRUE(dam.InstructionContains(-1, "int FuncWithArg(int nArg)", FALSE));

	// Restore the DAM window
	if(!bInitiallyMaximized)
		ShowWindow(hwnd, SW_RESTORE);

	MinimalTestResizeMoveWindow();

	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));

}

void CDisAsmIDETest::GoToSymbol(void)
{
	LOGTESTHEADER("GoToSymbol");

	CString csAddress, InstructionSaved;
	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	dam.Enable();
	// We need this Step Over to locate caret at the current addres
	EXPECT_TRUE(dbg.StepOver());
	InstructionSaved = dam.GetInstruction();
	csAddress = InstructionSaved.Left(8);

	EXPECT_TRUE(dam.GotoSymbol("FuncWithArg"));
	EXPECT_TRUE(dam.InstructionContains(-1, "int FuncWithArg(int nArg)", FALSE));
	EXPECT_TRUE(dam.InstructionContains(1, "push        ebp", FALSE));
	
	EXPECT_TRUE(dam.GotoSymbol(csAddress));

	//* We need this Step Over to locate caret at the current addres
	//* EXPECT_TRUE(dbg.StepOver());
	// TODO: (dklem 09/09/98) Uncomment the following 1 line when #6403 gets fixed. Fixed in Build 8296.1
	EXPECT_TRUE(dam.InstructionContains(0, InstructionSaved, FALSE));

	//Change address to hex
	csAddress = "0x" + csAddress;
	EXPECT_TRUE(dam.GotoSymbol("FuncWithArg"));
	EXPECT_TRUE(dam.GotoSymbol(csAddress));

	//* EXPECT_TRUE(dbg.StepOver());
	// TODO: (dklem 09/09/98) Uncomment the following 1 line when #6403 gets fixed. Fixed in Build 8296.1
	EXPECT_TRUE(dam.InstructionContains(0, InstructionSaved, FALSE));

	// Toggle Hex mode and do the previous tests to verify that hex mode doesn't affect them
	EXPECT_TRUE(dbg.ToggleHexDisplay(TRUE));
	
	EXPECT_TRUE(dam.GotoSymbol("FuncWithArg"));
	EXPECT_TRUE(dam.GotoSymbol(csAddress));
	//* EXPECT_TRUE(dbg.StepOver());
	// TODO: (dklem 09/09/98) Uncomment the following 1 line when #6403 gets fixed. Fixed in Build 8296.1
	EXPECT_TRUE(dam.InstructionContains(0, InstructionSaved, FALSE));
	
	//Change address to dec
	csAddress = csAddress.Right(8);
	EXPECT_TRUE(dam.GotoSymbol("FuncWithArg"));
	EXPECT_TRUE(dam.GotoSymbol(csAddress));

	//* EXPECT_TRUE(dbg.StepOver());
	// TODO: (dklem 09/09/98) Uncomment the following 1 line when #6403 gets fixed. Fixed in Build 8296.1
	EXPECT_TRUE(dam.InstructionContains(0, InstructionSaved, FALSE));

	// Toggle Hex mode back
	EXPECT_TRUE(dbg.ToggleHexDisplay(FALSE));

	MinimalTestResizeMoveWindow();

	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));
}

void CDisAsmIDETest::HitBreakPoint(void)
{
	LOGTESTHEADER("HitBreakPoint");

	CString csAddress, InstructionSaved;
	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	dam.Enable();

	// In this part we set a BP at FuncWithArg using F9

	EXPECT_TRUE(dam.GotoSymbol("FuncWithArg"));
	EXPECT_TRUE(dam.InstructionContains(-1, "int FuncWithArg(int nArg)", FALSE));
	EXPECT_TRUE(bps.SetBreakpoint());
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_BREAK));
	CheckThatIPisAtFuncWithArg();

	// In this part we Restart and Go and see in the a BP at FuncWithArg is hit
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_BREAK));
	CheckThatIPisAtFuncWithArg();

	// In this part we Stop and Go and see in the a BP at FuncWithArg is hit. We also toggle the BP off
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_BREAK));
	// Toggle breakpoint off
	EXPECT_TRUE(uidam.ChooseContextMenuItem(TOGGLE_BREAKPOINT));
	CheckThatIPisAtFuncWithArg();

	// In this part we set a BP at Func using Context Menu and Go.
	// We are trying to kill two birds here:
	// 1. Check if BP at FuncWithArg was actully toggled off, so we pass it
	// 2. BP at Func was set and hit
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dam.GotoSymbol("Func"));
	EXPECT_TRUE(dam.InstructionContains(-1, "int Func(double dArg)", FALSE));
	EXPECT_TRUE(uidam.ChooseContextMenuItem(INSERT_REMOVE_BREAK_POINT));
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_BREAK));
	// We need to make step over in the DAM window, so we activate
	dam.Enable();
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.InstructionContains(-3, "int Func(double dArg)", FALSE));

	// In this part we toggle BP at FuncWithArg on.  Check this and remove it.
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dam.GotoSymbol("FuncWithArg"));
	EXPECT_TRUE(dam.InstructionContains(-1, "int FuncWithArg(int nArg)", FALSE));
	// Toggle breakpoint on
	EXPECT_TRUE(uidam.ChooseContextMenuItem(TOGGLE_BREAKPOINT));
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_BREAK));
	// Remove breakpoint
	EXPECT_TRUE(uidam.ChooseContextMenuItem(INSERT_REMOVE_BREAK_POINT));
	CheckThatIPisAtFuncWithArg();

	// In this part we check that BP at FuncWithArg was removed.
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_BREAK));
	// We need to make step over in the DAM window, so we activate
	dam.Enable();
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.InstructionContains(-3, "int Func(double dArg)", FALSE));

	//Remove all BPs
	EXPECT_TRUE(bps.ClearAllBreakpoints());

	MinimalTestResizeMoveWindow();

	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));
}

void CDisAsmIDETest::CheckThatIPisAtFuncWithArg(void)
{

	EXPECT_TRUE(dam.Enable());
	EXPECT_TRUE(dam.InstructionContains(-2, "int FuncWithArg(int nArg)", FALSE));

	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC());
	EXPECT_TRUE(!dam.IsActive());
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.VerifyCurrentLine("return nArg + 2;"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC());
	EXPECT_TRUE(dam.IsActive());
	EXPECT_TRUE(dbg.StepOver());
	// TODO (dklem 02/01/99)  ERROR.  Looks like a bug in 60.
	//'mov         al,byte ptr [chJustChar]' looks as 'mov         al,byte ptr [ebp - whatever]'
	// The following 1 line commented because this bug
	//	EXPECT_TRUE(dam.InstructionContains(-1, "mov         eax,dword ptr [nArg]", FALSE));
	EXPECT_TRUE(dam.InstructionContains(-2, "return nArg + 2;", FALSE));

}

void CDisAsmIDETest::SwitchDAMtoSRCandBack(void)
{
	LOGTESTHEADER("SwitchDAMtoSRCandBack");
	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	
	dam.Enable();

	for(BOOL bUsingContextMenu = FALSE; bUsingContextMenu <= TRUE; bUsingContextMenu++)
		for(int ii = 0; ii < 4; ii++)
		{
			EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(bUsingContextMenu));
			EXPECT_TRUE(!dam.IsActive());
			EXPECT_TRUE(dbg.VerifyCurrentLine("TemplateFoo <char>(chJustChar);		/* First line for tests */"));
			EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(bUsingContextMenu));
			EXPECT_TRUE(dam.IsActive());
			//Sleep(500);
			EXPECT_TRUE(dam.InstructionContains(-1, "TemplateFoo <char>(chJustChar);     /* First line for tests */", FALSE));
												
			// TODO (dklem 02/01/99)  ERROR.  Looks like a bug in 60.
			//'mov         al,byte ptr [chJustChar]' looks as 'mov         al,byte ptr [ebp - whatever]'
			// The following 1 line commented because this bug
			// EXPECT_TRUE(dam.InstructionContains(0, "mov         al,byte ptr [chJustChar]", FALSE));

		}

	MinimalTestResizeMoveWindow();

	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));

}

void CDisAsmIDETest::SwitchSRCtoDAMMultiInstance(void)
{
	// Note that the Resolve Ambiguity verification implemented differently
	// in the GoToOverloadedSymbol() and in SwitchSRCtoDAMMultiInstance()
	// In SwitchSRCtoDAMMultiInstance() we find first instructions in each of TemplateFoo instances
	// by stepping in them and then verify that Resolve Ambiguity dialog brings us to the correct instructions.
	// In GoToOverloadedSymbol() we go to call TemplateFoo and check the address og the first instruction
	// and then verify that Resolve Ambiguity dialog brings us to the correct instructions.

	LOGTESTHEADER("SwitchSRCtoDAMMultiInstance");

	CString csResolveAmbiguityFunction[2];
	CString csInstructionInTemplateFoo[2];
	BOOL bFunctionFound;

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	// First of all we want to find first instruction in TemplateFoo <char>(chJustChar);		
	EXPECT_TRUE(dbg.StepInto());
	csInstructionInTemplateFoo[0] = dam.GetInstruction();

	// Then we want to find first instruction in TemplateFoo <int>(nJustInt);	
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(FALSE));
	EXPECT_TRUE(dbg.StepOut());
	EXPECT_TRUE(dbg.StepInto(2));
	csInstructionInTemplateFoo[1] = dam.GetInstruction();

	// Now check that Resolve Ambiguity dialog brings us to the correct instructions.
	csResolveAmbiguityFunction[0] = "TemplateFoo(char)";
	csResolveAmbiguityFunction[1] = "TemplateFoo(int)";

	for(int jj = 0; jj < 2; jj++)
	{
		dam.Disable();
		EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(FALSE));
		EXPECT_TRUE(dbg.ResolveSourceLineAmbiguity(csResolveAmbiguityFunction[jj]));

		//EXPECT_TRUE(dam.InstructionContains(1, csInstructionInTemplateFoo[jj], FALSE));

		bFunctionFound = FALSE;
		for(int ii = 0; ii < 10; ii++)
			if(	TRUE == (bFunctionFound = dam.InstructionContains(ii, csInstructionInTemplateFoo[jj], FALSE)))
				break;
		if(!bFunctionFound)
			LOG->RecordFailure("Address %s for %s was not found in %d lines", csInstructionInTemplateFoo[jj], csResolveAmbiguityFunction[jj], ii);
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~ delete until this line ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	}

	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));
}


void CDisAsmIDETest::TraceIntoCall(void)
{
	LOGTESTHEADER("TraceIntoCall");

	CString csAddress, csAddress1;

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* Second line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	dam.Enable();

	// Trace into call
	EXPECT_TRUE(dam.InstructionContains(-1, "FuncWithArg(1);", FALSE));
	EXPECT_TRUE(dam.InstructionContains(0, "push        1", FALSE));
	EXPECT_TRUE(dbg.StepInto());
	// Get address
	if(csAddress = dam.GetInstruction())
	{
		csAddress.MakeUpper();
		csAddress = csAddress.Right(csAddress.GetLength() - csAddress.Find("FUNCWITHARG"));
		csAddress = csAddress.Right(csAddress.GetLength() - csAddress.Find("(") - 1);
		csAddress = csAddress.Left(csAddress.FindOneOf("h)"));
	}

	// Check SHOW_NEX_STATEMENT
	EXPECT_TRUE(uidam.ChooseContextMenuItem(SHOW_NEX_STATEMENT));
	EXPECT_TRUE(dam.InstructionContains(0, "call", FALSE));
	EXPECT_TRUE(dam.InstructionContains(0, "(FuncWithArg) (", FALSE));
	
	
	EXPECT_TRUE(dbg.StepInto());
	// Get address
	if(csAddress1 = dam.GetInstruction())
	{
		csAddress1.MakeUpper();
		// Check that the address is correct
		EXPECT_TRUE( -1 != (csAddress1.Left(8)).Find(csAddress));
		csAddress1 = csAddress1.Right(csAddress1.GetLength() - csAddress1.Find("FUNCWITHARG"));
		csAddress1 = csAddress1.Right(csAddress1.GetLength() - csAddress1.Find("(") - 1);
		csAddress1 = csAddress1.Left(csAddress1.FindOneOf("h)"));
	}

	EXPECT_TRUE(dam.InstructionContains(0, "jmp         FuncWithArg (", FALSE));

	EXPECT_TRUE(dbg.StepInto());
	
	// Check that the address is correct
	if(csAddress = dam.GetInstruction())
	{
		csAddress1.MakeUpper();	
		EXPECT_TRUE( -1 != (csAddress.Left(8)).Find(csAddress1));
	}

	EXPECT_TRUE(dam.InstructionContains(-2, "int FuncWithArg(int nArg)", FALSE));
	EXPECT_TRUE(dbg.StepOut());
	EXPECT_TRUE(dam.InstructionContains(1, "Func(dJustDouble);", FALSE));
	
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));
}


void CDisAsmIDETest::GoToMaxMinAddress(void)
{

	LOGTESTHEADER("GoToMaxMinAddress");

	CString csAddress, csInstruction;

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	dam.Enable();

	EXPECT_TRUE(dam.GotoSymbol("00000000"));
	// TODO: (dklem 09/09/98) Change uidam.GetInstruction() to dam.GetInstruction() when #6013 gets fixed
	// #6013 was split into severeal bugs.  New bug for this case is #7887
	//csInstruction = uidam.GetInstruction(0, 1, TRUE);
	csInstruction = dam.GetInstruction();

	EXPECT_TRUE("00000000" == (csAddress = csInstruction.Left(8)));
	LOG->RecordInfo("CurrentAddress is %s", csAddress);

	// TODO: (dklem 10/30/98) uncomment the following line when #8781 gets fixed
	EXPECT_TRUE(dam.GotoSymbol("FFFFFFFF"));

	// TODO: (dklem 09/09/98) Change uidam.GetInstruction() to dam.GetInstruction() when #6013 gets fixed
	// #6013 was split into severeal bugs.  New bug for this case is #7887
	//csInstruction = uidam.GetInstruction(0, 1, TRUE);
	csInstruction = dam.GetInstruction();

	// TODO: (dklem 10/30/98) uncomment the following line when #8781 gets fixed
	EXPECT_TRUE("FFFFFFFF" == (csAddress = csInstruction.Left(8)));
	LOG->RecordInfo("CurrentAddress is %s", csAddress);
	
	// Resize and Move
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));
}


void CDisAsmIDETest::GoAfterScrollDisassemblyWndModified(void)
{

	LOGTESTHEADER("GoAfterScrollDisassemblyWndModified");

	for ( int i = 0; i < 200; i++)
	{
		MST.DoKeys ("+{pgdn}",FALSE,2000); //wait for idling
		if (MST.WFndWndWait("Browse for Folder", FW_NOCASE | FW_PART,0)
			|| MST.WFndWndWait("Find Source", FW_NOCASE | FW_PART,0))
			MST.WButtonClick( "Cancel" );
	}
		
	GoToMaxMinAddress();
}

void CDisAsmIDETest::GoToInvalidAddress(void)
{

	LOGTESTHEADER("GoToInvalidAddress");

	CString csAddress, csInstruction;
	HWND resulthWnd;

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	dam.Enable();

	// TODO: (dklem 10/30/98) uncomment the following line when #8781 gets fixed
	EXPECT_TRUE(dam.GotoSymbol("FFFFFFFFF5"));
	// TODO: (dklem 09/09/98) Change uidam.GetInstruction() to dam.GetInstruction() when #6013 gets fixed
	// #6013 was split into severeal bugs.  New bug for this case is #7887
	// csInstruction = uidam.GetInstruction(0, 1, TRUE);
	csInstruction = dam.GetInstruction();

	// TODO: (dklem 10/30/98) uncomment the following line when #8781 gets fixed
	EXPECT_TRUE("FFFFFFF5" == (csAddress = csInstruction.Left(8)));
	LOG->RecordInfo("CurrentAddress is %s", csAddress);

	EXPECT_TRUE(dam.GotoSymbol("PRIVET", FALSE));

	EXPECT_TRUE(NULL != (resulthWnd = MST.WFndWnd("Microsoft Visual C++", FW_NOCASE | FW_EXIST)));
	if(NULL != resulthWnd)
	{
		MST.WButtonClick("OK");
	}
	dam.Enable();
	// TODO: (dklem 09/09/98) Change uidam.GetInstruction() to dam.GetInstruction() when #6013 gets fixed
	// #6013 was split into severeal bugs.  New bug for this case is #7887
	// csInstruction = uidam.GetInstruction(0, 1, TRUE);
	// TODO: (dklem 10/30/98) uncomment the following line when #8781 gets fixedcsInstruction = dam.GetInstruction();
	EXPECT_TRUE("FFFFFFF5" == (csAddress = csInstruction.Left(8)));
	LOG->RecordInfo("CurrentAddress is %s", csAddress);

	// Resize and Move
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));
}


void CDisAsmIDETest::OpenDAMWhileChildIsRunning(void)
{

	LOGTESTHEADER("OpenDAMWhileChildIsRunning");

	CString csInstruction;
	
	// Restart and Go.  Close DAM Open DAM
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, NOWAIT));

	dam.Enable();
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));
	dam.Enable();
	csInstruction = dam.GetInstruction();
	// TODO: (dklem 11/03/98) Uncomment the following line when #8896 is fixed
	// EXPECT_TRUE(-1 != csInstruction.Find("(unavailable while child is running)"));

	// Stop and Go with DAM opened
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, NOWAIT));
	dam.Enable();
	csInstruction = dam.GetInstruction();
	EXPECT_TRUE(-1 != csInstruction.Find("(unavailable while child is running)"));

	// Stop, Go and open DAM with Context menu
	// TODO: (dklem 09/10/98) Uncomment the following 5 line when #6530 and #6531 get fixed
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, NOWAIT));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	csInstruction = dam.GetInstruction();
	EXPECT_TRUE(-1 != csInstruction.Find("(unavailable while child is running)"));

	// Stop, start, Go and open DAM 
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_TRUE(dbg.StepInto());
	dam.Enable();
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, NOWAIT));
	dam.Enable();
	csInstruction = dam.GetInstruction();
	// TODO: (dklem 11/03/98) Uncomment the following line when #8896 is fixed
	// EXPECT_TRUE(-1 != csInstruction.Find("(unavailable while child is running)"));

	// Stop, start, open DAM and Go 
// TODO: (dklem 09/10/98) Uncomment the following 5 line when #6534 gets fixed
//	EXPECT_TRUE(dbg.StopDebugging());
//	EXPECT_TRUE(dbg.StepInto());
//	dam.Enable();
//	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, NOWAIT));
//	csInstruction = dam.GetInstruction();
//	EXPECT_TRUE(-1 != csInstruction.Find("(unavailable while child is running)"));

	// We can not restart neither when child is running nor when debugger is not started, so we stop and start it into 2 steps
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_TRUE(dbg.StepInto());

	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));
	
}


void CDisAsmIDETest::CodeBytes(void)
{

	LOGTESTHEADER("CodeBytes");

	CString csAddress, csInstruction, csCodeBytes;
	char csCodeBytesInMemWindow[64];
	
	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	dam.Enable();
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CODE_BYTES));

	for(int ii = 0; ii < 2; ii++)
	{
		EXPECT_TRUE(dbg.StepInto());
		csInstruction = dam.GetInstruction();
		csAddress = csInstruction.Left(8);
		csCodeBytes = csInstruction.Mid(9, 20);
		csCodeBytes.TrimLeft();
		csCodeBytes.TrimRight();
		mem.GetMemoryData(csAddress, csCodeBytesInMemWindow, MEM_FORMAT_BYTE, csCodeBytes.GetLength());
		csCodeBytesInMemWindow[csCodeBytes.GetLength()]  ='\0';
		EXPECT_TRUE(0 == csCodeBytes.CompareNoCase(csCodeBytesInMemWindow));
	}
	
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CODE_BYTES));
	EXPECT_TRUE(!dam.InstructionContains(0, csCodeBytes, FALSE));

	EXPECT_TRUE(uidam.ChooseContextMenuItem(CODE_BYTES));
	EXPECT_TRUE(dam.InstructionContains(0, csCodeBytes, FALSE));

	EXPECT_TRUE(uidam.ChooseContextMenuItem(CODE_BYTES));
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));
}



void CDisAsmIDETest::SetFocusToThread(void)
{

	LOGTESTHEADER("SetFocusToThread");

	
	BOOL bFileSeparatorFound = FALSE; 
			
	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_TRUE(ERROR_SUCCESS == src.Open("damthread.c")); 
	EXPECT_TRUE(src.Find("MessageBeep(1);", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(bps.SetBreakpoint());
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_BREAK));
	EXPECT_TRUE(dbg.VerifyCurrentLine("MessageBeep(1);"));

	dam.Enable();

	EXPECT_TRUE(dam.InstructionContains(-1, "MessageBeep(1);", FALSE));
	EXPECT_TRUE(dam.InstructionContains(0, "mov         esi,esp", FALSE));
	EXPECT_TRUE(dam.InstructionContains(1, "push        1", FALSE));
	// One more check for a mangeled name
	EXPECT_TRUE(dam.InstructionContains(2, "call        dword ptr [__imp__MessageBeep@4", FALSE));


	// Check File separators
	EXPECT_TRUE(dam.GotoSymbol("ThreadRoutine"));
	// Using the next statement we just scroll 1 line up.  Actually it will be 2 lines scroll, 
	// since file separator is skipped while scrolling
	//dam.InstructionContains(-1, "", FALSE);
	EXPECT_TRUE(dam.InstructionContains(-3, "disasm exe\\damthread.c  ---", FALSE));

	EXPECT_TRUE(dam.GotoSymbol("WinMain"));
	// Using the next statement we just scroll 8 lines up.  Actually it will be 9 lines scroll, 
	// since file separator is skipped while scrolling
	//dam.InstructionContains(-8, "", FALSE);

	for(int ii = 0; ii > -10; ii--)
		if(	TRUE == (bFileSeparatorFound = dam.InstructionContains(ii, m_strProjBase + " exe.cpp" + "  ---", FALSE)))
			break;
	if(!bFileSeparatorFound)
			LOG->RecordFailure("File separator for %s was not found in %d lines", m_strProjBase + " exe.cpp", ii);

	//Remove all BPs
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	EXPECT_TRUE(ERROR_SUCCESS == src.Open(m_strProjBase + " exe.cpp"));

	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));
}


void CDisAsmIDETest::GoToOverloadedSymbol(void)
{

	// Note that the Resolve Ambiguity verification implemented differently
	// in the GoToOverloadedSymbol() and in SwitchSRCtoDAMMultiInstance()
	// In SwitchSRCtoDAMMultiInstance() we find first instructions in each of TemplateFoo instances
	// by stepping in them and then verify that Resolve Ambiguity dialog brings us to the correct instructions.
	// In GoToOverloadedSymbol() we go to call TemplateFoo and check the address og the first instruction
	// and then verify that Resolve Ambiguity dialog brings us to the correct instructions.


	CString csInstruction, csAddress;
	CString csResolveAmbiguityFunction[2];
	CString csResolveAmbiguityInstruction[2];
	
	LOGTESTHEADER("GoToOverloadedSymbol");

	BOOL bFuncltionFound; 

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	csResolveAmbiguityFunction[0] = "OverloadedFunc(int)";
	csResolveAmbiguityInstruction[0] = "void OverloadedFunc(int nArg)";

	csResolveAmbiguityFunction[1] = "OverloadedFunc(void)";
	csResolveAmbiguityInstruction[1] = "void OverloadedFunc(void)";

	// Test Overloaded Functions
	for(int jj = 0; jj < 2; jj++)
	{
		dam.Enable();
		dam.GotoSymbol("OverloadedFunc", FALSE);
		EXPECT_TRUE(dbg.ResolveAmbiguity(csResolveAmbiguityFunction[jj]));
		dam.Enable();

		// TODO: (dklem 09/16/98) Uncomment the following line when #6013 gets fixed
		// #6013 was split into severeal bugs.  New bug for this case is #7884 (related bug #7887)
		// EXPECT_TRUE(dam.InstructionContains(0, "void OverloadedFunc(int nArg)", FALSE));
		// TODO: (dklem 09/16/98) Remove the following 5 lines when #6013 gets fixed
		// #6013 was split into severeal bugs.  New bug for this case is #7884 (related bug #7887)
		for(int ii = 0, bFuncltionFound = FALSE; ii > -20; ii--)
			if(	TRUE == (bFuncltionFound = dam.InstructionContains(ii, csResolveAmbiguityInstruction[jj], FALSE)))
				break;
		if(!bFuncltionFound)
				LOG->RecordFailure("Function %s was not found in %d lines", csResolveAmbiguityInstruction[jj], ii);
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~ delete until this line ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	}

	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));

	// The same test for Template Functions
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	
	csResolveAmbiguityFunction[0] = "TemplateFoo(char)";
	csResolveAmbiguityFunction[1] = "TemplateFoo(int)";

	for(jj = 0; jj < 2; jj++)
	{
		dam.Enable();
		EXPECT_TRUE(dbg.StepInto(3));

		if(csAddress = dam.GetInstruction())
		{
			csAddress = csAddress.Right(csAddress.GetLength() - csAddress.Find("TemplateFoo"));
			csAddress = csAddress.Right(csAddress.GetLength() - csAddress.Find("(") - 1);
			csAddress = csAddress.Left(csAddress.FindOneOf("h)"));
			csAddress.MakeUpper();
		}

		dam.GotoSymbol("TemplateFoo", FALSE);
		EXPECT_TRUE(dbg.ResolveAmbiguity(csResolveAmbiguityFunction[jj]));
		dam.Enable();

		// TODO: (dklem 09/16/98) Uncomment the following line when #6013 gets fixed
		// #6013 was split into severeal bugs.  New bug for this case is #7884 (related bug #7887)
		// EXPECT_TRUE(dam.InstructionContains(0, csAddress, FALSE));
		// TODO: (dklem 09/16/98) Remove the following 5 lines when #6013 gets fixed
		// #6013 was split into severeal bugs.  New bug for this case is #7884 (related bug #7887)
		for(int ii = 0; ii < 10 ; ii++)
			if(	TRUE == (bFuncltionFound = dam.InstructionContains(ii, csAddress, FALSE)))
				break;
		if(!bFuncltionFound)
			LOG->RecordFailure("Address %s for %s was not found in %d lines", csAddress, csResolveAmbiguityFunction[jj], ii);
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~ delete until this line ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		EXPECT_TRUE(dbg.StepOver());
		EXPECT_TRUE(dbg.StepOut());
		EXPECT_TRUE(dbg.StepOver());
	}

	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));

}

void CDisAsmIDETest::CheckAsmSourceAndDAMConsistency(void)
{
	LOGTESTHEADER("CheckAsmSourceAndDAMConsistency");

	BOOL bFuncltionFound = FALSE; 

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("__asm {", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	dam.Enable();

	EXPECT_TRUE(dam.InstructionContains(0, "push        eax", FALSE));
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(dam.InstructionContains(0, "pop         eax", FALSE));

	// The following 4 lines are bug 3879 related
	// TODO (dklem 02/01/99)  ERROR.  Looks like a bug in 60.
	//'mov         al,byte ptr [chJustChar]' looks as 'mov         al,byte ptr [ebp - whatever]'
	// The following 4 lines used to skip such lines
/*
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(dam.InstructionContains(0, "lea         eax,[nJustInt]", FALSE));
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(dam.InstructionContains(0, "mov         dword ptr [p],eax ", FALSE));
*/
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));

}


void CDisAsmIDETest::ToolbarToDAMExpression(void)
{
	LOGTESTHEADER("ToolbarToDAMExpression");

	BOOL bFuncltionFound = FALSE; 

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("FuncWithArg", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	app.SendKeys("^F");
	app.SendKeys("^{F7}");	

	EXPECT_TRUE(dam.InstructionContains(-2, "FuncWithArg", FALSE));
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));
	
}


void CDisAsmIDETest::StepIntoStepOver(void)
{

	LOGTESTHEADER("StepIntoStepOver");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests ", FALSE, FALSE, FALSE, 0 )); // last argument 0 = FD_DOWN
	EXPECT_TRUE(dbg.StepToCursor());

	dam.Enable();

	// Read instrunctions and compare them with csDamWindowTextAtTemplateFooLine[]
	for(int ii = 2; ii < 4; ii++) {
		EXPECT_TRUE(dam.InstructionContains(0, csDamWindowTextAtTemplateFooLine[ii], FALSE));
		EXPECT_TRUE(dbg.StepOver());
	}

	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests ", FALSE, FALSE, FALSE, 0 )); // last argument 0 = FD_DOWN
	EXPECT_TRUE(dbg.StepToCursor());

	dam.Enable();

	// Read instrunctions and compare them with csDamWindowTextAtTemplateFooLine[]
	for(ii = 2; ii < 4; ii++) {
		EXPECT_TRUE(dam.InstructionContains(0, csDamWindowTextAtTemplateFooLine[ii], FALSE));
		EXPECT_TRUE(dbg.StepInto());
	}

	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 )); // last argument 0 = FD_DOWN
	EXPECT_TRUE(dbg.StepToCursor());

	dam.Enable();

	// Read instrunctions and compare them with csDamWindowTextAtTemplateFooLine[]
	for(ii = 2; ii < 4; ii++) {
		// TODO: (dklem 10/8/98) Uncomment the following line when #4321 gets fixed
		EXPECT_TRUE(dam.InstructionContains(0, csDamWindowTextAtTemplateFooLine[ii], FALSE));
		EXPECT_TRUE(dbg.StepOver());
	}

	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	dam.Enable();

	// Read instrunctions and compare them with csDamWindowTextAtTemplateFooLine[]
	for(ii = 2; ii < 4; ii++) {
		// TODO: (dklem 10/8/98) Uncomment the following line when #4321 gets fixed
		EXPECT_TRUE(dam.InstructionContains(0, csDamWindowTextAtTemplateFooLine[ii], FALSE));
		EXPECT_TRUE(dbg.StepInto());
	}


	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));

}

void CDisAsmIDETest::RedisplayingAfterEditingRegistersAndMemoryWindowsNoCVINFO(void)
{
	LOGTESTHEADER("RedisplayingAfterEditingRegistersAndMemoryWindowsNoCVINFO");

	CString csAddress, InstructionSaved;
	char csCodeBytesInMemWindow[64];

	// Restart 
	EXPECT_TRUE(dbg.Restart());

	dam.Enable();

	// We need this Step Over to locate caret at the current address
	EXPECT_TRUE(dbg.StepOver());
	InstructionSaved = dam.GetLines(10, 1);
	csAddress = InstructionSaved.Left(8);

	// Change register
	EXPECT_TRUE(regs.SetRegister(EIP, csAddress)); 

	dam.Enable();

	// TODO: (dklem 09/22/98) Uncomment the following line when #6923 and #6924 get fixed. #6923 is fixed in 8308.1. #6924 is fixed in 8323.0
	EXPECT_TRUE(dam.InstructionContains(0, csAddress, FALSE));
	EXPECT_TRUE(dbg.StepOver());
	// TODO: (dklem 09/22/98) Uncomment the following line when #6923 gets fixed. Fixed in 8308.1
	EXPECT_TRUE(dam.InstructionContains(-1, csAddress, FALSE));

	// The test plan says that combination with DAM scrolling is interesting
	dam.Enable();

	PgUpDownCtrlHomeEnd();
	
	mem.GetMemoryData(csAddress, csCodeBytesInMemWindow, MEM_FORMAT_BYTE,1);
	csCodeBytesInMemWindow[2] = '\0';
	if(strcmp(csCodeBytesInMemWindow,"AA") == 0)
		strcpy(csCodeBytesInMemWindow, "FF");
	else
		strcpy(csCodeBytesInMemWindow, "AA");

	// TODO: (dklem 09/22/98) Uncomment the following line when #6923 gets fixed. Fixed in 8308.1
	EXPECT_TRUE(mem.SetMemoryData(csAddress, csCodeBytesInMemWindow, MEM_FORMAT_BYTE));
	
	dam.Enable();
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CODE_BYTES));
	EXPECT_TRUE(dam.GotoSymbol(csAddress));

	// TODO: (dklem 09/22/98) Change uidam.GetInstruction() to dam.GetInstruction() when #6013 gets fixed
	// #6013 was split into severeal bugs.  New bug for this case is #7887
	// InstructionSaved = uidam.GetInstruction(0, 1, TRUE);
	InstructionSaved = dam.GetInstruction();

	// Get two first code bytes
	InstructionSaved = InstructionSaved.Mid(9, 20);
	InstructionSaved.TrimLeft(" \t");
	InstructionSaved = InstructionSaved.Left(2);

	// TODO: (dklem 09/22/98) Uncomment the following line when #6923 and #6013 get fixed. #6923 is fixed in 8308.1
	EXPECT_TRUE(InstructionSaved == csCodeBytesInMemWindow);
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CODE_BYTES));

	// The test plan says that combination with DAM scrolling is interesting
	dam.Enable();
	PgUpDownCtrlHomeEnd();

}

void CDisAsmIDETest::HitBreakPointNoCVINFO(void)
{
	LOGTESTHEADER("HitBreakPointNoCVINFO");

	CString csAddress, InstructionSaved;
	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());

	// We need this Step Over to locate caret at the current addres
	EXPECT_TRUE(dbg.StepOver());
	InstructionSaved = dam.GetLines(10, 1);
	csAddress = InstructionSaved.Left(8);

	EXPECT_TRUE(dam.GotoSymbol(csAddress));

	// TODO: (dklem 09/16/98) Remove the following line when #6013 gets fixed
	// #6013 was split into severeal bugs.  New bug for this case is #7887
	// uidam.GetInstruction(0, 1, TRUE); This line should be removed
	EXPECT_TRUE(uidam.ChooseContextMenuItem(SET_NEXT_STATEMENT));	

	EXPECT_TRUE(bps.SetBreakpoint());
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));
	EXPECT_TRUE(dbg.StopDebugging(ASSUME_NORMAL_TERMINATION));

	dbg.StepOver();
	EXPECT_TRUE(bps.EnableAllBreakpoints());
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_BREAK));
	EXPECT_TRUE(dam.InstructionContains(0, csAddress, FALSE));

	//Remove all BPs
	EXPECT_TRUE(bps.ClearAllBreakpoints());
}


void CDisAsmIDETest::SetNextStatementViaCtrlShiftF7NoCVINFO(void)
{
	LOGTESTHEADER("SetNextStatementViaCtrlShiftF7NoCVINFO");

	CString csAddress, InstructionSaved;
	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());

	// We need this Step Over to locate caret at the current addres
	EXPECT_TRUE(dbg.StepOver());
	InstructionSaved = dam.GetLines(10, 1);
	csAddress = InstructionSaved.Left(8);

	EXPECT_TRUE(dam.GotoSymbol(csAddress));

	// TODO: (dklem 09/16/98) Remove the following line when #6013 gets fixed
	// #6013 was split into severeal bugs.  New bug for this case is #7887
	// uidam.GetInstruction(0, 1, TRUE); This line should be removed
	MST.DoKeys("^+{F7}");

	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.InstructionContains(-1, csAddress, FALSE));

}


void CDisAsmIDETest::NavigateStackNoCVINFO(void)
{
	LOGTESTHEADER("NavigateStackNoCVINFO");

	CString csAddress, InstructionSaved;
	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());

	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));
	EXPECT_TRUE(stk.NavigateStack(0));
	// Check if DAM window came up
	EXPECT_TRUE(dam.InstructionContains(0, "push        ebp", FALSE));

	//Check that DAM comes up when the debugee is restarted
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dam.InstructionContains(0, "push        ebp", FALSE));
}

void CDisAsmIDETest::PgUpDownCtrlHomeEndNoCVINFO(void)
{

	LOGTESTHEADER("PgUpDownCtrlHomeEndNoCVINFO");
	
	// Restart 
	EXPECT_TRUE(dbg.Restart());
	dam.Enable();

	// Test RUN_TO_CURSOR
	EXPECT_TRUE(dam.InstructionContains(0, "push        ebp", FALSE));

	// TODO: (dklem 09/16/98) This is a dangerous place.  We can go out of scope, so RUN_TO_CURSOR will hang the child because of while(1) cycle
	MST.DoKeys("{PGDN}");

	// TODO: (dklem 09/16/98) Remove the following line when #6013 gets fixed
	// #6013 was split into severeal bugs.  New bug for this case is #7887
	// uidam.GetInstruction(0, 1, TRUE); This line should be removed
	EXPECT_TRUE(uidam.ChooseContextMenuItem(RUN_TO_CURSOR));
	EXPECT_TRUE(dbg.StepInto());
	// TODO (dklem 09/16/98) This won't work correct (result doesn't mean that we really moved to the new position) until #6774 gets fixed.  Fixed in 8337.0
	// Check that this gives an error if the following line: 
	// EXPECT_TRUE(uidam.ChooseContextMenuItem(RUN_TO_CURSOR));
	// above is commented ( when #6774 gets fixed )
	// The problem here is if RUN_TO_CURSOR doesn't work, StepInto will position EIP to the IP next to "push        ebp"
	// and this IP will be at the top of the DAM.  -1 in the next statement means pushing hte Up arrow.  However, since #6774
	// the IP will remain at the position next to "push        ebp" and the next statement doesn't make a sense.
	// So, try this test with commented EXPECT_TRUE(uidam.ChooseContextMenuItem(RUN_TO_CURSOR)); must give an error at the next line
	// If you shure that #6774 is fixed or doesn't exist, don't bother with this
	EXPECT_TRUE(!dam.InstructionContains(-1, "push        ebp", FALSE));
	
	// Return the caret to the original position.  This is necessary for the nex test PgUpDownCtrlHomeEnd()
	MST.DoKeys("{UP}");
	
	PgUpDownCtrlHomeEnd();
}

void CDisAsmIDETest::PgUpDownCtrlHomeEnd(void)
{

	CString csInitialAddress, csNewAddress, csNewAddress1;
	
	csInitialAddress = (dam.GetInstruction()).Left(8);
	
	// Check PhUp and PgDown
// TODO: (dklem 09/16/98) Uncomment the following /* */ block when #6763 is fixed
	MST.DoKeys("{PGUP 5}");
	csNewAddress = (dam.GetInstruction()).Left(8);
	EXPECT_TRUE(csNewAddress < csInitialAddress);

	MST.DoKeys("{PGDN 5}");
	csNewAddress = (dam.GetInstruction()).Left(8);
	EXPECT_TRUE(csNewAddress == csInitialAddress);

	MST.DoKeys("{PGDN 5}");
	csNewAddress = (dam.GetInstruction()).Left(8);
	EXPECT_TRUE(csNewAddress > csInitialAddress);

	MST.DoKeys("{PGUP 5}");
	csNewAddress = (dam.GetInstruction()).Left(8);
	// TODO: (dklem 09/16/98) Uncomment the following line when #6763 gets fixed
	EXPECT_TRUE(csNewAddress == csInitialAddress);

	// Check Ctrl+End and Ctrl+Home
/*	MST.DoKeys("^{END}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress);
	EXPECT_TRUE(csNewAddress > csInitialAddress);

	MST.DoKeys("^{HOME}");
	csNewAddress = (dam.GetInstruction()).Left(8);
	// TODO: (dklem 09/16/98) Uncomment the following line when #6774 gets fixed.  Fixed in 8337.0
	EXPECT_TRUE(csNewAddress == csInitialAddress);
*/
	// Check Arrows Up and Down
	MST.DoKeys("{HOME}{UP}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress);
	// TODO: (dklem 09/16/98) Uncomment the following line when #6774 gets fixed.  Fixed in 8337.0
	EXPECT_TRUE(csNewAddress < csInitialAddress);

	MST.DoKeys("{HOME}{UP}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress1);
	// TODO: (dklem 09/16/98) Uncomment the following line when #6774 gets fixed.  Fixed in 8337.0
	EXPECT_TRUE(csNewAddress1 < csNewAddress);

	MST.DoKeys("{HOME}{DOWN}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress1);
	EXPECT_TRUE(csNewAddress1 == csNewAddress);

	MST.DoKeys("{HOME}{DOWN}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress1);
	// TODO: (dklem 09/16/98) Uncomment the following 2 lines when #6774 gets fixed.  Fixed in 8337.0
	EXPECT_TRUE(csNewAddress1 > csNewAddress);
	EXPECT_TRUE(csNewAddress1 == csInitialAddress);

	MST.DoKeys("{HOME}{DOWN}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress);
	// TODO: (dklem 09/16/98) Uncomment the following line when #6774 gets fixed.  Fixed in 8337.0
	EXPECT_TRUE(csNewAddress > csInitialAddress);

	MST.DoKeys("{HOME}{DOWN}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress1);
	EXPECT_TRUE(csNewAddress1 > csNewAddress);

	MST.DoKeys("{HOME}{UP}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress1);
	EXPECT_TRUE(csNewAddress1 == csNewAddress);

	MST.DoKeys("{HOME}{UP}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress1);
	// TODO: (dklem 09/16/98) Uncomment the following line when #6774 gets fixed.  Fixed in 8337.0
	EXPECT_TRUE(csNewAddress1 == csInitialAddress);

	MinimalTestResizeMoveWindow();

}

void CDisAsmIDETest::VerifyDockingView(void)
{
	LOGTESTHEADER("VerifyDockingView");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	EXPECT_TRUE(uidam.EnableDockingView(TRUE));
	EXPECT_TRUE(uidam.IsDockingViewEnabled());
	// TODO: (dklem 09/14/98) Uncomment the following line when #6572 gets fixed
	// The bug #6572 is Memory leak while resizing DAM window. This leak is not that bad in the Release version
	// Based on my tests the Debug vesion consumes ~71,000K (at the peak) while running this test suite, Release version - 23,000K (at the peak) , which is acceptable
	// Comment the next line if the Debug version of MSDEV causes Out of Memory
	 TestResizeMoveWindow(TRUE, TRUE);	

	EXPECT_TRUE(uidam.EnableDockingView(FALSE));
	EXPECT_TRUE(!uidam.IsDockingViewEnabled());
	// TODO: (dklem 09/14/98) Uncomment the following line when #6572 gets fixed
	// The bug #6572 is Memory leak while resizing DAM window. This leak is not that bad in the Release version
	// Based on my tests the Debug vesion consumes ~71,000K (at the peak) while running this test suite, Release version - 23,000K (at the peak) , which is acceptable
	// Comment the next line if the Debug version of MSDEV causes Out of Memory
	TestResizeMoveWindow(FALSE, TRUE);	

	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));

}


void CDisAsmIDETest::MinimalTestResizeMoveWindow()
{

// TODO remove the next line immediately
//	return;
	
	BOOL bInitiallyMaximized;

	uidam.Activate();
	HWND hwnd = uidam.HWnd();

	if(IsZoomed(hwnd))
	{
		bInitiallyMaximized = TRUE;
		ShowWindow(hwnd, SW_RESTORE);
	}
	else 
		bInitiallyMaximized = FALSE;
	
	

	// TODO: (dklem 09/14/98) Uncomment the following 4 lines when #6572 gets fixed
	// The bug #6572 is Memory leak while resizing DAM window. This leak is not that bad in the Release version
	// Based on my tests the Debug vesion consumes ~71,000K (at the peak) while running this test suite, Release version - 23,000K (at the peak) , which is acceptable
	// Comment the next 4 lines if the Debug version of MSDEV causes Out of Memory
	TestResizeMoveWindow(FALSE, FALSE);

	// Restore the DAM window before turning Docking View on
	if(bInitiallyMaximized)
		ShowWindow(hwnd, SW_MAXIMIZE);
	
	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));

	TestResizeMoveWindow(TRUE, FALSE);
	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
}

void CDisAsmIDETest::TestResizeMoveWindow(BOOL bIsDocked, BOOL bFullTest)
{
	int nPositionMoved;
	uidam.Activate();

	BOOL DragFullWindows = TRUE;
	EXPECT_TRUE(GetDragFullWindows(&DragFullWindows));

	// Try minimum hor and ver sizes
	nPositionMoved = uidam. ResizeWindow(bIsDocked, SLeft, DRight, -1, DragFullWindows);
	uidam.ResizeWindow(bIsDocked, SLeft, DLeft, nPositionMoved, DragFullWindows);

	nPositionMoved = uidam.ResizeWindow(bIsDocked, SBottom, DUp, -1, DragFullWindows);
	uidam.ResizeWindow(bIsDocked, SBottom, DDown, nPositionMoved, DragFullWindows);

	// Move the window
	nPositionMoved = uidam.MoveWindow(bIsDocked, DRight, 20, DragFullWindows);
	nPositionMoved = uidam.MoveWindow(bIsDocked, DDown, 20, DragFullWindows);
	nPositionMoved = uidam.MoveWindow(bIsDocked, DLeft, 20, DragFullWindows);
	nPositionMoved = uidam.MoveWindow(bIsDocked, DUp, 20, DragFullWindows);

	if(!bFullTest) return;

	// Try to go beyond screen borders
	nPositionMoved = uidam.ResizeWindow(bIsDocked, SLeft, DLeft, -1, DragFullWindows);
	if(!DragFullWindows)
	{
		EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
		EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
		uidam.Activate();
	}
	uidam.ResizeWindow(bIsDocked, SLeft, DRight, nPositionMoved, DragFullWindows);

	nPositionMoved = uidam.ResizeWindow(bIsDocked, SRight, DRight, -1, DragFullWindows);
	if(!DragFullWindows)
	{
		EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
		EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
		uidam.Activate();
	}
	uidam.ResizeWindow(bIsDocked, SRight, DLeft, nPositionMoved, DragFullWindows);

	nPositionMoved = uidam.ResizeWindow(bIsDocked, SBottom, DDown, -1, DragFullWindows);
	if(!DragFullWindows)
	{
		EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
		EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
		uidam.Activate();
	}
	uidam.ResizeWindow(bIsDocked, SBottom, DUp, nPositionMoved, DragFullWindows);

	nPositionMoved = uidam.ResizeWindow(bIsDocked, STop, DUp, -1, DragFullWindows);
	// If we move it to far, the title bar is not available, we need to reactivate memory window
	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
	uidam.Activate();
	uidam.ResizeWindow(bIsDocked, STop, DDown, 10, DragFullWindows);

	// I like to move it move it
	nPositionMoved = uidam.MoveWindow(bIsDocked, DRight, -1, DragFullWindows);
	// If we move it to far, the title bar is not available, we need to reactivate memory window
	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
	uidam.Activate();
	uidam.MoveWindow(bIsDocked, DLeft, nPositionMoved, DragFullWindows);

	nPositionMoved = uidam.MoveWindow(bIsDocked, DLeft, -1, DragFullWindows);
	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
	uidam.Activate();
	uidam.MoveWindow(bIsDocked, DRight, nPositionMoved, DragFullWindows);

	nPositionMoved = uidam.MoveWindow(bIsDocked, DDown, -1, DragFullWindows);
	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
	uidam.Activate();
	uidam.MoveWindow(bIsDocked, DUp, nPositionMoved, DragFullWindows);

	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
	uidam.Activate();

	nPositionMoved = uidam.MoveWindow(bIsDocked, DUp, -1, DragFullWindows);
	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
	uidam.Activate();
	uidam.MoveWindow(bIsDocked, DDown, nPositionMoved, DragFullWindows);

}

void CDisAsmIDETest::PopulateDamWindowText(void)

{
	// This is a part of DAM window.  Copy it here if it changes.  I used the following steps
	// Use Ctrl+Sfift+F8 to select/remove rectangle 
	// I used the following steps
	// 1. Turn Off Code Byte in debugee's DAM, seclect lines you want to check and copy them
	// 2. Open a new text window and paste copied lines there.
	// 3. Select the very left rectangular part which contains addresses and delete it
	// 4. Select the part which left in the text window using Ctrl+Sfift+F8 (this is important). And copy this part.
	// 5. Switch to this file and select lines belonging to the csDamWindowTextAtTemplateFooLine array between
	//	   " and ",
	// 6. Press Ctrl+V.  
	// 7. Remove (addressh)
	// It is assumed in the SourceAnnotation that each line in csDamWindowTextAtTemplateFooLine[]
	// wchich begins with space or \t is a Source code line !
		
	csDamWindowTextAtTemplateFooLine.Add("																				");
	csDamWindowTextAtTemplateFooLine.Add("        TemplateFoo <char>(chJustChar);     /* First line for tests */			");
			// TODO (dklem 02/01/99)  ERROR.  Looks like a bug in 60.
			//'mov         al,byte ptr [chJustChar]' looks as 'mov         al,byte ptr [ebp - whatever]'
			// The next 1 line should replace the 2 line
	/*"mov         al,byte ptr [chJustChar]											");
	"push        eax																");
	"call																			");
	"add         esp,4																");
	"        TemplateFoo <int>(nJustInt);											");
	"mov         ecx,dword ptr [nJustInt]											");
	"push        ecx																");
	"call																			");
	"add         esp,4																");
	"																				");
	"        goto Ku_Ku;															");
	"jmp         Ku_Ku+																");
	"                nJustInt = 7;													");
	"Ku_Ku:																			");
	"                nJustInt = 17;													");
	"mov         dword ptr [nJustInt],												");
	"																				");
	"        FuncWithArg(1);														");
	"push        1																	");
	"call																			");
	"add         esp,4																");
	"        Func(dJustDouble);														");
	"mov         edx,dword ptr [ebp-												");
	"push        edx																");
	"mov         eax,dword ptr [dJustDouble]										");
	"push        eax																");
	"call			 																");
	"add         esp,8																");
	"																				");
	"        OverloadedFunc();														");
	"call						 													");
	"        OverloadedFunc(nJustInt);												");
	"mov         ecx,dword ptr [nJustInt]											");
	"push        ecx																");
	"call						 													");
	"add         esp,4																");
	"																				");
	" hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ThreadRoutine, (void*) pJustInt, 0L,&dwThreadId);");
	"mov         esi,esp															");
	"lea         edx,[dwThreadId]													");
	"push        edx																");
	"push        0																	");
	"mov         eax,dword ptr [pJustInt]											");
	"push        eax																");
	"push        offset @ILT+									");
	"push        0																	");
	"push        0																	");
	// If you remove the following line, add a line containing a mangeled name (@)
	"call        dword ptr [__imp__CreateThread@24									");	
	"cmp         esi,esp															");
	"call        																");
	"mov         dword ptr [hThread],eax											");
	"     ResumeThread(hThread);													");
	*/
	csDamWindowTextAtTemplateFooLine.Add("mov         al,byte ptr [														");
	csDamWindowTextAtTemplateFooLine.Add("push        eax																");
	csDamWindowTextAtTemplateFooLine.Add("call																			");
	csDamWindowTextAtTemplateFooLine.Add("add         esp,4																");
	csDamWindowTextAtTemplateFooLine.Add("        TemplateFoo <int>(nJustInt);											");

	// code-gen is different for these two instructions for processor pack.
	if(CMDLINE->GetBooleanValue("PP", FALSE))
	{
		csDamWindowTextAtTemplateFooLine.Add("mov         eax,dword ptr [													");
		csDamWindowTextAtTemplateFooLine.Add("push        eax																");
	}
	else
	{
		csDamWindowTextAtTemplateFooLine.Add("mov         ecx,dword ptr [													");
		csDamWindowTextAtTemplateFooLine.Add("push        ecx																");
	}

	csDamWindowTextAtTemplateFooLine.Add("call																			");
	csDamWindowTextAtTemplateFooLine.Add("add         esp,4																");
	csDamWindowTextAtTemplateFooLine.Add("																				");
	csDamWindowTextAtTemplateFooLine.Add("        goto Ku_Ku;															");
	csDamWindowTextAtTemplateFooLine.Add("jmp         Ku_Ku+																");
	csDamWindowTextAtTemplateFooLine.Add("                nJustInt = 7;													");
	csDamWindowTextAtTemplateFooLine.Add("Ku_Ku:																			");
	csDamWindowTextAtTemplateFooLine.Add("                nJustInt = 17;													");
	csDamWindowTextAtTemplateFooLine.Add("mov         dword ptr [														");
	csDamWindowTextAtTemplateFooLine.Add("																				");
	csDamWindowTextAtTemplateFooLine.Add("        FuncWithArg(1);														");
	csDamWindowTextAtTemplateFooLine.Add("push        1																	");
	csDamWindowTextAtTemplateFooLine.Add("call																			");
	csDamWindowTextAtTemplateFooLine.Add("add         esp,4																");
	csDamWindowTextAtTemplateFooLine.Add("        Func(dJustDouble);														");
	csDamWindowTextAtTemplateFooLine.Add("mov         edx,dword ptr [													");
	csDamWindowTextAtTemplateFooLine.Add("push        edx																");
	csDamWindowTextAtTemplateFooLine.Add("mov         eax,dword ptr [													");
	csDamWindowTextAtTemplateFooLine.Add("push        eax																");
	csDamWindowTextAtTemplateFooLine.Add("call			 																");
	csDamWindowTextAtTemplateFooLine.Add("add         esp,8																");
	csDamWindowTextAtTemplateFooLine.Add("																				");
	csDamWindowTextAtTemplateFooLine.Add("        OverloadedFunc();														");
	csDamWindowTextAtTemplateFooLine.Add("call						 													");
	csDamWindowTextAtTemplateFooLine.Add("        OverloadedFunc(nJustInt);												");
	csDamWindowTextAtTemplateFooLine.Add("mov         ecx,dword ptr [													");
	csDamWindowTextAtTemplateFooLine.Add("push        ecx																");
	csDamWindowTextAtTemplateFooLine.Add("call						 													");
	csDamWindowTextAtTemplateFooLine.Add("add         esp,4																");
	csDamWindowTextAtTemplateFooLine.Add("																				");
	csDamWindowTextAtTemplateFooLine.Add(" hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ThreadRoutine, (void*) pJustInt, 0L,&dwThreadId);");
	csDamWindowTextAtTemplateFooLine.Add("mov         esi,esp															");
	csDamWindowTextAtTemplateFooLine.Add("lea         edx,[																");
	csDamWindowTextAtTemplateFooLine.Add("push        edx																");
	csDamWindowTextAtTemplateFooLine.Add("push        0																	");
	csDamWindowTextAtTemplateFooLine.Add("mov         eax,dword ptr [													");
	csDamWindowTextAtTemplateFooLine.Add("push        eax																");
	csDamWindowTextAtTemplateFooLine.Add("push        offset @ILT+									");
	csDamWindowTextAtTemplateFooLine.Add("push        0																	");
	csDamWindowTextAtTemplateFooLine.Add("push        0																	");
	// If you remove the following line, add a line containing a mangeled name (@)
	csDamWindowTextAtTemplateFooLine.Add("call        dword ptr [__imp__CreateThread@24									");	
}


////////////////////// OLD TESTS ///////////////////////////////////////////////
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
////////////////////////////////////////////////////////////////////////////////

BOOL CDisAsmIDETest::GoAfterScrollDisassemblyWnd(  )
{
	COSource		src;	// WinslowF - added to call GoToLine. It's not in UIWB any more.
	BOOL retval = TRUE;

	CODebug codebug;
	EXPECT( codebug.Restart() );

	// Open DAM
	UIDAM dam = UIDebug::ShowDockWindow( IDW_DISASSY_WIN, TRUE );
	EXPECT( dam.IsActive() );

	int i;
	for ( i = 0; i < 200; i++)
	{
		MST.DoKeys ("+{pgdn}",FALSE,2000); //wait for idling
		if (MST.WFndWndWait("Browse for Folder", FW_NOCASE | FW_PART,0)
			|| MST.WFndWndWait("Find Source", FW_NOCASE | FW_PART,0))
			MST.WButtonClick( "Cancel" );
	}
		
	if ( !UIWB.VerifySubstringAtLine( "???" ) )
	{
		EXPECT ( src.GoToLine("0xf00000") );
	}

	if ( !UIWB.VerifySubstringAtLine( "???" ) )
	{
		EXPECT ( src.GoToLine("0xffffff") );
	}
		
	if ( !UIWB.VerifySubstringAtLine( "???" ) )
	{ 
   		m_pLog->RecordInfo("0x00ffffff : The app is too big: test case should be revised" );
		retval = FALSE;
	}

// YS: ToDo: we should use Go instead of StopDebugging

	//	EXPECT(	codebug.Go(NULL,NULL,NULL,0) );
	//	CString TitleRun = (CString)"[" + GetLocString(IDSS_DBG_RUN) + "]";
	//	MST.WFndWndWait(TitleRun, FW_PART, 10);
	//	
	//	UIWB.WaitForTermination();

	codebug.StopDebugging();		// TODO: WinslowF - Above three lines are replaced by this due to focus problems in Chicago.
// YS: end of block for ToDo

	WriteLog(PASSED, "01 : Scrolling Disassembly Window didn't corrupt Debugging as expected" );

	return retval;
}


	//~~~~~~~~~~~~~~~~~~~~~~~~~
/*
*	GO_TO_SOURCE,	
*	SHOW_NEX_STATEMENT,
*	INSERT_REMOVE_BREAK_POINT,
*	TOGGLE_BREAKPOINT,
*	RUN_TO_CURSOR,				
*	SET_NEXT_STATEMENT,
*	SOURCE_ANNOTATION,
*	CODE_BYTES,
	CODE_INJECTION,
*	DOCKING_VIEW,
*	CLOSE_HIDE
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\disasm\disasmpp.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	DISASMPP.CPP
//											 
//	Created by:			
//		dverma
//
//	Description:								 
//		VC6 Processor Pack testcases.		 

#include "stdafx.h"
#include "DisAsmPP.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
											   
IMPLEMENT_TEST(/*999,*/ CDisAsmPP, CDbgTestBase, "Processor Pack", -1, CDisAsmSubSuite)

// each function that runs a test has this prototype.
typedef void (CDisAsmPP::*PTR_TEST_FUNC)(void); 

// Information about a test to be put in the test header
#define LOGTESTHEADER(strTestName) 	m_strLogInfo.Format("# - %d.  %s. Total # - %d, Passed - %d %%", ++m_TestNumber, strTestName, m_TotalNumberOfTests, (m_TestNumber * 100) / m_TotalNumberOfTests);  \
									LogTestHeader(m_strLogInfo);

// we randomly pick out of the following list of tests and run them.
// insert functions for new tests to the end of the list.
PTR_TEST_FUNC tests[] = 
{
	&CDisAsmPP::TestMMX,
	&CDisAsmPP::Test3dNow,
	&CDisAsmPP::Test3dNowEnhanced,
	&CDisAsmPP::TestKatmai,
	&CDisAsmPP::TestWNI
};

												 
void CDisAsmPP::PreRun(void)
{
	// call the base class
	CTest::PreRun();

}

void CDisAsmPP::Run()

{	 
	char bPPFlagsPresent = 0;

	//	test if any pp switches present
	if (CMDLINE->GetBooleanValue("MMX",FALSE))  bPPFlagsPresent = 1;
	if (CMDLINE->GetBooleanValue("k6",FALSE))	bPPFlagsPresent = 1;
	if (CMDLINE->GetBooleanValue("k7",FALSE))	bPPFlagsPresent = 1;
	if (CMDLINE->GetBooleanValue("kni",FALSE))  bPPFlagsPresent = 1;
	if (CMDLINE->GetBooleanValue("wni",FALSE))  bPPFlagsPresent = 1;

	if (!bPPFlagsPresent) 
	{
			LOG->RecordInfo("No Processor Pack Flags Specified");
			return;
	}

	/******************
	 * INITIALIZATION *
	 ******************/

	// the base name of the localized directories and files we will use.
	if(GetSystem() & SYSTEM_DBCS)
		m_strProjBase = "[\\]^{|}Aa`@~ DisAsm PP";
	else
		m_strProjBase = "DisAsm PP";

	// the location of the unlocalized sources, under which the projects we will use will be located.
	m_strSrcDir = GetCWD() + "src\\DisAsm PP";
	// the locations of the dll and exe projects, and their localized sources, that we will use for this test.
	m_strExeDir = m_strSrcDir + "\\" + m_strProjBase + " EXE";

	if (!CMDLINE->GetBooleanValue("noclean",FALSE))
	
	{
		// clean-up the exe project from the last run.
		KillFiles(m_strExeDir + "\\Debug\\", "*.*");
		RemoveDirectory(m_strExeDir + "\\Debug");
		KillFiles(m_strExeDir + "\\", "*.*");
		RemoveDirectory(m_strExeDir);

		// set the options for the exe project we are building for this test.
		CProjWizOptions *pWin32AppWizOpt = new(CWin32AppWizOptions);
		pWin32AppWizOpt->m_strLocation = m_strSrcDir;
		pWin32AppWizOpt->m_strName = m_strProjBase + " EXE";	
		
		// create the exe project.
		EXPECT_SUCCESS(prj.New(pWin32AppWizOpt));
		// create a new localized exe source file in the project dir from the unlocalized exe source file.
		CopyFile(m_strSrcDir + "\\" + "DisAsm PP.cpp", m_strExeDir + "\\" + m_strProjBase + " EXE.cpp", FALSE);
		// make it writable so it can be cleaned up later.
		SetFileAttributes(m_strExeDir + "\\" + m_strProjBase + " EXE.cpp", FILE_ATTRIBUTE_NORMAL);
		// add the source to the project.
		EXPECT_SUCCESS(prj.AddFiles(m_strProjBase + " EXE.cpp"));
		// build the project.
		EXPECT_SUCCESS(prj.Build());
	}
	
	else
	{
		EXPECT_SUCCESS(prj.Open(m_strSrcDir + "\\" + m_strProjBase + " EXE\\" + m_strProjBase + " EXE.dsp"));
	}

	// indexes into the test function array.
	int iTest;
	
	// all tests expect the ide to be in this initial state.
	EXPECT_TRUE(dbg.StepOver());
	
	m_TestNumber = 0;
	m_TotalNumberOfTests = sizeof(tests) / sizeof(PTR_TEST_FUNC);

	// run each test once.
	for(iTest = 0; iTest < m_TotalNumberOfTests; iTest++)
		(this->*(tests[iTest]))();
	
	EXPECT_TRUE(dbg.StopDebugging(ASSUME_NORMAL_TERMINATION));
	EXPECT_SUCCESS(prj.Close());
}	

///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////


void CDisAsmPP::TestMMX()
{
	//	MMX switch has already been checked for in Run()
	
	LOGTESTHEADER("TestMMX");
	
	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(src.Find("	Test_MMX();")); 
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());	
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());

	//	test all registers for visibility
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movq mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movq mm1,mm2"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movq mm2,mm3"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movq mm3,mm4"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movq mm4,mm5"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movq mm5,mm6"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movq mm6,mm7"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movq mm7,mm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	shift left
	EXPECT_TRUE(dam.VerifyCurrentInstruction("psllw mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psllw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	mov 32 bit
	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movd mm0,dword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movd dword ptr [ebp-10h],mm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movq mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movq mmword ptr [ebp-8],mm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movd mm0,eax"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movd eax,mm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movq mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Pack with Signed Saturation
	EXPECT_TRUE(dam.VerifyCurrentInstruction("packsswb mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("packssdw mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("packsswb mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("packssdw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Pack with Unsigned Saturation	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("packuswb mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("packuswb mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Packed Add

	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddb mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddw mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddd mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddb mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddd mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Packed Add with Saturation
	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddsb mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddsw mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddsb mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddsw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Packed Add Unsigned with Saturation 
	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddusb mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddusw mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddusb mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddusw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Bitwise Logical And 
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pand mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pand mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Bitwise Logical And Not 
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pandn mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pandn mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Bitwise Logical Or
	EXPECT_TRUE(dam.VerifyCurrentInstruction("por mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("por mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Compare for Equal 
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpeqb mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpeqw mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpeqd mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpeqb mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpeqw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpeqd mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Compare for Greater Than

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpgtb mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpgtw mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpgtd mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpgtb mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpgtw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpgtd mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Packed Multiply and Add 

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmaddwd mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmaddwd mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Packed Multiply High

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmulhw mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmulhw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Packed Multiply Low

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmullw mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmullw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Packed Shift Left Logical

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psllw mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pslld mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psllq mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psllw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pslld mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psllq mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psllw mm0,7"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pslld mm0,7"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psllq mm0,7"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Packed Shift Right Arithmetic

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psraw mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrad mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("psraw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrad mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("psraw mm0,5"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrad mm0,5"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());	

	//	Packed Shift Right Logical
	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrlw mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrld mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrlq mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrlw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrld mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrlq mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrlw mm0,6"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrld mm0,6"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrlq mm0,6"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Packed Subtract

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubb mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubw mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubd mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubb mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubd mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Packed Subtract with Saturation

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubsb mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubsw mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubsb mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubsw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Packed Subtract Unsigned with Saturation

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubusb mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubsw mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubusb mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubsw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	//	Unpack High Packed Data

	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpckhbw mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpckhwd mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpckhdq mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpckhbw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpckhwd mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpckhdq mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	//	Unpack Low Packed Data

	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpcklbw mm0,dword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpcklwd mm0,dword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpckldq mm0,dword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpcklbw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpcklwd mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpckldq mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Bitwise Logical Exclusive OR

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pxor mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pxor mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

}

void CDisAsmPP::Test3dNow()
{
	if (!(CMDLINE->GetBooleanValue("k6",FALSE)||CMDLINE->GetBooleanValue("k7",FALSE))) 
		return;	//	exit if 3dnow switch is not set	
	
	LOGTESTHEADER("Test3dNow");
	
	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(src.Find("	Test_3dNow();")); 
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());	
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());

	//	average of unsigned int bytes
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pavgusb mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pavgusb mm0,mm5"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	float to 32 bit signed int
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pf2id mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pf2id mm0,mm5"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	accumulator
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfacc mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfacc mm0,mm5"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	add
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfadd mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfadd mm0,mm5"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	compare for equal
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfcmpeq mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfcmpeq mm0,mm5"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	compare for greater than or equal to
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfcmpge mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfcmpge mm0,mm5"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	compare for greater than
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfcmpgt mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfcmpgt mm0,mm5"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	maximum
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfmax mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfmax mm0,mm5"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	minimum
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfmin mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfmin mm0,mm5"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	multiply
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfmul mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfmul mm0,mm5"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	reciprocal
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfrcp mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfrcp mm0,mm5"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	reciprocal, reciprocal intermediate step 1, reciprocal intermediate step 2
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfrcpit1 mm1,mm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfrcpit2 mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfrcpit1 mm5,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfrcpit2 mm5,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	reciprocal sqrt
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfrsqrt mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfrsqrt mm0,mm5"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	reciprocal sqrt, reciprocal sqrt intermediate step 1	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfrsqit1 mm1,mm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfrsqit1 mm1,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	subtract
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfsub mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfsub mm0,mm5"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	reverse subtraction
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfsubr mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfsubr mm0,mm5"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	32 bit signed int to float
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pi2fd mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pi2fd mm0,mm5"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	multiply high
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmulhrw mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmulhrw mm0,mm5"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dbg.StepOver());

	//	load a processor cache into data cache
	EXPECT_TRUE(dam.VerifyCurrentInstruction("prefetch [ebp-9]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	same, sets MES state to modified
	EXPECT_TRUE(dam.VerifyCurrentInstruction("prefetchw [ebp-9]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

}

void CDisAsmPP::Test3dNowEnhanced()
{
	if (!CMDLINE->GetBooleanValue("k7",FALSE)) return;		//	exit if k7 switch is not set	
	
	LOGTESTHEADER("Test3dNowEnhanced");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(src.Find("	Test_3dNowEnhanced();")); 
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());	
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());

	//	packed float to int word with sign extend
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pf2iw mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pf2iw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	packed float negative accumulate
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfnacc mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfnacc mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	packed float mixed +ve -ve accumulate
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfpnacc mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pfpnacc mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	packed int word to float
	//	somewhat erroneous values
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pi2fw mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pi2fw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	packed swap double word
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pswapd mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pswapd mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	streaming store using byte mask

	EXPECT_TRUE(dam.VerifyCurrentInstruction("maskmovq mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	//	streaming store
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movntq mmword ptr [ebp-8],mm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
			
	//	packed avg of unsigned byte	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pavgb mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pavgb mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	packed avg of unsigned word	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pavgw mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pavgw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	extract word into int register
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pextrw eax,mm0,1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	insert word from int register
	//	TO DO : this test has been altered to pass because of POSTPONED VS98 bug 65288

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pinsrw mm0,ax,1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pinsrw mm0,word ptr [ebp-0Eh],1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	//	packed max signed word
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmaxsw mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmaxsw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	packed max unsigned byte
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmaxub mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmaxub mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	//	packed min signed word
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pminsw mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pminsw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	packed min unsigned byte	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pminub mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pminub mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	move mask to integer register
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmovmskb eax,mm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	packed multiply high unsigned word
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmulhuw mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmulhuw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	prefetch non-temporal access
	EXPECT_TRUE(dam.VerifyCurrentInstruction("prefetchnta [ebp-9]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	prefetch to all cache levels
	EXPECT_TRUE(dam.VerifyCurrentInstruction("prefetcht0 [ebp-9]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	//	prefetch to all cache levels except 0
	EXPECT_TRUE(dam.VerifyCurrentInstruction("prefetcht1 [ebp-9]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	//	prefetch to all cache levels except 0 & 1
	EXPECT_TRUE(dam.VerifyCurrentInstruction("prefetcht2 [ebp-9]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	//	packed sum of absolute byte differences
	EXPECT_TRUE(dam.VerifyCurrentInstruction("psadbw mm0,mmword ptr [ebp-8]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psadbw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	packed shuffle word
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pshufw mm0,mmword ptr [ebp-8],0E4h"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pshufw mm0,mm1,0E1h"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	// store fence
	EXPECT_TRUE(dam.VerifyCurrentInstruction("sfence"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
}

void CDisAsmPP::TestKatmai()
{
	if (!(CMDLINE->GetBooleanValue("kni",FALSE)||CMDLINE->GetBooleanValue("wni",FALSE))) 
		return;	//	exit if P3 switch is not set	

	LOGTESTHEADER("TestKatmai");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(src.Find("	Test_Katmai();")); 
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());	
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());

	//	test all registers for visibility
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movss xmm1,xmm2"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movss xmm2,xmm3"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movss xmm3,xmm4"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movss xmm4,xmm5"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movss xmm5,xmm6"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movss xmm6,xmm7"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movss xmm7,xmm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());


	EXPECT_TRUE(dam.VerifyCurrentInstruction("addps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("addps xmm0,xmmword ptr [ebp-20h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("addss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("addss xmm0,dword ptr [ebp-24h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("andnps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("andnps xmm0,xmmword ptr [ebp-20h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("andps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("andps xmm0,xmmword ptr [ebp-20h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	cmpps series

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpeqps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpltps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpleps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpunordps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpneqps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpnltps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpnleps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpordps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());


	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpeqps xmm0,xmmword ptr [ebp-20h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpltps xmm0,xmmword ptr [ebp-20h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpleps xmm0,xmmword ptr [ebp-20h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpunordps xmm0,xmmword ptr [ebp-20h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpneqps xmm0,xmmword ptr [ebp-20h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpnltps xmm0,xmmword ptr [ebp-20h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpnleps xmm0,xmmword ptr [ebp-20h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpordps xmm0,xmmword ptr [ebp-20h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	cmpss series

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpeqss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpltss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpless xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpunordss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpneqss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpnltss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpnless xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpordss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpeqss xmm0,dword ptr [ebp-24h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpltss xmm0,dword ptr [ebp-24h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpless xmm0,dword ptr [ebp-24h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpunordss xmm0,dword ptr [ebp-24h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpneqss xmm0,dword ptr [ebp-24h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpnltss xmm0,dword ptr [ebp-24h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpnless xmm0,dword ptr [ebp-24h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpordss xmm0,dword ptr [ebp-24h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());


	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpeqps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpeqss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpltps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpltss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpleps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpless xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpneqps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpneqss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpnltps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpnltss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpnleps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpnless xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("comiss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("comiss xmm0,dword ptr [ebp-24h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtpi2ps xmm0,mmword ptr [GlobalInt64 (0042d080)]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtpi2ps xmm0,mm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtps2pi mm0,xmm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtps2pi mm0,mmword ptr [GlobalInt64 (0042d080)]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtsi2ss xmm0,eax"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtsi2ss xmm0,dword ptr [ebp-24h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtss2si eax,xmm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtss2si eax,dword ptr [ebp-24h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvttps2pi mm0,xmm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvttps2pi mm0,mmword ptr [GlobalInt64 (0042d080)]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvttss2si eax,xmm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvttss2si eax,dword ptr [ebp-24h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("divps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("divps xmm0,xmmword ptr [ebp-20h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("divss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("divss xmm0,dword ptr [ebp-24h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("maxps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("maxps xmm0,xmmword ptr [ebp-20h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("maxss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("maxss xmm0,dword ptr [ebp-24h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("minps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("minps xmm0,xmmword ptr [ebp-20h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("minss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("minss xmm0,dword ptr [ebp-24h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movaps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movaps xmm0,xmmword ptr [ebp-20h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movaps xmmword ptr [ebp-20h],xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movhlps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movhps xmm0,qword ptr [GlobalInt64 (0042d080)]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movhps qword ptr [GlobalInt64 (0042d080)],xmm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movlps xmm0,qword ptr [GlobalInt64 (0042d080)]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movlps qword ptr [GlobalInt64 (0042d080)],xmm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movlhps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movmskps eax,xmm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movntps xmmword ptr [ebp-20h],xmm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movss xmm0,dword ptr [ebp-24h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movss dword ptr [ebp-24h],xmm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movups xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movups xmm0,xmmword ptr [ebp-20h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movups xmmword ptr [ebp-20h],xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("mulps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("mulps xmm0,xmmword ptr [ebp-20h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("mulss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("mulss xmm0,dword ptr [ebp-24h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("orps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("orps xmm0,xmmword ptr [ebp-20h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("rcpps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("rcpps xmm0,xmmword ptr [ebp-20h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("rcpss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("rcpss xmm0,dword ptr [ebp-24h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("rsqrtps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("rsqrtps xmm0,xmmword ptr [ebp-20h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("rsqrtss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("rsqrtss xmm0,dword ptr [ebp-24h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("sfence"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("shufps xmm0,xmm1,72h"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("shufps xmm0,xmmword ptr [ebp-20h],73h"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("sqrtps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("sqrtps xmm0,xmmword ptr [ebp-20h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("sqrtss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("sqrtss xmm0,dword ptr [ebp-24h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("stmxcsr dword ptr [ebp-24h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("ldmxcsr dword ptr [ebp-24h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("subps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("subps xmm0,xmmword ptr [ebp-20h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("subss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("subss xmm0,dword ptr [ebp-24h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("ucomiss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("ucomiss xmm0,dword ptr [ebp-24h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("unpckhps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("unpckhps xmm0,xmmword ptr [ebp-20h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("unpcklps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("unpcklps xmm0,xmmword ptr [ebp-20h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("xorps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("xorps xmm0,xmmword ptr [ebp-20h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

}

void CDisAsmPP::TestWNI()
{
	if (!CMDLINE->GetBooleanValue("wni",FALSE)) return;	//	exit if WNI switch is not set	

	LOGTESTHEADER("TestWNI");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(src.Find("	Test_WNI();")); 
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());	
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("emms"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	test all registers for visibility
	EXPECT_TRUE(dam.VerifyCurrentInstruction("addpd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("addpd xmm2,xmm3"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("addpd xmm4,xmm5"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("addpd xmm6,xmm7"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("addpd xmm1,xmm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("addpd xmm3,xmm2"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("addpd xmm5,xmm4"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("addpd xmm7,xmm6"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());


	EXPECT_TRUE(dam.VerifyCurrentInstruction("addpd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("addpd xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("addsd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("addsd xmm0,mmword ptr [ebp-18h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("andnpd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("andnpd xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("andpd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("andpd xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpeqpd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpeqpd xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpltpd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpltpd xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmplepd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmplepd xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpunordpd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpunordpd xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpneqpd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpneqpd xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpnltpd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpnltpd xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpnlepd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpnlepd xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpordpd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpordpd xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpeqsd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpeqsd xmm0,mmword ptr [ebp-18h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpltsd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpltsd xmm0,mmword ptr [ebp-18h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmplesd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmplesd xmm0,mmword ptr [ebp-18h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpunordsd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpunordsd xmm0,mmword ptr [ebp-18h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpneqsd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpneqsd xmm0,mmword ptr [ebp-18h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpnltsd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpnltsd xmm0,mmword ptr [ebp-18h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpnlesd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpnlesd xmm0,mmword ptr [ebp-18h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpordsd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpordsd xmm0,mmword ptr [ebp-18h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("comisd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("comisd xmm0,mmword ptr [ebp-18h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtdq2pd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtdq2pd xmm0,mmword ptr [ebp-18h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtpd2pi mm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtpd2pi mm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtpd2dq xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtpd2dq xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtpd2ps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtpd2ps xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtpi2pd xmm0,mm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtpi2pd xmm0,mmword ptr [ebp-18h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtps2pd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtps2pd xmm0,mmword ptr [ebp-18h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtsd2si eax,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtsd2si eax,mmword ptr [ebp-18h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtsd2ss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtsd2ss xmm0,mmword ptr [ebp-18h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtsi2sd xmm0,eax"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtsi2sd xmm0,dword ptr [ebp-24h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtss2sd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtss2sd xmm0,dword ptr [ebp-24h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvttpd2pi mm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvttpd2pi mm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvttpd2dq xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvttpd2dq xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvttsd2si eax,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvttsd2si eax,mmword ptr [ebp-18h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("divpd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("divpd xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("divsd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("divsd xmm0,mmword ptr [ebp-18h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("maxpd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("maxpd xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("maxsd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("maxsd xmm0,mmword ptr [ebp-18h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("minpd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("minpd xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("minsd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("minsd xmm0,mmword ptr [ebp-18h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movapd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movapd xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movapd xmmword ptr [ebp-10h],xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movhpd xmm0,qword ptr [ebp-18h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movhpd qword ptr [ebp-18h],xmm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movlpd xmm0,qword ptr [ebp-18h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movlpd qword ptr [ebp-18h],xmm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movmskpd eax,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movsd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movsd xmm0,mmword ptr [ebp-18h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movsd mmword ptr [ebp-18h],xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movupd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movupd xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movupd xmmword ptr [ebp-10h],xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("mulpd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("mulpd xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("mulsd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("mulsd xmm0,mmword ptr [ebp-18h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("orpd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("orpd xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("shufpd xmm0,xmm1,8"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("shufpd xmm0,xmmword ptr [ebp-10h],8"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("sqrtpd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("sqrtpd xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("sqrtsd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("sqrtsd xmm0,mmword ptr [ebp-18h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("subpd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("subpd xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("subsd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("subsd xmm0,mmword ptr [ebp-18h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("ucomisd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("ucomisd xmm0,mmword ptr [ebp-18h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("unpckhpd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("unpckhpd xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("unpcklpd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("unpcklpd xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("xorpd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("xorpd xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtdq2ps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtdq2ps xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtps2dq xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtps2dq xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvttps2dq xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvttps2dq xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtpi2ps xmm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtpi2ps xmm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtps2pi mm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtps2pi mm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvttps2pi mm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvttps2pi mm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movd xmm0,eax"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movd xmm0,dword ptr [ebp-24h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movd eax,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movd dword ptr [ebp-24h],xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movdqa xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movdqa xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movdqa xmmword ptr [ebp-10h],xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movdqu xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movdqu xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movdqu xmmword ptr [ebp-10h],xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	//	TO DO : MUST TEST with VCPP build > 8806.
//	EXPECT_TRUE(dam.VerifyCurrentInstruction("movdq2q mm0,xmm1"));
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movdq2q"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movq2dq xmm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movq xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movq xmm0,mmword ptr [ebp-18h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movq mmword ptr [ebp-18h],xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("packsswb xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("packsswb xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("packssdw xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("packssdw xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("packuswb xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("packuswb xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddb xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddb xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddw xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddw xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddd xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddq mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddq mm0,mmword ptr [ebp-18h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddq xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddq xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddsb xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddsb xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddsw xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddsw xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddusb xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddusb xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddusw xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddusw xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pand xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pand xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pandn xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pandn xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pavgb xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pavgb xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pavgw xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pavgw xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpeqb xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpeqb xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpeqw xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpeqw xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpeqd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpeqd xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpgtb xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpgtb xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpgtw xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpgtw xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpgtd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpgtd xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pextrw eax,xmm1,6"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pinsrw xmm0,word ptr [ebp-1Eh],6"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	TO DO : this test has been altered to pass because of POSTPONED VS98 bug 65288
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pinsrw xmm0,ax,6"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmaddwd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmaddwd xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmaxsw xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmaxsw xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmaxub xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmaxub xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pminsw xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pminsw xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pminub xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pminub xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmovmskb eax,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmulhw xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmulhw xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmulhuw xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmulhuw xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmullw xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmullw xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmuludq mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmuludq mm0,mmword ptr [ebp-18h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmuludq xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmuludq xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("por xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("por xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("psadbw xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psadbw xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pshufd xmm0,xmm1,8"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pshufd xmm0,xmmword ptr [ebp-10h],8"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pshufhw xmm0,xmm1,8"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pshufhw xmm0,xmmword ptr [ebp-10h],8"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pshuflw xmm0,xmm1,8"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pshuflw xmm0,xmmword ptr [ebp-10h],8"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pslldq xmm0,8"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("psllw xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psllw xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psllw xmm0,8"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pslld xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pslld xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pslld xmm0,8"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("psllq xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psllq xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psllq xmm0,8"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("psraw xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psraw xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psraw xmm0,8"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrad xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrad xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrad xmm0,8"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrldq xmm0,8"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrlw xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrlw xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrlw xmm0,8"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrld xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrld xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrld xmm0,8"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrlq xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrlq xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrlq xmm0,8"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubb xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubb xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubw xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubw xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubd xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubq mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubq mm0,mmword ptr [ebp-18h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubq xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubq xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubsb xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubsb xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubsw xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubsw xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubusb xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubusb xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubusw xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubusw xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpckhbw xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpckhbw xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpckhwd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpckhwd xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpckhdq xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpckhdq xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpckhqdq xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpckhqdq xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpcklbw xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpcklbw xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpcklwd xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpcklwd xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpckldq xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpckldq xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpcklqdq xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpcklqdq xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pxor xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pxor xmm0,xmmword ptr [ebp-10h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("clflush [ebp-19h]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("clflush [eax]"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("lfence"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("maskmovdqu xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
		
	EXPECT_TRUE(dam.VerifyCurrentInstruction("mfence"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movntpd xmmword ptr [ebp-10h],xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movntdq xmmword ptr [ebp-10h],xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movnti dword ptr [ebp-24h],eax"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pause"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\disasm\disasmpp.h ===
///////////////////////////////////////////////////////////////////////////////
//	DISASMPP.H
//
//	Created by:			
//		dverma
//
//	Description:
//		VC6 Processor Pack testcases.
//

#ifndef __DisAsmPP_H__
#define __DisAsmPP_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\DbgTestBase.h"
#include "disasub.h"

///////////////////////////////////////////////////////////////////////////////
//	CDisAsmPP class

class CDisAsmPP : public CDbgTestBase
{
	DECLARE_TEST(CDisAsmPP, CDisAsmSubSuite)

// Attributes
public:
	// the base name of the localized directories and files we will use.
	CString m_strProjBase;
	// the location of the unlocalized sources, under which the projects we will use will be located.
	CString m_strSrcDir;
	// the locations of the dll and exe projects, and their localized sources, that we will use for this test.
	CString m_strExeDir;

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);

// Test Cases
	void TestMMX(void);
	void Test3dNow(void);
	void Test3dNowEnhanced(void);
	void TestKatmai(void);
	void TestWNI(void);

protected:
	BOOL GoAfterScrollDisassemblyWnd(void);
	void CheckThatIPisAtFuncWithArg(void);
	void MinimalTestResizeMoveWindow(void);
	void TestResizeMoveWindow(BOOL bIsDocked, BOOL bFullTest);
	void PgUpDownCtrlHomeEnd(void);


private:
	int m_TestNumber;
	int m_TotalNumberOfTests;
	CString m_strLogInfo;
};

#endif //__DisAsmPP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\disasm\disacase.h ===
///////////////////////////////////////////////////////////////////////////////
//	DisAcase.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CDisAsmIDETest Class
//

#ifndef __DisAcase_H__
#define __DisAcase_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\DbgTestBase.h"
#include "disasub.h"

///////////////////////////////////////////////////////////////////////////////
//	CDisAsmIDETest class

class CDisAsmIDETest : public CDbgTestBase
{
	DECLARE_TEST(CDisAsmIDETest, CDisAsmSubSuite)

// Attributes
public:
	// the base name of the localized directories and files we will use.
	CString m_strProjBase;
	// the location of the unlocalized sources, under which the projects we will use will be located.
	CString m_strSrcDir;
	// the locations of the dll and exe projects, and their localized sources, that we will use for this test.
	CString m_strExeDir;

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);

// Test Cases
	void SourceAnnotation(void);
	void GoToSymbol(void);
	void HitBreakPoint(void);
	void SwitchDAMtoSRCandBack(void);
	void TraceIntoCall(void);
	void SwitchSRCtoDAMMultiInstance(void);
	void VerifyDockingView(void);
	void GoToMaxMinAddress(void);
	void GoToInvalidAddress(void);
	void OpenDAMWhileChildIsRunning(void);
	void CodeBytes(void);
	void SetFocusToThread(void);
	void GoToOverloadedSymbol(void);
	void GoAfterScrollDisassemblyWndModified(void);
	void CheckAsmSourceAndDAMConsistency(void);
	void RedisplayingAfterEditingRegistersAndMemoryWindowsNoCVINFO(void);
	void ToolbarToDAMExpression(void);
	void StepIntoStepOver(void);

	void HitBreakPointNoCVINFO(void);
	void NavigateStackNoCVINFO(void);
	void PgUpDownCtrlHomeEndNoCVINFO(void);
	void SetNextStatementViaCtrlShiftF7NoCVINFO(void);

	void DebugJIT(void);

protected:
	BOOL GoAfterScrollDisassemblyWnd(void);
	void CheckThatIPisAtFuncWithArg(void);
	void MinimalTestResizeMoveWindow(void);
	void TestResizeMoveWindow(BOOL bIsDocked, BOOL bFullTest);
	void PgUpDownCtrlHomeEnd(void);
	void PopulateDamWindowText(void);


private:
	int m_TestNumber;
	int m_TotalNumberOfTests;
	CString m_strLogInfo;
};

#endif //__DisAcase_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\disasm\disasub.h ===
///////////////////////////////////////////////////////////////////////////////
//	DisAsub.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CDisAsmSubSuite class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CDisAsmSubSuite class

class CDisAsmSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CDisAsmSubSuite)
//	CDisAsmSubSuite() { m_strName = "TestWizard Generated script"; m_strOwner = "VCBU QA"; }


	DECLARE_TESTLIST()
protected:
	void CleanUp(void);
	void SetUp(BOOL bCleanUp);
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\ee\eecase.h ===
///////////////////////////////////////////////////////////////////////////////
//	EECASE.H
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CEEIDETest Class
//

#ifndef __EECASE_H__
#define __EECASE_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\DbgTestBase.h"
#include "eesub.h"

///////////////////////////////////////////////////////////////////////////////
//	CEEIDETest class

class CEEIDETest : public CDbgTestBase
	
	{
	DECLARE_TEST(CEEIDETest, CEESubSuite)

	// Operations
	public:
		virtual void PreRun(void);
		virtual void Run(void);
	};

#endif //__EECASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\disasm\disasub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CDisAsmSubSuite class
//

#include "stdafx.h"
#include "DisAsub.h"
#include "afxdllx.h"
#include "..\..\DbgTestBase.h"

#include "DisAcase.h"
#include "DisAsmPP.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CDisAsmSubSuite

IMPLEMENT_SUBSUITE(CDisAsmSubSuite, CIDESubSuite, "Disassembly", "VCQA Debugger")

BEGIN_TESTLIST(CDisAsmSubSuite)
	TEST(CDisAsmIDETest, RUN)
	TEST(CDisAsmPP, RUN)
END_TESTLIST()

void CDisAsmSubSuite::CleanUp(void)
	{
	::CleanUp("testgo01");
	}

///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization

void CDisAsmSubSuite::SetUp(BOOL bCleanUp)

{
	CIDESubSuite::SetUp(bCleanUp);
	// TODO(michma - 9/2/98): re-enable when memory leak bugs are fixed.
	ExpectedMemLeaks(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\ee\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\ee\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\ee\eespec.h ===
///////////////////////////////////////////////////////////////////////////////
//	EECASE.H
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CEEIDETest Class
//

#ifndef __EESPECIAL_H__
#define __EESPECIAL_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\DbgTestBase.h"
#include "eesub.h"

///////////////////////////////////////////////////////////////////////////////
//	CEEIDETest class

class CSpecialTypesTest : public CDbgTestBase
	
{
	DECLARE_TEST(CSpecialTypesTest, CEESubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);
private:
	void PointerToFun(void);
	void GUIDs(void);
	void Variants(void);
	void ErrorCodes(void);
	void MMXRegs(void);

	CString m_TIBValue;
};

#endif //__EESPECIAL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\ee\eecasepp.h ===
///////////////////////////////////////////////////////////////////////////////
//	EECASEPP.H
//
//	Created by:			
//		dverma
//
//	Description :
//		VC6 Processor Pack testcases.
//

#ifndef __EECASEPP_H__
#define __EECASEPP_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\DbgTestBase.h"
#include "eesub.h"

///////////////////////////////////////////////////////////////////////////////
//	CEEPP class

class CEEPP : public CDbgTestBase
	
	{
	DECLARE_TEST(CEEPP, CEESubSuite)

	// Operations
	public:
		virtual void PreRun(void);
		virtual void Run(void);

	// testcases.
	protected:
		void testRegVal(COExpEval& cxx, char *value, char *message);
		void testRegVal(int regid, COExpEval& cxx, char *value, char *message);
		void testRegVal(char *varname, char *vartype, COExpEval& cxx, char *value, char *message);
		void testRegVal(COExpEval& cxx, char *value1, char *value2, char *value3, char *value4, char *message);
		void testRegVal(int reg_id, COExpEval& cxx, char *value1, char *value2, char *value3, char *value4, char *message);
		void test_MMX(COExpEval& cxx, CODebug& dbg, COSource& src);
		void test_3dNow(COExpEval& cxx, CODebug& dbg, COSource& src);
		void test_3dNowEnhanced(COExpEval& cxx, CODebug& dbg, COSource& src);
		void test_Katmai(COExpEval& cxx, CODebug& dbg, COSource& src);

	// Attributes
	public:
		// the base name of the localized directories and files we will use.
		CString m_strProjBase;
		// the location of the unlocalized sources, under which the projects we will use will be located.
		CString m_strSrcDir;
		// the locations of the dll and exe projects, and their localized sources, that we will use for this test.
		CString m_strExeDir;
};

#endif //__EECASEPP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\ee\eesub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	EESUB.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CEESubSuite class
//

#include "stdafx.h"
#include "eesub.h"
#include "afxdllx.h"
#include "..\cleanup.h"

#include "eecase.h"
#include "eespec.h"
#include "eecasepp.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CRetValSubSuite

IMPLEMENT_SUBSUITE(CEESubSuite, CIDESubSuite, "Expression Evaluator", "VCQA Debugger")

BEGIN_TESTLIST(CEESubSuite)
	TEST(CEEIDETest, RUN)
	TEST(CSpecialTypesTest, RUN)
	TEST(CEEPP, RUN)
END_TESTLIST()

void CEESubSuite::CleanUp(void)
	{
	::CleanUp("ee");
	}

///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\ee\eecasepp.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	EECASEPP.CPP
//											 
//	Created by:			
//		dverma		
//
//	Description:								 
//		VC6 Processor Pack testcases.

#include "stdafx.h"
#include "eecasepp.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
IMPLEMENT_TEST(CEEPP, CDbgTestBase, "Processor Pack", -1, CEESubSuite)
			  
									 
void CEEPP::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}


void CEEPP::Run(void)
	
{
	char bPPFlagsPresent = 0;

	//	test if any pp switches present
	if (CMDLINE->GetBooleanValue("MMX",FALSE))  bPPFlagsPresent = 1;
	if (CMDLINE->GetBooleanValue("k6",FALSE))  bPPFlagsPresent = 1;
	if (CMDLINE->GetBooleanValue("k7",FALSE))  bPPFlagsPresent = 1;
	if (CMDLINE->GetBooleanValue("kni",FALSE))  bPPFlagsPresent = 1;
	if (CMDLINE->GetBooleanValue("wni",FALSE))  bPPFlagsPresent = 1;

	if (!bPPFlagsPresent) 
	{
			LOG->RecordInfo("No Processor Pack Flags Specified");
			return;
	}

	/******************
	 * INITIALIZATION *
	 ******************/

	// the base name of the localized directories and files we will use.
	if(GetSystem() & SYSTEM_DBCS)
		m_strProjBase = "[\\]^{|}Aa`@~ ExprEval PP";
	else
		m_strProjBase = "ExprEval PP";

	// the location of the unlocalized sources, under which the projects we will use will be located.
	m_strSrcDir = GetCWD() + "src\\ExprEval PP";
	// the locations of the dll and exe projects, and their localized sources, that we will use for this test.
	m_strExeDir = m_strSrcDir + "\\" + m_strProjBase + " EXE";

	if(!CMDLINE->GetBooleanValue("noclean", FALSE))

	{
		// clean-up the exe project from the last run.
		KillFiles(m_strExeDir + "\\Debug\\", "*.*");
		RemoveDirectory(m_strExeDir + "\\Debug");
		KillFiles(m_strExeDir + "\\", "*.*");
		RemoveDirectory(m_strExeDir);

		// set the options for the exe project we are building for this test.
		CProjWizOptions *pWin32AppWizOpt = new(CWin32AppWizOptions);
		pWin32AppWizOpt->m_strLocation = m_strSrcDir;
		pWin32AppWizOpt->m_strName = m_strProjBase + " EXE";	
		
		// create the exe project.
		EXPECT_SUCCESS(prj.New(pWin32AppWizOpt));
		// create a new localized exe source file in the project dir from the unlocalized exe source file.
		CopyFile(m_strSrcDir + "\\" + "ExprEval PP.cpp", m_strExeDir + "\\" + m_strProjBase + " EXE.cpp", FALSE);
		// make it writable so it can be cleaned up later.
		SetFileAttributes(m_strExeDir + "\\" + m_strProjBase + " EXE.cpp", FILE_ATTRIBUTE_NORMAL);
		// add the source to the project.
		EXPECT_SUCCESS(prj.AddFiles(m_strProjBase + " EXE.cpp"));	
		// build the project.
		EXPECT_SUCCESS(prj.Build());
	}
	else
		{EXPECT_SUCCESS(prj.Open(m_strExeDir + "\\" + m_strProjBase + " EXE.dsp"));}

	// all tests expect the ide to be in this initial state.
	EXPECT_TRUE(dbg.StepOver());
		
	test_MMX(cxx,dbg,src);
	test_3dNow(cxx,dbg,src);
	test_3dNowEnhanced(cxx,dbg,src);
	test_Katmai(cxx,dbg,src);

	EXPECT_TRUE(dbg.StopDebugging(ASSUME_NORMAL_TERMINATION));
	EXPECT_SUCCESS(prj.Close());
}


//	 method to test the value of register MM0

void CEEPP::testRegVal(COExpEval& cxx, char *value, char *message)
{
	EXPR_INFO expr_info;

	cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "unsigned __int64", "MM0", value);		
	if(cxx.VerifyExprInfo(expr_info))
		LOG->RecordSuccess("%s : %s\n", expr_info.name,message);
	else
		LOG->RecordFailure("%s : %s\n", expr_info.name,message);
}

void CEEPP::testRegVal(char *varname, char *vartype, COExpEval& cxx, char *value, char *message)
{
	EXPR_INFO expr_info;

	cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, vartype, varname, value);		
	if(cxx.VerifyExprInfo(expr_info))
		LOG->RecordSuccess("%s : %s\n", expr_info.name,message);
	else
		LOG->RecordFailure("%s : %s\n", expr_info.name,message);

}

void CEEPP::testRegVal(int regid, COExpEval& cxx, char *value, char *message)
{
	EXPR_INFO expr_info;

	switch (regid)
	{
		case 0:			
					cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "unsigned __int64", "MM0", value);
					break;


		case 1:		
					cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "unsigned __int64", "MM1", value);
					break;


		case 2:					
					cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "unsigned __int64", "MM2", value);
					break;

		case 3:		
					cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "unsigned __int64", "MM3", value);
					break;


		case 4:		
					cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "unsigned __int64", "MM4", value);
					break;

		case 5:		
					cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "unsigned __int64", "MM5", value);
					break;

		case 6:		
					cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "unsigned __int64", "MM6", value);
					break;

		case 7:		
					cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "unsigned __int64", "MM7", value);
					break;

	}

	if(cxx.VerifyExprInfo(expr_info))
		LOG->RecordSuccess("%s : %s\n", expr_info.name,message);
	else
		LOG->RecordFailure("%s : %s\n", expr_info.name,message);
}

void CEEPP::testRegVal(COExpEval& cxx, char *value1, char *value2, char *value3, char *value4, char *message)
{
	EXPR_INFO expr_info;


	//	check XMM00
	cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "float", "XMM00", value4);		
	
	if(cxx.VerifyExprInfo(expr_info))
		LOG->RecordSuccess("%s : %s\n", expr_info.name,message);
	else
		LOG->RecordFailure("%s : %s\n", expr_info.name,message);

	//	check XMM01
	cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "float", "XMM01", value3);		
	
	if(cxx.VerifyExprInfo(expr_info))
		LOG->RecordSuccess("%s : %s\n", expr_info.name,message);
	else
		LOG->RecordFailure("%s : %s\n", expr_info.name,message);

	//	check XMM02		
	cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "float", "XMM02", value2);		
	
	if(cxx.VerifyExprInfo(expr_info))
		LOG->RecordSuccess("%s : %s\n", expr_info.name,message);
	else
		LOG->RecordFailure("%s : %s\n", expr_info.name,message);

	//	check XMM03
	cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "float", "XMM03", value1);		
	
	if(cxx.VerifyExprInfo(expr_info))
		LOG->RecordSuccess("%s : %s\n", expr_info.name,message);
	else
		LOG->RecordFailure("%s : %s\n", expr_info.name,message);

}

void CEEPP::testRegVal(int reg_id, COExpEval& cxx, char *value1, char *value2, char *value3, char *value4, char *message)
{

	CString MMXijRegs[] = {	"XMM00","XMM01","XMM02","XMM03", "XMM10","XMM11","XMM12","XMM13",
							"XMM20","XMM21","XMM22","XMM23", "XMM30","XMM31","XMM32","XMM33",
							"XMM40","XMM41","XMM42","XMM43", "XMM50","XMM51","XMM52","XMM53",
							"XMM60","XMM61","XMM62","XMM63", "XMM70","XMM71","XMM72","XMM73" };
	
	EXPR_INFO expr_info;


	//	check XMM00
	cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "float", MMXijRegs[reg_id*4], value4);		
	
	if(cxx.VerifyExprInfo(expr_info))
		LOG->RecordSuccess("%s : %s\n", expr_info.name,message);
	else
		LOG->RecordFailure("%s : %s\n", expr_info.name,message);

	//	check XMM01
	cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "float", MMXijRegs[reg_id*4+1], value3);		
	
	if(cxx.VerifyExprInfo(expr_info))
		LOG->RecordSuccess("%s : %s\n", expr_info.name,message);
	else
		LOG->RecordFailure("%s : %s\n", expr_info.name,message);

	//	check XMM02		
	cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "float", MMXijRegs[reg_id*4+2], value2);		
	
	if(cxx.VerifyExprInfo(expr_info))
		LOG->RecordSuccess("%s : %s\n", expr_info.name,message);
	else
		LOG->RecordFailure("%s : %s\n", expr_info.name,message);

	//	check XMM03
	cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "float", MMXijRegs[reg_id*4+3], value1);		
	
	if(cxx.VerifyExprInfo(expr_info))
		LOG->RecordSuccess("%s : %s\n", expr_info.name,message);
	else
		LOG->RecordFailure("%s : %s\n", expr_info.name,message);


}

void CEEPP::test_MMX(COExpEval& cxx, CODebug& dbg, COSource& src)
{
	//	MMX switch has already been checked for in Run()
	
	__int64 count = 0;

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	MST.DoKeys("{ESC}");	
	EXPECT_TRUE(src.Find("test_MMX();")); 
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());	
	EXPECT_TRUE(dbg.StepOver());

	char MMReg[][8] = {	"MM0", "MM1", "MM2", "MM3", "MM4", 
							"MM5", "MM6", "MM7"		};

	int num_reg = 8;
	int index = 0;

	cxx.Enable(EE_ALL_INFO);

	//	set value in watch window
	EXPECT_TRUE(dbg.ToggleHexDisplay(FALSE));
	for (index = 0; index <num_reg; index++)
	{
		EXPECT_TRUE(cxx.SetExpressionValue(MMReg[index],index*101));
	}

	//	do one stepover
	EXPECT_TRUE(dbg.StepOver());

	//	verify value in watch window
	for (index = 0; index <num_reg; index++)
	{
		char str[8];
		sprintf(str,"%d",index*101);
		testRegVal(MMReg[index], "unsigned __int64", cxx, str,"Test MMi in Watch");
	}

	//	verify value in register window
	EXPECT_TRUE(regs.Enable());
	for (index = 0; index <num_reg; index++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(MMReg[index], "" , index*101, FALSE));
	}
	EXPECT_TRUE(regs.Disable());


	//	test all registers for operability
	dbg.StepOver();
	testRegVal(0, cxx,"1000","move 64 bit");

	dbg.StepOver();
	testRegVal(1, cxx,"2000","move 64 bit");

	dbg.StepOver();
	testRegVal(2, cxx,"3000","move 64 bit");

	dbg.StepOver();
	testRegVal(3, cxx,"4000","move 64 bit");

	dbg.StepOver();
	testRegVal(4, cxx,"5000","move 64 bit");

	dbg.StepOver();
	testRegVal(5, cxx,"6000","move 64 bit");

	dbg.StepOver();
	testRegVal(6, cxx,"7000","move 64 bit");

	dbg.StepOver();
	testRegVal(7, cxx,"8000","move 64 bit");
	
	//	shift left
	dbg.StepOver();
	testRegVal(cxx,"1600","Shift Left");

	dbg.StepOver();
	testRegVal(cxx,"576","Shift Left");

	//	mov 32 bit
	dbg.StepOver();
	testRegVal(cxx,"123456789","mov 32 bit");
	
	dbg.StepOver();
	testRegVal(cxx,"0","mov 32 bit");
	
	dbg.StepOver();	//	32 bits - 1
	testRegVal(cxx,"4294967295","mov 32 bit");
	
	dbg.StepOver();	//	32 bits + 1
	testRegVal(cxx,"1","mov 32 bit");
	
	dbg.StepOver();	//	33 bits
	testRegVal(cxx,"0","mov 32 bit");


	//	move 64 bit

	dbg.StepOver();
	testRegVal(cxx,"123456789","move 64 bit");

	dbg.StepOver();
	testRegVal(cxx,"4294967296","move 64 bit");
	
	dbg.StepOver();
	testRegVal(cxx,"4294967295","move 64 bit");
	
	dbg.StepOver();	
	testRegVal(cxx,"4294967297","move 64 bit");
	
	dbg.StepOver();	
	testRegVal(cxx,"8589934592","move 64 bit");

	
	//	Pack with Signed Saturation
	dbg.StepOver();
	testRegVal(cxx,"4294967297","Pack with Signed Saturation");
	
	dbg.StepOver();
	testRegVal(cxx,"4294967297","Pack with Signed Saturation");

	//	Pack with Unsigned Saturation	
	dbg.StepOver();
	testRegVal(cxx,"4294967297","Pack with Unsigned Saturation");

	//	Packed Add
	dbg.StepOver();
	testRegVal(cxx,"101","Packed Add Byte");

	dbg.StepOver();
	testRegVal(cxx,"254","Packed Add Byte");
	
	dbg.StepOver();
	testRegVal(cxx,"0","Packed Add Byte");

	dbg.StepOver();
	testRegVal(cxx,"512","Packed Add Byte");


	dbg.StepOver();
	testRegVal(cxx,"101","Packed Add Word");

	dbg.StepOver();
	testRegVal(cxx,"0","Packed Add Word");

	dbg.StepOver();
	testRegVal(cxx,"131072","Packed Add Word");

	
	dbg.StepOver();
	testRegVal(cxx,"101","Packed Add Double");

	dbg.StepOver();
	testRegVal(cxx,"0","Packed Add Double");

	dbg.StepOver();
	testRegVal(cxx,"8589934592","Packed Add Double");


	//	Packed Add with Saturation
	dbg.StepOver();
	testRegVal(cxx,"250","Packed Add with Saturation");

	dbg.StepOver();
	testRegVal(cxx,"34","Packed Add with Saturation");


	//	Packed Add Unsigned with Saturation 
	dbg.StepOver();
	testRegVal(cxx,"255","Packed Add Unsigned with Saturation");

	dbg.StepOver();
	testRegVal(cxx,"65535","Packed Add Unsigned with Saturation");


	//	Bitwise Logical And 
	dbg.StepOver();
	testRegVal(cxx,"0","Logical And");

	dbg.StepOver();
	testRegVal(cxx,"15","Logical And");


	//	Bitwise Logical And Not 
	dbg.StepOver();
	testRegVal(cxx,"0","Logical And Not");

	dbg.StepOver();
	testRegVal(cxx,"14","Logical And Not");


	//	Bitwise Logical Or
	dbg.StepOver();
	testRegVal(cxx,"79","Logical Or");


	//	Compare for Equal 
	dbg.StepOver();
	testRegVal(cxx,"18446744073709486080","Byte Compare for Equal");

	dbg.StepOver();
	testRegVal(cxx,"18446744073709551360","Byte Compare for Equal");

	dbg.StepOver();
	testRegVal(cxx,"18446744073709551615","Byte Compare for Equal");


	dbg.StepOver();
	testRegVal(cxx,"18446744073709486080","Word Compare for Equal");

	dbg.StepOver();
	testRegVal(cxx,"18446744073709551615","Word Compare for Equal");
	
	dbg.StepOver();
	testRegVal(cxx,"18446744069414584320","Double Compare for Equal");

	dbg.StepOver();
	testRegVal(cxx,"18446744073709551615","Double Compare for Equal");


	//	Compare for Greater Than
	dbg.StepOver();
	testRegVal(cxx,"0","Byte Compare for Greater Than");

	dbg.StepOver();
	testRegVal(cxx,"255","Byte Compare for Greater Than");

	dbg.StepOver();
	testRegVal(cxx,"0","Byte Compare for Greater Than");

	dbg.StepOver();
	testRegVal(cxx,"255","Byte Compare for Greater Than");

	dbg.StepOver();
	testRegVal(cxx,"65280","Byte Compare for Greater Than");

	dbg.StepOver();
	testRegVal(cxx,"65280","Byte Compare for Greater Than");

	
	dbg.StepOver();
	testRegVal(cxx,"65535","Word Compare for Greater Than");

	dbg.StepOver();
	testRegVal(cxx,"4294901760","Word Compare for Greater Than");

	
	dbg.StepOver();
	testRegVal(cxx,"4294967295","Double Compare for Greater Than");

	dbg.StepOver();
	testRegVal(cxx,"18446744069414584320","Double Compare for Greater Than");


	//	Packed Multiply and Add 
	dbg.StepOver();
	testRegVal(cxx,"1300","Packed Multiply and Add");

	dbg.StepOver();
	testRegVal(cxx,"1","Packed Multiply and Add");


	//	Packed Multiply High
	dbg.StepOver();
	testRegVal(cxx,"0","Packed Multiply High");

	dbg.StepOver();
	testRegVal(cxx,"1","Packed Multiply High");


	//	Packed Multiply Low
	dbg.StepOver();
	testRegVal(cxx,"24","Multiply Low");

	dbg.StepOver();
	testRegVal(cxx,"6550","Multiply Low");


	//	Packed Shift Left Logical
	dbg.StepOver();
	testRegVal(cxx,"368","Packed Shift Left Logical Word");

	dbg.StepOver();
	testRegVal(cxx,"131074","Packed Shift Left Logical Word");

	dbg.StepOver();
	testRegVal(cxx,"0","Packed Shift Left Logical Word");

	
	dbg.StepOver();
	testRegVal(cxx,"368","Packed Shift Left Logical Double");

	dbg.StepOver();
	testRegVal(cxx,"2","Packed Shift Left Logical Double");

	dbg.StepOver();	//	=> 2^33
	testRegVal(cxx,"8589934592","Packed Shift Left Logical Double");

	dbg.StepOver();
	testRegVal(cxx,"0","Packed Shift Left Logical Double");

	
	dbg.StepOver();
	testRegVal(cxx,"368","Packed Shift Left Logical 64");

	//	Packed Shift Right Arithmetic
	dbg.StepOver();
	testRegVal(cxx,"50","Packed Shift Right Arithmetic Word");

	dbg.StepOver();
	testRegVal(cxx,"0","Packed Shift Right Arithmetic Word");

	dbg.StepOver();
	testRegVal(cxx,"1","Packed Shift Right Arithmetic Word");

	dbg.StepOver();
	testRegVal(cxx,"0","Packed Shift Right Arithmetic Word");

	dbg.StepOver();
	testRegVal(cxx,"0","Packed Shift Right Arithmetic Word");

	
	dbg.StepOver();
	testRegVal(cxx,"50","Packed Shift Right Arithmetic Double");

	dbg.StepOver();
	testRegVal(cxx,"0","Packed Shift Right Arithmetic Double");

	dbg.StepOver();
	testRegVal(cxx,"1","Packed Shift Right Arithmetic Double");

	dbg.StepOver();
	testRegVal(cxx,"0","Packed Shift Right Arithmetic Double");

	dbg.StepOver();
	testRegVal(cxx,"0","Packed Shift Right Arithmetic Double");

	
	//	Packed Shift Right Logical
	dbg.StepOver();
	testRegVal(cxx,"16","Packed Shift Right Logical Word");

	dbg.StepOver();
	testRegVal(cxx,"0","Packed Shift Right Logical Word");

	dbg.StepOver();	//	=>0
	testRegVal(cxx,"0","Packed Shift Right Logical Word");

	dbg.StepOver();	//	=>0
	testRegVal(cxx,"0","Packed Shift Right Logical Word");

	dbg.StepOver();	//	=>1
	testRegVal(cxx,"1","Packed Shift Right Logical Word");

	
	dbg.StepOver();
	testRegVal(cxx,"16","Packed Shift Right Logical Double");

	dbg.StepOver();
	testRegVal(cxx,"0","Packed Shift Right Logical Double");

	dbg.StepOver();	//	0
	testRegVal(cxx,"0","Packed Shift Right Logical Double");

	dbg.StepOver();	//	1
	testRegVal(cxx,"1","Packed Shift Right Logical Double");

	dbg.StepOver();	//	0
	testRegVal(cxx,"0","Packed Shift Right Logical Double");

	
	dbg.StepOver();
	testRegVal(cxx,"16","Packed Shift Right Logical Q");

	dbg.StepOver();
	testRegVal(cxx,"0","Packed Shift Right Logical Q");

	//	Packed Subtract
	dbg.StepOver();
	testRegVal(cxx,"140","Packed Subtract Byte");

	dbg.StepOver();
	testRegVal(cxx,"496","Packed Subtract Byte");

	dbg.StepOver();
	testRegVal(cxx,"65636","Packed Subtract Byte");

	
	dbg.StepOver();
	testRegVal(cxx,"300","Packed Subtract Word");

	dbg.StepOver();
	testRegVal(cxx,"65650","Packed Subtract Word");

	dbg.StepOver();
	testRegVal(cxx,"4294967396","Packed Subtract Word");

	dbg.StepOver();
	testRegVal(cxx,"4295032826","Packed Subtract Word");


	dbg.StepOver();
	testRegVal(cxx,"300","Packed Subtract Double");

	dbg.StepOver();
	testRegVal(cxx,"4294967396","Packed Subtract Double");

	//	Packed Subtract with Saturation
	dbg.StepOver();
	testRegVal(cxx,"140","Byte Packed Subtract with Saturation");

	dbg.StepOver();
	testRegVal(cxx,"384","Byte Packed Subtract with Saturation");

	dbg.StepOver();
	testRegVal(cxx,"65664","Byte Packed Subtract with Saturation");

	
	dbg.StepOver();
	testRegVal(cxx,"300","Word Packed Subtract with Saturation");

	dbg.StepOver();
	testRegVal(cxx,"65650","Word Packed Subtract with Saturation");

	dbg.StepOver();
	testRegVal(cxx,"4294967396","Word Packed Subtract with Saturation");


	//	Packed Subtract Unsigned with Saturation
	dbg.StepOver();	//	all "correct" values
	testRegVal(cxx,"140","Byte Packed Subtract Unsigned with Saturation");

	dbg.StepOver();
	testRegVal(cxx,"300","Byte Packed Subtract Unsigned with Saturation");

	dbg.StepOver();
	testRegVal(cxx,"65636","Byte Packed Subtract Unsigned with Saturation");

	
	dbg.StepOver();
	testRegVal(cxx,"300","Word Packed Subtract Unsigned with Saturation");

	dbg.StepOver();
	testRegVal(cxx,"65650","Word Packed Subtract Unsigned with Saturation");

	dbg.StepOver();
	testRegVal(cxx,"4294967396","Word Packed Subtract Unsigned with Saturation");

	
	//	Unpack High Packed Data
	dbg.StepOver();
	testRegVal(cxx,"0","Unpack High Packed Data Word");

	dbg.StepOver();
	testRegVal(cxx,"0","Unpack High Packed Data Word");

	dbg.StepOver();
	testRegVal(cxx,"256","Unpack High Packed Data Word");

	dbg.StepOver();
	testRegVal(cxx,"1","Unpack High Packed Data Word");

	dbg.StepOver();
	testRegVal(cxx,"257","Unpack High Packed Data Word");
	

	dbg.StepOver();
	testRegVal(cxx,"0","Unpack High Packed Data Double");

	dbg.StepOver();
	testRegVal(cxx,"0","Unpack High Packed Data Double");

	dbg.StepOver();
	testRegVal(cxx,"65536","Unpack High Packed Data Double");

	dbg.StepOver();
	testRegVal(cxx,"1","Unpack High Packed Data Double");

	dbg.StepOver();
	testRegVal(cxx,"65537","Unpack High Packed Data Double");
	
	dbg.StepOver();
	testRegVal(cxx,"0","Unpack High Packed Data Q");

	dbg.StepOver();
	testRegVal(cxx,"0","Unpack High Packed Data Q");

	dbg.StepOver();
	testRegVal(cxx,"4294967296","Unpack High Packed Data Q");

	dbg.StepOver();
	testRegVal(cxx,"1","Unpack High Packed Data Q");

	dbg.StepOver();
	testRegVal(cxx,"4294967297","Unpack High Packed Data Q");
	
	//	Unpack Low Packed Data
	dbg.StepOver();
	testRegVal(cxx,"513","Unpack Low Packed Data Word");

	dbg.StepOver();
	testRegVal(cxx,"258","Unpack Low Packed Data Word");

	dbg.StepOver();
	testRegVal(cxx,"131073","Unpack Low Packed Data Double");

	dbg.StepOver();
	testRegVal(cxx,"65538","Unpack Low Packed Data Double");
	
	dbg.StepOver();
	testRegVal(cxx,"8589934593","Unpack Low Packed Data Q");

	dbg.StepOver();
	testRegVal(cxx,"4294967298","Unpack Low Packed Data Q");
	
	//	Bitwise Logical Exclusive OR
	dbg.StepOver();
	testRegVal(cxx,"240","Logical Exclusive OR");

	dbg.StepOver();
	testRegVal(cxx,"0","Logical Exclusive OR");

	cxx.Disable();
}
	
void CEEPP::test_3dNow(COExpEval& cxx, CODebug& dbg, COSource& src)
{
	if (!(CMDLINE->GetBooleanValue("k6",FALSE)||CMDLINE->GetBooleanValue("k7",FALSE))) 
		return;	//	exit if 3dnow switch is not set	

	// Restart and Go to the line at which we want to begin our tests

	EXPECT_TRUE(dbg.Restart());
	MST.DoKeys("{ESC}");	
	EXPECT_TRUE(src.Find("test_3dNow();")); 
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());	
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());

	cxx.Enable(EE_ALL_INFO);

	char MMijReg[][8] = {	"MM00", "MM01", "MM10", "MM11", "MM20", "MM21", "MM30", "MM31", 
							"MM40", "MM41",	"MM50", "MM51", "MM60", "MM61", "MM70", "MM71"	};

	int num_reg = 16;
	int count = 0;

	//	set value in watch window
	EXPECT_TRUE(dbg.ToggleHexDisplay(FALSE));
	for (count = 0; count <num_reg; count++)
	{
		EXPECT_TRUE(cxx.SetExpressionValue(MMijReg[count],count*50));
	}

	//	do one stepover
	EXPECT_TRUE(dbg.StepOver());

	//	verify value in watch window
	for (count = 0; count <num_reg; count++)
	{
		char str[16];
		float fVal = (float) count*50;
		sprintf(str,"%f",fVal);
		if (count==0) 
			str[8] = '\0';	//	0 is shown as 0.000000
		else
			str[7] = '\0';
		
		testRegVal(MMijReg[count], "float", cxx, str,"Test MMij in Watch");
	}

	//	verify value in register window

	EXPECT_TRUE(regs.Enable());

	for (count = 0; count < num_reg; count++)
	{
		char str[16];
		double d = count*50;		
		sprintf(str,"+%.5E",d);

		EXPECT_TRUE(regs.RegisterValueIs(MMijReg[count], str, 0, TRUE));	
	}

	EXPECT_TRUE(regs.Disable());


	//	average of unsigned int bytes
	dbg.StepOver();
	testRegVal(cxx,"1","average of unsigned int bytes");

	dbg.StepOver();
	testRegVal(cxx,"1","average of unsigned int bytes");
	
	dbg.StepOver();
	testRegVal(cxx,"1","average of unsigned int bytes");
	
	dbg.StepOver();
	testRegVal(cxx,"734423025668","average of unsigned int bytes");


	//	float to 32 bit signed int

	dbg.StepOver();
	testRegVal(cxx,"2147483647","float to 32 bit signed int");

	dbg.StepOver();
	testRegVal(cxx,"9223372034707292159","float to 32 bit signed int");
	
	dbg.StepOver();
	testRegVal(cxx,"1","float to 32 bit signed int");
	
	dbg.StepOver();
	testRegVal(cxx,"4","float to 32 bit signed int");

	//	accumulator
	dbg.StepOver();
	testRegVal(cxx,"4575657231080488962","accumulator");
	
	dbg.StepOver();
	testRegVal(cxx,"1065353218","accumulator");

	dbg.StepOver();
	testRegVal(cxx,"4575657229998358528","accumulator");

	//	add
	dbg.StepOver();
	testRegVal(cxx,"1065353218","add");
	
	dbg.StepOver();
	testRegVal(cxx,"1077936131","add");

	dbg.StepOver();
	testRegVal(cxx,"1088421892","add");

	//	compare for equal
	dbg.StepOver();
	testRegVal(cxx,"18446744073709551615","compare for equal");
	
	dbg.StepOver();
	testRegVal(cxx,"18446744069414584320","compare for equal");

	dbg.StepOver();
	testRegVal(cxx,"18446744073709551615","compare for equal");

	dbg.StepOver();
	testRegVal(cxx,"4294967295","compare for equal");

	dbg.StepOver();
	testRegVal(cxx,"0","compare for equal");

	//	compare for greater than or equal to
	dbg.StepOver();
	testRegVal(cxx,"18446744073709551615","compare for greater than or equal to");
	
	dbg.StepOver();
	testRegVal(cxx,"18446744073709551615","compare for greater than or equal to");

	dbg.StepOver();
	testRegVal(cxx,"18446744073709551615","compare for greater than or equal to");

	dbg.StepOver();
	testRegVal(cxx,"18446744069414584320","compare for greater than or equal to");

	//	compare for greater than
	dbg.StepOver();
	testRegVal(cxx,"0","compare for greater than");
	
	dbg.StepOver();
	testRegVal(cxx,"0","compare for greater than");

	dbg.StepOver();
	testRegVal(cxx,"18446744069414584320","compare for greater than");

	dbg.StepOver();
	testRegVal(cxx,"18446744073709551615","compare for greater than");

	//	maximum
	dbg.StepOver();
	testRegVal(cxx,"0","maximum");
	
	dbg.StepOver();
	testRegVal(cxx,"4575657231063711746","maximum");

	dbg.StepOver();
	testRegVal(cxx,"4575657231076294659","maximum");

	dbg.StepOver();
	testRegVal(cxx,"4611686028095258627","maximum");

	//	minimum
	dbg.StepOver();
	testRegVal(cxx,"0","minimum");
	
	dbg.StepOver();
	testRegVal(cxx,"0","minimum");

	dbg.StepOver();
	testRegVal(cxx,"4575657231072100354","minimum");

	dbg.StepOver();
	testRegVal(cxx,"1065353218","minimum");

	//	multiply
	dbg.StepOver();
	testRegVal(cxx,"0","multiply");
	
	dbg.StepOver();
	testRegVal(cxx,"0","multiply");

	dbg.StepOver();
	testRegVal(cxx,"4611686036693581830","multiply");

	//	reciprocal
	dbg.StepOver();
	testRegVal(cxx,"9187343237679939583","reciprocal");
	
	dbg.StepOver();
	testRegVal(cxx,"4539626226423168512","reciprocal");

	dbg.StepOver();
	testRegVal(cxx,"1084227265","reciprocal");

	//	reciprocal, reciprocal intermediate step 1, reciprocal intermediate step 2
	dbg.StepOver();
	testRegVal(cxx,"4539626226423168512","reciprocal step1 step 2");
	
	dbg.StepOver();
	testRegVal(1, cxx,"1065418239","reciprocal step1 step 2");

	dbg.StepOver();
	testRegVal(cxx,"1057029630","reciprocal step1 step 2");

	dbg.StepOver();
	testRegVal(cxx,"1084308863","reciprocal step1 step 2");
	
	//	reciprocal sqrt
	dbg.StepOver();
	testRegVal(cxx,"9187343237679939583","reciprocal sqrt");
	
	dbg.StepOver();
	testRegVal(cxx,"4539627325934796544","reciprocal sqrt");

	dbg.StepOver();
	testRegVal(cxx,"4515608494420437504","reciprocal sqrt");

	//	reciprocal sqrt, reciprocal sqrt intermediate step 1	
	dbg.StepOver();
	testRegVal(cxx,"4539627325934796544","reciprocal sqrt, step 1");
	
	dbg.StepOver();
	testRegVal(1, cxx,"1065369343","reciprocal sqrt, step 1");

	dbg.StepOver();
	testRegVal(cxx,"4515608494420437504","reciprocal sqrt, step 1");

	dbg.StepOver();
	testRegVal(1, cxx,"1065365418","reciprocal sqrt, step 1");	

	//	subtract
	dbg.StepOver();
	testRegVal(cxx,"0","subtract");
	
	dbg.StepOver();
	testRegVal(cxx,"0","subtract");

	dbg.StepOver();
	testRegVal(cxx,"1077936131","subtract");

	dbg.StepOver();
	testRegVal(cxx,"4575657231072100354","subtract");

	//	reverse subtraction
	dbg.StepOver();
	testRegVal(cxx,"0","reverse subtraction");
	
	dbg.StepOver();
	testRegVal(cxx,"0","reverse subtraction");

	dbg.StepOver();
	testRegVal(cxx,"1077936131","reverse subtraction");

	dbg.StepOver();
	testRegVal(cxx,"4575657231072100354","reverse subtraction");

	//	32 bit signed int to float
	dbg.StepOver();
	testRegVal(cxx,"1065353216","32 bit signed int to float");
	
	dbg.StepOver();
	testRegVal(cxx,"4629700418010611712","32 bit signed int to float");

	dbg.StepOver();
	testRegVal(cxx,"4611686019492741120","32 bit signed int to float");

	//	multiply high
	dbg.StepOver();
	testRegVal(cxx,"0","multiply high");
	
	dbg.StepOver();
	testRegVal(cxx,"0","multiply high");

	dbg.StepOver();
	testRegVal(cxx,"8590000129","multiply high");

	cxx.Disable();
}
     
void CEEPP::test_3dNowEnhanced(COExpEval& cxx, CODebug& dbg, COSource& src)
{
	if (!CMDLINE->GetBooleanValue("k7",FALSE)) return;		//	exit if k7 switch is not set	

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	MST.DoKeys("{ESC}");	
	EXPECT_TRUE(src.Find("test_3dNowEnhanced();")); 
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());	
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());

	cxx.Enable(EE_ALL_INFO);

	//	packed float to int word with sign extend
	dbg.StepOver();
	testRegVal(cxx,"0","packed float to int word with sign extend");

	dbg.StepOver();
	testRegVal(cxx,"30064771076","packed float to int word with sign extend");

	dbg.StepOver();
	testRegVal(cxx,"42949672960","packed float to int word with sign extend");

	dbg.StepOver();
	testRegVal(cxx,"18446744069414584319","packed float to int word with sign extend");

	dbg.StepOver();
	testRegVal(cxx,"4294934528","packed float to int word with sign extend");

	//	packed float negative accumulate
	dbg.StepOver();
	testRegVal(cxx,"0","packed float negative accumulate");

	dbg.StepOver();
	testRegVal(cxx,"4629700416936869888","packed float negative accumulate");

	dbg.StepOver();
	testRegVal(cxx,"13799029259328552960","packed float negative accumulate");

	//	packed float mixed +ve -ve accumulate
	dbg.StepOver();
	testRegVal(cxx,"0","packed float mixed +ve -ve accumulate");

	dbg.StepOver();
	testRegVal(cxx,"1077936128","packed float mixed +ve -ve accumulate");

	dbg.StepOver();
	testRegVal(cxx,"4688247221760557056","packed float mixed +ve -ve accumulate");
   
	//	packed int word to float
	//	somewhat erroneous values
	dbg.StepOver();
	testRegVal(cxx,"1065353216","packed int word to float");

	dbg.StepOver();
	testRegVal(cxx,"13835058058495000576","packed int word to float");

	dbg.StepOver();
	testRegVal(cxx,"4674736414292705280","packed int word to float");

	dbg.StepOver();
	testRegVal(cxx,"4692750811720056832","packed int word to float");

	dbg.StepOver();
	testRegVal(cxx,"3338665984","packed int word to float");

	//	packed swap double word
	dbg.StepOver();
	testRegVal(cxx,"4294967296","packed swap double word");

	dbg.StepOver();
	testRegVal(cxx,"25769803777","packed swap double word");

	dbg.StepOver();
	testRegVal(cxx,"6","packed swap double word");

	//	streaming store using byte mask
	dbg.StepOver();
	dbg.StepOver();
	dbg.StepOver();

	//	streaming store
	dbg.StepOver();
	testRegVal("count", "__int64", cxx,"10","streaming store");

	dbg.StepOver();
	testRegVal("count", "__int64", cxx,"34359738373","streaming store");

			
	//	packed avg of unsigned byte	
	dbg.StepOver();
	testRegVal(cxx,"1","packed avg of unsigned byte");

	dbg.StepOver();
	testRegVal(cxx,"1","packed avg of unsigned byte");

	dbg.StepOver();
	testRegVal(cxx,"1","packed avg of unsigned byte");

	dbg.StepOver();
	testRegVal(cxx,"734423025668","packed avg of unsigned byte");
	
	//	packed avg of unsigned word	
	dbg.StepOver();
	testRegVal(cxx,"1","packed avg of unsigned word");

	dbg.StepOver();
	testRegVal(cxx,"12293138128684057218","packed avg of unsigned word");

	dbg.StepOver();
	testRegVal(cxx,"55000","packed avg of unsigned word");

	//	extract word into int register
	dbg.StepOver();
	testRegVal("eax", "unsigned long", cxx,"0","extract word into int register");

	dbg.StepOver();
	testRegVal("eax", "unsigned long", cxx,"1","extract word into int register");

	//	insert word from int register
	dbg.StepOver();
	testRegVal(cxx,"131076","insert word from int register");

	//	packed max signed word
	dbg.StepOver();
	testRegVal(cxx,"576742223002009601","packed max signed word");

	dbg.StepOver();
	testRegVal(cxx,"1431633926","packed max signed word");
	
	//	packed max unsigned byte
	dbg.StepOver();
	testRegVal(cxx,"1834219928319","packed max unsigned byte");
	
	//	packed min signed word
	dbg.StepOver();
	testRegVal(cxx,"533958022247022591","packed min signed word");

	dbg.StepOver();
	testRegVal(cxx,"1431633921","packed min signed word");
	
	//	packed min unsigned byte	
	dbg.StepOver();
	testRegVal(cxx,"730396487935","packed min unsigned byte");
	
	//	move mask to integer register
	dbg.StepOver();
	testRegVal("eax", "unsigned long", cxx,"217","move mask to integer register");
	
	//	packed multiply high unsigned word
	dbg.StepOver();
	testRegVal(cxx,"281474976841729","packed multiply high unsigned word");

	//	prefetch non-temporal access
	dbg.StepOver();
	
	//	prefetch to all cache levels
	dbg.StepOver();
	
	//	prefetch to all cache levels except 0
	dbg.StepOver();
	
	//	prefetch to all cache levels except 0 & 1
	dbg.StepOver();

	//	packed sum of absolute byte differences
	dbg.StepOver();
	testRegVal(cxx,"35","packed sum of absolute byte differences");

	dbg.StepOver();
	testRegVal(cxx,"35","packed sum of absolute byte differences");
	
	//	packed shuffle word
	dbg.StepOver();
	testRegVal(cxx,"281479271743489","packed shuffle word");

	dbg.StepOver();
	testRegVal(cxx,"578437695752307201","packed shuffle word");

	//	sfence
	dbg.StepOver();

	cxx.Disable();
}


void CEEPP::test_Katmai(COExpEval& cxx, CODebug& dbg, COSource& src)
{
	if (!(CMDLINE->GetBooleanValue("kni",FALSE)||CMDLINE->GetBooleanValue("wni",FALSE))) 
		return;	//	exit if P3 switch is not set	

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	MST.DoKeys("{ESC}");	
	EXPECT_TRUE(src.Find("test_Katmai();")); 
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());	
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());

	cxx.Enable(EE_ALL_INFO);

	char XMMijReg[][8] = {	"XMM00", "XMM01", "XMM02", "XMM03", 
							"XMM10", "XMM11", "XMM12", "XMM13", 
							"XMM20", "XMM21", "XMM22", "XMM23", 
							"XMM30", "XMM31", "XMM32", "XMM33", 
							"XMM40", "XMM41", "XMM42", "XMM43", 
							"XMM50", "XMM51", "XMM52", "XMM53", 
							"XMM60", "XMM61", "XMM62", "XMM63", 
							"XMM70", "XMM71", "XMM72", "XMM73"	};

	int num_reg = 32;
	int count = 0;

	//	set value in watch window
	for (count = 0; count <num_reg; count++)
	{
		cxx.SetExpressionValue(XMMijReg[count],count*50);
	}

	//	do one stepover
	EXPECT_TRUE(dbg.StepOver());

	//	verify value in watch window
	for (count = 0; count <num_reg; count++)
	{
		cxx.ExpressionValueIs(XMMijReg[count],count*50);
	}

	//	verify value in register window

	EXPECT_TRUE(regs.Enable());

	for (count = 0; count < num_reg; count++)
	{
		char str[16];
		double d = count*50;		
		sprintf(str,"+%.5E",d);

		EXPECT_TRUE(regs.RegisterValueIs(XMMijReg[count], str, 0, TRUE));	
	}

	EXPECT_TRUE(regs.Disable());


	//	verifying each register for expression evaluation
	dbg.StepOver();
	testRegVal(0, cxx,"1.00000","2.00000","3.00000","4.00000","verification xmm0");

	dbg.StepOver();
	testRegVal(1, cxx,"2.00000","3.00000","4.00000","5.00000","verification xmm1");

	dbg.StepOver();
	testRegVal(2, cxx,"3.00000","4.00000","5.00000","6.00000","verification xmm2");

	dbg.StepOver();
	testRegVal(3, cxx,"4.00000","5.00000","6.00000","7.00000","verification xmm3");

	dbg.StepOver();
	testRegVal(4, cxx,"5.00000","6.00000","7.00000","8.00000","verification xmm4");

	dbg.StepOver();
	testRegVal(5, cxx,"6.00000","7.00000","8.00000","9.00000","verification xmm5");

	dbg.StepOver();
	testRegVal(6, cxx,"7.00000","8.00000","9.00000","10.0000","verification xmm6");

	dbg.StepOver();
	testRegVal(7, cxx,"-1.00000","-2.00000","-3.00000", "6.00000","verification xmm7");


	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"3.00000","5.00000","7.00000","9.00000","addps");

	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","9.00000","addss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"0.000000","4.00000","0.000000","1.00000","andnps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"2.00000","2.00000","3.00000","3.50000","andnps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"0.000000","0.000000","0.000000","0.000000","andps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","4.00000","andps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"-1.#QNAN","-1.#QNAN","-1.#QNAN","0.000000","cmpeqps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"-1.#QNAN","-1.#QNAN","-1.#QNAN","-1.#QNAN","cmpeqps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","0.000000","cmpeqss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","-1.#QNAN","cmpeqss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"0.000000","-1.#QNAN","0.000000","0.000000","cmpltps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","0.000000","cmpltss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","0.000000","cmpltss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","-1.#QNAN","cmpltss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"-1.#QNAN","-1.#QNAN","0.000000","0.000000","cmpleps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","0.000000","cmpless");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","-1.#QNAN","cmpless");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","-1.#QNAN","cmpless");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"0.000000","-1.#QNAN","-1.#QNAN","0.000000","cmpneqps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","0.000000","cmpneqss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","-1.#QNAN","cmpneqss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"0.000000","-1.#QNAN","0.000000","-1.#QNAN","cmpnltps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","-1.#QNAN","cmpnltss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","0.000000","cmpnltss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","-1.#QNAN","cmpnltss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"0.000000","0.000000","0.000000","-1.#QNAN","cmpnleps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","-1.#QNAN","cmpnless");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","0.000000","cmpnless");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","0.000000","cmpnless");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","4.00000","comiss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","4.00000","comiss");
	
	dbg.StepOver();
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","4.00000","cvtpi2ps");

	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"8589934597","cvtps2pi");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","17.0000","cvtsi2ss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal("eax","unsigned long", cxx, "4", "cvtss2si");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"30064771077","cvttps2pi");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal("eax","unsigned long", cxx, "7", "cvttss2si");

	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"0.500000","1.00000","3.00000","4.00000","divps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","5.00000","divss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"5.00000","2.00000","9.00000","5.00000","maxps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"5.00000","2.00000","7.00000","6.00000","maxss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"5.00000","2.00000","7.00000","4.00000","maxss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"4.00000","2.00000","7.00000","3.00000","minps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","6.00000","minss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","4.00000","minss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"5.00000","6.00000","7.00000","8.00000","movaps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","5.00000","6.00000","movhlps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"6.00000","7.00000","3.00000","4.00000","movhps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","6.00000","7.00000","movlps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"5.00000","6.00000","3.00000","4.00000","movlhps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal("eax","unsigned long", cxx, "5", "movmskps");

	dbg.StepOver();
	dbg.StepOver();
	testRegVal("Var128.m128_f32[0]", "float", cxx, "-1.00000" ,"movntps");
	testRegVal("Var128.m128_f32[1]", "float", cxx, "9.00000" ,"movntps");
	testRegVal("Var128.m128_f32[2]", "float", cxx, "8.00000" ,"movntps");
	testRegVal("Var128.m128_f32[3]", "float", cxx, "7.00000" ,"movntps");

	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"0.000000","0.000000","0.000000","9.00000","movss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"5.00000","6.00000","7.00000","8.00000","movups");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"2.00000","6.00000","0.000000","10.0000","mulps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","8.00000","mulss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","3.00000","6.00000","5.00000","orps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"0.499878","0.333252","0.249939","0.199951","rcpps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","0.499878","rcpss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"0.999756","0.577271","0.499878","0.333252","rsqrtps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","0.333252","rsqrtss");
	
	dbg.StepOver();

	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"7.00000","5.00000","4.00000","2.00000","shufps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","1.73205","2.00000","3.00000","sqrtps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","3.00000","sqrtss");

	dbg.StepOver();
	testRegVal("i32Val","long", cxx, "8096", "stmxcsr");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"-1.00000","5.00000","1.00000","3.00000","subps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","8.00000","5.00000","-2.00000","subss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","4.00000","ucomiss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","5.00000","ucomiss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"5.00000","1.00000","6.00000","2.00000","unpckhps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"7.00000","3.00000","8.00000","4.00000","unpcklps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"0.000000","0.000000","1.76324e-038","2.93874e-039","xorps");

	cxx.Disable();

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\ee\eespec.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	EECASE.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "eespec.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
IMPLEMENT_TEST(CSpecialTypesTest, CDbgTestBase, "PtFns VARIANTs GUIDs HRs Errs MMX", -1, CEESubSuite)
									   
												 
void CSpecialTypesTest::PreRun(void)
	{
	// call the base class
	CTest::PreRun();
	}


void CSpecialTypesTest::Run(void)	
{
	/******************
	 * INITIALIZATION * non-incremental - just for PointerToFunctions
	 ******************/
#pragma message (__LOC__ "Revise incremental & add other switches when VC#8157 fixed")
	if(!SetProject("ee2\\ee2"))
	{
		m_pLog->RecordInfo("ERROR: could not init non-incremental ee2 project");
		return;
	}

	// step into the main function
	dbg.StepInto();	
	dbg.SetSteppingMode(SRC);

	EXPECT_TRUE( src.AttachActiveEditor() );
	cxx.Enable();
	/******************************************
	 * PointerToFunc on non-incremental build *
	 ******************************************/
#pragma message (__LOC__ "Disabled PointerToFun, because VC98#8157 is postponed")
//	PointerToFun();

	/******************
	 * INITIALIZATION *
	 ******************/
	if(!SetProject("ee2\\ee2",PROJECT_EXE,fDefault,"INCREMENTAL"))
	{
		m_pLog->RecordInfo("ERROR: could not init incremental ee2 project");
		return;
	}

	// step into the main function
	dbg.StepInto();	
	dbg.SetSteppingMode(SRC);

	EXPECT_TRUE( src.AttachActiveEditor() );
	cxx.Enable();

	EXPECT_TRUE(cxx.GetExpressionValue("@TIB", m_TIBValue) );
		
	/*********
	 * TESTS *
	 *********/
#pragma message (__LOC__ "Disabled PointerToFun, because VC98#8157 is postponed")
//	PointerToFun();
	XSAFETY;
	GUIDs();
	XSAFETY;
	Variants();
	XSAFETY;
	MMXRegs();
	XSAFETY;
	ErrorCodes();

	StopDbgCloseProject();
}

//PointerToFun
void CSpecialTypesTest::PointerToFun(void)
{
 	LogTestHeader( "PointerToFunctions Test" );

	EXPECT_TRUE(bps.SetBreakpoint("pointers_to_functions") );
	EXPECT_TRUE(dbg.Go("pointers_to_functions") );
//pointers to functions
	EXPECT_TRUE( src.Find("aclass.pfnint = afuncint;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "aclass.pfnint = afuncint;") );

	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("pfunint_table[0]", "ADDRESS afuncint(void *,unsigned long)") );
	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("pfunvar", "ADDRESS afunvar1(char *, <no type>)") );

	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("afuncint", "ADDRESS afuncint(void *, unsigned long)") );
	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("afunvar1", "ADDRESS afunvar1(char *, <no type>)") );

//pointers to functions as members of class
	EXPECT_TRUE(dbg.CurrentLineIs("aclass.pfnint = afuncint;") );
	EXPECT_TRUE(dbg.StepOver() );
	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("pclass->pfnint", "ADDRESS afuncint(void *, unsigned long)") );

	EXPECT_TRUE(dbg.CurrentLineIs("aclass.pfnvar = afuncvar;") );
	EXPECT_TRUE(dbg.StepOver() );
	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("pclass->pfnvar", "ADDRESS afuncvar(void *, <no type>)") );

	EXPECT_TRUE(dbg.CurrentLineIs("aclass.pfnvar = (PFNVAR)afunvar1;") );
	EXPECT_TRUE(dbg.StepOver() );
	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("pclass->pfnvar", "ADDRESS afunvar1(char *, <no type>)") );

	EXPECT_TRUE(dbg.CurrentLineIs("aclass.pfnvar = (PFNVAR)afunvar2;") );
	EXPECT_TRUE(dbg.StepOver() );
	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("pclass->pfnvar", "ADDRESS afunvar2(int *, int, <no type>)") );
//stepping into the class member - pointer to a function
	EXPECT_TRUE( src.Find("ret=(*aclass.pfnvar)(&ret,15,&ret);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL) );
	EXPECT_TRUE( dbg.StepInto( ) );
	EXPECT_TRUE( dbg.AtSymbol("afunvar2") );

//chaek if vtable pointers are correct
	EXPECT_TRUE( src.Find("memset(class_table,0, sizeof(class_table));") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "memset(class_table,0, sizeof(class_table));") );
	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("(class_table[0]).__vfptr[0]", "ADDRESS AClass::virt_method1(void)") );
	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("(class_table[0]).__vfptr[1]", "ADDRESS AClass::virt_method2(long, <no type>)") );
	//NULLify all pointers by executing memset(0,...)
	EXPECT_TRUE( dbg.StepOver( ) );
	EXPECT_TRUE( cxx.ExpressionErrorIs("(class_table[0]).__vfptr[0]", "Error: cannot display value") );
	EXPECT_TRUE( cxx.ExpressionErrorIs("(class_table[0]).__vfptr[1]", "Error: cannot display value") );
	//assign the object from a class
	EXPECT_TRUE(dbg.CurrentLineIs("class_table[0] = aclass;") );
	EXPECT_TRUE( dbg.StepOver( ) );
//class assignment does override function pointers but does not override vtable
	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("(aclass).__vfptr[0]", "ADDRESS AClass::virt_method1(void)") );
	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("(aclass).__vfptr[1]", "ADDRESS AClass::virt_method2(long, <no type>)") );
	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("class_table[0].pfnint", "ADDRESS afuncint(void *, unsigned long)") );
	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("class_table[0].pfnvar", "ADDRESS afunvar2(int *, int, <no type>)") );
	EXPECT_TRUE(cxx.ExpressionErrorIs("(class_table[0]).__vfptr[0]", "Error: cannot display value") );
	EXPECT_TRUE(cxx.ExpressionErrorIs("(class_table[0]).__vfptr[1]", "Error: cannot display value") );
//function which returns a pointer to a function
	EXPECT_TRUE(bps.SetBreakpoint("fun_return_pfn") );
	EXPECT_TRUE(dbg.Go("fun_return_pfn") );
	EXPECT_TRUE(dbg.StepOut() );
//verify in autopane the string "fun_return_pfn returned"	"ADDRESS afuncint(void *, unsigned long)"
	uivar.Activate();
	ERROR_SUCCESS(uivar.SetPane(PANE_AUTO) );
	EXPR_INFO expr_info_actual[1], expr_info_expected[1];
	
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));

	
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, 
		"void (void *, unsigned long)*",
		"fun_return_pfn returned",
		"ADDRESS afuncint(void *, unsigned long)");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1) );
	EXPECT_TRUE(dbg.ShowNextStatement() ); //uivar.Activate() steals the focus
	
	bps.ClearAllBreakpoints();
}//PointerToFun


//GUIDs
void CSpecialTypesTest::GUIDs(void)
{
 	LogTestHeader( "GUIDs Test" );
	
	char badGUIDstring[40]; //{????????-????-????-????-????????????}
	memset(badGUIDstring,'?',sizeof(badGUIDstring));
	badGUIDstring[0]='{';badGUIDstring[37]='}';badGUIDstring[38]=0;
	badGUIDstring[9]=badGUIDstring[14]=badGUIDstring[19]=badGUIDstring[24]='-';
	
	EXPECT_TRUE(bps.SetBreakpoint("guids_and_refguids") );
	EXPECT_TRUE(dbg.Go("guids_and_refguids") );
//check some global guids initialization
	EXPECT_TRUE( cxx.ExpressionValueIs("Global_Guid", "{00000000-0000-0000-0000-000000000000}") );
	EXPECT_TRUE( cxx.ExpressionValueIs("unKnownGuid", "{F0FF0FF0-FF0F-FF0F-FF00-FF00FF00FF00}") );

//check all value (including locals) at the following checkpoint	
	EXPECT_TRUE( src.Find("pGuid =&CLSID_FileProtocol;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, /*"pGuid*/"d =&CLSID_FileProtocol;") );
	MST.DoKeys("{HOME}"); //get out of the assignment

	EXPECT_TRUE( cxx.ExpressionValueIs("Guid", "{IID_IClassFactory}") );
	EXPECT_TRUE( cxx.ExpressionValueIs("Global_Guid", "{IID_IClassFactory2}") );
	EXPECT_TRUE( cxx.ExpressionValueSubstringIs("pGuid", "ADDRESS {IID_IClassFactory}") );
	EXPECT_TRUE(cxx.ExpressionErrorIs("pBadGuid", CString("0x00000005 ") + badGUIDstring) );
	EXPECT_TRUE(cxx.ExpressionErrorIs("pBadrefId", badGUIDstring) );
	EXPECT_TRUE( cxx.ExpressionValueIs("unKnown", "{F0FF0FF0-FF0F-FF0F-FF00-FF00FF00FF00}") );

//check all REFIIDs after the checkpoint was executed
	EXPECT_TRUE( src.Find("return_Unknown();") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "return_Unknown();") );
static char* data[][2] = {
	"refiid0",		"{IID_IUnknown}",
	"refiid1",		"{IID_IDispatch}",
	"refiid2",		"{IID_IMoniker}",
	"refiid3",		"{IID_IEnumString}",
	"refiid4",		"{IID_IStream}",
	"refiid5",		"{IID_IStorage}",
	"refiid6",		"{IID_IPersistStorage}",
	"refiid7",		"{IID_IPersist}",
	"refiid8",		"{IID_IActiveScript}",
	"refiid9",		"{IID_IObjectSafety}",
};
	for(int i = 0; i < (sizeof(data) / (sizeof(CString) * 2)); i++)
	{
		LOG->RecordCompare(cxx.ExpressionValueIs(data[i][0], data[i][1]),
			"Expression:(%s), expected:(%s)\n", data[i][0],data[i][1]);
	}

	uivar.Activate();
	ERROR_SUCCESS(uivar.SetPane(PANE_AUTO) );
	EXPR_INFO expr_info_actual[1], expr_info_expected[1];

	EXPECT_TRUE( dbg.StepOver() );
//verify in autopane the string "const _GUID &" "return_Unknown returned"	"{IID_IUnknown}"
		
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, 
		"const _GUID &",
		"return_Unknown returned",
		"{IID_IUnknown}");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1) );

	EXPECT_TRUE( dbg.StepOver() );		
//verify in autopane the string "_GUID" "return_GUIDUnknown returned"	"{IID_IUnknown}"
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, 
		"_GUID",
		"return_GUIDUnknown returned",
		"{IID_IUnknown}");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1) );

	EXPECT_TRUE(dbg.ShowNextStatement() ); //uivar.Activate() steals the focus
	bps.ClearAllBreakpoints();
}//GUIDs


//VARIANTs
#include <wtypes.h> //for VT_BYREF define
void CSpecialTypesTest::Variants(void)
{
 	LogTestHeader( "VARIANTs Test" );
	char badVARIANTstring[6]; //{???}
	memset(badVARIANTstring,'?',sizeof(badVARIANTstring));
	badVARIANTstring[0]='{';badVARIANTstring[4]='}';badVARIANTstring[5]=0;

//check the variant1 before being initialized
	EXPECT_TRUE( src.Find("::VariantInit(&variant1);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "VariantInit(&variant1);") );
	EXPECT_TRUE( cxx.ExpressionValueIs("variant1", badVARIANTstring) );
	EXPECT_TRUE(dbg.StepOver() ); //initialize the variant

//	added by dverma 4/25/2000 to check date for Win NT
	char strDateVal[64];

	if (GetSystem() == SYSTEM_NT_4)	//	NT4.0
		sprintf(strDateVal,"{1/1/96 12:00:00 AM VT_DATE}");	
	else
		sprintf(strDateVal,"{1/1/1996 12:00:00 AM VT_DATE}");	
		
	//check the variant1 assigned different values
	static char* variant1data[][2] = { //"line of code identifying variant", "variant value" 
		"variant1.vt = VT_I4;",		"{1052 VT_I4}",
		"variant1.vt = VT_UI1;",	"{255 VT_UI1}",
		"variant1.vt = VT_I2;",		"{32000 VT_I2}",
		"variant1.vt = VT_R4;",		"{20.0000 VT_R4}",
		"variant1.vt = VT_R8;",		"{3.1400000000000e+100 VT_R8}",
		"variant1.vt = VT_BOOL;",	"{True VT_BOOL}",
		"variant1.vt = VT_ERROR;",	"{0x80004005 VT_ERROR}",
		"variant1.vt = VT_CY;",		"{922337203685477.5807 VT_CY}",
		"variant1.vt = VT_DATE;",	strDateVal
	};

	for(int i = 0; i < (sizeof(variant1data) / (sizeof(CString) * 2)); i++)
	{
		EXPECT_TRUE(dbg.CurrentLineIs(variant1data[i][0]) );
		dbg.StepOver(2);
		LOG->RecordCompare(cxx.ExpressionValueIs("variant1", variant1data[i][1]),
			"variant1 expected:(%s)\n",variant1data[i][1]);
	}
//check the variant2 assigned different stricte automation type values
	EXPECT_TRUE( src.Find("variant2.vt = VT_BSTR;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "variant2.vt = VT_BSTR;") );
	EXPECT_TRUE( dbg.StepOver() );
	
	//	modified by dverma 6/21/2000 - now variant shows string instead of badvalue
//	EXPECT_TRUE( cxx.ExpressionValueIs("variant2", badVARIANTstring) ); //VT_BSTR but pointing to bad address
	char tempstr[16];
	strcpy(tempstr,"{\"\" VT_BSTR}");	//	{"" VT_BSTR}
	EXPECT_TRUE( cxx.ExpressionValueIs("variant2", tempstr) ); //VT_BSTR

	EXPECT_TRUE( dbg.StepOverUntilLine("::SysFreeString(variant2.bstrVal);") );
	LOG->RecordCompare( cxx.ExpressionValueIs("variant2", "{\"BSTR test\" VT_BSTR}"),
		"variant2 shld be \"BSTR test\"");
	dbg.StepOver();

static char* variant2data[][2] = { //"line of code identifying variant", "variant value" 
	"variant2.vt = VT_UNKNOWN;",	"{0x000000ff VT_UNKNOWN}",
	"variant2.vt = VT_DISPATCH;",	"{0x000000ff VT_DISPATCH}",
	"variant2.vt = VT_ARRAY;",		"{0x000000ff VT_ARRAY}",
};
	for(i = 0; i < (sizeof(variant2data) / (sizeof(CString) * 2)); i++)
	{
		EXPECT_TRUE(dbg.CurrentLineIs(variant2data[i][0]) );
		dbg.StepOver(2);
		LOG->RecordCompare(cxx.ExpressionValueIs("variant2", variant2data[i][1]),
			"variant2 expected:(%s)\n",variant2data[i][1]);
	}
	dbg.StepOver(); //Init of global variant

	if (GetSystem() == SYSTEM_NT_4)	//	NT4.0
		sprintf(strDateVal,"{7/31/97 10:50:59 PM VT_DATE|VT_BYREF}");	
	else
		sprintf(strDateVal,"{7/31/1997 10:50:59 PM VT_DATE|VT_BYREF}");	

	//check the glob_variant assigned different VT_BYREF values
	static char* globvariantdata[][2] = { //"line of code identifying variant", "variant value" 
		"glob_variant.vt = VT_UI1|VT_BYREF;",		"{255 VT_UI1|VT_BYREF}",
		"glob_variant.vt = VT_I2|VT_BYREF;",		"{1000 VT_I2|VT_BYREF}",
		"glob_variant.vt = VT_I4|VT_BYREF;",		"{1000000 VT_I4|VT_BYREF}",
		"glob_variant.vt = VT_R4|VT_BYREF;",		"{20.0000 VT_R4|VT_BYREF}",
		"glob_variant.vt = VT_R8|VT_BYREF;",		"{10.000000000000 VT_R8|VT_BYREF}",
		"glob_variant.vt = VT_BOOL|VT_BYREF;",		"{False VT_BOOL|VT_BYREF}",
		"glob_variant.vt = VT_ERROR|VT_BYREF;",		"{0x80004001 VT_ERROR|VT_BYREF}",
		"glob_variant.vt = VT_CY|VT_BYREF;",		"{-922337203685477.5808 VT_CY|VT_BYREF}",
		"glob_variant.vt = VT_DATE|VT_BYREF;",		strDateVal,
		"glob_variant.vt = VT_UNKNOWN|VT_BYREF;",	badVARIANTstring, //pVal==5 (bad pointer)
		"glob_variant.vt = VT_DISPATCH|VT_BYREF;",	badVARIANTstring, //pVal==5 (bad pointer)
		"glob_variant.vt = VT_ARRAY|VT_BYREF;",		badVARIANTstring, //pVal==5 (bad pointer)
		"glob_variant.vt = VT_VARIANT|VT_BYREF;",	"{VT_VARIANT|VT_BYREF}",
	};


	for(i = 0; i < (sizeof(globvariantdata) / (sizeof(CString) * 2)); i++)
	{
		EXPECT_TRUE(dbg.CurrentLineIs(globvariantdata[i][0]) );
		dbg.StepOver(2);
		LOG->RecordCompare(cxx.ExpressionValueIs("glob_variant", globvariantdata[i][1]),
			"glob_variant expected:(%s)\n",globvariantdata[i][1]);
	}
	//the last variant references itself
	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("glob_variant.pvarVal", "ADDRESS struct tagVARIANT  glob_variant") );
	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("*glob_variant.pvarVal", "{VT_VARIANT|VT_BYREF}") );

	dbg.StepOver(); //glob_variant references variant2
	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("glob_variant.pvarVal", "ADDRESS {0x000000ff VT_ARRAY}") );

//check reference to BSTR
	EXPECT_TRUE( src.Find("SysFreeString(pbstrVal);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "SysFreeString(pbstrVal);") );
	LOG->RecordCompare( cxx.ExpressionValueIs("glob_variant", "{\"PBST test\" VT_BSTR|VT_BYREF}"),
		"glob_variant shld be \"PBST test\"");
//check variant2 - non-statc, local variant
	EXPECT_TRUE( src.Find("void* anyref=&subvariant;variant2.byref = &subvariant;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "void* anyref=&subvariant;variant2.byref = &subvariant;") );
	EXPECT_TRUE(cxx.ExpressionValueIs("variant2", badVARIANTstring) ); //pointer is still bad (==0xff)
	dbg.StepOver(); 
	EXPECT_TRUE(cxx.ExpressionValueIs("variant2", badVARIANTstring) );//now the pointer is valid, pointing to subvariant, but "{VT_BYREF}" is wrong variant type, according to DOCs
	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("(tagVARIANT*)variant2.byref", "ADDRESS {10 VT_I4}") );
//check simple values of variant2
static char strVT_UI2_VT_BYREF[50];
	strVT_UI2_VT_BYREF[0]='{';
	itoa(VT_UI2|VT_BYREF,strVT_UI2_VT_BYREF+1,10);
	strcat(strVT_UI2_VT_BYREF, " VT_UI2|VT_BYREF}"); //it will be a variant value pointing to itself 
static char* simpledata[][2] = { //"line of code identifying variant", "variant value" 
	"variant2.vt = VT_I1;",		"{86 'V' VT_I1}",
	"variant2.vt = VT_UI2;",	"{65535 VT_UI2}",
	"variant2.vt = VT_UI4;",	"{4294967295 VT_UI4}",
	"variant2.vt = VT_INT;",	"{-256 VT_INT}",
	"variant2.vt = VT_UINT;",	"{256 VT_UINT}",
	"variant2.vt = VT_DECIMAL|VT_BYREF;",	"{0.0000000018446744073709551616 VT_DECIMAL|VT_BYREF}",
	"variant2.vt = VT_I1|VT_BYREF;",		"{99 'c' VT_I1|VT_BYREF}", //display only 1 char as it's  marshalled
	"variant2.vt = VT_UI2|VT_BYREF;",		strVT_UI2_VT_BYREF, //bogus, pointing to itself,
	"variant2.vt = VT_UI4|VT_BYREF;",		badVARIANTstring, //pVal==5 (bad pointer),
	"variant2.vt = VT_INT|VT_BYREF;",		badVARIANTstring, //pVal==NULL (bad pointer),
	"variant2.vt = VT_UINT|VT_BYREF;",		badVARIANTstring, //pVal==0xff (bad pointer)
};

	for(i = 0; i < (sizeof(simpledata) / (sizeof(CString) * 2)); i++)
	{
		EXPECT_TRUE(dbg.CurrentLineIs(simpledata[i][0]) );
		dbg.StepOver(2);
		LOG->RecordCompare(cxx.ExpressionValueIs("variant2", simpledata[i][1]),
			"simple variant2 expected:(%s)\n",simpledata[i][1]);
	}

	uivar.Activate();
	ERROR_SUCCESS(uivar.SetPane(PANE_AUTO) );
	EXPR_INFO expr_info_actual[1], expr_info_expected[1];

	EXPECT_TRUE( dbg.StepOver() );
//check return_variant function returns the VARIANT
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 3 /*ROW_BOTTOM does not exist*/));
	
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, 
		"tagVARIANT", "return_variant returned", "{65535 VT_I4}" );
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1) );
	EXPECT_TRUE(dbg.ShowNextStatement() ); //uivar.Activate() steals the focus

}//VARIANTs

BOOL MMX_Chip()
{
#pragma warning(disable:4035)
	__asm{
		mov eax,1;
		_emit 0x0f; //CPUID
		_emit 0xa2; //CPUID
		mov eax,1;
		test edx,0x0800000;
		jnz Yes
		mov eax,0
Yes:
	}
	return;
#pragma warning(default:4035)
}

//MMXRegs
void CSpecialTypesTest::MMXRegs(void)
{
 	LogTestHeader( "MMX Test" );
	if(!MMX_Chip())
	{
		LOG->RecordInfo("No MMX chip detected - skipping the test");
		return;
	}
}//MMXRegs

//ErrorCodes
void CSpecialTypesTest::ErrorCodes(void)
{
	char lastErrorLoc[16];

	//	this code needed due to bug 65586 - dverma 4/26/2000
	if (GetSystem() == SYSTEM_WIN_MILL)
	{
		strcpy(lastErrorLoc,"dw @tib+0x74");		//	location of last error set
	}
	else
	{
		strcpy(lastErrorLoc,"@ERR");
	}


static char* data[][2] = {
	"s_ok,hr",			"S_OK",
	"s_err,hr",			"E_NOINTERFACE",
	"s_unexp,hr",		"E_UNEXPECTED",
	"s_eomem,hr",		"E_OUTOFMEMORY",
//NOTE extra space required after a full text of message
	"5,hr",				"0x00000005 Access is denied. ",
	"8,hr",				"0x00000008 Not enough storage is available to process this command. ",
	"24L,hr",			"0x00000018 The program issued a command but the command length is incorrect. ",
//this message is truncated by the debugger	
	"0x95L,hr",			"0x00000095 An attempt was made to join or substitute a drive for which a directory on the drive is the target of a previous sub",
	lastErrorLoc,				"42",
};

 	LogTestHeader( "ErrorCodes Test" );

	src.Find("_asm int 3;");	
	dbg.StepToCursor();	

	for(int i = 0; i < (sizeof(data) / (sizeof(CString) * 2)); i++)
	{
		LOG->RecordCompare(cxx.ExpressionValueIs(data[i][0], data[i][1]),
			"Expression:(%s), expected:(%s)\n", data[i][0],data[i][1]);
	}
	CString strTIBEqual = "@TIB==" + m_TIBValue;
	LOG->RecordCompare(cxx.ExpressionValueIs(strTIBEqual, "1"),
			"TIB is equal:(%s)\n", m_TIBValue);

	//TODO fill with tests for the actual value of TIB?
}//ErrorCodes
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\ee\eesub.h ===
///////////////////////////////////////////////////////////////////////////////
//	EESUB.H
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CEESubSuite class
//

#ifndef __EESUB_H__
#define __EESUB_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CEESubSuite class

class CEESubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CEESubSuite)
	DECLARE_TESTLIST()
protected:
	void CleanUp(void);
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\ee\eecase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	EECASE.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "eecase.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
IMPLEMENT_TEST(CEEIDETest, CDbgTestBase, "General", -1, CEESubSuite)
									   
												 
void CEEIDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}


char* data[][2] = 

{
	// note: the class "derived1" and its base classes are all declared in headers
	//       and implemented in cpp files.

	// non-inherited, non-overloaded member function.
	// public member function.
	"derived1_obj.derived1_public_func",		"ADDRESS derived1::derived1_public_func(int)",         
	"derived1_obj_ptr->derived1_public_func",	"ADDRESS derived1::derived1_public_func(int)",
	    
	// inherited, non-overloaded, non-overridden member function.
	"derived1_obj.base2_func",		"ADDRESS base2::base2_func(int)",                                
	"derived1_obj_ptr->base2_func",	"ADDRESS base2::base2_func(int)",                           
	
	// inherited, overloaded, non-overridden member function.
	"derived1_obj.base1_overloaded_func",				"ADDRESS derived1::base1_overloaded_func(char)",      
	"derived1_obj_ptr->base1_overloaded_func",			"ADDRESS derived1::base1_overloaded_func(char)", 
	"derived1_obj.base1_overloaded_func(char)",			"ADDRESS derived1::base1_overloaded_func(char)",     
	"derived1_obj_ptr->base1_overloaded_func(char)",	"ADDRESS derived1::base1_overloaded_func(char)",
	// TODO: can't get at (int) version; can't even step into it.
	//"derived1_obj.base1_overloaded_func(int)",		"ADDRESS base1::base1_overloaded_func(int)",     
	//"derived1_obj_ptr->base1_overloaded_func(int)",	"ADDRESS base1::base1_overloaded_func(int)",
	
	// inherited, non-overloaded, overridden member function.
	"derived1_obj.base1_overridden_func",		"ADDRESS derived1::base1_overridden_func(int)",
 	"derived1_obj_ptr->base1_overridden_func",	"ADDRESS derived1::base1_overridden_func(int)",

	// virtual inherited non-overloaded, overridden member function.
	// TODO: only getting addresses when these are evaluated.
	//"derived1_obj.base1_virtual_func",		"ADDRESS derived1::base1_virtual_func(int)",
	//"derived1_obj_ptr->base1_virtual_func", "ADDRESS derived1::base1_virtual_func(int)",

	// static member function.
	// TODO: can't link when defined in class.
	//"derived1::derived1_static_func", "ADDRESS derived1::derived1_static_func(int)",
	
	// static member variable.
	"derived1::derived1_static_var", "1",

	// pointer to member variable.
	// TODO: seems to point to wrong place.
	//"*ptr_to_mem_var", "3",

	// pointer to member function.
	// TODO: just get address.
	// "*ptr_to_mem_func", "ADDRESS derived1::derived1_public_func(int)",

	// class-nested enum.
	"derived1_obj.enum_class_var",		"two_class",
	"derived1_obj_ptr->enum_class_var", "two_class",
	"derived1::one_class",				"1",
	"derived1::two_class",				"2",
	"derived1::three_class",			"3",

	// non-inherited, non-static, member variable.
	// public member variable.
	"derived1_obj.derived1_public_var",			"3",
	"derived1_obj_ptr->derived1_public_var",	"3",

	// inherited member variable.
	"derived1_obj.base1_var",		"1",
	"derived1_obj_ptr->base1_var",	"1",

	// protected member function.
	"derived1_obj.derived1_protected_func",			"ADDRESS derived1::derived1_protected_func(int)",         
	"derived1_obj_ptr->derived1_protected_func",	"ADDRESS derived1::derived1_protected_func(int)",

	// private member function.
	"derived1_obj.derived1_private_func",		"ADDRESS derived1::derived1_private_func(int)",         
	"derived1_obj_ptr->derived1_private_func",	"ADDRESS derived1::derived1_private_func(int)",

	// private member variable.
	"derived1_obj.derived1_private_var",		"4",
	"derived1_obj_ptr->derived1_private_var",	"4",

	// protected member variable.
	"derived1_obj.derived1_protected_var",		"5",
	"derived1_obj_ptr->derived1_protected_var",	"5",

	// class defined in dll.
	// TODO: get "member function not present".
	//"dll_class_obj.dll_class_func",			"ADDRESS dll_class::dll_class_func(int)",
	//"dll_class_obj_ptr->dll_class_func",	"ADDRESS dll_class::dll_class_func(int)",
	"dll_class_obj.dll_class_var",			"0",
	"dll_class_obj_ptr->dll_class_var",		"0",

	// struct (declared in header, implemented in cpp file).
	"struct1_obj.struct1_func",			"ADDRESS struct1::struct1_func(int)",
	"struct1_obj_ptr->struct1_func",	"ADDRESS struct1::struct1_func(int)",
	"struct1_obj.struct1_var",			"0",
	"struct1_obj_ptr->struct1_var",		"0",

	// union (declared in header, implemented in cpp file).
	"union1_obj.union1_func",		"ADDRESS union1::union1_func(int)",
	"union1_obj_ptr->union1_func",	"ADDRESS union1::union1_func(int)",
	"union1_obj.union1_var",		"0",
	"union1_obj_ptr->union1_var",	"0",

	// class (declared and implemented in cpp file).
	// TODO: get "member function not present"
	//"class_cpp_obj.class_cpp_func",			"ADDRESS class_cpp::class_cpp_func(int)",
	//"class_cpp_obj_ptr->class_cpp_func",	"ADDRESS class_cpp::class_cpp_func(int)",
	"class_cpp_obj.class_cpp_var",			"0",
	"class_cpp_obj_ptr->class_cpp_var",		"0",

	// struct (declared and implemented in cpp file).
	// TODO: get "member function not present"
	//"struct_cpp_obj.struct_cpp_func",		"ADDRESS struct_cpp::struct_cpp_func(int)",
	//"struct_cpp_obj_ptr->struct_cpp_func",	"ADDRESS struct_cpp::struct_cpp_func(int)",
	"struct_cpp_obj.struct_cpp_var",		"0",
	"struct_cpp_obj_ptr->struct_cpp_var",	"0",

	// union (declared and implemented in cpp file).
	// TODO: get "member function not present"
	//"union_cpp_obj.union_cpp_func",			"ADDRESS union_cpp::union_cpp_func(int)",
	//"union_cpp_obj_ptr->union_cpp_func",	"ADDRESS union_cpp::union_cpp_func(int)",
	"union_cpp_obj.union_cpp_var",			"0",
	"union_cpp_obj_ptr->union_cpp_var",		"0",

	// enum (defined in cpp file)
	"enum_cpp_var",	"three_cpp",
	"one_cpp",		"1",
	"two_cpp",		"2",
	"three_cpp",	"3",

	// class (declared in pch file, implemented in cpp file).
	"class_pch_obj.class_pch_func",			"ADDRESS class_pch::class_pch_func(int)",
	"class_pch_obj_ptr->class_pch_func",	"ADDRESS class_pch::class_pch_func(int)",
	"class_pch_obj.class_pch_var",			"0",
	"class_pch_obj_ptr->class_pch_var",		"0",

	// struct (declared in pch file, implemented in cpp file).
	"struct_pch_obj.struct_pch_func",		"ADDRESS struct_pch::struct_pch_func(int)",
	"struct_pch_obj_ptr->struct_pch_func",	"ADDRESS struct_pch::struct_pch_func(int)",
	"struct_pch_obj.struct_pch_var",		"0",
	"struct_pch_obj_ptr->struct_pch_var",	"0",

	// union (declared in pch file, implemented in cpp file).
	"union_pch_obj.union_pch_func",			"ADDRESS union_pch::union_pch_func(int)",
	"union_pch_obj_ptr->union_pch_func",	"ADDRESS union_pch::union_pch_func(int)",
	"union_pch_obj.union_pch_var",			"0",
	"union_pch_obj_ptr->union_pch_var",		"0",

	// enum (defined in pch file)
	"enum_pch_var",	"two_pch",
	"one_pch",		"1",
	"two_pch",		"2",
	"three_pch",	"3",

	// class (defined locally).
	"class_local_obj.class_local_var",		"0",
	"class_local_obj_ptr->class_local_var",	"0",

	// struct (defined locally).
	"struct_local_obj.struct_local_var",		"0",
	"struct_local_obj_ptr->struct_local_var",	"0",

	// union (defined locally).
	"union_local_obj.union_local_var",		"0",
	"union_local_obj_ptr->union_local_var",	"0",

	// enum (defined locally)
	"enum_local_var",	"one_local",
	"one_local",		"1",
	"two_local",		"2",
	"three_local",		"3",

	// non-overloaded global function.
	"global_func", "ADDRESS global_func(int)",

	// overloaded global function.
	"overloaded_global_func",		"ADDRESS overloaded_global_func(char)",
	"overloaded_global_func(int)",	"ADDRESS overloaded_global_func(int)",
	"overloaded_global_func(char)",	"ADDRESS overloaded_global_func(char)",
	
	// global variable.
	"global_var", "0",

	// static local variable.
	"static_local_var", "0",

	// namespace function.
	"namespace1::namespace1_func", "ADDRESS namespace1::namespace1_func(int)",

	// namespace variable.
	"namespace1::namespace1_var", "1",
	
	// in-line function (defined in header)
	// TODO: can't find this symbol.
	//"inline_func", "ADDRESS inline_func(int)",
	
	// enum (defined in header)
	"enum1_var",	"two",
	"one",			"1",
	"two",			"2",
	"three",		"3" 
};


// in order to initialize the "tests" array like we do below we need to mimmic the EXPR_INFO
// class which uses CStrings instead of LPCSTRs. CStrings prevent such initialization.
struct EXPR_INFO2
{
	EXPR_STATE	state;
	LPCSTR		type;
	LPCSTR		name;
	LPCSTR		value;
};


// initialize the data for all the tests (state, type, name, and value of each expression).
EXPR_INFO2 tests[] =

{
	// local const primitive.
	{NOT_EXPANDABLE,	"const int",	"const_int",	"0"},
	{COLLAPSED,			"const int *",	"pconst_int",	"ADDRESS"},
	{NOT_EXPANDABLE,	"const int",	"*pconst_int",	"0"},
	{NOT_EXPANDABLE,	"const int",	"int_const",	"0"},
	{COLLAPSED,			"const int *",	"pint_const",	"ADDRESS"},
	{NOT_EXPANDABLE,	"const int",	"*pint_const",	"0"},

	// global const primitive.
	{NOT_EXPANDABLE,	"const int",	"gconst_int",	"0"},
	{COLLAPSED,			"const int *",	"gpconst_int",	"ADDRESS gconst_int"},
	{NOT_EXPANDABLE,	"const int",	"*gpconst_int", "0"},
	{NOT_EXPANDABLE,	"const int",	"gint_const",	"0"},
	{COLLAPSED,			"const int *",	"gpint_const",	"ADDRESS gint_const"},
	{NOT_EXPANDABLE,	"const int",	"*gpint_const", "0"},

	// member const primitive.
	// TODO(michma - 2/13/98): fails due to bug VS98: 30574.
	//{NOT_EXPANDABLE,	"const int",	"class_cpp_obj.m_const_int",	"0"},
	{COLLAPSED,			"const int *",	"class_cpp_obj.m_pconst_int",	"ADDRESS"},
	{NOT_EXPANDABLE,	"const int",	"*class_cpp_obj.m_pconst_int",	"0"},
	// TODO(michma - 2/13/98): fails due to bug VS98: 30574.
	//{NOT_EXPANDABLE,	"const int",	"class_cpp_obj.m_int_const",	"0"},
	{COLLAPSED,			"const int *",	"class_cpp_obj.m_pint_const",	"ADDRESS"},
	{NOT_EXPANDABLE,	"const int",	"*class_cpp_obj.m_pint_const",	"0"},

	// local const struct.
	// TODO(michma - 2/13/98): fails due to bug VS98:30574.
	//{COLLAPSED, "const struct_cpp",	"const_struct_cpp",		"{...}"},
	{COLLAPSED, "const struct_cpp *",	"pconst_struct_cpp",	"ADDRESS"},
	{COLLAPSED, "const struct_cpp",		"*pconst_struct_cpp",	"{...}"},
	// TODO(michma - 2/13/98): fails due to bug VS98: 30574.
	//{COLLAPSED, "const struct_cpp",	"struct_cpp_const",		"{...}"},
	{COLLAPSED, "const struct_cpp *",	"pstruct_cpp_const",	"ADDRESS"},
	{COLLAPSED, "const struct_cpp",		"*pstruct_cpp_const",	"{...}"},

	// global const struct.
	// TODO(michma - 2/13/98): fails due to bug VS98: 30574.
	//{COLLAPSED, "const struct_cpp",	"gconst_struct_cpp",	"{...}"},
	{COLLAPSED, "const struct_cpp *",	"gpconst_struct_cpp",	"ADDRESS gconst_struct_cpp"},
	{COLLAPSED, "const struct_cpp",		"*gpconst_struct_cpp",	"{...}"},
	// TODO(michma - 2/13/98): fails due to bug VS98: 30574.
	//{COLLAPSED, "const struct_cpp",	"gstruct_cpp_const",	"{...}"},
	{COLLAPSED, "const struct_cpp *",	"gpstruct_cpp_const",	"ADDRESS gstruct_cpp_const"},
	{COLLAPSED, "const struct_cpp",		"*gpstruct_cpp_const",	"{...}"},

	// member const struct.
	// TODO(michma - 2/13/98): fails due to bug VS98: 30574.
	//{COLLAPSED, "const struct_cpp",	"class_cpp_obj.m_const_struct_cpp",		"{...}"},
	{COLLAPSED, "const struct_cpp *",	"class_cpp_obj.m_pconst_struct_cpp",	"ADDRESS"},
	{COLLAPSED, "const struct_cpp",		"*class_cpp_obj.m_pconst_struct_cpp",	"{...}"},
	// TODO(michma - 2/13/98): fails due to bug VS98:30574.
	//{COLLAPSED, "const struct_cpp",	"class_cpp_obj.m_struct_cpp_const",		"{...}"},
	{COLLAPSED, "const struct_cpp *",	"class_cpp_obj.m_pstruct_cpp_const",	"ADDRESS"},
	{COLLAPSED, "const struct_cpp",		"*class_cpp_obj.m_pstruct_cpp_const",	"{...}"}
};


void CEEIDETest::Run(void)
	
{
	/******************
	 * INITIALIZATION *
	 ******************/

	if(!InitProject("ee\\dll", PROJECT_DLL))
	{
		m_pLog->RecordInfo("ERROR: could not init dll project");
		return;
	}

	if(!InitProject("ee\\ee"))
	{
		m_pLog->RecordInfo("ERROR: could not init ee project");
		return;
	}

	// step to the "return" in ee.exe (all objects will be in scope).
	src.Open("ee.cpp");
	src.Find("return 0;");	
	dbg.StepToCursor();	
	cxx.Enable();

	// evaluate all the expressions.
	for(int i = 0; i < (sizeof(data) / (sizeof(CString) * 2)); i++)
	{
		if(cxx.ExpressionValueIs(data[i][0], data[i][1]))
			LOG->RecordSuccess("%s\n", data[i][0]);
		else
			LOG->RecordFailure("%s\n", data[i][0]);
	}

	cxx.Disable();

	// we need to enable the ee differently for these tests since we want to check all expression info, not just values.
	cxx.Enable(EE_ALL_INFO);
	// we only want to randomly run each test once.
	RandomNumberCheckList rncl(sizeof(tests) / sizeof(EXPR_INFO2));
	// indexes into the test array.
	int iTest;
	
	// randomly run each test once.
	while((iTest = rncl.GetNext()) != -1)
	
	{
		// transfer EXPR_INFO2 data to EXPR_INFO object.
		EXPR_INFO expr_info;
		cxx.FillExprInfo(expr_info, tests[iTest].state, tests[iTest].type, tests[iTest].name, tests[iTest].value);
		
		if(cxx.VerifyExprInfo(expr_info))
			LOG->RecordSuccess("%s\n", expr_info.name);
		else
			LOG->RecordFailure("%s\n", expr_info.name);
	}

	cxx.Disable();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\exe\execase2.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	execase.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "execase2.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
											   
IMPLEMENT_TEST(Cexe2IDETest, CDebugTestSet, "Execution special", -1, CexeSubSuite)
												 
void Cexe2IDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

void Cexe2IDETest::Run()
{	 
	XSAFETY;
	
	if( SetProject("testgo01\\testgo01"))
	{	  
		XSAFETY;
		GoExeDoesNotExist();
		XSAFETY;
		ExitWhileDebugging();
		XSAFETY;
	}
		
	if (SetProject("dllapp\\incdll", PROJECT_DLL) && SetProject("dllapp\\powdll", PROJECT_DLL)
		&& SetProject("dllapp\\dec2", PROJECT_DLL) && SetProject("dllapp\\dllappx"))
	{
		XSAFETY;
//		StartDebugging();		// WinslowF
			
		EXPECT_TRUE(DllStepTrace());
		XSAFETY;
		EXPECT_TRUE(DllStepOut());
		XSAFETY;
		EXPECT_TRUE(DllTraceOut());
		XSAFETY;
		EXPECT_TRUE(CannotFindDll());
		XSAFETY;
		EXPECT_TRUE(StepOverFuncInUnloadedDll());
		XSAFETY;
		EXPECT_TRUE(RestartFromWithinDll());
		XSAFETY;
		EXPECT_TRUE(GoFromWithinDll());
		XSAFETY;
	}
	//	StopDbgCloseProject();
		Sleep(1000);

	if( SetProject("cons01\\cons01"))
	{	  
		XSAFETY;
		StdInOutRedirection();
		XSAFETY;
	}
 
	if( SetProject("dbga\\dbga"))
	{	  
		XSAFETY;
		NoSystemCodeStepping();
		XSAFETY;
	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\exe\execase.h ===
///////////////////////////////////////////////////////////////////////////////
//	execase.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CexeIDETest Class
//

#ifndef __execase_H__
#define __execase_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\dbgset.h"
#include "exesub.h"

///////////////////////////////////////////////////////////////////////////////
//	CexeIDETest class

class CexeIDETest : public CDebugTestSet
{
	DECLARE_TEST(CexeIDETest, CexeSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run();

// Test Cases
protected:

	// Go cases
	BOOL GoAndVerify();
	BOOL RestartAndGo();
	BOOL RestartStopDebugging();

	// Step cases
	BOOL StepIntoSource();
	BOOL StepOverSource();
	BOOL StepOutSource();
	BOOL StepToCursorSource();
	BOOL StepOverFuncToBreakAtLocBP();
	BOOL StepOverFuncToBreakOnExprTrueBP();
	BOOL StepOverFuncToBreakOnExprChangesBP();
	BOOL TraceIntoWndProc();

	BOOL StepModel();
	BOOL BreakStepTrace();

};

#endif //__execase_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\exe\execase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	execase.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "execase.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
											   
IMPLEMENT_TEST(CexeIDETest, CDebugTestSet, "Execution base", -1, CexeSubSuite)
												 
void CexeIDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();

}

void CexeIDETest::Run()
{	 
	XSAFETY;
	
	if( SetProject("testgo01\\testgo01"))
	{	  
		XSAFETY;
		GoAndVerify();
		XSAFETY;
		RestartAndGo();
		XSAFETY;
		RestartStopDebugging();
		XSAFETY;
		StepOverFuncToBreakAtLocBP();
		XSAFETY;
		StepOverFuncToBreakOnExprTrueBP();
		XSAFETY;
		StepOverFuncToBreakOnExprChangesBP();
		XSAFETY;
	}
		
	if( SetProject("testbp01\\testbp01") )
	{	  
		XSAFETY;
		StepOutSource();
		XSAFETY;
		StepOverSource();
		XSAFETY;
		StepIntoSource();
		XSAFETY;
		StepToCursorSource();
		XSAFETY;
	}
		
	// tests against example x

	if ( SetProject("dbg\\dbg") )
	{
		XSAFETY;
//		StartDebugging();		// WinslowF

		EXPECT(StepModel());
		XSAFETY;
		EXPECT(BreakStepTrace());
		XSAFETY;
	}
	StopDbgCloseProject();
	Sleep(1000);
	
/* bug # 1347 is postponed for after V50
	if( SetProject("dbga\\dbga") )
	{	  
		XSAFETY;
		TraceIntoWndProc();
		XSAFETY;
	}
*/
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\exe\exesub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CexeSubSuite class
//

#include "stdafx.h"
#include "exesub.h"
#include "afxdllx.h"
#include "..\cleanup.h"

#include "exe_base.h"
#include "exe_dlls.h"
#include "exe_bp.h"
#include "exe_spec.h"
#include "execase3.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CexeSubSuite

IMPLEMENT_SUBSUITE(CexeSubSuite, CIDESubSuite, "Execution", "VCQA Debugger")

BEGIN_TESTLIST(CexeSubSuite)
	TEST(Cexe_baseIDETest, RUN)
	TEST(Cexe_dllsIDETest, RUN)
	TEST(Cexe_bpIDETest, RUN)
	TEST(Cexe_specialIDETest, RUN)
	TEST(CExe3Cases, RUN)
END_TESTLIST()

void CexeSubSuite::CleanUp(void)
	{
	::CleanUp("testbp01");
	::CleanUp("testgo01");
	::CleanUp("dbg");
	::CleanUp("dbga");
	::CleanUp("dllapp");
	}

///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\exe\execase2.h ===
///////////////////////////////////////////////////////////////////////////////
//	execase.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CexeIDETest Class
//

#ifndef __execase2_H__
#define __execase2_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\dbgset.h"
#include "exesub.h"

///////////////////////////////////////////////////////////////////////////////
//	CexeIDETest class

class Cexe2IDETest : public CDebugTestSet
{
	DECLARE_TEST(Cexe2IDETest, CexeSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run();

// Test Cases
protected:

	// Go cases
	BOOL GoExeDoesNotExist();
	BOOL ExitWhileDebugging();

	// Step cases
	BOOL StepIntoMixed();
	BOOL StepOverMixed();
	BOOL StepOutMixed();
	BOOL StepToCursorMixed();

	BOOL DllStepTrace();
	BOOL DllStepOut();
	BOOL DllTraceOut();
	BOOL CannotFindDll();
	BOOL StepOverFuncInUnloadedDll();
	BOOL RestartFromWithinDll();
	BOOL GoFromWithinDll();
	BOOL StdInOutRedirection();
	BOOL NoSystemCodeStepping();

// Utilities
protected:
	BOOL CheckGeneralNetworkFailure();

};

#endif //__execase2_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\exe\execase3.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	EXECASE3.CPP
//											 
//	Created by:			Date:			
//		MichMa				2/2/98	
//
//	Description:								 
//		Implementation of CExe3Cases		 

#include "stdafx.h"
#include "execase3.h"
#include "..\cleanup.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
											   
IMPLEMENT_TEST(CExe3Cases, CDebugTestSet, "Execution Pri1", -1, CexeSubSuite)


// each function that runs a test has this prototype.
typedef void (CExe3Cases::*PTR_TEST_FUNC)(void); 

// we randomly pick out of the following list of tests and run them.
// insert functions for new tests to the end of the list.
PTR_TEST_FUNC tests[] = 
{
	&CExe3Cases::StartDebuggingBreakRestartAndStep,
	&CExe3Cases::StepIntoFuncThroughIndirectCall,
	&CExe3Cases::StepIntoWhenInstructionPtrAdvancedButNotSourcePtr,
	&CExe3Cases::StepIntoWhenInstructionAndSourcePtrsAdvanceWithFocusInAsm,
	&CExe3Cases::StepIntoWhenInstructionAndSourcePtrsAdvanceWithFocusInSource,
	&CExe3Cases::StepOverToLineWithLocationBP,
	&CExe3Cases::StepOverFuncInMixedMode,
	&CExe3Cases::StepOverFuncWhichWillHitMessageBP,
	&CExe3Cases::StepOutOfFuncWhichWillHitExpressionTrueBP,
	&CExe3Cases::StepOutOfFuncWhichWillHitExpressionChangedBP,
	&CExe3Cases::StepOutOfFuncWhichWillHitMessageBP,
	&CExe3Cases::GoUntilExceptionIsRaised,
	&CExe3Cases::StopDebuggingWhileDebuggeeIsRunning,
	&CExe3Cases::StepToCursorInAsm,
	&CExe3Cases::StepToCursorAtLineWithLocationBP,
	&CExe3Cases::SetNextStatementInSource,
	&CExe3Cases::SetNextStatementInAsm,
	&CExe3Cases::ShowNextStatementWhenCursorNotOnStatementAndSourceInForeground,
	&CExe3Cases::ShowNextStatementWhenScrollingRequiredAndSourceInForeground,
	&CExe3Cases::ShowNextStatementInAsm,
	&CExe3Cases::StepIntoSpecificNonNested,
	&CExe3Cases::StepIntoSpecificNested,
	&CExe3Cases::StepIntoSpecificWhenBPSetInInnerFunc,
	&CExe3Cases::LoadCOFFExports
};


void CExe3Cases::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}


void CExe3Cases::Run(void)

{
	CString strProjBase;
	
	// setup some paths we will use.
	if(GetSystem() & SYSTEM_DBCS)
		strProjBase = "[\\]^{|}Aa`@~ execution pri1";
	else
		strProjBase = "execution pri1";

	// the location of the unlocalized sources.
	CString strSrcDir = GetCWD() + "src\\execution pri1";
	// the location of the localized project/sources.
	CString strProjDir = strSrcDir + "\\" + strProjBase;

	// clean-up from the last run.
	OurKillFile(strProjDir + "\\Debug\\", "*.*");
	RemoveDirectory(strProjDir + "\\Debug");
	OurKillFile(strProjDir + "\\", "*.*");
	RemoveDirectory(strProjDir);

	// set the options for the project we are building for this test.
	CProjWizOptions *pWin32AppWizOpt = new(CWin32AppWizOptions);
	pWin32AppWizOpt->m_strLocation = strSrcDir;
	pWin32AppWizOpt->m_strName = strProjBase;	
	
	// create the project.
	EXPECT_SUCCESS(proj.New(pWin32AppWizOpt));
	// create a new localized exe source file in the project dir from the unlocalized exe source file.
	CopyFile(strSrcDir + "\\" + "execution pri1 exe.cpp", strProjDir + "\\" + strProjBase + " exe.cpp", FALSE);
	// this appears to be a win32 timing problem. when running the test over the net, the server seems to keep the file 
	// locked even after CopyFile returns. an immediate call to SetFileAttributes will fail with a sharing violation.
	// so we wait a second here to make sure the server is totally finished processing the CopyFile request.
	Sleep(1000);
	// make it writable so it can be cleaned up later.
	SetFileAttributes(strProjDir + "\\" + strProjBase + " exe.cpp", FILE_ATTRIBUTE_NORMAL);
	// add source to the project.
	EXPECT_SUCCESS(proj.AddFiles(strProjBase + " exe.cpp"));
	// build the project.
	EXPECT_SUCCESS(proj.Build());

	// all tests expect this initial state.
	InitTestState();
	// we only want to randomly run each test once.
	RandomNumberCheckList rncl(sizeof(tests) / sizeof(PTR_TEST_FUNC));
	// indexes into the test function array.
	int iTest;
	
	if(CMDLINE->GetBooleanValue("random", TRUE))
	{
		// randomly run each test once.
		while((iTest = rncl.GetNext()) != -1)
			(this->*(tests[iTest]))();
	}
	else
	{
		// run each test in sequence.
		for(iTest = 0; iTest < sizeof(tests) / sizeof(PTR_TEST_FUNC); iTest++)
			(this->*(tests[iTest]))();
	}
}


void CExe3Cases::StartDebuggingBreakRestartAndStep(void)
{	
	LogTestHeader("StartDebuggingBreakRestartAndStep");
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, NOWAIT));
	EXPECT_TRUE(dbg.Break());
	EXPECT_TRUE(dbg.CurrentLineIs("loop line"));
	EXPECT_TRUE(stk.CurrentFunctionIs("WinMain"));
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of WinMain()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("WinMain"));
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(dbg.CurrentLineIs("second line of WinMain()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("WinMain"));
	InitTestState();
}


void CExe3Cases::StepIntoFuncThroughIndirectCall(void)
{	
	LogTestHeader("StepIntoFuncThroughIndirectCall");
	EXPECT_TRUE(src.Find("pFuncCalledIndirectly();"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of FuncCalledIndirectly()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("FuncCalledIndirectly"));
	InitTestState();
}


void CExe3Cases::StepIntoWhenInstructionPtrAdvancedButNotSourcePtr(void)
{
	LogTestHeader("StepIntoWhenInstructionPtrAdvancedButNotSourcePtr");
	EXPECT_TRUE(dam.Enable());
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(dam.InstructionIs("mov"));
	EXPECT_TRUE(dbg.SetSteppingMode(SRC));
	EXPECT_TRUE(dbg.CurrentLineIs("first line of WinMain()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("WinMain"));
	InitTestState();
}


void CExe3Cases::StepIntoWhenInstructionAndSourcePtrsAdvanceWithFocusInAsm(void)
{
	LogTestHeader("StepIntoWhenInstructionAndSourcePtrsAdvanceWithFocusInAsm");
	EXPECT_TRUE(src.Find("_asm"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dam.Enable());
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(dam.InstructionIs("pop"));
	EXPECT_TRUE(dbg.SetSteppingMode(SRC));
	EXPECT_TRUE(dbg.CurrentLineIs("pop eax"));
	EXPECT_TRUE(stk.CurrentFunctionIs("WinMain"));
	InitTestState();
}


void CExe3Cases::StepIntoWhenInstructionAndSourcePtrsAdvanceWithFocusInSource(void)
{
	LogTestHeader("StepIntoWhenInstructionAndSourcePtrsAdvanceWithFocusInSource");
	EXPECT_TRUE(src.Find("_asm"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dam.Enable());
	EXPECT_TRUE(dbg.SetSteppingMode(SRC));
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(dbg.CurrentLineIs("pop eax"));
	EXPECT_TRUE(dbg.SetSteppingMode(ASM));
	EXPECT_TRUE(dam.InstructionIs("pop"));
	EXPECT_TRUE(stk.CurrentFunctionIs("WinMain"));
	EXPECT_TRUE(dbg.SetSteppingMode(SRC));
	InitTestState();
}


void CExe3Cases::StepOverToLineWithLocationBP(void)
{	
	LogTestHeader("StepOverToLineWithLocationBP");
	// note that initial state has current line at first line of WinMain().
	EXPECT_TRUE(src.Find("second line of WinMain()"));
	EXPECT_VALIDBP(bps.SetBreakpoint());
	EXPECT_TRUE(dbg.StepOver());
	// make sure the bp is still there.
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("second line of WinMain()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("WinMain"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	InitTestState();
}


void CExe3Cases::StepOverFuncInMixedMode(void)
{
	LogTestHeader("StepOverFuncInMixedMode");
	EXPECT_TRUE(src.Find("Func();"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dam.Enable());
	EXPECT_TRUE(dbg.StepOver());
	// we want to check the source line immediately above the current instruction. 
	CString strDAMLine = dam.GetLines(-1, 1);
	EXPECT_TRUE(strDAMLine.Find("line after call to Func()") != -1);
	// now verify the source window.
	EXPECT_TRUE(dbg.SetSteppingMode(SRC));
	EXPECT_TRUE(dbg.CurrentLineIs("line after call to Func()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("WinMain"));
	InitTestState();
}


void CExe3Cases::StepOutOfFuncWhichWillHitExpressionTrueBP(void)
{
	LogTestHeader("StepOutOfFuncWhichWillHitExpressionTrueBP");
	EXPECT_TRUE(src.Find("first line of Func()"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_VALIDBP(bps.SetBreakOnExpr("gintVar == 1", COBP_TYPE_IF_EXP_TRUE));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("line after expression bp hit"));
	EXPECT_TRUE(stk.CurrentFunctionIs("Func"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	// TODO(michma): we need to do this extra step because of bug 38172.
	EXPECT_TRUE(dbg.StepInto());
	InitTestState();
}


void CExe3Cases::StepOutOfFuncWhichWillHitExpressionChangedBP(void)
{
	LogTestHeader("StepOutOfFuncWhichWillHitExpressionChangedBP");
	EXPECT_TRUE(src.Find("first line of Func()"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_VALIDBP(bps.SetBreakOnExpr("gintVar", COBP_TYPE_IF_EXP_CHANGED));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("line after expression bp hit"));
	EXPECT_TRUE(stk.CurrentFunctionIs("Func"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	// TODO(michma): we need to do this extra step because of bug 38172.
	EXPECT_TRUE(dbg.StepInto());
	InitTestState();
}


void CExe3Cases::GoUntilExceptionIsRaised(void)
{
	LogTestHeader("GoUntilExceptionIsRaised");
	// this will cause a divide by 0 error.
	EXPECT_TRUE(cxx.SetExpressionValue("gintDenominator", 0));
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, NOWAIT));
	EXPECT_TRUE(dbg.HandleMsg(MSG_EXCEPTION_DIVIDE_BY_ZERO));
	EXPECT_TRUE(dbg.CurrentLineIs("int i = 1 / gintDenominator;"));
	EXPECT_TRUE(stk.CurrentFunctionIs("WinMain"));
	InitTestState();
}


void CExe3Cases::StopDebuggingWhileDebuggeeIsRunning(void)
{
	LogTestHeader("StopDebuggingWhileDebuggeeIsRunning");
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_RUN));
	EXPECT_TRUE(dbg.StopDebugging());
	InitTestState();
}


void CExe3Cases::StepToCursorInAsm(void)
{
	LogTestHeader("StepToCursorInAsm");
	// debug to a place where we know for sure what the asm is.
	EXPECT_TRUE(src.Find("_asm"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dam.Enable());
	// attach the COSource object to the asm view so we can navigate it.
	src.AttachActive();
	// the instruction we want to step to is 2 lines down in the listing.
	src.TypeTextAtCursor("{DOWN 2}");
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dam.InstructionIs("pop"));
	EXPECT_TRUE(stk.CurrentFunctionIs("WinMain"));
	EXPECT_TRUE(dbg.SetSteppingMode(SRC));
	InitTestState();
}


void CExe3Cases::StepToCursorAtLineWithLocationBP(void)
{	
	LogTestHeader("StepToCursorAtLineWithLocationBP");
	// note that initial state has current line at first line of WinMain().
	EXPECT_TRUE(src.Find("second line of WinMain()"));
	EXPECT_VALIDBP(bps.SetBreakpoint());
	EXPECT_TRUE(dbg.StepToCursor());
	// make sure the bp is still there.
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("second line of WinMain()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("WinMain"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	InitTestState();
}


void CExe3Cases::ShowNextStatementWhenCursorNotOnStatementAndSourceInForeground(void)
{
	LogTestHeader("ShowNextStatementWhenCursorNotOnStatementAndSourceInForeground");
	EXPECT_TRUE(src.Find("first line of source file"));
	EXPECT_TRUE(dbg.ShowNextStatement());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of WinMain()"));
	InitTestState();
}


void CExe3Cases::ShowNextStatementWhenScrollingRequiredAndSourceInForeground(void)
{
	LogTestHeader("ShowNextStatementWhenScrollingRequiredAndSourceInForeground");
	EXPECT_TRUE(src.Find("END: for tests that require scrolling code out of view."));
	EXPECT_TRUE(dbg.ShowNextStatement());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of WinMain()"));
	InitTestState();
}


void CExe3Cases::ShowNextStatementInAsm(void)
{
	LogTestHeader("ShowNextStatementInAsm");
	// debug to a place where we know for sure what the asm is.
	EXPECT_TRUE(src.Find("_asm"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dam.Enable());
	// attach the COSource object to the asm view so we can navigate it.
	src.AttachActive();
	// move the cursor down a page.
	src.TypeTextAtCursor("{PGDN}");
	EXPECT_TRUE(dbg.ShowNextStatement());
	EXPECT_TRUE(dam.InstructionIs("push"));
	EXPECT_TRUE(dbg.SetSteppingMode(SRC));
	InitTestState();
}


void CExe3Cases::StepOverFuncWhichWillHitMessageBP(void)
{
	LogTestHeader("StepOverFuncWhichWillHitMessageBP");
	EXPECT_TRUE(src.Find("SendMessageFunc();"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_VALIDBP(bps.SetBreakOnMsg("WndProc", "WM_NULL"));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of WndProc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("WndProc"));
	// value of WM_NULL message is 0.
	EXPECT_TRUE(cxx.ExpressionValueIs("msg", 0));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	InitTestState();
}


void CExe3Cases::StepOutOfFuncWhichWillHitMessageBP(void)

{
		LogTestHeader("StepOutOfFuncWhichWillHitMessageBP");
		EXPECT_TRUE(src.Find("first line of SendMessageFunc()"));
		EXPECT_TRUE(dbg.StepToCursor());
		EXPECT_VALIDBP(bps.SetBreakOnMsg("WndProc", "WM_NULL"));
		EXPECT_TRUE(dbg.StepOut());
		EXPECT_TRUE(dbg.CurrentLineIs("first line of WndProc()"));
		EXPECT_TRUE(stk.CurrentFunctionIs("WndProc"));
	
		// michma - 3/1/99: due to bug vc98:60437.
		if(GetSystem() | SYSTEM_NT_5)
			{ EXPECT_TRUE(dbg.StepOver()); }

		// value of WM_NULL message is 0.
		EXPECT_TRUE(cxx.ExpressionValueIs("msg", 0));
		EXPECT_TRUE(bps.ClearAllBreakpoints());
		InitTestState();
}


void CExe3Cases::SetNextStatementInSource(void)
{
	LogTestHeader("SetNextStatementInSource");
	// step to a point where the next statement is an infinite loop.
	EXPECT_TRUE(src.Find("loop line"));
	EXPECT_TRUE(dbg.StepToCursor());
	// set the next statement to one after the infinite loop.
	EXPECT_TRUE(src.Find("return from WinMain()"));
	EXPECT_TRUE(dbg.SetNextStatement());
	// now instead of hitting the infinite loop the app should terminate.
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION));
	InitTestState();
}


void CExe3Cases::SetNextStatementInAsm(void)
{
	LogTestHeader("SetNextStatementInAsm");
	// step to a point where the next statement is an infinite loop.
	EXPECT_TRUE(src.Find("loop line"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dam.Enable());
	// attach the COSource object to the asm view so we can navigate it.
	src.AttachActive();
	// set the next instruction to one after the infinite loop (in the WinMain return).
	src.TypeTextAtCursor("{DOWN 6}");
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.SetSteppingMode(SRC));
	// now instead of hitting the infinite loop the app should terminate.
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION));
	InitTestState();
}


void CExe3Cases::StepIntoSpecificNonNested(void)
{
	LogTestHeader("StepIntoSpecificNonNested");
	EXPECT_TRUE(src.Find("Func();"));
	EXPECT_TRUE(dbg.StepToCursor());
	// put cursor on function name.
	EXPECT_TRUE(src.Find("Func();"));
	src.TypeTextAtCursor("{LEFT}{RIGHT}");
	EXPECT_TRUE(dbg.StepIntoSpecific());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of Func()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("Func"));
	InitTestState();
}


void CExe3Cases::StepIntoSpecificNested(void)
{
	LogTestHeader("StepIntoSpecificNested");
	EXPECT_TRUE(src.Find("OuterFunc(InnerFunc());"));
	EXPECT_TRUE(dbg.StepToCursor());
	// put cursor on inner function name.
	EXPECT_TRUE(src.Find("InnerFunc()"));
	src.TypeTextAtCursor("{LEFT}{RIGHT}");
	EXPECT_TRUE(dbg.StepIntoSpecific());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of InnerFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("InnerFunc"));
	EXPECT_TRUE(dbg.StepOut());
	// put cursor on outer function name.
	EXPECT_TRUE(src.Find("OuterFunc("));
	src.TypeTextAtCursor("{LEFT}{RIGHT}");
	EXPECT_TRUE(dbg.StepIntoSpecific());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of OuterFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("OuterFunc"));
	InitTestState();
}


void CExe3Cases::StepIntoSpecificWhenBPSetInInnerFunc(void)
{
	LogTestHeader("StepIntoSpecificWhenBPSetInInnerFunc");
	EXPECT_TRUE(src.Find("OuterFunc(InnerFunc());"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_VALIDBP(bps.SetBreakpoint("InnerFunc"));
	// put cursor on outer function name.
	EXPECT_TRUE(src.Find("OuterFunc("));
	src.TypeTextAtCursor("{LEFT}{RIGHT}");
	EXPECT_TRUE(dbg.StepIntoSpecific());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of InnerFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("InnerFunc"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	InitTestState();
}


void CExe3Cases::LoadCOFFExports(void)

{
	// this feature isn't supported on win9x.
	if(!((GetSystem() & SYSTEM_WIN_95) || (GetSystem() & SYSTEM_WIN_98) || (GetSystem() & SYSTEM_WIN_MILL)))
	
	{
		LogTestHeader("LoadCOFFExports");
		// Load COFF/Exports setting can only be toggled between sessions.
		EXPECT_TRUE(dbg.StopDebugging());

		// michma - 9/1/99: there should be a CODebug::ToggleLoadCOFFExports function for this, but since this is a one-time test addition for 
		// an old product, i don't want to take the time.
		
		// turn the option on.
		UIOptionsTabDlg uiopt;
		uiopt.Display();
		uiopt.ShowPage(TAB_DEBUG, 6);
		MST.WCheckCheck("&Load COFF && Exports");
		uiopt.OK();

		EXPECT_TRUE(dbg.StepInto());
		// instead of just KERNEL32 plus some address, we should now see a function name in the 3rd frame.
		if(GetSystem() & SYSTEM_NT_5)
			{EXPECT_TRUE(stk.FunctionIs("SetUnhandledExceptionFilter", 2));}
		else
			{EXPECT_TRUE(stk.FunctionIs("GetProcessPriorityBoost", 2));}
		
		// turn the option off.
		EXPECT_TRUE(dbg.StopDebugging());
		uiopt.Display();
		uiopt.ShowPage(TAB_DEBUG, 6);
 		MST.WCheckUnCheck("&Load COFF && Exports");
		uiopt.OK();

		EXPECT_TRUE(dbg.StepInto());
		// the function name should be gone now.
		if(GetSystem() & SYSTEM_NT_5)
			{EXPECT_TRUE(!stk.FunctionIs("SetUnhandledExceptionFilter", 2));}
		else
			{EXPECT_TRUE(!stk.FunctionIs("GetProcessPriorityBoost", 2));}
	}
}


void CExe3Cases::InitTestState(void)
{
	EXPECT_TRUE(dbg.Restart());
	// attach the COSource object to the source file that the debugger opened.
	src.AttachActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\exe\execase3.h ===
///////////////////////////////////////////////////////////////////////////////
//	EXECASE3.H
//
//	Created by:			Date:
//		MichMa				2/2/98
//
//	Description :
//		Declaration of the CExe3Cases Class
//

#ifndef __EXECASE3_H__
#define __EXECASE3_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\dbgset.h"
#include "exesub.h"


///////////////////////////////////////////////////////////////////////////////
//	CExe3Cases class

class CExe3Cases : public CDebugTestSet

{
	DECLARE_TEST(CExe3Cases, CexeSubSuite)

public:

	// Operations
	virtual void PreRun(void);
	virtual void Run(void);

	// Utils
	void InitTestState(void);

	// Test Cases
	void StartDebuggingBreakRestartAndStep(void);
	void StepIntoFuncThroughIndirectCall(void);
	void StepIntoWhenInstructionPtrAdvancedButNotSourcePtr(void);
	void StepIntoWhenInstructionAndSourcePtrsAdvanceWithFocusInAsm(void);
	void StepIntoWhenInstructionAndSourcePtrsAdvanceWithFocusInSource(void);
	void StepOverToLineWithLocationBP(void);
	void StepOverFuncInMixedMode(void);
	void StepOverFuncWhichWillHitMessageBP(void);
	void StepOutOfFuncWhichWillHitExpressionTrueBP(void);
	void StepOutOfFuncWhichWillHitExpressionChangedBP(void);
	void StepOutOfFuncWhichWillHitMessageBP(void);
	void GoUntilExceptionIsRaised(void);
	void StopDebuggingWhileDebuggeeIsRunning(void);
	void StepToCursorInAsm(void);
	void StepToCursorAtLineWithLocationBP(void);
	void SetNextStatementInSource(void);
	void SetNextStatementInAsm(void);
	void ShowNextStatementWhenCursorNotOnStatementAndSourceInForeground(void);
	void ShowNextStatementWhenScrollingRequiredAndSourceInForeground(void);
	void ShowNextStatementInAsm(void);
	void StepIntoSpecificNonNested(void);
	void StepIntoSpecificNested(void);
	void StepIntoSpecificWhenBPSetInInnerFunc(void);
	void LoadCOFFExports(void);
};

#endif //__EXECASE3_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\exe\exesub.h ===
///////////////////////////////////////////////////////////////////////////////
//	exesub.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CexeSubSuite class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CexeSubSuite class

class CexeSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CexeSubSuite)
//exeSubSuite() { m_strName = "TestWizard Generated script"; m_strOwner = "VCBU QA"; }


	DECLARE_TESTLIST()
protected:
	void CleanUp(void);
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\exe\exe_base.h ===
///////////////////////////////////////////////////////////////////////////////
//	exe_base.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CexeIDETest Class
//

#ifndef __exe_base_H__
#define __exe_base_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\dbgset.h"
#include "exesub.h"

///////////////////////////////////////////////////////////////////////////////
//	CexeIDETest class

class Cexe_baseIDETest : public CDebugTestSet
{
	DECLARE_TEST(Cexe_baseIDETest, CexeSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run();

// Test Cases
protected:

	// Go cases
	BOOL GoAndVerify();
	BOOL RestartAndGo();
	BOOL RestartStopDebugging();

	// Step cases
	BOOL StepIntoSource();
	BOOL StepOverSource();
	BOOL StepOutSource();
	BOOL StepToCursorSource();
	BOOL StepModel();
	BOOL StaticFuncStepTrace();

};

#endif //__exe_base_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\exe\exe_base.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	exe_base.CPP
//											 
//	Created by :			
//		VCBU QA		

#include <process.h>
#include "stdafx.h"
#include "exe_base.h"	

#if defined(_MIPS_) || defined(_ALPHA_)
#define _CHAIN_2 "chain_2"
#define _CHAIN_3 "chain_3"
#else
#define _CHAIN_2 "_chain_2"
#define _CHAIN_3 "_chain_3"
#endif

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
											   
IMPLEMENT_TEST(Cexe_baseIDETest, CDebugTestSet, "Execution Base", -1, CexeSubSuite)
												 
void Cexe_baseIDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();

}

void Cexe_baseIDETest::Run()
{	 
	XSAFETY;
	
	if( SetProject("testgo01\\testgo01"))
	{	  
		bps.ClearAllBreakpoints();
		XSAFETY;
		GoAndVerify();
		XSAFETY;
		RestartAndGo();
		XSAFETY;
		RestartStopDebugging();
		XSAFETY;
	}
	else
		m_pLog->RecordFailure("SetProject failed for \"testgo01\"." );
		
	if( SetProject("testbp01\\testbp01") )
	{	  
		bps.ClearAllBreakpoints();
		XSAFETY;
		StepOutSource();
		XSAFETY;
		StepOverSource();
		XSAFETY;
		StepIntoSource();
		XSAFETY;
		StepToCursorSource();
		XSAFETY;
	}
	else
		m_pLog->RecordFailure("SetProject failed for \"testbp01\"." );

		
	if ( SetProject("dbg\\dbg") )
	{
		bps.ClearAllBreakpoints();
		XSAFETY;
		EXPECT(StepModel());
		XSAFETY;
		StopDbgCloseProject();
	}
	else
		m_pLog->RecordFailure("SetProject failed for \"dbg\"." );

		
// TODO(michma - 3/26/98): apparently this test wasn't finished.
/*		
	if ( SetProject("spcfc01\\spcfc01") )
	{
		XSAFETY;
		StaticFuncStepTrace();
		XSAFETY;
	}
	else
		m_pLog->RecordFailure("SetProject failed for \"spcfc01\"." );
*/
}


///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////

BOOL Cexe_baseIDETest::GoAndVerify( )
{
 	LogTestHeader( "GoAndVerify" );
	m_pLog->RecordInfo( " Run an app and verify it ran " );

	EXPECT_TRUE( dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION) );
	return (TRUE);
}

BOOL Cexe_baseIDETest::RestartAndGo( )
{
 	LogTestHeader( "RestartAndGo" );
	m_pLog->RecordInfo( " Restart, verify stop and Go " );

	EXPECT_TRUE( dbg.Restart() );
	if( UIWB.GetPcodeSwitch() )
	{
		EXPECT_TRUE( dbg.CurrentLineIs( "int iGo = TestG();" ) );
	}
	else
	{
		EXPECT_TRUE( dbg.CurrentLineIs( "{" ) );
	}

	EXPECT_TRUE( dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION) );

	return (TRUE);
}


BOOL Cexe_baseIDETest::RestartStopDebugging( )
{
 	LogTestHeader( "RestartStopDebugging" );
	m_pLog->RecordInfo( "Restart, StopDebugging and verify" );

	EXPECT_TRUE( dbg.StepInto(1, NULL, "{") );
	EXPECT_TRUE( dbg.StepOver(1) );
    EXPECT_TRUE( dbg.Restart() );
	EXPECT_TRUE( dbg.CurrentLineIs( "{" ) );
	EXPECT_TRUE( dbg.StopDebugging() );
	EXPECT_TRUE( dbg.Wait(WAIT_FOR_TERMINATION) );

/*	#if defined( _M_IX86 ) || defined( _MAC )  // WinslowF - for OEM compatibility
		EXPECT_TRUE( VerifyProjectRan(0) );
	#else
		EXPECT_TRUE( VerifyProjectRan(1) );
	#endif
*/
	EXPECT_TRUE( dbg.StepOver(1) );
	EXPECT_TRUE( dbg.StopDebugging() );
	EXPECT_TRUE( dbg.Wait(WAIT_FOR_TERMINATION) );

	WriteLog(PASSED, "Restart-StopDebugging-StartDebugging was handled as expected" );
	return (TRUE);
}


BOOL Cexe_baseIDETest::StepOutSource(   )
{
 	LogTestHeader( "StepOutSource" );

	COSource		src;	// WinslowF - added to call GoToLine. It's not in UIWB any more.

	bps.ClearAllBreakpoints();
    dbg.Restart();
	EXPECT_TRUE( dbg.CurrentLineIs( "{" ) );

	CString strSource = "bp__ulul.c";

	// Open source
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);

	EXPECT_TRUE( src.Find("ul = (ulong)counter;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "ul = (ulong)counter;") );

	EXPECT_TRUE( dbg.StepOut(1, NULL, "ul = CFncULUL(ul);", "TestBP()") );

	return (TRUE);
}


BOOL Cexe_baseIDETest::StepOverSource(   )
{
 	LogTestHeader( "StepOverSource" );

    EXPECT_TRUE( dbg.Go(NULL,NULL,NULL,WAIT_FOR_TERMINATION) );

	CString strSource = "testbp.c";
	bps.ClearAllBreakpoints();

	// Open source
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);

	EXPECT_TRUE( src.Find("ul = CFncULUL(ul);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "ul = CFncULUL(ul);") );

	EXPECT_TRUE( dbg.StepOver(1, NULL, "f = CFncFF(f);") );

	return (TRUE);
}


BOOL Cexe_baseIDETest::StepIntoSource(   )
{
 	LogTestHeader( "StepIntoSource" );

	bps.ClearAllBreakpoints();
    dbg.Restart();

	if( !UIWB.GetPcodeSwitch() )
	{
	    EXPECT_TRUE( dbg.CurrentLineIs( "{" ) );
		EXPECT_TRUE( dbg.StepInto() );
	}

    EXPECT_TRUE( dbg.CurrentLineIs( "int iBP = TestBP();" ) );

	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "TestBP()") );

	MST.DoKeys("{up}");
    EXPECT_TRUE( dbg.CurrentLineIs( "int TestBP()" ) );

	EXPECT_TRUE( src.Find("s = CFncSSRecurse(10);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "s = CFncSSRecurse(10);") );

	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "CFncSSRecurse") );

	MST.DoKeys("{up}");
    EXPECT_TRUE( dbg.CurrentLineIs( "CFncSSRecurse(short NTimes)" ) );

	EXPECT_TRUE( src.Find("NTimes = (short)CFncSSRecurse((short)(NTimes-1));") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "NTimes = (short)CFncSSRecurse((short)(NTimes-1));") );

	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "CFncSSRecurse") );
	EXPECT_TRUE( stk.FunctionIs("CFncSSRecurse",1) );

	MST.DoKeys("{up}");
    EXPECT_TRUE( dbg.CurrentLineIs( "CFncSSRecurse(short NTimes)" ) );

	dbg.StopDebugging();

	return (TRUE);
}

BOOL Cexe_baseIDETest::StepToCursorSource(   )
{
 	LogTestHeader( "StepToCursorSource" );

	CString strSource = "bp__ldld.c";
	bps.ClearAllBreakpoints();

	// Open source
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);

	EXPECT_TRUE( src.Find("ul = (ulong)counter;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "ul = (ulong)counter;") );

	EXPECT_TRUE( src.Find("d  = (double)counter;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "d  = (double)counter;") );
	dbg.StopDebugging();
	return (TRUE);
}


/*
** A number of tests lumped together.  Some involve step/trace/stepout
** with different level of debug information or without debug 
** information.  
** 
*/

BOOL Cexe_baseIDETest::StepModel(   )
{
 	LogTestHeader( "StepModel" );

	int count;
	BOOL fOkay;

	/*
	** test Step_Out of func with debug info into func w/out debug info	
	** also test to Step_Out of func w/out debug info into func w/ partial info
	** also test to Step_Out of func w/partial debug info into func w/full info
	** also test to Step_Out of func with debug info into func w/debug info
	**
	** ChainMain is expected to be compiled with full debug information
	** chain_1 is expected to be compiled with full debug information
	** chain_2 is expected to be compiled with partial debug information
	** chain_3 is expected to be compiled without debug information
	** chain_4 is expected to be compiled with full debug information
	*/

	dbg.Restart();

	/* 
	** test tracing into function with partial debug information.
	*/
 
	bps.SetBreakpoint("{chain_1}START");
	dbg.Go();
	dbg.AtSymbol("START");
	fOkay = dbg.StepInto(1,NULL, NULL, "chain_2");
	WriteLog( fOkay ? PASSED : FAILED, "Trace from full cvinfo into module w/only partial cvinfo");
	if (!fOkay)
		return fOkay;	
 
	/* 
	** test tracing out of function w/out cvinfo into func w/ partial.
	** ; test instruction level tracing
	*/

	EXPECT_TRUE ( bps.SetBreakpoint(_CHAIN_3) != NULL );
	EXPECT_TRUE ( dbg.Go(NULL, NULL, "chain_3") );
	EXPECT_TRUE ( dbg.StepInto(2, NULL, NULL, "chain_3") );
	EXPECT_TRUE ( bps.DisableAllBreakpoints() );

	count=0;
	while ( (count<25) && (stk.GetFunction().Find("chain_3") != -1))
	{
		count++;
		dbg.StepOver();   // step over chain_4 ...
	} 
	fOkay = stk.CurrentFunctionIs("chain_2");
	WriteLog( fOkay ? PASSED : FAILED, "instruction level tracing from no cvinfo to partial cvinfo");
	if (!fOkay)
		return fOkay;	

	dbg.SetSteppingMode(SRC);

 	/* 
	** test tracing into function w/out cvinfo
	*/

	bps.ClearAllBreakpoints();
	EXPECT_TRUE ( bps.SetBreakpoint("{WndProc}TagCallNoCVInfo") != NULL );

	dbg.Go();   // will hit the throw
	dbg.Go(); 	// go again to get to the breakpoint
	dbg.AtSymbol("TagCallNoCVInfo");
	dbg.SetSteppingMode(SRC);

	// attempt to trace into func, but func doesn't have cvinfo so 
	// trace should actually stepover
	fOkay = dbg.StepInto(1, NULL, NULL, "WndProc");
	WriteLog(fOkay ? PASSED : FAILED, "Source level trace of func call w/out cvinfo");
	if (!fOkay)
		return FALSE;	

	src.Find("TagCallNoCVInfo:", TRUE);
	if (dbg.SetNextStatement(NULL) == FALSE)
	{
		m_pLog->RecordFailure("Unable to Set_Next_Statement");
		return FALSE;	
	}
	if (dbg.SetSteppingMode(ASM) == FALSE)
	{
		m_pLog->RecordFailure("Unable to set stepping mode to ASM");
		return FALSE;	// ( FALSE, GetTestDesc() );
	}

	// don't know exactly how many instructions so allow a few traces 
	count=0;
	do 
	{
		count++;
		dbg.StepInto();
	} while( (count<17) && (!dbg.AtSymbol(_CHAIN_3)) );
	EXPECT_TRUE ( dbg.AtSymbol(_CHAIN_3) );
	// now only have dissassembly.  keep tracing until get back to mixed.
	do 
	{
		dbg.StepInto();
	} while (!dbg.AtSymbol("chain_4"));
	fOkay = dbg.AtSymbol("chain_4");
	WriteLog(fOkay ? PASSED : FAILED, "Instruction level trace from no cvinfo to full cvinfo");
	
	dbg.SetSteppingMode(SRC);
	bps.ClearAllBreakpoints();
	return TRUE;	
}

BOOL Cexe_baseIDETest::StaticFuncStepTrace( )
{
 	LogTestHeader( "StaticFuncStepTrace" );

	bps.ClearAllBreakpoints();

    dbg.Restart();
    EXPECT_TRUE( dbg.CurrentLineIs( "{" ) );
	
 	LogTestHeader( "SRC: Trace into Static member function and trace out" );

	EXPECT_TRUE( src.Find("try_array(iA);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "try_array(iA);") );
	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "try_array(Array<int>") );
	EXPECT_TRUE( dbg.StepOver(4, NULL, "iA.static_func(mid);") );
	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "Array<int>::static_func") );
	EXPECT_TRUE( dbg.StepInto(3, NULL, NULL, "try_array(Array<int>") );

	EXPECT_TRUE( dbg.StepOut(1, NULL, NULL, "main") );

	// repeat for double type of the template function
	EXPECT_TRUE( src.Find("try_array(dA);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "try_array(dA);") );
	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "try_array(Array<double>") );
	EXPECT_TRUE( dbg.StepOver(4, NULL, "iA.static_func(mid);") );
	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "Array<double>::static_func") );
	EXPECT_TRUE( dbg.StepInto(3, NULL, NULL, "try_array(Array<double>") );

	// Once more with a nested call
	EXPECT_TRUE( dbg.StepOut(1, NULL, NULL, "main") );
	EXPECT_TRUE( dbg.StepOver(1, NULL, "iA.static_func(iA.getSize());") );
	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "Array<int>::getSize") );
	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "main") );
	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "Array<int>::static_func") );
	EXPECT_TRUE( dbg.StepInto(3, NULL, NULL, "main") );

	// Step over static member function
	EXPECT_TRUE( dbg.StepOver(1, NULL, "dA.static_func(iA.getSize());") );
	EXPECT_TRUE( dbg.StepOver(1, NULL, "int iGo = TestG();", "main") );

	// foo calls foo_Include
	EXPECT_TRUE( src.Find("Int=foo(Local);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "Int=foo(Local);", "TestG") );
	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "foo") );
	EXPECT_TRUE( dbg.StepInto(2, NULL, NULL, "foo_Include") );
	EXPECT_TRUE( dbg.StepInto(5, NULL, NULL, "foo") );
	EXPECT_TRUE( dbg.StepInto(3, NULL, NULL, "TestG") );
	EXPECT_TRUE( dbg.StepInto(2, NULL, NULL, "foo_Include") );
	EXPECT_TRUE( dbg.StepOut(1, NULL, NULL, "TestG") );

	// Step over static function
	EXPECT_TRUE( dbg.StepOver(3, NULL, "nest_func(foo_Include(foo(Global)));") );

	// trace again through nested calls of static functions
	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "foo") );
	EXPECT_TRUE( dbg.StepInto(2, NULL, NULL, "foo_Include") );
	EXPECT_TRUE( dbg.StepInto(5, NULL, NULL, "foo") );
	EXPECT_TRUE( dbg.StepInto(3, NULL, NULL, "TestG") );
	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "foo_Include") );
	EXPECT_TRUE( dbg.StepOut(1, NULL, NULL, "TestG") );

	// Test a couple situations in Disassmebly
    dbg.Restart();
    EXPECT_TRUE( dbg.CurrentLineIs( "{" ) );
	
 	LogTestHeader( "DAM: Trace into Static member function and trace out" );

	EXPECT_TRUE( src.Find("try_array(iA);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "try_array(iA);") );
	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "try_array(Array<int>") );
	EXPECT_TRUE( dbg.StepOver(4, NULL, "iA.static_func(mid);") );
	dbg.SetSteppingMode(ASM);

	//trace in
	int count=0;
	while ( (count<25) && (!stk.CurrentFunctionIs("Array<int>::static_func")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE ( stk.CurrentFunctionIs("Array<int>::static_func") );

	//trace out
	count=0;
	while ( (count<25) && (!stk.CurrentFunctionIs("try_array(Array<int>")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE ( stk.CurrentFunctionIs("try_array(Array<int>") );

	EXPECT_TRUE( dbg.StepOut(1, NULL, NULL, "main") );
	dbg.SetSteppingMode(SRC);

	// Step over static member function in DAM
 	LogTestHeader( "DAM: Step Over Static member function" );
	EXPECT_TRUE( src.Find("dA.static_func(iA.getSize());") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "dA.static_func(iA.getSize());") );
	dbg.SetSteppingMode(ASM);
	count=0;
	while ( (count<25) && (!dbg.CurrentLineIs( "static_func" )) )
	{
		count++;
		dbg.StepOver();
		Sleep(100);
	} 
	EXPECT_TRUE ( dbg.CurrentLineIs( "static_func" ) );
	EXPECT_TRUE( dbg.StepOver(1, NULL, NULL, "main") );

	dbg.SetSteppingMode(SRC);

 	LogTestHeader( "DAM: Step Over simple Static function" );
	EXPECT_TRUE( src.Find("Int=foo(Local);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "Int=foo(Local);") );
	dbg.SetSteppingMode(ASM);
	count=0;
	while ( (count<25) && (!dbg.CurrentLineIs( "foo" )) )
	{
		count++;
		dbg.StepOver();
		Sleep(100);
	} 
	EXPECT_TRUE ( dbg.CurrentLineIs( "foo" ) );
	EXPECT_TRUE( dbg.StepOver(1, NULL, NULL, "TestG") );

	dbg.SetSteppingMode(SRC);

 	LogTestHeader( "DAM: Trace into simple Static function and trace out" );

	EXPECT_TRUE( src.Find("nest_func(foo_Include(foo(Global)));") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "nest_func(foo_Include(foo(Global)));") );
	dbg.SetSteppingMode(ASM);

	//trace from TestG into foo
	count=0;
	while ( (count<25) && (!stk.CurrentFunctionIs("foo")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE ( stk.CurrentFunctionIs("foo") );

	//trace from foo into foo_Include
	count=0;
	while ( (count<25) && (!stk.CurrentFunctionIs("foo_Include")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE ( stk.CurrentFunctionIs("foo_Include") );

	//trace out	from foo_Include back to foo
	count=0;
	while ( (count<25) && (!stk.CurrentFunctionIs("foo")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE ( stk.CurrentFunctionIs("foo") );

	//trace out	from foo back to TestG
	count=0;
	while ( (count<25) && (!stk.CurrentFunctionIs("TestG")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE ( stk.CurrentFunctionIs("TestG") );

	//trace from TestG into foo_Include
	count=0;
	while ( (count<25) && (!stk.CurrentFunctionIs("foo_Include")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE ( stk.CurrentFunctionIs("foo_Include") );

	//trace out	from foo_Include back to TestG
	count=0;
	while ( (count<25) && (!stk.CurrentFunctionIs("TestG")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE ( stk.CurrentFunctionIs("TestG") );

	dbg.StopDebugging();

	return TRUE;	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\exe\exe_dlls.h ===
///////////////////////////////////////////////////////////////////////////////
//	exe_dlls.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the Cexe_dllsIDETest Class
//

#ifndef __exe_dlls_H__
#define __exe_dlls_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\dbgset.h"
#include "exesub.h"

///////////////////////////////////////////////////////////////////////////////
//	CexeIDETest class

class Cexe_dllsIDETest : public CDebugTestSet
{
	DECLARE_TEST(Cexe_dllsIDETest, CexeSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run();

// Test Cases
protected:

	BOOL DllStepTrace();
	BOOL DllStepOut();
	BOOL DllTraceOut();
	BOOL StepOverFuncInUnloadedDll();
	BOOL RestartFromWithinDll();
	BOOL GoFromWithinDll();

};

#endif //__exe_dlls_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\exe\exe_bp.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	exe_bp.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script		 

#include <process.h>
#include "stdafx.h"
#include "exe_bp.h"	

#if defined(_MIPS_) || defined(_ALPHA_)
#define _CHAIN_2 "chain_2"
#define _CHAIN_3 "chain_3"
#else
#define _CHAIN_2 "_chain_2"
#define _CHAIN_3 "_chain_3"
#endif

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
											   
IMPLEMENT_TEST(Cexe_bpIDETest, CDebugTestSet, "Execution and Breakpoints", -1, CexeSubSuite)
												 
void Cexe_bpIDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

void Cexe_bpIDETest::Run()
{	 
	XSAFETY;
	
	if( SetProject("testgo01\\testgo01"))
	{	  
		EXPECT_TRUE(bps.ClearAllBreakpoints());
		XSAFETY;
		StepOverFuncToBreakAtLocBP();
		XSAFETY;
		StepOverFuncToBreakOnExprTrueBP();
		XSAFETY;
		StepOverFuncToBreakOnExprChangesBP();
		XSAFETY;
		StepBPLineSRC();
		XSAFETY;
		StepBPLineDAM();
		XSAFETY;
	}
		
	/* For the dbg project:
	** ChainMain is expected to be compiled with full debug information
	** chain_1 is expected to be compiled with full debug information
	** chain_2 is expected to be compiled with partial debug information
	** chain_3 is expected to be compiled without debug information
	** chain_4 is expected to be compiled with full debug information
	*/
	if ( SetProject("dbg\\dbg") )
	{
		EXPECT_TRUE(bps.ClearAllBreakpoints());
		XSAFETY;
		EXPECT(BreakStepTrace());
		XSAFETY;
	}
	StopDbgCloseProject();
	Sleep(1000);
	
}


///////////////////////////////////////////////////////////////////////////////
//	Test Cases

/*
** A number of tests lumped together.  Some involve different level of debug
** information or without debug information.  Also a test or two
** involving step/stepout and breakpoints which are important enough
** to have in the stepping model tests.
*/

BOOL Cexe_bpIDETest::BreakStepTrace(   )
{ 	
 	LogTestHeader( "BreakStepTrace" );

 	/*
	** test Step_Out of func which fires a bp in a nested func in secondary module.
	** test to Step_Out of func with debug info into func w/out debug info	
	** also test to Step_Out of func w/out debug info into func w/ partial info
	** also test to Step_Out of func w/partial debug info into func w/full info
	** also test to Step_Out of func with debug info into func w/debug info
	*/

	bp *bp;
	BOOL fSuccess;
	
	dbg.StopDebugging();
	bp=bps.SetBreakpoint("WndProc");
	dbg.Go();  								// execute to function WndProc 
	EXPECT_TRUE ( dbg.VerifyAtSymbol("WndProc") );
	// Step past prolog
	dbg.StepOver(); 						
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	// set breakpoint on label
	bp = bps.SetBreakpoint("TagCallChainMain"); 	
	// execute to bp at label
	dbg.Go();  								
	EXPECT_TRUE ( dbg.AtSymbol("{WndProc}TagCallChainMain") );
	EXPECT_TRUE ( dbg.StepInto(1,"ChainMain") );

	/* 
	** test tracing out of static function.
	** test Step_Out of func which fires a bp in a nested func in 
	** secondary module.
	*/

	EXPECT_TRUE ( bps.SetBreakpoint("chain_4") != NULL );
	EXPECT_TRUE ( bps.SetBreakpoint("chain_5") != NULL );
	dbg.Go();
	EXPECT_TRUE ( dbg.AtSymbol("chain_4") );

	// attempt to step out but fire on breakpoint in nested function call
	// proper location is chain_5
	fSuccess = dbg.StepOut(1, NULL, NULL, "chain_5"); 
	WriteLog( fSuccess ? PASSED : FAILED, "StepOut and fire on breakpoint in nested function");
	if (!fSuccess)
		return fSuccess;			
	
	dbg.StepInto();
	EXPECT_TRUE ( fSuccess &= dbg.StepOut(1, NULL, NULL, "chain_4") );

	EXPECT_TRUE ( fSuccess &= dbg.StepOut(1, NULL, NULL, "chain_3") );
	WriteLog( fSuccess ? PASSED : FAILED, "StepOut from full to none cvinfo");

	fSuccess = dbg.StepOut(1, NULL, NULL, "chain_2");  
	WriteLog( fSuccess ? PASSED : FAILED, "StepOut from none to partial cvinfo");

	if (!fSuccess)
		return fSuccess;	
	fSuccess = dbg.StepOut(1, NULL, NULL, "chain_1");  
	WriteLog( fSuccess ? PASSED : FAILED, "StepOut from partial cvinfo to full cvinfo");

	if (!fSuccess)
		return fSuccess;	
	fSuccess = dbg.StepOut(1, NULL, NULL, "ChainMain"); 
	WriteLog( fSuccess ? PASSED : FAILED, "StepOut from full cvinfo to full cvinfo");
	if (!fSuccess)
		return fSuccess;	
/*	
	// attempt to step over function but which generates an exception.
	// ToDo: Yefims: this should go to NLG test
	bps.SetBreakpoint("{OtherMain}TagStepEH");
	dbg.Go();
	dbg.StepOver();
#if defined( _MIPS_ ) || defined(_ALPHA_)
	EXPECT_TRUE(stk.CurrentFunctionIs("NTDLL!"));
#else
	EXPECT_TRUE(stk.CurrentFunctionIs("KERNEL32!"));
#endif
	dbg.StepOut();
	dbg.StepOut();
	//TODO: where should we be?
 */
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	return TRUE;	
}									


BOOL Cexe_bpIDETest::StepOverFuncToBreakAtLocBP()
{
 	LogTestHeader( "StepOverFuncToBreakAtLocBP" );

	UIWB.OpenFile( m_strProjectDir + "\\" + "testgo.c");

	EXPECT_TRUE( src.Find("Int=foo(Local);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "Int=foo(Local);") );
	EXPECT_TRUE( src.Find("return Parameter;") );
	EXPECT_TRUE( bps.SetBreakpoint() != NULL );
	EXPECT_TRUE( dbg.StepOver(1, NULL, "return Parameter;") );

	EXPECT_TRUE( src.Find("nest_func();") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "nest_func();") );
	EXPECT_TRUE( bps.SetBreakpoint("func") != NULL );
	EXPECT_TRUE( dbg.StepOver(1, NULL, NULL, "func") );

	EXPECT_TRUE(bps.ClearAllBreakpoints());
	dbg.StopDebugging();
	return (TRUE);
}

BOOL Cexe_bpIDETest::StepOverFuncToBreakOnExprTrueBP()
{
 	LogTestHeader( "StepOverFuncToBreakOnExprTrueBP" );

	UIWB.OpenFile( m_strProjectDir + "\\" + "testgo.c");

	EXPECT_TRUE( src.Find("Int = foo_Include(Int);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "Int = foo_Include(Int);") );
	EXPECT_TRUE( bps.SetBreakOnExpr("{foo_Include}number==34", COBP_TYPE_IF_EXP_TRUE) != NULL );
	dbg.StepOver(1, NULL, NULL, NULL, 0);
	if( WaitMsgBoxText("Break when '{foo_Include}number==34'", 280) )
	{
		WriteLog( PASSED, "The MsgBox \"Break when '{foo_Include}number==34'\" was found as expected" );
		// REVIEW(michma - 6/3/99): there is this weird problem on w2k where the data breakpoint hit msg box
		// isn't active right away. doesn't repro manually, only when performed through cafe.
		// so we need to reactivate the IDE for the OK button to become active so we can dismiss the dlg.
		UIWB.Activate();
		MST.WButtonClick( "OK" );
		while(MST.WButtonExists("OK"));
		EXPECT_TRUE_COMMENT( TRUE, "BreakOnExprTrue" );	 	
	}
	else
	{
		WriteLog( FAILED, "The MsgBox \"Break when '{foo_Include}number==34'\" was not found" );
		EXPECT_TRUE( FALSE );	 	
	}
	EXPECT_TRUE( dbg.CurrentLineIs( "if(number == 3)" ) );
	EXPECT_TRUE( cxx.ExpressionValueIs("number == 34",1) );

	UIWB.OpenFile( m_strProjectDir + "\\" + "testgo.c");
	EXPECT_TRUE( src.Find("Int=recur_func();") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "Int=recur_func();") );
	EXPECT_TRUE( bps.SetBreakOnExpr("{recur_func}x==2", COBP_TYPE_IF_EXP_TRUE) != NULL );
	dbg.StepOver(1, NULL, NULL, NULL, 0);
	if( WaitMsgBoxText("Break when '{recur_func}x==2'", 280) )
	{
		WriteLog( PASSED, "The MsgBox \"Break when '{recur_func}x==2'\" was found as expected" );
		// REVIEW(michma - 6/3/99): there is this weird problem on w2k where the data breakpoint hit msg box
		// isn't active right away. doesn't repro manually, only when performed through cafe.
		// so we need to reactivate the IDE for the OK button to become active so we can dismiss the dlg.
		UIWB.Activate();
		MST.WButtonClick( "OK" );
		while(MST.WButtonExists("OK"));
		EXPECT_TRUE_COMMENT( TRUE, "BreakOnExprTrue" );	 	
	}
	else
	{
		WriteLog( FAILED, "The MsgBox \"Break when '{recur_func}x==2'\" was not found" );
		EXPECT_TRUE( FALSE );	 	
	}
	EXPECT_TRUE( dbg.CurrentLineIs( "if (x<9) recur_func();" ) );
	EXPECT_TRUE( cxx.ExpressionValueIs("x==2",1) );
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	// TODO(michma): we need to do this extra step because of bug 38172.
	EXPECT_TRUE(dbg.StepInto());

	dbg.StopDebugging();
	return (TRUE);
}

BOOL Cexe_bpIDETest::StepOverFuncToBreakOnExprChangesBP()
{
 	LogTestHeader( "StepOverFuncToBreakOnExprChangesBP" );

	UIWB.OpenFile( m_strProjectDir + "\\" + "testgo.c");
	EXPECT_TRUE( src.Find("Int=recur_func();") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "Int=recur_func();") );
	EXPECT_TRUE( bps.SetBreakOnExpr("{recur_func}x", COBP_TYPE_IF_EXP_CHANGED) != NULL );
	dbg.StepOver(1, NULL, NULL, NULL, 0);
	if( WaitMsgBoxText("Break when '{recur_func}x'", 280) )
	{
		WriteLog( PASSED, "The MsgBox \"Break when '{recur_func}x'\" was found as expected" );
		// REVIEW(michma - 6/3/99): there is this weird problem on w2k where the data breakpoint hit msg box
		// isn't active right away. doesn't repro manually, only when performed through cafe.
		// so we need to reactivate the IDE for the OK button to become active so we can dismiss the dlg.
		UIWB.Activate();
		MST.WButtonClick( "OK" );
		while(MST.WButtonExists("OK"));
		EXPECT_TRUE_COMMENT( TRUE, "BreakOnExprChanged" );	 	
	}
	else
	{
		WriteLog( FAILED, "The MsgBox \"Break when '{recur_func}x'\" was not found" );
		EXPECT_TRUE( FALSE );	 	
	}
	EXPECT_TRUE( dbg.CurrentLineIs( "if (x<9) recur_func();" ) );
	EXPECT_TRUE( cxx.ExpressionValueIs("x==2",1) );
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	// TODO(michma): we need to do this extra step because of bug 38172.
	EXPECT_TRUE(dbg.StepInto());

	dbg.StopDebugging();
	return (TRUE);
}

BOOL Cexe_bpIDETest::StepBPLineSRC()
{
 	LogTestHeader( "StepBPLineSRC" );

 	LogTestHeader( "StepOver to BPLine: foo_Include" );
	UIWB.OpenFile( m_strProjectDir + "\\" + "testg.h");
	EXPECT_TRUE( src.Find("if(number == 3)") );
	EXPECT_TRUE( bps.SetBreakpoint() != NULL );
	UIBreakpoints bpd;
	bpd.Activate();
	EXPECT_TRUE_COMMENT ( bpd.BreakpointIsSet("26", "testg.h"), "BP is set at line 26 in testg.h" );
	bpd.Close();
	UIWB.OpenFile( m_strProjectDir + "\\" + "testgo.c");
	EXPECT_TRUE( src.Find("foo_Include(Int);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "foo_Include(Int);") );
	EXPECT_TRUE( dbg.StepInto(2, NULL, "number*=2;") );
	EXPECT_TRUE( dbg.StepOver(1, NULL, "if(number == 3)") );
	bpd.Activate();
	EXPECT_TRUE_COMMENT ( bpd.BreakpointIsSet("26", "testg.h"), "BP is set at line 26 in testg.h" );
	bpd.Close();
	EXPECT_TRUE(bps.ClearAllBreakpoints());

 	LogTestHeader( "StepOut to BPLine" );
	CString strLine = "146";
	CString strLocation = (CString)"{,testgo.c,}@" + strLine;
	EXPECT_TRUE( bps.SetBreakpoint(strLocation) != NULL );
	bpd.Activate();
	EXPECT_TRUE( bpd.BreakpointIsSet(strLine, "testgo.c") );
	bpd.Close();
	EXPECT_TRUE( dbg.StepOut(1, NULL, "foo_Include(Int);") );
	bpd.Activate();
	EXPECT_TRUE( bpd.BreakpointIsSet(strLine, "testgo.c") );
	bpd.Close();
	EXPECT_TRUE(bps.ClearAllBreakpoints());

 	LogTestHeader( "StepInto to BPLine: recur_func" );
	EXPECT_TRUE( src.Find("if (x<9) recur_func();") );
	EXPECT_TRUE( bps.SetBreakpoint() != NULL );
	bpd.Activate();
	EXPECT_TRUE_COMMENT ( bpd.BreakpointIsSet("56", "testgo.c"), "BP is set at line 56 in testgo.c" );
	bpd.Close();
	EXPECT_TRUE( dbg.StepOver(1, NULL, "Int=recur_func();") );
	EXPECT_TRUE( dbg.StepInto(3, NULL, "if (x<9) recur_func();") );
	strLine = "56";
	bpd.Activate();
	EXPECT_TRUE_COMMENT ( bpd.BreakpointIsSet(strLine, "testgo.c"), "BP is set at line 56 in testgo.c" );
	bpd.Close();
	EXPECT_TRUE(bps.ClearAllBreakpoints());

 	LogTestHeader( "StepToCursor to BPLine: TestG" );
	EXPECT_TRUE( src.Find("nest_func();") );
	EXPECT_TRUE( bps.SetBreakpoint() != NULL );
	bpd.Activate();
	EXPECT_TRUE_COMMENT ( bpd.BreakpointIsSet("150", "testgo.c"), "BP is set at line 150 in testgo.c" );
	bpd.Close();
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "nest_func();") );
	strLine = "150";
	bpd.Activate();
	EXPECT_TRUE ( bpd.BreakpointIsSet(strLine, "testgo.c") );
	bpd.Close();
	EXPECT_TRUE(bps.ClearAllBreakpoints());

	dbg.StopDebugging();
	return (TRUE);
}

BOOL Cexe_bpIDETest::StepBPLineDAM()
{
 	LogTestHeader( "StepBPLineDAM" );
	UIBreakpoints bpd;

 	LogTestHeader( "StepOver to BPLine" );
	UIWB.OpenFile( m_strProjectDir + "\\" + "testgo.c");
	EXPECT_TRUE( src.Find("foo_Include(Int);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "foo_Include(Int);") );
	EXPECT_TRUE( dbg.StepInto(2, NULL, "number*=2;") );
	dbg.SetSteppingMode(ASM);
	MST.DoKeys("{down 2}");
	EXPECT_TRUE( bps.SetBreakpoint() != NULL );
	bpd.Activate();
	EXPECT_TRUE ( bpd.BreakpointIsSet("0x") );
	bpd.Close();
	EXPECT_TRUE( dbg.StepOver(2) );
	bpd.Activate();
	EXPECT_TRUE ( bpd.BreakpointIsSet("0x") );
	bpd.Close();
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	EXPECT_TRUE( dbg.StepOut(1) );

 	LogTestHeader( "StepInto to BPLine" );
	dbg.SetSteppingMode(SRC);
	EXPECT_TRUE( src.Find("if (x<9) recur_func();") );
	EXPECT_TRUE( bps.SetBreakpoint() != NULL );
	bpd.Activate();
	EXPECT_TRUE_COMMENT ( bpd.BreakpointIsSet("56", "testgo.c"), "BP is set at line 56 in testgo.c" );
	bpd.Close();
	EXPECT_TRUE( dbg.StepOver(1, NULL, "Int=recur_func();") );
	EXPECT_TRUE( dbg.StepInto(2, NULL, "x++;") );
	dbg.SetSteppingMode(ASM);
	EXPECT_TRUE( dbg.StepInto(3) );
	CString strLine = "56";
	bpd.Activate();
	EXPECT_TRUE ( bpd.BreakpointIsSet(strLine, "testgo.c") );
	bpd.Close();
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	MST.DoKeys("{down}");
	EXPECT_TRUE( bps.SetBreakpoint() != NULL );
	bpd.Activate();
	EXPECT_TRUE ( bpd.BreakpointIsSet("0x") );
	bpd.Close();
	EXPECT_TRUE( dbg.StepInto(1) );
	bpd.Activate();
	EXPECT_TRUE ( bpd.BreakpointIsSet("0x") );
	bpd.Close();
	EXPECT_TRUE(bps.ClearAllBreakpoints());

 	LogTestHeader( "StepToCursor to BPLine" );
	dbg.SetSteppingMode(SRC);
	EXPECT_TRUE( src.Find("nest_func();") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "nest_func();") );
	dbg.SetSteppingMode(ASM);
	MST.DoKeys("{down 3}");
	EXPECT_TRUE( bps.SetBreakpoint() != NULL );
	bpd.Activate();
	EXPECT_TRUE ( bpd.BreakpointIsSet("0x") );
	bpd.Close();
	EXPECT_TRUE( dbg.StepToCursor(0) );
	bpd.Activate();
	EXPECT_TRUE ( bpd.BreakpointIsSet("0x") );
	bpd.Close();
	EXPECT_TRUE(bps.ClearAllBreakpoints());

	dbg.StopDebugging();
	return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\exe\exe_bp.h ===
///////////////////////////////////////////////////////////////////////////////
//	exe_bp.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CexeIDETest Class
//

#ifndef __exe_bp_H__
#define __exe_bp_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\dbgset.h"
#include "exesub.h"

///////////////////////////////////////////////////////////////////////////////
//	Cexe_bpIDETest class

class Cexe_bpIDETest : public CDebugTestSet
{
	DECLARE_TEST(Cexe_bpIDETest, CexeSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run();

// Test Cases
protected:

	BOOL StepOverFuncToBreakAtLocBP();
	BOOL StepOverFuncToBreakOnExprTrueBP();
	BOOL StepOverFuncToBreakOnExprChangesBP();
	BOOL BreakStepTrace();
	BOOL StepBPLineSRC();
	BOOL StepBPLineDAM();
};

#endif //__exe_bp_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\exe\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\exe\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\exe\exe_spec.h ===
///////////////////////////////////////////////////////////////////////////////
//	exe_spec.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the Cexe_specialIDETest Class
//

#ifndef __exe_spec_H__
#define __exe_spec_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\dbgset.h"
#include "exesub.h"

///////////////////////////////////////////////////////////////////////////////
//	CexeIDETest class

class Cexe_specialIDETest : public CDebugTestSet
{
	DECLARE_TEST(Cexe_specialIDETest, CexeSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run();

// Test Cases
protected:

	BOOL GoExeDoesNotExist();
	BOOL ExitWhileDebugging();

	BOOL CannotFindDll();
	BOOL StdInOutRedirection();
	BOOL NoSystemCodeStepping();
	BOOL TraceIntoWndProc();

// Utilities
protected:
	BOOL CheckGeneralNetworkFailure();

};

#endif //__exe_spec_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\exe\exe_spec.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	exe_spec.CPP
//											 
//	Created by :			
//		VCBU QA		

#include <process.h>
#include "stdafx.h"
#include "exe_spec.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
IMPLEMENT_TEST(Cexe_specialIDETest, CDebugTestSet, "Execution Special", -1, CexeSubSuite)
												 
void Cexe_specialIDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

void Cexe_specialIDETest::Run()
{	 
	XSAFETY;
	
	if( SetProject("testgo01\\testgo01"))
	{	  
		bps.ClearAllBreakpoints();
		XSAFETY;
		GoExeDoesNotExist();
		XSAFETY;
		// TODO(michma): this has broken since chris' performance chagnes. 2/24/98
		//ExitWhileDebugging();
		XSAFETY;
	}

/*	It doesn't work now: the msg dialog is hidden behind the IDE and even Spy++ cannot see it	
	if (SetProject("dllapp\\incdll", PROJECT_DLL) && SetProject("dllapp\\powdll", PROJECT_DLL)
		&& SetProject("dllapp\\dec2", PROJECT_DLL) && SetProject("dllapp\\dllappx"))
	{
		XSAFETY;
		bps.ClearAllBreakpoints();
		EXPECT_TRUE(CannotFindDll());
		XSAFETY;
	}
*/
	if( SetProject("cons01\\cons01"))
	{	  
		XSAFETY;
		StdInOutRedirection();
		XSAFETY;
	}
 
	if( SetProject("dbga\\dbga"))
	{	  
		XSAFETY;
		if(!(GetSystem() & SYSTEM_NT))
		{
			NoSystemCodeStepping();
			XSAFETY;
		}

/* bug # 1347 is postponed for after V50
		TraceIntoWndProc();
		XSAFETY;
*/
	}

	// close the project in preparation for the next group of tests.
	COProject prj;
	prj.Attach();
	prj.Close();

}


///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////

BOOL Cexe_specialIDETest::GoExeDoesNotExist( )
{
 	LogTestHeader( "GoExeDoesNotExist" );
	m_pLog->RecordInfo( "Try to execute nonexisting PCTarget, correct the path and GO" );

	char* szTARGET_EXT = ".exe";
	char* szREMOTE_TARGET_EXT = "";

	CString stOldTarget = m_strProjectName + szTARGET_EXT ;
	CString stAbsPathTarget =  m_strProjectDir + "\\" + m_strProjectName + szTARGET_EXT ;
	CString stNewTarget = m_strProjectDir + "\\kit\\" + m_strProjectName + szTARGET_EXT;
	CString stBadTarget = m_strProjectDir + "\\..\\" + m_strProjectName + szTARGET_EXT ;

	// Rename the target and run
	CopyFile(stAbsPathTarget, m_strProjectDir + "\\foo" + szTARGET_EXT, FALSE);
	DeleteFile(stAbsPathTarget);
	EXPECT_TRUE(dbg.Go(NULL,NULL,NULL,0) );

	if( WaitMsgBoxText("does not exist", 10) )
	{
		WriteLog( PASSED, "01 : The MsgBox \"... does not exist...\" was found as expected" );
		MST.WButtonClick( "OK" ); // MST.WButtonClick( "No" );
	}
	else
	{
		if( WaitMsgBoxText("not found", 10) )
		{
			WriteLog( PASSED, "01 : The MsgBox \"...File not found\" was found as expected" );
			MST.WButtonClick( "OK" );
		}
		else
		{
			WriteLog( FAILED, "01 : The MsgBox \"...File not found\" was not found" );
			WriteLog( FAILED, "01 : The MsgBox \"... does not exist...\" was not found" );
			EXPECT_TRUE( FALSE );	 	
		}
	}
	
	// Set incorrect path\target 
	EXPECT_TRUE(proj.SetLocalTarget(stBadTarget) == ERROR_SUCCESS);
	EXPECT_TRUE(dbg.Go(NULL,NULL,NULL,0));

	if( WaitMsgBoxText("or do not exist", 10)) 
	{
		WriteLog( PASSED, "The MsgBox \"One or more targets are out of date...\" was found" );
		MST.WButtonClick( "No" );
	}

/*	EXPECT_TRUE( WaitMsgBoxText("not be opened", 10));
	EXPECT_TRUE( WaitMsgBoxText("not exist", 10));
	MST.WButtonClick( "OK" );
*/
 	if( WaitMsgBoxText("does not exist", 10) )
	{
		WriteLog( PASSED, "01 : The MsgBox \"... does not exist...\" was found as expected" );
		MST.WButtonClick( "OK" ); // MST.WButtonClick( "No" );
	}
	else
	{
		if( WaitMsgBoxText("not found", 10) )
		{
			WriteLog( PASSED, "01 : The MsgBox \"...File not found\" was found as expected" );
			MST.WButtonClick( "OK" );
		}
		else
		{
			WriteLog( FAILED, "01 : The MsgBox \"...File not found\" was not found" );
			WriteLog( FAILED, "01 : The MsgBox \"... does not exist...\" was not found" );
			EXPECT_TRUE( FALSE );	 	
		}
	}

	// Set correct new path\target and run
	CreateDirectory(m_strProjectDir + "\\kit", 0);          
	CopyFile(m_strProjectDir + "\\foo" + szTARGET_EXT, stNewTarget, FALSE);
	EXPECT(proj.SetLocalTarget(stNewTarget) == ERROR_SUCCESS );
	EXPECT_TRUE(dbg.Go(NULL,NULL,NULL,0) );

	if( WaitMsgBoxText("or do not exist", 10))
	{
		WriteLog( PASSED, "01 : The MsgBox \"One or more targets are out of date...\" was found as expected" );
		MST.WButtonClick( "No" );
		while(MST.WFndWndC("or do not exist", "Static", FW_PART));
	}

	// REVIEW (michma): why does UIWB.WaitForRun() never return?
	//UIWB.WaitForRun();
	// Sleep(10000);
	CString TitleRun = (CString)"[" + GetLocString(IDSS_DBG_RUN) + "]";
	MST.WFndWndWait(TitleRun, FW_PART, 10);

//	UIWB.WaitForTermination();
	dbg.Wait(WAIT_FOR_TERMINATION);

/*	EXPECT_TRUE( VerifyProjectRan() );
*/
	// Remove temporary file and dir
	DeleteFile(stNewTarget);
	RemoveDirectory(m_strProjectDir + "\\kit");         

	// Set correct AbsPath\target 
	EXPECT( proj.SetLocalTarget(stAbsPathTarget) == ERROR_SUCCESS );

	// Exe is still out of place
	EXPECT_TRUE(dbg.Go(NULL,NULL,NULL,0) );
	if( WaitMsgBoxText("does not exist", 10) )
	{
		WriteLog( PASSED, "The MsgBox \"... does not exist...\" was found as expected" );
		MST.WButtonClick( "OK" ); // MST.WButtonClick( "No" );
	}
	else
	{
		if( WaitMsgBoxText("not found", 10) )
		{
			WriteLog( PASSED, "The MsgBox \"...File not found\" was found as expected" );
			MST.WButtonClick( "OK" );
		}
		else
		{
			WriteLog( FAILED, "The MsgBox \"...File not found\" was not found" );
			WriteLog( FAILED, "The MsgBox \"... does not exist...\" was not found" );
			EXPECT_TRUE( FALSE );	 	
		}
	}

	// Exe is back in place
	CopyFile(m_strProjectDir + "\\foo" + szTARGET_EXT, stAbsPathTarget, FALSE);
	DeleteFile(m_strProjectDir + "\\foo" + szTARGET_EXT);
	Sleep(1000);
	EXPECT_TRUE( dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION) );

	// Restore initial target
	EXPECT_TRUE( proj.SetLocalTarget(stOldTarget) == ERROR_SUCCESS );

	// Verify restoration is OK
	EXPECT_TRUE( dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION) );

	return (TRUE);
}

BOOL Cexe_specialIDETest::CheckGeneralNetworkFailure( )
{
	if( WaitMsgBoxText("General Network Failure", 10) )
	{
		MST.DoKeys( KEY_Enter );
		return (FALSE);      
	}
	else
	{
		return (TRUE);      
	}
}


BOOL Cexe_specialIDETest::ExitWhileDebugging( )
{
 	LogTestHeader( "ExitWhileDebugging" );

	m_pLog->RecordInfo( "Restart, Exit IDE and verify: ExitWhileDebugging" );
	dbg.Restart();
	dbg.SetSteppingMode(SRC);  //Temporary workaround: bug #15556
	CString strLine = "{";

	if( UIWB.GetPcodeSwitch() )
		strLine = "int iGo = TestG();";

    EXPECT_TRUE( dbg.CurrentLineIs( strLine ) );
	UIWB.DoCommand(ID_APP_EXIT, DC_MNEMONIC);
	
	if( WaitMsgBoxText("command will stop the debugger", 10) )
	{
		WriteLog( PASSED, "01 : The MsgBox \"command will stop the debugger\" was found as expected" );
		MST.WButtonClick( "Cancel" );
	}
	else
	{
		WriteLog( FAILED, "01 : The MsgBox \"command will stop the debugger\" was not found as expected" );
		EXPECT_TRUE( FALSE );	 	
	}
 
	UIWB.DoCommand(ID_APP_EXIT, DC_MNEMONIC);

	if( WaitMsgBoxText("command will stop the debugger", 10) )
	{
		WriteLog( PASSED, "02 : The MsgBox \"command will stop the debugger\" was found as expected" );
		MST.WButtonClick( "OK" );
	}
	else
	{
		WriteLog( FAILED, "02 : The MsgBox \"command will stop the debugger\" was not found as expected" );
		EXPECT_TRUE( FALSE );	 	
	}

	if( WaitMsgBoxText("want to save", 10) )
	{
		MST.WButtonClick( "No" );
	}

	while(GetSubSuite()->GetIDE()->IsLaunched());

	// REVIEW(briancr): use RTTI for this cast, or at least to validate it
	GetSubSuite()->GetIDE()->Launch();
	WriteLog( PASSED, "03 : The IDE was closed and reopened as expected" );
	return (TRUE);
}


BOOL Cexe_specialIDETest::CannotFindDll( )
{
 	LogTestHeader( "CannotFindDll" );
	m_pLog->RecordInfo( "Try to start debugging exe which cannot find associated Dll, correct the path and debug" );

	// Verify we can start debugging
	dbg.Restart();
	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "WinMain") );
	dbg.StopDebugging();

	// Rename dec2.dll to dec22.dll and start debugging
	CopyFile(m_strProjectDir + "\\dec2.dll", m_strProjectDir + "\\dec22.dll", FALSE);
	DeleteFile(m_strProjectDir + "\\dec2.dll");
	EXPECT_TRUE(dbg.StepInto(1,NULL,NULL,NULL,0) );

//	dbg.CancelMsg(MSG_DLL_NOT_FOUND);	 // it got out of the CODebug ?
/*	if( WaitMsgBoxText("not found", 10) )
	{
		WriteLog( PASSED, "01 : The MsgBox \"...not found...\" was found" );
		MST.WButtonClick( "OK" ); 
	}
	else
	{
		if( WaitMsgBoxText("Could not execute", 10) )
		{
			WriteLog( PASSED, "01 : The MsgBox \"Could not execute...\" was found as expected" );
			MST.DoKeys( KEY_Enter );
			if( WaitMsgBoxText("Cannot execute", 10) )
			{
				WriteLog( PASSED, "01 : The MsgBox \"Cannot execute...\" was found as expected" );
				MST.DoKeys( KEY_Enter );
			}
		}
		else
		{
			WriteLog( FAILED, "The MsgBox \"...not found\" was not found" );
			WriteLog( FAILED, "The MsgBox \"Could not execute...\" was not found" );
			EXPECT_TRUE( FALSE );	 	
		}
	}
	
	if( WaitMsgBoxText("not found", 10) )
	{
		WriteLog( PASSED, "01 : The MsgBox \"...not found...\" was found" );
		MST.WButtonClick( "OK" ); 
	}
	else
	{
		if( WaitMsgBoxText("Could not execute", 10) )
		{
			WriteLog( PASSED, "01 : The MsgBox \"Could not execute...\" was found as expected" );
			MST.DoKeys( KEY_Enter );
			if( WaitMsgBoxText("Cannot execute", 10) )
			{
				WriteLog( PASSED, "01 : The MsgBox \"Cannot execute...\" was found as expected" );
				MST.DoKeys( KEY_Enter );
			}
		}
		else
		{
			WriteLog( FAILED, "The MsgBox \"...not found\" was not found" );
			WriteLog( FAILED, "The MsgBox \"Could not execute...\" was not found" );
			EXPECT_TRUE( FALSE );	 	
		}
	}
*/	
/*	
	if( WaitMsgBoxText("Could not execute", 10) )
	{
		WriteLog( PASSED, "01 : The MsgBox \"Could not execute...\" was found as expected" );
		MST.DoKeys( KEY_Enter );
	}
	else
	{
		WriteLog( FAILED, "01 : The MsgBox \"Could not execute...\" was not found" );
		EXPECT_TRUE( FALSE );	 	
	}
*/	
	// Restore initial Dll
	CopyFile(m_strProjectDir + "\\dec22.dll", m_strProjectDir + "\\dec2.dll", FALSE);
	DeleteFile(m_strProjectDir + "\\dec22.dll");
	EXPECT_TRUE( dbg.StepInto(1, NULL, "{", "WinMain") );
	dbg.StopDebugging();

	return (TRUE);
}

BOOL Cexe_specialIDETest::StdInOutRedirection()
{
 	LogTestHeader( "StdInOutRedirection" );
	m_pLog->RecordInfo( "Redirect Std Input and Output to files and debug console app" );

	// Redirect std input from file cons01.inp and check values
	CString progargs = "< cons01.inp";
	EXPECT_TRUE( proj.SetProgramArguments(progargs) == ERROR_SUCCESS );

	UIWB.OpenFile( m_strProjectDir + "\\" + "cons01.cpp");
	EXPECT_TRUE( src.Find("cin >> Char;") );

	EXPECT_TRUE( dbg.StepToCursor());
	// REVIEW(michma - 6/8/99): we're seeing a weird timing problem on w2k where sometimes the console window of the debuggee is still in the foreground
	// even though the debugger is in break mode. doesn't happen manually.
	UIWB.Activate();
	EXPECT_TRUE(dbg.CurrentLineIs("cin >> Char;"));
	
	dbg.StepOver(1, NULL, NULL, NULL, 0);
	EXPECT_TRUE( cxx.ExpressionValueIs("Char=='a'",1) );

	dbg.StepOver(1, NULL, NULL, NULL, 0);
	EXPECT_TRUE( cxx.ExpressionValueIs("Array1d[1]",888) );

	EXPECT_TRUE( src.Find("cin >> String;") );

	EXPECT_TRUE( dbg.StepToCursor());
	// REVIEW(michma - 6/8/99): we're seeing a weird timing problem on w2k where sometimes the console window of the debuggee is still in the foreground
	// even though the debugger is in break mode. doesn't happen manually.
	UIWB.Activate();
	EXPECT_TRUE(dbg.CurrentLineIs("cin >> String;"));

	EXPECT_TRUE( cxx.ExpressionValueIs("Array2d[0][2]",7) );

	dbg.StepOver(1, NULL, NULL, NULL, 0);
	CString stringValue = "ADDRESS \"!ZYXWVUTSRQPONMLKJIHGFEDCBA\"";
	EXPECT_TRUE( cxx.ExpressionValueIs("String",stringValue) );

	dbg.StopDebugging();

	// Redirect std output into file cons01.out
	progargs = "> cons01.out";
	EXPECT_TRUE( proj.SetProgramArguments(progargs) == ERROR_SUCCESS );

	DeleteFile(m_strProjectDir + "\\cons01.out");
	UIWB.OpenFile( m_strProjectDir + "\\" + "cons01.cpp");
	EXPECT_TRUE( src.Find("cout << Char;") );
	
	EXPECT_TRUE( dbg.StepToCursor());
	// REVIEW(michma - 6/8/99): we're seeing a weird timing problem on w2k where sometimes the console window of the debuggee is still in the foreground
	// even though the debugger is in break mode. doesn't happen manually.
	UIWB.Activate();
	EXPECT_TRUE(dbg.CurrentLineIs("cout << Char;"));

	EXPECT_TRUE( dbg.StepOver(1, NULL, "cout << Array1d[0] << Array1d[1] << Array1d[2] ;") );
	EXPECT_TRUE( src.Find("cin >> Char;") );
	
	EXPECT_TRUE( dbg.StepToCursor());
	// REVIEW(michma - 6/8/99): we're seeing a weird timing problem on w2k where sometimes the console window of the debuggee is still in the foreground
	// even though the debugger is in break mode. doesn't happen manually.
	UIWB.Activate();
	EXPECT_TRUE(dbg.CurrentLineIs("cin >> Char;"));

	dbg.StopDebugging();

	// Redirect both std input (cons01.inp) and output (cons01.out)
	// and check values and output
	DeleteFile(m_strProjectDir + "\\cons01.out");
	progargs = "< cons01.inp > cons01.out";
	EXPECT_TRUE( proj.SetProgramArguments(progargs) == ERROR_SUCCESS );

	UIWB.OpenFile( m_strProjectDir + "\\" + "cons01.cpp");
	EXPECT_TRUE( src.Find("cin >> Char;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "cin >> Char;") );
	dbg.StepOver(1, NULL, NULL, NULL, 0);
	EXPECT_TRUE( cxx.ExpressionValueIs("Char=='a'",1) );

	dbg.StepOver(1, NULL, NULL, NULL, 0);
	EXPECT_TRUE( cxx.ExpressionValueIs("Array1d[1]",888) );

	EXPECT_TRUE( src.Find("cin >> String;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "cin >> String;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("Array2d[0][2]",7) );

	dbg.StepOver(1, NULL, NULL, NULL, 0);
	EXPECT_TRUE( cxx.ExpressionValueIs("String",stringValue) );

	EXPECT_TRUE( dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION) );
	UIWB.OpenFile( m_strProjectDir + "\\" + "cons01.out");
	EXPECT_TRUE( src.Find("s111222333112233445566778899this is a string") );

	return (TRUE);
}

BOOL Cexe_specialIDETest::TraceIntoWndProc()
{
 	LogTestHeader( "TraceIntoWndProc" );
	bps.ClearAllBreakpoints();

	UIWB.OpenFile( m_strProjectDir + "\\" + "main2.c");
	EXPECT_TRUE( src.Find("SendMessage(") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "SendMessage(") );
//	EXPECT_TRUE( dbg.StepInto(1, NULL, "{", "WndProc") );
	EXPECT_TRUE( dbg.StepInto(1, NULL, "{") );
	EXPECT_TRUE( stk.CurrentFunctionIs("WndProc")	);
	EXPECT_TRUE( dbg.StepInto(1, NULL, "SAVELABEL(TagCallOtherMain);", "WndProc") );

	dbg.StopDebugging();
	return (TRUE);
}

BOOL Cexe_specialIDETest::NoSystemCodeStepping()
{
 	LogTestHeader( "NoSystemCodeStepping" );
	bps.ClearAllBreakpoints();
	BOOL ret = TRUE;

	UIWB.OpenFile( m_strProjectDir + "\\" + "main2.c");
	EXPECT_TRUE( src.Find("SAVELABEL(TagCreateCase);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "SAVELABEL(TagCreateCase);", "WndProc") );
	EXPECT_TRUE( dbg.StepOut(1, NULL, NULL, NULL, 0) );

//	if( WaitMsgBoxText("Cannot step through system code", 280) )
	if( WaitMsgBoxText("Can't trace into system DLLs", 280) )
	{
		WriteLog( PASSED, "The MsgBox \"Can't trace into system DLLs\" was found as expected" );
		MST.WButtonClick( "OK" ); 
	}
	else
	{
		WriteLog( FAILED, "The MsgBox \"Can't trace into system DLLs\" was not found" );
		ret = FALSE;	 	
	}
	dbg.StopDebugging();
	return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\exe\gocases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	GoCases.cpp
//
//	Created by :			Date :
//		YefimS			11/21/93
//
//	Description :
//		Implementation of Go cases
//

#include <process.h>
#include "stdafx.h"
#include "execase.h"

///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////

BOOL CexeIDETest::GoAndVerify( )
{
 	LogTestHeader( "GoAndVerify" );
	m_pLog->RecordInfo( " Run an app and verify it ran " );

	EXPECT_TRUE( dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION) );
	return (TRUE);
}

BOOL CexeIDETest::RestartAndGo( )
{
 	LogTestHeader( "RestartAndGo" );
	m_pLog->RecordInfo( " Restart, verify stop and Go " );

	EXPECT_TRUE( dbg.Restart() );
	if( UIWB.GetPcodeSwitch() )
	{
		EXPECT_TRUE( dbg.CurrentLineIs( "int iGo = TestG();" ) );
	}
	else
	{
		EXPECT_TRUE( dbg.CurrentLineIs( "{" ) );
	}

	EXPECT_TRUE( dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION) );

	return (TRUE);
}


BOOL CexeIDETest::RestartStopDebugging( )
{
 	LogTestHeader( "RestartStopDebugging" );
	m_pLog->RecordInfo( "Restart, StopDebugging and verify" );

    EXPECT_TRUE( dbg.Restart() );

	if( UIWB.GetPcodeSwitch() )
	{
	//dbg.SetSteppingMode(SRC);  //Temporary workaround: 
		EXPECT_TRUE( dbg.CurrentLineIs( "int iGo = TestG();" ) );
	}
	else
	{
		EXPECT_TRUE( dbg.CurrentLineIs( "{" ) );
	}
	EXPECT_TRUE( dbg.StopDebugging() );
	#if defined( _M_IX86 ) || defined( _MAC )  // WinslowF - for OEM compatibility
		EXPECT_TRUE( VerifyProjectRan(0) );
	#else
		EXPECT_TRUE( VerifyProjectRan(1) );
	#endif

	WriteLog(PASSED, "Stop Debugging was handled as expected" );
	return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\exe\exe_dlls.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	exe_dlls.CPP
//											 
//	Created by :			
//		VCBU QA		

#include "stdafx.h"
#include "exe_dlls.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
											   
IMPLEMENT_TEST(Cexe_dllsIDETest, CDebugTestSet, "Execution DLLs", -1, CexeSubSuite)
												 
void Cexe_dllsIDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

void Cexe_dllsIDETest::Run()
{	 
	XSAFETY;
	
	if (SetProject("dllapp\\incdll", PROJECT_DLL) && SetProject("dllapp\\powdll", PROJECT_DLL)
		&& SetProject("dllapp\\dec2", PROJECT_DLL) && SetProject("dllapp\\dllappx"))
	{
		XSAFETY;
//		StartDebugging();		// WinslowF
		bps.ClearAllBreakpoints();
			
		EXPECT_TRUE(DllStepTrace());
		XSAFETY;
		EXPECT_TRUE(DllStepOut());
		XSAFETY;
		EXPECT_TRUE(DllTraceOut());
		XSAFETY;
		EXPECT_TRUE(StepOverFuncInUnloadedDll());
		XSAFETY;
		EXPECT_TRUE(RestartFromWithinDll());
		XSAFETY;
		EXPECT_TRUE(GoFromWithinDll());
		XSAFETY;
	}
	//	StopDbgCloseProject();
	
}

///////////////////////////////////////////////////////////////////////////////
//	Test Cases

/*
** Stepping model test(s) involving DLL's.
** Step Loadlibrary and then trace into the virtual explicit dll.
**
*/ 

BOOL Cexe_dllsIDETest::DllStepTrace(   )
{
 	LogTestHeader( "DllStepTrace" );

	BOOL fSuccess;
	int count;

	/* 
	** test step/trace of LoadLibrary
	** (for portability reasons this needs to be isolated)
	*/
	dbg.Restart();
	bps.ClearAllBreakpoints();
	EXPECT_TRUE ( fSuccess = (bps.SetBreakpoint("{Dec,,dec2.dll}TagLoadLib") != NULL) );
	EXPECT_TRUE ( fSuccess &= dbg.Go("{Dec,,dec2.dll}TagLoadLib") );
	dbg.StepInto();  // step load library call which does a symbol load
	// REVIEW:  is there anything interesting to verify?
	EXPECT_TRUE( fSuccess &= (dbg.VerifyNotification("Loaded symbols", 3, 20, TRUE) && dbg.VerifyNotification("powdll.dll", 1, 20, TRUE)) );

	/* 
	** test tracing into function contained in a virtual dll. (for 
	** portability reasons this needs to be isolated)
	*/
	count=0;
	while ( (count<10) && (!dbg.AtSymbol("{Dec,,dec2.dll}TagCallPow")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE(fSuccess &= (dbg.AtSymbol("TagCallPow") && stk.CurrentFunctionIs("Dec")) );
	EXPECT_TRUE(fSuccess &= dbg.StepInto(1, NULL, NULL, "dPow"));

	dbg.StopDebugging();
	EXPECT_TRUE ( fSuccess &= dbg.Go("{Dec,,dec2.dll}TagLoadLib") );
	dbg.StepOver();  // step over load library call which does a symbol load
	EXPECT_TRUE( fSuccess &= (dbg.VerifyNotification("Loaded symbols", 3, 20, TRUE) && dbg.VerifyNotification("powdll.dll", 1, 20, TRUE)) );

	dbg.StopDebugging();
	EXPECT_TRUE(fSuccess &= (bps.SetBreakpoint("{Dec,,dec2.dll}TagCallPow") != NULL) );
	dbg.Go();
	EXPECT_TRUE ( fSuccess &= dbg.Go("{Dec,,dec2.dll}TagCallPow") );
	EXPECT_TRUE(fSuccess &= (bps.SetBreakpoint("dPow") != NULL));
	EXPECT_TRUE ( fSuccess &= dbg.StepOver(1, "dPow") );
	return fSuccess;	
}

BOOL Cexe_dllsIDETest::DllStepOut(   )
{
 	LogTestHeader( "DllStepOut" );
	BOOL fSuccess = TRUE;
	dbg.Restart();
	bps.ClearAllBreakpoints();
	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint("{Dec,,dec2.dll}Dec") != NULL ));
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, NULL, "Dec") );
	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint("{Dec,,dec2.dll}@54") != NULL ));
	
	// StepOut of implibed DLL into DLL
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, "Inc(wBar);") );
	EXPECT_TRUE ( fSuccess &= dbg.StepInto(1, NULL, NULL, "Inc") ); 
	EXPECT_TRUE_COMMENT ( fSuccess &= dbg.StepOut(1, NULL, NULL, "Dec"), "StepOut of implibed DLL into DLL (source mode)" ); 

	// StepOut of not implibed DLL into DLL
	int count=0;
	while ( (count<25) && (!dbg.AtSymbol("{Dec,,dec2.dll}TagCallPow")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE(fSuccess &= (dbg.AtSymbol("TagCallPow") && stk.CurrentFunctionIs("Dec")));
	EXPECT_TRUE(fSuccess &= dbg.StepInto(1, NULL, NULL, "dPow"));
	EXPECT_TRUE_COMMENT ( fSuccess &= dbg.StepOut(1, NULL, NULL, "Dec"), "StepOut of not implibed DLL into DLL (source mode)" ); 

	// StepOut of implibed DLL into EXE
	EXPECT_TRUE_COMMENT ( fSuccess &= dbg.StepOut(1, NULL, NULL, "MainWndProc"), "StepOut of implibed DLL into EXE (source mode)" ); 

	// ASM mode
	dbg.Restart();
	dbg.SetSteppingMode(ASM);
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, NULL, "Dec") );

	// StepOut of implibed DLL into DLL
	EXPECT_TRUE_COMMENT ( fSuccess &= dbg.Go(NULL, NULL, "Dec"), "At line 54" );
	count=0;
	while ( (count<25) && (!stk.CurrentFunctionIs("Inc")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE ( fSuccess &= stk.CurrentFunctionIs("Inc") );
	EXPECT_TRUE ( fSuccess &= dbg.StepInto(3, NULL, NULL, "Inc") ); 
	EXPECT_TRUE_COMMENT ( fSuccess &= dbg.StepOut(1, NULL, NULL, "Dec"), "StepOut of implibed DLL into DLL (mixed mode)" ); 

	// StepOut of not implibed DLL into DLL
	EXPECT_TRUE(fSuccess &= (bps.SetBreakpoint("{Dec,,dec2.dll}TagCallPow") != NULL));
	dbg.Go();
	count=0;
	while ( (count<25) && (!stk.CurrentFunctionIs("dPow")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE ( fSuccess &= stk.CurrentFunctionIs("dPow") );
	EXPECT_TRUE ( fSuccess &= dbg.StepInto(2, NULL, NULL, "dPow") ); 
	EXPECT_TRUE_COMMENT ( fSuccess &= dbg.StepOut(1, NULL, NULL, "Dec"), "StepOut of not implibed DLL into DLL (mixed mode)" ); 

	// StepOut of implibed DLL into EXE
	EXPECT_TRUE_COMMENT ( fSuccess &= dbg.StepOut(1, NULL, NULL, "MainWndProc"), "StepOut of implibed DLL into EXE (mixed mode)" ); 

	dbg.StopDebugging();
	return fSuccess;	
}

BOOL Cexe_dllsIDETest::DllTraceOut(   )
{
 	LogTestHeader( "DllTraceOut" );
	BOOL fSuccess = TRUE;
	dbg.Restart();
	bps.ClearAllBreakpoints();
	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint("{Dec,,dec2.dll}Dec") != NULL ));
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, NULL, "Dec") );
	
	// TraceOut of implibed DLL into DLL
	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint("{Dec,,dec2.dll}@54") != NULL ));
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, "Inc(wBar);") );
	EXPECT_TRUE ( fSuccess &= dbg.StepInto(1, NULL, NULL, "Inc") ); 
	int count=0;
	while ( (count<25) && (!stk.CurrentFunctionIs("Dec")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE_COMMENT ( fSuccess &= stk.CurrentFunctionIs("Dec"), "TraceOut of implibed DLL into DLL" );

	// TraceOut of not implibed DLL into DLL
	count=0;
	while ( (count<25) && (!dbg.AtSymbol("{Dec,,dec2.dll}TagCallPow")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE(fSuccess &= (dbg.AtSymbol("TagCallPow") && stk.CurrentFunctionIs("Dec")));
	EXPECT_TRUE(fSuccess &= dbg.StepInto(1, NULL, NULL, "dPow"));
	count=0;
	while ( (count<25) && (!stk.CurrentFunctionIs("Dec")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE_COMMENT ( fSuccess &= stk.CurrentFunctionIs("Dec"), "TraceOut of not implibed DLL into DLL" );

	dbg.StopDebugging();
	return fSuccess;	
}

BOOL Cexe_dllsIDETest::GoFromWithinDll(   )
{
 	LogTestHeader( "GoFromWithinDll" );
	BOOL fSuccess = TRUE;
	dbg.Restart();
	bps.ClearAllBreakpoints();

	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint("{Dec,,dec2.dll}Dec") != NULL ));
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, NULL, "Dec") );
	UIWB.OpenFile( m_strProjectDir + "\\" + "dllappx.c");
	EXPECT_TRUE( fSuccess &= src.Find("BPWithLengthTest();") );
	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint() != NULL ));
	EXPECT_TRUE( dbg.Go(NULL, "BPWithLengthTest();", "MainWndProc") );
	bps.ClearAllBreakpoints();
	dbg.Restart();

	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint("{Inc,,incdll.dll}Inc") != NULL ));
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, NULL, "Inc") );
	UIWB.OpenFile( m_strProjectDir + "\\" + "dec2.c");
	EXPECT_TRUE( fSuccess &= src.Find("dValue = dpfnPow( 10, 3 );") );
	EXPECT_TRUE( fSuccess &= dbg.StepToCursor(0, NULL, "dValue = dpfnPow( 10, 3 );") );
	
	EXPECT_TRUE(fSuccess &= (dbg.AtSymbol("TagCallPow") && stk.CurrentFunctionIs("Dec")));
	EXPECT_TRUE(fSuccess &= dbg.StepInto(2, NULL, NULL, "dPow"));
	UIWB.OpenFile( m_strProjectDir + "\\" + "dllappx.c");
	EXPECT_TRUE( fSuccess &= src.Find("BPWithLengthTest();") );
	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint() != NULL ));
	EXPECT_TRUE( fSuccess &= dbg.Go(NULL, "BPWithLengthTest();", "MainWndProc") );

	dbg.StopDebugging();
	return fSuccess;	
}

BOOL Cexe_dllsIDETest::RestartFromWithinDll(   )
{
 	LogTestHeader( "RestartFromWithinDll" );
	BOOL fSuccess = TRUE;
	dbg.Restart();
	bps.ClearAllBreakpoints();

	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint("{Dec,,dec2.dll}Dec") != NULL ));
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, NULL, "Dec") );
	EXPECT_TRUE( fSuccess &= dbg.Restart() );
	bps.ClearAllBreakpoints();

	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint("{Inc,,incdll.dll}Inc") != NULL ));
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, NULL, "Inc") );
	EXPECT_TRUE( fSuccess &= dbg.Restart() );
	bps.ClearAllBreakpoints();
	
	UIWB.OpenFile( m_strProjectDir + "\\" + "dec2.c");
	EXPECT_TRUE( fSuccess &= src.Find("dValue = dpfnPow( 10, 3 );") );
	EXPECT_TRUE( fSuccess &= dbg.StepToCursor(0, NULL, "dValue = dpfnPow( 10, 3 );") );
	EXPECT_TRUE(fSuccess &= (dbg.AtSymbol("TagCallPow") && stk.CurrentFunctionIs("Dec")));
	EXPECT_TRUE(fSuccess &= dbg.StepInto(2, NULL, NULL, "dPow"));
	EXPECT_TRUE( fSuccess &= dbg.Restart() );

	dbg.StopDebugging();
	return fSuccess;	
}

BOOL Cexe_dllsIDETest::StepOverFuncInUnloadedDll(   )
{
 	LogTestHeader( "StepOverFuncInUnloadedDll" );
	BOOL fSuccess = TRUE;
	dbg.Restart();
	bps.ClearAllBreakpoints();

	UIWB.OpenFile( m_strProjectDir + "\\" + "dllappx.c");
	EXPECT_TRUE( fSuccess &= src.Find("Dec( &wValue );") );
	EXPECT_TRUE( fSuccess &= dbg.StepToCursor(0, NULL, "Dec( &wValue );", "MainWndProc") );
	EXPECT_TRUE(fSuccess &= dbg.StepOver(1, NULL, NULL, "MainWndProc"));
	EXPECT_TRUE( fSuccess &= (dbg.VerifyNotification("Loaded symbols", 3, 20, TRUE) && dbg.VerifyNotification("powdll.dll", 1, 20, TRUE)) );

	dbg.StopDebugging();
	return fSuccess;	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\exe\gocases2.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	GoCases2.cpp
//
//	Created by :			Date :
//		YefimS			11/21/93
//
//	Description :
//		Implementation of Go cases
//

#include <process.h>
#include "stdafx.h"
#include "execase2.h"

///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////

BOOL Cexe2IDETest::GoExeDoesNotExist( )
{
 	LogTestHeader( "GoExeDoesNotExist" );
	m_pLog->RecordInfo( "Try to execute nonexisting PCTarget, correct the path and GO" );

	char* szTARGET_EXT = ".exe";
	char* szREMOTE_TARGET_EXT = "";

	CString stOldTarget = m_strProjectName + szTARGET_EXT ;
	CString stAbsPathTarget =  m_strProjectDir + "\\" + m_strProjectName + szTARGET_EXT ;
	CString stNewTarget = m_strProjectDir + "\\kit\\" + m_strProjectName + szTARGET_EXT;
	CString stBadTarget = m_strProjectDir + "\\..\\" + m_strProjectName + szTARGET_EXT ;

	// Rename the target and run
	CopyFile(stAbsPathTarget, m_strProjectDir + "\\foo" + szTARGET_EXT, FALSE);
	DeleteFile(stAbsPathTarget);
	EXPECT_TRUE(dbg.Go(NULL,NULL,NULL,0) );

	if( WaitMsgBoxText("does not exist", 10) )
	{
		WriteLog( PASSED, "01 : The MsgBox \"... does not exist...\" was found as expected" );
		MST.WButtonClick( "OK" ); // MST.WButtonClick( "No" );
	}
	else
	{
		if( WaitMsgBoxText("not found", 10) )
		{
			WriteLog( PASSED, "01 : The MsgBox \"...File not found\" was found as expected" );
			MST.WButtonClick( "OK" );
		}
		else
		{
			WriteLog( FAILED, "01 : The MsgBox \"...File not found\" was not found" );
			WriteLog( FAILED, "01 : The MsgBox \"... does not exist...\" was not found" );
			EXPECT_TRUE( FALSE );	 	
		}
	}
	
	// Set incorrect path\target 
	EXPECT_TRUE(proj.SetLocalTarget(stBadTarget) == ERROR_SUCCESS);
	EXPECT_TRUE(dbg.Go(NULL,NULL,NULL,0));

	if( WaitMsgBoxText("or do not exist", 10)) 
	{
		WriteLog( PASSED, "The MsgBox \"One or more targets are out of date...\" was found" );
		MST.WButtonClick( "No" );
	}

/*	EXPECT_TRUE( WaitMsgBoxText("not be opened", 10));
	EXPECT_TRUE( WaitMsgBoxText("not exist", 10));
	MST.WButtonClick( "OK" );
*/
 	if( WaitMsgBoxText("does not exist", 10) )
	{
		WriteLog( PASSED, "01 : The MsgBox \"... does not exist...\" was found as expected" );
		MST.WButtonClick( "OK" ); // MST.WButtonClick( "No" );
	}
	else
	{
		if( WaitMsgBoxText("not found", 10) )
		{
			WriteLog( PASSED, "01 : The MsgBox \"...File not found\" was found as expected" );
			MST.WButtonClick( "OK" );
		}
		else
		{
			WriteLog( FAILED, "01 : The MsgBox \"...File not found\" was not found" );
			WriteLog( FAILED, "01 : The MsgBox \"... does not exist...\" was not found" );
			EXPECT_TRUE( FALSE );	 	
		}
	}

	// Set correct new path\target and run
	CreateDirectory(m_strProjectDir + "\\kit", 0);          
	CopyFile(m_strProjectDir + "\\foo" + szTARGET_EXT, stNewTarget, FALSE);
	EXPECT(proj.SetLocalTarget(stNewTarget) == ERROR_SUCCESS );
	EXPECT_TRUE(dbg.Go(NULL,NULL,NULL,0) );

	if( WaitMsgBoxText("or do not exist", 10))
	{
		WriteLog( PASSED, "01 : The MsgBox \"One or more targets are out of date...\" was found as expected" );
		MST.WButtonClick( "No" );
		while(MST.WFndWndC("or do not exist", "Static", FW_PART));
	}

	// REVIEW (michma): why does UIWB.WaitForRun() never return?
	//UIWB.WaitForRun();
	// Sleep(10000);
	CString TitleRun = (CString)"[" + GetLocString(IDSS_DBG_RUN) + "]";
	MST.WFndWndWait(TitleRun, FW_PART, 10);
	
	UIWB.WaitForTermination();

/*	EXPECT_TRUE( VerifyProjectRan() );
*/
	// Remove temporary file and dir
	DeleteFile(stNewTarget);
	RemoveDirectory(m_strProjectDir + "\\kit");         

	// Set correct AbsPath\target 
	EXPECT( proj.SetLocalTarget(stAbsPathTarget) == ERROR_SUCCESS );

	// Exe is still out of place
	EXPECT_TRUE(dbg.Go(NULL,NULL,NULL,0) );
	if( WaitMsgBoxText("does not exist", 10) )
	{
		WriteLog( PASSED, "The MsgBox \"... does not exist...\" was found as expected" );
		MST.WButtonClick( "OK" ); // MST.WButtonClick( "No" );
	}
	else
	{
		if( WaitMsgBoxText("not found", 10) )
		{
			WriteLog( PASSED, "The MsgBox \"...File not found\" was found as expected" );
			MST.WButtonClick( "OK" );
		}
		else
		{
			WriteLog( FAILED, "The MsgBox \"...File not found\" was not found" );
			WriteLog( FAILED, "The MsgBox \"... does not exist...\" was not found" );
			EXPECT_TRUE( FALSE );	 	
		}
	}

	// Exe is back in place
	CopyFile(m_strProjectDir + "\\foo" + szTARGET_EXT, stAbsPathTarget, FALSE);
	DeleteFile(m_strProjectDir + "\\foo" + szTARGET_EXT);
	Sleep(1000);
	EXPECT_TRUE( dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION) );

	// Restore initial target
	EXPECT_TRUE( proj.SetLocalTarget(stOldTarget) == ERROR_SUCCESS );

	// Verify restoration is OK
	EXPECT_TRUE( dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION) );

	return (TRUE);
}

BOOL Cexe2IDETest::CheckGeneralNetworkFailure( )
{
	if( WaitMsgBoxText("General Network Failure", 10) )
	{
		MST.DoKeys( KEY_Enter );
		return (FALSE);      
	}
	else
	{
		return (TRUE);      
	}
}


BOOL Cexe2IDETest::ExitWhileDebugging( )
{
 	LogTestHeader( "ExitWhileDebugging" );

	m_pLog->RecordInfo( "Restart, Exit IDE and verify: ExitWhileDebugging" );
	dbg.Restart();
	dbg.SetSteppingMode(SRC);  //Temporary workaround: bug #15556
	CString strLine = "{";

	if( UIWB.GetPcodeSwitch() )
		strLine = "int iGo = TestG();";

    EXPECT_TRUE( dbg.CurrentLineIs( strLine ) );
	UIWB.DoCommand(ID_APP_EXIT, DC_MNEMONIC);
	
	if( WaitMsgBoxText("command will stop the debugger", 10) )
	{
		WriteLog( PASSED, "01 : The MsgBox \"command will stop the debugger\" was found as expected" );
		MST.WButtonClick( "Cancel" );
	}
	else
	{
		WriteLog( FAILED, "01 : The MsgBox \"command will stop the debugger\" was not found as expected" );
		EXPECT_TRUE( FALSE );	 	
	}
 
	UIWB.DoCommand(ID_APP_EXIT, DC_MNEMONIC);

	if( WaitMsgBoxText("command will stop the debugger", 10) )
	{
		WriteLog( PASSED, "02 : The MsgBox \"command will stop the debugger\" was found as expected" );
		MST.WButtonClick( "OK" );
	}
	else
	{
		WriteLog( FAILED, "02 : The MsgBox \"command will stop the debugger\" was not found as expected" );
		EXPECT_TRUE( FALSE );	 	
	}

	if( WaitMsgBoxText("want to save", 10) )
	{
		MST.WButtonClick( "No" );
	}

	while(GetSubSuite()->GetIDE()->IsLaunched());

	// REVIEW(briancr): use RTTI for this cast, or at least to validate it
	GetSubSuite()->GetIDE()->Launch();
	WriteLog( PASSED, "03 : The IDE was closed and reopened as expected" );
	return (TRUE);
}


BOOL Cexe2IDETest::CannotFindDll( )
{
 	LogTestHeader( "CannotFindDll" );
	m_pLog->RecordInfo( "Try to start debugging exe which cannot find associated Dll, correct the path and debug" );

	// Verify we can start debugging
	dbg.Restart();
	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "WinMain") );
	dbg.StopDebugging();

	// Rename dec2.dll to dec22.dll and start debugging
	CopyFile(m_strProjectDir + "\\dec2.dll", m_strProjectDir + "\\dec22.dll", FALSE);
	DeleteFile(m_strProjectDir + "\\dec2.dll");
	EXPECT_TRUE(dbg.StepInto(1,NULL,NULL,NULL,0) );

	if( WaitMsgBoxText("not found", 10) )
	{
		WriteLog( PASSED, "01 : The MsgBox \"...not found...\" was found" );
		MST.WButtonClick( "OK" ); 
	}
	else
	{
		if( WaitMsgBoxText("Could not execute", 10) )
		{
			WriteLog( PASSED, "01 : The MsgBox \"Could not execute...\" was found as expected" );
			MST.DoKeys( KEY_Enter );
			if( WaitMsgBoxText("Cannot execute", 10) )
			{
				WriteLog( PASSED, "01 : The MsgBox \"Cannot execute...\" was found as expected" );
				MST.DoKeys( KEY_Enter );
			}
		}
		else
		{
			WriteLog( FAILED, "The MsgBox \"...not found\" was not found" );
			WriteLog( FAILED, "The MsgBox \"Could not execute...\" was not found" );
			EXPECT_TRUE( FALSE );	 	
		}
	}
	
	if( WaitMsgBoxText("not found", 10) )
	{
		WriteLog( PASSED, "01 : The MsgBox \"...not found...\" was found" );
		MST.WButtonClick( "OK" ); 
	}
	else
	{
		if( WaitMsgBoxText("Could not execute", 10) )
		{
			WriteLog( PASSED, "01 : The MsgBox \"Could not execute...\" was found as expected" );
			MST.DoKeys( KEY_Enter );
			if( WaitMsgBoxText("Cannot execute", 10) )
			{
				WriteLog( PASSED, "01 : The MsgBox \"Cannot execute...\" was found as expected" );
				MST.DoKeys( KEY_Enter );
			}
		}
		else
		{
			WriteLog( FAILED, "The MsgBox \"...not found\" was not found" );
			WriteLog( FAILED, "The MsgBox \"Could not execute...\" was not found" );
			EXPECT_TRUE( FALSE );	 	
		}
	}
	
/*	
	if( WaitMsgBoxText("Could not execute", 10) )
	{
		WriteLog( PASSED, "01 : The MsgBox \"Could not execute...\" was found as expected" );
		MST.DoKeys( KEY_Enter );
	}
	else
	{
		WriteLog( FAILED, "01 : The MsgBox \"Could not execute...\" was not found" );
		EXPECT_TRUE( FALSE );	 	
	}
*/	
	// Restore initial Dll
	CopyFile(m_strProjectDir + "\\dec22.dll", m_strProjectDir + "\\dec2.dll", FALSE);
	DeleteFile(m_strProjectDir + "\\dec22.dll");
	EXPECT_TRUE( dbg.StepInto(1, NULL, "{", "WinMain") );
	dbg.StopDebugging();

	return (TRUE);
}

BOOL Cexe2IDETest::StdInOutRedirection()
{
 	LogTestHeader( "StdInOutRedirection" );
	m_pLog->RecordInfo( "Redirect Std Input and Output to files and debug console app" );

	// Redirect std input from file cons01.inp and check values
	CString progargs = "< cons01.inp";
	EXPECT_TRUE( proj.SetProgramArguments(progargs) == ERROR_SUCCESS );

	UIWB.OpenFile( m_strProjectDir + "\\" + "cons01.cpp");
	EXPECT_TRUE( src.Find("cin >> Char;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "cin >> Char;") );
	dbg.StepOver(1, NULL, NULL, NULL, 0);
	EXPECT_TRUE( cxx.ExpressionValueIs("Char=='a'",1) );

	dbg.StepOver(1, NULL, NULL, NULL, 0);
	EXPECT_TRUE( cxx.ExpressionValueIs("Array1d[1]",888) );

	EXPECT_TRUE( src.Find("cin >> String;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "cin >> String;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("Array2d[0][2]",7) );

	dbg.StepOver(1, NULL, NULL, NULL, 0);
	CString stringValue = "ADDRESS \"!ZYXWVUTSRQPONMLKJIHGFEDCBA\"";
	EXPECT_TRUE( cxx.ExpressionValueIs("String",stringValue) );

	dbg.StopDebugging();

	// Redirect std output into file cons01.out
	progargs = "> cons01.out";
	EXPECT_TRUE( proj.SetProgramArguments(progargs) == ERROR_SUCCESS );

	DeleteFile(m_strProjectDir + "\\cons01.out");
	UIWB.OpenFile( m_strProjectDir + "\\" + "cons01.cpp");
	EXPECT_TRUE( src.Find("cout << Char;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "cout << Char;") );
	EXPECT_TRUE( dbg.StepOver(1, NULL, "cout << Array1d[0] << Array1d[1] << Array1d[2] ;") );
	EXPECT_TRUE( src.Find("cin >> Char;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "cin >> Char;") );

	dbg.StopDebugging();

	// Redirect both std input (cons01.inp) and output (cons01.out)
	// and check values and output
	DeleteFile(m_strProjectDir + "\\cons01.out");
	progargs = "< cons01.inp > cons01.out";
	EXPECT_TRUE( proj.SetProgramArguments(progargs) == ERROR_SUCCESS );

	UIWB.OpenFile( m_strProjectDir + "\\" + "cons01.cpp");
	EXPECT_TRUE( src.Find("cin >> Char;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "cin >> Char;") );
	dbg.StepOver(1, NULL, NULL, NULL, 0);
	EXPECT_TRUE( cxx.ExpressionValueIs("Char=='a'",1) );

	dbg.StepOver(1, NULL, NULL, NULL, 0);
	EXPECT_TRUE( cxx.ExpressionValueIs("Array1d[1]",888) );

	EXPECT_TRUE( src.Find("cin >> String;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "cin >> String;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("Array2d[0][2]",7) );

	dbg.StepOver(1, NULL, NULL, NULL, 0);
	EXPECT_TRUE( cxx.ExpressionValueIs("String",stringValue) );

	EXPECT_TRUE( dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION) );
	UIWB.OpenFile( m_strProjectDir + "\\" + "cons01.out");
	EXPECT_TRUE( src.Find("s111222333112233445566778899this is a string") );

	return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\exe\stepcase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STEPCASE.CPP
//
//	Created by :			Date :
//		YefimS			01/06/94
//
//	Description :
//		Implementation of the CST1TestCases class
//

#include <process.h>
#include "stdafx.h"
#include "execase.h"
#include "execase2.h"

///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////

BOOL CexeIDETest::StepOutSource(   )
{
 	LogTestHeader( "StepOutSource" );

	COSource		src;	// WinslowF - added to call GoToLine. It's not in UIWB any more.

	bps.ClearAllBreakpoints();
    dbg.Restart();
	if( UIWB.GetPcodeSwitch() )
	{
		EXPECT_TRUE( dbg.CurrentLineIs( "int iBP = TestBP();" ) );
	}
	else
		EXPECT_TRUE( dbg.CurrentLineIs( "{" ) );

	CString strSource = "bp__ulul.c";

	// Open source
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);

	EXPECT_TRUE( src.Find("ul = (ulong)counter;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "ul = (ulong)counter;") );

	EXPECT_TRUE( dbg.StepOut(1, NULL, "ul = CFncULUL(ul);", "TestBP()") );

	return (TRUE);
}


BOOL CexeIDETest::StepOverSource(   )
{
 	LogTestHeader( "StepOverSource" );

    EXPECT_TRUE( dbg.Go(NULL,NULL,NULL,WAIT_FOR_TERMINATION) );

	CString strSource = "testbp.c";
	bps.ClearAllBreakpoints();

	// Open source
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);

	EXPECT_TRUE( src.Find("ul = CFncULUL(ul);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "ul = CFncULUL(ul);") );

	EXPECT_TRUE( dbg.StepOver(1, NULL, "f = CFncFF(f);") );

	return (TRUE);
}


BOOL CexeIDETest::StepIntoSource(   )
{
 	LogTestHeader( "StepIntoSource" );

	bps.ClearAllBreakpoints();
    dbg.Restart();

	if( !UIWB.GetPcodeSwitch() )
	{
	    EXPECT_TRUE( dbg.CurrentLineIs( "{" ) );
		EXPECT_TRUE( dbg.StepInto() );
	}

    EXPECT_TRUE( dbg.CurrentLineIs( "int iBP = TestBP();" ) );

	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "TestBP()") );

	MST.DoKeys("{up}");
    EXPECT_TRUE( dbg.CurrentLineIs( "int TestBP()" ) );

	EXPECT_TRUE( src.Find("s = CFncSSRecurse(10);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "s = CFncSSRecurse(10);") );

	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "CFncSSRecurse") );

	MST.DoKeys("{up}");
    EXPECT_TRUE( dbg.CurrentLineIs( "CFncSSRecurse(short NTimes)" ) );

	EXPECT_TRUE( src.Find("NTimes = (short)CFncSSRecurse((short)(NTimes-1));") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "NTimes = (short)CFncSSRecurse((short)(NTimes-1));") );

	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "CFncSSRecurse") );
	EXPECT_TRUE( stk.FunctionIs("CFncSSRecurse",1) );

	MST.DoKeys("{up}");
    EXPECT_TRUE( dbg.CurrentLineIs( "CFncSSRecurse(short NTimes)" ) );

	dbg.StopDebugging();

	return (TRUE);
}

BOOL CexeIDETest::StepToCursorSource(   )
{
 	LogTestHeader( "StepToCursorSource" );

	CString strSource = "bp__ldld.c";
	bps.ClearAllBreakpoints();

	// Open source
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);

	EXPECT_TRUE( src.Find("ul = (ulong)counter;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "ul = (ulong)counter;") );

	EXPECT_TRUE( src.Find("d  = (double)counter;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "d  = (double)counter;") );
	dbg.StopDebugging();
	return (TRUE);
}

BOOL CexeIDETest::StepOverFuncToBreakAtLocBP()
{
 	LogTestHeader( "StepOverFuncToBreakAtLocBP" );
	bps.ClearAllBreakpoints();

	UIWB.OpenFile( m_strProjectDir + "\\" + "testgo.c");

	EXPECT_TRUE( src.Find("Int=foo(Local);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "Int=foo(Local);") );
	EXPECT_TRUE( src.Find("return Parameter;") );
	EXPECT_TRUE( bps.SetBreakpoint() != NULL );
	EXPECT_TRUE( dbg.StepOver(1, NULL, "return Parameter;") );

	EXPECT_TRUE( src.Find("nest_func();") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "nest_func();") );
	EXPECT_TRUE( bps.SetBreakpoint("func") != NULL );
//	EXPECT_TRUE( dbg.StepOver(1, NULL, "int func() {") );
	EXPECT_TRUE( dbg.StepOver(1, NULL, NULL, "func") );

	dbg.StopDebugging();
	return (TRUE);
}

BOOL CexeIDETest::StepOverFuncToBreakOnExprTrueBP()
{
 	LogTestHeader( "StepOverFuncToBreakOnExprTrueBP" );
	bps.ClearAllBreakpoints();

	UIWB.OpenFile( m_strProjectDir + "\\" + "testgo.c");

	EXPECT_TRUE( src.Find("Int = foo_Include(Int);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "Int = foo_Include(Int);") );
	EXPECT_TRUE( bps.SetBreakOnExpr("{foo_Include}number==34", COBP_TYPE_IF_EXP_TRUE) != NULL );
	dbg.StepOver(1, NULL, NULL, NULL, 0);
	if( WaitMsgBoxText("Break when '{foo_Include}number==34'", 280) )
	{
		WriteLog( PASSED, "The MsgBox \"Break when '{foo_Include}number==34'\" was found as expected" );
		MST.WButtonClick( "OK" ); 
		EXPECT_TRUE_COMMENT( TRUE, "BreakOnExprTrue" );	 	
	}
	else
	{
		WriteLog( FAILED, "The MsgBox \"Break when '{foo_Include}number==34'\" was not found" );
		EXPECT_TRUE( FALSE );	 	
	}
	EXPECT_TRUE( dbg.CurrentLineIs( "if(number == 3)" ) );
	EXPECT_TRUE( cxx.ExpressionValueIs("number == 34",1) );

	UIWB.OpenFile( m_strProjectDir + "\\" + "testgo.c");
	EXPECT_TRUE( src.Find("Int=recur_func();") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "Int=recur_func();") );
	EXPECT_TRUE( bps.SetBreakOnExpr("{recur_func}x==2", COBP_TYPE_IF_EXP_TRUE) != NULL );
	dbg.StepOver(1, NULL, NULL, NULL, 0);
	if( WaitMsgBoxText("Break when '{recur_func}x==2'", 280) )
	{
		WriteLog( PASSED, "The MsgBox \"Break when '{recur_func}x==2'\" was found as expected" );
		MST.WButtonClick( "OK" ); 
		EXPECT_TRUE_COMMENT( TRUE, "BreakOnExprTrue" );	 	
	}
	else
	{
		WriteLog( FAILED, "The MsgBox \"Break when '{recur_func}x==2'\" was not found" );
		EXPECT_TRUE( FALSE );	 	
	}
	EXPECT_TRUE( dbg.CurrentLineIs( "if (x<9) recur_func();" ) );
	EXPECT_TRUE( cxx.ExpressionValueIs("x==2",1) );

	dbg.StopDebugging();
	return (TRUE);
}

BOOL CexeIDETest::StepOverFuncToBreakOnExprChangesBP()
{
 	LogTestHeader( "StepOverFuncToBreakOnExprChangesBP" );
	bps.ClearAllBreakpoints();

	UIWB.OpenFile( m_strProjectDir + "\\" + "testgo.c");
	EXPECT_TRUE( src.Find("Int=recur_func();") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "Int=recur_func();") );
	EXPECT_TRUE( bps.SetBreakOnExpr("{recur_func}x", COBP_TYPE_IF_EXP_CHANGED) != NULL );
	dbg.StepOver(1, NULL, NULL, NULL, 0);
	if( WaitMsgBoxText("Break when '{recur_func}x'", 280) )
	{
		WriteLog( PASSED, "The MsgBox \"Break when '{recur_func}x'\" was found as expected" );
		MST.WButtonClick( "OK" ); 
		EXPECT_TRUE_COMMENT( TRUE, "BreakOnExprChanged" );	 	
	}
	else
	{
		WriteLog( FAILED, "The MsgBox \"Break when '{recur_func}x'\" was not found" );
		EXPECT_TRUE( FALSE );	 	
	}
	EXPECT_TRUE( dbg.CurrentLineIs( "if (x<9) recur_func();" ) );
	EXPECT_TRUE( cxx.ExpressionValueIs("x==2",1) );

	dbg.StopDebugging();
	return (TRUE);
}

BOOL CexeIDETest::TraceIntoWndProc()
{
 	LogTestHeader( "TraceIntoWndProc" );
	bps.ClearAllBreakpoints();

	UIWB.OpenFile( m_strProjectDir + "\\" + "main2.c");
	EXPECT_TRUE( src.Find("SendMessage(") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "SendMessage(") );
//	EXPECT_TRUE( dbg.StepInto(1, NULL, "{", "WndProc") );
	EXPECT_TRUE( dbg.StepInto(1, NULL, "{") );
	EXPECT_TRUE( stk.CurrentFunctionIs("WndProc")	);
	EXPECT_TRUE( dbg.StepInto(1, NULL, "SAVELABEL(TagCallOtherMain);", "WndProc") );

	dbg.StopDebugging();
	return (TRUE);
}

BOOL Cexe2IDETest::NoSystemCodeStepping()
{
 	LogTestHeader( "NoSystemCodeStepping" );
	bps.ClearAllBreakpoints();
	BOOL ret = TRUE;

	UIWB.OpenFile( m_strProjectDir + "\\" + "main2.c");
	EXPECT_TRUE( src.Find("SAVELABEL(TagCreateCase);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "SAVELABEL(TagCreateCase);", "WndProc") );
	EXPECT_TRUE( dbg.StepOut(1, NULL, NULL, NULL, 0) );

//	if( WaitMsgBoxText("Cannot step through system code", 280) )
	if( WaitMsgBoxText("Can't trace into system DLLs", 280) )
	{
		WriteLog( PASSED, "The MsgBox \"Can't trace into system DLLs\" was found as expected" );
		MST.WButtonClick( "OK" ); 
	}
	else
	{
		WriteLog( FAILED, "The MsgBox \"Can't trace into system DLLs\" was not found" );
		ret = FALSE;	 	
	}
	dbg.StopDebugging();
	return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\mem\mem1.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	ME1CASES.CPP
//
//	Created by :			Date :
//		YefimS			11/21/93
//
//	Description :
//		Implementation of the CmemIDETest class
//

#include <process.h>
#include "stdafx.h"
#include "memcase.h"

///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////

BOOL CmemIDETest::GoAfterScrollMemoryWnd( )
{
//	DESC( "Restart, Scroll MemoryWnd and Go", "GoAfterScrollMemoryWnd" );

	BOOL retval = TRUE;
	COSource		src;	// WinslowF - added to call GoToLine. It's not in UIWB any more.

	CODebug codebug;
	EXPECT( codebug.Restart() );

	int i;
	UIMemory umw = UIDebug::ShowDockWindow( IDW_MEMORY_WIN, TRUE );
	EXPECT( umw.IsActive() );

	EXPECT ( umw.GoToAddress("0x16") == ERROR_SUCCESS);

	EXPECT ( umw.GoToAddress("0x7f0000") == ERROR_SUCCESS);
	
	for ( i = 0; i < 200; i++)
	{
		MST.DoKeys ("+{pgdn}");
	}

   if ( !UIWB.VerifySubstringAtLine( "  ?? ??" ) )
	{
		// REVIEW(michma - 3/16/98): VerifySubstringAtLine causes focus to go to source window due to new DoKeyshWnd call.
	    umw = UIDebug::ShowDockWindow( IDW_MEMORY_WIN, TRUE );
		EXPECT ( umw.GoToAddress("0x2000000") == ERROR_SUCCESS);
	}
		
   if ( !UIWB.VerifySubstringAtLine( "  ?? ??" ) )
	{
		// REVIEW(michma - 3/16/98): VerifySubstringAtLine causes focus to go to source window due to new DoKeyshWnd call.
	    umw = UIDebug::ShowDockWindow( IDW_MEMORY_WIN, TRUE );
		EXPECT ( umw.GoToAddress("0xffffffff") == ERROR_SUCCESS);
	}
		
   if ( !UIWB.VerifySubstringAtLine( "  ?? ??" ) )
	{
   	m_pLog->RecordInfo("0x02000000 : The app is too big: test case should be revised" );
		retval = FALSE;
	}

   EXPECT( codebug.Go(NULL,NULL,NULL,WAIT_FOR_TERMINATION) );

   WriteLog(PASSED, "Scrolling Memory Window didn't corrupt Debugging" );

//codebug.StopDebugging();
	return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\mem\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\exe\step3.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STEP3.CPP
//
//	Created by :			Date :
//		YefimS			01/06/94
//
//	Description :
//		Implementation of the CST1TestCases class
//

#include <process.h>
#include "stdafx.h"
#include "execase2.h"

///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////


BOOL Cexe2IDETest::StepToCursorMixed(   )
{
 	LogTestHeader( "StepToCursorMixed" );

	CString strSource = "bp__ldld.c";

	// Open source
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);

	EXPECT_TRUE( src.Find("c10[counter]  = (char)counter;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "c10[counter]  = (char)counter;") );
	dbg.SetSteppingMode(ASM);
	CString strLine = "c10[counter]  = (char)counter;";
	MST.DoKeys("{up}");

	EXPECT_TRUE_COMMENT( dbg.CurrentLineIs( strLine ), "DAM: expected line 'c10[counter]  = (char)counter;' " );

	MST.DoKeys("{down 3}");
	dbg.StepToCursor();
	if( UIWB.GetPcodeSwitch() )
		strLine = "LdfL8";
	else
		strLine = "move.b";

    EXPECT_TRUE( dbg.CurrentLineIs( strLine ) );

	return (TRUE);
}


BOOL Cexe2IDETest::StepOutMixed(   )
{
 	LogTestHeader( "StepOutMixed" );

	CString strSource = "bp__ldld.c";

	// Open source
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);

	EXPECT_TRUE( src.Find("c10[counter]  = (char)counter;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "c10[counter]  = (char)counter;") );

	dbg.SetSteppingMode(ASM);
	CString strLine = "c10[counter]  = (char)counter;";
	MST.DoKeys("{up}");
    EXPECT_TRUE( dbg.CurrentLineIs( strLine ) );

	MST.DoKeys("{down 3}");
	dbg.StepToCursor();

	if( UIWB.GetPcodeSwitch() )
		strLine = "LdfL8";
	else
		strLine = "move.b";

    EXPECT_TRUE( dbg.CurrentLineIs( strLine ) );

	dbg.StepOut();
  	EXPECT_TRUE( stk.CurrentFunctionIs( "TestBP()" ) );

	if( UIWB.GetPcodeSwitch() )
		strLine = "Call";
	else
		strLine = "jsr"; 
	MST.DoKeys("{up}");

    EXPECT_TRUE( dbg.CurrentLineIs( strLine ) );

	strLine = "ld = CFncLDLD(ld);"; 
	MST.DoKeys("{up}");
	MST.DoKeys("{up}");
	if( !UIWB.GetPcodeSwitch() )
	{
		MST.DoKeys("{up}");
		MST.DoKeys("{up}");
		MST.DoKeys("{up}");
	}

    EXPECT_TRUE( dbg.CurrentLineIs( strLine ) );
	return (TRUE);
}



BOOL Cexe2IDETest::StepOverMixed(   )
{
 	LogTestHeader( "StepOverMixed" );

	CString strSource = "testbp.c";
	CString strLine;

	// Open source
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);

	dbg.StepOver();
	dbg.SetSteppingMode(ASM);

	if( UIWB.GetPcodeSwitch() )
		strLine = "Call";
	else
		strLine = "jsr"; 

	EXPECT_TRUE( dbg.StepOver(1, NULL, strLine) );

	dbg.StepOver();
	MST.DoKeys("{up}");
    EXPECT_TRUE( dbg.CurrentLineIs( strLine ) );
	return (TRUE);
}



BOOL Cexe2IDETest::StepIntoMixed(   )
{
 	LogTestHeader( "StepIntoMixed" );
	COSource		src;	// WinslowF - added to call GoToLine. It's not in UIWB any more.

	CString strSource = "testbp.c";

    dbg.Restart();
	dbg.SetSteppingMode(SRC);
	CString strLine = "{";
	if( UIWB.GetPcodeSwitch() )
		strLine = "int iBP = TestBP();";
    EXPECT_TRUE( dbg.CurrentLineIs( strLine ) );

	// Open source
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);
	EXPECT_TRUE( src.Find("f = CFncFF(f);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "f = CFncFF(f);") );
	dbg.SetSteppingMode(ASM);

	if( UIWB.GetPcodeSwitch() )
		strLine = "Call";
	else
		strLine = "jsr"; 

	EXPECT_TRUE( dbg.StepInto(1, NULL, strLine, "TestBP()") );

	dbg.StepInto(3);
  	EXPECT_TRUE( stk.CurrentFunctionIs( "CFncSSRecurse" ) );

	MST.DoKeys("{up}");
	if( UIWB.GetPcodeSwitch() )
		strLine = "Cuc = (uchar)NTimes;";
	else
		strLine = "{"; 

    EXPECT_TRUE( dbg.CurrentLineIs( strLine ) );

	if( UIWB.GetPcodeSwitch() )
		MST.DoKeys("{up 5}");
	
	strLine = "CFncSSRecurse(short NTimes)"; 
	MST.DoKeys("{up}");
    EXPECT_TRUE( dbg.CurrentLineIs( strLine ) );

	EXPECT(dbg.StopDebugging());
	return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\exe\step2.cpp ===
/*
** STEP.CPP
**
**	Created by :			Date :
**		waltcr				8/14/94
**
**	Description :
**		Step/trace/go tests
*/


#include "stdafx.h"
#include "execase.h"
#include "execase2.h"

#if defined(_MIPS_) || defined(_ALPHA_)
#define _CHAIN_2 "chain_2"
#define _CHAIN_3 "chain_3"
#else
#define _CHAIN_2 "_chain_2"
#define _CHAIN_3 "_chain_3"
#endif

///////////////////////////////////////////////////////////////////////////////
//	Test Cases

/*
** A number of tests lumped together.  Some involve different level of debug
** information or without debug information.  Also a test or two
** involving step/stepout and breakpoints which are important enough
** to have in the stepping model tests.
** 
*/

BOOL CexeIDETest::BreakStepTrace(   )
{ 	
 	LogTestHeader( "BreakStepTrace" );

 	/*
	** test Step_Out of func which fires a bp in a nested func in secondary module.
	** test to Step_Out of func with debug info into func w/out debug info	
	** also test to Step_Out of func w/out debug info into func w/ partial info
	** also test to Step_Out of func w/partial debug info into func w/full info
	** also test to Step_Out of func with debug info into func w/debug info
	**
	** ChainMain is expected to be compiled with full debug information
	** chain_1 is expected to be compiled with full debug information
	** chain_2 is expected to be compiled with partial debug information
	** chain_3 is expected to be compiled without debug information
	** chain_4 is expected to be compiled with full debug information
	*/

	bp *bp;
	BOOL fSuccess;
	
	bps.ClearAllBreakpoints();
	dbg.StopDebugging();
	bp=bps.SetBreakpoint("WndProc");
	dbg.Go();  								// execute to function WndProc 
	EXPECT_TRUE ( dbg.VerifyAtSymbol("WndProc") );
	dbg.SetSteppingMode(SRC);
	// Step past prolog
	dbg.StepOver(); 						
	bps.ClearAllBreakpoints();
	// set breakpoint on label
	bp = bps.SetBreakpoint("TagCallChainMain"); 	
	// execute to bp at label
	dbg.Go();  								
	EXPECT_TRUE ( dbg.AtSymbol("{WndProc}TagCallChainMain") );
	EXPECT_TRUE ( dbg.StepInto(1,"ChainMain") );

	/* 
	** test tracing out of static function.
	** test Step_Out of func which fires a bp in a nested func in 
	** secondary module.
	*/

	EXPECT_TRUE ( bps.SetBreakpoint("chain_4") != NULL );
	EXPECT_TRUE ( bps.SetBreakpoint("chain_5") != NULL );
	dbg.Go();
	EXPECT_TRUE ( dbg.AtSymbol("chain_4") );

	// attempt to step out but fire on breakpoint in nested function call
	// proper location is chain_5
	fSuccess = dbg.StepOut(1, NULL, NULL, "chain_5"); 
	WriteLog( fSuccess ? PASSED : FAILED, "StepOut and fire on breakpoint in nested function");
	if (!fSuccess)
		return fSuccess;			
	
	dbg.StepInto();
	EXPECT_TRUE ( fSuccess &= dbg.StepOut(1, NULL, NULL, "chain_4") );

	// window already open, but it would be interesting to close and confirm 
	// dam is opened and gets focus, but that would be using whitebox testing 
	// which is considered voodoo.
	// should go back to chain_3, but wait till after next test to verify
	EXPECT_TRUE ( fSuccess &= dbg.StepOut(1, NULL, NULL, "chain_3") );

	// Proper location is w/in func chain_2
	fSuccess = dbg.StepOut(1, NULL, NULL, "chain_2");  
	WriteLog( fSuccess ? PASSED : FAILED, "StepOut from full to none and then none to partial cvinfo");
	if (!fSuccess)
		return fSuccess;	
	// proper location is w/in func chain_1
	fSuccess = dbg.StepOut(1, NULL, NULL, "chain_1");  
	WriteLog( fSuccess ? PASSED : FAILED, "StepOut from partial cvinfo to full cvinfo");
	if (!fSuccess)
		return fSuccess;	
	// proper location is chainmain
	fSuccess = dbg.StepOut(1, NULL, NULL, "ChainMain"); 
	WriteLog( fSuccess ? PASSED : FAILED, "StepOut from full cvinfo to full cvinfo");
	if (!fSuccess)
		return fSuccess;	
	
	// attempt to step over function but which generates an exception.
	
	bps.SetBreakpoint("{OtherMain}TagStepEH");
	dbg.Go();
	dbg.StepOver();
#if defined( _MIPS_ ) || defined(_ALPHA_)
	EXPECT_TRUE(stk.CurrentFunctionIs("NTDLL!"));
#else
	EXPECT_TRUE(stk.CurrentFunctionIs("KERNEL32!"));
#endif
	dbg.StepOut();
	dbg.StepOut();
	//TODO: where should we be?

	return TRUE;	
}									


/*
** A number of tests lumped together.  Some involve step/trace/stepout
** with different level of debug information or without debug 
** information.  
** 
*/

BOOL CexeIDETest::StepModel(   )
{
 	LogTestHeader( "StepModel" );

	int count;
	BOOL fOkay;

	/*
	** test Step_Out of func with debug info into func w/out debug info	
	** also test to Step_Out of func w/out debug info into func w/ partial info
	** also test to Step_Out of func w/partial debug info into func w/full info
	** also test to Step_Out of func with debug info into func w/debug info
	**
	** ChainMain is expected to be compiled with full debug information
	** chain_1 is expected to be compiled with full debug information
	** chain_2 is expected to be compiled with partial debug information
	** chain_3 is expected to be compiled without debug information
	** chain_4 is expected to be compiled with full debug information
	*/

	dbg.Restart();

	/* 
	** test tracing into function with partial debug information.
	*/
 
	bps.SetBreakpoint("{chain_1}START");
	dbg.Go();
	dbg.AtSymbol("START");
	fOkay = dbg.StepInto(1,NULL, NULL, "chain_2");
	WriteLog( fOkay ? PASSED : FAILED, "Trace from full cvinfo into module w/only partial cvinfo");
	if (!fOkay)
		return fOkay;	
 
	/* 
	** test tracing out of function w/out cvinfo into func w/ partial.
	** ; test instruction level tracing
	*/

	EXPECT_TRUE ( bps.SetBreakpoint(_CHAIN_3) != NULL );
	EXPECT_TRUE ( dbg.Go(NULL, NULL, "chain_3") );
	EXPECT_TRUE ( dbg.StepInto(2, NULL, NULL, "chain_3") );
	EXPECT_TRUE ( bps.DisableAllBreakpoints() );

	count=0;
	while ( (count<25) && (stk.GetFunction().Find("chain_3") != -1))
	{
		count++;
		dbg.StepOver();   // step over chain_4 ...
	} 
	fOkay = stk.CurrentFunctionIs("chain_2");
	WriteLog( fOkay ? PASSED : FAILED, "instruction level tracing from no cvinfo to partial cvinfo");
	if (!fOkay)
		return fOkay;	

	dbg.SetSteppingMode(SRC);

 	/* 
	** test tracing into function w/out cvinfo
	*/

	bps.ClearAllBreakpoints();
	EXPECT_TRUE ( bps.SetBreakpoint("{WndProc}TagCallNoCVInfo") != NULL );

	dbg.Go();   // will hit the throw
	dbg.Go(); 	// go again to get to the breakpoint
	dbg.AtSymbol("TagCallNoCVInfo");
	dbg.SetSteppingMode(SRC);

	// attempt to trace into func, but func doesn't have cvinfo so 
	// trace should actually stepover
	fOkay = dbg.StepInto(1, NULL, NULL, "WndProc");
	WriteLog(fOkay ? PASSED : FAILED, "Source level trace of func call w/out cvinfo");
	if (!fOkay)
		return FALSE;	
	// CAFE REVIEW: the stepinto and check of wndproc is not returning 
	// focus to src window.  should it?  For now next line sets it back.
	dbg.SetSteppingMode(SRC);
	src.Find("TagCallNoCVInfo:", TRUE);
	if (dbg.SetNextStatement(NULL) == FALSE)
	{
		m_pLog->RecordFailure("Unable to Set_Next_Statement");
		return FALSE;	
	}
	if (dbg.SetSteppingMode(ASM) == FALSE)
	{
		m_pLog->RecordFailure("Unable to set stepping mode to ASM");
		return FALSE;	// ( FALSE, GetTestDesc() );
	}

	// don't know exactly how many instructions so allow a few traces 
	count=0;
	do 
	{
		count++;
		dbg.StepInto();
	} while( (count<17) && (!dbg.AtSymbol(_CHAIN_3)) );
	EXPECT_TRUE ( dbg.AtSymbol(_CHAIN_3) );
	// now only have dissassembly.  keep tracing until get back to mixed.
	do 
	{
		dbg.StepInto();
	} while (!dbg.AtSymbol("chain_4"));
	fOkay = dbg.AtSymbol("chain_4");
	WriteLog(fOkay ? PASSED : FAILED, "Instruction level trace from no cvinfo to full cvinfo");
	
	dbg.SetSteppingMode(SRC);
	bps.ClearAllBreakpoints();
	return TRUE;	
}


/*
** Stepping model test(s) involving DLL's.
** Step Loadlibrary and then trace into the virtual explicit dll.
**
*/ 

BOOL Cexe2IDETest::DllStepTrace(   )
{
 	LogTestHeader( "DllStepTrace" );

	BOOL fSuccess;
	int count;

	/* 
	** test step/trace of LoadLibrary
	** (for portability reasons this needs to be isolated)
	*/
	dbg.Restart();
	bps.ClearAllBreakpoints();
	EXPECT_TRUE ( fSuccess = (bps.SetBreakpoint("{Dec,,dec2.dll}TagLoadLib") != NULL) );
	EXPECT_TRUE ( fSuccess &= dbg.Go("{Dec,,dec2.dll}TagLoadLib") );
	dbg.StepInto();  // step load library call which does a symbol load
	// REVIEW:  is there anything interesting to verify?
	EXPECT_TRUE( fSuccess &= (dbg.VerifyNotification("Loaded symbols", 3, 20, TRUE) && dbg.VerifyNotification("powdll.dll", 3, 20, TRUE)) );

	/* 
	** test tracing into function contained in a virtual dll. (for 
	** portability reasons this needs to be isolated)
	*/
	count=0;
	while ( (count<10) && (!dbg.AtSymbol("{Dec,,dec2.dll}TagCallPow")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE(fSuccess &= (dbg.AtSymbol("TagCallPow") && stk.CurrentFunctionIs("Dec")) );
	EXPECT_TRUE(fSuccess &= dbg.StepInto(1, NULL, NULL, "dPow"));

	dbg.StopDebugging();
	EXPECT_TRUE ( fSuccess &= dbg.Go("{Dec,,dec2.dll}TagLoadLib") );
	dbg.StepOver();  // step over load library call which does a symbol load
	EXPECT_TRUE( fSuccess &= (dbg.VerifyNotification("Loaded symbols", 3, 20, TRUE) && dbg.VerifyNotification("powdll.dll", 3, 20, TRUE)) );

	dbg.StopDebugging();
	EXPECT_TRUE(fSuccess &= (bps.SetBreakpoint("{Dec,,dec2.dll}TagCallPow") != NULL) );
	dbg.Go();
	EXPECT_TRUE ( fSuccess &= dbg.Go("{Dec,,dec2.dll}TagCallPow") );
	EXPECT_TRUE(fSuccess &= (bps.SetBreakpoint("dPow") != NULL));
	EXPECT_TRUE ( fSuccess &= dbg.StepOver(1, "dPow") );
	return fSuccess;	
}

BOOL Cexe2IDETest::DllStepOut(   )
{
 	LogTestHeader( "DllStepOut" );
	BOOL fSuccess = TRUE;
	dbg.Restart();
	bps.ClearAllBreakpoints();
	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint("{Dec,,dec2.dll}Dec") != NULL ));
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, NULL, "Dec") );
	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint("{Dec,,dec2.dll}@54") != NULL ));
	
	// StepOut of implibed DLL into DLL
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, "Inc(wBar);") );
	EXPECT_TRUE ( fSuccess &= dbg.StepInto(1, NULL, NULL, "Inc") ); 
	EXPECT_TRUE_COMMENT ( fSuccess &= dbg.StepOut(1, NULL, NULL, "Dec"), "StepOut of implibed DLL into DLL (source mode)" ); 

	// StepOut of not implibed DLL into DLL
	int count=0;
	while ( (count<25) && (!dbg.AtSymbol("{Dec,,dec2.dll}TagCallPow")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE(fSuccess &= (dbg.AtSymbol("TagCallPow") && stk.CurrentFunctionIs("Dec")));
	EXPECT_TRUE(fSuccess &= dbg.StepInto(1, NULL, NULL, "dPow"));
	EXPECT_TRUE_COMMENT ( fSuccess &= dbg.StepOut(1, NULL, NULL, "Dec"), "StepOut of not implibed DLL into DLL (source mode)" ); 

	// StepOut of implibed DLL into EXE
	EXPECT_TRUE_COMMENT ( fSuccess &= dbg.StepOut(1, NULL, NULL, "MainWndProc"), "StepOut of implibed DLL into EXE (source mode)" ); 

	// ASM mode
	dbg.Restart();
	dbg.SetSteppingMode(ASM);
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, NULL, "Dec") );

	// StepOut of implibed DLL into DLL
	EXPECT_TRUE_COMMENT ( fSuccess &= dbg.Go(NULL, NULL, "Dec"), "At line 54" );
	count=0;
	while ( (count<25) && (!stk.CurrentFunctionIs("Inc")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE ( fSuccess &= stk.CurrentFunctionIs("Inc") );
	EXPECT_TRUE ( fSuccess &= dbg.StepInto(3, NULL, NULL, "Inc") ); 
	EXPECT_TRUE_COMMENT ( fSuccess &= dbg.StepOut(1, NULL, NULL, "Dec"), "StepOut of implibed DLL into DLL (mixed mode)" ); 

	// StepOut of not implibed DLL into DLL
	EXPECT_TRUE(fSuccess &= (bps.SetBreakpoint("{Dec,,dec2.dll}TagCallPow") != NULL));
	dbg.Go();
	count=0;
	while ( (count<25) && (!stk.CurrentFunctionIs("dPow")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE ( fSuccess &= stk.CurrentFunctionIs("dPow") );
	EXPECT_TRUE ( fSuccess &= dbg.StepInto(2, NULL, NULL, "dPow") ); 
	EXPECT_TRUE_COMMENT ( fSuccess &= dbg.StepOut(1, NULL, NULL, "Dec"), "StepOut of not implibed DLL into DLL (mixed mode)" ); 

	// StepOut of implibed DLL into EXE
	EXPECT_TRUE_COMMENT ( fSuccess &= dbg.StepOut(1, NULL, NULL, "MainWndProc"), "StepOut of implibed DLL into EXE (mixed mode)" ); 

	dbg.StopDebugging();
	return fSuccess;	
}

BOOL Cexe2IDETest::DllTraceOut(   )
{
 	LogTestHeader( "DllTraceOut" );
	BOOL fSuccess = TRUE;
	dbg.Restart();
	bps.ClearAllBreakpoints();
	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint("{Dec,,dec2.dll}Dec") != NULL ));
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, NULL, "Dec") );
	
	// TraceOut of implibed DLL into DLL
	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint("{Dec,,dec2.dll}@54") != NULL ));
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, "Inc(wBar);") );
	EXPECT_TRUE ( fSuccess &= dbg.StepInto(1, NULL, NULL, "Inc") ); 
	int count=0;
	while ( (count<25) && (!stk.CurrentFunctionIs("Dec")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE_COMMENT ( fSuccess &= stk.CurrentFunctionIs("Dec"), "TraceOut of implibed DLL into DLL" );

	// TraceOut of not implibed DLL into DLL
	count=0;
	while ( (count<25) && (!dbg.AtSymbol("{Dec,,dec2.dll}TagCallPow")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE(fSuccess &= (dbg.AtSymbol("TagCallPow") && stk.CurrentFunctionIs("Dec")));
	EXPECT_TRUE(fSuccess &= dbg.StepInto(1, NULL, NULL, "dPow"));
	count=0;
	while ( (count<25) && (!stk.CurrentFunctionIs("Dec")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE_COMMENT ( fSuccess &= stk.CurrentFunctionIs("Dec"), "TraceOut of not implibed DLL into DLL" );

	dbg.StopDebugging();
	return fSuccess;	
}

BOOL Cexe2IDETest::GoFromWithinDll(   )
{
 	LogTestHeader( "GoFromWithinDll" );
	BOOL fSuccess = TRUE;
	dbg.Restart();
	bps.ClearAllBreakpoints();

	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint("{Dec,,dec2.dll}Dec") != NULL ));
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, NULL, "Dec") );
	UIWB.OpenFile( m_strProjectDir + "\\" + "dllappx.c");
	EXPECT_TRUE( fSuccess &= src.Find("BPWithLengthTest();") );
	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint() != NULL ));
	EXPECT_TRUE( dbg.Go(NULL, "BPWithLengthTest();", "MainWndProc") );
	bps.ClearAllBreakpoints();
	dbg.Restart();

	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint("{Inc,,incdll.dll}Inc") != NULL ));
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, NULL, "Inc") );
	UIWB.OpenFile( m_strProjectDir + "\\" + "dec2.c");
	EXPECT_TRUE( fSuccess &= src.Find("dValue = dpfnPow( 10, 3 );") );
	EXPECT_TRUE( fSuccess &= dbg.StepToCursor(0, NULL, "dValue = dpfnPow( 10, 3 );") );
	
	EXPECT_TRUE(fSuccess &= (dbg.AtSymbol("TagCallPow") && stk.CurrentFunctionIs("Dec")));
	EXPECT_TRUE(fSuccess &= dbg.StepInto(2, NULL, NULL, "dPow"));
	UIWB.OpenFile( m_strProjectDir + "\\" + "dllappx.c");
	EXPECT_TRUE( fSuccess &= src.Find("BPWithLengthTest();") );
	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint() != NULL ));
	EXPECT_TRUE( fSuccess &= dbg.Go(NULL, "BPWithLengthTest();", "MainWndProc") );

	dbg.StopDebugging();
	return fSuccess;	
}

BOOL Cexe2IDETest::RestartFromWithinDll(   )
{
 	LogTestHeader( "RestartFromWithinDll" );
	BOOL fSuccess = TRUE;
	dbg.Restart();
	bps.ClearAllBreakpoints();

	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint("{Dec,,dec2.dll}Dec") != NULL ));
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, NULL, "Dec") );
	EXPECT_TRUE( fSuccess &= dbg.Restart() );
	bps.ClearAllBreakpoints();

	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint("{Inc,,incdll.dll}Inc") != NULL ));
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, NULL, "Inc") );
	EXPECT_TRUE( fSuccess &= dbg.Restart() );
	bps.ClearAllBreakpoints();
	
	UIWB.OpenFile( m_strProjectDir + "\\" + "dec2.c");
	EXPECT_TRUE( fSuccess &= src.Find("dValue = dpfnPow( 10, 3 );") );
	EXPECT_TRUE( fSuccess &= dbg.StepToCursor(0, NULL, "dValue = dpfnPow( 10, 3 );") );
	EXPECT_TRUE(fSuccess &= (dbg.AtSymbol("TagCallPow") && stk.CurrentFunctionIs("Dec")));
	EXPECT_TRUE(fSuccess &= dbg.StepInto(2, NULL, NULL, "dPow"));
	EXPECT_TRUE( fSuccess &= dbg.Restart() );

	dbg.StopDebugging();
	return fSuccess;	
}

BOOL Cexe2IDETest::StepOverFuncInUnloadedDll(   )
{
 	LogTestHeader( "StepOverFuncInUnloadedDll" );
	BOOL fSuccess = TRUE;
	dbg.Restart();
	bps.ClearAllBreakpoints();

	UIWB.OpenFile( m_strProjectDir + "\\" + "dllappx.c");
	EXPECT_TRUE( fSuccess &= src.Find("Dec( &wValue );") );
	EXPECT_TRUE( fSuccess &= dbg.StepToCursor(0, NULL, "Dec( &wValue );", "MainWndProc") );
	EXPECT_TRUE(fSuccess &= dbg.StepOver(1, NULL, NULL, "MainWndProc"));
	EXPECT_TRUE( fSuccess &= (dbg.VerifyNotification("Loaded symbols", 3, 20, TRUE) && dbg.VerifyNotification("powdll.dll", 3, 20, TRUE)) );

	dbg.StopDebugging();
	return fSuccess;	
}

// TODO ?

/* 
** attempt to step over function but which fires on a conditional bp.
*/


/* 
** test tracing constructor.
*/


/* 
** test tracing into function contained in a secondary module.
*/


/* 
** test tracing into function contained in a virtual c++ function.
*/


/* 
** test tracing into function through indirect call.
*/


/* 
** perform test Step_Out of main/winmain.  (is this really a core test?
*/


/* 
** test to Step_Out of func w/partial info into func w/out debug info
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\mem\memsub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CmemSubSuite class
//

#include "stdafx.h"
#include "memsub.h"
#include "afxdllx.h"
#include "..\..\DbgTestBase.h"

#include "memcase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


/////////////////////////////////////////////////////////////////////////////
// CmemSubSuite

IMPLEMENT_SUBSUITE(CmemSubSuite, CIDESubSuite, "Memory Window", "VCQA Debugger")

BEGIN_TESTLIST(CmemSubSuite)
	TEST(CmemIDETest, RUN)
END_TESTLIST()

void CmemSubSuite::CleanUp(void)
	{
	::CleanUp("testgo01");
	::CleanUp("dbg");
	}

void CmemSubSuite::SetUp(BOOL bCleanUp)
{
	CIDESubSuite::SetUp(bCleanUp);
	// TODO(michma - 9/2/98): re-enable when memory leak bugs are fixed.
	ExpectedMemLeaks(-1);
}
///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\mem\memcase.h ===
///////////////////////////////////////////////////////////////////////////////
//	memcase.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CmemIDETest Class
//

#ifndef __memcase_H__
#define __memcase_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\DbgTestBase.h"
#include "memsub.h"

///////////////////////////////////////////////////////////////////////////////
//	CmemIDETest class

class CmemIDETest : public CDbgTestBase
{
	DECLARE_TEST(CmemIDETest, CmemSubSuite)

// Data
private:
	// the base name of the localized directories and files we will use.
	CString m_strProjBase;
	// the location of the unlocalized sources, under which the projects we will use will be located.
	CString m_strSrcDir;
	// the locations of the dll and exe projects, and their localized sources, that we will use for this test.
	CString m_strExeDir;

public:  // Operations
	virtual void PreRun(void);
	virtual void Run();

// Test cases
public:

	void GoToSymbol (void);
	void VerifyEditAllFormats(void);
	void EditInWatchVerifyInMemoryWindow(void);
	void VerifyColumns(void);
	void ReEvaluateExpression(void);
	void GoToOverloadedSymbol(void);
	void RestoringMWTroughtDebuggingSessions(void);
	void GoToMaxMinAddress(void);
	void GoToInvalidAddress(void);
	void EditEIP(void);
	void NavigatingPointer(void);
	void ContextMenuOnToolBar(void);
	void VerifyMultipleUndoRedo(void);
	void CycleThroughMemoryFormats(void);
	void PgUpDownCtrlHomeEnd(void);
	void VerifyDockingView(void);
	void VerifyEditing(void);
	void VerifyVCPPReg(void);
	void VerifyRegArray(CString Arr[],int Num_items);	

private:
	void InitializeGlobalsThatAreUsedInTheMemoryTests(void);
	void DoDifferentKeysInMemoryWindow(void);
	
// Old tests.  TODO (Dklem 07-30) remove them
	void GoAfterScrollMemoryWnd(void);
	void MemExpectBytes(void);
	void MemoryFormats(void);
	void TestResizeMoveWindow(BOOL bIsDocked, BOOL bFullTest);
	void MinimalTestResizeMoveWindow(void);

private:
	int m_TestNumber;
	int m_TotalNumberOfTests;
	CString m_strLogInfo;


};

#endif //__memcase_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\mem\mem2.cpp ===
/*
** MEM.CPP
**
**	Created by :			Date :
**		waltcr				2/2/94
**
**	Description :
**		memory tests
*/

#include "stdafx.h"
#include "memcase.h"

/*
** start debugging and do some initialization.  
*/

///////////////////////////////////////////////////////////////////////////////
//	Test Cases
							
/* 
** The memory window address and format is set in StartDebugging.
** Execute to location after value of Global is known.  
** Verify the memory window correlty displays the bytes.
**
*/

BOOL CmemIDETest::MemExpectBytes(   )
{	
	bps.ClearAllBreakpoints();
	dbg.StepInto();
	uimem = UIDebug::ShowDockWindow(IDW_MEMORY_WIN);
	uimem.GoToAddress("Global");
	dbg.Restart();
	bps.SetBreakOnExpr("{foo}END","Global==3",COBP_TYPE_IF_EXP_TRUE);
	EXPECT_TRUE(dbg.Go("END",NULL, "foo"));
	uimem = UIDebug::ShowDockWindow(IDW_MEMORY_WIN);
	uimem.GoToAddress("Global");  
	CString Bytes = uimem.GetCurrentData(4);
	EXPECT_TRUE(Bytes == "03 00 00 00 ");

	// TODO: not fully implemented, always return true for now. 
	return TRUE;
}


#if 0
// TODO
BOOL CMemCases::ReadWriteMemory(   )
{

//	DESC("Read and Write Memory Window Test", "Memory");


	/* 
	** prepare and perform read memory test
	*/

	
	// set memory address ealier in the debug session, now confirm
	// first confirm at correct address

	
	/* 
	** prepare and perform write memory test
	*/

	// now write to the address and verify it takes

}
#endif


BOOL CmemIDETest::MemoryFormats(   )
{
	int m;
	BOOL fOkay = TRUE;

	UIMemory uimem = UIDebug::ShowDockWindow(IDW_MEMORY_WIN);
	for (m=1;m<=14;m++ )
		fOkay &= UIWB.SetMemoryFormat((MEM_FORMAT)m);

	if (fOkay)
		WriteLog(PASSED, "Memory Format Cycle");
	else
		WriteLog(FAILED, "Memory Format Cycle");

	return fOkay;  // REVIEW
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\mem\memcase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	memcase.CPP
//											 
//	Created by :			
//		DKLEM
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "memcase.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
											   
//#define VERIFY_TEST_SUCCESS(TestCase)\
//	TestCase == ERROR_SUCCESS

//IMPLEMENT_TEST(999, CmemIDETest, CDbgTestBase, "Memory", -1, CmemSubSuite)
IMPLEMENT_TEST(CmemIDETest, CDbgTestBase, "Memory", -1, CmemSubSuite)
//IMPLEMENT_TEST(CmemIDETest, CDebugTestSet, "Memory", -1, CmemSubSuite)


// Information about a test to be put in the test header
#define LOGTESTHEADER(strTestName) 	m_strLogInfo.Format("# - %d.  %s. Total # - %d, Passed - %d %%", ++m_TestNumber, strTestName, m_TotalNumberOfTests, (m_TestNumber*100)/m_TotalNumberOfTests);  \
									LogTestHeader(m_strLogInfo);


// Globals that are used in the Memory Tests
	char			chJustChar; 
	char			sJustString [20]; 
	unsigned char	uchJustUnsignedChar;
	short int		nsJustShort;
	unsigned short	unsJustUnsignedShort;
	int				nJustInt;
	unsigned int	unJustUnsignedInt;
	long int		lJustLongInt;
	unsigned long	ulJustUnsignedLongInt;	
	float			fJustFloat;
	double			dJustDouble;
	long double		dlJustLongDouble;
	__int64			sfJustSixtyFourInt;
	unsigned __int64 sfJustSixtyFourUnsignedInt;

	// Arrays for the Column test
	const int number_of_columns_to_be_tested = 3;

	char			asJustString [number_of_columns_to_be_tested + 2] = "Mamb";
	char			asLongString[8*number_of_columns_to_be_tested + 2] = "Mamba-Tumba-Rumba-Shurum";
	short int		ansJustShort[number_of_columns_to_be_tested + 1] = { -123, 12, -34, 45};
	unsigned short	aunsJustUnsignedShort[number_of_columns_to_be_tested + 1] = { 22987, 126, 334, 645};
	int				anJustInt[number_of_columns_to_be_tested + 1] = { -65555, 112, -354, 4451};
	unsigned int	aunJustUnsignedInt[number_of_columns_to_be_tested + 1] = { 655551, 2112, 9834, 45008};
	long int		alJustLongInt[number_of_columns_to_be_tested + 1] = { -77777, 120087, 3477, 99045};
	unsigned long	aulJustUnsignedLongInt[number_of_columns_to_be_tested + 1]  = { 999999, 77712, 36544, 22245};
	float			afJustFloat[number_of_columns_to_be_tested + 1] = { (float) 123.14, (float) 23.16, (float) 60.70, (float) 2.93};
	double			adJustDouble[number_of_columns_to_be_tested + 1] = { -777e50,  77e22,  12e5,  54e10};
	long double		adlJustLongDouble[number_of_columns_to_be_tested + 1] = { -999e70, 89e3,  18e2,  -4e17};
	__int64			asfJustSixtyFourInt[number_of_columns_to_be_tested + 1] = { -1234567890987654909, 1, -2, -3 };
	unsigned __int64 asfJustSixtyFourUnsignedInt[number_of_columns_to_be_tested + 1] = { 9876543212345678123, 12, 45, 1};

void CmemIDETest::InitializeGlobalsThatAreUsedInTheMemoryTests(void)
{
	chJustChar = 'M'; 
	strcpy(sJustString, "Mamba-hara-mambu-ru"); /* 19 chars in the string */
	uchJustUnsignedChar = 'u';
	nsJustShort = -123;
	unsJustUnsignedShort = 22987;
	nJustInt = -65555;
	unJustUnsignedInt = 655551;
	lJustLongInt = -77777;
	ulJustUnsignedLongInt  = 999999;	
	fJustFloat = (float) 123.14;
	dJustDouble = -777e50;
	dlJustLongDouble = -999e70;
	sfJustSixtyFourInt = -1234567890987654909;
	sfJustSixtyFourUnsignedInt = 9876543212345678123;
}


// each function that runs a test has this prototype.
typedef void (CmemIDETest::*PTR_TEST_FUNC)(void); 

// we randomly pick out of the following list of tests and run them.
// insert functions for new tests to the end of the list.

PTR_TEST_FUNC tests[] = {
	&CmemIDETest::GoToSymbol,	
	&CmemIDETest::EditInWatchVerifyInMemoryWindow,
	&CmemIDETest::VerifyEditAllFormats,
// TODO: (dklem 08/12/98) Uncomment the following 1 line when #4360 and #7452 and #7594 gets fixed. Fixed in 8307.0
// There is no Columns option in 60
//*	&CmemIDETest::VerifyColumns,
	&CmemIDETest::ReEvaluateExpression,
	&CmemIDETest::GoToOverloadedSymbol,
	&CmemIDETest::RestoringMWTroughtDebuggingSessions,
	&CmemIDETest::GoToMaxMinAddress,
	&CmemIDETest::GoToInvalidAddress,
// TODO: (dklem 08/12/98) Uncomment the following 1 line when #5190 gets fixed
	&CmemIDETest::EditEIP,
// TODO: (dklem 08/12/98) Uncomment the following 2 lines when #4360 and #7452 and #7594 gets fixed. Fixed in 8307.0
	&CmemIDETest::NavigatingPointer,
	&CmemIDETest::ContextMenuOnToolBar,
// TODO: (dklem 08/12/98) Uncomment the following 1 line when #5454 gets fixed. Fixed in 8239.4
	&CmemIDETest::VerifyMultipleUndoRedo,
//////////////////////////////////////////////////////////////////
// TODO: (dklem 08/12/98) Uncomment the following 1 line when #4360 and #7452 and #7594 gets fixed. Fixed in 8307.0
//*	&CmemIDETest::CycleThroughMemoryFormats,
// TODO: (dklem 08/12/98) Uncomment the following 1 line when #5555 and #7456 get fixed. Fixed in 8307.0
// TODO: (dklem 11/10/98) Uncomment the following 1 line when #9430 is fixed.
//*	&CmemIDETest::PgUpDownCtrlHomeEnd,
	&CmemIDETest::VerifyEditing,

	//	added by dverma
	&CmemIDETest::VerifyVCPPReg
};


void CmemIDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();

}

void CmemIDETest::Run()
{

	/******************
	 * INITIALIZATION *
	 ******************/


	// the base name of the localized directories and files we will use.
	if(GetSystem() & SYSTEM_DBCS)
		m_strProjBase = "[\\]^{|}Aa`@~ mem";
	else
		m_strProjBase = "mem";

	// the location of the unlocalized sources, under which the projects we will use will be located.
	m_strSrcDir = GetCWD() + "src\\mem";
	// the locations of the dll and exe projects, and their localized sources, that we will use for this test.
	m_strExeDir = m_strSrcDir + "\\" + m_strProjBase + " exe";

	// clean-up the exe project from the last run.
	KillFiles(m_strExeDir + "\\Debug\\", "*.*");
	RemoveDirectory(m_strExeDir + "\\Debug");
	KillFiles(m_strExeDir + "\\", "*.*");
	RemoveDirectory(m_strExeDir);

	// set the options for the exe project we are building for this test.
	CProjWizOptions *pWin32AppWizOpt = new(CWin32AppWizOptions);
	pWin32AppWizOpt->m_strLocation = m_strSrcDir;
	pWin32AppWizOpt->m_strName = m_strProjBase + " exe";	
	
	// create the exe project.
	EXPECT_SUCCESS(prj.New(pWin32AppWizOpt));
	// create a new localized exe source file in the project dir from the unlocalized exe source file.
	CopyFile(m_strSrcDir + "\\" + "mem.cpp", m_strExeDir + "\\" + m_strProjBase + " exe.cpp", FALSE);
	// make it writable so it can be cleaned up later.
	SetFileAttributes(m_strExeDir + "\\" + m_strProjBase + " exe.cpp", FILE_ATTRIBUTE_NORMAL);
	// add the source to the project.
	EXPECT_SUCCESS(prj.AddFiles(m_strProjBase + " exe.cpp"));
	// build the project.
	EXPECT_SUCCESS(prj.Build());

	// all tests expect the ide to be in this initial state.
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(mem.Enable());

	// In the tests it is assumed that the initial memory window has Docking View turned on
	EXPECT_TRUE(uimem.EnableDockingView(TRUE));


	m_TestNumber = 0;
	m_TotalNumberOfTests = sizeof(tests) / sizeof(PTR_TEST_FUNC);
	
	// we only want to randomly run each test once.
	RandomNumberCheckList rncl(sizeof(tests) / sizeof(PTR_TEST_FUNC));
	// indexes into the test function array.
	int iTest;
	
	// randomly run each test once.
	while((iTest = rncl.GetNext()) != -1)
//	for(iTest = 0; iTest < sizeof(tests) / sizeof(PTR_TEST_FUNC); iTest++)
		(this->*(tests[iTest]))();

	VerifyDockingView();
	dbg.StopDebugging(ASSUME_NORMAL_TERMINATION) ;	

}


void CmemIDETest::GoToSymbol(void)
{
	LOGTESTHEADER("GoToSymbol");
	CString address;

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();

	EXPECT_TRUE(mem.MemoryDataIs("nJustInt", nJustInt));
	// Get current address (which is addres for nJustInt)
	EXPECT_TRUE(ee.GetExpressionValue("&nJustInt", address));
	// Change the address and check that it contains correct data
	EXPECT_TRUE(mem.MemoryDataIs("dJustDouble", dJustDouble));
	uimem.EnableToolBar(FALSE);
	EXPECT_TRUE(mem.MemoryDataIs(address, nJustInt));	

	EXPECT_TRUE(dbg.ToggleHexDisplay(TRUE));

	// Toggle Hex mode and do the previous tests to verify that hex mode doesn't affect them
	
	EXPECT_TRUE(mem.MemoryDataIs("nJustInt", nJustInt));
	// Get current address (which is addres for nJustInt)
	EXPECT_TRUE(ee.GetExpressionValue("&nJustInt", address));
	// Change the address and check that it contains correct data
	EXPECT_TRUE(mem.MemoryDataIs("dJustDouble", dJustDouble));
	uimem.EnableToolBar(TRUE);
	EXPECT_TRUE(mem.MemoryDataIs(address, nJustInt));	

	// Toggle Hex mode back
	EXPECT_TRUE(dbg.ToggleHexDisplay(FALSE));

	// Resize and Move
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());

}

void CmemIDETest::VerifyEditAllFormats(void)
{

	LOGTESTHEADER("VerifyEditAllFormats");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();

/*
	MEM_FORMAT_WCHAR Memory Format is not tested here.
*/

	//Try all types using the same schema
	// 1. Check data
	// 2. Update data in memory window
	// 3. Check data in memory and via expression

	EXPECT_TRUE(mem.MemoryDataIs("chJustChar", chJustChar));	
	chJustChar += 2;
	EXPECT_TRUE(mem.SetMemoryData("chJustChar", chJustChar, MEM_FORMAT_ASCII));	
	EXPECT_TRUE(mem.MemoryDataIs("chJustChar", chJustChar));	
	EXPECT_TRUE(cxx.ExpressionValueIs("chJustChar", chJustChar));	

	EXPECT_TRUE(mem.MemoryDataIs("uchJustUnsignedChar", uchJustUnsignedChar));	
	uchJustUnsignedChar += 2;
	EXPECT_TRUE(mem.SetMemoryData("uchJustUnsignedChar", uchJustUnsignedChar, MEM_FORMAT_ASCII));	
	EXPECT_TRUE(mem.MemoryDataIs("uchJustUnsignedChar", uchJustUnsignedChar));	
	EXPECT_TRUE(cxx.ExpressionValueIs("uchJustUnsignedChar", uchJustUnsignedChar));	

	// Check the Byte Memory Format
	EXPECT_TRUE(mem.SetMemoryData("uchJustUnsignedChar", "65", MEM_FORMAT_BYTE));
	uchJustUnsignedChar = 'e';  // Correspondes to 0x65
	EXPECT_TRUE(mem.MemoryDataIs("uchJustUnsignedChar", uchJustUnsignedChar));	


	EXPECT_TRUE(mem.MemoryDataIs("sJustString", sJustString, MEM_FORMAT_ASCII, strlen(sJustString)));	
	strcpy(sJustString, _strrev(sJustString));
	EXPECT_TRUE(mem.SetMemoryData("sJustString", sJustString, MEM_FORMAT_ASCII));	
	EXPECT_TRUE(mem.MemoryDataIs("sJustString", sJustString));	
	CString csExpectedString("ADDRESS ");
	csExpectedString = csExpectedString + "\"" + sJustString + "\"";
	EXPECT_TRUE(cxx.ExpressionValueIs("sJustString", csExpectedString));
	// Since there are too many crashes after editing we want to resize after editing each format
	// TODO: (dklem 11/04/98) Uncomment the following line when #8915 is fixed. 
	MinimalTestResizeMoveWindow();
	

	EXPECT_TRUE(mem.MemoryDataIs("nsJustShort", nsJustShort));	
	nsJustShort *= 2;
// TODO: (dklem 08/12/98) Uncomment the following 3 lines when #4734 gets fixed
//	EXPECT_TRUE(mem.SetMemoryData("nsJustShort", nsJustShort, MEM_FORMAT_SHORT));	
//	EXPECT_TRUE(mem.MemoryDataIs("nsJustShort", nsJustShort));	
//	EXPECT_TRUE(cxx.ExpressionValueIs("nsJustShort", nsJustShort));	
	// Since there are too many crashes after editing we want to resize after editing each format
	// TODO: (dklem 11/04/98) Uncomment the following line when #4734 and #8915 are fixed. 
	 MinimalTestResizeMoveWindow();


	EXPECT_TRUE(mem.MemoryDataIs("unsJustUnsignedShort", unsJustUnsignedShort));	
	unsJustUnsignedShort *= 2;
	EXPECT_TRUE(mem.SetMemoryData("unsJustUnsignedShort", unsJustUnsignedShort, MEM_FORMAT_SHORT_UNSIGNED));	
	EXPECT_TRUE(mem.MemoryDataIs("unsJustUnsignedShort", unsJustUnsignedShort));	
	EXPECT_TRUE(cxx.ExpressionValueIs("unsJustUnsignedShort", unsJustUnsignedShort));	
	// Since there are too many crashes after editing we want to resize after editing each format
	// TODO: (dklem 11/04/98) Uncomment the following line when #8915 is fixed. 
	MinimalTestResizeMoveWindow();

	// Check the Short Hex Memory Format
	// TODO: (dklem 10/20/98) Uncomment the following 3 lines when #8198 gets fixed.  Fixed int 8307.0
	EXPECT_TRUE(mem.SetMemoryData("unsJustUnsignedShort", "0113", MEM_FORMAT_SHORT_HEX));	
	unsJustUnsignedShort = 275;
	EXPECT_TRUE(mem.MemoryDataIs("unsJustUnsignedShort", unsJustUnsignedShort));	
	// Since there are too many crashes after editing we want to resize after editing each format
	// TODO: (dklem 11/04/98) Uncomment the following line when #8915 is fixed. 
	MinimalTestResizeMoveWindow();

	EXPECT_TRUE(mem.MemoryDataIs("nJustInt", nJustInt));	
	nJustInt += 1002;
// TODO: (dklem 08/12/98) Uncomment the following 3 lines when #4734 gets fixed
//	EXPECT_TRUE(mem.SetMemoryData("nJustInt", nJustInt, MEM_FORMAT_LONG));	
//	EXPECT_TRUE(mem.MemoryDataIs("nJustInt", nJustInt));	
//	EXPECT_TRUE(cxx.ExpressionValueIs("nJustInt", nJustInt));	
	// Since there are too many crashes after editing we want to resize after editing each format
	// TODO: (dklem 11/04/98) Uncomment the following line when #8915 and #4734 are fixed. 
	MinimalTestResizeMoveWindow();

	EXPECT_TRUE(mem.MemoryDataIs("unJustUnsignedInt", unJustUnsignedInt));	
	unJustUnsignedInt -= 157;
	EXPECT_TRUE(mem.SetMemoryData("unJustUnsignedInt", unJustUnsignedInt, MEM_FORMAT_LONG_UNSIGNED));	
	EXPECT_TRUE(mem.MemoryDataIs("unJustUnsignedInt", unJustUnsignedInt));	
	EXPECT_TRUE(cxx.ExpressionValueIs("unJustUnsignedInt", unJustUnsignedInt));	
	// Since there are too many crashes after editing we want to resize after editing each format
	// TODO: (dklem 11/04/98) Uncomment the following line when #8915 is fixed. 
	MinimalTestResizeMoveWindow();

	EXPECT_TRUE(mem.MemoryDataIs("lJustLongInt", lJustLongInt));	
	lJustLongInt += 12345;
// TODO: (dklem 08/12/98) Uncomment the following 3 lines when #4734 gets fixed
//	EXPECT_TRUE(mem.SetMemoryData("lJustLongInt", lJustLongInt, MEM_FORMAT_LONG));	
//	EXPECT_TRUE(mem.MemoryDataIs("lJustLongInt", lJustLongInt));	
//	EXPECT_TRUE(cxx.ExpressionValueIs("lJustLongInt", lJustLongInt));	
	// Since there are too many crashes after editing we want to resize after editing each format
	// TODO: (dklem 11/04/98) Uncomment the following line when #8915 and #4734 are fixed. 
	MinimalTestResizeMoveWindow();

	EXPECT_TRUE(mem.MemoryDataIs("ulJustUnsignedLongInt", ulJustUnsignedLongInt));	
	ulJustUnsignedLongInt -= 76543;
	EXPECT_TRUE(mem.SetMemoryData("ulJustUnsignedLongInt", ulJustUnsignedLongInt, MEM_FORMAT_LONG_UNSIGNED));	
	EXPECT_TRUE(mem.MemoryDataIs("ulJustUnsignedLongInt", ulJustUnsignedLongInt));	
	EXPECT_TRUE(cxx.ExpressionValueIs("ulJustUnsignedLongInt", ulJustUnsignedLongInt));	
	// Since there are too many crashes after editing we want to resize after editing each format
	// TODO: (dklem 11/04/98) Uncomment the following line when #8915 is fixed. 
	MinimalTestResizeMoveWindow();

	// Check the Long Hex Memory Format
	EXPECT_TRUE(mem.SetMemoryData("ulJustUnsignedLongInt", "000be293", MEM_FORMAT_LONG_HEX));	
	ulJustUnsignedLongInt = 778899;
	EXPECT_TRUE(mem.MemoryDataIs("ulJustUnsignedLongInt", ulJustUnsignedLongInt));	
	// Since there are too many crashes after editing we want to resize after editing each format
	// TODO: (dklem 11/04/98) Uncomment the following line when #8915 is fixed. 
	MinimalTestResizeMoveWindow();

// TODO: (dklem 08/12/98) Uncomment the following 15 lines when #4727 gets fixed.
//	Note: the code in Comem for the float, double and long double is NYI because memory window behavior when 
//	changing (typing) these types is not defined yet.
	EXPECT_TRUE(mem.MemoryDataIs("fJustFloat", fJustFloat));	
	fJustFloat *= (float) 1.981;
	EXPECT_TRUE(mem.SetMemoryData("fJustFloat", fJustFloat, MEM_FORMAT_REAL));	
	EXPECT_TRUE(mem.MemoryDataIs("fJustFloat", fJustFloat));	
	EXPECT_TRUE(cxx.ExpressionValueIs("fJustFloat", fJustFloat));	
	// Since there are too many crashes after editing we want to resize after editing each format
	// TODO: (dklem 11/04/98) Uncomment the following line when #8915 is fixed. 
	MinimalTestResizeMoveWindow();

	EXPECT_TRUE(mem.MemoryDataIs("dJustDouble", dJustDouble));	
	dJustDouble /= 3.923;
//  TODO: (dklem 09/02/98) Uncomment the following 2 lines when #6156 gets fixed
	EXPECT_TRUE(mem.SetMemoryData("dJustDouble", dJustDouble, MEM_FORMAT_REAL_LONG));	
	EXPECT_TRUE(mem.MemoryDataIs("dJustDouble", dJustDouble));	
// TODO: (dklem 09/02/98) Uncomment the following 1 line when #6097 gets fixed.	
//	EXPECT_TRUE(cxx.ExpressionValueIs("dJustDouble", dJustDouble));	
	// Since there are too many crashes after editing we want to resize after editing each format
	// TODO: (dklem 11/04/98) Uncomment the following line when #8915 is fixed. 
	MinimalTestResizeMoveWindow();

	EXPECT_TRUE(mem.MemoryDataIs("dlJustLongDouble", dlJustLongDouble));	
	dlJustLongDouble /= (-103.923);
//  TODO: (dklem 09/02/98) Uncomment the following 2 lines when #6156 gets fixed
	EXPECT_TRUE(mem.SetMemoryData("dlJustLongDouble", dlJustLongDouble, MEM_FORMAT_REAL_LONG));	
	EXPECT_TRUE(mem.MemoryDataIs("dlJustLongDouble", dlJustLongDouble));	

	// Check that E-000 can not be set
	CString csBytes = "{+}1.11111E-000";
	EXPECT_TRUE(mem.SetMemoryBytes("fJustFloat", csBytes, MEM_FORMAT_REAL));
	csBytes	= mem.ExtractMemoryData(MEM_FORMAT_REAL, "fJustFloat", 1);
	csBytes.TrimRight(" ");
	EXPECT_TRUE("+1.11111E+000" == csBytes);

	csBytes = "{+}1.11111E-";
	EXPECT_TRUE(mem.SetMemoryBytes("fJustFloat", csBytes, MEM_FORMAT_REAL));
	csBytes	= mem.ExtractMemoryData(MEM_FORMAT_REAL, "fJustFloat", 1);
	csBytes.TrimRight(" ");
	EXPECT_TRUE("+1.11111E+000" == csBytes);

//  TODO: (dklem 09/02/98) Uncomment the following 10 lines when #6156 gets fixed
	csBytes = "{+}2.22222222222222E-000";
	EXPECT_TRUE(mem.SetMemoryBytes("dJustDouble", csBytes, MEM_FORMAT_REAL_LONG));
	csBytes	= mem.ExtractMemoryData(MEM_FORMAT_REAL_LONG, "dJustDouble", 1);
	csBytes.TrimRight(" ");
	EXPECT_TRUE("+2.22222222222222E+000" == csBytes);

	csBytes = "{+}2.22222222222222E-";
	EXPECT_TRUE(mem.SetMemoryBytes("dJustDouble", csBytes, MEM_FORMAT_REAL_LONG));
	csBytes	= mem.ExtractMemoryData(MEM_FORMAT_REAL_LONG, "dJustDouble", 1);
	csBytes.TrimRight(" ");
	EXPECT_TRUE("+2.22222222222222E+000" == csBytes);


// TODO: (dklem 09/02/98) Uncomment the following 1 line when #6097 gets fixed.	
//	EXPECT_TRUE(cxx.ExpressionValueIs("dlJustLongDouble", dlJustLongDouble));	

	EXPECT_TRUE(mem.MemoryDataIs("sfJustSixtyFourInt", sfJustSixtyFourInt));	
	sfJustSixtyFourInt += 12345987987;
// TODO: (dklem 08/12/98) Uncomment the following 3 lines when #4734 gets fixed
//	EXPECT_TRUE(mem.SetMemoryData("sfJustSixtyFourInt", sfJustSixtyFourInt, MEM_FORMAT_INT64));	
//	EXPECT_TRUE(mem.MemoryDataIs("sfJustSixtyFourInt", sfJustSixtyFourInt));	
// TODO: (dklem 08/12/98) ExpressionValueIs NYI for __in64
//	EXPECT_TRUE(cxx.ExpressionValueIs("sfJustSixtyFourInt", sfJustSixtyFourInt));	
	// Since there are too many crashes after editing we want to resize after editing each format
	// TODO: (dklem 11/04/98) Uncomment the following line when #8915 and #4734 are fixed. 
	MinimalTestResizeMoveWindow();

	EXPECT_TRUE(mem.MemoryDataIs("sfJustSixtyFourUnsignedInt", sfJustSixtyFourUnsignedInt));	
	sfJustSixtyFourUnsignedInt -= 765430009987;

// TODO: (dklem 08/12/98) Uncomment the following 2 lines when #4780 gets fixed
//	EXPECT_TRUE(mem.SetMemoryData("sfJustSixtyFourUnsignedInt", sfJustSixtyFourUnsignedInt, MEM_FORMAT_INT64_UNSIGNED));	
//	EXPECT_TRUE(mem.MemoryDataIs("sfJustSixtyFourUnsignedInt", sfJustSixtyFourUnsignedInt));	
// TODO: (dklem 08/12/98) ExpressionValueIs NYI for __in64
//	EXPECT_TRUE(cxx.ExpressionValueIs("sfJustSixtyFourUnsignedInt", sfJustSixtyFourUnsignedInt));	
	// Since there are too many crashes after editing we want to resize after editing each format
	// TODO: (dklem 11/04/98) Uncomment the following line when #8915 and #4780 fixed. 
	MinimalTestResizeMoveWindow();

	// Check the Long Hex Memory Format
//  TODO: (dklem 09/02/98) Uncomment the following 3 lines when #6156 gets fixed
	EXPECT_TRUE(mem.SetMemoryData("sfJustSixtyFourUnsignedInt", "002386d8905a5967", MEM_FORMAT_INT64_HEX));	
	sfJustSixtyFourUnsignedInt = 9999888877771111;
	EXPECT_TRUE(mem.MemoryDataIs("sfJustSixtyFourUnsignedInt", sfJustSixtyFourUnsignedInt));	

	// Resize and Move
	// TODO: (dklem 11/03/98) Uncomment the following line when #8915 is fixed. 
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());

}


void CmemIDETest::EditInWatchVerifyInMemoryWindow(void)
{

	LOGTESTHEADER("EditInWatchVerifyInMemoryWindow");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();

	chJustChar += 2;
	EXPECT_TRUE(cxx.SetExpressionValue("chJustChar", (int) chJustChar));	
	EXPECT_TRUE(mem.MemoryDataIs("chJustChar", chJustChar));	

	uchJustUnsignedChar += 2;
	EXPECT_TRUE(cxx.SetExpressionValue("uchJustUnsignedChar", (int) uchJustUnsignedChar));	
	EXPECT_TRUE(mem.MemoryDataIs("uchJustUnsignedChar", uchJustUnsignedChar));	

	nsJustShort *= 2;
	EXPECT_TRUE(cxx.SetExpressionValue("nsJustShort", nsJustShort));	
	EXPECT_TRUE(mem.MemoryDataIs("nsJustShort", nsJustShort));	

	unsJustUnsignedShort *= 2;
	EXPECT_TRUE(cxx.SetExpressionValue("unsJustUnsignedShort", unsJustUnsignedShort));	
	EXPECT_TRUE(mem.MemoryDataIs("unsJustUnsignedShort", unsJustUnsignedShort));	
	
	nJustInt += 1002;
	EXPECT_TRUE(cxx.SetExpressionValue("nJustInt", nJustInt));	
	EXPECT_TRUE(mem.MemoryDataIs("nJustInt", nJustInt));	

	unJustUnsignedInt -= 157;
	EXPECT_TRUE(cxx.SetExpressionValue("unJustUnsignedInt", unJustUnsignedInt));	
	EXPECT_TRUE(mem.MemoryDataIs("unJustUnsignedInt", unJustUnsignedInt));	

	lJustLongInt += 12345;
	EXPECT_TRUE(cxx.SetExpressionValue("lJustLongInt", lJustLongInt));	
	EXPECT_TRUE(mem.MemoryDataIs("lJustLongInt", lJustLongInt));	

	ulJustUnsignedLongInt -= 76543;
	EXPECT_TRUE(cxx.SetExpressionValue("ulJustUnsignedLongInt", ulJustUnsignedLongInt));	
	EXPECT_TRUE(mem.MemoryDataIs("ulJustUnsignedLongInt", ulJustUnsignedLongInt));	

	fJustFloat = (float) 438.981;
	EXPECT_TRUE(cxx.SetExpressionValue("fJustFloat", fJustFloat));	
	EXPECT_TRUE(mem.MemoryDataIs("fJustFloat", fJustFloat));	

	dJustDouble = 3.923e22;
	EXPECT_TRUE(cxx.SetExpressionValue("dJustDouble", dJustDouble));	
	EXPECT_TRUE(mem.MemoryDataIs("dJustDouble", dJustDouble));	

	dlJustLongDouble = 1.237e71;
	EXPECT_TRUE(cxx.SetExpressionValue("dlJustLongDouble", dlJustLongDouble));	
	EXPECT_TRUE(mem.MemoryDataIs("dlJustLongDouble", dlJustLongDouble));	

	sfJustSixtyFourInt += 12345987987;
	EXPECT_TRUE(cxx.SetExpressionValue("sfJustSixtyFourInt", sfJustSixtyFourInt));	
	EXPECT_TRUE(mem.MemoryDataIs("sfJustSixtyFourInt", sfJustSixtyFourInt));	

	sfJustSixtyFourUnsignedInt -= 765430009987;
	EXPECT_TRUE(cxx.SetExpressionValue("sfJustSixtyFourUnsignedInt", sfJustSixtyFourUnsignedInt));	
	EXPECT_TRUE(mem.MemoryDataIs("sfJustSixtyFourUnsignedInt", sfJustSixtyFourUnsignedInt));	

	// Resize and Move
	// TODO: (dklem 11/03/98) Uncomment the following line when #8915 is fixed. 
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());
}


void CmemIDETest::VerifyColumns(void)
{
	LOGTESTHEADER("VerifyColumns");

	char str[64];

	// Make the last element in each array equal to 0 in order to make comparison.  
	// This means that GetMemoryData(,,, count = number_of_columns_to_be_tested + 1) should return 0 for the last element
	// We do not do this while initilazing arrays in order to easily copy/paste this part from debugee
	// if data change
	asJustString [number_of_columns_to_be_tested] = '\0';
	ansJustShort[number_of_columns_to_be_tested] = 0;
	aunsJustUnsignedShort[number_of_columns_to_be_tested] =  0;
	anJustInt[number_of_columns_to_be_tested] = 0;
	aunJustUnsignedInt[number_of_columns_to_be_tested] = 0;
	alJustLongInt[number_of_columns_to_be_tested] = 0;
	aulJustUnsignedLongInt[number_of_columns_to_be_tested] = 0;
	afJustFloat[number_of_columns_to_be_tested] = (float) 0.;
	adJustDouble[number_of_columns_to_be_tested] = 0.;
	adlJustLongDouble[number_of_columns_to_be_tested] = 0.;
	asfJustSixtyFourInt[number_of_columns_to_be_tested] = 0;
	asfJustSixtyFourUnsignedInt[number_of_columns_to_be_tested] = 0;
	
	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();

	EXPECT_TRUE(mem.Enable());
	EXPECT_TRUE(mem.SetColumns(itoa(number_of_columns_to_be_tested, str, 10)));

/*
	MEM_FORMAT_WCHAR Memory Format is not tested here.
*/

// TODO: (dklem 08/12/98) Uncomment the following 1 line when #4361 gets fixed. Fixed in 8239.4
// TODO: (dklem 10/07/98) Uncomment the following 1 line when #7580 gets fixed
//	EXPECT_TRUE(mem.MemoryDataIs("asJustString", asJustString, MEM_FORMAT_ASCII, number_of_columns_to_be_tested + 1));	

	EXPECT_TRUE(mem.MemoryDataIs("ansJustShort", ansJustShort, MEM_FORMAT_SHORT, number_of_columns_to_be_tested + 1));
	EXPECT_TRUE(mem.MemoryDataIs("aunsJustUnsignedShort", aunsJustUnsignedShort, MEM_FORMAT_SHORT_UNSIGNED, number_of_columns_to_be_tested + 1));
	EXPECT_TRUE(mem.MemoryDataIs("anJustInt", anJustInt, MEM_FORMAT_LONG, number_of_columns_to_be_tested + 1));
	EXPECT_TRUE(mem.MemoryDataIs("aunJustUnsignedInt", aunJustUnsignedInt, MEM_FORMAT_LONG_UNSIGNED, number_of_columns_to_be_tested + 1));
	EXPECT_TRUE(mem.MemoryDataIs("alJustLongInt", alJustLongInt, MEM_FORMAT_LONG, number_of_columns_to_be_tested + 1));
	EXPECT_TRUE(mem.MemoryDataIs("aulJustUnsignedLongInt", aulJustUnsignedLongInt, MEM_FORMAT_LONG_UNSIGNED, number_of_columns_to_be_tested + 1));
	EXPECT_TRUE(mem.MemoryDataIs("afJustFloat", afJustFloat, MEM_FORMAT_REAL, number_of_columns_to_be_tested + 1));
	EXPECT_TRUE(mem.MemoryDataIs("adJustDouble", adJustDouble, MEM_FORMAT_REAL_LONG, number_of_columns_to_be_tested + 1));
	EXPECT_TRUE(mem.MemoryDataIs("adlJustLongDouble", adlJustLongDouble, MEM_FORMAT_REAL_LONG, number_of_columns_to_be_tested + 1));	
	EXPECT_TRUE(mem.MemoryDataIs("asfJustSixtyFourInt", asfJustSixtyFourInt, MEM_FORMAT_INT64, number_of_columns_to_be_tested + 1));	
	// TODO: (dklem 11/04/98) Uncomment the following line when #7580 is fixed
	//EXPECT_TRUE(mem.MemoryDataIs("asfJustSixtyFourUnsignedInt", asfJustSixtyFourUnsignedInt, MEM_FORMAT_INT64_UNSIGNED, number_of_columns_to_be_tested + 1));	

//	Test MEM_FORMAT_BYTE format
	EXPECT_TRUE(mem.MemoryDataIs("asJustString", "4d 61 6d  Mam", MEM_FORMAT_BYTE, number_of_columns_to_be_tested * 4 + 1));
//	Test HEX formats
	EXPECT_TRUE(mem.MemoryDataIs("asLongString", "614d  626d  2d61        ", MEM_FORMAT_SHORT_HEX, (number_of_columns_to_be_tested + 1)));
	EXPECT_TRUE(mem.MemoryDataIs("asLongString", "626d614d  75542d61  2d61626d            ", MEM_FORMAT_LONG_HEX, (number_of_columns_to_be_tested + 1)));
	EXPECT_TRUE(mem.MemoryDataIs("asLongString", "75542d61626d614d  626d75522d61626d  6d75727568532d61                    ", MEM_FORMAT_INT64_HEX, (number_of_columns_to_be_tested + 1)));

	// Resize and Move
	// TODO: (dklem 11/03/98) Uncomment the following line when #7985 is fixed
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());

}


void CmemIDETest::ReEvaluateExpression(void)
{

	LOGTESTHEADER("ReEvaluateExpression");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();

	EXPECT_TRUE(mem.MemoryDataIs("nJustInt", nJustInt));
	// TODO fro 60.  Toggle evaluation doesn't work in 60
	//EXPECT_TRUE(0 == uimem.GetCurrentAddress().CompareNoCase( uimem.GetCurrentSymbol().Right(8) ) );
	EXPECT_TRUE(uimem.ToogleReEvaluation());
	EXPECT_TRUE(mem.MemoryDataIs("nJustInt", nJustInt));
	EXPECT_TRUE("nJustInt" == uimem.GetCurrentSymbol());
	EXPECT_TRUE(uimem.ToogleReEvaluation());

	// Resize and Move
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());

}



void CmemIDETest::GoToOverloadedSymbol(void)
{

	LOGTESTHEADER("GoToOverloadedSymbol");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();

	EXPECT_TRUE(mem.Enable());
	CString address = mem.GetAddress("FuncWithArg");
	EXPECT_TRUE(dam.Enable());
	EXPECT_TRUE(dam.GotoSymbol(address));

	// TODO: (dklem 10/06/98) Change uidam.GetInstruction() to dam.GetInstruction() when #6013 gets fixed
	CString Instruction = uidam.GetInstruction(-1, 1, FALSE);
	//CString csInstruction = dam.GetInstruction();

	EXPECT_TRUE(-1 != Instruction.Find("int FuncWithArg(int nArg)"));
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));

	// Resize and Move
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());

}

void CmemIDETest::RestoringMWTroughtDebuggingSessions(void)
{

	LOGTESTHEADER("RestoringMWTroughtDebuggingSessions");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();

	EXPECT_TRUE(mem.MemoryDataIs("unJustUnsignedInt", unJustUnsignedInt));
	CString address = uimem.GetCurrentAddress();

	EXPECT_TRUE(dbg.Restart());
	// TODO (dklem 01/29/99) Restarting doesn't preserve "unJustUnsignedInt" in the address box
	// So the next line is commented.
	// EXPECT_TRUE(0 == address.CompareNoCase(uimem.GetCurrentSymbol().Right(8)));

	// Resize and Move
	// TODO: (dklem 11/04/98) Uncomment the following line when #8915 is fixed. 
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());
}


void CmemIDETest::GoToMaxMinAddress(void)
{

	LOGTESTHEADER("GoToMaxMinAddress");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();

	CString csAddress, csSymbol;

	EXPECT_TRUE("00000000" == (csAddress = mem.GetAddress("00000000")));
	EXPECT_TRUE("00000000" == (csSymbol = uimem.GetCurrentSymbol()));

	LOG->RecordInfo("CurrentAddress is %s", csAddress);
	LOG->RecordInfo("CurrentSymbol is %s", csSymbol);

	csAddress = mem.GetAddress("FFFFFFFF");
	csSymbol = uimem.GetCurrentSymbol();
	EXPECT_TRUE(0 == csAddress.CompareNoCase("FFFFFFFF"));
	EXPECT_TRUE(0 == csSymbol.CompareNoCase("FFFFFFFF"));

	LOG->RecordInfo("CurrentAddress is %s", csAddress);
	LOG->RecordInfo("CurrentSymbol is %s", csSymbol);

	// Resize and Move
	// TODO: (dklem 11/03/98) Uncomment the following line when #7985 is fixed
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());
}

void CmemIDETest::GoToInvalidAddress(void)
{

	LOGTESTHEADER("GoToInvalidAddress");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();

	EXPECT_TRUE(mem.MemoryDataIs("nJustInt", nJustInt));
	
	EXPECT_TRUE(0 == mem.GetAddress("FFFFFFFFF5").CompareNoCase("FFFFFFF5"));
	EXPECT_TRUE(0 == uimem.GetCurrentSymbol().CompareNoCase("FFFFFFFFF5"));

	EXPECT_TRUE(0 == mem.GetAddress("PRIVET").CompareNoCase("FFFFFFF5"));
	EXPECT_TRUE(0 == uimem.GetCurrentSymbol().CompareNoCase("PRIVET"));

	uimem.EnableToolBar(FALSE);
	EXPECT_TRUE(ERROR_SUCCESS == uimem.GoToAddress("PRIVET"));

	// TODO: (dklem 08/12/98) Write a code for cheking  if "Invalid address" dialog comes up - see next 1 line - when #4379 gets fixed
	//EXPECT_TRUE(MST.WFndWnd("Add Dialog Caption", FW_NOCASE | FW_EXIST));

	EXPECT_TRUE(0 == uimem.GetCurrentAddress().CompareNoCase("FFFFFFF5"));


	uimem.EnableToolBar(TRUE);

	// Resize and Move
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());
}



void CmemIDETest::EditEIP(void)
{

	LOGTESTHEADER("EditEIP");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();

	EXPECT_TRUE(dam.Enable());
	CString Instruction = uidam.GetInstruction(2, 1);
	if(Instruction.GetAt(0) == 'F')
	{
		EXPECT_TRUE(mem.SetMemoryData("EIP", "AF"/*Instruction*/, MEM_FORMAT_BYTE));	
	}
	else
	{
		EXPECT_TRUE(mem.SetMemoryData("EIP", "FF"/*Instruction*/, MEM_FORMAT_BYTE));	
	}

	EXPECT_TRUE(dam.Enable());
	EXPECT_TRUE(Instruction != uidam.GetInstruction(0, 1));

	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));

	// Resize and Move
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());
}

void CmemIDETest::NavigatingPointer(void)
{
	LOGTESTHEADER("NavigatingPointer");
	
	//char str[64];
	//int nRegEIP;
	int number_of_columns_to_be_tested_for60 = 1;

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();

	EXPECT_TRUE(uimem.ToogleReEvaluation());

	EXPECT_TRUE(mem.Enable());
	// Get the address
	CString cstr = mem.ExtractMemoryData(MEM_FORMAT_LONG_HEX, "pnJustIntPtr", 1);
	// Navigate to address
	EXPECT_TRUE(mem.MemoryDataIs(cstr, nJustInt));


	// Get the address
	cstr = mem.ExtractMemoryData(MEM_FORMAT_LONG_HEX, "pvJustVoidPtrStr", 1);
	EXPECT_TRUE(mem.MemoryDataIs(cstr, sJustString, MEM_FORMAT_ASCII, strlen(sJustString)));
	// There is no columns feature in 60
	//EXPECT_TRUE(mem.SetColumns(itoa(number_of_columns_to_be_tested_for60, str, 10)));

	cstr = mem.ExtractMemoryData(MEM_FORMAT_LONG_HEX, "pvJustVoidPtrShort", 1);
	EXPECT_TRUE(mem.MemoryDataIs(cstr, ansJustShort, MEM_FORMAT_SHORT, number_of_columns_to_be_tested_for60));

	cstr = mem.ExtractMemoryData(MEM_FORMAT_LONG_HEX, "pvJustVoidPtrInt", 1);
	EXPECT_TRUE(mem.MemoryDataIs(cstr, anJustInt, MEM_FORMAT_LONG, number_of_columns_to_be_tested_for60));
	
	cstr = mem.ExtractMemoryData(MEM_FORMAT_LONG_HEX, "pvJustVoidPtrFloat", 1);
	EXPECT_TRUE(mem.MemoryDataIs(cstr, afJustFloat, MEM_FORMAT_REAL, number_of_columns_to_be_tested_for60));

	cstr = mem.ExtractMemoryData(MEM_FORMAT_LONG_HEX, "pvJustVoidPtrDouble", 1);
	EXPECT_TRUE(mem.MemoryDataIs(cstr, adJustDouble, MEM_FORMAT_REAL_LONG, number_of_columns_to_be_tested_for60));
	
	cstr = mem.ExtractMemoryData(MEM_FORMAT_LONG_HEX, "pvJustVoidPtrInt64", 1);
	EXPECT_TRUE(mem.MemoryDataIs(cstr, asfJustSixtyFourUnsignedInt, MEM_FORMAT_INT64, number_of_columns_to_be_tested_for60));

	EXPECT_TRUE(uimem.ToogleReEvaluation());

	// Check that setting EIP = 0 in the address edit box doesn't have side effects.  Related to bug 8940.  Fixed in 8303.1
	EXPECT_TRUE(dbg.Restart());

	// TODO (dklem 02/01/99) ERROR in 60 - Putting EIP = 0 in memory window stops debugee
	// Moreover EIP = 0 is memorized so there is no way to debug the app other than delet an opt file.
	/*
	EXPECT_TRUE(uimem.ToogleReEvaluation());
	nRegEIP = regs.GetRegister(EIP);
	itoa(nRegEIP, str, 10);
	uimem.Activate();
	EXPECT_TRUE(ERROR_SUCCESS == uimem.GoToAddress("EIP = 0"));
	//EXPECT_TRUE(mem.GetMemoryData((LPCSTR), tmp_str, MEM_FORMAT_ASCII)); 

	COApplication appDialog;
	if(!appDialog.Attach("Microsoft Visual C++", 10))
	{
		LOG->RecordFailure("The dialog \"Microsoft Visual C++ (invalid expression)\" did not come up");
		return;
	}
	else
		// Hit OK to close dialog
		appDialog.SendKeys("ENTER");

	
	// Check that this hasn't changed EIP
	EXPECT_TRUE(cxx.ExpressionValueIs("EIP", str));

	EXPECT_TRUE(uimem.ToogleReEvaluation());
	*/

	// Resize and Move
	// TODO: (dklem 11/03/98) Uncomment the following line when #7985 is fixed
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());

}


void CmemIDETest::ContextMenuOnToolBar(void)
{
	LOGTESTHEADER("ContextMenuOnToolBar");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();

	EXPECT_TRUE(mem.Enable());
	CString csData = mem.ExtractMemoryData(MEM_FORMAT_SHORT_HEX, "asLongString", 1);
	EXPECT_TRUE(0 == csData.CompareNoCase("614d  ")); 
	int asa = csData.CompareNoCase("614d  ");

	csData = mem.ExtractMemoryData(MEM_FORMAT_LONG_HEX, "asLongString", 1);
	EXPECT_TRUE(0 == csData.CompareNoCase("626d614d  ")); 

	// Resize and Move
	// TODO: (dklem 11/03/98) Uncomment the following line when #7985 is fixed
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());

}


void CmemIDETest::VerifyMultipleUndoRedo(void)
{
	LOGTESTHEADER("VerifyMultipleUndoRedo");

	char str[64];

	unsigned int unJustUnsignedIntegers[2];
	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();

	EXPECT_TRUE(mem.MemoryDataIs("unJustUnsignedInt", unJustUnsignedInt));	
	
	unJustUnsignedIntegers[0] = unJustUnsignedInt - 157;
	EXPECT_TRUE(mem.SetMemoryData("unJustUnsignedInt", unJustUnsignedIntegers[0], MEM_FORMAT_LONG_UNSIGNED));	
	EXPECT_TRUE(mem.MemoryDataIs("unJustUnsignedInt", unJustUnsignedIntegers[0]));	

	// 60 doesn't support Multiple Redo/Undo
/*
	unJustUnsignedIntegers[1] = unJustUnsignedIntegers[0] * 2;
	EXPECT_TRUE(mem.SetMemoryData("unJustUnsignedInt", unJustUnsignedIntegers[1], MEM_FORMAT_LONG_UNSIGNED));	
	EXPECT_TRUE(mem.MemoryDataIs("unJustUnsignedInt", unJustUnsignedIntegers[1]));
	
	EditUndo(strlen(itoa(unJustUnsignedIntegers[1], str, 10)));
	EXPECT_TRUE(mem.MemoryDataIs("unJustUnsignedInt", unJustUnsignedIntegers[0]));	
*/
	EditUndo(strlen(itoa(unJustUnsignedIntegers[0], str, 10)));
	EXPECT_TRUE(mem.MemoryDataIs("unJustUnsignedInt", unJustUnsignedInt));	

	EditRedo(strlen(itoa(unJustUnsignedIntegers[0], str, 10)));
	EXPECT_TRUE(mem.MemoryDataIs("unJustUnsignedInt", unJustUnsignedIntegers[0]));	
/*
	EditRedo(strlen(itoa(unJustUnsignedIntegers[1], str, 10)));
	EXPECT_TRUE(mem.MemoryDataIs("unJustUnsignedInt", unJustUnsignedIntegers[1]));	
*/
	// Resize and Move
	// TODO: (dklem 11/04/98) Uncomment the following line when #8915 is fixed. 
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());

}

void CmemIDETest::CycleThroughMemoryFormats(void)
{
	LOGTESTHEADER("CycleThroughMemoryFormats");

	char str[64];

	// Check that nothing bad happens when cycling and Memory window is closed
	// TODO: (dklem 08/21/98) Uncomment the following 2 lines when #5485 gets fixed. Fixed in 8239.4
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_TRUE(mem.CycleMemoryFormat(1));

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();

/*
	MEM_FORMAT_WCHAR Memory Format is not tested here.
*/
	
	EXPECT_TRUE(mem.MemoryDataIs("asLongString", asLongString, MEM_FORMAT_ASCII, strlen(asLongString)));

	EXPECT_TRUE(mem.SetColumns(itoa(number_of_columns_to_be_tested, str, 10)));

	uimem.Activate();

	EXPECT_TRUE(mem.CycleMemoryFormat(1));
	uimem.m_MemoryFormat = MEM_FORMAT_INT64_UNSIGNED;
	EXPECT_TRUE(" 8454432296767676749   7092453983987524205   7887336170996313441  " == uimem.GetCurrentData(number_of_columns_to_be_tested));
	
	EXPECT_TRUE(mem.CycleMemoryFormat(1));
	uimem.m_MemoryFormat = MEM_FORMAT_INT64_HEX;
	EXPECT_TRUE("75542d61626d614d  626d75522d61626d  6d75727568532d61  " == uimem.GetCurrentData(number_of_columns_to_be_tested));
	
	EXPECT_TRUE(mem.CycleMemoryFormat(1));
	uimem.m_MemoryFormat = MEM_FORMAT_INT64;
	EXPECT_TRUE(" 8454432296767676749   7092453983987524205   7887336170996313441  " == uimem.GetCurrentData(number_of_columns_to_be_tested));
	
	EXPECT_TRUE(mem.CycleMemoryFormat(1));
	uimem.m_MemoryFormat = MEM_FORMAT_REAL_LONG;
	EXPECT_TRUE("+1.51481173207894E+257  +1.35711012392993E+166  +1.89271628313060E+219  " == uimem.GetCurrentData(number_of_columns_to_be_tested));
	
	EXPECT_TRUE(mem.CycleMemoryFormat(1));
	uimem.m_MemoryFormat = MEM_FORMAT_REAL;
	EXPECT_TRUE("+1.09472E+021  +2.68967E+032  +1.28116E-011  " == uimem.GetCurrentData(number_of_columns_to_be_tested));
	
	EXPECT_TRUE(mem.CycleMemoryFormat(1));
	uimem.m_MemoryFormat = MEM_FORMAT_LONG_UNSIGNED;
	EXPECT_TRUE("1651335501  1968450913   761356909  " == uimem.GetCurrentData(number_of_columns_to_be_tested));
	
	EXPECT_TRUE(mem.CycleMemoryFormat(1));
	uimem.m_MemoryFormat = MEM_FORMAT_LONG_HEX;
	EXPECT_TRUE("626d614d  75542d61  2d61626d  " == uimem.GetCurrentData(number_of_columns_to_be_tested));
	
	EXPECT_TRUE(mem.CycleMemoryFormat(1));
	uimem.m_MemoryFormat = MEM_FORMAT_LONG;
	EXPECT_TRUE(" 1651335501   1968450913    761356909  " == uimem.GetCurrentData(number_of_columns_to_be_tested));
	
	EXPECT_TRUE(mem.CycleMemoryFormat(1));
	uimem.m_MemoryFormat = MEM_FORMAT_SHORT_UNSIGNED;
	EXPECT_TRUE("24909  25197  11617  " == uimem.GetCurrentData(number_of_columns_to_be_tested));
	
	EXPECT_TRUE(mem.CycleMemoryFormat(1));
	uimem.m_MemoryFormat = MEM_FORMAT_SHORT_HEX;
	EXPECT_TRUE("614d  626d  2d61  " == uimem.GetCurrentData(number_of_columns_to_be_tested));

	EXPECT_TRUE(mem.CycleMemoryFormat(1));
	uimem.m_MemoryFormat = MEM_FORMAT_SHORT;
	EXPECT_TRUE(" 24909   25197   11617  " == uimem.GetCurrentData(number_of_columns_to_be_tested));

	EXPECT_TRUE(mem.CycleMemoryFormat(1));
	uimem.m_MemoryFormat = MEM_FORMAT_BYTE;
	EXPECT_TRUE(0 == stricmp("4d 61 6d  Ma",uimem.GetCurrentData(number_of_columns_to_be_tested + 1)));

	// Resize and Move
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());

}


void CmemIDETest::PgUpDownCtrlHomeEnd(void)
{
	LOGTESTHEADER("PgUpDownCtrlHomeEnd");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();
	
	EXPECT_TRUE(mem.Enable());
	EXPECT_TRUE(mem.MemoryDataIs("chJustChar", chJustChar));	
	DoDifferentKeysInMemoryWindow();

	EXPECT_TRUE(mem.MemoryDataIs("uchJustUnsignedChar", uchJustUnsignedChar));	
	DoDifferentKeysInMemoryWindow();

	EXPECT_TRUE(mem.MemoryDataIs("nsJustShort", nsJustShort));	
	DoDifferentKeysInMemoryWindow();

	EXPECT_TRUE(mem.MemoryDataIs("unsJustUnsignedShort", unsJustUnsignedShort));	
	DoDifferentKeysInMemoryWindow();

	EXPECT_TRUE(mem.MemoryDataIs("nJustInt", nJustInt));	
	DoDifferentKeysInMemoryWindow();

	EXPECT_TRUE(mem.MemoryDataIs("unJustUnsignedInt", unJustUnsignedInt));	
	DoDifferentKeysInMemoryWindow();

	EXPECT_TRUE(mem.MemoryDataIs("lJustLongInt", lJustLongInt));	
	DoDifferentKeysInMemoryWindow();

	EXPECT_TRUE(mem.MemoryDataIs("ulJustUnsignedLongInt", ulJustUnsignedLongInt));	
	DoDifferentKeysInMemoryWindow();

	EXPECT_TRUE(mem.MemoryDataIs("fJustFloat", fJustFloat));	
	DoDifferentKeysInMemoryWindow();

	EXPECT_TRUE(mem.MemoryDataIs("dJustDouble", dJustDouble));	
	DoDifferentKeysInMemoryWindow();

	EXPECT_TRUE(mem.MemoryDataIs("dlJustLongDouble", dlJustLongDouble));	
	DoDifferentKeysInMemoryWindow();

	EXPECT_TRUE(mem.MemoryDataIs("sfJustSixtyFourInt", sfJustSixtyFourInt));	
	DoDifferentKeysInMemoryWindow();

	EXPECT_TRUE(mem.MemoryDataIs("sfJustSixtyFourUnsignedInt", sfJustSixtyFourUnsignedInt));	
	DoDifferentKeysInMemoryWindow();

	// Resize and Move
	// TODO: (dklem 11/03/98) Uncomment the following line when #7985 is fixed
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());

}

void CmemIDETest::DoDifferentKeysInMemoryWindow(void)
{
	CString csInitialAddress, csNewAddress, csNewAddress1;

	csInitialAddress = uimem.GetCurrentAddress();
	
	// Check PhUp and PgDown
	MST.DoKeys("{PGUP}");
	csNewAddress = uimem.GetCurrentAddress();
	EXPECT_TRUE(csNewAddress < csInitialAddress);

	MST.DoKeys("{PGDN}");
	csNewAddress = uimem.GetCurrentAddress();
	EXPECT_TRUE(csNewAddress == csInitialAddress);

	MST.DoKeys("{PGDN}");
	csNewAddress = uimem.GetCurrentAddress();
	EXPECT_TRUE(csNewAddress > csInitialAddress);

	MST.DoKeys("{PGUP}");
	csNewAddress = uimem.GetCurrentAddress();
	EXPECT_TRUE(csNewAddress == csInitialAddress);

	// Check Ctrl+End and Ctrl+Home
	MST.DoKeys("^{END}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress);
	EXPECT_TRUE(csNewAddress > csInitialAddress);

	MST.DoKeys("^{HOME}");
	csNewAddress = uimem.GetCurrentAddress();
	EXPECT_TRUE(csNewAddress == csInitialAddress);

	// Check Arrows Up and Down
	MST.DoKeys("{HOME}{UP}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress);
	EXPECT_TRUE(csNewAddress < csInitialAddress);

	MST.DoKeys("{HOME}{UP}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress1);
	EXPECT_TRUE(csNewAddress1 < csNewAddress);

	MST.DoKeys("{HOME}{DOWN}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress1);
	EXPECT_TRUE(csNewAddress1 == csNewAddress);

	MST.DoKeys("{HOME}{DOWN}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress1);
	EXPECT_TRUE(csNewAddress1 == csInitialAddress);

	MST.DoKeys("{HOME}{DOWN}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress);
	EXPECT_TRUE(csNewAddress > csInitialAddress);

	MST.DoKeys("{HOME}{DOWN}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress1);
	EXPECT_TRUE(csNewAddress1 > csNewAddress);

	MST.DoKeys("{HOME}{UP}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress1);
	EXPECT_TRUE(csNewAddress1 == csNewAddress);

	MST.DoKeys("{HOME}{UP}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress1);
	EXPECT_TRUE(csNewAddress1 == csInitialAddress);

	// Resize and Move
	// TODO: (dklem 11/03/98) Uncomment the following line when #7985 is fixed
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());

}

void CmemIDETest::VerifyDockingView(void)
{
	LOGTESTHEADER("VerifyDockingView");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();

	EXPECT_TRUE(uimem.EnableDockingView(FALSE));
	EXPECT_TRUE(!uimem.IsDockingViewEnabled());
	// TODO: (dklem 09/08/98) Uncomment the following 1 line when #6346 gets fixed
	// The bug #6346 is Memory leak while resizing Memory window.  This leak is not that bad in the Release version
	// Try to uncomment the next line and run the tests againts the Retail version when #7982 and #7985 are fixed. #7982 Fixed int 8307.0
	TestResizeMoveWindow(FALSE, TRUE);	

	EXPECT_TRUE(uimem.EnableDockingView(TRUE));
	EXPECT_TRUE(uimem.IsDockingViewEnabled());
	// TODO: (dklem 09/08/98) Uncomment the following 1 line when #6346 gets fixed
	// The bug #6346 is Memory leak while resizing Memory window.  This leak is not that bad in the Release version
	// Try to uncomment the next line and run the tests againts the Retail version when #7982 and #7985 are fixed. #7982 Fixed int 8307.0
	TestResizeMoveWindow(TRUE, TRUE);	

}

void CmemIDETest::VerifyEditing(void)
{
	LOGTESTHEADER("VerifyEditing");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();

	uimem.Activate();

	EXPECT_TRUE(mem.MemoryDataIs("sfJustSixtyFourUnsignedInt", sfJustSixtyFourUnsignedInt));	
	CString csInitialAddress = uimem.GetCurrentAddress();

// TODO: (dklem 09/02/98) Uncomment the following commented portion when #5440 gets fixed. Fixed in 8323.0

	// Check deleting address
	//MST.DoKeys("^{HOME}");
	MST.DoKeys("{HOME}");
	MST.DoKeys("{DEL 2}");
	MST.DoKeys("^+{RIGHT}");
	MST.DoKeys("{DEL}");

	// Check deleting data
	//MST.DoKeys("^{HOME}");
	MST.DoKeys("{HOME}");
	MST.DoKeys("{TAB}");
	MST.DoKeys("{DEL}");
	MST.DoKeys("^+{RIGHT}");
	MST.DoKeys("{DEL}");

	//MST.DoKeys("^{HOME}");
	MST.DoKeys("{HOME}");
	MST.DoKeys("{TAB}");
	MST.DoKeys("^+{RIGHT}");
	MST.DoKeys("{DEL}");

	// Data and address should not change
	EXPECT_TRUE(csInitialAddress == uimem.GetCurrentAddress());
	EXPECT_TRUE(mem.MemoryDataIs("sfJustSixtyFourUnsignedInt", sfJustSixtyFourUnsignedInt));	

	if(csInitialAddress != "12345678")
		clipboard.SetText("12345678");
	else
		clipboard.SetText("32154678");

	// Check pasting address
	//MST.DoKeys("^{HOME}");
	MST.DoKeys("{HOME}");
	MST.DoKeys("^+{RIGHT}");
	MST.DoKeys("^V");

	// Check pasting data
	//MST.DoKeys("^{HOME}");
	MST.DoKeys("{HOME}");
	MST.DoKeys("{TAB}");
	MST.DoKeys("^+{RIGHT}");
	MST.DoKeys("^V");

	// Data and address should not change
	EXPECT_TRUE(csInitialAddress == uimem.GetCurrentAddress());
	EXPECT_TRUE(mem.MemoryDataIs("sfJustSixtyFourUnsignedInt", sfJustSixtyFourUnsignedInt));	

	// Resize and Move
	// TODO: (dklem 11/04/98) Uncomment the following line when #8915 is fixed. 
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());

}

void CmemIDETest::MinimalTestResizeMoveWindow()
{

	BOOL bInitiallyMaximized;
	// TODO: (dklem 11/11/98) enable this test by removing the following 1 line when #6346 is fixed
	// Set HKLM\Software\Microsoft\DevStudio\6.1\NoSafeDup to DWORD(1) to turn it off.  (Debug only).

	// TODO: (dklem 09/08/98) Uncomment the following 4 lines when #6346 gets fixed
	// The bug #6346 is Memory leak while resizing Memory window.  This leak is not that bad in the Release version
	// Try to uncomment the next 4 lines and run the tests againts the Retail version when #7982 and #7985 are fixed. #7982 Fixed int 8307.0
	TestResizeMoveWindow(TRUE, FALSE);
	uimem.ToggleDockingView();

	uimem.Activate();
	HWND hwnd = uimem.HWnd();

	if(IsZoomed(hwnd))
	{
		bInitiallyMaximized = TRUE;
		ShowWindow(hwnd, SW_RESTORE);
	}
	else 
		bInitiallyMaximized = FALSE;

	TestResizeMoveWindow(FALSE, FALSE);
	uimem.ToggleDockingView();

	// Restore the MEM window before turning Docking View on
	if(bInitiallyMaximized)
		ShowWindow(hwnd, SW_MAXIMIZE);
}

void CmemIDETest::TestResizeMoveWindow(BOOL bIsDocked, BOOL bFullTest)
{
	int nPositionMoved;
	uimem.Activate();

	BOOL DragFullWindows = TRUE;
	EXPECT_TRUE(GetDragFullWindows(&DragFullWindows));

	// Try minimum hor and ver sizes
	// TODO: (dklem 09/04/98) Uncomment the following 2 lines when #6246 gets fixed
	nPositionMoved = uimem. ResizeWindow(bIsDocked, SLeft, DRight, -1, DragFullWindows);
	uimem.ResizeWindow(bIsDocked, SLeft, DLeft, nPositionMoved, DragFullWindows);

	nPositionMoved = uimem.ResizeWindow(bIsDocked, SBottom, DUp, -1, DragFullWindows);
	uimem.ResizeWindow(bIsDocked, SBottom, DDown, nPositionMoved, DragFullWindows);

	// Move the window
	nPositionMoved = uimem.MoveWindow(bIsDocked, DRight, 20, DragFullWindows);
	nPositionMoved = uimem.MoveWindow(bIsDocked, DDown, 20, DragFullWindows);
	nPositionMoved = uimem.MoveWindow(bIsDocked, DLeft, 20, DragFullWindows);
	nPositionMoved = uimem.MoveWindow(bIsDocked, DUp, 20, DragFullWindows);

	if(!bFullTest) return;

	// Try to go beyond screen borders
	nPositionMoved = uimem.ResizeWindow(bIsDocked, SLeft, DLeft, -1, DragFullWindows);
	if(!DragFullWindows)
	{
		EXPECT_TRUE(uimem.ToggleDockingView());
		EXPECT_TRUE(uimem.ToggleDockingView());
		uimem.Activate();
	}
	uimem.ResizeWindow(bIsDocked, SLeft, DRight, nPositionMoved, DragFullWindows);

	nPositionMoved = uimem.ResizeWindow(bIsDocked, SRight, DRight, -1, DragFullWindows);
	if(!DragFullWindows)
	{
		EXPECT_TRUE(uimem.ToggleDockingView());
		EXPECT_TRUE(uimem.ToggleDockingView());
		uimem.Activate();
	}
	uimem.ResizeWindow(bIsDocked, SRight, DLeft, nPositionMoved, DragFullWindows);

	nPositionMoved = uimem.ResizeWindow(bIsDocked, SBottom, DDown, -1, DragFullWindows);
	if(!DragFullWindows)
	{
		EXPECT_TRUE(uimem.ToggleDockingView());
		EXPECT_TRUE(uimem.ToggleDockingView());
		uimem.Activate();
	}
	uimem.ResizeWindow(bIsDocked, SBottom, DUp, nPositionMoved, DragFullWindows);

	// TODO: (dklem 09/04/98) Uncomment the following 2 lines when #6245 gets fixed. Fixed int 8307.0
	nPositionMoved = uimem.ResizeWindow(bIsDocked, STop, DUp, -1, DragFullWindows);
	if(!DragFullWindows)
	{
		EXPECT_TRUE(uimem.ToggleDockingView());
		EXPECT_TRUE(uimem.ToggleDockingView());
		uimem.Activate();
	}
	uimem.ResizeWindow(bIsDocked, STop, DDown, nPositionMoved, DragFullWindows);

	// I like to move it move it
	nPositionMoved = uimem.MoveWindow(bIsDocked, DRight, -1, DragFullWindows);
	// If we move it to far, the title bar is not available, we need to reactivate memory window
	uimem.ToggleDockingView();
	uimem.ToggleDockingView();
	uimem.Activate();
	uimem.MoveWindow(bIsDocked, DLeft, nPositionMoved, DragFullWindows);

	nPositionMoved = uimem.MoveWindow(bIsDocked, DLeft, -1, DragFullWindows);
	uimem.ToggleDockingView();
	uimem.ToggleDockingView();
	uimem.Activate();
	uimem.MoveWindow(bIsDocked, DRight, nPositionMoved, DragFullWindows);

	nPositionMoved = uimem.MoveWindow(bIsDocked, DDown, -1, DragFullWindows);
	uimem.ToggleDockingView();
	uimem.ToggleDockingView();
	uimem.Activate();
	uimem.MoveWindow(bIsDocked, DUp, nPositionMoved, DragFullWindows);

	// TODO: (dklem 09/04/98) Uncomment the following 5 lines when #6261 gets fixed
	nPositionMoved = uimem.MoveWindow(bIsDocked, DUp, -1, DragFullWindows);
	uimem.ToggleDockingView();
	uimem.ToggleDockingView();
	uimem.Activate();
	uimem.MoveWindow(bIsDocked, DDown, nPositionMoved, DragFullWindows);
}


//	added by dverma for VCPP
void CmemIDETest::VerifyRegArray(CString Arr[],int Num_items)
{
	unsigned __int64 *data = new unsigned __int64;

	mem.Enable();

	for (int count = 0; count< Num_items; count++)
		mem.GetMemoryData(Arr[count], data, MEM_FORMAT_INT64_UNSIGNED, 1);

	mem.Disable();
}

//	added by dverma for VCPP
void CmemIDETest::VerifyVCPPReg(void)
{
	LOG->RecordInfo("Verifying Processor Pack Registers");
	
	CString MMXRegs[] = {"MM0","MM1","MM2","MM3","MM4","MM5","MM6","MM7"};
	CString MMXijRegs[] = {	"MM00","MM10","MM20","MM30","MM40","MM50","MM60","MM70",
							"MM01","MM11","MM21","MM31","MM41","MM51","MM61","MM71"};

	CString XMMRegs[] = {"XMM0","XMM1","XMM2","XMM3","XMM4","XMM5","XMM6","XMM7"};
	CString XMMijRegs[] = {	"XMM00","XMM01","XMM02","XMM03", "XMM10","XMM11","XMM12","XMM13",
							"XMM20","XMM21","XMM22","XMM23", "XMM30","XMM31","XMM32","XMM33",
							"XMM40","XMM41","XMM42","XMM43", "XMM50","XMM51","XMM52","XMM53",
							"XMM60","XMM61","XMM62","XMM63", "XMM70","XMM71","XMM72","XMM73" };

	CString XMM0DRegs[] = {	"XMM0DL","XMM0DH","XMM1DL","XMM1DH","XMM2DL","XMM2DH",
							"XMM3DL","XMM3DH","XMM4DL","XMM4DH","XMM5DL","XMM5DH",
							"XMM6DL","XMM6DH","XMM7DL","XMM7DH" };

	CString XMM0IRegs[] = {	"XMM0IL","XMM0IH","XMM1IL","XMM1IH","XMM2IL","XMM2IH",
							"XMM3IL","XMM3IH","XMM4IL","XMM4IH","XMM5IL","XMM5IH",
							"XMM6IL","XMM6IH","XMM7IL","XMM7IH" };

	
	VerifyRegArray(MMXRegs,8);
		
	//	3dnow system
	if (CMDLINE->GetBooleanValue("k6",FALSE)||CMDLINE->GetBooleanValue("k7",FALSE))
	{
		VerifyRegArray(MMXijRegs,16);
	}

	//	P3 system
	if (CMDLINE->GetBooleanValue("kni",FALSE)||CMDLINE->GetBooleanValue("wni",FALSE))
	{
		VerifyRegArray(XMMRegs,8);
		VerifyRegArray(XMMijRegs,32);
		VerifyRegArray(XMM0DRegs,16);
		VerifyRegArray(XMM0IRegs,16);
	}

	LOG->RecordInfo("Processor Pack Verification Successful");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\mem\memsub.h ===
///////////////////////////////////////////////////////////////////////////////
//	memsub.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CmemSubSuite class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CmemSubSuite class

class CmemSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CmemSubSuite)
//	CmemSubSuite() { m_strName = "TestWizard Generated script"; m_strOwner = "VCBU QA"; }


	DECLARE_TESTLIST()
protected:
	void CleanUp(void);
	void SetUp(BOOL bCleanUp);
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\namespce\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\namespce\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\mem\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"
//#include "..\src\support\dbg\cowatch.h"
//#include "..\src\support\dbg\coauto.h"



#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\namespce\namesub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CNameSpceSubSuite class
//

#include "stdafx.h"
#include "Namesub.h"
#include "afxdllx.h"
#include "..\cleanup.h"

#include "Namecase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CNameSpceSubSuite

IMPLEMENT_SUBSUITE(CNameSpceSubSuite, CIDESubSuite, "Namespace", "VCQA Debugger")

BEGIN_TESTLIST(CNameSpceSubSuite)
	TEST(CNameSpceIDETest, RUN)
END_TESTLIST()

void CNameSpceSubSuite::CleanUp(void)
	{
	::CleanUp("namspace");
	}

///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\namespce\namecase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	Namecase.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script.	 

#include "stdafx.h"
#include "Namecase.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
										   
IMPLEMENT_TEST(CNameSpceIDETest, CDebugTestSet, "Namespace", -1, CNameSpceSubSuite)

												 
void CNameSpceIDETest::PreRun(void)
	{
	// call the base class
	CTest::PreRun();
	}


void CNameSpceIDETest::Run(void)
	
	{
	/******************
	 * INITIALIZATION *
	 ******************/
	if(!InitProject("namspace\\namspace"))
	{
		m_pLog->RecordInfo("ERROR: could not init namspace project");
		return;
	}

	// this is the initial state each test expects.
	//	  - step passed prolog of WinMain().
	if(!dbg.StepOver(2))
	{
		m_pLog->RecordInfo("ERROR: could not step passed WinMain()'s prolog");
		return;
	}

	/*********
	 * TESTS *
	 *********/
	EvaluateNamespaceFuncOutsideNamespace();
	EvaluateNamespaceVarOutsideNamespace();
	EvaluateNestedNamespaceVarOutsideNamespace();
	EvaluateNamespaceMemberInsideNamespace();
	GoToLocationBpOnNamespaceFunc();
	GoToDataBpOnNamespaceVar();
	NavigateMemoryWndToNamespaceVar();
	VerifyReturnValueInfoIncludesNamespace();
	NavigateStackOutOfAndBackIntoNamespaceFunc();
	ImplicitlyReferenceNamespaceMemberAfterUsingDirective();
	ImplicitlyReferenceNamespaceMemberInsideNamespace();
	} 


/************************************************************************
 * evaluate explicitly referenced namespace variable outside namespace. *
 ************************************************************************/
void CNameSpceIDETest::EvaluateNamespaceVarOutsideNamespace(void)
	{
	LogTestHeader("EvaluateNamespaceVarOutsideNamespace");
	EXPECT_TRUE(cxx.ExpressionValueIs("n1::i", 1));
	}


/******************************************************
 * evaluate explicitly referenced namespace function. *
 ******************************************************/
void CNameSpceIDETest::EvaluateNamespaceFuncOutsideNamespace(void)
	{
	LogTestHeader("EvaluateNamespaceFuncOutsideNamespace");
	EXPECT_TRUE(cxx.ExpressionValueIs("n1::func()", "<void>"));
	}


/*************************************************************
 * evaluate explicitly referenced nested namespace variable. *
 *************************************************************/
void CNameSpceIDETest::EvaluateNestedNamespaceVarOutsideNamespace(void)
	{
	LogTestHeader("EvaluateNestedNamespaceVarOutsideNamespace");
	EXPECT_TRUE(cxx.ExpressionValueIs("n1::n2::i", 2));
	}


/*********************************************************************
 * evaluate explicitly referenced namespace member inside namespace. *
 *********************************************************************/
void CNameSpceIDETest::EvaluateNamespaceMemberInsideNamespace(void)
	{
	LogTestHeader("EvaluateNamespaceMemberInsideNamespace");
	// step into namespace function (n1::func()).
	EXPECT_TRUE(src.Find("func();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(cxx.ExpressionValueIs("n1::i", 1));
	// restore stack to initial state.
	EXPECT_TRUE(dbg.StepOut());
	}


/********************************************************************************
 * set location bp on explicitly referenced namespace function, go, verify hit. *
 ********************************************************************************/
void CNameSpceIDETest::GoToLocationBpOnNamespaceFunc(void)
	
	{
	LogTestHeader("GoToLocationBpOnNamespaceFunc");
	EXPECT_TRUE(dbg.Restart());
	EXPECT_VALIDBP(bps.SetBreakpoint("n1::func"));

	if(GetUserTargetPlatforms() == PLATFORM_WIN32_MIPS || GetUserTargetPlatforms() == PLATFORM_WIN32_ALPHA)	
		dbg.Go();
	else
		{EXPECT_TRUE(dbg.Go(NULL, "first line of n1::func()"));}
	
	// restore stack and bp list to initial state.
	EXPECT_TRUE(dbg.StepOut());
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	}


/****************************************************************************
 * set data bp on explicitly referenced namespace variable, go, verify hit. *
 ****************************************************************************/
void CNameSpceIDETest::GoToDataBpOnNamespaceVar(void)
	{
	LogTestHeader("GoToDataBpOnNamespaceVar");
	EXPECT_TRUE(dbg.Restart());
	EXPECT_VALIDBP(bps.SetBreakOnExpr("n1::j", COBP_TYPE_IF_EXP_CHANGED));
	EXPECT_TRUE(dbg.Go(NULL, "line after n1::j changed"));
	// restore bp list to initial state.
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	}


/***********************************************************************
 * navigate memory window to explicitly referenced namespace variable. *
 ***********************************************************************/
void CNameSpceIDETest::NavigateMemoryWndToNamespaceVar(void)
	{
	LogTestHeader("NavigateMemoryWndToNamespaceVar");
	EXPECT_TRUE(mem.MemoryDataIs("n1::i", 1));
	RestoreFocusToSrcWnd();
	}


/**************************************************************************************
 * verify return value info includes namespace when stepping over namespace function. *
 **************************************************************************************/
void CNameSpceIDETest::VerifyReturnValueInfoIncludesNamespace(void)
	{
	LogTestHeader("VerifyReturnValueInfoIncludesNamespace");
	// step over namespace function (n1::func()).
	EXPECT_TRUE(src.Find("func();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.SetPane(PANE_AUTO));
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, ROW_LAST, 1));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "void", "n1::func returned", "<void>");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/******************************************************
 * navigate stack into and out of namespace function. *
 ******************************************************/
/***********************************************************************
 * verify stack window includes namespace when for namespace function. *
 ***********************************************************************/
void CNameSpceIDETest::NavigateStackOutOfAndBackIntoNamespaceFunc(void)
	
	{
	LogTestHeader("NavigateStackOutOfAndBackIntoNamespaceFunc");
	
	// step into namespace function (n1::func()).
	EXPECT_TRUE(src.Find("func();"));
	EXPECT_TRUE(dbg.SetNextStatement());

	if(GetUserTargetPlatforms() == PLATFORM_WIN32_MIPS || GetUserTargetPlatforms() == PLATFORM_WIN32_ALPHA)	
		{EXPECT_TRUE(dbg.StepInto(2));}
	else
		{EXPECT_TRUE(dbg.StepInto(3));}

	// navigate to WinMain() and back to namespace function.
	EXPECT_TRUE(stk.NavigateStack(1)>0);
	EXPECT_TRUE(stk.NavigateStack(0)>0);
	EXPECT_TRUE(stk.CurrentFunctionIs("n1::func()"));

	// verify locals pane updated.
	uivar.Activate();
	EXPECT_SUCCESS(uivar.SetPane(PANE_LOCALS));
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "local", "3");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));

	// restore stack to initial state.
	EXPECT_TRUE(dbg.StepOut());
	RestoreFocusToSrcWnd();
	}


/***********************************************************
 * verify debugger doesnt recognize implicitly referenced *
 * namespace member after using directive.                 *
 ***********************************************************/
void CNameSpceIDETest::ImplicitlyReferenceNamespaceMemberAfterUsingDirective(void)
	{
	LogTestHeader("ImplicitlyReferenceNamespaceMemberAfterUsingDirective");
	// should evaluate ::i instead of n1::i.
	EXPECT_TRUE(cxx.ExpressionValueIs("i", 0));
	}


/**********************************************************************************************
 * verify debugger doesnt recognize implicitly referenced namespace member inside namespace. *
 **********************************************************************************************/
void CNameSpceIDETest::ImplicitlyReferenceNamespaceMemberInsideNamespace(void)
	{
	LogTestHeader("ImplicitlyReferenceNamespaceMemberInsideNamespace");
	// step into namespace function (n1::func()).	
	EXPECT_TRUE(src.Find("func();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());
	// should evaluate ::i instead of n1::i.
	EXPECT_TRUE(cxx.ExpressionValueIs("i", 0));
	// restore stack to initial state.
	EXPECT_TRUE(dbg.StepOut());
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\namespce\namecase.h ===
///////////////////////////////////////////////////////////////////////////////
//	Namecase.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CNameSpceIDETest Class
//

#ifndef __Namecase_H__
#define __Namecase_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\dbgset.h"
#include "namesub.h"

///////////////////////////////////////////////////////////////////////////////
//	CNameSpceIDETest class

class CNameSpceIDETest : public CDebugTestSet
{
	DECLARE_TEST(CNameSpceIDETest, CNameSpceSubSuite)

	// Operations
	public:
		virtual void PreRun(void);
		virtual void Run(void);

	// Test cases
	private:
		void EvaluateNamespaceVarOutsideNamespace(void);
		void EvaluateNamespaceFuncOutsideNamespace(void);
		void EvaluateNestedNamespaceVarOutsideNamespace(void);
		void EvaluateNamespaceMemberInsideNamespace(void);
		void GoToLocationBpOnNamespaceFunc(void);
		void GoToDataBpOnNamespaceVar(void);
		void NavigateMemoryWndToNamespaceVar(void);
		void VerifyReturnValueInfoIncludesNamespace(void);
		void NavigateStackOutOfAndBackIntoNamespaceFunc(void);
		void ImplicitlyReferenceNamespaceMemberAfterUsingDirective(void);
		void ImplicitlyReferenceNamespaceMemberInsideNamespace(void);

	// Data
	private:
		EXPR_INFO expr_info_actual[4], expr_info_expected[4];
	};

#endif //__Namecase_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\nlg\nlgcase.h ===
///////////////////////////////////////////////////////////////////////////////
//	NLGcase.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CNLGIDETest Class
//

#ifndef __NLGcase_H__
#define __NLGcase_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\dbgset.h"
#include "nlgsub.h"

///////////////////////////////////////////////////////////////////////////////
//	CNLGIDETest class

class CNLGIDETest : public CDebugTestSet
{
	DECLARE_TEST(CNLGIDETest, CNLGSubSuite)

// Attributes
public:

// Operations
public:
	virtual void PreRun(void);
	virtual void Run();

	BOOL IsUnhandledException(CString except_text);

// Test Cases
protected:
	// EH
	BOOL EH_StepOverThrow( );
	BOOL EH_TryNoThrow( );
	BOOL EH_StepOverTry_StepOverCatch( );
	BOOL EH_StepOverReThrow( );
	BOOL EH_BreakInCatch( );
	BOOL EH_StepOverThrowFunc( );
	BOOL EH_StepOutThrowFunc( );
	BOOL EH_StepToCursorOverThrowIntoCatch( );
	BOOL EH_BreakInCtor( );
	BOOL EH_BreakInDtor( );

	// SEH
	BOOL SEH_TryNoException( );
	BOOL SEH_ExceptionContinueExecution( );
	BOOL SEH_ExceptionExecuteHandler( );
	BOOL SEH_TryFinallyNoException( );
	BOOL SEH_TryFinallyException( );
	BOOL SEH_BreakInFilter( );
	BOOL SEH_StepOver__try( );
	BOOL SEH_BreakInExcept( );
	BOOL SEH_BreakInFinally( );
	BOOL SEH_StepToCursorOver__tryIntoExcept( );
	BOOL SEH_StepToCursorOver__tryIntoFinally( );

	// Setjmp/Longjmp
	BOOL LJMP_StepOverLongJmp( );
	BOOL LJMP_StepOverFuncWithLongJmp( );
	BOOL LJMP_StepOutFuncWithLongJmp( );

// utilities

};

#endif //__NLGcase_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\namespce\namesub.h ===
///////////////////////////////////////////////////////////////////////////////
//	Namesub.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CNameSpceSubSuite class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CNameSpceSubSuite class

class CNameSpceSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CNameSpceSubSuite)
	DECLARE_TESTLIST()
protected:
	void CleanUp(void);
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\nlg\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\nlg\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\nlg\nlgcase2.h ===
///////////////////////////////////////////////////////////////////////////////
//	NLGcase.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CNLGIDETest Class
//

#ifndef __NLGcase2_H__
#define __NLGcase2_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\dbgset.h"
#include "nlgsub.h"

///////////////////////////////////////////////////////////////////////////////
//	CNLGIDETest class

class CNLG2IDETest : public CDebugTestSet
{
	DECLARE_TEST(CNLG2IDETest, CNLGSubSuite)

// Attributes
public:

// Operations
public:
	virtual void PreRun(void);
	virtual void Run();

	BOOL IsUnhandledException(CString except_text);

// Test Cases
protected:
	// EH
	BOOL EH_StepIntoThrow( );
	BOOL EH_StepIntoReThrow( );
	BOOL EH_CatchInDLL( );
	BOOL EH_CatchFromDLL( );
	BOOL EH_ReThrowInCtor( );

	// SEH
	BOOL SEH_ExceptionContinueSearch( );
	BOOL SEH_StepIntoRaiseException( );

	// Setjmp/Longjmp
	BOOL LJMP_StepIntoLongJmp( );

// utilities

};

#endif //__NLGcase_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\nlg\nlgcase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	NLGcase.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "NLGcase.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
											   
IMPLEMENT_TEST(CNLGIDETest, CDebugTestSet, "NonLocalGoto Base", -1, CNLGSubSuite)
												 
void CNLGIDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

void CNLGIDETest::Run()
{	 
	XSAFETY;
	SetProject("nlg\\nlg");
	XSAFETY;

	// EH
	EH_StepOverThrow( );
	XSAFETY;
	EH_TryNoThrow( );
	XSAFETY;
	EH_StepOverTry_StepOverCatch( );
	XSAFETY;

//if( GetSystem() != SYSTEM_CHICAGO )  // bug #10127
/* bug # 9231  postponed till after V50
	EH_StepOverReThrow( );
	XSAFETY;
*/

	EH_BreakInCatch( );
	XSAFETY;
	EH_StepOverThrowFunc( );
	XSAFETY;
	EH_StepOutThrowFunc( );
	XSAFETY;
	EH_StepToCursorOverThrowIntoCatch( );
	XSAFETY;
	EH_BreakInCtor( );
	XSAFETY;
	EH_BreakInDtor( );
	XSAFETY;

	if( GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
	// Setjmp/Longjmp
	LJMP_StepOverLongJmp( );
	XSAFETY;
	LJMP_StepOverFuncWithLongJmp( );
	XSAFETY;
	LJMP_StepOutFuncWithLongJmp( );
	XSAFETY;
	
        
	// SEH
	SetProject("seh01\\seh01");
	XSAFETY;
	SEH_TryNoException( );
	XSAFETY;
	SEH_ExceptionContinueExecution( );
	XSAFETY;
	SEH_ExceptionExecuteHandler( );
	XSAFETY;

	SEH_TryFinallyNoException( );
	XSAFETY;

	SEH_TryFinallyException( ); 
	XSAFETY;
 
/* bug # 9258 postponed till after V50
	SEH_BreakInFilter( );
	XSAFETY;
*/
	SEH_StepOver__try( );
	XSAFETY;
	SEH_BreakInExcept( );
	XSAFETY;
	SEH_BreakInFinally( );
	XSAFETY;
	SEH_StepToCursorOver__tryIntoExcept( );
	XSAFETY;
	SEH_StepToCursorOver__tryIntoFinally( );
	XSAFETY;
	}

}
 
///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////


// EH

BOOL CNLGIDETest::EH_StepOverThrow( )
{
	LogTestHeader( "EH_StepOverThrow" );
   	bps.ClearAllBreakpoints();
 	bps.SetBreakpoint("Case1");
	dbg.Go("Case1");
	dbg.SetSteppingMode(SRC);
	MST.DoKeys("{down 3}");

	EXPECT_TRUE( dbg.StepToCursor(0,NULL,"throw t;")	 )	;

	EXPECT_TRUE(dbg.StepOver(1, NULL, "catch( ... ) // after Case1"));

	if( GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
		EXPECT_TRUE(dbg.VerifyNotification("First-Chance Exception in nlg.exe", 1, 20, TRUE) &&
					dbg.VerifyNotification("Microsoft C++ Exception", 1, 20, TRUE) );
	}
	dbg.StopDebugging();
	return TRUE;
}


BOOL CNLGIDETest::EH_TryNoThrow( )
{
 	LogTestHeader( "EH_TryNoThrow" );
  	bps.ClearAllBreakpoints();
	bps.SetBreakpoint("Case2");
	dbg.Go("Case2");
	int nSteps;

	switch(GetUserTargetPlatforms())
	{
		case PLATFORM_WIN32_X86:
			// processor pack code-gen difference.
			if(CMDLINE->GetBooleanValue("PP", FALSE))
				nSteps = 3;
			else
				nSteps = 4;
			break;
        case PLATFORM_WIN32_ALPHA:
            nSteps = 4;
            break;
	}

	EXPECT_TRUE( dbg.StepOver(nSteps, NULL, "++counter; // Should execute") );
	EXPECT_TRUE( dbg.StepOver(1, NULL, "}") );
	
	return TRUE;
}

BOOL CNLGIDETest::EH_StepOverTry_StepOverCatch( )
{
 	LogTestHeader( "EH_StepOverTry_StepOverCatch" );
  	bps.ClearAllBreakpoints();
   	bps.SetBreakpoint("Case4");
	dbg.Go("Case4");
	dbg.SetSteppingMode(SRC);
	EXPECT_TRUE(dbg.StepOver(1, NULL, "try { ++counter; ThrowObject t(4); throw t; }"));

	EXPECT_TRUE(dbg.StepOver(1, NULL, "catch( ThrowObject c ) { ++counter; /* Should execute */ }"));
	if( GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
		EXPECT_TRUE( dbg.VerifyNotification("Microsoft C++ Exception", 3, 20, TRUE) );
		dbg.SetSteppingMode(SRC);
		MST.WFndWnd("eh01.cpp", FW_NOCASE | FW_FOCUS | FW_PART);
	}

	// processor pack code-gen difference.
	if(CMDLINE->GetBooleanValue("PP", FALSE))
		{EXPECT_TRUE(dbg.StepOver());}

	EXPECT_TRUE(dbg.StepOver(1, NULL, "++counter; // Should execute"));

	dbg.StopDebugging();
  	return TRUE;
}


BOOL CNLGIDETest::EH_StepOverReThrow( )
{
 	LogTestHeader( "EH_StepOverReThrow" );
  	bps.ClearAllBreakpoints();
 	bps.SetBreakpoint("Case6");
	dbg.Go("Case6");
	dbg.SetSteppingMode(SRC);
	int nSteps = 6;
	EXPECT_TRUE( dbg.StepOver(nSteps, NULL, "throw t;") );
	EXPECT_TRUE(dbg.StepOver(3, NULL, "throw c;"));

/*	if( GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{ 
		EXPECT_TRUE(dbg.StepOver(1, NULL, NULL, NULL, 0));
	
		if( WaitMsgBoxText("Directory does not exist", 10))
		{
			MST.WButtonClick( "OK" );
			while(MST.WFndWndC("Directory does not exist", "Static", FW_PART));
		}
		if (MST.WFndWnd("Browse for Folder", FW_NOCASE | FW_FOCUS | FW_PART)
			|| MST.WFndWnd("Find Source", FW_NOCASE | FW_FOCUS | FW_PART))
				MST.WButtonClick( "Cancel" );
	
		EXPECT_TRUE( stk.CurrentFunctionIs( "CallCatchBlock" ) );
		
		EXPECT_TRUE(dbg.StepOut(1, NULL, NULL, NULL, 0) );
		if( WaitMsgBoxText("Directory does not exist", 10))
		{
			MST.WButtonClick( "OK" );
			while(MST.WFndWndC("Directory does not exist", "Static", FW_PART));
		}
		if (MST.WFndWnd("Browse for Folder", FW_NOCASE | FW_FOCUS | FW_PART)
			|| MST.WFndWnd("Find Source", FW_NOCASE | FW_FOCUS | FW_PART))
				MST.WButtonClick( "Cancel" );
		int i;
		for(i = 0; i< 5; i++)
		{ 
			if (MST.WFndWndWait("Browse for Folder", FW_NOCASE | FW_FOCUS | FW_PART, 1)
				|| MST.WFndWndWait("Find Source", FW_NOCASE | FW_FOCUS | FW_PART, 1))
					MST.WButtonClick( "Cancel" );
		}

		EXPECT_TRUE(dbg.StepOut(1, NULL, NULL, NULL, 0) );

		for(i = 0; i< 5; i++)	// WinslowF - to handle multiple dlg boxes on NT
		{ 
			if (MST.WFndWndWait("Browse for Folder", FW_NOCASE | FW_FOCUS | FW_PART, 1)
				|| MST.WFndWndWait("Find Source", FW_NOCASE | FW_FOCUS | FW_PART, 1))
					MST.WButtonClick( "Cancel" );
		}

/* Doesn't work for Win95
		EXPECT_TRUE(dbg.StepOut(3, NULL, NULL, NULL, 0) && 
				dbg.SetSteppingMode(SRC) && 
				dbg.CurrentLineIs( "catch( ThrowObject o ) {" ) );
*/
/*	 	bps.SetBreakpoint("{,eh01.cpp,}@157");
		dbg.Go(NULL, NULL, NULL, 0);
		dbg.SetSteppingMode(SRC);
		MST.DoKeys("{up}");
		EXPECT_TRUE( dbg.CurrentLineIs( "catch( ThrowObject o ) {" ) );
	}
	else
	{
*/		EXPECT_TRUE(dbg.StepOver(1, NULL, "catch( ThrowObject o ) {"));
//	}

	if( GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
		EXPECT_TRUE(dbg.VerifyNotification("First-Chance Exception in nlg.exe", 5, 20, TRUE));
		EXPECT_TRUE(dbg.VerifyNotification("Microsoft C++ Exception", 6, 20, TRUE) );
		dbg.SetSteppingMode(SRC);
		MST.WFndWnd("eh01.cpp", FW_NOCASE | FW_FOCUS | FW_PART);
	}

//	dbg.StopDebugging();
 	bps.SetBreakpoint("Case7");
	dbg.Go("Case7");

	nSteps = 6;
	EXPECT_TRUE( dbg.StepOver(nSteps, NULL, "throw t;") );

	nSteps = 2;
	EXPECT_TRUE( dbg.StepOver(nSteps, NULL, "throw;") );
	if( GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
		EXPECT_TRUE(dbg.VerifyNotification("First-Chance Exception in nlg.exe", 7, 20, TRUE) );
		dbg.SetSteppingMode(SRC);
		MST.WFndWnd("eh01.cpp", FW_NOCASE | FW_FOCUS | FW_PART);
	}

	EXPECT_TRUE(dbg.StepOver(1, NULL, "catch( ThrowObject o ) {"));
	if( GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
		EXPECT_TRUE(dbg.VerifyNotification("Microsoft C++ Exception", 8, 20, TRUE) );
		dbg.SetSteppingMode(SRC);
	}

	dbg.StopDebugging();
	return TRUE;
}

BOOL CNLGIDETest::EH_BreakInCatch( )
{
 	LogTestHeader( "EH_BreakInCatch" );
	dbg.Restart();
  	bps.ClearAllBreakpoints();
   	bps.SetBreakpoint("{,eh01.cpp,}@20");
   	bps.SetBreakpoint("{,eh01.cpp,}@31");
   	bps.SetBreakpoint("{,eh01.cpp,}@132");
	dbg.SetSteppingMode(SRC);
	EXPECT_TRUE( dbg.Go(NULL, "Case2();") );
	EXPECT_TRUE( dbg.Go(NULL, "Case4();") );
	EXPECT_TRUE( dbg.Go(NULL, "++counter; // Should execute") );

   	bps.ClearAllBreakpoints();

	return TRUE;
}


BOOL CNLGIDETest::EH_StepOverThrowFunc( )
{
 	LogTestHeader( "EH_StepOverThrowFunc" );
    bps.ClearAllBreakpoints();
	dbg.StopDebugging();
  
   	bps.SetBreakpoint("{,eh01.cpp,}@14");	 
	EXPECT_TRUE( dbg.Go(NULL, "Case1();") );

// can't break at catch(){} on MIPS (v-katsuf) 
	EXPECT_TRUE(dbg.StepOver(1, NULL, "catch( ... ) // after Case1"));

   	bps.SetBreakpoint("{,eh01.cpp,}@25");	 
	dbg.SetSteppingMode(SRC);  
	EXPECT_TRUE( dbg.Go(NULL, "Case3();") );

// can't break at catch(){} on MIPS (v-katsuf) 
	EXPECT_TRUE(dbg.StepOver(1, NULL, "catch( ... ){ // after Case3"));

 	bps.SetBreakpoint("{,eh01.cpp,}@31");	 
	dbg.SetSteppingMode(SRC);  
	EXPECT_TRUE( dbg.Go(NULL, "Case4();") );
	EXPECT_TRUE(dbg.StepOver(1, NULL, "++caseNum; // should execute"));

	if( GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
		EXPECT_TRUE(dbg.VerifyNotification("First-Chance Exception in nlg.exe", 3, 20, TRUE) );
	}

   	bps.SetBreakpoint("{,eh01.cpp,}@42");	 
	dbg.SetSteppingMode(SRC);  
	EXPECT_TRUE( dbg.Go(NULL, "Case5();") );
	EXPECT_TRUE(dbg.StepOver(1, NULL, "++caseNum; // should execute"));

   	bps.SetBreakpoint("{,eh01.cpp,}@51");	 
	dbg.SetSteppingMode(SRC);  
	EXPECT_TRUE( dbg.Go(NULL, "Case6();") );
	EXPECT_TRUE(dbg.StepOver(1, NULL, "++caseNum; // should execute"));

   	bps.SetBreakpoint("{,eh01.cpp,}@60");	 // Case7 is in different segment
	dbg.SetSteppingMode(SRC);  
	EXPECT_TRUE( dbg.Go(NULL, "Case7();") );
	EXPECT_TRUE(dbg.StepOver(1, NULL, "++caseNum; // should execute"));
	if( GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
	EXPECT_TRUE(dbg.VerifyNotification("First-Chance Exception in nlg.exe", 7, 20, TRUE) &&
				dbg.VerifyNotification("First-Chance Exception in nlg.exe", 9, 20, TRUE) );
	}

    bps.ClearAllBreakpoints();
	dbg.StopDebugging();

	return TRUE;
}

BOOL CNLGIDETest::EH_StepOutThrowFunc( )
{
 	LogTestHeader( "EH_StepOutThrowFunc" );
  	bps.ClearAllBreakpoints();
 	dbg.Restart();
	dbg.SetSteppingMode(SRC);
	bps.SetBreakpoint("Case1");
	dbg.Go("Case1");
	EXPECT_TRUE(dbg.StepOut(1, NULL, "catch( ... ) // after Case1"));
	if( GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
		EXPECT_TRUE(dbg.VerifyNotification("First-Chance Exception in nlg.exe", 1, 20, TRUE) );
	}

	bps.SetBreakpoint("Case3");
	dbg.SetSteppingMode(SRC);  
	dbg.Go("Case3");
	EXPECT_TRUE(dbg.StepOut(1, NULL, "catch( ... ){ // after Case3"));

	bps.SetBreakpoint("Case5");
	dbg.SetSteppingMode(SRC);  
	dbg.Go("Case5");
if ( GetUserTargetPlatforms() != PLATFORM_WIN32_ALPHA )			//v-katsuf
//	EXPECT_TRUE(dbg.StepOut(1, NULL, "catch( ThrowObject o )")); // This is by design now.
	EXPECT_TRUE(dbg.StepOut(1, NULL, "++caseNum; // should execute")); 

	if( GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
		EXPECT_TRUE(dbg.VerifyNotification("First-Chance Exception in nlg.exe", 4, 20, TRUE) );
		dbg.SetSteppingMode(SRC);  
		MST.WFndWnd("eh01.cpp", FW_NOCASE | FW_FOCUS | FW_PART);
	}
	
	bps.SetBreakpoint("Case6");
	dbg.Go("Case6");
	if(GetUserTargetPlatforms() != PLATFORM_WIN32_ALPHA) // bug #8481
	{
//		EXPECT_TRUE(dbg.StepOut(1, NULL, "catch( ThrowObject c )")); // This is by design now.
	}
	EXPECT_TRUE(dbg.StepOut(1, NULL, "++caseNum; // should execute")); 
	if( GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
		EXPECT_TRUE(dbg.VerifyNotification("First-Chance Exception in nlg.exe", 5, 20, TRUE) );
//		dbg.SetSteppingMode(SRC);  
//		MST.WFndWnd("eh01.cpp", FW_NOCASE | FW_FOCUS | FW_PART);
	}

// To do : now there is a bug in CRT

	bps.ClearAllBreakpoints();
	dbg.StopDebugging();
	return TRUE;
}

BOOL CNLGIDETest::EH_StepToCursorOverThrowIntoCatch( )
{
	LogTestHeader( "EH_StepToCursorOverThrowIntoCatch" );
	bps.ClearAllBreakpoints();
	dbg.StepInto(1, NULL, NULL, NULL, 0); 
	dbg.SetSteppingMode(SRC);  

	CString strSource = "eh01.cpp";
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);   //Review yefims
//	file.Open( m_strProjectDir + "\\" + strSource);   
	
	EXPECT_TRUE( dbg.StepToCursor(19, NULL, "++caseNum;") );

	EXPECT_TRUE( dbg.StepToCursor(31, NULL, "Case4();") );
	if( GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
		EXPECT_TRUE(dbg.VerifyNotification("First-Chance Exception in nlg.exe", 2, 20, TRUE) );
		dbg.SetSteppingMode(SRC);  
		MST.WFndWnd(strSource, FW_NOCASE | FW_FOCUS | FW_PART);
	}

	EXPECT_TRUE( dbg.StepToCursor(108, NULL, "catch( ThrowObject c ) { ++counter;") );
	EXPECT_TRUE( dbg.StepToCursor(132, NULL, "++counter; // Should execute") );
	EXPECT_TRUE( dbg.StepToCursor(150, NULL, "throw c;") );

	EXPECT_TRUE( dbg.StepToCursor(157, NULL, "++counter; // Should execute") );
	if( GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
		EXPECT_TRUE(dbg.VerifyNotification("First-Chance Exception in nlg.exe", 6, 20, TRUE) );
		dbg.SetSteppingMode(SRC);  
		MST.WFndWnd(strSource, FW_NOCASE | FW_FOCUS | FW_PART);
	}

	strSource = "eh02.cpp";
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);   //Review yefims
	EXPECT_TRUE( dbg.StepToCursor(49, NULL, "++counter; // Should execute") );
	if( GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
		EXPECT_TRUE(dbg.VerifyNotification("First-Chance Exception in nlg.exe", 8, 20, TRUE) );
		dbg.SetSteppingMode(SRC);  
	}

	dbg.StopDebugging();

	return TRUE;
}

BOOL CNLGIDETest::EH_BreakInCtor( )
{
 	LogTestHeader( "EH_BreakInCtor" );
    bps.ClearAllBreakpoints();
	dbg.Restart();
   	bps.SetBreakpoint("{,ehutil.cpp,}@10");		// Ctor
	dbg.SetSteppingMode(SRC);

	EXPECT_TRUE( dbg.Go(NULL, "m_i = i;") );
	EXPECT_TRUE( stk.CurrentFunctionIs( "ThrowObject::ThrowObject" ) );
	CString func = stk.GetFunction(1);
	EXPECT_TRUE( func.Find( "Case1()" ) != -1 );
    bps.ClearAllBreakpoints();

   	bps.SetBreakpoint("{,ehutil.cpp,}@16");		// Copy Ctor
	EXPECT_TRUE( dbg.Go(NULL, "m_i = src.m_i;") );
	EXPECT_TRUE( stk.CurrentFunctionIs( "ThrowObject::ThrowObject" ) );
	func = stk.GetFunction(1);
	EXPECT_TRUE( func.Find( "Case1()" ) != -1 );

	EXPECT_TRUE( dbg.Go(NULL, "m_i = src.m_i;") );
	func = stk.GetFunction(1);
	EXPECT_TRUE( func.Find( "Case3()" ) != -1 );

	EXPECT_TRUE( dbg.Go(NULL, "m_i = src.m_i;") );
	func = stk.GetFunction(1);
	EXPECT_TRUE( func.Find( "Case4()" ) != -1 );
	EXPECT_TRUE( dbg.StepOver(1, NULL, NULL, NULL, 0) );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 4) && cxx.ExpressionValueIs("m_iCopy", 1));

   	EXPECT_TRUE( dbg.Go(NULL, "m_i = src.m_i;") );
	func = stk.GetFunction(1);
	if( GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
		EXPECT_TRUE( func.Find( "FrameUnwindToState" ) != -1 );	
	}
	else
	{
		EXPECT_TRUE( func.Find( "CallMemberFunction1" ) != -1 );
	}
	EXPECT_TRUE( dbg.StepOver(1, NULL, NULL, NULL, 0) );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 4) && cxx.ExpressionValueIs("m_iCopy", 2));

   	EXPECT_TRUE( dbg.Go(NULL, "m_i = src.m_i;") );
	func = stk.GetFunction(1);
	EXPECT_TRUE( func.Find( "Case5()" ) != -1 );
   
   	EXPECT_TRUE( dbg.Go(NULL, "m_i = src.m_i;") );
	func = stk.GetFunction(1);
	if( GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
		EXPECT_TRUE( func.Find( "FrameUnwindToState" ) != -1 );	//v-katsuf
	}
	else
	{
		EXPECT_TRUE( func.Find( "CallMemberFunction1" ) != -1 );
	}
	EXPECT_TRUE( dbg.StepOver(1, NULL, NULL, NULL, 0) );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 5) && cxx.ExpressionValueIs("m_iCopy", 2));

   	EXPECT_TRUE( dbg.Go(NULL, "m_i = src.m_i;") );
	func = stk.GetFunction(1);
	EXPECT_TRUE( func.Find( "Case6()" ) != -1 );
   
   	EXPECT_TRUE( dbg.Go(NULL, "m_i = src.m_i;") );
	func = stk.GetFunction(1);
	if( GetUserTargetPlatforms() == PLATFORM_WIN32_X86)
	{
		EXPECT_TRUE( func.Find( "FrameUnwindToState" ) != -1 );	//v-katsuf
	}
	else
	{
		EXPECT_TRUE( func.Find( "CallMemberFunction1" ) != -1 );
	}
	EXPECT_TRUE( dbg.StepOver(1, NULL, NULL, NULL, 0) );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 6) && cxx.ExpressionValueIs("m_iCopy", 2));

   	EXPECT_TRUE( dbg.Go(NULL, "m_i = src.m_i;") );
	func = stk.GetFunction(1);
	EXPECT_TRUE( func.Find( "Case6()" ) != -1 );
   
   	EXPECT_TRUE( dbg.Go(NULL, "m_i = src.m_i;") );
	func = stk.GetFunction(1);
	if(GetUserTargetPlatforms() == PLATFORM_WIN32_X86)
	{
		EXPECT_TRUE( func.Find( "FrameUnwindToState" ) != -1 );	//v-katsuf
	}
	else
	{
		EXPECT_TRUE( func.Find( "CallMemberFunction1" ) != -1 );
	}
	EXPECT_TRUE( dbg.StepOver(1, NULL, NULL, NULL, 0) );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 6) && cxx.ExpressionValueIs("m_iCopy", 4));

   	EXPECT_TRUE( dbg.Go(NULL, "m_i = src.m_i;") );
	func = stk.GetFunction(1);
	EXPECT_TRUE( func.Find( "Case7()" ) != -1 );
   
   	EXPECT_TRUE( dbg.Go(NULL, "m_i = src.m_i;") );
	func = stk.GetFunction(1);
	if( GetUserTargetPlatforms() == PLATFORM_WIN32_X86)
	{
		EXPECT_TRUE( func.Find( "FrameUnwindToState" ) != -1 );	//v-katsuf
	}
	else
	{
		EXPECT_TRUE( func.Find( "CallMemberFunction1" ) != -1 );
	}
	EXPECT_TRUE( dbg.StepOver(1, NULL, NULL, NULL, 0) );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 7) && cxx.ExpressionValueIs("m_iCopy", 2));

	bps.ClearAllBreakpoints();

	return TRUE;
}

BOOL CNLGIDETest::EH_BreakInDtor( )
{
	LogTestHeader( "EH_BreakInDtor" );
    bps.ClearAllBreakpoints();
	dbg.Restart();
   	bps.SetBreakpoint("{,ehutil.cpp,}@30");		// Dtor
	dbg.SetSteppingMode(SRC);

	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( stk.CurrentFunctionIs( "ThrowObject::~ThrowObject" ) );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 1) && cxx.ExpressionValueIs("m_iCopy", 0));

	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 3) && cxx.ExpressionValueIs("m_iCopy", 0));

	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 4) && cxx.ExpressionValueIs("m_iCopy", 0));

	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 4) && cxx.ExpressionValueIs("m_iCopy", 2));

 	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( stk.CurrentFunctionIs( "ThrowObject::~ThrowObject" ) );
 	CString func;
//	func = stk.GetFunction(1);
	func = stk.GetAllFunctions();
	if(GetUserTargetPlatforms() == PLATFORM_WIN32_X86)
	{
		EXPECT_TRUE( func.Find( "FrameUnwindToState" ) != -1 );	
	}
	else
	{
		EXPECT_TRUE( func.Find( "CallMemberFunction0" ) != -1 );
	}
	func = stk.GetAllFunctions();
/*	 code gen was changed ?
	EXPECT_TRUE( func.Find( "eh01() line 32" ) != -1 );
*/
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 4) && cxx.ExpressionValueIs("m_iCopy", 1));

 	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
// 	func = stk.GetFunction(1);
	func = stk.GetAllFunctions();
	if(GetUserTargetPlatforms() == PLATFORM_WIN32_X86)
	{
		EXPECT_TRUE( func.Find( "FrameUnwindToState" ) != -1 );	//v-katsuf
	}
	else
	{
		EXPECT_TRUE( func.Find( "CallMemberFunction0" ) != -1 );
	}
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 3) && cxx.ExpressionValueIs("m_iCopy", 1));

	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 1) && cxx.ExpressionValueIs("m_iCopy", 1));

	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 5) && cxx.ExpressionValueIs("m_iCopy", 0));

	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 5) && cxx.ExpressionValueIs("m_iCopy", 2));

 	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 5) && cxx.ExpressionValueIs("m_iCopy", 1));

	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 6) && cxx.ExpressionValueIs("m_iCopy", 0));

	if( GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 6) && cxx.ExpressionValueIs("m_iCopy", 1));
	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 6) && cxx.ExpressionValueIs("m_iCopy", 2));
	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 6) && cxx.ExpressionValueIs("m_iCopy", 4));
	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 6) && cxx.ExpressionValueIs("m_iCopy", 3));
	}
	else if( GetUserTargetPlatforms() == PLATFORM_WIN32_ALPHA)	
	{
	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 6) && cxx.ExpressionValueIs("m_iCopy", 2));
	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 6) && cxx.ExpressionValueIs("m_iCopy", 1));
	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 6) && cxx.ExpressionValueIs("m_iCopy", 4));
	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 6) && cxx.ExpressionValueIs("m_iCopy", 3));
	}
	else
	{
	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 6) && cxx.ExpressionValueIs("m_iCopy", 2));
	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 6) && cxx.ExpressionValueIs("m_iCopy", 4));
	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 6) && cxx.ExpressionValueIs("m_iCopy", 3));
	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 6) && cxx.ExpressionValueIs("m_iCopy", 1));
	}

 	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 7) && cxx.ExpressionValueIs("m_iCopy", 0));
 	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 7) && cxx.ExpressionValueIs("m_iCopy", 2));
 	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 7) && cxx.ExpressionValueIs("m_iCopy", 1));

    bps.ClearAllBreakpoints();

	return TRUE;
}



// SEH
BOOL CNLGIDETest::SEH_TryNoException( )

{
	LogTestHeader( "SEH_TryNoException" );
   	bps.ClearAllBreakpoints();
 	dbg.Restart();
	bps.SetBreakpoint("SehCase1");
	dbg.SetSteppingMode(SRC);
	dbg.Go("SehCase1");
	EXPECT_TRUE(dbg.StepOver(4, NULL, "RaiseNoException();"));

	// processor pack code-gen difference.
	if(CMDLINE->GetBooleanValue("PP", FALSE))
		{EXPECT_TRUE(dbg.StepOver(1, NULL, "++counter; // should execute"));}
	else
		{EXPECT_TRUE(dbg.StepOver(2, NULL, "++counter; // should execute"));}

	EXPECT_TRUE(dbg.StepOver(1, NULL, "}"));
	dbg.StopDebugging();
	return TRUE;
}

BOOL CNLGIDETest::SEH_ExceptionContinueExecution( )

{
 	LogTestHeader( "SEH_ExceptionContinueExecution" );
  	bps.ClearAllBreakpoints();
	bps.SetBreakpoint("SehCase3");
	dbg.Go("SehCase3");
	EXPECT_TRUE(dbg.StepOver(4, NULL, "RaiseIntDivideByZero();"));
	EXPECT_TRUE(dbg.StepOver(1, NULL, "++counter; // Should continue here"));
	EXPECT_TRUE(dbg.VerifyNotification("Integer Divide by Zero", 1, 20, TRUE) );
	dbg.SetSteppingMode(SRC);

	// processor pack code-gen difference.
	if(CMDLINE->GetBooleanValue("PP", FALSE))
		{EXPECT_TRUE(dbg.StepOver(1, NULL, "++counter; // should execute"));}
	else
		{EXPECT_TRUE(dbg.StepOver(2, NULL, "++counter; // should execute"));}

	dbg.StopDebugging();
	return TRUE;
}

BOOL CNLGIDETest::SEH_ExceptionExecuteHandler( )
{
 	LogTestHeader( "SEH_ExceptionExecuteHandler" );
  	bps.ClearAllBreakpoints();
	bps.SetBreakpoint("SehCase4");
	dbg.Go("SehCase4");
	EXPECT_TRUE(dbg.StepOver(4, NULL, "IntDivideByZero();"));
	EXPECT_TRUE(dbg.StepOver(1, NULL, "__except( ++counter, ExecuteHandler() ) {"));
	EXPECT_TRUE(dbg.VerifyNotification("First-Chance Exception in seh01.exe", 2, 20, TRUE) );
	dbg.SetSteppingMode(SRC);
	EXPECT_TRUE(dbg.StepOver(1, NULL, "++counter; // should execute"));	
	dbg.StopDebugging();
	return TRUE;
}

BOOL CNLGIDETest::SEH_TryFinallyNoException( )

{
	LogTestHeader( "SEH_TryFinallyNoException" );
	bps.ClearAllBreakpoints();
	dbg.StopDebugging();
	bps.SetBreakpoint("SehCase2");
	dbg.SetSteppingMode(SRC);
	dbg.Go("SehCase2");
	EXPECT_TRUE(dbg.StepOver(4, NULL, "RaiseNoException();"));

//	EXPECT_TRUE(dbg.StepOver(2, NULL, "++counter; // should execute")); //bug 9256 postponed

	// processor pack code-gen difference.
	if(CMDLINE->GetBooleanValue("PP", FALSE))
	{
 		EXPECT_TRUE(dbg.StepOver(1, NULL, "}"));
		EXPECT_TRUE( stk.CurrentFunctionIs( "SehCase2() line 54" ) );
	}
	else
	{
		dbg.StepOver();
		EXPECT_TRUE(dbg.StepInto(1, NULL, "++counter; // should execute"));
		EXPECT_TRUE( stk.CurrentFunctionIs( "SehCase2() line 52" ) );
 		EXPECT_TRUE(dbg.StepOver(2, NULL, "}"));
	}

	dbg.StopDebugging();
	return TRUE;
}

BOOL CNLGIDETest::SEH_TryFinallyException( )
{
	LogTestHeader( "SEH_TryFinallyException" );
   	bps.ClearAllBreakpoints();
	bps.SetBreakpoint("SehCase6");
	dbg.SetSteppingMode(SRC);
	EXPECT_TRUE( dbg.Go("SehCase6") );
	EXPECT_TRUE(dbg.StepOver(6, NULL, "IntDivideByZero();"));
	EXPECT_TRUE(dbg.StepOver(1, NULL, "++counter; // should execute"));
	EXPECT_TRUE( dbg.VerifyNotification("Integer Divide by Zero", 1, 20, TRUE) );
	dbg.SetSteppingMode(SRC);
	//Warning:  the following line has been changed from a two step to a single stepover
	//It is uncertain if the test was always bad or code generation changed handling in some way
	//So, if you see a failure where "__except( ++counter, ExecuteHandler() is expected but 
	//the cursor is one line short, then a code gen change has occured.
	EXPECT_TRUE(dbg.StepOver(1, NULL, "__except( ++counter, ExecuteHandler() ) {"));
	EXPECT_TRUE(dbg.StepOver(1, NULL, "++counter; // should execute"));
	dbg.StopDebugging();
	return TRUE;
}

BOOL CNLGIDETest::SEH_BreakInFilter( )
{
	LogTestHeader( "SEH_BreakInFilter" );
 	dbg.Restart();
	dbg.SetSteppingMode(SRC);
  	bps.ClearAllBreakpoints();
	EXPECT_TRUE( bps.SetBreakpoint("ContinueExecution") );
	EXPECT_TRUE( bps.SetBreakpoint("ExecuteHandler") );
	EXPECT_TRUE( bps.SetBreakpoint("ContinueSearch") );

	EXPECT_TRUE( dbg.Go("ContinueExecution") );
	EXPECT_TRUE( stk.CurrentFunctionIs( "ContinueExecution()" ) );
 	CString func = stk.GetFunction(1);
	EXPECT_TRUE( func.Find( "SehCase3()" ) != -1 );
	EXPECT_TRUE(dbg.StepOut(1, NULL, "__except( ++counter, ContinueExecution() ) {"));

	EXPECT_TRUE( dbg.Go("ExecuteHandler") );
	EXPECT_TRUE( stk.CurrentFunctionIs( "ExecuteHandler()" ) );
 	func = stk.GetFunction(1);
	EXPECT_TRUE( func.Find( "SehCase4()" ) != -1 );
	EXPECT_TRUE(dbg.StepOut(1, NULL, "__except( ++counter, ExecuteHandler() ) {"));

	EXPECT_TRUE( dbg.Go("ExecuteHandler") );
	EXPECT_TRUE( stk.CurrentFunctionIs( "ExecuteHandler()" ) );
 	func = stk.GetFunction(1);
	EXPECT_TRUE( func.Find( "SehCase6()" ) != -1 );
	EXPECT_TRUE(dbg.StepOver(4, NULL, "__except( ++counter, ExecuteHandler() ) {"));

	EXPECT_TRUE( dbg.Go("ExecuteHandler") );
	EXPECT_TRUE( stk.CurrentFunctionIs( "ExecuteHandler()" ) );
 	func = stk.GetFunction(1);
	EXPECT_TRUE( func.Find( "SehCase8()" ) != -1 );
	EXPECT_TRUE(dbg.StepOut(1, NULL, "__except( ++counter, ExecuteHandler() ) {"));

	EXPECT_TRUE( dbg.Go("ContinueExecution") );
	EXPECT_TRUE( stk.CurrentFunctionIs( "ContinueExecution()" ) );
 	func = stk.GetFunction(1);
	EXPECT_TRUE( func.Find( "SehCase8()" ) != -1 );
	EXPECT_TRUE(dbg.StepOut(1, NULL, "__except( ++counter, ContinueExecution() ) {"));

	EXPECT_TRUE( dbg.Go("ContinueSearch") );
	EXPECT_TRUE( stk.CurrentFunctionIs( "ContinueSearch()" ) );
 	func = stk.GetFunction(1);
	EXPECT_TRUE( func.Find( "SehCase5()" ) != -1 );
	EXPECT_TRUE(dbg.StepOut(1, NULL, "__except( ++counter, ContinueSearch() ) {"));

	dbg.StopDebugging();
  	bps.ClearAllBreakpoints();
	return TRUE;
}

BOOL CNLGIDETest::SEH_StepOver__try( )
{
	LogTestHeader( "SEH_StepOver__try" );
	CString strSource = "seh01.cpp";
 	dbg.Restart();
	bps.ClearAllBreakpoints();
	bps.SetBreakpoint("SehCase8");
	dbg.SetSteppingMode(SRC);
	MST.WFndWnd(strSource, FW_NOCASE | FW_FOCUS | FW_PART);
	EXPECT_TRUE( dbg.Go("SehCase8") );
	EXPECT_TRUE(dbg.StepOver(4, NULL, "__try { ++counter; RaiseIntDivideByZero();"));
	EXPECT_TRUE(dbg.StepOver(1, NULL, "__finally { ++counter; /* should execute */ }"));
	EXPECT_TRUE( dbg.VerifyNotification("Integer Divide by Zero", 2, 20, TRUE) );
	dbg.SetSteppingMode(SRC);
//	MST.WFndWnd(strSource, FW_NOCASE | FW_FOCUS | FW_PART);
	EXPECT_TRUE(dbg.StepOver(1, NULL, "__except( ++counter, ExecuteHandler() ) {"));
	EXPECT_TRUE(dbg.StepOver(1, NULL, "++counter; // should execute"));

	// processor pack code-gen difference.
	if(CMDLINE->GetBooleanValue("PP", FALSE))
		{EXPECT_TRUE(dbg.StepOver(1, NULL, "__try { ++counter; RaiseIntDivideByZero(); ++counter;"));}
	else
		{EXPECT_TRUE(dbg.StepOver(2, NULL, "__try { ++counter; RaiseIntDivideByZero(); ++counter;"));}

	EXPECT_TRUE(dbg.StepOver(1, NULL, "++counter; // should execute"));
	EXPECT_TRUE( dbg.VerifyNotification("Integer Divide by Zero", 3, 20, TRUE) );

	dbg.StopDebugging();
	return TRUE;
}

BOOL CNLGIDETest::SEH_BreakInExcept( )
{
	LogTestHeader( "SEH_BreakInExcept" );
 	dbg.Restart();
	dbg.SetSteppingMode(SRC);
  	bps.ClearAllBreakpoints();

	EXPECT_TRUE( bps.SetBreakpoint("{,seh01.cpp,}@91") );
	EXPECT_TRUE( bps.SetBreakpoint("{,seh01.cpp,}@136") );

	EXPECT_TRUE(dbg.Go(NULL, "++counter; // should execute")  &&
		stk.CurrentFunctionIs( "SehCase4()" ) );
	EXPECT_TRUE(dbg.Go(NULL, "++counter; // should execute")  &&
		stk.CurrentFunctionIs( "SehCase6()" ) );

	bps.ClearAllBreakpoints();

	dbg.StopDebugging();
	return TRUE;
}

BOOL CNLGIDETest::SEH_BreakInFinally( )
{
	LogTestHeader( "SEH_BreakInFinally" );
 	dbg.Restart();
	dbg.SetSteppingMode(SRC);
  	bps.ClearAllBreakpoints();

	EXPECT_TRUE( bps.SetBreakpoint("{,seh01.cpp,}@52") );
	EXPECT_TRUE( bps.SetBreakpoint("{,seh01.cpp,}@130") );

	EXPECT_TRUE(dbg.Go(NULL, "++counter; // should execute") &&
		stk.CurrentFunctionIs( "SehCase2()" ) );
	EXPECT_TRUE(dbg.Go(NULL, "++counter; // should execute") &&
		stk.CurrentFunctionIs( "SehCase6()" ) );

	bps.ClearAllBreakpoints();
	dbg.StopDebugging();
	return TRUE;
}

BOOL CNLGIDETest::SEH_StepToCursorOver__tryIntoExcept( )
{
	LogTestHeader( "SEH_StepToCursorOver__tryIntoExcept" );
 	dbg.Restart();
	dbg.SetSteppingMode(SRC);
  	bps.ClearAllBreakpoints();

	CString strSource = "seh01.cpp";
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);   //Review yefims
//	file.Open( m_strProjectDir + "\\" + strSource);   

	EXPECT_TRUE(dbg.StepToCursor(84, NULL, "__try {"));
	EXPECT_TRUE(dbg.StepToCursor(91, NULL, "++counter; // should execute"));
	EXPECT_TRUE(dbg.StepToCursor(121, NULL, "__try {"));
	EXPECT_TRUE(dbg.StepToCursor(136, NULL, "++counter; // should execute"));

	dbg.StopDebugging();

	return TRUE;
}


BOOL CNLGIDETest::SEH_StepToCursorOver__tryIntoFinally( )
{
	LogTestHeader( "SEH_StepToCursorOver__tryIntoFinally" );
 	dbg.Restart();
	dbg.SetSteppingMode(SRC);
  	bps.ClearAllBreakpoints();

	CString strSource = "seh01.cpp";
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);   //Review yefims
//	file.Open( m_strProjectDir + "\\" + strSource);   

	EXPECT_TRUE(dbg.StepToCursor(47, NULL, "__try {"));
	EXPECT_TRUE(dbg.StepToCursor(52, NULL, "++counter; // should execute"));
	EXPECT_TRUE(dbg.StepToCursor(123, NULL, "__try {"));
	EXPECT_TRUE(dbg.StepToCursor(130, NULL, "++counter; // should execute"));

	dbg.StopDebugging();

	return TRUE;
}


// Setjmp/Longjmp
BOOL CNLGIDETest::LJMP_StepOverLongJmp( )
{
	LogTestHeader( "LJMP_StepOverLongJmp" );
 	bps.ClearAllBreakpoints();
 	bps.SetBreakpoint("ljmp01");
	dbg.SetSteppingMode(SRC);
	dbg.Go("ljmp01");
	MST.DoKeys("{down 15}");
	EXPECT_TRUE( dbg.StepToCursor(0,NULL,"longjmp( mark, -1 );")	 )	;
	EXPECT_TRUE(dbg.StepOver(1, NULL, "jmpret = setjmp( mark );"));
	return TRUE;
}

BOOL CNLGIDETest::LJMP_StepOverFuncWithLongJmp( )
{
 	LogTestHeader( "LJMP_StepOverFuncWithLongJmp" );
 	bps.ClearAllBreakpoints();
 	bps.SetBreakpoint("{,ljmp01.cpp,}@55");
	dbg.SetSteppingMode(SRC);
	dbg.Go(NULL, "ljmp02( mark, i );");
	EXPECT_TRUE(dbg.StepOver(1, NULL, "jmpret = setjmp( mark );"));
	return TRUE;
}

BOOL CNLGIDETest::LJMP_StepOutFuncWithLongJmp( )
{
	LogTestHeader( "LJMP_StepOutFuncWithLongJmp" );
  	bps.ClearAllBreakpoints();
 	bps.SetBreakpoint("ljmp02");
	dbg.SetSteppingMode(SRC);
	dbg.Go("ljmp02");
	EXPECT_TRUE(dbg.StepOut(1, NULL, "jmpret = setjmp( mark );"));

	dbg.StopDebugging();
	return TRUE;
}


BOOL CNLGIDETest::IsUnhandledException(CString except_text)
{
	if( WaitMsgBoxText( except_text, 10 ) )
	{
		MST.WButtonClick( "OK" );
		return TRUE;
	}
	else
		return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\nlg\nlgsub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CNLGSubSuite class
//

#include "stdafx.h"
#include "NLGsub.h"
#include "afxdllx.h"
#include "..\cleanup.h"

#include "NLGcase.h"
#include "NLGcase2.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


/////////////////////////////////////////////////////////////////////////////
// CNLGSubSuite

IMPLEMENT_SUBSUITE(CNLGSubSuite, CIDESubSuite, "Non-Local Goto", "VCQA Debugger")

BEGIN_TESTLIST(CNLGSubSuite)
	TEST(CNLGIDETest, RUN)
	TEST(CNLG2IDETest, RUN)
END_TESTLIST()

void CNLGSubSuite::CleanUp(void)
	{
	::CleanUp("nlg");
	::CleanUp("seh01");
	}

///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\nlg\nlgsub.h ===
///////////////////////////////////////////////////////////////////////////////
//	NLGsub.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CNLGSubSuite class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CNLGSubSuite class

class CNLGSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CNLGSubSuite)
//	CNLGSubSuite() { m_strName = "TestWizard Generated script"; m_strOwner = "VCBU QA"; }


	DECLARE_TESTLIST()
protected:
	void CleanUp(void);
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\nlg\nlgcase2.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	NLGcase2.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "NLGcase2.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
											   
IMPLEMENT_TEST(CNLG2IDETest, CDebugTestSet, "NonLocalGoto Special", -1, CNLGSubSuite)
												 
void CNLG2IDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

void CNLG2IDETest::Run()
{	 
	XSAFETY;
	SetProject("nlg\\nlg");
	XSAFETY;

	// EH

	EH_StepIntoThrow( );
	XSAFETY;
/* bug # 9231postponed till after V50
	EH_StepIntoReThrow( );
	XSAFETY;
*/


//	EH_CatchInDLL( );  // plan to do it
//	XSAFETY;
//	EH_CatchFromDLL( );
//	XSAFETY;
//	EH_ReThrowInCtor( );  // may do it later
//	XSAFETY;

	if( GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
	// Setjmp/Longjmp
		LJMP_StepIntoLongJmp( );
		XSAFETY;
	
	// SEH
		SetProject("seh01\\seh01");
		XSAFETY;
/* bug # 9263  */
		SEH_StepIntoRaiseException( );  // too weird on Chicago: no CRT support
		XSAFETY;
		SEH_ExceptionContinueSearch( );
		XSAFETY;
	}
}
 
///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////


// EH

BOOL CNLG2IDETest::EH_StepIntoThrow( )
{
	LogTestHeader( "EH_StepIntoThrow" );
   	bps.ClearAllBreakpoints();
 	bps.SetBreakpoint("Case3");
	dbg.Go("Case3");
	int nSteps = 4;
	int i;

	EXPECT_TRUE( dbg.StepOver(nSteps, NULL, "throw t;") );
	EXPECT_TRUE(dbg.StepInto(1, NULL, "ThrowObject::ThrowObject( const ThrowObject& src) {"));
	EXPECT_TRUE(dbg.StepOut(1, NULL, "throw t;"));
	EXPECT_TRUE(dbg.StepInto(1, NULL, NULL, NULL, 0));

	if( WaitMsgBoxText("Directory does not exist", 10))
	{
		MST.WButtonClick( "OK" );
		while(MST.WFndWndC("Directory does not exist", "Static", FW_PART));
	}
	if (MST.WFndWnd("Browse for Folder", FW_NOCASE | FW_FOCUS | FW_PART)
		|| MST.WFndWnd("Find Source", FW_NOCASE | FW_FOCUS | FW_PART))
		MST.WButtonClick( "Cancel" );
	
	if ( !stk.CurrentFunctionIs( "eh01()" )	)
	{
		MST.DoKeys("{up}");
		EXPECT_TRUE( dbg.CurrentLineIs( "_CxxThrowException:" ) && stk.CurrentFunctionIs( "_CxxThrowException" ) );

		EXPECT_TRUE( dbg.StepOut(1, NULL, NULL, NULL, 0) );

		if( GetSystem() & SYSTEM_WIN ) 
		{
			for (i = 0; i < 9; i++)
			{
				if( WaitMsgBoxText("Directory does not exist", 10))
				{
					MST.WButtonClick( "OK" );
					while(MST.WFndWndC("Directory does not exist", "Static", FW_PART));
				}
				if (MST.WFndWnd("Browse for Folder", FW_NOCASE | FW_FOCUS | FW_PART)
					|| MST.WFndWnd("Find Source", FW_NOCASE | FW_FOCUS | FW_PART))
				{
					MST.WButtonClick( "Cancel" );
					dbg.StepOut(1, NULL, NULL, NULL, 0);
				}
			}
		}
		dbg.SetSteppingMode(SRC); 
	}

	EXPECT_TRUE( dbg.CurrentLineIs( "catch( ... ){ // after Case3" ) );

	EXPECT_TRUE(dbg.VerifyNotification("First-Chance Exception in nlg.exe", 2, 20, TRUE));
	dbg.SetSteppingMode(SRC);

	dbg.StopDebugging();
	return TRUE;
}

BOOL CNLG2IDETest::EH_StepIntoReThrow( )
{
	LogTestHeader( "EH_StepIntoReThrow" );
   	bps.ClearAllBreakpoints();
 	bps.SetBreakpoint("Case7");
	dbg.Go("Case7");

	int nSteps = 6;
	EXPECT_TRUE( dbg.StepOver(nSteps, NULL, "throw t;") );

	nSteps = 2;
	EXPECT_TRUE( dbg.StepOver(nSteps, NULL, "throw;") );

	EXPECT_TRUE(dbg.StepInto(1, NULL, NULL, NULL, 0));

/*	if( GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
		if( WaitMsgBoxText("Directory does not exist", 10))
		{
			MST.WButtonClick( "OK" );
			while(MST.WFndWndC("Directory does not exist", "Static", FW_PART));
		}
		if (MST.WFndWndWait("Browse for Folder", FW_NOCASE | FW_FOCUS | FW_PART, 1)
			|| MST.WFndWndWait("Find Source", FW_NOCASE | FW_FOCUS | FW_PART, 1))
				MST.WButtonClick( "Cancel" );
	
		MST.DoKeys("{up}");
		EXPECT_TRUE( dbg.CurrentLineIs( "_CxxThrowException:" ) );

		EXPECT_TRUE(dbg.StepOut(1, NULL, NULL, NULL, 0) );
		if( WaitMsgBoxText("Directory does not exist", 10))
		{
			MST.WButtonClick( "OK" );
			while(MST.WFndWndC("Directory does not exist", "Static", FW_PART));
		}
		if (MST.WFndWndWait("Browse for Folder", FW_NOCASE | FW_FOCUS | FW_PART, 1)
			|| MST.WFndWndWait("Find Source", FW_NOCASE | FW_FOCUS | FW_PART, 1))
				MST.WButtonClick( "Cancel" );

//		EXPECT_TRUE(dbg.StepOut(3, NULL, NULL, NULL, 0) && dbg.SetSteppingMode(SRC) );
	 	bps.SetBreakpoint("{,eh02.cpp,}.49");
		dbg.Go(NULL, NULL, NULL, 0);
		dbg.SetSteppingMode(SRC);
		MST.WFndWnd("eh02.cpp", FW_NOCASE | FW_FOCUS | FW_PART);
		MST.DoKeys("{up}");
	} 
*/	
	EXPECT_TRUE( dbg.CurrentLineIs( "catch( ThrowObject o ) {" ) );
 	
	EXPECT_TRUE(dbg.VerifyNotification("First-Chance Exception in nlg.exe", 8, 20, TRUE));

	dbg.StopDebugging();
	return TRUE;
}



BOOL CNLG2IDETest::EH_CatchInDLL( )
{
	return TRUE;
}

BOOL CNLG2IDETest::EH_CatchFromDLL( )
{
	return TRUE;
}


//BOOL CNLG2IDETest::EH_ReThrowInCtor( )
//{
//	LogTestHeader( "EH_ReThrowInCtor" );
//	dbg.Restart();
//   	bps.SetBreakpoint("{,ehutil.cpp,}.23");		// throw in Ctor
//	EXPECT_TRUE( dbg.Go(NULL, "throw m_i;") );
// 	EXPECT_TRUE( stk.CurrentFunctionIs( "ThrowObject::ThrowObject()" ) );
//	CString func = stk.GetFunction(1);
//	EXPECT_TRUE( func.Find( "Case8()" ) != -1 );
//
//	EXPECT_TRUE( dbg.Go(NULL, "m_i = i;") );
//	EXPECT_TRUE( stk.CurrentFunctionIs( "ThrowObject::ThrowObject(int 1)" ) );
//	func = stk.GetFunction(1);
//	EXPECT_TRUE( func.Find( "Case8()" ) != -1 );
//
//	EXPECT_TRUE(dbg.StepOver(1, NULL, "++counter; // Should execute"));
//	EXPECT_TRUE( stk.CurrentFunctionIs( "Case8() line 58" ) );
//
//	// F10 n times should get to line 68 in eh01.cpp
//   	EXPECT_TRUE(dbg.StepOver(2));
//	if( WaitMsgBoxText( "Browse for Folder", 10 ) )
//			MST.WButtonClick( "Cancel" );
//
//	// Verify we are in DAM 
// 	UIDAM dam;
//	EXPECT_TRUE( dam.IsActive() );
//	
//	EXPECT_TRUE( dbg.CurrentLineIs( "__NLG_Return" ) )
//   	func = stk.GetFunction(0);
//	EXPECT_TRUE( func.Find( "_CallSettingFrame" ) != -1 );
//   	func = stk.GetFunction(1);
//	EXPECT_TRUE( func.Find( "eh01()" ) != -1 );
//   	EXPECT_TRUE(bps.SetBreakpoint("{eh01}.64");
//	EXPECT_TRUE( dbg.Go(NULL, "catch( ... ) {") );
//	EXPECT_TRUE(dbg.StepOver(1, NULL, "++caseNum; // Should execute"));
//
////	EXPECT_TRUE( src.GetCurrentLine() == 68 );
//
//   	bps.ClearAllBreakpoints();
//
//	return TRUE;
//}


// SEH

BOOL CNLG2IDETest::SEH_ExceptionContinueSearch( )
{
 	LogTestHeader( "SEH_ExceptionContinueSearch" );
  	bps.ClearAllBreakpoints();
	bps.SetBreakpoint("SehCase5");
	dbg.Go("SehCase5");
	EXPECT_TRUE(dbg.StepOver(4, NULL, "IntDivideByZero();"));
	EXPECT_TRUE(dbg.StepOver(1, NULL, NULL, NULL, 0));
	EXPECT_TRUE( IsUnhandledException("Integer Divide by Zero") );
	EXPECT_TRUE( dbg.VerifyNotification("Integer Divide by Zero", 6, 20, TRUE) );
	dbg.SetSteppingMode(SRC);
	EXPECT_TRUE( dbg.CurrentLineIs( "k = i/j;" ) );
	MST.DoKeys("{down}");
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver(1, NULL, "++counter;"));

	// processor pack code-gen difference.
	if(CMDLINE->GetBooleanValue("PP", FALSE))
		{EXPECT_TRUE(dbg.StepOver(1, NULL, "++counter; // should execute"));}
	else
		{EXPECT_TRUE(dbg.StepOver(2, NULL, "++counter; // should execute"));}

	dbg.StopDebugging();
	return TRUE;
}


BOOL CNLG2IDETest::SEH_StepIntoRaiseException( )
{
 	LogTestHeader( "SEH_StepIntoRaiseException" );
  	bps.ClearAllBreakpoints();
	bps.SetBreakpoint("SehCase3");
	dbg.Go("SehCase3");
	dbg.SetSteppingMode(SRC);
	EXPECT_TRUE(dbg.StepInto(4, NULL, "RaiseIntDivideByZero();"));
	EXPECT_TRUE(dbg.StepInto(1, "RaiseIntDivideByZero"));
	EXPECT_TRUE(dbg.StepInto(3, NULL, "++counter; // Should continue here"));


	// processor pack code-gen difference.
	if(CMDLINE->GetBooleanValue("PP", FALSE))
		{EXPECT_TRUE(dbg.StepInto(1, NULL, "++counter; // should execute"));}
	else
		{EXPECT_TRUE(dbg.StepInto(2, NULL, "++counter; // should execute"));}

	bps.SetBreakpoint("SehCase4");
	dbg.Go("SehCase4");
	EXPECT_TRUE(dbg.StepInto(5, "IntDivideByZero"));
	EXPECT_TRUE(dbg.StepInto(4, NULL, "__except( ++counter, ExecuteHandler() ) {"));
	EXPECT_TRUE(dbg.StepInto(1, NULL, "++counter; // should execute"));
	bps.ClearAllBreakpoints();
	dbg.StopDebugging();
	return TRUE;
}


// Setjmp/Longjmp

BOOL CNLG2IDETest::LJMP_StepIntoLongJmp( )
{
 	LogTestHeader( "LJMP_StepIntoLongJmp" );
 	bps.ClearAllBreakpoints();
 	bps.SetBreakpoint("{,ljmp01.cpp,}.32");
	dbg.SetSteppingMode(SRC);
	EXPECT_TRUE( dbg.Go(NULL, "longjmp( mark, -1 );") );
	
	EXPECT_TRUE(dbg.StepInto(1, NULL, NULL, NULL, 0));

	if( WaitMsgBoxText("Directory does not exist", 10))
	{
		MST.WButtonClick( "OK" );
		while(MST.WFndWndC("Directory does not exist", "Static", FW_PART));
	}
	if (MST.WFndWndWait("Browse for Folder", FW_NOCASE | FW_FOCUS | FW_PART, 1)
		|| MST.WFndWndWait("Find Source", FW_NOCASE | FW_FOCUS | FW_PART, 1))
			MST.WButtonClick( "Cancel" );
	if ( stk.CurrentFunctionIs( "ljmp01()" ) )
	{
		EXPECT_TRUE( dbg.CurrentLineIs( "jmpret = setjmp( mark );" ) );
	}
	else
	{
		EXPECT_TRUE( stk.CurrentFunctionIs( "_longjmp()" ) );

		EXPECT_TRUE(dbg.StepOut(1, NULL, NULL, NULL, 0) && 
				dbg.SetSteppingMode(SRC) && 
				dbg.CurrentLineIs( "jmpret = setjmp( mark );" ) );
	}

	return TRUE;
}


BOOL CNLG2IDETest::IsUnhandledException(CString except_text)
{
	if( WaitMsgBoxText( except_text, 10 ) )
	{
		MST.WButtonClick( "OK" );
		return TRUE;
	}
	else
		return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\registers\StdAfx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\registers\registerspp.h ===
///////////////////////////////////////////////////////////////////////////////
//	RegistersPP.h
//
//	Created by:			
//		dverma
//
//	Description:
//		VC6 Processor Pack testcases.
//

#ifndef __RegistersPP_H__
#define __RegistersPP_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\DbgTestBase.h"
#include "regsub.h"
//#include "eesub.h"	//	for watch window access

///////////////////////////////////////////////////////////////////////////////
//	CRegistersPP class

class CRegistersPP : public CDbgTestBase

{
	DECLARE_TEST(CRegistersPP, CRegistersSubSuite)

// Attributes
public:
	// the base name of the localized directories and files we will use.
	CString m_strProjBase;
	// the location of the unlocalized sources, under which the projects we will use will be located.
	CString m_strSrcDir;
	// the locations of the dll and exe projects, and their localized sources, that we will use for this test.
	CString m_strExeDir;

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);

// Test Cases	

	void VerifyUnsupportedRegistersNotPresent(void);
	void TestMMXreg(void);
	void Test3dNowReg(void);
	void TestXMMreg(void);
	void TestWNIreg(void);
	void testRegVal(char *varname, char *vartype, char *value, char *message);
	void VerifyRegArray(CString Arr[],int Num_items);

private:
	int m_TestNumber;
	int m_TotalNumberOfTests;
	CString m_strLogInfo;
	char bSystemIsWin9X;
};

#endif //__RegistersPP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\registers\regsub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CRegistersSubSuite class
//

#include "stdafx.h"
#include "Regsub.h"
#include "afxdllx.h"
#include "..\..\DbgTestBase.h"

#include "Regcase.h"
#include "RegistersPP.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CRegistersSubSuite

IMPLEMENT_SUBSUITE(CRegistersSubSuite, CIDESubSuite, "Registers", "VCQA Debugger")

BEGIN_TESTLIST(CRegistersSubSuite)
	TEST(CRegistersIDETest, RUN)
	TEST(CRegistersPP, RUN)
END_TESTLIST()

void CRegistersSubSuite::CleanUp(void)
	{
	::CleanUp("testgo01");
	}

///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization

void CRegistersSubSuite::SetUp(BOOL bCleanUp)

{
	CIDESubSuite::SetUp(bCleanUp);
	// TODO(michma - 9/2/98): re-enable when memory leak bugs are fixed.
	ExpectedMemLeaks(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\registers\regsub.h ===
///////////////////////////////////////////////////////////////////////////////
//	Regsub.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CRegistersSubSuite class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CRegistersSubSuite class

class CRegistersSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CRegistersSubSuite)
//	CRegistersSubSuite() { m_strName = "TestWizard Generated script"; m_strOwner = "VCBU QA"; }


	DECLARE_TESTLIST()
protected:
	void CleanUp(void);
	void SetUp(BOOL bCleanUp);
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\registers\registerspp.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	RegistersPP.CPP
//											 
//	Created by:			
//		dverma
//
//	Description:								 
//		VC6 Processor Pack testcases.		 

#include "stdafx.h"
#include "RegistersPP.h"	
#include <stdlib.h>

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
											   
IMPLEMENT_TEST(/*999,*/ CRegistersPP, CDbgTestBase, "Processor Pack", -1, CRegistersSubSuite)

// each function that runs a test has this prototype.
typedef void (CRegistersPP::*PTR_TEST_FUNC)(void); 

// Information about a test to be put in the test header
#define LOGTESTHEADER(strTestName) 	m_strLogInfo.Format("# - %d.  %s. Total # - %d, Passed - %d %%", ++m_TestNumber, strTestName, m_TotalNumberOfTests, (m_TestNumber * 100) / m_TotalNumberOfTests);  \
									LogTestHeader(m_strLogInfo);

// we randomly pick out of the following list of tests and run them.
// insert functions for new tests to the end of the list.
PTR_TEST_FUNC tests[] = 
{
	&CRegistersPP::VerifyUnsupportedRegistersNotPresent,
	&CRegistersPP::TestMMXreg,
	&CRegistersPP::Test3dNowReg,
	&CRegistersPP::TestXMMreg,
	&CRegistersPP::TestWNIreg
};

											 
void CRegistersPP::PreRun(void)
{
	// call the base class
	CTest::PreRun();

}


void CRegistersPP::Run()

{	 
	char bPPFlagsPresent = 0;

	//	test if any pp switches present
	if (CMDLINE->GetBooleanValue("MMX",FALSE))  bPPFlagsPresent = 1;
	if (CMDLINE->GetBooleanValue("k6",FALSE))  bPPFlagsPresent = 1;
	if (CMDLINE->GetBooleanValue("k7",FALSE))  bPPFlagsPresent = 1;
	if (CMDLINE->GetBooleanValue("kni",FALSE))  bPPFlagsPresent = 1;
	if (CMDLINE->GetBooleanValue("wni",FALSE))  bPPFlagsPresent = 1;

	if (!bPPFlagsPresent) 
	{
			LOG->RecordInfo("No Processor Pack Flags Specified");
			return;
	}

	//	TODO : The bSystemIsWin9X flag needs to be used because of VS98 bug 64854
	//	resolved as won't fix.
	DWORD sysVal = GetSystem();
	if ((sysVal == SYSTEM_WIN_95) || (sysVal == SYSTEM_WIN_98) || (sysVal == SYSTEM_WIN_MILL))
	{
		bSystemIsWin9X = 1;
		LOG->RecordInfo("Win 9X OS detected.");
	}
	else
		bSystemIsWin9X = 0;

	// the base name of the localized directories and files we will use.
	if(GetSystem() & SYSTEM_DBCS)
		m_strProjBase = "[\\]^{|}Aa`@~ Registers PP";
	else
		m_strProjBase = "Registers PP";

	// the location of the unlocalized sources, under which the projects we will use will be located.
	m_strSrcDir = GetCWD() + "src\\Registers PP";
	// the locations of the dll and exe projects, and their localized sources, that we will use for this test.
	m_strExeDir = m_strSrcDir + "\\" + m_strProjBase + " EXE";

	if(!CMDLINE->GetBooleanValue("noclean", FALSE))
	{
		// clean-up the exe project from the last run.
		KillFiles(m_strExeDir + "\\Debug\\", "*.*");
		RemoveDirectory(m_strExeDir + "\\Debug");
		KillFiles(m_strExeDir + "\\", "*.*");
		RemoveDirectory(m_strExeDir);
		// set the options for the exe project we are building for this test.
		CProjWizOptions *pWin32AppWizOpt = new(CWin32AppWizOptions);
		pWin32AppWizOpt->m_strLocation = m_strSrcDir;
		pWin32AppWizOpt->m_strName = m_strProjBase + " EXE";	
		// create the exe project.
		EXPECT_SUCCESS(prj.New(pWin32AppWizOpt));
		// create a new localized exe source file in the project dir from the unlocalized exe source file.
		CopyFile(m_strSrcDir + "\\" + "Registers PP.cpp", m_strExeDir + "\\" + m_strProjBase + " EXE.cpp", FALSE);
		// make it writable so it can be cleaned up later.
		SetFileAttributes(m_strExeDir + "\\" + m_strProjBase + " EXE.cpp", FILE_ATTRIBUTE_NORMAL);
		// add the source to the project.
		EXPECT_SUCCESS(prj.AddFiles(m_strProjBase + " EXE.cpp"));
		// build the project.	
		EXPECT_SUCCESS(prj.Build());
	}
	else
		{EXPECT_SUCCESS(prj.Open(m_strExeDir + "\\" + m_strProjBase + " EXE.dsp"));}

	// all tests expect the ide to be in this initial state.
	EXPECT_TRUE(dbg.StepOver());

	// indexes into the test function array.
	int iTest;
	m_TestNumber = 0;
	m_TotalNumberOfTests = sizeof(tests) / sizeof(PTR_TEST_FUNC);
	
	for(iTest = 0; iTest < m_TotalNumberOfTests; iTest++)
		(this->*(tests[iTest]))();
}	

///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////

void CRegistersPP::testRegVal(char *varname, char *vartype, char *value, char *message)
{
	EXPR_INFO expr_info;

	cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, vartype, varname, value);		
	if(cxx.VerifyExprInfo(expr_info))
		LOG->RecordSuccess("%s : %s\n", expr_info.name,message);
	else
		LOG->RecordFailure("%s : %s\n", expr_info.name,message);

}

void CRegistersPP::VerifyRegArray(CString Arr[],int Num_items)
{
	EXPECT_TRUE(regs.Enable());

	for (int count = 0; count< Num_items; count++)
		EXPECT_FALSE(regs.RegisterDisplayed(Arr[count]));	

	EXPECT_TRUE(regs.Disable());
}

void CRegistersPP::VerifyUnsupportedRegistersNotPresent(void)
{
	CString MMXijRegs[] = {	"MM00","MM10","MM20","MM30","MM40","MM50","MM60","MM70",
							"MM01","MM11","MM21","MM31","MM41","MM51","MM61","MM71"};

	CString XMMRegs[] = {"XMM0","XMM1","XMM2","XMM3","XMM4","XMM5","XMM6","XMM7"};
	CString XMMijRegs[] = {	"XMM00","XMM01","XMM02","XMM03", "XMM10","XMM11","XMM12","XMM13",
							"XMM20","XMM21","XMM22","XMM23", "XMM30","XMM31","XMM32","XMM33",
							"XMM40","XMM41","XMM42","XMM43", "XMM50","XMM51","XMM52","XMM53",
							"XMM60","XMM61","XMM62","XMM63", "XMM70","XMM71","XMM72","XMM73" };

	CString XMM0DRegs[] = {	"XMM0DL","XMM0DH","XMM1DL","XMM1DH","XMM2DL","XMM2DH",
							"XMM3DL","XMM3DH","XMM4DL","XMM4DH","XMM5DL","XMM5DH",
							"XMM6DL","XMM6DH","XMM7DL","XMM7DH" };

	//	3dnow system
	if (CMDLINE->GetBooleanValue("k6",FALSE)||CMDLINE->GetBooleanValue("k7",FALSE))
	{
		VerifyRegArray(XMMRegs,8);
		VerifyRegArray(XMMijRegs,32);
		VerifyRegArray(XMM0DRegs,16);
	}

	//	P3 system
	if (CMDLINE->GetBooleanValue("kni",FALSE)||CMDLINE->GetBooleanValue("wni",FALSE))
	{
		VerifyRegArray(MMXijRegs,16);
	}

	//	KNI systems do not have XMMiD regs
	if (CMDLINE->GetBooleanValue("kni",FALSE))
	{
		VerifyRegArray(XMM0DRegs,16);
	}
}

void CRegistersPP::TestMMXreg(void)
{
	//	MMX switch has already been checked for in Run()
	
	LOGTESTHEADER("TestMMXreg");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	MST.DoKeys("{ESC}");
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(src.Find("TestMMX();")); 
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());	
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());

	CString MMXRegs[] = {"MM0","MM1","MM2","MM3","MM4","MM5","MM6","MM7"};
	CString MMXRegValues[] = {	"1111111111111111",
								"2222222222222222",
								"3333333333333333",
								"4444444444444444",
								"5555555555555555",
								"6666666666666666",
								"7777777777777777",
								"8888888888888888"};

	int num_reg = 8;
	int count = 0;

	//	step through source code
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(dbg.StepOver());
		EXPECT_TRUE(dbg.StepOver());
	}

	//	do one stepover
	if (!bSystemIsWin9X)
	EXPECT_TRUE(dbg.StepOver());

	//	now verify register values	
	EXPECT_TRUE(regs.Enable());

	for (count = 0; count< num_reg; count++)
	{
		//	test in reg window
		EXPECT_TRUE(regs.RegisterValueIs(MMXRegs[count], "" , (count+1)*100, FALSE));	
	}
	
	
	EXPECT_TRUE(cxx.Enable(EE_ALL_INFO));
	
	for (count = 0; count< num_reg; count++)
	{
		//	test in watch window
		char str[32];
		char strReg[8];
		strcpy(strReg,MMXRegs[count]);
		itoa((count+1)*100,str,10);

		testRegVal(strReg, "unsigned __int64", str,"Test MMX in Watch - Code");
	}

	//	modify register MMi in reg window
	EXPECT_TRUE(regs.Enable());
	
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.SetRegister(MMXRegs[count], MMXRegValues[count] , 0, TRUE));
	}
	
	//	do one stepover
	EXPECT_TRUE(regs.Disable());
	
	if (!bSystemIsWin9X)
	EXPECT_TRUE(dbg.StepOver());

	//	now verify register values

	EXPECT_TRUE(regs.Enable());	
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(MMXRegs[count], MMXRegValues[count] , 0, TRUE));
	}

	EXPECT_TRUE(cxx.Enable(EE_ALL_INFO));
	EXPECT_TRUE(dbg.ToggleHexDisplay(TRUE));
	for (count = 0; count< num_reg; count++)
	{
		//	test in watch window
		char str[32];
		char strReg[8];
		strcpy(strReg,MMXRegs[count]);
		strcpy(str,"0x");
		strcat(str,MMXRegValues[count]);
		testRegVal(strReg, "unsigned __int64", str,"Test MMX in Watch - Reg Window");
	}
	EXPECT_TRUE(dbg.ToggleHexDisplay(FALSE));
}

void CRegistersPP::Test3dNowReg(void)
{
	if (!(CMDLINE->GetBooleanValue("k6",FALSE)||CMDLINE->GetBooleanValue("k7",FALSE))) 
		return;	//	exit if 3dnow switch is not set	
	
	LOGTESTHEADER("Test3dNowReg");

	//	Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	MST.DoKeys("{ESC}");
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(src.Find("Test3dNow();")); 
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());	
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());	
	
	CString MMXRegs[] = {"MM0","MM1","MM2","MM3","MM4","MM5","MM6","MM7"};

	CString MMXijRegs[] = {	"MM00","MM10","MM20","MM30","MM40","MM50","MM60","MM70",
							"MM01","MM11","MM21","MM31","MM41","MM51","MM61","MM71"};

	CString MMXijRegValues[] = {	"+1.11111E+001","+2.22222E+001","+3.33333E+001","+4.44444E+001","+5.55555E+001",
									"+6.66666E+001","+7.77777E+001","+8.88888E+001",
									"-1.11111E-001","-2.22222E-001","-3.33333E-001","-4.44444E-001","-5.55555E-001",
									"-6.66666E-001","-7.77777E-001","-8.88888E-001"};


	CString MMXRegVal[] = {	"BDE38E2A4131C711","BE638E2A41B1C711","BEAAAA9F4205554D","BEE38E2A4231C711",
							"BF0E38DA425E38D5","BF2AAA9F4285554D","BF471C65429B8E2F","BF638E2A42B1C711" };

	int num_reg = 8;
	int count = 0;

	//	step through source code
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(dbg.StepOver());
		EXPECT_TRUE(dbg.StepOver());
	}

	//	do one stepover
	if (!bSystemIsWin9X)
	EXPECT_TRUE(dbg.StepOver());

	//	now verify register values
	CString MMXijStepOverValues[] = {	"+1.00000E+000","+3.00000E+000","+5.00000E+000","+7.00000E+000","+9.00000E+000",
										"+1.10000E+001","+1.30000E+001","+1.50000E+001","+2.00000E+000","+4.00000E+000",
										"+6.00000E+000","+8.00000E+000","+1.00000E+001","+1.20000E+001","+1.40000E+001",
										"+1.60000E+001"	};
	
	//	test in reg window
	EXPECT_TRUE(regs.Enable());
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(MMXijRegs[count], MMXijStepOverValues[count], 0, TRUE));
		EXPECT_TRUE(regs.RegisterValueIs(MMXijRegs[count+num_reg], MMXijStepOverValues[count+num_reg], 0, TRUE));	
	}

	//	test in watch window
	EXPECT_TRUE(cxx.Enable(EE_ALL_INFO));
	for (count = 0; count< num_reg; count++)
	{
		char str[32];
		char strReg[8];
		float f = 0.0;
	
		strcpy(strReg,MMXijRegs[count]);		
		f = (float) atof(MMXijStepOverValues[count]);
		
		if (f < 10)
			sprintf(str,"%6.5f",f);
		else
			sprintf(str,"%6.4f",f);
		
		testRegVal(strReg, "float", str,"Test MMXij in Watch - Code");
		
		strcpy(strReg,MMXijRegs[count+num_reg]);		
		f = (float) atof(MMXijStepOverValues[count+num_reg]);

		if (f < 10)
			sprintf(str,"%6.5f",f);
		else
			sprintf(str,"%6.4f",f);
		
		testRegVal(strReg, "float", str,"Test MMXij in Watch - Code");
	}



	EXPECT_TRUE(regs.Enable());

	//	initialize MMi to set MMij correctly
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.SetRegister(MMXRegs[count],"B727C5AC47C35000" , 0, TRUE));
	}

	//	verify that MMij changed correctly
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(MMXijRegs[count], "+1.00000E+005", 0, TRUE));
		EXPECT_TRUE(regs.RegisterValueIs(MMXijRegs[count+num_reg], "-1.00000E-005", 0, TRUE));
	}

	//	modify register MMi0 & MMi1 in reg window
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.SetRegister(MMXijRegs[count], MMXijRegValues[count], 0, TRUE));
		EXPECT_TRUE(regs.SetRegister(MMXijRegs[count+num_reg], MMXijRegValues[count+num_reg], 0, TRUE));
	}

	EXPECT_TRUE(regs.Disable());

	//	do one stepover
	if (!bSystemIsWin9X)
	EXPECT_TRUE(dbg.StepOver());

	//	verify MMij values

	//	test in reg window
	EXPECT_TRUE(regs.Enable());
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(MMXijRegs[count], MMXijRegValues[count], 0, TRUE));
		EXPECT_TRUE(regs.RegisterValueIs(MMXijRegs[count+num_reg], MMXijRegValues[count+num_reg], 0, TRUE));	
	}

	//	test in watch window
	EXPECT_TRUE(cxx.Enable(EE_ALL_INFO));
	for (count = 0; count< num_reg; count++)
	{
		char str[32];
		char strReg[8];
		float f = 0.0;
	
		strcpy(strReg,MMXijRegs[count]);		
		f = (float) atof(MMXijRegValues[count]);
		sprintf(str,"%6.4f",f);
		testRegVal(strReg, "float", str,"Test MMXij in Watch - Code");
		
		strcpy(strReg,MMXijRegs[count+num_reg]);		
		f = (float) atof(MMXijRegValues[count+num_reg]);
		sprintf(str,"%f",f);
		testRegVal(strReg, "float", str,"Test MMXij in Watch - Code");
	}

	//	verify that MMi changed correctly
	EXPECT_TRUE(regs.Enable());
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(MMXRegs[count], MMXRegVal[count], 0, TRUE));
	}

}

void CRegistersPP::TestXMMreg(void)
{
	if (!(CMDLINE->GetBooleanValue("kni",FALSE)||CMDLINE->GetBooleanValue("wni",FALSE))) 
		return;	//	exit if P3 switch is not set	

	LOGTESTHEADER("TestXMMreg");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	MST.DoKeys("{ESC}");
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(src.Find("TestXMM();")); 
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());	
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());

	CString XMMRegs[] = {"XMM0","XMM1","XMM2","XMM3","XMM4","XMM5","XMM6","XMM7"};
	CString XMMRegValues[] = {	"11111111111111111111111111111111",
								"22222222222222222222222222222222",
								"33333333333333333333333333333333",
								"44444444444444444444444444444444",
								"55555555555555555555555555555555",
								"66666666666666666666666666666666",
								"77777777777777777777777777777777",
								"88888888888888888888888888888888"};

	CString XMMijRegs[] = {	"XMM00","XMM01","XMM02","XMM03", "XMM10","XMM11","XMM12","XMM13",
							"XMM20","XMM21","XMM22","XMM23", "XMM30","XMM31","XMM32","XMM33",
							"XMM40","XMM41","XMM42","XMM43", "XMM50","XMM51","XMM52","XMM53",
							"XMM60","XMM61","XMM62","XMM63", "XMM70","XMM71","XMM72","XMM73" };

	CString XMMijRegValues[] = {	"+1.00000E+001","+1.00001E+001","+1.00011E+001","+1.00111E+001",
									"+2.00000E+001","+2.00002E+001","+2.00022E+001","+2.00222E+001",
									"+3.00000E+001","+3.00003E+001","+3.00033E+001","+3.00333E+001",
									"+4.00000E+001","+4.00004E+001","+4.00044E+001","+4.00444E+001",	
									"+5.00000E+001","+5.00005E+001","+5.00055E+001","+5.00555E+001",	
									"+6.00000E+001","+6.00006E+001","+6.00066E+001","+6.00666E+001",	
									"+7.00000E+001","+7.00007E+001","+7.00077E+001","+7.00777E+001",	
									"+8.00000E+001","+8.00008E+001","+8.00088E+001","+8.00888E+001"	};

	int num_reg = 8;
	int count = 0;

	CString XMMRegTestVal[] = {	
							"4080000040400000400000003F800000",		//	4,3,2,1
							"4100000040E0000040C0000040A00000",		//	8,7,6,5
							"41400000413000004120000041100000",		//	12,11,10,9
							"41800000417000004160000041500000",		//	16,15,14,13
							"41A00000419800004190000041880000",		//	20,19,18,17
							"41C0000041B8000041B0000041A80000",		//	24,23,22,21
							"41E0000041D8000041D0000041C80000",		//	28,27,26,25
							"4200000041F8000041F0000041E80000"		//	32,31,30,29
								};

	//	step through source code
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(dbg.StepOver());
	}

	//	do one stepover
	if (!bSystemIsWin9X)
	EXPECT_TRUE(dbg.StepOver());

	//	now verify XMMi register values
	EXPECT_TRUE(regs.Enable());
	
	for (count = 0; count< num_reg; count++)
	{		
		EXPECT_TRUE(regs.RegisterValueIs(XMMRegs[count], XMMRegTestVal[count] ,0 , TRUE));
	}

	//	verify XMMij
	CString XMMijStepOverValues[] = {	
									"+1.00000E+000","+2.00000E+000","+3.00000E+000","+4.00000E+000",
									"+5.00000E+000","+6.00000E+000","+7.00000E+000","+8.00000E+000",
									"+9.00000E+000","+1.00000E+001","+1.10000E+001","+1.20000E+001",
									"+1.30000E+001","+1.40000E+001","+1.50000E+001","+1.60000E+001",	
									"+1.70000E+001","+1.80000E+001","+1.90000E+001","+2.00000E+001",	
									"+2.10000E+001","+2.20000E+001","+2.30000E+001","+2.40000E+001",	
									"+2.50000E+001","+2.60000E+001","+2.70000E+001","+2.80000E+001",	
									"+2.90000E+001","+3.00000E+001","+3.10000E+001","+3.20000E+001"	
									};

	//	test in reg window
	EXPECT_TRUE(regs.Enable());
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(XMMijRegs[count*4], XMMijStepOverValues[count*4] , 0, TRUE));
		EXPECT_TRUE(regs.RegisterValueIs(XMMijRegs[count*4 + 1], XMMijStepOverValues[count*4 + 1] , 0, TRUE));
		EXPECT_TRUE(regs.RegisterValueIs(XMMijRegs[count*4 + 2], XMMijStepOverValues[count*4 + 2] , 0, TRUE));
		EXPECT_TRUE(regs.RegisterValueIs(XMMijRegs[count*4 + 3], XMMijStepOverValues[count*4 + 3] , 0, TRUE));
	}

	//	test in watch window
	EXPECT_TRUE(cxx.Enable(EE_ALL_INFO));
	for (count = 0; count< num_reg; count++)
	{
		char str[32];
		char strReg[8];
		float f = 0.0;
	
		strcpy(strReg,XMMijRegs[count*4]);		
		f = (float) atof(XMMijStepOverValues[count*4]);

		if (f < 10)
			sprintf(str,"%6.5f",f);
		else
			sprintf(str,"%6.4f",f);

		testRegVal(strReg, "float", str,"Test XMMij in Watch - Code");
		
		strcpy(strReg,XMMijRegs[count*4 + 1]);		
		f = (float) atof(XMMijStepOverValues[count*4 + 1]);
		
		if (f < 10)
			sprintf(str,"%6.5f",f);
		else
			sprintf(str,"%6.4f",f);
		
		testRegVal(strReg, "float", str,"Test XMMij in Watch - Code");

		strcpy(strReg,XMMijRegs[count*4+ 2]);		
		f = (float) atof(XMMijStepOverValues[count*4 + 2]);
		
		if (f < 10)
			sprintf(str,"%6.5f",f);
		else
			sprintf(str,"%6.4f",f);
		
		testRegVal(strReg, "float", str,"Test XMMij in Watch - Code");

		strcpy(strReg,XMMijRegs[count*4+ 3]);		
		f = (float) atof(XMMijStepOverValues[count*4 + 3]);
		
		if (f < 10)
			sprintf(str,"%6.5f",f);
		else
			sprintf(str,"%6.4f",f);

		testRegVal(strReg, "float", str,"Test XMMij in Watch - Code");
	}
	
	//	modify register XMMi in reg window
	EXPECT_TRUE(regs.Enable());
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.SetRegister(XMMRegs[count], XMMRegValues[count] , 0, TRUE));
	}

	//	do one stepover
	EXPECT_TRUE(regs.Disable());

	if (!bSystemIsWin9X)
	EXPECT_TRUE(dbg.StepOver());

	//	now verify XMMi register values
	EXPECT_TRUE(regs.Enable());
	
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(XMMRegs[count], XMMRegValues[count] , 0 , TRUE));
	}

	//	initialize XMMi to set XMMij correctly
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.SetRegister(XMMRegs[count], "47C3500047C3500047C3500047C35000" , 0, TRUE));
	}

	//	verify that XMMij changed correctly
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(XMMijRegs[count*4], "+1.00000E+005", 0, TRUE));
		EXPECT_TRUE(regs.RegisterValueIs(XMMijRegs[count*4 + 1], "+1.00000E+005", 0, TRUE));
		EXPECT_TRUE(regs.RegisterValueIs(XMMijRegs[count*4 + 2], "+1.00000E+005", 0, TRUE));
		EXPECT_TRUE(regs.RegisterValueIs(XMMijRegs[count*4 + 3], "+1.00000E+005", 0, TRUE));
	}

	//	modify register XMMij in reg window
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.SetRegister(XMMijRegs[count*4], XMMijRegValues[count*4] , 0, TRUE));
		EXPECT_TRUE(regs.SetRegister(XMMijRegs[count*4 + 1], XMMijRegValues[count*4 + 1] , 0, TRUE));
		EXPECT_TRUE(regs.SetRegister(XMMijRegs[count*4 + 2], XMMijRegValues[count*4 + 2] , 0, TRUE));
		EXPECT_TRUE(regs.SetRegister(XMMijRegs[count*4 + 3], XMMijRegValues[count*4 + 3] , 0, TRUE));
	}

	//	do one stepover
	EXPECT_TRUE(regs.Disable());

	if (!bSystemIsWin9X)
	EXPECT_TRUE(dbg.StepOver());

	//	verify XMMij values

	//	test in reg window
	EXPECT_TRUE(regs.Enable());
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(XMMijRegs[count*4], XMMijRegValues[count*4] , 0, TRUE));
		EXPECT_TRUE(regs.RegisterValueIs(XMMijRegs[count*4 + 1], XMMijRegValues[count*4 + 1] , 0, TRUE));
		EXPECT_TRUE(regs.RegisterValueIs(XMMijRegs[count*4 + 2], XMMijRegValues[count*4 + 2] , 0, TRUE));
		EXPECT_TRUE(regs.RegisterValueIs(XMMijRegs[count*4 + 3], XMMijRegValues[count*4 + 3] , 0, TRUE));
	}

	//	test in watch window
	EXPECT_TRUE(cxx.Enable(EE_ALL_INFO));
	for (count = 0; count< num_reg; count++)
	{
		char str[32];
		char strReg[8];
		float f = 0.0;
	
		strcpy(strReg,XMMijRegs[count*4]);		
		f = (float) atof(XMMijRegValues[count*4]);
		sprintf(str,"%6.4f",f);
		testRegVal(strReg, "float", str,"Test XMMij in Watch - Code");
		
		strcpy(strReg,XMMijRegs[count*4 + 1]);		
		f = (float) atof(XMMijRegValues[count*4 + 1]);
		sprintf(str,"%6.4f",f);
		testRegVal(strReg, "float", str,"Test XMMij in Watch - Code");

		strcpy(strReg,XMMijRegs[count*4+ 2]);		
		f = (float) atof(XMMijRegValues[count*4 + 2]);
		sprintf(str,"%6.4f",f);
		testRegVal(strReg, "float", str,"Test XMMij in Watch - Code");

		strcpy(strReg,XMMijRegs[count*4+ 3]);		
		f = (float) atof(XMMijRegValues[count*4 + 3]);
		sprintf(str,"%6.4f",f);
		testRegVal(strReg, "float", str,"Test XMMij in Watch - Code");
	}

	//	verify that XMMi changed correctly

	CString XMMNewRegVal[] = {	
							"41202D77412004814120006941200000",
							"41A02D7741A0048141A0006941A00000",
							"41F0443341F006C241F0009D41F00000",
							"42202D77422004814220006942200000",
							"424838D5424805A24248008342480000",
							"42704433427006C24270009D42700000",
							"428C27C8428C03F1428C005C428C0000",
							"42A02D7742A0048142A0006942A00000"
								};	

	EXPECT_TRUE(regs.Enable());
	
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(XMMRegs[count], XMMNewRegVal[count], 0, TRUE));
	}

}

void CRegistersPP::TestWNIreg(void)
{
	if (!CMDLINE->GetBooleanValue("wni",FALSE)) return;	//	exit if wni switch is not set	

	LOGTESTHEADER("TestWNIreg");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	MST.DoKeys("{ESC}");
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(src.Find("TestXMM();")); 
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());	
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());


	CString XMMRegs[] = {"XMM0","XMM1","XMM2","XMM3","XMM4","XMM5","XMM6","XMM7"};
	CString XMMRegValues[] = {	"40000000000000003FF0000000000000",
								"40100000000000004008000000000000",
								"40180000000000004014000000000000",
								"4020000000000000401C000000000000",
								"40240000000000004022000000000000",
								"40280000000000004026000000000000",
								"402C000000000000402A000000000000",
								"4030000000000000402E000000000000"};

	CString XMM0DRegs[] = {	"XMM0DL","XMM0DH","XMM1DL","XMM1DH","XMM2DL","XMM2DH",
							"XMM3DL","XMM3DH","XMM4DL","XMM4DH","XMM5DL","XMM5DH",
							"XMM6DL","XMM6DH","XMM7DL","XMM7DH" };

	CString XMM0DRegValues[] = {	"+1.00000000000000E+000","+2.00000000000000E+000","+3.00000000000000E+000",
									"+4.00000000000000E+000","+5.00000000000000E+000","+6.00000000000000E+000",
									"+7.00000000000000E+000","+8.00000000000000E+000","+9.00000000000000E+000",
									"+1.00000000000000E+001","+1.10000000000000E+001","+1.20000000000000E+001",
									"+1.30000000000000E+001","+1.40000000000000E+001","+1.50000000000000E+001",
									"+1.60000000000000E+001"	};

	CString XMM0IRegs[] = {	"XMM0IL","XMM0IH","XMM1IL","XMM1IH","XMM2IL","XMM2IH",
							"XMM3IL","XMM3IH","XMM4IL","XMM4IH","XMM5IL","XMM5IH",
							"XMM6IL","XMM6IH","XMM7IL","XMM7IH" };

	CString XMM0IRegValues[] = {	"4607182418800017408","4611686018427387904","4613937818241073152",
									"4616189618054758400","4617315517961601024","4618441417868443648",
									"4619567317775286272","4620693217682128896","4621256167635550208",
									"4621819117588971520","4622382067542392832","4622945017495814144",
									"4623507967449235456","4624070917402656768","4624633867356078080",
									"4625196817309499392"	};


	int num_reg = 8;
	int count = 0;


	//	step through source code
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(dbg.StepOver());
	}

	//	do one stepover
	if (!bSystemIsWin9X)
	EXPECT_TRUE(dbg.StepOver());

	//	now verify XMMiD register values
	
	CString XMMiDStepOverValues[] = {	
										"+2.00000047311187E+000","+5.12000122547150E+002",
										"+8.19200197219849E+003","+1.31072031677246E+005",
										"+5.24288127075195E+005","+2.09715250927734E+006",
										"+8.38861004101563E+006","+3.35544401796875E+007",
										"+6.71088803828125E+007","+1.34217760796875E+008",
										"+2.68435521656250E+008","+5.36871043437500E+008",
										"+1.07374208712500E+009","+2.14748417475000E+009",
										"+4.29496835050000E+009","+8.58993670300000E+009"
									};

	//	test in reg window
	EXPECT_TRUE(regs.Enable());
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(XMM0DRegs[count*2], XMMiDStepOverValues[count*2] , 0, TRUE));
		EXPECT_TRUE(regs.RegisterValueIs(XMM0DRegs[count*2 + 1], XMMiDStepOverValues[count*2 + 1] , 0, TRUE));
	}


	//	verify XMMiI register values
	CString XMMiIStepOverValues[] = {	
										"4611686019492741120","4647714816524288000",
										"4665729215040061440","4683743613553737728",
										"4692750812811624448","4701758012068462592",
										"4710765211325300736","4719772410582138880",
										"4724276010211082240","4728779609839501312",
										"4733283209467920384","4737786809096339456",
										"4742290408724758528","4746794008353177600",
										"4751297607981596672","4755801207610015744"
									};


	//	test in watch window
	EXPECT_TRUE(cxx.Enable(EE_ALL_INFO));
	for (count = 0; count< num_reg; count++)
	{
		char str[32];
		char strReg[8];
	
		strcpy(strReg,XMM0IRegs[count*2]);		
		strcpy(str,XMMiIStepOverValues[count*2]);
		testRegVal(strReg, "unsigned __int64", str,"Test XMMiI in Watch - Code");
		
		strcpy(strReg,XMM0IRegs[count*2 + 1]);		
		strcpy(str,XMMiIStepOverValues[count*2 + 1]);
		testRegVal(strReg, "unsigned __int64", str,"Test XMMiI in Watch - Code");
	}


	//
	//	verify that modifying XMMi changes XMM0D & XMM0I
	//
	EXPECT_TRUE(regs.Enable());
	
	//	modify register XMMi in reg window
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.SetRegister(XMMRegs[count], XMMRegValues[count] , 0, TRUE));
	}

	EXPECT_TRUE(cxx.Enable(EE_ALL_INFO));
	for (count = 0; count< num_reg; count++)
	{
		char str[32];
		char strReg[8];
		double dbl = 0.0;
		char **strptr = NULL;
	
		//	verify XMM0D

		strcpy(strReg,XMM0DRegs[count*2]);		
		strcpy(str,XMM0DRegValues[count*2]);		
		dbl = strtod(str,strptr);
		if (dbl < 10)
			sprintf(str,"%.13f",dbl);
		else
			sprintf(str,"%.12f",dbl);
		testRegVal(strReg, "double", str,"Test XMMD in Watch - Code");
		
		strcpy(strReg,XMM0DRegs[count*2 + 1]);		
		strcpy(str,XMM0DRegValues[count*2 + 1]);		
		dbl = strtod(str,strptr);
		if (dbl < 10)
			sprintf(str,"%.13f",dbl);
		else
			sprintf(str,"%.12f",dbl);
		testRegVal(strReg, "double", str,"Test XMMD in Watch - Code");

		//	verify XMM0I

		strcpy(strReg,XMM0IRegs[count*2]);		
		strcpy(str,XMM0IRegValues[count*2]);		
		testRegVal(strReg, "unsigned __int64", str,"Test XMMI in Watch - Code");

		strcpy(strReg,XMM0IRegs[count*2 + 1]);		
		strcpy(str,XMM0IRegValues[count*2 + 1]);		
		testRegVal(strReg, "unsigned __int64", str,"Test XMMI in Watch - Code");
	}
	
	//	verify that modifying XMM0D changes XMMi

	//	XMMD values to test XMM with
	CString XMM0D_TestValues[] = {	"+5.00000000000000E+001","+5.10000000000000E+001","+5.20000000000000E+001",
									"+5.30000000000000E+001","+5.40000000000000E+001","+5.50000000000000E+001",
									"+5.60000000000000E+001","+5.70000000000000E+001","+5.80000000000000E+001",
									"+5.90000000000000E+001","+6.00000000000000E+001","+6.10000000000000E+001",
									"+6.20000000000000E+001","+6.30000000000000E+001","+6.40000000000000E+001",
									"+6.50000000000000E+001"	};

	//	corresponding XMM values
	CString XMM_D_TestValues[] = {	"40498000000000004049000000000000",
									"404A800000000000404A000000000000",
									"404B800000000000404B000000000000",
									"404C800000000000404C000000000000",
									"404D800000000000404D000000000000",
									"404E800000000000404E000000000000",
									"404F800000000000404F000000000000",
									"40504000000000004050000000000000"};
	
	EXPECT_TRUE(regs.Enable());
	
	//	modify register XMM0D in reg window
	for (count = 0; count< num_reg*2; count++)
	{
		EXPECT_TRUE(regs.SetRegister(XMM0DRegs[count], XMM0D_TestValues[count] , 0, TRUE));
	}

	//	now verify XMMi register values
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(XMMRegs[count], XMM_D_TestValues[count] , 0, TRUE));
	}	
	
	//	verify that modifying XMM0I changes XMMi



	EXPECT_TRUE(regs.Enable());
	
	//	modify register XMM0I in watch window
	EXPECT_TRUE(dbg.ToggleHexDisplay(FALSE));

	for (count = 0; count <num_reg*2; count++)
	{
		EXPECT_TRUE(cxx.SetExpressionValue(XMM0IRegs[count],(count+1)*101));
	}

	//	cooresponding XMMi reg values
	CString XMM_I_TestValues[] = {	"00000000000000CA0000000000000065",
									"0000000000000194000000000000012F",
									"000000000000025E00000000000001F9",
									"000000000000032800000000000002C3",
									"00000000000003F2000000000000038D",
									"00000000000004BC0000000000000457",
									"00000000000005860000000000000521",
									"000000000000065000000000000005EB"};


	//	now verify XMMi register values
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(XMMRegs[count], XMM_I_TestValues[count] , 0 , TRUE));
	}	
		
	//	verify that XMM0D modifies correctly in reg & watch window
	//	modify in watch
	cxx.Enable(EE_ALL_INFO);

	//	set value in watch window
	EXPECT_TRUE(dbg.ToggleHexDisplay(FALSE));
	for (count = 0; count <num_reg*2; count++)
	{
		EXPECT_TRUE(cxx.SetExpressionValue(XMM0DRegs[count],count*11));
	}
	
	//	corresponding values in reg window

	CString XMM0DWatchValues[] = {	"+0.00000000000000E+000","+1.10000000000000E+001","+2.20000000000000E+001",
									"+3.30000000000000E+001","+4.40000000000000E+001","+5.50000000000000E+001",
									"+6.60000000000000E+001","+7.70000000000000E+001","+8.80000000000000E+001",
									"+9.90000000000000E+001","+1.10000000000000E+002","+1.21000000000000E+002",
									"+1.32000000000000E+002","+1.43000000000000E+002","+1.54000000000000E+002",
									"+1.65000000000000E+002"	};

	//	verify in reg
	EXPECT_TRUE(regs.Enable());
	
	for (count = 0; count< num_reg*2; count++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(XMM0DRegs[count], XMM0DWatchValues[count] , 0 , TRUE));
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\registers\regcase.h ===
///////////////////////////////////////////////////////////////////////////////
//	Regcase.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CRegistersIDETest Class
//

#ifndef __Regcase_H__
#define __Regcase_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\DbgTestBase.h"
#include "regsub.h"

const int gl_constNumberUndoRedo = 1;

///////////////////////////////////////////////////////////////////////////////
//	CRegistersIDETest class

class CRegistersIDETest : public CDbgTestBase
{
	DECLARE_TEST(CRegistersIDETest, CRegistersSubSuite)

// Attributes
public:
	// the base name of the localized directories and files we will use.
	CString m_strProjBase;
	// the location of the unlocalized sources, under which the projects we will use will be located.
	CString m_strSrcDir;
	// the locations of the dll and exe projects, and their localized sources, that we will use for this test.
	CString m_strExeDir;

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);

// Test Cases

	void VerifyEIP(void);
	void EIP_ESP_ChangeAfterStep(void);
	void VerifyFlags(void);
	void VerifyEAX(void);
	void EditRegisters(void);
	void ToggleFlags(void);
	void EditRegisterViaQuickWatch(void);
	void Registers_Dam_Watch_Memory(void);
	void Registers_Watch_Memory(void);
	void Change_EAX_Changes_RetValue(void);
	void DisplayIsAlwaysHex(void);
	void IntegrityWithSetFocusToThread(void);
	void IntegrityWithFunctionEvaluation(void);
	void BoundaryConditionsForEditingValues(void);
	void TypeInvalidValues(void);
	void FloatingPointException(void);
	void VerifyDockingView(void);

protected:
	void HelperFunctionVerifyEIP(char* szTestCaseName, char* szEIP);
	void MinimalTestResizeMoveWindow(void);
// TODO(michma - 3/2/00): this isn't working yet.
//	void TestResizeMoveWindow(BOOL bIsDocked, BOOL bFullTest);

private:
	char m_pszUndoRedoRegisters[gl_constNumberUndoRedo][128];
	int m_TestNumber;
	int m_TotalNumberOfTests;
	CString m_strLogInfo;
};

#endif //__Regcase_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\registers\regcase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	Regcase.CPP
//											 
//	Created by :			
//		dklem
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "Regcase.h"	
#include "process.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
											   
IMPLEMENT_TEST(/*999,*/ CRegistersIDETest, CDbgTestBase, "General", -1, CRegistersSubSuite)

// each function that runs a test has this prototype.
typedef void (CRegistersIDETest::*PTR_TEST_FUNC)(void); 

// Information about a test to be put in the test header
#define LOGTESTHEADER(strTestName) 	m_strLogInfo.Format("# - %d.  %s. Total # - %d, Passed - %d %%", ++m_TestNumber, strTestName, m_TotalNumberOfTests, (m_TestNumber*100)/m_TotalNumberOfTests);  \
									LogTestHeader(m_strLogInfo);

// we randomly pick out of the following list of tests and run them.
// insert functions for new tests to the end of the list.

PTR_TEST_FUNC tests[] = 
{
	&CRegistersIDETest::VerifyEIP,
	&CRegistersIDETest::EIP_ESP_ChangeAfterStep,
	&CRegistersIDETest::VerifyFlags,
	&CRegistersIDETest::VerifyEAX,
	&CRegistersIDETest::EditRegisters,
	&CRegistersIDETest::ToggleFlags,
	&CRegistersIDETest::EditRegisterViaQuickWatch,
	&CRegistersIDETest::Registers_Dam_Watch_Memory,
	&CRegistersIDETest::Registers_Watch_Memory,
	&CRegistersIDETest::Change_EAX_Changes_RetValue,
	&CRegistersIDETest::DisplayIsAlwaysHex,
	&CRegistersIDETest::IntegrityWithSetFocusToThread,
	&CRegistersIDETest::IntegrityWithFunctionEvaluation,
	&CRegistersIDETest::BoundaryConditionsForEditingValues,
	&CRegistersIDETest::TypeInvalidValues,
	&CRegistersIDETest::FloatingPointException,
	&CRegistersIDETest::VerifyDockingView,
};

											 
void CRegistersIDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();

}

void CRegistersIDETest::Run()
{	 
	/******************
	 * INITIALIZATION *
	 ******************/

	// the base name of the localized directories and files we will use.
	if(GetSystem() & SYSTEM_DBCS)
		m_strProjBase = "[\\]^{|}Aa`@~ Registers";
	else
		m_strProjBase = "Registers";

	// the location of the unlocalized sources, under which the projects we will use will be located.
	m_strSrcDir = GetCWD() + "src\\Registers";
	// the locations of the dll and exe projects, and their localized sources, that we will use for this test.
	m_strExeDir = m_strSrcDir + "\\" + m_strProjBase + " exe";

	if(!CMDLINE->GetBooleanValue("noclean", FALSE))
	{
		// clean-up the exe project from the last run.
		KillFiles(m_strExeDir + "\\Debug\\", "*.*");
		KillFiles(m_strExeDir + "\\Release\\", "*.*");
		RemoveDirectory(m_strExeDir + "\\Debug");
		RemoveDirectory(m_strExeDir + "\\Release");
		KillFiles(m_strExeDir + "\\", "*.*");
		RemoveDirectory(m_strExeDir);
		// set the options for the exe project we are building for this test.
		CProjWizOptions *pWin32AppWizOpt = new(CWin32AppWizOptions);
		pWin32AppWizOpt->m_strLocation = m_strSrcDir;
		pWin32AppWizOpt->m_strName = m_strProjBase + " exe";			
		// create the exe project.
		EXPECT_SUCCESS(prj.New(pWin32AppWizOpt));
		// create a new localized exe source file in the project dir from the unlocalized exe source file.
		CopyFile(m_strSrcDir + "\\" + "Registers.cpp", m_strExeDir + "\\" + m_strProjBase + " exe.cpp", FALSE);
		// make it writable so it can be cleaned up later.
		SetFileAttributes(m_strExeDir + "\\" + m_strProjBase + " exe.cpp", FILE_ATTRIBUTE_NORMAL);
		// add the source to the project.
		EXPECT_SUCCESS(prj.AddFiles(m_strProjBase + " exe.cpp"));
		// build the project.
		EXPECT_SUCCESS(prj.Build());
	}
	else
	{
		EXPECT_SUCCESS(prj.Open(m_strExeDir + "\\" + m_strProjBase + " exe.dsp"));
	}

	// all tests expect the ide to be in this initial state.
	EXPECT_TRUE(dbg.StepOver());
	
	// indexes into the test function array.
	int iTest;
	m_TestNumber = 0;
	m_TotalNumberOfTests = sizeof(tests) / sizeof(PTR_TEST_FUNC);
	// we only want to randomly run each test once.
	RandomNumberCheckList rncl(sizeof(tests) / sizeof(PTR_TEST_FUNC));

	// randomly run each test once.
//	while((iTest = rncl.GetNext()) != -1)
	for(iTest = 0; iTest < sizeof(tests) / sizeof(PTR_TEST_FUNC); iTest++)
		(this->*(tests[iTest]))();

	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_SUCCESS(prj.Close());
}	

///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////

void CRegistersIDETest::HelperFunctionVerifyEIP(char* szTestCaseName, char* szEIP)
{

	CString csDamEIP;

	EXPECT_TRUE(dam.Enable());
	csDamEIP = dam.GetInstruction();
	csDamEIP = csDamEIP.Left(8);
	EXPECT_TRUE(dam.Disable());

	// Resize and Move
	EXPECT_TRUE(regs.Enable());	
	EXPECT_TRUE(regs.RegisterValueIs(CString("EIP"), csDamEIP, -1));

	// Return EIP if requested
	if(szEIP)
		strcpy(szEIP, LPCTSTR(csDamEIP));
}


void CRegistersIDETest::VerifyEIP(void)
{

	LOGTESTHEADER("VerifyEIP");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	EXPECT_TRUE(regs.Enable());

	HelperFunctionVerifyEIP("VerifyEIP", NULL);
}

void CRegistersIDETest::EIP_ESP_ChangeAfterStep(void)
{
	LOGTESTHEADER("EIP_ESP_ChangeAfterStep");

	char *pszFlags[] = {"EIP ", "ESP "};
	CString csRegValues[2];
	int ii;

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	EXPECT_TRUE(regs.Enable());

	// Get initial values
	for(ii = 0; ii < sizeof(pszFlags)/sizeof(*pszFlags); ii++)
		csRegValues[ii] = regs.GetRegister(CString(pszFlags[ii]), NULL);

	// Step Into
	EXPECT_TRUE(dbg.StepInto(1));
	EXPECT_TRUE(regs.Enable());

	// Make sure that values changed
	for(ii = 0; ii < sizeof(pszFlags)/sizeof(*pszFlags); ii++)
		EXPECT_TRUE(!regs.RegisterValueIs(CString(pszFlags[ii]), csRegValues[ii], -1));

}

void CRegistersIDETest::VerifyFlags(void)
{

	LOGTESTHEADER("VerifyFlags");

	char *pszFlags[] = {"OV", "UP", "EI", "PL", "ZR", "AC", "PE", "CY"};
	BOOL bSame, bSame1;

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	EXPECT_TRUE(regs.Enable());

	// Verify that all flags are in place and their value are either 0 or 1
	for(int ii = 0; ii < sizeof(pszFlags)/sizeof(*pszFlags); ii++)
	{
		bSame = regs.RegisterValueIs(CString(pszFlags[ii]), CString("0"), -1);
		bSame1 = regs.RegisterValueIs(CString(pszFlags[ii]), CString("1"), -1);
		EXPECT_TRUE(bSame || bSame1);

	}

}

void CRegistersIDETest::VerifyEAX(void)
{

	LOGTESTHEADER("VerifyEAX");
	
	CString csRetValue;
	int nRegValue;

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	// Step Over the Foo(7) function
	EXPECT_TRUE(dbg.StepOver());

	// Get return value
	EXPECT_TRUE(ee.GetExpressionValue("res", csRetValue));

	EXPECT_TRUE(regs.Enable());

	// Verify that EAX is correct
	regs.GetRegister(CString("EAX"), &nRegValue);

	int x = atoi(LPCTSTR(csRetValue));

	EXPECT_TRUE(nRegValue == atoi(LPCTSTR(csRetValue)));

}

void CRegistersIDETest::EditRegisters(void)
{

	LOGTESTHEADER("EditRegisters");

	char szNewValue[128];
	CString csRegister;
/*	char szTmpStr[128];
	char *ptr;
	int nStrLen;
	BOOL bSign;
*/	
	char *pszCPURegs[] =		{"EAX", "EBX", "ECX", "EDX", "ESI", "EDI", "EIP", "ESP", "EBP", "EFL"};
	char *pszCPUSegments[] = 	{"CS", "DS", "ES", "SS", "FS", "GS" }; 
	// TODO (dklem 11/16/00) EDO was removed from the list because you can edit just low 4 bytes.  BUG # 50809 in VS7
	// TODO(michma - 3/15/00): we can't distinguish yet between normal EIP and float EIP.
	char *pszFloatingInt[] =	{"CTRL", "STAT", "TAGS", /* "EIP", */ "CS", "DS", /*"EDO "*/};
	char *pszFloatingFloat[] =	{"ST0", "ST1", "ST2", "ST3", "ST4", "ST5", "ST6", "ST7"};

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	EXPECT_TRUE(regs.Enable());

	// initialize random numbers generator
	srand((unsigned)time( NULL ));


	m_pLog->RecordInfo("Testing cpu registers.");

	// Verify that all CPU registers and segments are in place and are editable
	for(int ii = 0; ii < sizeof(pszCPURegs)/sizeof(*pszCPURegs); ii++)

	{
		m_pLog->RecordInfo("Testing register %s.", pszCPURegs[ii]);

		// The next for cycle is for Multiple Undo/Redo verification
		for(int jj = 0; jj < gl_constNumberUndoRedo; jj++)
		{
			// Create a new value 
			sprintf(szNewValue, "%.8x", (int) (0xFFFFFFFF * (((float)rand()) / ((float)(RAND_MAX)))));
			strupr(szNewValue);

			// Save value for Multiple Undo/Redo verification
			strcpy(m_pszUndoRedoRegisters[jj], szNewValue);

			// Set value
			EXPECT_TRUE(regs.SetRegister(CString(pszCPURegs[ii]), CString(szNewValue), -1));

			if(0 == strcmp(pszCPURegs[ii], "EIP "))
			{
				EXPECT_TRUE(regs.Enable());
			}

			// Verify value
			EXPECT_TRUE(regs.RegisterValueIs(CString(pszCPURegs[ii]), CString(szNewValue), -1));
		}

		// TODO (dklem 11/13/00) Enable when this function available
		// HelperFunctio_MultipleUndoRedo(pszCPURegs[ii]);
	}

	m_pLog->RecordInfo("Testing CPU segments.");

	// Verify that all CPU segments and segments are in place and are editable
	for(ii = 0; ii < sizeof(pszCPUSegments)/sizeof(*pszCPUSegments); ii++)
	
	{
		m_pLog->RecordInfo("Testing register %s.", pszCPUSegments[ii]);

		// The next for cycle is for Multiple Undo/Redo verification
		for(int jj = 0; jj < gl_constNumberUndoRedo; jj++)
		{
			// Create a new value 
			sprintf(szNewValue, "%.4x", (int) (0xFFFF * (((float)rand()) / ((float)(RAND_MAX)))));
			strupr(szNewValue);

			// Save value for Multiple Undo/Redo verification
			strcpy(m_pszUndoRedoRegisters[jj], szNewValue);

			// Set value
			EXPECT_TRUE(regs.SetRegister(CString(pszCPUSegments[ii]), CString(szNewValue), -1));
			// Verify value
			EXPECT_TRUE(regs.RegisterValueIs(CString(pszCPUSegments[ii]), CString(szNewValue), -1));
		}

		// TODO (dklem 11/13/00) Enable when this function available
		// HelperFunctio_MultipleUndoRedo(pszCPUSegments[ii]);
	}

	m_pLog->RecordInfo("Testing floating point int.");

	for(ii = 0; ii < sizeof(pszFloatingInt)/sizeof(*pszFloatingInt); ii++)

	{
		m_pLog->RecordInfo("Testing register %s.", pszFloatingInt[ii]);

		// The next for cycle is for Multiple Undo/Redo verification
		for(int jj = 0; jj < gl_constNumberUndoRedo; jj++)
		{
			// Create a new value 
			if(!strcmp(pszFloatingInt[ii], "EIP ") || !strcmp(pszFloatingInt[ii], "EDO "))
				sprintf(szNewValue, "%.8x", (int) (0xFFFFFFFF * (((float)rand()) / ((float)(RAND_MAX)))));
			else
				sprintf(szNewValue, "%.4x", (int) (0xFFFF * (((float)rand()) / ((float)(RAND_MAX)))));
			strupr(szNewValue);

			// Save value for Multiple Undo/Redo verification
			strcpy(m_pszUndoRedoRegisters[jj], szNewValue);

			// Set value
			EXPECT_TRUE(regs.SetRegister(CString(pszFloatingInt[ii]), CString(szNewValue), -1));
			// Verify value
			EXPECT_TRUE(regs.RegisterValueIs(CString(pszFloatingInt[ii]), CString(szNewValue), -1));
		}

		// TODO (dklem 11/13/00) Enable when this function available
		// HelperFunctio_MultipleUndoRedo(pszFloatingInt[ii]);
	}

	// Verify that there are no IP and DO in floats
	// TODO: (dklem 10/14/99) Uncomment the following 2 lines when #50800 is fixed. FIXED in 8682 (11/16/99).
	csRegister = regs.GetRegister(CString(" IP "), NULL);
	EXPECT_TRUE(csRegister.IsEmpty());
	csRegister = regs.GetRegister(CString(" DO "), NULL);
	EXPECT_TRUE(csRegister.IsEmpty());

	// DON'T FORGET TO ADD MULTIPLE UNDO/REDO VERIFICATION FOR FLOATING POINTS
	// TODO (dklem 11/16/00) The following piece of code was commented because changing exponent changes mantissa.  BUG #63001 in VS7
/*
	// Don't forget to treat + correctly.  Otherwise it will be interpreted as Shift.
	for(ii = 0; ii < sizeof(pszFloatingFloat)/sizeof(*pszFloatingFloat); ii++)
	{
		csRegister = regs.GetRegister(CString(pszFloatingFloat[ii]), NULL);
		lstrcpyn(szNewValue, LPCTSTR(csRegister), sizeof(szNewValue));

		// Change value
		nStrLen = (int) strlen(szNewValue);
		for(int i = 0; i < nStrLen; i++)
		{
			if('0' <= szNewValue[i] && szNewValue[i] <= '9')
				szNewValue[i] = '0' + (int) (10 * (((float)rand()) / ((float)(RAND_MAX)))); 

			// Choose the sign randomly
			if('+' == szNewValue[i] || szNewValue[i] == '-')
			{
				bSign = (int) ((((float)rand()) / ((float)(RAND_MAX))) + 0.5); 

				// Verify that bSign is 1 and 0
				if(bSign)
					while(0);
				else
					while(0);
				

				// we should put {} around +.  Otherwise it would be treated as Shift
				if(bSign)
				{
					memcpy(szNewValue + i + 3, szNewValue + i + 1, nStrLen);
					strncpy(szNewValue + i, "{+}", 3);
					nStrLen +=2;
					i +=2;
					strcpy(szNewValue + nStrLen - 2, "00");
					*(szNewValue + nStrLen) = '\0';
				}
				else
					szNewValue[i] = '-';
			}


		}

		// Since STx are long doubles whose size is 10 bytes and limits are 1.2E +/- 4932 (19 digits), we put these limits
		if(4931 < atoi(szNewValue + nStrLen - 4))
			strcpy(szNewValue + nStrLen - 4, "4931");

		// Set value
		EXPECT_TRUE(regs.SetRegister(CString(pszFloatingFloat[ii]), CString(szNewValue), -1));

		// Remove {} from szNewValue
		ptr = szNewValue;
		while(NULL != (ptr = strstr(ptr, "{+}")))
		{
			strcpy(szTmpStr, ptr + 3);
			strcpy(ptr, "+");
			strcpy(ptr + 1, szTmpStr);
		}

		// Verify value
		EXPECT_TRUE(regs.RegisterValueIs(CString(pszFloatingFloat[ii]), CString(szNewValue), -1));

	}
*/
	// Test the boundary conditions
	EXPECT_TRUE(regs.SetRegister(CString(pszFloatingFloat[0]), CString("{+}1.00000000000000000e{+}0000"), -1));
	EXPECT_TRUE(regs.SetRegister(CString(pszFloatingFloat[0]), CString("{+}1"), -1));
	EXPECT_TRUE(regs.RegisterValueIs(CString(pszFloatingFloat[0]), CString("+1.00000000000000000e+0000"), -1));

	// TODO (dklem 11/17/00) The following piece was commented because of limits for STx seems to be incorrect.  BUG # 62937 in VS7
/*
	EXPECT_TRUE(regs.SetRegister(CString(pszFloatingFloat[0]), CString("{+}1.19000000000000000e{+}4932"), -1));
	EXPECT_TRUE(regs.RegisterValueIs(CString(pszFloatingFloat[0]), CString("+1.19000000000000000e+4932"), -1));

	EXPECT_TRUE(regs.SetRegister(CString(pszFloatingFloat[0]), CString("{+}1.19000000000000000e-4932"), -1));
	EXPECT_TRUE(regs.RegisterValueIs(CString(pszFloatingFloat[0]), CString("+1.19000000000000000e-4932"), -1));
*/
	EXPECT_TRUE(regs.SetRegister(CString(pszFloatingFloat[0]), CString("{+}1.21000000000000000e{+}4932"), -1));
	EXPECT_TRUE(regs.RegisterValueIs(CString(pszFloatingFloat[0]), CString("1#INF"), -1));

// TODO (dklem 11/16/00) The following piece of code was commented because changing exponent changes mantissa.  BUG #63001 in VS7
/*
	EXPECT_TRUE(regs.SetRegister(CString(pszFloatingFloat[0]), CString("{+}1.21000000000000000e-4932"), -1));
	EXPECT_TRUE(regs.RegisterValueIs(CString(pszFloatingFloat[0]), CString("1#INF"), -1));
*/
	// Should disable (close) disassembly window since changing EIP bings it up
	EXPECT_TRUE(dam.Disable());
}

void CRegistersIDETest::ToggleFlags(void)
{

	LOGTESTHEADER("ToggleFlags");

	int nRegValue;
	char szTmpStr[8];

	char *pszFlags[] = {"OV", "UP", "EI", "PL", "ZR", "AC", "PE", "CY"};


	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	EXPECT_TRUE(regs.Enable());

	// Verify that all flags are in place and their value are either 0 or 1
	for(int ii = 0; ii < sizeof(pszFlags)/sizeof(*pszFlags); ii++)
	{
		// The next for cycle is for Multiple Undo/Redo verification
		for(int jj = 0; jj < gl_constNumberUndoRedo; jj++)
		{
			regs.GetRegister(CString(pszFlags[ii]), &nRegValue);

			// Swap value
			nRegValue = !nRegValue;

			// Save value for Multiple Undo/Redo verification
			strcpy(m_pszUndoRedoRegisters[jj], itoa(nRegValue, szTmpStr, 10));

			// Set value
			EXPECT_TRUE(regs.SetRegister(CString(pszFlags[ii]), CString(""), nRegValue, FALSE /* value is given as an integer */));
			EXPECT_TRUE(regs.RegisterValueIs(CString(pszFlags[ii]), CString(""), nRegValue, FALSE /* value is given as an integer */));
		}

		// TODO (dklem 11/13/00) Enable when this function available
		// HelperFunctio_MultipleUndoRedo(pszFlags[ii]);
	}

}

void CRegistersIDETest::EditRegisterViaQuickWatch(void)
{

	LOGTESTHEADER("EditRegisterViaQuickWatch");

	char *pszRegisters[] = {"EAX", "ESP"};
	char szNewValue[128], szSetValue[128];
	int ii;

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	EXPECT_TRUE(regs.Enable());

	// Make sure that values changed
	for(ii = 0; ii < sizeof(pszRegisters)/sizeof(*pszRegisters); ii++)
	{
		// Create a new value 
		sprintf(szNewValue, "%.8x", (int) (0xFFFFFFFF * (((float)rand()) / ((float)(RAND_MAX)))));
		strupr(szNewValue);
		sprintf(szSetValue, "0X%s", szNewValue);

		// Change the value via quick watch window
		EXPECT_TRUE(uiqw.Activate());
		EXPECT_TRUE(uiqw.SetExpression(pszRegisters[ii]));
		EXPECT_TRUE(uiqw.Recalc());
		EXPECT_TRUE(uiqw.SetNewValue(szSetValue));
		EXPECT_TRUE(uiqw.Recalc());

		// Verify that the new value has been set correctly
		EXPECT_TRUE(regs.Enable());
		EXPECT_TRUE(regs.RegisterValueIs(CString(pszRegisters[ii]), CString(szNewValue), -1));
	}

}

void CRegistersIDETest::Registers_Dam_Watch_Memory(void)
{

	LOGTESTHEADER("Registers_Dam_Watch_Memory");

	CString csEIP1, csEIP2, csMemoryAddress;
	CString csTmpAddress;

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	// Turn Hex mode on
	EXPECT_TRUE(dbg.ToggleHexDisplay(TRUE));

	// Get current EIP and EIP 7 lines down
	EXPECT_TRUE(dam.Enable());
	csEIP1 = dam.GetInstruction();
	csEIP1 = csEIP1 .Left(8);

	// We use UI layer since we CODisassembly doesn't have GetInstructionAt()
	//EXPECT_TRUE(dam.AttachActive());
	EXPECT_TRUE(dam.Enable());
	csEIP2 = uidam.GetInstruction(7, 1, FALSE);
	csEIP2  = csEIP2 .Left(8);

	// Verify EIP in the Registers window
	EXPECT_TRUE(regs.Enable());
	EXPECT_TRUE(regs.RegisterValueIs(CString("EIP"), csEIP1, -1));

	// Verify EIP in the Memory window
	EXPECT_TRUE(mem.Enable());
	csMemoryAddress = mem.GetAddress(CString("EIP"));
	EXPECT_TRUE((0 == csEIP1.CompareNoCase(csMemoryAddress.Right(8))));

	// Verify EIP in the Watch window
	csMemoryAddress.MakeLower();			// Value in the Watch appear with small letters
	csMemoryAddress.Insert(0, "0x");
	EXPECT_TRUE(watch.AddWatch(CString("EIP")));
	EXPECT_TRUE(watch.VerifyWatchInfo(CString("EIP"), csMemoryAddress,  "unsigned long", (EXPR_STATE) 0 /*NOT_EXPANABLE*/));
	EXPECT_TRUE(watch.RemoveWatch(CString("EIP")));
	EXPECT_TRUE(ee.ExpressionValueIs("EIP", csMemoryAddress));
	
	// Set new value in the Registers window
	EXPECT_TRUE(regs.Enable());
	EXPECT_TRUE(regs.SetRegister(CString("EIP"), csEIP2, -1));

	// Make sure that values changed
	EXPECT_TRUE(dam.Enable());
	csTmpAddress = dam.GetInstruction();
	csTmpAddress = csTmpAddress.Left(8);
	EXPECT_TRUE(0 == csEIP2.CompareNoCase(csTmpAddress));
	
	// Verify EIP in the Memory window
	EXPECT_TRUE(mem.Enable());
	csMemoryAddress = mem.GetAddress(CString("EIP"));
	EXPECT_TRUE((0 == csEIP2.CompareNoCase(csMemoryAddress.Right(8))));

	// Verify EIP in the Watch window
	csMemoryAddress.MakeLower();			// Value in the Watch appear with small letters
	csMemoryAddress.Insert(0, "0x");
	EXPECT_TRUE(watch.AddWatch(CString("EIP")));
	EXPECT_TRUE(watch.VerifyWatchInfo(CString("EIP"), csMemoryAddress,  "unsigned long", (EXPR_STATE) 0 /*NOT_EXPANABLE*/));
	EXPECT_TRUE(watch.RemoveWatch(CString("EIP")));
	EXPECT_TRUE(ee.ExpressionValueIs("EIP", csMemoryAddress));

	EXPECT_TRUE(mem.Disable());
	EXPECT_TRUE(dam.Disable());

	// Turn Hex mode off
	EXPECT_TRUE(dbg.ToggleHexDisplay(FALSE));

}

void CRegistersIDETest::Registers_Watch_Memory(void)
{

	LOGTESTHEADER("Registers_Watch_Memory");

	char *pszRegisters[] =		{"EAX", "EBX", "ECX", "EDX", "ESI", "EDI", "EIP", "ESP", "EBP", "EFL"};
	CString csReg, csMemoryAddress;
	char szTmpData[1024];

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	// Turn Hex mode on
	EXPECT_TRUE(dbg.ToggleHexDisplay(TRUE));

	for(int ii = 0; ii < sizeof(pszRegisters)/sizeof(*pszRegisters); ii++)
	{

		for(int i = 0; i < 2; i++)
		{
			// Verify Register in the Registers window
			EXPECT_TRUE(regs.Enable());
			csReg = regs.GetRegister(CString(pszRegisters[ii]), NULL);

			// Verify Register in the Memory window
			EXPECT_TRUE(mem.Enable());
			csMemoryAddress = mem.GetAddress(CString(pszRegisters[ii]));
			EXPECT_TRUE((0 == csReg.CompareNoCase(csMemoryAddress.Right(8))));
	
			// Verify Register in the Watch window
			csMemoryAddress.MakeLower();			// Value in the Watch appear with small letters
			csMemoryAddress.Insert(0, "0x");
			EXPECT_TRUE(watch.AddWatch(CString(pszRegisters[ii])));
			EXPECT_TRUE(watch.VerifyWatchInfo(CString(pszRegisters[ii]), csMemoryAddress,  "unsigned long", (EXPR_STATE) 0 /*NOT_EXPANABLE*/));
			EXPECT_TRUE(watch.RemoveWatch(CString(pszRegisters[ii])));

			EXPECT_TRUE(ee.ExpressionValueIs(CString(pszRegisters[ii]), csMemoryAddress));

			// Set new value in the Registers window
			// Create a new value 
			sprintf(szTmpData, "%.8x", (int) (0xFFFFFFFF * (((float)rand()) / ((float)(RAND_MAX)))));
			strupr(szTmpData);
			EXPECT_TRUE(regs.Enable());
			EXPECT_TRUE(regs.SetRegister(CString(pszRegisters[ii]), CString(szTmpData), -1));
		}

		// Make sure that values changed, i = 1;

	}	

	EXPECT_TRUE(mem.Disable());
	// changing the EIP may bring the asm window up.
	EXPECT_TRUE(dam.Disable());

	// Turn Hex mode off
	EXPECT_TRUE(dbg.ToggleHexDisplay(FALSE));
}

void CRegistersIDETest::Change_EAX_Changes_RetValue(void)
{

	LOGTESTHEADER("Change_EAX_Changes_RetValue");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* Return form Foo */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	EXPECT_TRUE(regs.Enable());

	EXPECT_TRUE(regs.SetRegister(CString("EAX"), CString("000000AF"), -1));
	// Step from function
	EXPECT_TRUE(dbg.StepOver(2));

	// Turn Hex mode off
	EXPECT_TRUE(dbg.ToggleHexDisplay(FALSE));

	// Verify res
	EXPECT_TRUE(watch.AddWatch(CString("res")));
	EXPECT_TRUE(watch.VerifyWatchInfo(CString("res"), CString("175"),  "int", (EXPR_STATE) 0 /*NOT_EXPANABLE*/));
	EXPECT_TRUE(watch.RemoveWatch(CString("res")));

}

void CRegistersIDETest::DisplayIsAlwaysHex(void)
{

	LOGTESTHEADER("DisplayIsAlwaysHex");

	char *pszCPURegs[] =		{"EAX", "EBX", "ECX", "EDX", "ESI", "EDI", "EIP", "ESP", "EBP", "EFL"};
	CString csCPURegValues[10];  // MUST BE THE SAME SIZE AS NUMBER OF REGS ABOVE
	char *pszCPUSegments[] = 	{"CS", "DS", "ES", "SS", "FS", "GS" }; 
	CString csCPUSegmentsValues[6];  // MUST BE THE SAME SIZE AS NUMBER OF REGS ABOVE
	char *pszFloatingInt[] =	{"CTRL", "STAT", "TAGS", "EIP", "CS", "DS", "EDO"};
	CString csFloatingIntValues[7];  // MUST BE THE SAME SIZE AS NUMBER OF REGS ABOVE

	// Restart and Go to the line at which we want to begin our tests
	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	// Turn Hex mode on
	EXPECT_TRUE(dbg.ToggleHexDisplay(TRUE));

	EXPECT_TRUE(regs.Enable());
	// Get initial values
	for(int ii = 0; ii < sizeof(pszCPURegs)/sizeof(*pszCPURegs); ii++)
	{
		csCPURegValues[ii] = regs.GetRegister(CString(pszCPURegs[ii]), NULL);
	}

	for(ii = 0; ii < sizeof(pszCPUSegments)/sizeof(*pszCPUSegments); ii++)
	{
		csCPUSegmentsValues[ii] = regs.GetRegister(CString(pszCPUSegments[ii]), NULL);
	}

	for(ii = 0; ii < sizeof(pszFloatingInt)/sizeof(*pszFloatingInt); ii++)
	{
		csFloatingIntValues[ii] = regs.GetRegister(CString(pszFloatingInt[ii]), NULL);
	}

	// Turn Hex mode on
	EXPECT_TRUE(dbg.ToggleHexDisplay(FALSE));

	// Make sure that values has not changed
	for(ii = 0; ii < sizeof(pszCPURegs)/sizeof(*pszCPURegs); ii++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(pszCPURegs[ii], csCPURegValues[ii], -1));
	}

	for(ii = 0; ii < sizeof(pszCPUSegments)/sizeof(*pszCPUSegments); ii++)
	{

		EXPECT_TRUE(regs.RegisterValueIs(pszCPUSegments[ii], csCPUSegmentsValues[ii], -1));
	}

	for(ii = 0; ii < sizeof(pszFloatingInt)/sizeof(*pszFloatingInt); ii++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(pszFloatingInt[ii], csFloatingIntValues[ii], -1));

	}

}

void CRegistersIDETest::IntegrityWithSetFocusToThread(void)
{

	LOGTESTHEADER("IntegrityWithSetFocusToThread");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* Thread proc */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	char szOriginalEIP[512];
	char szEIP[512];

	HelperFunctionVerifyEIP("IntegrityWithSetFocusToThread", szOriginalEIP);

	// Set 'WinMain' or 'WinMainCRTStartup' as an active thread.
	unsigned long ulThreadID;
	EXPECT_TRUE(ee.GetExpressionValue("dwMainThreadID", &ulThreadID));
	EXPECT_TRUE(threads.SetCurrentThread(ulThreadID));

	HelperFunctionVerifyEIP("IntegrityWithSetFocusToThread", szEIP);
	EXPECT_TRUE(0 != strcmp(szOriginalEIP, szEIP));

	// Set 'ThreadRoutine' as an active thread
	EXPECT_TRUE(ee.GetExpressionValue("dwSecondaryThreadID" ,&ulThreadID));
	EXPECT_TRUE(threads.SetCurrentThread(ulThreadID));

	HelperFunctionVerifyEIP("IntegrityWithSetFocusToThread", szEIP);
	EXPECT_TRUE(0 == strcmp(szOriginalEIP, szEIP));
}

void CRegistersIDETest::IntegrityWithFunctionEvaluation(void)
{

	LOGTESTHEADER("IntegrityWithFunctionEvaluation");

	CString csFooAddress;
	char szEIP[512];

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	EXPECT_TRUE(dbg.StepInto(1));

	// Get Foo address from the Watch window
	EXPECT_TRUE(ee.GetExpressionValue(CString("Foo"), csFooAddress));
	csFooAddress = csFooAddress.Mid(2, 8);
	csFooAddress.MakeUpper();

	// Get EIP from the Registers and Disassembly window
	HelperFunctionVerifyEIP("IntegrityWithFunctionEvaluation", szEIP);

	// Compare
	EXPECT_TRUE(0 == strcmp(LPCTSTR(csFooAddress), szEIP));
}

void CRegistersIDETest::BoundaryConditionsForEditingValues(void)
{

	LOGTESTHEADER("BoundaryConditionsForEditingValues");

	char szOriginalEIP[512];
	char szEIP[512];

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	// Get EIP from the Registers and Disassembly window
	HelperFunctionVerifyEIP("BoundaryConditionsForEditingValues", szOriginalEIP);

	// Open Disasm and try Boundary conditions
	EXPECT_TRUE(dam.Enable());
	EXPECT_TRUE(regs.Enable());
	EXPECT_TRUE(regs.SetRegister(CString("EIP"), CString("00000000"), -1));
	EXPECT_TRUE(regs.SetRegister(CString("EIP"), CString("FFFFFFFF"), -1));
	EXPECT_TRUE(regs.SetRegister(CString("EIP"), CString(szOriginalEIP), -1));

	// Close Disasm and compare EIP
	EXPECT_TRUE(dam.Disable());
	HelperFunctionVerifyEIP("BoundaryConditionsForEditingValues", szEIP);
	EXPECT_TRUE(0 == strcmp(szOriginalEIP, szEIP));

}

void CRegistersIDETest::TypeInvalidValues(void)
{

	LOGTESTHEADER("TypeInvalidValues");

	CString csRegValue;
	char *pszCPURegs[] =		{"EAX ", "EBX ", "ECX ", "EDX ", "ESI ", "EDI ", "EIP ", "ESP ", "EBP ", "EFL "};
	char *pszCPUSegments[] = 	{"CS ", "DS ", "ES ", "SS ", "FS ", "GS " }; 
	char *pszFloatingInt[] =	{"CTRL ", "STAT ", "TAGS ", "EIP ", "CS ", "DS ", "EDO "};
	char *pszFlags[] =			{"OV", "UP", "EI", "PL", "ZR", "AC", "PE" , "CY"};


	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	EXPECT_TRUE(regs.Enable());
/*
	// Get initial values
	for(int ii = 0; ii < sizeof(pszCPURegs)/sizeof(*pszCPURegs); ii++)
	{
		csRegValue = regs.GetRegister(CString(pszCPURegs[ii]), NULL);
		EXPECT_TRUE(regs.SetRegister(CString(pszCPURegs[ii]), CString("JK%$#KL{"), -1));
		EXPECT_TRUE(regs.RegisterValueIs(CString(pszCPURegs[ii]), CString(csRegValue), -1));
	}

	for(ii = 0; ii < sizeof(pszCPUSegments)/sizeof(*pszCPUSegments); ii++)
	{
		csRegValue = regs.GetRegister(CString(pszCPUSegments[ii]), NULL);
		EXPECT_TRUE(regs.SetRegister(CString(pszCPUSegments[ii]), CString("JK%$"), -1));
		EXPECT_TRUE(regs.RegisterValueIs(CString(pszCPUSegments[ii]), CString(csRegValue), -1));
	}

	for(ii = 0; ii < sizeof(pszFloatingInt)/sizeof(*pszFloatingInt); ii++)
	{
		csRegValue = regs.GetRegister(CString(pszFloatingInt[ii]), NULL);
		EXPECT_TRUE(regs.SetRegister(CString(pszFloatingInt[ii]), CString("#KL{"), -1));
		EXPECT_TRUE(regs.RegisterValueIs(CString(pszFloatingInt[ii]), CString(csRegValue), -1));
	}
*/
	for(int ii = 0; ii < sizeof(pszFlags)/sizeof(*pszFlags); ii++)
	{
		csRegValue = regs.GetRegister(CString(pszFlags[ii]), NULL);

		// Try to set invalid number (2) for even flags
		if((float) (ii/2) == (float)ii/2.)
		{
			EXPECT_TRUE(regs.SetRegister(CString(pszFlags[ii]), CString("2"), -1));
		}
		// Try to set invalid letter (S) for odd flags
		else
		{
			EXPECT_TRUE(regs.SetRegister(CString(pszFlags[ii]), CString("S"), -1));
		}

		EXPECT_TRUE(regs.RegisterValueIs(CString(pszFlags[ii]), CString(csRegValue), -1));
	}
}

void CRegistersIDETest::FloatingPointException(void)
{

	LOGTESTHEADER("FloatingPointException");

	//	ADDED BY DVERMA 4/19/2000 as exception not thrown on Win ME 
	//	won't fix bug #64854 - changes to CTRL don't persist.
	DWORD sysVal = GetSystem();
	if ((sysVal == SYSTEM_WIN_95) || (sysVal == SYSTEM_WIN_98) || (sysVal == SYSTEM_WIN_MILL))
	{
		LOG->RecordInfo("FloatingPointException() - test won't run on Win 9X OS.");
		return;
	}	

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* Exception should be here for CTRL 277 */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	EXPECT_TRUE(regs.Enable());
	EXPECT_TRUE(regs.SetRegister(CString("CTRL"), CString("0277"), -1));
	EXPECT_TRUE(dbg.StepOver(1, NULL, NULL, NULL, NOWAIT));
	// wait for the exception message to come up.
	while(!MST.WButtonExists(GetLocString(IDSS_OK)));
	MST.DoKeys("{ENTER}");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* Exception should be here for CTRL 27B */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	EXPECT_TRUE(regs.Enable());
	EXPECT_TRUE(regs.SetRegister(CString("CTRL"), CString("027B"), -1));
	EXPECT_TRUE(dbg.StepOver(1, NULL, NULL, NULL, NOWAIT));
	// wait for the exception message to come up.
	while(!MST.WButtonExists(GetLocString(IDSS_OK)));
	MST.DoKeys("{ENTER}");
}


void CRegistersIDETest::VerifyDockingView(void)
{
	LOGTESTHEADER("VerifyDockingView");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	EXPECT_TRUE(uidam.EnableDockingView(TRUE));
	EXPECT_TRUE(uidam.IsDockingViewEnabled());
	// TODO: (dklem 09/14/98) Uncomment the following line when #6572 gets fixed
	// The bug #6572 is Memory leak while resizing DAM window. This leak is not that bad in the Release version
	// Based on my tests the Debug vesion consumes ~71,000K (at the peak) while running this test suite, Release version - 23,000K (at the peak) , which is acceptable
	// Comment the next line if the Debug version of MSDEV causes Out of Memory
	// TODO(michma - 3/2/00): this isn't working yet.
	//TestResizeMoveWindow(TRUE, TRUE);	

	EXPECT_TRUE(uidam.EnableDockingView(FALSE));
	EXPECT_TRUE(!uidam.IsDockingViewEnabled());
	// TODO: (dklem 09/14/98) Uncomment the following line when #6572 gets fixed
	// The bug #6572 is Memory leak while resizing DAM window. This leak is not that bad in the Release version
	// Based on my tests the Debug vesion consumes ~71,000K (at the peak) while running this test suite, Release version - 23,000K (at the peak) , which is acceptable
	// Comment the next line if the Debug version of MSDEV causes Out of Memory
	// TODO(michma - 3/2/00): this isn't working yet.
	//TestResizeMoveWindow(FALSE, TRUE);	

	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));

}


void CRegistersIDETest::MinimalTestResizeMoveWindow()
{

// TODO remove the next line immediately
//	return;
	
	BOOL bInitiallyMaximized;

	uidam.Activate();
	HWND hwnd = uidam.HWnd();

	if(IsZoomed(hwnd))
	{
		bInitiallyMaximized = TRUE;
		ShowWindow(hwnd, SW_RESTORE);
	}
	else 
		bInitiallyMaximized = FALSE;
	
	

	// TODO: (dklem 09/14/98) Uncomment the following 4 lines when #6572 gets fixed
	// The bug #6572 is Memory leak while resizing DAM window. This leak is not that bad in the Release version
	// Based on my tests the Debug vesion consumes ~71,000K (at the peak) while running this test suite, Release version - 23,000K (at the peak) , which is acceptable
	// Comment the next 4 lines if the Debug version of MSDEV causes Out of Memory
	// TODO(michma - 3/2/00): this isn't working yet.
	//TestResizeMoveWindow(FALSE, FALSE);

	// Restore the DAM window before turning Docking View on
	if(bInitiallyMaximized)
		ShowWindow(hwnd, SW_MAXIMIZE);
	
	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));

	// TODO(michma - 3/2/00): this isn't working yet.
	//TestResizeMoveWindow(TRUE, FALSE);
	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
}

/*

TODO(michma - 3/2/00): this isn't working yet.

void CRegistersIDETest::TestResizeMoveWindow(BOOL bIsDocked, BOOL bFullTest)
{
	int nPositionMoved;
	uiregs.Activate();

	BOOL DragFullWindows = TRUE;
	EXPECT_TRUE(GetDragFullWindows(&DragFullWindows));

	// Try minimum hor and ver sizes
	nPositionMoved = uiregs. ResizeWindow(bIsDocked, SLeft, DRight, -1, DragFullWindows);
	uiregs.ResizeWindow(bIsDocked, SLeft, DLeft, nPositionMoved, DragFullWindows);

	nPositionMoved = uiregs.ResizeWindow(bIsDocked, SBottom, DUp, -1, DragFullWindows);
	uiregs.ResizeWindow(bIsDocked, SBottom, DDown, nPositionMoved, DragFullWindows);

	// Move the window
	nPositionMoved = uiregs.MoveWindow(bIsDocked, DRight, 20, DragFullWindows);
	nPositionMoved = uiregs.MoveWindow(bIsDocked, DDown, 20, DragFullWindows);
	nPositionMoved = uiregs.MoveWindow(bIsDocked, DLeft, 20, DragFullWindows);
	nPositionMoved = uiregs.MoveWindow(bIsDocked, DUp, 20, DragFullWindows);

	if(!bFullTest) return;

	// Try to go beyond screen borders
	nPositionMoved = uiregs.ResizeWindow(bIsDocked, SLeft, DLeft, -1, DragFullWindows);
	if(!DragFullWindows)
	{
		EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
		EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
		uiregs.Activate();
	}
	uiregs.ResizeWindow(bIsDocked, SLeft, DRight, nPositionMoved, DragFullWindows);

	nPositionMoved = uiregs.ResizeWindow(bIsDocked, SRight, DRight, -1, DragFullWindows);
	if(!DragFullWindows)
	{
		EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
		EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
		uiregs.Activate();
	}
	uiregs.ResizeWindow(bIsDocked, SRight, DLeft, nPositionMoved, DragFullWindows);

	nPositionMoved = uiregs.ResizeWindow(bIsDocked, SBottom, DDown, -1, DragFullWindows);
	if(!DragFullWindows)
	{
		EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
		EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
		uiregs.Activate();
	}
	uiregs.ResizeWindow(bIsDocked, SBottom, DUp, nPositionMoved, DragFullWindows);

	nPositionMoved = uiregs.ResizeWindow(bIsDocked, STop, DUp, -1, DragFullWindows);
	// If we move it to far, the title bar is not available, we need to reactivate memory window
	EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
	EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
	uiregs.Activate();
	uiregs.ResizeWindow(bIsDocked, STop, DDown, 10, DragFullWindows);

	// I like to move it move it
	nPositionMoved = uiregs.MoveWindow(bIsDocked, DRight, -1, DragFullWindows);
	// If we move it to far, the title bar is not available, we need to reactivate memory window
	EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
	EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
	uiregs.Activate();
	uiregs.MoveWindow(bIsDocked, DLeft, nPositionMoved, DragFullWindows);

	nPositionMoved = uiregs.MoveWindow(bIsDocked, DLeft, -1, DragFullWindows);
	EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
	EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
	uiregs.Activate();
	uiregs.MoveWindow(bIsDocked, DRight, nPositionMoved, DragFullWindows);

	nPositionMoved = uiregs.MoveWindow(bIsDocked, DDown, -1, DragFullWindows);
	EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
	EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
	uiregs.Activate();
	uiregs.MoveWindow(bIsDocked, DUp, nPositionMoved, DragFullWindows);

	EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
	EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
	uiregs.Activate();

	nPositionMoved = uiregs.MoveWindow(bIsDocked, DUp, -1, DragFullWindows);
	EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
	EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
	uiregs.Activate();
	uiregs.MoveWindow(bIsDocked, DDown, nPositionMoved, DragFullWindows);

}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\retval\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\registers\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	registers.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\retval\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\retval\retvsub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CRetValSubSuite class
//

#include "stdafx.h"
#include "RetVsub.h"
#include "afxdllx.h"
#include "..\cleanup.h"

#include "RetVcase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CRetValSubSuite

IMPLEMENT_SUBSUITE(CRetValSubSuite, CIDESubSuite, "Return Value", "VCQA Debugger")

BEGIN_TESTLIST(CRetValSubSuite)
	TEST(CRetValIDETest, RUN)
END_TESTLIST()

void CRetValSubSuite::CleanUp(void)
	{
	::CleanUp("retval");
	}

///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\remote\remcases.h ===
///////////////////////////////////////////////////////////////////////////////
//	REMCASES.H
//
//	Created by :			Date :
//		MichMa					8/24/94
//
//	Description :
//		Declaration of the CRemoteDebuggingCases class
//

#ifndef __REMCASES_H__
#define __REMCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "dbgset.h"

///////////////////////////////////////////////////////////////////////////////
//	CRemoteDebuggingCases class

class CRemoteDebuggingCases : public CDebugTestSet
	{
		DECLARE_TEST(CRemoteDebuggingCases, CCORESubSuite)

	// Operations (test cases)
	public:
		
		virtual void PreRun(void);
		virtual void Run(void);
		
		void GeneralCases(PLATFORM_TYPE platform, CONNECTION_TYPE connection);
		void TCPIPCases(PLATFORM_TYPE platform);
		void Win32SerialCases(PLATFORM_TYPE platform);
		void Mac68kSerialCases(void);
		void MacPPCSerialCases(void);
		void AppleTalkCases(PLATFORM_TYPE platform);

	// Data
	private:

		CODebug dbg;
		COProject prj;
		COConnection *pconnec;

		BOOL fGeneralCasesDone;		
	};

#endif //__REMCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\remote\remcases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	REMCASES.CPP
//
//	Created by:				Date:
//			MichMa				8/24/94
//
//	Description:
//			Remote Debugging Breadth Test

#include "stdafx.h"
#include "remcases.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

#define proj		"dbg.mak"
#define proj_exe	"dbg.exe"
#define diff_proj	"testgo01.mak"

IMPLEMENT_TEST(CRemoteDebuggingCases, CDebugTestSet, "Remote", -1, CCORESubSuite)

void CRemoteDebuggingCases::PreRun(void)
	{
	fGeneralCasesDone = FALSE;
	// call the base class
	CTest::PreRun();
	}


void CRemoteDebuggingCases::Run(void)
												
	{	
	int platforms = GetUserTargetPlatforms();
	int connections;
	pconnec = GetSubSuite()->GetIDE()->GetConnectionInfo();

	if(platforms & PLATFORM_WIN32_X86)
	
		{
		connections = pconnec->GetUserConnections(PLATFORM_WIN32_X86);
		
		if(connections & CONNECTION_TCP_IP)
			{
			GeneralCases(PLATFORM_WIN32_X86, CONNECTION_TCP_IP);
			TCPIPCases(PLATFORM_WIN32_X86);
			}

		if(connections & CONNECTION_SERIAL)
			{
			GeneralCases(PLATFORM_WIN32_X86, CONNECTION_SERIAL);
			Win32SerialCases(PLATFORM_WIN32_X86);
			}
		}
			 
	if(platforms & PLATFORM_WIN32S_X86)
		{
		// win32s only supports serial connection.
		GeneralCases(PLATFORM_WIN32S_X86, CONNECTION_SERIAL);
		Win32SerialCases(PLATFORM_WIN32S_X86);
		}

	if(platforms & PLATFORM_MAC_68K)
	
		{
		connections = pconnec->GetUserConnections(PLATFORM_MAC_68K);
		
		if(connections & CONNECTION_TCP_IP)
			{
			GeneralCases(PLATFORM_MAC_68K, CONNECTION_TCP_IP);
			TCPIPCases(PLATFORM_MAC_68K);
			}

		if(connections & CONNECTION_SERIAL)
			{
			GeneralCases(PLATFORM_MAC_68K, CONNECTION_SERIAL);
			Mac68kSerialCases();
			}

		// only nt supports appletalk
		if((connections & CONNECTION_APPLETALK) && (GetSystem() & SYSTEM_NT))
			{
			GeneralCases(PLATFORM_MAC_68K, CONNECTION_APPLETALK);
			AppleTalkCases(PLATFORM_MAC_68K);
			}
		}

	if(platforms & PLATFORM_MAC_PPC)
	
		{
		connections = pconnec->GetUserConnections(PLATFORM_MAC_PPC);

		if(connections & CONNECTION_TCP_IP)
			{
			GeneralCases(PLATFORM_MAC_PPC, CONNECTION_TCP_IP);
			TCPIPCases(PLATFORM_MAC_PPC);
			}

		if(connections & CONNECTION_SERIAL)
			{
			GeneralCases(PLATFORM_MAC_PPC, CONNECTION_SERIAL);
			MacPPCSerialCases();
			}

		// only nt supports appletalk
		if((connections & CONNECTION_APPLETALK) && (GetSystem() & SYSTEM_NT))
			{
			GeneralCases(PLATFORM_MAC_PPC, CONNECTION_APPLETALK);
			AppleTalkCases(PLATFORM_MAC_PPC);
			}
		}

	//EXPECT_TRUE(MST.WFndWndWaitC("Could not find the app", "Static", FW_PART, 30));
	//EXPECT_TRUE(MST.WFndWndWaitC("Appletalk error: Specified settings are invalid", "Static", FW_PART, 3));
	//EXPECT_TRUE(MST.WFndWndWaitC("zone 'xxx' could not be found", "Static", FW_PART, 30));
	//EXPECT_TRUE(MST.WFndWndWaitC("Macintosh 'xxx' could not be found", "Static", FW_PART, 30));
	//EXPECT_TRUE(MST.WFndWndWaitC("password is incorrect", "Static", FW_PART, 30));
	}      


// REVIEW (michma): the remote/local exe mismatch case should probably be performed
// on each platform/connection combo, but the remote path cases should only need
// to be performed against one platform/connection.

void CRemoteDebuggingCases::GeneralCases(PLATFORM_TYPE platform, CONNECTION_TYPE connection)

	{
	// this set of cases only needs to be performed against one platform/connection combo.
	if(fGeneralCasesDone)
		return;

	// Initialization
	CString remote_proj_path = pconnec->GetUserRemoteLocalPath(platform) + proj_exe;

	/***************************************************************
	 * start debugging with remote path not set; cancel debugging. *
	 ***************************************************************/
	
	SetProject(proj);
	prj.SetRemotePath("");
	dbg.StepInto(1, NULL, NULL, NULL, NOWAIT);
	EXPECT_SUCCESS(dbg.CancelMsg(MSG_REMOTE_EXE_NAME_REQUIRED));

	/****************************************************************************
	 * start debugging with remote path not set; set it and continue debugging. *
	 ****************************************************************************/

	dbg.StepInto(1, NULL, NULL, NULL, NOWAIT);
	EXPECT_SUCCESS(dbg.HandleMsg(MSG_REMOTE_EXE_NAME_REQUIRED, remote_proj_path));
	dbg.Wait(WAIT_FOR_BREAK);
	EXPECT_TRUE(dbg.AtSymbol("WinMain"));
	dbg.StopDebugging();

	/**************************************************************************************
	 * start debugging with a remote executable that does not match the local executable. *
	 **************************************************************************************/
	
	prj.Open(diff_proj);
	prj.SetRemotePath(remote_proj_path);
	dbg.StepInto(1, NULL, NULL, NULL, NOWAIT);
	EXPECT_SUCCESS(dbg.CancelMsg(MSG_REMOTE_LOCAL_EXE_MISMATCH));

	fGeneralCasesDone = TRUE;
	}


void CRemoteDebuggingCases::TCPIPCases(PLATFORM_TYPE platform)

	{	
	/***************************************************************
	 * start debugging with neither address nor password provided. *
	 ***************************************************************/
	pconnec->SetAll(platform, CONNECTION_TCP_IP, "", "");
	dbg.StepInto(1, NULL, NULL, NULL, NOWAIT);
	//EXPECT_SUCCESS(dbg.CancelMsg());

	/*********************************************************************
	 * start debugging with address not provided (password is provided). *
	 *********************************************************************/
	pconnec->SetPassword(PASSWORD_USER, CONNECTION_TCP_IP);
	dbg.StepInto(1, NULL, NULL, NULL, NOWAIT);
	//EXPECT_SUCCESS(dbg.CancelMsg());

	/*********************************************************************
	 * start debugging with password not provided (address is provided). *
	 *********************************************************************/
	pconnec->SetPassword(PASSWORD_USER, CONNECTION_TCP_IP);
	dbg.StepInto(1, NULL, NULL, NULL, NOWAIT);
	//EXPECT_SUCCESS(dbg.CancelMsg());

	/*******************************************************
	 * start debugging with non-existent address provided. *
	 *******************************************************/

	/*****************************************************
	 * start debugging with incorrect password provided. *
	 *****************************************************/

	/***************************************************************
	 * start debugging with correct address and password provided. *
	 ***************************************************************/
	}


void CRemoteDebuggingCases::Win32SerialCases(PLATFORM_TYPE platform){}
void CRemoteDebuggingCases::Mac68kSerialCases(void){}
void CRemoteDebuggingCases::MacPPCSerialCases(void){}
void CRemoteDebuggingCases::AppleTalkCases(PLATFORM_TYPE platform){}

	//Win32 Serial Connection
	//start debugging with correct connector, baud rate, and flow control provided (use fastest baud rate and default flow control)
	//start debugging with non-existent connector
	//start debugging with existent but incorrect connector
	//start debugging with incorrect baud rate (connector and flow control correct)
	//start debugging with incorrect flow control (connector and baud rate correct)
	//start debugging with each of the other baud rate speeds
	//start debugging with each of the other flow control types

	//Mac 68K Serial Connection
	//start debugging with correct connector, baud rate, data bits, parity, and stop bits provided (use fastest baud rate and default data bits, parity, and stop bits)
	//start debugging with non-existent connector
	//start debugging with existent but incorrect connector
	//start debugging with incorrect baud rate (connector, data bits, parity, and stop bits correct)
	//start debugging with incorrect data bits (connector, baud rate, parity, and stop bits correct)
	//start debugging with incorrect parity (connector, baud rate, data bits, and stop bits correct)
	//start debugging with incorrect stop bits (connector, baud rate, data bits, and parity correct)
	//start debugging with each of the other baud rate speeds
	//start debugging with each of the other data bit counts
	//start debugging with each of the other parity types
	//start debugging with each of the other stop bit counts

	//Mac PPC Serial Connection
	//start debugging with correct connector provided
	//start debugging with non-existent connector
	//start debugging with existent but incorrect connector

	//Mac Appletalk Connection
	//start debugging with correct zone, machine name, and password provided
	//start debugging with neither zone nor machine name nor password provided
	//start debugging with no zone provided (machine name and password provided)
	//start debugging with no machine name provided (zone and password provided)
	//start debugging with no password provided (zone and machine name provided)
	//start debugging with non-existent zone address provided
	//start debugging with non-existent machine name provided
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\retval\retvsub.h ===
///////////////////////////////////////////////////////////////////////////////
//	RetVsub.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CRetValSubSuite class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CRetValSubSuite class

class CRetValSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CRetValSubSuite)
	DECLARE_TESTLIST()
protected:
	void CleanUp(void);
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\stack\cspecial.h ===
///////////////////////////////////////////////////////////////////////////////
//	cspecial.H
//
//	Created by :			Date :
//		YefimS					01/06/94
//
//	Description :
//		Declaration of the Cstack2IDETest class
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __CSPECIAL_H__
#define __CSPECIAL_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif


#include "..\dbgset.h"

///////////////////////////////////////////////////////////////////////////////
//	Cstack2IDETest class

class Cstack_specialIDETest : public CDebugTestSet
{
	DECLARE_TEST(Cstack_specialIDETest, CstackSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run();

// Test Cases
protected:
	BOOL MainSequence(   );
	BOOL CheckParamList(   );
	BOOL VarParam(   );
	BOOL Recursion(   );
	BOOL Options(   );
	BOOL AdvancedParam(   );

// Utilities
protected:
	BOOL ShortRecCycle(int nParam);
	BOOL EndOfStackIsCorrect(int level);
	BOOL StackIsCorrect(int nParam, LPCSTR strLine);
};

#endif //__CSPECIAL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\retval\retvcase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	RetVcase.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "RetVcase.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
IMPLEMENT_TEST(CRetValIDETest, CDebugTestSet, "Return Value", -1, CRetValSubSuite)
									   
												 
void CRetValIDETest::PreRun(void)
	{
	// call the base class
	CTest::PreRun();
	}


void CRetValIDETest::Run(void)
	
	{
	/******************
	 * INITIALIZATION *
	 ******************/
	if(!InitProject("retval\\testdll", PROJECT_DLL))
//	if(!SetProject("retval\\testdll", PROJECT_DLL))
		{
		m_pLog->RecordInfo("ERROR: could not init testdll project");
		return;
		}

	if(!InitProject("retval\\retval"))
//	if(!SetProject("retval\\retval"))
		{
		m_pLog->RecordInfo("ERROR: could not init retval project");
		return;
		}

	// this is the initial state each test expects.
	//	  - step passed prolog of WinMain().
	//	  - select Auto pane in variables wnd.
	//    - restore focus to source wnd.
	if(!dbg.StepOver(2))
		{
		m_pLog->RecordInfo("ERROR: could not step passed WinMain()'s prolog");
		return;
		}

	uivar.Activate();

	if(!uivar.SetPane(PANE_AUTO) == ERROR_SUCCESS)
		{
		m_pLog->RecordInfo("ERROR: could not activate Auto pane");
		return;
		}

	RestoreFocusToSrcWnd();
		
	/*********
	 * TESTS *
	 *********/
	// can't step into system code on win95.
	//if(GetSystem() != SYSTEM_CHICAGO)
		// TODO (michma): need to get passed compiler problem with EnumWindowsProc
		// before we can finish implementing this test.
		//StepOutOfCallbackFunction();
		
	StepOverFunctionsReturningNativeTypes();
	StepOverFunctionReturningClassObject();
	StepOverFunctionReturningPointerToClassObject();
// Orion 12285 is postponed:	StepOverFunctionThrowingExceptionToParent();
	StepOutOfWinMain();
	StepOverDllFunction();
	StepOverConstructorAndVirtualMemberFunction();
	StepOverFunctionWithOnlyLineNumberDebugInfo();
	StepOverFunctionWithNoDebugInfo();
	// TODO (michma): need to change retval.mak so we actually statically link to retail crt.
	// test will fail until then.
	//StepOverStaticallyLinkedNonDebugCrtFunction();
	
	StepOverWin32ApiFunction();
	StepOutOfFunctionWithF8();
	StepOutOfFunctionWithF10();
	StepOutOfFunctionWithShiftF7();
	StepOverLineWithNoFunctionCall();
	VerifyNoReturnValueDisplayedAfterGo();
	VerifyReturnValueDisappearsWhenAssigningValue();
	VerifyReturnValueDisappearsWhenNotAssigningValue();
	VerifyReturnValueStaysAfterResettingNextStatement();
	VerifyReturnValueStaysAfterStackNavigation();
	VerifyReturnValueForFastcallCallingConvention();
	StepOutOfMultipleLevelsOfRecursion();
	VerifyReturnValueFieldCannotBeEdited();
	ToggleReturnValueOffAndOn();
	VerifyNoReturnValueDisplayedAfterRestart(); 
// TODO(michma): re-enable when orion: 9820.
	//VerifyNoReturnValueDisplayedAfterStopAndRestart(); 
	} 
	     

/*****************************************************************************
 * step over function returning each native type (void, char, unsigned char, *
 * int, unsigned int, long, unsigned long, float, double, long double).      *
 *****************************************************************************/
/***************************************************************
 * verify return value for cdecl (default) calling convention. *
 ***************************************************************/
void CRetValIDETest::StepOverFunctionsReturningNativeTypes(void)

	{
	// void
	LogTestHeader("StepOverFunctionsReturningNativeTypes - void");
	EXPECT_TRUE(src.Find("func_void();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
#ifndef _M_ALPHA
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "void", "func_void returned", "<void>");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
#else
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "char", "ch", "0 '\\x00'");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "void", "func_void returned", "<void>");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
#endif
	RestoreFocusToSrcWnd();

	// char
	LogTestHeader("StepOverFunctionsReturningNativeTypes - char");
	EXPECT_TRUE(src.Find("char ch = func_char();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "char", "ch", "127 '\x7f'");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "unsigned char", "uch", "UNKNOWN");
	FillExprInfo(expr_info_expected[2], NOT_EXPANDABLE, "char", "func_char returned", "127 '\x7f'");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 3));
	RestoreFocusToSrcWnd();

	// unsigned char
	LogTestHeader("StepOverFunctionsReturningNativeTypes - unsigned char");
	EXPECT_TRUE(src.Find("func_uchar();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "i", "UNKNOWN");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "unsigned char", "uch", "255 '\xff'");
	FillExprInfo(expr_info_expected[2], NOT_EXPANDABLE, "unsigned char", "func_uchar returned", "255 '\xff'");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 3));
	RestoreFocusToSrcWnd();

	// int
	LogTestHeader("StepOverFunctionsReturningNativeTypes - int");
	EXPECT_TRUE(src.Find("func_int();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "i", "2147483647");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "unsigned int", "ui", "UNKNOWN");
	FillExprInfo(expr_info_expected[2], NOT_EXPANDABLE, "int", "func_int returned", "2147483647");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 3));
	RestoreFocusToSrcWnd();

	// unsigned int
	LogTestHeader("StepOverFunctionsReturningNativeTypes - unsigned int");
	EXPECT_TRUE(src.Find("func_uint();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "long", "l", "UNKNOWN");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "unsigned int", "ui", "4294967295");
	FillExprInfo(expr_info_expected[2], NOT_EXPANDABLE, "unsigned int", "func_uint returned", "4294967295");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 3));
	RestoreFocusToSrcWnd();

	// long
	LogTestHeader("StepOverFunctionsReturningNativeTypes - long");
	EXPECT_TRUE(src.Find("func_long();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "long", "l", "2147483647");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "unsigned long", "ul", "UNKNOWN");
	FillExprInfo(expr_info_expected[2], NOT_EXPANDABLE, "long", "func_long returned", "2147483647");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 3));
	RestoreFocusToSrcWnd();

	// unsigned long
	LogTestHeader("StepOverFunctionsReturningNativeTypes - unsigned long");
	EXPECT_TRUE(src.Find("func_ulong();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "float", "flt", "UNKNOWN");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "unsigned long", "ul", "4294967295");
	FillExprInfo(expr_info_expected[2], NOT_EXPANDABLE, "unsigned long", "func_ulong returned", "4294967295");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 3));
	RestoreFocusToSrcWnd();

	// float
	LogTestHeader("StepOverFunctionsReturningNativeTypes - float");
	EXPECT_TRUE(src.Find("func_float();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "double", "dbl", "UNKNOWN");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "float", "flt", "3.40282e+038");
	FillExprInfo(expr_info_expected[2], NOT_EXPANDABLE, "float", "func_float returned", "3.40282e+038");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 3));
	RestoreFocusToSrcWnd();

	// double
	LogTestHeader("StepOverFunctionsReturningNativeTypes - double");
	EXPECT_TRUE(src.Find("func_double();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "double", "dbl", "1.7976931348623e+308");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "double", "ldbl", "UNKNOWN");
	FillExprInfo(expr_info_expected[2], NOT_EXPANDABLE, "double", "func_double returned", "1.7976931348623e+308");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 3));
	RestoreFocusToSrcWnd();

	// long double
	LogTestHeader("StepOverFunctionsReturningNativeTypes - long double");
	EXPECT_TRUE(src.Find("func_ldouble();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], COLLAPSED, "base", "b", "{...}");

	// 68k uses long doubles, other platforms map them to doubles.
	CString ldbl_val_str = "1.7976931348623e+308";

	CString ldbl_typ_str = "double";

	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, ldbl_typ_str, "ldbl", ldbl_val_str);
	FillExprInfo(expr_info_expected[2], NOT_EXPANDABLE, ldbl_typ_str, "func_ldouble returned", ldbl_val_str);
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 3));
	RestoreFocusToSrcWnd();
	}


/**********************************************
 * step over function returning class object. *
 **********************************************/
void CRetValIDETest::StepOverFunctionReturningClassObject(void)
	{
	LogTestHeader("StepOverFunctionReturningClassObject");
	EXPECT_TRUE(src.Find("func_class();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], COLLAPSED, "base", "b", "{...}");
	FillExprInfo(expr_info_expected[1], COLLAPSED, "base *", "pb", "ADDRESS");
	FillExprInfo(expr_info_expected[2], NOT_EXPANDABLE, "base", "func_class returned", "{...}");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 3));
	RestoreFocusToSrcWnd();
	}


/*********************************************************
 * step over function returning pointer to class object. *
 *********************************************************/
void CRetValIDETest::StepOverFunctionReturningPointerToClassObject(void)
	{
	LogTestHeader("StepOverFunctionReturningPointerToClassObject");
	EXPECT_TRUE(src.Find("func_pclass();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], COLLAPSED, "base *", "pb", "ADDRESS");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "base *", "func_pclass returned", "ADDRESS");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
	// verify that address values displayed for both items are the same.
	EXPECT_TRUE(expr_info_actual[0].value == expr_info_actual[1].value);
	RestoreFocusToSrcWnd();
	}


/************************************************************
 * step over function that does a throw and lands execution *
 * back in the parent function, and step out of the catch.  *
 ************************************************************/
void CRetValIDETest::StepOverFunctionThrowingExceptionToParent(void)

	{
	LogTestHeader("StepOverFunctionThrowingExceptionToParent");
	EXPECT_TRUE(src.Find("try"));
	EXPECT_TRUE(dbg.SetNextStatement());
	
	// step over function that does a throw.
	EXPECT_TRUE(dbg.StepOver(2));

	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "", "", "");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	
	// step out of the catch.
	EXPECT_TRUE(dbg.StepInto());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	
	RestoreFocusToSrcWnd();
	}


/************************
 * step out of WinMain. *
 ************************/
/****************************************************************
 * verify return value for stdcall (pascal) calling convention. *
 ****************************************************************/
void CRetValIDETest::StepOutOfWinMain(void)
	{
	LogTestHeader("StepOutOfWinMain");
	// start from WinMain()'s return statement.
	EXPECT_TRUE(src.Find("return 0;"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver(2));
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, ROW_LAST));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "WinMain returned", "0");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	// restore execution to initial state (anywhere after WinMain prolog).
	RestoreFocusToSrcWnd();
	dbg.Restart();
	dbg.SetSteppingMode(SRC);
	dbg.StepOver();
	}


/***************************
 * step over dll function. *
 ***************************/
void CRetValIDETest::StepOverDllFunction(void)
	{
	LogTestHeader("StepOverDllFunction");
	EXPECT_TRUE(src.Find("dll_func();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "dll_func returned", "1");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/********************************************************************************
 * step over implicit constructor call (new) and virtual class member function. *
 ********************************************************************************/
void CRetValIDETest::StepOverConstructorAndVirtualMemberFunction(void)

	{	
	LogTestHeader("StepOverConstructorAndVirtualMemberFunction");
	
	// step over the constructor.
	EXPECT_TRUE(src.Find("base *pd = new derived;"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	// TODO (michma): need to change retval.mak so we statically link to retail crt.
	// (new's return value willl not be displayed).	don't forget to change ExprInfoIs' third param to 4.
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], COLLAPSED, "base *", "pd", "ADDRESS");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "int", "pd->m_var", "UNKNOWN");
	//FillExprInfo(expr_info_expected[2], NOT_EXPANDABLE, "void *", "operator new returned", "ADDRESS");
	FillExprInfo(expr_info_expected[2], NOT_EXPANDABLE, "void", "derived::derived returned", "<void>");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 3));

	// step over the member function.
	EXPECT_TRUE(dbg.StepOver(2));
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], COLLAPSED, "base *", "pd", "ADDRESS");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "int", "derived::m_func returned", "1");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));

	RestoreFocusToSrcWnd();
	}


/********************************************************
 * step over function with only line number debug info. *
 ********************************************************/ 
void CRetValIDETest::StepOverFunctionWithOnlyLineNumberDebugInfo(void)
	{
	LogTestHeader("StepOverFunctionWithOnlyLineNumberDebugInfo");
	EXPECT_TRUE(src.Find("line_numbers_only();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "", "", "");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/******************************************
 * step over function with no debug info. *
 ******************************************/
void CRetValIDETest::StepOverFunctionWithNoDebugInfo(void)
	{
	LogTestHeader("StepOverFunctionWithNoDebugInfo");
	EXPECT_TRUE(src.Find("no_debug_info();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "", "", "");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/*********************************************************
 * step over statically linked, non-debug, crt function. *
 *********************************************************/
void CRetValIDETest::StepOverStaticallyLinkedNonDebugCrtFunction(void)
	{
	LogTestHeader("StepOverStaticallyLinkedNonDebugCrtFunction");
	EXPECT_TRUE(src.Find("abs(-1);"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
#ifndef _M_ALPHA
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "abs returned", "1");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
#else
	FillExprInfo(expr_info_expected[0], COLLAPSED, "base *", "pd", "ADDRESS");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "int", "abs returned", "1");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
#endif
	RestoreFocusToSrcWnd();
	}


/*****************************************************************************
 * step over Win32 API function.
 *****************************************************************************/
void CRetValIDETest::StepOverWin32ApiFunction(void)
	{
	LogTestHeader("StepOverWin32ApiFunction");
	EXPECT_TRUE(src.Find("GetLastError();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "", "", "");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/*********************************
 * step out of function with F8. * 
 *********************************/
void CRetValIDETest::StepOutOfFunctionWithF8(void)
	
	{
	LogTestHeader("StepOutOfFunctionWithF8");
	EXPECT_TRUE(src.Find("func_void();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	if( WaitMsgBoxText("This operation will move the current location", 10) )
	{
		MST.WButtonClick( "OK" ); 
	}
	
	// TODO (michma): x86 acts like mips and alpha until orion: 4423 is fixed.
	//if (m_platform == PLATFORM_WIN32_ALPHA)
	//	{EXPECT_TRUE(dbg.StepInto(2));}
	//else
		{EXPECT_TRUE(dbg.StepInto(3));}
	
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "void", "func_void returned", "<void>");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));

	RestoreFocusToSrcWnd();
	}


/**********************************
 * step out of function with F10. *
 **********************************/
void CRetValIDETest::StepOutOfFunctionWithF10(void)
	
	{
	LogTestHeader("StepOutOfFunctionWithF10");
	EXPECT_TRUE(src.Find("func_void();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	if( WaitMsgBoxText("This operation will move the current location", 10) )
	{
		MST.WButtonClick( "OK" ); 
	}
	EXPECT_TRUE(dbg.StepInto());

	// TODO (michma): x86 acts like mips and alpha until orion: 4423 is fixed.
	//if (m_platform == PLATFORM_WIN32_ALPHA)
	//	{EXPECT_TRUE(dbg.StepOver());}
	//else
		{EXPECT_TRUE(dbg.StepOver(2));}

	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "void", "func_void returned", "<void>");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));

	RestoreFocusToSrcWnd();
	}


/***************************************
 * step out of function with shift+F7. *
 ***************************************/
void CRetValIDETest::StepOutOfFunctionWithShiftF7(void)
	{
	LogTestHeader("StepOutOfFunctionWithShiftF7");
	EXPECT_TRUE(src.Find("func_void();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(dbg.StepOut());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
#ifndef _M_ALPHA
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "void", "func_void returned", "<void>");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
#else
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "char", "ch", "0 '\\x00'");
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "void", "func_void returned", "<void>");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
#endif
	RestoreFocusToSrcWnd();
	}


/*****************************************
 * step over line with no function call. *
 *****************************************/
void CRetValIDETest::StepOverLineWithNoFunctionCall(void)
	{
	LogTestHeader("StepOverLineWithNoFunctionCall");
	EXPECT_TRUE(src.Find("for(0;0;0);"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
#ifndef _M_ALPHA
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "", "", "");
#else
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "char", "ch", "127 '\x7f'");
#endif
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/********************************************************************
 * go and verify that previous function return value not displayed. *
 ********************************************************************/
void CRetValIDETest::VerifyNoReturnValueDisplayedAfterGo(void)
	{
	LogTestHeader("VerifyNoReturnValueDisplayedAfterGo");
	EXPECT_TRUE(src.Find("func_void();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(src.Find("for(0;0;0);"));
	EXPECT_TRUE(dbg.StepToCursor());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
#ifndef _M_ALPHA
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "", "", "");
#else
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "char", "ch", "127 '\x7f'");
#endif
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/***********************************************************************************************
 * verify that function return item disappears when stepping to next line and assigning value. *
 ***********************************************************************************************/
void CRetValIDETest::VerifyReturnValueDisappearsWhenAssigningValue(void)

	{
	LogTestHeader("VerifyReturnValueDisappearsWhenAssigningValue");
	EXPECT_TRUE(src.Find("char ch = func_char();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(dbg.StepOut());
	
	// just stepped out of function so value hasn't been asigned yet but
	// return value should be displayed.
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "char", "ch", "UNKNOWN");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "char", "func_char returned", "127 '\x7f'");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
	
	// return value should disappear now.
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "char", "ch", "127 '\x7f'");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "unsigned char", "uch", "UNKNOWN");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));

	RestoreFocusToSrcWnd();
	}


/**************************************************************
 * verify that function return item disappears when stepping  *
 * to line after next and not assigning value.                *
 **************************************************************/
void CRetValIDETest::VerifyReturnValueDisappearsWhenNotAssigningValue(void)

	{
	LogTestHeader("VerifyReturnValueDisappearsWhenNotAssigningValue");
	EXPECT_TRUE(src.Find("func_void();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(dbg.StepOut());
	
	// after stepping out of function, execution resumes at next line since no value to assign.
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
#ifndef _M_ALPHA
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "void", "func_void returned", "<void>");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
#else
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "char", "ch", "127 '\x7f'");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "void", "func_void returned", "<void>");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
#endif
	
	// return value should disappear now.
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
#ifndef _M_ALPHA
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "", "", "");
#else
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "char", "ch", "127 '\x7f'");
#endif
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));

	RestoreFocusToSrcWnd();
	}


/************************************************************************
 * verify that function return item stays after setting next statement. *
 ************************************************************************/
void CRetValIDETest::VerifyReturnValueStaysAfterResettingNextStatement(void)
	{
	LogTestHeader("VerifyReturnValueStaysAfterResettingNextStatement");
	EXPECT_TRUE(src.Find("func_void();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(src.Find("while(0);"));
	EXPECT_TRUE(dbg.SetNextStatement());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
#ifndef _M_ALPHA
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "void", "func_void returned", "<void>");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
#else
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "char", "ch", "127 '\x7f'");
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "void", "func_void returned", "<void>");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
#endif
	RestoreFocusToSrcWnd();
	}


/**********************************************************************
 * verify that function return item stays after callstack navigation. *
 **********************************************************************/
void CRetValIDETest::VerifyReturnValueStaysAfterStackNavigation(void)
	{
	LogTestHeader("VerifyReturnValueStaysAfterStackNavigation");
	EXPECT_TRUE(src.Find("func_void();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(stk.NavigateStack(1)!=0); //may hit the Kernel module, in which case -1
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, ROW_LAST));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "void", "func_void returned", "<void>");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	// restore stack to initial state. 
	EXPECT_TRUE(stk.NavigateStack(0)>0);
	RestoreFocusToSrcWnd();
	}


/*****************************************************************
 * step over function that uses the fastcall calling convention. * 
 *****************************************************************/
void CRetValIDETest::VerifyReturnValueForFastcallCallingConvention(void)
	{
	LogTestHeader("VerifyReturnValueForFastcallCallingConvention");
	EXPECT_TRUE(src.Find("fastcall_func();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "fastcall_func returned", "1");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/******************************************************
 * step out of multiple levels of recursive function. *
 ******************************************************/
void CRetValIDETest::StepOutOfMultipleLevelsOfRecursion(void)
	
	{
	LogTestHeader("StepOutOfMultipleLevelsOfRecursion");
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("return i; // most nested return"));
	EXPECT_TRUE(dbg.StepToCursor());
	char ret_val_str[2];

	// step out of each call (4 times).
	// YS:actually it Steps out 5 times and now it shows 2 lines for the first 4 StepOuts
	for(int ret_val_dec = 5; ret_val_dec > 0; ret_val_dec--)
	{
		EXPECT_TRUE(dbg.StepOut());
		uivar.Activate();
	 	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
		if (ret_val_dec > 1)
		{
			FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "i", itoa(ret_val_dec - 1, ret_val_str, 10));
			FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "int", "recursive_func returned", itoa(ret_val_dec, ret_val_str, 10));
		}
		else
			FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "recursive_func returned", itoa(ret_val_dec, ret_val_str, 10));
		EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	}

	RestoreFocusToSrcWnd();
	}


/**********************************
 * step out of callback function. *
 **********************************/
void CRetValIDETest::StepOutOfCallbackFunction(void)
	{
	// TODO (michma): need to get passed compiler problem with EnumWindowsProc
	// before we can finish implementing this test.
	LogTestHeader("StepOutOfCallbackFunction");
	}


/*********************************************
 * verify that Value field cannot be edited. *
 *********************************************/
void CRetValIDETest::VerifyReturnValueFieldCannotBeEdited(void)
	{
	LogTestHeader("VerifyReturnValueFieldCannotBeEdited");
	EXPECT_TRUE(src.Find("func_void();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	// attempt to set the value in the first row (containing return value) to 0.
	EXPECT_TRUE(uivar.SetValue(0, 1) == ERROR_ERROR);
	RestoreFocusToSrcWnd();
	}


/**************************************************************************************
 * restart debugging and verify that previous function return value removed at break. *
 **************************************************************************************/
void CRetValIDETest::VerifyNoReturnValueDisplayedAfterRestart(void)
	{
	LogTestHeader("VerifyNoReturnValueDisplayedAfterRestart");
	EXPECT_TRUE(src.Find("func_void();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.Restart());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, ROW_LAST));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "nCmdShow", "1");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	// restore execution to inital state (anywhere after WinMain() prolog).
	EXPECT_TRUE(dbg.StepOver());
	RestoreFocusToSrcWnd();
	}


/*******************************************************
 * stop and restart debugging and verify that previous *
 * function return value removed at break.             *
 *******************************************************/
void CRetValIDETest::VerifyNoReturnValueDisplayedAfterStopAndRestart(void) 
	{
	LogTestHeader("VerifyNoReturnValueDisplayedAfterStopAndRestart");
	EXPECT_TRUE(src.Find("func_void();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_TRUE(dbg.Restart());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, ROW_LAST));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "nCmdShow", "1");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	// restore execution to inital state (anywhere after WinMain() prolog).
	EXPECT_TRUE(dbg.StepOver());
	RestoreFocusToSrcWnd();
	}


/************************************************************
 * toggle return value off and an via Tools.Options.Debug. *
 ************************************************************/
void CRetValIDETest::ToggleReturnValueOffAndOn(void)
	
	{
	LogTestHeader("ToggleReturnValueOffAndOn");

	dbg.ToggleReturnValue(TOGGLE_OFF);
	EXPECT_TRUE(src.Find("func_void();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "", "", "");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();

	dbg.ToggleReturnValue(TOGGLE_ON);
	EXPECT_TRUE(src.Find("func_void();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "void", "func_void returned", "<void>");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\retval\retvcase.h ===
///////////////////////////////////////////////////////////////////////////////
//	RetVcase.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CRetValIDETest Class
//

#ifndef __RetVcase_H__
#define __RetVcase_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\dbgset.h"
#include "retvsub.h"

///////////////////////////////////////////////////////////////////////////////
//	CRetValIDETest class

class CRetValIDETest : public CDebugTestSet
{
		DECLARE_TEST(CRetValIDETest, CRetValSubSuite)

	// Operations
	public:
		virtual void PreRun(void);
		virtual void Run(void);

	// Test cases
	private:
		void StepOverFunctionsReturningNativeTypes(void);
		void StepOverFunctionReturningClassObject(void);
		void StepOverFunctionReturningPointerToClassObject(void);
		void StepOverFunctionThrowingExceptionToParent(void);
		void StepOutOfWinMain(void);
		void StepOverDllFunction(void);
		void StepOverConstructorAndVirtualMemberFunction(void);
		void StepOverFunctionWithOnlyLineNumberDebugInfo(void);
		void StepOverFunctionWithNoDebugInfo(void);
		void StepOverStaticallyLinkedNonDebugCrtFunction(void);
		void StepOverWin32ApiFunction(void);
		void StepOutOfFunctionWithF8(void);
		void StepOutOfFunctionWithF10(void);
		void StepOutOfFunctionWithShiftF7(void);
		void StepOverLineWithNoFunctionCall(void);
		void VerifyNoReturnValueDisplayedAfterGo(void);
		void VerifyReturnValueDisappearsWhenAssigningValue(void);
		void VerifyReturnValueDisappearsWhenNotAssigningValue(void);
		void VerifyReturnValueStaysAfterResettingNextStatement(void);
		void VerifyReturnValueStaysAfterStackNavigation(void);
		void VerifyReturnValueForFastcallCallingConvention(void);
		void StepOutOfMultipleLevelsOfRecursion(void);
		void StepOutOfCallbackFunction(void);
		void VerifyReturnValueFieldCannotBeEdited(void);
		void VerifyNoReturnValueDisplayedAfterRestart(void);
		void VerifyNoReturnValueDisplayedAfterStopAndRestart(void); 
		void ToggleReturnValueOffAndOn(void);

	// Data
	private:
		EXPR_INFO expr_info_actual[4], expr_info_expected[4];
	};

#endif //__RetVcase_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\stack\cspecial.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SK1CASES.CPP
//
//	Created by :			Date :
//		YefimS			01/06/94
//
//	Description :
//		Implementation of the Cstack2IDETest class
//

#include "stdafx.h"
#include "stacsub.h"
#include "cspecial.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(Cstack_specialIDETest, CDebugTestSet, "CallStack Special", -1, CstackSubSuite)

void Cstack_specialIDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

void Cstack_specialIDETest::Run()
{	 
	XSAFETY;
	if( SetProject("stack01\\stack01") )
	{	  
		XSAFETY;
		MainSequence();
		XSAFETY;
		Recursion();
		XSAFETY;
//		Options();
//		XSAFETY;
		AdvancedParam();
	}
}

///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////

BOOL Cstack_specialIDETest::MainSequence(   )
{
	EXPECT( dbg.Restart() );
	EXPECT( UIWB.VerifySubstringAtLine( "{" ) );		
	// Verify main and __crt are in stack
	CString strFunc = "main() line 57";
	LOG->RecordCompare( stk.CurrentFunctionIs(strFunc) == TRUE,
		"Top of stack on restart expected value: %s ", strFunc);
	strFunc = "mainCRTStartup";
	stk.NavigateStack(1);
	LOG->RecordCompare( stk.FunctionIs(strFunc, 1) == TRUE,
		"CRT startup stack on restart expected value: %s ", strFunc);

	CheckParamList();
	VarParam();

	return (TRUE);
}

//I have no idea what I wanted to to here: all C++ cases are included in AdvancedParam()
BOOL Cstack_specialIDETest::CheckParamList(   )
{
	return (TRUE);
}

BOOL Cstack_specialIDETest::VarParam(   )
{
	bps.SetBreakpoint("average");
	dbg.Go("average");
	EXPECT_TRUE(stk.CurrentFunctionIs("average(int 1) line ") );
	bps.ClearAllBreakpoints();
	return (TRUE);
}

const int nFirstFactorialLine = 311;
//char szLastLn==nFirstFactorialLine+5;
//char szRetLn==nFirstFactorialLine+4;

BOOL Cstack_specialIDETest::Recursion(   )
{
 	LogTestHeader( "Recursion" );

	CString sLastLn;sLastLn.Format("%d",nFirstFactorialLine+5); //last line of factorial function
	CString sRetLn;sRetLn.Format("%d",nFirstFactorialLine+4);  //the return line of factorial function

	EXPECT( dbg.Restart() );
	// Open source
	CString strSource = "cstack.c";
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);   //Review yefims
	MST.WFndWnd(strSource, FW_FOCUS);

	EXPECT_TRUE( src.Find("factorial(9)") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "factorial(9)") );
	CString strFunc = "main() line 122";
	VerifyLocalsWndString("int", "i_main", "4");
//	MST.WFndWnd(strSource, FW_FOCUS);
	WriteLog( stk.CurrentFunctionIs(strFunc) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);
/*	strFunc = "mainCRTStartup";
	WriteLog( stk.FunctionIs(strFunc, 1) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);
*/
	WriteLog( ShortRecCycle(9) ? PASSED : FAILED, "Recursion 1: CallStack verification through recursion step" );
	WriteLog( ShortRecCycle(8) ? PASSED : FAILED, "Recursion 2: CallStack verification through recursion step" );

	MST.WFndWnd(strSource, FW_FOCUS);
	for(int cnt=0;cnt<6;cnt++)
		EXPECT( dbg.StepToCursor());

	WriteLog( ShortRecCycle(1) ? PASSED : FAILED, "Recursion 9: CallStack verification through recursion step" );
	WriteLog( ShortRecCycle(0) ? PASSED : FAILED, "Recursion 10: CallStack verification through recursion step" );

	EXPECT( dbg.StepOver() );

	WriteLog( StackIsCorrect(0, sLastLn) ? PASSED : FAILED, "Recursion 10: Stack correctness after StepOver");
	EXPECT( dbg.StepOut() );
	WriteLog( StackIsCorrect(1, sRetLn) ? PASSED : FAILED, "Recursion 9: Stack correctness after StepOut");
	EXPECT( dbg.StepOut() );

	for(cnt=0;cnt<6;cnt++)
		EXPECT( dbg.StepOut() );

	WriteLog( StackIsCorrect(8, sRetLn) ? PASSED : FAILED, "Recursion 2: Stack correctness after StepOut");
	EXPECT( dbg.StepOut() );
	WriteLog( StackIsCorrect(9, sRetLn) ? PASSED : FAILED, "Recursion 1: Stack correctness after StepOut");
	EXPECT( dbg.StepOut() );
//	EXPECT( EndOfStackIsCorrect(0) ); //use StackIsCorrect with no smbols from recursive function
	WriteLog( StackIsCorrect(10, "") ? PASSED : FAILED, "Recursion 0: Stack correctness after all is done");

	EXPECT( dbg.StopDebugging() );

	return (TRUE);
}
//callstack options (hex display, types/values only displey?)
BOOL Cstack_specialIDETest::Options(   )
{
	return (TRUE);
}

BOOL Cstack_specialIDETest::AdvancedParam(   )
{
	bps.SetBreakpoint("Cxx_Tests");
	dbg.Go("Cxx_Tests");
//pointers to gunctions on the stack
	EXPECT_TRUE( StepInUntilFrameAdded( "poniterstofunc" ));
	//TODO check the second param on the stack when the EE bug fixed
	EXPECT_TRUE(stk.CurrentFunctionIs("poniterstofunc(void (void *, unsigned long)*") );
	dbg.StepOut();
	EXPECT_TRUE( StepInUntilFrameAdded( "poniterstofunc" ));
	//NULL pointer to function
	//TODO: change <no type> when EE bug is fixed
	EXPECT_TRUE(stk.CurrentFunctionIs("int (void *, <no type>)* 0x00000000") );
	dbg.StepOut();
//overloaded functions
	EXPECT_TRUE( StepInUntilFrameAdded("overloaded_function(int 1)") );
	dbg.StepOut();
//TODO set ambiguous BP on second entry to "overloaded_function"?
	EXPECT_TRUE( StepInUntilFrameAdded("overloaded_function(long 1)") );
	dbg.StepOut();
//different calling conventions
	bps.SetBreakpoint("fastcall_function");
	dbg.Go("fastcall_function");	
	char const * const stk0[] =
	{
		"fastcall_function(float 3.00000) line", //__fastcall does not put all params on stack
		"stdcall_function(int 1, long 2, float 3.00000) line",
		"cdecl_function(int 1, long 2, float 3.00000) line",
		"Cxx_Tests()",
		NULL
	};
	// Verify information on stack above callback
	int index;
	EXPECT_SUBTEST( (index = stk.Index( "Cxx_Tests()" ) ) != -1 );
	EXPECT_SUBTEST( stk.Compare( stk0, FrameList::NoFilter, 0, index ) );

	bps.ClearAllBreakpoints();
	EXPECT_TRUE(dbg.Go( NULL, NULL, NULL, ASSUME_NORMAL_TERMINATION));
	return (TRUE);
}


BOOL Cstack_specialIDETest::ShortRecCycle(int nParam)
{
	CString strLine;
	strLine.Format("%d", nFirstFactorialLine+1);

	EXPECT_TRUE( dbg.StepInto(2) );
	if( !StackIsCorrect(nParam, strLine) )
		return FALSE;

	strLine.Format("%d", nParam);
	EXPECT_TRUE( LocalsWndStringIs("int", "i", strLine ));

	EXPECT_TRUE( dbg.StepInto() );
	EXPECT_TRUE( LocalsWndStringIs("int", "i", strLine ));

	if( nParam )
		strLine.Format("%d",nFirstFactorialLine+4);
	else
		strLine.Format("%d",nFirstFactorialLine+2);

	if( !StackIsCorrect(nParam, strLine) )
		return FALSE;

	return TRUE;
}

BOOL Cstack_specialIDETest::StackIsCorrect(int nParam, LPCSTR strLine)
{
#define MAX_STK_LINE 80
 	char buffer[10];
	BOOL ret = TRUE;	
	int level;
	char  stktable[11][MAX_STK_LINE]; //11 for the "main()" frame
	char const * stkrec[12]; //12 for the baseline which must be NULL
	for( level = 0; level < 10 - nParam; level++ )
	{
		strcpy(stktable[level], "factorial(int ");
		strcat(stktable[level], _itoa(nParam + level, buffer, 10));
		strcat(stktable[level], ") line ");
		if(level==0)
			strcat(stktable[level], strLine);
		else
		{
			sprintf(buffer, "%d + ",nFirstFactorialLine+4);
			strcat(stktable[level], buffer);
		}
		stkrec[level]=stktable[level];
	}
	strcpy(stktable[level], "main() "); //main shld be the last
	stkrec[level]=stktable[level];
//	strcpy(stktable[++level], "mainCRTStartup"); //platform specific
//	stkrec[level]=stktable[level];
	stkrec[level+1] =  NULL;
	EXPECT_SUBTEST( ret=stk.Compare( stkrec, FrameList::NoFilter, 0, level ) );

	return ret;
}



BOOL Cstack_specialIDETest::EndOfStackIsCorrect(int level)
{ //obsolete
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\stack\cs_base.h ===
///////////////////////////////////////////////////////////////////////////////
//	cs_base.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the Cstack_baseIDETest Class
//

#ifndef __cs_base_H__
#define __cs_base_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\dbgset.h"

///////////////////////////////////////////////////////////////////////////////
//	CstackIDETest class

class Cstack_baseIDETest :public CDebugTestSet
{
	DECLARE_TEST(Cstack_baseIDETest, CstackSubSuite)

public:  // Operations
	virtual void PreRun(void);
	virtual void Run();

	// Test Cases
protected:
	void RebuildProject(LPCSTR projName,LPCSTR pConfig);
	BOOL GeneralNavigation();
	BOOL ChainDisplay();
	BOOL SteppingAndCallStackUpdating();
	BOOL CheckLocals();
	BOOL NavigationAndModifiedLocalGlobal();
};

#endif //__cs_base_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\stack\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\stack\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\stack\cs_dlls.h ===
///////////////////////////////////////////////////////////////////////////////
//	cs_dlls.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CstackIDETest Class
//

#ifndef __cs_dlls_H__
#define __cs_dlls_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\dbgset.h"

///////////////////////////////////////////////////////////////////////////////
//	CstackIDETest class

class Cstack_dllsIDETest :public CDebugTestSet
{
	DECLARE_TEST(Cstack_dllsIDETest, CstackSubSuite)

public:  // Operations
	virtual void PreRun(void);
	virtual void Run();

	// Test Cases
protected:
	BOOL DllGeneralNavigation();
	BOOL DllStepCheckCallStack();
};

#endif //__cs_dlls_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\stack\cs_base.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	cs_base.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "stacsub.h"
#include "cs_base.h"	 

#if defined(_ALPHA_)
#define _CHAIN_2 "chain_2"
#define _CHAIN_3 "chain_3"
#else
#define _CHAIN_2 "_chain_2"
#define _CHAIN_3 "_chain_3"
#endif

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
IMPLEMENT_TEST(Cstack_baseIDETest, CDebugTestSet, "CallStack Base", -1, CstackSubSuite)

void Cstack_baseIDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

void Cstack_baseIDETest::Run()
{
	XSAFETY;

//	EXPECT_EXEC( dbg.SetOwnedStack( &stk ), "Could not setup owned stack" );
//	XSAFETY;

	/*
	** For the dbg application:
	** ChainMain is expected to be compiled with full debug information
	** chain_1 is expected to be compiled with full debug information
	** chain_2 is expected to be compiled with partial debug information
	** chain_3 is expected to be compiled without debug information
	** chain_4 is expected to be compiled with full debug information
	** chain_5 is expected to be compiled with full debug information
	*/
	EXPECT_EXEC( SetProject( "dbg\\dbg" ), "Project could not be setup" );
	XSAFETY;
	GeneralNavigation();
	XSAFETY;
	SteppingAndCallStackUpdating();
	XSAFETY;
	ChainDisplay();
	XSAFETY;

	if( SetProject("stack01\\stack01") )
	{	  
		XSAFETY;
		CheckLocals();
		XSAFETY;
	}

	if( SetProject("testgo01\\testgo01") )
	{	  
		XSAFETY;
		NavigationAndModifiedLocalGlobal();
		XSAFETY;
	}

}

BOOL Cstack_baseIDETest::GeneralNavigation()
{
	CString fnName;	
	CString szTitle;
	UIEditor editor;
 	LogTestHeader( "GeneralNavigation Test" );
 	LogTestHeader( "Initial callstack after first stepin" );
	EXPECT_SUBTEST( dbg.StepInto( 1, "WinMain" ) );
	EXPECT_SUBTEST( Frame( stk.GetFunction( 0 ) ).GetFunctionName( fnName ) );
	EXPECT_SUBTEST( fnName == "WinMain" );

 	LogTestHeader( "General navigation with full debug info" );
	EXPECT_SUBTEST( NULL != bps.SetBreakpoint("chain_5") );
	EXPECT_SUBTEST( dbg.Go() );
	EXPECT_SUBTEST( dbg.AtSymbol("chain_5"));
//	UIWB.DoCommand(ID_WINDOW_CLOSE_ALL, DC_MNEMONIC);	

 	LogTestHeader( "Navigate to 'chain_5' : full debug info : current function" );
	EXPECT_TRUE( stk.NavigateStack( "chain_5" )>0 );
	MST.WFndWndWait("chain1.c", FW_FOCUS | FW_PART, 2);
	EXPECT_TRUE( src.AttachActiveEditor() );
	EXPECT_TRUE( editor.AttachActive() );
	szTitle = editor.GetTitle();
	szTitle.MakeLower();
	EXPECT_TRUE( szTitle == "chain1.c" );
	if( GetUserTargetPlatforms() == PLATFORM_WIN32_ALPHA ) {
		EXPECT_TRUE( src.GetCurrentLine() == 34 );
	}
	else {
		EXPECT_TRUE( src.GetCurrentLine() == 32 );
	}
	// bad programing practice - string constants?? WinslowF
	MST.WFndWndWait("chain1.c", FW_FOCUS | FW_PART, 2);
	EXPECT_TRUE( ERROR_SUCCESS == src.Close(FALSE) );

 	LogTestHeader( "Navigate to 'chain_4' : full debug info" );
	EXPECT_TRUE( stk.NavigateStack( "chain_4" )>0 );
	MST.WFndWndWait("chain4.c", FW_FOCUS | FW_PART, 2);
	EXPECT_TRUE( src.AttachActiveEditor() );
	EXPECT_TRUE( editor.AttachActive() );
	szTitle = editor.GetTitle();
	szTitle.MakeLower();
	EXPECT_TRUE( szTitle == "chain4.c" );
	EXPECT_TRUE( src.GetCurrentLine() == 99 );
	EXPECT_TRUE( editor.Close() );
	VerifyLocalsWndString("int", "x", "3");
	VerifyLocalsWndString("int", "Sum_4", "4", 2);

 	LogTestHeader( "Navigate to 'chain_2' : partial debug info" );
	EXPECT_TRUE( stk.NavigateStack( "DBG! chain_2" )>0 );
	MST.WFndWndWait("chain2.c", FW_FOCUS | FW_PART, 2);
	EXPECT_TRUE( src.AttachActiveEditor() );
	EXPECT_TRUE( editor.AttachActive() );
	szTitle = editor.GetTitle();
	szTitle.MakeLower();
	EXPECT_TRUE( szTitle == "chain2.c" );
	EXPECT_TRUE( src.GetCurrentLine() == 26 );
//	EXPECT_TRUE( editor.Close() ); --leave the "chain2.c" file opened

 	LogTestHeader( "Navigate to 'chain_1' : full debug info" );
	EXPECT_TRUE( stk.NavigateStack( "chain_1" )>0 );
	MST.WFndWndWait("chain1.c", FW_FOCUS | FW_PART, 2);
	EXPECT_TRUE( src.AttachActiveEditor() );
	EXPECT_TRUE( editor.AttachActive() );
	szTitle = editor.GetTitle();
	szTitle.MakeLower();
	EXPECT_TRUE( szTitle == "chain1.c" );
	EXPECT_TRUE( src.GetCurrentLine() == 24 );
	EXPECT_TRUE( editor.Close() );

 	LogTestHeader( "Navigate to 'ChainMain' : full debug info" );
	EXPECT_TRUE( stk.NavigateStack( "ChainMain" )>0 );
	MST.WFndWndWait("chain0.c", FW_FOCUS | FW_PART, 2);
	EXPECT_TRUE( src.AttachActiveEditor() );
	EXPECT_TRUE( editor.AttachActive() );
	szTitle = editor.GetTitle();
	szTitle.MakeLower();
	EXPECT_TRUE( szTitle == "chain0.c" );
	EXPECT_TRUE( src.GetCurrentLine() == 28 );
	EXPECT_TRUE( editor.Close() );

 	LogTestHeader( "Navigate to 'WndProc' : full debug info" );
	EXPECT_TRUE( stk.NavigateStack( "WndProc" )>0 );
	MST.WFndWndWait("main.c", FW_FOCUS | FW_PART, 2);
	EXPECT_TRUE( src.AttachActiveEditor() );
	EXPECT_TRUE( editor.AttachActive() );
	szTitle = editor.GetTitle();
	szTitle.MakeLower();
	EXPECT_TRUE( szTitle == "main.c" );
	EXPECT_TRUE( src.GetCurrentLine() == 117 );
	EXPECT_TRUE( editor.Close() );

 	LogTestHeader( "Navigate to 'chain_3' (DAM: no debug info)" );
	EXPECT_TRUE( stk.NavigateStack( "chain_3" )==-1 );
	EXPECT_TRUE( src.AttachActiveEditor() );
	EXPECT_TRUE( editor.AttachActive() );
	EXPECT_TRUE( editor.GetTitle() == "Disassembly" );
	// bad programing practice - string constants?? WinslowF
	MST.WFndWndWait("Disassembly", FW_FOCUS | FW_PART, 2);
	EXPECT_TRUE( ERROR_SUCCESS == src.Close(FALSE) );

 	LogTestHeader( "Once more to 'chain_5'" );
	EXPECT_TRUE( stk.NavigateStack( "chain_5" )>0 );
	MST.WFndWndWait("chain1.c", FW_FOCUS | FW_PART, 2);
	EXPECT_TRUE( src.AttachActiveEditor() );
	EXPECT_TRUE( editor.AttachActive() );
	szTitle = editor.GetTitle();
	szTitle.MakeLower();
	EXPECT_TRUE( szTitle == "chain1.c" );
	if( GetUserTargetPlatforms() == PLATFORM_WIN32_ALPHA) 
	{
		EXPECT_TRUE( src.GetCurrentLine() == 34 );
	}
	else
	{
		EXPECT_TRUE( src.GetCurrentLine() == 32 );
	}

	LogTestHeader( "Once more to 'chain_2' : source wnd opened" );
	EXPECT_TRUE( stk.NavigateStack( "DBG! chain_2" )>0 );
	MST.WFndWndWait("chain2.c", FW_FOCUS | FW_PART, 2);
	EXPECT_TRUE( src.AttachActiveEditor() );
	EXPECT_TRUE( editor.AttachActive() );
	szTitle = editor.GetTitle();
	szTitle.MakeLower();
	EXPECT_TRUE( szTitle == "chain2.c" );
	EXPECT_TRUE( src.GetCurrentLine() == 26 );
//	EXPECT_TRUE( editor.Close() );

	LogTestHeader( "Navigation within the C++ member functions" );
	UIWB.DoCommand(ID_WINDOW_CLOSE_ALL, DC_MNEMONIC);	
	EXPECT_SUBTEST( NULL != bps.SetBreakpoint("fooclass::chain2_func") );
	EXPECT_SUBTEST( dbg.Go() );
	EXPECT_SUBTEST( dbg.AtSymbol("fooclass::chain2_func"));

 	LogTestHeader( "Navigate to 'fooclass::chain1_func', no src window" );
	EXPECT_TRUE( stk.NavigateStack( "fooclass::chain1_func" )>0 );
	MST.WFndWndWait("cxx.cxx", FW_FOCUS | FW_PART, 2);
	EXPECT_TRUE( src.AttachActiveEditor() );
	EXPECT_TRUE( editor.AttachActive() );
	szTitle = editor.GetTitle();
	EXPECT_TRUE( szTitle == "cxx.cxx" );
	EXPECT_TRUE( src.GetCurrentLine() == 52 );
//	EXPECT_TRUE( editor.Close() );
	VerifyLocalsWndString("unsigned char", "local_cpp_func", "65", 2);

 	LogTestHeader( "Navigate to 'fooclass::chain2_func', src wnd opened" );
	EXPECT_TRUE( stk.NavigateStack( "fooclass::chain2_func" )>0 );
	MST.WFndWndWait("cxx.h", FW_FOCUS | FW_PART, 2);
	EXPECT_TRUE( src.AttachActiveEditor() );
	EXPECT_TRUE( editor.AttachActive() );
	szTitle = editor.GetTitle();
	EXPECT_TRUE( szTitle == "cxx.h" );
	EXPECT_TRUE( src.GetCurrentLine() == 50 );
//	EXPECT_TRUE( editor.Close() );

	dbg.StopDebugging();
	return (TRUE);
}

BOOL Cstack_baseIDETest::ChainDisplay()
{
	CString fnName;
	UIEditor editor;
	int index;
	const char* frame1;
	const char* frame6;

 	LogTestHeader( "Verify Call Stack chain display" );

	bps.ClearAllBreakpoints();

	// Get into nested function to prepare for the test
	EXPECT_TRUE( bps.SetBreakpoint("chain_5") );
	EXPECT_TRUE( dbg.Go(NULL, NULL, "chain_5") );
//	EXPECT_TRUE( dbg.Go() );
//	EXPECT_TRUE( dbg.AtSymbol("chain_5"));

 	LogTestHeader( "Navigate to 'WndProc'" );
	EXPECT_TRUE( stk.NavigateStack( "WndProc" )>0 );
	MST.WFndWndWait("main.c", FW_FOCUS | FW_PART, 2);
	EXPECT_TRUE( src.AttachActiveEditor() );
	EXPECT_TRUE( editor.AttachActive() );
	CString szTitle = editor.GetTitle();
	szTitle.MakeLower();
	EXPECT_TRUE( szTitle == "main.c" );
	EXPECT_TRUE( src.GetCurrentLine() == 117 );

	if( GetUserTargetPlatforms() == PLATFORM_WIN32_ALPHA )
	{
		frame1 = "chain_5( int 3 ) line 34";
	}
	else 
	{
		frame1 = "chain_5( int 3 ) line 32";
	}

	frame6 = "WndProc( HWND__ * %, unsigned int %, unsigned int %, long %) line 117";

	char const * const stk0[] =
	{
		{ frame1 },
		{ "chain_4( int 3 ) line 99" },
		{ "DBG! chain_3" },
		{ "DBG! chain_2 line 26" },
		{ "chain_1( int % ) line 24" },
		{ "ChainMain() line 28" },
		{ frame6 },
//		{ "WndProc( HWND__ * %, unsigned int %, unsigned int %, long %) line 117" },
		NULL
	};

	// Verify information on stack above callback
	EXPECT_SUBTEST( (index = stk.Index( "WndProc" ) ) != -1 );
	EXPECT_SUBTEST( stk.Compare( stk0, FrameList::NoFilter, 0, index ) );

	dbg.StopDebugging();

	RebuildProject("dbg\\dbg","1"); //configuration 1
	EXPECT_TRUE( dbg.Go(NULL, NULL, "chain_5") );
//	EXPECT_TRUE( dbg.Go() );
//	EXPECT_TRUE( dbg.AtSymbol("chain_5"));
	char const * const stk1[] =
	{
		{ frame1 },
		{ "chain_4( int 3 ) line 99" },
		{ "chain_3( int 3 ) line 27" },
		{ "DBG! chain_2 line 26" },
		{ "chain_1( int % ) line 24" },
		{ "ChainMain() line 28" },
		{ frame6 },
//		{ "WndProc( HWND__ * %, unsigned int %, unsigned int %, long %) line 117" },
		NULL
	};
	// Verify information on stack above callback
	EXPECT_SUBTEST( (index = stk.Index( "WndProc" ) ) != -1 );
	EXPECT_SUBTEST( stk.Compare( stk1, FrameList::NoFilter, 0, index ) );

	dbg.StopDebugging();

	XSAFETY;

	RebuildProject("dbg\\dbg","2"); //configuration 2
	EXPECT_TRUE( dbg.Go(NULL, NULL, "chain_5") );
//	EXPECT_TRUE( dbg.Go() );
//	EXPECT_TRUE( dbg.AtSymbol("chain_5"));
	char const * const stk2[] =
	{
		{ frame1 },
		{ "chain_4( int 3 ) line 99" },
		{ "DBG! chain_3" },
		{ "chain_2( int 3 ) line 26" },
		{ "chain_1( int % ) line 24" },
		{ "ChainMain() line 28" },
		{ frame6 },
//		{ "WndProc( HWND__ * %, unsigned int %, unsigned int %, long %) line 117" },
		NULL
	};
	// Verify information on stack above callback
	EXPECT_SUBTEST( (index = stk.Index( "WndProc" ) ) != -1 );
	EXPECT_SUBTEST( stk.Compare( stk2, FrameList::NoFilter, 0, index ) );

	dbg.StopDebugging();
	XSAFETY;

	return (TRUE);
}

void Cstack_baseIDETest::RebuildProject(LPCSTR projName,LPCSTR pConfig)
{
	GetSubSuite()->CleanUp();

	EXPECT_EXEC( SetProject(projName, PROJECT_EXE,fBuildOnly,pConfig), "Project could not be rebuilt" );
}

BOOL Cstack_baseIDETest::SteppingAndCallStackUpdating()
{
	CString fnName;
	UIEditor editor;

 	LogTestHeader( "SteppingAndCallStackUpdating" );

	bps.ClearAllBreakpoints();

 	LogTestHeader( "Updating of callstack during stepping" );

	UIWB.OpenFile( m_strProjectDir + "\\" + "main.c");   //Review yefims
	
	EXPECT_SUBTEST( dbg.StepToCursor(117) );

		FrameList list0;
		list0.CreateFromText( stk.GetAllFunctions() );
		EXPECT_SUBTEST( StepInUntilFrameAdded( "OtherMain" ) );

		EXPECT_SUBTEST( StepInUntilFrameAdded( "foo" ) );
		EXPECT_SUBTEST( StepInUntilFrameRemoved() );
		
		//	TODO: this is due to bug #65634
		//	remove the if line below when fixed - test fails on NT4
		if (GetSystem() != SYSTEM_NT_4)
		EXPECT_TRUE( cxx.ExpressionValueIs("foo(5, 6)", "11") ); //evaluate the function we've stepped out
		EXPECT_SUBTEST( StepInUntilFrameAdded( "BPWithLengthTest" ) );
		EXPECT_SUBTEST( StepInUntilFrameRemoved() );

		EXPECT_SUBTEST( StepInUntilFrameAdded( "Cxx_Tests" ) );
		long an_exception;
		EXPECT_TRUE( cxx.GetExpressionValue("OtherMain()", &an_exception)); //evaluate the function we're at which throws an exception (discard result)
		EXPECT_SUBTEST( StepInUntilFrameAdded( "fooclass::fooclass" ) );
		EXPECT_SUBTEST( StepInUntilFrameRemoved() );
		EXPECT_SUBTEST( StepInUntilFrameAdded( "fooclass::getID" ) );
		EXPECT_SUBTEST( StepInUntilFrameRemoved() );
		EXPECT_SUBTEST( StepInUntilFrameAdded( "fooclass::getCount" ) );
		EXPECT_SUBTEST( StepInUntilFrameRemoved() );
		EXPECT_SUBTEST( StepInUntilFrameAdded( "fooclass::operator int()" ) );
		EXPECT_TRUE( cxx.ExpressionValueIs("Cxx_Tests()", "<void>") ); //evaluate the function we're at
		EXPECT_SUBTEST( StepInUntilFrameRemoved() );
		EXPECT_SUBTEST( StepInUntilFrameAdded( "fooclass::static_func" ) );
		EXPECT_SUBTEST( StepInUntilFrameRemoved() );
		EXPECT_SUBTEST( StepInUntilFrameAdded( "fooclass::clear" ) );
		EXPECT_SUBTEST( StepInUntilFrameRemoved() );
		EXPECT_SUBTEST( StepInUntilFrameAdded( "fooclass::inline_func" ) );
		EXPECT_SUBTEST( StepInUntilFrameRemoved() );
		EXPECT_SUBTEST( StepInUntilFrameAdded( "fooclass::operator int()" ) );
		EXPECT_SUBTEST( StepInUntilFrameRemoved() );
		EXPECT_SUBTEST( dbg.StepOverUntilLine( "};") );
		EXPECT_SUBTEST( StepInUntilFrameAdded( "fooclass::~fooclass" ) );
	
		EXPECT_SUBTEST( StepInUntilFrameRemoved() );

		EXPECT_SUBTEST( StepInUntilFrameRemoved() );	// Cxx_Tests

		//	TODO: this is due to bug #65634
		//	remove the if line below when fixed - test fails on NT4
		if (GetSystem() != SYSTEM_NT_4)
		EXPECT_TRUE( cxx.ExpressionValueIs("foo2(6, 5)", "11") ); //evaluate the function we're about to step into
		EXPECT_SUBTEST( StepInUntilFrameAdded( "foo2" ) );
		EXPECT_SUBTEST( StepInUntilFrameRemoved() );

//	StopDbgCloseProject();
//	WriteLog(PASSED,"Testing of dbg.mak completed");
//	Sleep (200);

	dbg.StopDebugging();
	return (TRUE);
}

BOOL Cstack_baseIDETest::CheckLocals(   )
{
 	LogTestHeader( "CheckLocals" );

	CString strSource = "cstack.c";
	dbg.StepInto();

	// Open source
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);   //Review yefims
//	file.Open( m_strProjectDir + "\\" + strSource);   
	MST.WFndWnd(strSource, FW_FOCUS);

	EXPECT_TRUE( src.Find("VoidProcNoParam();") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "VoidProcNoParam();") );

	MST.WFndWnd(strSource, FW_FOCUS);
	EXPECT_TRUE( dbg.StepInto() );

	CString strFunc = "VoidProcNoParam()";
	WriteLog( stk.CurrentFunctionIs(strFunc) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);

	dbg.SetSteppingMode(SRC);
	MST.WFndWnd(strSource, FW_FOCUS);
	EXPECT_TRUE( src.Find("CharProc1Param(SCHAR_MIN)") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "CharProc1Param(SCHAR_MIN)") );
	EXPECT_TRUE( dbg.StepInto(2) );
	strFunc = "CharProc1Param(char -128)";
	WriteLog( stk.CurrentFunctionIs(strFunc) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);
	VerifyLocalsWndString("char", "c", "-128");

	dbg.SetSteppingMode(SRC);
	MST.WFndWnd(strSource, FW_FOCUS);
	EXPECT_TRUE( src.Find("UCharProc1Param(UCHAR_MAX)") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "UCharProc1Param(UCHAR_MAX)") );
	EXPECT_TRUE( dbg.StepInto(2) );
	strFunc = "UCharProc1Param(unsigned char 255)";
	WriteLog( stk.CurrentFunctionIs(strFunc) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);
	VerifyLocalsWndString("unsigned char", "uc", "255");

	dbg.SetSteppingMode(SRC);
	MST.WFndWnd(strSource, FW_FOCUS);
	EXPECT_TRUE( src.Find("(IntProc1Param(INT_MIN)") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "(IntProc1Param(INT_MIN)") );
	EXPECT_TRUE( dbg.StepInto(2) );
	strFunc = "IntProc1Param(int -2147483648)";
	WriteLog( stk.CurrentFunctionIs(strFunc) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);
	VerifyLocalsWndString("int", "i", "-2147483648");
	
	return (TRUE);
}

BOOL Cstack_baseIDETest::NavigationAndModifiedLocalGlobal()
{
 	LogTestHeader( "NavigationAndModifiedLocalGlobal" );
	bps.ClearAllBreakpoints();

	bps.SetBreakpoint("foo");
	EXPECT_TRUE( dbg.Go(NULL, "int foo(int Parameter) {", "foo") );
	EXPECT_TRUE( cxx.ExpressionValueIs("Global", 77) );
	CString errorString = "CXX0017: Error: symbol \"Local\" not found";
	EXPECT_TRUE( cxx.ExpressionErrorIs("Local", errorString) );

	EXPECT_TRUE( stk.NavigateStack("TestG")>0 );
	EXPECT_TRUE( cxx.ExpressionValueIs("Global", 77) );
	EXPECT_TRUE( cxx.ExpressionValueIs("Local", 17) );
	EXPECT_TRUE( cxx.SetExpressionValue("Global", 60) );
	EXPECT_TRUE( cxx.SetExpressionValue("Local", 10) );

	EXPECT_TRUE( stk.NavigateStack("foo")>0 );
	EXPECT_TRUE( cxx.ExpressionValueIs("Global", 60) );
	EXPECT_TRUE( cxx.ExpressionErrorIs("Local", errorString) );

	EXPECT_TRUE( stk.NavigateStack("WinMain")>0 );
	EXPECT_TRUE( cxx.ExpressionValueIs("Global", 60) );
	EXPECT_TRUE( cxx.ExpressionErrorIs("Local", errorString) );

	EXPECT_TRUE( dbg.StepOut(1, NULL, NULL, "TestG") );
	EXPECT_TRUE( cxx.ExpressionValueIs("Global", 60) );
	EXPECT_TRUE( cxx.ExpressionValueIs("Local", 10) );
	
	bps.ClearAllBreakpoints();
	EXPECT_TRUE( dbg.StepOut(1, NULL, NULL, "WinMain") );
	EXPECT_TRUE( cxx.ExpressionValueIs("Global", 60) );
	EXPECT_TRUE( cxx.ExpressionErrorIs("Local", errorString) );
	
	dbg.StopDebugging();
	return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\threads\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\stack\cs_stres.h ===
///////////////////////////////////////////////////////////////////////////////
//	cs_stres.H
//
//	Created by :			Date :
//		YefimS				01/06/94
//
//	Description :
//		Declaration of the Cstack_stressIDETest class
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __cs_stres_H__
#define __cs_stres_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif


#include "..\dbgset.h"

///////////////////////////////////////////////////////////////////////////////
//	Cstack_stressIDETest class

class Cstack_stressIDETest : public CDebugTestSet
{
	DECLARE_TEST(Cstack_stressIDETest, CstackSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run();

// Test Cases
protected:
	BOOL CheckLocals(   );
	BOOL Recursion(   );

// Utilities
protected:
	void VerifyStack(int nParam, LPCSTR strLine);
	void VerifyEndOfStack(int level);
	void RecCycle(int nParam);
	BOOL ShortRecCycle(int nParam);
	BOOL EndOfStackIsCorrect(int level);
	BOOL StackIsCorrect(int nParam, LPCSTR strLine);
};

#endif //__cs_stres_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\stack\stacsub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CstackSubSuite class
//

#include "stdafx.h"
#include "stacsub.h"
#include "afxdllx.h"
#include "..\cleanup.h"

#include "cs_base.h"
#include "cs_dlls.h"
#include "cspecial.h"
#include "cs_stres.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


/////////////////////////////////////////////////////////////////////////////
// CstackSubSuite

IMPLEMENT_SUBSUITE(CstackSubSuite, CIDESubSuite, "CallStack", "VCQA Debugger")

BEGIN_TESTLIST(CstackSubSuite)
	TEST(Cstack_baseIDETest, RUN)
	TEST(Cstack_dllsIDETest, RUN)
	TEST(Cstack_specialIDETest, RUN)
	TEST(Cstack_stressIDETest, RUN)
END_TESTLIST()


void CstackSubSuite::CleanUp(void)
	{
	::CleanUp("stack01");
	::CleanUp("testgo01");
	::CleanUp("dbg");
	::CleanUp("dllapp");
	}
///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\threads\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\stack\stacsub.h ===
///////////////////////////////////////////////////////////////////////////////
//	stacsub.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CstackSubSuite class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CstackSubSuite class

class CstackSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CstackSubSuite)
//	CstackSubSuite() { m_strName = "TestWizard Generated script"; m_strOwner = "VCBU QA"; }


	DECLARE_TESTLIST()
public:
	void CleanUp(void);
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\stack\cs_dlls.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	cs_dlls.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "stacsub.h"
#include "cs_dlls.h"	 

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
#define cRetailTests 1
#define cDebugTests 1

IMPLEMENT_TEST(Cstack_dllsIDETest, CDebugTestSet, "CallStack DLLs", -1, CstackSubSuite)

void Cstack_dllsIDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();

}

void Cstack_dllsIDETest::Run()
{
	XSAFETY;

//	EXPECT_EXEC( dbg.SetOwnedStack( &stk ), "Could not setup owned stack" );
//	XSAFETY;
	EXPECT_EXEC( SetProject( "dllapp\\incdll", PROJECT_DLL, fBuildOnly), "Project could not be setup" );
	EXPECT_EXEC( SetProject( "dllapp\\powdll", PROJECT_DLL, fBuildOnly), "Project could not be setup" );
	EXPECT_EXEC( SetProject( "dllapp\\dec2", PROJECT_DLL, fBuildOnly), "Project could not be setup" );
	EXPECT_EXEC( SetProject( "dllapp\\dllappx"), "Project could not be setup" );

	// when makefile is wrapped, wrapper name is dllappx1.mak and
	// exe for debug session becomes dllappx1.exe, so we must
	// change it back since we actually build dllappx.exe.
	proj.SetExeForDebugSession("dllappx.exe");

	// dllappx builds 4 files: incdll.dll, dec2.dll, powdll.dll and dllappx.exe.
	// dllappx.exe is copied to remote by SetProject, but we need to do dlls.
	COConnection *pconnec = GetSubSuite()->GetIDE()->GetConnectionInfo();
	if(pconnec->GetUserConnections() != CONNECTION_LOCAL)
	{
		proj.UpdateRemoteFile("src\\dllapp\\incdll.dll");
		proj.UpdateRemoteFile("src\\dllapp\\dec2.dll");
		proj.UpdateRemoteFile("src\\dllapp\\powdll.dll");
	}

	XSAFETY;
	DllGeneralNavigation();
	XSAFETY;
	DllStepCheckCallStack();
	XSAFETY;

	StopDbgCloseProject();
	WriteLog(PASSED,"Testing of dllapp.mak completed");
}


BOOL Cstack_dllsIDETest::DllGeneralNavigation()
{
	CString fnName;
	UIEditor editor;
	int index;

 	LogTestHeader( "DllGeneralNavigation" );

	bps.ClearAllBreakpoints();

	LogTestHeader( "Initial callstack after first stepin" );
	EXPECT_TRUE( dbg.StepInto( 1, "WinMain" ) );
	EXPECT_TRUE( Frame( stk.GetFunction( 0 ) ).GetFunctionName( fnName ) );
	EXPECT_TRUE( fnName == "WinMain" );

 	LogTestHeader( "General navigation with full debug info" );
	EXPECT_TRUE( NULL != bps.SetBreakpoint("{MainWndProc,,}CALLDLLATSTART") );
	EXPECT_TRUE( dbg.Go() );
	EXPECT_TRUE( dbg.AtSymbol("CALLDLLATSTART"));

	char const * const stk1[] =
	{
		{ "MainWndProc( HWND__ * %, unsigned int %, unsigned int %, long %) line 261" },
		NULL
	};

	// Verify information on stack above callback
	EXPECT_TRUE( (index = stk.Index( "MainWndProc" ) ) != -1 );
	EXPECT_TRUE( stk.Compare( stk1, FrameList::NoFilter, 0, index ) );

	dbg.StopDebugging();

	return (TRUE);
}

BOOL Cstack_dllsIDETest::DllStepCheckCallStack()
{
	CString fnName;
	UIEditor editor;
	int index;

 	LogTestHeader( "DllStepCheckCallStack" );
	bps.ClearAllBreakpoints();

	// Step through some dll's.
 	LogTestHeader( "Step through some dll's; stack check and some navigation" );
	EXPECT_TRUE( bps.SetBreakpoint("{MainWndProc,,}CALLDLLATSTART") );
	EXPECT_TRUE( dbg.Go("CALLDLLATSTART") );
	EXPECT_TRUE( StepInUntilFrameAdded( "Dec(unsigned short *" ) );
	EXPECT_TRUE( src.Find("Inc(wBar);   // call another") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "Inc(wBar);   // call another") );
	LOG->Comment("Swithing to ASM mode");
	dbg.SetSteppingMode(ASM);
	LOG->Comment("Stepping until INCDLL!");
	for(int i=0;i<30;i++)
	{  //look for the module name when stepping through thunk jumps
		dbg.StepInto();
		if(stk.CurrentFunctionIs("INCDLL! "))
			break;
	}
	LOG->RecordCompare(i<10, "Stepping into INCDLL module");
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE( stk.CurrentFunctionIs("Inc(unsigned short *") );

	// Do a stack check and some navigation
	char const * const stk2[] =
	{
		{ "Inc( unsigned short * % ) line 36" },
		{ "Dec( unsigned short * % ) line 57" },
		{ "MainWndProc( HWND__ * %, unsigned int %, unsigned int %, long %) line 266" },
//		{ "*" },
		NULL
	};

	// Set stack dirty since StepInUntilFrameAdded used different COStack/CODebug objects
//	stk.SetDirty( TRUE );
	EXPECT_TRUE( (index = stk.Index( "MainWndProc" ) ) != -1 );
	EXPECT_TRUE( stk.Compare( stk2, FrameList::NoFilter, 0, index ) );

	dbg.SetSteppingMode(SRC);
	EXPECT_TRUE( StepInUntilFrameRemoved() );
	EXPECT_TRUE( stk.Compare( stk2+1, FrameList::NoFilter, 0, index-1 ) );

		
	//	dPow is called in an explicitly loaded dll by a function pointer
	EXPECT_TRUE( StepInUntilFrameAdded( "dPow(int 10, int 3)" ) );

	// Do a stack check and some navigation
	const char* frame1;
	frame1 = "dPow( int 10, int 3 ) line 37";
			
	char const * const stk3[] =
	{
		{ frame1 },
		{ "Dec( unsigned short * % ) line 64" },
		{ "MainWndProc( HWND__ * %, unsigned int %, unsigned int %, long %) line 266" },
//		{ "*" },
		NULL
	};

	// Set stack dirty since StepInUntilFrameAdded used different COStack/CODebug objects
	stk.SetDirty( TRUE );
	
	EXPECT_TRUE( (index = stk.Index( "MainWndProc" ) ) != -1 );
	EXPECT_TRUE( stk.Compare( stk3, FrameList::NoFilter, 0, index ) );

	EXPECT_TRUE( StepInUntilFrameRemoved() );
 
	dbg.StopDebugging();

	return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\tmplates\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\tmplates\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\stack\cs_stres.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	cs_stres.CPP
//
//	Created by :			Date :
//		YefimS			01/06/94
//
//	Description :
//		Implementation of the Cstack2IDETest class
//

#include "stdafx.h"
#include "stacsub.h"
#include "cs_stres.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(Cstack_stressIDETest, CDebugTestSet, "CallStack Stress", -1, CstackSubSuite)

void Cstack_stressIDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

void Cstack_stressIDETest::Run()
{	 
	XSAFETY;
	if( SetProject("stack01\\stack01") )
	{	  
		XSAFETY;
		CheckLocals();
		XSAFETY;
		Recursion();
		XSAFETY;
	}
}

///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////

BOOL Cstack_stressIDETest::CheckLocals(   )
{
 	LogTestHeader( "CheckLocals" );

	CString strSource = "cstack.c";
	
	dbg.StepInto();

	// Open source
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);   //Review yefims

	EXPECT_TRUE( src.Find("VoidProcNoParam();") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "VoidProcNoParam();") );
//	MST.WFndWnd(strSource, FW_FOCUS);
	EXPECT_TRUE( dbg.StepInto() );
	CString strFunc = "VoidProcNoParam()";
	WriteLog( stk.CurrentFunctionIs(strFunc) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);

	EXPECT_TRUE( src.Find("CharProc1Param(SCHAR_MIN)") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "CharProc1Param(SCHAR_MIN)") );
	EXPECT_TRUE( dbg.StepInto(2) );
	strFunc = "CharProc1Param(char -128)";
	WriteLog( stk.CurrentFunctionIs(strFunc) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);
	VerifyLocalsWndString("char", "c", "-128");

	EXPECT_TRUE( src.Find("UIntProc1Param(UINT_MAX)") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "UIntProc1Param(UINT_MAX)") );
	EXPECT_TRUE( dbg.StepInto(2) );
	strFunc = "UIntProc1Param(unsigned int 4294967295)";
	WriteLog( stk.CurrentFunctionIs(strFunc) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);
	VerifyLocalsWndString("unsigned int", "ui", "4294967295");

	EXPECT_TRUE( src.Find("LongProc1Param") );
	EXPECT_TRUE( dbg.StepToCursor(0) );
	EXPECT( dbg.StepInto(2) );
	// Verify function is in stack
	strFunc = "LongProc1Param(long -2147483648)";
	WriteLog( stk.CurrentFunctionIs(strFunc) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);
	// Verify locals in Locals window							
	VerifyLocalsWndString("long", "l", "-2147483648");

	EXPECT_TRUE( src.Find("LDoubleProc1Param(ldblmin)") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "LDoubleProc1Param(ldblmin)") );
	EXPECT( dbg.StepInto(2) );
	strFunc = "LDoubleProc1Param(double 2.2250738585072e-308)";
	WriteLog( stk.CurrentFunctionIs(strFunc) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);
	VerifyLocalsWndString("double", "ld", "2.2250738585072e-308");

	EXPECT_TRUE( src.Find("PShortProc1Param") );
	EXPECT_TRUE( dbg.StepToCursor(0) );
	EXPECT( dbg.StepInto(2) );
	// Verify function is in stack
	strFunc = "PShortProc1Param(short *";
	WriteLog( stk.CurrentFunctionIs(strFunc) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);
	// Verify locals in Locals window							
	VerifyLocalsWndString("short *", "ps", "0x");

	EXPECT_TRUE( src.Find("average(1,2,3,4,5,6,7,8,9, -1)") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "average(1,2,3,4,5,6,7,8,9, -1)") );
	EXPECT( dbg.StepInto(2) );
	strFunc = "average(int 1)";
	WriteLog( stk.CurrentFunctionIs(strFunc) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);
	VerifyLocalsWndString("int", "first", "1");

	EXPECT_TRUE( src.Find("factorial(9)") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "factorial(9)") );
	EXPECT( dbg.StepInto(2) );
	strFunc = "factorial(int 9)";
	WriteLog( stk.CurrentFunctionIs(strFunc) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);
	VerifyLocalsWndString("int", "i", "9");

	EXPECT_TRUE( src.Find("MultiParam(CHAR_MIN,") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "MultiParam(CHAR_MIN,") );
	EXPECT( dbg.StepInto(2) );
	strFunc = "MultiParam(char -128, int 2147483647, short 32767, long 2147483647, double 1.7976931348623e+308, double 1.7976931348623e+308, float 3.40282e+038)";
	WriteLog( stk.CurrentFunctionIs(strFunc) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);

	VerifyLocalsWndString("char", "c", "-128");
	VerifyLocalsWndString("int", "i", "2147483647", 2);
	VerifyLocalsWndString("short", "s", "32767", 3);
	VerifyLocalsWndString("long", "l", "2147483647", 4);
	VerifyLocalsWndString("double", "d", "1.7976931348623e+308", 5);
	VerifyLocalsWndString("double", "ld", "1.7976931348623e+308", 6);
	VerifyLocalsWndString("float", "f", "3.40282e+038", 7);

	return (TRUE);
}

const int nFirstFactorialLine = 311;
//char szLastLn==nFirstFactorialLine+5;
//char szRetLn==nFirstFactorialLine+4;

BOOL Cstack_stressIDETest::Recursion(   )
{
 	LogTestHeader( "Recursion" );

	CString sLastLn;sLastLn.Format("%d",nFirstFactorialLine+5); //last line of factorial function
	CString sRetLn;sRetLn.Format("%d",nFirstFactorialLine+4);  //the return line of factorial function

	EXPECT( dbg.Restart() );
	// Open source
	CString strSource = "cstack.c";
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);   //Review yefims
	MST.WFndWnd(strSource, FW_FOCUS);

	EXPECT_TRUE( src.Find("factorial(9)") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "factorial(9)") );
	//the copy of the sequence from cspecial case
//	CString strFunc = "main() line 122";
//	VerifyLocalsWndString("int", "i_main", "4");
//	MST.WFndWnd(strSource, FW_FOCUS);
//	WriteLog( stk.CurrentFunctionIs(strFunc) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);
/*	strFunc = "mainCRTStartup";
	WriteLog( stk.FunctionIs(strFunc, 1) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);
*/
//CHRISKOZ	WriteLog( ShortRecCycle(9) ? PASSED : FAILED, "Recursion 1: CallStack verification through recursion step" );
//CHRISKOZ	WriteLog( ShortRecCycle(8) ? PASSED : FAILED, "Recursion 2: CallStack verification through recursion step" );
//CHRISKOZ	WriteLog( ShortRecCycle(7) ? PASSED : FAILED, "Recursion 3: CallStack verification through recursion step" );
//CHRISKOZ	WriteLog( ShortRecCycle(6) ? PASSED : FAILED, "Recursion 4: CallStack verification through recursion step" );
//CHRISKOZ	WriteLog( ShortRecCycle(5) ? PASSED : FAILED, "Recursion 5: CallStack verification through recursion step" );
//CHRISKOZ	WriteLog( ShortRecCycle(4) ? PASSED : FAILED, "Recursion 6: CallStack verification through recursion step" );
//CHRISKOZ	WriteLog( ShortRecCycle(3) ? PASSED : FAILED, "Recursion 7: CallStack verification through recursion step" );
//CHRISKOZ	WriteLog( ShortRecCycle(2) ? PASSED : FAILED, "Recursion 8: CallStack verification through recursion step" );

//CHRISKOZ	WriteLog( ShortRecCycle(1) ? PASSED : FAILED, "Recursion 9: CallStack verification through recursion step" );
//CHRISKOZ	WriteLog( ShortRecCycle(0) ? PASSED : FAILED, "Recursion 10: CallStack verification through recursion step" );

	RecCycle(9); LOG->RecordSuccess("Recursion 1: Stack correctness in recursive StepInto");
	RecCycle(8); LOG->RecordSuccess("Recursion 2: Stack correctness in recursive StepInto");
	RecCycle(7); LOG->RecordSuccess("Recursion 3: Stack correctness in recursive StepInto");
	RecCycle(6); LOG->RecordSuccess("Recursion 4: Stack correctness in recursive StepInto");
	RecCycle(5); LOG->RecordSuccess("Recursion 5: Stack correctness in recursive StepInto");
	RecCycle(4); LOG->RecordSuccess("Recursion 6: Stack correctness in recursive StepInto");
//CHRISKOZ enable when StepOver recurvisefunction does not work
//	RecCycle(3); 
//	RecCycle(2);
//	RecCycle(1);
//	RecCycle(0);

	EXPECT( dbg.StepOver() ); //CHRISKOZ, bug: StepOver the recursive function used not to work

//CHRISKOZ enable when StepOver recurvisefunction does not work
//	WriteLog( StackIsCorrect(0, sLastLn) ? PASSED : FAILED, "Recursion 10: Stack correctness after StepOver");
//	EXPECT( dbg.StepOut() );
//	WriteLog( StackIsCorrect(1, sRetLn) ? PASSED : FAILED, "Recursion 9: Stack correctness after StepOut");
//	EXPECT( dbg.StepOut() );
//	WriteLog( StackIsCorrect(2, sRetLn) ? PASSED : FAILED, "Recursion 8: Stack correctness after StepOut");
//	EXPECT( dbg.StepOut() );
//	WriteLog( StackIsCorrect(3, sRetLn) ? PASSED : FAILED, "Recursion 7: Stack correctness after StepOut");
//	EXPECT( dbg.StepOut() );
	WriteLog( StackIsCorrect(4, sLastLn) ? PASSED : FAILED, "Recursion 6: Stack correctness after StepOver");
	EXPECT( dbg.StepOut() );
	WriteLog( StackIsCorrect(5, sRetLn) ? PASSED : FAILED, "Recursion 5: Stack correctness after StepOut");
	EXPECT( dbg.StepOut() );
	WriteLog( StackIsCorrect(6, sRetLn) ? PASSED : FAILED, "Recursion 4: Stack correctness after StepOut");
	EXPECT( dbg.StepOut() );
	WriteLog( StackIsCorrect(7, sRetLn) ? PASSED : FAILED, "Recursion 3: Stack correctness after StepOut");
	EXPECT( dbg.StepOut() );
	WriteLog( StackIsCorrect(8, sRetLn) ? PASSED : FAILED, "Recursion 2: Stack correctness after StepOut");
	EXPECT( dbg.StepOut() );
	WriteLog( StackIsCorrect(9, sRetLn) ? PASSED : FAILED, "Recursion 1: Stack correctness after StepOut");
	EXPECT( dbg.StepOut() );
//	EXPECT( EndOfStackIsCorrect(0) ); //use StackIsCorrect with no smbols from recursive function
	WriteLog( StackIsCorrect(10, "") ? PASSED : FAILED, "Recursion 0: Stack correctness after all is done");

	EXPECT( dbg.StopDebugging() );

	return (TRUE);
}



void Cstack_stressIDETest::RecCycle(int nParam)
{
	CString strLine;
	strLine.Format("%d", nFirstFactorialLine);

	EXPECT( dbg.StepInto() );
	StackIsCorrect(nParam, strLine);

	EXPECT( dbg.StepInto() );

	strLine.Format("%d", nParam);
	VerifyLocalsWndString("int", "i", strLine);	
	strLine.Format("%d", nFirstFactorialLine+1);	
	StackIsCorrect(nParam, strLine);

	EXPECT( dbg.StepInto() );
	strLine.Format("%d", nParam);
	VerifyLocalsWndString("int", "i", strLine);

	if( nParam )
		strLine.Format("%d", nFirstFactorialLine+4);
	else
		strLine.Format("%d", nFirstFactorialLine+2);

	StackIsCorrect(nParam, strLine);
}

BOOL Cstack_stressIDETest::ShortRecCycle(int nParam)
{
	CString strLine;
	strLine.Format("%d", nFirstFactorialLine+1);

	EXPECT_TRUE( dbg.StepInto(2) );
	if( !StackIsCorrect(nParam, strLine) )
		return FALSE;

	strLine.Format("%d", nParam);
	EXPECT_TRUE( LocalsWndStringIs("int", "i",  strLine));
//	if( !StackIsCorrect(nParam, nFirstFactorialLine+1) )
//		return FALSE;
	EXPECT_TRUE( dbg.StepInto() );
	EXPECT_TRUE( LocalsWndStringIs("int", "i", strLine));

	if( nParam )
		strLine.Format("%d", nFirstFactorialLine+4);
	else
		strLine.Format("%d", nFirstFactorialLine+2);

	if( !StackIsCorrect(nParam, strLine) )
		return FALSE;

	return TRUE;
}


BOOL Cstack_stressIDETest::StackIsCorrect(int nParam, LPCSTR strLine)
{
#define MAX_STK_LINE 80
 	char buffer[10];
	BOOL ret = TRUE;	
	int level;
	char  stktable[11][MAX_STK_LINE]; //11 for the "main()" frame
	char const * stkrec[12]; //12 for the baseline which must be NULL
	for( level = 0; level < 10 - nParam; level++ )
	{
		strcpy(stktable[level], "factorial(int ");
		strcat(stktable[level], _itoa(nParam + level, buffer, 10));
		strcat(stktable[level], ") line ");
		if(level==0)
			strcat(stktable[level], strLine);
		else
		{
			sprintf(buffer, "%d + ",nFirstFactorialLine+4);
			strcat(stktable[level], buffer);
		}
		stkrec[level]=stktable[level];
LOG->RecordInfo("Function at level %d: expected value: %s ", level, stkrec[level]);
	}
	strcpy(stktable[level], "main() "); //main shld be the last
	stkrec[level]=stktable[level];
LOG->RecordInfo("Function at level %d: expected value: %s ", level, stkrec[level]);
//	strcpy(stktable[++level], "mainCRTStartup"); //platform specific
//	stkrec[level]=stktable[level];
	stkrec[level+1] =  NULL;
	EXPECT_SUBTEST( ret=stk.Compare( stkrec, FrameList::NoFilter, 0, level ) );

	return ret;
}


BOOL Cstack_stressIDETest::EndOfStackIsCorrect(int level)
{ //obsolete
	return TRUE;
}

void Cstack_stressIDETest::VerifyStack(int nParam, LPCSTR strLine)
{ //obsolete
/* 	char buffer[4];

	// Verify stack
	CString strFunc = (CString)"factorial(int " + (CString)_itoa(nParam, buffer, 10) + ") line " + strLine;
	WriteLog( stk.CurrentFunctionIs(strFunc) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);
	int level;
	for( level = 1; level < 10 - nParam; level++ )
	{
		strFunc = (CString)"factorial(int " + (CString)_itoa(nParam + level, buffer, 10) + ") line 'nFirstFactorialLine+4' + ";
		WriteLog( stk.FunctionIs(strFunc, level) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);
	}		
	VerifyEndOfStack(level);
*/
}

void Cstack_stressIDETest::VerifyEndOfStack(int level)
{ //obsolete
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\threads\ThreadsSubsuite.h ===
///////////////////////////////////////////////////////////////////////////////
//	ThreadsSubsuite.h
//
//	Created by: MichMa		Date: 2/5/98
//
//	Description :
//		Declaration of the CThreadsSubsuite class
//

#ifndef __THREADSSUBSUITE_H__
#define __THREADSSUBSUITE_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CThreadsSubsuite class

class CThreadsSubsuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CThreadsSubsuite)
	DECLARE_TESTLIST()
};

#endif //__THREADSSUBSUITE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\threads\ThreadsSubsuite.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	ThreadsSubsuite.cpp
//
//	Created by: MichMa		Date: 2/5/98
//
//	Description :
//		Implementation of the CThreadsSubsuite class
//

#include "stdafx.h"
#include "ThreadsSubsuite.h"
#include "afxdllx.h"
#include "..\cleanup.h"

#include "ThreadsCases.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CThreadsSubsuite

IMPLEMENT_SUBSUITE(CThreadsSubsuite, CIDESubSuite, "Threads", "VCQA Debugger")

BEGIN_TESTLIST(CThreadsSubsuite)
	TEST(CThreadsCases, RUN)
END_TESTLIST()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\threads\ThreadsCases.h ===
///////////////////////////////////////////////////////////////////////////////
//	ThreadsCases.h
//
//	Created by:			Date:
//		MichMa				2/5/98
//
//	Description :
//		Declaration of the CThreadsCases Class
//

#ifndef __THREADSCASES_H__
#define __THREADSCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\dbgset.h"
#include "ThreadsSubsuite.h"


///////////////////////////////////////////////////////////////////////////////
//	CThreadsCases class

class CThreadsCases : public CDebugTestSet

{
	DECLARE_TEST(CThreadsCases, CThreadsSubsuite)

private:
	// Data
	int m_iDefaultThreadPri;

public:

	// Operations
	virtual void PreRun(void);
	virtual void Run(void);

	// Utils
	void InitTestState(void);
	LPCSTR GetThreadIDStr(LPCSTR szThreadIDVar);

	// Test Cases
	void VerifyThreadInfoForMultipleThreads(void);
	void ChangeFocusToDifferentThreadAndBack(void);
	void RunMultithreadedAppToTermination(void);
	void HitLocationBPInThreadSetBeforeThreadCreated(void);
	void HitLocationBPInThreadSetAfterThreadCreated(void);
	void HitGlobalDataBPInThreadSetWhileFocusedOnAnotherThread(void);
	void HitGlobalDataBPInThreadSetWhileFocusedOnSameThread(void);
	void VerifyMemoryDumpOfLocalFromSecondaryThread(void);
	void NavigateStackInSecondaryThread(void);
	void StopDebuggingFromSecondaryThread(void);
	void SuspendAndResumeThread(void);
	void SetFocusToThreadAndStep(void);
	void GoWhenThreadWithFocusIsSuspended(void);
};

#endif //__THREADSCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\tmplates\tmplsub.h ===
///////////////////////////////////////////////////////////////////////////////
//	TMPLSUB.H
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CTemplatesSubSuite class
//

#ifndef __TMPLSUB_H__
#define __TMPLSUB_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CTemplatesSubSuite class

class CTemplatesSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CTemplatesSubSuite)
	DECLARE_TESTLIST()
protected:
	void CleanUp(void);
};

#endif //__TMPLSUB_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\tmplates\tmplsub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	TMPLSUB.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CTemplatesSubSuite class
//

#include "stdafx.h"
#include "tmplsub.h"
#include "afxdllx.h"
#include "..\cleanup.h"

#include "tmplcase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CTemplatesSubSuite

IMPLEMENT_SUBSUITE(CTemplatesSubSuite, CIDESubSuite, "Templates", "VCQA Debugger")

BEGIN_TESTLIST(CTemplatesSubSuite)
	TEST(CTemplatesIDETest, RUN)
END_TESTLIST()

void CTemplatesSubSuite::CleanUp(void)
	{
	::CleanUp("ee");
	}

///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\threads\ThreadsCases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	ThreadsCases.cpp
//											 
//	Created by:			Date:			
//		MichMa				2/5/98	
//
//	Description:								 
//		Implementation of CThreadsCases		 

#include "stdafx.h"
#include "ThreadsCases.h"
#include "..\cleanup.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
											   
IMPLEMENT_TEST(CThreadsCases, CDebugTestSet, "Threads", -1, CThreadsSubsuite)


// each function that runs a test has this prototype.
typedef void (CThreadsCases::*PTR_TEST_FUNC)(void); 

// we randomly pick out of the following list of tests and run them.
// insert functions for new tests to the end of the list.
PTR_TEST_FUNC tests[] = 
{
	&CThreadsCases::VerifyThreadInfoForMultipleThreads,
	&CThreadsCases::ChangeFocusToDifferentThreadAndBack,
	&CThreadsCases::RunMultithreadedAppToTermination,
	&CThreadsCases::HitLocationBPInThreadSetBeforeThreadCreated,
	&CThreadsCases::HitLocationBPInThreadSetAfterThreadCreated,
	&CThreadsCases::HitGlobalDataBPInThreadSetWhileFocusedOnAnotherThread,
	&CThreadsCases::HitGlobalDataBPInThreadSetWhileFocusedOnSameThread,
	&CThreadsCases::VerifyMemoryDumpOfLocalFromSecondaryThread,
	&CThreadsCases::NavigateStackInSecondaryThread,
	&CThreadsCases::StopDebuggingFromSecondaryThread,
	&CThreadsCases::SuspendAndResumeThread,
	&CThreadsCases::SetFocusToThreadAndStep,
	&CThreadsCases::GoWhenThreadWithFocusIsSuspended
};


void CThreadsCases::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}


void CThreadsCases::Run(void)

{
	// default thread priority differs between nt and win9x.
	if((GetSystem() & SYSTEM_WIN_95) || (GetSystem() & SYSTEM_WIN_98) || (GetSystem() & SYSTEM_WIN_MILL))
		m_iDefaultThreadPri = 8;
	else
		m_iDefaultThreadPri = 9;
	
	// setup some paths we will use.
	CString strProjBase;

	if(GetSystem() & SYSTEM_DBCS)
		strProjBase = "[\\]^{|}Aa`@~ threads app";
	else
		strProjBase = "threads app";

	// the location of the unlocalized sources.
	CString strSrcDir = GetCWD() + "src\\threads";
	// the location of the localized project/sources.
	CString strProjDir = strSrcDir + "\\" + strProjBase;

	// clean-up from the last run.
	OurKillFile(strProjDir + "\\Debug\\", "*.*");
	RemoveDirectory(strProjDir + "\\Debug");
	OurKillFile(strProjDir + "\\", "*.*");
	RemoveDirectory(strProjDir);

	// set the options for the project we are building for this test.
	CProjWizOptions *pWin32AppWizOpt = new(CWin32AppWizOptions);
	pWin32AppWizOpt->m_strLocation = strSrcDir;
	pWin32AppWizOpt->m_strName = strProjBase;	
	
	// create the project.
	EXPECT_SUCCESS(proj.New(pWin32AppWizOpt));
	// create a new localized exe source file in the project dir from the unlocalized exe source file.
	CopyFile(strSrcDir + "\\threads.cpp", strProjDir + "\\" + strProjBase + ".cpp", FALSE);
	// make it writable so it can be cleaned up later.
	SetFileAttributes(strProjDir + "\\" + strProjBase + ".cpp", FILE_ATTRIBUTE_NORMAL);
	// add source to the project.
	EXPECT_SUCCESS(proj.AddFiles(strProjBase + ".cpp"));
	// build the project.
	EXPECT_SUCCESS(proj.Build());

	// all tests expect this initial state.
	InitTestState();
	// we only want to randomly run each test once.
	RandomNumberCheckList rncl(sizeof(tests) / sizeof(PTR_TEST_FUNC));
	// indexes into the test function array.
	int iTest;
	
	// randomly run each test once.
	while((iTest = rncl.GetNext()) != -1)
		(this->*(tests[iTest]))();
}


void CThreadsCases::VerifyThreadInfoForMultipleThreads(void)
{
	LogTestHeader("VerifyThreadInfoForMultipleThreads");
	// breaking in WinMain's loop should ensure that we break on source code in both threads and on all os's.
	EXPECT_TRUE(src.Find("loop inside WinMain()"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dbg.CurrentLineIs("loop inside WinMain()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("WinMain"));
	// verify primary thread info.
	CThreadInfo ThreadInfo;
	ThreadInfo.bHasFocus = TRUE;
	ThreadInfo.strID = GetThreadIDStr("dwMainThreadID");
	ThreadInfo.intSuspend = 0;
	ThreadInfo.intPriority = m_iDefaultThreadPri;
	ThreadInfo.strLocation = "WinMain";
	EXPECT_TRUE(threads.VerifyThreadInfo(ThreadInfo));
	// verify secondary thread info.
	ThreadInfo.bHasFocus = FALSE;
	ThreadInfo.strID = GetThreadIDStr("dwSecondaryThreadID");
	ThreadInfo.intSuspend = 0;
	ThreadInfo.intPriority = m_iDefaultThreadPri;
	ThreadInfo.strLocation = "SecondaryThreadFunc";
	EXPECT_TRUE(threads.VerifyThreadInfo(ThreadInfo));
	InitTestState();
}


void CThreadsCases::ChangeFocusToDifferentThreadAndBack(void)
{
	LogTestHeader("ChangeFocusToDifferentThreadAndBack");
	// TODO(michma - 2/8/98): add watch and asm verification.
	// breaking in WinMain's loop should ensure that we break on source code in both threads and on all os's.
	EXPECT_TRUE(src.Find("loop inside WinMain()"));
	EXPECT_TRUE(dbg.StepToCursor());
	CString strThreadID = GetThreadIDStr("dwSecondaryThreadID");
	EXPECT_TRUE(threads.SetThreadFocus(strThreadID));
	EXPECT_TRUE(dbg.CurrentLineIs("loop inside SecondaryThreadFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("SecondaryThreadFunc"));
	EXPECT_TRUE(locals.VerifyLocalInfo("pdata", "0x00000000", "void *", NOT_EXPANDABLE));
	EXPECT_TRUE(locals.VerifyLocalInfo("intLocalSecondaryThreadFunc", "1", "int", NOT_EXPANDABLE));
	EXPECT_TRUE(locals.LocalsCountIs(2));
	strThreadID = GetThreadIDStr("dwMainThreadID");
	EXPECT_TRUE(threads.SetThreadFocus(strThreadID));
	EXPECT_TRUE(dbg.CurrentLineIs("loop inside WinMain()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("WinMain"));
	EXPECT_TRUE(locals.VerifyLocalInfo("hInst", "ADDRESS", "HINSTANCE__ *", COLLAPSED));
	EXPECT_TRUE(locals.VerifyLocalInfo("hInstPrev", "0x00000000", "HINSTANCE__ *", COLLAPSED));
	EXPECT_TRUE(locals.VerifyLocalInfo("lszCmdLine", "ADDRESS \"", "char *", COLLAPSED));
	EXPECT_TRUE(locals.VerifyLocalInfo("nCmdShow", "1", "int", NOT_EXPANDABLE));
	EXPECT_TRUE(locals.VerifyLocalInfo("intLocalWinMain", "0", "int", NOT_EXPANDABLE));
	EXPECT_TRUE(locals.LocalsCountIs(5));
	InitTestState();
}


void CThreadsCases::RunMultithreadedAppToTermination(void)
{
	LogTestHeader("RunMultithreadedAppToTermination");
	// step passed the code that will create the secondary thread.
	EXPECT_TRUE(src.Find("line after call to CreateThread()"));
	EXPECT_TRUE(dbg.StepToCursor());
	// setting bInfiniteLoop to 0 will let the app terminate.
	EXPECT_TRUE(cxx.SetExpressionValue("bInfiniteLoop", 0));
	CString strSecondaryThreadID = GetThreadIDStr("dwSecondaryThreadID");
	CString strMainThreadID = GetThreadIDStr("dwMainThreadID");
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION));
	EXPECT_TRUE(threads.VerifyThreadExitCode(strSecondaryThreadID, 1));
	EXPECT_TRUE(threads.VerifyThreadExitCode(strMainThreadID, 0));
	InitTestState();
}


void CThreadsCases::HitLocationBPInThreadSetBeforeThreadCreated(void)
{
	LogTestHeader("HitLocationBPInThreadSetBeforeThreadCreated");
	EXPECT_TRUE(src.Find("loop inside SecondaryThreadFunc()"));
	EXPECT_VALIDBP(bps.SetBreakpoint());
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("loop inside SecondaryThreadFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("SecondaryThreadFunc"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	InitTestState();
}


void CThreadsCases::HitLocationBPInThreadSetAfterThreadCreated(void)
{
	LogTestHeader("HitLocationBPInThreadSetAfterThreadCreated");
	EXPECT_TRUE(src.Find("CreateThreadFunc();"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dbg.StepOver());
	// verify that the thread has been created before setting the breakpoint.
	CThreadInfo ThreadInfo;
	ThreadInfo.bHasFocus = FALSE;
	ThreadInfo.strID = GetThreadIDStr("dwSecondaryThreadID");
	ThreadInfo.intSuspend = 0;
	ThreadInfo.intPriority = m_iDefaultThreadPri;
	ThreadInfo.strLocation = "SecondaryThreadFunc";
	EXPECT_TRUE(threads.VerifyThreadInfo(ThreadInfo));
	// now set the bp in the thread's func and verify that it is hit.
	EXPECT_TRUE(src.Find("loop inside SecondaryThreadFunc()"));
	EXPECT_VALIDBP(bps.SetBreakpoint());
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("loop inside SecondaryThreadFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("SecondaryThreadFunc"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	InitTestState();
}


void CThreadsCases::HitGlobalDataBPInThreadSetWhileFocusedOnAnotherThread(void)
{
	LogTestHeader("HitGlobalDataBPInThreadSetWhileFocusedOnAnotherThread");
	// remember that initially focus is on main thread (WinMain).
	EXPECT_VALIDBP(bps.SetBreakOnExpr("intGlobal", COBP_TYPE_IF_EXP_CHANGED));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("line after intGlobal changed."));
	EXPECT_TRUE(stk.CurrentFunctionIs("SecondaryThreadFunc"));
	EXPECT_TRUE(cxx.ExpressionValueIs("intGlobal", 1));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	InitTestState();
}


void CThreadsCases::HitGlobalDataBPInThreadSetWhileFocusedOnSameThread(void)
{
	LogTestHeader("HitGlobalDataBPInThreadSetWhileFocusedOnSameThread");
	EXPECT_TRUE(src.Find("first line of SecondaryThreadFunc()"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of SecondaryThreadFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("SecondaryThreadFunc"));
	EXPECT_VALIDBP(bps.SetBreakOnExpr("intGlobal", COBP_TYPE_IF_EXP_CHANGED));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("line after intGlobal changed."));
	EXPECT_TRUE(stk.CurrentFunctionIs("SecondaryThreadFunc"));
	EXPECT_TRUE(cxx.ExpressionValueIs("intGlobal", 1));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	InitTestState();
}


void CThreadsCases::VerifyMemoryDumpOfLocalFromSecondaryThread(void)
{
	LogTestHeader("VerifyMemoryDumpOfLocalFromSecondaryThread");
	EXPECT_TRUE(src.Find("loop inside SecondaryThreadFunc()"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dbg.CurrentLineIs("loop inside SecondaryThreadFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("SecondaryThreadFunc"));
	EXPECT_TRUE(mem.MemoryDataIs("intLocalSecondaryThreadFunc", 1));
	InitTestState();
}


void CThreadsCases::NavigateStackInSecondaryThread(void)
{
	LogTestHeader("NavigateStackInSecondaryThread");
	EXPECT_TRUE(src.Find("first line of FuncCalledBySecondaryThreadFunc()"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(stk.NavigateStack(1));
	EXPECT_TRUE(dbg.CurrentLineIs("line after call to FuncCalledBySecondaryThreadFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("SecondaryThreadFunc"));
	EXPECT_TRUE(locals.VerifyLocalInfo("pdata", "0x00000000", "void *", NOT_EXPANDABLE));
	EXPECT_TRUE(locals.VerifyLocalInfo("intLocalSecondaryThreadFunc", "1", "int", NOT_EXPANDABLE));
	EXPECT_TRUE(locals.LocalsCountIs(2));
	EXPECT_TRUE(stk.NavigateStack(0));
	EXPECT_TRUE(dbg.CurrentLineIs("first line of FuncCalledBySecondaryThreadFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("FuncCalledBySecondaryThreadFunc"));
	EXPECT_TRUE(locals.LocalsCountIs(0));
	InitTestState();
}


void CThreadsCases::StopDebuggingFromSecondaryThread(void)
{
	LogTestHeader("StopDebuggingFromSecondaryThread");
	EXPECT_TRUE(src.Find("first line of SecondaryThreadFunc()"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of SecondaryThreadFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("SecondaryThreadFunc"));
	// view registers and disassembly while in secondary thread (a different case in the testplan).
	EXPECT_TRUE(regs.Enable());
	EXPECT_TRUE(dam.Enable());
	EXPECT_TRUE(dbg.SetSteppingMode(SRC));
	EXPECT_TRUE(dbg.StopDebugging());
	InitTestState();
}


void CThreadsCases::SuspendAndResumeThread(void)
{
	LogTestHeader("SuspendAndResumeThread");
	// step over the function that creates the thread.
	EXPECT_TRUE(src.Find("CreateThreadFunc();"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dbg.StepOver());
	// set the bp in the thread's func.
	EXPECT_TRUE(src.Find("loop inside SecondaryThreadFunc()"));
	EXPECT_VALIDBP(bps.SetBreakpoint());
	// suspend the thread and verify its new status.
	CString strThreadID = GetThreadIDStr("dwSecondaryThreadID");
	EXPECT_TRUE(threads.SuspendThread(strThreadID)); 
	CThreadInfo ThreadInfo;
	ThreadInfo.bHasFocus = FALSE;
	ThreadInfo.strID = strThreadID;
	ThreadInfo.intSuspend = 1;
	ThreadInfo.intPriority = m_iDefaultThreadPri;
	ThreadInfo.strLocation = "SecondaryThreadFunc";
	EXPECT_TRUE(threads.VerifyThreadInfo(ThreadInfo));
	// go and verify that the bp isn't hit (if app is still running after 5 seconds).
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, NOWAIT));
	Sleep(5000);
	EXPECT_TRUE(dbg.GetDebugState() == Debug_Run);
	// resume the thread and verify its new status.
	EXPECT_TRUE(dbg.Break());
	EXPECT_TRUE(threads.ResumeThread(strThreadID));
	ThreadInfo.intSuspend = 0;
	EXPECT_TRUE(threads.VerifyThreadInfo(ThreadInfo));
	// go and verify that the bp is hit.
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("loop inside SecondaryThreadFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("SecondaryThreadFunc"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	InitTestState();
}


void CThreadsCases::SetFocusToThreadAndStep(void)

{
	LogTestHeader("SetFocusToThreadAndStep");
	// break in the secondary thread.
	EXPECT_TRUE(src.Find("loop inside SecondaryThreadFunc()"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dbg.CurrentLineIs("loop inside SecondaryThreadFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("SecondaryThreadFunc"));
	// set focus to the main thread.
	CString strThreadID = GetThreadIDStr("dwMainThreadID");
	EXPECT_TRUE(threads.SetThreadFocus(strThreadID));

	// step in the main thread (different behavior between nt and win9x).
	if((GetSystem() & SYSTEM_WIN_95) || (GetSystem() & SYSTEM_WIN_98))
	{
		EXPECT_TRUE(dbg.StepOver());
		EXPECT_TRUE(dbg.CurrentLineIs("last line of CreateThreadFunc()"));
		EXPECT_TRUE(stk.CurrentFunctionIs("CreateThreadFunc"));
	}
	// on nt we end up in ntdll.dll when switching threads.
	else
	{
		EXPECT_TRUE(stk.RunToFrame("WinMain"));
		EXPECT_TRUE(dbg.SetSteppingMode(SRC));
		EXPECT_TRUE(dbg.CurrentLineIs("loop inside WinMain()"));
		EXPECT_TRUE(stk.CurrentFunctionIs("WinMain"));
	}

	InitTestState();
}


void CThreadsCases::GoWhenThreadWithFocusIsSuspended(void)
{
	LogTestHeader("GoWhenThreadWithFocusIsSuspended");
	EXPECT_TRUE(src.Find("loop inside SecondaryThreadFunc()"));
	EXPECT_TRUE(dbg.StepToCursor());
	CString strThreadID = GetThreadIDStr("dwSecondaryThreadID");
	EXPECT_TRUE(threads.SuspendThread(strThreadID));
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_RUN));
	// CreateThreadFunc sleeps for 3 seconds before returning. this is to ensure that the thread gets created before 
	// that function returns. so if we want to be sure we break into WinMain below, we need to sleep for 3 seconds
	// to ensure that CreateThreadFunc has returned.
	Sleep(3000);
	EXPECT_TRUE(dbg.Break());
	EXPECT_TRUE(dbg.CurrentLineIs("loop inside WinMain()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("WinMain"));
	InitTestState();
}


void CThreadsCases::InitTestState(void)
{
	EXPECT_TRUE(dbg.Restart());
	// attach the COSource object to the source file that the debugger opened.
	src.AttachActive();
} 


LPCSTR CThreadsCases::GetThreadIDStr(LPCSTR szThreadIDVar)

{
	LOG->RecordInfo("GetThreadIDStr - szThreadIDVar = '%s'", szThreadIDVar);
	static char szText[12] = "";
	DWORD dwThreadID;
	
	if(!cxx.GetExpressionValue(szThreadIDVar, &dwThreadID))
	{
		LOG->RecordInfo("CThreadsCases::GetThreadIDStr - GetExpressionValue failed.");
		return (LPCSTR)szText;
	}

	sprintf(szText, "%.8x", dwThreadID);
	return (LPCSTR)szText;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\varswnd\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\varswnd\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\varswnd\autocase.h ===
///////////////////////////////////////////////////////////////////////////////
//	AUTOCASE.H
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CAutoPaneIDETest Class
//

#ifndef __AUTOCASE_H__
#define __AUTOCASE_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

//#include "..\dbgset.h"
#include "..\..\DbgTestBase.h"
#include "varssub.h"

///////////////////////////////////////////////////////////////////////////////
//	CNameSpceIDETest class

class CAutoPaneIDETest : public CDbgTestBase
{
	DECLARE_TEST(CAutoPaneIDETest, CVarsWndSubSuite)

	// Operations
	public:
		virtual void PreRun(void);
		virtual void Run(void);

	// Test cases
	private:
		void VerifyUpdateAfterGo(void);
		void VerifyUpdateAfterStepInto(void);
		void VerifyUpdateAfterStepOut(void);
		void VerifyUpdateAfterStepOver(void);
		void VerifyUpdateAfterRestart(void);
		void VerifyUpdateAfterBreak(void);
		void VerifyUpdateAfterRunToCursor(void);
		void VerifyUpdateAfterSetNextStatement(void);
		void ChangeValueViaExecution(void);
		void ChangeValueViaMemWnd(void);
		void ChangeValueViaWatchWnd(void);
		void ChangeValueViaQuickWatchDlg(void);
		void ChangeValueViaAutoPane(void);
		void VerifyFuncArgsAppearWhenPrologReached(void);
		void NavigateStackToParentFuncAndBack(void);
		void ChangeToThisPaneAndBack(void);
		void ChangeToLocalsPaneAndBack(void);
		void VerifyOnlyCurrentAndPrevStatementsAreScanned(void);
		void VerifyMultilineStatementsGetScannedBackTenLines(void);
		void ScanArraySubscript(void);
		void ScanCastsAndOpsInsideArraySubscript(void);
		void ScanSelfSubscriptedArray(void);
		void ScanIndirectAccessToClassVariableAndFunc(void);
		void ScanDirectAccessToClassVariableAndFunc(void);
		void ScanScopeOp(void);
		void ScanAddressOfOp(void);
		void ScanPointerToMember(void);
		void VerifyRegistersNotAddedInMixedMode(void);
		void VerifyNamesCantBeManuallyDeletedAddedOrEdited(void);
		void VerifyConstantExpressionsNotAdded(void);
		void VerifyFuncCallsNotAdded(void);
		void VerifyUnsupportedOpsNotAdded(void);
		void StepIntoContextOfNoExpressions(void);
		void VerifyExpressionsInCommentsNotAdded(void);
		void VerifyDupExpressionsNotAdded(void);
		void VerifyExpressionsWithErrorValsNotAdded(void);

	// Data
	private:
		EXPR_INFO expr_info_actual[8], expr_info_expected[8];
	};

#endif //__AUTOCASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Tests\Debugger\Core\varswnd\autocase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	AUTOCASE.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 	   
//		TestWizard Generated script.	 

#include "stdafx.h"
#include "autocase.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
										   
IMPLEMENT_TEST(CAutoPaneIDETest, CDbgTestBase, "Auto Pane", -1, CVarsWndSubSuite)
												 
void CAutoPaneIDETest::PreRun(void)
	{
	// call the base class
	CTest::PreRun();
	}


void CAutoPaneIDETest::Run(void)
	
	{
	/******************
	 * INITIALIZATION *
	 ******************/
	if(!InitProject("autopane\\autopane"))
		{
		m_pLog->RecordInfo("ERROR: could not init autopane project");
		return;
		}

	// this is the initial state each test expects.
	//	  - step passed prolog of WinMain().
	//	  - select Auto pane in variables wnd.
	//    - restore focus to source window.
	if(!dbg.StepOver(2))
		{
		m_pLog->RecordInfo("ERROR: could not step passed WinMain()'s prolog");
		return;
		}

	uivar.Activate();

	if(!uivar.SetPane(PANE_AUTO) == ERROR_SUCCESS)
		{
		m_pLog->RecordInfo("ERROR: could not activate Auto pane");
		return;
		}

	RestoreFocusToSrcWnd();

	/*********
	 * TESTS *
	 *********/
	VerifyUpdateAfterGo();
	VerifyUpdateAfterStepInto();
	VerifyUpdateAfterStepOut();
	VerifyUpdateAfterStepOver();
//	VerifyUpdateAfterRestart();	   //bug orion #15002
	VerifyUpdateAfterBreak();
	VerifyUpdateAfterRunToCursor();
	VerifyUpdateAfterSetNextStatement();
	ChangeValueViaExecution();
//	ChangeValueViaMemWnd();
	ChangeValueViaWatchWnd();
	ChangeValueViaQuickWatchDlg();
	ChangeValueViaAutoPane();
	//VerifyFuncArgsAppearWhenPrologReached();
	//NavigateStackToParentFuncAndBack();
	//ChangeToThisPaneAndBack();
	//ChangeToLocalsPaneAndBack();
	//VerifyOnlyCurrentAndPrevStatementsAreScanned();
	//VerifyMultilineStatementsGetScannedBackTenLines();
	ScanArraySubscript();
	ScanCastsAndOpsInsideArraySubscript();
	ScanSelfSubscriptedArray();
	ScanIndirectAccessToClassVariableAndFunc();
	ScanDirectAccessToClassVariableAndFunc();
	ScanScopeOp();
	ScanAddressOfOp();
	//ScanPointerToMember();
	//VerifyRegistersNotAddedInMixedMode();
	//VerifyNamesCantBeManuallyDeletedAddedOrEdited();
	//VerifyConstantExpressionsNotAdded();
	//VerifyFuncCallsNotAdded();
	//VerifyUnsupportedOpsNotAdded();
	StepIntoContextOfNoExpressions();
	VerifyExpressionsInCommentsNotAdded();
	VerifyDupExpressionsNotAdded();
	//VerifyExpressionsWithErrorValsNotAdded();

	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_SUCCESS(prj.Attach());
	EXPECT_SUCCESS(prj.Close());
	} 


/*******************************************
 * verify variables list updated after go. *
 *******************************************/
void CAutoPaneIDETest::VerifyUpdateAfterGo(void)
	{
	LogTestHeader("VerifyUpdateAfterGo");
	EXPECT_TRUE(dbg.Restart());
//	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(src.Find("*pi = 1;"));
	EXPECT_TRUE(bps.SetBreakpoint());
	EXPECT_TRUE(dbg.Go());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "i", "0");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "int", "*pi", "0");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
	bps.ClearAllBreakpoints();
	RestoreFocusToSrcWnd();
	}


/**************************************************
 * verify variables list updated after step into. *
 **************************************************/
void CAutoPaneIDETest::VerifyUpdateAfterStepInto(void)
	{
	LogTestHeader("VerifyUpdateAfterStepInto");
	EXPECT_TRUE(src.Find("i = 0;"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "i", "0");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "int", "*pi", "0");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
	RestoreFocusToSrcWnd();
	}


/*************************************************
 * verify variables list updated after step out. *
 *************************************************/
void CAutoPaneIDETest::VerifyUpdateAfterStepOut(void)
	{
	LogTestHeader("VerifyUpdateAfterStepOut");
	EXPECT_TRUE(src.Find("b.func(0);"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(dbg.StepOut());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], COLLAPSED, "base", "b", "{...}");
	//FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "void", "base::func returned", "<void>");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/**************************************************
 * verify variables list updated after step over. *
 **************************************************/
void CAutoPaneIDETest::VerifyUpdateAfterStepOver(void)
	{
	LogTestHeader("VerifyUpdateAfterStepOver");
	EXPECT_TRUE(src.Find("i = 0;"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "i", "0");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "int", "*pi", "0");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
	RestoreFocusToSrcWnd();
	}


/************************************************
 * verify variables list updated after restart. *
 ************************************************/
void CAutoPaneIDETest::VerifyUpdateAfterRestart(void)
	{
	LogTestHeader("VerifyUpdateAfterRestart");
	EXPECT_TRUE(dbg.Restart());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], COLLAPSED, "void *", "hinst", "ADDRESS");
	FillExprInfo(expr_info_expected[1], COLLAPSED, "void *", "hinstPrev", "ADDRESS");
	FillExprInfo(expr_info_expected[2], COLLAPSED, "char *", "lszCmdLine", "ADDRESS");
	FillExprInfo(expr_info_expected[3], NOT_EXPANDABLE, "int", "nCmdShow", "1");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 4));
	// restore execution to initial state (anywhere after WinMain's prolog).
	EXPECT_TRUE(dbg.StepOver());
	RestoreFocusToSrcWnd();
	}


/**********************************************
 * verify variables list updated after break. *
 **********************************************/
void CAutoPaneIDETest::VerifyUpdateAfterBreak(void)
	{
	LogTestHeader("VerifyUpdateAfterBreak");
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.Go(NULL, 0, NULL, WAIT_FOR_RUN));
	// wait until infinite loop (while(1);) is executed.
	Sleep(10000);
	EXPECT_TRUE(dbg.Break());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "i", "1");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/******************************************************
 * verify variables list updated after run to cursor. *
 ******************************************************/
void CAutoPaneIDETest::VerifyUpdateAfterRunToCursor(void)
	{
	LogTestHeader("VerifyUpdateAfterRunToCursor");
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("*pi = 1;"));
	EXPECT_TRUE(dbg.StepToCursor());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "i", "0");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "int", "*pi", "0");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
	RestoreFocusToSrcWnd();
	}


/************************************************************
 * verify variables list updated after setd next statement. *
 ************************************************************/
void CAutoPaneIDETest::VerifyUpdateAfterSetNextStatement(void)
	{
	LogTestHeader("VerifyUpdateAfterSetNextStatement");
	EXPECT_TRUE(src.Find("i = 0;"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(src.Find("*pi = 1;"));
	EXPECT_TRUE(dbg.SetNextStatement());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "i", "0");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "int", "*pi", "0");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
	RestoreFocusToSrcWnd();
	}


/****************************************************************
 * verify auto pane updated when variable changes via execution	*
 ****************************************************************/
void CAutoPaneIDETest::ChangeValueViaExecution(void)
	{
	LogTestHeader("ChangeValueViaExecution");
	EXPECT_TRUE(src.Find("int i2 = 0;"));
	EXPECT_TRUE(dbg.SetNextStatement());
	// step over "int i2 = 0;" and "i2 = 1;".
	EXPECT_TRUE(dbg.StepOver(2));
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "i2", "1");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}

/*********************************************************************
 * verify auto pane updated when variable changes via memory window. *
 *********************************************************************/
void CAutoPaneIDETest::ChangeValueViaMemWnd(void)
	{
	LogTestHeader("ChangeValueViaMemWnd");
	EXPECT_TRUE(src.Find("int i2 = 0;"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(mem.SetMemoryData("i2", 1));
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "i2", "1");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/********************************************************************
 * verify auto pane updated when variable changes via watch window.	*
 ********************************************************************/
void CAutoPaneIDETest::ChangeValueViaWatchWnd(void)
	{
	LogTestHeader("ChangeValueViaWatchWnd");
	EXPECT_TRUE(src.Find("int i2 = 0;"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uiwatch.Activate();
	EXPECT_SUCCESS(uiwatch.SetName("i2", 1));
	EXPECT_SUCCESS(uiwatch.SetValue("1", 1));
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "i2", "1");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	uiwatch.Activate();
	uiwatch.Delete(1);
	RestoreFocusToSrcWnd();
	}


/************************************************************************
 * verify auto pane updated when variable changes via quickwatch dlg.	*
 ************************************************************************/
void CAutoPaneIDETest::ChangeValueViaQuickWatchDlg(void)
	{
	LogTestHeader("ChangeValueViaQuickWatchDlg");
	EXPECT_TRUE(src.Find("int i2 = 0;"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(uiqw.Activate());
	EXPECT_TRUE(uiqw.SetExpression("i2"));
	EXPECT_TRUE(uiqw.Recalc());
	EXPECT_TRUE(uiqw.SetNewValue("1"));
	EXPECT_TRUE(uiqw.Close() == NULL);
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "i2", "1");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/******************************************************************************************
 * verify auto pane updated when variable changes via auto pane (ie. two different rows). *
 ******************************************************************************************/
void CAutoPaneIDETest::ChangeValueViaAutoPane(void)
	{
	LogTestHeader("ChangeValueViaAutoPane");
	EXPECT_TRUE(src.Find("i = 0;"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.SetValue("1", 1));
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "i", "1");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "int", "*pi", "1");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
	RestoreFocusToSrcWnd();
	}


/**************************************************************
 * verify that function arguments appear when prolog reached. *
 **************************************************************/
void CAutoPaneIDETest::VerifyFuncArgsAppearWhenPrologReached(void)
	{
	}


/****************************************************
 * navigate the stack to another function and back.	*
 ****************************************************/
void CAutoPaneIDETest::NavigateStackToParentFuncAndBack(void)
	{
	}


/********************************************
 * change panes from auto to this and back.	*
 ********************************************/
void CAutoPaneIDETest::ChangeToThisPaneAndBack(void)
	{
	}


/**********************************************
 * change panes from auto to locals and back. *
 **********************************************/
void CAutoPaneIDETest::ChangeToLocalsPaneAndBack(void)
	{
	}


/*****************************************************************************************
 * verify that only expressions from current statement and previous statement are added. *
 *****************************************************************************************/
void CAutoPaneIDETest::VerifyOnlyCurrentAndPrevStatementsAreScanned(void)
	{
	}


/****************************************************************
 * verify that multi-line statements get scanned back 10 lines.	*
 ****************************************************************/
void CAutoPaneIDETest::VerifyMultilineStatementsGetScannedBackTenLines(void)
	{
	}


/******************************************************************************************
 * step into context of "array[i]".  only "array[i]" should show up, not "array" nor "i". *
 ******************************************************************************************/
void CAutoPaneIDETest::ScanArraySubscript(void)
	{
	LogTestHeader("ScanArraySubscript");
	EXPECT_TRUE(src.Find("array[0] = 'x';"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "char", "array[0]", "120 'x'");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/***********************************************************************************
 * step into context of "array[i + (int)*pchar]", entire expression should show    *
 * up even though casts and arithmetic operators are unsupported outside brackets. *	
 ***********************************************************************************/
void CAutoPaneIDETest::ScanCastsAndOpsInsideArraySubscript(void)
	{
	LogTestHeader("ScanCastsAndOpsInsideArraySubscript");
	EXPECT_TRUE(src.Find("array[(5 + 15) / 10 * 2 - (4 + (int)'\x00')] = '1';"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "char", "array[(5+15)/10*2-(4+(int)'\\x00')]", "49 '1'");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/*******************************************
 * step into context of "array[array[i]]". *
 *******************************************/
void CAutoPaneIDETest::ScanSelfSubscriptedArray(void)
	{
	LogTestHeader("ScanSelfSubscriptedArray");
	EXPECT_TRUE(src.Find("array[array[4]] = 'a';"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "char", "array[4]", "UNKNOWN");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "char", "array[array[4]]", "97 'a'");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
	RestoreFocusToSrcWnd();
	}


/*******************************************************************************
 * step into context of indirect access to class member variable and function. *
 *******************************************************************************/
void CAutoPaneIDETest::ScanIndirectAccessToClassVariableAndFunc(void)
	{
	LogTestHeader("ScanIndirectAccessToClassVariableAndFunc");
	EXPECT_TRUE(src.Find("pb->m_public = 0;"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], COLLAPSED, "base *", "pb", "ADDRESS");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "int", "pb->m_public", "0");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
	RestoreFocusToSrcWnd();
	}


/*****************************************************************************
 * step into context of direct access to class member variable and function. *
 *****************************************************************************/
void CAutoPaneIDETest::ScanDirectAccessToClassVariableAndFunc(void)
	{
	LogTestHeader("ScanDirectAccessToClassVariableAndFunc");
	EXPECT_TRUE(src.Find("b.m_public = 1;"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], COLLAPSED, "base", "b", "{...}");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "int", "b.m_public", "1");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
	RestoreFocusToSrcWnd();
	}


/*************************************
 * step into context of :: operator. *
 *************************************/
void CAutoPaneIDETest::ScanScopeOp(void)
	{
	LogTestHeader("ScanScopeOp");
	EXPECT_TRUE(src.Find("::global = 1;"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "::global", "1");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/*************************************************
 * step into context of address-of (&) operator. *
 *************************************************/
void CAutoPaneIDETest::ScanAddressOfOp(void)
	{
	LogTestHeader("ScanAddressOfOp");
	EXPECT_TRUE(src.Find("int *pint = &i;"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], COLLAPSED, "int *", "&i", "ADDRESS");
	FillExprInfo(expr_info_expected[1], COLLAPSED, "int *", "pint", "ADDRESS");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
	RestoreFocusToSrcWnd();
	}


/*******************************************
 * step into context of pointer to member. *
 *******************************************/
void CAutoPaneIDETest::ScanPointerToMember(void)
	{
	}


/*************************************************
 * step in mixed mode - registers not supported. *
 *************************************************/
void CAutoPaneIDETest::VerifyRegistersNotAddedInMixedMode(void)
	{
	}


/********************************************************************
 * verify that expression names cant be deleted, added, or edited.	*
 ********************************************************************/
void CAutoPaneIDETest::VerifyNamesCantBeManuallyDeletedAddedOrEdited(void)
	{
	}


/**************************************************
 * verify that no constant expressions are added. *
 **************************************************/
void CAutoPaneIDETest::VerifyConstantExpressionsNotAdded(void)
	{
	}


/********************************************
 * verify that function calls arent added.	*
 ********************************************/
void CAutoPaneIDETest::VerifyFuncCallsNotAdded(void)
	{
	}


/****************************************************************************
 * verify that the unsupported operators are not included 				    *
 * (arithmetic, casts, logical, bitwise, increment, decrement, relational).	*
 ****************************************************************************/
void CAutoPaneIDETest::VerifyUnsupportedOpsNotAdded(void)
	{
	}


/****************************************
 * step into context of no expressions.	*
 ****************************************/
void CAutoPaneIDETest::StepIntoContextOfNoExpressions(void)
	{
	LogTestHeader("StepIntoContextOfNoExpressions");
	EXPECT_TRUE(src.Find("while(0); // no expressions"));
	EXPECT_TRUE(dbg.SetNextStatement());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "", "", "");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/*************************************************